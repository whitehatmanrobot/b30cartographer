entEditor->Create(NULL, 
								   "WindowName", 
								   WS_CHILD | WS_VISIBLE, 
								   CRect( 0, 0, 800, 400 ), 
								   this, 
								   888, 
								   NULL) == 0)
	{
		return -1;
	}

	// Set the transport name
	SetTransportName();

	m_pInstrumentEditor->OnInitialUpdate(); 
	m_hAcceleratorTable = LoadAccelerators(AfxGetInstanceHandle(),MAKEINTRESOURCE(IDR_DLS_ACCELERATOR));

	// Collect the static controls in the editor
	m_pInstrumentEditor->CollectStatics();

	return 0;
}

void CInstrumentCtrl::OnSize(UINT nType, int cx, int cy) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	COleControl::OnSize(nType, cx, cy);
	
	m_pInstrumentEditor->MoveWindow( 0, 0, cx, cy );
}

void CInstrumentCtrl::OnChildActivate() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	COleControl::OnChildActivate();	
}

void CInstrumentCtrl::OnKeyDown(UINT nChar, UINT nRepCnt, UINT nFlags) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	// Give the control on the editor a chance to 
	// consume this if it wants to (like the drums checkbox) 
	if(m_pInstrumentEditor)
	{
		if(m_pInstrumentEditor->SendKeyToChildControl(nChar, nRepCnt, nFlags) == TRUE)
			return;
	}
	switch (nChar)
    {
		case 32 :  // Space bar
		{	
			if(m_nMIDINoteOns[m_nLastSpacebarNote] > 0)
				break;

			// Figure out which note we should play
			m_nLastSpacebarNote = GetSpacebarNote();

			m_pInstrument->UpdatePatch();
			m_pInstrument->m_pComponent->PlayMIDIEvent(MIDI_NOTEON,
													  BYTE(m_nLastSpacebarNote),
													  DEFAULT_VELOCITY,
													  5, // Give enough time for the UpdatePatch to apply
													  m_pInstrument->IsDrum());

			m_nMIDINoteOns[m_nLastSpacebarNote]++;
			break;
		}
			
		default:
		{
			COleControl::OnKeyDown(nChar, nRepCnt, nFlags);
			break;
		}
	}
	
	
}

void CInstrumentCtrl::OnKeyUp(UINT nChar, UINT nRepCnt, UINT nFlags) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	switch (nChar)
    {
		case 32 :  // Space bar
			while (m_nMIDINoteOns[m_nLastSpacebarNote] > 0)
			{
				m_pInstrument->m_pComponent->PlayMIDIEvent(MIDI_NOTEOFF,
														  BYTE(m_nLastSpacebarNote),
														  DEFAULT_VELOCITY,
														  0,
														  m_pInstrument->IsDrum());
				m_nMIDINoteOns[m_nLastSpacebarNote]--;
			}
			break;
		default:
			COleControl::OnKeyUp(nChar, nRepCnt, nFlags);
	}	
}

void CInstrumentCtrl::OnDestroy() 
{
	if(m_pInstrument)
	{
		ASSERT(m_pInstrument->m_pInstrumentCtrl == this);

		m_pInstrument->m_pInstrumentCtrl = NULL;		
		m_pInstrument->Release();
	}

	COleControl::OnDestroy();

	if(m_hMenuInPlace && m_nInstrumentCtrlRefCount <= 1)
	{
		::DestroyMenu(m_hMenuInPlace);
		m_hMenuInPlace = NULL;
	}
}

HMENU CInstrumentCtrl::OnGetInPlaceMenu() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	return m_hMenuInPlace;
}

void CInstrumentCtrl::OnEditRedo() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	// Remember if the instrument property page was up
	bool bInstrumentPageIsUp = m_pInstrument->IsPropertyPageShowing();

	// Turn off all the notes to prevent hanging notes
	m_pInstrumentEditor->TurnOffMidiNotes();


	CUndoMan* pUndoMgr = m_pInstrument->m_pUndoMgr;
	
	ASSERT(pUndoMgr);
	pUndoMgr->Redo(m_pInstrument);
	m_pInstrumentEditor->SetupInstrument();
	m_pInstrumentEditor->RefreshRegion();
	m_pInstrument->UpdateInstrument();
	m_pInstrument->RefreshUI(false);

	if(bInstrumentPageIsUp)
		m_pInstrument->OnShowProperties();
}

void CInstrumentCtrl::OnUpdateEditRedo(CCmdUI* pCmdUI) 
{
	char actionStr[BUFFER_64];
	CString		csMenuText,csShortCut;

	AFX_MANAGE_STATE(_afxModuleAddrThis);

	csMenuText.LoadString(IDS_REDO_MENU_TEXT);
	csShortCut.LoadString(IDS_REDO_SHORTCUT_TEXT);

	if((m_pInstrument->m_pUndoMgr)->GetRedo(actionStr, sizeof(actionStr)))
	{
		pCmdUI->Enable(TRUE);
		pCmdUI->SetText(csMenuText + _T(" ") + actionStr + csShortCut);
	}
	else
	{
		pCmdUI->Enable(FALSE);
		pCmdUI->SetText(csMenuText + csShortCut);
	}
}

void CInstrumentCtrl::OnEditUndo() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	// Remember if the instrument property page was up
	bool bInstrumentPageIsUp = m_pInstrument->IsPropertyPageShowing();

	// Turn off all the notes to prevent hanging notes
	m_pInstrumentEditor->TurnOffMidiNotes();

	CUndoMan* pUndoMgr = m_pInstrument->m_pUndoMgr;
	
	ASSERT(pUndoMgr);
	IPersistStream *pIPStream;

	m_pInstrument->QueryInterface( IID_IPersistStream, (void **) &pIPStream );
	if( pIPStream )
	{
		pUndoMgr->Undo(m_pInstrument);
		pIPStream->Release();
	}

	m_pInstrumentEditor->SetupInstrument();
	m_pInstrumentEditor->RefreshRegion();
	m_pInstrument->UpdateInstrument();
	
	CWnd* pWnd = m_pInstrumentEditor->GetFocus();
	if(m_pInstrument)
		m_pInstrument->RefreshUI(false);

	if(bInstrumentPageIsUp)
		m_pInstrument->OnShowProperties();

	if(pWnd)
		pWnd->SetFocus();
	
}

void CInstrumentCtrl::OnUpdateEditUndo(CCmdUI* pCmdUI) 
{
	char actionStr[BUFFER_64];
	CString		csMenuText,csShortCut;

	AFX_MANAGE_STATE(_afxModuleAddrThis);
	
	csMenuText.LoadString(IDS_UNDO_MENU_TEXT);
	csShortCut.LoadString(IDS_UNDO_SHORTCUT_TEXT);

	if((m_pInstrument->m_pUndoMgr)->GetUndo(actionStr, sizeof(actionStr)))
	{
		pCmdUI->Enable(TRUE);
		pCmdUI->SetText(csMenuText + _T(" ") + actionStr + csShortCut);
	}
	else 
	{
		pCmdUI->Enable(FALSE);
		pCmdUI->SetText(csMenuText + csShortCut);
	}
}

void CInstrumentCtrl::OnAppAbout() 
{
	AboutBox();
}

void CInstrumentCtrl::OnShowToolBars() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( m_pInPlaceFrame == NULL )
	{
		return;
	}

	m_pInPlaceFrame->SetActiveObject( &m_xMyOleInPlaceActiveObject, NULL );

	if( m_pInPlaceDoc != NULL )
	{
		m_pInPlaceDoc->SetActiveObject( &m_xMyOleInPlaceActiveObject, NULL );
	}
	COleControl::OnShowToolBars();
}

void CInstrumentCtrl::TurnOffMidiNotes()
{
	ASSERT(m_pInstrument);
	if(m_pInstrument == NULL)
		return;

	HRESULT hr;
	BYTE i;
	for (i = 0; i < 128; i++)
	{
		if ( m_nMIDINoteOns[i] )
		{
  			while(m_nMIDINoteOns[i] >= 0)
			{
				hr = m_pInstrument->m_pComponent->PlayMIDIEvent(MIDI_NOTEOFF,
																i,
																DEFAULT_VELOCITY,
             													0,
																m_pInstrument->IsDrum());
				m_nMIDINoteOns[i]--;
				if ( FAILED(hr) )
					break;
			}
		}
	}
}

void CInstrumentCtrl::OnChar(UINT nChar, UINT nRepCnt, UINT nFlags) 
{
		COleControl::OnChar(nChar, nRepCnt, nFlags);
}

int CInstrumentCtrl::GetSpacebarNote()
{
	// return the root note if its in a region or return the closest note to
	// it that is in a region.  This is the note that should be played
	// when the spacebar is pressed.
	ASSERT(m_pInstrumentEditor != NULL);
	ASSERT(m_pInstrument != NULL);
	
	int nNote = m_pInstrument->m_nMIDINote;

	// get begin and end notes in current region
	int nFirstNote = m_pInstrumentEditor->m_pCurRegion->m_rRgnHeader.RangeKey.usLow;
	int nLastNote = m_pInstrumentEditor->m_pCurRegion->m_rRgnHeader.RangeKey.usHigh;

	if (nNote < nFirstNote || nNote > nLastNote) {
		
		// the note is not in the current region, so find the closest note
		// to the root note that IS in the current region
		if (abs(nNote - nFirstNote) > abs(nNote - nLastNote)) {

			nNote = nLastNote;
		}
		else {

			nNote = nFirstNote;
		}
	}

	return nNote;
}

void CInstrumentCtrl::OnHelpFinder() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

    // Determine name of DMUSProd.exe help file
	CString strHelpFileName;

	if( theApp.GetHelpFileName( strHelpFileName ) )
	{
		strHelpFileName += "::/htm/directmusicproducer.htm";
		::HtmlHelp( NULL, strHelpFileName, HH_DISPLAY_TOPIC, 0 );
	}
}

void CInstrumentCtrl::SetTransportName()
{
	ASSERT(m_pInstrument);
	if(m_pInstrument == NULL)
		return;
	ASSERT(m_pInstrument->m_pComponent);
	if(m_pInstrument->m_pComponent == NULL)
		return;
	if(m_pInstrument->m_pComponent->m_pIConductor == NULL)
		return;

	// The actual transport name is collection:wavename
	m_pInstrument->GetName();
	CString sWaveName = m_pInstrument->m_csName;
	if(sWaveName.IsEmpty())
		sWaveName.LoadString(IDS_INSTRUMENT_TEXT);

	CString sCollectionName = m_pInstrument->m_pCollection->m_Info.m_csName;
	CString sTransportName = sCollectionName + ":" + sWaveName;

	// Set the name for the transport
	BSTR bstrWaveName = sTransportName.AllocSysString();
	m_pInstrument->m_pComponent->m_pIConductor->SetTransportName(m_pInstrument, bstrWaveName);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\DLSDesigner\Instrument.h ===
#ifndef __INSTRUMENT_H__
#define __INSTRUMENT_H__

// Instrument.h : header file
//

#include "DLSComponent.h"
#include "DLSDocType.h"
#include "RiffStrm.h"
#include "Info.h"
#include "alist.h"
#include "InstrumentRegions.h"
#include "DLSLoadSaveUtils.h"
#include "UnknownChunk.h"

class CInstrumentPropPgMgr;
class Collection;
class CUndoMan;
class AllocatedPortBufferPair;
class CArticulationList;

struct StopResetTimeEvent
{
	long		 lWaitTime;		// Length of the one shot wave in milliseconds
	CInstrument* pInstrument;	// Instrument playing
};

class CInstrument : public AListItem, public IDMUSProdNode, public IPersistStream, public IDMUSProdPropPageObject, public IDMUSProdTransport
{
friend class CDLSComponent;
friend class CCollection;
friend class CRegion;
friend class CArticulation;
friend class CWave;
friend class CMonoWave;
friend class CStereoWave;
friend class CWaveCtrl;
friend class CInstrumentRegions;
friend class CCollectionInstruments;
friend class CCollectionWaves;
friend class CInstrumentCtrl;
friend class CInstrumentFVEditor;
friend class CInstrumentPropPgMgr;
friend class CInstrumentPropPg;
friend class CWavePropPg;
friend class CCollectionRef;
friend class CPatchConflictDlg;
friend class CUserPatchConflictDlg;
public:
    CInstrument(CDLSComponent* pComponent);
	~CInstrument();
    CInstrument * GetNext() {return(CInstrument *)AListItem::GetNext();};

    // IUnknown functions
    HRESULT STDMETHODCALLTYPE QueryInterface( REFIID riid, LPVOID *ppv );
    ULONG STDMETHODCALLTYPE AddRef();
    ULONG STDMETHODCALLTYPE Release();

    // IDMUSProdNode functions
	HRESULT STDMETHODCALLTYPE GetNodeImageIndex( short* pnNbrFirstImage );
    HRESULT STDMETHODCALLTYPE GetComponent( IDMUSProdComponent** ppIComponent );
    
	HRESULT STDMETHODCALLTYPE GetDocRootNode( IDMUSProdNode** ppIDocRootNode );
    HRESULT STDMETHODCALLTYPE SetDocRootNode( IDMUSProdNode* pIDocRootNode );
    HRESULT STDMETHODCALLTYPE GetParentNode( IDMUSProdNode** ppIParentNode );
    HRESULT STDMETHODCALLTYPE SetParentNode( IDMUSProdNode* pIParentNode );
    
	HRESULT STDMETHODCALLTYPE GetNodeId( GUID* pguid );

    HRESULT STDMETHODCALLTYPE GetNodeName( BSTR* pbstrName );
    HRESULT STDMETHODCALLTYPE GetNodeNameMaxLength( short* pnMaxLength );
    HRESULT STDMETHODCALLTYPE ValidateNodeName( BSTR bstrName );
    HRESULT STDMETHODCALLTYPE SetNodeName( BSTR bstrName );

    HRESULT STDMETHODCALLTYPE GetEditorClsId( CLSID* pclsid );
    HRESULT STDMETHODCALLTYPE GetEditorTitle( BSTR* pbstrTitle );
    HRESULT STDMETHODCALLTYPE GetEditorWindow( HWND* hWndEditor );
    HRESULT STDMETHODCALLTYPE SetEditorWindow( HWND hWndEditor );

	HRESULT STDMETHODCALLTYPE UseOpenCloseImages( BOOL* pfUseOpenCloseImages );

    HRESULT STDMETHODCALLTYPE GetRightClickMenuId(HINSTANCE* phInstance, UINT* pnResourceId);
    HRESULT STDMETHODCALLTYPE OnRightClickMenuInit(HMENU hMenu);
    HRESULT STDMETHODCALLTYPE OnRightClickMenuSelect(long lCommandId);

    HRESULT STDMETHODCALLTYPE DeleteChildNode( IDMUSProdNode* pIChildNode, BOOL fPromptUser );
    HRESULT STDMETHODCALLTYPE InsertChildNode( IDMUSProdNode* pIChildNode );
    HRESULT STDMETHODCALLTYPE DeleteNode( BOOL fPromptUser );

	HRESULT STDMETHODCALLTYPE GetFirstChild(IDMUSProdNode** ppIFirstChildNode);
	HRESULT STDMETHODCALLTYPE GetNextChild(IDMUSProdNode* pIChildNode, IDMUSProdNode** ppINextChildNode);
	HRESULT STDMETHODCALLTYPE GetNodeListInfo(DMUSProdListInfo* pListInfo);

	HRESULT STDMETHODCALLTYPE OnNodeSelChanged( BOOL fSelected );
    // IDMUSProdNode : drag & drop methods
	HRESULT STDMETHODCALLTYPE CreateDataObject( IDataObject** ppIDataObject );
	HRESULT STDMETHODCALLTYPE CanCut();
	HRESULT STDMETHODCALLTYPE CanCopy();
	HRESULT STDMETHODCALLTYPE CanDelete();
	HRESULT STDMETHODCALLTYPE CanDeleteChildNode( IDMUSProdNode* pIChildNode );
	HRESULT STDMETHODCALLTYPE CanPasteFromData( IDataObject* pIDataObject, BOOL* pfWillSetReference );
	HRESULT STDMETHODCALLTYPE PasteFromData( IDataObject* pIDataObject );
	HRESULT STDMETHODCALLTYPE CanChildPasteFromData( IDataObject* pIDataObject, IDMUSProdNode* pIChildNode, BOOL* pfWillSetReference );
	HRESULT STDMETHODCALLTYPE ChildPasteFromData( IDataObject* pIDataObject, IDMUSProdNode* pIChildNode );

	HRESULT STDMETHODCALLTYPE GetObject( REFCLSID rclsid, REFIID riid, void** ppvObject );

    // IPersist functions
    STDMETHOD(GetClassID)(CLSID* pClsId);

    // IPersistStream functions
    STDMETHOD(IsDirty)();
    STDMETHOD(Load)(IStream* pIStream);
    STDMETHOD(Save)(IStream* pIStream, BOOL fClearDirty);
    STDMETHOD(GetSizeMax)( ULARGE_INTEGER FAR* pcbSize );

	// IDMUSProdPropPageObject functions
    HRESULT STDMETHODCALLTYPE GetData(void** ppData);
    HRESULT STDMETHODCALLTYPE SetData(void* pData);
	HRESULT STDMETHODCALLTYPE OnRemoveFromPageManager();
	HRESULT STDMETHODCALLTYPE OnShowProperties();

    //IDMUSProdTransport functions
	STDMETHOD(Play)(BOOL /*fPlayFromStart*/);
	STDMETHOD(Stop)(BOOL /*fStopImmediate*/);  
    STDMETHOD(Transition)( );
	STDMETHOD(Record)(BOOL fPressed);
	STDMETHOD(GetName)(BSTR* pbstrName);
	STDMETHOD(TrackCursor)(BOOL fTrackCursor);


	//Additional functions
	void			UpdatePatch();
	bool			ValidatePatch();
	BOOL			VerifyDLS();
	HRESULT			CheckForOverlappedRegions();
	CRegion*		GetRegion(int nNote);
	DWORD			GetDLS1RegionCount();

    CCollection *	GetParentCollection() {return(m_pCollection);}
	HRESULT			Load(IDMUSProdRIFFStream* pIRiffStream, MMCKINFO* pckMain);
	HRESULT			UpdateInstrument();
	void			GetName();
	void			GetName(CString& sName);
	void			TurnOffMidiNotes();
	bool			IsDrum() { return (m_rInstHeader.Locale.ulBank & F_INSTRUMENT_DRUMS) != 0; }
	
	HRESULT			OnViewProperties();
	void			RefreshUI(bool bWaveDataChanged);
	void			RefreshRegion();
	
	HRESULT			SaveStateForUndo(UINT uUndoTextID);
	void			PopUndoState();
	
	BOOL			SupportsNewFormat();
	
	CInstrumentFVEditor*	GetInstrumentEditor();
	CInstrumentRegions*		GetRegions();

	void			SetFirstGlobaArtAsCurrent();
	void			SetCurrentArticulation(CArticulation* pArticulation);
	CArticulation*	GetCurrentArticulation();
	UINT			GetArticulationCount();							// Goes throung all the lists os articulations and returns the number of global articulations
	void			CheckRegionsForLocalArts();
	BOOL			NoArtForEveryRegion();

	HRESULT			GetListOfConditions(CPtrList* pConditionList);
	CCollection*	GetCollection();

	bool			GetAuditionMode();
	void			SetAuditionMode(bool bAuditionMode);

protected:
	HRESULT Download(IDirectMusicPortDownload* pIDMPortDownLoad);
	HRESULT Unload(IDirectMusicPortDownload* pIDMPortDownLoad);
	HRESULT DM_Init(IDirectMusicPortDownload* pIDMPortDownLoad);
    HRESULT GetDMIDForPort(IDirectMusicPortDownload* pIDMDownloadPort, DWORD* pdwDMID);
	HRESULT Size(DWORD& dwSize);
	HRESULT Write(void* pvoid, IDirectMusicPortDownload* pIDMPortDownLoad);
	HRESULT Save(IDMUSProdRIFFStream* pIRiffStream, bool fFullSave);
	
	bool	SaveString(IStream* pIStream, CString sData);
	bool	LoadString(IStream* pIStream, CString& sData);

private:
	GCENT	GetMaxVolume();
	bool	IsPropertyPageShowing();
	
	AllocatedPortBufferPair* GetAllocatedBufferForPort(IDirectMusicPortDownload* pIDMPortDownLoad); // Gets the buffer allocated (in DM_Init) for this port
	void	RemoveFromAllocatedBufferList(AllocatedPortBufferPair* pAllocatedBuffer);
	void	CreateDefaultGlobalArticulation();	// Creates a deafulat list of global articulations
	void	DeleteAllRegions();			// Removes all regions from the instrument
	void	DeleteArticulationLists();	// Removes all global articulations lists

	void	OnConditionConfigChanged(CSystemConfiguration* pCurrentConfig, bool bRefreshNode = true);	

	HRESULT	UpdateForAuditionMode();

public:
	CDLSComponent*				m_pComponent;

	CTypedPtrList<CPtrList, AllocatedPortBufferPair*> m_lstAllocatedBuffers; // List of allocated buffers to be unloaded
	
    WORD						m_nMIDINote;
	CCollection*				m_pCollection;		// Parent collection.
	CInstrumentCtrl*			m_pInstrumentCtrl;	// When instrument is displayed within a control this is set 
    CUnknownChunk				m_UnknownChunk;
	HANDLE						m_hStopEvent;
	CUndoMan*					m_pUndoMgr;

private:

	DWORD m_dwDLSize;
	BOOL						m_bNewFormat;
	bool						m_bAuditionMode;	// Audition mode can be solo layer or multiple layer
	int							m_cMidiNoteOns[128];
	CInstrumentRegions			m_Regions;			// List of regions.
    CInfo						m_Info;				// Info chunk.
	INSTHEADER					m_rInstHeader;		// DLS instrument chunk.
	
	CString						m_csName;			// Display name. Generated by GetName() method.

	DWORD						m_dwId;				//DownLoad ID (obtained from DM)
	DWORD						m_cbSizeOffsetTable;
	DWORD						m_dwRef;
	IDMUSProdNode*				m_pIRootNode;
	IDMUSProdNode*				m_pIParentNode;
	HWND						m_hWndEditor;

	StopResetTimeEvent			m_ResetCallBackParams;

	CInstrumentPropPgMgr*		m_pInstrumentPropPgMgr;

	CArticulation*				m_pCurArticulation;
	CTypedPtrList<CPtrList, CArticulationList*> m_lstArticulationLists;	// List of artiulation lists

	GUID						m_guidUndoStream;
};

#endif // __INSTRUMENT_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\DLSDesigner\InstrumentPropPg.cpp ===
//
// InstrumentPropPg.cpp : implementation file
//

#include "stdafx.h"
#include "Instrument.h"
#include "InstrumentPropPg.h"
#include "Collection.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CInstrumentPropPg property page

IMPLEMENT_DYNCREATE(CInstrumentPropPg, CPropertyPage)

CInstrumentPropPg::CInstrumentPropPg() : CPropertyPage(CInstrumentPropPg::IDD), m_pInstrument(NULL), m_bSaveUndoState(true)
{
	//{{AFX_DATA_INIT(CInstrumentPropPg)
	m_csComment = _T("");
	m_csCopyright = _T("");
	m_csEngineer = _T("");
	m_csSubject = _T("");
	m_csName = _T("");
	//}}AFX_DATA_INIT

	m_fNeedToDetach = FALSE;
}

CInstrumentPropPg::~CInstrumentPropPg()
{
}

void CInstrumentPropPg::SetObject(CInstrument* pInstrument) 
{
	m_pInstrument = pInstrument;
}

/////////////////////////////////////////////////////////////////////////////
// CInstrumentPropPg::EnableControls

void CInstrumentPropPg::EnableControls(BOOL fEnable) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	
	CWnd * pCtrl = GetDlgItem(IDC_NAME);
	if(pCtrl)
	{
		pCtrl->EnableWindow(fEnable);
		pCtrl = NULL;
	}

	pCtrl = GetDlgItem(IDC_SUBJECT);
	if(pCtrl)
	{
		pCtrl->EnableWindow(fEnable);
		pCtrl = NULL;
	}

	pCtrl = GetDlgItem(IDC_ENGINEER);
	if(pCtrl)
	{
		pCtrl->EnableWindow(fEnable);
		pCtrl = NULL;
	}

	pCtrl = GetDlgItem(IDC_COPYRIGHT);
	if(pCtrl)
	{
		pCtrl->EnableWindow(fEnable);
		pCtrl = NULL;
	}

	pCtrl = GetDlgItem(IDC_COMMENT);
	if(pCtrl)
	{
		pCtrl->EnableWindow(fEnable);
		pCtrl = NULL;
	}
}

void CInstrumentPropPg::DoDataExchange(CDataExchange* pDX)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	CPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CInstrumentPropPg)
	DDX_Text(pDX, IDC_COMMENT, m_csComment);
	DDX_Text(pDX, IDC_COPYRIGHT, m_csCopyright);
	DDX_Text(pDX, IDC_ENGINEER, m_csEngineer);
	DDX_Text(pDX, IDC_SUBJECT, m_csSubject);
	DDX_Text(pDX, IDC_NAME, m_csName);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CInstrumentPropPg, CPropertyPage)
	//{{AFX_MSG_MAP(CInstrumentPropPg)
	ON_EN_CHANGE(IDC_COMMENT, OnChangeComment)
	ON_EN_CHANGE(IDC_COPYRIGHT, OnChangeCopyright)
	ON_EN_CHANGE(IDC_ENGINEER, OnChangeEngineer)
	ON_EN_CHANGE(IDC_NAME, OnChangeName)
	ON_EN_CHANGE(IDC_SUBJECT, OnChangeSubject)
	ON_WM_CREATE()
	ON_WM_DESTROY()
	ON_EN_KILLFOCUS(IDC_NAME, OnKillfocusEdits)
	ON_EN_KILLFOCUS(IDC_COMMENT, OnKillfocusEdits)
	ON_EN_KILLFOCUS(IDC_COPYRIGHT, OnKillfocusEdits)
	ON_EN_KILLFOCUS(IDC_ENGINEER, OnKillfocusEdits)
	ON_EN_KILLFOCUS(IDC_SUBJECT, OnKillfocusEdits)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CInstrumentPropPg message handlers

void CInstrumentPropPg::OnChangeComment() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	ASSERT(m_pInstrument);

	BOOL bUpdate;
	bUpdate = UpdateData(TRUE);	

	if(bUpdate)
	{		
		if(m_pInstrument->m_Info.m_csComment != m_csComment)
		{
			if(m_bSaveUndoState)
			{
				m_bSaveUndoState = false;
				if(FAILED(m_pInstrument->SaveStateForUndo(IDS_UNDO_COMMENT)))
				{
					m_csComment = m_pInstrument->m_Info.m_csComment;
					UpdateData(FALSE);
					return;
				}
			}

			m_pInstrument->m_Info.m_csComment = m_csComment;
			m_pInstrument->m_pCollection->SetDirtyFlag();
		}
	}
}

void CInstrumentPropPg::OnChangeCopyright() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	ASSERT(m_pInstrument);

	BOOL bUpdate;
	bUpdate = UpdateData(TRUE);	

	if(bUpdate)
	{		
		if(m_pInstrument->m_Info.m_csCopyright != m_csCopyright)
		{
			if(m_bSaveUndoState)
			{
				m_bSaveUndoState = false;
				if(FAILED(m_pInstrument->SaveStateForUndo(IDS_UNDO_COPYRIGHT)))
				{
					m_csCopyright = m_pInstrument->m_Info.m_csCopyright; 
					UpdateData(FALSE);
					return;
				}
			}

			m_pInstrument->m_Info.m_csCopyright = m_csCopyright;
			m_pInstrument->m_pCollection->SetDirtyFlag();
		}
	}
}

void CInstrumentPropPg::OnChangeEngineer() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	ASSERT(m_pInstrument);

	BOOL bUpdate;
	bUpdate = UpdateData(TRUE);	

	if(bUpdate)
	{		
		if(m_pInstrument->m_Info.m_csEngineer != m_csEngineer)
		{
			if(m_bSaveUndoState)
			{
				m_bSaveUndoState = false;
				if(FAILED(m_pInstrument->SaveStateForUndo(IDS_UNDO_ENGINEER)))
				{
					m_csEngineer = m_pInstrument->m_Info.m_csEngineer;
					UpdateData(FALSE);
					return;
				}
			}

			m_pInstrument->m_Info.m_csEngineer = m_csEngineer;
			m_pInstrument->m_pCollection->SetDirtyFlag();
		}
	}
}

void CInstrumentPropPg::OnChangeName() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT(m_pInstrument);

	BOOL bUpdate;
	bUpdate = UpdateData(TRUE);	

	if(bUpdate)
	{		
		// Remove the colons from the name string
		if(m_csName.Remove(TCHAR(':')))
		{
			UpdateData(FALSE);
			CEdit* pEdit = (CEdit*)GetDlgItem(IDC_NAME);
			if(pEdit)
			{
				int nLineLength = pEdit->LineLength();
				pEdit->SetSel(nLineLength, -1, TRUE);
			}
		}

		if(m_pInstrument->m_Info.m_csName != m_csName)
		{
			if(m_bSaveUndoState)
			{
				m_bSaveUndoState = false;
				if(FAILED(m_pInstrument->SaveStateForUndo(IDS_UNDO_NAME)))
				{
					m_csName = m_pInstrument->m_Info.m_csName;
					UpdateData(FALSE);
					return;
				}
			}

			m_pInstrument->m_Info.m_csName = m_csName;
		
			BSTR bstrName = m_pInstrument->m_Info.m_csName.AllocSysString();
			m_pInstrument->SetNodeName(bstrName);
			m_pInstrument->m_pComponent->m_pIFramework->RefreshNode(m_pInstrument);
			m_pInstrument->m_pComponent->m_pIFramework->NotifyNodes(m_pInstrument->m_pCollection, INSTRUMENT_NameChange, NULL);
			m_pInstrument->m_pCollection->SetDirtyFlag();


		}
	}
}

void CInstrumentPropPg::OnChangeSubject() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	ASSERT(m_pInstrument);

	BOOL bUpdate;
	bUpdate = UpdateData(TRUE);	

	if(bUpdate)
	{		
		if(m_pInstrument->m_Info.m_csSubject != m_csSubject)
		{
			if(m_bSaveUndoState)
			{
				m_bSaveUndoState = false;
				if(FAILED(m_pInstrument->SaveStateForUndo(IDS_UNDO_SUBJECT)))
				{
					m_csSubject = m_pInstrument->m_Info.m_csSubject;
					UpdateData(FALSE);
					return;
				}
			}
			m_pInstrument->m_Info.m_csSubject = m_csSubject;
			m_pInstrument->m_pCollection->SetDirtyFlag();
		}
	}

}

BOOL CInstrumentPropPg::OnSetActive() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	// Check if we're a good valid window yet....
	if(::IsWindow(m_hWnd) == FALSE)
		return FALSE;

	if(m_pInstrument == NULL)
	{
		EnableControls(FALSE);
		return CPropertyPage::OnSetActive();
	}
	
	EnableControls(TRUE);
	
	m_csName = m_pInstrument->m_Info.m_csName;
	int nSeparatorIndex  = m_csName.Find(_T(":"));
	if(nSeparatorIndex != -1)
		m_csName = m_csName.Left(nSeparatorIndex);

	m_csCopyright = m_pInstrument->m_Info.m_csCopyright;
	m_csEngineer = m_pInstrument->m_Info.m_csEngineer;
	m_csSubject = m_pInstrument->m_Info.m_csSubject;
	m_csComment = m_pInstrument->m_Info.m_csComment;
	
	return CPropertyPage::OnSetActive();
}

int CInstrumentPropPg::OnCreate(LPCREATESTRUCT lpCreateStruct) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	// Attach the window to the property page structure.
	// This has been done once already in the main application
	// since the main application owns the property sheet.
	// It needs to be done here so that the window handle can
	// be found in the DLLs handle map.
	if(!FromHandlePermanent(m_hWnd))
	{
		HWND hWnd = m_hWnd;
		m_hWnd = NULL;
		Attach( hWnd );

		m_fNeedToDetach = TRUE;
	}
	if (CPropertyPage::OnCreate(lpCreateStruct) == -1)
		return -1;
	
	return 0;
}

void CInstrumentPropPg::OnDestroy() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	// Detach the window from the property page structure.
	// This will be done again by the main application since
	// it owns the property sheet.  It needs o be done here
	// so that the window handle can be removed from the
	// DLLs handle map.
	if( m_fNeedToDetach && m_hWnd != NULL )
	{
		HWND hWnd = m_hWnd;
		Detach();
		m_hWnd = hWnd;
	}

	CPropertyPage::OnDestroy();
}

void CInstrumentPropPg::OnKillfocusEdits() 
{
	m_bSaveUndoState = true;
}

BOOL CInstrumentPropPg::OnInitDialog() 
{
	CPropertyPage::OnInitDialog();
	
	CWnd* pCtrl = GetDlgItem(IDC_COMMENT);
	if(pCtrl)
		((CEdit*)pCtrl)->SetLimitText(COMMENT_TEXT_LIMIT);
	
	return FALSE;  // return TRUE unless you set the focus to a control
	               // EXCEPTION: OCX Property Pages should return FALSE
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\DLSDesigner\InstrumentCtl.h ===
#if !defined(AFX_INSTRUMENTCTL_H__BC964EA9_96F7_11D0_89AA_00A0C9054129__INCLUDED_)
#define AFX_INSTRUMENTCTL_H__BC964EA9_96F7_11D0_89AA_00A0C9054129__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include <DMUSProd.h>
class CInstrumentFVEditor;
class CInstrument;

// InstrumentCtl.h : Declaration of the CInstrumentCtrl ActiveX Control class.

/////////////////////////////////////////////////////////////////////////////
// CInstrumentCtrl : See InstrumentCtl.cpp for implementation.

class CInstrumentCtrl : public COleControl
{
friend class CInstrumentFVEditor;
friend class CArticulation;
friend class CRegion;
friend class CInstrumentRegions;
friend class CDLSEdit;
	DECLARE_DYNCREATE(CInstrumentCtrl)

// Constructor
public:
	CInstrumentCtrl();

// Attributes
public:
	CInstrument*	GetInstrument() {return(m_pInstrument);}
	void			TurnOffMidiNotes();
	void			SetTransportName();

private:
	HACCEL					m_hAcceleratorTable;
	int						m_nMIDINoteOns[128];
	static int				m_nInstrumentCtrlRefCount;
	static HMENU			m_hMenuInPlace;
	//CToolBar*				m_pToolBar;
	CInstrument*			m_pInstrument;
	IDMUSProdNode*			m_pAttachedNode;
protected:
	int						GetSpacebarNote();
	int						m_nLastSpacebarNote;


public:
	CInstrumentFVEditor*	m_pInstrumentEditor;

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CInstrumentCtrl)
	public:
	virtual BOOL PreTranslateMessage( MSG* pMsg );
	virtual void OnDraw(CDC* pdc, const CRect& rcBounds, const CRect& rcInvalid);
	virtual void DoPropExchange(CPropExchange* pPX);
	virtual void OnResetState();
	virtual HMENU OnGetInPlaceMenu();
	virtual void OnShowToolBars();
	//}}AFX_VIRTUAL

// Implementation
protected:
	~CInstrumentCtrl();

	DECLARE_OLECREATE_EX(CInstrumentCtrl)    // Class factory and guid
	DECLARE_OLETYPELIB(CInstrumentCtrl)      // GetTypeInfo
	//DECLARE_PROPPAGEIDS(CInstrumentCtrl)     // Property page IDs
	DECLARE_OLECTLTYPE(CInstrumentCtrl)		// Type name and misc status

// Message maps
	//{{AFX_MSG(CInstrumentCtrl)
	afx_msg void AboutBox();
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	afx_msg void OnSize(UINT nType, int cx, int cy);
	afx_msg void OnChildActivate();
	afx_msg void OnKeyDown(UINT nChar, UINT nRepCnt, UINT nFlags);
	afx_msg void OnKeyUp(UINT nChar, UINT nRepCnt, UINT nFlags);
	afx_msg void OnDestroy();
	afx_msg void OnEditRedo();
	afx_msg void OnUpdateEditRedo(CCmdUI* pCmdUI);
	afx_msg void OnEditUndo();
	afx_msg void OnUpdateEditUndo(CCmdUI* pCmdUI);
	afx_msg void OnAppAbout();
	afx_msg void OnChar(UINT nChar, UINT nRepCnt, UINT nFlags);
	afx_msg void OnHelpFinder();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

// Dispatch maps
	//{{AFX_DISPATCH(CInstrumentCtrl)
		// NOTE - ClassWizard will add and remove member functions here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_DISPATCH
	DECLARE_DISPATCH_MAP()


// Event maps
	//{{AFX_EVENT(CInstrumentCtrl)
		// NOTE - ClassWizard will add and remove member functions here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_EVENT
	DECLARE_EVENT_MAP()

// Interface Maps
public:
	// IOleInPlaceActiveObject
	BEGIN_INTERFACE_PART(MyOleInPlaceActiveObject, IOleInPlaceActiveObject)
		INIT_INTERFACE_PART(CInstrumentCtl, MyOleInPlaceActiveObject)
		STDMETHOD(GetWindow)(HWND*);
		STDMETHOD(ContextSensitiveHelp)(BOOL);
		STDMETHOD(TranslateAccelerator)(LPMSG);
		STDMETHOD(OnFrameWindowActivate)(BOOL);
		STDMETHOD(OnDocWindowActivate)(BOOL);
		STDMETHOD(ResizeBorder)(LPCRECT, LPOLEINPLACEUIWINDOW, BOOL);
		STDMETHOD(EnableModeless)(BOOL);
	END_INTERFACE_PART(MyOleInPlaceActiveObject)

    // IDMUSProdEditor functions
	BEGIN_INTERFACE_PART(Editor, IDMUSProdEditor)
		STDMETHOD(AttachObjects)(IDMUSProdNode*);
		STDMETHOD(OnInitMenuFilePrint)(HMENU, UINT);
		STDMETHOD(OnInitMenuFilePrintPreview)(HMENU, UINT);
		STDMETHOD(OnFilePrint)();
		STDMETHOD(OnFilePrintPreview)();
		STDMETHOD(OnViewProperties)();
		STDMETHOD(OnF1Help)();
	END_INTERFACE_PART(Editor)

	DECLARE_INTERFACE_MAP()

	enum {
	//{{AFX_DISP_ID(CInstrumentCtrl)
		// NOTE: ClassWizard will add and remove enumeration elements here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_DISP_ID
	};
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_INSTRUMENTCTL_H__BC964EA9_96F7_11D0_89AA_00A0C9054129__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\DLSDesigner\InstrumentPropPg.h ===
#if !defined(AFX_INSTRUMENTPROPPG_H__8C0AA7C5_E6FC_11D0_876A_00AA00C08146__INCLUDED_)
#define AFX_INSTRUMENTPROPPG_H__8C0AA7C5_E6FC_11D0_876A_00AA00C08146__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

//
// InstrumentPropPg.h : header file
//

#include "resource.h"

const int COMMENT_TEXT_LIMIT = 1024;

class CInstrument;

/////////////////////////////////////////////////////////////////////////////
// CInstrumentPropPg dialog

class CInstrumentPropPg : public CPropertyPage
{
	DECLARE_DYNCREATE(CInstrumentPropPg)

// Construction
public:
	CInstrumentPropPg();
	~CInstrumentPropPg();

	void SetObject(CInstrument* pInstrument);

	void EnableControls(BOOL fEnable);

// Dialog Data
	//{{AFX_DATA(CInstrumentPropPg)
	enum { IDD = IDD_INSTRUMENT_PROP_PAGE };
	CString	m_csComment;
	CString	m_csCopyright;
	CString	m_csEngineer;
	CString	m_csSubject;
	CString	m_csName;
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CInstrumentPropPg)
	public:
	virtual BOOL OnSetActive();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CInstrumentPropPg)
	afx_msg void OnChangeComment();
	afx_msg void OnChangeCopyright();
	afx_msg void OnChangeEngineer();
	afx_msg void OnChangeName();
	afx_msg void OnChangeSubject();
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	afx_msg void OnDestroy();
	afx_msg void OnKillfocusEdits();
	virtual BOOL OnInitDialog();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

private:
	CInstrument* m_pInstrument;
	
	BOOL	m_fNeedToDetach;
	bool	m_bSaveUndoState;
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_INSTRUMENTPROPPG_H__8C0AA7C5_E6FC_11D0_876A_00AA00C08146__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\DLSDesigner\InstrumentFVEditor.h ===
//{{AFX_INCLUDES()
#include "regionkeyboard.h"
//}}AFX_INCLUDES
#if !defined(AFX_INSTRUMENTFVEDITOR_H__8C0AA7C7_E6FC_11D0_876A_00AA00C08146__INCLUDED_)
#define AFX_INSTRUMENTFVEDITOR_H__8C0AA7C7_E6FC_11D0_876A_00AA00C08146__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// InstrumentFVEditor.h : header file
//

#include "resource.h"
#include "myslider.h"
#include "Conductor.h"
#include "RegionNote.h"

#define CF_DLS_ARTICULATION "DLS Articulation"
#define CF_DLS_REGION "DLS Region"

class CDLSStatic;

/////////////////////////////////////////////////////////////////////////////
// CInstrumentFVEditor form view

#ifndef __AFXEXT_H__
#include <afxext.h>
#endif


#define DM_VALIDATE			(WM_USER + 1000)
#define DM_BRINGTOTOP		(DM_VALIDATE + 1)
#define DM_UPDATE_VALUES	(DM_BRINGTOTOP + 1)
#define	DM_REGION_SELECT	(DM_UPDATE_VALUES + 1)

#define AUDITION_SOLO		0
#define AUDITION_MULTIPLE	1

class CCollection;
class CCollectionWaves;
class CArticulation;
class CInstrument;
class CRegion;
class CWave;
class CInstrumentCtrl;
class CLFODialog;
class CPitchDialog;
class CVolDialog;
class CDLSEdit;

class CInstrumentFVEditor : public CFormView, public IPersistStream, public IDMUSProdMidiInCPt
{
friend class CArticulation;
friend class CRegion;
friend class CInstrument;
friend class CInstrumentCtrl;
friend class CInstrumentRegions;
friend class CLFODialog;
friend class CVibratoLFODialog;
friend class CPitchDialog;
friend class CVolDialog;
friend class CFilterDialog;

protected:
	CInstrumentFVEditor(CInstrumentCtrl *parent = NULL);	// protected constructor used by dynamic creation
	DECLARE_DYNCREATE(CInstrumentFVEditor)

// Form Data
public:
	//{{AFX_DATA(CInstrumentFVEditor)
	enum { IDD = IDD_INSTRUMENT };
	CButton	m_SoloLayerButton;
	CButton	m_FilterButton;
	CButton	m_VibLFOButton;
	CButton	m_ArtDLS1Check;
	CComboBox	m_RegionConditionCombo;
	CScrollBar	m_LayerScrollBar;
	CSpinButtonCtrl	m_ClickVelocitySpin;
	CEdit	m_ClickVelocityEdit;
	CSpinButtonCtrl	m_VelocityHighRangeSpin;
	CSpinButtonCtrl	m_VelocityLowRangeSpin;
	CEdit	m_VelocityHighRangeEdit;
	CEdit	m_VelocityLowRangeEdit;
	CButton	m_VolumeButton;
	CButton	m_LFOButton;
	CButton	m_PitchButton;
	CEdit	m_RootNoteEdit;
	CEdit	m_HighRangeEdit;
	CEdit	m_LowRangeEdit;
	CSpinButtonCtrl	m_ThruSpin;
	CSpinButtonCtrl	m_RangeSpin;
	CSpinButtonCtrl	m_RootNoteSpin;
	CSpinButtonCtrl	m_PatchSpin;
	CSpinButtonCtrl	m_MSBSpin;
	CSpinButtonCtrl	m_LSBSpin;
	UINT	m_wBank;
	UINT	m_wBank2;
	UINT	m_wPatch;
	BOOL	m_fIsDrumKit;
	CRegionKeyboard	m_RegionKeyBoard;
	BOOL	m_fAllowOverlap;
	BOOL	m_fUseInstArt;
	//}}AFX_DATA
	CDLSEdit*	m_pCDLSEditUpperRange;
	CDLSEdit*	m_pCDLSEditLowerRange;
	CDLSEdit*	m_pCDLSEditRootNote;
	CDLSEdit*	m_pCDLSEditMSB;
	CDLSEdit*	m_pCDLSEditLSB;
	CDLSEdit*	m_pCDLSEditPatch;
// Attributes
public:

// Operations
public:

    // IUnknown functions
    HRESULT STDMETHODCALLTYPE QueryInterface( REFIID riid, LPVOID *ppv );
    ULONG STDMETHODCALLTYPE AddRef();
    ULONG STDMETHODCALLTYPE Release();

	// IDMUSProdMidiInCPt functions
	HRESULT STDMETHODCALLTYPE OnMidiMsg(REFERENCE_TIME dwTime, 
										BYTE bStatus, 
										BYTE bData1, 
										BYTE bData2);

    // IPersist functions
    STDMETHOD(GetClassID)(CLSID* pClsId);

    // IPersistStream functions
    STDMETHOD(IsDirty)();
    STDMETHOD(Load)( IStream* pIStream );
    STDMETHOD(Save)( IStream* pIStream, BOOL fClearDirty );
    STDMETHOD(GetSizeMax)( ULARGE_INTEGER FAR* pcbSize );

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CInstrumentFVEditor)
	public:
	virtual void OnInitialUpdate();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	virtual void OnDraw(CDC* pDC);
	//}}AFX_VIRTUAL


// Implementation
protected:
	virtual ~CInstrumentFVEditor();
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

public:
	void RegisterMidi();
	void UnRegisterMidi();
	bool IsMidiRegistered();
	void RegionWaveChanged();
	void DeleteAndSetupWavesForCurrentRegion();
	void TurnOffMidiNotes();
	void UpdateRootNote(int nRootNote);
	void UpdateNoteRange(DWORD dwLowRange, DWORD dwHighRange, bool bSettingLowRange);
	void UpdateVelocityRange(DWORD dwLowRange, DWORD dwHighRange, bool bSettingLowRange);
	BOOL SendKeyToChildControl(UINT nChar, UINT nRepCnt, UINT nFlags);

	USHORT GetActiveLayer();
	CRegion* FindConflictingDLS1Region(USHORT usStartNote, USHORT usEndNote);

	CWnd* GetRegionKeyboardWnd();

private:
	/* adds the given wave as an entry in the region wavelink dropdown */
	void AddWaveToWaveLinkDropdown(CComboBox *pCombo, CWave *pWave);

	void SetupInstrument();
	void SetupRegion();
	void SetupArticulation();
	void CleanupArticluation();
	void SetCurRegion(CRegion* pRegion);
	void SetCurArticulation(CArticulation* pArticulation);
	void InitRegionConditionsCombo(CRegion* pRegion);
	void RefreshRegion();
	void SetRKBMap();
	CRegion* FindRegionFromMap(short nLayer, short nStartNote);
	CRegion* FindRegionFromMap(int nNote);
	void SendRegionChange();
    BOOL IsValidMidiNoteText(char * pszNote);
	void ValidatePatch();
	void ValidateBank();
	void ValidateBank2();
	void SetLayerScrollInfo(int nFirstVisibleLayer);

	void RegionChangeCommonTasks(bool bUpdateFramework=true);
	void ValidateFullPatch(UINT* pwValidationMember, UINT wOldValue, UINT uControlID);
	void Update_and_Download(UINT uCause);
	WORD CalculateAuditionNote();
	void SetAttachedNode();
	void UpdateUseInstArt();
	void SetArticulationStaticIcon(bool bInstrumentLevel);

	/* updates both shared and articulation dialog-specific controls to match m_pCurArticulation */
	void UpdateArticulationControls();

	HRESULT GetArticulationBounds(CRect& rcBounds);
	HRESULT GetControlPosition(UINT nID, CRect& rcPosition);

	void CollectStatics();
	CDLSStatic* GetStaticControl(UINT nID);

	void AddStringToCombo(CComboBox& combo, CString& sString);

	void SetAuditionRadioMode();

	/* refreshes the property page for the current region, if selected and displayed */
	void RefreshCurrentRegionPropertyPage();
	
	CPtrList m_lstStatics;	// List of static controls in the editor

	UINT		m_nCurrentArticulationDlg;
	CDialog*	m_pArtDialog;
	CRect		m_rcArtBounds;
	
	//enum { TAB_COUNT = 3, TAB_X_POS = 18 + 4, INST_SETTINGS_MAX_TEXT = 64, TAB_Y_POS = (235 + 21)};
	// Fixed Large Font problem of placing VolDialog etc. The tab control they are inserted into is
	// located at dialog unit coordinates (7,143). Changed TAB_X_POS and TAB_Y_POS
	// Added some constants for the rects of the 3 groups - instrument, region and articulation - for
	// right click tests

	enum { TAB_COUNT = 3, TAB_X_POS = 8, INST_SETTINGS_MAX_TEXT = 64, TAB_Y_POS = (150 + 25),
			INST_GROUP_X = 278, INST_GROUP_Y = 75, INST_GROUP_WIDTH = 125,INST_GROUP_HEIGHT = 70,
			RGN_GROUP_X = 2, RGN_GROUP_Y = 10,RGN_GROUP_WIDTH = 410, RGN_GROUP_HEIGHT = 93,
			ART_GROUP_X = 2, ART_GROUP_Y = 136, ART_GROUP_WIDTH = 314, ART_GROUP_HEIGHT = 176};

	CInstrumentCtrl*		m_parent;
	CInstrument*			m_pInstrument;
	CCollection*			m_pCollection;
	CDLSComponent*			m_pComponent;
	//CDialog*				m_Tabs[TAB_COUNT];
	int						m_currSelTab;
	bool					m_fInOnInitialUpdate;

	DWORD					m_dwLowerNoteRange;		// Start note for the current region
	DWORD					m_dwUpperNoteRange;		// End note for the current region
	DWORD					m_dwLowerVelocityRange;	// Lower limit of the velocity range for the current region
	DWORD					m_dwUpperVelocityRange; // Upper limit of the velocity range for the current region
	long					m_lUnityNote;	// Root Note

	CWave*					m_pWave;
	CCollectionWaves*		m_pWaves;
	CRegion*				m_pCurRegion;
	CArticulation*			m_pCurArticulation;
    DWORD					m_dwGroup;
	DWORD					m_dwCookie;
	UINT					m_nClickVelocity;

	USHORT					m_usActiveLayer;		// Keeps the active layer for region edits and auditions

	static int				m_nInstrumentEditors;
	static HICON			m_hInstrumentIcon;
	static HICON			m_hRegionIcon;
	static CMenu*			m_pContextInstMenu;
	static CMenu*			m_pContextRegionMenu;
	static CMenu*			m_pContextArtMenu;
	
	static CBitmap			m_bmpAttack;
	static CBitmap			m_bmpDecay;
	static CBitmap			m_bmpDecay2;
	static CBitmap			m_bmpSustain;
	static CBitmap			m_bmpRelease;
	static CBitmap			m_bmpRelease2;

	static HANDLE			m_hAttack;
	static HANDLE			m_hDecay ;
	static HANDLE			m_hDecay2;
	static HANDLE			m_hSustain;
	static HANDLE			m_hRelease;
	static HANDLE			m_hRelease2;


	UINT					m_cfFormatRegion;
	UINT					m_cfFormatArt;
	int						m_nStartNoteForCurRegion;
	int						m_nHasFocus;
	enum {fBANK = 0x0001, fBANK2 = 0x0002, fPATCH = 0x0004, fLOWER_RANGE = 0x0008,
		fUPPER_RANGE = 0x0010, fROOT_NOTE = 0x0020};
	DWORD					m_bfTouched;
	bool					m_bTouchedByProgram;
	bool					m_bTouchedBySpinner;
	DWORD					m_dwIgnorePatchConflicts;
		
	// Generated message map functions
	//{{AFX_MSG(CInstrumentFVEditor)
	afx_msg void OnDrums();
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	afx_msg void OnRegionSelectedChangedRegionRegionkeyboard(short nLayer, short nStartNote);
	afx_msg void OnRegionOverlap();
	afx_msg void OnRegionUia();
	afx_msg void OnSelchangeRegionWavelink();
	afx_msg void OnContextMenu(CWnd* pWnd, CPoint point);
	afx_msg void OnDestroy();
	afx_msg void OnArticulationCopy();
	afx_msg void OnArticulationPaste();
	afx_msg void OnArticulationDelete();
	afx_msg void OnRegionDelete();
	afx_msg void OnInstrumentProperties();
	afx_msg void OnRegionProperties();
	afx_msg void OnInstEdRegionNewRegion();
	afx_msg void OnNewRegionRegionRegionkeyboard(short nLayer, long lower, long upper);
	afx_msg void OnRangeChangedRegionRegionkeyboard(short nLayer, long lower, long upper);
	afx_msg void OnKillfocusPatch();
	afx_msg void OnKillfocusBank();
	afx_msg void OnKillfocusBank2();
	afx_msg void OnSelchangeRegionGroup();
	afx_msg void OnUpdatePatch();
	afx_msg void OnDropdownRegionWavelink();
	afx_msg LRESULT OnValidate(UINT wParam,LONG lParam);
	afx_msg LRESULT OnBringToTop(UINT wParam,LONG lParam);
	afx_msg LRESULT OnUpdateMIDIValues(UINT wParam, LONG lPARAM);
	afx_msg LRESULT OnMIDIRegionSelect(UINT wParam, LONG lParam);
	afx_msg void OnChangeBank();
	afx_msg void OnChangeBank2();
	afx_msg void OnChangePatch();
	afx_msg void OnChangeLowerRange();
	afx_msg void OnChangeUpperRange();
	afx_msg void OnChangeRootNote();
	afx_msg void OnUpdateBank();
	afx_msg void OnUpdateBank2();
	afx_msg void OnDeltaPosMSBSpin(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnDeltaPosLSBSpin(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnDeltaPosPatchSpin(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnNotePlayedRegionRegionkeyboard(long nNote, BOOL bType);
	afx_msg void OnRegionMovedRegionRegionkeyboard(short nOldLayer, short nOldStartNote, short nMovedLayer, short nMovedStartNote, short nMovedEndNote);
	afx_msg void OnRegionDeletedRegionkeyboard(short nLayer, short nStartnote);
	afx_msg void OnKillfocusRegionElrange();
	afx_msg void OnKillfocusRegionEurange();
	afx_msg void OnKillfocusRegionRootNote();
	afx_msg void OnDeltaposRegionRootNoteSpin(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnDeltaposRegionThruSpin(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnDeltaposRegionRangeSpin(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnSetfocusRegionElrange();
	afx_msg void OnSetfocusRegionEurange();
	afx_msg void OnSetfocusRegionRootNote();
	afx_msg void OnPitchButton();
	afx_msg void OnLfoButton();
	afx_msg void OnVolumeButton();
	afx_msg void OnKillfocusRegionVelocityElrange();
	afx_msg void OnKillfocusRegionVelocityEurange();
	afx_msg void OnKillfocusClickVelocity();
	afx_msg void OnDeltaposRegionVelocityRangeSpin(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnDeltaposRegionVelocityThruSpin(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnVScroll(UINT nSBCode, UINT nPos, CScrollBar* pScrollBar);
	afx_msg void OnDeltaposClickVelocitySpin(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnActiveLayerChangedRegionRegionkeyboard(short nLayer);
	afx_msg void OnConditionEditButton();
	afx_msg void OnSelchangeRegionConditionCombo();
	afx_msg void OnDropdownRegionConditionCombo();
	afx_msg void OnArtDls1Check();
	afx_msg void OnViblfoButton();
	afx_msg void OnFilterButton();
	afx_msg void OnInstEdRegionNewLayer();
	afx_msg void OnInstEdLayerDelete();
	afx_msg void OnRadioMultipleLayers();
	afx_msg void OnRadioSoloLayer();
	afx_msg void OnCopyRegionRegionkeyboard(short nSourceLayer, short nSourceStartNote, short nCopyLayer, short nCopyStartNote);
	afx_msg void OnWaveEditButton();
	afx_msg void OnScrollLayersRegionRegionkeyboard(BOOL bUp);
	DECLARE_EVENTSINK_MAP()
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_INSTRUMENTFVEDITOR_H__8C0AA7C7_E6FC_11D0_876A_00AA00C08146__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\DLSDesigner\InstrumentPropPgMgr.cpp ===
//////////////////////////////////////////////////////////////////////
//
// InstrumentPropPgMgr.cpp: implementation of the CInstrumentPropPgMgr class.
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "InstrumentPropPgMgr.h"
#include "InstrumentPropPg.h"
#include "Collection.h"
#include "Instrument.h"


#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CInstrumentPropPgMgr::CInstrumentPropPgMgr() : m_pInstrumentPage(NULL)
{

}

CInstrumentPropPgMgr::~CInstrumentPropPgMgr()
{
	if(m_pInstrumentPage)
		delete m_pInstrumentPage;

	m_pInstrumentPage = NULL;
}

/////////////////////////////////////////////////////////////////////////////
// CInstrumentPropPgMgr IJazzPropPageManager implementation

/////////////////////////////////////////////////////////////////////////////
// CInstrumentPropPgMgr IJazzPropPageManager::GetPropertySheetTitle

HRESULT CInstrumentPropPgMgr::GetPropertySheetTitle(BSTR* pbstrTitle, BOOL* pfAddPropertiesText)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT(pbstrTitle);
	ASSERT(pfAddPropertiesText);

	*pfAddPropertiesText = TRUE;

	CInstrument* pInstrument;

	if(m_pIPropPageObject && (SUCCEEDED (m_pIPropPageObject->GetData((void **)&pInstrument))))
	{
		pInstrument->GetName();
		CString sInstrumentName = pInstrument->m_csName; 
		
		BSTR bstrCollectionName;
		pInstrument->m_pCollection->GetNodeName(&bstrCollectionName);
		CString sCollectionName = bstrCollectionName;
		SysFreeString(bstrCollectionName);

		CString sTitle;
		sTitle.Format(IDS_INSTRUMENT_PROPPAGE_TITLE, sCollectionName, sInstrumentName);
		*pbstrTitle = sTitle.AllocSysString();
	}
	else
	{
		CString strTitle;
		strTitle.LoadString(IDS_INSTRUMENT_TEXT);
		*pbstrTitle = strTitle.AllocSysString();
	}

	return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
// CInstrumentPropPgMgr IJazzPropPageManager::GetPropertySheetPages

HRESULT CInstrumentPropPgMgr::GetPropertySheetPages(IDMUSProdPropSheet* pIPropSheet, LONG* hPropSheetPage[], short* pnNbrPages)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( (hPropSheetPage == NULL)
	||  (pnNbrPages == NULL) )
	{
		return E_POINTER;
	}

	if( pIPropSheet == NULL )
	{
		return E_INVALIDARG;
	}

	m_pIPropSheet = pIPropSheet;
	m_pIPropSheet->AddRef();

	hPropSheetPage[0] = NULL;
	*pnNbrPages = 0;

	// Add General tab
	HPROPSHEETPAGE hPage;
	short nNbrPages = 0;

	if(m_pInstrumentPage == NULL)
		m_pInstrumentPage = new CInstrumentPropPg();

	if(m_pInstrumentPage)
	{
		hPage = ::CreatePropertySheetPage((LPPROPSHEETPAGE)&m_pInstrumentPage->m_psp);
		if(hPage)
		{
			hPropSheetPage[nNbrPages] = (LONG *)hPage;
			nNbrPages++;
		}			
	}

	// Set number of pages
	*pnNbrPages = nNbrPages; 

	return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
// CInstrumentPropPgMgr IJazzPropPageManager::RefreshData

HRESULT CInstrumentPropPgMgr::RefreshData(void)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if(m_pInstrumentPage == NULL)
		return E_FAIL;
	
	CInstrument* pInstrument = NULL;
	
	if(m_pIPropPageObject == NULL)
	{
		pInstrument = NULL;
	}
	else
	{
		if(FAILED(m_pIPropPageObject->GetData((void **)&pInstrument)))
		{
			return E_FAIL;
		}
	}

	m_pInstrumentPage->SetObject(pInstrument);

	if(m_pIPropSheet)
		m_pIPropSheet->RefreshTitle();

	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\DLSDesigner\KeyBoardMap.h ===
//////////////////////////////////////////////////////////////////////
// KeyBoardMap.h 
//

#ifndef KEYBOARDMAP_H
#define KEYBOARDMAP_H

#include "objbase.h"

class RegionNote;

class KeyBoardMap : public IUnknown
{
public:

	KeyBoardMap() : m_pRegionMap(NULL), m_dwRef(0) { AddRef();}
	~KeyBoardMap() {}

    // IUnknown functions
    HRESULT STDMETHODCALLTYPE QueryInterface( REFIID riid, LPVOID *ppv );
    ULONG STDMETHODCALLTYPE AddRef();
    ULONG STDMETHODCALLTYPE Release();

	void SetRegionMap(RegionNote* pRegionMap) {ASSERT(pRegionMap); 
											   m_pRegionMap = pRegionMap;}

	RegionNote* GetRegionMap() {return m_pRegionMap;}
	
private:
	RegionNote* m_pRegionMap;
	DWORD		m_dwRef;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\DLSDesigner\KeyBoardMap.cpp ===
//////////////////////////////////////////////////////////////////////
// KeyBoardMap.cpp : implementation file
//

#include "StdAfx.h"
#include "RegionNote.h"
#include "KeyBoardMap.h"

HRESULT KeyBoardMap::QueryInterface( REFIID riid, LPVOID FAR* ppvObj )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

    if(::IsEqualIID(riid, IID_IUnknown))
    {
        AddRef();
        *ppvObj = this;
        return S_OK;
    }

    *ppvObj = NULL;
    return E_NOINTERFACE;
}

ULONG KeyBoardMap::AddRef()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	
	AfxOleLockApp();
    return ++m_dwRef;
}

ULONG KeyBoardMap::Release()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

    ASSERT( m_dwRef != 0 );

	AfxOleUnlockApp();
    --m_dwRef;

    if( m_dwRef == 0 )
    {
        delete this;
        return 0;
    }

    return m_dwRef;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\DLSDesigner\InstrumentPropPgMgr.h ===
//////////////////////////////////////////////////////////////////////
//
// InstrumentPropPgMgr.h
//
//////////////////////////////////////////////////////////////////////

#ifndef INSTRUMENTPROPPGMGR_H
#define INSTRUMENTPROPPGMGR_H

#include "DllBasePropPageManager.h"

class CInstrumentPropPg;

//////////////////////////////////////////////////////////////////////
//  CInstrumentPropPgMgr

class CInstrumentPropPgMgr : public CDllBasePropPageManager 
{
	friend class CInstrument;

public:
	CInstrumentPropPgMgr();
	virtual ~CInstrumentPropPgMgr();

    // IJazzPropPageManager functions
    HRESULT STDMETHODCALLTYPE GetPropertySheetTitle( BSTR* pbstrTitle, BOOL* pfAddPropertiesText );
    HRESULT STDMETHODCALLTYPE GetPropertySheetPages( IDMUSProdPropSheet* pIPropSheet, LONG* hPropSheetPage[], short* pnNbrPages );

    HRESULT STDMETHODCALLTYPE RefreshData();

	// Member variables
private:
	
	CInstrumentPropPg*	m_pInstrumentPage;
};

#endif // #ifndef INSTRUMENTPROPPGMGR_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\DLSDesigner\InstrumentRegions.cpp ===
// InstrumentRegions.cpp : implementation file
//

#include "stdafx.h"
#include "DlsDefsPlus.h"
#include "DLSDesignerDLL.h"
#include "DLSDesigner.h"
#include "Collection.h"
#include "Instrument.h"
#include "Region.h"
#include "Articulation.h"
#include "InstrumentRegions.h"
#include "InstrumentCtl.h"
#include "InstrumentFVEditor.h"
#include "WaveNode.h"
#include "Wave.h"
#include "MonoWave.h"
#include "StereoWave.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CInstrumentRegions constructor/destructor

CInstrumentRegions::CInstrumentRegions() :
m_dwRef(0),
m_pIRootNode(NULL),
m_pIParentNode(NULL),
m_pDLSComponent(NULL),
m_pInstrument(NULL),
m_nNumberOfLayers(MINIMUM_LAYERS)
{
	AddRef();
}

CInstrumentRegions::~CInstrumentRegions()
{
	while(!IsEmpty())
	{
        CRegion *pRegion = RemoveHead();
        pRegion->Release();
	}
}

void CInstrumentRegions::AddTail(CRegion *pINode)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	
	ASSERT(pINode);
	
	AList::AddTail((AListItem *) pINode);
}

CRegion *CInstrumentRegions::GetHead() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	return (CRegion *)AList::GetHead();
}

CRegion *CInstrumentRegions::RemoveHead() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	return (CRegion *) AList::RemoveHead();
}

void CInstrumentRegions::Remove(CRegion *pINode) 
{ 
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	
	ASSERT(pINode);
	
	AList::Remove((AListItem *) pINode);
}

/////////////////////////////////////////////////////////////////////////////
// CInstrumentRegions IUnknown implementation

HRESULT CInstrumentRegions::QueryInterface( REFIID riid, LPVOID FAR* ppvObj )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

    if( ::IsEqualIID(riid, IID_IDMUSProdNode)
	||  ::IsEqualIID(riid, IID_IUnknown) )
    {
        AddRef();
        *ppvObj = this;
        return S_OK;
    }
	
	if(::IsEqualIID(riid, IID_IDMUSProdSortNode))
	{
		AddRef();
        *ppvObj = (IDMUSProdSortNode*) this;
        return S_OK;
	}

    *ppvObj = NULL;
    return E_NOINTERFACE;
}

ULONG CInstrumentRegions::AddRef()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	
	AfxOleLockApp();
    return ++m_dwRef;
}

ULONG CInstrumentRegions::Release()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

    ASSERT( m_dwRef != 0 );

	AfxOleUnlockApp();
    --m_dwRef;

    if( m_dwRef == 0 )
    {
        delete this;
        return 0;
    }

    return m_dwRef;
}

/////////////////////////////////////////////////////////////////////////////
// CInstrumentRegions IDMUSProdNode implementation

/////////////////////////////////////////////////////////////////////////////
// CInstrumentRegions IDMUSProdNode::GetNodeImageIndex

HRESULT CInstrumentRegions::GetNodeImageIndex(short* pnFirstImage)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT(pnFirstImage);
	
	ASSERT(m_pDLSComponent != NULL);

	return(m_pDLSComponent->GetFolderImageIndex(pnFirstImage));
}

/////////////////////////////////////////////////////////////////////////////
// CInstrumentRegions IDMUSProdNode::GetComponent

HRESULT CInstrumentRegions::GetComponent(IDMUSProdComponent** ppIComponent)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	
	ASSERT(m_pDLSComponent != NULL);
	ASSERT(ppIComponent);

	return m_pDLSComponent->QueryInterface(IID_IDMUSProdComponent, (void**)ppIComponent);
}

/////////////////////////////////////////////////////////////////////////////
// CInstrumentRegions IDMUSProdNode::GetRootNode

HRESULT CInstrumentRegions::GetDocRootNode(IDMUSProdNode** ppIRootNode)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT(m_pIRootNode != NULL);

	m_pIRootNode->AddRef();
	*ppIRootNode = m_pIRootNode;

	return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
// CInstrumentRegions IDMUSProdNode::SetRootNode

HRESULT CInstrumentRegions::SetDocRootNode(IDMUSProdNode* pIRootNode)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( pIRootNode != NULL );

	m_pIRootNode = pIRootNode;
//	m_pIRootNode->AddRef();		intentionally missing

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CInstrumentRegions IDMUSProdNode::GetParentNode

HRESULT CInstrumentRegions::GetParentNode(IDMUSProdNode** ppIParentNode)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT(m_pIParentNode != NULL);

	m_pIParentNode->AddRef();
	*ppIParentNode = m_pIParentNode;

	return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
// CInstrumentRegions IDMUSProdNode::SetParentNode

HRESULT CInstrumentRegions::SetParentNode(IDMUSProdNode* pIParentNode)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( pIParentNode != NULL );

	m_pIParentNode = pIParentNode;
//	m_pIParentNode->AddRef();		intentionally missing

	return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
// CInstrumentRegions IDMUSProdNode::GetNodeId

HRESULT CInstrumentRegions::GetNodeId( GUID* pguid )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( pguid == NULL )
	{
		return E_POINTER;
	}

	*pguid = GUID_RegionFolderNode;

	return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
// CInstrumentRegions IDMUSProdNode::GetNodeName

HRESULT CInstrumentRegions::GetNodeName( BSTR* pbstrName )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	
	ASSERT(pbstrName);

	CString strName;
	TCHAR achBuffer[BUFFER_128];

	if(::LoadString(theApp.m_hInstance, IDS_REGION_FOLDER_NAME, achBuffer, BUFFER_128))
	{
		strName = achBuffer;
	}

    *pbstrName = strName.AllocSysString();

	return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
// CInstrumentRegions IDMUSProdNode::GetNodeNameMaxLength

HRESULT CInstrumentRegions::GetNodeNameMaxLength(short* pnMaxLength)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT(pnMaxLength);
	
	*pnMaxLength = -1; // Can't rename a Region folder

	return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
// CInstrumentRegions IDMUSProdNode::ValidateNodeName

HRESULT CInstrumentRegions::ValidateNodeName(BSTR bstrName)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	// Just free bstrName; can't rename Regions folder
	::SysFreeString(bstrName);

	return S_OK;

}

/////////////////////////////////////////////////////////////////////////////
// CInstrumentRegions IDMUSProdNode::SetNodeName

HRESULT CInstrumentRegions::SetNodeName( BSTR bstrName )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	return E_NOTIMPL; // Can't rename a Region folder
}

/////////////////////////////////////////////////////////////////////////////
// CInstrumentRegions IDMUSProdNode::GetEditorClsId

HRESULT CInstrumentRegions::GetEditorClsId( CLSID* pClsId )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	return E_NOTIMPL; // Can't edit a Region folder
}

/////////////////////////////////////////////////////////////////////////////
// CInstrumentRegions IDMUSProdNode::GetEditorTitle

HRESULT CInstrumentRegions::GetEditorTitle( BSTR* pbstrTitle )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	return E_NOTIMPL; // Can't edit a Region folder
}

/////////////////////////////////////////////////////////////////////////////
// CInstrumentRegions IDMUSProdNode::GetEditorWindow

HRESULT CInstrumentRegions::GetEditorWindow( HWND* hWndEditor )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	return E_NOTIMPL; // Can't edit a Region folder
}

/////////////////////////////////////////////////////////////////////////////
// CInstrumentRegions IDMUSProdNode::SetEditorWindow

HRESULT CInstrumentRegions::SetEditorWindow( HWND hWndEditor )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	return E_NOTIMPL; // Can't edit a Region folder
}

/////////////////////////////////////////////////////////////////////////////
// CInstrumentRegions IDMUSProdNode::UseOpenCloseImages

HRESULT CInstrumentRegions::UseOpenCloseImages(BOOL* pfUseOpenCloseImages)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT(pfUseOpenCloseImages);

	*pfUseOpenCloseImages = TRUE;

	return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
// CInstrumentRegions IDMUSProdNode::GetRightClickMenuId

HRESULT CInstrumentRegions::GetRightClickMenuId(HINSTANCE* phInstance, UINT* pnMenuId)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT(pnMenuId);
	ASSERT(phInstance);

	*phInstance = theApp.m_hInstance;
	*pnMenuId = IDM_REGIONS_NODE_RMENU;

	return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
// CInstrumentRegions IDMUSProdNode::OnRightClickMenuInit

HRESULT CInstrumentRegions::OnRightClickMenuInit(HMENU hMenu)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	/*int nNextFreeNote = GetNextFreeNote();
	if(nNextFreeNote == -1)
	{
		BOOL status = EnableMenuItem(hMenu, IDM_NEW_REGION, MF_BYCOMMAND | MF_GRAYED);
	}
	else*/
	{
		BOOL status = EnableMenuItem(hMenu, IDM_NEW_REGION, MF_BYCOMMAND | MF_ENABLED);
	}

	return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
// CInstrumentRegions IDMUSProdNode::OnRightClickMenuSelect

HRESULT CInstrumentRegions::OnRightClickMenuSelect(long lCommandId)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	HRESULT hr = E_FAIL;

	switch(lCommandId)
	{
		case IDM_NEW_REGION:
			if(m_pInstrument)
			{
				if(FAILED(m_pInstrument->SaveStateForUndo(IDS_UNDO_REGION_INSERT)))
					return E_FAIL;
			}
			hr = InsertChildNode(NULL);
			break;
	}

	return hr;
}

/////////////////////////////////////////////////////////////////////////////
// CInstrumentRegions IDMUSProdNode::DeleteChildNode

HRESULT CInstrumentRegions::DeleteChildNode(IDMUSProdNode* pIChildNode, BOOL fPromptUser)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT(pIChildNode != NULL);
	ASSERT(m_pDLSComponent != NULL);
	ASSERT(m_pDLSComponent->m_pIFramework != NULL);

	// Remove node from Project Tree
	if( m_pDLSComponent->m_pIFramework->RemoveNode(pIChildNode, fPromptUser) == S_FALSE )
	{
		return E_FAIL;
	}

	if (m_pInstrument)
	{
		if(FAILED(m_pInstrument->SaveStateForUndo(IDS_UNDO_REGION_DELETE)))
		{
			// Out Of Memory!!! Do we need to add the node back to the tre???
			// Will it go through??
			return E_FAIL;
		}

		CInstrumentFVEditor* pIE = m_pInstrument->GetInstrumentEditor();
		CRegion* pRegion = (CRegion*) pIChildNode;
		if(pIE)
		{
			pIE->m_RegionKeyBoard.DeleteRegion(short(pRegion->GetLayer()), pRegion->m_rRgnHeader.RangeKey.usLow);
			pIE->SendRegionChange();
		}
	}

	// Remove from list
	Remove((CRegion *)pIChildNode);
	pIChildNode->Release();

	// Set flag so we know to save file 
	m_pInstrument->m_pCollection->SetDirtyFlag();

	m_pInstrument->UpdateInstrument();
	
	return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
// CInstrumentRegions IDMUSProdNode::InsertChildNode

HRESULT CInstrumentRegions::InsertChildNode(IDMUSProdNode* pIChildNode)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	int nNextFreeNote = 0;
	USHORT usFreeLayer = 1; 
	GetNextFreeNote(usFreeLayer, nNextFreeNote);
	if(nNextFreeNote > -1)
		return(InsertRegion(pIChildNode, usFreeLayer, USHORT(nNextFreeNote), USHORT(nNextFreeNote)));
	else
		return E_FAIL;
}

/* creates a new region */
HRESULT CInstrumentRegions::InsertRegion(IDMUSProdNode* pIChildNode, int nLayer, USHORT lowerNote,
	USHORT upperNote, bool bInsertIntoKeyboard, CRegion **ppRegion)
{
	ASSERT(m_pDLSComponent);
	if(m_pDLSComponent == NULL)
	{
		return E_UNEXPECTED;
	}

	IDMUSProdFramework* pIFramework = m_pDLSComponent->m_pIFramework;
	ASSERT(pIFramework);
	if(pIFramework == NULL)
	{
		return E_UNEXPECTED;
	}

	ASSERT(m_pInstrument);
	if(m_pInstrument == NULL)
	{
		return E_UNEXPECTED;
	}
	
	if(pIChildNode == NULL)
	{
		pIChildNode = new CRegion(m_pDLSComponent);
		if(pIChildNode == NULL)
		{
			return E_OUTOFMEMORY;
		}
	}

	// assign a variable so we don't cast every time.
	CRegion * pRegion = (CRegion *)pIChildNode;
	if(bInsertIntoKeyboard)
	{
		if(m_pInstrument && m_pInstrument->GetInstrumentEditor() != NULL)
		{
			CInstrumentFVEditor* pIE = m_pInstrument->GetInstrumentEditor();
			if(pIE)
			{
				short nFirstNote = lowerNote;
				short nLastNote = upperNote;
				nLayer = pIE->m_RegionKeyBoard.InsertNewRegion(nFirstNote, nLastNote, 0, 127);
			}
		}
		else 
		{
			nLayer = 0;
		}
	}

	pRegion->SetLayer(nLayer);

	pRegion->m_pInstrument = m_pInstrument;
	pRegion->GetName();
	
	pRegion->m_rRgnHeader.RangeKey.usLow = lowerNote;
	pRegion->m_rRgnHeader.RangeKey.usHigh = upperNote;
	
	// Make sure we have an Articulation for the Region to use
	
	CInstrument* pInstrument = pRegion->GetInstrument();
	if(pInstrument && pInstrument->GetArticulationCount() == 0)
	{
		// Instrument does not have an Articulation so we need to create one
		pInstrument->CreateDefaultGlobalArticulation();
		if(pInstrument->m_pCurArticulation == NULL)
			goto LDeleteChildAndFail;
	}		

    // Setup a wave for the region.
	if(pRegion->m_pWave == NULL)
	{
		CWave* pWave = m_pInstrument->m_pCollection->m_Waves.GetFirstWave();
		if (!pWave)
			goto LDeleteChildAndFail;

		pRegion->SetWave(pWave);
	}

    // add to Region list
	AddTail( pRegion);

	// Set root and parent node of ALL children
	theApp.SetNodePointers( pIChildNode, (IDMUSProdNode *)(m_pInstrument->m_pCollection), (IDMUSProdNode *)this );

	// Add node to Project Tree
	if(!SUCCEEDED(pIFramework->AddNode(pIChildNode, (IDMUSProdNode *)this)))
	{
		DeleteChildNode( pIChildNode, FALSE );
		return E_FAIL;
	}

	if(m_pInstrument)
	{
		CInstrumentFVEditor* pIE;
		pIE = m_pInstrument->GetInstrumentEditor();
		if(pIE)
		{
			pIE->SetCurRegion(pRegion);
			pIE->SendRegionChange();
			pIE->m_RegionKeyBoard.SetWaveName(short(nLayer), lowerNote, pRegion->GetWaveName());
		}
	}

	bool fIsDrumKit;
	fIsDrumKit = (pRegion->m_pInstrument->m_rInstHeader.Locale.ulBank & F_INSTRUMENT_DRUMS) != 0;
	if(fIsDrumKit) // If a Drum Kit we want the Region to own the Articulation
	{
		//pRegion->m_pArticulation = new CArticulation(m_pDLSComponent, pRegion);
		pRegion->InsertChildNode(NULL);
		if(pRegion->m_pArticulation == NULL)
			goto LDeleteChildAndFail;

		pIFramework->SetSelectedNode(pRegion);
	}
	
	// Set flag to indicate the DLS collection now needs to be saved
	m_pInstrument->m_pCollection->SetDirtyFlag();

	if (ppRegion)
		*ppRegion = pRegion;

	return S_OK;

LDeleteChildAndFail:
	delete pIChildNode;
	return E_OUTOFMEMORY;
}

////////////////////////////////////////////////////////////////////////////
// CInstrumentRegions IDMUSProdNode::DeleteNode

HRESULT CInstrumentRegions::DeleteNode( BOOL fPromptUser )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	return E_NOTIMPL;
}

//////////////////////////////////////////////////////////////////////
//
//	CInstrumentRegions IDMUSProdNode::GetFirstChild
//
//////////////////////////////////////////////////////////////////////
HRESULT CInstrumentRegions::GetFirstChild(IDMUSProdNode** ppIFirstChildNode)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if(ppIFirstChildNode == NULL)
	{
		return E_POINTER;
	}

	*ppIFirstChildNode = NULL;

	IDMUSProdNode* pINode = (IDMUSProdNode*) GetHead();

	if(pINode)
	{
		pINode->AddRef();
		*ppIFirstChildNode = pINode;
	}

	return S_OK;
}

//////////////////////////////////////////////////////////////////////
//
//	CInstrumentRegions IDMUSProdNode::GetNextChild
//
//////////////////////////////////////////////////////////////////////
HRESULT CInstrumentRegions::GetNextChild(IDMUSProdNode* pIChildNode, IDMUSProdNode** ppINextChildNode)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if(ppINextChildNode == NULL)
	{
		return E_POINTER;
	}

	*ppINextChildNode = NULL;

	if(pIChildNode == NULL)
	{
		return E_INVALIDARG;
	}

	IDMUSProdNode* pINode = (IDMUSProdNode*) ((CRegion *) pIChildNode)->GetNext();

	if(pINode)
	{
		pINode->AddRef();
		*ppINextChildNode = pINode;
	}

	return S_OK;
}

//////////////////////////////////////////////////////////////////////
//
//	CInstrumentRegions IDMUSProdNode::GetNodeListInfo
//
//////////////////////////////////////////////////////////////////////
HRESULT CInstrumentRegions::GetNodeListInfo(DMUSProdListInfo* pListInfo)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	
	ASSERT(pListInfo);
	
	return E_NOTIMPL;
}

/////////////////////////////////////////////////////////////////////////////
// CInstrumentRegions IDMUSProdNode::OnNodeSelChanged

HRESULT CInstrumentRegions::OnNodeSelChanged(BOOL fSelected)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
//
// CInstrumentRegions IDMUSProdNode::CreateDataObject
//
//////////////////////////////////////////////////////////////////////
HRESULT CInstrumentRegions::CreateDataObject( IDataObject** ppIDataObject )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
    return E_NOTIMPL;
}

/////////////////////////////////////////////////////////////////////////////
//
// CInstrumentRegions IDMUSProdNode::CanCut
//
//////////////////////////////////////////////////////////////////////
HRESULT CInstrumentRegions::CanCut()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
    return E_NOTIMPL;

}

/////////////////////////////////////////////////////////////////////////////
//
// CInstrumentRegions IDMUSProdNode::CanCopy
//
//////////////////////////////////////////////////////////////////////
HRESULT CInstrumentRegions::CanCopy()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
    return E_NOTIMPL;

}

/////////////////////////////////////////////////////////////////////////////
//
// CInstrumentRegions IDMUSProdNode::CanDelete
//
//////////////////////////////////////////////////////////////////////
HRESULT CInstrumentRegions::CanDelete()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
    return E_NOTIMPL;

}

/////////////////////////////////////////////////////////////////////////////
//
// CInstrumentRegions IDMUSProdNode::CanDeleteChildNode
//
//////////////////////////////////////////////////////////////////////
HRESULT CInstrumentRegions::CanDeleteChildNode( IDMUSProdNode* pIChildNode )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
    return E_NOTIMPL;

}

/////////////////////////////////////////////////////////////////////////////
//
// CInstrumentRegions IDMUSProdNode::CanPasteFromData
//
//////////////////////////////////////////////////////////////////////
HRESULT CInstrumentRegions::CanPasteFromData( IDataObject* pIDataObject, BOOL* pfWillSetReference )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
    return E_NOTIMPL;

}

/////////////////////////////////////////////////////////////////////////////
//
// CInstrumentRegions IDMUSProdNode::PasteFromData
//
//////////////////////////////////////////////////////////////////////
HRESULT CInstrumentRegions::PasteFromData( IDataObject* pIDataObject )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
    return E_NOTIMPL;

}

/////////////////////////////////////////////////////////////////////////////
//
// CInstrumentRegions IDMUSProdNode::CanChildPasteFromData
//
//////////////////////////////////////////////////////////////////////
HRESULT CInstrumentRegions::CanChildPasteFromData( IDataObject* pIDataObject, IDMUSProdNode* pIChildNode,
												   BOOL* pfWillSetReference )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
    return E_NOTIMPL;

}

/////////////////////////////////////////////////////////////////////////////
//
// CInstrumentRegions IDMUSProdNode::ChildPasteFromData
//
//////////////////////////////////////////////////////////////////////
HRESULT CInstrumentRegions::ChildPasteFromData( IDataObject* pIDataObject, IDMUSProdNode* pIChildNode )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
    return E_NOTIMPL;

}

/////////////////////////////////////////////////////////////////////////////
// CInstrumentRegions IDMUSProdNode::GetObject

HRESULT CInstrumentRegions::GetObject( REFCLSID rclsid, REFIID riid, void** ppvObject )
{
//	AFX_MANAGE_STATE(_afxModuleAddrThis);

	return E_NOTIMPL;
}


/////////////////////////////////////////////////////////////////////////////
// CInstrumentRegions IDMUSProdSortNode methods
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// IDMUSProdSortNode::CompareNodes

HRESULT CInstrumentRegions::CompareNodes(IDMUSProdNode* pNode1, IDMUSProdNode* pNode2, int* pnResult)
{
	ASSERT(pNode1);
	ASSERT(pNode2);
	
	if(pNode1 == NULL || pNode2 == NULL)
		return E_INVALIDARG;

	if(pnResult == NULL)
		return E_POINTER;

	CRegion* pRegion1 = dynamic_cast<CRegion*>(pNode1);
	CRegion* pRegion2 = dynamic_cast<CRegion*>(pNode2);
	
	if(pRegion1 == NULL || pRegion2 == NULL)
		return E_FAIL;

	if(pRegion1->m_rRgnHeader.RangeKey.usLow < pRegion2->m_rRgnHeader.RangeKey.usLow)
	{
		*pnResult = -1;
	}
	else if(pRegion1->m_rRgnHeader.RangeKey.usLow > pRegion2->m_rRgnHeader.RangeKey.usLow)
	{
		*pnResult = 1;
	}
	else 
	{
		*pnResult = 0;
	}

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CInstrumentRegions::Load

HRESULT CInstrumentRegions::Load(IDMUSProdRIFFStream* pIRiffStream, MMCKINFO* pckMain)
{    
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	IStream* pIStream;
	MMCKINFO ck;
    HRESULT	hr = E_FAIL;

	ASSERT(m_pDLSComponent != NULL);

    pIStream = pIRiffStream->GetStream();
	ASSERT(pIStream != NULL);

	ck.ckid = 0;
	ck.fccType = 0;
    while( pIRiffStream->Descend(&ck, pckMain, 0) == 0 )
	{
		switch (ck.ckid) 
		{
			case FOURCC_LIST :
				switch(ck.fccType)
				{
					case FOURCC_RGN :
					case FOURCC_RGN2:
					{
						bool bDLS1Region = (ck.fccType == FOURCC_RGN) ? true : false;
						CRegion *pRegion = new CRegion(m_pDLSComponent, bDLS1Region);
						if(pRegion != NULL)
						{
							pRegion->m_pInstrument = m_pInstrument;
							hr = pRegion->Load(pIRiffStream, &ck);
							if(SUCCEEDED(hr))
							{
								AddTail(pRegion);
							}
							else
							{
								pRegion->Release();
								pIStream->Release();
								return hr;
							}
						}
						else
						{
							pIStream->Release();
							return E_OUTOFMEMORY;
						}

						break;
					}
				}
			break;
		}
        pIRiffStream->Ascend( &ck, 0 );
		ck.ckid = 0;
		ck.fccType = 0;
	}

	pIStream->Release();
	return hr;
}



void CInstrumentRegions::GetNextFreeNote(USHORT& usLayer, int& nNote)
{

	USHORT usFirstLayer = 1;
	if(m_pInstrument && m_pInstrument->GetInstrumentEditor() != NULL)
	{
		usFirstLayer = m_pInstrument->GetInstrumentEditor()->GetActiveLayer();
	}

	for(usLayer = usFirstLayer; usLayer < m_nNumberOfLayers; usLayer++)
	{
		for(nNote = 0; nNote < 128; nNote++)
		{
			CRegion* pRegion = FindRegionFromMap(usLayer, short(nNote));
			if(pRegion == NULL)
			{
				return;
			}
			else
			{
				// Skip the search to the end of this region
				nNote = pRegion->m_rRgnHeader.RangeKey.usHigh;
			}

		}
	}


}

void CInstrumentRegions::SetDrumArticulation()
{
	CRegion * pRegion = GetHead();
	for( ; pRegion; pRegion = pRegion->GetNext())
	{
		pRegion->m_bUseInstrumentArticulation = false;
	}
}

void CInstrumentRegions::ValidateUIA()
{
	CRegion * pRegion = GetHead();
	for( ; pRegion; pRegion = pRegion->GetNext())
	{
		if(!pRegion->ValidateUIA())
		{
			if (m_pInstrument->m_rInstHeader.Locale.ulBank & F_INSTRUMENT_DRUMS)
			{
				pRegion->CreateAndInsertArticulationList();
			}
			else
			{
				m_pInstrument->InsertChildNode(NULL);
			}
		}
	}
}

CRegion* CInstrumentRegions::FindRegionFromMap(short nLayer, short nStartNote)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	CRegion* pRegion = GetHead();
	CRegion* pTempRegion = NULL;

	// Walk the region list to find region
	for(; pRegion; pRegion = pRegion->GetNext())
	{
		if(pRegion->GetLayer() == nLayer && pRegion->m_rRgnHeader.RangeKey.usLow == nStartNote)
		{
			return pRegion;
		}
	}
	
	return NULL;
}

CRegion* CInstrumentRegions::FindRegionFromMap(int nNote)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	CRegion* pRegion = GetHead();
	CRegion* pTempRegion = NULL;

	// Walk the region list to find region
	for(; pRegion; pRegion = pRegion->GetNext())
	{
		if(pRegion->m_rRgnHeader.RangeKey.usLow <= nNote && pRegion->m_rRgnHeader.RangeKey.usHigh >= nNote)
		{
			return pRegion;
		}
	}
	
	return NULL;
}

HRESULT CInstrumentRegions::FindRegionsForNote(short nNote, CPtrList* plstRegions)
{
	ASSERT(plstRegions);
	if(plstRegions == NULL)
	{
		return E_POINTER;
	}

	CRegion* pRegion = GetHead();
	for(; pRegion; pRegion = pRegion->GetNext())
	{
		if(pRegion->m_rRgnHeader.RangeKey.usLow <= nNote && pRegion->m_rRgnHeader.RangeKey.usHigh >= nNote)
		{
			plstRegions->AddTail(pRegion);
		}
	}

	return S_OK;
}

HRESULT	 CInstrumentRegions::FindPlayingRegions(USHORT usPlayNote, USHORT usVelocity, CPtrList* plstRegions)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	ASSERT(m_pInstrument);
	if(m_pInstrument == NULL)
	{
		return E_UNEXPECTED;
	}
	
	CInstrumentFVEditor* pIE = m_pInstrument->GetInstrumentEditor();
	if(pIE == NULL)
	{
		return E_FAIL;
	}

	USHORT usActiveLayer = pIE->GetActiveLayer();
	bool bAuditionMode = m_pInstrument->GetAuditionMode();

	bool bIgnoreLayer = bAuditionMode == AUDITION_MULTIPLE ? true : false;

	CRegion* pRegion = GetHead();
	while(pRegion)
	{
		if(pRegion->IsOkayToPlay(usActiveLayer, usPlayNote, usVelocity, bIgnoreLayer) == true)
		{
			plstRegions->AddTail(pRegion);
		}

		pRegion = pRegion->GetNext();
	}

	return S_OK;
}


int CInstrumentRegions::GetNumberOfLayers()
{
	return m_nNumberOfLayers;
}

void CInstrumentRegions::SetNumberOfLayers(int nLayers)
{
	m_nNumberOfLayers = nLayers;
}

BOOL CInstrumentRegions::IsLayerEmpty(int nLayer)
{
	CRegion* pRegion = GetHead();
	while(pRegion)
	{
		if(pRegion->GetLayer() == nLayer)
		{
			return FALSE;
		}

		pRegion = pRegion->GetNext();
	}

	return TRUE;
}

/* copies a region, optionally returns the new region in ppRegion */
HRESULT	CInstrumentRegions::CopyRegion(short nSrcLayer, short nSrcStartNote, short nCopyLayer, short nCopyStartNote,
	CRegion **ppRegion)
{
	CRegion* pRegion = m_pInstrument->m_Regions.FindRegionFromMap(nSrcLayer, nSrcStartNote);
	if(pRegion == NULL)
		return E_FAIL;

	short nSrcEndNote = pRegion->m_rRgnHeader.RangeKey.usHigh;
	short nCopyEndNote = nCopyStartNote + abs(nSrcEndNote - nSrcStartNote);
	nCopyEndNote = nCopyEndNote > 127 ? 127 : nCopyEndNote;
	
	CRegion* pCopiedRegion;
	if(FAILED(InsertRegion(NULL, nCopyLayer, nCopyStartNote, nCopyEndNote, false, &pCopiedRegion)))
		return E_FAIL;

	if (ppRegion)
		*ppRegion = pCopiedRegion;

	// Copy all the properties for the region
	return pCopiedRegion->CopyProperties(pRegion);
}

/* duplicates a region into a new layer, returning the new region in ppRegion */
HRESULT CInstrumentRegions::CopyRegion(CRegion *pOldRegion, CRegion **ppNewRegion)
{
	ASSERT(m_pInstrument);

	// find first empty layer
	int nLayer = 0;
	while (!m_pInstrument->m_Regions.IsLayerEmpty(nLayer))
		nLayer++;

	CRegion* pNewRegion;
	if(FAILED(InsertRegion(NULL, nLayer, pOldRegion->GetRangeValue(false), pOldRegion->GetRangeValue(true), true, &pNewRegion)))
		return E_FAIL;
	ASSERT(pNewRegion);
	
	if (*ppNewRegion)
		*ppNewRegion = pNewRegion;

	// Copy all the properties for the region
	return pNewRegion->CopyProperties(pOldRegion);
}


/* get number of regions included in this collection, counting each mono channel separately */
LONG CInstrumentRegions::GetChannelCount()
{
	LONG cChannels = 0;
	CRegion* pRegion = GetHead();
	while (pRegion)
		{
		cChannels += pRegion->GetChannelCount();
		pRegion = pRegion->GetNext();
		}
	return cChannels;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\DLSDesigner\InstrumentRegions.h ===
#ifndef __INSTRUMENTREGIONS_H__
#define __INSTRUMENTREGIONS_H__

// InstrumentRegions.h : header file
//

#include "alist.h"

#define MINIMUM_LAYERS	4

class CRegion;
class CInstrument;

class CInstrumentRegions : public AList, public IDMUSProdNode, public IDMUSProdSortNode
{
friend class CInstrument;
friend class CDLSComponent;

public:
	void ValidateUIA();
	void SetDrumArticulation();
    CInstrumentRegions();
	~CInstrumentRegions();

	enum { SIZE_OF_NOTE_MAP = 128 }; 
	
	//	AList overrides
    CRegion *GetHead();
    CRegion *RemoveHead();
	void Remove(CRegion *pRegion);
	void AddTail(CRegion *pRegion);

    // IUnknown functions
    HRESULT STDMETHODCALLTYPE QueryInterface( REFIID riid, LPVOID *ppv );
    ULONG STDMETHODCALLTYPE AddRef();
    ULONG STDMETHODCALLTYPE Release();

    // IDMUSProdNode functions
	HRESULT STDMETHODCALLTYPE GetNodeImageIndex( short* pnNbrFirstImage );

    HRESULT STDMETHODCALLTYPE GetComponent( IDMUSProdComponent** ppIComponent );
    HRESULT STDMETHODCALLTYPE GetDocRootNode( IDMUSProdNode** ppIDocRootNode );
    HRESULT STDMETHODCALLTYPE SetDocRootNode( IDMUSProdNode* pIDocRootNode );
    HRESULT STDMETHODCALLTYPE GetParentNode( IDMUSProdNode** ppIParentNode );
    HRESULT STDMETHODCALLTYPE SetParentNode( IDMUSProdNode* pIParentNode );
    HRESULT STDMETHODCALLTYPE GetNodeId( GUID* pguid );
    HRESULT STDMETHODCALLTYPE GetNodeName( BSTR* pbstrName );
    HRESULT STDMETHODCALLTYPE GetNodeNameMaxLength( short* pnMaxLength );
    HRESULT STDMETHODCALLTYPE ValidateNodeName( BSTR bstrName );
    HRESULT STDMETHODCALLTYPE SetNodeName( BSTR bstrName );

    HRESULT STDMETHODCALLTYPE GetEditorClsId(CLSID* pclsid);
    HRESULT STDMETHODCALLTYPE GetEditorTitle(BSTR* pbstrTitle);
    HRESULT STDMETHODCALLTYPE GetEditorWindow(HWND* hWndEditor);
    HRESULT STDMETHODCALLTYPE SetEditorWindow(HWND hWndEditor);

	HRESULT STDMETHODCALLTYPE UseOpenCloseImages( BOOL* pfUseOpenCloseImages );

    HRESULT STDMETHODCALLTYPE GetRightClickMenuId(HINSTANCE* phInstance, UINT* pnResourceId);
    HRESULT STDMETHODCALLTYPE OnRightClickMenuInit(HMENU hMenu);
    HRESULT STDMETHODCALLTYPE OnRightClickMenuSelect(long lCommandId);

    HRESULT STDMETHODCALLTYPE DeleteChildNode( IDMUSProdNode* pIChildNode, BOOL fPromptUser );
    HRESULT STDMETHODCALLTYPE InsertChildNode( IDMUSProdNode* pIChildNode );
    HRESULT STDMETHODCALLTYPE DeleteNode( BOOL fPromptUser );

	HRESULT STDMETHODCALLTYPE GetFirstChild(IDMUSProdNode** ppIFirstChildNode);
	HRESULT STDMETHODCALLTYPE GetNextChild(IDMUSProdNode* pIChildNode, IDMUSProdNode** ppINextChildNode);
	HRESULT STDMETHODCALLTYPE GetNodeListInfo(DMUSProdListInfo* pListInfo);

	HRESULT STDMETHODCALLTYPE OnNodeSelChanged( BOOL fSelected );
    // IDMUSProdNode : drag & drop methods
	HRESULT STDMETHODCALLTYPE CreateDataObject( IDataObject** ppIDataObject );
	HRESULT STDMETHODCALLTYPE CanCut();
	HRESULT STDMETHODCALLTYPE CanCopy();
	HRESULT STDMETHODCALLTYPE CanDelete();
	HRESULT STDMETHODCALLTYPE CanDeleteChildNode( IDMUSProdNode* pIChildNode );
	HRESULT STDMETHODCALLTYPE CanPasteFromData( IDataObject* pIDataObject, BOOL* pfWillSetReference );
	HRESULT STDMETHODCALLTYPE PasteFromData( IDataObject* pIDataObject );
	HRESULT STDMETHODCALLTYPE CanChildPasteFromData( IDataObject* pIDataObject, IDMUSProdNode* pIChildNode, BOOL* pfWillSetReference );
	HRESULT STDMETHODCALLTYPE ChildPasteFromData( IDataObject* pIDataObject, IDMUSProdNode* pIChildNode );

	HRESULT STDMETHODCALLTYPE GetObject( REFCLSID rclsid, REFIID riid, void** ppvObject );

	// IDMUSProdSortNode : Sorting interface
	HRESULT STDMETHODCALLTYPE CompareNodes(IDMUSProdNode* pINode1, IDMUSProdNode* pINode2, int* pnResult);

	// Additional functions.
	HRESULT Load(IDMUSProdRIFFStream* pIRiffStream, MMCKINFO* pckMain);

	/* creates a new region */
	HRESULT InsertRegion(IDMUSProdNode* pIChildNode, int nLayer, USHORT lowerNote,
		USHORT upperNote, bool bInsertIntoKeyboard = true, CRegion **pRegion = NULL);

	void	GetNextFreeNote(USHORT& usLayer, int& nNote);
	
	HRESULT	 FindRegionsForNote(short nNote, CPtrList* plstRegions);
	CRegion* FindRegionFromMap(short nLayer, short nStartNote);
	CRegion* FindRegionFromMap(int nNote);
	HRESULT	 FindPlayingRegions(USHORT nPlayNote, USHORT usVelocity, CPtrList* plstRegions);
	
	int		GetNumberOfLayers();
	void	SetNumberOfLayers(int nLayers);
	BOOL	IsLayerEmpty(int nLayer);

	/* copies a region, optionally returns the new region in ppRegion */
	HRESULT	CopyRegion(short nSrcLayer, short nSrcStartNote, short nCopyLayer, short nCopyStartNote, CRegion **ppRegion = NULL);

	/* duplicates a region into a new layer, returning the new region in ppRegion */
	HRESULT CopyRegion(CRegion *pOldRegion, CRegion **ppNewRegion);

	/* get number of regions included in this collection, counting each mono channel separately */
	LONG	GetChannelCount();

private:
    DWORD			m_dwRef;
	IDMUSProdNode*	m_pIRootNode;
	IDMUSProdNode*	m_pIParentNode;

	CDLSComponent*	m_pDLSComponent;	
	CInstrument*	m_pInstrument;
	int				m_nNumberOfLayers;						// Total number of layers
};

#endif // __INSTRUMENTREGIONS_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\DLSDesigner\LFODialog.h ===
#if !defined(AFX_LFODIALOG_H__044108C2_EBC5_11D0_876A_00AA00C08146__INCLUDED_)
#define AFX_LFODIALOG_H__044108C2_EBC5_11D0_876A_00AA00C08146__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// LFODialog.h : header file
//

#include "resource.h"
#include "myslider.h"
#include "DLSLoadSaveUtils.h"

/////////////////////////////////////////////////////////////////////////////
// CLFODialog dialog

class CArticulation;
class CCollection;

class CLFODialog : public CDialog, CSliderCollection
{
// Construction
public:
	CLFODialog(CArticulation* p_Articulation);
	void UpdateArticulation(CArticulation* pNewArt);

// Dialog Data
	//{{AFX_DATA(CLFODialog)
	enum { IDD = IDD_LFO_PAGE };
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CLFODialog)
	protected:
	virtual BOOL OnCommand(WPARAM wParam, LPARAM lParam);
	virtual BOOL OnNotify(WPARAM wParam, LPARAM lParam, LRESULT* pResult);
	//}}AFX_VIRTUAL

	// CSliderCollection overrides
	virtual bool OnSliderUpdate(MySlider *pms, DWORD dwmscupdf);

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CLFODialog)
	afx_msg void OnHScroll(UINT nSBCode, UINT nPos, CScrollBar* pScrollBar);
	virtual BOOL OnInitDialog();
	afx_msg void OnDestroy();
	afx_msg void OnPaint();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

private:
	HRESULT			SaveUndoState(UINT uStringRes);
	void			CollectStatics();
	void			EnableDLS2Controls(BOOL bEnable = TRUE);
	void			UpdateInstrument();

	CPtrList		m_lstStatics;	// List of static controls in the dialog

	CCollection*	m_pCollection;	
	ArticParams*	m_pArticParams;
	LFOParams		m_LFOParams;
	CArticulation*	m_pArticulation;
    
	MySlider*		m_pmsLFOFrequency;
    MySlider*		m_pmsLFODelay;
    MySlider*		m_pmsLFOVolumeScale;
    MySlider*		m_pmsLFOPitchScale;
    MySlider*		m_pmsLFOMWToVolume;
    MySlider*		m_pmsLFOMWToPitch;
	MySlider*		m_pmsLFOChanPressToPitch;
	MySlider*		m_pmsLFOChanPressToGain;
	MySlider*		m_pmsLFOChanPressToFc;
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_LFODIALOG_H__044108C2_EBC5_11D0_876A_00AA00C08146__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\DLSDesigner\LFODialog.cpp ===
// LFODialog.cpp : implementation file
//

#include "stdafx.h"
#include "LFODialog.h"
#include "Collection.h"
#include "Instrument.h"
#include "Region.h"
#include "DLSStatic.h"
#include "InstrumentFVEditor.h"
#include "Articulation.h"
#include "DlsDefsPlus.h"
#include "UndoMan.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CLFODialog dialog

CLFODialog::CLFODialog(CArticulation* pArticulation)
		  : CDialog(), CSliderCollection(9),
		    m_pArticParams(pArticulation->GetArticParams()),
		    m_pCollection(NULL)
{
	m_pArticulation = pArticulation;

#ifdef _DEBUG	
	pArticulation->ValidateParent();
#endif

	CInstrument* pInstrument = pArticulation->GetInstrument();
	if(pInstrument)
	{
		// Articulation is owned by an instrument			
		m_pCollection = pInstrument->m_pCollection;
	}
	else
	{
		// Articulation is owned by a region
		CRegion* pRegion = pArticulation->GetRegion();
		ASSERT(pRegion);
		pInstrument = pRegion->GetInstrument();
		ASSERT(pInstrument);
		m_pCollection = pInstrument->m_pCollection;
	}
	CSliderCollection::Init(this);
	//{{AFX_DATA_INIT(CLFODialog)
	//}}AFX_DATA_INIT
}

BEGIN_MESSAGE_MAP(CLFODialog, CDialog)
	//{{AFX_MSG_MAP(CLFODialog)
	ON_WM_HSCROLL()
	ON_WM_DESTROY()
	ON_WM_PAINT()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CLFODialog message handlers

void CLFODialog::OnHScroll(UINT nSBCode, UINT nPos, CScrollBar* pScrollBar) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	ASSERT(m_pArticParams);
	if(m_pArticParams == NULL)
	{
		return;
	}

	CSliderCollection::OnHScroll(nSBCode, nPos, pScrollBar);
	CDialog::OnHScroll(nSBCode, nPos, pScrollBar);
}

BOOL CLFODialog::OnInitDialog() 
{
	CDialog::OnInitDialog();
	m_LFOParams = m_pArticParams->m_LFO;
	m_pmsLFOFrequency = Insert(
		IDC_LFO_FREQUENCY,
		IDC_LFO_DFREQUENCY,
		IDC_LFO_FREQUENCY_SPIN,
		MYSLIDER_LFORANGE,
		FIVE_HERTZ,
		IDS_LFO_FREQ_UNDO_TEXT,
		&m_LFOParams.m_pcFrequency);

	m_pmsLFODelay = Insert(
		IDC_LFO_DELAY,
		IDC_LFO_DDELAY,
		IDC_LFO_DELAY_SPIN,
		MYSLIDER_LFODELAY,
		Mils2TimeCents(0),
		IDS_LFO_DELAY_UNDO_TEXT,
		&m_LFOParams.m_tcDelay);
   
	m_pmsLFOVolumeScale = Insert(
		IDC_LFO_VOLUME,
		IDC_LFO_DVOLUME,
		IDC_LFO_VOLUME_SPIN,
		MYSLIDER_VOLUMECENTS,
		0,
		IDS_LFO_VOLUME_UNDO_TEXT,
		&m_LFOParams.m_gcVolumeScale);

	m_pmsLFOPitchScale = Insert(
		IDC_LFO_PITCH,
		IDC_LFO_DPITCH,
		IDC_LFO_PITCH_SPIN,
		MYSLIDER_PITCHCENTS,
		0,
		IDS_LFO_PITCH_UNDO_TEXT,
		&m_LFOParams.m_pcPitchScale);

	m_pmsLFOMWToVolume = Insert(
		IDC_LFO_MW2VOLUME,
		IDC_LFO_DMW2VOLUME,
		IDC_LFO_MW2VOLUME_SPIN,
		MYSLIDER_VOLUMECENTS,
		0,
		IDS_MW2VOL_UNDO_TEXT,
		&m_LFOParams.m_gcMWToVolume);

	m_pmsLFOMWToPitch = Insert(
		IDC_LFO_MW2PITCH,
		IDC_LFO_DMW2PITCH, 
		IDC_LFO_MW2PITCH_SPIN,
		MYSLIDER_PITCHCENTS,
		0,
		IDS_MW2PITCH_UNDO_TEXT,
		&m_LFOParams.m_pcMWToPitch);

	m_pmsLFOChanPressToGain = Insert(
		IDC_LFO_CHANPRESSTOGAIN,
		IDC_LFO_DCHANPRESSTOGAIN, 
		IDC_LFO_CHANPRESSTOGAIN_SPIN,
		MYSLIDER_VOLUMECENTS,
		0,
		IDS_UNDO_LFO_CHANPRESSTOGAIN_EDIT,
		&m_LFOParams.m_gcChanPressToGain);

	m_pmsLFOChanPressToPitch = Insert(
		IDC_LFO_CHANPRESSTOPITCH,
		IDC_LFO_DCHANPRESSTOPITCH, 
		IDC_LFO_CHANPRESSTOPITCH_SPIN,
		MYSLIDER_PITCHCENTS,
		0,
		IDS_UNDO_LFO_CHANPRESSTOPITCH_EDIT,
		&m_LFOParams.m_pcChanPressToPitch);

	m_pmsLFOChanPressToFc = Insert(
		IDC_LFO_CHANPRESSTOFC,
		IDC_LFO_DCHANPRESSTOFC, 
		IDC_LFO_CHANPRESSTOFC_SPIN,
		MYSLIDER_FILTERPITCHCENTS,
		0,
		IDS_UNDO_LFO_CHANPRESSTOFC_EDIT,
		&m_LFOParams.m_pcChanPressToFc);

	CollectStatics();

	BOOL bDLS1 = m_pArticulation->IsDLS1();
	EnableDLS2Controls(!bDLS1);

	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

HRESULT CLFODialog::SaveUndoState(UINT uStringRes)
{
	CInstrumentFVEditor* pParent = (CInstrumentFVEditor*) GetParent();
	ASSERT(pParent);

	if(pParent && pParent->m_pInstrument)
	{
		if(FAILED(pParent->m_pInstrument->SaveStateForUndo(uStringRes)))
			return E_FAIL;
	}
	else
		return E_FAIL;

	return S_OK;
}

void CLFODialog::UpdateArticulation(CArticulation* pNewArt)
{
	m_pArticParams = pNewArt->GetArticParams();

	m_pArticulation = pNewArt;
#ifdef _DEBUG	
	pNewArt->ValidateParent();
#endif

	CInstrument* pInstrument = pNewArt->GetInstrument();
	if(pInstrument)
	{
		// Articulation is owned by an instrument			
		m_pCollection = pInstrument->m_pCollection;
	}
	else
	{
		// Articulation is owned by a region
		CRegion* pRegion = pNewArt->GetRegion();
		ASSERT(pRegion);
		pInstrument = pRegion->GetInstrument();
		ASSERT(pInstrument);
		m_pCollection = pInstrument->m_pCollection;
	}

	m_LFOParams = m_pArticParams->m_LFO;
	m_pmsLFOFrequency->SetValue(this, m_LFOParams.m_pcFrequency);
	m_pmsLFODelay->SetValue(this, m_LFOParams.m_tcDelay);
	m_pmsLFOVolumeScale->SetValue(this, m_LFOParams.m_gcVolumeScale);
	m_pmsLFOPitchScale->SetValue(this, m_LFOParams.m_pcPitchScale);
	m_pmsLFOMWToVolume->SetValue(this, m_LFOParams.m_gcMWToVolume);
	m_pmsLFOMWToPitch->SetValue(this, m_LFOParams.m_pcMWToPitch);
	m_pmsLFOChanPressToGain->SetValue(this, m_LFOParams.m_gcChanPressToGain);
	m_pmsLFOChanPressToPitch->SetValue(this, m_LFOParams.m_pcChanPressToPitch);
	m_pmsLFOChanPressToFc->SetValue(this, m_LFOParams.m_pcChanPressToFc);

	BOOL bDLS1 = m_pArticulation->IsDLS1();
	EnableDLS2Controls(!bDLS1);
}

void CLFODialog::CollectStatics()
{
	// Remove all previous statics....should there be any?
	while(!m_lstStatics.IsEmpty())
	{
		CDLSStatic* pStatic = (CDLSStatic*) m_lstStatics.RemoveHead();
		ASSERT(pStatic);
		if(pStatic)
		{
			delete pStatic;
		}
	}
	
	CWnd* pChild = GetWindow(GW_CHILD);
	while(pChild)
	{
		char szClassName[MAX_PATH];
		::GetClassName(pChild->m_hWnd, szClassName, MAX_PATH);
		
		// Add it to the list if it's a "Static"
		if(strcmp(szClassName,"Static") == 0)
		{
			CDLSStatic* pDLSStatic = NULL;
			if(SUCCEEDED(CDLSStatic::CreateControl(this, pChild, &pDLSStatic)))
				m_lstStatics.AddTail(pDLSStatic);
		}

		pChild = pChild->GetNextWindow();
	}

	// Destroy the actual static controls now
	POSITION position = m_lstStatics.GetHeadPosition();
	while(position)
	{
		CDLSStatic* pStatic = (CDLSStatic*) m_lstStatics.GetNext(position);
		ASSERT(pStatic);
		CWnd* pWnd = GetDlgItem(pStatic->GetID());
		if(pWnd)
		{
			pWnd->DestroyWindow();
		}
	}
}


void CLFODialog::OnDestroy() 
{
	CDialog::OnDestroy();
	
	// Remove all previous statics....should there be any?
	while(!m_lstStatics.IsEmpty())
	{
		CDLSStatic* pStatic = (CDLSStatic*) m_lstStatics.RemoveHead();
		ASSERT(pStatic);
		if(pStatic)
		{
			delete pStatic;
		}
	}
}

void CLFODialog::OnPaint() 
{
	CPaintDC dc(this); // device context for painting
	
	POSITION position = m_lstStatics.GetHeadPosition();
	while(position)
	{
		CDLSStatic* pStatic = (CDLSStatic*) m_lstStatics.GetNext(position);
		ASSERT(pStatic);
		pStatic->OnDraw(&dc);
	}
}

void CLFODialog::EnableDLS2Controls(BOOL bEnable)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if (m_pmsLFOChanPressToGain)
		{
		m_pmsLFOChanPressToGain->EnableControl(this, bEnable != 0);
		m_pmsLFOChanPressToPitch->EnableControl(this, bEnable != 0);
		m_pmsLFOChanPressToFc->EnableControl(this, bEnable != 0);
		}
}

BOOL CLFODialog::OnCommand(WPARAM wParam, LPARAM lParam) 
{
	LRESULT lResult;
	if (CSliderCollection::OnCommand(wParam, lParam, &lResult))
		return lResult;

	return CDialog::OnCommand(wParam, lParam);
}

BOOL CLFODialog::OnNotify(WPARAM wParam, LPARAM lParam, LRESULT* pResult) 
{
	LRESULT lResult;
	if (CSliderCollection::OnNotify(wParam, lParam, &lResult))
		return lResult;
	
	return CDialog::OnNotify(wParam, lParam, pResult);
}

void CLFODialog::UpdateInstrument()
{
	m_pArticParams->m_LFO = m_LFOParams;
	CInstrument* pInstrument = m_pArticulation->GetInstrument();

	if(pInstrument)
	{
		pInstrument->UpdateInstrument();
		if(pInstrument->m_pCollection)
		{
			pInstrument->m_pCollection->SetDirtyFlag();
		}
	}
	else if (m_pArticulation->GetRegion())
	{
		CRegion* pRegion = m_pArticulation->GetRegion();
		ASSERT(pRegion);
		pInstrument = pRegion->GetInstrument();
		ASSERT(pInstrument);
		pInstrument->UpdateInstrument();
		if(pInstrument->m_pCollection)
		{
			pInstrument->m_pCollection->SetDirtyFlag();
		}
	}
}

bool CLFODialog::OnSliderUpdate(MySlider *pms, DWORD dwmscupdf)
{
	switch (dwmscupdf)
		{
		case dwmscupdfStart:
			if (SUCCEEDED(SaveUndoState(pms->GetUndoStringID())))
				return true;
			UpdateArticulation(m_pArticulation);
			return false;

		case dwmscupdfEnd:
			UpdateInstrument();
			return true;

		default:
			ASSERT(FALSE);
			return false;
		}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\DLSDesigner\NameUnknownQueryDialog.cpp ===
// NameUnknownQueryDialog.cpp : implementation file
//

#include "stdafx.h"
#include "dlsdesigner.h"
#include "DLSComponent.h"
#include "NameUnknownQueryDialog.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CNameUnknownQueryDialog dialog


CNameUnknownQueryDialog::CNameUnknownQueryDialog(CWnd* pParent /*=NULL*/, CDLSComponent* pComponent)
	: CDialog(CNameUnknownQueryDialog::IDD, pParent), m_pComponent(pComponent)
{
	ASSERT(pComponent);

	//{{AFX_DATA_INIT(CNameUnknownQueryDialog)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT
}


void CNameUnknownQueryDialog::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CNameUnknownQueryDialog)
	DDX_Control(pDX, IDC_QUERY_NAME_EDIT, m_QueryNameEdit);
	DDX_Control(pDX, IDC_QUERY_GUID_STATIC, m_QueryGUIDStatic);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CNameUnknownQueryDialog, CDialog)
	//{{AFX_MSG_MAP(CNameUnknownQueryDialog)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CNameUnknownQueryDialog message handlers

BOOL CNameUnknownQueryDialog::OnInitDialog() 
{
	CDialog::OnInitDialog();
	SetGUIDString();
	
	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

void CNameUnknownQueryDialog::SetQueryGUID(const GUID& guidQuery)
{
	m_guidQuery = guidQuery;
}

void CNameUnknownQueryDialog::SetGUIDString()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	ASSERT(m_pComponent);

	LPOLESTR psz;
	if( SUCCEEDED( ::StringFromIID(m_guidQuery, &psz) ) )
	{
		TCHAR szGuid[100];
		WideCharToMultiByte( CP_ACP, 0, psz, -1, szGuid, sizeof(szGuid), NULL, NULL );
		CoTaskMemFree( psz );
		
		m_QueryGUIDStatic.SetWindowText(szGuid);
	}
}

void CNameUnknownQueryDialog::OnOK() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	ASSERT(m_pComponent);
	if(m_pComponent == NULL)
	{
		CDialog::OnOK();
		return;
	}

	m_QueryNameEdit.GetWindowText(m_sQueryName);
	
	m_sQueryName.TrimLeft();
	m_sQueryName.TrimRight();

	if(m_sQueryName.IsEmpty())
	{
		return;
	}

	int nLength = m_sQueryName.GetLength();
	for(int nIndex = 0; nIndex < nLength; nIndex++)
	{
		if(!isalnum(m_sQueryName[nIndex]))
		{
			return;
		}
	}

	// Check if the query name already exists
	GUID guidQuery;
	if(m_pComponent->IsAPresetQuery(m_sQueryName, guidQuery) == TRUE)
	{
		AfxMessageBox(IDS_ERR_QUERYNAME_CONFLICT);
		return;
	}

	
	CDialog::OnOK();
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\DLSDesigner\newwavedialog.cpp ===
// newwavedialog.cpp : implementation file
//

#include "stdafx.h"
#include "dlsdesigner.h"
#include "newwavedialog.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


CArray <DWORD, DWORD> CNewWaveDialog::m_arraySampleRate;
CString CNewWaveDialog::m_sLastSelectedRate = "22050";
bool	CNewWaveDialog::m_bLastSelected8Bit = false;
bool	CNewWaveDialog::m_bLastSelectedStereo = false;


/////////////////////////////////////////////////////////////////////////////
// CNewWaveDialog dialog

CNewWaveDialog::CNewWaveDialog(CWnd* pParent /*=NULL*/)
	: CDialog(CNewWaveDialog::IDD, pParent)
{
	//{{AFX_DATA_INIT(CNewWaveDialog)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT
}


void CNewWaveDialog::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CNewWaveDialog)
	DDX_Control(pDX, IDC_SAMPLE_RATE_COMBO, m_SampleRateCombo);
	DDX_Control(pDX, IDC_MONO_RADIOBTN, m_MonoButton);
	DDX_Control(pDX, IDC_8BITSAMPLE_RADIOBTN, m_8BitSampleButton);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CNewWaveDialog, CDialog)
	//{{AFX_MSG_MAP(CNewWaveDialog)
	ON_BN_CLICKED(IDC_16BITSAMPLE_RADIOBTN, On16bitsampleRadiobtn)
	ON_BN_CLICKED(IDC_STEREO_RADIOBTN, OnStereoRadiobtn)
	ON_BN_CLICKED(IDC_8BITSAMPLE_RADIOBTN, On8bitsampleRadiobtn)
	ON_BN_CLICKED(IDC_MONO_RADIOBTN, OnMonoRadiobtn)
	ON_CBN_KILLFOCUS(IDC_SAMPLE_RATE_COMBO, OnKillfocusSampleRateCombo)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CNewWaveDialog message handlers

BOOL CNewWaveDialog::OnInitDialog() 
{
	CDialog::OnInitDialog();

	// Init the array if it's empty
	if(m_arraySampleRate.GetSize() == 0)
	{
		for(int nIndex = 0; nIndex < DEFAULT_SAMPLERATE_COUNT; nIndex++)
		{
			DWORD dwSampleRate = atoi(arrDefaultSampleRates[nIndex]);
			m_arraySampleRate.Add(dwSampleRate);
		}
	}

	// Init the sample rates combo
	int nCount = m_arraySampleRate.GetSize();
	for(int nIndex = 0; nIndex < nCount; nIndex++)
	{
		CString sSampleRate;
		sSampleRate.Format("%d", m_arraySampleRate[nIndex]);
		m_SampleRateCombo.AddString(sSampleRate);
	}

	// Set the last selected SampleRate, SampleSize and Channel selection
	int nLastRateIndex = m_SampleRateCombo.FindStringExact(0, m_sLastSelectedRate);
	if(nLastRateIndex == CB_ERR)
	{
		nLastRateIndex = m_SampleRateCombo.AddString(m_sLastSelectedRate);
	}
	m_SampleRateCombo.SelectString(0, m_sLastSelectedRate);

	SetSampleSizeButtons();
	SetChannelButtons();
	
	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

BOOL CNewWaveDialog::IsValidSampleRate(DWORD& dwSampleRate)
{
	CString sSampleRate = "";
	m_SampleRateCombo.GetWindowText(sSampleRate);
	dwSampleRate = atoi((LPCSTR)sSampleRate);

	if(dwSampleRate < 3000 || dwSampleRate > 88000)
	{
		dwSampleRate = dwSampleRate < 3000 ? 3000 : 88000;
		CString sSampleRate;
		sSampleRate.Format("%d", dwSampleRate);
		m_SampleRateCombo.SetWindowText(sSampleRate);
		return FALSE;
	}

	return TRUE;
}

void CNewWaveDialog::OnOK() 
{
	
	m_bLastSelected8Bit = (m_8BitSampleButton.GetCheck() != 0);
	m_bLastSelectedStereo = (m_MonoButton.GetCheck() == 0);

	DWORD dwSampleRate = 0;
	if(IsValidSampleRate(dwSampleRate) == false)
		return;

	m_sLastSelectedRate.Format("%d", dwSampleRate);

	
	CDialog::OnOK();
}

void CNewWaveDialog::On16bitsampleRadiobtn() 
{
	m_bLastSelected8Bit = false;
	SetSampleSizeButtons();
}

void CNewWaveDialog::OnStereoRadiobtn() 
{
	m_bLastSelectedStereo = true;
	SetChannelButtons();
}

void CNewWaveDialog::SetSampleSizeButtons()
{
	m_8BitSampleButton.SetCheck(m_bLastSelected8Bit);
	CButton* pButton = (CButton*)GetDlgItem(IDC_16BITSAMPLE_RADIOBTN);
	pButton->SetCheck(!m_bLastSelected8Bit);
}

void CNewWaveDialog::SetChannelButtons()
{
	m_MonoButton.SetCheck(!m_bLastSelectedStereo);
	CButton* pButton = (CButton*)GetDlgItem(IDC_STEREO_RADIOBTN);
	pButton->SetCheck(m_bLastSelectedStereo);
}

void CNewWaveDialog::On8bitsampleRadiobtn() 
{
	m_bLastSelected8Bit = true;
	SetSampleSizeButtons();
}

void CNewWaveDialog::OnMonoRadiobtn() 
{
	m_bLastSelectedStereo = false;
	SetChannelButtons();
}

void CNewWaveDialog::OnKillfocusSampleRateCombo() 
{
	CString sSampleRate = "";
	m_SampleRateCombo.GetWindowText(sSampleRate);
	DWORD dwSampleRate = atoi((LPCSTR)sSampleRate);

	if(dwSampleRate < 3000 || dwSampleRate > 88000)
	{
		dwSampleRate = dwSampleRate < 3000 ? 3000 : 88000;
		CString sSampleRate;
		sSampleRate.Format("%d", dwSampleRate);
		m_SampleRateCombo.SetWindowText(sSampleRate);
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\DLSDesigner\MonoWave.cpp ===
//////////////////////////////////////////////////////////////////////
//
// MonoWave.cpp : implementation file
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include <mmsystem.h>
#include <mmreg.h>
#include <msacm.h>
#include "DLSDesignerDLL.h"
#include "WaveNode.h"
#include "Wave.h"
#include "WaveDataManager.h"
#include "StereoWave.h"
#include "MonoWave.h"
#include "Region.h"
#include "Collection.h"
#include "DLSLoadSaveUtils.h"
#include "WavePropPgMgr.h"
#include "WavePropPg.h"
#include "WaveInfoPropPg.h"
#include "WaveCompressionPropPage.h"
#include "stream.h"
#include "Instrument.h"
#include "Wavectl.h"
#include "DlsDefsPlus.h"
#include "CollectionInstruments.h"



#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


//////////////////////////////////////////////////////////////////////
//
//	CMonoWaveDrawBuffer
//
//////////////////////////////////////////////////////////////////////
CMonoWaveDrawBuffer::CMonoWaveDrawBuffer(BYTE mwdbType):
	m_mwdbType(mwdbType),
	m_pMonoWave(NULL),
	m_pMonoWaveDrawBuffer(NULL),
	m_pbBuffer(NULL),
	m_nSamplesPerPixel(0),
	m_wBytesPerSample(0)
{}

CMonoWaveDrawBuffer::~CMonoWaveDrawBuffer()
{
	if (m_pbBuffer)
		delete[] m_pbBuffer;
}

/* data will be built from wave file */
void CMonoWaveDrawBuffer::Init(int nSamplesPerPixel, CMonoWave* pMonoWave)
{
	ASSERT((m_pMonoWave == NULL) && (m_pMonoWaveDrawBuffer == NULL)); // only one Init should be called
	ASSERT(pMonoWave);
	m_nSamplesPerPixel = nSamplesPerPixel;
	m_pMonoWave = pMonoWave;
}

/* data will be built from another zoom object */
void CMonoWaveDrawBuffer::Init(int nSamplesPerPixel, CMonoWaveDrawBuffer* pMonoWaveDrawBuffer)
{
	ASSERT((m_pMonoWave == NULL) && (m_pMonoWaveDrawBuffer == NULL)); // only one Init should be called
	ASSERT(pMonoWaveDrawBuffer);
	ASSERT(pMonoWaveDrawBuffer->GetSamplesPerPixel() < nSamplesPerPixel); // draw buffer doesn't have enough detail for us
	ASSERT(pMonoWaveDrawBuffer->GetType() == m_mwdbType);	// cannot compute from a buffer of a different type
	m_nSamplesPerPixel = nSamplesPerPixel;
	m_pMonoWaveDrawBuffer = pMonoWaveDrawBuffer;
}

/* ensures the buffer is filled from dwStartSample to a length of dwDrawLength. Returns
	pointer to buffer, and offsets to start and stop reading within the buffer. */
HRESULT	CMonoWaveDrawBuffer::Get(DWORD dwSampleStart, DWORD dwDrawLength,
	BYTE **ppbBuffer, DWORD *pdwBufferLength)
{
	ASSERT((m_pMonoWave != NULL) || (m_pMonoWaveDrawBuffer != NULL)); // Init must have been called
	ASSERT(ppbBuffer);
	ASSERT(pdwBufferLength);
	ASSERT(m_nSamplesPerPixel > 0);

	// set critical section
	HRESULT hr;
	CRITICAL_SECTION *pcs = GetCriticalSection();
	EnterCriticalSection(pcs);

	// get bytes per sample
	m_wBytesPerSample = GetBytesPerSample();

	// if empty wave, return immediately
	DWORD cSamplesInWave = GetWaveLength();
	if (cSamplesInWave == 0)
		{
		*ppbBuffer = NULL;
		*pdwBufferLength = 0;
		hr = S_OK;
		goto LExit;
		}
	
	// cap arguments
	if (dwSampleStart > cSamplesInWave)
		dwSampleStart = cSamplesInWave;
	if (dwSampleStart+dwDrawLength > cSamplesInWave)
		dwDrawLength = cSamplesInWave-dwSampleStart;

	// compute desired start and end positions
	DWORD dwUnitStart, dwUnitEnd, cUnits;
	dwUnitStart = dwSampleStart / m_nSamplesPerPixel;
	dwUnitEnd = (dwSampleStart + dwDrawLength) / m_nSamplesPerPixel;
	cUnits = dwUnitEnd - dwUnitStart;

	// destroy buffer now if it needs to be grown
	if ((m_pbBuffer != NULL) && (cUnits > m_cUnits))
		{
		delete[] m_pbBuffer;
		m_pbBuffer = NULL;
		}

	// build buffer if we don't have it yet
	if (m_pbBuffer == NULL)
		{
		// compute desired units, and narrow if possible to conserve memory
		m_cUnits = cSamplesInWave / m_nSamplesPerPixel;
		m_dwUnitOffset = 0;
		DWORD cUnitDesiredMax = max(2000, cSamplesInWave / 512); // our rule of thumb is to have the full buffer for 512 samples/pixel, with a minimum of a good screen's width
		if (cUnits > cUnitDesiredMax)
			cUnitDesiredMax = cUnits; // hold at least as many samples as required by caller
		if (m_cUnits > cUnitDesiredMax)
			{
			m_cUnits = cUnitDesiredMax;

			// narrowed buffer is centered on the region we're asked for
			DWORD dwUnitCenterDouble = dwUnitStart + dwUnitEnd;
			if (dwUnitCenterDouble > m_cUnits)
				m_dwUnitOffset = (dwUnitCenterDouble - m_cUnits) / 2;
			}

		// compute buffer size
		DWORD dwBufferSize = m_cUnits * m_wBytesPerSample;

		// allocate
		m_pbBuffer = new BYTE[dwBufferSize];
		if (m_pbBuffer == NULL)
			{
			hr = E_OUTOFMEMORY;
			goto LExit;
			}

		m_dwUnitStart = m_dwUnitEnd = m_dwUnitOffset;
		}

	ASSERT(m_cUnits > 0);

	// scroll or dirty buffer if necessary
	if (dwUnitStart < m_dwUnitOffset)
		{
		// scroll left
		DWORD dwDelta = m_dwUnitOffset - dwUnitStart;
		m_dwUnitOffset = dwUnitStart;
		if (dwDelta < m_cUnits)
			{
			memmove(&m_pbBuffer[dwDelta*m_wBytesPerSample], &m_pbBuffer[0], (m_cUnits-dwDelta)*m_wBytesPerSample);
			if (m_dwUnitEnd > m_dwUnitOffset+m_cUnits)
				{
				m_dwUnitEnd = m_dwUnitOffset+m_cUnits;
				if (m_dwUnitStart > m_dwUnitEnd)
					m_dwUnitStart = m_dwUnitEnd;
				}
			}
		else
			m_dwUnitStart = m_dwUnitEnd;
		}
	else if (dwUnitEnd > m_dwUnitOffset+m_cUnits)
		{
		// scroll right
		DWORD dwDelta = dwUnitEnd - (m_dwUnitOffset+m_cUnits);
		m_dwUnitOffset = dwUnitEnd - m_cUnits;
		if (dwDelta < m_cUnits)
			{
			memmove(&m_pbBuffer[0], &m_pbBuffer[dwDelta*m_wBytesPerSample], (m_cUnits-dwDelta)*m_wBytesPerSample);
			if (m_dwUnitStart < m_dwUnitOffset)
				{
				m_dwUnitStart = m_dwUnitOffset;
				if (m_dwUnitEnd < m_dwUnitStart)
					m_dwUnitEnd = m_dwUnitStart;
				}
			}
		else
			m_dwUnitStart = m_dwUnitEnd;
		}

	// fill in the data we haven't computed yet
	if (m_dwUnitStart == m_dwUnitEnd)
		{
		hr = Fill(dwUnitStart, dwUnitEnd);
		if (FAILED(hr))
			goto LExit;
		m_dwUnitStart = dwUnitStart;
		m_dwUnitEnd = dwUnitEnd;
		}
	else
		{
		if (dwUnitStart < m_dwUnitStart)
			{
			hr = Fill(dwUnitStart, m_dwUnitStart);
			if (FAILED(hr))
				goto LExit;
			m_dwUnitStart = dwUnitStart;
			}
		if (dwUnitEnd > m_dwUnitEnd)
			{
			hr = Fill(m_dwUnitEnd, dwUnitEnd);
			if (FAILED(hr))
				goto LExit;
			m_dwUnitEnd = dwUnitEnd;
			}
		}

	// we're done
	*ppbBuffer = &m_pbBuffer[(dwUnitStart-m_dwUnitOffset)*m_wBytesPerSample];
	*pdwBufferLength = dwUnitEnd-dwUnitStart;
	hr = S_OK;

LExit:
	LeaveCriticalSection(pcs);
	return hr;
}

/* fills the buffer from dwStart to dwEnd */
HRESULT CMonoWaveDrawBuffer::Fill(DWORD dwUnitStart, DWORD dwUnitEnd)
{
#ifdef _DEBUG
	ASSERT(m_pbBuffer);
	ASSERT(dwUnitStart < dwUnitEnd); // nothing to compute
	if (m_dwUnitStart != m_dwUnitEnd)
		{
		if (dwUnitStart < m_dwUnitStart)
			ASSERT(dwUnitEnd <= m_dwUnitStart); // overlap with already-computed data
		if (dwUnitEnd >= m_dwUnitEnd)
			ASSERT(dwUnitStart >= m_dwUnitEnd); // overlap with already-computed data
		}
#endif

	int nSampleStep = m_nSamplesPerPixel;
	DWORD dwSourceLength;

	// compute what data we need to get
	DWORD dwReadStart = dwUnitStart * m_nSamplesPerPixel;
	DWORD dwReadLength = (dwUnitEnd-dwUnitStart)*m_nSamplesPerPixel;
	
	BYTE* pbSource = NULL;
	if (m_pMonoWave)
		{
		// get the data from a wave

		// turn on wait cursor for slow reads
		CWaitCursor* pCursor = NULL;
		if (dwReadLength > 100000)
			pCursor = new CWaitCursor();
	
		if(FAILED(m_pMonoWave->GetChannelData(dwReadStart, dwReadLength, &pbSource)))
			return E_FAIL;
		dwSourceLength = dwReadLength;

		if (pCursor)
			delete pCursor;
		}
	else
		{
		// get the data from another buffer
		if (FAILED(m_pMonoWaveDrawBuffer->Get(dwReadStart, dwReadLength, &pbSource, &dwSourceLength)))
			return E_FAIL;
		nSampleStep /= m_pMonoWaveDrawBuffer->GetSamplesPerPixel();
		}

	// going to use dwUnitStart as an index in the buffer
	dwUnitStart -= m_dwUnitOffset;
	dwUnitEnd -= m_dwUnitOffset;

	switch (m_mwdbType)
		{
		case mwdbTypeWaveEditor:
			if (nSampleStep == 1)
				{
				// we'll draw every single sample....
				memcpy(&m_pbBuffer[dwUnitStart*m_wBytesPerSample], pbSource, dwSourceLength*m_wBytesPerSample);
				}
			else
				{
				// weed out the unwanted samples....
				if (m_wBytesPerSample == 1)
					{
					for(DWORD dwSourceSample = 0; dwSourceSample < dwSourceLength; dwSourceSample += nSampleStep)
						m_pbBuffer[dwUnitStart++] = pbSource[dwSourceSample];
					}
				else if (m_wBytesPerSample == 2)
					{
					short* pnBuffer = (short*)m_pbBuffer;
					short* pnSource = (short*)pbSource;

					for(DWORD dwSourceSample = 0; dwSourceSample < dwSourceLength; dwSourceSample += nSampleStep)
						pnBuffer[dwUnitStart++] = pnSource[dwSourceSample];
					}
				else
					{
					ASSERT(FALSE); // sample size not supported
					return E_FAIL;
					}
				}
			break;

		case mwdbTypeWaveTrack:
			{
			// search for the highest value in nSampleStep number of samples
			DWORD dwSamplesChecked = 0;
			if(m_wBytesPerSample == 2)
				{
				// Now add this sample to the draw buffer
				short* pnDrawBuffer = (short*)m_pbBuffer;
				short* pnWaveData = (short*)pbSource;

				for(DWORD dwUnit = dwUnitStart; dwUnit < dwUnitEnd; dwUnit++)
					{
					short nHighestSampleValue = 0;
					for(int nIndex = 0; nIndex < (int)nSampleStep; nIndex++)
						{
						short nSampleValue = pnWaveData[dwSamplesChecked + nIndex];
						if(abs(nSampleValue) > nHighestSampleValue)
							nHighestSampleValue = abs(nSampleValue);
						}
				
					*(pnDrawBuffer + dwUnit) = nHighestSampleValue;
					dwSamplesChecked += nSampleStep;
					}
				}
			else
				{
				ASSERT(m_wBytesPerSample == 1); // sample size not supported
				for(DWORD dwUnit = dwUnitStart; dwUnit < dwUnitEnd; dwUnit++)
					{
					int nHighestSampleValue = 0;
					for(int nIndex = 0; nIndex < (int)nSampleStep; nIndex++)
						{
						int nSampleValue = pbSource[dwSamplesChecked + nIndex];
						if(abs(nSampleValue) > nHighestSampleValue)
							nHighestSampleValue = abs(nSampleValue);
						}

					// Now add this sample to the draw buffer
					*(m_pbBuffer + dwUnit) = BYTE(nHighestSampleValue);
					dwSamplesChecked += nSampleStep;
					}
				}
			}
			break;

		default:
			ASSERT(FALSE); // wave buffer type not supported
		}

	// clean up buffer if we allocated it
	if (m_pMonoWave)	
		delete[] pbSource;

	return S_OK;
}

/* buffer is dirty and should be recomputed on next Fill call */
void CMonoWaveDrawBuffer::Dirty()
{
	// we don't deallocate our buffer, we simply mark its data as dirty
	m_dwUnitStart = m_dwUnitEnd = m_wBytesPerSample = 0;
}

/* returns the length of the referenced wave */
DWORD CMonoWaveDrawBuffer::GetWaveLength()
{
	ASSERT((m_pMonoWave != NULL) || (m_pMonoWaveDrawBuffer != NULL)); // Init must have been called
	return m_pMonoWave ?
		m_pMonoWave->GetWaveLength() :
		m_pMonoWaveDrawBuffer->GetWaveLength();
}

/* returns the number of bytes per sample */
WORD CMonoWaveDrawBuffer::GetBytesPerSample()
{
	ASSERT((m_pMonoWave != NULL) || (m_pMonoWaveDrawBuffer != NULL)); // Init must have been called
	if (m_wBytesPerSample == 0)
		m_wBytesPerSample = m_pMonoWave ?
			m_pMonoWave->m_rWaveformat.wBitsPerSample / 8 :
			m_pMonoWaveDrawBuffer->GetBytesPerSample();
	return m_wBytesPerSample;
}

/* returns the wave's critical section */
CRITICAL_SECTION* CMonoWaveDrawBuffer::GetCriticalSection()
{
	return m_pMonoWave ?
		&m_pMonoWave->m_DrawBufferCreateLock :
		m_pMonoWaveDrawBuffer->GetCriticalSection();
}


//////////////////////////////////////////////////////////////////////
//
//	CMonoWave::CMonoWave
//
//////////////////////////////////////////////////////////////////////
CMonoWave::CMonoWave(CWaveNode* pNode, DWORD dwSampleRate, UINT nSampleSize) : CWave(pNode, dwSampleRate, nSampleSize, 1), 
m_dwDLSize(0),	
m_pdbWaveTrack(NULL),
m_bStripChannelData(false),
m_bRightChannel(false),
m_pdbOptimum(NULL),
m_pdbLatest(NULL),
m_pdb(NULL),
m_nSamplesPerPixelOptimum(0)
{
	ASSERT( pNode != NULL );

    m_pnWave = NULL;

 	m_dwDataSize = 0;
    m_fReadFormat = FALSE;
    m_fReadSMPL = FALSE;
    m_fReadWSMP = FALSE;

	if(m_pDataManager == NULL)
	{
		CString sSourceFileName = m_pWaveNode->GetFileName();
		char szTempPath[MAX_PATH];
		DWORD dwSuccess = GetTempPath(MAX_PATH, szTempPath);
		m_pDataManager = new CWaveDataManager(this, sSourceFileName, szTempPath);
	}

    InitializeCriticalSection(&m_DrawBufferCreateLock);

}

CMonoWave::CMonoWave(CWaveNode* pNode, GUID guidStereoWave, bool bRightChannel, DWORD dwSampleRate, UINT nSampleSize) : CWave(pNode, dwSampleRate, nSampleSize, 1),
m_guidStereoWave(guidStereoWave), 
m_bRightChannel(bRightChannel),
m_pdbWaveTrack(NULL),
m_dwDLSize(0),	
m_bStripChannelData(false),
m_pdbOptimum(NULL),
m_pdbLatest(NULL),
m_pdb(NULL),
m_nSamplesPerPixelOptimum(0)
{
	ASSERT( pNode != NULL );

    m_pnWave = NULL;

 	m_dwDataSize = 0;
    m_fReadFormat = FALSE;
    m_fReadSMPL = FALSE;
    m_fReadWSMP = FALSE;

	if(m_pDataManager == NULL)
	{
		CString sSourceFileName = m_pWaveNode->GetFileName();
		char szTempPath[MAX_PATH];
		DWORD dwSuccess = GetTempPath(MAX_PATH, szTempPath);
		m_pDataManager = new CWaveDataManager(this, sSourceFileName, szTempPath);
	}

    InitializeCriticalSection(&m_DrawBufferCreateLock);
}


//////////////////////////////////////////////////////////////////////
//
//	CMonoWave::~CMonoWave()
//
//////////////////////////////////////////////////////////////////////
CMonoWave::~CMonoWave()
{
	ASSERT(m_pWaveNode);
	CDLSComponent* pComponent = m_pWaveNode->GetComponent();
	ASSERT(pComponent);

	if (!m_lstAllocatedBuffers.IsEmpty())
	{
		POSITION position = pComponent->m_lstDLSPortDownload.GetHeadPosition();
		while(position)
		{
			IDirectMusicPortDownload* pIDMPortDownload = pComponent->m_lstDLSPortDownload.GetNext(position);
			ASSERT(pIDMPortDownload);
			Unload(pIDMPortDownload);
		}
	}

	if (m_pdbWaveTrack)
		delete m_pdbWaveTrack;

	if (m_pdbLatest)
		delete m_pdbLatest;
	if (m_pdbOptimum)
		delete m_pdbOptimum;

    DeleteCriticalSection(&m_DrawBufferCreateLock);
}


//////////////////////////////////////////////////////////////////////
//
//	CMonoWave::Save
//
//////////////////////////////////////////////////////////////////////
HRESULT CMonoWave::Save(IDMUSProdRIFFStream* pIRiffStream, UINT wType, BOOL fFullSave)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

    ASSERT(m_pDataManager);
    if(m_pDataManager == NULL)
    {
        return E_UNEXPECTED;
    }

    // Ask the data mnager to update the uncomrpessed deltas
    if(!m_bCompressed)
    {
        if(FAILED(m_pDataManager->UpdateUncompressedDeltas()))
        {
            return E_FAIL;
        }
    }


	bool bRuntime = false;

	ASSERT(pIRiffStream);
	if(pIRiffStream == NULL)
	{
		return E_POINTER;
	}
	
	IStream* pIStream = pIRiffStream->GetStream();
	ASSERT(pIStream);
	if(pIStream == NULL)
	{
		return E_OUTOFMEMORY;
	}

	ASSERT(m_pDataManager);
	if(m_pDataManager == NULL)
	{
		return E_FAIL;
	}

	HRESULT			hr = S_OK;			
	MMCKINFO		ckMain;
	MMCKINFO		ck;
	DWORD			cb;
    DWORD           dwSaveSize;

    m_dwHeaderOffset = GetFilePos(pIStream);

    if(wType == MMIO_CREATERIFF)
    {
	    ckMain.fccType = mmioFOURCC('W','A','V','E');
    }
    else
    {
	    ckMain.fccType = FOURCC_wave;
    }
	hr = pIRiffStream->CreateChunk(&ckMain, wType);
    if(FAILED(hr))
	{
		pIStream->Release();
        return (hr);
    }

	IDMUSProdPersistInfo* pIJazzPersistInfo;
	if(SUCCEEDED(pIStream->QueryInterface(IID_IDMUSProdPersistInfo,(void**) &pIJazzPersistInfo)))
	{
		DMUSProdStreamInfo	StreamInfo;
		FileType	ftSaveType;

		pIJazzPersistInfo->GetStreamInfo(&StreamInfo);
		ftSaveType = StreamInfo.ftFileType;

		if (ftSaveType == FT_RUNTIME)
			bRuntime = true;
		
		pIJazzPersistInfo->Release();		
	}


	if(fFullSave)
	{
		
		// Write DMUS_FOURCC_GUID_CHUNK
		if(FAILED(CWave::WriteGUIDChunk(pIRiffStream)))
		{
			pIStream->Release();
			return E_FAIL; 
		}

		// Save the stereo wave information
		if(IsStereo())
		{
			ck.ckid = mmioFOURCC('w','v','s','t');
			hr = pIRiffStream->CreateChunk(&ck, 0);

			if (FAILED(hr))
			{
				pIStream->Release();
				return (hr);
			}

			// Save the flag that marks whether this is the right channel of a stereo wave
			hr = pIStream->Write((LPSTR) &(m_bRightChannel), sizeof(bool), &cb);	

			if(FAILED(hr) || cb != sizeof(bool))
			{
				pIStream->Release();
				return E_FAIL;
			}

			// Save the GUID that identifies this wave to the stereo wave
			hr = pIStream->Write((LPSTR)&(m_guidStereoWave), sizeof(GUID), &cb);
			if(FAILED(hr) || cb != sizeof(GUID))
			{
				pIStream->Release();
				return E_FAIL;
			}

			if (FAILED(pIRiffStream->Ascend(&ck, 0)))
			{
				pIStream->Release();
				return E_FAIL;
			}
		}

		
		// Compressed wave info chunk
		if(FAILED(WriteCompressionChunk(pIRiffStream, bRuntime)))
		{
			pIStream->Release();
			return E_FAIL;
		}

		// Write the 'fmt ' chunk
		if(FAILED(WriteFormat(pIRiffStream, bRuntime)))
		{
			pIStream->Release();
			return E_FAIL;
		}

		// Write the <fact-ck> if the wave is non-PCM
		if(m_bCompressed && bRuntime)
		{
			if(FAILED(WriteFACTChunk(pIRiffStream)))
			{
				pIStream->Release();
				return E_FAIL;
			}
		}
	}

	// Save the 'wavh' chunk that keeps the streaming info
	ck.ckid = DMUS_FOURCC_WAVEHEADER_CHUNK;
	hr = pIRiffStream->CreateChunk(&ck, 0);
    if (FAILED(hr))
    {
		pIStream->Release();
        return (hr);
    }

	_DMUS_IO_WAVE_HEADER waveHeader;
	if(FAILED(CWave::GetStreamingWaveHeader(&waveHeader)))
	{
		pIStream->Release();
		return E_FAIL;
	}

	hr = pIStream->Write((LPSTR)&waveHeader, sizeof(_DMUS_IO_WAVE_HEADER), &cb);
	if(FAILED(hr) || cb != sizeof(_DMUS_IO_WAVE_HEADER))
	{
		pIStream->Release();
		return E_FAIL;
	}
	
	if (FAILED(pIRiffStream->Ascend(&ck, 0)))
	{
		pIStream->Release();
		return E_FAIL;
	}


	// Save the RSMPL Info
	if(FAILED(WriteRSMPLChunk(pIRiffStream)))
	{
		pIStream->Release();
		return E_FAIL;
	}

	// Save the WSMPL Info
    ck.ckid = FOURCC_WSMP;
    hr = pIRiffStream->CreateChunk(&ck, 0);
    if (FAILED(hr))
    {
		pIStream->Release();
        return hr;
    }
    dwSaveSize = sizeof(WSMPL);
    if (m_rWSMP.cSampleLoops > 0)
    {
        dwSaveSize += sizeof(WLOOP);
        m_rWSMP.cSampleLoops = 1;
    }
    hr = pIStream->Write((LPSTR) &m_rWSMP,dwSaveSize, &cb);
    if (FAILED(pIRiffStream->Ascend(&ck, 0)) || cb != dwSaveSize)
    {
		pIStream->Release();
        return E_FAIL;
    }

	if (fFullSave)
	{
		// We position the data offset just after the chunk header
		m_dwDataOffset = GetFilePos(pIStream) + 8;

		ck.ckid = mmioFOURCC('d','a','t','a') ;
		hr = pIRiffStream->CreateChunk(&ck,0);
		if (FAILED(hr))
		{
			pIStream->Release();
			return hr;
		}

		if(bRuntime && m_bCompressed) 
		{
			UINT nExtraBytes = m_CompressedWavObj.WaveFormatEx.cbSize;
			WAVEFORMATEX* pwfxDest = NULL;
			if(FAILED(SafeAllocBuffer((BYTE**)&pwfxDest, sizeof(WAVEFORMATEX) + nExtraBytes)))
			{
				return E_OUTOFMEMORY;
			}

			CopyMemory((BYTE*)pwfxDest, &m_CompressedWavObj.WaveFormatEx, sizeof(WAVEFORMATEX));
			CopyMemory((BYTE*)pwfxDest + sizeof(WAVEFORMATEX), m_CompressedWavObj.pbExtractWaveFormatData, nExtraBytes); 

			// Save the compressed wave data
			hr = WriteCompressedData(pIStream, pwfxDest, cb);
			dwSaveSize = cb;

			delete[] pwfxDest;

		}
		else
		{
			if(m_pWaveNode->IsInACollection())
			{
				BYTE* pbData = NULL;
				if(FAILED(GetAllUncompressedChannelData(&pbData, &dwSaveSize)))
				{
					return E_FAIL;
				}
				
				if(FAILED(pIStream->Write(pbData, dwSaveSize, &cb)))
				{
					delete[] pbData;
					return E_FAIL;
				}

				delete[] pbData;
			}
			else
			{
                // This method writes down the uncompressed data and handles failures
                // So it's safe to set dwSaveSize to the bytes actually writeen down
				hr = m_pDataManager->SaveUncompressedDataToStream(pIStream, cb);
                dwSaveSize = cb;
			}
		}

		if (FAILED(hr) || cb != dwSaveSize)
		{
			pIRiffStream->Ascend(&ck, 0);
			pIStream->Release();
			return E_FAIL;
		}

		pIRiffStream->Ascend(&ck, 0);

        // Save unknown chunks
        m_UnknownChunk.Save(pIRiffStream);
		m_Info.Save(pIRiffStream);
	}

    pIRiffStream->Ascend(&ckMain, 0);
	pIStream->Release();

    return (hr);
}


HRESULT CMonoWave::ReadWVST(IStream* pIStream, MMCKINFO* pckMain)		   
{
	ASSERT(pIStream);
	if(pIStream == NULL)
	{
		return E_POINTER;
	}
	
	ASSERT(pckMain);
	if(pckMain == NULL)
	{
		return E_POINTER;
	}

	DWORD cb = 0;
	HRESULT hr = pIStream->Read(&m_bRightChannel, sizeof(bool), &cb);
	if(FAILED(hr) || cb != sizeof(bool))
	{
		return E_FAIL;
	}
	
	hr = pIStream->Read(&m_guidStereoWave, sizeof(GUID), &cb);
	if(FAILED(hr) || cb != sizeof(GUID))
	{
		return E_FAIL;
	}

	return S_OK;
}

HRESULT CMonoWave::ReadFMT(IStream* pIStream, MMCKINFO* pckMain)
{
	if(FAILED(CWave::ReadFMT(pIStream, pckMain)))
	{
		return E_FAIL;
	}

	WAVEFORMATEX* pwfxRead = &m_rWaveformat;
	if(m_bCompressed && m_bLoadingRuntime)
	{
		pwfxRead = &m_CompressedWavObj.WaveFormatEx;
	}

	// Must be a mono wave...
	if(pwfxRead->nChannels != 1 && IsStereo() == false)   // we only support mono and stereo files.
    {
        AfxMessageBox(IDS_WAVE_STEREO, MB_ICONEXCLAMATION); 
		return E_FAIL;
	}
	else if(IsStereo())
	{
		// Massage the data for the mono channel format
		pwfxRead->nChannels = 1;
		if(((pwfxRead->wBitsPerSample == 8) && (pwfxRead->nBlockAlign == 2)) ||
		  ((pwfxRead->wBitsPerSample == 16) && (pwfxRead->nBlockAlign == 4)))
		{
			pwfxRead->nBlockAlign = pwfxRead->nBlockAlign / 2;
		}
	}

	return S_OK;
}


HRESULT CMonoWave::ReadDataInfo(IStream* pIStream, MMCKINFO* pckMain)
{
	if(FAILED(CWave::ReadDataInfo(pIStream, pckMain)))
	{
		return E_FAIL;
	}

	if(IsStereo())
	{
		CStereoWave* pStereoWave = (CStereoWave*)m_pWaveNode->GetWave();
		ASSERT(pStereoWave);
		if(pStereoWave->IsTrueStereo())
		{
			m_dwDataSize /= 2;
			m_OriginalWavObj.dwDataSize = m_dwDataSize;
		}
	}

	// Compute wavelength
	m_dwWaveLength = m_dwDataSize;
	if(m_rWaveformat.wBitsPerSample == 16)
	{
		m_dwWaveLength = m_dwDataSize >> 1;
	}

	return S_OK;
}




//////////////////////////////////////////////////////////////////////
//
//	CMonoWave::Load
//
//////////////////////////////////////////////////////////////////////

HRESULT CMonoWave::Load(IDMUSProdRIFFStream* pIRiffStream, MMCKINFO* pckMain)
{
	ASSERT(m_pWaveNode);
	if(m_pWaveNode == NULL)
	{
		return E_UNEXPECTED;
	}

	if(FAILED(CWave::Load(pIRiffStream, pckMain)))
	{
		return E_FAIL;
	}

	return S_OK;
}


HRESULT CMonoWave::LoadHeader(IDMUSProdRIFFStream* pIRiffStream, MMCKINFO* pckMain)
{
	ASSERT(pIRiffStream);
	if(pIRiffStream == NULL)
	{
		return E_POINTER;
	}

	ASSERT(pckMain);
	if(pckMain == NULL)
	{
		return E_POINTER;
	}

	if(FAILED(CWave::LoadHeader(pIRiffStream, pckMain)))
	{
		return E_FAIL;
	}

	// Massage the data for the mono wave
	if(IsStereo())
	{
		// Massage the data for the mono channel format
		m_OriginalWavObj.WaveFormatEx.nChannels = 1;
		if(((m_OriginalWavObj.WaveFormatEx.wBitsPerSample == 8) && (m_OriginalWavObj.WaveFormatEx.nBlockAlign == 2)) ||
		  ((m_OriginalWavObj.WaveFormatEx.wBitsPerSample == 16) && (m_OriginalWavObj.WaveFormatEx.nBlockAlign == 4)))
		{
			m_OriginalWavObj.WaveFormatEx.nBlockAlign = m_OriginalWavObj.WaveFormatEx.nBlockAlign / 2;
            m_OriginalWavObj.WaveFormatEx.nAvgBytesPerSec = m_OriginalWavObj.WaveFormatEx.nSamplesPerSec * m_OriginalWavObj.WaveFormatEx.nBlockAlign;
		}
	}

	// Update the header stream
	// Stero waves will do their own update
	if(IsStereo() == FALSE)
	{
		if(SUCCEEDED(UpdateHeaderStream()))
		{
			m_pWaveNode->ReloadDirectSoundWave();
			NotifyWaveChange(false);
		}
	}

	return S_OK;
}


HRESULT CMonoWave::LoadData(IDMUSProdRIFFStream* pIRiffStream, MMCKINFO* pckMain)
{
	ASSERT(pIRiffStream);
	if(pIRiffStream == NULL)
	{
		return E_POINTER;
	}

	ASSERT(pckMain);
	if(pckMain == NULL)
	{
		return E_POINTER;
	}

	IStream* pIStream = pIRiffStream->GetStream();
	ASSERT(pIStream);
	if(pIStream == NULL)
	{
		return E_OUTOFMEMORY;
	}

	HRESULT hr = E_FAIL;
	MMCKINFO ck;
	ck.ckid = FOURCC_DATA;

	if(pIRiffStream->Descend(&ck, pckMain, MMIO_FINDCHUNK) == 0)
	{
		if(m_bCompressed && m_bLoadingRuntime)
		{
			hr = LoadRuntimeCompressedWave(pIStream, ck.cksize);
		}
		else
		{
			hr = LoadUncompressedOrDesignTimeWave(pIStream, ck.cksize);
		}
	}

	pIStream->Release();
	return hr;
}

HRESULT CMonoWave::LoadUncompressedOrDesignTimeWave(IStream* pIStream, DWORD dwChunkSize)
{
	ASSERT(pIStream);
	if(pIStream == NULL)
	{
		return E_POINTER;
	}

	DWORD cbRead = 0;
	HRESULT hr = S_OK;
	BYTE* pbTempDataBuffer = NULL;
	CWaveDataManager* pDataManager = NULL;

	DWORD dwDataSize = dwChunkSize;
	if(IsStereo() && m_bStripChannelData)
	{
		dwDataSize = dwDataSize / 2;
	}

	// Allocate a buffer for the wave / left channel data
	if(FAILED(hr = SafeAllocBuffer(&m_OriginalWavObj.pbData, dwDataSize)))
	{
		goto ON_ERROR;
	}

	if(FAILED(hr = SafeAllocBuffer(&pbTempDataBuffer, dwChunkSize)))
	{
		goto ON_ERROR;
	}

	/*****************************************************/
	/* TEST CALL!!! Remove the block when checking in....*/
	/*****************************************************/
	pDataManager = GetDataManager();
	ASSERT(pDataManager);

	if(FAILED(pDataManager->GetData(0, m_dwWaveLength, pbTempDataBuffer, cbRead)))
	{
		goto ON_ERROR;
	}
	/*****************************************************/

	// Compute wavelength
	if (m_rWaveformat.wBitsPerSample == 8)
	{
		m_dwWaveLength = dwDataSize;
	}
	else
	{
		m_dwWaveLength = dwDataSize >> 1;
	}


	if(m_bStripChannelData)
	{
		if(FAILED(StripChannelData(pbTempDataBuffer, dwChunkSize, m_OriginalWavObj.pbData)))
		{
			goto ON_ERROR;
		}
	}
	else
	{
		CopyMemory(m_OriginalWavObj.pbData, pbTempDataBuffer, dwDataSize);
	}

	m_dwDataSize = dwDataSize;
	m_OriginalWavObj.dwDataSize = m_dwDataSize;

	// This is what is used to show the wav
	m_pnWave = (short*)m_OriginalWavObj.pbData;

	// This might be a designtime file that has waves marked compressed 
	// So we need to update the compressed wave object
	if(m_bCompressed)
	{
		if(FAILED(CompressLoadedWaveData()))
		{
			// On failure to compress the original data to the required compressed format
			// we use the original with compression turned off
			// The user will now have to use different compression format and recompress the wave
			// Turn the compression flag off
			m_bCompressed = false;
		}
		
	}

	// Delete the temporary buffer
	if(pbTempDataBuffer)
	{
		delete[] pbTempDataBuffer;
	}

	return hr;

	// Cleanup on error
ON_ERROR:
	if(pIStream)
	{
		pIStream->Release();
	}
	pIStream->Release();
	CleanWaveObject(&m_OriginalWavObj);
	CleanWaveObject(&m_CompressedWavObj);
	CleanWaveObject(&m_DecompressedWavObj);
	if(pbTempDataBuffer)
	{
		delete[] pbTempDataBuffer;
		pbTempDataBuffer = NULL;
	}

	return hr;
}

// This method assumes that the compression format has been successfully read into
// the compressed wave object....
HRESULT CMonoWave::LoadRuntimeCompressedWave(IStream* pIStream, DWORD dwChunkSize)
{
	// No stream?
	ASSERT(pIStream);
	if(pIStream == NULL)
	{
		return E_POINTER;
	}

	// Allocate a fresh buffer for the compressed data
	m_CompressedWavObj.pbData = new BYTE[dwChunkSize];
	if(m_CompressedWavObj.pbData == NULL)
	{
		return E_OUTOFMEMORY;
	}

	// Keeps track of number of bytes read from the stream for each read attempt
	DWORD cbRead = 0;

	// Read in the data from the stream
	ZeroMemory(m_CompressedWavObj.pbData, dwChunkSize);
	HRESULT hr = pIStream->Read(m_CompressedWavObj.pbData, dwChunkSize, &cbRead);
	if(FAILED(hr) || cbRead != dwChunkSize)
	{
		AfxMessageBox(IDS_ERR_RUNTIME_UNSUPPORTED_COMPRESSION_FORMAT);
		return E_FAIL;
	}

	// Set the size of the compressed data in the wave object
	m_CompressedWavObj.dwDataSize = dwChunkSize;

	// Check if the compression format is supported 
	if(!m_CompressionManager.GetSupportedFormats(m_CompressedWavObj.WaveFormatEx.wFormatTag, this))
	{
		// Unknown format
		AfxMessageBox(IDS_ERR_RUNTIME_UNSUPPORTED_COMPRESSION_FORMAT);
		return E_FAIL; 
	}

	// Compressed wave formats may have extra information after the standard WAVEFORMATEX
	DWORD dwExtraBytes = m_CompressedWavObj.WaveFormatEx.cbSize;

	// Decompresses the data to the passed PCM format
	if(SUCCEEDED(UpdateDecompressedWave(&m_rWaveformat)))
	{
		// Clear up the old data
		CleanWaveObject(&m_OriginalWavObj);
		CopyWaveObject(&m_DecompressedWavObj, &m_OriginalWavObj);
		m_dwDataSize = m_DecompressedWavObj.dwDataSize;
	}
	else
	{
		AfxMessageBox(IDS_ERR_RUNTIME_UNSUPPORTED_COMPRESSION_FORMAT);
		return hr;
	}

	// Success!
	return S_OK;
}


// This method assumes that the original wave data has been successfuly read
HRESULT CMonoWave::CompressLoadedWaveData()
{
	// Check if the compression format is supported 
	if(!m_CompressionManager.GetSupportedFormats(m_CompressedWavObj.WaveFormatEx.wFormatTag, this))
	{
		AfxMessageBox(IDS_ERR_UNSUPPORTED_COMPRESSION_FORMAT);
		return E_FAIL;
	}

	// Non-PCM formats have extra information after standard WAVEFORMATEX struct
	DWORD dwExtraBytes = m_CompressedWavObj.WaveFormatEx.cbSize;

	// Copy the compression format
	WAVEFORMATEX* pCompressionFormat = (WAVEFORMATEX* )new BYTE[sizeof(WAVEFORMATEX) + dwExtraBytes];
	if(pCompressionFormat == NULL)
	{
		return E_OUTOFMEMORY;
	}

	ZeroMemory(pCompressionFormat, sizeof(WAVEFORMATEX) + dwExtraBytes);
	CopyMemory(pCompressionFormat, &(m_CompressedWavObj.WaveFormatEx), sizeof(WAVEFORMATEX));
	CopyMemory((char*)(pCompressionFormat) + sizeof(WAVEFORMATEX), m_CompressedWavObj.pbExtractWaveFormatData, dwExtraBytes);

	// Find out and adjust the sample loss
	DWORD dwDifference = 0;
	if(FAILED(FindSampleLoss(pCompressionFormat, dwDifference)))
	{
		if(pCompressionFormat->nChannels != 2 && m_pCollection != NULL)
		{
			AfxMessageBox(IDS_ERR_UNSUPPORTED_COMPRESSION_FORMAT);
		}

		if(pCompressionFormat)
		{
			delete[] pCompressionFormat;
		}
		
		return E_FAIL;
	}

	// Clean the wave objects (we might be here through the Undo/Redo action
	CleanWaveObject(&m_CompressedWavObj);
	CleanWaveObject(&m_DecompressedWavObj);

	// Compress the wave data to the required format
	HRESULT hr = ConvertWave(m_OriginalWavObj, pCompressionFormat, m_CompressedWavObj, true, dwDifference);
	if(SUCCEEDED(hr))
	{
		// Update the decompressed data
		hr = UpdateDecompressedWave(&(m_OriginalWavObj.WaveFormatEx));
	}
	
	// Get rid of the compression format buffer
	if(pCompressionFormat)
	{
		delete[] pCompressionFormat;
	}

	if(FAILED(hr))
	{
		AfxMessageBox(IDS_ERR_UNSUPPORTED_COMPRESSION_FORMAT);
	}

	return hr;
}


//////////////////////////////////////////////////////////////////////
//
//	CMonoWave::UpdateWave()
//
//////////////////////////////////////////////////////////////////////
HRESULT CMonoWave::UpdateWave()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);	
	HRESULT hr = S_OK;
	ASSERT(m_pWaveNode);

	CDLSComponent* pComponent = m_pWaveNode->GetComponent();
	ASSERT(pComponent);
	
	// Return if there' no valid port
	if(pComponent->m_lstDLSPortDownload.IsEmpty())
		return E_FAIL;

	POSITION position = pComponent->m_lstDLSPortDownload.GetHeadPosition();
	while(position)
	{
		IDirectMusicPortDownload* pIDMPortDownload = pComponent->m_lstDLSPortDownload.GetNext(position);		
		ASSERT(pIDMPortDownload);

        // Remember the download Id for the old port, if any
        DWORD dwDMID;
        bool fGotID = SUCCEEDED(GetDMIDForPort(pIDMPortDownload, &dwDMID));

		// unload the wave if necessary
		Unload(pIDMPortDownload);

		// nothing to download if new wave is empty
		if (m_dwWaveLength == 0)
			return S_OK;

		// initialize port, reusing the id
		if (fGotID)
			hr = DM_Init(pIDMPortDownload, dwDMID); // reuse the download id
		else
			hr = DM_Init(pIDMPortDownload); // get a new download id

		// download
		if (SUCCEEDED(hr))
			{
			// download, with wait cursor if necessary
			CWaitCursor *pcursor = (m_dwDLSize > 100000) ? new CWaitCursor() : NULL;
			hr = Download(pIDMPortDownload);
			if (pcursor)
				delete pcursor;

			if (!SUCCEEDED(hr))
				{
				// Remove the added buffer
				AllocatedPortBufferPair* pBuffer = GetAllocatedBufferForPort(pIDMPortDownload);
				ASSERT(pBuffer); // buffer should exist
				if (pBuffer)
					RemoveFromAllocatedBufferList(pBuffer);
	
				AfxMessageBox(IDS_ERR_UPDATE_DOWNLOAD, MB_OK | MB_ICONEXCLAMATION);
				}
			}
		}

	return hr;
} 

CString CMonoWave::GetName()
{
	if(IsStereo())
	{
		if(!m_bRightChannel)
			return m_Info.m_csName + "(Left)";
		else
			return m_Info.m_csName + "(Right)";
	}

	return m_Info.m_csName;
}

HRESULT CMonoWave::Size(DWORD& dwSize)
{
	HRESULT hr = S_OK;
	
	DWORD dwTotalSize = 0;
	DWORD dwOffsetCount = 0;
	
	dwSize = 0;
	__try
	{
		// Calculate the space needed for DMUS_DOWNLOADINFO 
		dwSize += CHUNK_ALIGN(sizeof(DMUS_DOWNLOADINFO));

		// Calculate the space needed for wave's copyright
		if(!m_Info.m_csCopyright.IsEmpty())
		{
			dwSize += CHUNK_ALIGN(sizeof(DMUS_COPYRIGHT));		
			
			// Add Length + 1 for null char
			dwSize += m_Info.m_csCopyright.GetLength() + 1;	
			dwOffsetCount++;
		}
		// If wave does not have one use collection's
		else if( (m_pCollection) && (!m_pCollection->m_Info.m_csCopyright.IsEmpty()) )
		{
			dwSize += CHUNK_ALIGN(sizeof(DMUS_COPYRIGHT));						
			
			// Add Length + 1 for null char
			dwSize += m_pCollection->m_Info.m_csCopyright.GetLength() + 1; 
			dwOffsetCount++;
		}
		
		// Calculate space needed for DMUS_WAVE and DMUS_WAVEDATA
		dwSize += CHUNK_ALIGN(sizeof(DMUS_WAVE)) + CHUNK_ALIGN(sizeof(DMUS_WAVEDATA));
		dwOffsetCount += 2;

		// Extra bytes that follow the WAVEFOMATEX structure
#if(0)	// For now we won't support until all compression support is implemented
		if ( m_rWaveformat.wFormatTag != WAVE_FORMAT_PCM )
		{
			//some other test?
			dwSize += m_rWaveformat.cbSize;
			dwOffsetCount++;
		}
#endif			

		// Calculate space needed for offset table
		m_cbSizeOffsetTable = CHUNK_ALIGN(dwOffsetCount * sizeof(ULONG));
		dwSize += m_cbSizeOffsetTable;

		// Compute leading data we'll skip
		DWORD cbDecompressedStart = m_bCompressed ? m_dwDecompressedStart*(m_rWaveformat.wBitsPerSample/8) : 0;

		// Calculate space needed for wave data
		// We allocated DMUS_MIN_DATA_SIZE worth when we allocated for DMUS_WAVE
		if(m_dwDataSize > DMUS_MIN_DATA_SIZE+cbDecompressedStart)
		{
			dwSize += m_dwDataSize - DMUS_MIN_DATA_SIZE - cbDecompressedStart;
		}

		dwSize = CHUNK_ALIGN(dwSize);

	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		hr = E_UNEXPECTED;
	}
	
	return hr;
}

HRESULT CMonoWave::Write(void * pvoid, IDirectMusicPortDownload* pIDMPortDownLoad)
{
	ASSERT(pvoid);
    if(pvoid == NULL)
    {
        return E_POINTER;
    }

    ASSERT(pIDMPortDownLoad);
    if(pIDMPortDownLoad == NULL)
    {
        return E_POINTER;
    }

	Size(m_dwDLSize);

	HRESULT hr = S_OK;

	__try
	{
		DWORD dwCurIndex = 0;	// Used to determine what index to store offset in Offset Table
		DWORD dwCurOffset = 0;	// Offset relative to beginning of passed in memory
		// Write DMUS_DOWNLOADINFO		
		DMUS_DOWNLOADINFO *pDLInfo = (DMUS_DOWNLOADINFO *) pvoid;

		pDLInfo->dwDLType = DMUS_DOWNLOADINFO_WAVE;
		DWORD dwDMid;
        if(FAILED(GetDMIDForPort(pIDMPortDownLoad, &dwDMid)))
        {
            return E_FAIL;
        }
        pDLInfo->dwDLId = dwDMid;

		pDLInfo->dwNumOffsetTableEntries = (m_cbSizeOffsetTable/sizeof(DWORD));
		pDLInfo->cbSize = m_dwDLSize;
		
		dwCurOffset += CHUNK_ALIGN(sizeof(DMUS_DOWNLOADINFO));

		DMUS_OFFSETTABLE* pDMOffsetTable = (DMUS_OFFSETTABLE *)(((BYTE*)pvoid) + dwCurOffset);

		// Increment pass the DMUS_OFFSETTABLE structure; we will fill the other members in later
		dwCurOffset += CHUNK_ALIGN(m_cbSizeOffsetTable);

		// First entry in ulOffsetTable is the first data chunk - the DMUS_WAVE in this case.
		pDMOffsetTable->ulOffsetTable[0] = dwCurOffset;

		dwCurIndex = 2;		// First two items are DMUS_WAVE and DMUS_WAVEDATA;

		DMUS_WAVE* pDMWave = (DMUS_WAVE*)(((BYTE*)pvoid) + dwCurOffset);
		pDMWave->ulWaveDataIdx = 1;		// Point to the DMUS_WAVEDATA chunk.

		dwCurOffset += CHUNK_ALIGN(sizeof(DMUS_WAVE));

		// download wave data
		DMUS_WAVEDATA* pDMWaveData = (DMUS_WAVEDATA*)(((BYTE*)pvoid) + dwCurOffset);
		pDMOffsetTable->ulOffsetTable[1] = dwCurOffset;
		BYTE* pbData = NULL;
		DWORD dwDecompressedStart = m_bCompressed ? m_dwDecompressedStart : 0;
		if(FAILED(GetChannelData(dwDecompressedStart, m_dwWaveLength-dwDecompressedStart, &pbData)))
			return E_FAIL;
		DWORD cbDecompressedStart = dwDecompressedStart*(m_rWaveformat.wBitsPerSample/8);
		ASSERT(m_dwDataSize >= cbDecompressedStart);
		DWORD dwDataSize = m_dwDataSize-cbDecompressedStart;
		CopyMemory(pDMWaveData->byData, pbData, dwDataSize);
		pDMWaveData->cbSize = dwDataSize;
		delete[] pbData;

		if(dwDataSize < DMUS_MIN_DATA_SIZE)
			dwCurOffset += sizeof(DMUS_WAVEDATA);
		else
			dwCurOffset += sizeof(DMUS_WAVEDATA) + dwDataSize - DMUS_MIN_DATA_SIZE;
		dwCurOffset = CHUNK_ALIGN(dwCurOffset);

		CopyMemory(&(pDMWave->WaveformatEx), &m_rWaveformat, sizeof(WAVEFORMATEX));

		// Write no extension chunks
		pDMWave->ulFirstExtCkIdx = 0;
		
		DWORD	dwStrSize=0;
		// Write copyright information
		if(!m_Info.m_csCopyright.IsEmpty())
		{
			dwStrSize = m_Info.m_csCopyright.GetLength() + 1;
			pDMOffsetTable->ulOffsetTable[dwCurIndex] = dwCurOffset;
			pDMWave->ulCopyrightIdx = dwCurIndex;
			// Copy the cbSize value
			CopyMemory((BYTE*)pvoid + dwCurOffset, &dwStrSize, sizeof(ULONG));

			// Copy the actual Copyright String
			dwCurOffset += sizeof(ULONG);
			CopyMemory((BYTE*)pvoid + dwCurOffset,m_Info.m_csCopyright.GetBuffer(0),dwStrSize);

			dwCurIndex++;
			m_Info.m_csCopyright.ReleaseBuffer();
		}
		// If instrument does not have one use collection's
		else if((m_pCollection) && (!m_pCollection->m_Info.m_csCopyright.IsEmpty()))
		{
			dwStrSize = m_pCollection->m_Info.m_csCopyright.GetLength() + 1;
			pDMOffsetTable->ulOffsetTable[dwCurIndex] = dwCurOffset;
			pDMWave->ulCopyrightIdx = dwCurIndex;

			// Copy the cbSize value
			CopyMemory((BYTE*)pvoid + dwCurOffset, &dwStrSize, sizeof(ULONG));

			// Copy the actual Copyright String
			dwCurOffset += sizeof(ULONG);
			CopyMemory((BYTE*)pvoid + dwCurOffset,m_pCollection->m_Info.m_csCopyright.GetBuffer(0),dwStrSize);

			dwCurIndex++;
			m_pCollection->m_Info.m_csCopyright.ReleaseBuffer();
		}
		else
		{
			pDMWave->ulCopyrightIdx = 0;
		}
	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		hr = E_UNEXPECTED;
	}

	if(FAILED(hr))
	{
		ZeroMemory(pvoid, m_dwDLSize);
	}
	return hr;
}

/* initializes the download port, using a new download ID */
HRESULT CMonoWave::DM_Init(IDirectMusicPortDownload* pIDMPortDownLoad)
{
	// Do nothing if we don't have a valid port to download to...
	if(pIDMPortDownLoad == NULL)
	{
		return E_FAIL;
	}

	DWORD dwDMid;
	HRESULT hr = pIDMPortDownLoad->GetDLId(&dwDMid, 1);
	if (FAILED(hr))
		{
#ifdef _DEBUG
		AfxMessageBox(IDS_ERR_DM_ID, MB_OK | MB_ICONEXCLAMATION);
		return hr;
#endif
		}

	return DM_Init(pIDMPortDownLoad, dwDMid);
}

/* initializes the download port, using dwDMID for its id */
HRESULT CMonoWave::DM_Init(IDirectMusicPortDownload* pIDMPortDownLoad, DWORD dwDMID)
{
	HRESULT	hr = E_FAIL;
	ASSERT(m_pWaveNode);
	CDLSComponent* pComponent = m_pWaveNode->GetComponent();
	ASSERT(pComponent);

	// Do nothing if we don't have a valid port to download to...
	if(pIDMPortDownLoad == NULL)
	{
		return E_FAIL;
	}

	hr = Size(m_dwDLSize);
	if (m_dwDLSize)
	{
		// Add prepend and append amount to download buffer size
		DWORD dwAppendValue = 0;
		if(FAILED(pComponent->GetAppendValueForPort(pIDMPortDownLoad, &dwAppendValue)))
			return E_FAIL;
		
		m_dwDLSize += dwAppendValue;

		IDirectMusicDownload* pIDMDownload;
		hr = pIDMPortDownLoad->AllocateBuffer(m_dwDLSize, &pIDMDownload);
		if (!SUCCEEDED(hr))
		{
			AfxMessageBox(IDS_ERR_INSUFFICIENT_MEMORY, MB_OK | MB_ICONEXCLAMATION);
			return E_OUTOFMEMORY;
		}

		// Allocate a download buffer if we don't have one previously allocated
		AllocatedPortBufferPair* pAllocatedBuffer = GetAllocatedBufferForPort(pIDMPortDownLoad);
		if(pAllocatedBuffer == NULL)
			{
			// Add to the list of allocated buffers
			pAllocatedBuffer = new AllocatedPortBufferPair(pIDMPortDownLoad, pIDMDownload);
			if(pAllocatedBuffer == NULL)
			{
				return E_OUTOFMEMORY;
			}

			m_lstAllocatedBuffers.AddTail(pAllocatedBuffer);
			}

        pAllocatedBuffer->SetDMID(dwDMID);
	}
	else
	{
#ifdef _DEBUG
		AfxMessageBox(IDS_ERR_ZERO_SIZE_WAV, MB_OK | MB_ICONEXCLAMATION);
#endif
		hr = E_FAIL;
	}
	return hr;
}

HRESULT CMonoWave::Download(IDirectMusicPortDownload* pIDMPortDownLoad)
{
    AFX_MANAGE_STATE(_afxModuleAddrThis);

	void*		pBuffer=NULL;
	DWORD		dwSize;
	HRESULT		hr = S_OK;
	
	// Do nothing if we don't have a valid port to download to...
	if(pIDMPortDownLoad == NULL)
	{
		return E_FAIL;
	}

	// Don't download anything if the wave is zero length
	if(m_dwWaveLength == 0)
	{
		return S_OK;
	}

	// Get the allocated buffer
	AllocatedPortBufferPair* pAllocatedBuffer = GetAllocatedBufferForPort(pIDMPortDownLoad);
	ASSERT(pAllocatedBuffer);
	
	// There isn't any buffer allocated 
	// most likely due to insufficient memory
	if(pAllocatedBuffer == NULL)
	{
		return E_FAIL;
	}

	IDirectMusicDownload* pIDMDownload = pAllocatedBuffer->m_pAllocatedBuffer;
	// Fail if we haven't allocated a buffer for download
	if(pIDMDownload == NULL)
	{
		return E_FAIL;
	}

	hr = pIDMDownload->GetBuffer(&pBuffer,&dwSize);
	if ( !SUCCEEDED(hr) || (pBuffer == NULL) || (dwSize < m_dwDLSize) )
	{
#ifdef _DEBUG
		AfxMessageBox(IDS_ERR_GET_DOWNLOAD_BUFFER, MB_OK | MB_ICONEXCLAMATION);
#endif
		return E_FAIL;
	}
	
	if(!SUCCEEDED(hr = Write((((BYTE*)pBuffer)), pIDMPortDownLoad)))
	{
#ifdef _DEBUG
		AfxMessageBox(IDS_ERR_DOWNLOAD_WRITE, MB_OK | MB_ICONEXCLAMATION);
#endif
		return hr;
	}
	if ( !SUCCEEDED( hr = pIDMPortDownLoad->Download(pIDMDownload)) )
	{
#ifdef _DEBUG
		UINT	iErrorStringResource;
		switch (hr)
		{
			case DMUS_E_BADWAVE:   // Bad wave chunk
				iErrorStringResource = IDS_ERR_BADWAVE;
				break;
			case DMUS_E_NOTPCM:    // Not PCM data in wave
				iErrorStringResource = IDS_ERR_NOTPCM;
				break;
			case DMUS_E_NOTMONO:	// Wave not MONO
				iErrorStringResource = IDS_ERR_NOTMONO;
				break;
			case DMUS_E_BADARTICULATION: // Bad articulation chunk
				iErrorStringResource = IDS_ERR_BADARTICULATION;
				break;
			case DMUS_E_BADWAVELINK:  // Bad link from region to wave
				iErrorStringResource = IDS_ERR_BADWAVELINK;
				break;
			case DMUS_E_BADINSTRUMENT:// Bad instrument chunk
				iErrorStringResource = IDS_ERR_BADINSTRUMENT;
				break;
			case DMUS_E_NOARTICULATION:// No articulation found in region
				iErrorStringResource = IDS_ERR_NOARTICULATION;
				break;
			case DMUS_E_BADOFFSETTABLE:
				iErrorStringResource = IDS_ERR_BADOFFSET;
				break;
			default:
				iErrorStringResource = IDS_ERR_DM_DOWNLOAD;
		}
		AfxMessageBox(iErrorStringResource, MB_OK | MB_ICONEXCLAMATION);
#endif
	}
	else if( m_pDummyInstrument )
	{
		ASSERT(m_pWaveNode);
		CDLSComponent* pComponent = m_pWaveNode->GetComponent();
		ASSERT(pComponent);

		POSITION position = pComponent->m_lstDLSPortDownload.GetHeadPosition();
		while(position)
		{
			IDirectMusicPortDownload* pIDMPortDownload = pComponent->m_lstDLSPortDownload.GetNext(position);
			ASSERT(pIDMPortDownload);
			m_pDummyInstrument->DM_Init(pIDMPortDownload);
			m_pDummyInstrument->Download(pIDMPortDownload);
		}
		
		m_pDummyInstrument->UpdatePatch();
		// HACK!! For some reason the performance requires that we send a PMSG for the patch to get applied...
		// HACK!! So we send the messages and hope when we hit play it's going to play the right wave and
		// HACK!! NOT that Skeletor laugh patch again!
		pComponent->PlayMIDIEvent(MIDI_NOTEON,
									  (BYTE)m_rWSMP.usUnityNote, //use wave's unity note
									  0,
									  0, // time
									  m_pDummyInstrument->IsDrum());   
		pComponent->PlayMIDIEvent(MIDI_NOTEOFF,
									  (BYTE)m_rWSMP.usUnityNote, //use wave's unity note
									  0,
									  0, // time
									  m_pDummyInstrument->IsDrum());   
	}
	return hr;
}


HRESULT CMonoWave::UpdateDecompressedWave(const WAVEFORMATEX* pwfxDst)
{
	ASSERT(pwfxDst);
	if(pwfxDst == NULL)
		return E_FAIL;

	if(m_bCompressed)
	{
		// We have to decompress the wave
		if(SUCCEEDED(ConvertWave(m_CompressedWavObj, pwfxDst, m_DecompressedWavObj, false))) 
		{
			// Clear the earlier wav
			m_pnWave = (short*)m_DecompressedWavObj.pbData;
			m_dwDataSize = m_DecompressedWavObj.dwDataSize;
			
			if(m_OriginalWavObj.WaveFormatEx.wBitsPerSample == 8)
				m_dwWaveLength = m_dwDataSize ;
			else
				m_dwWaveLength = m_dwDataSize >> 1;

			return S_OK;
		}
		else
		{
			SwitchCompression(false);
			return E_FAIL;
		}
	}

	return E_FAIL;
}


// bSwitch = false -> Compression OFF
// bSwitch = true -> Compression ON
HRESULT CMonoWave::SwitchCompression(bool bSwitch)
{
	HRESULT hr = S_OK;

	SetWaveBufferToCompressed(bSwitch);

    if(SUCCEEDED(hr))
    {
        // Update the header stream
	    // Stereo waves will do their own update
	    if(IsStereo() == FALSE)
	    {
		    if(SUCCEEDED(UpdateHeaderStream()))
		    {
			    m_pWaveNode->ReloadDirectSoundWave();
		    }
	    }
    }

    // Update the draw buffer
	RefreshDrawBuffer();

	CWaveCtrl* pWaveEditor = m_pWaveNode->GetWaveEditor();
    if(pWaveEditor)
    {
		pWaveEditor->InvalidateControl(); // Repaint the wave with new values
    }

	return hr;
}

void CMonoWave::SetWaveBufferToCompressed(bool bSwitch)
{
	m_bCompressed = bSwitch;
	
	if(!bSwitch)
	{
		m_dwDataSize = m_OriginalWavObj.dwDataSize;

		if(m_OriginalWavObj.WaveFormatEx.wBitsPerSample == 8)
		{
			m_dwWaveLength = m_dwDataSize ;
		}
		else
		{
			m_dwWaveLength = m_dwDataSize >> 1;
		}

		CopyMemory(&m_rWaveformat, &(m_OriginalWavObj.WaveFormatEx), sizeof(m_OriginalWavObj.WaveFormatEx));
	}
	else 
	{
		m_dwDataSize = m_DecompressedWavObj.dwDataSize;

		if(m_DecompressedWavObj.WaveFormatEx.wBitsPerSample == 8)
		{
			m_dwWaveLength = m_dwDataSize ;
		}
		else
		{
			m_dwWaveLength = m_dwDataSize >> 1;
		}

		CopyMemory(&m_rWaveformat, &(m_DecompressedWavObj.WaveFormatEx), sizeof(m_DecompressedWavObj.WaveFormatEx));
	}
}


// This is called if the m_pnWave member is modified directly...e.g. the clipboard 
// operations modify this pointer directly...
// So we need to update our wave objects accordingly
HRESULT CMonoWave::OnWaveBufferUpdated()
{
	if(m_DecompressedWavObj.pbData)
	{
		delete[] m_DecompressedWavObj.pbData;
		m_DecompressedWavObj.pbData = NULL;

		m_DecompressedWavObj.dwDataSize = 0;
	}

	if(FAILED(UpdateWave()))
	{
		return E_FAIL;
	}

	// Update the dummy instrument
	UpdateDummyInstrument();

	// clear the draw buffers
	RefreshDrawBuffer();
	if (m_pdbWaveTrack)
		m_pdbWaveTrack->Dirty();

	if(IsStereo() == false)
	{
		if(FAILED(CWave::OnWaveBufferUpdated()))
		{
			TRACE("DirectSoundWave header update failed!");
			return E_FAIL;
		}
	}

	// Update the data size
	if(m_bCompressed == false)
	{
		m_OriginalWavObj.dwDataSize = m_dwDataSize;
	}

	return S_OK;
}

HRESULT CMonoWave::Unload(IDirectMusicPortDownload* pIDMPortDownLoad)
{
	HRESULT hr = E_FAIL;
	
	ASSERT(pIDMPortDownLoad);
	if(pIDMPortDownLoad == NULL)
	{
		return E_POINTER;
	}

	// unload the dummy instrument first
	if(m_pDummyInstrument)
	{
		if(FAILED(m_pDummyInstrument->Unload(pIDMPortDownLoad)))
		{
			return E_FAIL;
		}
	}

	// now unload the wave
	AllocatedPortBufferPair* pAllocatedBuffer = GetAllocatedBufferForPort(pIDMPortDownLoad);
	if(pAllocatedBuffer == NULL)
	{
		return S_OK;
	}

	if(pAllocatedBuffer->m_pAllocatedBuffer)
	{
		hr = pAllocatedBuffer->m_pDownloadPort->Unload(pAllocatedBuffer->m_pAllocatedBuffer);
	}

	RemoveFromAllocatedBufferList(pAllocatedBuffer);

	return hr;
}

AllocatedPortBufferPair* CMonoWave::GetAllocatedBufferForPort(IDirectMusicPortDownload* pIDMPortDownLoad) const
{
	ASSERT(pIDMPortDownLoad);
	if(pIDMPortDownLoad == NULL)
		return NULL;

	POSITION position = m_lstAllocatedBuffers.GetHeadPosition();
	while(position)
	{
		AllocatedPortBufferPair* pAllocatedBuffer = (AllocatedPortBufferPair*)m_lstAllocatedBuffers.GetNext(position);
		
		ASSERT(pAllocatedBuffer);
		if(pAllocatedBuffer->m_pDownloadPort == pIDMPortDownLoad)
			return pAllocatedBuffer;
	}

	return NULL;
}

void CMonoWave::RemoveFromAllocatedBufferList(AllocatedPortBufferPair* pAllocatedBuffer)
{
	ASSERT(pAllocatedBuffer);
	if(pAllocatedBuffer == NULL)
		return;

	POSITION position = m_lstAllocatedBuffers.GetHeadPosition();

	while(position)
	{
		POSITION oldPosition = position;
		AllocatedPortBufferPair* pAllocatedBufferItem = (AllocatedPortBufferPair*)m_lstAllocatedBuffers.GetNext(position);
		if(pAllocatedBufferItem == pAllocatedBuffer)
		{
			m_lstAllocatedBuffers.RemoveAt(oldPosition);
			pAllocatedBufferItem->m_pAllocatedBuffer->Release();
			delete pAllocatedBufferItem;
			return;
		}
	}
}

void CMonoWave::SetPreviousRegionLinkID(DWORD dwID)
{
	m_dwPreviousRegionLinkID = dwID;
}

DWORD CMonoWave::GetDownloadID(IDirectMusicPortDownload* pIDMPortDownLoad) const
{
    DWORD dwDMID;
	GetDMIDForPort(pIDMPortDownLoad, &dwDMID);
    return dwDMID;
}


int CMonoWave::GetNumberOfLoops() const
{
	return m_rWSMP.cSampleLoops;
}

ULONG CMonoWave::GetWavePoolOffset()
{
	return m_dwHeaderOffset;
}


HRESULT CMonoWave::Compress(const WAVEFORMATEX* pwfxDest, bool bInUndoRedo)
{
	ASSERT(pwfxDest);
	if(pwfxDest == NULL)
	{
		return E_POINTER;
	}

	ASSERT(m_pDataManager);
	if(m_pDataManager == NULL)
	{
		return E_FAIL;
	}

    // Update the uncompressed deltas if we're not already compressed
    if(!m_bCompressed && !bInUndoRedo)
    {
        if(FAILED(m_pDataManager->UpdateUncompressedDeltas()))
        {
            return E_FAIL;
        }
    }

	// Ask the data manager to recreate the decomp file
	if(FAILED(m_pDataManager->CreateDecompFile()))
	{
		return E_FAIL;
	}

	int nBytesPerSample = m_OriginalWavObj.WaveFormatEx.wBitsPerSample / 8;
    DWORD dwDataSize = m_OriginalWavObj.dwDataSize;
    DWORD dwWaveLength = (nBytesPerSample == 1) ? dwDataSize  : (dwDataSize >> 1);
    
	// Remember the old wavelength
	DWORD dwOldLength = dwWaveLength;

	// We have to compress the wave in chunks
	DWORD dwSamplesCompressed = 0;
	DWORD dwSamplesToCompress = dwWaveLength;
	
	DWORD dwCompressedSize = 0;
	DWORD dwDecompressedSize = 0;

	// Get data in chunks of WAVE_DATA_BUFFER_SIZE 
	while(dwSamplesCompressed < dwWaveLength)
	{
		BYTE* pbData = NULL;
		//DWORD dwLength = WAVE_DATA_BUFFER_SIZE;
		DWORD dwLength = dwWaveLength;
		dwSamplesToCompress = dwWaveLength - dwSamplesCompressed;
		
		// Take the big slice for the last chunk....
		// The conversion might fail if we take very small amount of data
		if(dwSamplesToCompress <= WAVE_DATA_BUFFER_SIZE * 2)
		{
			dwLength = dwSamplesToCompress;
		}

		if(FAILED(GetChannelData(dwSamplesCompressed, dwLength, &pbData, true)))
		{
			return E_FAIL;
		}

		// Now compress the data
		DWORD dwSourceSize = dwLength * nBytesPerSample;
		BYTE* pbCompressed = NULL;
		DWORD dwCompressed = 0;
		if(FAILED(ConvertWave(&m_rWaveformat, pwfxDest, pbData, dwSourceSize, &pbCompressed, dwCompressed)))
		{
			delete[] pbData;
			return E_FAIL;
		}

		dwCompressedSize += dwCompressed;
		
		// Update the number of samples successfully compressed
		dwSamplesCompressed += dwLength;

		// Now decompress the compressed data and give it to data manager
		BYTE* pbDecompressed = NULL;
		DWORD dwDecompressed = 0;
		if(FAILED(ConvertWave(pwfxDest, &m_rWaveformat, pbCompressed, dwCompressed, &pbDecompressed, dwDecompressed)))
		{
			delete[] pbData;
			delete[] pbCompressed;
			return E_FAIL;
		}

		dwDecompressedSize += dwDecompressed;
		
		delete[] pbData;
		delete[] pbCompressed;

		// Ask the data manager to write the decompressed buffer to the decomp file
		if(FAILED(m_pDataManager->WriteDecompressedData(pbDecompressed, dwDecompressed)))
		{
			delete[] pbDecompressed;
			return E_FAIL;
		}

		delete[] pbDecompressed;
	}

	// Reset the compression info
	CleanWaveObject(&m_CompressedWavObj);
	m_CompressedWavObj.dwDataSize = dwCompressedSize;
	CopyMemory(&(m_CompressedWavObj.WaveFormatEx), pwfxDest, sizeof(WAVEFORMATEX));
	if(pwfxDest->cbSize)
	{
		if(FAILED(SafeAllocBuffer(&(m_CompressedWavObj.pbExtractWaveFormatData), pwfxDest->cbSize)))
		{
			return E_OUTOFMEMORY;
		}
		CopyMemory(m_CompressedWavObj.pbExtractWaveFormatData, ((BYTE*)pwfxDest) + sizeof(WAVEFORMATEX), pwfxDest->cbSize);
	}

	// Reset the decompression info	
	CleanWaveObject(&m_DecompressedWavObj);
	m_DecompressedWavObj.dwDataSize = dwDecompressedSize;
	CopyMemory(&(m_DecompressedWavObj.WaveFormatEx), &m_rWaveformat, sizeof(WAVEFORMATEX));


	// Our wavelength has possibly changed 
	m_dwDataSize = dwDecompressedSize;
	m_dwWaveLength = dwDecompressedSize / nBytesPerSample;
	
	// Mark the wave as compressed...
	m_bCompressed = true;

	// Update the loop points if it's looped...
	if(m_bPlayLooped)
	{
		LONG lDifference = m_dwWaveLength - dwOldLength;
		m_rWLOOP.ulStart += lDifference;
		m_rWLOOP.ulStart = m_rWLOOP.ulStart;
		m_rWLOOP.ulStart = min(m_rWLOOP.ulStart, m_dwWaveLength);
		m_rWLOOP.ulLength = min(m_rWLOOP.ulLength, m_dwWaveLength - m_rWLOOP.ulStart);
		
		m_rRLOOP.dwStart = m_rWLOOP.ulStart;
		m_rRLOOP.dwEnd = m_rWLOOP.ulStart + m_rWLOOP.ulLength - 1;
	}

	return S_OK;
}


HRESULT CMonoWave::WriteCompressedData(IStream* pIStream, WAVEFORMATEX* pwfxDest, DWORD& cbWritten)
{
	ASSERT(pIStream);
	if(pIStream == NULL)
	{
		return E_POINTER;
	}

	ASSERT(pwfxDest);
	if(pwfxDest == NULL)
	{
		return E_POINTER;
	}

	ASSERT(m_pDataManager);
	if(m_pDataManager == NULL)
	{
		return E_FAIL;
	}

	int nBytesPerSample = m_rWaveformat.wBitsPerSample / 8;

	// We have to compress the wave in chunks
	DWORD dwSamplesCompressed = 0;
	DWORD dwSamplesToCompress = m_OriginalWavObj.dwDataSize / nBytesPerSample;
	DWORD dwUncompressedLength = dwSamplesToCompress;
	
	DWORD dwCompressedSize = 0;

	// Get data in chunks of WAVE_DATA_BUFFER_SIZE 
	while(dwSamplesCompressed < dwUncompressedLength)
	{
		BYTE* pbData = NULL;
		DWORD dwLength = dwUncompressedLength;
		dwSamplesToCompress = dwUncompressedLength - dwSamplesCompressed;
		
		// Take the big slice for the last chunk....
		// The conversion might fail if we take very small amount of data
		if(dwSamplesToCompress <= WAVE_DATA_BUFFER_SIZE * 2)
		{
			dwLength = dwSamplesToCompress;
		}

		if(FAILED(GetChannelData(dwSamplesCompressed, dwLength, &pbData, true)))
		{
			return E_FAIL;
		}

		// Now compress the data
		DWORD dwSourceSize = dwLength * nBytesPerSample;
		BYTE* pbCompressed = NULL;
		DWORD dwCompressed = 0;
		if(FAILED(ConvertWave(&m_rWaveformat, pwfxDest, pbData, dwSourceSize, &pbCompressed, dwCompressed)))
		{
			delete[] pbData;
			return E_FAIL;
		}

		dwCompressedSize += dwCompressed;
		
		// Update the number of samples successfully compressed
		dwSamplesCompressed += dwLength;

		// Write the data to the stream
		DWORD cb = 0;
		if(FAILED(pIStream->Write(pbCompressed, dwCompressed, &cb)))
		{
			delete[] pbData;
			return E_FAIL;
		}

		delete[] pbData;
		delete[] pbCompressed;

		cbWritten += cb;	
	}

	return S_OK;
}


void CMonoWave::OnDraw(CDC* pDC, const CRect& rcClient, const long lOffset, DWORD& dwStartSample, DWORD dwLength, float fSamplesPerPixel, const WaveDrawParams* pDrawParams, const WaveTimelineInfoParams* pInfoParams)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	// Nothing to draw?
	if(dwLength == 0 )
	{
		return;
	}


	ASSERT(pDC);
	if(pDC == NULL)
	{
		return;
	}

	ASSERT(pDrawParams);
	if(pDrawParams == NULL)
	{
		return;
	}

	ASSERT(pInfoParams);
	if(pInfoParams == NULL)
	{
		return;
	}

	if(dwStartSample >= m_dwWaveLength)
	{
		return;
	}

	// Check the rect for 0 width
	if(rcClient.Width() <= 0)
	{
		return;
	}

	BOOL bLoopedOnTrack = pInfoParams->dwFlags & WAVE_LOOPED;
	DWORD dwLoopStart = (pInfoParams->dwLoopStart) / DRAW_UNIT_SIZE;
	DWORD dwLoopEnd = pInfoParams->dwLoopEnd / DRAW_UNIT_SIZE;

	int nMidY = (rcClient.bottom - rcClient.top) / 2; 

	dwStartSample = dwStartSample;
	if(m_dwWaveLength < dwStartSample + dwLength && !bLoopedOnTrack)
	{
		dwLength = m_dwWaveLength - dwStartSample;
	}

	DWORD dwStart = dwStartSample / DRAW_UNIT_SIZE;
	DWORD dwDrawLength = (dwLength < DRAW_UNIT_SIZE) ? 1 : dwLength / DRAW_UNIT_SIZE;

	// What's our sample size?
	int nBytesPerSample = m_rWaveformat.wBitsPerSample / 8;

	// What's our zero value? (We assume only 8 and 16 bit waves)
	int nZeroValue = nBytesPerSample == 1 ? 128 : 0;

	// What's our max Y value?
	float fYScale = nBytesPerSample == 1 ? (float) nMidY / 128 : (float) nMidY / 32768;
	
	// What's our screen width?
	int nRectWidth = rcClient.Width();
	
	// How many samples to step in each iteration?
	float nSampleStep = (fSamplesPerPixel > 1) ? fSamplesPerPixel : 1;

	// How many pixels do we have to skip per sample?
	float nXStep = (fSamplesPerPixel >= 1) ? 1 : ((float)nRectWidth / dwDrawLength); 

	float fAccumulatedXStepErr = 0;
	float fXStepErr = nXStep - (int)nXStep;
	int nSampleSkip = (int)(1 / fXStepErr);
	if(nXStep < 1 && lOffset == 0)
	{
		fXStepErr = 1 - nXStep;
	}
	
	// Need to take into account the error while drawing...
	float fAccumulatedError = 0;
	float fErrorFactor = fSamplesPerPixel - (int) fSamplesPerPixel;
	if(fSamplesPerPixel < 1)
	{
		fErrorFactor = 0;
	}

	// create the draw buffer on the fly
	if (m_pdbWaveTrack == NULL)
		{
		m_pdbWaveTrack = new CMonoWaveDrawBuffer(mwdbTypeWaveTrack);
		if (m_pdbWaveTrack == NULL)
			return;
		m_pdbWaveTrack->Init(DRAW_UNIT_SIZE, this);
		}

	// fill visible area of the wave track draw buffer
	DWORD dwUnitStart = dwStart;
	DWORD dwUnitLength = dwDrawLength;
	if ((bLoopedOnTrack) && (dwLoopStart < dwStart))
		{
		// we may have to go further back because of a loop
		// assume worst case: start at loop, and end at end of current visible screen
		dwUnitLength += dwStart - dwLoopStart;
		dwUnitStart = dwLoopStart;
		}
    BYTE* pbData;
	DWORD dwDataLength;
	if (FAILED(m_pdbWaveTrack->Get(dwUnitStart*DRAW_UNIT_SIZE, dwUnitLength*DRAW_UNIT_SIZE, &pbData, &dwDataLength)))
		return;

	COLORREF clrWave = pDrawParams->clrForeground;
	COLORREF clrBgnd = pDrawParams->clrBackground;
	COLORREF clrClip = pDrawParams->clrClipMarker;

	// Fill the rect with the background color
	if(pDrawParams->bErase)
		pDC->FillSolidRect(rcClient, clrBgnd);
		
	// Draw the LIGHT-BLUE zero-line.
	pDC->FillSolidRect(rcClient.left, rcClient.top+nMidY, rcClient.Width(), 1, RGB(192, 176, 244));

	// Temp fix for DX8 Bug 44791. The value 255 is defined in WaveString.cpp as
	// COLOR_SELECTED_WAVE. Because it is defined in the cpp file, we will have
	// to hard code the value here.
	CPen wavePen(PS_SOLID, 0, clrWave);
	CPen bluePen(PS_SOLID, 0, RGB(0, 0, 164));
	CPen* pOldPen = pDC->SelectObject((m_bCompressed && (255 != clrWave)) ? &bluePen : &wavePen);

	if(nBytesPerSample == 1)
	{
		// We're reading bytes here.
        
		// Move to the first visible sample.
        int nY = (int)(fYScale * (abs(pbData[0] - nZeroValue)));
        pDC->MoveTo(rcClient.left, (pbData[0] > nZeroValue) ? (rcClient.top + (nMidY - nY)) : (rcClient.top + (nMidY + nY)));

		DWORD dwSampleIndex = 0;
		for(int nXPos = rcClient.left + (int)(nXStep); nXPos < rcClient.right; nXPos += (int)floor(nXStep))
		{
			dwSampleIndex += (DWORD) nSampleStep;
			if(bLoopedOnTrack && dwSampleIndex >= dwLoopEnd)
			{
				dwSampleIndex = dwLoopStart;
			}

			if(fAccumulatedError > 1)
			{
				dwSampleIndex++;
				fAccumulatedError -= 1;
			}

			if(fAccumulatedXStepErr > 1)
			{
				nXPos++;
				fAccumulatedXStepErr -= 1;
			}

			if(dwSampleIndex >= dwDataLength)
			{
				if(bLoopedOnTrack)
				{
					dwSampleIndex = dwLoopStart;
				}
				else
				{
					break;
				}
			}
			
			int nSampleValue = pbData[dwSampleIndex];
			int nNextSampleValue = nSampleValue > 128 ? 128 - (nSampleValue - 128) : 128 + (128 - nSampleValue);

			if (nSampleValue < 128)
			{                    
				pDC->LineTo(nXPos, rcClient.top + nMidY + (int)(float)(fYScale * (128 - abs(nSampleValue))));
				pDC->LineTo(nXPos, rcClient.top + nMidY + (int)(float)(fYScale * (128 - abs(nNextSampleValue))));
			}
			else
			{
				pDC->LineTo(nXPos, rcClient.top + nMidY - (int)((float)(fYScale * (nSampleValue - 128))));                       
				pDC->LineTo(nXPos, rcClient.top + nMidY - (int)((float)(fYScale * (nNextSampleValue - 128))));                       
			}

			fAccumulatedError += fErrorFactor;
			fAccumulatedXStepErr += fXStepErr;
		}
	}
	else
	{
		short* pnDrawBuffer = (short*)pbData;

		// Move to the first visible sample.
        int nY = (int)(fYScale * (abs(pnDrawBuffer[0] - nZeroValue)));
        pDC->MoveTo( rcClient.left, (pnDrawBuffer[0] > nZeroValue) ? (rcClient.top + (nMidY - nY)) : (rcClient.top + (nMidY + nY)));

		DWORD dwSampleIndex = 0;
		for(int nXPos = rcClient.left + (int)nXStep; nXPos < rcClient.right; nXPos += (int)floor(nXStep))
		{
			dwSampleIndex += (DWORD) nSampleStep;
			if(bLoopedOnTrack && dwSampleIndex >= dwLoopEnd)
			{
				dwSampleIndex = dwLoopStart;
			}

			if(fAccumulatedError > 1)
			{
				dwSampleIndex++;
				fAccumulatedError -= 1;
			}

			if(fAccumulatedXStepErr > 1)
			{
				nXPos++;
				fAccumulatedXStepErr -= 1;
			}

			if(dwSampleIndex >= dwDataLength)
			{
				if(bLoopedOnTrack)
				{
					dwSampleIndex = dwLoopStart;
				}
				else
				{
					break;
				}
			}
			
			int nSampleValue = pnDrawBuffer[dwSampleIndex];
			int nNextSampleValue = -nSampleValue;

			if (nSampleValue < 0)
			{                    
				pDC->LineTo(nXPos, rcClient.top + nMidY + (int)(float)(fYScale * abs(nSampleValue)));
				pDC->LineTo(nXPos, rcClient.top + nMidY + (int)(float)(fYScale * abs(nNextSampleValue)));
			}
			else
			{
				pDC->LineTo(nXPos, rcClient.top + nMidY - (int)((float)(fYScale * nSampleValue)));                       
				pDC->LineTo(nXPos, rcClient.top + nMidY - (int)((float)(fYScale * nNextSampleValue)));                       
			}

			fAccumulatedError += fErrorFactor;
			fAccumulatedXStepErr += fXStepErr;
		}
	}
	
	// Select the old GDIObjects back
	if(pOldPen)
	{
		pDC->SelectObject(pOldPen);
	}
}


void CMonoWave::OnDraw(CDC* pDC, const CRect& rcClient)
{
	// Must have a DC!
	ASSERT(pDC);
	if(!pDC)
	{
		return;
	}

	// Must have an editor to draw on!
	CWaveCtrl* pWaveEditor = GetWaveEditor();
	ASSERT(pWaveEditor);
	if(pWaveEditor == NULL)
	{
		return;
	}

	int nMidY = (rcClient.bottom - rcClient.top) / 2; 

	// How many samples per pixel do we draw?
	int nSamplesPerPixel = pWaveEditor->GetSamplesPerPixel();

	// How much are we scrolled?
	int nSamplesScrolled = pWaveEditor->GetScrolledSamples();
	
	// How much are we zoomed in?
	int nZoomFactor = pWaveEditor->GetZoomFactor();

	// What's our maximum height
	int nyMax = ((rcClient.bottom - rcClient.top) - 2) / 2; 

	// How many samples do we have to draw?
    int nSamplesToDraw = min((int)m_dwWaveLength - nSamplesScrolled, (nZoomFactor >= 0) ?
		rcClient.right * nSamplesPerPixel :
		(rcClient.right / nSamplesPerPixel) + 2); // +1 because first sample is used at start, +1 to draw line past end

	// What's our maximum width?
    int nxMax = (nZoomFactor >= 0) ? nSamplesToDraw / nSamplesPerPixel : nSamplesToDraw * nSamplesPerPixel;

	// switch zoom buffers if necessary
	int nSamplesPerPixelZoom = (nZoomFactor > 0) ? nSamplesPerPixel : 1;
	if ((m_pdb == NULL) || (m_pdb->GetSamplesPerPixel() != nSamplesPerPixelZoom))
		{
		// compute optimum sample rate on the fly
		if (m_nSamplesPerPixelOptimum == 0)
			{
			// compute maximum samples per pixel (whole wave fits in screen, estimated at 1K pixels)
			double dMaxSampsPerPixel = ((double)m_dwWaveLength / 1000);
			short nZoomFactorMin = (short)ceil(log(dMaxSampsPerPixel) / log(2));

			// the "optimum" is four zooms above the minimum zoom, and between 16 and 512 samples per pixel
			// (16 to not be ridiculous and remember data that can be quickly read from disk)
			// (512 to speed up browsing of large waves)
			if (nZoomFactorMin >= 4)
				{
				m_nSamplesPerPixelOptimum = 1 << (nZoomFactorMin - 4); // same as dividing max sample/pixel rate by 16
				if (m_nSamplesPerPixelOptimum > 512)
					m_nSamplesPerPixelOptimum = 512;
				else if (m_nSamplesPerPixelOptimum < 16)
					m_nSamplesPerPixelOptimum = 16;
				}
			else
				m_nSamplesPerPixelOptimum = 16; // no buffer needed: 16 will never be reached, max is 1 << 3 = 8 for this wave
			}

		// destroy "latest" buffer if it exists
		if (m_pdbLatest)
			{
			delete m_pdbLatest;
			m_pdbLatest = NULL;
			}

		// build the optimum zoom buffer if needed now
		if ((nSamplesPerPixelZoom >= (int)m_nSamplesPerPixelOptimum) && (m_pdbOptimum == NULL))
			{
			m_pdbOptimum = new CMonoWaveDrawBuffer(mwdbTypeWaveEditor);
			if (m_pdbOptimum == NULL)
				return;
			m_pdbOptimum->Init(m_nSamplesPerPixelOptimum, this);
			}

		// create draw buffer on the fly
		if (nSamplesPerPixelZoom == (int)m_nSamplesPerPixelOptimum)
			{
			ASSERT(m_pdbOptimum->GetSamplesPerPixel() == (int)m_nSamplesPerPixelOptimum);
			m_pdb = m_pdbOptimum;
			}
		else
			{
			m_pdbLatest = new CMonoWaveDrawBuffer(mwdbTypeWaveEditor);
			if (m_pdbLatest == NULL)
				return;
			if (nSamplesPerPixelZoom > (int)m_nSamplesPerPixelOptimum)
				m_pdbLatest->Init(nSamplesPerPixelZoom, m_pdbOptimum);
			else
				m_pdbLatest->Init(nSamplesPerPixelZoom, this);
			m_pdb = m_pdbLatest;
			}
		}

	// fill draw buffer
	short* pnData;
	DWORD dwUnitLength;
	ASSERT(m_pdb);
	ASSERT(m_pdb->GetSamplesPerPixel() == nSamplesPerPixelZoom);
	if (FAILED(m_pdb->Get(nSamplesScrolled, nSamplesToDraw, (BYTE **)&pnData, &dwUnitLength)))
		return;
	
	// This might be a new wave with no data in it yet....
	if(pnData == NULL)
		return;

	// Draw the LIGHT-BLUE zero-line.
	pDC->FillSolidRect(rcClient.left, rcClient.top+nyMax, rcClient.Width(), 1, RGB(192, 176, 244));

	CPen blackPen(PS_SOLID, 0, RGB(0, 0, 0));
	CPen bluePen(PS_SOLID, 0, RGB(0, 0, 164));
	CPen *pOldPen = pDC->SelectObject(m_bCompressed ? &bluePen : &blackPen);

	int nXStep = (nZoomFactor > 0) ? 1 : nSamplesPerPixel;
	DWORD dwSample = 0;
	if(m_rWaveformat.wBitsPerSample == 8)
    {
		// We're reading bytes here.
        BYTE* pByte = (BYTE*) pnData;
        
		// 128 is the zero value for 8-bit data
        float nyScale = (float) nyMax / 128;

        // Move to the first visible sample.
        int ny = (int)(nyScale * (abs(pByte[0] - 128)));
        pDC->MoveTo( rcClient.left, (pByte[0] > 128) ? (rcClient.top + (nyMax - ny)) : (rcClient.top + (nyMax + ny)));

		for(int nXPos = 0; nXPos <= nxMax; nXPos += nXStep)
        {
			if (dwSample >= dwUnitLength)
				break;

            if (pByte[dwSample] > 128)
                pDC->LineTo(nXPos, rcClient.top + nyMax - (int)(nyScale * (pByte[dwSample] - 128)));
            else    
                pDC->LineTo(nXPos, rcClient.top + nyMax + (int)(nyScale * (128 - pByte[dwSample])));

			dwSample++;
        }

	}
	else if(m_rWaveformat.wBitsPerSample == 16)
    {
		short* pData = pnData;
        
		float nyScale = (float) nyMax / 32768;
		
		// Move to the first visible sample.
		int ny = (int)((float)(nyScale * (abs(pData[0]))));
        pDC->MoveTo(rcClient.left, (pData[0] > 0) ? (rcClient.top + (nyMax - ny)) : (rcClient.top + (nyMax + ny)));

		for(int nXPos = 0; nXPos <= nxMax; nXPos += nXStep)
        {
			if (dwSample >= dwUnitLength)
				break;

            if (pData[dwSample] < 0)
                pDC->LineTo(nXPos, rcClient.top + nyMax + (int)(float)(nyScale * abs(pData[dwSample])));
            else
                pDC->LineTo(nXPos, rcClient.top + nyMax - (int)((float)(nyScale * pData[dwSample])));                       

			dwSample++;
        }
	}

	// Select the old GDIObjects back
	if(pOldPen)
	{
		pDC->SelectObject(pOldPen);
	}
}

void CMonoWave::RefreshDrawBuffer()
{
	if (m_pdbOptimum)
		m_pdbOptimum->Dirty();
	if (m_pdbLatest)
		m_pdbLatest->Dirty();
}

HRESULT CMonoWave::GetChannelData(DWORD dwStartSample, DWORD dwLength, BYTE** ppbData, bool bGetUncompressedOnly)
{
	if(m_dwWaveLength == 0 || dwLength == 0)
	{
		return S_OK;
	}

    HRESULT hr = E_FAIL;

	if(IsStereo() && m_pCollection && m_bCompressed)
	{
		DWORD cb = 0;

        EnterCriticalSection(&m_pWaveNode->m_CriticalSection);
		hr = GetData(dwStartSample, dwLength, ppbData, cb, bGetUncompressedOnly);
        LeaveCriticalSection(&m_pWaveNode->m_CriticalSection);
        return hr;
	}
	else if(IsStereo())
	{
		CStereoWave* pStereoWave = (CStereoWave*)(m_pWaveNode->GetWave());
		ASSERT(pStereoWave);
		if(pStereoWave == NULL)
		{
			return E_FAIL;
		}

		if(pStereoWave->IsTrueStereo())
		{
			DWORD cb = 0;
            EnterCriticalSection(&m_pWaveNode->m_CriticalSection);
            hr = pStereoWave->GetData(dwStartSample, dwLength, ppbData, cb, bGetUncompressedOnly);
            LeaveCriticalSection(&m_pWaveNode->m_CriticalSection);
			if(FAILED(hr))
			{
				return E_FAIL;
			}

			// Strip the channels data
			BYTE* pbChannelData = NULL;
			DWORD dwDataSize = cb / 2;
			if(FAILED(SafeAllocBuffer(&pbChannelData, dwDataSize)))
			{
				delete[] *ppbData;
				return E_OUTOFMEMORY;
			}

			if(FAILED(StripChannelData(*ppbData, cb, pbChannelData)))
			{
				delete[] *ppbData;
				return E_FAIL;
			}

			delete[] *ppbData;
			*ppbData = pbChannelData;
			return hr;
		}
	}

	DWORD cb = 0;
    EnterCriticalSection(&m_pWaveNode->m_CriticalSection);
    hr = GetData(dwStartSample, dwLength, ppbData, cb, bGetUncompressedOnly);
    LeaveCriticalSection(&m_pWaveNode->m_CriticalSection);
	return hr;
}


HRESULT CMonoWave::GetAllUncompressedChannelData(BYTE** ppbData, DWORD* pdwSize)
{
    ASSERT(pdwSize);
    if(pdwSize == NULL)
    {
        return E_POINTER;
    }
    
    if(m_dwWaveLength == 0)
	{
		return S_OK;
	}
    
    bool bUncompressedInTrueStereo = false;
    if(IsStereo())
    {
        CStereoWave* pStereoWave = (CStereoWave*)(m_pWaveNode->GetWave());
		ASSERT(pStereoWave);
		if(pStereoWave == NULL)
		{
			return E_FAIL;
		}

		bUncompressedInTrueStereo = (pStereoWave->IsTrueStereo() != 0);
    }

    if(bUncompressedInTrueStereo == false)
	{
		return GetAllUncompressedData(ppbData, pdwSize);
	}
    else
	{
		CStereoWave* pStereoWave = (CStereoWave*)(m_pWaveNode->GetWave());
		ASSERT(pStereoWave);
		if(pStereoWave == NULL)
		{
			return E_FAIL;
		}

		if(pStereoWave->IsTrueStereo())
		{
			DWORD cb = 0;
			if(FAILED(pStereoWave->GetAllUncompressedData(ppbData, pdwSize)))
			{
				return E_FAIL;
			}

			// Strip the channels data
			BYTE* pbChannelData = NULL;
			DWORD dwDataSize = *pdwSize / 2;
			if(FAILED(SafeAllocBuffer(&pbChannelData, dwDataSize)))
			{
				delete[] *ppbData;
				return E_OUTOFMEMORY;
			}

			if(FAILED(StripChannelData(*ppbData, *pdwSize, pbChannelData)))
			{
				delete[] *ppbData;
				return E_FAIL;
			}

			delete[] *ppbData;
			*ppbData = pbChannelData;
            *pdwSize = dwDataSize;
			return S_OK;
		}
	}

	return E_FAIL;
}


HRESULT CMonoWave::StripChannelData(const BYTE* pbSrcData, DWORD dwChunkSize, BYTE* pbDestBuffer)
{
	// All pointers must be valid
	ASSERT(pbSrcData);
	if(pbSrcData == NULL)
		return E_POINTER;

	ASSERT(pbDestBuffer);
	if(pbDestBuffer == NULL)
		return E_POINTER;

	int nBytesPerSample = m_rWaveformat.wBitsPerSample / 8;
	int nInitialPos = 0;
	if(m_bRightChannel)
	{
		nInitialPos = nBytesPerSample;
	}

	for(DWORD dwByteCount = nInitialPos; dwByteCount < dwChunkSize; dwByteCount += nBytesPerSample * 2)
	{
		CopyMemory(pbDestBuffer, pbSrcData + dwByteCount, nBytesPerSample);
		pbDestBuffer += nBytesPerSample;
	}

	/* TODO: Enable this optimization
	const BYTE *pbEndSrc = pbSrcData + dwChunkSize;

	if( 16 == m_rWaveformat.wBitsPerSample )
	{
		if(m_bRightChannel)
		{
			pbSrcData += 2;
		}

		while( pbSrcData < pbEndSrc )
		{
			CopyMemory(pbDestBuffer, pbSrcData, 2);
			pbSrcData += 4;
			pbDestBuffer += 2;
		}
	}
	else if( 8 == m_rWaveformat.wBitsPerSample )
	{
		if(m_bRightChannel)
		{
			pbSrcData += 1;
		}

		while( pbSrcData < pbEndSrc )
		{
			CopyMemory(pbDestBuffer, pbSrcData, 1);
			pbSrcData += 2;
			pbDestBuffer += 1;
		}
	}
	else
	{
		const int nBytesPerSample = m_rWaveformat.wBitsPerSample / 8;

		if(m_bRightChannel)
		{
			pbSrcData += nBytesPerSample;
		}

		while( pbSrcData < pbEndSrc )
		{
			CopyMemory(pbDestBuffer, pbSrcData, nBytesPerSample);
			pbSrcData += nBytesPerSample * 2;
			pbDestBuffer += nBytesPerSample;
		}
	}
	*/

	return S_OK;
}

DWORD CMonoWave::GetDataSize()
{
	return m_dwDataSize;
}

DWORD CMonoWave::GetUncompressedDataSize()
{
	return m_OriginalWavObj.dwDataSize;
}

DWORD CMonoWave::GetCompressedDataSize()
{
	return m_CompressedWavObj.dwDataSize;
}


DWORD CMonoWave::GetCompressionFormatTag()
{
	ASSERT(m_bCompressed);
	if(m_bCompressed)
	{
		return m_CompressedWavObj.WaveFormatEx.wFormatTag;
	}
	
	return 0;
}

HRESULT CMonoWave::GetCompressionFormat(WAVEFORMATEX* pwfxCompression)
{
	ASSERT(pwfxCompression);
	if(pwfxCompression == NULL)
		return E_POINTER;

	CopyMemory(pwfxCompression, &m_CompressedWavObj.WaveFormatEx, sizeof(WAVEFORMATEX));
	return S_OK;
}


BYTE* CMonoWave::GetCompressionFormatExtraInfo()
{
	return m_CompressedWavObj.pbExtractWaveFormatData;
}


GUID CMonoWave::GetGUID()
{
	return m_guidStereoWave;
}

void CMonoWave::SetGUID(const GUID& guidStereoWave)
{
	CWaveNode::CopyGUID(guidStereoWave, m_guidStereoWave);
}

// Caller will have to deal with updating the wave
// The method just does what it says...removes a bunch of bytes
HRESULT CMonoWave::RemoveSelection(DWORD dwStart, DWORD dwEnd)
{
	// Swap the points if necessary
	DWORD dwTemp = dwStart;
	if(dwStart > dwEnd)
	{
		DWORD dwTemp = dwStart;
		dwStart = dwEnd;
		dwEnd = dwTemp;
	}

	DWORD dwBytesRemoved;
	DWORD dwSamplesRemoved = abs(dwEnd - dwStart) + 1;

	DWORD dwNewBufferSize = 0;
	if (m_rWaveformat.wBitsPerSample == 8)
	{
		dwBytesRemoved = dwEnd - dwStart + 1;
	}
	else
	{
		dwBytesRemoved = (dwEnd << 1) - (dwStart << 1) + 2;
	}

    dwNewBufferSize = m_OriginalWavObj.dwDataSize - dwBytesRemoved;

	if(FAILED(m_pDataManager->RemoveData(dwStart, dwSamplesRemoved)))
	{
		return E_FAIL;
	}

    m_OriginalWavObj.dwDataSize -= dwBytesRemoved;
	m_dwDataSize = m_OriginalWavObj.dwDataSize;
	m_dwWaveLength -= dwSamplesRemoved;

	return S_OK;
}

HRESULT CMonoWave::CopySelectionToClipboard(IStream* pIStream, DWORD dwStart, DWORD dwEnd)
{
	ASSERT(pIStream);
	if(pIStream == NULL)
	{
		return E_POINTER;
	}

	// Swap the points if necessary
	if(dwStart > dwEnd)
	{
		DWORD dwTemp = dwStart;
		dwStart = dwEnd;
		dwEnd = dwTemp;
	}

	DWORD dwClipLength = dwEnd - dwStart + 1;

	if(FAILED(CWave::WriteDataToClipboard(pIStream, dwStart, dwClipLength)))
	{
		return E_FAIL;
	}

	return S_OK;
}

HRESULT CMonoWave::PasteSelectionFromClipboard(IStream* pIStream, DWORD dwStart)
{
	ASSERT(pIStream);
	if(pIStream == NULL)
	{
		return E_POINTER;
	}

	BYTE* pbData = NULL;
	WAVEFORMATEX wfxClip;
	DWORD dwDataSize = 0;
	if(FAILED(CWave::ReadDataFromClipbaord(pIStream, wfxClip, &pbData, dwDataSize)) || pbData == NULL || dwDataSize == 0)
	{
		return E_FAIL;
	}

	UINT nClipSampleSize = wfxClip.wBitsPerSample / 8;
	UINT nClipChannels = wfxClip.nChannels;

	DWORD dwClipLength = (dwDataSize / nClipSampleSize) / nClipChannels;
	
	HRESULT hr = InsertWaveData(pbData, wfxClip, dwClipLength, dwStart);
	if(FAILED(hr))
	{
		delete[] pbData;
	}

	return hr;
}


HRESULT CMonoWave::InsertWaveData(BYTE* pbData, WAVEFORMATEX wfFormat, DWORD  dwSamples, DWORD dwStart)
{
    AFX_MANAGE_STATE(_afxModuleAddrThis);
	
	DWORD dwNewBufferSize = 0;
	DWORD dwNumNewBytes = 0;

	UINT nClipChannels = wfFormat.nChannels;

	if(nClipChannels == 2)
	{
		BYTE* pbMonoData = NULL;
		int nSampleSize = wfFormat.wBitsPerSample / 8;

		DWORD dwMonoSize = dwSamples * nSampleSize;
		if(FAILED(SafeAllocBuffer(&pbMonoData, dwMonoSize)))
		{
			return E_OUTOFMEMORY;
		}

		if(nSampleSize == 2)
		{
			if(FAILED(MixStereoToMono((short*)pbData, (short*)pbMonoData, dwSamples)))
			{
				delete[] pbMonoData;
				return E_FAIL;
			}
		}
		else if(nSampleSize == 1)
		{
			if(FAILED(MixStereoToMono(pbData, pbMonoData, dwSamples)))
			{
				delete[] pbMonoData;
				return E_FAIL;
			}
		}
		else
		{
			// We can't handle any other sample sizes
			delete[] pbMonoData;
			return E_FAIL;
		}
		
		delete[] pbData;
		pbData = pbMonoData;
		nClipChannels = 1;
	}
	else if(nClipChannels != 1)
	{
		return E_FAIL;
	}

	if(m_rWaveformat.wBitsPerSample == 8)
	{
		dwNumNewBytes = dwSamples * nClipChannels;
		//dwNewBufferSize = m_dwWaveLength + dwNumNewBytes;
	}
	else
	{
		dwNumNewBytes = (dwSamples * nClipChannels) << 1;
		//dwNewBufferSize = (m_dwWaveLength << 1) + dwNumNewBytes;
	}

    dwNewBufferSize = m_OriginalWavObj.dwDataSize + dwNumNewBytes;

	if(m_rWaveformat.wBitsPerSample != wfFormat.wBitsPerSample)
	{
		DWORD dwIndex = 0;
		
		if(m_rWaveformat.wBitsPerSample == 8) 
		{
			BYTE* pbNewBuffer = NULL;
			if(FAILED(SafeAllocBuffer(&pbNewBuffer, dwNumNewBytes)))
			{
				return E_OUTOFMEMORY;
			}

			for(dwIndex = 0; dwIndex < dwNumNewBytes; dwIndex++)
			{
				pbNewBuffer[dwIndex] = *((short*)pbData + dwIndex) < 0 ? 
					128 - MulDiv(abs(*((short*)pbData + dwIndex)), 128, 32768) :
					128 + MulDiv(abs(*((short*)pbData + dwIndex)), 127, 32767);
			}

			delete[] pbData;
			pbData = pbNewBuffer;
		}
		else
		{
			short* pnNewBuffer = NULL;
			if(FAILED(SafeAllocBuffer((BYTE**)&pnNewBuffer, dwNumNewBytes)))
			{
				return E_OUTOFMEMORY;
			}

			for(dwIndex = 0; dwIndex < dwSamples; dwIndex++)
			{
				pnNewBuffer[dwIndex] = *(pbData + dwIndex) < 128 ? 
					- MulDiv(abs(*(pbData + dwIndex) - 128), 32768, 128) :
					+ MulDiv(*(pbData + dwIndex) - 128, 32767, 127);
			}

			delete[] pbData;
			pbData = (BYTE*)pnNewBuffer;
		}
	}

	if(FAILED(m_pDataManager->InsertData(dwStart, (BYTE*)pbData, dwSamples)))
	{
		return E_FAIL;
	}

	delete[] pbData;
	
    m_OriginalWavObj.dwDataSize = dwNewBufferSize;
    m_dwDataSize = m_OriginalWavObj.dwDataSize; 
    m_dwWaveLength += dwSamples;

	return S_OK;
}


HRESULT CMonoWave::MergeStereoDataBuffers(short* pbLeftChannelData, short* pbRightChannelData, WAVEFORMATEX wfxClipFormat, short* pbMergedData, DWORD dwDataSize)
{
	if(pbLeftChannelData == NULL)
		return E_POINTER;
	if(pbRightChannelData == NULL)
		return E_POINTER;
	if(pbMergedData == NULL)
		return E_POINTER;

	int nBytesPerSample = 1;
	if(wfxClipFormat.wBitsPerSample == 16)
		nBytesPerSample = 2;
	
	for(int nCount = 0; nCount < (int)(dwDataSize / 2); nCount += nBytesPerSample)
	{
		short dwMergedSampleValue = 0;
		if(wfxClipFormat.wBitsPerSample == 8)
		{
			dwMergedSampleValue = (pbLeftChannelData[nCount] + pbRightChannelData[nCount]) / 2;
			pbMergedData[nCount] = (BYTE)dwMergedSampleValue;
		}
		else
		{
			dwMergedSampleValue = (pbLeftChannelData[nCount] + pbRightChannelData[nCount]) / 2;
			pbMergedData[nCount] = dwMergedSampleValue;
		}
	}

	return S_OK;
}

HRESULT CMonoWave::InsertSilence(DWORD dwStart, DWORD dwLength)
{
	if( dwLength == 0 )
	{
		return S_OK;
	}

	DWORD dwBytesPerSample = 1;
	if(m_rWaveformat.wBitsPerSample > 8)
	{
		dwBytesPerSample = m_rWaveformat.wBitsPerSample / 8;
	}

	BYTE* pbBuffer = new BYTE[dwLength * dwBytesPerSample];
	if( !pbBuffer )
	{
		return E_FAIL;
	}

	ZeroMemory( pbBuffer, dwLength * dwBytesPerSample );

	HRESULT hr = InsertWaveData(pbBuffer, m_rWaveformat, dwLength, dwStart);
	if(FAILED(hr))
	{
		delete[] pbBuffer;
		return E_FAIL;
	}

	// If inserted before loop start point
	if( dwStart < m_rWLOOP.ulStart )
	{
		// Update the start and end values
		SetLoop( m_rRLOOP.dwStart + dwLength, m_rRLOOP.dwEnd + dwLength );
	}
	// If inserted before loop end point
	else if( dwStart < m_rWLOOP.ulStart + m_rWLOOP.ulLength )
	{
		// Update end value (start remains the same)
		SetLoop( m_rRLOOP.dwStart, m_rRLOOP.dwEnd + dwLength );
	}

	return S_OK;
}

HRESULT CMonoWave::CopyLoop()
{
	// Wave's not looped?
	if(m_bPlayLooped == false)
	{
		return E_FAIL;
	}

	DWORD dwLoopLength = m_rWLOOP.ulLength;
	DWORD dwStartSample = m_rWLOOP.ulStart;
	DWORD dwEndSample = dwStartSample + dwLoopLength;

	BYTE* pbBuffer = NULL;
	if(FAILED(GetChannelData(dwStartSample, dwLoopLength, &pbBuffer)))
	{
		return E_FAIL;
	}

	DWORD dwStart = dwEndSample;
	DWORD dwEnd = dwStart;
	HRESULT hr = InsertWaveData(pbBuffer, m_rWaveformat, dwLoopLength, dwStart);
	if(FAILED(hr))
	{
		delete[] pbBuffer;
		return E_FAIL;
	}

	// Move the loop values to the copied position now...
	m_rWLOOP.ulStart = dwEndSample;
	m_rRLOOP.dwStart = dwEndSample;
	m_rRLOOP.dwEnd = dwEndSample + dwLoopLength;

	UpdateLoopInRegions();

	return S_OK;
}

short* CMonoWave::GetWaveData()
{
	BYTE* pbData = NULL;
	if(FAILED(GetChannelData(0, m_dwWaveLength, &pbData)))
	{
		return NULL;
	}

	return (short*)pbData;
}

HRESULT CMonoWave::UpdateDataForStereoCompression(const DMUSP_WAVEOBJECT& stereoWaveObject)
{
	CleanWaveObject(&m_DecompressedWavObj);
	
	DWORD dwDataSize = stereoWaveObject.dwDataSize;

	m_dwDataSize = dwDataSize / 2;
	m_bCompressed = true;	
	CopyMemory(&m_DecompressedWavObj.WaveFormatEx, &(stereoWaveObject.WaveFormatEx), sizeof(WAVEFORMATEX));
	m_DecompressedWavObj.dwDataSize = m_dwDataSize;

	CopyMemory(&m_rWaveformat, &(stereoWaveObject.WaveFormatEx), sizeof(WAVEFORMATEX));
	m_rWaveformat.nChannels = 1;
	if(((m_rWaveformat.wBitsPerSample == 8) && (m_rWaveformat.nBlockAlign == 2)) ||
	  ((m_rWaveformat.wBitsPerSample == 16) && (m_rWaveformat.nBlockAlign == 4)))
	{
		m_rWaveformat.nBlockAlign = m_rWaveformat.nBlockAlign / 2;
	}
	if (m_rWaveformat.wBitsPerSample == 8)
	{
		m_dwWaveLength = m_dwDataSize;
	}
	else
	{
		m_dwWaveLength = m_dwDataSize >> 1;
	}

	return S_OK;
}

HRESULT CMonoWave::SetUncompressedData(const DMUSP_WAVEOBJECT& stereoWaveObject)
{
	CleanWaveObject(&m_OriginalWavObj);
	
	DWORD dwDataSize = stereoWaveObject.dwDataSize;

	m_OriginalWavObj.dwDataSize = dwDataSize / 2;
	CopyMemory(&m_OriginalWavObj.WaveFormatEx, &(stereoWaveObject.WaveFormatEx), sizeof(WAVEFORMATEX));

	m_OriginalWavObj.WaveFormatEx.nChannels = 1;
	if(((m_OriginalWavObj.WaveFormatEx.wBitsPerSample == 8) && (m_OriginalWavObj.WaveFormatEx.nBlockAlign == 2)) ||
	  ((m_OriginalWavObj.WaveFormatEx.wBitsPerSample == 16) && (m_OriginalWavObj.WaveFormatEx.nBlockAlign == 4)))
	{
		m_OriginalWavObj.WaveFormatEx.nBlockAlign = m_OriginalWavObj.WaveFormatEx.nBlockAlign / 2;
	}

	if(m_bCompressed == false)
	{
		m_dwDataSize = m_OriginalWavObj.dwDataSize;
		if (m_OriginalWavObj.WaveFormatEx.wBitsPerSample == 8)
		{
			m_dwWaveLength = m_dwDataSize;
		}
		else
		{
			m_dwWaveLength = m_dwDataSize >> 1;
		}
	}

	return S_OK;

}

HRESULT	CMonoWave::GetPlayTimeForTempo(int nTempo, DWORD& dwPlayTime)
{
	// Normal tempo is 120 bpm
	float fNormalPlayTime = (float) m_dwWaveLength / m_rWaveformat.nSamplesPerSec;
	dwPlayTime = (DWORD)(nTempo * (fNormalPlayTime / 120));

	return S_OK;
}

void CMonoWave::SnapToZero(DWORD& dwSample, UINT nDirection)
{
	// We don't care about start and end samples
	if(dwSample == 0 || dwSample == m_dwWaveLength - 1)
		return;

	bool fForward = (nDirection & SNAP_FORWARD) != 0;
	bool fBackward = (nDirection & SNAP_BACKWARD) != 0;
	ASSERT(fForward || fBackward); // at least one direction must be specified
	BYTE* pbData;

	// start with typical case: zero crossing is within 512 samples around start position

	// find boundaries before and after the start sample
	const int dwTypicalLength = 512;
	DWORD dwLengthBefore = fBackward ?
		(dwSample > dwTypicalLength) ?
			dwTypicalLength :				// room to grow on the left
			dwSample :						// clip to start of wave
		0;									// no need to go left
	DWORD dwLengthAfter = fForward ?
		(dwSample+dwTypicalLength <= m_dwWaveLength) ?
			dwTypicalLength :				// room to grow on the right
			m_dwWaveLength-dwSample :		// clip to end of wave
		0;									// no need to go right

	// get data
	ASSERT(dwSample >= dwLengthBefore);
	ASSERT(dwLengthBefore+dwLengthAfter > 0);
	if (FAILED(GetChannelData(dwSample-dwLengthBefore, dwLengthBefore+dwLengthAfter, &pbData)))
		return;

	// look for zero crossing
	int iSnap = FindSnapToZero(pbData, dwLengthBefore, 0, dwLengthBefore+dwLengthAfter, nDirection);
	delete[] pbData;
	if (iSnap != 0)
		{
		dwSample += iSnap;
		return;
		}

	// not found, expand search in each direction
	// note overlap of 2 on each buffer:
	// - we need to compare the last of the previous buffer, to the first of the current one -> overlap 1
	// - FindSnapToZero always skips the first sample -> overlap 1 more
	DWORD dwOffset = dwTypicalLength-2;
	int iSnapBefore = 0;
	int iSnapAfter = 0;
	while (fBackward || fForward)
		{
		ASSERT((iSnapBefore == 0) && (iSnapAfter == 0)); // we should have exited otherwise
		
		// look forward
		if (fForward)
			{
			DWORD dwStart = dwSample+dwOffset;
			if (dwStart > m_dwWaveLength)
				fForward = false; // reached end, stop looking
			else
				{
				DWORD dwLength = dwTypicalLength;
				if (dwStart+dwLength > m_dwWaveLength)
					dwLength = m_dwWaveLength-dwStart;
					
				if (FAILED(GetChannelData(dwStart, dwLength, &pbData)))
					return;
				iSnapAfter = FindSnapToZero(pbData, 0, 0, dwLength, SNAP_FORWARD);
				delete[] pbData;
				}
			}

		// look backward
		if (fBackward)
			{
			if (dwSample < dwOffset)
				fBackward = false; // reached start, stop looking
			else
				{
				DWORD dwStart = dwSample-dwOffset;
				DWORD dwLength = dwTypicalLength;
				if (dwStart < dwLength)
					dwLength = dwStart;
					
				if (FAILED(GetChannelData(dwStart, dwLength, &pbData)))
					return;
				iSnapBefore = FindSnapToZero(pbData, dwLength, 0, dwLength, SNAP_BACKWARD);
				delete[] pbData;
				}
			}

		// return if we found snap values, pick the smallest in absolute value (closest to start sample)
		if ((iSnapBefore != 0) || (iSnapAfter != 0))
			{
			ASSERT(iSnapBefore <= 0);
			ASSERT(iSnapAfter >= 0);
			if ((iSnapBefore < 0) && (iSnapAfter > 0))
				if (-iSnapBefore < iSnapAfter)
					iSnapAfter = 0;
				else
					iSnapBefore = 0;
			if (iSnapBefore < 0)
				dwSample -= dwOffset - iSnapBefore;
			else
				dwSample += dwOffset + iSnapAfter;
			return;
			}

		// prepare for next loop
		dwOffset += dwTypicalLength-2;
		}

	// no zero crossing found across entire wave in the given direction(s)
}

/* looks for the zero crossing start at dwSample, in the given nDirection, within the limits of dwLeft and dwRight.
	If found, returns the offset from dwSample in iOffset. Returns 0 if not found. */
int CMonoWave::FindSnapToZero(BYTE *pbData, DWORD dwSample, DWORD dwLeft, DWORD dwRight, UINT nDirection)
{
	int nCount = 1;
	if(m_rWaveformat.wBitsPerSample == 8)
    {
        BYTE* pByte = (BYTE*) pbData;
		while ((dwSample >= dwLeft+nCount) || (dwSample+nCount < dwRight))
        {
            if((nDirection & SNAP_FORWARD) && (dwSample + nCount + 1) < (int)dwRight)
            {
                if(pByte[dwSample + nCount] >= 128 && pByte[dwSample + nCount + 1] < 128)
                	return nCount + 1;
            }

            if((nDirection & SNAP_BACKWARD) && dwSample >= (dwLeft+nCount+1))
            {  
				// check in the other direction.
                if(pByte[dwSample - nCount] < 128 && pByte[dwSample - nCount - 1] >= 128)
                	return -nCount;
            }

			nCount++;
        } 
	}
	else
    {
		short* pnData = (short*) pbData;
		while ((dwSample >= dwLeft+nCount) || (dwSample+nCount < dwRight))
		{
			if((nDirection & SNAP_FORWARD) && (dwSample + nCount + 1) < (int)dwRight)
			{
				if( pnData[dwSample + nCount] >= 0 && pnData[dwSample + nCount + 1] < 0 )
					return nCount+1;
			}

			if((nDirection & SNAP_BACKWARD) && dwSample >= (dwLeft+nCount+1))
			{
				// Check in the other direction.
				if(pnData[dwSample - nCount] < 0 && pnData[dwSample - nCount - 1] >= 0)
					return -nCount;
			}

			nCount++;
		} 
	}

	return false; // not found
}

void CMonoWave::UpdateOnUndo(HEADER_INFO headerInfo)
{
	CWave::UpdateOnUndo(headerInfo);
	if(IsStereo() == FALSE)
	{
		if(SUCCEEDED(UpdateHeaderStream()))
		{
			m_pWaveNode->ReloadDirectSoundWave();
		}
	}
}


HRESULT	CMonoWave::WriteRIFFHeaderToStream(IStream* pIStream, DWORD* pdwBytesWritten)
{
	ASSERT(pIStream);
	if(pIStream == NULL)
	{
		return E_POINTER;
	}

	ASSERT(pdwBytesWritten);
	if(pdwBytesWritten == NULL)
	{
		return E_POINTER;
	}

	// Seek to the begiinning of this stream...
	if(FAILED(StreamSeek(pIStream, 0, STREAM_SEEK_SET)))
	{
		return E_FAIL;
	}

	IDMUSProdRIFFStream* pIRiffStream = NULL;
	if(FAILED(AllocRIFFStream(pIStream, &pIRiffStream)))
	{
		return E_OUTOFMEMORY;
	}

	MMCKINFO ckMain;
	ckMain.fccType = mmioFOURCC('W','A','V','E');
	
	// RIFF chunk size = 'WAVE' + 'wavhXXXX' + sizeof(DMUS_IO_WAVE_HEADER) + 'fmt XXXX' + PCM-WAVEFORMATEX + 'dataXXXX' + actual data size
	ckMain.cksize = 4 + 8 + sizeof(DMUS_IO_WAVE_HEADER) + 8 + sizeof(WAVEFORMATEX) + 8 + m_dwDataSize;

	HRESULT hr = pIRiffStream->CreateChunk(&ckMain, MMIO_CREATERIFF);
    if(FAILED(hr))
	{
		pIRiffStream->Release();
        return (hr);
    }


	// Save the 'wavh' chunk that keeps the streaming info
	MMCKINFO ck;
	ck.ckid = DMUS_FOURCC_WAVEHEADER_CHUNK;
	hr = pIRiffStream->CreateChunk(&ck, 0);
    if (FAILED(hr))
    {
		pIStream->Release();
        return hr;
    }

	_DMUS_IO_WAVE_HEADER waveHeader;
	if(FAILED(CWave::GetStreamingWaveHeader(&waveHeader)))
	{
		pIStream->Release();
		return E_FAIL;
	}

	DWORD cb = 0;
	hr = pIStream->Write((LPSTR)&waveHeader, sizeof(_DMUS_IO_WAVE_HEADER), &cb);
	if(FAILED(hr) || cb != sizeof(_DMUS_IO_WAVE_HEADER))
	{
		pIStream->Release();
		return E_FAIL;
	}
	
	if(FAILED(pIRiffStream->Ascend(&ck, 0)))
	{
		pIStream->Release();
		return E_FAIL;
	}


	if(FAILED(WriteFormat(pIRiffStream, false)))
	{
		pIRiffStream->Release();
		return E_FAIL;
	}

	// Keep the offset before writing the data-ck
	DWORD dwOffset = StreamTell(pIStream);

	// Write only upto <data-ck>[size]
	ck.ckid = mmioFOURCC('d','a','t','a');
	ck.cksize = m_dwDataSize;
	if(FAILED(pIRiffStream->CreateChunk(&ck,0)))
	{
		pIRiffStream->Release();
		return E_FAIL;
	}

	// Don't ascend the data chunk as we're not writing any wave data
	// We just need to have the correct data size set in the chunk 
	DWORD dwBytesFromStart = StreamTell(pIStream);
	StreamSeek(pIStream, dwOffset, STREAM_SEEK_SET);

	if(FAILED(StreamSeek(pIStream, 0, STREAM_SEEK_SET)))
	{
		return E_FAIL;
	}

	*pdwBytesWritten = dwBytesFromStart;
	pIRiffStream->Release();

	return S_OK;
}


HRESULT CMonoWave::WriteFormat(IDMUSProdRIFFStream* pIRiffStream, bool bRuntime)
{
	ASSERT(pIRiffStream);
	if(pIRiffStream == NULL)
	{
		return E_POINTER;
	}

	IStream* pIStream = pIRiffStream->GetStream();
	ASSERT(pIStream);
	if(pIStream == NULL)
	{
		return E_FAIL;
	}

	MMCKINFO ck;
	ck.ckid = mmioFOURCC('f','m','t',' ');
	HRESULT hr = pIRiffStream->CreateChunk(&ck, 0);
	if(FAILED(hr))
	{
		pIStream->Release();
		return hr;
	}

	// Run Time -> We need to save the compressed wav format
	if(bRuntime && m_bCompressed)  
	{
		DWORD cb = 0;
		hr = pIStream->Write((LPSTR) &(m_CompressedWavObj.WaveFormatEx), sizeof(WAVEFORMATEX), &cb);
		if (FAILED(hr) || cb != sizeof(WAVEFORMATEX))
		{
			pIStream->Release();
			return E_FAIL;
		}

		// Save the extra information with format info
		hr = pIStream->Write((LPSTR) m_CompressedWavObj.pbExtractWaveFormatData, m_CompressedWavObj.WaveFormatEx.cbSize, &cb); 
		if (FAILED(hr) || cb != m_CompressedWavObj.WaveFormatEx.cbSize)
		{
			pIStream->Release();
			return E_FAIL;
		}
	}
	else // Design Time -> Save the original uncompressed wav format
	{
		DWORD cb = 0;
		hr = pIStream->Write((LPSTR) &(m_OriginalWavObj.WaveFormatEx),sizeof(WAVEFORMATEX), &cb);	
		if (FAILED(hr) || cb != sizeof(WAVEFORMATEX))
		{
			pIStream->Release();
			return E_FAIL;
		}
	}

	if (FAILED(pIRiffStream->Ascend(&ck, 0)))
	{
		pIStream->Release();
		return E_FAIL;
	}

	pIStream->Release();

	return S_OK;
}


HRESULT	CMonoWave::WriteCompressionChunk(IDMUSProdRIFFStream* pIRiffStream, bool bRuntime)
{
	ASSERT(pIRiffStream);
	if(pIRiffStream == NULL)
	{
		return E_POINTER;
	}

	IStream* pIStream = pIRiffStream->GetStream();
	ASSERT(pIStream);
	if(pIStream == NULL)
	{
		return E_FAIL;
	}

	MMCKINFO ck;
	ck.ckid = mmioFOURCC('w','a','v','u'); 
	HRESULT hr = pIRiffStream->CreateChunk(&ck, 0);
	if(FAILED(hr))
	{
		pIStream->Release();
		return (hr);
	}

	// Save the flag that marks whether this file is Runtime or Designtime
	DWORD cb = 0;
	hr = pIStream->Write((LPSTR) &(bRuntime), sizeof(bool), &cb);	
	if(FAILED(hr) || cb != sizeof(bool))
	{
		pIStream->Release();
		return E_FAIL;
	}

	// Save the flag that marks compression
	hr = pIStream->Write((LPSTR) &(m_bCompressed), sizeof(bool), &cb);	
	if(FAILED(hr) || cb != sizeof(bool))
	{
		pIStream->Release();
		return E_FAIL;
	}

	// Save the compression format in the wavu chunk if this is not a runtime save
	if(m_bCompressed && bRuntime == false)
	{
		// Save the format header
		hr = pIStream->Write((LPSTR) &(m_CompressedWavObj.WaveFormatEx), sizeof(WAVEFORMATEX), &cb);	
		if(FAILED(hr) || cb != sizeof(WAVEFORMATEX))
		{
			pIStream->Release();
			return E_FAIL;
		}
		
		// Compressed waves might have extra information in the header
		if(m_CompressedWavObj.WaveFormatEx.cbSize)
		{
			hr = pIStream->Write(m_CompressedWavObj.pbExtractWaveFormatData, m_CompressedWavObj.WaveFormatEx.cbSize, &cb);
			if(FAILED(hr) || cb != m_CompressedWavObj.WaveFormatEx.cbSize)
			{
				pIStream->Release();
				return E_FAIL;
			}
		}
	}

	// But if it is the runtime save then we'd rather preserve the original wave format to uncompress it properly
	if(m_bCompressed && bRuntime)
	{
		// Save the format header
		hr = pIStream->Write((LPSTR) &(m_OriginalWavObj.WaveFormatEx), sizeof(WAVEFORMATEX), &cb);	
		if (FAILED(hr) || cb != sizeof(WAVEFORMATEX))
		{
			pIStream->Release();
			return E_FAIL;
		}
		
		// Compressed waves might have extra information in the header
		if(m_OriginalWavObj.WaveFormatEx.cbSize)
		{
			hr = pIStream->Write(m_OriginalWavObj.pbExtractWaveFormatData, m_OriginalWavObj.WaveFormatEx.cbSize, &cb);
			if(FAILED(hr) || cb != m_OriginalWavObj.WaveFormatEx.cbSize)
			{
				pIStream->Release();
				return E_FAIL;
			}
		}
	}

    // Write the actual start of the decompressed data
    cb = 0;
    hr = pIStream->Write(&m_dwDecompressedStart, sizeof(DWORD), &cb);
    if(FAILED(hr) || cb != sizeof(DWORD))
    {
        pIStream->Release();
        return E_FAIL;
    }

	if (FAILED(pIRiffStream->Ascend(&ck, 0)))
	{
		pIStream->Release();
		return E_FAIL;
	}

	pIStream->Release();

	return S_OK;
}


HRESULT CMonoWave::WriteFACTChunk(IDMUSProdRIFFStream* pIRiffStream)
{
	ASSERT(pIRiffStream);
	if(pIRiffStream == NULL)
	{
		return E_POINTER;
	}

	IStream* pIStream = pIRiffStream->GetStream();
	ASSERT(pIStream);
	if(pIStream == NULL)
	{
		return E_FAIL;
	}

	MMCKINFO ck;
	ck.ckid = mmioFOURCC('f','a','c','t');
	HRESULT hr = pIRiffStream->CreateChunk(&ck, 0);
	if(FAILED(hr))
	{
		pIStream->Release();
		return (hr);
	}

	// Write the number of original samples (before compression)
	int nSampleSize = m_OriginalWavObj.WaveFormatEx.wBitsPerSample / 8;
	DWORD dwSamples = m_OriginalWavObj.dwDataSize / nSampleSize;
	
    DWORD cb = 0;
	hr = pIStream->Write((LPSTR) &(dwSamples), sizeof(DWORD), &cb);
	if(FAILED(hr) || cb != sizeof(DWORD))
	{
		pIStream->Release();
		return E_FAIL;
	}

	if (FAILED(pIRiffStream->Ascend(&ck, 0)))
	{
		pIStream->Release();
		return E_FAIL;
	}

	pIStream->Release();

	return S_OK;
}


HRESULT CMonoWave::WriteRSMPLChunk(IDMUSProdRIFFStream* pIRiffStream)
{
	ASSERT(pIRiffStream);
	if(pIRiffStream == NULL)
	{
		return E_POINTER;
	}

	IStream* pIStream = pIRiffStream->GetStream();
	ASSERT(pIStream);
	if(pIStream == NULL)
	{
		return E_FAIL;
	}

	MMCKINFO ck;
	ck.ckid = mmioFOURCC('s','m','p','l');
    HRESULT hr = pIRiffStream->CreateChunk(&ck, 0);
    if (FAILED(hr))
    {
		pIStream->Release();
        return (hr);
    }

    DWORD dwSaveSize = sizeof(RSMPL);
    if (m_rRSMPL.cSampleLoops > 0)
    {
        dwSaveSize += sizeof(RLOOP);
        m_rRSMPL.cSampleLoops = 1;
    }

	DWORD cb = 0;
    hr = pIStream->Write((LPSTR) &m_rRSMPL,dwSaveSize, &cb);
    if (FAILED(pIRiffStream->Ascend(&ck, 0)) || cb != dwSaveSize)
    {
		pIStream->Release();
        return E_FAIL;
    }

	pIStream->Release();

	return S_OK;
}

BOOL CMonoWave::IsTrueStereo()
{
	return FALSE;
}

HRESULT CMonoWave::CloseSourceHandler()
{
	ASSERT(m_pDataManager);
	if(m_pDataManager == NULL)
	{
		return E_FAIL;
	}

	HRESULT hr = E_FAIL;
	EnterCriticalSection(&m_pWaveNode->m_CriticalSection);
	hr = m_pDataManager->CloseSourceHandler();
	LeaveCriticalSection(&m_pWaveNode->m_CriticalSection);

	return hr;
}


HRESULT CMonoWave::OnSourceRenamed(CString sNewName)
{
	ASSERT(m_pDataManager);
	if(m_pDataManager == NULL)
	{
		return E_FAIL;
	}

	HRESULT hr = E_FAIL;
	EnterCriticalSection(&m_pWaveNode->m_CriticalSection);
	hr = m_pDataManager->OnSourceRenamed(sNewName);
	LeaveCriticalSection(&m_pWaveNode->m_CriticalSection);
	
	return hr;
}


HRESULT CMonoWave::FileNameChanged(CString sNewFileName)
{
	ASSERT(m_pDataManager);
	if(m_pDataManager == NULL)
	{
		return E_FAIL;
	}
	
	if(FAILED(m_pDataManager->Initialize(sNewFileName, m_dwHeaderOffset, m_dwDataOffset, false)))
	{
		return E_FAIL;
	}

	return S_OK;
}

HRESULT	CMonoWave::UpdateHeaderStream()
{
	if(IsStereo() == false)
	{
		return CWave::UpdateHeaderStream();
	}

	return E_FAIL;
}

HRESULT CMonoWave::FindBestLoop(DWORD dwLoopStart, DWORD dwFindStart, DWORD dwFindEnd, int nFindWindow, DWORD* pdwBestLoopEnd)
{
	ASSERT(nFindWindow > 0);
	if(nFindWindow <= 0)
	{
		return E_FAIL;
	}

	dwFindEnd = dwFindEnd >= (m_dwWaveLength - (nFindWindow / 2)) ? ((m_dwWaveLength - (nFindWindow / 2)) - 1) : dwFindEnd;

	DWORD dwSourceStart = dwLoopStart - (nFindWindow / 2);
	if((int)dwSourceStart < 0)
	{
		dwSourceStart = 0;
	}

	BYTE* pbSourcePattern = NULL;
	if(FAILED(GetChannelData(dwSourceStart, nFindWindow, &pbSourcePattern)))
	{
		return E_FAIL;
	}

	if(dwFindStart <= dwLoopStart + (nFindWindow / 2))
	{
		dwFindStart = dwLoopStart + (nFindWindow / 2) + 1;
	}

	DWORD dwMinDiff = 0xFFFFFFFF;
	DWORD dwBestSample = dwFindStart;

	DWORD dwMatchStart = (dwFindStart - (nFindWindow / 2));
	while((dwMatchStart + (nFindWindow / 2) <= dwFindEnd) && (dwMatchStart + (nFindWindow / 2) < m_dwWaveLength))
	{
		BYTE* pbMatchPattern = NULL;
		if(FAILED(GetChannelData(dwMatchStart, nFindWindow, &pbMatchPattern)))
		{
			delete[] pbSourcePattern;
			pbSourcePattern = NULL;
			return E_FAIL;
		}

		int nSampleSize = m_rWaveformat.wBitsPerSample;
		
		DWORD dwDiff = 0;
		if(nSampleSize == 16)
		{
			dwDiff = DiffPatterns((short*)pbSourcePattern, (short*)pbMatchPattern, nFindWindow);
		}
		else
		{
			dwDiff = DiffPatterns(pbSourcePattern, pbMatchPattern, nFindWindow);
		}

		if(dwDiff <= dwMinDiff)
		{
			dwMinDiff = dwDiff;
			dwBestSample = dwMatchStart;
		}

		dwMatchStart++;
		
		delete[] pbMatchPattern;
		pbMatchPattern = NULL;
	}

	delete[] pbSourcePattern;
	*pdwBestLoopEnd = dwBestSample + ((nFindWindow / 2) - 1);
	return S_OK;
}

template <class T>
DWORD CMonoWave::DiffPatterns(T* pSourcePattern, T* pMatchPattern, DWORD dwPatternLength)
{
	DWORD dwDiff = 0;
	DWORD dwStart = 0;
	while(dwStart < dwPatternLength)
	{
		 dwDiff += abs(pSourcePattern[dwStart] - pMatchPattern[dwStart]);
		 dwStart++;
	}

	return dwDiff;
}

template <class T> 
HRESULT CMonoWave::MixStereoToMono(T* pStereoData, T* pMonoData, DWORD dwStereoLength)
{
	ASSERT(pStereoData);
	if(pStereoData == NULL)
	{
		return E_POINTER;
	}

	ASSERT(pMonoData);
	if(pMonoData == NULL)
	{
		return E_POINTER;
	}

	if(dwStereoLength == 0)
	{
		return S_OK;
	}

	DWORD dwStereoSample = 0;
	for(DWORD dwMonoSample = 0; dwMonoSample < dwStereoLength; dwMonoSample++)
	{
		pMonoData[dwMonoSample] = ((pStereoData[dwStereoSample] + pStereoData[dwStereoSample++]) / 2);
		dwStereoSample++;
	}

	return S_OK;
}

HRESULT CMonoWave::GetDMIDForPort(IDirectMusicPortDownload* pIDMDownloadPort, DWORD* pdwDMID) const
{
    ASSERT(pdwDMID);
    if(pdwDMID == NULL)
        return E_POINTER;

	AllocatedPortBufferPair* pBuffer = GetAllocatedBufferForPort(pIDMDownloadPort);
	if (!pBuffer)
		return E_FAIL;

	*pdwDMID = pBuffer->GetDMID();
	return S_OK;
}

BOOL CMonoWave::GetWaveForDownloadID(DWORD dwID)
{
    POSITION position = m_lstAllocatedBuffers.GetHeadPosition();
    while(position)
    {
        AllocatedPortBufferPair* pBuffer = m_lstAllocatedBuffers.GetNext(position);
        ASSERT(pBuffer);
        if(pBuffer->GetDMID() == dwID)
        {
            return TRUE;
        }
    }

    return FALSE;
}

/* returns given channel */
CMonoWave *CMonoWave::GetChannel(LONG iChannel)
{
	if (iChannel == 0)
		return this;

	ASSERT(FALSE); // only one channel in a mono wave
	return NULL;
}

/* sets wavelink parameters according to channel number */
void CMonoWave::SetWaveLinkPerChannel(LONG iChannel, WAVELINK *pwl)
{
	ASSERT(pwl);
	ASSERT(iChannel == 0);
	pwl->ulTableIndex = GetWaveID();
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\DLSDesigner\NameUnknownQueryDialog.h ===
#if !defined(AFX_NAMEUNKNOWNQUERYDIALOG_H__8F804FE4_569F_4338_A09D_D91E0DC4DF93__INCLUDED_)
#define AFX_NAMEUNKNOWNQUERYDIALOG_H__8F804FE4_569F_4338_A09D_D91E0DC4DF93__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "Resource.h"

// NameUnknownQueryDialog.h : header file
//
class CDLSComponent;

/////////////////////////////////////////////////////////////////////////////
// CNameUnknownQueryDialog dialog

class CNameUnknownQueryDialog : public CDialog
{
// Construction
public:
	CNameUnknownQueryDialog(CWnd* pParent = NULL, CDLSComponent* pComponent = NULL);   // standard constructor

// Dialog Data
	//{{AFX_DATA(CNameUnknownQueryDialog)
	enum { IDD = IDD_NAME_UNNKNOWNQUERY_DIALOG };
	CEdit	m_QueryNameEdit;
	CStatic	m_QueryGUIDStatic;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CNameUnknownQueryDialog)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

public:
	void SetQueryGUID(const GUID& guidQuery);
	CString GetQueryName()
	{
		return m_sQueryName;
	};

private:
	void SetGUIDString();	// Sets the GUID on the static control

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CNameUnknownQueryDialog)
	virtual BOOL OnInitDialog();
	virtual void OnOK();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

private:
	CDLSComponent*	m_pComponent;
	GUID			m_guidQuery;
	CString			m_sQueryName;
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_NAMEUNKNOWNQUERYDIALOG_H__8F804FE4_569F_4338_A09D_D91E0DC4DF93__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\DLSDesigner\MonoWave.h ===
#ifndef __MONOWAVE_H__
#define __MONOWAVE_H__

// MonoWave.h : header file
//

#include "DLSComponent.h"
#include "DLSDocType.h"
#include "RiffStrm.h"
#include "CollectionWaves.h"
#include "Info.h"
#include "DLS1.h"
#include "WaveCtl.h"
#include <mmsystem.h>
#include <mmreg.h>
#include <msacm.h>
#include "WaveCompressionManager.h"


#define DRAW_UNIT_SIZE	100

/*--------------------------------------------------------------------------
CMonoWaveDrawBuffer

Holds a buffer to draw wave files at a given sample rate. Buffer memory is managed
by the class itself (caller should not allocate nor free it).

There are two buffer types, which downsample differently:
- WaveEditor, which are used in the wave editor. Each value is the first sample in
	its sample range of nSamplesPerPixel. 
- WaveTrack, which are used in wave tracks. Each value is the maximum absolute
	value of all samples in the sample range.

The wave "source" can either be a real wave, or another buffer (of the same type)
with a lower sample rate, which can avoid disk reads when switching between buffers
at higher sample rates. No creation or destruction notifications are in place, so caller
needs to release buffers in the right order (from higher to lower sample rate).

Usage:
- initialize the class using one of the Init calls
- call Get with the desired sample start and length (relative to wave start). The
	method returns a buffer pointer and a length. You need to cast the pointer into
	a WORD pointer (or something else) if there is more than one byte per pixel. 
--------------------------------------------------------------------------*/
enum
	{
	mwdbTypeWaveEditor = 1,
	mwdbTypeWaveTrack = 2,
	};

class CMonoWaveDrawBuffer
{
public:
	CMonoWaveDrawBuffer(BYTE mwdbType);
	~CMonoWaveDrawBuffer();

	/* data will be built from wave file */
	void Init(int nSamplesPerPixel, CMonoWave* pMonoWave);

	/* data will be built from another buffer with lower samples / pixel */
	void Init(int nSamplesPerPixel, CMonoWaveDrawBuffer* pMonoWaveDrawBuffer);

	/* ensures the buffer is filled from dwStartSample to a length of dwDrawLength. Returns
		pointer to, and length of, buffer. */
	HRESULT	Get(DWORD dwSampleStart, DWORD dwDrawLength,
		BYTE **ppbBuffer, DWORD *pdwBufferLength);

	/* buffer is dirty and should be recomputed on next Fill call */
	void Dirty();

	/* returns the length of the referenced wave */
	DWORD GetWaveLength();

	/* returns the number of bytes per sample */
	WORD GetBytesPerSample();

	// accessors
	BYTE GetType() { return m_mwdbType; }
	int GetSamplesPerPixel() { return m_nSamplesPerPixel; }

private:
	/* fills the buffer from dwStart to dwEnd */
	HRESULT Fill(DWORD dwUnitStart, DWORD dwUnitEnd);

	/* returns the wave's critical section */
	CRITICAL_SECTION* GetCriticalSection();

	BYTE		m_mwdbType;				// one of the mwdbTypexxx enum
	
	// either one of the following will be non-NULL, depending on which Init method is called
	CMonoWave*				m_pMonoWave;				// reference to the wave to compute draw data from
	CMonoWaveDrawBuffer*	m_pMonoWaveDrawBuffer;		// reference to the wave draw buffer to compute own draw data from
	WORD					m_wBytesPerSample;			// sample size in bytes (1 or 2)

	// all "units" are scaled to the buffer. They correspond to pixels, or (sample number) / (samples per pixel).
	BYTE*		m_pbBuffer;				// buffer
	DWORD		m_dwUnitStart;			// start of valid data in buffer (inclusive), relative to start of wave
	DWORD		m_dwUnitEnd;			// end of valid data in buffer (exclusive), relative to start of wave
	DWORD		m_dwUnitOffset;			// offset of buffer related to start of wave = starting index of buffer
	DWORD		m_cUnits;				// number of samples in the buffer = length of buffer
	int			m_nSamplesPerPixel;		// this also is samples per unit
};

class CMonoWave : public CWave
{
	
public:

	CMonoWave(CWaveNode* pWaveNode, DWORD dwSampleRate = 20050, UINT nSampleSize = 16);
	CMonoWave(CWaveNode*, GUID guidStereoWave, bool bRightChannel, DWORD dwSampleRate = 22050, UINT nSampleSize = 16);
	~CMonoWave();

	// Persistance methods
	HRESULT Load(IDMUSProdRIFFStream* pIRiffStream, MMCKINFO* pckMain);				// Loads the Mono wave
	HRESULT Save(IDMUSProdRIFFStream* pIRiffStream, UINT wType, BOOL fFullSave);	// Saves the Mono wave

	HRESULT LoadHeader(IDMUSProdRIFFStream* pIRiffStream, MMCKINFO* pckMain);		// Loads everything except the wave data
	HRESULT LoadData(IDMUSProdRIFFStream* pIRiffStream, MMCKINFO* pckMain);			// Loads the wave data

	HRESULT ReadWVST(IStream* pIStream, MMCKINFO* pckMain);		   
	HRESULT ReadFMT(IStream* pIStream, MMCKINFO* pckMain);
	HRESULT ReadDataInfo(IStream* pIStream, MMCKINFO* pckMain);
	
	HRESULT	WriteRIFFHeaderToStream(IStream* pIStream, DWORD* pdwBytesWritten);


	HRESULT Download(IDirectMusicPortDownload* pIDMPortDownLoad);		// Downloads the wave to the DirectMusic port
	HRESULT Unload(IDirectMusicPortDownload* pIDMPortDownLoad);			// Unloads the wave from the DirectMusic port

	/* initializes the download port, using a new download ID */
	HRESULT DM_Init(IDirectMusicPortDownload* pIDMPortDownLoad);		// Initializes the download port

	/* initializes the download port, using dwDMID for its id */
	HRESULT DM_Init(IDirectMusicPortDownload* pIDMPortDownLoad, DWORD dwDMID);

	// Compression methods
	HRESULT Compress(const WAVEFORMATEX* pwfDst, bool bInUndoRedo = false);

		
	HRESULT LoadUncompressedOrDesignTimeWave(IStream* pIStream, 
												DWORD dwChunkSize);		// Loads (and (de)compresses Design-Time Wave

	HRESULT LoadRuntimeCompressedWave(IStream* pIStream, 
										DWORD dwChunkSize);				// Loads (and decompresses) the compressed wave data from the runtime stream type
	
	HRESULT CompressLoadedWaveData();									// Encodes the loaded wave data to the required format and updates the compressed & decompressed wave objects

	void	SetWaveBufferToCompressed(bool bSwitch);					// Switches m_pnWave and m_dwDataSize between Compressed and Decompressed waves.

	HRESULT WriteCompressedData(IStream* pIStream, 
								WAVEFORMATEX* pwfxDest, 
								DWORD& cbWritten);						// Compresses and writes the data to the passed stream
																		
	
	HRESULT	Size(DWORD& dwSize);										    // Calculates the size required for the wave buffer
	HRESULT Write(void* pvoid, IDirectMusicPortDownload* pIDMPortDownLoad);	// Writes the wave data to the download buffer
	DWORD	GetDownloadID(IDirectMusicPortDownload* pIDMPortDownLoad) const;// Returns the download ID m_dwDMId

	// Drawing functions
	void	OnDraw(CDC* pDC, const CRect& rcClient);
	void	OnDraw(CDC* pDC, const CRect& rcClient, const long lScrollOffset,						
					DWORD& dwStartSample, DWORD dwLength,
					float fSamplesPerPixel,	const WaveDrawParams* pDrawParams, const WaveTimelineInfoParams* pInfoParams);
    void    RefreshDrawBuffer();

	// Additionalfunctions
	CString	GetName(); 

	DWORD	GetCompressionFormatTag();
	BYTE*	GetCompressionFormatExtraInfo();
	
	HRESULT	GetCompressionFormat(WAVEFORMATEX* pwfxCompression);
	
	BOOL    GetWaveForDownloadID(DWORD dwID);

	ULONG	GetWavePoolOffset();					// Gets the offset into the wave pool; set at save time

	HRESULT GetChannelData(DWORD dwStartSample, DWORD dwLength, BYTE** ppbData, bool bGetUncompressedOnly = false);
    HRESULT GetAllUncompressedChannelData(BYTE** ppbData, DWORD* pdwSize);

	BOOL	IsTrueStereo();
	HRESULT CloseSourceHandler();

	HRESULT UpdateWave();
	HRESULT	UpdateDecompressedWave(const WAVEFORMATEX* pwfxDst);
	HRESULT	SwitchCompression(bool bSwitch);
	
	HRESULT CopySelectionToClipboard(IStream* pIStream, DWORD dwStart, DWORD dwEnd);
	HRESULT PasteSelectionFromClipboard(IStream* pIStream, DWORD dwStart);

	HRESULT	OnWaveBufferUpdated();
	HRESULT RemoveSelection(DWORD dwStart, DWORD dwEnd);
	HRESULT InsertWaveData(BYTE* pbData, WAVEFORMATEX wfxDataFormat, DWORD dwSamples, DWORD dwStart);
	HRESULT InsertSilence(DWORD dwStart, DWORD dwLength);
	HRESULT CopyLoop();
	HRESULT FindBestLoop(DWORD dwLoopStart, DWORD dwFindStart, DWORD dwFindEnd, int nFindWindow, DWORD* pdwBestLoopEnd);
	void	SnapToZero(DWORD& dwSample, UINT nDirection = SNAP_BOTH);

	int		GetNumberOfLoops() const;									// Gets the number of loops set in WSMPL struct

	DWORD	GetDataSize();					// This might be the original data size or the size of the decompressed wave
	DWORD	GetUncompressedDataSize();		// This is always the original wave size
	DWORD	GetCompressedDataSize();		// This is the size of the compressed wave
	HRESULT	UpdateDataForStereoCompression(const DMUSP_WAVEOBJECT& stereoWaveObject);
	HRESULT SetUncompressedData(const DMUSP_WAVEOBJECT& stereoWaveObject);

	HRESULT	GetPlayTimeForTempo(int nTempo, DWORD& dwPlayTime);

	GUID	GetGUID();
	void	SetGUID(const GUID& guidStereoWave);

	short*	GetWaveData();

	void	UpdateOnUndo(HEADER_INFO headerInfo);

	AllocatedPortBufferPair* GetAllocatedBufferForPort(IDirectMusicPortDownload* pIDMPortDownLoad) const;	// Gets the buffer allocated (in DM_Init) for this port
	void					 RemoveFromAllocatedBufferList(AllocatedPortBufferPair* pAllocatedBuffer);	// Releases the allocated buffer and removes the item from the list

	HRESULT FileNameChanged(CString sNewFileName);
	
	HRESULT OnSourceRenamed(CString sNewName);

	HRESULT	UpdateHeaderStream();			 // Updates the header memory stream
	
	void	SetPreviousRegionLinkID(DWORD dwID);
    
    HRESULT GetDMIDForPort(IDirectMusicPortDownload* pIDMDownloadPort, DWORD* pdwDMID) const;

	/* returns channel count */
	virtual LONG GetChannelCount() { return 1; }

	/* returns given channel */
	virtual CMonoWave *GetChannel(LONG iChannel);

	/* sets wavelink parameters according to channel number */
	virtual void SetWaveLinkPerChannel(LONG iChannel, WAVELINK *pwl);

private:
	HRESULT StripChannelData(const BYTE* pbSrcData, DWORD dwChunkSize, BYTE* pbDestBuffer);
	HRESULT MergeStereoDataBuffers(short* pbLeftChannelData, short* pbRightChannelData, WAVEFORMATEX wfxClipFormat, short* pbMergedData, DWORD dwDataSize);

	HRESULT WriteFormat(IDMUSProdRIFFStream* pIRiffStream, bool bRuntime);
	HRESULT	WriteCompressionChunk(IDMUSProdRIFFStream* pIRiffStream, bool bRuntime);
	HRESULT WriteData(IDMUSProdRIFFStream* pIRiffStream, bool bRuntime);
	HRESULT WriteFACTChunk(IDMUSProdRIFFStream* pIRiffStream);
	HRESULT WriteRSMPLChunk(IDMUSProdRIFFStream* pIRiffStream);

	/* looks for the zero crossing start at dwSample, in the given nDirection, within the limits of dwLeft and dwRight.
		If found, returns the offset from dwSample in iOffset. Returns 0 if not found. */
	int		FindSnapToZero(BYTE *pbData, DWORD dwSample, DWORD dwLeft, DWORD dwRight, UINT nDirection);

	template <class T> DWORD DiffPatterns(T* pSourcePattern, T* pMatchPattern, DWORD dwPatternLength);
	template <class T> HRESULT MixStereoToMono(T* pStereoData, T* pMonoData, DWORD dwStereoLength);

public:

	bool	m_bStripChannelData;				// Do we need tostri the data while loading this wave?
    
    CRITICAL_SECTION    m_DrawBufferCreateLock; 

private:

	CTypedPtrList<CPtrList, AllocatedPortBufferPair*>	m_lstAllocatedBuffers;		// List of allocated buffers to be unloaded

	short*				m_pnWave;			// Sample data

	DWORD				m_dwDLSize;		// Size of the download buffer

	GUID				m_guidStereoWave;				// GUID that identifies the stereo wave this mono wave belongs to
	bool				m_bRightChannel;				// Is this the right channel of a stereo wave?

	DWORD				m_cbSizeOffsetTable;

	// wave track buffer
	CMonoWaveDrawBuffer *m_pdbWaveTrack;
	
	// wave editor buffers
	int					m_nSamplesPerPixelOptimum;		// desired sample per pixels rate for optimum zoom buffer. 0 = not initialized, MAX_INT = buffer will never be created
	CMonoWaveDrawBuffer *m_pdbOptimum;					// zoom buffer, from which all lower zooms are computed
	CMonoWaveDrawBuffer *m_pdbLatest;					// latest draw buffer
	CMonoWaveDrawBuffer *m_pdb;							// pointer to the draw buffer currently in use
};


#endif // __MONOWAVE_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\DLSDesigner\newwavedialog.h ===
#if !defined(AFX_NEWWAVEDIALOG_H__686C5727_2333_4743_BBEB_31AA5C8D6505__INCLUDED_)
#define AFX_NEWWAVEDIALOG_H__686C5727_2333_4743_BBEB_31AA5C8D6505__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// newwavedialog.h : header file
//

#include "Resource.h"
#include "afxtempl.h"

#define DEFAULT_SAMPLERATE_COUNT	8
static CString arrDefaultSampleRates[DEFAULT_SAMPLERATE_COUNT] = {"3000", "8000", "11025", "22050", "32000", "44100", "48000", "88000"};


/////////////////////////////////////////////////////////////////////////////
// CNewWaveDialog dialog

class CNewWaveDialog : public CDialog
{
// Construction
public:
	CNewWaveDialog(CWnd* pParent = NULL);   // standard constructor

// Dialog Data
	//{{AFX_DATA(CNewWaveDialog)
	enum { IDD = IDD_NEW_WAVE };
	CComboBox	m_SampleRateCombo;
	CButton	m_MonoButton;
	CButton	m_8BitSampleButton;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CNewWaveDialog)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL


public:
	static CString m_sLastSelectedRate;
	static bool	m_bLastSelected8Bit;
	static bool m_bLastSelectedStereo;


private:
	BOOL IsValidSampleRate(DWORD& dwSampleRate);
	void SetSampleSizeButtons();
	void SetChannelButtons();


// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CNewWaveDialog)
	virtual BOOL OnInitDialog();
	virtual void OnOK();
	afx_msg void On16bitsampleRadiobtn();
	afx_msg void OnStereoRadiobtn();
	afx_msg void On8bitsampleRadiobtn();
	afx_msg void OnMonoRadiobtn();
	afx_msg void OnKillfocusSampleRateCombo();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

private:
	static CArray <DWORD, DWORD> m_arraySampleRate;
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_NEWWAVEDIALOG_H__686C5727_2333_4743_BBEB_31AA5C8D6505__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\DLSDesigner\PatchConflictDlg.cpp ===
// PatchConflictDlg.cpp : implementation file
//

#include "stdafx.h"
#include "dlsdesigner.h"
#include "PatchConflictDlg.h"
#include "DlsDefsPlus.h"
#include "Collection.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

#include "GMStrings.cpp"

/////////////////////////////////////////////////////////////////////////////
// CPatchConflictDlg dialog


CPatchConflictDlg::CPatchConflictDlg(HRESULT hrCode, 
									 CInstrument* pCollidingInstrument,
									 CCollection* pLoadingCollection, 
									 CInstrument* pParentInstrument /*=NULL*/ ) : CDialog(IDD_PATCH_CONFLICT),
m_hrConflictCause(hrCode),
m_pCollidingInstrument(pCollidingInstrument),
m_pLoadingCollection(pLoadingCollection),
m_pInstrument(pParentInstrument),
m_bTouchedByUser(false)
{
	//{{AFX_DATA_INIT(CPatchConflictDlg)
	m_Patch = 0;
	m_LSB = 0;
	m_MSB = 0;
	m_Drum = FALSE;
	//}}AFX_DATA_INIT
	m_iRetVal = 0;
}


void CPatchConflictDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CPatchConflictDlg)
	DDX_Control(pDX, IDC_CONFLICT_NOT_AGAIN_CHECK, m_NotAgainCheck);
	DDX_Text(pDX, IDC_CONFLICT_PATCH, m_Patch);
	DDV_MinMaxUInt(pDX, m_Patch, 0, 127);
	DDX_Text(pDX, IDC_CONFLICT_LSB, m_LSB);
	DDV_MinMaxUInt(pDX, m_LSB, 0, 127);
	DDX_Text(pDX, IDC_CONFLICT_MSB, m_MSB);
	DDV_MinMaxUInt(pDX, m_MSB, 0, 127);
	DDX_Check(pDX, IDC_DRUM, m_Drum);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CPatchConflictDlg, CDialog)
	//{{AFX_MSG_MAP(CPatchConflictDlg)
	ON_EN_CHANGE(IDC_CONFLICT_LSB, OnChangeLSB)
	ON_EN_CHANGE(IDC_CONFLICT_MSB, OnChangeMSB)
	ON_EN_CHANGE(IDC_CONFLICT_PATCH, OnChangePatch)
	ON_BN_CLICKED(IDC_BTN_FIX, OnBtnFix)
	ON_BN_CLICKED(IDC_BTN_FIX_ALL, OnBtnFixAll)
	ON_BN_CLICKED(IDC_BTN_IGNORE_ALL, OnBtnIgnoreAll)
	ON_BN_CLICKED(IDC_DRUM, OnDrum)
	ON_BN_CLICKED(ID_BTN_IGNORE, OnBtnIgnore)
	ON_WM_CANCELMODE()
	ON_BN_CLICKED(IDC_CONFLICT_NOT_AGAIN_CHECK, OnConflictNotAgainCheck)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

void CPatchConflictDlg::InitDlgText()
{
	CString		csDlgPrompt;
	CString		csCatStr;
	CWnd*		pEdit;
	m_MSB = (m_pInstrument->m_rInstHeader.Locale.ulBank & 0x00007F00) >> 8;
	m_LSB = m_pInstrument->m_rInstHeader.Locale.ulBank & 0x0000007F;
	m_Patch = m_pInstrument->m_rInstHeader.Locale.ulInstrument;
	m_Drum = ((m_pInstrument->m_rInstHeader.Locale.ulBank & 0x80000000) == 0) ? FALSE : TRUE;
	
	UpdateData(FALSE);
	//Construct the correct message for the dialog's static text

	csDlgPrompt.LoadString(IDS_PATCH_CONFLICT_COMMON);
	if (m_hrConflictCause & SC_PATCH_DUP_GM)
	{
		csCatStr.LoadString(IDS_PATCH_CONFLICT_GM);
		//To Do: load GM name?
		pEdit = GetDlgItem(IDC_CONFLICTING_INS);
		if (pEdit)
		{
			CString strInstName;
			GetGMInstName(strInstName);
			pEdit->SetWindowText(strInstName);
			pEdit = NULL;
		}
		pEdit = GetDlgItem(IDC_CONFLICT_COLLECTION);
		if (pEdit)
		{
			pEdit->SetWindowText(_T("GM"));
			pEdit = NULL;
		}
	}
	else if (m_hrConflictCause & SC_PATCH_DUP_COLLECTION)
	{
		csCatStr.LoadString(IDS_PATCH_CONFLICT_COLLECTION);
		pEdit = GetDlgItem(IDC_CONFLICTING_INS);
		if (pEdit)
		{
			pEdit->SetWindowText(m_pCollidingInstrument->m_Info.m_csName.GetBuffer(0));
			pEdit = NULL;
		}
		pEdit = GetDlgItem(IDC_CONFLICT_COLLECTION);
		if (pEdit && m_pCollidingInstrument->m_pCollection)
		{
			pEdit->SetWindowText(m_pCollidingInstrument->m_pCollection->m_Info.m_csName.GetBuffer(0));
			pEdit = NULL;
		}
	}
	else if (m_hrConflictCause & SC_PATCH_DUP_SYNTH)
	{
		csCatStr.LoadString(IDS_PATCH_CONFLICT_GENERAL);
		pEdit = GetDlgItem(IDC_CONFLICT_COLLECTION);
		if (pEdit)
		{
			pEdit->SetWindowText(m_pCollidingInstrument->m_pCollection->m_Info.m_csName.GetBuffer(0));
			pEdit = NULL;
		}
		pEdit = GetDlgItem(IDC_CONFLICTING_INS);
		if (pEdit)
		{
			pEdit->SetWindowText(m_pCollidingInstrument->m_Info.m_csName.GetBuffer(0));
			pEdit = NULL;
		}
	}
	csDlgPrompt += csCatStr; 
	CWnd* pPromptText = GetDlgItem(IDC_CONFLICT_DESC_TEXT);
	if ( pPromptText )
	{
		pPromptText->SetWindowText(csDlgPrompt.GetBuffer(0));
	}
	pEdit = GetDlgItem(IDC_CONFLICT_NAME);
	if (pEdit)
	{
		pEdit->SetWindowText(m_pInstrument->m_Info.m_csName.GetBuffer(0));
		pEdit = NULL;
	}
}


/////////////////////////////////////////////////////////////////////////////
// CPatchConflictDlg message handlers

BOOL CPatchConflictDlg::OnInitDialog() 
{
	InitDlgText();
	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}


void CPatchConflictDlg::OnChangeLSB() 
{
	m_bTouchedByUser = true;
}

void CPatchConflictDlg::OnChangeMSB() 
{
	m_bTouchedByUser = true;	
}

void CPatchConflictDlg::OnChangePatch() 
{
	m_bTouchedByUser = true;
}

void CPatchConflictDlg::OnDrum() 
{
	m_bTouchedByUser = true;
}

void CPatchConflictDlg::OnBtnFix() 
{

	CInstrument*	pDummy;
	HRESULT			hr;

	if (m_bTouchedByUser)
	{
		if (UpdateData(TRUE))
		{
			m_bTouchedByUser = false;
			//test patch
			hr = m_pInstrument->m_pComponent->IsValidPatch(m_pInstrument, MAKE_BANK(m_Drum, m_MSB, m_LSB), m_Patch, NULL, &pDummy);
			if ( !SUCCEEDED(hr) )
			{
				//To Do: message notifying user to try again or press fix to auto fix
				return;
			}
		}
		else
		{
			return;
		}
	}
	else
	{
		hr = m_pInstrument->m_pComponent->GetNextValidPatch((DWORD)m_Drum, (BYTE*)&m_MSB, (BYTE*)&m_LSB, (BYTE*)&m_Patch);
		if ( FAILED(hr) )
		{
			//To Do: notify user all valid patches are taken.
			//hr = DLS_NO_VALID_PATCHES;
			//EndDialog(IDCANCEL);
			EndDialog(DLS_NO_VALID_PATCHES);
		}
	}
	m_pInstrument->m_rInstHeader.Locale.ulBank = MAKE_BANK(m_Drum, m_MSB, m_LSB);
	m_pInstrument->m_rInstHeader.Locale.ulInstrument = m_Patch;
	EndDialog(IDOK);
}

void CPatchConflictDlg::OnBtnFixAll() 
{
	//To Do: Check if touched?
	//auto fix
	m_pInstrument->m_pComponent->GetNextValidPatch((DWORD)m_Drum, (BYTE*)&m_MSB, (BYTE*)&m_LSB, (BYTE*)&m_Patch);
	m_pInstrument->m_rInstHeader.Locale.ulBank = MAKE_BANK(m_Drum, m_MSB, m_LSB);
	m_pInstrument->m_rInstHeader.Locale.ulInstrument = m_Patch;
	m_hrConflictCause = S_OK;
	//return autofix
	EndDialog(DLS_DLG_FIX_ALL);
}

void CPatchConflictDlg::OnBtnIgnoreAll() 
{
	if (m_hrConflictCause & SC_PATCH_DUP_GM)
	{
		m_hrConflictCause &= ~SC_PATCH_DUP_GM;
		m_iRetVal |= DLS_DLG_IGNORE_ALL_GM;
	}
	if (m_hrConflictCause & SC_PATCH_DUP_COLLECTION)
	{
		m_hrConflictCause &= ~SC_PATCH_DUP_COLLECTION;
		m_iRetVal |= DLS_DLG_IGNORE_ALL_COLLECTION;
	}
	if (m_hrConflictCause & SC_PATCH_DUP_SYNTH)
	{
		m_hrConflictCause &= ~SC_PATCH_DUP_SYNTH;
		m_iRetVal |= DLS_DLG_IGNORE_ALL_SYNTH;
	}
	if (DLS_ERR_FIRST == m_hrConflictCause)
	{
		EndDialog(m_iRetVal);
	}
	else
	{
		InitDlgText();
		return;
	}
}

void CPatchConflictDlg::OnBtnIgnore() 
{
	if (m_hrConflictCause & SC_PATCH_DUP_GM)
	{
		m_hrConflictCause &= ~SC_PATCH_DUP_GM;
	}
	else if (m_hrConflictCause & SC_PATCH_DUP_COLLECTION)
	{
		m_hrConflictCause &= ~SC_PATCH_DUP_COLLECTION;
	}
	else if (m_hrConflictCause & SC_PATCH_DUP_SYNTH)
	{
		m_hrConflictCause &= ~SC_PATCH_DUP_SYNTH;
	}
	if (DLS_ERR_FIRST == m_hrConflictCause)
	{
		EndDialog(IDCANCEL);
	}
	else
	{
		InitDlgText();
		return;
	}
}

void CPatchConflictDlg::GetGMInstName(CString & strResult)
{
	BInstr* pArr = m_Drum ? &abiDrums[0] : &abiGS[0];
	ASSERT(pArr);
	if(pArr == NULL)
		return;
	
	while(pArr->nStringId != IDS_PGMEND)
	{
		if ((pArr->bPatch == m_Patch) && (pArr->bMSB == m_MSB) &&	(pArr->bLSB == m_LSB))
		{
			// This is the one we want!
			strResult.LoadString(pArr->nStringId);
			break;
		}

		pArr++;
	}
}




void CPatchConflictDlg::OnConflictNotAgainCheck() 
{
	ASSERT(m_pInstrument);
	if(m_pInstrument == NULL)
	{
		return;
	}

	CDLSComponent* pComponent = m_pInstrument->m_pComponent;
	ASSERT(pComponent);
	if(pComponent == NULL)
	{
		return;
	}

	int nCheck = m_NotAgainCheck.GetCheck();
	bool bShow = nCheck == 0 ? false : true;
	pComponent->SetCollectionPatchConflict(bShow);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\DLSDesigner\PatchConflictDlg.h ===
#if !defined(AFX_PATCHCONFLICTDLG_H__A077F003_C94B_11D1_B987_006097B01078__INCLUDED_)
#define AFX_PATCHCONFLICTDLG_H__A077F003_C94B_11D1_B987_006097B01078__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// PatchConflictDlg.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CPatchConflictDlg dialog

#include "resource.h"
#include "Instrument.h"

class CPatchConflictDlg : public CDialog
{
// Construction
public:
	CPatchConflictDlg(HRESULT hrCode, CInstrument* pCollidingInstrument, CCollection* pLoadingCollection, CInstrument* pParentInstrument = NULL);
	
// Dialog Data
	//{{AFX_DATA(CPatchConflictDlg)
	enum { IDD = IDD_PATCH_CONFLICT };
	CButton	m_NotAgainCheck;
	UINT	m_Patch;
	UINT	m_LSB;
	UINT	m_MSB;
	BOOL	m_Drum;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CPatchConflictDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	void GetGMInstName(CString& strResult);

	// Generated message map functions
	//{{AFX_MSG(CPatchConflictDlg)
	virtual BOOL OnInitDialog();
	afx_msg void OnChangeLSB();
	afx_msg void OnChangeMSB();
	afx_msg void OnChangePatch();
	afx_msg void OnBtnFix();
	afx_msg void OnBtnFixAll();
	afx_msg void OnBtnIgnoreAll();
	afx_msg void OnDrum();
	afx_msg void OnBtnIgnore();
	afx_msg void OnConflictNotAgainCheck();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
private:
	void InitDlgText();
	CInstrument*			m_pInstrument;
	CInstrument*			m_pCollidingInstrument;
	CCollection*			m_pLoadingCollection;
	bool					m_bTouchedByUser;
	HRESULT					m_hrConflictCause;
	int						m_iRetVal;
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_PATCHCONFLICTDLG_H__A077F003_C94B_11D1_B987_006097B01078__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\DLSDesigner\ProgressDialog.h ===
#if !defined(AFX_PROGRESSDIALOG_H__78F41A92_4CED_11D2_9A8F_006097B01078__INCLUDED_)
#define AFX_PROGRESSDIALOG_H__78F41A92_4CED_11D2_9A8F_006097B01078__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// ProgressDialog.h : header file
//
#include "Resource.h"


class CWave;
class CProgressUpdateThread : public CWinThread
{

public:
	CProgressUpdateThread();
	~CProgressUpdateThread();

public:
	CProgressCtrl* m_pProgressBar;

};


/////////////////////////////////////////////////////////////////////////////
// CProgressDialog dialog

class CProgressDialog : public CDialog
{
// Construction
public:
	CProgressDialog(CWnd* pParent = NULL);   // standard constructor

// Dialog Data
	//{{AFX_DATA(CProgressDialog)
	enum { IDD = IDD_PROGRESS_DIALOG };
	CProgressCtrl	m_ProgressBar;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CProgressDialog)
	public:
	virtual BOOL DestroyWindow();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

public:
	void SetRange(int nRange);


// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CProgressDialog)
	virtual BOOL OnInitDialog();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

private:
	int		m_nRange;
	UINT	m_uTimerID;



};
//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_PROGRESSDIALOG_H__78F41A92_4CED_11D2_9A8F_006097B01078__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\DLSDesigner\Region.cpp ===
// Region.cpp : implementation file
//

#include "stdafx.h"
#include "DLSDesignerDLL.h"
#include "DLSDesigner.h"
#include "Collection.h"
#include "Instrument.h"
#include "Region.h"
#include "ArticulationList.h"
#include "Articulation.h"
#include "WaveNode.h"
#include "Wave.h"
#include "MonoWave.h"
#include "StereoWave.h"
#include "ConditionalChunk.h"

#include "InstrumentFVEditor.h"
#include "InstrumentCtl.h"

#include "DLSLoadSaveUtils.h"
#include "DlsDefsPlus.h"

#include "RegionPropPgMgr.h"
#include "resource.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


/////////////////////////////////////////////////////////////////////////////
// CRegion constructor/destructor

CRegion::CRegion(CDLSComponent* pComponent, bool bDLS1Region) :
m_pInstrument(NULL),
m_pWave(NULL),
m_usRegionSaved(0),
m_pArticulation(NULL),
m_pIRootNode(NULL),
m_pIParentNode(NULL),
m_pRegionPropPgMgr(NULL),
m_pInstrumentFVEditor(NULL),
m_bOverrideWaveAttenuation(false),
m_bOverrideWaveFineTune(false),
m_bOverrideWaveRootNote(false),
m_bOverrideWaveMoreSettings(false),
m_bDeletingRegion(false),
m_bUseInstrumentArticulation(true),
m_bLastDeleted(FALSE),
m_bDLS1Region(bDLS1Region),
m_bConditionOK(TRUE),
m_nLayer(0),
m_pConditionalChunk(NULL)
{
	ASSERT( pComponent != NULL );

    m_dwRef = 0;
	AddRef();

	m_pComponent = pComponent;
	m_pComponent->AddRef();

	// Create a conditional chunk
	m_pConditionalChunk = new CConditionalChunk(m_pComponent);

    m_rRgnHeader.usKeyGroup = 0;
    m_rRgnHeader.fusOptions = F_RGN_OPTION_SELFNONEXCLUSIVE;
    m_rRgnHeader.RangeKey.usLow = 0;
    m_rRgnHeader.RangeKey.usHigh = 127;
    m_rRgnHeader.RangeVelocity.usLow = 0;
    m_rRgnHeader.RangeVelocity.usHigh = 127;
    m_rWSMP.cbSize = sizeof(WSMPL);
    m_rWSMP.usUnityNote = 60;
    m_rWSMP.sFineTune = 0;
    m_rWSMP.lAttenuation = 0;
    m_rWSMP.fulOptions = F_WSMP_NO_TRUNCATION;
    m_rWSMP.cSampleLoops = 0;
    m_rWLOOP.cbSize = sizeof(WLOOP);
    m_rWLOOP.ulType = WLOOP_TYPE_FORWARD;
    m_rWLOOP.ulStart = 0;
    m_rWLOOP.ulLength = 0;
    m_rWaveLink.ulChannel = WAVELINK_CHANNEL_LEFT;
    m_rWaveLink.fusOptions = 0;
    m_rWaveLink.usPhaseGroup = 0;
    m_rWaveLink.ulTableIndex = 0;

	if(m_pRegionPropPgMgr == NULL)
	{
		m_pRegionPropPgMgr = new CRegionPropPgMgr();
	}
	else
	{
		m_pRegionPropPgMgr->AddRef();
	}
}

CRegion::~CRegion()
{
	// If we are in a Property Page Manager we need to remove ourselves before we go away
	IDMUSProdPropSheet *pIPropSheet;
	if(SUCCEEDED(m_pComponent->m_pIFramework->QueryInterface(IID_IDMUSProdPropSheet, (void**) &pIPropSheet)))
	{
		if(pIPropSheet->IsEqualPageManagerObject(this) == S_OK)
		{
			pIPropSheet->RemovePageManagerByObject(this);
		}
		else
		{
			if(m_pRegionPropPgMgr)
			{
				m_pRegionPropPgMgr->RemoveObject(this);
			}
		}
		pIPropSheet->Release();
	}
	
	if(m_pRegionPropPgMgr)
	{
		DWORD refCount = m_pRegionPropPgMgr->Release();
		if(refCount == 0)
		{
			m_pRegionPropPgMgr = NULL;
		}
	}	
	
	while(!m_lstArticulationLists.IsEmpty())
	{
		CArticulationList* pArticList = (CArticulationList*) m_lstArticulationLists.RemoveHead();
		pArticList->Release();
	}

	if(m_pComponent)
	{
		m_pComponent->Release();
	}

	if(m_pWave)
	{
		CWaveNode* pWaveNode = m_pWave->GetNode();
		if(pWaveNode)
		{
			pWaveNode->Release();
		}
	}

	if(m_pConditionalChunk)
	{
		delete m_pConditionalChunk;
		m_pConditionalChunk = NULL;
	}
}

void CRegion::SetInitialWave(CWave* pWave)
{
	ASSERT(pWave);
	if(pWave == NULL)
		return;

	m_pWave = pWave;

	WSMPL waveWSMP = m_pWave->GetWSMPL();
	WLOOP waveLoop = m_pWave->GetWLOOP();

	m_rWSMP.cSampleLoops = waveWSMP.cSampleLoops;
	m_rWLOOP.ulStart = waveLoop.ulStart;
	m_rWLOOP.ulLength = waveLoop.ulLength;
	m_rWSMP.fulOptions = waveWSMP.fulOptions;
	m_rWSMP.usUnityNote = waveWSMP.usUnityNote;
}


CRegion * CRegion::GetNext() 
{
	return(CRegion *)AListItem::GetNext();
}

void CRegion::GetName()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	m_csName = GetRangeName(FALSE);
    m_csName += " to ";
    m_csName += GetRangeName(TRUE);
    
	if (m_pWave != NULL)
    {
        m_csName += " -> ";
		m_csName += m_pWave->GetName();
    }
}

CString CRegion::GetWaveName()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	return m_pWave ? m_pWave->GetName() : "";
}

CString CRegion::GetRangeName(BOOL bUpper)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	char sBuffer[10]; // J3 make a define
	notetostring(GetRangeValue(bUpper), sBuffer);
    
    return CString(sBuffer);
}

USHORT CRegion::GetRangeValue(BOOL bUpper)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	return bUpper ? m_rRgnHeader.RangeKey.usHigh : m_rRgnHeader.RangeKey.usLow;
}

void CRegion::SetRangeValue(BOOL bUpper, CString csName)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

    if (bUpper)
    {
        m_rRgnHeader.RangeKey.usHigh = stringtonote(csName.GetBuffer(0));

    }
    else
    {
        m_rRgnHeader.RangeKey.usLow = stringtonote(csName.GetBuffer(0));
    }
    csName.ReleaseBuffer();
}

/////////////////////////////////////////////////////////////////////////////
// CRegion IUnknown implementation

HRESULT CRegion::QueryInterface( REFIID riid, LPVOID FAR* ppvObj )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

    if( ::IsEqualIID(riid, IID_IDMUSProdNode)
	||  ::IsEqualIID(riid, IID_IUnknown) )
    {
        AddRef();
        *ppvObj = (IDMUSProdNode *)this;
        return S_OK;
    }

    if( ::IsEqualIID(riid, IID_IPersist) )
    {
        AddRef();
        *ppvObj = (IPersist *)this;
        return S_OK;
    }

    if( ::IsEqualIID(riid, IID_IPersistStream) )
    {
        AddRef();
        *ppvObj = (IPersistStream *)this;
        return S_OK;
    }

    if( ::IsEqualIID(riid, IID_IDMUSProdPropPageObject) )
    {
        AddRef();
        *ppvObj = (IDMUSProdPropPageObject *)this;
        return S_OK;
    }

	if(::IsEqualIID(riid, IID_IDMUSProdNotifySink))
    {
        AddRef();
        *ppvObj = (IDMUSProdNotifySink*)this;
        return S_OK;
    }
    *ppvObj = NULL;
    return E_NOINTERFACE;
}

ULONG CRegion::AddRef()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	AfxOleLockApp();
    return ++m_dwRef;
}

ULONG CRegion::Release()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

    ASSERT( m_dwRef != 0 );

	AfxOleUnlockApp();
    --m_dwRef;

    if( m_dwRef == 0 )
    {
        delete this;
        return 0;
    }

    return m_dwRef;
}

/////////////////////////////////////////////////////////////////////////////
// CRegion IDMUSProdNode implementation

/////////////////////////////////////////////////////////////////////////////
// CRegion IDMUSProdNode::GetNodeImageIndex

HRESULT CRegion::GetNodeImageIndex(short* pnFirstImage)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	
	ASSERT(pnFirstImage);
	
	ASSERT(m_pComponent != NULL);

	if(m_bConditionOK)
	{
		return(m_pComponent->GetRegionImageIndex(pnFirstImage));
	}
	else
	{
		return(m_pComponent->GetRegionGrayedImageIndex(pnFirstImage));
	}
}

/////////////////////////////////////////////////////////////////////////////
// CRegion IDMUSProdNode::GetComponent

HRESULT CRegion::GetComponent( IDMUSProdComponent** ppIComponent )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	
	ASSERT( m_pComponent != NULL );

	return m_pComponent->QueryInterface( IID_IDMUSProdComponent, (void**)ppIComponent );
}


/////////////////////////////////////////////////////////////////////////////
// CRegion IDMUSProdNode::GetRootNode

HRESULT CRegion::GetDocRootNode( IDMUSProdNode** ppIRootNode )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( m_pIRootNode != NULL );

	m_pIRootNode->AddRef();
	*ppIRootNode = m_pIRootNode;

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CRegion IDMUSProdNode::SetRootNode

HRESULT CRegion::SetDocRootNode( IDMUSProdNode* pIRootNode )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( pIRootNode != NULL );

	m_pIRootNode = pIRootNode;
//	m_pIRootNode->AddRef();		intentionally missing

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CRegion IDMUSProdNode::GetParentNode

HRESULT CRegion::GetParentNode( IDMUSProdNode** ppIParentNode )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( m_pIParentNode != NULL );

	m_pIParentNode->AddRef();
	*ppIParentNode = m_pIParentNode;

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CRegion IDMUSProdNode::SetParentNode

HRESULT CRegion::SetParentNode( IDMUSProdNode* pIParentNode )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( pIParentNode != NULL );

	m_pIParentNode = pIParentNode;
//	m_pIParentNode->AddRef();		intentionally missing

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CRegion IDMUSProdNode::GetNodeId

HRESULT CRegion::GetNodeId( GUID* pguid )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( pguid == NULL )
	{
		return E_POINTER;
	}

	*pguid = GUID_RegionNode;

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CRegion IDMUSProdNode::GetNodeName

HRESULT CRegion::GetNodeName(BSTR* pbstrName)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT(pbstrName);
    
 	GetName();
	*pbstrName = m_csName.AllocSysString();

	return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
// CRegion IDMUSProdNode::GetNodeNameMaxLength

HRESULT CRegion::GetNodeNameMaxLength(short* pnMaxLength)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	
	ASSERT(pnMaxLength);
	
	*pnMaxLength = -1; // Can't edit Region name.

	return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
// CRegion IDMUSProdNode::ValidateNodeName

HRESULT CRegion::ValidateNodeName(BSTR bstrName)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	// Just free bstrName; can't rename a Region
	::SysFreeString(bstrName);

	return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
// CRegion IDMUSProdNode::SetNodeName

HRESULT CRegion::SetNodeName( BSTR bstrName )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	CString strName = bstrName;
	::SysFreeString( bstrName );

	m_csName = strName;

	// Set flag so we know to save file 
	m_pInstrument->m_pCollection->SetDirtyFlag();

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CRegion IDMUSProdNode::GetEditorClsId

HRESULT CRegion::GetEditorClsId(CLSID* pClsId)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	
	ASSERT(m_pInstrument);
	
	return(m_pInstrument->GetEditorClsId(pClsId));
}


/////////////////////////////////////////////////////////////////////////////
// CRegion IDMUSProdNode::GetEditorTitle

HRESULT CRegion::GetEditorTitle(BSTR* pbstrTitle)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT(m_pInstrument);
	
	return(m_pInstrument->GetEditorTitle(pbstrTitle));
}


/////////////////////////////////////////////////////////////////////////////
// CRegion IDMUSProdNode::GetEditorWindow

HRESULT CRegion::GetEditorWindow(HWND* hWndEditor)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT(m_pInstrument);
	
	if ( m_bDeletingRegion )
	{
		*hWndEditor = NULL;
		return S_OK;
	}
	else
		return(m_pInstrument->GetEditorWindow(hWndEditor));
}


/////////////////////////////////////////////////////////////////////////////
// CRegion IDMUSProdNode::SetEditorWindow

HRESULT CRegion::SetEditorWindow(HWND hWndEditor)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT(m_pInstrument);
	
	return(m_pInstrument->SetEditorWindow(hWndEditor));
}


/////////////////////////////////////////////////////////////////////////////
// CRegion IDMUSProdNode::UseOpenCloseImages

HRESULT CRegion::UseOpenCloseImages(BOOL* pfUseOpenCloseImages)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT(pfUseOpenCloseImages);

	*pfUseOpenCloseImages = TRUE;

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CRegion IDMUSProdNode::GetRightClickMenuId

HRESULT CRegion::GetRightClickMenuId(HINSTANCE* phInstance, UINT* pnMenuId)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT(pnMenuId);
	ASSERT(phInstance);

	*phInstance = theApp.m_hInstance;
	*pnMenuId = IDM_REGION_NODE_RMENU;

	return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
// CRegion IDMUSProdNode::OnRightClickMenuInit

HRESULT CRegion::OnRightClickMenuInit(HMENU hMenu)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	BOOL status;
	/*if(m_pArticulation)
	{//Note DLS 1 should be || !(m_pInstrument->m_rInstHeader.Locale.ulBank & F_INSTRUMENT_DRUMS)
		status = EnableMenuItem(hMenu, IDM_INSERT_ART, MF_BYCOMMAND | MF_GRAYED);
	}
	else
	{
		status = EnableMenuItem(hMenu, IDM_INSERT_ART, MF_BYCOMMAND | MF_ENABLED);
	}*/
	if (1 < m_pInstrument->m_Regions.GetCount())//can't delete only region
	{
		status = EnableMenuItem(hMenu, IDM_DELETE, MF_BYCOMMAND | MF_ENABLED);
	}
	else
	{
		status = EnableMenuItem(hMenu, IDM_DELETE, MF_BYCOMMAND | MF_GRAYED);
	}
	return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
// CRegion IDMUSProdNode::OnRightClickMenuSelect

HRESULT CRegion::OnRightClickMenuSelect( long lCommandId )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT(m_pComponent != NULL);
	ASSERT(m_pComponent->m_pIFramework != NULL);

	HRESULT hr = E_FAIL;
	IDMUSProdNode* pIParentNode;
	
	switch( lCommandId )
	{
		case IDM_OPEN:
			if(SUCCEEDED(m_pComponent->m_pIFramework->OpenEditor(this)))
			{
				ASSERT(m_pInstrument);
				ASSERT(m_pInstrument->GetInstrumentEditor());
				CInstrumentFVEditor* pIE;
				pIE = m_pInstrument->GetInstrumentEditor();
				if(pIE)
					pIE->SetCurRegion(this);

				hr = S_OK;
			}
			break;
		
		case IDM_INSERT_ART_LIST: 
			{
				if(m_pInstrument)
				{
					m_pInstrument->SaveStateForUndo(IDS_UNDO_INSERT_ARTLIST);
				}
				if(FAILED(InsertChildNode(NULL)))
				{
					return E_FAIL;
				}
				
				hr = S_OK;
				break;
			}
			
		case IDM_CUT:
			hr = E_NOTIMPL;			
			break;

		case IDM_COPY:
			hr = E_NOTIMPL;
			break;

		case IDM_PASTE:
			hr = E_NOTIMPL;
			break;

		case IDM_DELETE:
			if(SUCCEEDED(GetParentNode(&pIParentNode)))
			{
				if(m_pInstrument)
				{
					CInstrumentFVEditor* pIE;
					pIE = m_pInstrument->GetInstrumentEditor();
					if(pIE)
						pIE->TurnOffMidiNotes();
					else
					{
						m_pInstrument->Stop(true);
						m_pInstrument->TurnOffMidiNotes();
						if(m_pInstrument->m_pInstrumentCtrl)
							m_pInstrument->m_pInstrumentCtrl->TurnOffMidiNotes();
					}

				}

				m_bDeletingRegion = true;
				if(SUCCEEDED(pIParentNode->DeleteChildNode((IDMUSProdNode *)this, TRUE)))
				{
					hr = S_OK;				
				}
				pIParentNode->Release();
			}

			break;

		case IDM_RENAME:
			if(SUCCEEDED(m_pComponent->m_pIFramework->EditNodeLabel((IDMUSProdNode *)this)))
			{
				hr = S_OK;
			}
			break;
		
		case IDM_PROPERTIES:
			if(SUCCEEDED(OnShowProperties()))
			{
				hr = S_OK;
			}
			break;
	}

	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CRegion IDMUSProdNode::DeleteChildNode

HRESULT CRegion::DeleteChildNode(IDMUSProdNode* pIChildNode, BOOL fPromptUser)
{
 	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT(pIChildNode != NULL);
	ASSERT(m_pComponent != NULL);
	ASSERT(m_pComponent->m_pIFramework != NULL);

	HRESULT hr = S_OK;
	
	// Remove node from Project Tree
	if(m_pComponent->m_pIFramework->RemoveNode(pIChildNode, fPromptUser) == S_FALSE)
	{
		return E_FAIL;
	}

	// Remove it from the list of articulation lists 
	POSITION position = m_lstArticulationLists.Find(dynamic_cast<CArticulationList*>(pIChildNode));
	if(position)
	{
		m_lstArticulationLists.RemoveAt(position);
	}

	pIChildNode->Release();
	
	m_pArticulation = NULL;

	if (m_pInstrumentFVEditor)
	{
		m_pInstrumentFVEditor->UpdateUseInstArt();
	}

	if(GetArticulationCount() == 0 && m_pInstrument->GetArticulationCount() == 0)
	{
		hr = m_pInstrument->InsertChildNode(NULL);
	}	

	// Set flag so we know to save file 
	m_pInstrument->m_pCollection->SetDirtyFlag();
	m_pInstrument->UpdateInstrument();
	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CRegion IDMUSProdNode::InsertChildNode

HRESULT CRegion::InsertChildNode(IDMUSProdNode* pIChildNode)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT(m_pComponent != NULL);
	ASSERT(m_pComponent->m_pIFramework != NULL);	
	ASSERT(m_pInstrument);

	if(pIChildNode == NULL)
	{
		pIChildNode = new CArticulationList(m_pComponent, this);

		if(pIChildNode == NULL)
		{
			return E_OUTOFMEMORY;
		}
	}
	else
	{
		pIChildNode->AddRef();
	}

	// If we're inserting an articulation chances are we want to use it...
	m_lstArticulationLists.AddTail((CArticulationList*)pIChildNode);
	m_pArticulation = ((CArticulationList*)pIChildNode)->GetHead();
	m_bUseInstrumentArticulation = false;


	SetCurrentArtInEditor();		


	// Set root and parent node of ALL children
	theApp.SetNodePointers(pIChildNode, (IDMUSProdNode *)(m_pInstrument->m_pCollection), (IDMUSProdNode *)this);

	// Add node to Project Tree
	if( !SUCCEEDED (m_pComponent->m_pIFramework->AddNode(pIChildNode, (IDMUSProdNode *)this)))
	{
		DeleteChildNode( pIChildNode, FALSE );
		return E_FAIL;
	}

	// Set flag to indicate the DLS collection now needs to be saved
	m_pInstrument->m_pCollection->SetDirtyFlag();
	m_pInstrument->UpdateInstrument();

	return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
// CRegion IPersist implementation

/////////////////////////////////////////////////////////////////////////////
// CRegion IPersist::GetClassID

HRESULT CRegion::GetClassID( CLSID* pClsId )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

    ASSERT( pClsId != NULL );

    memset( pClsId, 0, sizeof( CLSID ) );

    return E_NOTIMPL;
}

////////////////////////////////////////////////////////////////////////////
// CRegion IDMUSProdNode::DeleteNode

HRESULT CRegion::DeleteNode( BOOL fPromptUser )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	
	IDMUSProdNode* pIParentNode;

	if( SUCCEEDED ( GetParentNode(&pIParentNode) ) )
	{
		if( pIParentNode )
		{
			m_bDeletingRegion = true;
			HRESULT hr = pIParentNode->DeleteChildNode( this, fPromptUser );
			pIParentNode->Release();
			return hr;		
		}
	}

	return E_FAIL;
}

//////////////////////////////////////////////////////////////////////
//
//	CRegion IDMUSProdNode::GetFirstChild
//
//////////////////////////////////////////////////////////////////////
HRESULT CRegion::GetFirstChild(IDMUSProdNode** ppIFirstChildNode)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if(ppIFirstChildNode == NULL)
	{
		return E_POINTER;
	}

	*ppIFirstChildNode = NULL;

	if(m_lstArticulationLists.GetCount() > 0)
	{
		CArticulationList* pArticList = (CArticulationList*)m_lstArticulationLists.GetHead();
		ASSERT(pArticList);
		IDMUSProdNode* pINode = static_cast<IDMUSProdNode*>(pArticList);

		if(pINode)
		{
			pINode->AddRef();
			*ppIFirstChildNode = pINode;
		}
	}

	return S_OK;
}

//////////////////////////////////////////////////////////////////////
//
//	CRegion IDMUSProdNode::GetNextChild
//
//////////////////////////////////////////////////////////////////////
HRESULT CRegion::GetNextChild(IDMUSProdNode* pIChildNode, IDMUSProdNode** ppINextChildNode)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if(ppINextChildNode == NULL)
	{
		return E_POINTER;
	}

	*ppINextChildNode = NULL;

	if(pIChildNode == NULL)
	{
		return E_INVALIDARG;
	}

	CArticulationList* pArticList = dynamic_cast<CArticulationList*>(pIChildNode);
	if(pArticList)
	{
		POSITION position = m_lstArticulationLists.Find(pArticList);
		ASSERT(position);
		pArticList = m_lstArticulationLists.GetNext(position);
		if(position)
		{
			pArticList = (CArticulationList*) m_lstArticulationLists.GetNext(position);
			pArticList->AddRef();
			*ppINextChildNode = dynamic_cast<IDMUSProdNode*>(pArticList);
			return S_OK;
		}
	}

	return S_OK;
}

//////////////////////////////////////////////////////////////////////
//
//	CRegion IDMUSProdNode::GetNodeListInfo
//
//////////////////////////////////////////////////////////////////////
HRESULT CRegion::GetNodeListInfo(DMUSProdListInfo* pListInfo)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	
	ASSERT(pListInfo);
	
	return E_NOTIMPL;
}

/////////////////////////////////////////////////////////////////////////////
// CRegion IDMUSProdNode::OnNodeSelChanged

HRESULT CRegion::OnNodeSelChanged(BOOL fSelected)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	ASSERT(m_pInstrument);
	ASSERT( m_pComponent != NULL );

	if(fSelected)
	{
		ASSERT( m_pComponent->m_pIFramework != NULL );
		
		if(m_pInstrument->m_pInstrumentCtrl)
		{
			CInstrumentFVEditor* pIE;
			pIE = m_pInstrument->GetInstrumentEditor();
			if(pIE)
			{
				pIE->SetCurRegion(this);

				// If Region has an Articulation we want to use it, if not we want to use the 
				// Instrument Articulation.
				if ( m_pArticulation && !m_bUseInstrumentArticulation )
				{
					pIE->SetCurArticulation(m_pArticulation);
				}
				else
				{
					pIE->SetCurArticulation(m_pInstrument->GetCurrentArticulation());		
				}
				pIE->SendRegionChange();
			}
			m_pInstrument->m_pComponent->m_pIConductor->SetActiveTransport(m_pInstrument, BS_PLAY_ENABLED | BS_NO_AUTO_UPDATE);

		}
	}	
	else
	{
		m_pInstrument->m_pComponent->m_pIConductor->TransportStopped(m_pInstrument);
		m_pInstrument->m_pComponent->m_pIConductor->SetBtnStates(m_pInstrument, BS_NO_AUTO_UPDATE);
		CInstrumentFVEditor* pIE;
		pIE = m_pInstrument->GetInstrumentEditor();
		if(pIE)
			pIE->TurnOffMidiNotes();
		else
		{
			m_pInstrument->TurnOffMidiNotes();
			m_pInstrument->Stop(true);
		}
	}

	if(m_pInstrument)
	{
		m_pInstrument->UpdateInstrument();
	}

	return S_OK;
}



/////////////////////////////////////////////////////////////////////////////
//
// CRegion IDMUSProdNode::CreateDataObject
//
//////////////////////////////////////////////////////////////////////
HRESULT CRegion::CreateDataObject( IDataObject** ppIDataObject )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
    return E_NOTIMPL;
}

/////////////////////////////////////////////////////////////////////////////
//
// CRegion IDMUSProdNode::CanCut
//
//////////////////////////////////////////////////////////////////////
HRESULT CRegion::CanCut()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
    return E_NOTIMPL;
}

/////////////////////////////////////////////////////////////////////////////
//
// CRegion IDMUSProdNode::CanCopy
//
//////////////////////////////////////////////////////////////////////
HRESULT CRegion::CanCopy()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
    return E_NOTIMPL;
}

/////////////////////////////////////////////////////////////////////////////
//
// CRegion IDMUSProdNode::CanDelete
//
//////////////////////////////////////////////////////////////////////
HRESULT CRegion::CanDelete()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if (1 < m_pInstrument->m_Regions.GetCount())//can't delete only region
	{
		return S_OK;
	}
    return E_FAIL;
}

/////////////////////////////////////////////////////////////////////////////
//
// CRegion IDMUSProdNode::CanDeleteChildNode
//
//////////////////////////////////////////////////////////////////////
HRESULT CRegion::CanDeleteChildNode( IDMUSProdNode* pIChildNode )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
    return E_NOTIMPL;
}

/////////////////////////////////////////////////////////////////////////////
//
// CRegion IDMUSProdNode::CanPasteFromData
//
//////////////////////////////////////////////////////////////////////
HRESULT CRegion::CanPasteFromData( IDataObject* pIDataObject, BOOL* pfWillSetReference )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
    return E_NOTIMPL;
}

/////////////////////////////////////////////////////////////////////////////
//
// CRegion IDMUSProdNode::PasteFromData
//
//////////////////////////////////////////////////////////////////////
HRESULT CRegion::PasteFromData( IDataObject* pIDataObject )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
    return E_NOTIMPL;
}

/////////////////////////////////////////////////////////////////////////////
//
// CRegion IDMUSProdNode::CanChildPasteFromData
//
//////////////////////////////////////////////////////////////////////
HRESULT CRegion::CanChildPasteFromData( IDataObject* pIDataObject, IDMUSProdNode* pIChildNode,
									    BOOL* pfWillSetReference )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
    return E_NOTIMPL;
}

/////////////////////////////////////////////////////////////////////////////
//
// CRegion IDMUSProdNode::ChildPasteFromData
//
//////////////////////////////////////////////////////////////////////
HRESULT CRegion::ChildPasteFromData( IDataObject* pIDataObject, IDMUSProdNode* pIChildNode )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
    return E_NOTIMPL;
}

/////////////////////////////////////////////////////////////////////////////
// CRegion IDMUSProdNode::GetObject

HRESULT CRegion::GetObject( REFCLSID rclsid, REFIID riid, void** ppvObject )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	return E_NOTIMPL;
}


/////////////////////////////////////////////////////////////////////////////
// CRegion IDMUSProdPropPageObject implementation

/////////////////////////////////////////////////////////////////////////////
// CRegion IDMUSProdPropPageObject::GetData

HRESULT CRegion::GetData(void** ppData)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	ASSERT(ppData);

	*ppData = this;
	return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
// CInstrument IDMUSProdPropPageObject::SetData

HRESULT CRegion::SetData(void* pData)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT(pData);
	return E_NOTIMPL;
}

/////////////////////////////////////////////////////////////////////////////
// CCollection IDMUSProdPropPageObject::OnRemoveFromPageManager

HRESULT CRegion::OnRemoveFromPageManager(void)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
// CCollection IDMUSProdPropPageObject::OnShowProperties

HRESULT CRegion::OnShowProperties(void)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	HRESULT hr = E_FAIL;

	ASSERT(m_pComponent != NULL);
	ASSERT(m_pComponent->m_pIFramework != NULL);

	// Show the Collection properties
	IDMUSProdPropSheet* pIPropSheet;

	hr = m_pComponent->m_pIFramework->QueryInterface(IID_IDMUSProdPropSheet, (void**)&pIPropSheet);
	if(SUCCEEDED(hr))
	{
		int nActivePage = (int)CRegionPropPgMgr::dwLastSelPage;
		
		if(SUCCEEDED(hr = pIPropSheet->SetPageManager(m_pRegionPropPgMgr)))
		{
			m_pRegionPropPgMgr->SetObject(this);
			pIPropSheet->SetActivePage(short(nActivePage)); 
		}

		pIPropSheet->Show(TRUE);
		pIPropSheet->Release();
	}

	return hr;
}

/////////////////////////////////////////////////////////////////////////////
// CRegion Additional functions

/////////////////////////////////////////////////////////////////////////////
// CRegion::Save

HRESULT CRegion::Save(IDMUSProdRIFFStream* pIRiffStream, bool fFullSave,
	USHORT usRegionSaved)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT(pIRiffStream);

	HRESULT			hr = S_OK;			// Return code
    MMCKINFO		ick;
    MMCKINFO		ck;
	DWORD			cb;
    DWORD           dwSaveSize;
	
    IStream* pIStream = pIRiffStream->GetStream();
	ASSERT(pIStream);
    if(pIStream == NULL)
        return E_OUTOFMEMORY;

	// decide what we'll save
	bool bSaveArticulationList = true;
	bool bSaveDesignChunks = true;
	IDMUSProdPersistInfo* pIJazzPersistInfo;
	if ( SUCCEEDED(pIStream->QueryInterface(IID_IDMUSProdPersistInfo,(void**) &pIJazzPersistInfo)) )
	{
		DMUSProdStreamInfo	StreamInfo;
		FileType	ftSaveType;

		pIJazzPersistInfo->GetStreamInfo(&StreamInfo);
		ftSaveType = StreamInfo.ftFileType;

		if (ftSaveType == FT_RUNTIME)
			{
			bSaveArticulationList = !m_bUseInstrumentArticulation && (GetArticulationCount() != 0);
			bSaveDesignChunks = false;
			}

		pIJazzPersistInfo->Release();
	}

	// save each channel
	LONG cChannels = GetChannelCount();
	for (LONG iChannel = 0; iChannel < cChannels; iChannel++)
		{
	    m_bDLS1Region = (m_nLayer == 0);
	    if (m_pWave && (m_pWave->GetChannelCount() > 1))
	    	m_bDLS1Region = false;
		ick.fccType = m_bDLS1Region ? FOURCC_RGN : FOURCC_RGN2;

	    hr = pIRiffStream->CreateChunk(&ick, MMIO_CREATELIST);
	    if (FAILED(hr))
			goto LReleaseStreamAndFail;
		
		// Save the conditional chunk
		if(m_pConditionalChunk)
		{
			m_pConditionalChunk->Save(pIRiffStream);
		}

	    ck.ckid = FOURCC_RGNH ;
	    hr = pIRiffStream->CreateChunk(&ck, 0);
	    if(FAILED(hr))
			goto LReleaseStreamAndFail;

	    hr = pIStream->Write((LPSTR) &m_rRgnHeader, sizeof(RGNHEADER), &cb);	
	    if(FAILED(hr) || cb != sizeof(RGNHEADER))
			goto LReleaseStreamAndFail;

		// write layer (optional)
		hr = pIStream->Write((LPSTR) &m_nLayer, sizeof(USHORT), &cb);
	    if(FAILED(hr) || cb != sizeof(USHORT))
			goto LReleaseStreamAndFail;
		
	    if(FAILED(pIRiffStream->Ascend(&ck, 0)))
	    {
	    	hr = E_FAIL;
			goto LReleaseStreamAndFail;
	    }

	    ck.ckid = FOURCC_WSMP ;
	    hr = pIRiffStream->CreateChunk(&ck, 0);
	    if(FAILED(hr))
			goto LReleaseStreamAndFail;

		dwSaveSize = sizeof(WSMPL);
	    if(m_rWSMP.cSampleLoops > 0)
	    {
	        dwSaveSize += sizeof(WLOOP);
	        m_rWSMP.cSampleLoops = 1;
	    }
	    
		hr = pIStream->Write((LPSTR) &m_rWSMP,dwSaveSize, &cb);	
	    if (FAILED(hr) || cb != dwSaveSize)
			goto LReleaseStreamAndFail;
	    if (FAILED(pIRiffStream->Ascend(&ck, 0)))
	    {
	    	hr = E_FAIL;
			goto LReleaseStreamAndFail;
	    }

		if (fFullSave)
		{
			if (m_pWave != NULL)
			{
				// save wavelink
				m_pWave->SetWaveLinkPerChannel(iChannel, &m_rWaveLink);

				ck.ckid = FOURCC_WLNK ;
				hr = pIRiffStream->CreateChunk(&ck, 0);
				if (FAILED(hr))
					goto LReleaseStreamAndFail;
				hr = pIStream->Write((LPSTR) &m_rWaveLink,sizeof(WAVELINK), &cb);	
				if (FAILED(hr) || cb != sizeof(WAVELINK))
					goto LReleaseStreamAndFail;

				if (FAILED(pIRiffStream->Ascend(&ck, 0)))
					goto LReleaseStreamAndFail;
			}
		}

		// save design-time stuff
		if (bSaveDesignChunks)
			{
			ck.ckid = DLS_REGION_EXTRA_CHUNK;
			hr = pIRiffStream->CreateChunk(&ck, 0);
			if (FAILED(hr))
				goto LReleaseStreamAndFail;
				
			hr = pIStream->Write((LPSTR) &m_bUseInstrumentArticulation,sizeof(bool), &cb);
			if (FAILED(hr) || cb != sizeof(bool))
				goto LReleaseStreamAndFail;
			
			hr = pIStream->Write((LPSTR) &m_bOverrideWaveFineTune, sizeof(bool), &cb);
			if(FAILED(hr) || cb != sizeof(bool))
				goto LReleaseStreamAndFail;

			hr = pIStream->Write((LPSTR)&(usRegionSaved), sizeof(USHORT), &cb);
			if (cb != sizeof(USHORT))
				hr = E_FAIL;
			if (FAILED(hr))
				goto LReleaseStreamAndFail;

			hr = pIRiffStream->Ascend(&ck, 0);
			if (FAILED(hr))
				goto LReleaseStreamAndFail;
			}

		// save articulation list
		if (bSaveArticulationList)
			{
			POSITION position = m_lstArticulationLists.GetHeadPosition();
			while(position)
				{
				CArticulationList* pArticList = (CArticulationList*) m_lstArticulationLists.GetNext(position);
				ASSERT(pArticList);
				if(pArticList)
					{
					hr = pArticList->Save(pIRiffStream);
					if(FAILED(hr)) 
						goto LReleaseStreamAndFail;
					}
				}
			}
		
	    // save unknown chunks
	    m_UnknownChunk.Save(pIRiffStream);
	    pIRiffStream->Ascend(&ick, 0);
		}

	pIStream->Release();
	ASSERT(SUCCEEDED(hr)); // we should be in failure case
    return hr;

LReleaseStreamAndFail:
	ASSERT(FAILED(hr)); // hr hasn't been set correctly
	pIStream->Release();
	return hr;
}

/////////////////////////////////////////////////////////////////////////////
// CRegion::Load

HRESULT CRegion::Load( IDMUSProdRIFFStream* pIRiffStream, MMCKINFO* pckMain )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	ASSERT(m_pComponent);
	if(m_pComponent == NULL)
	{
		return E_POINTER;
	}

	ASSERT(pIRiffStream);
	if(pIRiffStream == NULL)
	{
		return E_POINTER;
	}

    IStream* pIStream = NULL;
	DWORD cb = 0;
	DWORD cSize = 0;
    HRESULT	hr = S_OK;
    bool bExtraChunkPresent = false; // extra chunk present, overrides default behavior

    pIStream = pIRiffStream->GetStream();
	ASSERT(pIStream != NULL);
	if(pIStream == NULL)
	{
		return E_OUTOFMEMORY;
	}

	// Remove all previous articulation lists
	DeleteArticulationLists();

	MMCKINFO ck;
	ck.ckid = 0;
	ck.fccType = 0;
    while( pIRiffStream->Descend( &ck, pckMain, 0 ) == 0 )
	{
        switch( ck.ckid )
		{
			case FOURCC_CDL:
			{
				if(m_pConditionalChunk == NULL)
				{
					m_pConditionalChunk = new CConditionalChunk(m_pComponent);
				}

				if(FAILED(m_pConditionalChunk->Load(pIRiffStream, &ck)))
				{
					pIStream->Release();
					return E_FAIL;
				}
				break;
			}

			case FOURCC_RGNH :
			{
				if( ck.cksize < sizeof(RGNHEADER) )
				{
					cSize = ck.cksize;
				}
				else
				{
					cSize = sizeof(RGNHEADER);
				}
				hr = pIStream->Read( &m_rRgnHeader, cSize, &cb );
	            if( FAILED(hr) || cb != cSize )
				{
					pIStream->Release();
					return (hr);
				}
				
				// Read the layer value if we have it...
				if(m_bDLS1Region == false && ck.cksize > sizeof(RGNHEADER))
				{
					hr = pIStream->Read( &m_nLayer, sizeof(USHORT), &cb );
					if(FAILED(hr) || cb != sizeof(USHORT))
					{
						pIStream->Release();
						return (hr);
					}

				}
				
				// If it's a DLS1 region with broken velocity ranges...fix it...
				if(m_bDLS1Region)
				{
					// DLS1 regions are always in layer 0
					m_nLayer = 0;

					if(m_rRgnHeader.RangeVelocity.usLow == 0 && m_rRgnHeader.RangeVelocity.usHigh == 0)
					{
						m_rRgnHeader.RangeVelocity.usHigh = 127;
					}

					// Mark the collection as dirty
					if(m_pInstrument && m_pInstrument->m_pCollection)
					{
						m_pInstrument->m_pCollection->SetDirtyFlag();
					}
				}

				if(m_pInstrument)
				{
					if(m_pInstrument->m_Regions.GetNumberOfLayers() < m_nLayer)
					{
						m_pInstrument->m_Regions.SetNumberOfLayers(m_nLayer + 1);
					}
				}

				break;
			}

			case DLS_REGION_EXTRA_CHUNK :
			{
				bExtraChunkPresent = true;
				hr = pIStream->Read( &m_bUseInstrumentArticulation, sizeof(bool), &cb );
	            if( FAILED(hr) || cb != sizeof(bool))
				{
					pIStream->Release();
					return (hr);
				}

				hr = pIStream->Read(&m_bOverrideWaveFineTune, sizeof(bool), &cb);
				if(FAILED(hr) || cb != sizeof(bool))
				{
					pIStream->Release();
					return hr;
				}

				// IDs shared between multiple channels really representing the same region
				if (ck.cksize < sizeof(bool)+sizeof(bool)+sizeof(USHORT))
					break;
				hr = pIStream->Read(&m_usRegionSaved, sizeof(USHORT), &cb);
				if (cb != sizeof(USHORT))
					hr = E_FAIL;
				if (FAILED(hr))
					{
					pIStream->Release();
					return hr;
					}
				break;
			}

			case FOURCC_WSMP :
			{
				if( ck.cksize < (sizeof(WSMPL) + sizeof(WLOOP)) )
				{
					cSize = ck.cksize;
				}
				else
				{
					cSize = sizeof(WSMPL) + sizeof(WLOOP);
				}
				hr = pIStream->Read( &m_rWSMP, cSize, &cb );
                if( FAILED(hr) || cb != cSize )
				{
					pIStream->Release();
					return (hr);
				}
				break;
			}

			case FOURCC_WLNK :
			{
				if( ck.cksize < sizeof(WAVELINK) )
				{
					cSize = ck.cksize;
				}
				else
				{
					cSize = sizeof(WAVELINK);
				}
				hr = pIStream->Read( &m_rWaveLink, cSize, &cb );
                if( FAILED(hr) || cb != cSize )
				{
					pIStream->Release();
					return (hr);
				}
				break;
			}

			case FOURCC_LIST :
			{
				switch (ck.fccType)
				{
					case FOURCC_LAR2 :
					case FOURCC_LART :
                    {
						BOOL bDLS1 = FALSE;
						if(ck.fccType == FOURCC_LART)
						{
							bDLS1 = TRUE;
						}

						CArticulationList* pArticList = new CArticulationList(m_pComponent, this);
						if(pArticList == NULL)
						{
							pIStream->Release();
							return E_OUTOFMEMORY;
						}
						
						pArticList->SetDLS1(bDLS1);
						if(FAILED(hr = pArticList->Load(pIRiffStream, &ck)))
						{
							pIStream->Release();
							return hr;
						}

						m_lstArticulationLists.AddTail(pArticList);

						// use region articulation, unless overriden (fix 48914)
						if (!bExtraChunkPresent)
							m_bUseInstrumentArticulation = false;

						break;
                    }
					
                    default:
					{
                        m_UnknownChunk.Load(pIRiffStream, &ck, TRUE);
                        break;
					}

				}   
				break;
			}

			// Ignore edit chunks while loading.
            case mmioFOURCC('e','d','i','t'):   
                    break;
            default:
                m_UnknownChunk.Load(pIRiffStream, &ck, FALSE);
                break;
		}   //switch (ckid)
        pIRiffStream->Ascend( &ck, 0 );
    }
	pIStream->Release();

	// Set the first articulation in the very first articulation list as
	// the current articulation for this region...
	if(!m_lstArticulationLists.IsEmpty())
	{
		CArticulationList* pArtList = (CArticulationList*) m_lstArticulationLists.GetHead();
		ASSERT(pArtList);
		if(pArtList)
			m_pArticulation = pArtList->GetHead();
	}

	// Check WAVELINK.ulChannel field; make it 1 if 0....
	if(m_rWaveLink.ulChannel == 0)
		m_rWaveLink.ulChannel = WAVELINK_CHANNEL_LEFT;

    return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CRegion IPersistStream implementation

/////////////////////////////////////////////////////////////////////////////
//
// CRegion IPersistStream::IsDirty
//
//////////////////////////////////////////////////////////////////////
HRESULT CRegion::IsDirty()
{
    // I want to know if I am called
	ASSERT(FALSE);

	AFX_MANAGE_STATE(_afxModuleAddrThis);
	return E_NOTIMPL;
}

/////////////////////////////////////////////////////////////////////////////
//
// CRegion IPersistStream::GetSizeMax
//
//////////////////////////////////////////////////////////////////////
HRESULT CRegion::GetSizeMax( ULARGE_INTEGER FAR* /*pcbSize*/ )
{
    // I want to know if I am called
	ASSERT(FALSE);

	AFX_MANAGE_STATE(_afxModuleAddrThis);
	return E_NOTIMPL;
}

/////////////////////////////////////////////////////////////////////////////
//
// CRegion IPersistStream::Load
//
//////////////////////////////////////////////////////////////////////
HRESULT CRegion::Load(IStream* pIStream)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	ASSERT(pIStream);
	if(pIStream == NULL)
	{
		return E_POINTER;
	}

	ULONG ulBytesRead = 0;

	// Check the number of articulation lists in the stream
	int nArtListCount = 0;
	HRESULT hr = pIStream->Read((void *)&nArtListCount, sizeof(int), &ulBytesRead);
	if(FAILED(hr) || ulBytesRead != sizeof(int)) 
	{
		return E_FAIL; 
	}

	int nExistentArtLists = m_lstArticulationLists.GetCount();
	if(nArtListCount < nExistentArtLists)
	{
		for(int nCount = 0; nCount < (nExistentArtLists	- nArtListCount); nCount++)
		{
			CArticulationList* pArtList = (CArticulationList*)m_lstArticulationLists.RemoveHead();
			ASSERT(pArtList);
			CArticulation* pArt = (CArticulation*) pArtList->GetHead();
			while(pArt)
			{
				pArt->SetDeleteFlag(true);
				pArt = pArt->GetNext();
			}

			m_pComponent->m_pIFramework->RemoveNode(pArtList, FALSE);
			pArtList->Release();
		}
	}
	else if(nArtListCount > nExistentArtLists)
	{
		for(int nCount = 0; nCount < (nArtListCount - nExistentArtLists); nCount++)
		{
			InsertChildNode(NULL);
		}
	}

	// Now load up all Articulation lists
	POSITION position = m_lstArticulationLists.GetHeadPosition();
	while(position)
	{
		CArticulationList* pArtList = (CArticulationList*)m_lstArticulationLists.GetNext(position);
		ASSERT(pArtList);
		if(pArtList)
		{
			if(FAILED(hr = pArtList->Load(pIStream)))
			{
				return E_FAIL;
			}
		}
	}

	// The RGNHEADER structure
	hr = pIStream->Read((void *)&m_rRgnHeader, sizeof(RGNHEADER), &ulBytesRead);
	if(FAILED(hr) || ulBytesRead != sizeof(RGNHEADER)) 
	{
		return E_FAIL;
	}

	// Read the layer info
	hr = pIStream->Read((void *)&m_nLayer, sizeof(USHORT), &ulBytesRead);
	if(FAILED(hr) || ulBytesRead != sizeof(USHORT)) 
	{
		return E_FAIL;
	}

	// The WAVELINK structure
	hr = pIStream->Read((void *)&m_rWaveLink, sizeof(WAVELINK), &ulBytesRead);
	if(FAILED(hr) || ulBytesRead != sizeof(WAVELINK)) 
	{
		return E_FAIL;
	}
	
	GetWave();

	// The WLOOP structure
	hr = pIStream->Read((void *)&m_rWLOOP, sizeof(WLOOP), &ulBytesRead);
	if(FAILED(hr) || ulBytesRead != sizeof(WLOOP)) 
	{
		return E_FAIL;
	}

	// The Region's WSMPL structure
	hr = pIStream->Read((void *)&m_rWSMP, sizeof(WSMPL), &ulBytesRead);
	if(FAILED(hr) || ulBytesRead != sizeof(WSMPL)) 
	{
		return E_FAIL;
	}

	// The length of the region name 
	int nCount = 0;
	hr = pIStream->Read((void *)&nCount, sizeof(int), &ulBytesRead);
	if(FAILED(hr) || ulBytesRead != sizeof(int)) 
	{
		return E_FAIL;
	}

	// Allocate and read the name
	CString tempName; 
	char* tempNameBuffer = tempName.GetBufferSetLength(nCount);
	hr = pIStream->Read((void *)tempNameBuffer, nCount, &ulBytesRead);
	if(FAILED(hr) || ulBytesRead != (ULONG) nCount) 
	{
		return E_FAIL;
	}
	tempName. ReleaseBuffer(nCount);
	m_csName = tempName;

	// Use Instrument Articulation flag
	hr = pIStream->Read((void *)&m_bUseInstrumentArticulation, sizeof(BOOL), &ulBytesRead);
	if(FAILED(hr) || ulBytesRead != sizeof(BOOL)) 
	{
		return E_FAIL;
	}

	
	/* - : Read the flags marked on the Region's Property page : - */
	
	// Is Attenuation Overridden?
	hr = pIStream->Read((void *)&m_bOverrideWaveAttenuation, sizeof(bool), &ulBytesRead);
	if(FAILED(hr) || ulBytesRead != sizeof(bool)) 
	{
		return E_FAIL;
	}

	// Is FineTune Overridden?
	hr = pIStream->Read((void *)&m_bOverrideWaveFineTune, sizeof(bool), &ulBytesRead);
	if(FAILED(hr) || ulBytesRead != sizeof(bool)) 
	{
		return E_FAIL;
	}

	// Is RootNote Overridden?
	hr = pIStream->Read((void *)&m_bOverrideWaveRootNote, sizeof(bool), &ulBytesRead);
	if(FAILED(hr) || ulBytesRead != sizeof(bool)) 
	{
		return E_FAIL;
	}

	// Is the region overriding the wave settings?
	hr = pIStream->Read((void *)&m_bOverrideWaveMoreSettings, sizeof(bool), &ulBytesRead);
	if(FAILED(hr) || ulBytesRead != sizeof(bool)) 
	{
		return E_FAIL;
	}

	// The length of the condition expression
	nCount = 0;
	hr = pIStream->Read((void *)&nCount, sizeof(int), &ulBytesRead);
	if(FAILED(hr) || ulBytesRead != sizeof(int)) 
	{
		return E_FAIL;
	}

	// Allocate and read the expression
	if(nCount > 0)
	{
		CString conditionName; 
		char* conditionNameBuffer = conditionName.GetBufferSetLength(nCount);
		hr = pIStream->Read((void *)conditionNameBuffer, nCount, &ulBytesRead);
		if(FAILED(hr) || ulBytesRead != (ULONG) nCount) 
		{
			return E_FAIL;
		}
		conditionName. ReleaseBuffer(nCount);
		m_pConditionalChunk->RegularToRPN(conditionName);
	}
	else
	{
		CString sNone;
		sNone.LoadString(IDS_NONE);
		m_pConditionalChunk->RegularToRPN(sNone);
	}


	// Was this region previously deleted?
	hr = pIStream->Read((void *)&m_bLastDeleted, sizeof(bool), &ulBytesRead);
	if (!SUCCEEDED(hr) || ulBytesRead != sizeof(bool)) 
	{
		return E_FAIL;
	}
	
	return hr; 
}

/////////////////////////////////////////////////////////////////////////////
//
// CRegion IPersistStream::Save
//
//////////////////////////////////////////////////////////////////////
HRESULT CRegion::Save(IStream* pIStream, BOOL fClearDirty)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
    ASSERT(pIStream);
	if(pIStream == NULL)
	{
		return E_POINTER;
	}

	ULONG ulBytesWritten = 0;

	// If there is no global articulation we have to note that on the  stream
	int nCount = GetArticulationCount() ? 1 : 0;
	int nArtListCount = m_lstArticulationLists.GetCount();
	HRESULT hr = pIStream->Write((void*)&nArtListCount, sizeof(int), &ulBytesWritten);
	if(FAILED(hr) || ulBytesWritten != sizeof(int)) 
	{
		return E_FAIL;
	}

	POSITION position = m_lstArticulationLists.GetHeadPosition();
	while(position)
	{
		CArticulationList* pArtList = (CArticulationList*)m_lstArticulationLists.GetNext(position);
		if(pArtList)
		{
			if(FAILED(hr = pArtList->Save(pIStream, FALSE)))
			{
				return E_FAIL;
			}
		}
	}
    	
	// The RGNHEADER structure
	hr = pIStream->Write((void *)&m_rRgnHeader, sizeof(RGNHEADER), &ulBytesWritten);
	if(FAILED(hr) || ulBytesWritten != sizeof(RGNHEADER)) 
	{
		return E_FAIL;
	}

	// Save the layer info
	hr = pIStream->Write((void *)&m_nLayer, sizeof(USHORT), &ulBytesWritten);
	if(FAILED(hr) || ulBytesWritten != sizeof(USHORT)) 
	{
		return E_FAIL;
	}

	// THE WAVELINK structure
	hr = pIStream->Write((void *)&m_rWaveLink, sizeof(WAVELINK), &ulBytesWritten);
	if(FAILED(hr) || ulBytesWritten != sizeof(WAVELINK)) 
	{
		return E_FAIL;
	}

	// The WLOOP structure
	hr = pIStream->Write((void *)&m_rWLOOP, sizeof(WLOOP), &ulBytesWritten);
	if(FAILED(hr) || ulBytesWritten != sizeof(WLOOP)) 
	{
		return E_FAIL;
	}

	// The Region's WSMPL structure
	hr = pIStream->Write((void *)&m_rWSMP, sizeof(WSMPL), &ulBytesWritten);
	if(FAILED(hr) || ulBytesWritten != sizeof(WSMPL)) 
	{
		return E_FAIL;
	}

	// The region name length
	nCount = m_csName.GetLength();
	hr = pIStream->Write((void *)&nCount, sizeof(int), &ulBytesWritten);
	if(FAILED(hr) || ulBytesWritten != sizeof(int)) 
	{
		return E_FAIL;
	}

	// The Region Name
	hr = pIStream->Write((void *)(m_csName.GetBuffer(0)), nCount, &ulBytesWritten);
	if(FAILED(hr) || ulBytesWritten != (ULONG) nCount) 
	{
		return E_FAIL;
	}

	// Use Instrument Articulation flag
	hr = pIStream->Write((void *)(&m_bUseInstrumentArticulation), sizeof(BOOL), &ulBytesWritten);
	if(FAILED(hr) || ulBytesWritten != sizeof(BOOL)) 
	{
		return E_FAIL;
	}
	
	
	/* - : Save the flags marked on the regions property page : - */

	// Is Attenuation overridden?
	hr = pIStream->Write((void *)(&m_bOverrideWaveAttenuation), sizeof(bool), &ulBytesWritten);
	if(FAILED(hr) || ulBytesWritten != sizeof(bool)) 
	{
		return E_FAIL;
	}

	// Is Fine Tune overridden?
	hr = pIStream->Write((void *)(&m_bOverrideWaveFineTune), sizeof(bool), &ulBytesWritten);
	if(FAILED(hr) || ulBytesWritten != sizeof(bool)) 
	{
		return E_FAIL;
	}

	// Is Root Note overridden?
	hr = pIStream->Write((void *)(&m_bOverrideWaveRootNote), sizeof(bool), &ulBytesWritten);
	if(FAILED(hr) ||ulBytesWritten != sizeof(bool)) 
	{
		return E_FAIL;
	}

	// Does this region override the wave settings
	hr = pIStream->Write((void *)(&m_bOverrideWaveMoreSettings), sizeof(bool), &ulBytesWritten);
	if(FAILED(hr) || ulBytesWritten != sizeof(bool)) 
	{
		return E_FAIL;
	}

	// Save the condition
	CString sCondition = m_pConditionalChunk->GetCondition();
	nCount = sCondition .GetLength();
	hr = pIStream->Write((void *)&nCount, sizeof(int), &ulBytesWritten);
	if(FAILED(hr) || ulBytesWritten != sizeof(int)) 
	{
		return E_FAIL;
	}

	// The Condition Expression
	if(nCount > 0)
	{
		hr = pIStream->Write((void *)(sCondition .GetBuffer(0)), nCount, &ulBytesWritten);
		if(FAILED(hr) || ulBytesWritten != (ULONG) nCount) 
		{
			return E_FAIL;
		}
	}
	
	// Are we saving an undo state for a region delete action?
	// This will load up into the "m_bLastDeleted" flag....
	hr = pIStream->Write((void *)(&m_bDeletingRegion), sizeof(bool), &ulBytesWritten);
	if(FAILED(hr) || ulBytesWritten != sizeof(bool)) 
	{
		return E_FAIL;
	}

	return hr; 
}

HRESULT CRegion::Write(void* pv,
					   LONG iChannel,
					   DWORD* pdwCurOffset,
					   DWORD* pDMIOffsetTable,
					   DWORD* pdwCurIndex,
					   DWORD  dwIndexNextRegion,
                       IDirectMusicPortDownload* pIDMPortDownLoad)
{
    ASSERT(pIDMPortDownLoad);
    if(pIDMPortDownLoad == NULL)
    {
        return E_POINTER;
    }

	HRESULT hr = S_OK;
	if(!m_bConditionOK)
	{
		return hr;
	}

	DWORD dwRelativeCurOffset = 0;
	DMUS_REGION*	pRegion = (DMUS_REGION*)pv;
	// Argument validation - Debug
	ASSERT(pv);
	ASSERT(pdwCurOffset);
	ASSERT(pDMIOffsetTable);
	ASSERT(pdwCurIndex);

	__try
	{
		CopyMemory(pv, (void *)&m_rRgnHeader, sizeof(RGNHEADER));
		WAVELINK wl = m_rWaveLink;
		if (m_pWave)
		{
			m_pWave->SetWaveLinkPerChannel(iChannel, &wl);
			CMonoWave *pMonoWave = m_pWave->GetChannel(iChannel);
			ASSERT(pMonoWave);
			wl.ulTableIndex = pMonoWave->GetDownloadID(pIDMPortDownLoad);
		}
		pRegion->WaveLink = wl;
		pRegion->WSMP = m_rWSMP;
		pRegion->WLOOP[0] = m_rWLOOP;
		pRegion->ulNextRegionIdx = dwIndexNextRegion;

		(*pdwCurIndex)++;
		*pdwCurOffset += CHUNK_ALIGN(sizeof(DMUS_REGION));
		dwRelativeCurOffset += CHUNK_ALIGN(sizeof(DMUS_REGION));
		
		// Write extension chunks
		CUnknownChunkItem* pExtChk = m_UnknownChunk.GetHead();
		if(pExtChk)
		{
			((DMUS_REGION*)pv)->ulFirstExtCkIdx = *pdwCurIndex;
		}
		else
		{
			// If no extension chunks set to zero
			((DMUS_REGION*)pv)->ulFirstExtCkIdx = 0;
		}

		for(; pExtChk && SUCCEEDED(hr); pExtChk =(CUnknownChunkItem*) pExtChk->GetNext())
		{
			DWORD dwCountExtChk = m_UnknownChunk.GetCount();
			DWORD dwIndexNextExtChk = 0;

			if(dwCountExtChk == 1)
			{
				dwIndexNextExtChk = 0;
			}
			else
			{
				dwIndexNextExtChk = *pdwCurIndex + 1;
			}
			
			pDMIOffsetTable[*pdwCurIndex] = *pdwCurOffset;
			hr = pExtChk->Write(((BYTE *)pv + dwRelativeCurOffset), 
								pdwCurOffset,
								dwIndexNextExtChk);
			
			dwCountExtChk--;
			(*pdwCurIndex)++;
		}
		
		if(SUCCEEDED(hr))
		{
			// Write region articulation if we have one
			UINT nArtCount = GetArticulationCount();
			if(nArtCount > 0 && !m_bUseInstrumentArticulation)
			{
				POSITION position = m_lstArticulationLists.GetHeadPosition();
				while(position)
				{
					CArticulationList* pArtList = (CArticulationList*)m_lstArticulationLists.GetNext(position);
					if(pArtList && pArtList->IsConditionOK() == TRUE && pArtList->GetCount() > 0)
					{
						((DMUS_REGION*)pv)->ulRegionArtIdx = *pdwCurIndex;

						if(FAILED(hr = pArtList->Write((BYTE*)pv, &dwRelativeCurOffset, pdwCurOffset, pDMIOffsetTable, pdwCurIndex)))
						{
							break;
						}
					}
				}
			}
			else
			{
				((DMUS_REGION*)pv)->ulRegionArtIdx = 0;
			}
		}
	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		hr = E_UNEXPECTED;
	}
	return hr;
}

DWORD CRegion::Size()
{
	DWORD dwSize = 0;

	if(!m_bConditionOK)
	{
		return dwSize;
	}

	__try
	{
		dwSize += CHUNK_ALIGN(sizeof(DMUS_REGION));

		if(GetArticulationCount() > 0)
		{
			POSITION position = m_lstArticulationLists.GetHeadPosition();
			while(position)
			{
				CArticulationList* pArtList = (CArticulationList*) m_lstArticulationLists.GetNext(position);
				ASSERT(pArtList);
				if(pArtList)
				{
					dwSize += pArtList->Size();
				}
			}
		}

		// Calculate the space need for Region's extension chunks
		CUnknownChunkItem* pExtChk = m_UnknownChunk.GetHead();
		for(; pExtChk; pExtChk = (CUnknownChunkItem*) pExtChk->GetNext())
		{
			dwSize += pExtChk->Size();
		}
	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		dwSize = 0;
	}
	return dwSize;
}

DWORD CRegion::Count()
{
	ASSERT(m_pInstrument);
	if(m_pInstrument == NULL)
	{
		return 0;
	}

	// Return nothing if we don't want to be downloaded
	if(!m_bConditionOK)
	{
		return 0;
	}

	bool bAuditionMode = m_pInstrument->GetAuditionMode();
	if(bAuditionMode == AUDITION_SOLO)
	{
		// Use the audition mode to update ONLY if the editor's open!
		CInstrumentFVEditor* pEditor = m_pInstrument->GetInstrumentEditor();
		if(pEditor != NULL)
		{
			USHORT usActiveLayer = pEditor->GetActiveLayer();
			if(usActiveLayer != m_nLayer)
			{
				return 0;
			}
		}
	}

	DWORD dwCount = 1;
	if(GetArticulationCount() > 0 && !m_bUseInstrumentArticulation)
	{
		dwCount += m_UnknownChunk.GetCount();
		POSITION position = m_lstArticulationLists.GetHeadPosition();
		while(position)
		{
			CArticulationList* pArtList = (CArticulationList*) m_lstArticulationLists.GetNext(position);
			ASSERT(pArtList);
			if(pArtList)
			{
				dwCount += pArtList->Count();
			}
		}

		return dwCount;
	}
	else
	{
		return m_UnknownChunk.GetCount() + dwCount;
	}
}

bool CRegion::ValidateUIA()
{
	// In our design files we save out the state of the "Use Instrument Articulation" checkbox in a 
	// special chunk. If we load files that do not have this chunk we need to check that if
	// m_bUseInstrumentArticulation is true, as initialized, the instrument does have an articulation
	if ( m_bUseInstrumentArticulation )
	{
		if (m_pInstrument->GetCurrentArticulation() == NULL)
		{
			m_bUseInstrumentArticulation = false;
			if (m_pArticulation == NULL)
			{
				//m_bUseInstrumentArticulation = true;
				return false;
			}
		}
	}
	else
	{
		if (m_pArticulation == NULL)
		{
			m_bUseInstrumentArticulation = true;
			if (m_pInstrument->GetCurrentArticulation() == NULL)
			{
				return false;
			}
		}
	}
	return true;
}

void CRegion::GetWave()
{
	ASSERT(m_pInstrument);
	if(m_pInstrument == NULL)
		return;

	CPtrList waveList;
	if(FAILED(m_pInstrument->m_pCollection->m_Waves.GetListOfWaves(&waveList)))
		return;
	
	POSITION position = waveList.GetHeadPosition();
	while (position)
		{
		CWave* pWave = (CWave*) waveList.GetNext(position);
		ASSERT(pWave);
		
		if ((pWave != NULL) && (m_pWave != pWave))
			{
			if (pWave->GetWaveForID(m_rWaveLink.ulTableIndex) ||
				((pWave->GetChannelCount() == 1) && ((CMonoWave *)pWave)->GetWaveForDownloadID(m_rWaveLink.ulTableIndex))) // if mono wave, also check download port
				{
				m_pWave->GetNode()->Release();
				m_pWave = pWave;
				pWave->GetNode()->AddRef();
				break;
				}
			}
		}
}

void CRegion::SetWave(CWave* pWave)
{
	ASSERT(pWave);
	if(pWave == NULL)
		return;

	// Reset multichannel settings only if they can't be retained (fix 51314)
	if ((m_pWave == NULL) ||(pWave->GetChannelCount() != m_pWave->GetChannelCount()))
		{
		m_rWaveLink.fusOptions = (pWave->GetChannelCount() > 1) ? F_WAVELINK_MULTICHANNEL : 0;
		m_rWaveLink.ulChannel = 1;
		}

	// Release the previous wave
	if(m_pWave)
	{
		CWaveNode* pWaveNode = m_pWave->GetNode();
		// Release the current wave
		if(pWaveNode)
		{
			pWaveNode->Release();
		}
	}

	// Assign the new wave
	m_pWave = pWave;
	CWaveNode* pWaveNode = pWave->GetNode();
	if(pWaveNode)
		pWaveNode->AddRef();

	m_rWaveLink.ulTableIndex = pWave->GetWaveID();

	WSMPL waveWSMPL = pWave->GetWSMPL();
	WLOOP waveWLOOP = pWave->GetWLOOP();

	if(m_bOverrideWaveAttenuation)
	{
		waveWSMPL.lAttenuation = m_rWSMP.lAttenuation;
	}

	if(m_bOverrideWaveFineTune)
	{
		waveWSMPL.sFineTune = m_rWSMP.sFineTune;
	}

	if(m_bOverrideWaveRootNote)
	{
		waveWSMPL.usUnityNote = m_rWSMP.usUnityNote;
	}

	if(m_bOverrideWaveMoreSettings)
	{
		memcpy(&waveWLOOP, &m_rWLOOP, sizeof(waveWLOOP));
	}

	// Copy wave sample info to region
	memcpy(&m_rWSMP, &waveWSMPL, sizeof(m_rWSMP));
	memcpy(&m_rWLOOP, &waveWLOOP, sizeof(m_rWLOOP));

	// update names
    GetName();
	if (m_pInstrumentFVEditor)
		m_pInstrumentFVEditor->m_RegionKeyBoard.SetWaveName(short(GetLayer()), GetRangeValue(false), GetWaveName());
}


int CRegion::GetLayer()
{
	return m_nLayer;
}

void CRegion::SetLayer(int nLayer)
{
	m_nLayer = USHORT(nLayer);
	m_bDLS1Region = (m_nLayer == 0);
	if ((m_pWave != NULL) && (m_pWave->GetChannelCount() > 1))
		m_bDLS1Region = false;
	
	if(m_pInstrument)
	{
		if(m_pInstrument->m_Regions.GetNumberOfLayers() < m_nLayer)
		{
			m_pInstrument->m_Regions.SetNumberOfLayers(m_nLayer);
		}
	}
}

CRegion* CRegion::IsOverlappingRegion(CRegion* pRegion)
{
	// We need a region to check...
	if(pRegion == NULL)
		return NULL;

	// We don't care about non-DLS1 regions...they can overlap...
	if(m_bDLS1Region == false)
		return NULL;

	// Will always overlap with self huh?
	if(pRegion == this)
		return NULL;

	USHORT usStartNote = pRegion->m_rRgnHeader.RangeKey.usLow;
	USHORT usEndNote = pRegion->m_rRgnHeader.RangeKey.usHigh;

	return IsOverlappingRegion(usStartNote, usEndNote);
}

CRegion* CRegion::IsOverlappingRegion(USHORT usStartNote, USHORT usEndNote)
{
	// We don't care about non-DLS1 regions...they can overlap...
	if(m_bDLS1Region == false)
		return NULL;

	if(usStartNote >= m_rRgnHeader.RangeKey.usLow && usStartNote <= m_rRgnHeader.RangeKey.usHigh)
		return this;

	if(usEndNote >= m_rRgnHeader.RangeKey.usLow && usEndNote <= m_rRgnHeader.RangeKey.usHigh)
		return this;

	if(m_rRgnHeader.RangeKey.usLow >= usStartNote && m_rRgnHeader.RangeKey.usLow <= usEndNote)
		return this;

	if(m_rRgnHeader.RangeKey.usHigh >= usStartNote && m_rRgnHeader.RangeKey.usHigh <= usEndNote)
		return this;

	return NULL;
}

CConditionalChunk* CRegion::GetConditionalChunk()
{
	return m_pConditionalChunk;
}

HRESULT	CRegion::SetCondition(const CString& sCondition)
{
	ASSERT(m_pConditionalChunk);
	if(m_pConditionalChunk == NULL)
		return E_FAIL;

	return m_pConditionalChunk->RegularToRPN(sCondition);
}

UINT CRegion::GetArticulationCount()
{
	UINT nRegionArticulations = 0;

	POSITION position = m_lstArticulationLists.GetHeadPosition();
	while(position)
	{
		CArticulationList* pArticList = (CArticulationList*) m_lstArticulationLists.GetNext(position);
		ASSERT(pArticList);
		if(pArticList)
		{
			nRegionArticulations += pArticList->GetCount();
		}
	}

	return nRegionArticulations;
}


// Returns the number of articulations that will actually get downloaded
UINT CRegion::GetArticulationsUsed()
{
	UINT nRegionArticulations = 0;

	POSITION position = m_lstArticulationLists.GetHeadPosition();
	while(position)
	{
		CArticulationList* pArticList = (CArticulationList*) m_lstArticulationLists.GetNext(position);
		ASSERT(pArticList);
		if(pArticList)
		{
			nRegionArticulations += pArticList->GetArticulationsUsed();
		}
	}

	return nRegionArticulations;
}


void CRegion::SetCurrentArticulation(CArticulation* pArticulation)
{
	// We don't check for NULL as we might be doing it 
	// intentionally when deleting a local articulation...
	m_pArticulation = pArticulation;

	if(m_pArticulation)
	{
		SetCurrentArtInEditor();
	}
}


void CRegion::DeleteArticulationLists()
{
	while(!m_lstArticulationLists.IsEmpty())
	{
		CArticulationList* pArticList = (CArticulationList*) m_lstArticulationLists.GetHead();
		if(FAILED(pArticList->DeleteNode(FALSE)))
		{
			POSITION position = m_lstArticulationLists.Find(pArticList);
			if(position)
			{
				m_lstArticulationLists.RemoveAt(position);
			}
			delete pArticList;
		}
	}

	// This articulation is already pfft!
	m_pArticulation = NULL;
}


CArticulation* CRegion::GetCurrentArticulation()
{
	return m_pArticulation;
}


void CRegion::SetCurrentArtInEditor()
{
	// We don't have an articulation??
	if(m_pArticulation == NULL)
	{
		if(GetArticulationCount() == 0)
		{
			InsertChildNode(NULL);
		}
		else
		{
			CArticulationList* pArticList = m_lstArticulationLists.GetHead();
			ASSERT(pArticList);

			m_pArticulation = pArticList->GetHead();
		}
	}

	if(m_pInstrument && m_pInstrument->m_pInstrumentCtrl)
	{
		CInstrumentFVEditor* pIE = m_pInstrument->GetInstrumentEditor();
		if(pIE)
		{
			pIE->SetCurRegion(this);
			pIE->SendRegionChange();
			pIE->SetCurArticulation(m_pArticulation);
		}
	}
}


HRESULT CRegion::GetListOfConditions(CPtrList* pConditionList)
{
	ASSERT(pConditionList);
	if(pConditionList == NULL)
	{
		return E_POINTER;
	}

	ASSERT(m_pConditionalChunk);
	if(m_pConditionalChunk)
	{
		pConditionList->AddTail(m_pConditionalChunk);
	}

	POSITION position = m_lstArticulationLists.GetHeadPosition();
	while(position)
	{
		CArticulationList* pArtList = (CArticulationList*)m_lstArticulationLists.GetNext(position);
		ASSERT(pArtList);
		if(pArtList)
		{
			CConditionalChunk* pConditionalChunk = pArtList->GetConditionalChunk();
			ASSERT(pConditionalChunk);
			if(pConditionalChunk)
			{
				pConditionList->AddTail(pConditionalChunk);
			}
		}
	}

	return S_OK;
}


void CRegion::OnConditionConfigChanged(CSystemConfiguration* pCurrentConfig, bool bRefreshNode)
{
	ASSERT(pCurrentConfig);
	if(pCurrentConfig == NULL)
	{
		return;
	}

	m_bConditionOK = TRUE;

	ASSERT(m_pComponent);
	if(m_pComponent == NULL)
	{
		m_bConditionOK = FALSE;
	}

	ASSERT(m_pComponent->m_pIFramework);
	if(m_pComponent->m_pIFramework == NULL)
	{
		m_bConditionOK = FALSE;
	}
	
	IDMUSProdFramework* pIFramework = m_pComponent->m_pIFramework;
	ASSERT(m_pConditionalChunk);
	if(m_pConditionalChunk == NULL)
	{
		m_bConditionOK = FALSE;
	}

	// We need to evaluate the condition defined in the conditional chunk 
	// from the values set in the configuration and decide on the download
	m_bConditionOK = m_pConditionalChunk->Evaluate(pCurrentConfig);
	CInstrumentFVEditor* pIE = m_pInstrument->GetInstrumentEditor();
	if(pIE)
	{
		pIE->m_RegionKeyBoard.EnableRegion(short(GetLayer()), m_rRgnHeader.RangeKey.usLow, m_bConditionOK);
	}

	// If the region doesn't go down; no articulations go doen either....
	POSITION position = m_lstArticulationLists.GetHeadPosition();
	while(position)
	{
		CArticulationList* pArtList = (CArticulationList*) m_lstArticulationLists.GetNext(position);
		ASSERT(pArtList);
		if(pArtList)
		{
			if(m_bConditionOK == FALSE)
			{
				pArtList->SetConditionOK(m_bConditionOK, bRefreshNode);
			}
			else
			{
				pArtList->OnConditionConfigChanged(pCurrentConfig, bRefreshNode);
			}
		}
	}

	if(bRefreshNode)
	{
		pIFramework->RefreshNode(this);
	}
}


void CRegion::CheckConfigAndRefreshNode()
{
	ASSERT(m_pConditionalChunk);
	if(m_pConditionalChunk == NULL)
	{
		m_bConditionOK = FALSE;
	}

	CSystemConfiguration* pCurrentConfig = m_pComponent->GetCurrentConfig();
	OnConditionConfigChanged(pCurrentConfig, true);
	if(m_pInstrument)
	{
		m_pInstrument->UpdateInstrument();
	}
}

void CRegion::CheckArtsAndSetInstrumentArt()
{
	// Set the use instrument art flag if we have no local arts that will go down
	// Else the synth complains
	if(GetArticulationsUsed() == 0)
	{
		m_bUseInstrumentArticulation = true;
		if(m_pInstrument)
		{
			CInstrumentFVEditor* pIE = m_pInstrument->GetInstrumentEditor();
			if(pIE)
			{
				pIE->UpdateUseInstArt();
			}
		}
	}
}

HRESULT	CRegion::CreateAndInsertArticulationList()
{
	return InsertChildNode(NULL);
}


HRESULT	CRegion::CopyProperties(CRegion* pRegion)
{
	ASSERT(pRegion);
	if(pRegion == NULL)
	{
		return E_POINTER;
	}
	
	ASSERT(pRegion->m_pWave);
	if(pRegion->m_pWave == NULL)
	{
		return E_UNEXPECTED;
	}

	m_rRgnHeader = pRegion->m_rRgnHeader;
	m_rWaveLink = pRegion->m_rWaveLink;
	m_rWSMP = pRegion->m_rWSMP;
	m_rWLOOP = pRegion->m_rWLOOP;
	m_bOverrideWaveAttenuation = pRegion->m_bOverrideWaveAttenuation;
	m_bOverrideWaveFineTune = pRegion->m_bOverrideWaveFineTune;
	m_bOverrideWaveRootNote = pRegion->m_bOverrideWaveRootNote;
	m_bOverrideWaveMoreSettings = pRegion->m_bOverrideWaveMoreSettings;

	// Set the condition to be the same
	CConditionalChunk* pConditionalChunk = pRegion->GetConditionalChunk();
	CString sCondition = pConditionalChunk->GetCondition();
	SetCondition(sCondition);

	// Need to update region keyboard with new region range, otherwise update in SetWave() will fail
	if (m_pInstrumentFVEditor)
		m_pInstrumentFVEditor->m_RegionKeyBoard.SetRange(m_rRgnHeader.RangeKey.usLow, m_rRgnHeader.RangeKey.usHigh, m_rRgnHeader.RangeVelocity.usLow, m_rRgnHeader.RangeVelocity.usHigh);

	CWave* pWave = pRegion->m_pWave;
	ASSERT(pWave);
	if(pWave == NULL)
	{
		return E_UNEXPECTED;
	}

	SetWave(pWave);
	CheckConfigAndRefreshNode();

	return S_OK;
}	

WAVELINK CRegion::GetWaveLink()
{
	return m_rWaveLink;
}

void CRegion::SetWaveLink(WAVELINK waveLink)
{
	CopyMemory(&m_rWaveLink, &waveLink, sizeof(WAVELINK));
}

bool CRegion::IsOkayToPlay(USHORT usActiveLayer, USHORT usNote, USHORT usVelocity, bool bIgnoreLayer)
{
	ASSERT(m_pInstrument);
	if(m_pInstrument == NULL)
	{
		return false;
	}

	if(bIgnoreLayer == false)
	{
		if(usActiveLayer != m_nLayer)
		{
			return false;
		}
	
	}

	if(usNote < m_rRgnHeader.RangeKey.usLow || usNote > m_rRgnHeader.RangeKey.	usHigh)
	{
		return false;
	}

	if(usVelocity < m_rRgnHeader.RangeVelocity.usLow || usVelocity > m_rRgnHeader.RangeVelocity.usHigh)
	{
		return false;
	}

	return true;
}


CWaveNode* CRegion::GetWaveNode()
{
	ASSERT(m_pWave);
	if(m_pWave == NULL)
		return NULL;

	return m_pWave->GetNode();
}

/* returns the number of channels in the wave pointed to by this region */
LONG CRegion::GetChannelCount()
{
	if (m_pWave == NULL)
		{
		ASSERT(FALSE);
		return 0;
		}

	return m_pWave->GetChannelCount();
}


/////////////////////////////////////////////////////////////////////////////
// MergeNextRegions

/* merges following regions that have the same m_usRegionSaved, with this one, and returns the
	"master" wave that should be used (regions with same saved ID are supposed to
	point to different channels of the same wave) */
void CRegion::MergeNextRegions(CWave* &pWave)
{
	// if there are regions further in the list with the same ID, merge them with this one
	if (m_usRegionSaved > 0)
		{
		CRegion *pRegionPrev = this;
		CRegion *pRegionCur = GetNext();
		while (pRegionCur)
			{
			CRegion *pRegionNext = pRegionCur->GetNext();
			if (pRegionCur->m_usRegionSaved == m_usRegionSaved)
				{
				// delete region from linked list
				pRegionPrev->SetNext(pRegionNext);
				pRegionCur->Remove(pRegionCur);
				delete pRegionCur;

				// find the multichannel wave, if any
				// (wave may be monochannel when it's assigned because of ID match,
				// which can happen after a copy/paste instrument without copying waves)
				pWave = pWave->GetNode()->GetWave();
				}
			else
				pRegionPrev = pRegionCur;
			pRegionCur = pRegionNext;
			}
		}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\DLSDesigner\PitchDialog.h ===
//{{AFX_INCLUDES()
#include "adsrenvelope.h"
//}}AFX_INCLUDES
#if !defined(AFX_PITCHDIALOG_H__55AEE3E5_EC78_11D0_876A_00AA00C08146__INCLUDED_)
#define AFX_PITCHDIALOG_H__55AEE3E5_EC78_11D0_876A_00AA00C08146__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// PitchDialog.h : header file
//

#include "resource.h"
#include "myslider.h"
#include "DLSLoadSaveUtils.h"

class CDLSStatic;
class CArticulation;
class CCollection;
class CInstrument;

/////////////////////////////////////////////////////////////////////////////
// CPitchDialog dialog

class CPitchDialog : public CDialog, CSliderCollection
{
// Construction
public:
	void UpdateArticulation(CArticulation* pNewArt);
	CPitchDialog(CArticulation* p_Articulation);   // standard constructor

// Dialog Data
	//{{AFX_DATA(CPitchDialog)
	enum { IDD = IDD_PITCH_PAGE };
	CSliderCtrl	m_sliderKeyToHold;
	CADSREnvelope	m_PEGADSREnvelope;
	float	m_flAttack;
	float	m_flDecay;
	float	m_flRelease;
	float	m_flSustain;
	float	m_flDelay;
	float	m_flHold;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CPitchDialog)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	virtual BOOL OnCommand(WPARAM wParam, LPARAM lParam);
	virtual BOOL OnNotify(WPARAM wParam, LPARAM lParam, LRESULT* pResult);
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CPitchDialog)
	afx_msg void OnHScroll(UINT nSBCode, UINT nPos, CScrollBar* pScrollBar);
	afx_msg void OnADSREDecayTimeChangedPegAdsrenvelopectrl(long NewDecayTime);
	afx_msg void OnADSREAttackTimeChangedPegAdsrenvelopectrl(long NewAttackTime);
	afx_msg void OnADSREReleaseTimeChangedPegAdsrenvelopectrl(long NewReleaseTime);
	afx_msg void OnADSRESustainLevelChangedPegAdsrenvelopectrl(long NewSustainLevel);
	virtual BOOL OnInitDialog();
	afx_msg void OnKillfocusPegDattack();
	afx_msg void OnKillfocusPegDdecay();
	afx_msg void OnKillfocusPegDsustain();
	afx_msg void OnKillfocusPegDrelease();
	afx_msg LRESULT OnValidate(UINT wParam,LONG lParam);
	afx_msg HBRUSH OnCtlColor(CDC* pDC, CWnd* pWnd, UINT nCtlColor);
	afx_msg void OnRealDecayChangedPegAdsrenvelopectrl(long lNewRealDecay);
	afx_msg void OnRealReleaseChangedPegAdsrenvelopectrl(long lNewRealRelease);
	afx_msg void OnADSRMouseMoveStart();
	afx_msg void OnDestroy();
	afx_msg void OnPaint();
	afx_msg void OnKillfocusPegDelay();
	afx_msg void OnKillfocusPegHold();
	afx_msg void OnADSREDelayTimeChangedPegAdsrenvelopectrl(long lNewDelayTime);
	afx_msg void OnADSREHoldTimeChangedPegAdsrenvelopectrl(long lNewHoldTime);
	DECLARE_EVENTSINK_MAP()
	//}}AFX_MSG
	afx_msg void OnEditChange( UINT nEditControl );
	DECLARE_MESSAGE_MAP()

	// CSliderCollection overrides
	virtual bool OnSliderUpdate(MySlider *pms, DWORD dwmscupdf);
	
private:
	void ValidateDelayTime();
	void ValidateAttackTime();
	void ValidateHoldTime();
	void ValidateDecayTime();
	void ValidateSustainLevel();
	void ValidateReleaseTime();
	void SelectEditAndBringWindowToTop(CEdit* pEdit);
	void EnableDLS2Controls(BOOL bEnable = TRUE);
	HRESULT SaveUndoState(UINT uStringRes);
	void	CollectStatics();
	CDLSStatic* GetStaticControl(UINT nID);
	void UpdateInstrument();

	/* In order to solve problems with using OnKillFocus handlers to validate and update
		edit controls I am adding a bit field - m_bfTouched. Each bit to be set high in 
		response to EN_CHANGE message from given controls. The enumeration below defines 
		the bit flag for each of the four edit controls in the Pitch page.  I have made 
		IDC_PEG_DATTACK, IDC_PEG_DDECAY, IDC_PEG_DSUSTAIN and IDC_PEG_DRELEASE contigous. 
		in the resource editor. I use a ON_CONTROL_RANGE message map macro to handle 
		EN_CHANGE's. If any more edit controls get added to this dialog template the macro
		and the handler OnEditChange() might have to be modified. OnEditChange() gets one
		parameter which is the control ID of the edit control that changed. from this ID
		I subtract FIRST_CONTROL to come up with the argument to a shift left (<<) of 0x01.
		This creates the bit flag which corresponds to the ones in the enum. The ones in
		enum are used in comparison in the OnKillFocusXXX functions.
	*/
	enum { FIRST_CONTROL = IDC_FIRST_EDIT2VALIDATE, fPEG_DATTACK = 0x01,
		fPEG_DDECAY = 0x02, fPEG_DSUSTAIN = 0x04, fPEG_DRELEASE = 0x08, fPEG_DDELAY = 0x10, fPEG_DHOLD = 0x20};

	CPtrList m_lstStatics;	// List of static controls in the dialog

	CArticulation*			m_pArticulation;
	CCollection*			m_pCollection;
	CInstrument*			m_pInstrument;
	ArticParams*			m_pArticParams;
    MySlider*				m_pmsPEGVel2Attack;
    MySlider*				m_pmsPEGKey2Decay;
	MySlider*				m_pmsPEGKey2Hold;
	MySlider*				m_pmsPEGRange;
	bool					m_bInitingDialog;
	bool					m_bTouchedByProgram;// has edit control value changed by SetWindowText?
	DWORD					m_bfTouched; // bit field meaning "has the edit control really been 
								 // changed?" for OnKillFocus()
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_PITCHDIALOG_H__55AEE3E5_EC78_11D0_876A_00AA00C08146__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\DLSDesigner\ProgressDialog.cpp ===
// ProgressDialog.cpp : implementation file
//

#include "stdafx.h"
#include "dlsdesigner.h"
#include "Wave.h"
#include "ProgressDialog.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CProgressDialog dialog


CProgressDialog::CProgressDialog(CWnd* pParent /*=NULL*/)
	: CDialog(CProgressDialog::IDD, pParent)
{
	//{{AFX_DATA_INIT(CProgressDialog)
	//}}AFX_DATA_INIT
	m_nRange = 100;
	Create(IDD, pParent);
}


void CProgressDialog::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CProgressDialog)
	DDX_Control(pDX, IDC_PROGRESS, m_ProgressBar);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CProgressDialog, CDialog)
	//{{AFX_MSG_MAP(CProgressDialog)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CProgressDialog message handlers

void  CProgressDialog::SetRange(int nRange)
{
	m_nRange = nRange;
}



BOOL CProgressDialog::OnInitDialog() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	CDialog::OnInitDialog();
	
	m_ProgressBar.SetRange(0, short(m_nRange));
	m_ProgressBar.SetStep(1);
	m_ProgressBar.SetPos(1);
	
	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}


BOOL CProgressDialog::DestroyWindow() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	
	return CDialog::DestroyWindow();
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\DLSDesigner\Region.h ===
#ifndef __REGION_H__
#define __REGION_H__

// Region.h : header file
//

#include "DLSComponent.h"
#include "DLSDocType.h"
#include "RiffStrm.h"
#include "dls1.h"
#include "UnknownChunk.h"
#include "ConditionalChunk.h"
#include <afxtempl.h>

class CRegionPropPgMgr;
class CInstrumentFVEditor;
class CMonoWave;
class CConditionalChunk;
class CArticulationList;

class CRegion : public AListItem, public IDMUSProdNode, public IPersistStream, public IDMUSProdPropPageObject
{
friend class CWave;
friend class CMonoWave;
friend class CStereoWave;
friend class CWaveCtrl;
friend class CArticulation;
friend class CInstrument;
friend class CInstrumentRegions;
friend class CCollection;
friend class CCollectionWaves;
friend class CInstrumentFVEditor;
friend class CRegionPropPg;
friend class CRegionExtraPropPg;
friend class CInstrumentCtrl;
friend class CWavePropPg;
friend class CCollectionInstruments;

public:
    CRegion(CDLSComponent* pComponent, bool bDLS1Region = false);
	~CRegion();
    CRegion* GetNext();

    // IUnknown functions
    HRESULT STDMETHODCALLTYPE QueryInterface( REFIID riid, LPVOID *ppv );
    ULONG STDMETHODCALLTYPE AddRef();
    ULONG STDMETHODCALLTYPE Release();

    // IDMUSProdNode functions
	HRESULT STDMETHODCALLTYPE GetNodeImageIndex( short* pnNbrFirstImage );

    HRESULT STDMETHODCALLTYPE GetComponent( IDMUSProdComponent** ppIComponent );
    HRESULT STDMETHODCALLTYPE GetDocRootNode( IDMUSProdNode** ppIDocRootNode );
    HRESULT STDMETHODCALLTYPE SetDocRootNode( IDMUSProdNode* pIDocRootNode );
    HRESULT STDMETHODCALLTYPE GetParentNode( IDMUSProdNode** ppIParentNode );
    HRESULT STDMETHODCALLTYPE SetParentNode( IDMUSProdNode* pIParentNode );
    HRESULT STDMETHODCALLTYPE GetNodeId( GUID* pguid );
    HRESULT STDMETHODCALLTYPE GetNodeName( BSTR* pbstrName );
    HRESULT STDMETHODCALLTYPE GetNodeNameMaxLength( short* pnMaxLength );
    HRESULT STDMETHODCALLTYPE ValidateNodeName( BSTR bstrName );
    HRESULT STDMETHODCALLTYPE SetNodeName( BSTR bstrName );

    HRESULT STDMETHODCALLTYPE GetEditorClsId( CLSID* pclsid );
    HRESULT STDMETHODCALLTYPE GetEditorTitle( BSTR* pbstrTitle );
    HRESULT STDMETHODCALLTYPE GetEditorWindow( HWND* hWndEditor );
    HRESULT STDMETHODCALLTYPE SetEditorWindow( HWND hWndEditor );

	HRESULT STDMETHODCALLTYPE UseOpenCloseImages( BOOL* pfUseOpenCloseImages );

    HRESULT STDMETHODCALLTYPE GetRightClickMenuId(HINSTANCE* phInstance, UINT* pnResourceId);
    HRESULT STDMETHODCALLTYPE OnRightClickMenuInit(HMENU hMenu);
    HRESULT STDMETHODCALLTYPE OnRightClickMenuSelect(long lCommandId);

    HRESULT STDMETHODCALLTYPE DeleteChildNode( IDMUSProdNode* pIChildNode, BOOL fPromptUser );
    HRESULT STDMETHODCALLTYPE InsertChildNode( IDMUSProdNode* pIChildNode );
    HRESULT STDMETHODCALLTYPE DeleteNode( BOOL fPromptUser );

	HRESULT STDMETHODCALLTYPE GetFirstChild(IDMUSProdNode** ppIFirstChildNode);
	HRESULT STDMETHODCALLTYPE GetNextChild(IDMUSProdNode* pIChildNode, IDMUSProdNode** ppINextChildNode);
	HRESULT STDMETHODCALLTYPE GetNodeListInfo(DMUSProdListInfo* pListInfo);

	HRESULT STDMETHODCALLTYPE OnNodeSelChanged( BOOL fSelected );
    // IDMUSProdNode : drag & drop methods
	HRESULT STDMETHODCALLTYPE CreateDataObject( IDataObject** ppIDataObject );
	HRESULT STDMETHODCALLTYPE CanCut();
	HRESULT STDMETHODCALLTYPE CanCopy();
	HRESULT STDMETHODCALLTYPE CanDelete();
	HRESULT STDMETHODCALLTYPE CanDeleteChildNode( IDMUSProdNode* pIChildNode );
	HRESULT STDMETHODCALLTYPE CanPasteFromData( IDataObject* pIDataObject, BOOL* pfWillSetReference );
	HRESULT STDMETHODCALLTYPE PasteFromData( IDataObject* pIDataObject );
	HRESULT STDMETHODCALLTYPE CanChildPasteFromData( IDataObject* pIDataObject, IDMUSProdNode* pIChildNode, BOOL* pfWillSetReference );
	HRESULT STDMETHODCALLTYPE ChildPasteFromData( IDataObject* pIDataObject, IDMUSProdNode* pIChildNode );

	HRESULT STDMETHODCALLTYPE GetObject( REFCLSID rclsid, REFIID riid, void** ppvObject );

    // IPersist functions
    STDMETHOD(GetClassID)(CLSID* pClsId);

    // IPersistStream functions
    STDMETHOD(IsDirty)();
    STDMETHOD(Load)( IStream* pIStream );
    STDMETHOD(Save)( IStream* pIStream, BOOL fClearDirty );
    STDMETHOD(GetSizeMax)( ULARGE_INTEGER FAR* pcbSize );

    // IDMUSProdPropPageObject functions
    HRESULT STDMETHODCALLTYPE GetData( void** ppData );
    HRESULT STDMETHODCALLTYPE SetData( void* pData );
	HRESULT STDMETHODCALLTYPE OnRemoveFromPageManager();
	HRESULT STDMETHODCALLTYPE OnShowProperties();

	//Additional functions
public:
    CInstrument* GetInstrument() {return(m_pInstrument);}
	HRESULT		Load( IDMUSProdRIFFStream* pIRiffStream, MMCKINFO* pckMain );

	CRegion*	IsOverlappingRegion(CRegion* pRegion);
	CRegion*	IsOverlappingRegion(USHORT usStartNote, USHORT usEndNote);
    void		SetRangeValue(BOOL bUpper, CString csName);
    CString		GetRangeName(BOOL bUpper);
    USHORT		GetRangeValue(BOOL bUpper);
	CString		GetWaveName();
    void		GetName();
    void		SetInitialWave(CWave* pWave);		// This is called right after newing the region to set the default wave...
	int			GetLayer();							// Returns the visual layer of this region (Required for Instrument Editor)						
	void		SetLayer(int nLayer);
	bool		ValidateUIA();
	DWORD		Count();
	DWORD		Size();
	void		SetWave(CWave* pWave);				// Replaces the current wave with the passed wave for this region

	WAVELINK	GetWaveLink();
	void		SetWaveLink(WAVELINK waveLink);
	
	HRESULT				SetCondition(const CString& sCondition);
	HRESULT				GetListOfConditions(CPtrList* pConditionList);	// Gets the conditions set for the region and all the chldren articulation lists
	CConditionalChunk*	GetConditionalChunk();							// Gets the conditional chunk for this region
	
	HRESULT			CreateAndInsertArticulationList();
	void			SetCurrentArticulation(CArticulation* pArticulation);
	UINT			GetArticulationCount();
	CArticulation*	GetCurrentArticulation();

	void			OnConditionConfigChanged(CSystemConfiguration* pCurrentConfig, bool bRefreshNode = true);
	void			CheckConfigAndRefreshNode();
	void			CheckArtsAndSetInstrumentArt();
	HRESULT			CopyProperties(CRegion* pRegion);	// Copies the proeprties from the passed region

	bool			IsOkayToPlay(USHORT usActiveLayer, USHORT nNote, USHORT usVelocity, bool bIgnoreLayer);

	CWaveNode*		GetWaveNode();	// REturns the wave node referred by this region

	/* returns the number of channels in the wave pointed to by this region */
	LONG			GetChannelCount();

	/* merges following regions that have the same m_usRegionSaved, with this one, and returns the
		"master" wave that should be used (regions with same saved ID are supposed to
		point to different channels of the same wave) */
	void			MergeNextRegions(CWave* &pWave);

protected:
	HRESULT Write(void* pv, LONG iChannel, DWORD* pdwCurOffset, DWORD* pDMIOffsetTable, DWORD* pdwCurIndex, DWORD dwIndexNextRegion, IDirectMusicPortDownload* pIDMPortDownLoad);
	HRESULT Save(IDMUSProdRIFFStream* pIRiffStream, bool fFullSave, USHORT usRegionSaved);

	BOOL m_bUseInstrumentArticulation;

private:
	void DeleteArticulationLists();
	UINT GetArticulationsUsed();			// Gets the number of articulations that will actually get downloaded
	void SetCurrentArtInEditor();

public:
	CDLSComponent*		m_pComponent;
    CInstrument*		m_pInstrument;		// Parent Instrument.
	bool				m_bLastDeleted;		// This node was deleted last; used during the undo

    CInstrumentFVEditor* m_pInstrumentFVEditor;

private:
	void				GetWave();

	// Articulation stuff
	CArticulation*		m_pArticulation;	// Optional Articulation child.
	CTypedPtrList<CPtrList, CArticulationList*> m_lstArticulationLists;

    CWave*				m_pWave;			// Link to wave (may be mono, stereo, or any channel)
    USHORT				m_usRegionSaved;	// regions that are really one share the same ID at save/load time, 1 based (0 means region ID wasn't loaded)
    
    CUnknownChunk		m_UnknownChunk;

    DWORD				m_dwRef;
	IDMUSProdNode*		m_pIRootNode;
	IDMUSProdNode*		m_pIParentNode;

	CString				m_csName;			// Display name. Generated by GetName() method.
	CConditionalChunk*	m_pConditionalChunk;	// Conditional chunk for the region
	RGNHEADER			m_rRgnHeader;		// Comes from a DLS file chunk
    WSMPL				m_rWSMP;			// Comes from a DLS file chunk
	WLOOP				m_rWLOOP;			// Comes from a DLS file chunk
	WAVELINK			m_rWaveLink;		// Comes from a DLS file chunk

	CRegionPropPgMgr*	m_pRegionPropPgMgr;

	// Flag that indicates a DLS1 region
	bool				m_bDLS1Region;

	// Flag that says if we're satifying the config condition
	BOOL				m_bConditionOK;

    // flags to remember whether we are overriding wave properties or not.
    BOOL m_bOverrideWaveAttenuation;
    BOOL m_bOverrideWaveFineTune;
    BOOL m_bOverrideWaveRootNote;
    BOOL m_bOverrideWaveMoreSettings;
	bool m_bDeletingRegion;//this node is being deleted

	USHORT	m_nLayer;
};

#define DLS_REGION_EXTRA_CHUNK			mmioFOURCC('d','m','p','r')
#endif // __REGION_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\DLSDesigner\PitchDialog.cpp ===
// PitchDialog.cpp : implementation file
//

#include "stdafx.h"
#include "PitchDialog.h"
#include "Collection.h"
#include "Instrument.h"
#include "Region.h"
#include "DLSStatic.h"
#include "InstrumentFVEditor.h"
#include "Articulation.h"
#include "DlsDefsPlus.h"
#include "UndoMan.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CPitchDialog dialog


CPitchDialog::CPitchDialog(CArticulation* pArticulation) :
CDialog(), CSliderCollection(4),
m_pArticParams(pArticulation->GetArticParams()),
m_pCollection(NULL),
m_bInitingDialog(false),
m_pmsPEGVel2Attack(NULL)
{
	m_pArticulation = pArticulation;
#ifdef _DEBUG	
	pArticulation->ValidateParent();
#endif

	CInstrument* pInstrument = pArticulation->GetInstrument();
	if(pInstrument)
	{
		// Articulation is owned by an instrument			
		m_pCollection = pInstrument->m_pCollection;
		m_pInstrument = pInstrument;
	}
	else
	{
		// Articulation is owned by a region
		CRegion* pRegion = pArticulation->GetRegion();
		ASSERT(pRegion);
		pInstrument = pRegion->GetInstrument();
		ASSERT(pInstrument);
		m_pCollection = pInstrument->m_pCollection;
		m_pInstrument = pInstrument;
	}
	
	//{{AFX_DATA_INIT(CPitchDialog)
	m_flAttack = 0.0f;
	m_flDecay = 0.0f;
	m_flRelease = 0.0f;
	m_flSustain = 0.0f;
	m_flDelay = 0.0f;
	m_flHold = 0.0f;
	//}}AFX_DATA_INIT
	m_bfTouched = 0;
	m_bTouchedByProgram = false;

	CSliderCollection::Init(this);
}


void CPitchDialog::DoDataExchange(CDataExchange* pDX)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CPitchDialog)
	DDX_Control(pDX, IDC_PEG_KEY2HOLD, m_sliderKeyToHold);
	DDX_Control(pDX, IDC_PEG_ADSRENVELOPECTRL, m_PEGADSREnvelope);
	DDX_Text(pDX, IDC_PEG_DATTACK, m_flAttack);
	DDV_MinMaxFloat(pDX, m_flAttack, 1.e-003f, 40.f);
	DDX_Text(pDX, IDC_PEG_DDECAY, m_flDecay);
	DDV_MinMaxFloat(pDX, m_flDecay, 1.e-003f, 40.f);
	DDX_Text(pDX, IDC_PEG_DRELEASE, m_flRelease);
	DDV_MinMaxFloat(pDX, m_flRelease, 1.e-003f, 40.f);
	DDX_Text(pDX, IDC_PEG_DSUSTAIN, m_flSustain);
	DDV_MinMaxFloat(pDX, m_flSustain, 0.f, 100.f);
	DDX_Text(pDX, IDC_PEG_DDELAY, m_flDelay);
	DDV_MinMaxFloat(pDX, m_flDelay, 1.e-003f, 40.f);
	DDX_Text(pDX, IDC_PEG_DHOLD, m_flHold);
	DDV_MinMaxFloat(pDX, m_flHold, 1.e-003f, 40.f);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CPitchDialog, CDialog)
	//{{AFX_MSG_MAP(CPitchDialog)
	ON_WM_HSCROLL()
	ON_EN_KILLFOCUS(IDC_PEG_DATTACK, OnKillfocusPegDattack)
	ON_EN_KILLFOCUS(IDC_PEG_DDECAY, OnKillfocusPegDdecay)
	ON_EN_KILLFOCUS(IDC_PEG_DSUSTAIN, OnKillfocusPegDsustain)
	ON_EN_KILLFOCUS(IDC_PEG_DRELEASE, OnKillfocusPegDrelease)
	ON_MESSAGE(DM_VALIDATE,OnValidate)
	ON_WM_CTLCOLOR()
	ON_WM_DESTROY()
	ON_WM_PAINT()
	ON_EN_KILLFOCUS(IDC_PEG_DDELAY, OnKillfocusPegDelay)
	ON_EN_KILLFOCUS(IDC_PEG_DHOLD, OnKillfocusPegHold)
	//}}AFX_MSG_MAP
	// This is to get notified of changes to the edit controls
	ON_CONTROL_RANGE(EN_CHANGE, IDC_PEG_DATTACK, IDC_PEG_DHOLD, OnEditChange)
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CPitchDialog message handlers

LRESULT CPitchDialog::OnValidate(UINT wParam,LONG lParam)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	switch ( wParam )
	{
		case IDC_PEG_DDELAY :
			ValidateDelayTime();
			break;
		case IDC_PEG_DATTACK :
			ValidateAttackTime();
			break;
		case IDC_PEG_DHOLD :
			ValidateHoldTime();
			break;
		case IDC_PEG_DDECAY :
			ValidateDecayTime();
			break;
		case IDC_PEG_DSUSTAIN :
			ValidateSustainLevel();
			break;
		case IDC_PEG_DRELEASE :
			ValidateReleaseTime();
			break;
		default:
			break;
	}
	return 0;
}

//OnEditChange : See PitchDialog.h for details about this. (In private member
//				 section of CPitchDialog)
void CPitchDialog::OnEditChange( UINT nEditControl )
{
	if ( !m_bTouchedByProgram )
		m_bfTouched |= 0x01 << (nEditControl - FIRST_CONTROL);
}

void CPitchDialog::OnHScroll(UINT nSBCode, UINT nPos, CScrollBar* pScrollBar) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	ASSERT(m_pArticParams);
	if(m_pArticParams == NULL)
	{
		return;
	}

	ASSERT(m_pInstrument);
	if(m_pInstrument == NULL)
	{
		return;
	}

	ASSERT(m_pCollection);
	if(m_pCollection == NULL)
	{
		return;
	}

	CSliderCollection::OnHScroll(nSBCode, nPos, pScrollBar);
	CDialog::OnHScroll(nSBCode, nPos, pScrollBar);
}

BEGIN_EVENTSINK_MAP(CPitchDialog, CDialog)
    //{{AFX_EVENTSINK_MAP(CPitchDialog)
	ON_EVENT(CPitchDialog, IDC_PEG_ADSRENVELOPECTRL, 1 /* ADSREDecayTimeChanged */, OnADSREDecayTimeChangedPegAdsrenvelopectrl, VTS_I4)
	ON_EVENT(CPitchDialog, IDC_PEG_ADSRENVELOPECTRL, 2 /* ADSREAttackTimeChanged */, OnADSREAttackTimeChangedPegAdsrenvelopectrl, VTS_I4)
	ON_EVENT(CPitchDialog, IDC_PEG_ADSRENVELOPECTRL, 3 /* ADSREReleaseTimeChanged */, OnADSREReleaseTimeChangedPegAdsrenvelopectrl, VTS_I4)
	ON_EVENT(CPitchDialog, IDC_PEG_ADSRENVELOPECTRL, 4 /* ADSRESustainLevelChanged */, OnADSRESustainLevelChangedPegAdsrenvelopectrl, VTS_I4)
	ON_EVENT(CPitchDialog, IDC_PEG_ADSRENVELOPECTRL, 5 /* RealDecayChanged */, OnRealDecayChangedPegAdsrenvelopectrl, VTS_I4)
	ON_EVENT(CPitchDialog, IDC_PEG_ADSRENVELOPECTRL, 6 /* RealReleaseChanged */, OnRealReleaseChangedPegAdsrenvelopectrl, VTS_I4)
	ON_EVENT(CPitchDialog, IDC_PEG_ADSRENVELOPECTRL, 7 /* ADSRMouseMoveStart */, OnADSRMouseMoveStart, VTS_NONE)
	ON_EVENT(CPitchDialog, IDC_PEG_ADSRENVELOPECTRL, 9 /* ADSREDelayTimeChanged */, OnADSREDelayTimeChangedPegAdsrenvelopectrl, VTS_I4)
	ON_EVENT(CPitchDialog, IDC_PEG_ADSRENVELOPECTRL, 10 /* ADSREHoldTimeChanged */, OnADSREHoldTimeChangedPegAdsrenvelopectrl, VTS_I4)
	//}}AFX_EVENTSINK_MAP
END_EVENTSINK_MAP()

////////////////////////////////////////////////////////////////////////////////
// ADSR control ATTACK Time changed
void CPitchDialog::OnADSREAttackTimeChangedPegAdsrenvelopectrl(long NewAttackTime) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	char text[BUFFER_64];
    sprintf(text," %02d.%03d", NewAttackTime / 1000, NewAttackTime % 1000);
	CWnd* pDisplay = GetDlgItem(IDC_PEG_DATTACK);

	m_bTouchedByProgram = true;
	pDisplay->SetWindowText(text);
	m_bTouchedByProgram = false;

	if(!m_bInitingDialog)
	{
		if ( !( m_bfTouched & fPEG_DATTACK ) )
			m_pArticParams->m_PitchEG.m_tcAttack = Mils2TimeCents(NewAttackTime);
		m_pCollection->SetDirtyFlag();
		m_pInstrument->UpdateInstrument();
	}
}

////////////////////////////////////////////////////////////////////////////////
// ADSR control DECAY Time changed
void CPitchDialog::OnADSREDecayTimeChangedPegAdsrenvelopectrl(long NewDecayTime) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	char text[BUFFER_64];
    sprintf(text," %02d.%03d", NewDecayTime / 1000, NewDecayTime % 1000);
	CWnd * pDisplay = GetDlgItem(IDC_PEG_DDECAY);

	m_bTouchedByProgram = true;
	pDisplay->SetWindowText(text);
	m_bTouchedByProgram = false;

	if(!m_bInitingDialog)
	{
		if ( !( m_bfTouched & fPEG_DDECAY ) )
			m_pArticParams->m_PitchEG.m_tcDecay = Mils2TimeCents(NewDecayTime);
		m_pCollection->SetDirtyFlag();
		m_pInstrument->UpdateInstrument();
	}
}

////////////////////////////////////////////////////////////////////////////////
// ADSR control SUSTAIN Level changed
void CPitchDialog::OnADSRESustainLevelChangedPegAdsrenvelopectrl(long NewSustainLevel) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	char text[BUFFER_64];
    sprintf(text," %02d.%d",NewSustainLevel / 10, NewSustainLevel % 10);
	CWnd * pDisplay = GetDlgItem(IDC_PEG_DSUSTAIN);

	m_bTouchedByProgram = true;
	pDisplay->SetWindowText(text);
	m_bTouchedByProgram = false;

	if(!m_bInitingDialog)
	{
		m_pArticParams->m_PitchEG.m_ptSustain = (PERCENT) (NewSustainLevel << 16);
		m_pCollection->SetDirtyFlag();
		m_pInstrument->UpdateInstrument();
	}
}

////////////////////////////////////////////////////////////////////////////////
// ADSR control RELEASE Time changed
void CPitchDialog::OnADSREReleaseTimeChangedPegAdsrenvelopectrl(long NewReleaseTime) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	char text[BUFFER_64];
    sprintf(text," %02d.%03d", NewReleaseTime / 1000, NewReleaseTime % 1000);
	CWnd * pDisplay = GetDlgItem(IDC_PEG_DRELEASE);

	m_bTouchedByProgram = true;
	pDisplay->SetWindowText(text);
	m_bTouchedByProgram = false;

	if(!m_bInitingDialog)
	{
		if ( !( m_bfTouched & fPEG_DRELEASE ) )
			m_pArticParams->m_PitchEG.m_tcRelease = Mils2TimeCents(NewReleaseTime);
		m_pCollection->SetDirtyFlag();
		m_pInstrument->UpdateInstrument();
	}
}

void CPitchDialog::OnRealDecayChangedPegAdsrenvelopectrl(long lNewRealDecay) 
{
	CWnd*	pWnd;
	char text[BUFFER_64];

    sprintf(text," %02d.%03d", lNewRealDecay / 1000, lNewRealDecay % 1000);
	pWnd = GetDlgItem(IDC_PEG_RDECAY);
	pWnd->SetWindowText(text);
}

void CPitchDialog::OnRealReleaseChangedPegAdsrenvelopectrl(long lNewRealRelease) 
{
	CWnd*	pWnd;
	char text[BUFFER_64];

    sprintf(text," %02d.%03d", lNewRealRelease / 1000, lNewRealRelease % 1000);
	pWnd = GetDlgItem(IDC_PEG_RRELEASE);
	pWnd->SetWindowText(text);	
}

HBRUSH CPitchDialog::OnCtlColor(CDC* pDC, CWnd* pWnd, UINT nCtlColor) 
{
	COLORREF crTextColor = 0;
	int nStaticText;

	HBRUSH hbr = CDialog::OnCtlColor(pDC, pWnd, nCtlColor);
	
	nStaticText = pWnd->GetDlgCtrlID();
	switch (nStaticText)
	{
		case IDC_PEG_DELAY_STATIC:
			crTextColor = DELAY_COLOR;
			break;

		case IDC_PEG_ATTACK_STATIC:
			crTextColor = ATTACK_COLOR;
			break;

		case IDC_PEG_HOLD_STATIC:
			crTextColor = HOLD_COLOR;
			break;

		case IDC_PEG_DECAY_STATIC:
			crTextColor = DECAY_COLOR;
			break;

		case IDC_PEG_SUSTAIN_STATIC:
			crTextColor = SUSTAIN_COLOR;
			break;

		case IDC_PEG_RELEASE_STATIC:
			crTextColor = RELEASE_COLOR;
			break;

		default:
			return hbr;
	}
	pDC->SetTextColor(crTextColor);
	
	return hbr;
}

BOOL CPitchDialog::OnInitDialog() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	m_bInitingDialog = true;

	CDialog::OnInitDialog();

	// Set all the bitmaps
	CStatic* pStatic = (CStatic*)GetDlgItem(IDC_ATTACK_STATIC);
	if(pStatic)
		pStatic->SetBitmap(CInstrumentFVEditor::m_bmpAttack);
	
	pStatic = (CStatic*)GetDlgItem(IDC_DECAY_STATIC);
	if(pStatic)
		pStatic->SetBitmap(CInstrumentFVEditor::m_bmpDecay);
	
	pStatic = (CStatic*)GetDlgItem(IDC_DECAY2_STATIC);
	if(pStatic)
		pStatic->SetBitmap(CInstrumentFVEditor::m_bmpDecay2);

	pStatic = (CStatic*)GetDlgItem(IDC_SUSTAIN_STATIC);
	if(pStatic)
		pStatic->SetBitmap(CInstrumentFVEditor::m_bmpSustain);

	pStatic = (CStatic*)GetDlgItem(IDC_RELEASE_STATIC);
	if(pStatic)
		pStatic->SetBitmap(CInstrumentFVEditor::m_bmpRelease);

	pStatic = (CStatic*)GetDlgItem(IDC_RELEASE2_STATIC);
	if(pStatic)
		pStatic->SetBitmap(CInstrumentFVEditor::m_bmpRelease2);

	DWORD dw = 0;

	// Set Sustain first; this is a kludge we need to fix ADSR control J4
	// UpdateADSREnvelope fires an Sustain changed event before it the sustain is set 
	// this messes up the proper sustain value
	m_PEGADSREnvelope.SetSustainLevel(m_pArticParams->m_PitchEG.m_ptSustain >> 16);

	dw = TimeCents2Mils(m_pArticParams->m_PitchEG.m_tcRelease);
	m_PEGADSREnvelope.SetReleaseTime(dw ? (dw <= MAXADSRTIME ? dw : MAXADSRTIME) : 1);

	dw = TimeCents2Mils(m_pArticParams->m_PitchEG.m_tcDelay);
	m_PEGADSREnvelope.SetDelayTime(dw ? (dw <= MAXADSRTIME ? dw : MAXADSRTIME) : 1);
	
	dw = TimeCents2Mils(m_pArticParams->m_PitchEG.m_tcAttack);
	m_PEGADSREnvelope.SetAttackTime(dw ? (dw <= MAXADSRTIME ? dw : MAXADSRTIME) : 1);

	dw = TimeCents2Mils(m_pArticParams->m_PitchEG.m_tcHold);
	m_PEGADSREnvelope.SetHoldTime(dw ? (dw <= MAXADSRTIME ? dw : MAXADSRTIME) : 1);
	
	dw = TimeCents2Mils(m_pArticParams->m_PitchEG.m_tcDecay);
	m_PEGADSREnvelope.SetDecayTime(dw ? (dw <= MAXADSRTIME ? dw : MAXADSRTIME) : 1);

	//CollectStatics();

	BOOL bDLS1 = m_pArticulation->IsDLS1();
	EnableDLS2Controls(!bDLS1);

	// RED Attack
	CDLSStatic* pDLSStatic = GetStaticControl(IDC_PEG_ATTACK_STATIC);
	if(pDLSStatic)
		pDLSStatic->SetTextColor(RGB(255,0,0));

	// GREEN Decay
	pDLSStatic = GetStaticControl(IDC_PEG_DECAY_STATIC);
	if(pDLSStatic)
		pDLSStatic->SetTextColor(RGB(0,155,0));

	// BLUE Release
	pDLSStatic = GetStaticControl(IDC_PEG_RELEASE_STATIC);
	if(pDLSStatic)
		pDLSStatic->SetTextColor(RGB(0,0,255));
	
	m_bInitingDialog = false;

	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

void CPitchDialog::OnKillfocusPegDattack() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	PostMessage(DM_VALIDATE,IDC_PEG_DATTACK);	
}

void CPitchDialog::OnKillfocusPegDdecay() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	PostMessage(DM_VALIDATE,IDC_PEG_DDECAY);
}

void CPitchDialog::OnKillfocusPegDsustain() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	PostMessage(DM_VALIDATE,IDC_PEG_DSUSTAIN);
}

void CPitchDialog::OnKillfocusPegDrelease() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	PostMessage(DM_VALIDATE,IDC_PEG_DRELEASE);
}

void CPitchDialog::ValidateAttackTime()
{
	BOOL bUpdate;

	if ( m_bfTouched & fPEG_DATTACK )
	{
		float flOldAttack = m_flAttack;

		bUpdate = UpdateData(TRUE);	
		if(bUpdate)
		{
			if(!m_bInitingDialog)
			{
				if(FAILED(SaveUndoState(IDS_ATTACK_UNDO_TEXT)))
				{
					m_bfTouched &= ~fPEG_DATTACK;
					m_flAttack = flOldAttack;
					UpdateData(FALSE);
					return;
				}
				DWORD flAttack = (DWORD)((m_flAttack*(float)1000.0) + (float)0.5);

				// Find out the error creeping up in conversion and adjust the actual value for that
				TCENT tcAttack = Mils2TimeCents(flAttack);
				DWORD dwAttack =  TimeCents2Mils(tcAttack);
				DWORD dwErrorMargin = dwAttack - flAttack;
				flAttack = flAttack - dwErrorMargin;

				m_pArticParams->m_PitchEG.m_tcAttack = Mils2TimeCents((long)flAttack);

				// TimeCents is not millisecond accurate at higher values so we
				// need to convert back to milliseconds to display exactly how
				// many milliseconds the TimeCents value represents.
				flAttack = TimeCents2Mils(m_pArticParams->m_PitchEG.m_tcAttack);

				m_pCollection->SetDirtyFlag();
				if (m_PEGADSREnvelope)
				{
					m_PEGADSREnvelope.SetAttackTime((long)flAttack);
				}
				m_pInstrument->UpdateInstrument();
			}
		}
		else
		{
			long flAttack = TimeCents2Mils(m_pArticParams->m_PitchEG.m_tcAttack);
			char text[BUFFER_64];
			sprintf(text," %02d.%03d", flAttack/1000, flAttack%1000);

			CEdit* pDisplay = (CEdit*)GetDlgItem(IDC_PEG_DATTACK);
			if(pDisplay)
			{
				pDisplay->SetWindowText(text);
				SelectEditAndBringWindowToTop(pDisplay);
			}
		}

		m_bfTouched &= ~fPEG_DATTACK;

	}
}

void CPitchDialog::ValidateDecayTime()
{
	BOOL bUpdate;
	if ( m_bfTouched & fPEG_DDECAY )
	{
		float flOldDecay = m_flDecay;
		bUpdate = UpdateData(TRUE);	
		if(bUpdate)
		{		
			if(!m_bInitingDialog)
			{
				if(FAILED(SaveUndoState(IDS_DECAY_UNDO_TEXT)))
				{
					m_bfTouched &= ~fPEG_DDECAY;
					m_flDecay = flOldDecay;
					UpdateData(FALSE);
					return;
				}
				// Add 0.5 to the float value so that on conversion to int,
				// we get the correct value. float of 10.0 is stored as 9.99999..
				// m_fldecay is stored in seconds.
				DWORD flDecay = (DWORD)((m_flDecay*(float)1000) + (float)0.5);

				// Find out the error creeping up in conversion and adjust the actual value for that
				TCENT tcDecay = Mils2TimeCents(flDecay);
				DWORD dwDecay =  TimeCents2Mils(tcDecay);
				DWORD dwErrorMargin = dwDecay - flDecay;
				flDecay = flDecay - dwErrorMargin;


				m_pArticParams->m_PitchEG.m_tcDecay = Mils2TimeCents((long)flDecay);
				// TimeCents is not millisecond accurate at higher values so we
				// need to convert back to milliseconds to display exactly how
				// many milliseconds the TimeCents value represents.
				flDecay = TimeCents2Mils(m_pArticParams->m_PitchEG.m_tcDecay);
				m_pCollection->SetDirtyFlag();
				if (m_PEGADSREnvelope)
				{
					m_PEGADSREnvelope.SetDecayTime((long)flDecay);
				}
				m_pInstrument->UpdateInstrument();
			}
			
		}
		else
		{
			char text[BUFFER_64];
			long flDecay = TimeCents2Mils(m_pArticParams->m_PitchEG.m_tcDecay);
			sprintf(text," %02d.%03d", flDecay / 1000, flDecay % 1000);
			CEdit* pDisplay = (CEdit*)GetDlgItem(IDC_PEG_DDECAY);
			if(pDisplay)
			{
				pDisplay->SetWindowText(text);
				SelectEditAndBringWindowToTop(pDisplay);
			}
		}
		
		m_bfTouched &= ~fPEG_DDECAY;
	}
}

void CPitchDialog::ValidateSustainLevel()
{
	BOOL bUpdate;
	if ( m_bfTouched & fPEG_DSUSTAIN )
	{
		float flOldSustain = m_flSustain;

		bUpdate = UpdateData(TRUE);	
		if(bUpdate)
		{		
			if(!m_bInitingDialog)
			{
				if(FAILED(SaveUndoState(IDS_SUSTAIN_UNDO_TEXT)))
				{
					m_bfTouched &= ~fPEG_DSUSTAIN;
					m_flSustain = flOldSustain;
					UpdateData(FALSE);
					return;
				}
				// Add 0.5 to the float value so that on conversion to int,
				// we get the correct value. float of 10.0 is stored as 9.99999..
				// m_flSustain goes from 0 - 1000 (0 - 100%)
				DWORD flSustain = (DWORD)((m_flSustain * (float)10)+ (float)0.5);

				m_pArticParams->m_PitchEG.m_ptSustain = (PERCENT) flSustain;
				m_pCollection->SetDirtyFlag();
				if (m_PEGADSREnvelope)
				{
					m_PEGADSREnvelope.SetSustainLevel((long)flSustain);
				}
				m_pInstrument->UpdateInstrument();
			}
		}
		else
		{
			char text[BUFFER_64];
			long flSustain = m_pArticParams->m_PitchEG.m_ptSustain >> 16;
			sprintf(text," %02d.%d",flSustain / 10, flSustain % 10);
			CEdit * pDisplay = (CEdit*)GetDlgItem(IDC_PEG_DSUSTAIN);
			
			if(pDisplay)
			{
				pDisplay->SetWindowText(text);
				SelectEditAndBringWindowToTop(pDisplay);
			}
		}
		m_bfTouched &= ~fPEG_DSUSTAIN;
	}
}

void CPitchDialog::ValidateReleaseTime()
{
	BOOL bUpdate;
	if ( m_bfTouched & fPEG_DRELEASE )
	{
		float flOldRelease = m_flRelease;

		bUpdate = UpdateData(TRUE);	
		if(bUpdate)
		{		
			if(!m_bInitingDialog)
			{
				if(FAILED(SaveUndoState(IDS_RELEASE_UNDO_TEXT)))
				{
					m_bfTouched &= ~fPEG_DRELEASE;
					m_flRelease = flOldRelease;
					UpdateData(FALSE);
					return;
				}
				// Add 0.5 to the float value so that on conversion to int,
				// we get the correct value. float of 10.0 is stored as 9.99999..
				// m_flRelease is stored in seconds.
				DWORD flRelease = (DWORD)((m_flRelease*(float)1000) + (float)0.5);

				// Find out the error creeping up in conversion and adjust the actual value for that
				TCENT tcRelease = Mils2TimeCents(flRelease);
				DWORD dwRelease =  TimeCents2Mils(tcRelease);
				DWORD dwErrorMargin = dwRelease - flRelease;
				flRelease = flRelease - dwErrorMargin;

				m_pArticParams->m_PitchEG.m_tcRelease = Mils2TimeCents((long)flRelease);
				// TimeCents is not millisecond accurate at higher values so we
				// need to convert back to milliseconds to display exactly how
				// many milliseconds the TimeCents value represents.
				flRelease = TimeCents2Mils(m_pArticParams->m_PitchEG.m_tcRelease);
				m_pCollection->SetDirtyFlag();
				if (m_PEGADSREnvelope)
				{
					m_PEGADSREnvelope.SetReleaseTime((long)flRelease);
				}
				m_pInstrument->UpdateInstrument();
			}
		}
		else
		{
			char text[BUFFER_64];
			long flRelease = TimeCents2Mils(m_pArticParams->m_PitchEG.m_tcRelease);
			sprintf(text," %02d.%03d", flRelease / 1000, flRelease % 1000);
			CEdit* pDisplay = (CEdit*)GetDlgItem(IDC_PEG_DRELEASE);

			if(pDisplay)
			{
				pDisplay->SetWindowText(text);
				SelectEditAndBringWindowToTop(pDisplay);
			}
		}
		m_bfTouched &= ~fPEG_DRELEASE;
	}
}

void CPitchDialog::OnADSRMouseMoveStart() 
{
	if(FAILED(SaveUndoState(IDS_ADSR_UNDO_TEXT)))
		return;
}

HRESULT CPitchDialog::SaveUndoState(UINT uStringRes)
{
	CInstrumentFVEditor* pParent = (CInstrumentFVEditor*) GetParent();
	ASSERT(pParent);

	if(pParent && pParent->m_pInstrument)
	{
		if(FAILED(pParent->m_pInstrument->SaveStateForUndo(uStringRes)))
			return E_FAIL;
	}
	else
		return E_FAIL;

	return S_OK;
}

void CPitchDialog::UpdateArticulation(CArticulation * pNewArt)
{
	m_pArticParams = pNewArt->GetArticParams();

	m_pArticulation = pNewArt;
#ifdef _DEBUG	
	pNewArt->ValidateParent();
#endif

	CInstrument* pInstrument = pNewArt->GetInstrument();
	if(pInstrument)
	{
		// Articulation is owned by an instrument			
		m_pCollection = pInstrument->m_pCollection;
		m_pInstrument = pInstrument;
	}
	else
	{
		// Articulation is owned by a region
		CRegion* pRegion = pNewArt->GetRegion();
		ASSERT(pRegion);
		pInstrument = pRegion->GetInstrument();
		ASSERT(pInstrument);
		m_pCollection = pInstrument->m_pCollection;
		m_pInstrument = pInstrument;
	}
	
	m_bfTouched = 0;
	m_bTouchedByProgram = false;
	m_bInitingDialog = true;

	if (m_pmsPEGVel2Attack)
		{
		// Point sliders at new articulation values
		m_pmsPEGVel2Attack->SetDataValueToEdit(
			&(m_pArticParams->m_PitchEG.m_tcVel2Attack));
		m_pmsPEGKey2Decay->SetDataValueToEdit(
			&(m_pArticParams->m_PitchEG.m_tcKey2Decay));
		m_pmsPEGKey2Hold->SetDataValueToEdit(
			&(m_pArticParams->m_PitchEG.m_tcKey2Hold));
		m_pmsPEGRange->SetDataValueToEdit(
			&(m_pArticParams->m_PitchEG.m_pcRange));

		m_pmsPEGVel2Attack->SetValue(this, m_pArticParams->m_PitchEG.m_tcVel2Attack);
		m_pmsPEGKey2Decay->SetValue(this, m_pArticParams->m_PitchEG.m_tcKey2Decay);
		m_pmsPEGKey2Hold->SetValue(this, m_pArticParams->m_PitchEG.m_tcKey2Hold);
		m_pmsPEGRange->SetValue(this, m_pArticParams->m_PitchEG.m_pcRange);
		}
	else
		{
		m_pmsPEGVel2Attack = Insert(
			IDC_PEG_VEL2ATTACK,
			IDC_PEG_DVEL2ATTACK,
			0,
			MYSLIDER_TIMESCALE,
			0,
			IDS_VEL2ATTACK_UNDO_TEXT,
			&(m_pArticParams->m_PitchEG.m_tcVel2Attack));
	    
		m_pmsPEGKey2Decay = Insert(
			IDC_PEG_KEY2DECAY,
			IDC_PEG_DKEY2DECAY,
			0,
			MYSLIDER_TIMESCALE,
			0,
			IDS_KEY2DECAY_UNDO_TEXT,
			&(m_pArticParams->m_PitchEG.m_tcKey2Decay));

		m_pmsPEGKey2Hold = Insert(
			IDC_PEG_KEY2HOLD,
			IDC_PEG_DKEY2HOLD,
			0,
			MYSLIDER_TIMESCALE,
			0,
			IDS_UNDO_KEYTOHOLD_EDIT,
			&(m_pArticParams->m_PitchEG.m_tcKey2Hold));

		m_pmsPEGRange = Insert(
			IDC_PEG_RANGE,
			IDC_PEG_DRANGE,
			IDC_PEG_DRANGE_SPIN,
			MYSLIDER_PITCHCENTS,
			0,
			IDS_PITCH_RANGE_UNDO_TEXT,
			&(m_pArticParams->m_PitchEG.m_pcRange));
		}

	DWORD dw;

	// Set Sustain first; this is a kludge we need to fix ADSR control J4
	// UpdateADSREnvelope fires an Sustain changed event before it the sustain is set 
	// this messes up the proper sustain value
	m_PEGADSREnvelope.SetSustainLevel(m_pArticParams->m_PitchEG.m_ptSustain >> 16);

	dw = TimeCents2Mils(m_pArticParams->m_PitchEG.m_tcRelease);
	m_PEGADSREnvelope.SetReleaseTime(dw ? (dw <= MAXADSRTIME ? dw : MAXADSRTIME) : 1);
	
	dw = TimeCents2Mils(m_pArticParams->m_PitchEG.m_tcAttack);
	m_PEGADSREnvelope.SetAttackTime(dw ? (dw <= MAXADSRTIME ? dw : MAXADSRTIME) : 1);
	
	dw = TimeCents2Mils(m_pArticParams->m_PitchEG.m_tcDecay);
	m_PEGADSREnvelope.SetDecayTime(dw ? (dw <= MAXADSRTIME ? dw : MAXADSRTIME) : 1);

	BOOL bDLS1 = m_pArticulation->IsDLS1();
	EnableDLS2Controls(!bDLS1);
	
	m_bInitingDialog = false;
}

void CPitchDialog::SelectEditAndBringWindowToTop(CEdit* pEdit)
{
	ASSERT(pEdit);
	if(pEdit == NULL)
		return;

	HWND hwndEditor = NULL;
	m_pInstrument->GetEditorWindow(&hwndEditor);
	if(hwndEditor)
		::BringWindowToTop(hwndEditor);

	pEdit->SetFocus();
	pEdit->SetSel(0, -1);
}

void CPitchDialog::CollectStatics()
{
	// Remove all previous statics....should there be any?
	while(!m_lstStatics.IsEmpty())
	{
		CDLSStatic* pStatic = (CDLSStatic*) m_lstStatics.RemoveHead();
		ASSERT(pStatic);
		if(pStatic)
		{
			delete pStatic;
		}
	}

	CWnd* pChild = GetWindow(GW_CHILD);
	while(pChild)
	{
		char szClassName[MAX_PATH];
		::GetClassName(pChild->m_hWnd, szClassName, MAX_PATH);
		
		// Add it to the list if it's a "Static"
		if(strcmp(szClassName,"Static") == 0)
		{
			CDLSStatic* pDLSStatic = NULL;
			if(SUCCEEDED(CDLSStatic::CreateControl(this, pChild, &pDLSStatic)))
				m_lstStatics.AddTail(pDLSStatic);
		}

		pChild = pChild->GetNextWindow();
	}

	// Destroy the actual static controls now
	POSITION position = m_lstStatics.GetHeadPosition();
	while(position)
	{
		CDLSStatic* pStatic = (CDLSStatic*) m_lstStatics.GetNext(position);
		ASSERT(pStatic);
		CWnd* pWnd = GetDlgItem(pStatic->GetID());
		if(pWnd)
		{
			pWnd->DestroyWindow();
		}
	}
}

void CPitchDialog::OnDestroy() 
{
	CDialog::OnDestroy();
	
	// Remove all previous statics....should there be any?
	while(!m_lstStatics.IsEmpty())
	{
		CDLSStatic* pStatic = (CDLSStatic*) m_lstStatics.RemoveHead();
		ASSERT(pStatic);
		if(pStatic)
		{
			delete pStatic;
		}
	}
}

void CPitchDialog::OnPaint() 
{
	CPaintDC dc(this); // device context for painting
	
	POSITION position = m_lstStatics.GetHeadPosition();
	while(position)
	{
		CDLSStatic* pStatic = (CDLSStatic*) m_lstStatics.GetNext(position);
		ASSERT(pStatic);
		pStatic->OnDraw(&dc);
	}
}


CDLSStatic* CPitchDialog::GetStaticControl(UINT nID)
{
	POSITION position = m_lstStatics.GetHeadPosition();
	while(position)
	{
		CDLSStatic* pStatic = (CDLSStatic*) m_lstStatics.GetNext(position);
		ASSERT(pStatic);
		if(pStatic->GetID() == nID)
			return pStatic;
	}

	return NULL;
}

void CPitchDialog::OnKillfocusPegDelay() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	PostMessage(DM_VALIDATE,IDC_PEG_DDELAY);
}

void CPitchDialog::OnKillfocusPegHold() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	PostMessage(DM_VALIDATE,IDC_PEG_DHOLD);
}

void CPitchDialog::ValidateDelayTime()
{
	BOOL bUpdate;

	if ( m_bfTouched & fPEG_DDELAY )
	{
		float flOldDelay = m_flDelay;

		bUpdate = UpdateData(TRUE);	
		if(bUpdate)
		{
			if(!m_bInitingDialog)
			{
				if(FAILED(SaveUndoState(IDS_UNDO_DELAY_EDIT)))
				{
					m_bfTouched &= ~fPEG_DDELAY;
					m_flDelay = flOldDelay;
					UpdateData(FALSE);
					return;
				}
				
				DWORD flDelay = (DWORD)((m_flDelay * (float)1000.0) + (float)0.5);

				// Find out the error creeping up in conversion and adjust the actual value for that
				TCENT tcDelay = Mils2TimeCents(flDelay);
				DWORD dwDelay =  TimeCents2Mils(tcDelay);
				DWORD dwErrorMargin = dwDelay - flDelay;
				flDelay = flDelay - dwErrorMargin;

				m_pArticParams->m_PitchEG.m_tcDelay = Mils2TimeCents((long)flDelay);

				// TimeCents is not millisecond accurate at higher values so we
				// need to convert back to milliseconds to display exactly how
				// many milliseconds the TimeCents value represents.
				
				flDelay = TimeCents2Mils(m_pArticParams->m_PitchEG.m_tcDelay);

				m_pCollection->SetDirtyFlag();
				if (m_PEGADSREnvelope)
				{
					m_PEGADSREnvelope.SetDelayTime((long)flDelay);
				}
				m_pInstrument->UpdateInstrument();
			}
		}
		else
		{
			long flDelay = TimeCents2Mils(m_pArticParams->m_PitchEG.m_tcDelay);
			char text[BUFFER_64];
			sprintf(text," %02d.%03d", flDelay/1000, flDelay%1000);

			CEdit* pDisplay = (CEdit*)GetDlgItem(IDC_PEG_DATTACK);
			if(pDisplay)
			{
				pDisplay->SetWindowText(text);
				SelectEditAndBringWindowToTop(pDisplay);
			}
		}

		m_bfTouched &= ~fPEG_DDELAY;

	}
}


void CPitchDialog::ValidateHoldTime()
{
	BOOL bUpdate;

	if ( m_bfTouched & fPEG_DHOLD )
	{
		float flOldHold = m_flHold;

		bUpdate = UpdateData(TRUE);	
		if(bUpdate)
		{
			if(!m_bInitingDialog)
			{
				if(FAILED(SaveUndoState(IDS_UNDO_HOLD_EDIT)))
				{
					m_bfTouched &= ~fPEG_DHOLD;
					m_flHold = flOldHold;
					UpdateData(FALSE);
					return;
				}
				
				DWORD flHold = (DWORD)((m_flHold * (float)1000.0) + (float)0.5);

				// Find out the error creeping up in conversion and adjust the actual value for that
				TCENT tcHold = Mils2TimeCents(flHold);
				DWORD dwHold =  TimeCents2Mils(tcHold);
				DWORD dwErrorMargin = dwHold - flHold;
				flHold = flHold - dwErrorMargin;

				m_pArticParams->m_PitchEG.m_tcHold = Mils2TimeCents((long)flHold);

				// TimeCents is not millisecond accurate at higher values so we
				// need to convert back to milliseconds to display exactly how
				// many milliseconds the TimeCents value represents.
				
				flHold = TimeCents2Mils(m_pArticParams->m_PitchEG.m_tcHold);

				m_pCollection->SetDirtyFlag();
				if (m_PEGADSREnvelope)
				{
					m_PEGADSREnvelope.SetHoldTime((long)flHold);
				}
				m_pInstrument->UpdateInstrument();
			}
		}
		else
		{
			long flHold = TimeCents2Mils(m_pArticParams->m_PitchEG.m_tcHold);
			char text[BUFFER_64];
			sprintf(text," %02d.%03d", flHold/1000, flHold%1000);

			CEdit* pDisplay = (CEdit*)GetDlgItem(IDC_PEG_DHOLD);
			if(pDisplay)
			{
				pDisplay->SetWindowText(text);
				SelectEditAndBringWindowToTop(pDisplay);
			}
		}

		m_bfTouched &= ~fPEG_DHOLD;

	}
}

void CPitchDialog::OnADSREDelayTimeChangedPegAdsrenvelopectrl(long lNewDelayTime) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	char text[BUFFER_64];
    sprintf(text," %02d.%03d", lNewDelayTime / 1000, lNewDelayTime % 1000);
	CWnd* pDisplay = GetDlgItem(IDC_PEG_DDELAY);

	m_bTouchedByProgram = true;
	pDisplay->SetWindowText(text);
	m_bTouchedByProgram = false;

	if(!m_bInitingDialog)
	{
		if ( !( m_bfTouched & fPEG_DDELAY ) )
			m_pArticParams->m_PitchEG.m_tcDelay = Mils2TimeCents(lNewDelayTime);
		m_pCollection->SetDirtyFlag();
		m_pInstrument->UpdateInstrument();
	}
}

void CPitchDialog::OnADSREHoldTimeChangedPegAdsrenvelopectrl(long lNewHoldTime) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	char text[BUFFER_64];
    sprintf(text," %02d.%03d", lNewHoldTime / 1000, lNewHoldTime % 1000);
	CWnd* pDisplay = GetDlgItem(IDC_PEG_DHOLD);

	m_bTouchedByProgram = true;
	pDisplay->SetWindowText(text);
	m_bTouchedByProgram = false;

	if(!m_bInitingDialog)
	{
		if ( !( m_bfTouched & fPEG_DHOLD ) )
			m_pArticParams->m_PitchEG.m_tcHold = Mils2TimeCents(lNewHoldTime);
		m_pCollection->SetDirtyFlag();
		m_pInstrument->UpdateInstrument();
	}
}

void CPitchDialog::EnableDLS2Controls(BOOL bEnable)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	// Delay and Hold Edits
	CWnd* pWnd = GetDlgItem(IDC_PEG_DDELAY);
	if(pWnd)
		pWnd->EnableWindow(bEnable);
	pWnd = GetDlgItem(IDC_PEG_DELAY_STATIC);
	if(pWnd)
		pWnd->EnableWindow(bEnable);

	pWnd = GetDlgItem(IDC_PEG_DHOLD);
	if(pWnd)
		pWnd->EnableWindow(bEnable);
	pWnd = GetDlgItem(IDC_PEG_HOLD_STATIC);
	if(pWnd)
		pWnd->EnableWindow(bEnable);

	m_sliderKeyToHold.EnableWindow(bEnable);
	m_PEGADSREnvelope.SetDLS1(!bEnable);
}


BOOL CPitchDialog::OnCommand(WPARAM wParam, LPARAM lParam) 
{
	LRESULT lResult;
	if (CSliderCollection::OnCommand(wParam, lParam, &lResult))
		return lResult;

	return CDialog::OnCommand(wParam, lParam);
}

BOOL CPitchDialog::OnNotify(WPARAM wParam, LPARAM lParam, LRESULT* pResult) 
{
	LRESULT lResult;
	if (CSliderCollection::OnNotify(wParam, lParam, &lResult))
		return lResult;
	
	return CDialog::OnNotify(wParam, lParam, pResult);
}

void CPitchDialog::UpdateInstrument()
{
	m_pInstrument->UpdateInstrument();
	if(m_pInstrument->m_pCollection)
		m_pInstrument->m_pCollection->SetDirtyFlag();
}

bool CPitchDialog::OnSliderUpdate(MySlider *pms, DWORD dwmscupdf)
{
	switch (dwmscupdf)
		{
		case dwmscupdfStart:
			if (SUCCEEDED(SaveUndoState(pms->GetUndoStringID())))
				return true;
			UpdateArticulation(m_pArticulation);
			return false;

		case dwmscupdfEnd:
			UpdateInstrument();
			return true;

		default:
			ASSERT(FALSE);
			return false;
		}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\DLSDesigner\RegionExtraPropPg.cpp ===
// RegionExtraPropPg.cpp : implementation file
//

#include "stdafx.h"
#include "RegionPropPgMgr.h"
#include "RegionExtraPropPg.h"
#include "region.h"
#include "DlsDefsPlus.h"
#include "Collection.h"
#include "Instrument.h"
#include "Wave.h"
#include "MonoWave.h"
#include "RegionPropPgMgr.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CRegionExtraPropPg property page

IMPLEMENT_DYNCREATE(CRegionExtraPropPg, CPropertyPage)

CRegionExtraPropPg::CRegionExtraPropPg() : CPropertyPage(CRegionExtraPropPg::IDD), 
m_pRegion(NULL),
m_fActivateOverride(false),
m_fActivateAST(false),
m_fActivateASC(false),
m_fInOnInitialUpdate(true),
m_fOneShot(false),
m_pContextMenu(NULL),
m_bfTouched(0),
m_bTouchedByProgram(false),
m_dwLoopStart(MINIMUM_VALID_LOOPSTART),
m_dwLoopLength(0)
{
	//{{AFX_DATA_INIT(CRegionExtraPropPg)
	m_fAllowCompress = FALSE;
	m_fAllowTruncate = FALSE;
	//}}AFX_DATA_INIT

	m_pContextMenu = new CMenu();
	m_pContextMenu->LoadMenu(IDM_REGION_PROP_PAGE_RMENU);

	m_fNeedToDetach = FALSE;
}

CRegionExtraPropPg::~CRegionExtraPropPg()
{
	delete m_pContextMenu;
}

/////////////////////////////////////////////////////////////////////////////
// CRegionExtraPropPg::EnableControls

void CRegionExtraPropPg::EnableControls(bool fEnable) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);	

	CWnd* pCtrl;

	pCtrl = GetDlgItem(IDC_OWS_OVERRIDE);
	if(pCtrl)
	{
		pCtrl->EnableWindow(fEnable);
		pCtrl = NULL;
	}
		
    if (m_pRegion)
    {
	    EnableAST(m_pRegion->m_bOverrideWaveMoreSettings && fEnable);
	    
	    EnableASC(m_pRegion->m_bOverrideWaveMoreSettings && fEnable);

    	EnablePlayBack(m_pRegion->m_bOverrideWaveMoreSettings && fEnable);
    }
    else    // no region. fEnable will be false.
    {
        ASSERT(fEnable == FALSE);
	    EnableAST(fEnable);	   
	    EnableASC(fEnable);
    }

	// Loop controls should be grayed if playback is not checked.
    if (m_pRegion)
    {
        EnableLoopCtrls(m_pRegion->m_bOverrideWaveMoreSettings && !m_fOneShot && fEnable);
    }
}

void CRegionExtraPropPg::DoDataExchange(CDataExchange* pDX)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);	
	
	CPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CRegionExtraPropPg)
	DDX_Control(pDX, IDC_SAMPLE_LENGTH_EDIT, m_SampleLengthEdit);
	DDX_Control(pDX, IDC_OWS_LOOPSTART, m_LoopStartEdit);
	DDX_Control(pDX, IDC_OWS_LOOPLENGTH, m_LoopLengthEdit);
	DDX_Check(pDX, IDC_OWS_ALLOW_COMPRESS, m_fAllowCompress);
	DDX_Check(pDX, IDC_OWS_ALLOW_TRUNCATE, m_fAllowTruncate);
	//}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(CRegionExtraPropPg, CPropertyPage)
	//{{AFX_MSG_MAP(CRegionExtraPropPg)
	ON_WM_DESTROY()
	ON_WM_CREATE()
	ON_BN_CLICKED(IDC_OWS_LOOP, OnOwsLoop)
	ON_BN_CLICKED(IDC_OWS_ALLOW_TRUNCATE, OnOwsAllowTruncate)
	ON_BN_CLICKED(IDC_OWS_OVERRIDE, OnOwsOverride)
	ON_BN_CLICKED(IDC_OWS_ALLOW_COMPRESS, OnOwsAllowCompress)
	ON_BN_CLICKED(IDC_OWS_ONE_SHOT, OnOwsOneShot)
	ON_WM_CONTEXTMENU()
	ON_COMMAND(IDM_REVERT_TO_WAVE, OnRevertToWave)
	ON_EN_KILLFOCUS(IDC_OWS_LOOPSTART, OnKillfocusOwsLoopstart)
	ON_EN_KILLFOCUS(IDC_OWS_LOOPLENGTH, OnKillfocusOwsLooplength)
	ON_EN_CHANGE(IDC_OWS_LOOPLENGTH, OnChangeLooplength)
	ON_EN_CHANGE(IDC_OWS_LOOPSTART, OnChangeLoopstart)
	ON_MESSAGE(DM_VALIDATE,OnValidate)
	ON_BN_CLICKED(IDC_LOOP_AND_RELEASE_RADIO, OnOwsLoop)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CRegionExtraPropPg message handlers

BOOL CRegionExtraPropPg::OnSetActive() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	m_fInOnInitialUpdate = true;

	if(m_pRegion == NULL || m_pRegion->m_pWave == NULL) 
	{
		EnableControls(FALSE);
		CRegionPropPgMgr::dwLastSelPage = REGION_EXTRA_PROP_PAGE;
		return CPropertyPage::OnSetActive();
	}

	// Get the loop values from the wave
	WLOOP waveLoop = m_pRegion->m_pWave->GetWLOOP();

	// Get the smpl values from the wave
	WSMPL waveWSMPL = m_pRegion->m_pWave->GetWSMPL();

	// Get values from regions. If override is off we will set it to wave's properties.
#if MINIMUM_VALID_LOOPSTART > 0
	if(m_pRegion->m_rWLOOP.ulStart >= MINIMUM_VALID_LOOPSTART)
		m_dwLoopStart = m_pRegion->m_rWLOOP.ulStart;
	else
		m_pRegion->m_rWLOOP.ulStart = m_dwLoopStart;
#else
	m_dwLoopStart = m_pRegion->m_rWLOOP.ulStart;
#endif

	// Can't have a looop length less than 5 can we?
	if(m_pRegion->m_rWLOOP.ulLength >= MINIMUM_VALID_LOOPLENGTH)
		m_dwLoopLength = m_pRegion->m_rWLOOP.ulLength;
	else
	{
		m_pRegion->m_rWLOOP.ulLength = waveLoop.ulLength;
		m_dwLoopLength = m_pRegion->m_rWLOOP.ulLength;
	}

	m_fAllowTruncate = !(m_pRegion->m_rWSMP.fulOptions & F_WSMP_NO_TRUNCATION);
	m_fAllowCompress = !(m_pRegion->m_rWSMP.fulOptions & F_WSMP_NO_COMPRESSION);
    m_fOneShot = (m_pRegion->m_rWSMP.cSampleLoops == 0);
    
    //override wave playback settings?
    if (m_pRegion->m_pWave)
    {   
		// Set the total sample length
		CString sSampleLength;
		sSampleLength.Format("%d", m_pRegion->m_pWave->m_dwWaveLength);
		m_SampleLengthEdit.SetWindowText(sSampleLength);

        if (!m_pRegion->m_bOverrideWaveMoreSettings)    // see if we need to turn it on
        {   // override is off so set it to wave settings   
	        m_fOneShot = !(m_pRegion->m_pWave->IsLooped()); 

#if MINIMUM_VALID_LOOPSTART > 0
			if(waveLoop.ulStart >= MINIMUM_VALID_LOOPSTART)
				m_dwLoopStart = waveLoop.ulStart;
			else
				waveLoop.ulStart = m_dwLoopStart;
#else
			m_dwLoopStart = waveLoop.ulStart;
#endif

			
			if(waveLoop.ulLength >= MINIMUM_VALID_LOOPLENGTH)
			{
				m_dwLoopLength = waveLoop.ulLength;
			}
			else if(m_pRegion->m_pWave->m_dwWaveLength >= MINIMUM_VALID_LOOPLENGTH)
			{
				waveLoop.ulLength = m_pRegion->m_pWave->m_dwWaveLength;
				m_dwLoopLength = waveLoop.ulLength;
			}
			else
			{
				waveLoop.ulLength = MINIMUM_VALID_LOOPLENGTH;
				m_dwLoopLength = MINIMUM_VALID_LOOPLENGTH;
			}

			m_fAllowTruncate = !(waveWSMPL.fulOptions & F_WSMP_NO_TRUNCATION);
			m_fAllowCompress = !(waveWSMPL.fulOptions & F_WSMP_NO_COMPRESSION);
        }
		
		m_pRegion->m_pWave->SetWLOOP(waveLoop);
    }
    else   // no wave 
    {
        m_pRegion->m_bOverrideWaveMoreSettings = true;
    }

   // override Check
	m_fActivateOverride = (m_pRegion->m_bOverrideWaveMoreSettings != 0);
    CButton * pCheckBox = (CButton *) GetDlgItem(IDC_OWS_OVERRIDE);
    if (pCheckBox)
    {
        pCheckBox->SetCheck(m_pRegion->m_bOverrideWaveMoreSettings);
    }

	char text[BUFFER_64];
	sprintf(text, "%d", m_dwLoopStart);
	CWnd * pDisplay = GetDlgItem(IDC_OWS_LOOPSTART);
	if(pDisplay)
	{
		pDisplay->SetWindowText(text);
	}

	sprintf(text, "%d", m_dwLoopLength);
	pDisplay = GetDlgItem(IDC_OWS_LOOPLENGTH);
	if(pDisplay)
	{
		pDisplay->SetWindowText(text);
	}

    pCheckBox = (CButton *) GetDlgItem(IDC_OWS_ALLOW_TRUNCATE);
	if(pCheckBox)
	{
		pCheckBox->SetCheck(m_fAllowTruncate);
	}

	pCheckBox = (CButton *) GetDlgItem(IDC_OWS_ALLOW_COMPRESS);
	if(pCheckBox)
	{
		pCheckBox->SetCheck(m_fAllowCompress);
	}
    

	pCheckBox = (CButton *) GetDlgItem(IDC_OWS_ONE_SHOT);
	if(pCheckBox)
	{
		pCheckBox->SetCheck(!m_fOneShot);
	}
	
	if(waveLoop.ulType == WLOOP_TYPE_FORWARD)
	{
		// Set the forward loop type
		pCheckBox = (CButton *) GetDlgItem(IDC_OWS_LOOP);
		if(pCheckBox)
		{
			pCheckBox->SetCheck(1);
		}
	}
	else
	{
		// Set the forward loop type
		pCheckBox = (CButton *) GetDlgItem(IDC_LOOP_AND_RELEASE_RADIO);
		if(pCheckBox)
		{
			pCheckBox->SetCheck(1);
		}
	}

	EnableControls(TRUE);

	m_fInOnInitialUpdate = false;

	CRegionPropPgMgr::dwLastSelPage = REGION_EXTRA_PROP_PAGE;
	return CPropertyPage::OnSetActive();
}

void CRegionExtraPropPg::OnOwsOneShot() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if(m_fInOnInitialUpdate)
	{
		return;
	}

	ASSERT(m_pRegion);
	
	// Save the undo state 
	if(m_pRegion && m_pRegion->m_pInstrument)
	{
		if(FAILED(m_pRegion->m_pInstrument->SaveStateForUndo(IDS_UNDO_LOOPSETTINGS)))
			return;
	}

	BOOL bUpdate;
	bUpdate = UpdateData(TRUE);	

	if(bUpdate)
	{		
		// This is actually a loop check box
		CButton* pRadioBtn = (CButton *) GetDlgItem(IDC_OWS_ONE_SHOT);

		if(pRadioBtn)
		{
			int nState = pRadioBtn->GetCheck();
			
			switch(nState)
			{
				case 0:
					m_fOneShot = true;
					EnableLoopCtrls(false);
					m_pRegion->m_rWSMP.cSampleLoops = 0;
					m_pRegion->m_rWLOOP.ulType = 0;
					m_pRegion->m_rWLOOP.ulStart = 0;
					m_pRegion->m_rWLOOP.ulLength = 0;
					m_pRegion->m_rWLOOP.cbSize = sizeof(m_pRegion->m_rWLOOP);
					break;

				case 1:
					m_fOneShot = false;
					EnableLoopCtrls(true);
					m_pRegion->m_rWSMP.cSampleLoops = 1;
					m_pRegion->m_rWLOOP.ulType = WLOOP_TYPE_FORWARD;
					CButton* pLoopAndReleaseRadio = (CButton*)GetDlgItem(IDC_LOOP_AND_RELEASE_RADIO);
					if(pLoopAndReleaseRadio)
					{
						int nCheck = pLoopAndReleaseRadio->GetState();
						if(nCheck == 1)
						{
							m_pRegion->m_rWLOOP.ulType = WLOOP_TYPE_RELEASE;
						}
					}
					m_pRegion->m_rWLOOP.ulStart = m_dwLoopStart;
					m_pRegion->m_rWLOOP.ulLength = m_dwLoopLength;
					m_pRegion->m_rWLOOP.cbSize = sizeof(m_pRegion->m_rWLOOP);
					break;
			}

			// Set flag so we know to save file 
			m_pRegion->m_pInstrument->m_pCollection->SetDirtyFlag();
		
			m_pRegion->m_pInstrument->UpdateInstrument();
		}
	}
}

void CRegionExtraPropPg::OnOwsAllowCompress() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if(m_fInOnInitialUpdate)
	{
		return;
	}

	ASSERT(m_pRegion);
	
	// Save the undo state 
	if(m_pRegion && m_pRegion->m_pInstrument)
	{
		if(FAILED(m_pRegion->m_pInstrument->SaveStateForUndo(IDS_UNDO_OVERRIDE_ALLOWCOMPRESSION)))
			return;
	}
	
	BOOL bUpdate;
	bUpdate = UpdateData(TRUE);	
	{
		if(m_fAllowCompress)
		{
			m_pRegion->m_rWSMP.fulOptions &= ~F_WSMP_NO_COMPRESSION;
        }
        else
		{		
			m_pRegion->m_rWSMP.fulOptions |= F_WSMP_NO_COMPRESSION;
		}

		// Set flag so we know to save file 
		m_pRegion->m_pInstrument->m_pCollection->SetDirtyFlag();
		
		m_pRegion->m_pInstrument->UpdateInstrument();

	}
}

void CRegionExtraPropPg::OnOwsAllowTruncate() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if(m_fInOnInitialUpdate)
	{
		return;
	}

	ASSERT(m_pRegion);
	
	// Save the undo state 
	if(m_pRegion && m_pRegion->m_pInstrument)
	{
		if(FAILED(m_pRegion->m_pInstrument->SaveStateForUndo(IDS_UNDO_OVERRIDE_ALLOWTRUNCATION)))
			return;
	}
	
	BOOL bUpdate;
	bUpdate = UpdateData(TRUE);	

	if(bUpdate)
	{
		if(m_fAllowTruncate)
        {
			m_pRegion->m_rWSMP.fulOptions &= ~F_WSMP_NO_TRUNCATION;
		}
		else
		{
			m_pRegion->m_rWSMP.fulOptions |= F_WSMP_NO_TRUNCATION;
		}

		// Set flag so we know to save file 
		m_pRegion->m_pInstrument->m_pCollection->SetDirtyFlag();
		
		m_pRegion->m_pInstrument->UpdateInstrument();

	}
}

void CRegionExtraPropPg::OnOwsLoop() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	
	// Save the undo state 
	if(m_pRegion && m_pRegion->m_pInstrument)
	{
		if(FAILED(m_pRegion->m_pInstrument->SaveStateForUndo(IDS_UNDO_LOOPSETTINGS)))
			return;
	}

	// This is actually a loop check box
    CButton* pRadioBtn = (CButton *) GetDlgItem(IDC_OWS_ONE_SHOT);

	if(pRadioBtn)
	{
		int nState = pRadioBtn->GetCheck();	
	
		switch(nState)
		{
			case 0:
                m_fOneShot = true;
				EnableLoopCtrls(false);
                m_pRegion->m_rWSMP.cSampleLoops = 0;
				m_pRegion->m_rWLOOP.ulType = 0;
				m_pRegion->m_rWLOOP.ulStart = 0;
				m_pRegion->m_rWLOOP.ulLength = 0;
				m_pRegion->m_rWLOOP.cbSize = sizeof(m_pRegion->m_rWLOOP);
				break;
		
			case 1:
                m_fOneShot = false;
				EnableLoopCtrls(true);
                m_pRegion->m_rWSMP.cSampleLoops = 1;		
				m_pRegion->m_rWLOOP.ulType = WLOOP_TYPE_FORWARD;
				CButton* pLoopAndReleaseRadio = (CButton*)GetDlgItem(IDC_LOOP_AND_RELEASE_RADIO);
				if(pLoopAndReleaseRadio)
				{
					int nCheck = pLoopAndReleaseRadio->GetCheck();
					if(nCheck == 1)
					{
						m_pRegion->m_rWLOOP.ulType = WLOOP_TYPE_RELEASE;
					}
				}
				m_pRegion->m_rWLOOP.ulStart = m_dwLoopStart;
				m_pRegion->m_rWLOOP.ulLength = m_dwLoopLength;
				m_pRegion->m_rWLOOP.cbSize = sizeof(m_pRegion->m_rWLOOP);
				ValidateAndSetLoopValues();
				break;
		}

		// Set flag so we know to save file 
		m_pRegion->m_pInstrument->m_pCollection->SetDirtyFlag();
	
		m_pRegion->m_pInstrument->UpdateInstrument();

	}
}

void CRegionExtraPropPg::OnOwsOverride() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	// Save the Undo State
	if(m_pRegion && m_pRegion->m_pInstrument)
	{
		if(FAILED(m_pRegion->m_pInstrument->SaveStateForUndo(IDS_UNDO_OVERRIDE_WAVESETTINGS)))
			return;
	}


    CButton* pCheckBox = (CButton *) GetDlgItem(IDC_OWS_OVERRIDE);

	if(pCheckBox)
	{
		int nState = pCheckBox->GetCheck();
	
		switch(nState)
		{
			case 0:
				if (m_pRegion->m_pWave == NULL)
				{
					pCheckBox->SetCheck(true);
					AfxMessageBox(IDS_CANNOT_CHECK_OVERRIDE, MB_ICONEXCLAMATION);

					return;
				}
				m_fActivateOverride = false;
                RevertToWavePlaybackSettings();
                RevertToWaveAST();
                RevertToWaveASC();
				EnablePlayBack(false);
				EnableLoopCtrls(false);
				EnableAST(false);
                EnableASC(false);
				break;
		
			case 1:
				m_fActivateOverride = true;
				EnableAST(true);
				EnableASC(true);
				EnablePlayBack(true);
                EnableLoopCtrls(!m_fOneShot && true);
				break;
		}

        m_pRegion->m_bOverrideWaveMoreSettings = m_fActivateOverride;

		if(m_pRegion->m_pInstrument && m_pRegion->m_pInstrument->m_pCollection)
			m_pRegion->m_pInstrument->m_pCollection->SetDirtyFlag();
	}
}

void CRegionExtraPropPg::EnableAST(bool bNewState)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

    CWnd* pCtrl = GetDlgItem(IDC_OWS_ALLOW_TRUNCATE);
	if(pCtrl)
	{
		pCtrl->EnableWindow(bNewState);
		pCtrl = NULL;
	}
}

void CRegionExtraPropPg::EnablePlayBack(bool bNewState)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

    CWnd* pCtrl = GetDlgItem(IDC_OWS_STATIC_PLAY_BACK);
	if(pCtrl)
	{
		pCtrl->EnableWindow(bNewState);
		pCtrl = NULL;
	}
    
	pCtrl = GetDlgItem(IDC_OWS_ONE_SHOT);
	if(pCtrl)
	{
		pCtrl->EnableWindow(bNewState);
		pCtrl = NULL;
	}

	pCtrl = GetDlgItem(IDC_OWS_LOOP);
	if(pCtrl)
	{
		pCtrl->EnableWindow(bNewState);
		pCtrl = NULL;
	}
}

void CRegionExtraPropPg::EnableASC(bool bNewState)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

    CWnd* pCtrl = GetDlgItem(IDC_OWS_ALLOW_COMPRESS);
	if(pCtrl)
	{
		pCtrl->EnableWindow(bNewState);
		pCtrl = NULL;
	}
}

void CRegionExtraPropPg::EnableLoopCtrls(bool bNewState)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	CWnd* pCtrl = GetDlgItem(IDC_OWS_LOOP);
	if(pCtrl)
	{
		pCtrl->EnableWindow(bNewState);
		pCtrl = NULL;
	}

	pCtrl = GetDlgItem(IDC_LOOP_AND_RELEASE_RADIO);
	if(pCtrl)
	{
		pCtrl->EnableWindow(bNewState);
		pCtrl = NULL;
	}
    
	pCtrl = GetDlgItem(IDC_OWS_LOOPLENGTH);
	if(pCtrl)
	{
		pCtrl->EnableWindow(bNewState);
		pCtrl = NULL;
	}

    pCtrl = GetDlgItem(IDC_OWS_LOOPSTART);
	if(pCtrl)
	{
		pCtrl->EnableWindow(bNewState);
		pCtrl = NULL;
	}

    pCtrl = GetDlgItem(IDC_OWS_STATIC_START);
	if(pCtrl)
	{
		pCtrl->EnableWindow(bNewState);
		pCtrl = NULL;
	}

	pCtrl = GetDlgItem(IDC_OWS_STATIC_LENGTH);
	if(pCtrl)
	{
		pCtrl->EnableWindow(bNewState);
		pCtrl = NULL;
	}
}

void CRegionExtraPropPg::OnDestroy() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	// Detach the window from the property page structure.
	// This will be done again by the main application since
	// it owns the property sheet.  It needs o be done here
	// so that the window handle can be removed from the
	// DLLs handle map.
	if( m_fNeedToDetach && m_hWnd != NULL )
	{
		HWND hWnd = m_hWnd;
		Detach();
		m_hWnd = hWnd;
	}

	CPropertyPage::OnDestroy();
}

int CRegionExtraPropPg::OnCreate(LPCREATESTRUCT lpCreateStruct) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if(m_pRegion == NULL)
		return 0;

	// Attach the window to the property page structure.
	// This has been done once already in the main application
	// since the main application owns the property sheet.
	// It needs to be done here so that the window handle can
	// be found in the DLLs handle map.
	if(!FromHandlePermanent(m_hWnd))
	{
		HWND hWnd = m_hWnd;
		m_hWnd = NULL;
		Attach( hWnd );

		m_fNeedToDetach = TRUE;
	}

	if (CPropertyPage::OnCreate(lpCreateStruct) == -1)
		return -1;
	if (m_pRegion->m_pWave)
	{

		WSMPL waveWSMPL = m_pRegion->m_pWave->GetWSMPL();
		WLOOP waveLoop = m_pRegion->m_pWave->GetWLOOP();

		if ( (m_pRegion->m_rWSMP.cSampleLoops != waveWSMPL.cSampleLoops) ||
			 (m_pRegion->m_rWLOOP.ulStart != waveLoop.ulStart) ||
			 (m_pRegion->m_rWLOOP.ulLength != waveLoop.ulLength) ||
			 (m_pRegion->m_rWSMP.fulOptions != waveWSMPL.fulOptions) )
		{
			m_pRegion->m_bOverrideWaveMoreSettings = m_fActivateOverride = true;
			return 0;
		}
		
	}
	return 0;
}

void CRegionExtraPropPg::OnContextMenu(CWnd* pWnd, CPoint point) 
{
	/*CMenu* pPopupMenu =  m_pContextMenu->GetSubMenu(0);
	
	pPopupMenu->TrackPopupMenu(TPM_LEFTALIGN | TPM_RIGHTBUTTON | TPM_LEFTBUTTON,
							   point.x,
							   point.y,
							   this,
							   NULL);*/
}

void CRegionExtraPropPg::OnRevertToWave() 
{
	// TODO: Add your command handler code here
	
}

// ===============================================================================
// ===============================================================================
void CRegionExtraPropPg::OnKillfocusOwsLoopstart() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if ((m_bfTouched & fLOOP_START) && FAILED(ValidateAndSetLoopValues()))
		PostMessage(DM_VALIDATE,IDC_LOOP_START);
}

// ===============================================================================
// ===============================================================================
void CRegionExtraPropPg::OnKillfocusOwsLooplength() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	if ((m_bfTouched & fLOOP_LENGTH) && FAILED(ValidateAndSetLoopValues()))
		PostMessage(DM_VALIDATE,IDC_LOOP_LENGTH);
}

// ==============================================================
// RevertToWaveAST
//  Sets the wave allow sample truncation to the value specified
//  in the wave property.
// ==============================================================
void CRegionExtraPropPg::RevertToWaveAST()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
    // Get the wave's finetune.
    ASSERT(m_pRegion);

    if (m_pRegion->m_pWave) 
    {
		WSMPL waveWSMPL = m_pRegion->m_pWave->GetWSMPL();

		m_pRegion->m_rWSMP.fulOptions = waveWSMPL.fulOptions;
        
    	m_fAllowTruncate = !(m_pRegion->m_rWSMP.fulOptions & F_WSMP_NO_TRUNCATION);

        // update the checkbox.
        CButton * pCheckBox = (CButton *)GetDlgItem(IDC_OWS_ALLOW_TRUNCATE);
        if (pCheckBox)
        {
            pCheckBox->SetCheck(m_fAllowTruncate);
        }
    }
}

// ==============================================================
// RevertToWaveASC
//  Sets the wave allow sample compression to the value specified
//  in the wave property.
// ==============================================================
void CRegionExtraPropPg::RevertToWaveASC()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
    // Get the wave's finetune.
    ASSERT(m_pRegion);
    //ASSERT(m_pRegion->m_pWave); // there should always be one.

    if (m_pRegion->m_pWave) 
    {
		WSMPL waveWSMPL = m_pRegion->m_pWave->GetWSMPL();
		
		m_pRegion->m_rWSMP.fulOptions = waveWSMPL.fulOptions;
        
    	m_fAllowCompress = !(m_pRegion->m_rWSMP.fulOptions & F_WSMP_NO_COMPRESSION);

        // update the checkbox.
        CButton * pCheckBox = (CButton *)GetDlgItem(IDC_OWS_ALLOW_COMPRESS);
        if (pCheckBox)
        {
            pCheckBox->SetCheck(m_fAllowCompress);
        }
    }
}


// ==============================================================
// RevertToWavePlaybackSettings
//  Sets the plaback settings to the settings specified
//  in the wave property.
// ==============================================================
void CRegionExtraPropPg::RevertToWavePlaybackSettings()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
    // Get the wave's finetune.
    ASSERT(m_pRegion);
    //ASSERT(m_pRegion->m_pWave); // there should always be one.

    if (m_pRegion->m_pWave) 
    {
		WSMPL waveWSMPL = m_pRegion->m_pWave->GetWSMPL();
		WLOOP waveLoop = m_pRegion->m_pWave->GetWLOOP();

		// Revert for only the allow sample truncation, sample compression and loop options
		// The other options on the first property page have separate checkboxes
		m_pRegion->m_rWSMP.fulOptions = waveWSMPL.fulOptions;
		m_pRegion->m_rWSMP.cSampleLoops = waveWSMPL.cSampleLoops;

		// Check if the loop values in WLOOP are good; else fix them
		if((int)waveLoop.ulStart < 0)
			waveLoop.ulStart = 0;
		if((int)waveLoop.ulLength < MINIMUM_VALID_LOOPLENGTH)
			waveLoop.ulLength = MINIMUM_VALID_LOOPLENGTH;
	
		memcpy(&m_pRegion->m_rWLOOP, &waveLoop, sizeof(m_pRegion->m_rWLOOP));

		// Set the modified loop for the wave
		m_pRegion->m_pWave->SetWLOOP(waveLoop);

        // Set the loop start & length values.
        m_dwLoopStart = m_pRegion->m_rWLOOP.ulStart;
        m_dwLoopLength = m_pRegion->m_rWLOOP.ulLength;

    	char text[BUFFER_64];
    	sprintf(text, "%d", m_dwLoopStart);
        CWnd * pWnd = GetDlgItem(IDC_OWS_LOOPSTART);
        if (pWnd)
        {
            pWnd->SetWindowText(text);
        }

    	sprintf(text, "%d", m_dwLoopLength);
	    pWnd = GetDlgItem(IDC_OWS_LOOPLENGTH);
        if (pWnd)
        {
            pWnd->SetWindowText(text);
        }

        // Set the radio buttons.
        CButton * pBtn = (CButton *)GetDlgItem(IDC_OWS_LOOP);
        if (pBtn)
        {
            pBtn->SetCheck(m_pRegion->m_pWave->IsLooped());
        }

        pBtn = (CButton *)GetDlgItem(IDC_OWS_ONE_SHOT);
        if (pBtn)
        {
            pBtn->SetCheck(!m_pRegion->m_pWave->IsLooped());
        }
    }
    // update the synth
    m_pRegion->m_pInstrument->UpdateInstrument();
}


void CRegionExtraPropPg::OnChangeLoopstart() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	if ( m_fInOnInitialUpdate || m_bTouchedByProgram )
		return;
	m_bfTouched = fLOOP_START;
}


void CRegionExtraPropPg::OnChangeLooplength() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	if ( m_fInOnInitialUpdate || m_bTouchedByProgram )
		return;
	m_bfTouched = fLOOP_LENGTH;
}

HRESULT CRegionExtraPropPg::ValidateAndSetLoopValues()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	ASSERT(m_pRegion);
	if(m_pRegion == NULL)
	{
		return E_UNEXPECTED;
	}

	ASSERT(m_pRegion->m_pInstrument);
	if(m_pRegion->m_pInstrument == NULL)
	{
		return E_UNEXPECTED;
	}

	HRESULT hr = S_OK;

	CString sLoopValue;

	m_LoopStartEdit.GetWindowText(sLoopValue);
	DWORD dwLoopStart = (DWORD)_ttol(sLoopValue);

	m_LoopLengthEdit.GetWindowText(sLoopValue);
	DWORD dwLoopLength = (DWORD)_ttol(sLoopValue);

	// validate loop values
	hr = m_pRegion->m_pWave->HrValidateLoopValues(dwLoopStart, dwLoopLength, false);

	// Now set the actual values
	// ONLY if they're different...
	if(SUCCEEDED(hr) && (m_dwLoopStart != dwLoopStart || m_dwLoopLength != dwLoopLength))
	{
		if(m_pRegion && m_pRegion->m_pInstrument)
		{
			if(FAILED(m_pRegion->m_pInstrument->SaveStateForUndo(IDS_UNDO_LOOPPOINTS)))
			{
				hr = E_FAIL;
			}
		}
	}

	if(SUCCEEDED(hr))
	{
		m_dwLoopStart = dwLoopStart;
		m_pRegion->m_rWLOOP.ulStart = m_dwLoopStart;

		m_dwLoopLength = dwLoopLength;
		m_pRegion->m_rWLOOP.ulLength = dwLoopLength;

		UpdateData(TRUE);

		if(m_pRegion->m_pInstrument)
		{
			m_pRegion->m_pInstrument->UpdateInstrument();
			m_pRegion->m_pInstrument->m_pCollection->SetDirtyFlag();
		}
	}

	return hr;
}


LRESULT CRegionExtraPropPg::OnValidate(UINT wParam, long lParam)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	PostValidate(wParam);
	return 0;
}

void CRegionExtraPropPg::PostValidate(UINT	nControl)
{
	m_pPropMgr->ShowPropSheet();
	CWnd * pWnd = GetDlgItem(nControl);
	if (IsWindow(pWnd->GetSafeHwnd()))
    {
        pWnd->SetFocus();
        ((CEdit *)pWnd)->SetSel(0, -1);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\DLSDesigner\regionkeyboard.cpp ===
// Machine generated IDispatch wrapper class(es) created by Microsoft Visual C++

// NOTE: Do not modify the contents of this file.  If this class is regenerated by
//  Microsoft Visual C++, your modifications will be overwritten.


#include "stdafx.h"
#include "regionkeyboard.h"

/////////////////////////////////////////////////////////////////////////////
// CRegionKeyboard

IMPLEMENT_DYNCREATE(CRegionKeyboard, CWnd)

/////////////////////////////////////////////////////////////////////////////
// CRegionKeyboard properties

/////////////////////////////////////////////////////////////////////////////
// CRegionKeyboard operations

void CRegionKeyboard::InitializeKeyBoard(LPUNKNOWN RegionMap)
{
	static BYTE parms[] =
		VTS_UNKNOWN;
	InvokeHelper(0x1, DISPATCH_METHOD, VT_EMPTY, NULL, parms,
		 RegionMap);
}

void CRegionKeyboard::SetCurrentRegion(short nLayer, short nStartNote)
{
	static BYTE parms[] =
		VTS_I2 VTS_I2;
	InvokeHelper(0x2, DISPATCH_METHOD, VT_EMPTY, NULL, parms,
		 nLayer, nStartNote);
}

void CRegionKeyboard::MidiEvent(short nMidiNote, short nNoteFlag, short nVelocity)
{
	static BYTE parms[] =
		VTS_I2 VTS_I2 VTS_I2;
	InvokeHelper(0x3, DISPATCH_METHOD, VT_EMPTY, NULL, parms,
		 nMidiNote, nNoteFlag, nVelocity);
}

void CRegionKeyboard::SetRootNote(short nNote)
{
	static BYTE parms[] =
		VTS_I2;
	InvokeHelper(0x4, DISPATCH_METHOD, VT_EMPTY, NULL, parms, nNote);
}

short CRegionKeyboard::InsertNewRegion(short nStartNote, short nEndNote, short nStartVelocity, short nEndVelocity)
{
	short result;
	static BYTE parms[] =
		VTS_I2 VTS_I2 VTS_I2 VTS_I2;
	InvokeHelper(0x5, DISPATCH_METHOD, VT_I2, (void*)&result, parms,
		 nStartNote, nEndNote, nStartVelocity, nEndVelocity);

	return result;
}

short CRegionKeyboard::InsertRegion(short nLayer, short nStartNote, short nEndNote, short nStartVelocity, short nEndVelocity, LPCTSTR pszWaveName)
{
	short result;
	static BYTE parms[] =
		VTS_I2 VTS_I2 VTS_I2 VTS_I2 VTS_I2 VTS_BSTR;
	InvokeHelper(0x6, DISPATCH_METHOD, VT_I2, (void*)&result, parms,
		 nLayer, nStartNote, nEndNote, nStartVelocity, nEndVelocity, pszWaveName);

	return result;
}

BOOL CRegionKeyboard::SetRange(short nStartNote, short nEndNote, short nStartVelocity, short nEndVelocity)
{
	BOOL result;
	static BYTE parms[] =
		VTS_I2 VTS_I2 VTS_I2 VTS_I2;
	InvokeHelper(0x7, DISPATCH_METHOD, VT_BOOL, (void*)&result, parms,
		 nStartNote, nEndNote, nStartVelocity, nEndVelocity);

	return result;
}

void CRegionKeyboard::DeleteRegion(short nLayer, short nStartNote)
{
	static BYTE parms[] = VTS_I2 VTS_I2;
	InvokeHelper(0x8, DISPATCH_METHOD, VT_EMPTY, NULL, parms, nLayer, nStartNote);
}

void CRegionKeyboard::DeleteAllRegions()
{
	InvokeHelper(0x9, DISPATCH_METHOD, VT_EMPTY, NULL, NULL);
}

void CRegionKeyboard::ReleaseMouseCapture()
{
	InvokeHelper(0xA, DISPATCH_METHOD, VT_EMPTY, NULL, NULL);
}

void CRegionKeyboard::TurnOffMidiNotes()
{
	InvokeHelper(0xB, DISPATCH_METHOD, VT_EMPTY, NULL, NULL);
}

short CRegionKeyboard::SetCurrentLayer(short nLayer)
{
	short result;
	static BYTE parms[] = VTS_I2;
	InvokeHelper(12, DISPATCH_METHOD, VT_I2, (void*)&result, parms, nLayer);
	return result;
}

short CRegionKeyboard::SetFirstVisibleLayer(short nLayer)
{
	short result;
	static BYTE parms[] = VTS_I2;
	InvokeHelper(13, DISPATCH_METHOD, VT_I2, (void*)&result, parms, nLayer);
	return result;
}

short CRegionKeyboard::ScrollLayers(short nSBCode, short nCurPos)
{
	short result;
	static BYTE parms[] = VTS_I2 VTS_I2;
	InvokeHelper(14, DISPATCH_METHOD, VT_I2, (void*)&result, parms, nSBCode, nCurPos);
	return result;
}

short CRegionKeyboard::GetNumberOfLayers()
{
	short result;
	InvokeHelper(15, DISPATCH_METHOD, VT_I2, (void*)&result, NULL, NULL);
	return result;
}

short CRegionKeyboard::GetFirstVisibleLayer()
{
	short result;
	InvokeHelper(16, DISPATCH_METHOD, VT_I2, (void*)&result, NULL, NULL);
	return result;
}

short CRegionKeyboard::AddNewLayer() 
{
	short result;
	InvokeHelper(17, DISPATCH_METHOD, VT_I2, (void*)&result, NULL, NULL);
	return result;
}

short CRegionKeyboard::DeleteActiveLayer() 
{
	short result;
	InvokeHelper(18, DISPATCH_METHOD, VT_I2, (void*)&result, NULL, NULL);
	return result;
}

void CRegionKeyboard::SetAuditionMode(BOOL bAuditionMode)
{
	static BYTE parms[] = VTS_BOOL;
	InvokeHelper(19, DISPATCH_METHOD, VT_EMPTY, NULL, parms, bAuditionMode);
}

void CRegionKeyboard::EnableRegion(short nLayer, short nStartNote, BOOL bEnable) 
{
	static BYTE parms[] = VTS_I2 VTS_I2 VTS_BOOL;
	InvokeHelper(20, DISPATCH_METHOD, VT_EMPTY, NULL, parms, nLayer, nStartNote, bEnable);
}

void CRegionKeyboard::SetNumberOfLayers(short nLayers)
{
	static BYTE parms[] = VTS_I2;
	InvokeHelper(21, DISPATCH_METHOD, VT_EMPTY, NULL, parms, nLayers);
}

void CRegionKeyboard::AboutBox()
{
	InvokeHelper(0xfffffdd8, DISPATCH_METHOD, VT_EMPTY, NULL, NULL);
}

void CRegionKeyboard::SetWaveName(short nLayer, short nStartNote, LPCTSTR pszWaveName) 
{
	static BYTE parms[] = VTS_I2 VTS_I2 VTS_BSTR;
	InvokeHelper(22, DISPATCH_METHOD, VT_EMPTY, NULL, parms, nLayer, nStartNote, pszWaveName);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\DLSDesigner\regionkeyboard.h ===
#if !defined(AFX_REGIONKEYBOARD_H__F78E9A62_FFB0_11D1_B987_006097B01078__INCLUDED_)
#define AFX_REGIONKEYBOARD_H__F78E9A62_FFB0_11D1_B987_006097B01078__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// Machine generated IDispatch wrapper class(es) created by Microsoft Visual C++

// NOTE: Do not modify the contents of this file.  If this class is regenerated by
//  Microsoft Visual C++, your modifications will be overwritten.

/////////////////////////////////////////////////////////////////////////////
// CRegionKeyboard wrapper class

class CRegionKeyboard : public CWnd
{
protected:
	DECLARE_DYNCREATE(CRegionKeyboard)
public:
	CLSID const& GetClsid()
	{
		static CLSID const clsid
			= { 0x36cd3187, 0xee61, 0x11d0, { 0x87, 0x6a, 0x0, 0xaa, 0x0, 0xc0, 0x81, 0x46 } };
		return clsid;
	}
	virtual BOOL Create(LPCTSTR lpszClassName,
		LPCTSTR lpszWindowName, DWORD dwStyle,
		const RECT& rect,
		CWnd* pParentWnd, UINT nID,
		CCreateContext* pContext = NULL)
	{ return CreateControl(GetClsid(), lpszWindowName, dwStyle, rect, pParentWnd, nID); }

    BOOL Create(LPCTSTR lpszWindowName, DWORD dwStyle,
		const RECT& rect, CWnd* pParentWnd, UINT nID,
		CFile* pPersist = NULL, BOOL bStorage = FALSE,
		BSTR bstrLicKey = NULL)
	{ return CreateControl(GetClsid(), lpszWindowName, dwStyle, rect, pParentWnd, nID,
		pPersist, bStorage, bstrLicKey); }

// Attributes
public:

// Operations
public:
	
	void	InitializeKeyBoard(LPUNKNOWN RegionMap);
	void	SetCurrentRegion(short nLayer, short nStartNote);
	void	MidiEvent(short nMidiNote, short nNoteFlag, short nVelocity);
	void	AboutBox();
	void	SetRootNote(short nNote);
	short	InsertNewRegion(short nStartNote, short nEndNote, short nStartVelocity, short nEndVelocity);
	short	InsertRegion(short nLayer, short nStartNote, short nEndNote, short nStartVelocity, short nEndVelocity, LPCTSTR pszWaveName);
	BOOL	SetRange(short nStartNote, short nEndNote, short nStartVelocity, short nEndVelocity);
	void	DeleteRegion(short nLayer, short nStartNote);
	void	DeleteAllRegions();
	void	ReleaseMouseCapture();
	void	TurnOffMidiNotes();
	short	SetCurrentLayer(short nLayer);
	short	SetFirstVisibleLayer(short nLayer);
	short   ScrollLayers(short nSBCode, short nCurPos);
	short   GetNumberOfLayers();
	short	GetFirstVisibleLayer();
	short	AddNewLayer();
	short	DeleteActiveLayer();	
	void	SetAuditionMode(BOOL bAuditionMode);
	void	EnableRegion(short nLayer, short nStartNote, BOOL bEnable);
	void	SetNumberOfLayers(short nLayers);
	void	SetWaveName(short nLayer, short nStartNote, LPCTSTR pszWaveName);
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_REGIONKEYBOARD_H__F78E9A62_FFB0_11D1_B987_006097B01078__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\DLSDesigner\RegionExtraPropPg.h ===
#if !defined(AFX_REGIONEXTRAPROPPG_H__6E263AA2_ECD6_11D0_876A_00AA00C08146__INCLUDED_)
#define AFX_REGIONEXTRAPROPPG_H__6E263AA2_ECD6_11D0_876A_00AA00C08146__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

// RegionExtraPropPg.h : header file
//

#include "resource.h"
#include "myslider.h"

class CRegion;
class CRegionPropPgMgr;

#define DM_VALIDATE (WM_USER + 1000)

/////////////////////////////////////////////////////////////////////////////
// CRegionExtraPropPg dialog

class CRegionExtraPropPg : public CPropertyPage
{
	DECLARE_DYNCREATE(CRegionExtraPropPg)

// Construction
public:
	CRegionExtraPropPg();
	~CRegionExtraPropPg();

	void SetObject(CRegion* pRegion) {m_pRegion = pRegion;}
	void SetPropMgr(CRegionPropPgMgr* pPropMgr) {m_pPropMgr = pPropMgr;}	

	void EnableControls(bool fEnable);
	void EnableAST(bool bNewState);
	void EnablePlayBack(bool bNewState);
	void EnableASC(bool bNewState);
	void EnableLoopCtrls(bool bNewState);
    void RevertToWaveASC(void);
    void RevertToWaveAST(void);
    void RevertToWavePlaybackSettings(void);

// Dialog Data
	//{{AFX_DATA(CRegionExtraPropPg)
	enum { IDD = IDD_REGION_EXTRA_PROP_PAGE };
	CEdit	m_SampleLengthEdit;
	CEdit	m_LoopStartEdit;
	CEdit	m_LoopLengthEdit;
	BOOL	m_fAllowCompress;
	BOOL	m_fAllowTruncate;
	//}}AFX_DATA

	DWORD	m_dwLoopLength;
	DWORD	m_dwLoopStart;

CMenu* m_pContextMenu;

// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CRegionExtraPropPg)
	public:
	virtual BOOL OnSetActive();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CRegionExtraPropPg)
	afx_msg void OnDestroy();
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	afx_msg void OnOwsLoop();
	afx_msg void OnOwsAllowTruncate();
	afx_msg void OnOwsOverride();
	afx_msg void OnOwsAllowCompress();
	afx_msg void OnOwsOneShot();
	afx_msg void OnContextMenu(CWnd* pWnd, CPoint point);
	afx_msg void OnRevertToWave();
	afx_msg void OnKillfocusOwsLoopstart();
	afx_msg void OnKillfocusOwsLooplength();
	afx_msg void OnChangeLooplength();
	afx_msg void OnChangeLoopstart();
	afx_msg LRESULT OnValidate(UINT wParam, long lParam);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
	enum { fLOOP_START = 0x01,	fLOOP_LENGTH = 0x02, fROOT_NOTE = 0x04 };
private:
	HRESULT ValidateAndSetLoopValues();
	void PostValidate(UINT	nControl);
	BOOL		m_fOneShot;
	CRegion*	m_pRegion;
	bool		m_fInOnInitialUpdate;
	bool		m_fActivateOverride;
	bool		m_fActivateAST;
	bool		m_fActivateASC;
	bool		m_fActivateLoop;

	DWORD m_bfTouched; //bit field for "has control been changed by user?"
	bool m_bTouchedByProgram; //Did program call SetWindowText() on this control?
	CRegionPropPgMgr*  m_pPropMgr;

	BOOL m_fNeedToDetach;
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_REGIONEXTRAPROPPG_H__6E263AA2_ECD6_11D0_876A_00AA00C08146__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\DLSDesigner\RegionPropPg.cpp ===
// RegionPropPg.cpp : implementation file
//

#include "stdafx.h"
#include "Region.h"
#include "RegionPropPg.h"
#include "RegionPropPgMgr.h"
#include "DlsDefsPlus.h"
#include "Collection.h"
#include "Instrument.h"
#include "Wave.h"
#include "MonoWave.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

extern short stringtonote(char * psz);
extern BOOL isValidNoteString(char * psz);

 
UINT CRegionPropPg::m_arrChannelPositions[MAX_WAVELINK_CHANNELS] = 
{IDS_REGION_CHANNEL0, IDS_REGION_CHANNEL1,  IDS_REGION_CHANNEL2, IDS_REGION_CHANNEL3, IDS_REGION_CHANNEL4, 
IDS_REGION_CHANNEL5, IDS_REGION_CHANNEL6, IDS_REGION_CHANNEL7, IDS_REGION_CHANNEL8, IDS_REGION_CHANNEL9, 
IDS_REGION_CHANNEL10, IDS_REGION_CHANNEL11, IDS_REGION_CHANNEL12, IDS_REGION_CHANNEL13, IDS_REGION_CHANNEL14,
IDS_REGION_CHANNEL15, IDS_REGION_CHANNEL16, IDS_REGION_CHANNEL17};

/////////////////////////////////////////////////////////////////////////////
// CRegionPropPg property page

IMPLEMENT_DYNCREATE(CRegionPropPg, CPropertyPage)

CRegionPropPg::CRegionPropPg() : CPropertyPage(CRegionPropPg::IDD), CSliderCollection(2),
m_pRegion(NULL),
m_fInOnInitialUpdate(true),
m_fActivateFineTune(false),
m_fActivateAttenuation(false),
m_fActivateRootNote(false),
m_fNeedToDetach(FALSE),
m_pContextMenu(NULL),
m_pmsAttenuation(NULL),
m_pmsTune(NULL)
{
	//{{AFX_DATA_INIT(CRegionPropPg)
	//}}AFX_DATA_INIT

    m_pContextMenu = new CMenu();
	m_pContextMenu->LoadMenu(IDM_REGION_PROP_PAGE_RMENU);
	CSliderCollection::Init(this);
}

CRegionPropPg::~CRegionPropPg()
{
	delete m_pContextMenu;
}

/////////////////////////////////////////////////////////////////////////////
// CRegionPropPg::EnableControls

void CRegionPropPg::EnableControls(BOOL fEnable) 
{
	CWnd * pCtrl = GetDlgItem(IDC_PHASE_GROUP_CHECK);
	if(pCtrl)
	{
		pCtrl->EnableWindow(fEnable);
		pCtrl = NULL;
	}

	pCtrl = GetDlgItem(IDC_OWS_ACTIVE_ATTENUATION);
	if(pCtrl)
	{
		pCtrl->EnableWindow(fEnable);
		pCtrl = NULL;
	}

	pCtrl = GetDlgItem(IDC_OWS_ACTIVE_ROOT_NOTE);
	if(pCtrl)
	{
		pCtrl->EnableWindow(fEnable);
		pCtrl = NULL;
	}

	pCtrl = GetDlgItem(IDC_OWS_ACTIVE_FINE_TUNE);
	if(pCtrl)
	{
		pCtrl->EnableWindow(fEnable);
		pCtrl = NULL;
	}

	EnablePhaseGroupControls(fEnable != 0);

	EnableFineTune(m_fActivateFineTune && fEnable);
	
	EnableAttenuation(m_fActivateAttenuation && fEnable);

	EnableRootNote(m_fActivateRootNote && fEnable);
}

void CRegionPropPg::DoDataExchange(CDataExchange* pDX)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);	
	
	CPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CRegionPropPg)
	DDX_Control(pDX, IDC_MULTICHANNEL_CHECK, m_MultichannelCheck);
	DDX_Control(pDX, IDC_CHANNEL_COMBO, m_ChannelCombo);
	DDX_Control(pDX, IDC_PHASE_GROUP_SPIN, m_PhaseGroupSpin);
	DDX_Control(pDX, IDC_PHASE_GROUP_EDIT, m_PhaseGroupEdit);
	DDX_Control(pDX, IDC_PHASE_GROUP_CHECK, m_PhaseGroupCheck);
	DDX_Control(pDX, IDC_MASTER_CHECK, m_MasterCheck);
	DDX_Control(pDX, IDC_OWS_DUNITYNOTE, m_RootNoteEdit);
	DDX_Control(pDX, IDC_OWS_ROOT_NODE_SPIN, m_RootNoteSpin);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CRegionPropPg, CPropertyPage)
	//{{AFX_MSG_MAP(CRegionPropPg)
	ON_WM_CREATE()
	ON_WM_DESTROY()
	ON_BN_CLICKED(IDC_OWS_ACTIVE_ATTENUATION, OnOwsActiveAttenuation)
	ON_BN_CLICKED(IDC_OWS_ACTIVE_FINE_TUNE, OnOwsActiveFineTune)
	ON_BN_CLICKED(IDC_OWS_ACTIVE_ROOT_NOTE, OnOwsActiveRootNote)
	ON_WM_HSCROLL()
	ON_WM_CONTEXTMENU()
	ON_EN_KILLFOCUS(IDC_OWS_DUNITYNOTE, OnKillfocusOwsDunitynote)
	ON_NOTIFY(UDN_DELTAPOS, IDC_OWS_ROOT_NODE_SPIN, OnDeltaposOwsRootNodeSpin)
	ON_BN_CLICKED(IDC_PHASE_GROUP_CHECK, OnPhaseGroupCheck)
	ON_EN_KILLFOCUS(IDC_PHASE_GROUP_EDIT, OnKillfocusPhaseGroupEdit)
	ON_NOTIFY(UDN_DELTAPOS, IDC_PHASE_GROUP_SPIN, OnDeltaposPhaseGroupSpin)
	ON_BN_CLICKED(IDC_MASTER_CHECK, OnMasterCheck)
	ON_CBN_SELCHANGE(IDC_CHANNEL_COMBO, OnSelchangeChannelCombo)
	ON_BN_CLICKED(IDC_MULTICHANNEL_CHECK, OnMultichannelCheck)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CRegionPropPg message handlers

BOOL CRegionPropPg::OnSetActive() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	BOOL	bRetval;

	m_fInOnInitialUpdate = true;

	CRegionPropPgMgr::dwLastSelPage = REGION_PROP_PAGE;
	bRetval = CPropertyPage::OnSetActive();
	
	if(m_pRegion == NULL)
	{
		EnableControls(FALSE);
		return bRetval;
	}

	InitPhaseGroupControls();

    if (m_pRegion->m_pWave)
    {
		WSMPL waveWSMPL = m_pRegion->m_pWave->GetWSMPL();

        // If the wave root note changed in the instrument dialog and we were not
        // initiliazed we need to check to see if rootnote changed.
        if (!m_pRegion->m_bOverrideWaveRootNote) // see if we need to turn it on
        {
            m_pRegion->m_bOverrideWaveRootNote =  
                (m_pRegion->m_rWSMP.usUnityNote == waveWSMPL.usUnityNote) ? false : true;
        }
        
        if (!m_pRegion->m_bOverrideWaveAttenuation) // see if we need to turn it on
        {
            m_pRegion->m_bOverrideWaveAttenuation =  
                (m_pRegion->m_rWSMP.lAttenuation == waveWSMPL.lAttenuation) ? false : true;
        }

        if (m_pRegion->m_bOverrideWaveFineTune) // see if we need to turn it on
        {
            m_pRegion->m_bOverrideWaveFineTune =  
                (m_pRegion->m_rWSMP.sFineTune == waveWSMPL.sFineTune) ? false : true;
        }

        m_fActivateRootNote = m_pRegion->m_bOverrideWaveRootNote;
        m_fActivateAttenuation = m_pRegion->m_bOverrideWaveAttenuation;
        m_fActivateFineTune = m_pRegion->m_bOverrideWaveFineTune;
    }
    else    // If there is no wave, override must be true.
    {
        m_pRegion->m_bOverrideWaveRootNote = true;
        m_fActivateRootNote = true;

        m_pRegion->m_bOverrideWaveAttenuation = true;
        m_fActivateAttenuation = true;

        m_pRegion->m_bOverrideWaveFineTune = true;
        m_fActivateFineTune = true;

    }

	// If the user chose to override wave settings we use the region root note.
    // else the region root note and the wave root note are the same.
    m_RootNoteSpin.SetRange(0, 127);
	if (m_pRegion->m_bOverrideWaveRootNote)
    {
	    UpdateRootNoteText(m_pRegion->m_rWSMP.usUnityNote);
		m_RootNoteSpin.SetPos(m_pRegion->m_rWSMP.usUnityNote);
	}
    else    
    {   // If we are not overriding the wave, there must be a wave.
        ASSERT(m_pRegion->m_pWave);
		WSMPL waveWSMPL = m_pRegion->m_pWave->GetWSMPL();

		UpdateRootNoteText(waveWSMPL.usUnityNote);
        // use default root note for a region
        m_pRegion->m_rWSMP.usUnityNote = waveWSMPL.usUnityNote;
		m_RootNoteSpin.SetPos(waveWSMPL.usUnityNote);
    }
   	
	

    // Set finetune and attenuation
    if (m_pRegion->m_bOverrideWaveAttenuation)
    {
    	m_lAttenuation = m_pRegion->m_rWSMP.lAttenuation;
    }
    else    
    {   //If we are not overriding the wave, there must be a wave.
        ASSERT(m_pRegion->m_pWave);
		WSMPL waveWSMPL = m_pRegion->m_pWave->GetWSMPL();

    	m_lAttenuation = waveWSMPL.lAttenuation;
        //else use default root note for a region
        m_pRegion->m_rWSMP.lAttenuation = m_lAttenuation;
    }

    if (m_pRegion->m_bOverrideWaveFineTune)
    {
        m_lFineTune = (long) m_pRegion->m_rWSMP.sFineTune << 16;
    }
    else    
    {   //If we are not overriding the wave, there must be a wave.
        ASSERT(m_pRegion->m_pWave);
		WSMPL waveWSMPL = m_pRegion->m_pWave->GetWSMPL();

        m_lFineTune = (long) waveWSMPL.sFineTune << 16;
        //else use default root note for a region
        m_pRegion->m_rWSMP.sFineTune = waveWSMPL.sFineTune;
    }
       
    // Initialize the sliders
	if (m_pmsTune)
		{
		m_pmsTune->SetValue(this, m_lFineTune);
		m_pmsAttenuation->SetValue(this, m_lAttenuation);
		}

	char text[BUFFER_64];
	if (m_lFineTune < 0)
    {
		m_lFineTune = -m_lFineTune >> 16;
        sprintf(text,"-%02d.%02d ", m_lFineTune / 100, m_lFineTune % 100);
	}
	else
	{
		m_lFineTune = m_lFineTune >> 16;		
		sprintf(text," %02d.%02d", m_lFineTune / 100, m_lFineTune % 100);
	}

	CWnd * pDisplay = GetDlgItem(IDC_OWS_DTUNE);
	if(pDisplay)
	{
		pDisplay->SetWindowText(text);
	}

	sprintf(text, "%d", m_lAttenuation);
    if (m_lAttenuation < 0)
    {
        m_lAttenuation = -m_lAttenuation >> 16;
        sprintf(text,"-%02d.%01d", m_lAttenuation / 10, m_lAttenuation % 10);
    }
    else 
    {
        m_lAttenuation = m_lAttenuation >> 16;
        sprintf(text," %02d.%01d", m_lAttenuation / 10, m_lAttenuation % 10);
    }

	pDisplay = GetDlgItem(IDC_OWS_ATTENUATION);

	if(pDisplay)
	{
		pDisplay->SetWindowText(text);
	}

    // Now enable controls
	EnableControls(TRUE);
	m_fInOnInitialUpdate = false;
	return bRetval;
}

void CRegionPropPg::OnOwsActiveAttenuation() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	
	// Save the undo state 
	if(m_pRegion && m_pRegion->m_pInstrument)
	{
		if(FAILED(m_pRegion->m_pInstrument->SaveStateForUndo(IDS_UNDO_OVERRIDE_ATTENUATION)))
		{
			CButton * pBtn = (CButton *)GetDlgItem(IDC_OWS_ACTIVE_ATTENUATION);
			if (pBtn)
			{
				pBtn->SetCheck(m_fActivateAttenuation);
			}
			return;
		}
	}


    CButton* pCheckBox = (CButton *) GetDlgItem(IDC_OWS_ACTIVE_ATTENUATION);

	if(pCheckBox)
	{
        if (m_pRegion->m_pWave == NULL)
        {
            AfxMessageBox(IDS_CANNOT_CHECK_OVERRIDE, MB_ICONEXCLAMATION);
            pCheckBox->SetCheck(true);
            return;
        }

		UINT uState = pCheckBox->GetState();	
	
		switch(uState & 0x0003)
		{
			case 0:
				m_pRegion->m_bOverrideWaveAttenuation = m_fActivateAttenuation = false;
                RevertToWaveAttenuation();                
				EnableAttenuation(false);
				break;
		
			case 1:
				m_pRegion->m_bOverrideWaveAttenuation = m_fActivateAttenuation = true;
				EnableAttenuation(true);
				break;
		}

		if(m_pRegion->m_pInstrument && m_pRegion->m_pInstrument->m_pCollection)
			m_pRegion->m_pInstrument->m_pCollection->SetDirtyFlag();
	}
}

void CRegionPropPg::OnOwsActiveFineTune() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
		
	// Save the undo state 
	if(m_pRegion && m_pRegion->m_pInstrument)
	{
		if(FAILED(m_pRegion->m_pInstrument->SaveStateForUndo(IDS_UNDO_OVERRIDE_FINETUNE)))
		{
			CButton * pBtn = (CButton *)GetDlgItem(IDC_OWS_ACTIVE_FINE_TUNE);
			if (pBtn)
			{
				pBtn->SetCheck(m_fActivateFineTune);
			}
			return;
		}	
	}

    CButton* pCheckBox = (CButton *) GetDlgItem(IDC_OWS_ACTIVE_FINE_TUNE);

	if(pCheckBox)
	{
        if (m_pRegion->m_pWave == NULL)
        {
            AfxMessageBox(IDS_CANNOT_CHECK_OVERRIDE, MB_ICONEXCLAMATION);
            pCheckBox->SetCheck(true);
            return;
        }

        UINT uState = pCheckBox->GetState();	
	
		switch(uState & 0x0003)
		{
			case 0:
				m_pRegion->m_bOverrideWaveFineTune = m_fActivateFineTune = false;
                RevertToWaveFineTune();                
				EnableFineTune(false);
				break;
		
			case 1:
				m_pRegion->m_bOverrideWaveFineTune = m_fActivateFineTune = true;
				EnableFineTune(true);
				break;
		}
		
		if(m_pRegion->m_pInstrument && m_pRegion->m_pInstrument->m_pCollection)
			m_pRegion->m_pInstrument->m_pCollection->SetDirtyFlag();
	}
}

void CRegionPropPg::OnOwsActiveRootNote() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	// Save the undo state 
	if(m_pRegion && m_pRegion->m_pInstrument)
	{
		if(FAILED(m_pRegion->m_pInstrument->SaveStateForUndo(IDS_UNDO_OVERRIDE_ROOTNOTE)))
		{
			CButton * pBtn = (CButton *)GetDlgItem(IDC_OWS_ACTIVE_ROOT_NOTE);
			if (pBtn)
			{
				pBtn->SetCheck(m_fActivateRootNote);
			}
			return;
		}
	}

    CButton* pCheckBox = (CButton *) GetDlgItem(IDC_OWS_ACTIVE_ROOT_NOTE);

	if(pCheckBox)
	{
        if (m_pRegion->m_pWave == NULL)
        {
            AfxMessageBox(IDS_CANNOT_CHECK_OVERRIDE, MB_ICONEXCLAMATION);
            pCheckBox->SetCheck(true);
            return;
        }
		
        UINT uState = pCheckBox->GetState();	
	
		switch(uState & 0x0003)
		{
			case 0:
				m_pRegion->m_bOverrideWaveRootNote = m_fActivateRootNote = false;
                RevertToWaveRootNote();                
				EnableRootNote(false);
				break;
		
			case 1:
				m_pRegion->m_bOverrideWaveRootNote = m_fActivateRootNote = true;
				EnableRootNote(true);
				break;
		}

		if(m_pRegion->m_pInstrument && m_pRegion->m_pInstrument->m_pCollection)
			m_pRegion->m_pInstrument->m_pCollection->SetDirtyFlag();
	}
}

void CRegionPropPg::UpdateOwsDattenuation() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if(m_fInOnInitialUpdate || !m_pRegion)
	{
		return;
	}
	if(UpdateData(TRUE))
	{
		if(m_pRegion->m_rWSMP.lAttenuation != m_lAttenuation)
		{
			if(m_pRegion && m_pRegion->m_pInstrument)
			{
				if(FAILED(m_pRegion->m_pInstrument->SaveStateForUndo(IDS_UNDO_ATTENUATION)))
				{
					m_lAttenuation = m_pRegion->m_rWSMP.lAttenuation ;
					m_pmsAttenuation->SetValue(this, m_lAttenuation);
					UpdateData(FALSE);
					return;
				}
			}
		}
		else
			return;

		m_pRegion->m_rWSMP.lAttenuation = m_lAttenuation;

		// Set flag so we know to save file 
		m_pRegion->m_pInstrument->m_pCollection->SetDirtyFlag();
		m_pRegion->m_pInstrument->UpdateInstrument();
		m_pRegion->m_pInstrument->RefreshRegion();
	}
}

void CRegionPropPg::UpdateOwsDtune() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if(m_fInOnInitialUpdate || !m_pRegion)
	{
		return;
	}
	if(UpdateData(TRUE))
	{
		if(m_pRegion->m_rWSMP.sFineTune != (WORD) (m_lFineTune >> 16))
		{
			if(m_pRegion && m_pRegion->m_pInstrument)
			{
				if(FAILED(m_pRegion->m_pInstrument->SaveStateForUndo(IDS_UNDO_FINETUNE)))
				{
					m_lFineTune = (long) m_pRegion->m_rWSMP.sFineTune << 16;
					m_pmsTune->SetValue(this, m_lFineTune);
					UpdateData(FALSE);
					return;
				}
			}
		}
		else
			return;

		m_pRegion->m_rWSMP.sFineTune = (WORD) (m_lFineTune >> 16);

		// Set flag so we know to save file 
		m_pRegion->m_pInstrument->m_pCollection->SetDirtyFlag();
		m_pRegion->m_pInstrument->UpdateInstrument();
	}
}

void CRegionPropPg::OnHScroll(UINT nSBCode, UINT nPos, CScrollBar* pScrollBar) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	CSliderCollection::OnHScroll(nSBCode, nPos, pScrollBar);
	CPropertyPage::OnHScroll(nSBCode, nPos, pScrollBar);
}

void CRegionPropPg::EnablePhaseGroupControls(bool bNewState)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	EnablePhaseGroupEdit(bNewState);
	m_MultichannelCheck.EnableWindow(bNewState);

	EnableChannelCombo(bNewState);

}

void CRegionPropPg::EnablePhaseGroupEdit(bool bNewState)
{
	bool bEnablePhaseGroupEdit = bNewState;
	if(bNewState == TRUE)
	{
		ASSERT(m_pRegion);
		WAVELINK waveLink = m_pRegion->GetWaveLink();
		bEnablePhaseGroupEdit = waveLink.usPhaseGroup != 0;
	}

	m_PhaseGroupEdit.EnableWindow(bEnablePhaseGroupEdit);
	m_PhaseGroupSpin.EnableWindow(bEnablePhaseGroupEdit);
	m_MasterCheck.EnableWindow(bEnablePhaseGroupEdit);
}

void CRegionPropPg::EnableChannelCombo(bool bNewState)
{
	bool bEnableChannelCombo = bNewState;
	if(bNewState == TRUE)
	{
		ASSERT(m_pRegion);
		WAVELINK waveLink = m_pRegion->GetWaveLink();
		bEnableChannelCombo = (waveLink.fusOptions & F_WAVELINK_MULTICHANNEL) != 0;
	}

	m_ChannelCombo.EnableWindow(bEnableChannelCombo);
}

void CRegionPropPg::EnableFineTune(bool bNewState)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if (m_pmsTune)
		m_pmsTune->EnableControl(this, bNewState);

	CWnd* pCtrl = GetDlgItem(IDC_OWS_STATIC_FINE_TUNE);
	if(pCtrl)
	{
		pCtrl->EnableWindow(bNewState);
		pCtrl = NULL;
	}

	pCtrl = GetDlgItem(IDC_OWS_STATIC_S_TONES);
	if(pCtrl)
	{
		pCtrl->EnableWindow(bNewState);
		pCtrl = NULL;
	}

    CButton * pBtn = (CButton *)GetDlgItem(IDC_OWS_ACTIVE_FINE_TUNE);
    if (pBtn)
    {
        pBtn->SetCheck(m_fActivateFineTune);
    }

}

void CRegionPropPg::EnableAttenuation(bool bNewState)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if (m_pmsAttenuation)
		m_pmsAttenuation->EnableControl(this, bNewState);

	CWnd* pCtrl = GetDlgItem(IDC_OWS_STATIC_ATTENUATION);
	if(pCtrl)
	{
		pCtrl->EnableWindow(bNewState);
		pCtrl = NULL;
	}

	pCtrl = GetDlgItem(IDC_OWS_STATIC_DB);
	if(pCtrl)
	{
		pCtrl->EnableWindow(bNewState);
		pCtrl = NULL;
	}

    CButton * pBtn = (CButton *)GetDlgItem(IDC_OWS_ACTIVE_ATTENUATION);
    if (pBtn)
    {
        pBtn->SetCheck(m_fActivateAttenuation);
    }

}

void CRegionPropPg::EnableRootNote(bool bNewState)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	
	CWnd* pCtrl = GetDlgItem(IDC_OWS_STATIC_ROOT_NOTE);
	if(pCtrl)
	{
		pCtrl->EnableWindow(bNewState);
		pCtrl = NULL;
	}

	pCtrl = GetDlgItem(IDC_OWS_ROOT_NODE_SPIN);
	if(pCtrl)
	{
		pCtrl->EnableWindow(bNewState);
		pCtrl = NULL;
	}

	pCtrl = GetDlgItem(IDC_OWS_DUNITYNOTE);
	if(pCtrl)
	{
		pCtrl->EnableWindow(bNewState);
		pCtrl = NULL;
	}

    CButton * pBtn = (CButton *)GetDlgItem(IDC_OWS_ACTIVE_ROOT_NOTE);
    if (pBtn)
    {
        pBtn->SetCheck(m_fActivateRootNote);
    }

}

int CRegionPropPg::OnCreate(LPCREATESTRUCT lpCreateStruct) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	// Attach the window to the property page structure.
	// This has been done once already in the main application
	// since the main application owns the property sheet.
	// It needs to be done here so that the window handle can
	// be found in the DLLs handle map.
	if(!FromHandlePermanent(m_hWnd))
	{
		HWND hWnd = m_hWnd;
		m_hWnd = NULL;
		Attach( hWnd );

		m_fNeedToDetach = TRUE;
	}

	if (CPropertyPage::OnCreate(lpCreateStruct) == -1)
		return -1;

	return 0;
}

void CRegionPropPg::OnDestroy() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	// Detach the window from the property page structure.
	// This will be done again by the main application since
	// it owns the property sheet.  It needs o be done here
	// so that the window handle can be removed from the
	// DLLs handle map.
	if( m_fNeedToDetach && m_hWnd != NULL )
	{
		HWND hWnd = m_hWnd;
		Detach();
		m_hWnd = hWnd;
	}

	CPropertyPage::OnDestroy();
}

void CRegionPropPg::OnContextMenu(CWnd* pWnd, CPoint point) 
{
	/*CMenu* pPopupMenu =  m_pContextMenu->GetSubMenu(0);
	
	pPopupMenu->TrackPopupMenu(TPM_LEFTALIGN | TPM_RIGHTBUTTON | TPM_LEFTBUTTON,
							   point.x,
							   point.y,
							   this,
							   NULL);*/
}

void CRegionPropPg::OnKillfocusOwsDunitynote() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	USHORT usNewNote = GetNoteInEditBox();
	UpdateRootNote(usNewNote);
}

// ====================================================================
// Changes the instrument dialog wave root note and the region property
// root note to be the root note set for the wave.
// ====================================================================
void CRegionPropPg::RevertToWaveRootNote()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
    // Get the wave's root note.
    ASSERT(m_pRegion);
    ASSERT(m_pRegion->m_pWave); // there should always be one.

    if (m_pRegion->m_pWave) 
    {
		WSMPL waveWSMPL = m_pRegion->m_pWave->GetWSMPL();

        m_pRegion->m_rWSMP.usUnityNote = waveWSMPL.usUnityNote;
        
        // change the unitynote stored in CRegionPropPg.
        UpdateRootNoteText(m_pRegion->m_rWSMP.usUnityNote);
		//m_RootNoteSpin.SetPos(m_pRegion->m_rWSMP.usUnityNote);
 
        // Calling SetPos results in an update message sent to the root_note edit box
        // and it will dirty collection and updateSynth also. This updates the 
        // property page also.
        if (m_pRegion->m_pInstrumentFVEditor)
        {
            if (m_pRegion->m_pInstrumentFVEditor->m_RootNoteSpin.GetSafeHwnd())
            {
                m_pRegion->m_pInstrumentFVEditor->m_RootNoteSpin.SetPos(m_pRegion->m_rWSMP.usUnityNote);
				char pszNote[20];
				notetostring(m_pRegion->m_rWSMP.usUnityNote, pszNote);
				m_pRegion->m_pInstrumentFVEditor->m_RootNoteEdit.SetWindowText(pszNote);
				m_pRegion->m_pInstrumentFVEditor->m_RegionKeyBoard.SetRootNote(m_pRegion->m_rWSMP.usUnityNote);
            }
        }
        else    // instr. editor isnot open. So update the root note yourself in prop. pg
        {
            if (m_RootNoteSpin.GetSafeHwnd())
            {
                m_RootNoteSpin.SetPos(m_pRegion->m_rWSMP.usUnityNote);
            }
        }

    }
}

// ====================================================================
// Changes the instrument dialog wave Attenuation and the region property
// attenuation to be the value set for the wave.
// ====================================================================
void CRegionPropPg::RevertToWaveAttenuation()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
    // Get the wave's attenuation.
    ASSERT(m_pRegion);
    ASSERT(m_pRegion->m_pWave); // there should always be one.

    if (m_pRegion->m_pWave) 
    {
		WSMPL waveWSMPL = m_pRegion->m_pWave->GetWSMPL();

        m_pRegion->m_rWSMP.lAttenuation = waveWSMPL.lAttenuation;
        
        // change the value stored in CRegionPropPg.
        m_lAttenuation = m_pRegion->m_rWSMP.lAttenuation;

        // Set the slider position. This will cause the slider pos to be updated and
        // the corresponding text to be displayed.
        m_pmsAttenuation->SetValue(this, m_lAttenuation);        

		// Set flag so we know to save file 
		m_pRegion->m_pInstrument->m_pCollection->SetDirtyFlag();
		m_pRegion->m_pInstrument->UpdateInstrument();
		m_pRegion->m_pInstrument->RefreshRegion();
    }
}

// ====================================================================
// Changes the instrument dialog wave finetune and the region property
// finetune to be the value set for the wave.
// ====================================================================
void CRegionPropPg::RevertToWaveFineTune()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
    // Get the wave's finetune.
    ASSERT(m_pRegion);
    ASSERT(m_pRegion->m_pWave); // there should always be one.

    if (m_pRegion->m_pWave) 
    {
		WSMPL waveWSMPL = m_pRegion->m_pWave->GetWSMPL();

        m_pRegion->m_rWSMP.sFineTune = waveWSMPL.sFineTune;
        
        // change the value stored in CRegionPropPg.
        m_lFineTune = m_pRegion->m_rWSMP.sFineTune << 16;

        // Set the slider position. This will cause the slider pos to be updated and
        // the corresponding text to be displayed.
        m_pmsTune->SetValue(this, m_lFineTune);

		// Set flag so we know to save file 
		m_pRegion->m_pInstrument->m_pCollection->SetDirtyFlag();
		m_pRegion->m_pInstrument->UpdateInstrument();
		m_pRegion->m_pInstrument->RefreshRegion();
    }
}

void CRegionPropPg::UpdateRootNote(USHORT usNewNote)
{
	if(m_pRegion == NULL)
		return;
	if(!m_pRegion->m_pWave)
		return;

	// update the wave if the note's different
	if (usNewNote != m_pRegion->m_rWSMP.usUnityNote) 
	{
		// change the value in the instrument editor also.
		if (m_pRegion->m_pInstrumentFVEditor)
		{
			if (m_pRegion->m_pWave)
			{
				m_pRegion->m_pInstrumentFVEditor->UpdateRootNote(usNewNote);
			}
		}
	}
}

void CRegionPropPg::UpdateRootNoteText(int note)
{
	ASSERT(note >= 0 && note <= 127);
	char pszNote[20];
	notetostring((DWORD)note, pszNote);
	m_RootNoteEdit.SetWindowText(pszNote);
}

// get the note typed by the user in the edit box, if valid. if not valid,
// returns the current unity note for the wave.
USHORT CRegionPropPg::GetNoteInEditBox()
{
	ASSERT(m_pRegion->m_pWave);

	USHORT usNote;
	CString strNote;
	m_RootNoteEdit.GetWindowText(strNote);
	LPSTR lpsBuf = strNote.GetBuffer(3);
	if (isValidNoteString(lpsBuf)) {
		usNote = stringtonote(lpsBuf);
	}
	else {
		usNote = m_pRegion->m_rWSMP.usUnityNote;
	}
	
	// reset the note in the edit box
	char szNote[20];
	notetostring(usNote, szNote);
	m_RootNoteEdit.SetWindowText(szNote);
	
	return usNote;
}

void CRegionPropPg::SetRootNote(USHORT usNewNote)
{
	UpdateRootNoteText(usNewNote);
	m_RootNoteSpin.SetPos(usNewNote);
}


void CRegionPropPg::OnDeltaposOwsRootNodeSpin(NMHDR* pNMHDR, LRESULT* pResult) 
{
	NM_UPDOWN* pNMUpDown = (NM_UPDOWN*)pNMHDR;
	
	USHORT usNote = GetNoteInEditBox();

	int nNewPos = usNote + pNMUpDown->iDelta;
	
	if (nNewPos < 0) 
		nNewPos = 0; 
	else if (nNewPos > 127) 
		nNewPos = 127;

	*pResult = 1;

	UpdateRootNoteText(nNewPos);
	OnKillfocusOwsDunitynote(); 
}

void CRegionPropPg::InitPhaseGroupControls()
{
	ASSERT(m_pRegion);
	if(m_pRegion == NULL)
	{
		return;
	}

	m_PhaseGroupSpin.SetRange(1, 255);
	InitChannelCombo();

	WAVELINK waveLink = m_pRegion->GetWaveLink();
	
	bool bPhaseGroupCheck = (waveLink.usPhaseGroup != 0);
	m_PhaseGroupCheck.SetCheck(bPhaseGroupCheck);
	
	bool bMasterCheck = (waveLink.fusOptions & F_WAVELINK_PHASE_MASTER) != 0;
	m_MasterCheck.SetCheck(bMasterCheck);

	bool bMultiChannelCheck = (waveLink.fusOptions & F_WAVELINK_MULTICHANNEL) != 0;
	m_MultichannelCheck.SetCheck(bMultiChannelCheck);

	m_PhaseGroupSpin.SetPos(waveLink.usPhaseGroup);
	USHORT usBitSet = 0;
	for(USHORT nIndex = 0; nIndex < (sizeof(waveLink.ulChannel) * 8); nIndex++)
	{
		ULONG ulTest = 1;
		if(waveLink.ulChannel & (1 << nIndex))
		{
			usBitSet = nIndex;
			break;
		}
	}

	m_ChannelCombo.SetCurSel(usBitSet);
}

void CRegionPropPg::InitChannelCombo()
{
	if (m_pRegion == NULL)
		{
		ASSERT(FALSE);
		return;
		}

	CString sChannel;
	m_ChannelCombo.ResetContent();
	if ((m_pRegion->m_pWave != NULL) && (m_pRegion->m_pWave->GetChannelCount() > 1))
		{
		sChannel.LoadString(IDS_REGION_CHANNEL_STEREO);
		m_ChannelCombo.AddString(sChannel);
		}
	else
		{
		for(int nIndex = 0; nIndex < MAX_WAVELINK_CHANNELS; nIndex++)
		{
			sChannel.LoadString(m_arrChannelPositions[nIndex]);
			m_ChannelCombo.AddString(sChannel);
		}
	}
}

void CRegionPropPg::OnPhaseGroupCheck() 
{
	ASSERT(m_pRegion);
	if(m_pRegion == NULL)
	{
		return;
	}

	int nCheck = m_PhaseGroupCheck.GetCheck();

	// Phase Group is 0 if the region doesn't belong to any Phase Group
	int nPhaseGroup = 0;
	if(nCheck)
	{
		nPhaseGroup = m_PhaseGroupSpin.GetPos();
	}

	WAVELINK waveLink = m_pRegion->GetWaveLink();

	// No change?
	if(nPhaseGroup == waveLink.usPhaseGroup)
	{
		return;
	}

	waveLink.usPhaseGroup = USHORT(nPhaseGroup);

	SaveUndoState(IDS_UNDO_PHASE_GROUP);
	SetRegionWaveLink(m_pRegion, waveLink);
	EnablePhaseGroupEdit(nCheck != 0);
}

void CRegionPropPg::OnKillfocusPhaseGroupEdit() 
{
	CString sPhaseGroup;
	m_PhaseGroupEdit.GetWindowText(sPhaseGroup);
	
	int nPhaseGroup = atoi((LPCSTR)sPhaseGroup);
	if(nPhaseGroup < 1 || nPhaseGroup > 255)
	{
		nPhaseGroup = m_PhaseGroupSpin.GetPos();
		sPhaseGroup.Format("%d", nPhaseGroup);
		m_PhaseGroupEdit.SetWindowText(sPhaseGroup);
		return;
	}

	m_PhaseGroupSpin.SetPos(nPhaseGroup);
	WAVELINK waveLink = m_pRegion->GetWaveLink();

	// No change?
	if(waveLink.usPhaseGroup == nPhaseGroup)
	{
		return;
	}

	waveLink.usPhaseGroup = USHORT(nPhaseGroup);
	
	SaveUndoState(IDS_UNDO_PHASE_GROUP_ID);
	SetRegionWaveLink(m_pRegion, waveLink);
}

void CRegionPropPg::OnDeltaposPhaseGroupSpin(NMHDR* pNMHDR, LRESULT* pResult) 
{
	NM_UPDOWN* pNMUpDown = (NM_UPDOWN*)pNMHDR;
	
	OnKillfocusPhaseGroupEdit();
	
	*pResult = 0;
}

void CRegionPropPg::OnMasterCheck() 
{
	ASSERT(m_pRegion);
	if(m_pRegion == NULL)
	{
		return;
	}

	int nMasterCheck = m_MasterCheck.GetCheck();
	
	WAVELINK thisWaveLink = m_pRegion->GetWaveLink();
	USHORT usThisPhaseGroup = thisWaveLink.usPhaseGroup;

	// There can be only one Master in the same phase group
	// So look in all the regions that belong to the same phase group in an instrument
	// and warn and change the master flag
	if(nMasterCheck)
	{
		CInstrument* pInstrument = m_pRegion->GetInstrument();
		ASSERT(pInstrument);
		if(pInstrument == NULL)
		{
			return;
		}

		CInstrumentRegions* pInstrumentRegions = pInstrument->GetRegions();
		ASSERT(pInstrumentRegions);
		if(pInstrumentRegions == NULL)
		{
			return;
		}

		CRegion* pRegion  = pInstrumentRegions->GetHead();
		while(pRegion)
		{
			WAVELINK waveLink = pRegion->GetWaveLink();
			if(waveLink.usPhaseGroup ==  usThisPhaseGroup && waveLink.fusOptions & F_WAVELINK_PHASE_MASTER)
			{
				if(pRegion == m_pRegion)
				{
					continue;
				}
				else
				{
					int nChoice = AfxMessageBox(IDS_MULTIPLE_MASTERS_IN_PHASE_GROUP, MB_OKCANCEL);
					if(nChoice == IDOK)
					{
						static bool bSavedUndoState = false;
						if(!bSavedUndoState)
						{
							SaveUndoState(IDS_UNDO_PHASE_GROUP_MASTER);
						}

						waveLink.fusOptions &= ~F_WAVELINK_PHASE_MASTER;
						SetRegionWaveLink(pRegion, waveLink);
					}
					else
					{
						thisWaveLink.fusOptions &= ~F_WAVELINK_PHASE_MASTER;
						m_MasterCheck.SetCheck(0);
						return;
					}
				}
			}

			pRegion = pRegion->GetNext();
		}

		thisWaveLink.fusOptions |= F_WAVELINK_PHASE_MASTER;
	}
	else
	{
		SaveUndoState(IDS_UNDO_PHASE_GROUP_MASTER);
		thisWaveLink.fusOptions &= ~F_WAVELINK_PHASE_MASTER;
	}

	
	SetRegionWaveLink(m_pRegion, thisWaveLink);
}



void CRegionPropPg::OnSelchangeChannelCombo() 
{
	ASSERT(m_pRegion);
	if(m_pRegion == NULL)
	{
		return;
	}

	WAVELINK waveLink = m_pRegion->GetWaveLink();
	int nCurSel = m_ChannelCombo.GetCurSel();
	ULONG ulChannel = 1 << nCurSel;

	if(waveLink.ulChannel == ulChannel)
	{
		return;
	}

	waveLink.ulChannel = ulChannel;

	SaveUndoState(IDS_UNDO_CHANNEL);
	SetRegionWaveLink(m_pRegion, waveLink);
}

void CRegionPropPg::OnMultichannelCheck() 
{
	ASSERT(m_pRegion);
	if(m_pRegion == NULL)
	{
		return;
	}

	int nCheck = m_MultichannelCheck.GetCheck();

	WAVELINK waveLink = m_pRegion->GetWaveLink();
	if(nCheck == 0)
	{
		// Use it as a mono Wave
		waveLink.fusOptions &= ~F_WAVELINK_MULTICHANNEL;
		waveLink.ulChannel = 1; 
	}
	else
	{
		waveLink.fusOptions |= F_WAVELINK_MULTICHANNEL;
	}

	SaveUndoState(IDS_UNDO_MULTICHANNEL);
	SetRegionWaveLink(m_pRegion, waveLink);
	EnableChannelCombo(nCheck != 0);
}

void CRegionPropPg::SetRegionWaveLink(CRegion* pRegion, WAVELINK waveLink)
{
	ASSERT(pRegion);
	if(pRegion == NULL)
	{
		return;
	}

	CInstrument* pInstrument = pRegion->GetInstrument();
	ASSERT(pInstrument);
	if(pInstrument == NULL)
	{
		return;
	}

	pRegion->SetWaveLink(waveLink);
	pInstrument->UpdateInstrument();
}

void CRegionPropPg::SaveUndoState(UINT uUndoID)
{
	ASSERT(m_pRegion);
	if(m_pRegion == NULL)
	{
		return;
	}

	CInstrument* pInstrument = m_pRegion->GetInstrument();
	ASSERT(pInstrument);
	if(pInstrument)
	{
		pInstrument->SaveStateForUndo(uUndoID);
	}
}

BOOL CRegionPropPg::OnCommand(WPARAM wParam, LPARAM lParam) 
{
	LRESULT lResult;
	if (CSliderCollection::OnCommand(wParam, lParam, &lResult))
		return lResult;

	return CPropertyPage::OnCommand(wParam, lParam);
}

BOOL CRegionPropPg::OnNotify(WPARAM wParam, LPARAM lParam, LRESULT* pResult) 
{
	LRESULT lResult;
	if (CSliderCollection::OnNotify(wParam, lParam, &lResult))
		return lResult;
	
	return CPropertyPage::OnNotify(wParam, lParam, pResult);
}

BOOL CRegionPropPg::OnInitDialog() 
{
	CPropertyPage::OnInitDialog();

	// create and hook up the sliders
	CSliderCollection::Free(); // refresh sliders after a page switch
	
	m_pmsTune = Insert(
		IDC_OWS_TUNE,
		IDC_OWS_DTUNE,
		IDC_OWS_DTUNE_SPIN,
		MYSLIDER_PITCHCENTS, 
		0,
		IDS_UNDO_ATTENUATION,
		&m_lFineTune);
	    
	m_pmsAttenuation = Insert(
		IDC_OWS_ATTENUATION,
		IDC_OWS_DATTENUATION,
		IDC_OWS_DATTENUATION_SPIN,
		MYSLIDER_VOLUME, 
		0,
		IDS_UNDO_FINETUNE,
		&m_lAttenuation);
	
	return TRUE;  // return TRUE unless you set the focus to a control
}

bool CRegionPropPg::OnSliderUpdate(MySlider *pms, DWORD dwmscupdf)
{
	switch (dwmscupdf)
		{
		case dwmscupdfStart:
			return true; // save state is done on End of updates

		case dwmscupdfEnd:
			if (pms == m_pmsAttenuation)
				UpdateOwsDattenuation();
			else
				{
				ASSERT(pms == m_pmsTune); // slider not handled
				UpdateOwsDtune();
				}
			return true;

		default:
			ASSERT(FALSE);
			return false;
		}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\DLSDesigner\RegionPropPg.h ===
#if !defined(AFX_REGIONPROPPG_H__8C0AA7C6_E6FC_11D0_876A_00AA00C08146__INCLUDED_)
#define AFX_REGIONPROPPG_H__8C0AA7C6_E6FC_11D0_876A_00AA00C08146__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

//
// RegionPropPg.h : header file
//

#include "resource.h"
#include "myslider.h"
#include "region.h"
#include "instrumentfveditor.h"

#define	MAX_WAVELINK_CHANNELS	18

class CRegion;

/////////////////////////////////////////////////////////////////////////////
// CRegionPropPg dialog

class CRegionPropPg : public CPropertyPage, CSliderCollection
{
    friend class CInstrumentFVEditor;

	DECLARE_DYNCREATE(CRegionPropPg)

// Construction
public:
	CRegionPropPg();
	~CRegionPropPg();

	void SetObject(CRegion* pRegion) {m_pRegion = pRegion;}
	
	void EnableControls(BOOL fEnable);
	void EnablePhaseGroupControls(bool bNewState);
	void EnablePhaseGroupEdit(bool bNewState);
	void EnableChannelCombo(bool bNewState);
	void EnableFineTune(bool bNewState);
	void EnableAttenuation(bool bNewState);
	void EnableRootNote(bool bNewState);
    void RevertToWaveRootNote(void);
    void RevertToWaveAttenuation(void);
    void RevertToWaveFineTune(void);
	void UpdateRootNote(USHORT usNewNote);
	void UpdateRootNoteText(int note);
	USHORT GetNoteInEditBox();
	void SetRootNote(USHORT usNewNote);


// Dialog Data
	//{{AFX_DATA(CRegionPropPg)
	enum { IDD = IDD_REGION_PROP_PAGE };
	CButton	m_MultichannelCheck;
	CComboBox	m_ChannelCombo;
	CSpinButtonCtrl	m_PhaseGroupSpin;
	CEdit	m_PhaseGroupEdit;
	CButton	m_PhaseGroupCheck;
	CButton	m_MasterCheck;
	CEdit	m_RootNoteEdit;
	CSpinButtonCtrl	m_RootNoteSpin;
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CRegionPropPg)
	public:
	virtual BOOL OnSetActive();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	virtual BOOL OnCommand(WPARAM wParam, LPARAM lParam);
	virtual BOOL OnNotify(WPARAM wParam, LPARAM lParam, LRESULT* pResult);
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CRegionPropPg)
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	afx_msg void OnDestroy();
	afx_msg void OnOwsActiveAttenuation();
	afx_msg void OnOwsActiveFineTune();
	afx_msg void OnOwsActiveRootNote();
	afx_msg void OnHScroll(UINT nSBCode, UINT nPos, CScrollBar* pScrollBar);
	afx_msg void OnContextMenu(CWnd* pWnd, CPoint point);
	afx_msg void OnKillfocusOwsDunitynote();
	afx_msg void OnDeltaposOwsRootNodeSpin(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnPhaseGroupCheck();
	afx_msg void OnKillfocusPhaseGroupEdit();
	afx_msg void OnDeltaposPhaseGroupSpin(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnMasterCheck();
	afx_msg void OnSelchangeChannelCombo();
	afx_msg void OnMultichannelCheck();
	virtual BOOL OnInitDialog();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

private:

	void	InitPhaseGroupControls();
	void	InitChannelCombo();
	void	SetRegionWaveLink(CRegion* pRegion, WAVELINK waveLink);
	void	SaveUndoState(UINT uUndoID);
	void	UpdateOwsDattenuation();
	void	UpdateOwsDtune();

	// CSliderCollection overrides
	virtual bool OnSliderUpdate(MySlider *pms, DWORD dwmscupdf);

private:
    long		m_lFineTune;
    long		m_lAttenuation;

	MySlider*	m_pmsTune;
    MySlider*	m_pmsAttenuation;

	CRegion*	m_pRegion;

	bool		m_fInOnInitialUpdate;	
	BOOL		m_fActivateFineTune;
	BOOL		m_fActivateAttenuation;
	BOOL		m_fActivateRootNote;
	CMenu*		m_pContextMenu;
	BOOL		m_fNeedToDetach;

	static UINT	m_arrChannelPositions[MAX_WAVELINK_CHANNELS];
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_REGIONPROPPG_H__8C0AA7C6_E6FC_11D0_876A_00AA00C08146__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\DLSDesigner\ResampleDlg.cpp ===
// ResampleDlg.cpp : implementation file
//

#include "stdafx.h"
#include "dlsdesigner.h"
#include "ResampleDlg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CResampleDlg dialog


CResampleDlg::CResampleDlg(DWORD dwSampleRate, CWnd* pParent /*=NULL*/)
	: CDialog(CResampleDlg::IDD, pParent)
{
	m_dwCurrentSampleRate = dwSampleRate;
	m_dwNewSampleRate = dwSampleRate;
	//{{AFX_DATA_INIT(CResampleDlg)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT
}


void CResampleDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CResampleDlg)
	DDX_Control(pDX, IDC_EDIT_NEW_SAMPLERATE, m_editNewSamplerate);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CResampleDlg, CDialog)
	//{{AFX_MSG_MAP(CResampleDlg)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CResampleDlg message handlers

BOOL CResampleDlg::OnInitDialog() 
{
	CDialog::OnInitDialog();

	SetDlgItemInt( IDC_EDIT_CURRENT_SAMPLERATE, m_dwCurrentSampleRate, FALSE );

	m_editNewSamplerate.LimitText( 5 );
	SetDlgItemInt( IDC_EDIT_NEW_SAMPLERATE, m_dwCurrentSampleRate, FALSE );

	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

void CResampleDlg::OnOK() 
{
	BOOL fSucceeded = FALSE;
	DWORD dwNewSampleRate = GetDlgItemInt( IDC_EDIT_NEW_SAMPLERATE, &fSucceeded, FALSE );
	if( !fSucceeded || dwNewSampleRate < 3072 || dwNewSampleRate > 81920 )
	{
		AfxMessageBox(IDS_INVALID_NEW_SAMPLERATE, MB_ICONEXCLAMATION);
		return;
	}

	m_dwNewSampleRate = dwNewSampleRate;

	CDialog::OnOK();
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\DLSDesigner\StdAfx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\DLSDesigner\RegionPropPgMgr.cpp ===
//////////////////////////////////////////////////////////////////////
//
// RegionPropPgMgr.cpp : implementation file
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "RegionPropPgMgr.h"
#include "RegionPropPg.h"
#include "RegionExtraPropPg.h"
#include "Collection.h"
#include "Instrument.h"
#include "Region.h"

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#define new DEBUG_NEW
#endif


// Last selected page
DWORD CRegionPropPgMgr::dwLastSelPage = 0;

//////////////////////////////////////////////////////////////////////
// CRegionPropPgMgr Construction/Destruction
//////////////////////////////////////////////////////////////////////

CRegionPropPgMgr::CRegionPropPgMgr() : m_pRegionPage(NULL), m_pRegionExtraPage(NULL)
{
}

CRegionPropPgMgr::~CRegionPropPgMgr()
{
	if(m_pRegionPage)
		delete m_pRegionPage;

	if(m_pRegionExtraPage)
		delete m_pRegionExtraPage;
}

/////////////////////////////////////////////////////////////////////////////
// CRegionPropPgMgr IJazzPropPageManager implementation

/////////////////////////////////////////////////////////////////////////////
// CRegionPropPgMgr IJazzPropPageManager::GetPropertySheetTitle

HRESULT CRegionPropPgMgr::GetPropertySheetTitle(BSTR* pbstrTitle, BOOL* pfAddPropertiesText)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT(pbstrTitle);
	ASSERT(pfAddPropertiesText);

	*pfAddPropertiesText = TRUE;

	CRegion* pRegion;

	if(m_pIPropPageObject && (SUCCEEDED (m_pIPropPageObject->GetData((void **)&pRegion))))
	{
		BSTR bstrCollectionName;
		pRegion->m_pInstrument->m_pCollection->GetNodeName(&bstrCollectionName);
		CString sCollectionName = bstrCollectionName;
		SysFreeString(bstrCollectionName);

		CString sInstrumentName;
		pRegion->m_pInstrument->GetName(sInstrumentName);
		if(sInstrumentName.IsEmpty())
			sInstrumentName.LoadString(IDS_INSTRUMENT_TEXT);
		
		BSTR bstrRegionName;
		pRegion->GetNodeName(&bstrRegionName);
		CString sRegionName = bstrRegionName;
		SysFreeString(bstrRegionName);

		CString sTitle;
		sTitle.Format(IDS_REGION_PROPPAGE_TITLE, sCollectionName, sInstrumentName, sRegionName);
		*pbstrTitle = sTitle.AllocSysString();
	}
	else
	{
		CString strTitle;
		strTitle.LoadString(IDS_REGION_TEXT);
		*pbstrTitle = strTitle.AllocSysString();
	}

	return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
// CRegionPropPgMgr IJazzPropPageManager::GetPropertySheetPages

HRESULT CRegionPropPgMgr::GetPropertySheetPages(IDMUSProdPropSheet* pIPropSheet, LONG* hPropSheetPage[], short* pnNbrPages)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( (hPropSheetPage == NULL)
	||  (pnNbrPages == NULL) )
	{
		return E_POINTER;
	}

	if( pIPropSheet == NULL )
	{
		return E_INVALIDARG;
	}

	m_pIPropSheet = pIPropSheet;
	m_pIPropSheet->AddRef();

	hPropSheetPage[0] = NULL;
	*pnNbrPages = 0;

	// Add General tab
	HPROPSHEETPAGE hPage;
	short nNbrPages = 0;

	if(m_pRegionPage == NULL)
    	m_pRegionPage = new CRegionPropPg();

	if(m_pRegionPage)
	{
		hPage = ::CreatePropertySheetPage((LPPROPSHEETPAGE)&m_pRegionPage->m_psp);
		if(hPage)
		{
			hPropSheetPage[nNbrPages] = (LONG *)hPage;
			nNbrPages++;
		}			
	}

	if(m_pRegionExtraPage == NULL)
    	m_pRegionExtraPage = new CRegionExtraPropPg();
	if(m_pRegionExtraPage)
	{
		hPage = ::CreatePropertySheetPage((LPPROPSHEETPAGE)&m_pRegionExtraPage->m_psp);
		if(hPage)
		{
			hPropSheetPage[nNbrPages] = (LONG *)hPage;
			nNbrPages++;
		}			
	}

	// Set number of pages
	*pnNbrPages = nNbrPages; 

	return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
// CRegionPropPgMgr IJazzPropPageManager::RefreshData

HRESULT CRegionPropPgMgr::RefreshData(void)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	// Don't do anything if there are no pages yet...
	if(m_pRegionPage == NULL || m_pRegionExtraPage == NULL)
		return E_FAIL;
	
	CRegion* pRegion = NULL;
	
	if(m_pIPropPageObject == NULL)
	{
		pRegion = NULL;
	}
	else if(FAILED(m_pIPropPageObject->GetData((void **)&pRegion)))
	{
		return E_FAIL;
	}

	m_pRegionPage->SetObject(pRegion);
	m_pRegionExtraPage->SetObject(pRegion);
	m_pRegionExtraPage->SetPropMgr(this);
	
	if(m_pIPropSheet)
		m_pIPropSheet->RefreshTitle();
	return S_OK;
}

void CRegionPropPgMgr::ShowPropSheet()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	SetObject(m_pIPropPageObject);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\DLSDesigner\RegionPropPgMgr.h ===
//////////////////////////////////////////////////////////////////////
//
// RegionPropPgMgr.h
//
//////////////////////////////////////////////////////////////////////

#ifndef REGIONPROPPGMGR_H
#define REGIONPROPPGMGR_H

#include "DllBasePropPageManager.h"
//#include "instrumentfveditor.h"

class CRegionPropPg;
class CRegionExtraPropPg;
class CInstrumentFVEditor;

#define REGION_PROP_PAGE		0		
#define REGION_EXTRA_PROP_PAGE	1

//////////////////////////////////////////////////////////////////////
//  CRegionPropPgMgr

class CRegionPropPgMgr : public CDllBasePropPageManager 
{
    friend class CInstrumentFVEditor;
public:
	void ShowPropSheet();
	CRegionPropPgMgr();
	virtual ~CRegionPropPgMgr();

    // IJazzPropPageManager functions
    HRESULT STDMETHODCALLTYPE GetPropertySheetTitle( BSTR* pbstrTitle, BOOL* pfAddPropertiesText );
    HRESULT STDMETHODCALLTYPE GetPropertySheetPages( IDMUSProdPropSheet* pIPropSheet, LONG* hPropSheetPage[], short* pnNbrPages );

    HRESULT STDMETHODCALLTYPE RefreshData();

public:
	static DWORD dwLastSelPage;

	// Member variables
private:
	CRegionPropPg*			m_pRegionPage;
	CRegionExtraPropPg*		m_pRegionExtraPage;
};

#endif // #ifndef REGIONPROPPGMGR_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\DLSDesigner\ScriptEdit.cpp ===
// ScriptEdit.cpp : implementation file
//

#include "stdafx.h"
#include "dlsdesigner.h"
#include "ConditionEditor.h"
#include "ScriptEdit.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CScriptEdit

CScriptEdit::CScriptEdit()
{
}

CScriptEdit::~CScriptEdit()
{
}


BEGIN_MESSAGE_MAP(CScriptEdit, CEdit)
	//{{AFX_MSG_MAP(CScriptEdit)
	ON_WM_CONTEXTMENU()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CScriptEdit message handlers

void CScriptEdit::OnContextMenu(CWnd* pWnd, CPoint point) 
{
	ASSERT(m_pConditionEditor);
	if(m_pConditionEditor)
	{
		m_pConditionEditor->ShowPopupMenu(pWnd, point);
	}
	return;	
}

void CScriptEdit::SetEditor(CConditionEditor* pEditor)
{
	ASSERT(pEditor);
	if(pEditor == NULL) 
		return;

	m_pConditionEditor = pEditor;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\DLSDesigner\ResampleDlg.h ===
#if !defined(AFX_RESAMPLEDLG_H__7E1F5F2F_0BB7_4A93_93DC_8D591F4D658F__INCLUDED_)
#define AFX_RESAMPLEDLG_H__7E1F5F2F_0BB7_4A93_93DC_8D591F4D658F__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "resource.h"

// ResampleDlg.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CResampleDlg dialog

class CResampleDlg : public CDialog
{
// Construction
public:
	CResampleDlg(DWORD dwSampleRate, CWnd* pParent = NULL);   // standard constructor

// Dialog Data
	//{{AFX_DATA(CResampleDlg)
	enum { IDD = IDD_RESAMPLE };
	CEdit	m_editNewSamplerate;
	//}}AFX_DATA

	DWORD GetSampleRate() { return m_dwNewSampleRate; }


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CResampleDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CResampleDlg)
	virtual BOOL OnInitDialog();
	virtual void OnOK();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

private:
	DWORD	m_dwCurrentSampleRate;
	DWORD	m_dwNewSampleRate;
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_RESAMPLEDLG_H__7E1F5F2F_0BB7_4A93_93DC_8D591F4D658F__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\DLSDesigner\ScriptEdit.h ===
#if !defined(AFX_SCRIPTEDIT_H__5DBD135B_D610_449C_90E0_76C7932AEA1C__INCLUDED_)
#define AFX_SCRIPTEDIT_H__5DBD135B_D610_449C_90E0_76C7932AEA1C__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// ScriptEdit.h : header file
//

class CConditionEditor;

/////////////////////////////////////////////////////////////////////////////
// CScriptEdit window

class CScriptEdit : public CEdit
{
// Construction
public:
	CScriptEdit();

// Attributes
public:

// Operations
public:

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CScriptEdit)
	//}}AFX_VIRTUAL

// Implementation
public:
	virtual ~CScriptEdit();
	void SetEditor(CConditionEditor* pEditor);

private:
	CConditionEditor* m_pConditionEditor;

	// Generated message map functions
protected:
	//{{AFX_MSG(CScriptEdit)
	afx_msg void OnContextMenu(CWnd* pWnd, CPoint point);
	//}}AFX_MSG

	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_SCRIPTEDIT_H__5DBD135B_D610_449C_90E0_76C7932AEA1C__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\DLSDesigner\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by DLSDesigner.rc
//
#define IDB_COLLECTION                  1
#define IDI_ABOUTDLL                    1
#define IDD_ABOUTBOX_INSTRUMENT         2
#define IDB_INSTRUMENT                  2
#define IDS_INSTRUMENT                  3
#define IDD_ABOUTBOX_WAVE               3
#define IDB_WAVE                        3
#define IDC_COPY                        3
#define IDB_ARTICULATION                4
#define IDC_RESAMPLE                    4
#define IDS_PGMEND                      4
#define IDS_WAVE                        5
#define IDB_REGION                      5
#define IDC_16TO8                       5
#define IDC_CONDITION_CONFIG_COMBO      102
#define IDC_CONDITION_CONFIG_TOOLBAR    103
#define IDC_CONDITION_CONFIG_EDIT_BUTTON 104
#define IDD_COLLECTION_EXTRA_PROP_PAGE  105
#define IDC_CONDITION_CONFIG_ADD_BUTTON 105
#define IDC_CONDITION_CONFIG_DELETE_BUTTON 106
#define IDC_LFO_FREQUENCY_SPIN          107
#define IDC_LFO_VOLUME_SPIN             108
#define IDC_LFO_DELAY_SPIN              109
#define IDC_LFO_PITCH_SPIN              110
#define IDC_LFO_MW2VOLUME_SPIN          111
#define IDC_LFO_MW2PITCH_SPIN           112
#define FO_CHANPRESSTOGAIN_SPIN         113
#define IDC_LFO_CHANPRESSTOPITCH_SPIN   114
#define IDC_LFO_CHANPRESSTOFC_SPIN      115
#define IDC_LFO_CHANPRESSTOGAIN_SPIN    116
#define IDC_LFO2_FREQUENCY_SPIN         117
#define IDC_LFO2_DELAY_SPIN             118
#define IDC_LFO2_PITCH_SPIN             119
#define IDC_LFO2_CHANPRESSTOPITCH_SPIN  120
#define IDC_LFO2_MW2PITCH_SPIN          121
#define IDC_FILTER_DINITIALQ_SPIN       122
#define IDC_FILTER_DLFOTOFC_SPIN        123
#define IDC_FILTER_DCC1TOFC_SPIN        124
#define IDC_FILTER_DENV2TOFC_SPIN       125
#define IDC_FILTER_DVELTOFC_SPIN        126
#define IDC_FILTER_DKEYNUMTOFC_SPIN     127
#define IDC_PEG_DRANGE_SPIN             128
#define IDC_DB_ATTENUATION_SPIN         129
#define IDC_SEMI_TONES_SPIN             130
#define IDC_OWS_DATTENUATION_SPIN       131
#define IDC_OWS_DTUNE_SPIN              132
#define IDC_DECOMPRESSEDDATASTART_SPIN  133
#define IDD_WAVE_PROP_PAGE              134
#define IDD_COLLECTION_PROP_PAGE        138
#define IDD_INSTRUMENT                  139
#define IDI_FOLDER                      201
#define IDI_FOLDER_SEL                  202
#define IDC_ARTICULATION_TAB            202
#define IDS_DLS_FOLDER_NAME             207
#define IDS_DLS_COMPONENT_NAME          208
#define IDR_DLS_DOCTYPE                 209
#define IDC_OWS_ACTIVE_ATTENUATION      209
#define IDI_COLLECTION                  209
#define IDR_WAVE_DOCTYPE                210
#define IDI_WAVE                        210
#define IDC_OWS_ATTENUATION             210
#define IDS_INSTRUMENT_FOLDER_NAME      211
#define IDI_COLLECTION_SEL              211
#define IDC_OWS_DATTENUATION            211
#define IDS_WAVE_FOLDER_NAME            212
#define IDI_INSTRUMENT                  212
#define IDC_OWS_DTUNE                   212
#define IDS_REGION_FOLDER_NAME          213
#define IDC_OWS_DUNITYNOTE              213
#define IDI_INSTRUMENT_SEL              214
#define IDS_FILE_OPEN_ANY_WAVE          214
#define IDI_ARTICULATION_SEL            215
#define IDC_OWS_TUNE                    215
#define IDI_REGION                      216
#define IDC_OWS_LOOPSTART               217
#define IDI_REGION_SEL                  218
#define IDC_OWS_LOOPLENGTH              218
#define IDI_ARTICULATION                219
#define IDC_OWS_ALLOW_TRUNCATE          219
#define IDI_WAVE_SEL                    220
#define IDC_OWS_ALLOW_COMPRESS          220
#define IDS_ERR_MISSING_DLS             221
#define IDM_INSTRUMENT_NODE_RMENU       221
#define IDC_OWS_ACTIVE_FINE_TUNE        221
#define IDS_ERR_MISSING_CONDUCTOR       222
#define IDM_REGION_NODE_RMENU           222
#define IDC_OWS_ACTIVE_ROOT_NOTE        222
#define IDM_WAVE_NODE_RMENU             223
#define IDM_ARTICULATION_NODE_RMENU     224
#define IDM_COLLECTIONS_NODE_RMENU      225
#define IDC_OWS_OVERRIDE                225
#define IDS_ERR_MEMORY                  227
#define IDC_OWS_ONE_SHOT                227
#define IDS_ERR_ADD_DOCTYPE             228
#define IDC_OWS_LOOP                    228
#define IDS_ERR_ADD_IMAGELIST           229
#define IDS_HELP_FILE_EXT               230
#define IDS_ERR_COMPRESSION_FAILED      231
#define IDC_OWS_ROOT_NODE_SPIN          232
#define IDS_ERR_CLIPBOARD_ON_COMPRESSED_WAVE 232
#define IDD_LFO_PAGE                    233
#define IDS_WAVE_COPY_CONFIRMATION      233
#define IDM_COLLECTION_NODE_RMENU       234
#define IDD_INSTRUMENT_PROP_PAGE        234
#define IDC_REGION_RANGE_SPIN           234
#define IDS_NO_WAVE_COPY_WARNING        234
#define IDM_INSTRUMENTS_NODE_RMENU      235
#define IDD_REGION_PROP_PAGE            235
#define IDC_REGION_THRU_SPIN            235
#define IDS_NO_WAVES_WARNING            235
#define IDM_WAVES_NODE_RMENU            236
#define IDC_REGION_UIA                  236
#define IDD_REGION_EXTRA_PROP_PAGE      236
#define IDS_INVALID_LOOPSTART           236
#define IDM_REGIONS_NODE_RMENU          237
#define IDC_REGION_ROOT_NOTE            237
#define IDS_INVALID_INSERT_INSTRUMENT   237
#define IDC_REGION_ROOT_NOTE_SPIN       238
#define IDS_LOOP_VALUES_EXCEED_WAVELENGTH 238
#define IDC_INSTRUMENT_BMSB_SPIN        239
#define IDS_NOT_DLS1                    239
#define IDC_INSTRUMENT_BLSB_SPIN        240
#define IDM_DLS_DESIGNER                240
#define IDS_ERR_INST_SAME_ADDRESS       240
#define IDC_INSTRUMENT_PATCH_SPIN       241
#define IDD_VOLUME_PAGE                 241
#define IDS_ERR_INST_OVERLAPPING_REGIONS 241
#define IDD_PITCH_PAGE                  242
#define IDS_ERR_DRUMS_MORE_REGIONS      242
#define IDC_REGION_VELOCITY_RANGE_SPIN  242
#define IDM_WAVEREF_NODE_RMENU          242
#define IDS_ERR_INVALID_NUMBER_ARTICULATIONS 243
#define IDC_REGION_VELOCITYTHRU_SPIN    243
#define IDC_REGION_VELOCITY_THRU_SPIN   243
#define IDS_ERR_INST_NO_REGIONS         244
#define IDC_CLICK_VELOCITY_SPIN         244
#define IDS_ERR_INST_NO_GLOBAL_ARTICULATION 245
#define IDM_REGION_PROP_PAGE_RMENU      246
#define IDS_ERR_INST_INVALID_NUMBER_REGIONS 246
#define IDM_INST_EDITOR_REGION_RMENU    247
#define IDS_IS_DLS1                     247
#define IDM_INST_EDITOR_ARTICULATION_RMENU 248
#define IDS_ERR_UNSUPPORTED_COMPRESSION_FORMAT 248
#define IDC_REGION_REGIONKEYBOARD       249
#define IDM_INST_EDITOR_INSTRUMENT_RMENU 249
#define IDS_ERR_RUNTIME_UNSUPPORTED_COMPRESSION_FORMAT 249
#define IDS_ERR_DLS_RUNTIME_UNSUPPORTED_COMPRESSION_FORMAT 249
#define IDS_ERR_TOOMANY_WAVE_FILES      250
#define IDS_ERR_FAILED_WAVE_INSERT      251
#define IDS_ERR_INVALID_LOOPSTART       252
#define IDC_OWS_STATIC_PLAY_BACK        253
#define IDS_ERR_INVALID_BANK            253
#define IDC_OWS_STATIC_FINE_TUNE        254
#define IDS_ERR_GETFORMAT               254
#define IDC_OWS_STATIC_ROOT_NOTE        255
#define IDS_ERR_DOWNLOAD                255
#define IDC_OWS_STATIC_ATTENUATION      256
#define IDB_ZOOMIN                      256
#define IDS_ERR_FAILEDBUFFER            256
#define IDC_OWS_STATIC_START            257
#define IDB_ZOOMINDOWN                  257
#define IDS_CONFIRM_REPLACE_WAVE        257
#define IDC_OWS_STATIC_LENGTH           258
#define IDB_ZOOMOUT                     258
#define IDS_CONTINUE_VERIFYDLS          258
#define IDC_OWS_STATIC_S_TONES          259
#define IDB_ZOOMOUTDOWN                 259
#define IDS_LOOP_SELECTION_TOO_SMALL    259
#define IDC_OWS_STATIC_DB               260
#define IDS_ERR_DELETE_ON_COMPRESSED_WAVE 260
#define IDC_LFO_STATIC_DB1              261
#define IDM_WAVE_EDITOR_REGION_RMENU    261
#define IDS_ERR_INSUFFICIENT_MEMORY     261
#define IDC_LFO_STATIC_S_TONES2         262
#define IDS_ERR_WAVE_DOWNLOAD_FAILED    262
#define IDM_ARTICULATIONLIST_NODE_RMENU 262
#define IDC_LFO_STATIC_DB2              263
#define IDS_ERR_INST_DOWNLOAD_FAILED    263
#define IDC_LFO_STATIC_S_TONES3         263
#define IDC_LFO_STATIC_S_TONES1         264
#define IDS_COLLECTION_NODE_TEXT        264
#define IDS_COLLECTION_OBJECT_TEXT      264
#define IDC_PEG_STATIC_S_TONES1         265
#define IDC_PEG_S_TONES_STATIC          265
#define IDS_WAVE_NODE_TEXT              265
#define IDS_WAVE_OBJECT_TEXT            265
#define IDC_LFO_STATIC_S_TONES4         265
#define IDC_PEG_PERCENT_STATIC          266
#define IDD_WAVE_INFO_PROP_PAGE         266
#define IDS_WAVE_NODE_TEXT2             266
#define IDC_LFO_STATIC_DB3              266
#define IDS_ERR_DOWNLOAD_DLS_CONFIG     266
#define IDC_VEG_PERCENT_STATIC1         267
#define IDS_NO_WAVE                     267
#define IDC_VEG_PERCENT_STATIC2         268
#define IDS_ERR_STEREO_COMPRESSION_IN_COLLECTION 268
#define IDC_VEG_SECONDS_STATIC1         269
#define IDD_DLS_ABOUT_BOX               269
#define IDS_ERR_DLS1RGN_RANGECONFLICT   269
#define IDC_VEG_SECONDS_STATIC2         270
#define IDI_JAZZ                        270
#define IDS_QUERY_GMINHARDWARE          270
#define IDC_VEG_SECONDS_STATIC3         271
#define IDB_ATTACK                      271
#define IDS_QUERY_GSINHARDWARE          271
#define IDC_PEG_SECONDS_STATIC1         272
#define IDS_QUERY_XGINHARDWARE          272
#define IDC_PEG_SECONDS_STATIC2         273
#define IDB_DECAY                       273
#define IDS_QUERY_SUPPORTSDLS1          273
#define IDC_PEG_SECONDS_STATIC3         274
#define IDB_DECAY2                      274
#define IDD_DLG_GUID                    274
#define IDS_QUERY_SUPPORTSDLS2          274
#define IDC_VEG_VEL_TO_ATTACH_STATIC    275
#define IDB_RELEASE                     275
#define IDS_QUERY_SAMPLEMEMORYSIZE      275
#define IDC_VEG_KEY_TO_DECAY_STATIC     276
#define IDB_RELEASE2                    276
#define IDS_QUERY_MANUFACTURERSID       276
#define IDC_VEG_PAN_STATIC              277
#define IDB_SUSTAIN                     277
#define IDS_QUERY_PRODUCTID             277
#define IDC_VEG_RELEASE_STATIC          278
#define IDS_QUERY_SAMPLEPLAYBACKRATE    278
#define IDC_VEG_SUSTAIN_STATIC          279
#define IDR_DLS_ACCELERATOR             279
#define IDS_ERR_UNKNOWN_QUERY           279
#define IDC_VEG_DECAY_STATIC            280
#define IDI_COLLECTION_REF              280
#define IDS_ERR_UNKNOWN_OPERATOR        280
#define IDC_VEG_ATTACK_STATIC           281
#define IDI_COLLECTION_REF_SEL          281
#define IDI_ICON1                       281
#define IDS_NONE                        281
#define IDC_PEG_RANGE_STATIC            282
#define IDC_VEG_DELAY_STATIC            282
#define IDS_QUERIES                     282
#define IDC_PEG_KEY_TO_DECAY_STATIC     283
#define IDD_WAVE_COMPRESSION_PROP_PAGE  283
#define IDC_VEG_HOLD_STATIC             283
#define IDS_PRESET_CONDITIONS           283
#define IDC_PEG_VEL_TO_ATTACK_STATIC    284
#define IDS_OPERATORS                   284
#define IDC_VEG_KEY_TO_HOLD_STATIC      284
#define IDC_PEG_ATTACK_STATIC           285
#define IDD_PATCH_CONFLICT              285
#define IDS_MALFORMED_EXPRESSION        285
#define IDC_VEG_SHUTDOWN_TIME_STATIC    285
#define IDC_PEG_DECAY_STATIC            286
#define IDD_USER_PATCH_CONFLICT         286
#define IDS_ARTICULATION_FOLDER_NAME    286
#define IDC_PEG_SUSTAIN_STATIC          287
#define IDS_CONDITION_CONFIG_TOOLBAR_TITLE 287
#define IDC_PEG_RELEASE_STATIC          288
#define IDD_PROGRESS_DIALOG             288
#define IDS_CONDITION_CONFIG_TOOLBAR_MENUTEXT 288
#define IDC_PEG_DELAY_STATIC            289
#define IDS_CONDITION_CONFIG_TOOLBAR_HELP 289
#define IDC_PEG_HOLD_STATIC             290
#define IDS_TOOLBAR_FONT                290
#define IDC_AUTHOR                      291
#define IDS_CONDITION_CONFIG_QUERYVALUENOTE 291
#define IDC_PEG_KEY_TO_HOLD_STATIC      291
#define IDD_NEW_WAVE                    292
#define IDS_ERR_CONFIG_NAME_CONFLICT    292
#define IDC_SAMPLERATE                  293
#define IDS_ERR_CONFIG_NO_NAME          293
#define IDC_SAMPLESIZE                  294
#define IDS_ERR_DEFAULT_CONFIG_EDIT     294
#define IDC_LENGTH                      295
#define IDS_ERR_QUERYNAME_CONFLICT      295
#define IDC_FINE_TUNE                   296
#define IDB_DELAY                       296
#define IDS_OPCODE_BITWISE_AND          296
#define IDB_HOLD                        297
#define IDS_OPCODE_BITWISE_OR           297
#define IDC_ACTIVATE_ATTENUATION        298
#define IDI_WAVE_REF                    298
#define IDS_OPCODE_BITWISE_XOR          298
#define IDC_ACTIVATE_FINE_TUNE          299
#define IDI_WAVE_REF_SEL                299
#define IDS_OPCODE_ADD                  299
#define IDC_ACTIVATE_ROOT_NOTE          300
#define IDD_CONDITION_EDITOR            300
#define IDS_OPCODE_SUBTRACT             300
#define IDC_DB_ATTENUATION              301
#define IDD_NAME_UNNKNOWNQUERY_DIALOG   301
#define IDS_OPCODE_MULTIPLY             301
#define IDC_SEMI_TONES                  302
#define IDS_OPCODE_DIVIDE               302
#define IDC_SAMPLE_COMPRESSION          303
#define IDD_ARTLIST_PROP_PAGE           303
#define IDS_OPCODE_LOGICAL_AND          303
#define IDC_SAMPLE_TRUNCATION           304
#define IDS_OPCODE_LOGICAL_OR           304
#define IDC_LOOP_START                  305
#define IDC_EDIT_GUID                   305
#define IDS_OPCODE_LT                   305
#define IDC_LOOP_LENGTH                 306
#define IDC_NEW_GUID                    306
#define IDS_OPCODE_LE                   306
#define IDC_ROOT_NOTE                   307
#define IDC_GM_GUID                     307
#define IDS_OPCODE_GT                   307
#define IDC_LOOP_END                    308
#define IDS_OPCODE_GE                   308
#define IDC_SELECTION_START             309
#define IDS_OPCODE_EQ                   309
#define IDC_LOOP                        310
#define IDC_SELECTION_END               310
#define IDI_REGION_GRAY                 310
#define IDS_OPCODE_NOT                  310
#define IDC_ACTIVATE_PLAYBACK           311
#define IDC_SELECTION_LENGTH            311
#define IDI_REGION_GRAY_SEL             311
#define IDS_OPCODE_QS                   311
#define IDC_ROOT_NOTE_SPIN              312
#define IDI_ARTICULATION_GRAY           312
#define IDS_OPCODE_HELP_BITWISE_AND     312
#define IDI_ARTICULATION_GRAY_SEL       313
#define IDS_OPCODE_HELP_BITWISE_OR      313
#define IDI_FOLDER_GRAY                 314
#define IDS_OPCODE_HELP_BITWISE_XOR     314
#define IDC_STATIC_ROOT_NOTE            315
#define IDI_FOLDER_GRAY_SEL             315
#define IDS_OPCODE_HELP_ADD             315
#define IDC_STATIC_PLAYBACK             316
#define IDB_CONDITION_CONFIG_TOOLBAR    316
#define IDS_OPCODE_HELP_SUBTRACT        316
#define IDI_WAVE_STEREO_SEL             316
#define IDC_STATIC_START                317
#define IDS_OPCODE_HELP_MULTIPLY        317
#define IDI_WAVE_STEREO_REF_SEL         317
#define IDC_STATIC_LENGTH               318
#define IDD_CONDITION_CONFIG_EDITOR     318
#define IDS_OPCODE_HELP_DIVIDE          318
#define IDI_WAVE_STEREO_REF             318
#define IDC_STATIC_DB                   319
#define IDS_OPCODE_HELP_LOGICAL_AND     319
#define IDD_VIBLFO_PAGE                 319
#define IDI_WAVE_STEREO                 319
#define IDC_STATIC_SEMI_TONES           320
#define IDS_OPCODE_HELP_LOGICAL_OR      320
#define IDD_FILTER_PAGE                 320
#define IDC_STATIC_FINE_TUNE            321
#define IDS_OPCODE_HELP_LT              321
#define IDD_MISC_PAGE                   321
#define IDC_STATIC_ATTENUATION          322
#define IDS_OPCODE_HELP_LE              322
#define IDC_STATIC_END                  323
#define IDS_OPCODE_HELP_GT              323
#define IDM_CONFIG_TOOLBAR_RMENU        323
#define IDS_OPCODE_HELP_GE              324
#define IDC_SLIDER1                     325
#define IDC_REGION_GROUP                325
#define IDS_OPCODE_HELP_EQ              325
#define IDC_LFO_CHANPRESSTOFC           325
#define IDC_FILTER_INITIALFC            325
#define IDC_OUTPUT_CC10TOPAN            325
#define IDS_OPCODE_HELP_NOT             326
#define IDS_OPCODE_HELP_QS              327
#define IDS_ERR_INSERT_STEREO_COMPRESSED_WAVE_IN_COLLECTION 328
#define IDC_SIZEWE_BLUE                 328
#define IDC_GM_ASSIGNMENT               329
#define IDS_ERR_MATCHING_PARENTHESIS_FORMAT 329
#define IDC_SIZEWE_GREEN                329
#define IDD_ADPCM_LOOP_WARNING          329
#define IDC_FILE_VERSION                330
#define IDS_UNDO_STREAMING              330
#define IDD_INSERT_SILENCE              330
#define IDS_UNDO_READAHEAD_TIME         331
#define IDD_RESAMPLE                    331
#define IDC_REGION_ROOT_NOTE_TEXT       332
#define IDS_ERR_COLLECTION_NO_WAVES     332
#define IDC_REGION_ELRANGE_TEXT         333
#define IDS_ERR_COLLECTION_WAVE_LOAD    333
#define IDC_REGION_EURANGE_TEXT         334
#define IDS_INSERT_COLLECTION_WAVE_TITLE 334
#define IDC_VELOCITY_ELRANGE_TEXT       335
#define IDS_REGION_CHANNEL0             335
#define IDC_EDIT1                       336
#define IDC_VEG_RDECAY                  336
#define IDC_CONFLICTING_INS             336
#define IDC_VELOCITY_EURANGE_TEXT       336
#define IDC_SCRIPT_EDIT                 336
#define IDC_QUERY_NAME_EDIT             336
#define IDC_VALUE_EDIT                  336
#define IDC_LFO_DCHANPRESSTOFC          336
#define IDC_FILTER_DINITIALFC           336
#define IDC_OUTPUT_DRPN2KEY             336
#define IDC_READAHEAD_EDIT              336
#define IDC_PHASE_GROUP_EDIT            336
#define IDS_REGION_CHANNEL1             336
#define IDC_EDIT_SAMPLES                336
#define IDC_EDIT_UPSAMPLE_RATE          336
#define IDC_VEG_RRELEASE                337
#define IDS_REGION_CHANNEL2             337
#define IDC_EDIT_UPSAMPLE_LOOP_START    337
#define IDC_PEG_RDECAY                  338
#define IDS_REGION_CHANNEL3             338
#define IDC_EDIT_UPSAMPLE_LOOP_END      338
#define IDC_PEG_RRELEASE                339
#define IDS_REGION_CHANNEL4             339
#define IDC_EDIT_UPSAMPLE_INSERTED      339
#define IDC_COMBO1                      340
#define IDS_REGION_CHANNEL5             340
#define IDC_EDIT_DOWNSAMPLE_RATE        340
#define IDC_COMPRESSED                  341
#define IDS_REGION_CHANNEL6             341
#define IDC_EDIT_DOWNSAMPLE_LOOP_START  341
#define IDC_CONFLICT_MSB                342
#define IDS_REGION_CHANNEL7             342
#define IDC_EDIT_DOWNSAMPLE_LOOP_END    342
#define IDC_CONFLICT_LSB                343
#define IDS_REGION_CHANNEL8             343
#define IDC_EDIT_DOWNSAMPLE_INSERTED    343
#define IDC_CONFLICT_PATCH              344
#define IDS_REGION_CHANNEL9             344
#define IDC_EDIT_ORIGINAL_RATE          344
#define IDC_BTN_FIX_ALL                 345
#define IDS_REGION_CHANNEL10            345
#define IDC_EDIT_ORIGINAL_LOOP_START    345
#define IDC_BTN_IGNORE_ALL              346
#define IDS_REGION_CHANNEL11            346
#define IDC_EDIT_ORIGINAL_LOOP_END      346
#define IDC_CONFLICT_NAME               347
#define IDS_REGION_CHANNEL12            347
#define IDC_EDIT_ORIGINAL_INSERTED      347
#define IDC_CONFLICT_DESC_TEXT          348
#define IDS_REGION_CHANNEL13            348
#define IDC_BTN_FIX                     349
#define IDS_REGION_CHANNEL14            349
#define IDC_CONFLICT_COLLECTION         350
#define IDS_REGION_CHANNEL15            350
#define IDC_DRUM                        351
#define IDS_REGION_CHANNEL16            351
#define IDC_IGNORE_CHECK                352
#define IDS_REGION_CHANNEL17            352
#define IDC_COMBO2                      353
#define IDS_MULTIPLE_MASTERS_IN_PHASE_GROUP 353
#define IDS_UNDO_PHASE_GROUP            354
#define IDS_UNDO_PHASE_GROUP_ID         355
#define IDC_PROGRESS                    356
#define IDS_UNDO_PHASE_GROUP_MASTER     356
#define IDC_SAMPLE_LENGTH_EDIT          357
#define IDS_UNDO_MULTICHANNEL           357
#define IDC_SAMPLE_LENGTH_STATIC        358
#define IDS_UNDO_CHANNEL                358
#define ID_BTN_IGNORE                   359
#define IDS_ERR_DEFAULT_CONFIG_DELETE   359
#define IDC_REGIONLAYERS_SCROLLBAR      360
#define IDS_WARN_SAMPLERATE             360
#define IDC_ARTICULATION_STATIC         361
#define IDS_WARN_MSSYNTH_LOOP_LIMIT     361
#define IDS_UNDO_CONDITION              362
#define IDC_COMPRESSION_RATIO           363
#define IDS_ERR_WVP_RUNTIME_UNSUPPORTED_COMPRESSION_FORMAT 363
#define IDC_WAVE_SIZE                   364
#define IDS_UNDO_LAYER_DELETE           364
#define IDC_LOOP_CHECK                  365
#define IDS_UNDO_LAYER_INSERT           365
#define IDC_LOOP_LENGTH_LOCK_CHECK      366
#define IDS_UNDO_MODIFY_LOOP            366
#define IDC_LOOP_LENGTH_SPIN            367
#define IDS_REGION_CHANNEL_STEREO       367
#define IDC_LOOP_END_SPIN               368
#define IDS_INVALID_NEW_SAMPLERATE      368
#define IDC_LOOP_START_SPIN             369
#define IDS_XBADPCM_MONO                369
#define IDC_SELECTION_START_SPIN        370
#define IDC_ATTACK_STATIC               370
#define IDS_XBADPCM_STEREO              370
#define IDC_SELECTION_END_SPIN          371
#define IDC_DECAY_STATIC                371
#define IDS_UNDO_NOPREROLL              371
#define IDC_SELECTION_LENGTH_SPIN       372
#define IDC_DECAY2_STATIC               372
#define IDC_SELECTION_LENGTH_LOCK_CHECK 373
#define IDC_SUSTAIN_STATIC              373
#define IDC_RELEASE_STATIC              374
#define IDC_RELEASE2_STATIC             375
#define IDC_8BITSAMPLE_RADIOBTN         376
#define IDC_DELAY_STATIC                376
#define IDC_16BITSAMPLE_RADIOBTN        377
#define IDC_HOLD_STATIC                 377
#define IDC_MONO_RADIOBTN               378
#define IDC_STEREO_RADIOBTN             379
#define IDC_SAMPLE_RATE_COMBO           380
#define IDC_STATIC_MSB                  381
#define IDC_STATIC_LSB                  382
#define IDC_STATIC_PATCH                383
#define IDC_STATIC_MAXLEVEL             384
#define IDC_STATIC_WAVE                 385
#define IDC_STATIC_ROOT                 386
#define IDC_STATIC_RANGE                387
#define IDC_STATIC_TO                   388
#define IDC_STATIC_KEYGROUP             389
#define IDC_STATIC_VELOCITYRANGE        390
#define IDC_STATIC_VELOCITY_TO          391
#define IDC_VOLUME_BUTTON               402
#define IDC_STATIC_CONDITION            403
#define IDC_PITCH_BUTTON                404
#define IDC_LFO_BUTTON                  405
#define IDC_CONDITION_COMBO             406
#define IDC_REGION_CONDITION_COMBO      406
#define IDC_CONDITION_EDIT_BUTTON       407
#define IDC_STATIC_AUDITION_OPTIONS     408
#define IDC_RADIO_SOLO_LAYER            409
#define IDC_RADIO_MULTIPLE_LAYERS       410
#define IDC_STATIC_CLICKVELOCITY        411
#define IDC_STATIC_INSTRUMENTGROUP      412
#define IDC_STATIC_REGIONGROUP          413
#define IDC_VIBLFO_BUTTON               414
#define IDC_FILTER_BUTTON               415
#define IDC_WAVE_EDIT_BUTTON            416
#define IDC_LAYER_SCROLLBAR             418
#define IDC_PEG_KEY2DECAY               420
#define IDC_VEG_KEY2DECAY               421
#define IDC_PEG_KEY2HOLD                421
#define IDC_DLS1_REGION                 422
#define IDC_VEG_KEY2HOLD                422
#define IDC_DLS1_STATIC                 423
#define IDC_QUERY_GUID_STATIC           424
#define IDC_DLS1_CHECK                  427
#define IDC_ARTLIST_CONDITION_COMBO     428
#define IDC_ART_DLS1_CHECK              430
#define IDC_QUERY_LIST                  431
#define IDC_VALUE_STATIC                432
#define IDC_CONFIG_NAME_EDIT            433
#define IDC_HELP_STATIC                 435
#define IDC_LFO2_PITCH                  444
#define IDC_LFO2_DPITCH                 449
#define IDC_LFO_CHANPRESSTOPITCH        450
#define IDC_LFO_DCHANPRESSTOPITCH       451
#define IDC_LFO_CHANPRESSTOGAIN         452
#define IDC_LFO_DCHANPRESSTOGAIN        453
#define IDC_FREQ_STATIC                 454
#define IDC_HERTZ_STATIC                455
#define IDC_SECONDS_STATIC              456
#define IDC_PITCH_STATIC                457
#define IDC_PRSTONES_STATIC             458
#define IDC_CHPRTOPITCH_STATIC          459
#define IDC_CPTOPSTONES_STATIC          460
#define IDC_MW2PITCH_STATIC             461
#define IDC_MW2PSTONES_STATIC           462
#define IDC_LFO2_CHANPRESSTOPITCH       466
#define IDC_LFO2_DCHANPRESSTOPITCH      467
#define IDC_LFO2_MW2PITCH               468
#define IDC_LFO2_DMW2PITCH              469
#define IDC_FILTER_INITIALQ             470
#define IDC_FILTER_LFOTOFC              471
#define IDC_FILTER_CC1TOFC              472
#define IDC_FILTER_ENV2TOFC             473
#define IDC_FILTER_VELTOFC              474
#define IDC_FILTER_KEYNUMTOFC           475
#define IDC_FILTER_DINITIALQ            476
#define IDC_FILTER_DLFOTOFC             477
#define IDC_FILTER_DCC1TOFC             478
#define IDC_FILTER_DENV2TOFC            479
#define IDC_FILTER_DVELTOFC             480
#define IDC_FILTER_DKEYNUMTOFC          481
#define IDC_ENABLE_FILTER               482
#define IDC_OUTPUT_CC19TOREVERB         483
#define IDC_OUTPUT_DEFAULTREVERB        484
#define IDC_OUTPUT_CC93TOCHORUS         485
#define IDC_OUTPUT_DEFAULTCHORUS        486
#define IDC_OUTPUT_RPN2KEY              487
#define IDC_OUTPUT_DCC10TOPAN           488
#define IDC_OUTPUT_DCC19TOREVERB        489
#define IDC_OUTPUT_DDEFAULTREVERB       490
#define IDC_OUTPUT_DCC93TOCHORUS        491
#define IDC_OUTPUT_DDEFAULTCHORUS       492
#define IDC_FORWARD_LOOP_RADIO          493
#define IDC_LOOP_AND_RELEASE_RADIO      494
#define IDC_STREAM_CHECK                495
#define IDC_READAHEAD_SPIN              496
#define IDC_READAHEAD_SAMPLES_STATIC    497
#define IDC_EDIT_GUID_BUTTON            500
#define IDC_PHASE_GROUP_CHECK           501
#define IDC_PHASE_GROUP_SPIN            502
#define IDC_MASTER_CHECK                503
#define IDC_CHANNEL_COMBO               504
#define IDC_MULTICHANNEL_CHECK          505
#define IDC_STATIC_LAYER1               506
#define IDC_STATIC_LAYER2               507
#define IDC_STATIC_LAYER3               508
#define IDC_CONFLICT_NOT_AGAIN_CHECK    509
#define IDC_READ_AHEAD_STATIC           510
#define IDC_MS_STATIC                   511
#define IDC_MSC_PAN_SPIN                513
#define IDC_FILTER_DINITIALFC_SPIN      515
#define IDC_DECOMPRESSEDDATASTART_EDIT  516
#define IDC_DECOMPRESSEDDATASTART_STATIC 517
#define IDC_DECOMPRESSEDDATASTART_STATIC2 518
#define IDC_ARTLIST_CONDITION_STATIC    519
#define IDC_EDIT_MILLISECONDS           522
#define IDC_EDIT_SECONDS                523
#define IDC_EDIT_CURRENT_SAMPLERATE     524
#define IDC_EDIT_NEW_SAMPLERATE         525
#define IDC_RADIO_UPSAMPLE              526
#define IDC_RADIO_DOWNSAMPLE            527
#define IDC_RADIO_ORIGINAL              528
#define IDC_CHECK_NOT_AGAIN             529
#define IDC_NOPREROLL_CHECK             530
#define IDC_VEG_ADSRENVELOPECTRL        1000
#define IDC_PEG_ADSRENVELOPECTRL        1000
#define IDC_REGION_EURANGE              1015
#define IDC_REGION_ELRANGE              1016
#define IDC_VELOCITY_ELRANGE            1017
#define IDC_REGION_VELOCITY_ELRANGE     1017
#define IDC_ATTENUATION                 1018
#define IDC_VELOCITY_EURANGE            1018
#define IDC_REGION_VELOCITY_EURANGE     1018
#define IDC_DATTENUATION                1019
#define IDC_CLICK_VELOCITY              1019
#define IDC_TUNE                        1020
#define IDC_LFO_DVOLUME                 1021
#define IDC_DTUNE                       1021
#define IDC_LFO_DPITCH                  1022
#define IDC_LFO_DMW2VOLUME              1023
#define IDC_LFO_DMW2PITCH               1024
#define IDC_NOTE                        1024
#define IDC_VEG_DATTACK                 1025
#define IDC_PEG_DATTACK                 1025
#define IDC_FIRST_EDIT2VALIDATE         1025
#define IDC_VEG_DDECAY                  1026
#define IDC_PEG_DDECAY                  1026
#define IDC_VEG_DSUSTAIN                1027
#define IDC_PEG_DSUSTAIN                1027
#define IDC_VEG_DRELEASE                1028
#define IDC_PEG_DRELEASE                1028
#define IDC_VEG_DDELAY                  1029
#define IDC_PEG_DDELAY                  1029
#define IDC_PEG_DHOLD                   1030
#define IDC_VEG_DHOLD                   1030
#define IDC_LFO_FREQUENCY               1031
#define IDC_LFO_DELAY                   1032
#define IDC_LFO_VOLUME                  1033
#define IDC_LFO_PITCH                   1034
#define IDC_LFO_MW2VOLUME               1035
#define IDC_LFO_MW2PITCH                1036
#define IDC_PEG_DRANGE                  1037
#define IDC_LFO2_FREQUENCY              1037
#define IDC_LFO2_DELAY                  1038
#define IDC_PEG_DVEL2ATTACK             1046
#define IDC_PEG_DKEY2DECAY              1047
#define IDC_PEG_VEL2ATTACK              1048
#define IDC_PEG_RANGE                   1049
#define IDC_VEG_VEL2ATTACK              1050
#define IDC_PEG_DKEY2HOLD               1050
#define IDC_VEG_SHUTDOWNTIME            1051
#define IDC_MSC_PAN                     1052
#define IDC_VEG_DVEL2ATTACK             1053
#define IDC_VEG_DKEY2DECAY              1054
#define IDC_NAME                        1055
#define IDC_VEG_DKEY2HOLD               1055
#define IDC_SUBJECT                     1056
#define IDC_VEG_DSHUTDOWNTIME           1056
#define IDC_REGION_WAVELINK             1057
#define IDC_ENGINEER                    1058
#define IDC_COPYRIGHT                   1059
#define IDC_COMMENT                     1060
#define IDC_BANK                        1061
#define IDC_TRUNCATE                    1061
#define IDC_PATCH                       1062
#define IDC_MSC_DPAN                    1062
#define IDC_COMPRESS                    1062
#define IDC_BANK2                       1063
#define IDC_LFO_DFREQUENCY              1063
#define IDC_LFO_DDELAY                  1064
#define IDC_DMAXLEVEL                   1065
#define IDC_DLENGTH                     1065
#define IDC_LFO2_DFREQUENCY             1065
#define IDC_DLOOPSTART                  1066
#define IDC_LFO2_DDELAY                 1066
#define IDC_DLOOPLENGTH                 1067
#define IDC_DNOTE                       1068
#define IDC_DSAMPLESIZE                 1069
#define IDC_DSAMPLERATE                 1070
#define IDC_DEFFECTIVERATE              1071
#define IDC_DREGIONNOTE                 1072
#define IDC_DRUMS                       1074
#define IDC_REGION_OVERLAP              1079
#define IDC_ONE_SHOT                    1081
#define IDC_SAMPLE_COUNT                1111
#define IDC_INST_COUNT                  1112
#define IDC_REGION_COUNT                1113
#define IDC_ARTIC_COUNT                 1114
#define IDC_WAVE_COUNT                  1115
#define IDC_VER_1                       1125
#define IDC_VER_2                       1126
#define IDC_VER_3                       1127
#define IDC_VER_4                       1128
#define IDC_HSCROLLBAR                  1129
#define BTN_ZOOMIN                      1130
#define BTN_ZOOMOUT                     1131
#define IDM_NEW_INSTRUMENT              32768
#define IDM_NEW_WAVE                    32769
#define IDM_NEW_REGION                  32770
#define IDM_DELETE                      32771
#define IDM_REVERT_TO_WAVE              32773
#define IDM_PROPERTIES                  32775
#define ID_EDIT_DELETE                  32777
#define ID_EDIT_SELECTALL               32779
#define ID_INST_ED_REGION_CUT           32782
#define ID_INST_ED_REGION_COPY          32783
#define ID_INST_ED_REGION_PASTE         32784
#define ID_INST_ED_REGION_DELETE        32785
#define IDM_NEW_COLLECTION              32787
#define IDM_INST_ED_REGION_NEW_REGION   32788
#define IDM_INST_ED_INSTRUMENT_PROPERTIES 32791
#define IDM_INST_ED_REGION_PROPERTIES   32792
#define IDM_RENAME                      32797
#define IDM_OPEN                        32800
#define IDM_CUT                         32801
#define IDM_COPY                        32802
#define IDM_PASTE                       32803
#define IDM_INST_ED_ARTICULATION_NEW_REGION 32804
#define ID_INST_ED_ARTICULATION_CUT     32805
#define ID_INST_ED_ARTICULATION_COPY    32806
#define ID_INST_ED_ARTICULATION_PASTE   32807
#define ID_INST_ED_ARTICULATION_DELETE  32808
#define IDM_SAVEAS                      32810
#define IDM_INSERT_ART                  32811
#define IDM_INSERT_REGION               32812
#define IDM_REPLACE                     32813
#define IDM_MAKE_MELODIC                32814
#define IDM_CLONE                       32815
#define IDM_SNAP_TO_ZERO                32816
#define IDM_SET_LOOP_FROM_SELECTION     32817
#define IDM_HELP_FINDER                 32818
#define IDM_VERIFY_DLS1                 32819
#define IDS_INSTRUMENT_PROPPAGE_TITLE   32819
#define IDS_WAVE_PROPPAGE_TITLE         32820
#define IDM_COPY_LOOP                   32820
#define IDS_REGION_PROPPAGE_TITLE       32821
#define IDM_WAVEEDITORREGION_FADE_IN    32821
#define IDM_WAVEEDITORREGION_FADE_OUT   32822
#define IDM_NEW_ARTICULATION            32823
#define IDM_INSERT_ART_LIST             32824
#define ID_BUTTON32830                  32830
#define IDC_ADD_CONFIG_BUTTON           32830
#define ID_BUTTON32831                  32831
#define IDC_DELETE_CONFIG_BUTTON        32831
#define ID_BUTTON32832                  32832
#define IDC_EDIT_CONFIG_BUTTON          32832
#define IDM_INST_ED_REGION_NEW_LAYER    32833
#define ID_INST_ED_LAYER_DELETE         32834
#define IDM_EXPORT_CONFIGS              32838
#define IDM_IMPORT_CONFIGS              32839
#define IDM_FIND_BEST_LOOP              32842
#define IDM_DECOMPRESS_START            32844
#define IDM_INSERT_SILENCE              32845
#define IDM_RESAMPLE                    32846
#define IDS_UNDO_REGION_MOVE            57346
#define IDS_UNDO_REGION_DELETE          57347
#define IDS_UNDO_REGION_INSERT          57348
#define IDS_UNDO_USE_INSTRUMENT_ARTICULATION 57349
#define IDS_UNDO_DELETE_ARTICULATION    57350
#define IDS_UNDO_INSERT_ARTICULATION    57351
#define IDS_UNDO_LOOPPOINTS             57352
#define IDS_UNDO_OVERRIDE_WAVESETTINGS  57353
#define IDS_UNDO_OVERRIDE_ALLOWTRUNCATION 57354
#define IDS_UNDO_OVERRIDE_ALLOWCOMPRESSION 57355
#define IDS_UNDO_LOOPSETTINGS           57356
#define IDS_UNDO_OVERRIDE_ATTENUATION   57357
#define IDS_UNDO_OVERRIDE_FINETUNE      57358
#define IDS_UNDO_OVERRIDE_ROOTNOTE      57359
#define IDS_UNDO_ATTENUATION            57360
#define IDS_UNDO_FINETUNE               57361
#define IDS_UNDO_ROOTNOTE               57362
#define IDS_UNDO_COMPRESSION            57363
#define IDS_UNDO_COMMENT                57364
#define IDS_UNDO_SUBJECT                57365
#define IDS_UNDO_ENGINEER               57366
#define IDS_UNDO_COPYRIGHT              57367
#define IDS_UNDO_NAME                   57368
#define IDS_UNDO_AUTHOR                 57369
#define IDS_UNDO_DELETE_SELECTION       57370
#define IDS_LOOP_COPY                   57371
#define IDS_UNDO_FADEIN                 57372
#define IDS_UNDO_FADEOUT                57373
#define IDS_UNDO_VELOCITY_RANGE_EDIT    57374
#define IDS_UNDO_DELAY_EDIT             57375
#define IDS_UNDO_HOLD_EDIT              57376
#define IDS_UNDO_ARTICULATION_DELETE    57377
#define IDS_UNDO_KEYTOHOLD_EDIT         57378
#define IDS_UNDO_SHUTDOWNTIME_EDIT      57379
#define IDS_UNDO_LFO2_FREQ_EDIT         57380
#define IDS_UNDO_LFO2_DELAY_EDIT        57381
#define IDS_UNDO_LFO2_PITCH_EDIT        57382
#define IDS_UNDO_LFO2_MW2PITCH_EDIT     57383
#define IDS_UNDO_LFO2_CHANPRESSTOPITCH_EDIT 57384
#define IDS_UNDO_LFO_CHANPRESSTOPITCH_EDIT 57385
#define IDS_UNDO_LFO_CHANPRESSTOGAIN_EDIT 57386
#define IDS_UNDO_LFO_CHANPRESSTOFC_EDIT 57387
#define IDS_UNDO_INSERT_ARTLIST         57388
#define IDS_UNDO_INITIAL_FC             57389
#define IDS_UNDO_INITIAL_Q              57390
#define IDS_UNDO_LFO_TO_FC              57391
#define IDS_UNDO_LFOCC1_TO_FC           57392
#define IDS_UNDO_EG2_TO_FC              57393
#define IDS_UNDO_KEYVEL_TO_FC           57394
#define IDS_UNDO_KEYNUM_TO_FC           57395
#define IDS_ERR_WRONGSAMPLESIZE         57396
#define IDS_UNDO_WAVE_LOOP_TYPE         57397
#define IDS_ERR_DELETE_DEFAULT_LAYER    57398
#define IDS_ERR_DELETE_NONEMPTY_LAYER   57399
#define IDS_CONFIG_REG                  57400
#define IDS_CONFIG_EXPORT_SUCCESS       57401
#define IDS_CONFIG_EXPORT_FAILURE       57402
#define IDS_CONFIG_IMPORT_FAILURE       57403
#define IDS_CONFIG_IMPORT_SUCCESS       57404
#define IDS_UNDO_BEST_LOOP              57405
#define IDS_UNDO_DLS1_CHECK             57406
#define IDS_UNDO_REGION_INSERT_STEREO   57407
#define IDS_UNDO_DECOMPRESSEDSTART      57408
#define IDS_UNDO_INS_SILENCE            57409
#define IDS_UNDO_RESAMPLE               57410
#define IDS_ERR_NO_PORT                 57644
#define IDS_ERR_INVALIDARG              57645
#define IDS_INSTRUMENT_TEXT             57646
#define IDS_REGION_TEXT                 57647
#define IDS_COLLECTION_TEXT             57648
#define IDS_WAVE_TEXT                   57649
#define IDS_ARTICULATION_TEXT           57650
#define IDS_DLS_EDITOR_VERSION_TEXT     57651
#define IDS_INVALID_LOOP_VALUES         57652
#define IDS_ENTER_VALID_MIDI_NOTE       57653
#define IDS_CANNOT_CHECK_OVERRIDE       57654
#define IDS_LOOP_TOO_SMALL              57655
#define IDS_KEY_GROUP_UNDO_TEXT         57656
#define IDS_LSB_UNDO_TEXT               57657
#define IDS_MSB_UNDO_TEXT               57658
#define IDS_UNDO_MENU_TEXT              57659
#define IDS_REDO_MENU_TEXT              57660
#define IDS_UNDO_SHORTCUT_TEXT          57661
#define IDS_REDO_SHORTCUT_TEXT          57662
#define IDS_PATCH_UNDO_TEXT             57663
#define IDS_RANGE_UNDO_TEXT             57664
#define IDS_ROOT_UNDO_TEXT              57665
#define IDS_ADSR_UNDO_TEXT              57666
#define IDS_PAN_UNDO_TEXT               57667
#define IDS_VEL2ATTACK_UNDO_TEXT        57668
#define IDS_KEY2DECAY_UNDO_TEXT         57669
#define IDS_ATTACK_UNDO_TEXT            57670
#define IDS_DECAY_UNDO_TEXT             57671
#define IDS_SUSTAIN_UNDO_TEXT           57672
#define IDS_RELEASE_UNDO_TEXT           57673
#define IDS_PITCH_RANGE_UNDO_TEXT       57674
#define IDS_LFO_FREQ_UNDO_TEXT          57675
#define IDS_LFO_DELAY_UNDO_TEXT         57676
#define IDS_LFO_VOLUME_UNDO_TEXT        57677
#define IDS_LFO_PITCH_UNDO_TEXT         57678
#define IDS_MW2VOL_UNDO_TEXT            57679
#define IDS_MW2PITCH_UNDO_TEXT          57680
#define IDS_DRUM_UNDO_TEXT              57681
#define IDS_REGION_OVERLAP_UNDO_TEXT    57682
#define IDS_WAVE_OVER_ONE_MEG           57683
#define IDS_WAVE_STEREO                 57684
#define IDS_ERR_WAVE_INCORRECT_CHANNELS 57684
#define IDS_WAVE_CUT_UNDO_TEXT          57685
#define IDS_WAVE_PASTE_UNDO_TEXT        57686
#define IDS_WAVE_REFERENCE_PROMPT       57687
#define IDS_WAVE_DELETE_CONFIRM_TITLE   57688
#define IDS_WAVE_DELETE_CONFIRM         57689
#define IDS_WAVE_SAMPLE_RATE            57690
#define IDS_WAVE_NOT_PCM                57691
#define IDS_128_CHAR_LIMIT              57692
#define IDS_BLANK_INST_NAME_FORMAT      57693
#define IDS_INST_NAME_FORMAT            57694
#define IDS_DRUM_KIT_SUFFIX             57695
#define IDS_ERR_DM_FROM_FRAMEWORK       57696
#define IDS_NO_COLLECTION               57697
#define IDS_ERR_UPDATE_ALLOC            57698
#define IDS_ERR_UPDATE_DOWNLOAD         57699
#define IDS_ERR_ZERO_SIZE_INS           57700
#define IDS_ERR_INIT_ALLOC              57701
#define IDS_ERR_DM_ID                   57702
#define IDS_ERR_GET_DOWNLOAD_BUFFER     57703
#define IDS_ERR_DOWNLOAD_WRITE          57704
#define IDS_ERR_BADWAVE                 57705
#define IDS_ERR_NOTPCM                  57706
#define IDS_ERR_NOTMONO                 57707
#define IDS_ERR_BADARTICULATION         57708
#define IDS_ERR_BADREGION               57709
#define IDS_ERR_BADWAVELINK             57710
#define IDS_ERR_BADINSTRUMENT           57711
#define IDS_ERR_NOARTICULATION          57712
#define IDS_ERR_NOWAVE                  57713
#define IDS_ERR_DM_DOWNLOAD             57714
#define IDS_ERR_INIT_DOWNLOAD           57715
#define IDS_ERR_ZERO_SIZE_WAV           57716
#define IDS_PATCH_CONFLICT_COMMON       57717
#define IDS_PATCH_CONFLICT_COLLECTION   57718
#define IDS_PATCH_CONFLICT_GENERAL      57719
#define IDS_PATCH_CONFLICT_GM           57720
#define IDS_ERR_PATCH                   57721
#define IDS_IGNORE_CHECK_GM             57722
#define IDS_IGNORE_CHECK_COLLECTION     57723
#define IDS_IGNORE_CHECK_SYNTH          57724
#define IDS_INST_DELETE_CONFIRM         57725
#define IDS_INST_DELETE_CONFIRM_TITLE   57726
#define IDS_REGION_DELETE_CONFIRM       57727
#define IDS_REGION_DELETE_CONFIRM_TITLE 57728
#define IDS_WAVELINK_UNDO_TEXT          57729
#define IDS_ERR_LOOP_START              57730
#define IDS_ERR_BADOFFSET               57731
#define IDS_ERR_DMPORT_INITIALIZATION_FAILED 57732
#define IDS_VOL_TAB_LABEL               57733
#define IDS_PITCH_TAB_LABEL             57734
#define IDS_LFO_TAB_LABEL               57735
#define IDS_PGM000                      57736
#define IDS_PGM008                      57737
#define IDS_PGM0016                     57738
#define IDS_PGM010                      57739
#define IDS_PGM018                      57740
#define IDS_PGM020                      57741
#define IDS_PGM028                      57742
#define IDS_PGM030                      57743
#define IDS_PGM038                      57744
#define IDS_PGM040                      57745
#define IDS_PGM048                      57746
#define IDS_PGM0416                     57747
#define IDS_PGM0424                     57748
#define IDS_PGM050                      57749
#define IDS_PGM058                      57750
#define IDS_PGM0516                     57751
#define IDS_PGM060                      57752
#define IDS_PGM068                      57753
#define IDS_PGM0616                     57754
#define IDS_PGM0624                     57755
#define IDS_PGM070                      57756
#define IDS_PGM080                      57757
#define IDS_PGM090                      57758
#define IDS_PGM0A0                      57759
#define IDS_PGM0B0                      57760
#define IDS_PGM0B8                      57761
#define IDS_PGM0C0                      57762
#define IDS_PGM0C8                      57763
#define IDS_PGM0D0                      57764
#define IDS_PGM0E0                      57765
#define IDS_PGM0E8                      57766
#define IDS_PGM0E9                      57767
#define IDS_PGM0F0                      57768
#define IDS_PGM100                      57769
#define IDS_PGM108                      57770
#define IDS_PGM1016                     57771
#define IDS_PGM1032                     57772
#define IDS_PGM110                      57773
#define IDS_PGM118                      57774
#define IDS_PGM1132                     57775
#define IDS_PGM120                      57776
#define IDS_PGM130                      57777
#define IDS_PGM138                      57778
#define IDS_PGM1316                     57779
#define IDS_PGM140                      57780
#define IDS_PGM150                      57781
#define IDS_PGM158                      57782
#define IDS_PGM160                      57783
#define IDS_PGM170                      57784
#define IDS_PGM180                      57785
#define IDS_PGM188                      57786
#define IDS_PGM1816                     57787
#define IDS_PGM1832                     57788
#define IDS_PGM190                      57789
#define IDS_PGM198                      57790
#define IDS_PGM1916                     57791
#define IDS_PGM1A0                      57792
#define IDS_PGM1A8                      57793
#define IDS_PGM1B0                      57794
#define IDS_PGM1B8                      57795
#define IDS_PGM1C0                      57796
#define IDS_PGM1C8                      57797
#define IDS_PGM1C16                     57798
#define IDS_PGM1D0                      57799
#define IDS_PGM1E0                      57800
#define IDS_PGM1E8                      57801
#define IDS_PGM1F0                      57802
#define IDS_PGM1F8                      57803
#define IDS_PGM200                      57804
#define IDS_PGM210                      57805
#define IDS_PGM220                      57806
#define IDS_PGM230                      57807
#define IDS_PGM240                      57808
#define IDS_PGM250                      57809
#define IDS_PGM260                      57810
#define IDS_PGM261                      57811
#define IDS_PGM268                      57812
#define IDS_PGM270                      57813
#define IDS_PGM278                      57814
#define IDS_PGM2716                     57815
#define IDS_PGM280                      57816
#define IDS_PGM288                      57817
#define IDS_PGM290                      57818
#define IDS_PGM2A0                      57819
#define IDS_PGM2B0                      57820
#define IDS_PGM2C0                      57821
#define IDS_PGM2D0                      57822
#define IDS_PGM2E0                      57823
#define IDS_PGM2F0                      57824
#define IDS_PGM300                      57825
#define IDS_PGM308                      57826
#define IDS_PGM310                      57827
#define IDS_PGM320                      57828
#define IDS_PGM328                      57829
#define IDS_PGM330                      57830
#define IDS_PGM340                      57831
#define IDS_PGM3432                     57832
#define IDS_PGM350                      57833
#define IDS_PGM360                      57834
#define IDS_PGM370                      57835
#define IDS_PGM380                      57836
#define IDS_PGM390                      57837
#define IDS_PGM391                      57838
#define IDS_PGM3A0                      57839
#define IDS_PGM3B0                      57840
#define IDS_PGM3C0                      57841
#define IDS_PGM3C1                      57842
#define IDS_PGM3D0                      57843
#define IDS_PGM3D8                      57844
#define IDS_PGM3E0                      57845
#define IDS_PGM3E8                      57846
#define IDS_PGM3E16                     57847
#define IDS_PGM3F0                      57848
#define IDS_PGM3F8                      57849
#define IDS_PGM3F16                     57850
#define IDS_PGM400                      57851
#define IDS_PGM410                      57852
#define IDS_PGM420                      57853
#define IDS_PGM430                      57854
#define IDS_PGM440                      57855
#define IDS_PGM450                      57856
#define IDS_PGM460                      57857
#define IDS_PGM470                      57858
#define IDS_PGM480                      57859
#define IDS_PGM490                      57860
#define IDS_PGM4A0                      57861
#define IDS_PGM4B0                      57862
#define IDS_PGM4C0                      57863
#define IDS_PGM4D0                      57864
#define IDS_PGM4E0                      57865
#define IDS_PGM4F0                      57866
#define IDS_PGM500                      57867
#define IDS_PGM501                      57868
#define IDS_PGM508                      57869
#define IDS_PGM510                      57870
#define IDS_PGM511                      57871
#define IDS_PGM518                      57872
#define IDS_PGM520                      57873
#define IDS_PGM530                      57874
#define IDS_PGM540                      57875
#define IDS_PGM550                      57876
#define IDS_PGM560                      57877
#define IDS_PGM570                      57878
#define IDS_PGM580                      57879
#define IDS_PGM590                      57880
#define IDS_PGM5A0                      57881
#define IDS_PGM5B0                      57882
#define IDS_PGM5C0                      57883
#define IDS_PGM5D0                      57884
#define IDS_PGM5E0                      57885
#define IDS_PGM5F0                      57886
#define IDS_PGM600                      57887
#define IDS_PGM610                      57888
#define IDS_PGM620                      57889
#define IDS_PGM621                      57890
#define IDS_PGM630                      57891
#define IDS_PGM640                      57892
#define IDS_PGM650                      57893
#define IDS_PGM660                      57894
#define IDS_PGM661                      57895
#define IDS_PGM662                      57896
#define IDS_PGM670                      57897
#define IDS_PGM680                      57898
#define IDS_PGM681                      57899
#define IDS_PGM690                      57900
#define IDS_PGM6A0                      57901
#define IDS_PGM6B0                      57902
#define IDS_PGM6B8                      57903
#define IDS_PGM6C0                      57904
#define IDS_PGM6D0                      57905
#define IDS_PGM6E0                      57906
#define IDS_PGM6F0                      57907
#define IDS_PGM700                      57908
#define IDS_PGM710                      57909
#define IDS_PGM720                      57910
#define IDS_PGM730                      57911
#define IDS_PGM738                      57912
#define IDS_PGM740                      57913
#define IDS_PGM748                      57914
#define IDS_PGM750                      57915
#define IDS_PGM758                      57916
#define IDS_PGM760                      57917
#define IDS_PGM768                      57918
#define IDS_PGM769                      57919
#define IDS_PGM770                      57920
#define IDS_PGM780                      57921
#define IDS_PGM781                      57922
#define IDS_PGM782                      57923
#define IDS_PGM790                      57924
#define IDS_PGM791                      57925
#define IDS_PGM7A0                      57926
#define IDS_PGM7A1                      57927
#define IDS_PGM7A2                      57928
#define IDS_PGM7A3                      57929
#define IDS_PGM7A4                      57930
#define IDS_PGM7A5                      57931
#define IDS_PGM7B0                      57932
#define IDS_PGM7B1                      57933
#define IDS_PGM7B2                      57934
#define IDS_PGM7B3                      57935
#define IDS_PGM7C0                      57936
#define IDS_PGM7C1                      57937
#define IDS_PGM7C2                      57938
#define IDS_PGM7C3                      57939
#define IDS_PGM7C4                      57940
#define IDS_PGM7C5                      57941
#define IDS_PGM7D0                      57942
#define IDS_PGM7D1                      57943
#define IDS_PGM7D2                      57944
#define IDS_PGM7D3                      57945
#define IDS_PGM7D4                      57946
#define IDS_PGM7D5                      57947
#define IDS_PGM7D6                      57948
#define IDS_PGM7D7                      57949
#define IDS_PGM7D8                      57950
#define IDS_PGM7D9                      57951
#define IDS_PGM7E0                      57952
#define IDS_PGM7E1                      57953
#define IDS_PGM7E2                      57954
#define IDS_PGM7E3                      57955
#define IDS_PGM7E4                      57956
#define IDS_PGM7E5                      57957
#define IDS_PGM7F0                      57958
#define IDS_PGM7F1                      57959
#define IDS_PGM7F2                      57960
#define IDS_PGM7F3                      57961
#define IDS_DRM000                      57962
#define IDS_DRM080                      57963
#define IDS_DRM100                      57964
#define IDS_DRM180                      57965
#define IDS_DRM190                      57966
#define IDS_DRM200                      57967
#define IDS_DRM280                      57968
#define IDS_DRM300                      57969
#define IDS_DRM380                      57970

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        332
#define _APS_NEXT_COMMAND_VALUE         32847
#define _APS_NEXT_CONTROL_VALUE         531
#define _APS_NEXT_SYMED_VALUE           134
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\DLSDesigner\StereoWave.cpp ===
//////////////////////////////////////////////////////////////////////
//
// StereoWave.cpp : implementation file
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include <mmsystem.h>
#include <mmreg.h>
#include <msacm.h>
#include "DLSDesignerDLL.h"
#include "WaveNode.h"
#include "WaveDataManager.h"
#include "Wave.h"
#include "MonoWave.h"
#include "StereoWave.h"
#include "Region.h"
#include "Collection.h"
#include "DLSLoadSaveUtils.h"
#include "WavePropPgMgr.h"
#include "WavePropPg.h"
#include "WaveInfoPropPg.h"
#include "WaveCompressionPropPage.h"
#include "stream.h" 
#include "Instrument.h"
#include "Wavectl.h"
#include "DlsDefsPlus.h"

 
CStereoWave::CStereoWave(CWaveNode* pWaveNode, BOOL bTrueStereo, DWORD dwSampleRate, UINT nSampleSize) : CWave(pWaveNode, dwSampleRate, nSampleSize, 2), 
m_bIsPlaying(FALSE), 
m_bTrueStereo(FALSE),
m_bLoadingRuntime(false)
{
	m_bTrueStereo = bTrueStereo;

	::CoCreateGuid(&m_guidStereoWave);
	m_pLeftChannel = new CMonoWave(pWaveNode, m_guidStereoWave, false);
	m_pRightChannel = new CMonoWave(pWaveNode, m_guidStereoWave, true);

	if(m_pDataManager == NULL)
	{
		CString sSourceFileName = m_pWaveNode->GetFileName();
		char szTempPath[MAX_PATH];
		DWORD dwSuccess = GetTempPath(MAX_PATH, szTempPath);
		m_pDataManager = new CWaveDataManager(this, sSourceFileName, szTempPath);
	}
}

CStereoWave::CStereoWave(CWaveNode* pWaveNode, GUID guidStereoWave, DWORD dwSampleRate, UINT nSampleSize) : CWave(pWaveNode, dwSampleRate, nSampleSize, 2), 
m_guidStereoWave(guidStereoWave),
m_bIsPlaying(FALSE),
m_bTrueStereo(FALSE),
m_bLoadingRuntime(false)
{
	m_pLeftChannel = new CMonoWave(pWaveNode, m_guidStereoWave, false);
	m_pRightChannel = new CMonoWave(pWaveNode, m_guidStereoWave, true);

	if(m_pDataManager == NULL)
	{
		CString sSourceFileName = m_pWaveNode->GetFileName();
		char szTempPath[MAX_PATH];
		DWORD dwSuccess = GetTempPath(MAX_PATH, szTempPath);
		m_pDataManager = new CWaveDataManager(this, sSourceFileName, szTempPath);
	}
}


CStereoWave::~CStereoWave()
{
	if(m_pLeftChannel)
	{
		delete m_pLeftChannel;
		m_pLeftChannel = NULL;
	}

	if(m_pRightChannel)
	{
		delete m_pRightChannel;
		m_pRightChannel = NULL;
	}
}
 

HRESULT CStereoWave::LoadHeader(IDMUSProdRIFFStream* pIRiffStream, MMCKINFO* pckMain)
{
	ASSERT(pIRiffStream);
	if(pIRiffStream == NULL)
	{
		return E_POINTER;
	}

	ASSERT(pckMain);
	if(pckMain == NULL)
	{
		return E_POINTER;
	}

	ASSERT(m_pLeftChannel);
	if(m_pLeftChannel == NULL)
	{
		return E_FAIL;
	}

	ASSERT(m_pRightChannel);
	if(m_pRightChannel == NULL)
	{
		return E_FAIL;
	}

	// This is a wave ina DLS collection and it's either uncompressed 
	// or compressed in a format that the mono channels can deal with
	bool bStereoCompressed = false;
	if(FAILED(IsStereoCompressed(pIRiffStream, pckMain, bStereoCompressed)))
	{
		return E_FAIL;
	}

	m_bCompressed = bStereoCompressed;
	m_pLeftChannel->m_bCompressed = false;
	m_pRightChannel->m_bCompressed = false;

	if(m_pWaveNode->IsInACollection() || !bStereoCompressed)
	{
		if(bStereoCompressed)
		{
			AfxMessageBox(IDS_ERR_INSERT_STEREO_COMPRESSED_WAVE_IN_COLLECTION);
			return E_FAIL;
		}

		IStream* pIStream = pIRiffStream->GetStream();
		ASSERT(pIStream);
		if(pIStream == NULL)
		{
			return E_OUTOFMEMORY;
		}

		// Remember where the stream pointer is positioned
		DWORD dwStreamPosition = StreamTell(pIStream);
		if(SUCCEEDED(m_pRightChannel->LoadHeader(pIRiffStream, pckMain)))
		{
			StreamSeek(pIStream, dwStreamPosition, STREAM_SEEK_SET);
			if(FAILED(m_pLeftChannel->LoadHeader(pIRiffStream, pckMain)))
			{
				pIStream->Release();
				return E_FAIL;
			}
		}
		else
		{
			pIStream->Release();
			return E_FAIL;
		}

		pIStream->Release();
		
		CopyMemory(&m_rWaveformat, &(m_pLeftChannel->m_rWaveformat), sizeof WAVEFORMATEX);
		GetTrueStereoFormat(m_rWaveformat);
		CopyMemory(&(m_OriginalWavObj.WaveFormatEx), &(m_pLeftChannel->m_rWaveformat), sizeof WAVEFORMATEX);
		GetTrueStereoFormat(m_OriginalWavObj.WaveFormatEx);
		m_OriginalWavObj.dwDataSize = m_pLeftChannel->GetUncompressedDataSize() * 2;
		m_dwDataSize = m_pLeftChannel->GetDataSize() * 2;

		// Sync up the info from the loaded mono waves
		SyncWaveProperties(true);
	}
	else
	{
		if(FAILED(CWave::LoadHeader(pIRiffStream, pckMain)))
		{
			return E_FAIL;
		}
	}

	// Update the DirestSoundHeader Stream
	if(SUCCEEDED(UpdateHeaderStream()))
	{
		m_pWaveNode->ReloadDirectSoundWave();
		NotifyWaveChange(false);
	}
	
	return S_OK;
}


HRESULT CStereoWave::LoadData(IDMUSProdRIFFStream* pIRiffStream, MMCKINFO* pckMain)
{
	ASSERT(pIRiffStream);
	if(pIRiffStream == NULL)
	{
		return E_POINTER;
	}

	ASSERT(pckMain);
	if(pckMain == NULL)
	{
		return E_POINTER;
	}

	ASSERT(m_pLeftChannel);
	if(m_pLeftChannel == NULL)
	{
		return E_FAIL;
	}

	ASSERT(m_pRightChannel);
	if(m_pRightChannel == NULL)
	{
		return E_FAIL;
	}

	// This is a wave in a DLS collection and it's either uncompressed 
	// or compressed in a format that the mono channels can deal with
	bool bStereoCompressed = false;
	if(FAILED(IsStereoCompressed(pIRiffStream, pckMain, bStereoCompressed)))
	{
		return E_FAIL;
	}

	if(m_pWaveNode->IsInACollection() || !bStereoCompressed)
	{
		// Load the data
		BYTE* pbData = NULL;
		DWORD cb = 0;
		if(FAILED(GetData(0, m_dwWaveLength, &pbData, cb)))
		{
			delete[] pbData;
			return E_FAIL;
		}

		// Set the data for the channels
		DMUSP_WAVEOBJECT stereoWave;
		stereoWave.dwDataSize = m_dwDataSize;
		stereoWave.pbData = pbData;
		stereoWave.WaveFormatEx = m_rWaveformat;
		stereoWave.pbExtractWaveFormatData = NULL;
		
		if(FAILED(m_pRightChannel->SetUncompressedData(stereoWave)))
		{
			delete[]  pbData;
			return E_FAIL;
		}

		if(FAILED(m_pLeftChannel->SetUncompressedData(stereoWave)))
		{
			delete[]  pbData;
			return E_FAIL;
		}

		if(FAILED(InterleaveChannelsForStereoData()))
		{
			delete[]  pbData;
			return E_FAIL;
		}

		m_OriginalWavObj.dwDataSize = m_pLeftChannel->GetUncompressedDataSize() + m_pRightChannel->GetUncompressedDataSize();
	}
	else
	{
		HRESULT hr = E_FAIL;
		MMCKINFO ck;
		ck.ckid = FOURCC_DATA;

		if(pIRiffStream->Descend(&ck, pckMain, MMIO_FINDCHUNK) == 0)
		{
			BYTE* pbData = m_OriginalWavObj.pbData;
			if(m_bCompressed && m_bLoadingRuntime)
			{
				pbData = m_CompressedWavObj.pbData;
			}

			if(FAILED(SafeAllocBuffer(&pbData, ck.cksize)))
			{
				return E_OUTOFMEMORY;
			}

			IStream* pIStream = pIRiffStream->GetStream();
			ASSERT(pIStream);
			if(pIStream == NULL)
			{
				return E_OUTOFMEMORY;
			}

			if(FAILED(CWave::ReadData(pIStream, pckMain, 0, ck.cksize, pbData)))
			{
				delete[] pbData;
				pIStream->Release();
				return E_FAIL;
			}

			pIStream->Release();

			if(m_bLoadingRuntime)
			{
				if(FAILED(UpdateDecompressedWave(&m_OriginalWavObj.WaveFormatEx)))
				{
					return E_FAIL;
				}
			}
			else
			{
				// Set the uncompressed data for the channels first
				if(FAILED(m_pLeftChannel->SetUncompressedData(m_OriginalWavObj)))
					return E_FAIL;
				if(FAILED(m_pRightChannel->SetUncompressedData(m_OriginalWavObj)))
					return E_FAIL;
				
				// Now compress and update the compressed data
				WAVEFORMATEX wfxPCM;
				GetTrueStereoFormat(wfxPCM);
				DWORD dwDataSize = GetUncompressedDataSize();
				
				BYTE* pwfxDst = NULL;
				if(FAILED(SafeAllocBuffer(&pwfxDst, sizeof WAVEFORMATEX + m_CompressedWavObj.WaveFormatEx.cbSize)))
				{
					return E_OUTOFMEMORY;
				}

				CopyMemory(pwfxDst, &m_CompressedWavObj.WaveFormatEx, sizeof WAVEFORMATEX);
				CopyMemory(pwfxDst + sizeof WAVEFORMATEX, m_CompressedWavObj.pbExtractWaveFormatData, m_CompressedWavObj.WaveFormatEx.cbSize);

				if(SUCCEEDED(ConvertStereoData(m_OriginalWavObj, ((WAVEFORMATEX*)pwfxDst), m_CompressedWavObj, true)))
				{
					m_bCompressed = true;
					if(FAILED(UpdateDecompressedWave(&wfxPCM)))
					{
						// Need to put up a messagebox
						SwitchCompression(false);
					}

					delete[] pwfxDst;
					return S_OK;
				}
				
				delete[] pwfxDst;
			}
		}
	}

	return S_OK;
}

HRESULT CStereoWave::ReadWVST(IStream* pIStream, MMCKINFO* pckMain)
{
	return S_OK;
}


HRESULT CStereoWave::IsStereoCompressed(IDMUSProdRIFFStream* pIRiffStream, MMCKINFO* pckMain, bool& bStereoCompressed)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT(pIRiffStream);
	if(pIRiffStream == NULL)
		return E_POINTER;

	IStream* pIStream = pIRiffStream->GetStream();
	ASSERT(pIStream);
	if(pIStream == NULL)
		return E_FAIL;

	// Remember where the stream pointer is positioned
	DWORD dwStreamPosition = StreamTell(pIStream);

	HRESULT hr = S_OK;
	DWORD cSize = 0;
	MMCKINFO ck;
	ck.ckid = mmioFOURCC('w','a','v','u');
	if(pIRiffStream->Descend(&ck, pckMain, MMIO_FINDCHUNK) == 0) 
	{
		DWORD cb = 0;

		// Read the flag which indiactes Runtime or Designtime File
		hr = pIStream->Read(&m_bLoadingRuntime, sizeof bool, &cb);
		if(FAILED(hr) || cb != sizeof bool)
		{
			pIStream->Release();
			return hr;
		}


		// Read the flag that indicates compression
		hr = pIStream->Read(&m_bCompressed, sizeof bool, &cb);
		if(FAILED(hr) || cb != sizeof bool)
		{
			pIStream->Release();
			return hr;
		}
		
		// Read the WAVEFORMATEX data for the compressed wave
		WAVEFORMATEX stereoCompressionFormat;
		hr = pIStream->Read((LPSTR) &(stereoCompressionFormat), sizeof WAVEFORMATEX, &cb);	
		if (FAILED(hr) || cb != sizeof WAVEFORMATEX)
		{
			m_bCompressed = false;
			return E_FAIL;
		}

		BYTE* pbExtraInfo = NULL;
		if(stereoCompressionFormat.cbSize)
		{
			if(FAILED(SafeAllocBuffer(&pbExtraInfo, stereoCompressionFormat.cbSize)))
			{
				return E_OUTOFMEMORY;
			}

			if(FAILED(pIStream->Read(pbExtraInfo, stereoCompressionFormat.cbSize, &cb)))
			{
				delete[] pbExtraInfo;
			}
		}

		// We keep the compression info in designtime files / decompression info in runtime files
		if(m_bCompressed)
		{
			if(!m_bLoadingRuntime && stereoCompressionFormat.nChannels == 2)
			{
				bStereoCompressed = true;
				if(m_CompressedWavObj.pbExtractWaveFormatData)
				{
					delete[] m_CompressedWavObj.pbExtractWaveFormatData;
					m_CompressedWavObj.pbExtractWaveFormatData = NULL;
				}

				CopyMemory(&m_CompressedWavObj.WaveFormatEx, &stereoCompressionFormat, sizeof(WAVEFORMATEX));
				m_CompressedWavObj.pbExtractWaveFormatData = pbExtraInfo;
			}
			else if(m_bLoadingRuntime && stereoCompressionFormat.nChannels == 2)
			{
				bStereoCompressed = true;

				// This is really a PCM format that we want to decompress to
				CopyMemory(&m_OriginalWavObj.WaveFormatEx, &stereoCompressionFormat, sizeof(WAVEFORMATEX));
			}
		}
	}
	else
	{
		ck.ckid = mmioFOURCC('f','m','t',' ');
		StreamSeek(pIStream, dwStreamPosition, STREAM_SEEK_SET);
		if(pIRiffStream->Descend(&ck, pckMain, MMIO_FINDCHUNK) == 0)
		{
			WAVEFORMATEX wfxTemp;
			if(ck.cksize < sizeof(WAVEFORMATEX))
			{
				cSize = ck.cksize;
			}
			else
			{
				cSize = sizeof(WAVEFORMATEX);
			}

			DWORD cb = 0;
			hr = pIStream->Read(&wfxTemp, cSize, &cb);
			if(FAILED(hr) || cb != cSize)
			{
				pIStream->Release();
				pIRiffStream->Ascend(&ck, 0);
				return E_FAIL;
			}

			if(wfxTemp.wFormatTag != WAVE_FORMAT_PCM)
			{
				m_bLoadingRuntime = true;
				bStereoCompressed = true;

				CopyMemory(&m_CompressedWavObj.WaveFormatEx, &wfxTemp, sizeof(WAVEFORMATEX));
				
				if(m_CompressedWavObj.pbExtractWaveFormatData)
				{
					delete[] m_CompressedWavObj.pbExtractWaveFormatData;
					m_CompressedWavObj.pbExtractWaveFormatData = NULL;
				}

				if(FAILED(SafeAllocBuffer(&m_CompressedWavObj.pbExtractWaveFormatData, wfxTemp.cbSize)))
				{
					pIStream->Release();
					pIRiffStream->Ascend(&ck, 0);
					return E_OUTOFMEMORY;
				}

				if(FAILED(pIStream->Read(m_CompressedWavObj.pbExtractWaveFormatData, wfxTemp.cbSize, &cb)))
				{
					delete[] m_CompressedWavObj.pbExtractWaveFormatData;
					pIStream->Release();
					pIRiffStream->Ascend(&ck, 0);
					return E_FAIL;
				}
			}
			else
			{
				bStereoCompressed = false;
			}
		}
	}

	StreamSeek(pIStream, dwStreamPosition, STREAM_SEEK_SET );
	pIStream->Release();

	return hr;
}


HRESULT CStereoWave::LoadCompressedStereoData(IDMUSProdRIFFStream* pIRiffStream, MMCKINFO* pckMain)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT(pIRiffStream);
	if(pIRiffStream == NULL)
		return E_POINTER;

	bool bReadWSMPL = false;
	bool bReadRSMPL = false;

	MMCKINFO ck;
	ck.ckid = 0;
	ck.fccType = 0;
	while( pIRiffStream->Descend( &ck, pckMain, 0 ) == 0 )
	{
		switch (ck.ckid) 
        {
			case mmioFOURCC('f','m','t',' '):
			{
				if(FAILED(ReadFormatChunk(pIRiffStream)))
				{
					return E_FAIL;
				}
			
				break;
			}

			case FOURCC_WSMP:
			{
				if(FAILED(ReadWSMPLChunk(pIRiffStream, ck.cksize)))
				{
					return E_FAIL;
				}

				bReadWSMPL = true;
				break;
			}

			case mmioFOURCC('s','m','p','l'):
			{
				if(FAILED(ReadRSMPLChunk(pIRiffStream, ck.cksize)))
				{
					return E_FAIL;	
				}
				
				bReadRSMPL = true;
				break;
			}

			case mmioFOURCC('d','a','t','a'):
			{
				HRESULT hr = E_FAIL;
				BYTE* pbDataBuffer = NULL;
				if(m_bLoadingRuntime && m_bCompressed)
				{
					m_CompressedWavObj.pbData = new BYTE[ck.cksize];
					pbDataBuffer = m_CompressedWavObj.pbData;
					m_CompressedWavObj.dwDataSize = ck.cksize;
				}
				else if(!m_bCompressed || !m_bLoadingRuntime)
				{
					m_OriginalWavObj.pbData = new BYTE[ck.cksize];
					pbDataBuffer = m_OriginalWavObj.pbData;
					m_OriginalWavObj.dwDataSize = ck.cksize;
				}

				if(pbDataBuffer == NULL)
				{
					return E_OUTOFMEMORY;
				}

				IStream* pIStream = pIRiffStream->GetStream();
				ASSERT(pIStream);
				if(pIStream == NULL)
					return E_FAIL;
								
				DWORD cb = 0;
				hr = pIStream->Read(pbDataBuffer, ck.cksize, &cb);
				if(FAILED(hr) || cb != ck.cksize)
				{
					pIStream->Release();
					return E_FAIL;
				}

				pIStream->Release();			

				break;
			}
			
			case mmioFOURCC('f','a','c','t'):
            case FOURCC_EDIT: 
			{
                break;
			}

			case FOURCC_LIST:
			{
				switch (ck.fccType)
				{
					case mmioFOURCC('I','N','F','O') :
					{
						m_Info.Load(pIRiffStream, &ck);
						break;
					}
					default:
					{
						// Compensation for fccType field : 
						// Descend puts the stream pointer after the fccType field 
						// but the size is still the old size so we need to adjust that
						ck.cksize -= sizeof DWORD; 
						m_UnknownChunk.Load(pIRiffStream, &ck, TRUE);
						
						// Reset the size so Ascend call goes through  properly
						ck.cksize += sizeof DWORD; 
						break;
					}
				}

				break;
			}
			
			default:
			{
                m_UnknownChunk.Load(pIRiffStream, &ck, FALSE);
                break;
			}
		}
		
		pIRiffStream->Ascend( &ck, 0 );
		ck.ckid = 0;
		ck.fccType = 0;
	}

	// Always give precedence to the legacy RSMPL loop structure
	// Otherwise we might end up ignoring changes made to the wave 
	// files in SoundForge etc. which also have WSMPL chunks in them
	if (bReadRSMPL)
    {
		// The RSMPL structure field dwMIDIPitchFraction keeps a +ve value 
		// that is the fraction of a semitone above the untiy note
		// WSMP on the other hand let's you have a fine tune value between 
		// -12 to +12 semitones. Since we always give RSMPL chunk the precedence 
		// copying the RSMPL values into WSMPL struct will make the unitynote 
		// and fine tune values jump which results in some problems...
		// So we check if the values are basically the same and if they are we use
		// the WSMPL values instead of RSMPL. Easy enough?
		short sUnityNote = m_rWSMP.usUnityNote;
		short sFineTune = m_rWSMP.sFineTune;
		CopySMPLToWSMP();
		if(IsUnityNoteAndFractionSame(m_rRSMPL, sUnityNote, sFineTune))
		{
			m_rWSMP.usUnityNote = sUnityNote;
			m_rWSMP.sFineTune = sFineTune;
		}

	}
	else
	{
		CopyWSMPToSMPL();
	}

	// Set the loop flag
	if(m_rWSMP.cSampleLoops > 0)
		m_bPlayLooped = true;
	else
		m_bPlayLooped = false;

	// Validate the loop values...
	// These might have been set to illegal values outside Producer
	if(m_rWLOOP.ulStart > m_dwWaveLength)
		m_rWLOOP.ulStart = 0;
	if(m_rWLOOP.ulStart + m_rWLOOP.ulLength > m_dwWaveLength)
		m_rWLOOP.ulLength = m_dwWaveLength - m_rWLOOP.ulStart;


	SyncWaveProperties(false);

    return S_OK;
}



HRESULT CStereoWave::Load(IDMUSProdRIFFStream* pIRiffStream, MMCKINFO* pckMain, bool bLoadRightChannel)
{
	ASSERT(m_pWaveNode);
	if(m_pWaveNode == NULL)
	{
		return E_UNEXPECTED;
	}

	ASSERT(m_pLeftChannel);
	if(m_pLeftChannel == NULL)
		return E_FAIL;
	ASSERT(m_pRightChannel);
	if(m_pRightChannel == NULL)
		return E_FAIL;

	HRESULT hr = E_FAIL;

	if(bLoadRightChannel)
	{
		hr = m_pRightChannel->Load(pIRiffStream, pckMain);
	}
	else
	{
		hr = m_pLeftChannel->Load(pIRiffStream, pckMain);
	}

    m_OriginalWavObj.dwDataSize = m_pLeftChannel->GetUncompressedDataSize() * 2;

	// Sync up the info from the loaded mono waves
	SyncWaveProperties(true);

	return hr;
}

HRESULT CStereoWave::UpdateWave()
{
	ASSERT(m_pLeftChannel);
	ASSERT(m_pRightChannel);

	SyncWaveProperties(true);

	if(FAILED(m_pLeftChannel->UpdateWave()))
		return E_FAIL;
	
	if(FAILED(m_pRightChannel->UpdateWave()))
		return E_FAIL;

	return S_OK;
}

HRESULT	CStereoWave::UpdateDecompressedWave(const WAVEFORMATEX* pwfxDst)
{
	ASSERT(m_pLeftChannel);
	ASSERT(m_pRightChannel);

	if(m_pCollection)
	{
		if(FAILED(m_pLeftChannel->UpdateDecompressedWave(pwfxDst)))
			return E_FAIL;
		
		if(FAILED(m_pRightChannel->UpdateDecompressedWave(pwfxDst)))
			return E_FAIL;

		SyncWaveProperties(true);
		return S_OK;
	}
	else if(m_bCompressed)
	{
		if(SUCCEEDED(ConvertStereoData(m_CompressedWavObj, pwfxDst, m_DecompressedWavObj, false)))
		{
			if(FAILED(UpdateChannelsForStereoCompression()))
			{
				SwitchCompression(false);
				return E_FAIL;
			}

			SyncWaveProperties(true);
			return S_OK;
		}
		else
		{
			SwitchCompression(false);
			return E_FAIL;
		}
	}

	return E_FAIL;
}


HRESULT	CStereoWave::SwitchCompression(bool bSwitch)
{
	ASSERT(m_pLeftChannel);
    if(m_pLeftChannel == NULL)
    {
        return E_UNEXPECTED;
    }

	ASSERT(m_pRightChannel);
    if(m_pRightChannel == NULL)
    {
        return E_UNEXPECTED;
    }
	
	// no work to do if already pointing to appropriate wave
	if (m_bCompressed == bSwitch)
		return S_OK;

	if(m_pCollection || !bSwitch)
	{
		m_pLeftChannel->SetWaveBufferToCompressed(bSwitch);
		m_pRightChannel->SetWaveBufferToCompressed(bSwitch);
	}
	else if(bSwitch)
	{
		if(FAILED(UpdateChannelsForStereoCompression()))
			return E_FAIL;
	}

    m_bCompressed = bSwitch;

	SyncWaveProperties(true);

    // Update the header stream
	if(SUCCEEDED(UpdateHeaderStream()))
	{
		m_pWaveNode->ReloadDirectSoundWave();
	}

    RefreshDrawBuffer();

	CWaveCtrl* pWaveEditor = m_pWaveNode->GetWaveEditor();
	if(pWaveEditor)
	{
		pWaveEditor->InvalidateControl(); // Repaint the wave with new values
	}

	return S_OK;
}


HRESULT	CStereoWave::OnWaveBufferUpdated()
{
	ASSERT(m_pLeftChannel);
	if(m_pLeftChannel == NULL)
		return E_FAIL;

	ASSERT(m_pRightChannel);
	if(m_pRightChannel == NULL)
		return E_FAIL;

	if(SUCCEEDED(m_pLeftChannel->OnWaveBufferUpdated()))
	{
		if(SUCCEEDED(m_pRightChannel->OnWaveBufferUpdated()))
		{
			m_dwDataSize = m_pLeftChannel->GetDataSize() * 2;
			if (!m_bCompressed)
				m_OriginalWavObj.dwDataSize = m_dwDataSize;

			SyncWaveProperties(true);
			UpdateDummyInstrument();
			
			if(FAILED(CWave::OnWaveBufferUpdated()))
			{
				TRACE("DirectSoundWave header update failed!");
				return E_FAIL;
			}

			return S_OK;
		}
	}

	return E_FAIL;
}

CMonoWave* CStereoWave::GetLeftChannel()
{
	return m_pLeftChannel;
}

CMonoWave* CStereoWave::GetRightChannel()
{
	return m_pRightChannel;
}

HRESULT CStereoWave::Compress(const WAVEFORMATEX* pwfxDst, bool bInUndoRedo)
{
	ASSERT(m_pLeftChannel);
	if(m_pLeftChannel == NULL)
		return E_FAIL;

	ASSERT(m_pRightChannel);
	if(m_pRightChannel == NULL)
		return E_FAIL;

	if(m_pCollection)
	{
		if(SUCCEEDED(m_pLeftChannel->Compress(pwfxDst, bInUndoRedo)))
		{
			if(SUCCEEDED(m_pRightChannel->Compress(pwfxDst, bInUndoRedo)))
			{
				SyncWaveProperties(true);
				return S_OK;
			}
		}
	}
	else
	{
		if(FAILED(CompressStereoData(pwfxDst, bInUndoRedo)))
			return E_FAIL;

		return S_OK;
	}

	return E_FAIL;
}


HRESULT CStereoWave::CompressStereoData(const WAVEFORMATEX* pwfxDest, bool bInUndoRedo)
{
	ASSERT(pwfxDest);
	if(pwfxDest == NULL)
	{
		return E_POINTER;
	}

	ASSERT(m_pDataManager);
	if(m_pDataManager == NULL)
	{
		return E_FAIL;
	}

    // Update the uncompressed deltas if we're not already compressed
    if(!m_bCompressed && !bInUndoRedo)
    {
        if(FAILED(m_pDataManager->UpdateUncompressedDeltas()))
        {
            return E_FAIL;
        }
    }

	// Ask the data manager to recreate the decomp file
	if(FAILED(m_pDataManager->CreateDecompFile()))
	{
		return E_FAIL;
	}

	int nBytesPerSample = m_OriginalWavObj.WaveFormatEx.wBitsPerSample / 8;
    DWORD dwDataSize = m_OriginalWavObj.dwDataSize;
    DWORD dwWaveLength = (nBytesPerSample == 1) ? (dwDataSize / 2) : ((dwDataSize >> 1) / 2);

	// Remember the old wavelength
	DWORD dwOldLength = dwWaveLength;

	// We have to compress the wave in chunks
	DWORD dwSamplesCompressed = 0;
	DWORD dwSamplesToCompress = dwWaveLength * 2;
	
	DWORD dwCompressedSize = 0;
	DWORD dwDecompressedSize = 0;

	// Get data in chunks of WAVE_DATA_BUFFER_SIZE 
	while(dwSamplesCompressed < dwWaveLength)
	{
		BYTE* pbData = NULL;
		//DWORD dwLength = WAVE_DATA_BUFFER_SIZE;
		DWORD dwLength = dwWaveLength;
		dwSamplesToCompress = dwWaveLength - dwSamplesCompressed;
		
		// Take the big slice for the last chunk....
		// The conversion might fail if we take very small amount of data
		if(dwSamplesToCompress <= WAVE_DATA_BUFFER_SIZE * 2)
		{
			dwLength = dwSamplesToCompress;
		}

		DWORD cb = 0;
		if(FAILED(GetData(dwSamplesCompressed, dwLength, &pbData, cb, true)))
		{
			return E_FAIL;
		}

		// Now compress the data
		DWORD dwSourceSize = dwLength * nBytesPerSample * 2;
		BYTE* pbCompressed = NULL;
		DWORD dwCompressed = 0;
		if(FAILED(ConvertWave(&m_rWaveformat, pwfxDest, pbData, dwSourceSize, &pbCompressed, dwCompressed)))
		{
			delete[] pbData;
			return E_FAIL;
		}

		dwCompressedSize += dwCompressed;
		
		// Update the number of samples successfully compressed
		dwSamplesCompressed += dwLength;
		dwSamplesToCompress -= m_dwWaveLength - dwSamplesCompressed;

		// Now decompress the compressed data and give it to data manager
		BYTE* pbDecompressed = NULL;
		DWORD dwDecompressed = 0;
		if(FAILED(ConvertWave(pwfxDest, &m_rWaveformat, pbCompressed, dwCompressed, &pbDecompressed, dwDecompressed)))
		{
			delete[] pbData;
			delete[] pbCompressed;
			return E_FAIL;
		}

		dwDecompressedSize += dwDecompressed;
		
		delete[] pbData;
		delete[] pbCompressed;

		// Ask the data manager to write the decompressed buffer to the decomp file
		if(FAILED(m_pDataManager->WriteDecompressedData(pbDecompressed, dwDecompressed)))
		{
			delete[] pbDecompressed;
			return E_FAIL;
		}

		delete[] pbDecompressed;
	}

	// Reset the compression info
	CleanWaveObject(&m_CompressedWavObj);
	m_CompressedWavObj.dwDataSize = dwCompressedSize;
	CopyMemory(&(m_CompressedWavObj.WaveFormatEx), pwfxDest, sizeof(WAVEFORMATEX));
	if(pwfxDest->cbSize)
	{
		if(FAILED(SafeAllocBuffer(&(m_CompressedWavObj.pbExtractWaveFormatData), pwfxDest->cbSize)))
		{
			return E_OUTOFMEMORY;
		}
		CopyMemory(m_CompressedWavObj.pbExtractWaveFormatData, ((BYTE*)pwfxDest) + sizeof(WAVEFORMATEX), pwfxDest->cbSize);
	}

	// Reset the decompression info	
	CleanWaveObject(&m_DecompressedWavObj);
	m_DecompressedWavObj.dwDataSize = dwDecompressedSize;
	CopyMemory(&(m_DecompressedWavObj.WaveFormatEx), &m_rWaveformat, sizeof(WAVEFORMATEX));


	// Our wavelength has possibly changed 
    m_dwDataSize = dwDecompressedSize;
	m_dwWaveLength = (dwDecompressedSize / nBytesPerSample) / 2;
	
	// Mark the wave as compressed...
	m_bCompressed = true;

	// Mark the channels for compression
	m_pLeftChannel->m_bCompressed = true;
	m_pRightChannel->m_bCompressed = true;

	// Update the loop points if it's looped...
	if(m_bPlayLooped)
	{
		LONG lDifference = m_dwWaveLength - dwOldLength;
		m_rWLOOP.ulStart += lDifference;
		m_rWLOOP.ulStart = max(0, ((long)m_rWLOOP.ulStart));
		m_rWLOOP.ulStart = min(((long)m_rWLOOP.ulStart), (long)m_dwWaveLength);
		m_rWLOOP.ulLength = min(m_rWLOOP.ulLength, m_dwWaveLength - m_rWLOOP.ulStart);
		
		m_rRLOOP.dwStart = m_rWLOOP.ulStart;
		m_rRLOOP.dwEnd = m_rWLOOP.ulStart + m_rWLOOP.ulLength - 1;
	}

	if(FAILED(UpdateChannelsForStereoCompression()))
	{
		return E_FAIL;
	}

	return S_OK;
}




HRESULT CStereoWave::Download(IDirectMusicPortDownload* pIDMPortDownload)
{
	// Validate the passed port and the waves for both the channels
	ASSERT(pIDMPortDownload);
	if(pIDMPortDownload == NULL)
		return E_POINTER;

	ASSERT(m_pLeftChannel);
	if(m_pLeftChannel == NULL)
		return E_FAIL;

	ASSERT(m_pRightChannel);
	if(m_pRightChannel == NULL)
		return E_FAIL;

	if(FAILED(m_pLeftChannel->Download(pIDMPortDownload)))
		return E_FAIL;

	if(FAILED(m_pRightChannel->Download(pIDMPortDownload)))
		return E_FAIL;

	if(m_pDummyInstrument)
	{
		CDLSComponent* pComponent = m_pWaveNode->GetComponent();
		ASSERT(pComponent);

		POSITION position = pComponent->m_lstDLSPortDownload.GetHeadPosition();
		while(position)
		{
			IDirectMusicPortDownload* pIDMPortDownload = pComponent->m_lstDLSPortDownload.GetNext(position);
			ASSERT(pIDMPortDownload);
			m_pDummyInstrument->DM_Init(pIDMPortDownload);
			m_pDummyInstrument->Download(pIDMPortDownload);
		}
		
		m_pDummyInstrument->UpdatePatch();
	}

	return S_OK;
}

void CStereoWave::UpdateLoopInRegions()
{
	ASSERT(m_pLeftChannel);
	if(m_pLeftChannel == NULL)
		return;
	
	ASSERT(m_pRightChannel);
	if(m_pRightChannel == NULL)
		return;

	m_pLeftChannel->UpdateLoopInRegions();
	m_pRightChannel->UpdateLoopInRegions();

	CWave::UpdateLoopInRegions();

	// Sync up the info from the loaded mono waves
	SyncWaveProperties(true);
}

HRESULT CStereoWave::DM_Init(IDirectMusicPortDownload* pIDMPortDownload)
{
	ASSERT(pIDMPortDownload);
	if(pIDMPortDownload == NULL)
	{ 
		return E_POINTER;
	}

	ASSERT(m_pLeftChannel);
	if(m_pLeftChannel == NULL)
	{
		return E_FAIL;
	}
	
	ASSERT(m_pRightChannel);
	if(m_pRightChannel == NULL)
	{
		return E_FAIL;
	}

	HRESULT hr = E_FAIL;
	if(SUCCEEDED(hr = m_pLeftChannel->DM_Init(pIDMPortDownload)))
	{
		hr = m_pRightChannel->DM_Init(pIDMPortDownload);
	}

	return hr;
}

HRESULT CStereoWave::Unload(IDirectMusicPortDownload* pIDMPortDownload)
{
	ASSERT(pIDMPortDownload);
	if(pIDMPortDownload == NULL)
	{
		return E_POINTER;
	}

	ASSERT(m_pLeftChannel);
	if(m_pLeftChannel == NULL)
	{
		return E_FAIL;
	}
	
	ASSERT(m_pRightChannel);
	if(m_pRightChannel == NULL)
	{
		return E_FAIL;
	}

	HRESULT hr = E_FAIL;
	if(SUCCEEDED(hr = m_pLeftChannel->Unload(pIDMPortDownload)))
	{
		hr = m_pRightChannel->Unload(pIDMPortDownload);
	}

	// Unload the dummy instrument first
	if(m_pDummyInstrument)
	{
		if(FAILED(m_pDummyInstrument->Unload(pIDMPortDownload)))
			return E_FAIL;
	}

	return hr;
}

HRESULT CStereoWave::SaveAs(IStream* pIStream, bool bPromptForFileName)
{
	// If we need a name call the base class saveas method
	if(bPromptForFileName)
	{
		return CWave::SaveAs(pIStream, bPromptForFileName);
	}

	if(pIStream)
	{
		return SaveAs(pIStream);
	}

	return E_POINTER;
}


// Saves the out as a true stereo wave file
HRESULT CStereoWave::SaveAs(IStream* pIStream)
{
	ASSERT(pIStream);
	if(pIStream == NULL)
		return E_POINTER;

	if(FAILED(Save(pIStream)))
	{
		return E_FAIL;
	}
	
	return S_OK;
}

HRESULT CStereoWave::Save(IStream* pIStream)
{
	ASSERT(pIStream);
	if(pIStream == NULL)
	{
		return E_POINTER;
	}

    ASSERT(m_pDataManager);
    if(m_pDataManager == NULL)
    {
        return E_UNEXPECTED;
    }

    // Ask the data mnager to update the uncomrpessed deltas
    if(!m_bCompressed)
    {
        if(FAILED(m_pDataManager->UpdateUncompressedDeltas()))
        {
            return E_FAIL;
        }
    }


	IDMUSProdRIFFStream* pIRiffStream = NULL;
	if(FAILED(AllocRIFFStream(pIStream, &pIRiffStream)))
	{
		return E_FAIL;
	}

	bool bRuntime = false;
	IDMUSProdPersistInfo* pIJazzPersistInfo;
	if(SUCCEEDED(pIStream->QueryInterface(IID_IDMUSProdPersistInfo,(void**) &pIJazzPersistInfo)))
	{
		DMUSProdStreamInfo	StreamInfo;
		FileType	ftSaveType;

		pIJazzPersistInfo->GetStreamInfo(&StreamInfo);
		ftSaveType = StreamInfo.ftFileType;

		if (ftSaveType == FT_RUNTIME)
			bRuntime = true;
		
		pIJazzPersistInfo->Release();		
	}

	// Create wave riff header
	m_dwHeaderOffset = GetFilePos(pIStream);

	MMCKINFO ckMain;
	ckMain.fccType = mmioFOURCC('W','A','V','E'); 
	if(FAILED(pIRiffStream->CreateChunk(&ckMain, MMIO_CREATERIFF)))
	{
		pIRiffStream->Release();
		return E_FAIL;
	}

	// Write the GUID chunk
	if(FAILED(CWave::WriteGUIDChunk(pIRiffStream)))
	{
		pIRiffStream->Release();
		return E_FAIL;
	}


	// Write the compression information
	if(m_bCompressed)
	{
		if(FAILED(WriteCompressionChunk(pIRiffStream, bRuntime)))
		{
			pIRiffStream->Release();
			return E_FAIL;
		}
	}

	// Save the 'wavh' chunk that keeps the streaming info
	MMCKINFO ck;
	ck.ckid = DMUS_FOURCC_WAVEHEADER_CHUNK;
	HRESULT hr = pIRiffStream->CreateChunk(&ck, 0);
    if (FAILED(hr))
    {
		pIStream->Release();
        return hr;
    }

	_DMUS_IO_WAVE_HEADER waveHeader;
	if(FAILED(CWave::GetStreamingWaveHeader(&waveHeader)))
	{
		pIStream->Release();
		return E_FAIL;
	}

	DWORD cb = 0;
	hr = pIStream->Write((LPSTR)&waveHeader, sizeof(_DMUS_IO_WAVE_HEADER), &cb);
	if(FAILED(hr) || cb != sizeof(_DMUS_IO_WAVE_HEADER))
	{
		pIStream->Release();
		return E_FAIL;
	}
	
	if (FAILED(pIRiffStream->Ascend(&ck, 0)))
	{
		pIStream->Release();
		return E_FAIL;
	}



	if(FAILED(WriteStereoFormat(pIRiffStream, bRuntime)))
	{
		pIRiffStream->Release();
		return E_FAIL;
	}

	if(!bRuntime || !m_bCompressed)
	{
		if(FAILED(WriteStereoData(pIRiffStream, bRuntime)))
		{
			pIRiffStream->Release();
			return E_FAIL;
		}
	}
	else
	{
		if(FAILED(WriteFACTChunk(pIRiffStream)))
		{
			pIRiffStream->Release();
			return E_FAIL;
		}

		if(FAILED(WriteCompressedData(pIRiffStream)))
		{
			pIRiffStream->Release();
			return E_FAIL;
		}
	}
	
	if(FAILED(WriteRSMPLChunk(pIRiffStream)))
	{
		pIRiffStream->Release();
		return E_FAIL;
	}

	if(FAILED(WriteWSMPLChunk(pIRiffStream)))
	{
		pIRiffStream->Release();
		return E_FAIL;
	}

	if(FAILED(m_Info.Save(pIRiffStream)))
	{
		pIRiffStream->Release();
		return E_FAIL;
	}

	pIRiffStream->Ascend(&ckMain, 0);
	pIRiffStream->Release();

	return S_OK;
}


HRESULT CStereoWave::WriteStereoFormat(IDMUSProdRIFFStream* pIRiffStream, bool bRuntime)
{
	ASSERT(pIRiffStream);
	if(pIRiffStream == NULL)
	{
		return E_POINTER;
	}

	IStream* pIStream = pIRiffStream->GetStream();
	ASSERT(pIStream);
	if(pIStream == NULL)
	{
		return E_POINTER;
	}

	WAVEFORMATEX wfxPCM;
	WAVEFORMATEX* pStereoFormat = NULL;
	BYTE* pbExtraInfo = NULL;
	if(!m_bCompressed || !bRuntime)
	{
		GetTrueStereoFormat(wfxPCM);
		pStereoFormat = &wfxPCM;
	}
	else if(m_bCompressed && bRuntime)
	{
		pStereoFormat = &(m_CompressedWavObj.WaveFormatEx);
		pbExtraInfo = m_CompressedWavObj.pbExtractWaveFormatData;
	}
	
	// Create format chunk
	MMCKINFO ck;
	DWORD cb = 0;

	ck.ckid = mmioFOURCC('f','m','t',' ');
	if(FAILED(pIRiffStream->CreateChunk(&ck, 0)))
	{
		pIStream->Release();
		return E_FAIL;
	}

	// Write the WAVEFORMATEX
	HRESULT hr = pIStream->Write((LPSTR) pStereoFormat, sizeof WAVEFORMATEX, &cb);	
	if(FAILED(hr) || cb != sizeof WAVEFORMATEX)
	{
		pIStream->Release();
		return E_FAIL;
	}

	// Write the extra info
	hr = pIStream->Write(pbExtraInfo, pStereoFormat->cbSize, &cb);	
	if(FAILED(hr) || cb != pStereoFormat->cbSize)
	{
		pIStream->Release();
		return E_FAIL;
	}
	
	if(FAILED(pIRiffStream->Ascend(&ck, 0)))
	{
		pIStream->Release();
		return E_FAIL;
	}

	pIStream->Release();
	return S_OK;
}


HRESULT CStereoWave::WriteCompressionChunk(IDMUSProdRIFFStream* pIRiffStream, bool bRuntime)
{

	ASSERT(pIRiffStream);
	if(pIRiffStream == NULL)
	{
		return E_POINTER;
	}

	IStream* pIStream = pIRiffStream->GetStream();
	ASSERT(pIStream);
	if(pIStream == NULL)
	{
		return E_POINTER;
	}

	// Compressed wave info chunk
	MMCKINFO ck;
	DWORD cb = 0;

	ck.ckid = mmioFOURCC('w','a','v','u'); 
	if(FAILED(pIRiffStream->CreateChunk(&ck, 0)))
	{
		pIStream->Release();
		return E_FAIL;
	}

	// Save the flag that marks whether this file is Runtime or Designtime
	HRESULT hr = pIStream->Write((LPSTR) &(bRuntime), sizeof bool, &cb);	
	if(FAILED(hr) || cb != sizeof bool)
	{
		pIStream->Release();
		return E_FAIL;
	}

	// Save the flag that marks compression
	hr = pIStream->Write((LPSTR) &(m_bCompressed), sizeof bool, &cb);	
	if(FAILED(hr) || cb != sizeof bool)
	{
		pIStream->Release();
		return E_FAIL;
	}

	// Save the compression format in the wavu chunk if this is not a runtime save
	if(m_bCompressed && bRuntime == false)
	{
		// Save the format header
		hr = pIStream->Write((LPSTR) &(m_CompressedWavObj.WaveFormatEx), sizeof WAVEFORMATEX, &cb);	
		if(FAILED(hr) || cb != sizeof WAVEFORMATEX)
		{
			pIStream->Release();
			return E_FAIL;
		}
		
		// Compressed waves might have extra information in the header
		if(m_CompressedWavObj.WaveFormatEx.cbSize > 0)
		{
			BYTE* pbExtraInfo = m_CompressedWavObj.pbExtractWaveFormatData;
			hr = pIStream->Write(pbExtraInfo, m_CompressedWavObj.WaveFormatEx.cbSize, &cb);
			if(FAILED(hr) || cb != m_CompressedWavObj.WaveFormatEx.cbSize)
			{
				pIStream->Release();
				return E_FAIL;
			}
		}
	}
	if(m_bCompressed && bRuntime)
	{
		WAVEFORMATEX wfxPCM;
		GetTrueStereoFormat(wfxPCM);

		hr = pIStream->Write((LPSTR) &wfxPCM, sizeof WAVEFORMATEX, &cb);	
		if (FAILED(hr) || cb != sizeof WAVEFORMATEX)
		{
			pIStream->Release();
			return E_FAIL;
		}
	}

    // Write the actual start of the decompressed data
    cb = 0;
    hr = pIStream->Write(&m_dwDecompressedStart, sizeof(DWORD), &cb);
    if(FAILED(hr) || cb != sizeof(DWORD))
    {
        pIStream->Release();
        return E_FAIL;
    }

	if (FAILED(pIRiffStream->Ascend(&ck, 0)))
	{
		pIStream->Release();
		return E_FAIL;
	}


	pIStream->Release();
	return S_OK;
}



HRESULT CStereoWave::WriteRSMPLChunk(IDMUSProdRIFFStream* pIRiffStream)
{
	ASSERT(pIRiffStream);
	if(pIRiffStream == NULL)
	{
		return E_POINTER;
	}

	IStream* pIStream = pIRiffStream->GetStream();
	ASSERT(pIStream);
	if(pIStream == NULL)
	{
		return E_POINTER;
	}

	// Create RSMPL chunk
	MMCKINFO ck;
	DWORD cb = 0;

	ck.ckid = mmioFOURCC('s','m','p','l');
    if(FAILED(pIRiffStream->CreateChunk(&ck, 0)))
    {
		pIStream->Release();
        return E_FAIL;
    }

    DWORD dwSaveSize = sizeof RSMPL;
    if(m_rRSMPL.cSampleLoops > 0)
    {
        dwSaveSize += sizeof RLOOP;
        m_rRSMPL.cSampleLoops = 1;
    }

    HRESULT hr = pIStream->Write((LPSTR) &m_rRSMPL,dwSaveSize, &cb);
    if(FAILED(hr) || cb != dwSaveSize)
    {
		pIStream->Release();
        return E_FAIL;
    }

	if(FAILED(pIRiffStream->Ascend(&ck, 0)))
	{
		pIStream->Release();
		return E_FAIL;
	}

	pIStream->Release();
	return S_OK;

}

HRESULT CStereoWave::WriteWSMPLChunk(IDMUSProdRIFFStream* pIRiffStream)
{
	ASSERT(pIRiffStream);
	if(pIRiffStream == NULL)
	{
		return E_POINTER;
	}

	IStream* pIStream = pIRiffStream->GetStream();
	ASSERT(pIStream);
	if(pIStream == NULL)
	{
		return E_POINTER;
	}

	// Create WSMPL chunk
	MMCKINFO ck;
	DWORD cb = 0;

	ck.ckid = FOURCC_WSMP;
    if(FAILED(pIRiffStream->CreateChunk(&ck, 0)))
    {
		pIStream->Release();
        return E_FAIL;
    }

    DWORD dwSaveSize = sizeof WSMPL;
    if(m_rWSMP.cSampleLoops > 0)
    {
        dwSaveSize += sizeof WLOOP;
        m_rWSMP.cSampleLoops = 1;
    }

    HRESULT hr = pIStream->Write((LPSTR) &m_rWSMP, dwSaveSize, &cb);
    if(FAILED(hr) || cb != dwSaveSize)
    {
		pIStream->Release();
        return E_FAIL;
    }

	if(FAILED(pIRiffStream->Ascend(&ck, 0)))
	{
		pIStream->Release();
		return E_FAIL;
	}

	pIStream->Release();
	return S_OK;

}


HRESULT CStereoWave::WriteStereoData(IDMUSProdRIFFStream* pIRiffStream, bool bRuntime)
{
	ASSERT(pIRiffStream);
	if(pIRiffStream == NULL)
	{
		return E_POINTER;
	}

	IStream* pIStream = pIRiffStream->GetStream();
	ASSERT(pIStream);
	if(pIStream == NULL)
	{
		return E_POINTER;
	}

	ASSERT(m_pDataManager);
	if(m_pDataManager == NULL)
	{
		return E_FAIL;
	}

	// Save data
	MMCKINFO ck;
	DWORD cb = 0;

	m_dwDataOffset = GetFilePos(pIStream) + 8;
	
	ck.ckid = mmioFOURCC('d','a','t','a') ;
	if(FAILED(pIRiffStream->CreateChunk(&ck,0)))
	{
		pIStream->Release();
		return E_FAIL;
	}

	if(IsTrueStereo())
	{
		if(FAILED(m_pDataManager->SaveUncompressedDataToStream(pIStream, cb)))
		{
			pIStream->Release();
			return E_FAIL;
		}
	}
	else
	{
		// Intereleave the data from the channels and then write it to the stream
		if(FAILED(WriteInterleavedData(pIStream)))
		{
			pIStream->Release();
			return E_FAIL;
		}
	}

	HRESULT hr = pIRiffStream->Ascend(&ck, 0);
	if(FAILED(hr))
	{
		pIStream->Release();
		return E_FAIL;
	}

	pIStream->Release();
	return S_OK;

}


HRESULT CStereoWave::WriteInterleavedData(IStream* pIStream)
{
	ASSERT(pIStream);
	if(pIStream == NULL)
	{
		return E_POINTER;
	}

	ASSERT(m_pLeftChannel);
	if(m_pLeftChannel == NULL)
	{
		return E_UNEXPECTED;
	}

	ASSERT(m_pRightChannel);
	if(m_pRightChannel == NULL)
	{
		return E_UNEXPECTED;
	}

	DWORD dwSamplesToWrite = m_dwWaveLength;
	DWORD dwSamplesWritten = 0;
	UINT nBytesPerSample = m_rWaveformat.wBitsPerSample / 8;

	
	while(dwSamplesWritten < m_dwWaveLength)
	{
		if(dwSamplesToWrite > WAVE_DATA_BUFFER_SIZE * 2)
		{
			dwSamplesToWrite = WAVE_DATA_BUFFER_SIZE;
		}
		
		DWORD byRead = 0;
		BYTE* pbLeft = NULL;
		if(FAILED(m_pLeftChannel->GetData(dwSamplesWritten, dwSamplesToWrite, &pbLeft, byRead)))
		{
			return E_FAIL;
		}

		byRead = 0;
		BYTE* pbRight = NULL;
		if(FAILED(m_pRightChannel->GetData(dwSamplesWritten, dwSamplesToWrite, &pbRight, byRead)))
		{
			return E_FAIL;
		}

		// Interleave the data
		BYTE* pbStereo = NULL;
		DWORD dwStereoSize = dwSamplesToWrite * 2 * nBytesPerSample;
		if(FAILED(SafeAllocBuffer(&pbStereo, dwStereoSize)))
		{
			return E_OUTOFMEMORY;
		}

		if(FAILED(InterleaveBuffersForStereoData(pbLeft, pbRight, pbStereo, m_rWaveformat, dwStereoSize)))
		{
			return E_FAIL;
		}

		// Write it to the stream
		DWORD cbWritten = 0;
		if(FAILED(pIStream->Write(pbStereo, dwStereoSize, &cbWritten)))
		{
			return E_FAIL;
		}

		if(cbWritten != dwStereoSize)
		{
			return E_FAIL;
		}

		delete[] pbStereo;
		delete[] pbLeft;
		delete[] pbRight;

		dwSamplesWritten += dwSamplesToWrite;
		dwSamplesToWrite = m_dwWaveLength - dwSamplesWritten;
	}

	return S_OK;
}


HRESULT CStereoWave::WriteFACTChunk(IDMUSProdRIFFStream* pIRiffStream)
{
	ASSERT(pIRiffStream);
	if(pIRiffStream == NULL)
	{
		return E_POINTER;
	}

	IStream* pIStream = pIRiffStream->GetStream();
	ASSERT(pIStream);
	if(pIStream == NULL)
	{
		return E_POINTER;
	}

	MMCKINFO ck;
	ck.ckid = mmioFOURCC('f','a','c','t');
	if(FAILED(pIRiffStream->CreateChunk(&ck,0)))
	{
		pIStream->Release();
		return E_FAIL;
	}

	// Write the number of original samples (before compression)
	int nSampleSize = m_OriginalWavObj.WaveFormatEx.wBitsPerSample / 8;
	DWORD dwSamples = m_OriginalWavObj.dwDataSize / nSampleSize;
	DWORD dwLength = dwSamples / 2;
	
	DWORD cb = 0;
	HRESULT hr = pIStream->Write((LPSTR) &(dwLength), sizeof(DWORD), &cb);
	if(FAILED(hr) || cb != sizeof(DWORD))
	{
		pIStream->Release();
		return E_FAIL;
	}

	hr = pIRiffStream->Ascend(&ck, 0);
	if(FAILED(hr))
	{
		pIStream->Release();
		return E_FAIL;
	}

	pIStream->Release();
	return S_OK;
}


HRESULT CStereoWave::WriteCompressedData(IDMUSProdRIFFStream* pIRiffStream)
{
	ASSERT(pIRiffStream);
	if(pIRiffStream == NULL)
	{
		return E_POINTER;
	}

	ASSERT(m_pDataManager);
	if(m_pDataManager == NULL)
	{
		return E_FAIL;
	}

	IStream* pIStream = pIRiffStream->GetStream();
	ASSERT(pIStream);
	if(pIStream == NULL)
	{
		return E_OUTOFMEMORY;
	}

	// We position the data offset just after the chunk header
	m_dwDataOffset = GetFilePos(pIStream) + 8;

	MMCKINFO ck;
	ck.ckid = mmioFOURCC('d','a','t','a') ;
	HRESULT hr = pIRiffStream->CreateChunk(&ck,0);
	if (FAILED(hr))
	{
		pIStream->Release();
		return hr;
	}

	UINT nExtraBytes = m_CompressedWavObj.WaveFormatEx.cbSize;
	WAVEFORMATEX* pwfxDest = NULL;
	if(FAILED(SafeAllocBuffer((BYTE**)&pwfxDest, sizeof(WAVEFORMATEX) + nExtraBytes)))
	{
		return E_OUTOFMEMORY;
	}

	CopyMemory((BYTE*)pwfxDest, &m_CompressedWavObj.WaveFormatEx, sizeof(WAVEFORMATEX));
	CopyMemory((BYTE*)pwfxDest + sizeof(WAVEFORMATEX), m_CompressedWavObj.pbExtractWaveFormatData, nExtraBytes); 


	int nBytesPerSample = m_rWaveformat.wBitsPerSample / 8;

	// We have to compress the wave in chunks
	DWORD dwSamplesCompressed = 0;
	DWORD dwSourceLength = (m_OriginalWavObj.dwDataSize / nBytesPerSample) / 2;
	DWORD dwSamplesToCompress = dwSourceLength * 2;
	
	DWORD dwCompressedSize = 0;
	DWORD dwDecompressedSize = 0;

	// Get data in chunks of WAVE_DATA_BUFFER_SIZE 
	while(dwSamplesCompressed < dwSourceLength)
	{
		BYTE* pbData = NULL;
		DWORD dwLength = dwSourceLength; //WAVE_DATA_BUFFER_SIZE;
		dwSamplesToCompress = dwSourceLength - dwSamplesCompressed;
		
		// Take the big slice for the last chunk....
		// The conversion might fail if we take very small amount of data
		/*if(dwSamplesToCompress <= WAVE_DATA_BUFFER_SIZE * 2)
		{
			dwLength = dwSamplesToCompress;
		}*/

		
		// Turn off the compression temporarily to fool the GetChannelData
		// into getting us the uncompressed data for compression else we end
		// up compressing the decompressed wave data...
		m_bCompressed = false;

		DWORD cb = 0;
		if(FAILED(GetData(dwSamplesCompressed, dwLength, &pbData, cb)))
		{
			m_bCompressed = true;
			delete[] pwfxDest;
			pIStream->Release();
			return E_FAIL;
		}

		// Turn compression back on...
		m_bCompressed = true;

		// Now compress the data
		DWORD dwSourceSize = dwLength * nBytesPerSample * 2;
		BYTE* pbCompressed = NULL;
		DWORD dwCompressed = 0;
		if(FAILED(ConvertWave(&m_rWaveformat, pwfxDest, pbData, dwSourceSize, &pbCompressed, dwCompressed)))
		{
			delete[] pwfxDest;
			pIStream->Release();
			delete[] pbData;
			return E_FAIL;
		}

		dwCompressedSize += dwCompressed;
		
		// Update the number of samples successfully compressed
		dwSamplesCompressed += dwLength;

		// Write the data to the stream
		if(FAILED(pIStream->Write(pbCompressed, dwCompressed, &cb)))
		{
			delete[] pwfxDest;
			pIStream->Release();
			delete[] pbData;
			return E_FAIL;
		}

		delete[] pbData;
		delete[] pbCompressed;
	}


	delete[] pwfxDest;
	if(FAILED(pIRiffStream->Ascend(&ck, 0)))
	{
		pIStream->Release();
		return E_FAIL;
	}

	pIStream->Release();
	return S_OK;
}




HRESULT CStereoWave::Save(IDMUSProdRIFFStream* pIRiffStream, UINT wType, BOOL fFullSave)
{
	ASSERT(pIRiffStream);
	if(pIRiffStream == NULL)
	{
		return E_POINTER;
	}

	ASSERT(m_pLeftChannel);
	if(m_pLeftChannel == NULL)
	{
		return E_FAIL;
	}
	
	ASSERT(m_pRightChannel);
	if(m_pRightChannel == NULL)
	{
		return E_FAIL;
	}

    IStream* pIStream = pIRiffStream->GetStream();
	ASSERT(pIStream);
	if(pIStream == NULL)
	{
		return E_FAIL;
	}

    bool bRuntime = false;
    IDMUSProdPersistInfo* pIJazzPersistInfo = NULL;
	if(SUCCEEDED(pIStream->QueryInterface(IID_IDMUSProdPersistInfo,(void**) &pIJazzPersistInfo)))
	{
		DMUSProdStreamInfo StreamInfo;
		FileType ftSaveType;

		pIJazzPersistInfo->GetStreamInfo(&StreamInfo);
		ftSaveType = StreamInfo.ftFileType;

		if (ftSaveType == FT_RUNTIME)
        {
			bRuntime = true;
        }
		
		pIJazzPersistInfo->Release();		
	}


	HRESULT hr = E_FAIL;
	if(m_pCollection)
	{
        // Ask the data mnager to update the uncomrpessed deltas
        if(!m_bCompressed)
        {
            if(FAILED(m_pDataManager->UpdateUncompressedDeltas()))
            {
                return E_FAIL;
            }
        }

		if(SUCCEEDED(hr = m_pLeftChannel->Save(pIRiffStream, wType, fFullSave)))
		{
			hr = m_pRightChannel->Save(pIRiffStream, wType, fFullSave);
		}
	}
	else
	{
		hr = Save(pIStream);
	}

    pIStream->Release();
	return hr;
}

void CStereoWave::RefreshDrawBuffer()
{
    ASSERT(m_pLeftChannel);
	if(m_pLeftChannel == NULL)
	{
		return;
	}
	
	ASSERT(m_pRightChannel);
	if(m_pRightChannel == NULL)
	{
		return;
	}

    m_pLeftChannel->RefreshDrawBuffer();
    m_pRightChannel->RefreshDrawBuffer();
}

void CStereoWave::OnDraw(CDC* pDC, const CRect& rcClient)
{
	ASSERT(m_pWaveNode);
	if(m_pWaveNode == NULL)
	{
		return;
	}

	ASSERT(m_pLeftChannel);
	if(m_pLeftChannel == NULL)
	{
		return;
	}
	
	ASSERT(m_pRightChannel);
	if(m_pRightChannel == NULL)
	{
		return;
	}

	ASSERT(pDC);
	if(pDC == NULL)
	{
		return;
	}

	// Divide the client rect horizontally in half...top for the left channel, bottom for the right
	CRect rcLeftChannel;
	rcLeftChannel.top = rcClient.top;
	rcLeftChannel.bottom = rcClient.top + ((rcClient.bottom - rcClient.top) / 2);
	rcLeftChannel.left = rcClient.left;
	rcLeftChannel.right = rcClient.right;

	CRect rcRightChannel;
	rcRightChannel.top = rcClient.bottom - ((rcClient.bottom - rcClient.top) / 2) ;
	rcRightChannel.left = rcClient.left;
	rcRightChannel.bottom = rcClient.bottom;
	rcRightChannel.right = rcClient.right;

	// Draw the channel divinding line
	CPen* pOldPen = NULL;
	CPen penDividingLine(PS_SOLID, 0, RGB(0, 176, 0));
	pOldPen = pDC->SelectObject(&penDividingLine);
	pDC->MoveTo(rcClient.left, rcLeftChannel.bottom);
	pDC->LineTo(rcClient.right, rcLeftChannel.bottom);
	if(pOldPen)
	{
		pDC->SelectObject(pOldPen);
	}


	m_pLeftChannel->OnDraw(pDC, rcLeftChannel);
	m_pRightChannel->OnDraw(pDC, rcRightChannel);
	
	return;
}

void CStereoWave::OnDraw(CDC* pDC, const CRect& rcClient, const long lOffset, DWORD& dwStartSample, DWORD dwLength, float fSamplesPerPixel, const WaveDrawParams* pDrawParams, const WaveTimelineInfoParams* pInfoParams)
{
	ASSERT(m_pLeftChannel);
	if(m_pLeftChannel == NULL)
	{
		return;
	}
	
	ASSERT(m_pRightChannel);
	if(m_pRightChannel == NULL)
	{
		return;
	}

	ASSERT(pDC);
	if(pDC == NULL)
	{
		return;
	}

	// Divide the client rect horizontally in half...top for the left channel, bottom for the right
	CRect rcLeftChannel;
	rcLeftChannel.top = rcClient.top;
	rcLeftChannel.bottom = rcClient.top + ((rcClient.bottom - rcClient.top) / 2);
	rcLeftChannel.left = rcClient.left;
	rcLeftChannel.right = rcClient.right;

	CRect rcRightChannel;
	rcRightChannel.top = rcClient.bottom - ((rcClient.bottom - rcClient.top) / 2) ;
	rcRightChannel.left = rcClient.left;
	rcRightChannel.bottom = rcClient.bottom;
	rcRightChannel.right = rcClient.right;

	// Draw the channel divinding line
	CPen* pOldPen = NULL;
	CPen penDividingLine(PS_SOLID, 0, RGB(0, 176, 0));
	pOldPen = pDC->SelectObject(&penDividingLine);
	pDC->MoveTo(rcClient.left, rcLeftChannel.bottom);
	pDC->LineTo(rcClient.right, rcLeftChannel.bottom);
	if(pOldPen)
	{
		pDC->SelectObject(pOldPen);
	}

	// Make a copy of the reference so both channels draw at the same position
	DWORD dwFirstSample = dwStartSample;
	m_pLeftChannel->OnDraw(pDC, rcLeftChannel, lOffset, dwFirstSample, dwLength, fSamplesPerPixel, pDrawParams, pInfoParams);
	dwFirstSample = dwStartSample;
	m_pRightChannel->OnDraw(pDC, rcRightChannel, lOffset, dwFirstSample, dwLength, fSamplesPerPixel, pDrawParams, pInfoParams);

	// Update the refrence so next portion of the wave updates properly
	dwStartSample = dwFirstSample;
	
	return;
}

GUID CStereoWave::GetGUID()
{
	return m_guidStereoWave;
}

void CStereoWave::SetGUID(const GUID& guidSrc)
{
	CWaveNode::CopyGUID(guidSrc, m_guidStereoWave);
	if(m_pLeftChannel)
	{
		m_pLeftChannel->SetGUID(m_guidStereoWave);
	}
	if(m_pRightChannel)
	{
		m_pRightChannel->SetGUID(m_guidStereoWave);
	}
}

// Syncs the WSMPL, WLOOP and Info values for this object from the mono wave values 
// This method must be called after any operation on these structures
void CStereoWave::SyncWaveProperties(bool bCopyFromChannels)
{
	ASSERT(m_pLeftChannel);
	ASSERT(m_pRightChannel);
	if(m_pLeftChannel == NULL)
		return;
	if(m_pRightChannel == NULL)
		return;

	if(bCopyFromChannels)
	{
		CopyInfo(&(m_pLeftChannel->m_Info), &m_Info);
		CWave::SetWSMPL(m_pLeftChannel->GetWSMPL());
		CWave::SetWLOOP(m_pLeftChannel->GetWLOOP());
		CWave::SetRSMPL(m_pLeftChannel->GetRSMPL());
		CWave::SetRLOOP(m_pLeftChannel->GetRLOOP());
		m_bPlayLooped = (m_pLeftChannel->IsLooped() && m_pRightChannel->IsLooped());
		m_bCompressed = (m_pLeftChannel->m_bCompressed && m_pRightChannel->m_bCompressed);
		CopyMemory(&m_rWaveformat, &(m_pLeftChannel->m_rWaveformat), sizeof WAVEFORMATEX);
		GetTrueStereoFormat(m_rWaveformat);
		m_dwWaveLength = m_pLeftChannel->m_dwWaveLength;
		m_dwDataSize = GetDataSize();
		m_bStreaming = m_pLeftChannel->IsStreamingWave();
		m_bNoPreroll = m_pLeftChannel->IsNoPrerollWave();
		m_dwReadAheadTime = m_pLeftChannel->GetReadAheadTime();
		m_dwDecompressedStart = m_pLeftChannel->GetDwDecompressedStart(false);

        if(m_bCompressed == false)
        {
            CopyMemory(&m_OriginalWavObj.WaveFormatEx, &m_rWaveformat, sizeof WAVEFORMATEX);
            m_OriginalWavObj.dwDataSize = m_pLeftChannel->GetUncompressedDataSize() * 2;
        }
	}
	else
	{
		CopyInfo(&m_Info, &(m_pLeftChannel->m_Info));
		CopyInfo(&m_Info, &(m_pRightChannel->m_Info));

		WSMPL wsmpl;
		CopyMemory(&wsmpl, &m_rWSMP, sizeof WSMPL);
		
		WLOOP wloop;
		CopyMemory(&wloop, &m_rWLOOP, sizeof WLOOP);

		RSMPL rsmpl;
		CopyMemory(&rsmpl, &m_rRSMPL, sizeof RSMPL);

		RLOOP rloop;
		CopyMemory(&rloop, &m_rRLOOP, sizeof RLOOP);

		m_pLeftChannel->SetWSMPL(wsmpl);
		m_pLeftChannel->SetWLOOP(wloop);
		m_pLeftChannel->SetRSMPL(rsmpl);
		m_pLeftChannel->SetRLOOP(rloop);

		m_pRightChannel->SetWSMPL(wsmpl);
		m_pRightChannel->SetWLOOP(wloop);
		m_pRightChannel->SetRSMPL(rsmpl);
		m_pRightChannel->SetRLOOP(rloop);

		m_pLeftChannel->SetLooped(m_bPlayLooped != 0);
		m_pRightChannel->SetLooped(m_bPlayLooped != 0);

		CopyMemory(&m_pLeftChannel->m_rWaveformat, &m_rWaveformat, sizeof WAVEFORMATEX);
		CopyMemory(&m_pRightChannel->m_rWaveformat, &m_rWaveformat, sizeof WAVEFORMATEX);

		m_pLeftChannel->m_rWaveformat.nChannels = 1;
		m_pLeftChannel->m_rWaveformat.nBlockAlign /= 2;
		
		m_pRightChannel->m_rWaveformat.nChannels = 1;
		m_pRightChannel->m_rWaveformat.nBlockAlign /= 2;

		m_pLeftChannel->m_bCompressed = m_bCompressed;
		m_pRightChannel->m_bCompressed = m_bCompressed;

		m_pLeftChannel->SetStreamingWave(m_bStreaming);
		m_pLeftChannel->SetNoPrerollWave(m_bNoPreroll);
		m_pLeftChannel->SetReadAheadTime(m_dwReadAheadTime);
		m_pLeftChannel->SetDwDecompressedStart(m_dwDecompressedStart);

		m_pRightChannel->SetStreamingWave(m_bStreaming);
		m_pRightChannel->SetNoPrerollWave(m_bNoPreroll);
		m_pRightChannel->SetReadAheadTime(m_dwReadAheadTime);
		m_pRightChannel->SetDwDecompressedStart(m_dwDecompressedStart);

		RefreshWave();

	}
	
}

CString CStereoWave::GetName()
{
	CString sName = "";
	ASSERT(m_pLeftChannel);
	ASSERT(m_pRightChannel);
	if(m_pLeftChannel == NULL)
		return sName;
	if(m_pRightChannel == NULL)
		return sName;

	//sName = m_pLeftChannel->GetName();

	return m_Info.m_csName;
}

void CStereoWave::CopyInfo(CInfo* pSrcInfo, CInfo* pDstInfo)
{
	ASSERT(pSrcInfo);
	ASSERT(pDstInfo);
	if(pSrcInfo == NULL)
		return;
	if(pDstInfo == NULL)
		return;

	pDstInfo->m_csName = pSrcInfo->m_csName;
	pDstInfo->m_csComment = pSrcInfo->m_csComment;
	pDstInfo->m_csCopyright = pSrcInfo->m_csCopyright;
	pDstInfo->m_csDate = pSrcInfo->m_csDate;
	pDstInfo->m_csEngineer = pSrcInfo->m_csEngineer;
	pDstInfo->m_csProduct = pSrcInfo->m_csProduct;
	pDstInfo->m_csSoftware = pSrcInfo->m_csSoftware;
	pDstInfo->m_csSubject = pSrcInfo->m_csSubject;
}


DWORD CStereoWave::GetDataSize()
{
	ASSERT(m_pLeftChannel);
	ASSERT(m_pRightChannel);
	if(m_pLeftChannel == NULL)
		return 0;
	if(m_pRightChannel == NULL)
		return 0;

	if(!m_bTrueStereo)
	{
		return m_pLeftChannel->GetDataSize() + m_pRightChannel->GetDataSize();
	}

	return m_dwDataSize;
}


DWORD CStereoWave::GetUncompressedDataSize()
{
	ASSERT(m_pLeftChannel);
	ASSERT(m_pRightChannel);
	if(m_pLeftChannel == NULL)
		return 0;
	if(m_pRightChannel == NULL)
		return 0;

	if(m_pCollection)
		return m_pLeftChannel->GetUncompressedDataSize() + m_pRightChannel->GetUncompressedDataSize();
	else
		return m_OriginalWavObj.dwDataSize;
}


DWORD CStereoWave::GetCompressedDataSize()
{
	ASSERT(m_pLeftChannel);
	ASSERT(m_pRightChannel);
	if(m_pLeftChannel == NULL)
		return 0;
	if(m_pRightChannel == NULL)
		return 0;

	if(m_pCollection)
	{
		return m_pLeftChannel->GetCompressedDataSize() + m_pRightChannel->GetCompressedDataSize();
	}
	else
	{
		return m_CompressedWavObj.dwDataSize;
	}
}

DWORD CStereoWave::GetCompressionFormatTag()
{
	ASSERT(m_pLeftChannel);
	ASSERT(m_pRightChannel);
	if(m_pLeftChannel == NULL)
		return 0;
	if(m_pRightChannel == NULL)
		return 0;

	if(m_bCompressed)
	{
		if(m_pCollection)
		{
			DWORD dwLeftChannelCompressionTag = m_pLeftChannel->GetCompressionFormatTag();
			DWORD dwRightChannelCompressionTag = m_pRightChannel->GetCompressionFormatTag();
			
			ASSERT(dwLeftChannelCompressionTag == dwRightChannelCompressionTag);

			if(m_pLeftChannel->GetCompressionFormatTag() == m_pRightChannel->GetCompressionFormatTag())
			{
				return m_pLeftChannel->GetCompressionFormatTag();
			}
		}
		else
		{
			return m_CompressedWavObj.WaveFormatEx.wFormatTag;
		}
	}

	return 0;
}

HRESULT CStereoWave::GetCompressionFormat(WAVEFORMATEX* pwfxCompression)
{
	ASSERT(m_pLeftChannel);
	ASSERT(m_pRightChannel);

	if(pwfxCompression == NULL)
		return E_POINTER;

	if(m_pCollection)
	{
		if(SUCCEEDED(m_pLeftChannel->GetCompressionFormat(pwfxCompression)))
		{
			return S_OK;
		}
	}
	else
	{
		CopyMemory(pwfxCompression, &m_CompressedWavObj.WaveFormatEx, sizeof WAVEFORMATEX);
	}

	return S_OK;
}

void CStereoWave::SetWSMPL(WSMPL& wsmpl)
{
	CWave::SetWSMPL(wsmpl);
	SyncWaveProperties(false);
}

void CStereoWave::SetWLOOP(WLOOP& wloop)
{
	CWave::SetWLOOP(wloop);
	SyncWaveProperties(false);
}


void CStereoWave::SetRSMPL(RSMPL& rsmpl)
{
	CWave::SetRSMPL(rsmpl);
	SyncWaveProperties(false);
}

void CStereoWave::SetRLOOP(RLOOP& rloop)
{
	CWave::SetRLOOP(rloop);
	SyncWaveProperties(false);
}

HRESULT CStereoWave::RemoveSelection(DWORD dwStart, DWORD dwEnd)
{
	ASSERT(m_pLeftChannel);
	ASSERT(m_pRightChannel);
	if(m_pLeftChannel == NULL)
	{
		return E_FAIL;
	}

	if(m_pRightChannel == NULL)
	{
		return E_FAIL;
	}

    if(IsTrueStereo() == FALSE)
    {
        if(SUCCEEDED(m_pLeftChannel->RemoveSelection(dwStart, dwEnd)))
        {
            if(SUCCEEDED(m_pRightChannel->RemoveSelection(dwStart, dwEnd)))
            {
                SyncWaveProperties();
                return S_OK;
            }

            return E_FAIL;
        }

        return E_FAIL;
    }

	// Swap the points if necessary
	DWORD dwTemp = dwStart;
	if(dwStart > dwEnd)
	{
		DWORD dwTemp = dwStart;
		dwStart = dwEnd;
		dwEnd = dwTemp;
	}

	int nBytesPerSample = m_rWaveformat.wBitsPerSample / 8;
	int nChannels = m_rWaveformat.nChannels;

	DWORD dwBytesRemoved = 0;
	DWORD dwSamplesRemoved = abs(dwEnd - dwStart) + 1;

	if(FAILED(m_pDataManager->RemoveData(dwStart, dwSamplesRemoved)))
	{
		return E_FAIL;
	}

    m_OriginalWavObj.dwDataSize -= dwSamplesRemoved * nChannels * nBytesPerSample;
	m_dwDataSize = m_OriginalWavObj.dwDataSize;
	m_dwWaveLength -= dwSamplesRemoved;

    RefreshWave();
	UpdateLoopInRegions();

	return S_OK;
}

HRESULT CStereoWave::CopySelectionToClipboard(IStream* pIStream, DWORD dwStart, DWORD dwEnd)
{
	ASSERT(m_pLeftChannel);
	ASSERT(m_pRightChannel);
	if(m_pLeftChannel == NULL)
		return E_FAIL;
	if(m_pRightChannel == NULL)
		return E_FAIL;

	ASSERT(pIStream);
	if(pIStream == NULL)
		return E_POINTER;

	// Swap the points if necessary
	if(dwStart > dwEnd)
	{
		DWORD dwTemp = dwStart;
		dwStart = dwEnd;
		dwEnd = dwTemp;
	}

	DWORD dwClipLength = dwEnd - dwStart + 1;

	if(FAILED(WriteDataToClipboard(pIStream, dwStart, dwClipLength)))
	{
		return E_FAIL;
	}

	return S_OK;
}


HRESULT CStereoWave::WriteDataToClipboard(IStream* pIStream, DWORD dwStartSample, DWORD dwClipLength)
{
    if(IsTrueStereo())
    {
        return CWave::WriteDataToClipboard(pIStream, dwStartSample, dwClipLength);
    }

    ASSERT(pIStream);
	if(pIStream == NULL)
	{
		return E_POINTER;
	}

	IDMUSProdRIFFStream* pIRiffStream = NULL;
	HRESULT hr = AllocRIFFStream( pIStream, &pIRiffStream );
	if(FAILED(hr))
	{
		pIStream->Release();
		return hr;
	}
	
	// Create wave riff header
	MMCKINFO ckMain;
	ckMain.fccType = mmioFOURCC('W','A','V','E');
	hr = pIRiffStream->CreateChunk(&ckMain, MMIO_CREATERIFF);
	if(FAILED(hr))
	{
		return E_FAIL;
	}


	MMCKINFO ck;
	DWORD cb = 0;

	// Create format chunk
	ck.ckid = mmioFOURCC('f','m','t',' ');
	hr = pIRiffStream->CreateChunk(&ck, 0);
	if(FAILED(hr))
	{
		pIRiffStream->Release();
		return E_FAIL;
	}

	hr = pIStream->Write((LPSTR) &(m_rWaveformat), sizeof(WAVEFORMATEX), &cb);	
	if (FAILED(hr) || cb != sizeof(WAVEFORMATEX))
	{
		pIRiffStream->Release();
		return E_FAIL;
	}
	
	if (FAILED(pIRiffStream->Ascend(&ck, 0)))
	{
		pIRiffStream->Release();
		return E_FAIL;
	}
	
	// Save data
	ck.ckid = mmioFOURCC('d','a','t','a') ;
	hr = pIRiffStream->CreateChunk(&ck,0);
	if(FAILED(hr))
	{
		pIRiffStream->Release();
		return E_FAIL;
	}

    BYTE* pbLeft = NULL;
    if(FAILED(m_pLeftChannel->GetChannelData(dwStartSample, dwClipLength, &pbLeft, false)))
	{
		return E_FAIL;
	}

	BYTE* pbRight = NULL;
	if(FAILED(m_pRightChannel->GetChannelData(dwStartSample, dwClipLength, &pbRight, false)))
	{
        delete[] pbLeft;
		return E_FAIL;
	}

	// Interleave the data
	BYTE* pbStereo = NULL;
	DWORD dwStereoSize = dwClipLength * 2 * (m_rWaveformat.wBitsPerSample / 8);
	if(FAILED(SafeAllocBuffer(&pbStereo, dwStereoSize)))
	{
        delete[] pbLeft;
        delete[] pbRight;
		return E_OUTOFMEMORY;
	}

	if(FAILED(InterleaveBuffersForStereoData(pbLeft, pbRight, pbStereo, m_rWaveformat, dwStereoSize)))
	{
        delete[] pbLeft;
        delete[] pbRight;
        delete[] pbStereo;
		return E_FAIL;
	}


	if(FAILED(pIStream->Write((LPSTR) pbStereo, dwStereoSize, &cb)))	
	{
        delete[] pbLeft;
        delete[] pbRight;
		delete[] pbStereo;
		return E_FAIL;
	}

	delete[] pbStereo;
    delete[] pbLeft;
    delete[] pbRight;

	hr = pIRiffStream->Ascend(&ck, 0);
	if(FAILED(hr))
	{
		pIRiffStream->Release();
		return E_FAIL;
	}

	pIRiffStream->Ascend(&ckMain, 0);
	pIRiffStream->Release();

	return S_OK;

}


HRESULT CStereoWave::PasteSelectionFromClipboard(IStream* pIStream, DWORD dwStart)
{
	ASSERT(m_pLeftChannel);
	ASSERT(m_pRightChannel);
	if(m_pLeftChannel == NULL)
		return E_FAIL;
	if(m_pRightChannel == NULL)
		return E_FAIL;
	ASSERT(pIStream);
	if(pIStream == NULL)
		return E_POINTER;

	BYTE* pbData = NULL;
	DWORD dwDataSize = 0;
	WAVEFORMATEX wfxClip;

	if(FAILED(CWave::ReadDataFromClipbaord(pIStream, wfxClip, &pbData, dwDataSize)) || pbData == NULL || dwDataSize == 0)
	{
		return E_FAIL;
	}

	UINT nClipSampleSize = wfxClip.wBitsPerSample / 8;
	UINT nClipChannels = wfxClip.nChannels;

	DWORD dwClipLength = (dwDataSize / nClipSampleSize) / nClipChannels;

	// Insert method deletes the passed buffer
	return InsertWaveData(pbData, wfxClip, dwClipLength, dwStart);
}


HRESULT CStereoWave::InsertWaveData(BYTE* pbData, WAVEFORMATEX wfxDataFormat, DWORD dwSamples, DWORD dwStart)
{
	ASSERT(m_pLeftChannel);
	ASSERT(m_pRightChannel);
	if(m_pLeftChannel == NULL)
		return E_FAIL;
	if(m_pRightChannel == NULL)
		return E_FAIL;

	UINT nClipChannels = wfxDataFormat.nChannels;
	UINT nClipSampleSize = wfxDataFormat.wBitsPerSample / 8;

	DWORD dwNewBufferSize = 0;
	DWORD dwNumNewBytes = 0;

    if(IsTrueStereo() == FALSE)
    {
        DWORD dwDataSize = dwSamples * nClipSampleSize * nClipChannels;
        BYTE* pbChannel = NULL;
        if(FAILED(CWave::SafeAllocBuffer(&pbChannel, dwDataSize)))
        {
            delete[] pbData;
            return E_OUTOFMEMORY;
        }

        CopyMemory(pbChannel, pbData, dwDataSize);
        if(SUCCEEDED(m_pLeftChannel->InsertWaveData(pbChannel, wfxDataFormat, dwSamples, dwStart)))
        {
            if(FAILED(CWave::SafeAllocBuffer(&pbChannel, dwDataSize)))
            {
                delete[] pbData;
                return E_OUTOFMEMORY;
            }
            CopyMemory(pbChannel, pbData, dwDataSize);

            if(SUCCEEDED(m_pRightChannel->InsertWaveData(pbChannel, wfxDataFormat, dwSamples, dwStart)))
            {
                SyncWaveProperties();
                
                delete[] pbData;
                return S_OK;
            }

            delete[] pbData;
            return E_FAIL;
        }

        delete[] pbData;
        return E_FAIL;
    }


	if(nClipChannels == 1)
	{
		// Make an interleaved stereo buffer out of the mono buffer 
		BYTE* pbStereoData = NULL;
		DWORD dwDataSize = dwSamples * nClipSampleSize;
		DWORD dwStereoSize = dwDataSize * 2;
		if(FAILED(SafeAllocBuffer(&pbStereoData, dwStereoSize)))
		{
			return E_OUTOFMEMORY;
		}
		
		BYTE* pbCopy = NULL;
		if(FAILED(SafeAllocBuffer(&pbCopy, dwDataSize)))
		{
            delete[] pbData;
			return E_OUTOFMEMORY;
		}
		CopyMemory(pbCopy, pbData, dwDataSize);

		if(FAILED(InterleaveBuffersForStereoData(pbData, pbCopy, pbStereoData, wfxDataFormat, dwStereoSize)))
		{
            delete[] pbData;
			delete[] pbCopy;
			delete[] pbStereoData;
			return E_FAIL;
		}

		delete[] pbData;
		delete[] pbCopy;
		pbData = pbStereoData;
		nClipChannels = 2;
	}

	DWORD dwClipSize = dwSamples * nClipSampleSize * nClipChannels;

	if(m_rWaveformat.wBitsPerSample == 8)
	{
		dwNumNewBytes = dwSamples * 2;
	}
	else
	{
		dwNumNewBytes = (dwSamples << 1) * 2;
	}

	// Massage the data if the sample sizes are different
	if(m_rWaveformat.wBitsPerSample != wfxDataFormat.wBitsPerSample)
	{
		DWORD dwIndex = 0;
		if(m_rWaveformat.wBitsPerSample == 8) 
		{
			BYTE* pbNewBuffer = NULL;
			if(FAILED(SafeAllocBuffer(&pbNewBuffer, dwNumNewBytes)))
			{
				delete[] pbData;
				return E_OUTOFMEMORY;
			}

			for(dwIndex = 0; dwIndex < dwNumNewBytes; dwIndex++)
			{
				pbNewBuffer[dwIndex] = *((short*)pbData + dwIndex) < 0 ? 
					128 - MulDiv(abs(*((short*)pbData + dwIndex)), 128, 32768) :
					128 + MulDiv(abs(*((short*)pbData + dwIndex)), 127, 32767);
			}

			delete[] pbData;
			pbData = pbNewBuffer;
		}
		else
		{
			short* pnNewBuffer = NULL;
			if(FAILED(SafeAllocBuffer((BYTE**)&pnNewBuffer, dwNumNewBytes)))
			{
				delete[] pbData;
				return E_OUTOFMEMORY;
			}

			for(dwIndex = 0; dwIndex < dwClipSize; dwIndex++)
			{
				pnNewBuffer[dwIndex] = *(pbData + dwIndex) < 128 ? 
					- MulDiv(abs(*(pbData + dwIndex) - 128), 32768, 128) :
					+ MulDiv(*(pbData + dwIndex) - 128, 32767, 127);
			}
			
			delete[] pbData;
			pbData = (BYTE*)pnNewBuffer;
		}
	}

	if(FAILED(m_pDataManager->InsertData(dwStart, pbData, dwSamples)))
	{
		return E_FAIL;
	}

	delete[] pbData;

	m_dwWaveLength += dwSamples;
	m_OriginalWavObj.dwDataSize += dwNumNewBytes;
    m_dwDataSize = m_OriginalWavObj.dwDataSize;

	RefreshWave();
	
	return S_OK;
}

	
HRESULT CStereoWave::Fade(bool bFadeDirection, DWORD dwStart, DWORD dwEnd)
{
	ASSERT(m_pLeftChannel);
	ASSERT(m_pRightChannel);
	if(m_pLeftChannel == NULL)
		return E_FAIL;
	if(m_pRightChannel == NULL)
		return E_FAIL;

    if(IsTrueStereo() == FALSE)
    {
        if(FAILED(m_pLeftChannel->Fade(bFadeDirection, dwStart, dwEnd)))
        {
            return E_FAIL;
        }
        
        if(FAILED(m_pRightChannel->Fade(bFadeDirection, dwStart, dwEnd)))
        {
            return E_FAIL;
        }
    }
    else
    {
	    if(FAILED(CWave::Fade(bFadeDirection, dwStart, dwEnd)))
	    {
		    return E_FAIL;
	    }
    }

	if(FAILED(RefreshWave()))
	{
		return E_FAIL;
	}

	return S_OK;
}

	
HRESULT CStereoWave::InsertSilence(DWORD dwStart, DWORD dwLength)
{
	if( dwLength == 0 )
	{
		return S_OK;
	}

	DWORD dwBytesPerSample = 1;
	if(m_rWaveformat.wBitsPerSample > 8)
	{
		dwBytesPerSample = m_rWaveformat.wBitsPerSample / 8;
	}

	dwBytesPerSample *= 2;

	ASSERT(m_pLeftChannel);
	ASSERT(m_pRightChannel);
	if(m_pLeftChannel == NULL)
		return E_FAIL;
	if(m_pRightChannel == NULL)
		return E_FAIL;

	BYTE* pbBuffer = new BYTE[dwLength * dwBytesPerSample];
	if( !pbBuffer )
	{
		return E_FAIL;
	}

	ZeroMemory( pbBuffer, dwLength * dwBytesPerSample );

	HRESULT hr = InsertWaveData(pbBuffer, m_rWaveformat, dwLength, dwStart);
	if(FAILED(hr))
	{
		delete[] pbBuffer;
		return E_FAIL;
	}

	// If inserted before loop start point
	if( dwStart < m_rWLOOP.ulStart )
	{
		// Update the start and end values
		SetLoop( m_rRLOOP.dwStart + dwLength, m_rRLOOP.dwEnd + dwLength );
	}
	// If inserted before loop end point
	else if( dwStart < m_rWLOOP.ulStart + m_rWLOOP.ulLength )
	{
		// Update end value (start remains the same)
		SetLoop( m_rRLOOP.dwStart, m_rRLOOP.dwEnd + dwLength );
	}

	return S_OK;
}

	
HRESULT CStereoWave::Resample(DWORD dwNewSampleRate)
{
	ASSERT(m_pLeftChannel);
	ASSERT(m_pRightChannel);
	if(m_pLeftChannel == NULL)
		return E_FAIL;
	if(m_pRightChannel == NULL)
		return E_FAIL;

	if( m_rWaveformat.nSamplesPerSec == dwNewSampleRate )
	{
		return S_OK;
	}

    if(IsTrueStereo() == FALSE)
    {
        if(FAILED(m_pLeftChannel->Resample(dwNewSampleRate)))
        {
            return E_FAIL;
        }
        
        if(FAILED(m_pRightChannel->Resample(dwNewSampleRate)))
        {
            return E_FAIL;
        }

		// Now update the stereo wave with the new sample rate
		SyncWaveProperties(true);
    }
    else
    {
	    if(FAILED(CWave::Resample(dwNewSampleRate)))
	    {
		    return E_FAIL;
	    }

		// Update the individual waves with the new sample rate
		SyncWaveProperties(false);
    }

	if(FAILED(RefreshWave()))
	{
		return E_FAIL;
	}

	return S_OK;
}


HRESULT CStereoWave::CopyLoop()
{
	ASSERT(m_pLeftChannel);
	ASSERT(m_pRightChannel);
	if(m_pLeftChannel == NULL)
		return E_FAIL;
	if(m_pRightChannel == NULL)
		return E_FAIL;

	// Wave's not looped?
	if(m_bPlayLooped == false)
	{
		return E_FAIL;
	}

	DWORD dwLoopLength = m_rWLOOP.ulLength;
	DWORD dwStartSample = m_rWLOOP.ulStart;
	DWORD dwEndSample = dwStartSample + dwLoopLength;

	BYTE* pbBuffer = NULL;
	DWORD cb = 0;
	if(FAILED(GetData(dwStartSample, dwLoopLength, &pbBuffer, cb)))
	{
		return E_FAIL;
	}

	DWORD dwStart = dwEndSample;
	DWORD dwEnd = dwStart;
	HRESULT hr = InsertWaveData(pbBuffer, m_rWaveformat, dwLoopLength, dwStart);
	if(FAILED(hr))
	{
		delete[] pbBuffer;
		return E_FAIL;
	}

	// Move the loop values to the copied position now...
	m_rWLOOP.ulStart = dwEndSample;
	m_rRLOOP.dwStart = dwEndSample;
	m_rRLOOP.dwEnd = dwEndSample + dwLoopLength;

	SyncWaveProperties(false);

	UpdateLoopInRegions();

	// Dirty the collection so we know the file gets saved
	return S_OK;
}


HRESULT CStereoWave::SetLoop(DWORD dwStart, DWORD dwEnd)
{
	ASSERT(m_pLeftChannel);
	ASSERT(m_pRightChannel);
	if(m_pLeftChannel == NULL)
		return E_FAIL;
	if(m_pRightChannel == NULL)
		return E_FAIL;

	if(SUCCEEDED(m_pLeftChannel->SetLoop(dwStart, dwEnd)))
	{
		if(SUCCEEDED(m_pRightChannel->SetLoop(dwStart, dwEnd)))
		{
			// RememberLoopAfterCompression was called as part of the SetLoop method,
			// so we just need to fix it in our wave structure
			CWave::RememberLoopAfterCompression();
			SyncWaveProperties(true);
			UpdateDummyInstrument();
			return S_OK;
		}
	}

	return E_FAIL;
}

void CStereoWave::RememberLoopBeforeCompression()
{
    ASSERT(m_pLeftChannel);
	ASSERT(m_pRightChannel);
	if(m_pLeftChannel == NULL)
		return;
	if(m_pRightChannel == NULL)
		return;

    CWave::RememberLoopBeforeCompression();
    m_pLeftChannel->RememberLoopBeforeCompression();
    m_pRightChannel->RememberLoopBeforeCompression();    
}

void CStereoWave::RevertToLoopBeforeCompression()
{
    ASSERT(m_pLeftChannel);
	ASSERT(m_pRightChannel);
	if(m_pLeftChannel == NULL)
		return;
	if(m_pRightChannel == NULL)
		return;

    CWave::RevertToLoopBeforeCompression();
    m_pLeftChannel->RevertToLoopBeforeCompression();
    m_pRightChannel->RevertToLoopBeforeCompression();
}

void CStereoWave::RememberLoopAfterCompression()
{
    ASSERT(m_pLeftChannel);
	ASSERT(m_pRightChannel);
	if(m_pLeftChannel == NULL)
		return;
	if(m_pRightChannel == NULL)
		return;

    CWave::RememberLoopAfterCompression();
    m_pLeftChannel->RememberLoopAfterCompression();
    m_pRightChannel->RememberLoopAfterCompression();    
}

/* Reverts to the saved decompressed start and loop points */
void CStereoWave::RevertToAfterCompression()
{
    ASSERT(m_pLeftChannel);
	ASSERT(m_pRightChannel);
	if(m_pLeftChannel == NULL)
		return;
	if(m_pRightChannel == NULL)
		return;

    CWave::RevertToAfterCompression();
    m_pLeftChannel->RevertToAfterCompression();
    m_pRightChannel->RevertToAfterCompression();
}

HRESULT CStereoWave::InterleaveBuffersForStereoData(BYTE* pbLeft, BYTE* pbRight, BYTE* pbStereoData, WAVEFORMATEX wfxData, DWORD dwDataSize)
{
	ASSERT(pbLeft);
	ASSERT(pbRight);
	ASSERT(pbStereoData);
	if(pbLeft == NULL || pbRight == NULL || pbStereoData == NULL)
	{
		return E_POINTER;
	}

	UINT nBytesPerSample = wfxData.wBitsPerSample / 8;
	for(DWORD dwByteCount = 0; dwByteCount < dwDataSize; dwByteCount += nBytesPerSample * 2)
	{
		CopyMemory(pbStereoData + dwByteCount, pbLeft, nBytesPerSample);
		CopyMemory(pbStereoData + dwByteCount + nBytesPerSample, pbRight, nBytesPerSample);

		pbLeft += nBytesPerSample;
		pbRight += nBytesPerSample;
	}

	return S_OK;
}


HRESULT CStereoWave::InterleaveChannelsForStereoData()
{
	ASSERT(m_pLeftChannel);
	ASSERT(m_pRightChannel);
	if(m_pLeftChannel == NULL)
		return E_FAIL;
	if(m_pRightChannel == NULL)
		return E_FAIL;

	// Clean the original data if any
	if(m_OriginalWavObj.pbData)
	{
		delete[] m_OriginalWavObj.pbData;
		m_OriginalWavObj.pbData = NULL;
		m_OriginalWavObj.dwDataSize = 0;
	}


	BYTE* pbLeftChannelData = (BYTE*)m_pLeftChannel->GetWaveData();
	BYTE* pbRightChannelData = (BYTE*)m_pRightChannel->GetWaveData();

	// This might be a newly created empty wave
	if(pbLeftChannelData == NULL || pbRightChannelData == NULL)
	{
		m_OriginalWavObj.pbData = NULL;
		m_OriginalWavObj.dwDataSize = 0;

		return S_OK;
	}

	DWORD dwDataSize = GetDataSize();
	BYTE* pbData = new BYTE[dwDataSize];
	if(pbData == NULL)
	{
		return E_OUTOFMEMORY;
	}
	ZeroMemory(pbData, dwDataSize);

	int nBytesPerSample = m_rWaveformat.wBitsPerSample / 8;

	for(DWORD dwByteCount = 0; dwByteCount < dwDataSize; dwByteCount += nBytesPerSample * 2)
	{
		CopyMemory(pbData + dwByteCount, pbLeftChannelData, nBytesPerSample);
		CopyMemory(pbData + dwByteCount + nBytesPerSample, pbRightChannelData, nBytesPerSample);

		pbLeftChannelData += nBytesPerSample;
		pbRightChannelData += nBytesPerSample;
	}

	m_OriginalWavObj.pbData = pbData;
	m_OriginalWavObj.dwDataSize = dwDataSize;

	return S_OK;
}



HRESULT CStereoWave::ConvertStereoData(const DMUSP_WAVEOBJECT& sourceWave, const WAVEFORMATEX* pwfxDst, DMUSP_WAVEOBJECT& convertedWave, bool bCompress)
{
	ASSERT(m_pLeftChannel);
	if(m_pLeftChannel == NULL)
		return E_FAIL;

	ASSERT(m_pRightChannel);
	if(m_pRightChannel == NULL)
		return E_FAIL;

	// This must be a stereo format
	if(pwfxDst->nChannels != 2)
		return E_FAIL;

	if(FAILED(CWave::ConvertWave(sourceWave, pwfxDst, convertedWave, bCompress)))
	{
		return E_FAIL;
	}

	return S_OK;
}


void CStereoWave::GetTrueStereoFormat(WAVEFORMATEX& wfxPCM)
{
	CopyMemory(&wfxPCM, &m_rWaveformat, sizeof WAVEFORMATEX);
	
	if(wfxPCM.nChannels < 2)
	{
		wfxPCM.nChannels  = 2;
	}

	if((wfxPCM.nBlockAlign == 1 && wfxPCM.wBitsPerSample == 8) ||
		(wfxPCM.nBlockAlign == 2 && wfxPCM.wBitsPerSample == 16))
	{
		wfxPCM.nBlockAlign *= 2;
	}

    wfxPCM.nAvgBytesPerSec = wfxPCM.nSamplesPerSec * wfxPCM.nBlockAlign;

	wfxPCM.cbSize = 0;

	return;
}


HRESULT CStereoWave::UpdateChannelsForStereoCompression()
{
	ASSERT(m_pLeftChannel);
	if(m_pLeftChannel == NULL)
		return E_FAIL;

	ASSERT(m_pRightChannel);
	if(m_pRightChannel == NULL)
		return E_FAIL;

	// Don't do anything if the wave is not compressed
	if(!m_bCompressed)
		return E_FAIL;

	
	if(SUCCEEDED(m_pLeftChannel->UpdateDataForStereoCompression(m_DecompressedWavObj)))
	{
		if(SUCCEEDED(m_pRightChannel->UpdateDataForStereoCompression(m_DecompressedWavObj)))
		{
			return S_OK;
		}
	}
	
	return E_FAIL;
}


HRESULT CStereoWave::ReadFormatChunk(IDMUSProdRIFFStream* pIRiffStream)
{
	if(pIRiffStream == NULL)
		return E_POINTER;

	IStream* pIStream = pIRiffStream->GetStream();
	ASSERT(pIStream);
	if(pIStream == NULL)
		return E_FAIL;

	DWORD cb = 0;
	WAVEFORMATEX wfxTemp;
	HRESULT hr = pIStream->Read( &wfxTemp, sizeof WAVEFORMATEX, &cb );
	if(FAILED(hr) || cb != sizeof WAVEFORMATEX)
	{
		pIStream->Release();
		return E_FAIL;
	}
	
	// This must be a compressed wav huh?
	if(m_bCompressed && m_bLoadingRuntime)
	{
		BYTE* pbExtraInfo = NULL;
		
		// So we need the extra info bits
		if(wfxTemp.cbSize > 0)
		{
			pbExtraInfo = new BYTE[wfxTemp.cbSize];
			if(pbExtraInfo == NULL)
			{
				pIStream->Release();
				return E_OUTOFMEMORY;
			}
			ZeroMemory(pbExtraInfo, wfxTemp.cbSize);

			hr = pIStream->Read(pbExtraInfo, wfxTemp.cbSize, &cb);
			if(FAILED(hr) || cb != wfxTemp.cbSize)
			{
				delete[] pbExtraInfo;
				pIStream->Release();
				return(hr);
			}
		}

		if(m_CompressedWavObj.pbExtractWaveFormatData)
		{
			delete[] m_CompressedWavObj.pbExtractWaveFormatData;
			m_CompressedWavObj.pbExtractWaveFormatData = NULL;
		}

		CopyMemory(&(m_CompressedWavObj.WaveFormatEx), &wfxTemp, sizeof wfxTemp);
		m_CompressedWavObj.pbExtractWaveFormatData = pbExtraInfo;
	}
	else if(wfxTemp.wFormatTag == WAVE_FORMAT_PCM)
	{
		CopyMemory(&m_rWaveformat, &wfxTemp, sizeof wfxTemp);
		m_rWaveformat.cbSize = 0;
		CopyMemory(&m_OriginalWavObj.WaveFormatEx, &m_rWaveformat, sizeof WAVEFORMATEX);
	}
	else 
	{
		AfxMessageBox(IDS_WAVE_NOT_PCM, MB_ICONEXCLAMATION); 
		pIStream->Release();
		return E_FAIL;
	}

	pIStream->Release();
	return S_OK;
}

HRESULT CStereoWave::ReadWSMPLChunk(IDMUSProdRIFFStream* pIRiffStream, DWORD dwChunkSize)
{
	if(pIRiffStream == NULL)
		return E_POINTER;

	IStream* pIStream = pIRiffStream->GetStream();
	ASSERT(pIStream);
	if(pIStream == NULL)
		return E_FAIL;

	DWORD cSize = 0;
	DWORD cb = 0;

	if(dwChunkSize < (sizeof WSMPL + sizeof WLOOP) )
	{
		cSize = dwChunkSize;
	}
	else
	{
		cSize = sizeof WSMPL + sizeof WLOOP;
	}
	
	HRESULT hr = pIStream->Read( &m_rWSMP, cSize, &cb );
	if( FAILED(hr) || cb != cSize )
	{
		pIStream->Release();
		return E_FAIL;
	}
			
	pIStream->Release();
	return S_OK;
}


HRESULT CStereoWave::ReadRSMPLChunk(IDMUSProdRIFFStream* pIRiffStream, DWORD dwChunkSize)
{
	if(pIRiffStream == NULL)
		return E_POINTER;

	IStream* pIStream = pIRiffStream->GetStream();
	ASSERT(pIStream);
	if(pIStream == NULL)
		return E_FAIL;

	DWORD cSize = 0;
	DWORD cb = 0;
	
	if(dwChunkSize < (sizeof RSMPL + sizeof RLOOP))
	{
		cSize = dwChunkSize;
	}
	else
	{
		cSize = (sizeof RSMPL + sizeof RLOOP);
	}

    HRESULT hr = pIStream->Read( &m_rRSMPL, cSize, &cb );
	if(FAILED(hr) || cb != cSize )
	{
		pIStream->Release();
		return E_FAIL;
	}

	pIStream->Release();
	return S_OK;
}

HRESULT	CStereoWave::GetPlayTimeForTempo(int nTempo, DWORD& dwPlayTime)
{
	ASSERT(m_pLeftChannel);
	ASSERT(m_pRightChannel);
	if(m_pLeftChannel == NULL)
		return E_FAIL;
	if(m_pRightChannel == NULL)
		return E_FAIL;
	
	DWORD dwLeftChannelPlayTime = m_pLeftChannel->GetPlayTimeForTempo(nTempo, dwPlayTime);
	DWORD dwRightChannelPlayTime = m_pRightChannel->GetPlayTimeForTempo(nTempo, dwPlayTime);

	// Resturn the longest play time
	dwLeftChannelPlayTime > dwRightChannelPlayTime ? dwPlayTime = dwLeftChannelPlayTime : dwPlayTime = dwRightChannelPlayTime;

	return S_OK;
}

void CStereoWave::SnapToZero(DWORD& dwSample, UINT nDirection)
{
	ASSERT(m_pLeftChannel);
	ASSERT(m_pRightChannel);
	if(m_pLeftChannel == NULL)
		return;
	if(m_pRightChannel == NULL)
		return;

	m_pLeftChannel->SnapToZero(dwSample, nDirection);
}

HRESULT CStereoWave::RefreshWave()
{
	ASSERT(m_pLeftChannel);
	ASSERT(m_pRightChannel);
	if(m_pLeftChannel == NULL)
		return E_FAIL;
	if(m_pRightChannel == NULL)
		return E_FAIL;

	// Set the data for the channels
	DMUSP_WAVEOBJECT stereoWave;
	stereoWave.dwDataSize = m_OriginalWavObj.dwDataSize;
	stereoWave.WaveFormatEx = m_OriginalWavObj.WaveFormatEx;
	stereoWave.pbExtractWaveFormatData = NULL;
	
	if(FAILED(m_pRightChannel->SetUncompressedData(stereoWave)))
	{
		return E_FAIL;
	}

	if(FAILED(m_pLeftChannel->SetUncompressedData(stereoWave)))
	{
		return E_FAIL;
	}

	return S_OK;
}

CString CStereoWave::GetUndoMenuText(bool bRedo)
{
    ASSERT(m_pLeftChannel);
	ASSERT(m_pRightChannel);
	if(m_pLeftChannel == NULL)
    {
		return "";
    }

	if(m_pRightChannel == NULL)
    {
		return "";
    }

    ASSERT(m_pDataManager);
    if(m_pDataManager == NULL)
    {
        return "";
    }

    if(IsTrueStereo() == FALSE)
    {
        m_pLeftChannel->GetUndoMenuText(bRedo);
        return m_pRightChannel->GetUndoMenuText(bRedo);
    }

    return CWave::GetUndoMenuText(bRedo);
}

HRESULT CStereoWave::SaveUndoState(UINT uUndoStrID)
{
	ASSERT(m_pLeftChannel);
	ASSERT(m_pRightChannel);
	if(m_pLeftChannel == NULL)
    {
		return E_FAIL;
    }

	if(m_pRightChannel == NULL)
    {
		return E_FAIL;
    }

    ASSERT(m_pDataManager);
    if(m_pDataManager == NULL)
    {
        return E_FAIL;
    }

    if(IsTrueStereo() == FALSE)
    {
        if(SUCCEEDED(m_pLeftChannel->SaveUndoState(uUndoStrID)))
        {
            return m_pRightChannel->SaveUndoState(uUndoStrID);
        }

        return E_FAIL;
    }

    return CWave::SaveUndoState(uUndoStrID);
}

HRESULT CStereoWave::Undo()
{
    ASSERT(m_pLeftChannel);
	ASSERT(m_pRightChannel);
	if(m_pLeftChannel == NULL)
    {
		return E_FAIL;
    }

	if(m_pRightChannel == NULL)
    {
		return E_FAIL;
    }

    ASSERT(m_pDataManager);
    if(m_pDataManager == NULL)
    {
        return E_FAIL;
    }

    if(IsTrueStereo() == FALSE)
    {
        if(SUCCEEDED(m_pLeftChannel->Undo()))
        {
            if(SUCCEEDED(m_pRightChannel->Undo()))
            {
                SyncWaveProperties();
                return S_OK;
            }

            return E_FAIL;
        }

        return E_FAIL;
    }

    return CWave::Undo();
}

HRESULT CStereoWave::Redo()
{
    ASSERT(m_pLeftChannel);
	ASSERT(m_pRightChannel);
	if(m_pLeftChannel == NULL)
    {
		return E_FAIL;
    }

	if(m_pRightChannel == NULL)
    {
		return E_FAIL;
    }

    ASSERT(m_pDataManager);
    if(m_pDataManager == NULL)
    {
        return E_FAIL;
    }

    if(IsTrueStereo() == FALSE)
    {
        if(SUCCEEDED(m_pLeftChannel->Redo()))
        {
            if(SUCCEEDED(m_pRightChannel->Redo()))
            {
                SyncWaveProperties();
                return S_OK;
            }

            return E_FAIL;
        }

        return E_FAIL;
    }

    return CWave::Redo();
}


HRESULT CStereoWave::PopUndoState()
{
    ASSERT(m_pLeftChannel);
	ASSERT(m_pRightChannel);
	if(m_pLeftChannel == NULL)
    {
		return E_FAIL;
    }

	if(m_pRightChannel == NULL)
    {
		return E_FAIL;
    }

    ASSERT(m_pDataManager);
    if(m_pDataManager == NULL)
    {
        return E_FAIL;
    }

    if(IsTrueStereo() == FALSE)
    {
        if(SUCCEEDED(m_pLeftChannel->PopUndoState()))
        {
            if(SUCCEEDED(m_pRightChannel->PopUndoState()))
            {
                SyncWaveProperties();
                return S_OK;
            }

            return E_FAIL;
        }

        return E_FAIL;
    }

    return CWave::PopUndoState();


}

void CStereoWave::UpdateOnUndo(HEADER_INFO headerInfo)
{
    ASSERT(m_pLeftChannel);
	ASSERT(m_pRightChannel);
	if(m_pLeftChannel == NULL)
    {
		return;
    }

	if(m_pRightChannel == NULL)
    {
		return;
    }

	// Update the base structures
    if(IsTrueStereo())
    {
        m_pLeftChannel->m_bCompressed = headerInfo.m_bCompressed;
        m_pRightChannel->m_bCompressed = headerInfo.m_bCompressed;

	    CWave::UpdateOnUndo(headerInfo);
	    
	    // Now update the individual channels
	    SyncWaveProperties(false);

	    if(SUCCEEDED(UpdateHeaderStream()))
	    {
		    m_pWaveNode->ReloadDirectSoundWave();
	    }
    }
    else
    {
        m_pLeftChannel->UpdateOnUndo(headerInfo);
        m_pRightChannel->UpdateOnUndo(headerInfo);

        // Now update the stereo wave
	    SyncWaveProperties(true);
    }
}

HRESULT	CStereoWave::WriteRIFFHeaderToStream(IStream* pIStream, DWORD* pdwBytesWritten)
{
	ASSERT(pIStream);
	if(pIStream == NULL)
	{
		return E_POINTER;
	}

	ASSERT(pdwBytesWritten);
	if(pdwBytesWritten == NULL)
	{
		return E_POINTER;
	}

	// Seek to the begiinning of this stream...
	if(FAILED(StreamSeek(pIStream, 0, STREAM_SEEK_SET)))
	{
		return E_FAIL;
	}
	
	IDMUSProdRIFFStream* pIRiffStream = NULL;
	if(FAILED(AllocRIFFStream(pIStream, &pIRiffStream)))
	{
		return E_OUTOFMEMORY;
	}

	MMCKINFO ckMain;
	ckMain.fccType = mmioFOURCC('W','A','V','E'); 
	
	// RIFF chunk size = 'WAVE' + 'wavhXXXX' + _DMUS_IO_WAVE_HEADER + 'fmt XXXX' + PCM-WAVEFORMATEX + 'dataXXXX' + actual data size
	ckMain.cksize = 4 + 8 + sizeof(_DMUS_IO_WAVE_HEADER) + 8 + sizeof(WAVEFORMATEX) + 8 + m_dwDataSize;
	if(FAILED(pIRiffStream->CreateChunk(&ckMain, MMIO_CREATERIFF)))
	{
		pIRiffStream->Release();
		return E_FAIL;
	}

	// Save the 'wavh' chunk that keeps the streaming info
	MMCKINFO ck;
	ck.ckid = DMUS_FOURCC_WAVEHEADER_CHUNK;
	HRESULT hr = pIRiffStream->CreateChunk(&ck, 0);
    if (FAILED(hr))
    {
		pIStream->Release();
        return hr;
    }

	_DMUS_IO_WAVE_HEADER waveHeader;
	if(FAILED(CWave::GetStreamingWaveHeader(&waveHeader)))
	{
		pIStream->Release();
		return E_FAIL;
	}

	DWORD cb = 0;
	hr = pIStream->Write((LPSTR)&waveHeader, sizeof(_DMUS_IO_WAVE_HEADER), &cb);
	if(FAILED(hr) || cb != sizeof(_DMUS_IO_WAVE_HEADER))
	{
		pIStream->Release();
		return E_FAIL;
	}
	
	if(FAILED(pIRiffStream->Ascend(&ck, 0)))
	{
		pIStream->Release();
		return E_FAIL;
	}

	if(FAILED(WriteStereoFormat(pIRiffStream, false)))
	{
		pIRiffStream->Release();
		return E_FAIL;
	}

	// Keep the offset before writing the data-ck
	DWORD dwOffset = StreamTell(pIStream);

	// Write only upto <data-ck>[size]
	ck.ckid = mmioFOURCC('d','a','t','a');
	ck.cksize = m_dwDataSize;
	if(FAILED(pIRiffStream->CreateChunk(&ck,0)))
	{
		pIStream->Release();
		return E_FAIL;
	}

	// Don't ascend the data chunk as we're not writing any wave data
	// We just need to have the correct data size set in the chunk 
	DWORD dwBytesFromStart = StreamTell(pIStream);
	StreamSeek(pIStream, dwOffset, STREAM_SEEK_SET);

	if(FAILED(StreamSeek(pIStream, 0, STREAM_SEEK_SET)))
	{
		return E_FAIL;
	}

	*pdwBytesWritten = dwBytesFromStart;
	pIRiffStream->Release();

	return S_OK;
}

BOOL CStereoWave::IsTrueStereo()
{
	ASSERT(m_pWaveNode);
	if(m_pWaveNode == NULL)
	{
		return FALSE;
	}

	if(m_pWaveNode->IsInACollection() == FALSE)
	{
		return TRUE;
	}

	return m_bTrueStereo;
}


HRESULT CStereoWave::CloseSourceHandler()
{
	ASSERT(m_pLeftChannel);
	ASSERT(m_pRightChannel);
	if(m_pLeftChannel == NULL)
	{
		return E_FAIL;
	}
	if(m_pRightChannel == NULL)
	{
		return E_FAIL;
	}
	if(m_pDataManager == NULL)
	{
		return E_FAIL;
	}

	EnterCriticalSection(&m_pWaveNode->m_CriticalSection);
	if(FAILED(m_pDataManager->CloseSourceHandler()))
	{
		LeaveCriticalSection(&m_pWaveNode->m_CriticalSection);
		return E_FAIL;
	}
	LeaveCriticalSection(&m_pWaveNode->m_CriticalSection);

	if(SUCCEEDED(m_pLeftChannel->CloseSourceHandler()))
	{
		if(SUCCEEDED(m_pRightChannel->CloseSourceHandler()))
		{
			return S_OK;
		}
	}

	return E_FAIL;
}

HRESULT CStereoWave::OnSourceRenamed(CString sNewName)
{
	ASSERT(m_pDataManager);
	if(m_pDataManager == NULL)
	{
		return E_FAIL;
	}

	EnterCriticalSection(&m_pWaveNode->m_CriticalSection);
	if(FAILED(m_pDataManager->OnSourceRenamed(sNewName)))
	{
		LeaveCriticalSection(&m_pWaveNode->m_CriticalSection);
		return E_FAIL;
	}
	LeaveCriticalSection(&m_pWaveNode->m_CriticalSection);

	if(SUCCEEDED(m_pLeftChannel->OnSourceRenamed(sNewName)))
	{
		if(SUCCEEDED(m_pRightChannel->OnSourceRenamed(sNewName)))
		{
			return S_OK;
		}
	}

	return E_FAIL;
}

HRESULT CStereoWave::FileNameChanged(CString sNewFileName)
{
	ASSERT(m_pLeftChannel);
	ASSERT(m_pRightChannel);
	if(m_pLeftChannel == NULL)
	{
		return E_FAIL;
	}
	if(m_pRightChannel == NULL)
	{
		return E_FAIL;
	}

	ASSERT(m_pDataManager);
	if(m_pDataManager == NULL)
	{
		return E_FAIL;
	}

	if(FAILED(m_pDataManager->Initialize(sNewFileName, m_dwHeaderOffset, m_dwDataOffset, false)))
	{
		return E_FAIL;
	}

	if(FAILED(m_pLeftChannel->FileNameChanged(sNewFileName)))
	{
		return E_FAIL;
	}

	if(FAILED(m_pRightChannel->FileNameChanged(sNewFileName)))
	{
		return E_FAIL;
	}


	return S_OK;
}

HRESULT CStereoWave::PrepareForSave(CString sNewFileName)	
{
	ASSERT(m_pDataManager);
	if(m_pDataManager == NULL)
	{
		return E_POINTER;
	}
	
	// We need to rename ourselves if we're NOT in a collection
	if(m_pCollection == NULL)
	{
		if(FAILED(m_pLeftChannel->CloseSourceHandler()))
		{
			return E_FAIL;
		}

		if(FAILED(m_pRightChannel->CloseSourceHandler()))
		{
			return E_FAIL;
		}

		if(FAILED(m_pDataManager->RenameSource(sNewFileName)))
		{
			return E_FAIL;
		}
	}

	return S_OK;
}

HRESULT CStereoWave::CleanupAfterSave(CString sFileName)
{
	ASSERT(m_pDataManager);
	if(m_pDataManager == NULL)
	{
		return E_FAIL;
	}

	ASSERT(m_pLeftChannel);
	if(m_pLeftChannel == NULL)
	{
		return E_UNEXPECTED;
	}

	ASSERT(m_pRightChannel);
	if(m_pRightChannel == NULL)
	{
		return E_UNEXPECTED;
	}

	if(FAILED(m_pDataManager->Initialize(sFileName, m_dwHeaderOffset, m_dwDataOffset, true)))
	{
		return E_FAIL;
	}

	if(FAILED(m_pLeftChannel->CleanupAfterSave(sFileName)))
	{
		return E_FAIL;
	}

	if(FAILED(m_pRightChannel->CleanupAfterSave(sFileName)))
	{
		return E_FAIL;
	}

	// Set the name for the wave node 
	m_pWaveNode->SetFileName(sFileName);

    m_pWaveNode->SetSourceInTempFile(FALSE);

    if(m_pCollection)
    {
        m_bTrueStereo = FALSE;
    }

	return S_OK;
}

HRESULT CStereoWave::FindBestLoop(DWORD dwLoopStart, DWORD dwFindStart, DWORD dwFindEnd, int nFindWindow, DWORD* pdwBestLoopEnd)
{
	ASSERT(m_pLeftChannel);
	if(m_pLeftChannel == NULL)
	{
		return E_UNEXPECTED;
	}

	ASSERT(m_pRightChannel);
	if(m_pRightChannel == NULL)
	{
		return E_UNEXPECTED;
	}

	if(FAILED(m_pLeftChannel->FindBestLoop(dwLoopStart, dwFindStart, dwFindEnd, nFindWindow, pdwBestLoopEnd)))
	{
		return E_FAIL;
	}

	return S_OK;
}

void CStereoWave::SetCollection(CCollection* pCollection)
{
	ASSERT(m_pLeftChannel);
	if(m_pLeftChannel == NULL)
	{
		return;
	}

	ASSERT(m_pRightChannel);
	if(m_pRightChannel == NULL)
	{
		return;
	}


	CWave::SetCollection(pCollection);

	m_pLeftChannel->SetCollection(pCollection);
	m_pRightChannel->SetCollection(pCollection);

}

void CStereoWave::SetPreviousRegionLinkIDs(DWORD dwLeft, DWORD dwRight)
{
	ASSERT(m_pLeftChannel);
	if(m_pLeftChannel == NULL)
	{
		return;
	}

	ASSERT(m_pRightChannel);
	if(m_pRightChannel == NULL)
	{
		return;
	}

	m_pLeftChannel->SetPreviousRegionLinkID(dwLeft);
	m_pRightChannel->SetPreviousRegionLinkID(dwRight);
}

/* returns given channel */
CMonoWave *CStereoWave::GetChannel(LONG iChannel)
{
	switch (iChannel)
		{
		case 0:
			return GetLeftChannel();

		case 1:
			return GetRightChannel();

		default:
			ASSERT(FALSE); // unexpected channel number
			return NULL;
		}
}

/* sets wavelink parameters according to channel number */
void CStereoWave::SetWaveLinkPerChannel(LONG iChannel, WAVELINK *pwl)
{
	ASSERT(pwl);

	// set multichannel
	if ((pwl->fusOptions & F_WAVELINK_MULTICHANNEL) != 0)
		pwl->ulChannel = 1 << iChannel;

	// only one channel can be master
	if (iChannel != 0)
		pwl->fusOptions &= ~F_WAVELINK_PHASE_MASTER;

	// set wave ID
	CMonoWave *pMonoWave = GetChannel(iChannel);
	pwl->ulTableIndex = pMonoWave->GetWaveID();
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\DLSDesigner\StdAfx.h ===
#if !defined(AFX_STDAFX_H__BC964E9A_96F7_11D0_89AA_00A0C9054129__INCLUDED_)
#define AFX_STDAFX_H__BC964E9A_96F7_11D0_89AA_00A0C9054129__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000 

// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#define VC_EXTRALEAN		// Exclude rarely-used stuff from Windows headers

#include <afxctl.h>         // MFC support for ActiveX Controls
#include <afxcmn.h>
#include <htmlhelp.h>

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__BC964E9A_96F7_11D0_89AA_00A0C9054129__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\DLSDesigner\StereoWave.h ===
#ifndef __STEREOWAVE_H__
#define __STEREOWAVE_H__

// StereoWave.h : header file
//

class CStereoWave : public CWave
{

public:
	
	CStereoWave(CWaveNode* pWavenode, BOOL bTrueStereo, DWORD dwSampleRate = 22050, UINT nSampleSize = 16);
	CStereoWave(CWaveNode* pWaveNode, GUID guidStereoWave, DWORD dwSampleRate = 22050, UINT nSampleSize = 16);
	~CStereoWave();

	HRESULT Load(IDMUSProdRIFFStream* pIRiffStream, MMCKINFO* pckMain, bool bLoadRightChannel = false);
	HRESULT Save(IStream* pIStream);
	HRESULT Save(IDMUSProdRIFFStream* pIRiffStream, UINT wType, BOOL fFullSave);
	HRESULT SaveAs(IStream* pIStream, bool bPromptForFileName);
	HRESULT SaveAs(IStream* pIStream);
	HRESULT LoadData(IDMUSProdRIFFStream* pIRiffStream, MMCKINFO* pckMain);
	HRESULT LoadHeader(IDMUSProdRIFFStream* pIRiffStream, MMCKINFO* pckMain);
	HRESULT	WriteRIFFHeaderToStream(IStream* pIStream, DWORD* pdwBytesWritten);
	HRESULT PrepareForSave(CString sNewFileName);
	HRESULT CleanupAfterSave(CString sFileName);

	HRESULT ReadWVST(IStream* pIStream, MMCKINFO* pckMain);


	HRESULT Download(IDirectMusicPortDownload* pIDMPortDownLoad);
	HRESULT Unload(IDirectMusicPortDownload* pIDMPortDownLoad);
	HRESULT DM_Init(IDirectMusicPortDownload* pIDMPortDownLoad);

	HRESULT UpdateWave();
	HRESULT	UpdateDecompressedWave(const WAVEFORMATEX* pwfxDst);
	HRESULT	SwitchCompression(bool bSwitch);
	virtual void UpdateLoopInRegions();						// Updates the regions using this wave for the loop changes
	void	SyncWaveProperties(bool bCopyFromChannels = true);

    CString GetUndoMenuText(bool bRedo = false);
    HRESULT SaveUndoState(UINT uUndoStrID);
	void	UpdateOnUndo(HEADER_INFO headerInfo);		// Refreshes the wave with the header information
	HRESULT	RefreshWave();								// Forces the wave to refetch it's data and update the views
    HRESULT Undo();
    HRESULT Redo();
    HRESULT PopUndoState();

	void	SetCollection(CCollection* pCollection);

	HRESULT CopySelectionToClipboard(IStream* pIStream, DWORD dwStart, DWORD dwEnd);
	HRESULT PasteSelectionFromClipboard(IStream* pIStream, DWORD dwStart);
    HRESULT WriteDataToClipboard(IStream* pIStream, DWORD dwStartSample, DWORD dwClipLength);
	HRESULT RemoveSelection(DWORD dwStart, DWORD dwEnd);
	HRESULT InsertWaveData(BYTE* pbData, WAVEFORMATEX wfxDataFormat, DWORD dwSamples, DWORD dwStart);
	HRESULT	OnWaveBufferUpdated();
	HRESULT Fade(bool bFadeDirection, DWORD dwStart, DWORD dwEnd);
	HRESULT InsertSilence(DWORD dwStart, DWORD dwLength);
	HRESULT Resample(DWORD dwNewSampleRate);
	HRESULT SetLoop(DWORD dwStart, DWORD dwEnd);
	HRESULT CopyLoop();
	HRESULT FindBestLoop(DWORD dwLoopStart, DWORD dwFindStart, DWORD dwFindEnd, int nFindWindow, DWORD* pdwBestLoopEnd);
	void	SnapToZero(DWORD& dwSample, UINT nDirection = SNAP_BOTH);

    void	RememberLoopBeforeCompression();					// Saves the loop points set before the compression
    void    RevertToLoopBeforeCompression();					// Reverts to the saved loop points
    void    RememberLoopAfterCompression();						// Saves the loop points set after the compression
	void	RevertToAfterCompression();						// Reverts to the saved decompressed start and loop points

	HRESULT Compress(const WAVEFORMATEX* pwfxDst, bool bInUndoRedo = false);
	DWORD	GetCompressionFormatTag();
	HRESULT GetCompressionFormat(WAVEFORMATEX* pwfxCompression);
    HRESULT	UpdateChannelsForStereoCompression();		// Updates the m_DEcompressedWavObj members of left and right channel waves

	DWORD	GetDataSize();				// Size of either the uncompressed or decompressed wave (depending on m_bCompressed flag)
	DWORD	GetCompressedDataSize();	// Size of the compressed wave
	DWORD	GetUncompressedDataSize();	// This is always the size of the original wave
	HRESULT CloseSourceHandler();		// Closes the source file handlers
	HRESULT FileNameChanged(CString sNewFileName);

	BOOL	IsTrueStereo();

	HRESULT	GetPlayTimeForTempo(int nTempo, DWORD& dwPlayTime);	// Computes the time required for this wave to play once at the passed tempo

	// Drawing methods
	void	OnDraw(CDC* pDC, const CRect& rcClient);// Draws the wave on the DC within the passed rect
	void	OnDraw(CDC* pDC, const CRect& rcClient, const long lScrollOffset,
					DWORD& dwStartSample, DWORD dwLength,
					float fSamplesPerPixel, const WaveDrawParams* pDrawParams, const WaveTimelineInfoParams* pInfoParams);
    void    RefreshDrawBuffer();

	CString		GetName();							// Return the name of the wave
	int			GetNumberOfLoops();					// How many loops?
	ULONG		GetWavePoolOffset();				// Offset of this wave in the collection
 		
	void		SetWSMPL(WSMPL& newWSMPL);			// Sets the WSMPL values
	void		SetWLOOP(WLOOP& newWLOOP);			// Sets the WLOOP values
	void		SetRSMPL(RSMPL& newRSMPL);			// Sets the RSMPL values
	void		SetRLOOP(RLOOP& newRLOOP);			// Sets the RLOOP values

	CMonoWave* GetLeftChannel();					// Returns the left channel wave
	CMonoWave* GetRightChannel();					// Returns the right channels wave

	GUID GetGUID();									// GUID that identifies this stereo wave
	void SetGUID(const GUID& guidSrc);				// Set the GUID to identify this stereo wave (this may be used at the load time)

	void SetPreviousRegionLinkIDs(DWORD dwLeft, DWORD dwRight);

	HRESULT		OnSourceRenamed(CString sNewName);

	/* returns channel count */
	virtual LONG GetChannelCount() { return 2; }

	/* returns given channel */
	virtual CMonoWave *GetChannel(LONG iChannel);
	
	/* sets wavelink parameters according to channel number, returns the channel */
	virtual void SetWaveLinkPerChannel(LONG iChannel, WAVELINK *pwl);

private:

	HRESULT	CompressStereoData(const WAVEFORMATEX* pwfxDst, bool bInUndoRedo = false);	// Compresses TRUE stereo data
	HRESULT ConvertStereoData(const DMUSP_WAVEOBJECT& sourceWave, 
						const WAVEFORMATEX* pwfxDst, 
						DMUSP_WAVEOBJECT &pConvertedWave, 
						bool bEncode);							// Convert the stereo data to the passed destination format

	void	GetTrueStereoFormat(WAVEFORMATEX& wfxPCM);	// Returns the true stereo format for this wave
	
	void	CopyInfo(CInfo* pSrcInfo, CInfo* pDstInfo);	// Copies the m_Info members

	HRESULT IsStereoCompressed(IDMUSProdRIFFStream* pIRiffStream, MMCKINFO* pckMain, bool& bStereoCompressed);
	HRESULT InterleaveBuffersForStereoData(BYTE* pbLeft, BYTE* pbRight, BYTE* pbStereoData, WAVEFORMATEX wfxData, DWORD dwDataSize);
	HRESULT InterleaveChannelsForStereoData();
	HRESULT WriteStereoFormat(IDMUSProdRIFFStream* pIRiffStream, bool bRuntime);
	HRESULT	WriteCompressionChunk(IDMUSProdRIFFStream* pIRiffStream, bool bRuntime);
	HRESULT WriteStereoData(IDMUSProdRIFFStream* pIRiffStream, bool bRuntime);
	HRESULT	WriteInterleavedData(IStream* pIStream);
	HRESULT WriteCompressedData(IDMUSProdRIFFStream* pIRiffStream);
	HRESULT WriteFACTChunk(IDMUSProdRIFFStream* pIRiffStream);
	HRESULT WriteRSMPLChunk(IDMUSProdRIFFStream* pIRiffStream);
	HRESULT WriteWSMPLChunk(IDMUSProdRIFFStream* pIRiffStream);

	HRESULT LoadCompressedStereoData(IDMUSProdRIFFStream* pIRiffStream, MMCKINFO* pckMain);
	HRESULT ReadFormatChunk(IDMUSProdRIFFStream* pIRiffStream);
	HRESULT ReadWSMPLChunk(IDMUSProdRIFFStream* pIRiffStream, DWORD dwChunkSize);
	HRESULT ReadRSMPLChunk(IDMUSProdRIFFStream* pIRiffStream, DWORD dwChunkSize);

private:
	BOOL		m_bIsPlaying;
	GUID		m_guidStereoWave;		// This GUID used to identify mono waves that 
									// (as separate channels) belong to this Stereo wave

	CMonoWave*	m_pLeftChannel;
	CMonoWave*	m_pRightChannel;

	bool		m_bLoadingRuntime;
	BOOL		m_bTrueStereo;

};


#endif // __STEREOWAVE_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\DLSDesigner\stream.cpp ===
/****************************************************************************

    Contains the implementation of CFileStream

    Copyright (c) Microsoft Corporation  1994,  1995
    
    Stolen and Modified 3/5/96 by Mark Burton from 10/10/95 Brian McDowell

*******************************************************************************/
#include <string.h>
#include "stdafx.h"
#include "stream.h"

#define FILE_BEGIN	0
#define FILE_CURRENT	1
#define	FILE_END	2

// ---------------------------------------------------
//  AllocFileStream()
// ---------------------------------------------------
STDAPI AllocFileStream(LPSTREAM FAR *ppStream, const char *pAbsFilePath, DWORD dwOffset, DWORD dwFlags)
{
	HRESULT		hr = E_OUTOFMEMORY;
    CFileStream *pStream;
	
	pStream = new CFileStream;

	if (pStream)
	{
		pStream->AddRef();

		hr = pStream->Init(pAbsFilePath, dwOffset, dwFlags);

		if (SUCCEEDED(hr))
		{
			*ppStream = pStream;
		}
		else
		{
			pStream->Release();
		}
	}

    return(hr);
}

// ---------------------------------------------------
//  AllocStreamFromFile()
// ---------------------------------------------------
STDAPI AllocStreamFromFile(LPSTREAM FAR *ppStream, const char *pAbsFilePath, DWORD dwOffset)
{
	return AllocFileStream(ppStream,pAbsFilePath,dwOffset,STREAM_READ);
}


// ---------------------------------------------------
//  AllocStreamToFile()
// ---------------------------------------------------
STDAPI AllocStreamToFile(LPSTREAM FAR *ppStream, const char *pAbsFilePath, DWORD dwOffset)
{
	return AllocFileStream(ppStream,pAbsFilePath,dwOffset,STREAM_WRITE);
}




// ************************************************************************
// ************************************************************************
//
//  CFileStream
//
// ************************************************************************
// ************************************************************************

// ---------------------------------------------------
//  CFileStream
// ---------------------------------------------------
CFileStream::CFileStream(void)
{
    m_RefCnt = 0;
    m_szFileName[0] = '0';
    m_dwStartOffset = 0;
}

// ---------------------------------------------------
//  ~CFileStream
// ---------------------------------------------------
CFileStream::~CFileStream()
{
    // close file if it is open
    if (m_hFile)
    {
        _lclose(m_hFile);
        m_hFile = NULL;
    }
}

// ---------------------------------------------------
//  CFileStream::AddRef()
// ---------------------------------------------------
STDMETHODIMP_(ULONG) CFileStream::AddRef() 
{ 
    return ++m_RefCnt;
} 

// ---------------------------------------------------
//  CFileStream::Release()
// ---------------------------------------------------
STDMETHODIMP_(ULONG) CFileStream::Release() 
{
    DWORD RefCnt = --m_RefCnt;
    if (RefCnt == 0)
        delete this; 
    return RefCnt; 
}

// ---------------------------------------------------
//  CFileStream::QueryInterface()
// ---------------------------------------------------
STDMETHODIMP CFileStream::QueryInterface(REFIID iid, LPVOID* ppvObj) 
{ 
//    ASSERT(ppvObj);

    *ppvObj = NULL;

    if (IsEqualIID(iid, IID_IUnknown))
        *ppvObj = (LPVOID)(LPUNKNOWN)this;

    if (IsEqualIID(iid, IID_IStream))
        *ppvObj = (LPVOID)(LPSTREAM)this;

    if (*ppvObj)
    {
        ((LPUNKNOWN)*ppvObj)->AddRef();
        return NOERROR;
    }
    return E_NOINTERFACE;
} 


// ---------------------------------------------------
//  CFileStream::Init
// ---------------------------------------------------
STDMETHODIMP CFileStream::Init(const char *pAbsFilePath, DWORD dwOffset, DWORD fdwFlags)
{
	HRESULT hr = E_FAIL;

	m_fdwFlags = fdwFlags;

	if (m_fdwFlags & STREAM_READ)
	{ 
	    // open the file read only
	    m_hFile = _lopen(pAbsFilePath, OF_READ|OF_SHARE_DENY_WRITE);

	    // if we opened it, and we could seek to position specified
	    if ((m_hFile != HFILE_ERROR) && (_llseek(m_hFile, (long)dwOffset, FILE_BEGIN) != HFILE_ERROR))
	    {
	        // then set up all of our variables
	        strcpy(m_szFileName, pAbsFilePath);

	        m_dwStartOffset = dwOffset;
	       	m_dwLength = 0;
			m_fInited = TRUE;
	    }
	}
	else if (m_fdwFlags & STREAM_WRITE)
	{
		// create the file if it does not exist.
		// first, see if it exists by opening for reading.
//		m_hFile = _lopen(pAbsFilePath, OF_READ);

//		if (m_hFile == HFILE_ERROR) // file doesn't exist!
//		{
			m_hFile = _lcreat(pAbsFilePath,0);
//		}
		if (m_hFile != HFILE_ERROR)
		{
			_lclose(m_hFile);

		    // open the file writing
		    m_hFile = _lopen(pAbsFilePath, OF_WRITE|OF_SHARE_DENY_READ);

			if (m_hFile != HFILE_ERROR)
			{
				m_fInited = TRUE;
			}
		}
	}
	
	if (m_fInited)
	{
		hr = S_OK;
	}

	return(hr);
}




// ---------------------------------------------------
//  CFileStream::Read()
// ---------------------------------------------------
STDMETHODIMP CFileStream::Read(THIS_ void HUGEP * pv, ULONG cb, ULONG * pcbRead)
{ 
    long cbRead;
	HRESULT hr = E_POINTER;

    if (pv)
    {
        cbRead = _hread( m_hFile, pv, cb );

        if (cbRead != HFILE_ERROR)
		{
			if (pcbRead)
			{
				*pcbRead = (ULONG)cbRead;
			}

			hr = S_OK;
		}
		else
		{
			hr = E_FAIL;
		}
    }

    return(hr);
} 

// ---------------------------------------------------
//  CFileStream::Seek()
// ---------------------------------------------------
STDMETHODIMP CFileStream::Seek(THIS_ LARGE_INTEGER dlibMove, DWORD dwOrigin, ULARGE_INTEGER * pliNewPosition)
{
	HRESULT hr = E_FAIL;
	long	lOffset = HFILE_ERROR;

    switch (dwOrigin)
    {
    case STREAM_SEEK_SET : 
        lOffset = _llseek(m_hFile, (long)(m_dwStartOffset + dlibMove.LowPart), FILE_BEGIN);
        break;

    case STREAM_SEEK_CUR : 
        lOffset = _llseek(m_hFile, (long)dlibMove.LowPart, FILE_CURRENT);
        break;

    case STREAM_SEEK_END :
        lOffset = _llseek(m_hFile, (long)dlibMove.LowPart, FILE_END);
        break;
    
    default:
    	break;
//        ASSERTSZ(FALSE,"Invalid Flag for Stream::Seek");
    }

	if (lOffset == HFILE_ERROR)
	{
		hr = E_FAIL;
	}
	else
	{ 
		hr = S_OK;

		if (pliNewPosition)
		{
			pliNewPosition->LowPart = _llseek(m_hFile, 0, FILE_CURRENT);
			pliNewPosition->HighPart = 0;
		}
	}

    return hr;
} 

// ---------------------------------------------------
//  CFileStream::Write()
// ---------------------------------------------------

STDMETHODIMP CFileStream::Write(THIS_ VOID const HUGEP * pv, ULONG cb, ULONG * pcbWritten)
{   
	 return ((*pcbWritten = _hwrite(m_hFile, (LPCSTR) pv, cb)) == -1)
               ? E_FAIL : S_OK; 
}

// NOT IMPLEMENTED CFileStream IStream methods

STDMETHODIMP CFileStream::Clone(THIS_ IStream ** ppFileStream)
{   return E_NOTIMPL; }

STDMETHODIMP CFileStream::SetSize(THIS_ ULARGE_INTEGER libNewSize)
{   return E_NOTIMPL; }

STDMETHODIMP CFileStream::CopyTo(THIS_ IStream * pStm, ULARGE_INTEGER cb,   ULARGE_INTEGER * pcbRead, ULARGE_INTEGER * pcbWritten)
{   return E_NOTIMPL; }

STDMETHODIMP CFileStream::Commit(THIS_ DWORD grfCommitFlags)
{   return E_NOTIMPL; }

STDMETHODIMP CFileStream::Revert(THIS)
{   return E_NOTIMPL; }

STDMETHODIMP CFileStream::LockRegion(THIS_ ULARGE_INTEGER libOffset, ULARGE_INTEGER cb, DWORD dwLockType)
{   return E_NOTIMPL; }

STDMETHODIMP CFileStream::UnlockRegion(THIS_ ULARGE_INTEGER libOffset, ULARGE_INTEGER cb,   DWORD dwLockType)
{   return E_NOTIMPL; }

STDMETHODIMP CFileStream::Stat(THIS_ STATSTG * pstatstg, DWORD grfStatFlag)
{   return E_NOTIMPL; }
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\DLSDesigner\stream.h ===
/****************************************************************************

    Contains the definition for IStream interface

    Copyright (c) Microsoft Corporation  1994,  1995
    
    Stolen and Modified 3/5/96 by Mark Burton from 2/21/95 Tom Laird-McConnell

*******************************************************************************/

#ifndef _CStreams_
#define _CStreams_

#include "riffstrm.h"

STDAPI AllocStreamToFile(LPSTREAM FAR *ppStream, const char *pAbsFilePath, DWORD dwOffset);
STDAPI AllocStreamFromFile(LPSTREAM FAR *ppStream, const char *pAbsFilePath, DWORD dwOffset);
enum STREAM_MODES 
{
	STREAM_WRITE			= 	1,		
	STREAM_READ				= 	2,		
};

// **************************************
//
// CFileStream
//
// Implementation of IStream interface, and IUnknown
//
// **************************************
class CFileStream : public IStream
{
private:
    int     m_RefCnt;
    char    m_szFileName[255];
    
    HFILE   m_hFile;
    DWORD   m_dwStartOffset;
    DWORD   m_dwLength;
    DWORD	m_fdwFlags;
	BOOL	m_fInited;

public:
    CFileStream(void);
    ~CFileStream();

    STDMETHODIMP	Init(const char *pAbsFilePath,DWORD dwOffset,DWORD fdwFlags);

    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj);
    STDMETHOD_(ULONG,AddRef) (THIS) ;
    STDMETHOD_(ULONG,Release) (THIS);

    // *** IStream methods ***
    STDMETHOD(Read) (THIS_ VOID HUGEP *pv,
                     ULONG cb, ULONG FAR *pcbRead);
    STDMETHOD(Write) (THIS_ VOID const HUGEP *pv,
            ULONG cb,
            ULONG FAR *pcbWritten);
    STDMETHOD(Seek) (THIS_ LARGE_INTEGER dlibMove,
               DWORD dwOrigin,
               ULARGE_INTEGER FAR *plibNewPosition);
    STDMETHOD(SetSize) (THIS_ ULARGE_INTEGER libNewSize);
    STDMETHOD(CopyTo) (THIS_ IStream FAR *pstm,
             ULARGE_INTEGER cb,
             ULARGE_INTEGER FAR *pcbRead,
             ULARGE_INTEGER FAR *pcbWritten);
    STDMETHOD(Commit) (THIS_ DWORD grfCommitFlags);
    STDMETHOD(Revert) (THIS);
    STDMETHOD(LockRegion) (THIS_ ULARGE_INTEGER libOffset,
                 ULARGE_INTEGER cb,
                 DWORD dwLockType);
    STDMETHOD(UnlockRegion) (THIS_ ULARGE_INTEGER libOffset,
                 ULARGE_INTEGER cb,
                 DWORD dwLockType);
    STDMETHOD(Stat) (THIS_ STATSTG FAR *pstatstg, DWORD grfStatFlag);
    STDMETHOD(Clone)(THIS_ IStream FAR * FAR *ppstm);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\DLSDesigner\UndoMan.cpp ===
// CUndoNode implementation file

#include "stdafx.h"
#include "DLSDesignerDLL.h"
#include "UndoMan.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

GUID CUndoMan::m_guidUndoStream;

CUndoNode::CUndoNode()
{
	// initialize member variables
	m_pPrev = NULL;
	m_pNext = NULL;
	m_pIMemStream = NULL;
	m_nUndoLevel = DEFAULT_UNDO_LEVEL;
}
CUndoNode::~CUndoNode()
{
	// release the memory stream
	if( m_pIMemStream )  {
		m_pIMemStream->Release();
}	}

CUndoNode* CUndoNode::SaveState( IPersistStream *pIPStream, char *pszText )
{
	CUndoNode  *pDel, *pPrev;
	short n;

	// delete all redo nodes from this point
	while( m_pNext )
	{
		pDel = m_pNext;
		m_pNext = m_pNext->m_pNext;
		delete pDel;
	}

	// scan the list backward until no more nodes or undo level is reached
	pPrev = m_pPrev;
	n = 0;
	while( pPrev  &&  n < m_nUndoLevel )
	{
		pPrev = pPrev->m_pPrev;
		n++;
	}
	// terminate the new head
	if( pPrev )  {
		if( pPrev->m_pNext )  {
			pPrev->m_pNext->m_pPrev = NULL;
	}	}

	// delete oldest undo nodes past max level
	while( pPrev )
	{
		pDel = pPrev;
		pPrev = pPrev->m_pPrev;
		delete pDel;
	}

	// create a new node
	m_pNext = new CUndoNode;
	
	// Out Of Memory!
	if(m_pNext == NULL)
		return NULL;

	if( m_pNext )
	{
		// attach the new node to the list
		m_pNext->m_pPrev = this;
		m_pNext->m_pNext = NULL;

		// copy the text string
		lstrcpyn( m_pNext->m_szMenuText, pszText, sizeof(m_szMenuText) - 1 );

		// set the undo level to the same
		m_pNext->m_nUndoLevel = m_nUndoLevel;

		// create a memory stream
		if( SUCCEEDED( theApp.m_pFramework->AllocMemoryStream( FT_DESIGN, CUndoMan::m_guidUndoStream, &m_pNext->m_pIMemStream ) ) )
		{
			// write the current data to it, leave it dirty
			if(SUCCEEDED(pIPStream->Save( m_pNext->m_pIMemStream, FALSE )))
			{
				return m_pNext;
			}
			else
			{
				// Save Failed!!
				delete m_pNext;
				m_pNext = NULL;
				return NULL;
			}
		}
		delete m_pNext;
	}
	return this;
}




CUndoNode* CUndoNode::Undo( IPersistStream *pIPStream )
{
	// check for valid undo
#ifdef _DEBUG
	ASSERT(m_pPrev);
#endif
	if( m_pPrev == NULL )  
	{
		return this;
	}

	// save the current state if there is no redo
	if( m_pNext == NULL )  
	{
		SaveState( pIPStream, "!" );
	}

	// rewind the memory stream and load it
	LARGE_INTEGER largeint;
	largeint.LowPart = 0;
	largeint.HighPart = 0;
	m_pIMemStream->Seek( largeint, STREAM_SEEK_SET, NULL );
	if( SUCCEEDED(pIPStream->Load( m_pIMemStream )) )
	{
		// return the previous node
		return m_pPrev;
	}
	return this;
}

CUndoNode* CUndoNode::Redo( IPersistStream *pIPStream )
{
	// check for a valid redo node
#ifdef _DEBUG
	ASSERT(m_pNext);
	ASSERT(pIPStream);
#endif
	if( m_pNext == NULL )  
	{
		return this;
	}
	if( m_pNext->m_pNext == NULL )  {
		return this;
	}

	LARGE_INTEGER largeint;
	largeint.LowPart = 0;
	largeint.HighPart = 0;

	// must skip next, which is the action we just undid
	m_pNext->m_pNext->m_pIMemStream->Seek( largeint, STREAM_SEEK_SET, NULL );
	if( SUCCEEDED(pIPStream->Load( m_pNext->m_pNext->m_pIMemStream )) )
	{
		// return the next node
		return m_pNext;
	}
	return this;
}

BOOL  CUndoNode::GetUndo( char *pszText, int nMaxCount )
{
	if( m_pPrev == NULL )
	{
		// nothing to undo
		return FALSE;
	}
	// copy the undo text
	lstrcpyn( pszText, m_szMenuText, nMaxCount );
	return TRUE;
}

BOOL  CUndoNode::GetRedo( char *pszText, int nMaxCount )
{
	if( m_pNext )
	{
		// check the next of next for validity
		if( m_pNext->m_pNext )  {
			lstrcpyn( pszText, m_pNext->m_szMenuText, nMaxCount );
			return TRUE;
	}	}
	// nothing to redo
	return FALSE;
}

void  CUndoNode::Destroy()
{
	CUndoNode  *pDel;

	// delete all redo nodes from this
	while( m_pNext )
	{
		pDel = m_pNext;
		m_pNext = m_pNext->m_pNext;
		delete pDel;
	}

	// delete all undo nodes from this
	while( m_pPrev )
	{
		pDel = m_pPrev;
		m_pPrev = m_pPrev->m_pPrev;
		delete pDel;
	}
	delete this;
}

void  CUndoNode::SetUndoLevel( long nUndoLevel )
{
	CUndoNode  *pScan = m_pNext;

	// set level for all redo nodes from this
	while( pScan )  {
		pScan->m_nUndoLevel = nUndoLevel;
		pScan = pScan->m_pNext;
	}
	// set level for all undo nodes from this
	pScan = m_pPrev;
	while( pScan )  {
		pScan->m_nUndoLevel = nUndoLevel;
		pScan = pScan->m_pPrev;
	}
	m_nUndoLevel = nUndoLevel;
}

CUndoNode* CUndoNode::DeleteState()
{
	CUndoNode* pNextNode = NULL;
	CUndoNode* pDeletenode = this;
	CUndoNode* pNewTopNode = NULL;

	if(m_pNext)
	{
		pNextNode = m_pNext;
		pNextNode->m_pPrev = m_pPrev;
	}

	if(m_pPrev)
	{
		m_pPrev->m_pNext = pNextNode;
		pNewTopNode = m_pPrev;
	}

	delete this;

	return pNewTopNode;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\DLSDesigner\UndoMan.h ===
// Standard Jazz Undo Manager Class - header file

#define MENU_TEXT_SIZE  32
#define DEFAULT_UNDO_LEVEL  8

class CUndoNode
{
private:
	// The UndoMan class forms a double linked list that grows and shrinks
	// from both sides.  Only a pointer to the current node is necessary
	// for the app to maintain.  Prev of the current node are undo items.
	// Next of the current node are redo items.
	CUndoNode  *m_pNext;
	CUndoNode  *m_pPrev;

	// Each node maintains an memory stream with the actual state data and
	// a short text string identifying the operation that the data being
	// stored would undo.  This text is usually displayed in the edit menu
	// with the Undo and Redo items as a confirmation to the user.
	IStream  *m_pIMemStream;
	char  m_szMenuText[MENU_TEXT_SIZE];
	long  m_nUndoLevel;

public:
	CUndoNode();
	~CUndoNode();

	// These functions return a pointer to the new current node.  The current
	// node pointer must be assigned the return value for the class to work
	// properly.
	CUndoNode*	SaveState( IPersistStream *pIPStream, char *psz );
	CUndoNode*	Undo( IPersistStream *pIPStream );
	CUndoNode*	Redo( IPersistStream *pIPStream );
	CUndoNode*	DeleteState();

	// GetUndo and GetRedo return FALSE if the operation is not possible, and
	// in this case, nothing is copied into pszText.
	BOOL  GetUndo( char *pszText, int nMaxCount );
	BOOL  GetRedo( char *pszText, int nMaxCount );

	// Destroy is a convenience function to delete all undo and redo nodes.
	void  Destroy();
	void  SetUndoLevel( long nUndoLevel );

	
};

// CUndoMan is a wrapper class to hide the current node pointer.
class CUndoMan
{
private:
	CUndoNode  *m_pCurrentNode;
	
public:
	CUndoMan()  
	{
		m_pCurrentNode = new CUndoNode;
		::CoCreateGuid(&m_guidUndoStream);
	}
	
	~CUndoMan()  
	{
		m_pCurrentNode->Destroy();
	}
	

	inline HRESULT SaveState( IPersistStream *pIPStream, char *psz )  
	{
		CUndoNode*  pCurrentNode = NULL;
		pCurrentNode = m_pCurrentNode->SaveState( pIPStream, psz );
		if(pCurrentNode == NULL)
		{
			return E_FAIL;
		}

		m_pCurrentNode = pCurrentNode;
		return S_OK;
	}
	
	inline void Undo( IPersistStream *pIPStream )  
	{
		m_pCurrentNode = m_pCurrentNode->Undo( pIPStream );
	}
	
	inline void Redo( IPersistStream *pIPStream )  
	{
		m_pCurrentNode = m_pCurrentNode->Redo( pIPStream );
	}
	
	inline BOOL  GetUndo( char *pszText, int nMaxCount )  
	{
		return m_pCurrentNode->GetUndo( pszText, nMaxCount );
	}
	
	inline BOOL  GetRedo( char *pszText, int nMaxCount )  
	{
		return m_pCurrentNode->GetRedo( pszText, nMaxCount );
	}
	
	inline void  SetUndoLevel( long nUndoLevel )  
	{
		m_pCurrentNode->SetUndoLevel( nUndoLevel );
	}	
	inline void DeleteState()	
	{
		m_pCurrentNode = m_pCurrentNode->DeleteState();
	}

public:
	static GUID m_guidUndoStream;
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\DLSDesigner\UserPatchConflictDlg.cpp ===
// UserPatchConflictDlg.cpp : implementation file
//

#include "stdafx.h"
#include "dlsdesigner.h"
#include "UserPatchConflictDlg.h"
#include "DlsDefsPlus.h"
#include "Collection.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

extern BInstr abiGS[];
extern BInstr abiDrums[];
extern const DWORD  dwabiGSInstruments;
extern const DWORD dwabiDrums;

/////////////////////////////////////////////////////////////////////////////
// CUserPatchConflictDlg dialog

CUserPatchConflictDlg::CUserPatchConflictDlg(HRESULT hrCode, ULONG ulBank, ULONG ulPatch, CInstrument* pCollidingInstrument)
	: CDialog(CUserPatchConflictDlg::IDD),
m_ulCheckedBank(ulBank),
m_ulCheckedPatch(ulPatch),
m_pCollidingInstrument(pCollidingInstrument),
m_hrConflictCause(hrCode)
{
	//{{AFX_DATA_INIT(CUserPatchConflictDlg)
	m_bIgnoreAll = FALSE;
	//}}AFX_DATA_INIT
}


void CUserPatchConflictDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CUserPatchConflictDlg)
	DDX_Control(pDX, IDC_CONFLICT_NOT_AGAIN_CHECK, m_NotAgainCheck);
	DDX_Check(pDX, IDC_IGNORE_CHECK, m_bIgnoreAll);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CUserPatchConflictDlg, CDialog)
	//{{AFX_MSG_MAP(CUserPatchConflictDlg)
	ON_BN_CLICKED(IDC_CONFLICT_NOT_AGAIN_CHECK, OnConflictNotAgainCheck)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

void CUserPatchConflictDlg::InitDlgText()
{
	CString		csDlgPrompt;
	CString		csCatStr;
	CString		csCheckStr;
	CWnd*		pEdit;
	
	//Construct the correct message for the dialog's static text

	csDlgPrompt.LoadString(IDS_ERR_PATCH);
	if (m_hrConflictCause & SC_PATCH_DUP_GM)
	{
		csCatStr.LoadString(IDS_PATCH_CONFLICT_GM);
		
		pEdit = GetDlgItem(IDC_CONFLICTING_INS);
		if (pEdit)
		{
			CString strInstName;
			GetGMInstName(strInstName);
			pEdit->SetWindowText(strInstName);
			pEdit = NULL;
		}

		pEdit = GetDlgItem(IDC_CONFLICT_COLLECTION);
		if (pEdit)
		{
			pEdit->SetWindowText(_T("GM"));
			pEdit = NULL;
		}
		csCheckStr.LoadString(IDS_IGNORE_CHECK_GM);
	}
	else if (m_hrConflictCause & SC_PATCH_DUP_COLLECTION)
	{
		csCatStr.LoadString(IDS_PATCH_CONFLICT_COLLECTION);
		pEdit = GetDlgItem(IDC_CONFLICTING_INS);
		if (pEdit)
		{
			pEdit->SetWindowText(m_pCollidingInstrument->m_Info.m_csName.GetBuffer(0));
			pEdit = NULL;
		}
		pEdit = GetDlgItem(IDC_CONFLICT_COLLECTION);
		if (pEdit && m_pCollidingInstrument->m_pCollection)
		{
			pEdit->SetWindowText(m_pCollidingInstrument->m_pCollection->m_Info.m_csName.GetBuffer(0));
			pEdit = NULL;
		}

		csCheckStr.LoadString(IDS_IGNORE_CHECK_COLLECTION);
	}
	else if (m_hrConflictCause & SC_PATCH_DUP_SYNTH)
	{
		csCatStr.LoadString(IDS_PATCH_CONFLICT_GENERAL);
		pEdit = GetDlgItem(IDC_CONFLICT_COLLECTION);
		if (pEdit)
		{
			pEdit->SetWindowText(m_pCollidingInstrument->m_pCollection->m_Info.m_csName.GetBuffer(0));
			pEdit = NULL;
		}
		pEdit = GetDlgItem(IDC_CONFLICTING_INS);
		if (pEdit)
		{
			pEdit->SetWindowText(m_pCollidingInstrument->m_Info.m_csName.GetBuffer(0));
			pEdit = NULL;
		}
		csCheckStr.LoadString(IDS_IGNORE_CHECK_SYNTH);
	}
	csDlgPrompt += csCatStr; 
	CWnd* pPromptText = GetDlgItem(IDC_CONFLICT_DESC_TEXT);
	if ( pPromptText )
	{
		pPromptText->SetWindowText(csDlgPrompt.GetBuffer(0));
		pPromptText = NULL;
	}
	
	pPromptText = GetDlgItem(IDC_IGNORE_CHECK);
	if ( pPromptText )
	{
		pPromptText->SetWindowText(csCheckStr.GetBuffer(0));
	}
}

/////////////////////////////////////////////////////////////////////////////
// CUserPatchConflictDlg message handlers

BOOL CUserPatchConflictDlg::OnInitDialog() 
{
	InitDlgText();
	CDialog::OnInitDialog();
	
	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

void CUserPatchConflictDlg::OnCancel() 
{
	if (!m_bIgnoreAll)
	{
		if (m_hrConflictCause & SC_PATCH_DUP_GM)
		{
			m_hrConflictCause &= ~SC_PATCH_DUP_GM;
			m_iRetVal |= DLS_DLG_IGNORE_ALL_GM;
		}
		else if (m_hrConflictCause & SC_PATCH_DUP_COLLECTION)
		{
			m_hrConflictCause &= ~SC_PATCH_DUP_COLLECTION;
			m_iRetVal |= DLS_DLG_IGNORE_ALL_COLLECTION;
		}
		else if (m_hrConflictCause & SC_PATCH_DUP_SYNTH)
		{
			m_hrConflictCause &= ~SC_PATCH_DUP_SYNTH;
			m_iRetVal |= DLS_DLG_IGNORE_ALL_SYNTH;
		}
		if (DLS_ERR_FIRST == m_hrConflictCause)
		{
			EndDialog(m_iRetVal);
		}
		else
		{
			InitDlgText();
			return;
		}
	}
	else
	{
		EndDialog(IDCANCEL);
	}
}

void CUserPatchConflictDlg::GetGMInstName(CString& strResult)
{
	BYTE bMSB = (BYTE) ((m_ulCheckedBank & 0x00007F00) >> 8);
	BYTE bLSB = (BYTE) (m_ulCheckedBank & 0x0000007F);
	BYTE bPatch = (BYTE)(m_ulCheckedPatch & 0x0000007F);
	BYTE dwDrum =  ((m_ulCheckedBank & 0x80000000) == 0) ? FALSE: TRUE;
	
	BInstr* pArr = dwDrum ? &abiDrums[0] : &abiGS[0];
	ASSERT(pArr);
	if(pArr == NULL)
		return;

	while(pArr->nStringId != IDS_PGMEND)
	{
		if ((pArr->bPatch == bPatch) && (pArr->bMSB == bMSB) &&	(pArr->bLSB == bLSB))
		{
			// This is the one we want!
			strResult.LoadString(pArr->nStringId);
			break;
		}

		pArr++;
	}
}

void CUserPatchConflictDlg::OnConflictNotAgainCheck() 
{
	ASSERT(m_pCollidingInstrument);
	if(m_pCollidingInstrument == NULL)
	{
		return;
	}

	CDLSComponent* pComponent = m_pCollidingInstrument->m_pComponent;
	ASSERT(pComponent);
	if(pComponent == NULL)
	{
		return;
	}

	int nCheck = m_NotAgainCheck.GetCheck();
	bool bShow = nCheck == 0 ? false : true;
	pComponent->SetUserPatchConflict(bShow);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\DLSDesigner\VibratoLFODialog.cpp ===
// VibratoLFODialog.cpp : implementation file
//

#include "stdafx.h"
#include "dlsdesigner.h"
#include "vibratolfodialog.h"
#include "Collection.h"
#include "Instrument.h"
#include "Region.h"
#include "DLSStatic.h"
#include "InstrumentFVEditor.h"
#include "Articulation.h"
#include "DlsDefsPlus.h"
#include "UndoMan.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CVibratoLFODialog dialog


CVibratoLFODialog::CVibratoLFODialog(CArticulation* pArticulation) :
CDialog(), CSliderCollection(5),
m_pArticParams(pArticulation->GetArticParams()), 
m_pCollection(NULL)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	ASSERT(m_pArticulation);
	m_pArticulation = pArticulation;

	CInstrument* pInstrument = pArticulation->GetInstrument();
	if(pInstrument)
	{
		// Articulation is owned by an instrument			
		m_pCollection = pInstrument->m_pCollection;
	}
	else
	{
		// Articulation is owned by a region
		CRegion* pRegion = pArticulation->GetRegion();
		ASSERT(pRegion);
		pInstrument = pRegion->GetInstrument();
		ASSERT(pInstrument);
		m_pCollection = pInstrument->m_pCollection;
	}

	CSliderCollection::Init(this);

	//{{AFX_DATA_INIT(CVibratoLFODialog)
	//}}AFX_DATA_INIT
}


BEGIN_MESSAGE_MAP(CVibratoLFODialog, CDialog)
	//{{AFX_MSG_MAP(CVibratoLFODialog)
	ON_WM_HSCROLL()
	ON_WM_DESTROY()
	ON_WM_PAINT()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CVibratoLFODialog message handlers

void CVibratoLFODialog::OnHScroll(UINT nSBCode, UINT nPos, CScrollBar* pScrollBar) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	ASSERT(m_pArticParams);
	if(m_pArticParams == NULL)
	{
		return;
	}

	CSliderCollection::OnHScroll(nSBCode, nPos, pScrollBar);
	CDialog::OnHScroll(nSBCode, nPos, pScrollBar);
}

BOOL CVibratoLFODialog::OnInitDialog() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	CDialog::OnInitDialog();

	m_pmsLFOFrequency = Insert(
		IDC_LFO2_FREQUENCY, IDC_LFO2_DFREQUENCY, IDC_LFO2_FREQUENCY_SPIN,
		MYSLIDER_LFORANGE, FIVE_HERTZ, IDS_UNDO_LFO2_FREQ_EDIT,
		&m_LFOParams.m_pcFrequencyVibrato);

	m_pmsLFODelay = Insert(
		IDC_LFO2_DELAY, IDC_LFO2_DDELAY, IDC_LFO2_DELAY_SPIN,
		MYSLIDER_LFODELAY, Mils2TimeCents(0), IDS_UNDO_LFO2_DELAY_EDIT,
		&m_LFOParams.m_tcDelayVibrato);

	m_pmsLFOPitchScale = Insert(
		IDC_LFO2_PITCH, IDC_LFO2_DPITCH, IDC_LFO2_PITCH_SPIN,
		MYSLIDER_PITCHCENTS, 0, IDS_LFO_PITCH_UNDO_TEXT,
		&m_LFOParams.m_pcPitchScaleVibrato);
	
	m_pmsLFOMWToPitch = Insert(
		IDC_LFO2_MW2PITCH, IDC_LFO2_DMW2PITCH, IDC_LFO2_MW2PITCH_SPIN,
		MYSLIDER_PITCHCENTS, 0, IDS_UNDO_LFO2_MW2PITCH_EDIT,
		&m_LFOParams.m_pcMWToPitchVibrato);

	m_pmsLFOChanPressToPitch = Insert(
		IDC_LFO2_CHANPRESSTOPITCH, IDC_LFO2_DCHANPRESSTOPITCH, IDC_LFO2_CHANPRESSTOPITCH_SPIN,
		MYSLIDER_PITCHCENTS, 0, IDS_UNDO_LFO2_CHANPRESSTOPITCH_EDIT,
		&m_LFOParams.m_pcChanPressToPitchVibrato);

	CollectStatics();

	BOOL bDLS1 = m_pArticulation->IsDLS1();
	EnableDLS2Controls(!bDLS1);

	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

HRESULT CVibratoLFODialog::SaveUndoState(UINT uStringRes)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	CInstrumentFVEditor* pParent = (CInstrumentFVEditor*) GetParent();
	ASSERT(pParent);

	if(pParent && pParent->m_pInstrument)
	{
		if(FAILED(pParent->m_pInstrument->SaveStateForUndo(uStringRes)))
		{
			return E_FAIL;
		}
	}
	else
	{
		return E_FAIL;
	}

	return S_OK;
}

void CVibratoLFODialog::UpdateArticulation(CArticulation* pNewArt)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	m_pArticParams = pNewArt->GetArticParams();

	m_pArticulation = pNewArt;

#ifdef _DEBUG	
	pNewArt->ValidateParent();
#endif

	CInstrument* pInstrument = pNewArt->GetInstrument();
	if(pInstrument)
	{
		// Articulation is owned by an instrument			
		m_pCollection = pInstrument->m_pCollection;
	}
	else
	{
		// Articulation is owned by a region
		CRegion* pRegion = pNewArt->GetRegion();
		ASSERT(pRegion);
		pInstrument = pRegion->GetInstrument();
		ASSERT(pInstrument);
		m_pCollection = pInstrument->m_pCollection;
	}

	m_LFOParams = m_pArticParams->m_LFO;
	m_pmsLFOFrequency->SetValue(this, m_LFOParams.m_pcFrequencyVibrato);
	m_pmsLFODelay->SetValue(this, m_LFOParams.m_tcDelayVibrato);
	m_pmsLFOPitchScale->SetValue(this, m_LFOParams.m_pcPitchScaleVibrato);
	m_pmsLFOMWToPitch->SetValue(this, m_LFOParams.m_pcMWToPitchVibrato);
	m_pmsLFOChanPressToPitch->SetValue(this, m_LFOParams.m_pcChanPressToPitchVibrato);

	BOOL bDLS1 = m_pArticulation->IsDLS1();
	EnableDLS2Controls(!bDLS1);
}

void CVibratoLFODialog::CollectStatics()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	// Remove all previous statics....should there be any?
	while(!m_lstStatics.IsEmpty())
	{
		CDLSStatic* pStatic = (CDLSStatic*) m_lstStatics.RemoveHead();
		ASSERT(pStatic);
		if(pStatic)
		{
			delete pStatic;
		}
	}
	
	CWnd* pChild = GetWindow(GW_CHILD);
	while(pChild)
	{
		char szClassName[MAX_PATH];
		::GetClassName(pChild->m_hWnd, szClassName, MAX_PATH);
		
		// Add it to the list if it's a "Static"
		if(strcmp(szClassName,"Static") == 0)
		{
			CDLSStatic* pDLSStatic = NULL;
			if(SUCCEEDED(CDLSStatic::CreateControl(this, pChild, &pDLSStatic)))
				m_lstStatics.AddTail(pDLSStatic);
		}

		pChild = pChild->GetNextWindow();
	}

	// Destroy the actual static controls now
	POSITION position = m_lstStatics.GetHeadPosition();
	while(position)
	{
		CDLSStatic* pStatic = (CDLSStatic*) m_lstStatics.GetNext(position);
		ASSERT(pStatic);
		CWnd* pWnd = GetDlgItem(pStatic->GetID());
		if(pWnd)
		{
			pWnd->DestroyWindow();
		}
	}
}


void CVibratoLFODialog::OnDestroy() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	CDialog::OnDestroy();
	
	// Remove all previous statics....should there be any?
	while(!m_lstStatics.IsEmpty())
	{
		CDLSStatic* pStatic = (CDLSStatic*) m_lstStatics.RemoveHead();
		ASSERT(pStatic);
		if(pStatic)
		{
			delete pStatic;
		}
	}
}

void CVibratoLFODialog::OnPaint() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	CPaintDC dc(this); // device context for painting
	
	POSITION position = m_lstStatics.GetHeadPosition();
	while(position)
	{
		CDLSStatic* pStatic = (CDLSStatic*) m_lstStatics.GetNext(position);
		ASSERT(pStatic);
		pStatic->OnDraw(&dc);
	}
}

void CVibratoLFODialog::EnableDLS2Controls(BOOL bEnable)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	m_pmsLFOFrequency->EnableControl(this, bEnable != 0);
	m_pmsLFODelay->EnableControl(this, bEnable != 0);
	m_pmsLFOPitchScale->EnableControl(this, bEnable != 0);
	m_pmsLFOMWToPitch->EnableControl(this, bEnable != 0);
	m_pmsLFOChanPressToPitch->EnableControl(this, bEnable != 0);
}

BOOL CVibratoLFODialog::OnCommand(WPARAM wParam, LPARAM lParam) 
{
	LRESULT lResult;
	if (CSliderCollection::OnCommand(wParam, lParam, &lResult))
		return lResult;

	return CDialog::OnCommand(wParam, lParam);
}

BOOL CVibratoLFODialog::OnNotify(WPARAM wParam, LPARAM lParam, LRESULT* pResult) 
{
	LRESULT lResult;
	if (CSliderCollection::OnNotify(wParam, lParam, &lResult))
		return lResult;
	
	return CDialog::OnNotify(wParam, lParam, pResult);
}

void CVibratoLFODialog::UpdateInstrument()
{
	m_pArticParams->m_LFO = m_LFOParams;
	CInstrument* pInstrument = m_pArticulation->GetInstrument();
	if(pInstrument)
	{
		pInstrument->UpdateInstrument();
		if(pInstrument->m_pCollection)
		{
			pInstrument->m_pCollection->SetDirtyFlag();
		}
	}
	else if (m_pArticulation->GetRegion())
	{
		CRegion* pRegion = m_pArticulation->GetRegion();
		ASSERT(pRegion);
		pInstrument = pRegion->GetInstrument();
		ASSERT(pInstrument);
		pInstrument->UpdateInstrument();
		if(pInstrument->m_pCollection)
		{
			pInstrument->m_pCollection->SetDirtyFlag();
		}
	}
}

bool CVibratoLFODialog::OnSliderUpdate(MySlider *pms, DWORD dwmscupdf)
{
	switch (dwmscupdf)
		{
		case dwmscupdfStart:
			if (SUCCEEDED(SaveUndoState(pms->GetUndoStringID())))
				return true;
			UpdateArticulation(m_pArticulation);
			return false;

		case dwmscupdfEnd:
			UpdateInstrument();
			return true;

		default:
			ASSERT(FALSE);
			return false;
		}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\DLSDesigner\vibratolfodialog.h ===
#if !defined(AFX_VIBRATOLFODIALOG_H__EAEB7193_15B2_44DC_AF35_285187CC357F__INCLUDED_)
#define AFX_VIBRATOLFODIALOG_H__EAEB7193_15B2_44DC_AF35_285187CC357F__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// vibratolfodialog.h : header file
//

#include "resource.h"
#include "myslider.h"
#include "DLSLoadSaveUtils.h"

/////////////////////////////////////////////////////////////////////////////
// CVibratoLFODialog dialog

class CArticulation;
class CCollection;

class CVibratoLFODialog : public CDialog, CSliderCollection
{
// Construction
public:
	CVibratoLFODialog(CArticulation* pArticulation);   

public:
	void UpdateArticulation(CArticulation* pNewArt);

// Dialog Data
	//{{AFX_DATA(CVibratoLFODialog)
	enum { IDD = IDD_VIBLFO_PAGE };
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CVibratoLFODialog)
	protected:
	virtual BOOL OnCommand(WPARAM wParam, LPARAM lParam);
	virtual BOOL OnNotify(WPARAM wParam, LPARAM lParam, LRESULT* pResult);
	//}}AFX_VIRTUAL

	// CSliderCollection overrides
	virtual bool OnSliderUpdate(MySlider *pms, DWORD dwmscupdf);

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CVibratoLFODialog)
	afx_msg void OnHScroll(UINT nSBCode, UINT nPos, CScrollBar* pScrollBar);
	virtual BOOL OnInitDialog();
	afx_msg void OnDestroy();
	afx_msg void OnPaint();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

private:

	HRESULT			SaveUndoState(UINT uStringRes);
	void			CollectStatics();
	void			EnableDLS2Controls(BOOL bEnable = TRUE);
	void			UpdateInstrument();

	CPtrList		m_lstStatics;	// List of static controls in the dialog

	CCollection*	m_pCollection;	
	ArticParams*	m_pArticParams;
	LFOParams		m_LFOParams;
	CArticulation*	m_pArticulation;
    
	MySlider*		m_pmsLFOMWToPitch;
	MySlider*		m_pmsLFOFrequency;
    MySlider*		m_pmsLFODelay;
    MySlider*		m_pmsLFOPitchScale;
	MySlider*		m_pmsLFOChanPressToPitch;
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_VIBRATOLFODIALOG_H__EAEB7193_15B2_44DC_AF35_285187CC357F__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\DLSDesigner\VolDialog.cpp ===
// VolDialog.cpp : implementation file
//

#include "stdafx.h"
#include "VolDialog.h"
#include "InstrumentFVEditor.h"
#include "DLSStatic.h"
#include "Articulation.h"
#include "DlsDefsPlus.h"
#include "UndoMan.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CVolDialog dialog


CVolDialog::CVolDialog(CArticulation* pArticulation) :
CDialog(), CSliderCollection(5),
m_pArticParams(pArticulation->GetArticParams()),
m_pCollection(NULL),
m_bInitingDialog(false)
{
	m_pArticulation = pArticulation;
#ifdef _DEBUG	
	pArticulation->ValidateParent();
#endif

	CInstrument* pInstrument = pArticulation->GetInstrument();
	if(pInstrument)
	{
		// Articulation is owned by an instrument			
		m_pCollection = pInstrument->m_pCollection;
		m_pInstrument = pInstrument;
	}
	else
	{
		// Articulation is owned by a region
		CRegion* pRegion = pArticulation->GetRegion();
		ASSERT(pRegion);
		pInstrument = pRegion->GetInstrument();
		ASSERT(pInstrument);
		m_pCollection = pInstrument->m_pCollection;
		m_pInstrument = pInstrument;
	}
	
	//{{AFX_DATA_INIT(CVolDialog)
	m_flAttack = 0.0f;
	m_flDecay = 0.0f;
	m_flRelease = 0.0f;
	m_flSustain = 0.0f;
	m_flDelay = 0.0f;
	m_flHold = 0.0f;
	//}}AFX_DATA_INIT
	m_bfTouched = 0;
	m_bTouchedByProgram = false;

	CSliderCollection::Init(this);
}


void CVolDialog::DoDataExchange(CDataExchange* pDX)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CVolDialog)
	DDX_Control(pDX, IDC_VEG_ADSRENVELOPECTRL, m_VEGASDREnvelope);
	DDX_Text(pDX, IDC_VEG_DATTACK, m_flAttack);
	DDV_MinMaxFloat(pDX, m_flAttack, 1.e-003f, 40.f);
	DDX_Text(pDX, IDC_VEG_DDECAY, m_flDecay);
	DDV_MinMaxFloat(pDX, m_flDecay, 1.e-003f, 40.f);
	DDX_Text(pDX, IDC_VEG_DRELEASE, m_flRelease);
	DDV_MinMaxFloat(pDX, m_flRelease, 1.e-003f, 40.f);
	DDX_Text(pDX, IDC_VEG_DSUSTAIN, m_flSustain);
	DDV_MinMaxFloat(pDX, m_flSustain, 0.f, 100.f);
	DDX_Text(pDX, IDC_VEG_DDELAY, m_flDelay);
	DDV_MinMaxFloat(pDX, m_flDelay, 1.e-003f, 40.f);
	DDX_Text(pDX, IDC_VEG_DHOLD, m_flHold);
	DDV_MinMaxFloat(pDX, m_flHold, 1.e-003f, 40.f);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CVolDialog, CDialog)
	//{{AFX_MSG_MAP(CVolDialog)
	ON_WM_HSCROLL()
	ON_EN_KILLFOCUS(IDC_VEG_DATTACK, OnKillfocusVegDattack)
	ON_EN_KILLFOCUS(IDC_VEG_DDECAY, OnKillfocusVegDdecay)
	ON_EN_KILLFOCUS(IDC_VEG_DRELEASE, OnKillfocusVegDrelease)
	ON_EN_KILLFOCUS(IDC_VEG_DSUSTAIN, OnKillfocusVegDsustain)
	ON_MESSAGE(DM_VALIDATE,OnValidate)
	ON_WM_CTLCOLOR()
	ON_WM_DESTROY()
	ON_WM_PAINT()
	ON_EN_KILLFOCUS(IDC_VEG_DDELAY, OnKillfocusVegDelay)
	ON_EN_KILLFOCUS(IDC_VEG_DHOLD, OnKillfocusVegHold)
	//}}AFX_MSG_MAP
	// This is to get notified of changes to the edit controls
	ON_CONTROL_RANGE(EN_CHANGE, IDC_VEG_DATTACK, IDC_VEG_DHOLD, OnEditChange)
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CVolDialog message handlers

LRESULT CVolDialog::OnValidate(UINT wParam,LONG lParam)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	switch ( wParam )
	{
		case IDC_VEG_DDELAY :
			ValidateDelayTime();
			break;
		case IDC_VEG_DATTACK :
			ValidateAttackTime();
			break;
		case IDC_VEG_DHOLD :
			ValidateHoldTime();
			break;
		case IDC_VEG_DDECAY :
			ValidateDecayTime();
			break;
		case IDC_VEG_DSUSTAIN :
			ValidateSustainLevel();
			break;
		case IDC_VEG_DRELEASE :
			ValidateReleaseTime();
			break;
		default:
			break;
	}
	return 0;
}

//OnEditChange : See VolDialog.h for details about this. (In private member
//				 section of CVolDialog)
void CVolDialog::OnEditChange( UINT nEditControl )
{
	if ( !m_bTouchedByProgram )
		m_bfTouched |= 0x01 << (nEditControl - FIRST_CONTROL);
}

void CVolDialog::OnHScroll(UINT nSBCode, UINT nPos, CScrollBar* pScrollBar) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	ASSERT(m_pArticParams);
	if(m_pArticParams == NULL)
	{
		return;
	}

	ASSERT(m_pInstrument);
	if(m_pInstrument == NULL)
	{
		return;
	}

	ASSERT(m_pCollection);
	if(m_pCollection == NULL)
	{
		return;
	}

	CSliderCollection::OnHScroll(nSBCode, nPos, pScrollBar);
	CDialog::OnHScroll(nSBCode, nPos, pScrollBar);
}

BEGIN_EVENTSINK_MAP(CVolDialog, CDialog)
    //{{AFX_EVENTSINK_MAP(CVolDialog)
	ON_EVENT(CVolDialog, IDC_VEG_ADSRENVELOPECTRL, 4 /* ADSRESustainLevelChanged */, OnADSRESustainLevelChangedVegAdsrenvelopectrl, VTS_I4)
	ON_EVENT(CVolDialog, IDC_VEG_ADSRENVELOPECTRL, 3 /* ADSREReleaseTimeChanged */, OnADSREReleaseTimeChangedVegAdsrenvelopectrl, VTS_I4)
	ON_EVENT(CVolDialog, IDC_VEG_ADSRENVELOPECTRL, 2 /* ADSREAttackTimeChanged */, OnADSREAttackTimeChangedVegAdsrenvelopectrl, VTS_I4)
	ON_EVENT(CVolDialog, IDC_VEG_ADSRENVELOPECTRL, 1 /* ADSREDecayTimeChanged */, OnADSREDecayTimeChangedVegAdsrenvelopectrl, VTS_I4)
	ON_EVENT(CVolDialog, IDC_VEG_ADSRENVELOPECTRL, 5 /* RealDecayChanged */, OnRealDecayChangedVegAdsrenvelopectrl, VTS_I4)
	ON_EVENT(CVolDialog, IDC_VEG_ADSRENVELOPECTRL, 6 /* RealReleaseChanged */, OnRealReleaseChangedVegAdsrenvelopectrl, VTS_I4)
	ON_EVENT(CVolDialog, IDC_VEG_ADSRENVELOPECTRL, 7 /* ADSRMouseMoveStart */, OnADSRMouseMoveStart, VTS_NONE)
	ON_EVENT(CVolDialog, IDC_VEG_ADSRENVELOPECTRL, 9 /* ADSREDelayTimeChanged */, OnADSREDelayTimeChangedVegAdsrenvelopectrl, VTS_I4)
	ON_EVENT(CVolDialog, IDC_VEG_ADSRENVELOPECTRL, 10 /* ADSREHoldTimeChanged */, OnADSREHoldTimeChangedVegAdsrenvelopectrl, VTS_I4)
	//}}AFX_EVENTSINK_MAP
END_EVENTSINK_MAP()

////////////////////////////////////////////////////////////////////////////////
// ADSR control ATTACK Time changed
void CVolDialog::OnADSREAttackTimeChangedVegAdsrenvelopectrl(long NewAttackTime) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	char text[BUFFER_64];
    sprintf(text," %02d.%03d", NewAttackTime / 1000, NewAttackTime % 1000);
	CWnd* pDisplay = GetDlgItem(IDC_VEG_DATTACK);
	
	m_bTouchedByProgram = true;
	pDisplay->SetWindowText(text);
	m_bTouchedByProgram = false;

	if( !m_bInitingDialog )
	{
		if ( !( m_bfTouched & fVEG_DATTACK ) )
		{
			m_pArticParams->m_VolEG.m_tcAttack = Mils2TimeCents(NewAttackTime);
		}

		m_pCollection->SetDirtyFlag();
		m_pInstrument->UpdateInstrument();
	}
}

////////////////////////////////////////////////////////////////////////////////
// ADSR control DECAY Time changed
void CVolDialog::OnADSREDecayTimeChangedVegAdsrenvelopectrl(long NewDecayTime) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	char text[BUFFER_64];
    sprintf(text," %02d.%03d", NewDecayTime / 1000, NewDecayTime % 1000);
	CWnd * pDisplay = GetDlgItem(IDC_VEG_DDECAY);
	
	m_bTouchedByProgram = true;
	pDisplay->SetWindowText(text);
	m_bTouchedByProgram = false;

	if(!m_bInitingDialog)
	{
		if ( !( m_bfTouched & fVEG_DDECAY ) )
			m_pArticParams->m_VolEG.m_tcDecay = Mils2TimeCents(NewDecayTime);
		m_pCollection->SetDirtyFlag();
		m_pInstrument->UpdateInstrument();
	}
}

////////////////////////////////////////////////////////////////////////////////
// ADSR control SUSTAIN Level changed
void CVolDialog::OnADSRESustainLevelChangedVegAdsrenvelopectrl(long NewSustainLevel) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	char text[BUFFER_64];
    sprintf(text," %02d.%d",NewSustainLevel / 10, NewSustainLevel % 10);
	CWnd * pDisplay = GetDlgItem(IDC_VEG_DSUSTAIN);
	
	m_bTouchedByProgram = true;
	pDisplay->SetWindowText(text);
	m_bTouchedByProgram = false;

	if(!m_bInitingDialog)
	{
		m_pArticParams->m_VolEG.m_ptSustain = (PERCENT) NewSustainLevel << 16;
		m_pCollection->SetDirtyFlag();
		m_pInstrument->UpdateInstrument();
	}
}

////////////////////////////////////////////////////////////////////////////////
// ADSR control RELEASE Time changed
void CVolDialog::OnADSREReleaseTimeChangedVegAdsrenvelopectrl(long NewReleaseTime) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	char text[BUFFER_64];
    sprintf(text," %02d.%03d", NewReleaseTime / 1000, NewReleaseTime % 1000);
	CWnd * pDisplay = GetDlgItem(IDC_VEG_DRELEASE);
	
	m_bTouchedByProgram = true;
	pDisplay->SetWindowText(text);
	m_bTouchedByProgram = false;

	if(!m_bInitingDialog)
	{
		if ( !( m_bfTouched & fVEG_DRELEASE ) )
			m_pArticParams->m_VolEG.m_tcRelease = Mils2TimeCents(NewReleaseTime);
		m_pCollection->SetDirtyFlag();
		m_pInstrument->UpdateInstrument();
	}
}

void CVolDialog::OnRealDecayChangedVegAdsrenvelopectrl(long lNewRealDecay) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	CWnd*	pWnd;
	char text[BUFFER_64];

    sprintf(text," %02d.%03d", lNewRealDecay / 1000, lNewRealDecay % 1000);
	pWnd = GetDlgItem(IDC_VEG_RDECAY);
	pWnd->SetWindowText(text);
}

void CVolDialog::OnRealReleaseChangedVegAdsrenvelopectrl(long lNewRealRelease) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	CWnd*	pWnd;
	char text[BUFFER_64];

    sprintf(text," %02d.%03d", lNewRealRelease / 1000, lNewRealRelease % 1000);
	pWnd = GetDlgItem(IDC_VEG_RRELEASE);
	pWnd->SetWindowText(text);	
}


HBRUSH CVolDialog::OnCtlColor(CDC* pDC, CWnd* pWnd, UINT nCtlColor) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	COLORREF crTextColor = 0;
	int nStaticText;

	HBRUSH hbr = CDialog::OnCtlColor(pDC, pWnd, nCtlColor);
	
	nStaticText = pWnd->GetDlgCtrlID();
	switch (nStaticText)
	{
		case IDC_VEG_DELAY_STATIC:
			crTextColor = DELAY_COLOR;
			break;

		case IDC_VEG_ATTACK_STATIC:
			crTextColor = ATTACK_COLOR;
			break;

		case IDC_VEG_HOLD_STATIC:
			crTextColor = HOLD_COLOR;
			break;

		case IDC_VEG_DECAY_STATIC:
			crTextColor = DECAY_COLOR;
			break;

		case IDC_VEG_SUSTAIN_STATIC:
			crTextColor = SUSTAIN_COLOR;
			break;

		case IDC_VEG_RELEASE_STATIC:
			crTextColor = RELEASE_COLOR;
			break;
		default:
			return hbr;
	}
	pDC->SetTextColor(crTextColor);
	return hbr;
}


BOOL CVolDialog::OnInitDialog() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	m_bInitingDialog = true;

	CDialog::OnInitDialog();

	// Set all the bitmaps
	CStatic* pStatic = (CStatic*)GetDlgItem(IDC_ATTACK_STATIC);
	if(pStatic)
		pStatic->SetBitmap(CInstrumentFVEditor::m_bmpAttack);
	
	pStatic = (CStatic*)GetDlgItem(IDC_DECAY_STATIC);
	if(pStatic)
		pStatic->SetBitmap(CInstrumentFVEditor::m_bmpDecay);
	
	pStatic = (CStatic*)GetDlgItem(IDC_DECAY2_STATIC);
	if(pStatic)
		pStatic->SetBitmap(CInstrumentFVEditor::m_bmpDecay2);

	pStatic = (CStatic*)GetDlgItem(IDC_SUSTAIN_STATIC);
	if(pStatic)
		pStatic->SetBitmap(CInstrumentFVEditor::m_bmpSustain);

	pStatic = (CStatic*)GetDlgItem(IDC_RELEASE_STATIC);
	if(pStatic)
		pStatic->SetBitmap(CInstrumentFVEditor::m_bmpRelease);

	pStatic = (CStatic*)GetDlgItem(IDC_RELEASE2_STATIC);
	if(pStatic)
		pStatic->SetBitmap(CInstrumentFVEditor::m_bmpRelease2);
		
	m_pmsVEGShutdownTime = Insert(
		IDC_VEG_SHUTDOWNTIME,
		IDC_VEG_DSHUTDOWNTIME,
		0,
		MYSLIDER_TIMESCALE,
		0,
		IDS_UNDO_SHUTDOWNTIME_EDIT,
		&(m_pArticParams->m_VolEG.m_tcShutdownTime));

	m_pmsMSCDefaultPan = Insert(
		IDC_MSC_PAN,
		IDC_MSC_DPAN,
		IDC_MSC_PAN_SPIN,
		MYSLIDER_PAN,
		0,
		IDS_PAN_UNDO_TEXT,
		&(m_pArticParams->m_Misc.m_ptDefaultPan));

	m_pmsVEGVel2Attack = Insert(
		IDC_VEG_VEL2ATTACK,
		IDC_VEG_DVEL2ATTACK,
		0,
		MYSLIDER_TIMESCALE,
		0,
		IDS_VEL2ATTACK_UNDO_TEXT,
		&(m_pArticParams->m_VolEG.m_tcVel2Attack));
    
	m_pmsVEGKey2Hold = Insert(
		IDC_VEG_KEY2HOLD,
		IDC_VEG_DKEY2HOLD,
		0,
		MYSLIDER_TIMESCALE,
		0,
		IDS_UNDO_KEYTOHOLD_EDIT,
		&(m_pArticParams->m_VolEG.m_tcKey2Hold));

	m_pmsVEGKey2Decay = Insert(
		IDC_VEG_KEY2DECAY,
		IDC_VEG_DKEY2DECAY,
		0,
		MYSLIDER_TIMESCALE,
		0,
		IDS_KEY2DECAY_UNDO_TEXT,
		&(m_pArticParams->m_VolEG.m_tcKey2Decay));

	// Set Sustain first; this is a kludge we need to fix ADSR control J4
	// UpdateADSREnvelope fires an Sustain changed event before it the sustain is set 
	// this messes up the proper sustain value
	m_VEGASDREnvelope.SetSustainLevel(m_pArticParams->m_VolEG.m_ptSustain >> 16);
	
	DWORD dw;
	
	dw = TimeCents2Mils(m_pArticParams->m_VolEG.m_tcRelease);
	m_VEGASDREnvelope.SetReleaseTime(dw ? (dw <= MAXADSRTIME ? dw : MAXADSRTIME) : 1);

	dw = TimeCents2Mils(m_pArticParams->m_VolEG.m_tcDelay);
	m_VEGASDREnvelope.SetDelayTime(dw ? (dw <= MAXADSRTIME ? dw : MAXADSRTIME) : 1);
	
	dw = TimeCents2Mils(m_pArticParams->m_VolEG.m_tcAttack);
	m_VEGASDREnvelope.SetAttackTime(dw ? (dw <= MAXADSRTIME ? dw : MAXADSRTIME) : 1);

	dw = TimeCents2Mils(m_pArticParams->m_VolEG.m_tcHold);
	m_VEGASDREnvelope.SetHoldTime(dw ? (dw <= MAXADSRTIME ? dw : MAXADSRTIME) : 1);
	
	dw = TimeCents2Mils(m_pArticParams->m_VolEG.m_tcDecay);
	m_VEGASDREnvelope.SetDecayTime(dw ? (dw <= MAXADSRTIME ? dw : MAXADSRTIME) : 1);

	BOOL bDLS1 = m_pArticulation->IsDLS1();
	EnableDLS2Controls(!bDLS1);

	m_bInitingDialog = false;

	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}


void CVolDialog::OnKillfocusVegDattack() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	PostMessage(DM_VALIDATE,IDC_VEG_DATTACK);	
	//Default();
}

void CVolDialog::OnKillfocusVegDdecay() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	PostMessage(DM_VALIDATE,IDC_VEG_DDECAY);	
}

void CVolDialog::OnKillfocusVegDsustain() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	PostMessage(DM_VALIDATE,IDC_VEG_DSUSTAIN);	
}

void CVolDialog::OnKillfocusVegDrelease() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	PostMessage(DM_VALIDATE,IDC_VEG_DRELEASE);	
}


void CVolDialog::ValidateAttackTime()
{
	BOOL bUpdate;
	if ( m_bfTouched & fVEG_DATTACK )
	{
		float flOldAttack = m_flAttack;

		bUpdate = UpdateData(TRUE);	
		if(bUpdate)
		{		
			if(!m_bInitingDialog)
			{
				if(FAILED(SaveUndoState(IDS_ATTACK_UNDO_TEXT)))
				{
					m_flAttack = flOldAttack;
					m_bfTouched &= ~fVEG_DATTACK;
					UpdateData(FALSE);
					return;
				}
				// Add 0.5 to the float value so that on conversion to int,
				// we get the correct value. float of 10.0 is stored as 9.99999..
				// m_flAttack is stored in seconds.
				DWORD flAttack = (DWORD)((m_flAttack*(float)1000.0) + (float)0.5);

				// Find out the error creeping up in conversion and adjust the actual value for that
				TCENT tcAttack = Mils2TimeCents(flAttack);
				DWORD dwAttack =  TimeCents2Mils(tcAttack);
				DWORD dwErrorMargin = dwAttack - flAttack;
				flAttack = flAttack - dwErrorMargin;

				m_pArticParams->m_VolEG.m_tcAttack = Mils2TimeCents(flAttack);
				// TimeCents is not millisecond accurate at higher values so we
				// need to convert back to milliseconds to display exactly how
				// many milliseconds the TimeCents value represents.
				flAttack = TimeCents2Mils(m_pArticParams->m_VolEG.m_tcAttack);

				m_pCollection->SetDirtyFlag();
				if (m_VEGASDREnvelope)
				{
					m_VEGASDREnvelope.SetAttackTime(flAttack); //it's stored internally as milliseconds
				}
				m_pInstrument->UpdateInstrument();
			}
		} 
		else
		{
			long flAttack = TimeCents2Mils(m_pArticParams->m_VolEG.m_tcAttack);
			char text[BUFFER_64];
			sprintf(text," %02d.%03d", flAttack/1000, flAttack%1000);

			CEdit* pDisplay = (CEdit*)GetDlgItem(IDC_VEG_DATTACK);
			if(pDisplay)
			{
				pDisplay->SetWindowText(text);
				SelectEditAndBringWindowToTop(pDisplay);
			}
		}
		m_bfTouched &= ~fVEG_DATTACK;
	}
}

void CVolDialog::ValidateDecayTime()
{
	BOOL bUpdate;
	if ( m_bfTouched & fVEG_DDECAY )
	{
		float flOldDecay = m_flDecay;
		bUpdate = UpdateData(TRUE);	
		if(bUpdate)
		{		
			if(!m_bInitingDialog)
			{
				if(FAILED(SaveUndoState(IDS_DECAY_UNDO_TEXT)))
				{
					m_bfTouched &= ~fVEG_DDECAY;
					m_flDecay = flOldDecay;
					UpdateData(FALSE);
					return;
				}
				// Add 0.5 to the float value so that on conversion to int,
				// we get the correct value. float of 10.0 is stored as 9.99999..
				// m_fldecay is stored in seconds.
				DWORD flDecay = (DWORD)((m_flDecay*(float)1000) + (float)0.5);

				// Find out the error creeping up in conversion and adjust the actual value for that
				TCENT tcDecay = Mils2TimeCents(flDecay);
				DWORD dwDecay =  TimeCents2Mils(tcDecay);
				DWORD dwErrorMargin = dwDecay - flDecay;
				flDecay = flDecay - dwErrorMargin;

				m_pArticParams->m_VolEG.m_tcDecay = Mils2TimeCents((long)flDecay);
				// TimeCents is not millisecond accurate at higher values so we
				// need to convert back to milliseconds to display exactly how
				// many milliseconds the TimeCents value represents.
				flDecay = TimeCents2Mils(m_pArticParams->m_VolEG.m_tcDecay);

				m_pCollection->SetDirtyFlag();
				if (m_VEGASDREnvelope)
				{
					m_VEGASDREnvelope.SetDecayTime((long)flDecay);
				}
				m_pInstrument->UpdateInstrument();
			}
		} 
		else
		{
			char text[BUFFER_64];
			long flDecay = TimeCents2Mils(m_pArticParams->m_VolEG.m_tcDecay);
			sprintf(text," %02d.%03d", flDecay / 1000, flDecay % 1000);
			CEdit* pDisplay = (CEdit*)GetDlgItem(IDC_VEG_DDECAY);
			if(pDisplay)
			{
				pDisplay->SetWindowText(text);
				SelectEditAndBringWindowToTop(pDisplay);
			}
		}
		m_bfTouched &= ~fVEG_DDECAY;
	}
}

void CVolDialog::ValidateSustainLevel()
{
	BOOL bUpdate;
	if ( m_bfTouched & fVEG_DSUSTAIN )
	{
		float flOldSustain = m_flSustain;

		bUpdate = UpdateData(TRUE);	
		if(bUpdate)
		{		
			if(!m_bInitingDialog)
			{
				if(FAILED(SaveUndoState(IDS_SUSTAIN_UNDO_TEXT)))
				{
					m_bfTouched &= ~fVEG_DSUSTAIN;
					m_flSustain = flOldSustain;
					UpdateData(FALSE);
					return;
				}
				// Add 0.5 to the float value so that on conversion to int,
				// we get the correct value. float of 10.0 is stored as 9.99999..
				// m_flSustain goes from 0 - 1000 (0 - 100%)
				DWORD flSustain = (DWORD)((m_flSustain * (float)10)+ (float)0.5);

				m_pArticParams->m_VolEG.m_ptSustain = (PERCENT)flSustain << 16;

				m_pCollection->SetDirtyFlag();
				if (m_VEGASDREnvelope)
				{
					m_VEGASDREnvelope.SetSustainLevel(flSustain);
				}
				m_pInstrument->UpdateInstrument();
			}
		}
		else
		{
			char text[BUFFER_64];
			long flSustain = m_pArticParams->m_VolEG.m_ptSustain >> 16;
			sprintf(text," %02d.%d",flSustain / 10, flSustain % 10);
			CEdit* pDisplay = (CEdit*)GetDlgItem(IDC_VEG_DSUSTAIN);
			
			if(pDisplay)
			{
				pDisplay->SetWindowText(text);
				SelectEditAndBringWindowToTop(pDisplay);
			}
		}
		m_bfTouched &= ~fVEG_DSUSTAIN;
	}
}

void CVolDialog::ValidateReleaseTime()
{
	BOOL bUpdate;
	if ( m_bfTouched & fVEG_DRELEASE )
	{
		float flOldRelease = m_flRelease;

		bUpdate = UpdateData(TRUE);	
		if(bUpdate)
		{
			if(!m_bInitingDialog)
			{
				if(FAILED(SaveUndoState(IDS_RELEASE_UNDO_TEXT)))
				{
					m_bfTouched &= ~fVEG_DRELEASE;
					m_flRelease = flOldRelease;
					UpdateData(FALSE);
					return;
				}
				// Add 0.5 to the float value so that on conversion to int,
				// we get the correct value. float of 10.0 is stored as 9.99999..
				// m_flRelease is stored in seconds.
				DWORD flRelease = (DWORD)((m_flRelease*(float)1000) + (float)0.5);

				// Find out the error creeping up in conversion and adjust the actual value for that
				TCENT tcRelease = Mils2TimeCents(flRelease);
				DWORD dwRelease =  TimeCents2Mils(tcRelease);
				DWORD dwErrorMargin = dwRelease - flRelease;
				flRelease = flRelease - dwErrorMargin;

				m_pArticParams->m_VolEG.m_tcRelease = Mils2TimeCents((long)flRelease);
				// TimeCents is not millisecond accurate at higher values so we
				// need to convert back to milliseconds to display exactly how
				// many milliseconds the TimeCents value represents.
				flRelease = TimeCents2Mils(m_pArticParams->m_VolEG.m_tcRelease);

				m_pCollection->SetDirtyFlag();
				if (m_VEGASDREnvelope)
				{
					m_VEGASDREnvelope.SetReleaseTime((long)flRelease);
				}
				m_pInstrument->UpdateInstrument();
			}
		}
		else
		{
			char text[BUFFER_64];
			long flRelease = TimeCents2Mils(m_pArticParams->m_VolEG.m_tcRelease);
			sprintf(text," %02d.%03d", flRelease / 1000, flRelease % 1000);
			CEdit* pDisplay = (CEdit*)GetDlgItem(IDC_VEG_DRELEASE);

			if(pDisplay)
			{
				pDisplay->SetWindowText(text);
				SelectEditAndBringWindowToTop(pDisplay);
			}
		}

		m_bfTouched &= ~fVEG_DRELEASE;

	}
}



void CVolDialog::OnADSRMouseMoveStart() 
{
	if(FAILED(SaveUndoState(IDS_ADSR_UNDO_TEXT)))
		return;
}

HRESULT CVolDialog::SaveUndoState(UINT uStringRes)
{
	CInstrumentFVEditor* pParent = (CInstrumentFVEditor*) GetParent();
	ASSERT(pParent);

	if(pParent && pParent->m_pInstrument)
	{
		if(FAILED(pParent->m_pInstrument->SaveStateForUndo(uStringRes)))
			return E_FAIL;
	}
	else
		return E_FAIL;

	return S_OK;
}

void CVolDialog::UpdateArticulation(CArticulation * pNewArt)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	m_pArticParams = pNewArt->GetArticParams();

	m_pArticulation = pNewArt;
#ifdef _DEBUG	
	pNewArt->ValidateParent();
#endif

	CInstrument* pInstrument = pNewArt->GetInstrument();
	if(pInstrument)
	{
		// Articulation is owned by an instrument			
		m_pCollection = pInstrument->m_pCollection;
		m_pInstrument = pInstrument;
	}
	else
	{
		// Articulation is owned by a region
		CRegion* pRegion = pNewArt->GetRegion();
		ASSERT(pRegion);
		pInstrument = pRegion->GetInstrument();
		ASSERT(pInstrument);
		m_pCollection = pInstrument->m_pCollection;
		m_pInstrument = pInstrument;
	}
	
	m_bfTouched = 0;
	m_bTouchedByProgram = false;
	m_bInitingDialog = true;

	// Point sliders at new articulation values
	m_pmsVEGShutdownTime->SetDataValueToEdit(
		&(m_pArticParams->m_VolEG.m_tcShutdownTime));
	m_pmsMSCDefaultPan->SetDataValueToEdit(
		&(m_pArticParams->m_Misc.m_ptDefaultPan));
	m_pmsVEGVel2Attack->SetDataValueToEdit(
		&(m_pArticParams->m_VolEG.m_tcVel2Attack));
	m_pmsVEGKey2Hold->SetDataValueToEdit(
		&(m_pArticParams->m_VolEG.m_tcKey2Hold));
	m_pmsVEGKey2Decay->SetDataValueToEdit(
		&(m_pArticParams->m_VolEG.m_tcKey2Decay));

	//UpdateData(FALSE);
	m_pmsMSCDefaultPan->SetValue(this, m_pArticParams->m_Misc.m_ptDefaultPan);
	m_pmsVEGVel2Attack->SetValue(this, m_pArticParams->m_VolEG.m_tcVel2Attack);
	m_pmsVEGKey2Decay->SetValue(this, m_pArticParams->m_VolEG.m_tcKey2Decay);
	m_pmsVEGKey2Hold->SetValue(this, m_pArticParams->m_VolEG.m_tcKey2Hold);
	m_pmsVEGShutdownTime->SetValue(this, m_pArticParams->m_VolEG.m_tcShutdownTime);
	
	// Set Sustain first; this is a kludge we need to fix ADSR control J4
	// UpdateADSREnvelope fires an Sustain changed event before it the sustain is set 
	// this messes up the proper sustain value
	m_VEGASDREnvelope.SetSustainLevel(m_pArticParams->m_VolEG.m_ptSustain >> 16);
	
	DWORD dw;

	dw = TimeCents2Mils(m_pArticParams->m_VolEG.m_tcRelease);
	m_VEGASDREnvelope.SetReleaseTime(dw ? (dw <= MAXADSRTIME ? dw : MAXADSRTIME) : 1);

	dw = TimeCents2Mils(m_pArticParams->m_VolEG.m_tcDelay);
	m_VEGASDREnvelope.SetDelayTime(dw ? (dw <= MAXADSRTIME ? dw : MAXADSRTIME) : 1);
	
	dw = TimeCents2Mils(m_pArticParams->m_VolEG.m_tcAttack);
	m_VEGASDREnvelope.SetAttackTime(dw ? (dw <= MAXADSRTIME ? dw : MAXADSRTIME) : 1);

	dw = TimeCents2Mils(m_pArticParams->m_VolEG.m_tcHold);
	m_VEGASDREnvelope.SetHoldTime(dw ? (dw <= MAXADSRTIME ? dw : MAXADSRTIME) : 1);
	
	dw = TimeCents2Mils(m_pArticParams->m_VolEG.m_tcDecay);
	m_VEGASDREnvelope.SetDecayTime(dw ? (dw <= MAXADSRTIME ? dw : MAXADSRTIME) : 1);

	BOOL bDLS1 = m_pArticulation->IsDLS1();
	EnableDLS2Controls(!bDLS1);

	m_bInitingDialog = false;
}

void CVolDialog::SelectEditAndBringWindowToTop(CEdit* pEdit)
{
	ASSERT(pEdit);
	if(pEdit == NULL)
		return;

	HWND hwndEditor = NULL;
	m_pInstrument->GetEditorWindow(&hwndEditor);
	if(hwndEditor)
		::BringWindowToTop(hwndEditor);

	pEdit->SetFocus();
	pEdit->SetSel(0, -1);
}

void CVolDialog::CollectStatics()
{
	// Remove all previous statics....should there be any?
	while(!m_lstStatics.IsEmpty())
	{
		CDLSStatic* pStatic = (CDLSStatic*) m_lstStatics.RemoveHead();
		ASSERT(pStatic);
		if(pStatic)
		{
			delete pStatic;
		}
	}

	CWnd* pChild = GetWindow(GW_CHILD);
	while(pChild)
	{
		char szClassName[MAX_PATH];
		::GetClassName(pChild->m_hWnd, szClassName, MAX_PATH);
		
		// Add it to the list if it's a "Static"
		if(strcmp(szClassName,"Static") == 0)
		{
			CDLSStatic* pDLSStatic = NULL;
			if(SUCCEEDED(CDLSStatic::CreateControl(this, pChild, &pDLSStatic)))
				m_lstStatics.AddTail(pDLSStatic);
		}

		pChild = pChild->GetNextWindow();
	}

	// Destroy the actual static controls now
	POSITION position = m_lstStatics.GetHeadPosition();
	while(position)
	{
		CDLSStatic* pStatic = (CDLSStatic*) m_lstStatics.GetNext(position);
		ASSERT(pStatic);
		CWnd* pWnd = GetDlgItem(pStatic->GetID());
		if(pWnd)
		{
			pWnd->DestroyWindow();
		}
	}
}

CDLSStatic* CVolDialog::GetStaticControl(UINT nID)
{
	POSITION position = m_lstStatics.GetHeadPosition();
	while(position)
	{
		CDLSStatic* pStatic = (CDLSStatic*) m_lstStatics.GetNext(position);
		ASSERT(pStatic);
		if(pStatic->GetID() == nID)
			return pStatic;
	}

	return NULL;
}

void CVolDialog::OnDestroy() 
{
	CDialog::OnDestroy();
	
	// Remove all previous statics....should there be any?
	while(!m_lstStatics.IsEmpty())
	{
		CDLSStatic* pStatic = (CDLSStatic*) m_lstStatics.RemoveHead();
		ASSERT(pStatic);
		if(pStatic)
		{
			delete pStatic;
		}
	}
}


void CVolDialog::OnPaint() 
{
	CPaintDC dc(this); // device context for painting
	
	POSITION position = m_lstStatics.GetHeadPosition();
	while(position)
	{
		CDLSStatic* pStatic = (CDLSStatic*) m_lstStatics.GetNext(position);
		ASSERT(pStatic);
		pStatic->OnDraw(&dc);
	}
}

void CVolDialog::OnKillfocusVegDelay() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	PostMessage(DM_VALIDATE,IDC_VEG_DDELAY);	
}

void CVolDialog::OnKillfocusVegHold() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	PostMessage(DM_VALIDATE,IDC_VEG_DHOLD);	
}


void CVolDialog::ValidateDelayTime()
{
	BOOL bUpdate;
	if ( m_bfTouched & fVEG_DDELAY )
	{
		float flOldDelay = m_flDelay;

		bUpdate = UpdateData(TRUE);	
		if(bUpdate)
		{		
			if(!m_bInitingDialog)
			{
				if(FAILED(SaveUndoState(IDS_UNDO_DELAY_EDIT)))
				{
					m_flDelay = flOldDelay;
					m_bfTouched &= ~fVEG_DDELAY;
					UpdateData(FALSE);
					return;
				}
				// Add 0.5 to the float value so that on conversion to int,
				// we get the correct value. float of 10.0 is stored as 9.99999..
				// m_flDelay is stored in seconds.
				DWORD flDelay = (DWORD)((m_flDelay*(float)1000.0) + (float)0.5);

				// Find out the error creeping up in conversion and adjust the actual value for that
				TCENT tcDelay = Mils2TimeCents(flDelay);
				DWORD dwDelay =  TimeCents2Mils(tcDelay);
				DWORD dwErrorMargin = dwDelay - flDelay;
				flDelay = flDelay - dwErrorMargin;

				m_pArticParams->m_VolEG.m_tcDelay = Mils2TimeCents(flDelay);

				// TimeCents is not millisecond accurate at higher values so we
				// need to convert back to milliseconds to display exactly how
				// many milliseconds the TimeCents value represents.

				flDelay = TimeCents2Mils(m_pArticParams->m_VolEG.m_tcDelay);

				m_pCollection->SetDirtyFlag();
				if (m_VEGASDREnvelope)
				{
					m_VEGASDREnvelope.SetDelayTime(flDelay); //it's stored internally as milliseconds
				}
				m_pInstrument->UpdateInstrument();
			}
		} 
		else
		{
			long flDelay = TimeCents2Mils(m_pArticParams->m_VolEG.m_tcDelay);
			char text[BUFFER_64];
			sprintf(text," %02d.%03d", flDelay/1000, flDelay%1000);

			CEdit* pDisplay = (CEdit*)GetDlgItem(IDC_VEG_DDELAY);
			if(pDisplay)
			{
				pDisplay->SetWindowText(text);
				SelectEditAndBringWindowToTop(pDisplay);
			}
		}
		m_bfTouched &= ~fVEG_DDELAY;
	}
}




void CVolDialog::ValidateHoldTime()
{
	BOOL bUpdate;
	if ( m_bfTouched & fVEG_DHOLD )
	{
		float flOldHold = m_flHold;

		bUpdate = UpdateData(TRUE);	
		if(bUpdate)
		{		
			if(!m_bInitingDialog)
			{
				if(FAILED(SaveUndoState(IDS_UNDO_HOLD_EDIT)))
				{
					m_flHold = flOldHold;
					m_bfTouched &= ~fVEG_DHOLD;
					UpdateData(FALSE);
					return;
				}
				// Add 0.5 to the float value so that on conversion to int,
				// we get the correct value. float of 10.0 is stored as 9.99999..
				// m_flHold is stored in seconds.
				DWORD flHold = (DWORD)((m_flHold*(float)1000.0) + (float)0.5);

				// Find out the error creeping up in conversion and adjust the actual value for that
				TCENT tcHold = Mils2TimeCents(flHold);
				DWORD dwHold =  TimeCents2Mils(tcHold);
				DWORD dwErrorMargin = dwHold - flHold;
				flHold = flHold - dwErrorMargin;

				m_pArticParams->m_VolEG.m_tcHold = Mils2TimeCents(flHold);

				// TimeCents is not millisecond accurate at higher values so we
				// need to convert back to milliseconds to display exactly how
				// many milliseconds the TimeCents value represents.

				flHold = TimeCents2Mils(m_pArticParams->m_VolEG.m_tcHold);

				m_pCollection->SetDirtyFlag();
				if (m_VEGASDREnvelope)
				{
					m_VEGASDREnvelope.SetHoldTime(flHold); //it's stored internally as milliseconds
				}
				m_pInstrument->UpdateInstrument();
			}
		} 
		else
		{
			long flHold = TimeCents2Mils(m_pArticParams->m_VolEG.m_tcHold);
			char text[BUFFER_64];
			sprintf(text," %02d.%03d", flHold/1000, flHold%1000);

			CEdit* pDisplay = (CEdit*)GetDlgItem(IDC_VEG_DHOLD);
			if(pDisplay)
			{
				pDisplay->SetWindowText(text);
				SelectEditAndBringWindowToTop(pDisplay);
			}
		}
		m_bfTouched &= ~fVEG_DHOLD;
	}
}

void CVolDialog::OnADSREDelayTimeChangedVegAdsrenvelopectrl(long lNewDelayTime) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	char text[BUFFER_64];
    sprintf(text," %02d.%03d", lNewDelayTime / 1000, lNewDelayTime % 1000);
	CWnd* pDisplay = GetDlgItem(IDC_VEG_DDELAY);
	
	m_bTouchedByProgram = true;
	pDisplay->SetWindowText(text);
	m_bTouchedByProgram = false;

	if( !m_bInitingDialog )
	{
		if ( !( m_bfTouched & fVEG_DDELAY ) )
			m_pArticParams->m_VolEG.m_tcDelay = Mils2TimeCents(lNewDelayTime);
		m_pCollection->SetDirtyFlag();
		m_pInstrument->UpdateInstrument();
	}
}

void CVolDialog::OnADSREHoldTimeChangedVegAdsrenvelopectrl(long lNewHoldTime) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	char text[BUFFER_64];
    sprintf(text," %02d.%03d", lNewHoldTime / 1000, lNewHoldTime % 1000);
	CWnd* pDisplay = GetDlgItem(IDC_VEG_DHOLD);
	
	m_bTouchedByProgram = true;
	pDisplay->SetWindowText(text);
	m_bTouchedByProgram = false;

	if( !m_bInitingDialog )
	{
		if ( !( m_bfTouched & fVEG_DHOLD ) )
			m_pArticParams->m_VolEG.m_tcHold = Mils2TimeCents(lNewHoldTime);
		m_pCollection->SetDirtyFlag();
		m_pInstrument->UpdateInstrument();
	}
}

void CVolDialog::EnableDLS2Controls(BOOL bEnable)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	// Delay and Hold edits
	CWnd* pWnd = GetDlgItem(IDC_VEG_DDELAY);
	if(pWnd)
		pWnd->EnableWindow(bEnable);
	pWnd = GetDlgItem(IDC_VEG_DELAY_STATIC);
	if(pWnd)
		pWnd->EnableWindow(bEnable);

	pWnd = GetDlgItem(IDC_VEG_DHOLD);
	if(pWnd)
		pWnd->EnableWindow(bEnable);
	pWnd = GetDlgItem(IDC_VEG_HOLD_STATIC);
	if(pWnd)
		pWnd->EnableWindow(bEnable);

	m_pmsVEGShutdownTime->EnableControl(this, bEnable != 0);
	m_pmsVEGKey2Hold->EnableControl(this, bEnable != 0);
	
	// Envelope
	m_VEGASDREnvelope.SetDLS1(!bEnable);
}

BOOL CVolDialog::OnCommand(WPARAM wParam, LPARAM lParam) 
{
	LRESULT lResult;
	if (CSliderCollection::OnCommand(wParam, lParam, &lResult))
		return lResult;

	return CDialog::OnCommand(wParam, lParam);
}

BOOL CVolDialog::OnNotify(WPARAM wParam, LPARAM lParam, LRESULT* pResult) 
{
	LRESULT Result;
	if (CSliderCollection::OnNotify(wParam, lParam, &Result))
		return Result;
	
	return CDialog::OnNotify(wParam, lParam, pResult);
}

void CVolDialog::UpdateInstrument()
{
	m_pInstrument->UpdateInstrument();
	m_pCollection->SetDirtyFlag();
}

bool CVolDialog::OnSliderUpdate(MySlider *pms, DWORD dwmscupdf)
{
	switch (dwmscupdf)
		{
		case dwmscupdfStart:
			if (SUCCEEDED(SaveUndoState(pms->GetUndoStringID())))
				return true;
			UpdateArticulation(m_pArticulation);
			return false;

		case dwmscupdfEnd:
			UpdateInstrument();
			return true;

		default:
			ASSERT(FALSE);
			return false;
		}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\DLSDesigner\VolDialog.h ===
//{{AFX_INCLUDES()
#include "adsrenvelope.h"
//}}AFX_INCLUDES
#if !defined(AFX_VOLDIALOG_H__55AEE3E3_EC78_11D0_876A_00AA00C08146__INCLUDED_)
#define AFX_VOLDIALOG_H__55AEE3E3_EC78_11D0_876A_00AA00C08146__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// VolDialog.h : header file
//

#include "resource.h"
#include "myslider.h"
#include "Collection.h"
#include "Instrument.h"
#include "Region.h"
#include "DLSLoadSaveUtils.h"

class CDLSStatic;
class CArticulation;

/////////////////////////////////////////////////////////////////////////////
// CVolDialog dialog

class CVolDialog : public CDialog, CSliderCollection
{

// Construction
public:
	CVolDialog(CArticulation* pArticulation);

// Dialog Data
	//{{AFX_DATA(CVolDialog)
	enum { IDD = IDD_VOLUME_PAGE };
	CADSREnvelope	m_VEGASDREnvelope;
	float	m_flAttack;
	float	m_flDecay;
	float	m_flRelease;
	float	m_flSustain;
	float	m_flDelay;
	float	m_flHold;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CVolDialog)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	virtual BOOL OnCommand(WPARAM wParam, LPARAM lParam);
	virtual BOOL OnNotify(WPARAM wParam, LPARAM lParam, LRESULT* pResult);
	//}}AFX_VIRTUAL

	// CSliderCollection overrides
	virtual bool OnSliderUpdate(MySlider *pms, DWORD dwmscupdf);
	
// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CVolDialog)
	afx_msg void OnHScroll(UINT nSBCode, UINT nPos, CScrollBar* pScrollBar);
	afx_msg void OnADSRESustainLevelChangedVegAdsrenvelopectrl(long NewSustainLevel);
	afx_msg void OnADSREReleaseTimeChangedVegAdsrenvelopectrl(long NewReleaseTime);
	afx_msg void OnADSREAttackTimeChangedVegAdsrenvelopectrl(long NewAttackTime);
	afx_msg void OnADSREDecayTimeChangedVegAdsrenvelopectrl(long NewDecayTime);
	virtual BOOL OnInitDialog();
	afx_msg void OnKillfocusVegDattack();
	afx_msg void OnKillfocusVegDdecay();
	afx_msg void OnKillfocusVegDrelease();
	afx_msg void OnKillfocusVegDsustain();
	afx_msg LRESULT OnValidate(UINT wParam,LONG lParam);
	afx_msg HBRUSH OnCtlColor(CDC* pDC, CWnd* pWnd, UINT nCtlColor);
	afx_msg void OnRealDecayChangedVegAdsrenvelopectrl(long lNewRealDecay);
	afx_msg void OnRealReleaseChangedVegAdsrenvelopectrl(long lNewRealRelease);
	afx_msg void OnADSRMouseMoveStart();
	afx_msg void OnDestroy();
	afx_msg void OnPaint();
	afx_msg void OnKillfocusVegDelay();
	afx_msg void OnKillfocusVegHold();
	afx_msg void OnADSREDelayTimeChangedVegAdsrenvelopectrl(long lNewDelayTime);
	afx_msg void OnADSREHoldTimeChangedVegAdsrenvelopectrl(long lNewHoldTime);
	DECLARE_EVENTSINK_MAP()
	//}}AFX_MSG
	afx_msg void OnEditChange( UINT nEditControl );
	DECLARE_MESSAGE_MAP()

public:	// J3 make private
	void UpdateArticulation(CArticulation* pNewArt);
	CArticulation*	m_pArticulation;
private:
	void ValidateDelayTime();
	void ValidateAttackTime();
	void ValidateHoldTime();
	void ValidateDecayTime();
	void ValidateSustainLevel();
	void ValidateReleaseTime();
	void SelectEditAndBringWindowToTop(CEdit* pEdit);
	
	void EnableDLS2Controls(BOOL bEnable = TRUE);

private:
	HRESULT SaveUndoState(UINT uStringRes);
	void	CollectStatics();
	CDLSStatic* GetStaticControl(UINT nID);
	void UpdateInstrument();
	
	/* In order to solve problems with using OnKillFocus handlers to validate and update
		edit controls I am adding a bit field - m_bfTouched. Each bit to be set high in 
		response to EN_CHANGE message from given controls. The enumeration below defines 
		the bit flag for each of the four edit controls in the Volume page.  I have made 
		IDC_VEG_DATTACK, IDC_VEG_DDECAY, IDC_VEG_DSUSTAIN and IDC_VEG_DRELEASE contigous
		in the resource editor. I use a ON_CONTROL_RANGE message map macro to handle 
		EN_CHANGE's. If any more edit controls get added to this dialog template the macro
		and the handler OnEditChange() might have to be modified. OnEditChange() gets one
		parameter which is the control ID of the edit control that changed. from this ID
		I subtract FIRST_CONTROL to come up with the argument to a shift left (<<) of 0x01.
		This creates the bit flag which corresponds to the ones in the enum. The ones in
		enum are used in comparison in the OnKillFocusXXX functions.
	*/
	enum { FIRST_CONTROL = IDC_FIRST_EDIT2VALIDATE, fVEG_DATTACK = 0x01,
		fVEG_DDECAY = 0x02, fVEG_DSUSTAIN = 0x04, fVEG_DRELEASE = 0x08, fVEG_DDELAY = 0x10, fVEG_DHOLD = 0x20};

	CPtrList m_lstStatics;	// List of static controls in the dialog

	CCollection*			m_pCollection;	
	CInstrument*			m_pInstrument;
	ArticParams*			m_pArticParams;
    MySlider*				m_pmsMSCDefaultPan;
    MySlider*				m_pmsVEGVel2Attack;
	MySlider*				m_pmsVEGKey2Hold;
    MySlider*				m_pmsVEGKey2Decay;
	MySlider*				m_pmsVEGShutdownTime;
	bool					m_bInitingDialog;
	bool					m_bTouchedByProgram;// has edit control value changed by SetWindowText?
	DWORD					m_bfTouched; // bit field meaning "has the edit control really been 
								 // changed?" for OnKillFocus()
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_VOLDIALOG_H__55AEE3E3_EC78_11D0_876A_00AA00C08146__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\DLSDesigner\UserPatchConflictDlg.h ===
#if !defined(AFX_USERPATCHCONFLICTDLG_H__0D184C41_CCB8_11D1_B987_006097B01078__INCLUDED_)
#define AFX_USERPATCHCONFLICTDLG_H__0D184C41_CCB8_11D1_B987_006097B01078__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// UserPatchConflictDlg.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CUserPatchConflictDlg dialog

#include "Instrument.h"
#include "resource.h"

class CUserPatchConflictDlg : public CDialog
{
// Construction
public:
	CUserPatchConflictDlg(HRESULT hrCode, ULONG ulCheckedBank, ULONG ulPatch, CInstrument* pCollidingInstrument);   // standard constructor

// Dialog Data
	//{{AFX_DATA(CUserPatchConflictDlg)
	enum { IDD = IDD_USER_PATCH_CONFLICT };
	CButton	m_NotAgainCheck;
	BOOL	m_bIgnoreAll;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CUserPatchConflictDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CUserPatchConflictDlg)
	virtual BOOL OnInitDialog();
	virtual void OnCancel();
	afx_msg void OnConflictNotAgainCheck();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
private:
	void InitDlgText();
	void GetGMInstName(CString & strResult);

	ULONG					m_ulCheckedPatch;
	ULONG					m_ulCheckedBank;
	CInstrument*			m_pCollidingInstrument;
	HRESULT					m_hrConflictCause;
	int						m_iRetVal;
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_USERPATCHCONFLICTDLG_H__0D184C41_CCB8_11D1_B987_006097B01078__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\DLSDesigner\Wave.h ===
#ifndef __WAVE_H__
#define __WAVE_H__

// Wave.h : header file
//
#include "DLSComponent.h"
#include "DLSDocType.h"
#include "RiffStrm.h"
#include "CollectionWaves.h"
#include "Info.h"
#include "DLS1.h"
#include "WaveCtl.h"
#include "WaveTimelineDraw.h"
#include <mmsystem.h>
#include <mmreg.h>
#include <msacm.h>
#include "WaveCompressionManager.h"
#include "dmusicf.h"

// Definitions for the WAVE RIFF FOURCC's /////
#define FOURCC_DRAG	mmioFOURCC('d','r','a','g')
#define FOURCC_WVST	mmioFOURCC('w','v','s','t')
#define FOURCC_WAVU mmioFOURCC('w','a','v','u')
#define FOURCC_FMT	mmioFOURCC('f','m','t',' ')
#define FOURCC_SMPL	mmioFOURCC('s','m','p','l')
#define FOURCC_DATA mmioFOURCC('d','a','t','a')
#define FOURCC_FACT mmioFOURCC('f','a','c','t')
#define FOURCC_INFO mmioFOURCC('I','N','F','O')
///////////////////////////////////////////////

typedef struct TEMPO_CHANGE
{
	REFERENCE_TIME	rtTempoStart;
	REFERENCE_TIME	rtTempoEnd;
	double			dblTempo;
}TempoChange;


// Anything less than this is not accepted as a valid loop length
#define MINIMUM_VALID_LOOPSTART		0
#define MINIMUM_VALID_LOOPLENGTH	6
#define MSSYNTH_LOOP_LIMIT			524287	// Looped waves will not play correctly with MS Synth beyond this loop length

// Min and Max values for the streaming read ahead.
#ifdef DMP_XBOX
#define MIN_READAHEAD   50  // 50 ms on XBOX
#else
#define MIN_READAHEAD   200 // 200 ms on PC
#endif
#define MAX_READAHEAD   1000  


// Standard data buffer size we'll fetch from the source and temp files
#define WAVE_DATA_BUFFER_SIZE	 4096 

#define DEFAULT_READAHEAD_TIME	500 // Default ReadAhead time for streaming waves is 500ms

#define	SNAP_FORWARD	1
#define SNAP_BACKWARD	SNAP_FORWARD  << 1
#define	SNAP_BOTH		SNAP_FORWARD | SNAP_BACKWARD 


typedef struct _rsmpl 
{
  DWORD dwManufacturer;
  DWORD dwProduct;
  DWORD dwSamplePeriod;
  DWORD dwMIDIUnityNote;
  DWORD dwMIDIPitchFraction;
  DWORD dwSMPTEFormat;
  DWORD dwSMPTEOffset;
  DWORD cSampleLoops;
  DWORD cbSamplerData;
} RSMPL, FAR *LPRSMPL;

typedef struct _orloop 
{
  DWORD dwIdentifier;
  DWORD dwType;
  DWORD dwStart;
  DWORD dwEnd;
  DWORD dwFraction;
  DWORD dwPlayCount;
} RLOOP, FAR *LPRLOOP;

// Structure used to pass the header information between the wave and the data manager / undo manager
typedef struct waveHeaderInfo
{
	DWORD				m_dwWaveLength;	// Length of the wave in samples
	DWORD				m_dwDataSize;	// Size of the wave in bytes

	WSMPL				m_rWSMP;        // New version of wave sample chunk.
	WLOOP				m_rWLOOP;       // New version of loop info.

    RSMPL				m_rRSMP;		// Wave sampling extension (for wave saving only.)
	RLOOP		        m_rRLOOP;       // Loop information (for wave saving

	bool				m_bCompressed;	// Is this wave compressed?

	BOOL				m_bStreaming;	// Is this a streaming wave?
	BOOL				m_bNoPreroll;	// Do we need to pre-roll the wave data?
	DWORD				m_dwReadAheadTime;
	DWORD				m_dwDecompressedStart;
	DWORD				m_dwSamplerate;	// Sample rate
} HEADER_INFO;


typedef struct DMUSP_WAVEOBJECT
{
	WAVEFORMATEX		WaveFormatEx;			 // Standard wave format header.
	BYTE*				pbExtractWaveFormatData; // Compressed waves may have extra data that follows the WAVEFORMATEX structure
	DWORD				dwDataSize;				 // Length of wave (in bytes).	
	BYTE*				pbData;					 // Wave Data (Left channel data for Mono waves).
} DMUSP_WAVEOBJECT;

class CWaveNode;
class CWaveDataManager;
class CMonoWave;
class CWaveCompressionManager;
class CWavePropPgMgr;
class AllocatedPortBufferPair;

class CWave : public IPersistStream, public IDMUSProdPropPageObject
{

	friend class CWaveDataManager;
	friend class CWaveCtrl;
	friend BOOL CALLBACK acmFormatEnumCallback(HACMDRIVERID hadid,           
										   LPACMFORMATDETAILS pafd,  
										   DWORD dwInstance,             
										   DWORD dwSupport);
public:
    CWave(CWaveNode* pNode,DWORD dwSampleRate = 22050, UINT nSampleSize = 16, UINT nChannels = 1);
	virtual ~CWave();

    // IUnknown functions
    HRESULT STDMETHODCALLTYPE QueryInterface( REFIID riid, LPVOID *ppv );
    ULONG STDMETHODCALLTYPE AddRef();
    ULONG STDMETHODCALLTYPE Release();

	// IPersist functions
    STDMETHOD(GetClassID)(CLSID* pClsId);

	// IPersistStream functions
    STDMETHOD(IsDirty)();
    STDMETHOD(Load)( IStream* pIStream );
    STDMETHOD(Save)( IStream* pIStream, BOOL fClearDirty );
    STDMETHOD(GetSizeMax)( ULARGE_INTEGER FAR* pcbSize );

	// IDMUSProdPropPageObject functions
    HRESULT STDMETHODCALLTYPE GetData( void** ppData );
    HRESULT STDMETHODCALLTYPE SetData( void* pData );
	HRESULT STDMETHODCALLTYPE OnRemoveFromPageManager();
	HRESULT STDMETHODCALLTYPE OnShowProperties();

	// Additional methods
public:
	
	// Persistence methods
	virtual HRESULT Load(IDMUSProdRIFFStream* pIRiffStream, MMCKINFO* pckMain);				// Load the wave from the passed stream
	virtual HRESULT Save(IDMUSProdRIFFStream* pIRiffStream, UINT wType, BOOL fFullSave) = 0;// Save this wave into the passed stream
	virtual HRESULT SaveAs(IStream* pIStream);												// Saves the WVP as a WAV file
	virtual HRESULT LoadHeader(IDMUSProdRIFFStream* pIRiffStream, MMCKINFO* pckMain);		// Loads only the header info NOT the wave DATA chunk
	virtual HRESULT LoadData(IDMUSProdRIFFStream* pIRiffStream, MMCKINFO* pckMain) = 0;		// Loads only the wave data; the derived objects decide how they want to load the data
	virtual HRESULT PrepareForSave(CString sNewFileName);									// File being saved do whatever's necessary
	virtual HRESULT CleanupAfterSave(CString sFileName);									// File successfully saved so cleanup whatever you need to
	virtual HRESULT	WriteRIFFHeaderToStream(IStream* pIStream, DWORD* pdwBytesWritten) = 0;	// Writes the header in RIFF format to the passed stream upto <data-ck>[size]; returns the number of bytes written
	virtual	HRESULT WriteGUIDChunk(IDMUSProdRIFFStream* pIRiffStream);						// Writes the DMUS_FOURCC_GUID_CHUNK to the passed stream
	
	// The read methods just read the data from the chunks into the correct data structures
	// The derived classes must do the specialized error checking and data massaging that 
	// may need to be done...
	virtual HRESULT ReadDRAG(IStream* pIStream, MMCKINFO* pckMain);
	virtual	HRESULT ReadGUID(IStream* pIStream, MMCKINFO* pckMain);
	virtual HRESULT ReadWVST(IStream* pIStream, MMCKINFO* pckMain) = 0;		   
	virtual HRESULT ReadWAVU(IStream* pIStream, MMCKINFO* pckMain);
	virtual HRESULT ReadFMT(IStream* pIStream, MMCKINFO* pckMain);
	virtual HRESULT ReadWSMP(IStream* pIStream, MMCKINFO* pckMain);
	virtual HRESULT ReadSMPL(IStream* pIStream, MMCKINFO* pckMain);
	virtual HRESULT ReadDataInfo(IStream* pIStream, MMCKINFO* pckMain);
	virtual HRESULT ReadData(IStream* pIStream, MMCKINFO* pckMain, DWORD dwOffset, DWORD dwLength, BYTE* pbData);
	
	virtual HRESULT Download(IDirectMusicPortDownload* pIDMPortDownLoad) = 0;	// Download this wave to the passed port
	virtual HRESULT Unload(IDirectMusicPortDownload* pIDMPortDownLoad) = 0;		// Unload this wave from the passed port
	virtual HRESULT DM_Init(IDirectMusicPortDownload* pIDMPortDownLoad) = 0;	// Get the size of the download buffer and other DMusic related things
	virtual HRESULT	UpdateWave() = 0;											// Redownload the wave to the synth
	
	virtual HRESULT	OnWaveBufferUpdated();										// The wave data has been touched; do the housekeeping things

	// Compression methods
	virtual HRESULT	Compress(const WAVEFORMATEX* pwfDst, bool bInUndoRedo = false) = 0;				// Mono and Stereo waves will handle compression differently	
	virtual HRESULT	UpdateDecompressedWave(const WAVEFORMATEX* pwfxDst) = 0;// Decompresses the wave to the passed format
	virtual HRESULT	SwitchCompression(bool bSwitch) = 0;					// Turns the compression on/off
	virtual DWORD	GetCompressedDataSize() = 0;							// What is the size of the compressed wave?
	virtual DWORD	GetCompressionFormatTag() = 0;							// What's the compression format tag?
	virtual HRESULT GetCompressionFormat(WAVEFORMATEX* pwfxCompression) = 0;// What is the compression WAVEFORMATEX?


	// Transport related methods
	virtual BOOL	WaveIsPlaying();						// Returns true if the wave is currently playing
	virtual HRESULT	Play(BOOL fPlayFromStart);				// Plays the wave
	virtual void	TurnOffMidiNotes();						// Turn all playing notes off; called on stop button click

	// Update methods
	void	UpdateDummyInstrument();						// Updates the dummy instrument
	void			UpdateRefRegions();						// Updates the instruments that have regions that refer this wave
	virtual void	UpdateLoopInRegions();					// Updates the regions using this wave for the loop changes


	// UI Methods
	virtual void	OnDraw(CDC* pDC, const CRect& rcClient) = 0;
	virtual void	OnDraw(CDC* pDC, const CRect& rcClient, const long lScrollOffset,
							DWORD& dwStartSample, DWORD dwLength,
							float fSamplesPerPixel,	const WaveDrawParams* pDrawParams, const WaveTimelineInfoParams* pInfoParams) = 0;
    virtual void    RefreshDrawBuffer() = 0;

	// Operations on the wave data
	virtual HRESULT RemoveSelection(DWORD dwStart, DWORD dwEnd) = 0;// Removes the samples between dwStart and dwEnd
	virtual HRESULT InsertWaveData(BYTE* pbData, WAVEFORMATEX wfxDataFormat, DWORD dwDataSize, DWORD dwStart) = 0;// Inserts the data in passed buffer at dwStart smaple position
	virtual HRESULT Fade(bool bFadeDirection, DWORD dwStart, DWORD dwEnd);
	virtual HRESULT InsertSilence(DWORD dwStart, DWORD dwLength) = 0;
	virtual HRESULT Resample(DWORD dwNewSampleRate);
	virtual	HRESULT SetLoop(DWORD dwStart, DWORD dwEnd);
	virtual HRESULT CopyLoop() = 0;
	virtual HRESULT FindBestLoop(DWORD dwLoopStart, DWORD dwFindStart, DWORD dwFindEnd, int nFindWindow, DWORD* pdwBestLoopEnd) = 0;
    virtual void	RememberLoopBeforeCompression();					// Saves the loop points set before the compression
	virtual	void    RevertToLoopBeforeCompression();					// Reverts to the saved loop points
	virtual void    RememberLoopAfterCompression();						// Saves the loop points set after the compression
	virtual void	RevertToAfterCompression();							// Reverts to the saved decompressed start and loop points

	// Clipboard operations
	virtual HRESULT CopySelectionToClipboard(IStream* pIStream, DWORD dwStart, DWORD dwEnd) = 0;
	virtual HRESULT PasteSelectionFromClipboard(IStream* pIStream, DWORD dwStart) = 0;


	// Methods to deal with the dummy instrument 
	void			ReleaseDummyInstruments();					// Releases the dummy instruments owned by the waves		
	void			SetupDummyInstrument();						// Sets up a dummy instrument (Used by the editors)
	void			ValidateDummyPatch();						// Validates the dummy instrument's msb, lsb, patch
	CInstrument*	GetDummyInstrument();

	// Common virtual accessor and mutator methods
	virtual CString GetName();
	virtual void	SetName(CString sName);
	virtual DWORD	GetDataSize();								// This could be original size or decompressed size
	virtual DWORD	GetUncompressedDataSize() = 0;				// This is always the size of the original wave
	virtual void	SetWSMPL(WSMPL& newWSMPL);					// Sets the WSMPL values
	virtual void	SetWLOOP(WLOOP& newWLOOP);					// Sets the WLOOP values
	virtual void	SetRSMPL(RSMPL& newRSMPL);					// Sets the RSMPL values
	virtual void	SetRLOOP(RLOOP& newRLOOP);					// Sets the RLOOP values
	virtual	int		GetTimePlayed();							// Gets the time already played by the wave
	virtual BOOL	IsTrueStereo() = 0;								// Is the wave true stereo?
	
	virtual	HRESULT	GetPlayTimeForTempo(int nTempo, DWORD& dwPlayTime) = 0; // Computes the time required for this wave to play once at the passed tempo

	// Operations with the DataManager	
	CWaveDataManager* GetDataManager();						// Returns the data manager for the wave
	HRESULT GetData(DWORD dwStartSample, DWORD dwLength, 
					BYTE** ppbData, DWORD& dwBytesRead, bool bGetUncompressedOnly = false);	// Gets the required data from the data manager
    HRESULT GetAllUncompressedData(BYTE** ppbData, DWORD* pdwSize); // Gets the entire uncompressed wave data
	virtual HRESULT CloseSourceHandler() = 0;				// Closes the file handlers to the source
	virtual HRESULT OnSourceRenamed(CString sNewName) = 0;

	// Common base operations on the wave
	HRESULT PromptForSaveFileName(CString& sSaveFileName, CString& sSavePath);	// Opens a save as dialog and returns the chosen file name and path
	virtual HRESULT SaveAs(IStream* pIStream, bool bPromptForFileName);			// Save out the wave file
	void	Replace();															// Replace this wave everywhere it's referenced
	virtual void SnapToZero(DWORD& dwSample, UINT nDirection = SNAP_BOTH) = 0;								// Get the nearest zero crossing
	void	RefreshPropertyPage();												// Refresh the poroperty page
	
    virtual CString GetUndoMenuText(bool bRedo = false);
    virtual void UpdateOnUndo(HEADER_INFO headerInfo);							// Update the wave after undo/redo actions
    virtual HRESULT	SaveUndoState(UINT uUndoStrID);
    virtual HRESULT Undo();
    virtual HRESULT Redo();
    virtual HRESULT PopUndoState();                                             // Deletes the last saved undo state

	// Helpers for the clipboard operations
	HRESULT ReadDataFromClipbaord(IStream* pIStream, WAVEFORMATEX& wfxClipFormat, 
									BYTE** ppbData, DWORD& dwDataSize);			
	virtual HRESULT WriteDataToClipboard(IStream* pIStream, DWORD dwStartSample, DWORD dwClipLength); 
	HRESULT WriteDataToStream(IStream* pIStream, DWORD dwStartSample, DWORD dwLength, DWORD& dwSamplesWritten);

	// Methods for a streaming wave
	void	CheckSizeAndSetStreaming();							// Checks for the wave size and sets the streaming options
	BOOL	IsStreamingWave();
	void	SetStreamingWave(BOOL bStream);
	BOOL	IsNoPrerollWave();
	void	SetNoPrerollWave(BOOL bNoPreroll);
	DWORD	GetReadAheadTime();
	void	SetReadAheadTime(DWORD dwReadAheadTime = DEFAULT_READAHEAD_TIME);
	HRESULT GetStreamingWaveHeader(_DMUS_IO_WAVE_HEADER* pStreamingWaveHeader);

	// Common base accessors mutators 
	GUID			GetFileGUID();								// Gets the m_guidFile that's written to DMUS_FOURCC_GUID_CHUNK
	void			SetFileGUID(GUID guidNew);					// Sets the m_guidFile that's written to DMUS_FOURCC_GUID_CHUNK
	CWaveNode*		GetNode() const;							// Gets the CWaveNode* this wave belongs to
	CWaveCtrl*		GetWaveEditor() const;						// CWaveCtrl* for this wave
	virtual void	SetCollection(CCollection* pCollection);	// Sets the collection for the wave
	CCollection*	GetCollection() const;						// Gets the collection for the wave

	int		GetNumberOfLoops();									// returns WSMPL.cSampleLoops
	DWORD	GetWaveLength();									// Gets the length of the wave
	bool	IsStereo();											// Is this a stereo wave?
	bool	IsLooped();											// Is the wave looped?
	void	SetLooped(bool bLoop);								// Sets the loop flag
	bool	IsUnityNoteAndFractionSame(const RSMPL& rsmpl, 
										short sUnityNote, 
										short sFineTune);		// Checks the unitynote and the MIDIPitchFraction
	void	CopySMPLToWSMP();									// Copies the legacy RSMPL structure into DLS WSMPL structure
    void	CopyWSMPToSMPL();									// Copies DLS WSMPL structure into legacy RSMPL the structure
	WSMPL	GetWSMPL();											// Returns the WSMPL struct
	WLOOP	GetWLOOP();											// Returns the WLOOP struct
	RSMPL	GetRSMPL();
	RLOOP	GetRLOOP();

	/* returns channel count */
	virtual LONG GetChannelCount() = 0;

	/* returns given channel */
	virtual CMonoWave *GetChannel(LONG iChannel) = 0;
	
	/* sets wavelink parameters according to channel number, returns the channel */
	virtual void SetWaveLinkPerChannel(LONG iChannel, WAVELINK *pwl) = 0;

	// Utility methods
	HRESULT	SafeAllocBuffer(BYTE** ppbBuffer, DWORD dwSize);	// Allocates and zeroes a buffer of size dwSize 
	virtual HRESULT FileNameChanged(CString sNewFileName) = 0;  // Called when the wavenode's file name changes
	void	NotifyWaveChange(bool bSetDirtyFlag);				// Notifies all the nodes that the wave has changed
	CString	SampleToTime(DWORD dwSample);						// Returns hr:min:sec:ms format string for the sample

	IStream*			GetHeaderMemStream();					// Gets the header in a memory stream in RIFF format
	virtual HRESULT		UpdateHeaderStream();					// Updates the header memory stream
	DWORD				GetRIFFHeaderSize();					// Returns the size of the header 

	void	SetHeaderOffset(DWORD dwOffset);
	void	SetDataOffset(DWORD dwOffset);		
	
    void    ValidateWLoop(WLOOP* pWLOOP);
	
	void	SetDirtyFlag();
	void	ClearDirtyFlag();
				
	USHORT	GetUnityNote();

	DWORD	GetWaveID() const;
	void	SetWaveID(const DWORD dwID);
	bool	GetWaveForID(DWORD dwID);

	/* returns whether the passed-in wave points to this one or any of its channels */
	bool IsReferencedBy(CWave *pWave);

	/* get/set start sample where decompressed data should start playing */
	void SetDwDecompressedStart(DWORD dwDecompressedStart) { m_dwDecompressedStart = dwDecompressedStart; }

	/* returns decompressed start, or 0 if bConsider is true and value shouldn't be taken into account */
	DWORD GetDwDecompressedStart(bool bConsider)
		{ return (bConsider && !FConsiderDecompressedStart()) ? 0 : m_dwDecompressedStart; }

	/* returns whether decompressed start should be taken into account for displaying or playing */
	bool FConsiderDecompressedStart();

	/* UI wrapper that attempts to set the decompressed start to the given value */
	HRESULT HrSetDecompressedStart(DWORD dwDecompressedDataStart);

	/* UI wrapper that validates loop start and end. Caller should only save undo state and set loop values on success. */
	HRESULT HrValidateLoopValues(DWORD &dwLoopStart, DWORD &dwLoopLength, const bool bLockLoopLength);

	/* loop length has changed in wave, update all regions referencing the wave */
	void UpdateLoopStartAndLengthInRegions();

	/* returns the minimum and maximum value of selection (and loop) */
	DWORD GetDwSelMax() { return m_dwWaveLength - GetDwDecompressedStart(true); }

	/* ensures the given sample count is within selection boundaries */
	void ConstrainToSelectionBoundaries(int& nSel);

protected:
	
	HRESULT FindSampleLoss(const WAVEFORMATEX* pwfxDest, DWORD& dwDifference);	// Finds out the number of samples lost in decompression


	HRESULT CalculateConversionSteps(const WAVEFORMATEX* pwfxSrc, 
										const WAVEFORMATEX* pwfxDst, 
										bool bEncode);							// Figures out the number of conversion steps required

	HRESULT ConvertWave(const WAVEFORMATEX* pwfxSource, 
						const WAVEFORMATEX* pwfxDest, 
						BYTE* pbSource, 
						const DWORD dwSourceSize, 
						BYTE** pbDest, 
						DWORD& cbConverted); 


	HRESULT ConvertWave(const DMUSP_WAVEOBJECT& sourceWave, 
						const WAVEFORMATEX *pwfxDst, 
						DMUSP_WAVEOBJECT& convertedWave, 
						bool bEncode, 
						DWORD dwSilenceSamples = 0);							// Converts the wave to the required format

	int	msaudioGetSamplePerFrame(int cSamplePerSec, 
								DWORD dwBitPerSec, 
								int cNumChannels, 
								int nVersion);									// Silent samples added by MSAudio codec

	WAVEFORMATEX*	CopyWaveFormat(const WAVEFORMATEX* pwfxSrc,	bool bCompress);// Returns a copy of the waveformat structure (inserts MSAudio keys if required)

	HRESULT			CopyWaveObject(const DMUSP_WAVEOBJECT* pSrcWaveObject, 
									DMUSP_WAVEOBJECT* pDstWaveObject,
									DWORD dwDataBufferSize = 0xFFFFFFFF);		// Returns a copy of the source wave object; user must delete this copy

	void			DeleteWaveObjectBuffers(DMUSP_WAVEOBJECT* pWaveObject);		// Deletes the allocated buffers in the object

	void			CleanWaveObject(DMUSP_WAVEOBJECT* pWaveObject);				// Deletes allocated memory and zeroes the structures

	// Attributes
public:
    CUnknownChunk       m_UnknownChunk;

	bool				m_bCompressed;				// This wave is compressed
	bool				m_bLoadingRuntime;			// This wave's being loaded from a Runtime file
	DWORD				m_dwPreviousRegionLinkID;	// Used to store the region link when the instruments are drag-dropped
	
	// Common attributes for both Mono and Stereo waves
	WAVEFORMATEX		m_rWaveformat;				// Standard Wave format header.

	DWORD				m_dwWaveLength;				// Length of wave (in samples).
	CInfo				m_Info;						// Waves can have names, useful for identification.

	BOOL				m_bStreaming;				// Is this a streaming wave
	BOOL				m_bNoPreroll;				// Do we need to pre-roll the wave data?
	DWORD				m_dwReadAheadTime;			// Read ahead time used in streaming waves; convert to REFERENCE_TIME when saving it to the 'wavh' chunk
	
	static CWaveCompressionManager	m_CompressionManager;	// The one and only object that handles compression
	
protected:

	CWaveNode*			m_pWaveNode;			// The node that contains this wave
	CWaveDataManager*	m_pDataManager;			// All data read/write requests go through this object
	CInstrument*		m_pDummyInstrument;		// Used to play the wave
	BOOL                m_bIsPlaying;			// set if we're playing a wave.
    BOOL                m_bPlayLooped;			// True if we should play looped.
	int					m_nTimePlayed;			// Time wave was played.
	short				m_sUnityNoteUsedToTriggerPlay;	// note specified in the playmidievent note_on 
	
	DMUSP_WAVEOBJECT	m_CompressedWavObj;		// The compressed wav (if compression is turned on)
	DMUSP_WAVEOBJECT	m_OriginalWavObj;		// The original uncompressed wav (at all times)
	DMUSP_WAVEOBJECT	m_DecompressedWavObj;	// The decompressed wav (if compression is turned on)

	CCollection*		m_pCollection;			// Collection this wave belongs to...may be NULL
	
	DWORD				m_dwDataSize;			// Size of wave (in bytes).
	ULONG				m_dwHeaderOffset;		// Offset into wave pool.
	DWORD				m_dwDataOffset;			// Offset to the data chunk

	BOOL				m_fReadFormat;			// Make sure Wave read has formatex chunk.
    BOOL				m_fReadWSMP;			// And it has read the WSMP chunk!
    BOOL				m_fReadSMPL;			// And that it has SMPL chunk.

	WLOOP				m_rWLOOPUncompressed;	// WLOOP struct that remembers the loop points set before compression
	WLOOP				m_rWLOOPCompressed;		// WLOOP struct that remembers the loop points set after compression

    BOOL                m_bUseFormatSuggest;    // If we successfully read the WAVU chunk decompression info this is set to TRUE; else we need to do acmFormatSuggest

	// IMPORTANT: the following two member structs need to be together in order
	// for file load logic to work
	WSMPL				m_rWSMP;        // New version of wave sample chunk.
	WLOOP				m_rWLOOP;       // New version of loop info.

/////////////////////////////////////////////////////////////////////////////////////////////
// IMPORTANT: the following two member structs need to be together in order
// for file load logic to work
    RSMPL				m_rRSMPL;       // Wave sampling extension (for wave saving only.)
	RLOOP		        m_rRLOOP;       // Loop information (for wave saving.)

	DWORD				m_dwDecompressedStart;	// sample at which decompressed data should start playing (avoids silence at start of codecs like MP3)

private:
	CWavePropPgMgr*		m_pWavePropPgMgr;	// Manages property pages
    long				m_lRef;				// Reference count for the wave

	CString				m_sTempFileName;
	DWORD				m_dwRIFFHeaderSize;	// Size of the header for the wave to be passed to the wavetrack 
	IStream*			m_pIMemHeaderStream;// Keeps the header in RIFF format so we can pass it to the wavetrack	

	DWORD	m_dwId;								// Load/Save Identifier.(waves number sequentially)
	
	CTypedPtrArray<CPtrArray, WAVEFORMATEX*>			m_arrIntermediateFormats;	// List of intermediate wave objects required for wave conversion
};

#endif // __WAVE_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\DLSDesigner\wave.cpp ===
//////////////////////////////////////////////////////////////////////
//
// Wave.cpp : implementation file
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include <mmsystem.h>
#include <mmreg.h>
#include <msacm.h>
#include "DLSDesignerDLL.h"
#include "WaveNode.h"
#include "Wave.h"
#include "MonoWave.h"
#include "Region.h"
#include "Collection.h"
#include "DLSLoadSaveUtils.h"
#include "WavePropPgMgr.h"
#include "WavePropPg.h"
#include "WaveInfoPropPg.h"
#include "WaveCompressionPropPage.h"
#include "stream.h"
#include "Instrument.h"
#include "Wavectl.h"
#include "resource.h"
#include "Articulation.h"

#include "WaveDataManager.h"

#include "DlsDefsPlus.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

#define RESAMPLE_SIZE_CHANGE( dwNewSampleRate, dwOldSampleRate, dwOldSize ) ((__int64(dwNewSampleRate) * __int64(dwOldSize) + __int64(dwOldSampleRate)/2)/__int64(dwOldSampleRate))


CWaveCompressionManager	CWave::m_CompressionManager;

//////////////////////////////////////////////////////////////////////
//
//	CWave::CWave();
//
//////////////////////////////////////////////////////////////////////
CWave::CWave(CWaveNode* pNode, DWORD dwSampleRate, UINT nSampleSize, UINT nChannels) :
m_bPlayLooped(false),
m_bCompressed(false),
m_bLoadingRuntime(false),
m_dwPreviousRegionLinkID(0),
m_pWavePropPgMgr(NULL),
m_bIsPlaying(FALSE),
m_pDataManager(NULL),
m_pDummyInstrument(NULL), 
m_pIMemHeaderStream(NULL),
m_bStreaming(FALSE),
m_bNoPreroll(FALSE),
m_bUseFormatSuggest(TRUE),
m_dwReadAheadTime(DEFAULT_READAHEAD_TIME),
m_dwId(0),
m_dwDecompressedStart(0)
{
	ASSERT( pNode != NULL );

    m_lRef = 0;
	AddRef();

	m_pWaveNode = pNode;
    m_pCollection = NULL;

	m_nTimePlayed = 0;

	m_dwWaveLength = 0;
	m_dwDataSize = 0;

	m_rWaveformat.wFormatTag = WAVE_FORMAT_PCM;
    m_rWaveformat.nChannels = WORD(nChannels);
    m_rWaveformat.nSamplesPerSec = dwSampleRate;
	m_rWaveformat.wBitsPerSample = WORD(nSampleSize);
    m_rWaveformat.nAvgBytesPerSec = dwSampleRate * (nSampleSize / 8);
    m_rWaveformat.nBlockAlign = nChannels * (nSampleSize / 8);
	m_rWaveformat.cbSize = 0;
    
	m_rRSMPL.dwManufacturer = 0x03000041;   // Microsoft.
    m_rRSMPL.dwProduct = 0;
    m_rRSMPL.dwSamplePeriod = 45351;        // 22 kHz.
    m_rRSMPL.dwMIDIUnityNote = 60;
    m_rRSMPL.dwMIDIPitchFraction = 0;
    m_rRSMPL.dwSMPTEFormat = 0;
    m_rRSMPL.dwSMPTEOffset = 0;
    m_rRSMPL.cSampleLoops = 0;
    m_rRSMPL.cbSamplerData = 0;
    
	m_rRLOOP.dwIdentifier = 0;
    m_rRLOOP.dwType = 0;
    m_rRLOOP.dwStart = 0;
    m_rRLOOP.dwEnd = 0;
    m_rRLOOP.dwFraction = 0;
    m_rRLOOP.dwPlayCount = 0;
    
	m_rWSMP.cbSize = sizeof(WSMPL);
    m_rWSMP.usUnityNote = 60;
    m_rWSMP.sFineTune = 0;
    m_rWSMP.lAttenuation = 0;
    m_rWSMP.fulOptions = F_WSMP_NO_TRUNCATION;
    m_rWSMP.cSampleLoops = 0;
    
	m_rWLOOP.cbSize = sizeof(WLOOP);
    m_rWLOOP.ulType = WLOOP_TYPE_FORWARD;
    m_rWLOOP.ulStart = 0;
    m_rWLOOP.ulLength = 0;

	ZeroMemory(&m_CompressedWavObj, sizeof(DMUSP_WAVEOBJECT));
	ZeroMemory(&m_OriginalWavObj, sizeof(DMUSP_WAVEOBJECT));
	ZeroMemory(&m_DecompressedWavObj, sizeof(DMUSP_WAVEOBJECT));

	CopyMemory(&m_OriginalWavObj.WaveFormatEx, &m_rWaveformat, sizeof(WAVEFORMATEX));
	
	if(m_pWavePropPgMgr == NULL)
	{
		m_pWavePropPgMgr = new CWavePropPgMgr();
	}
	else
	{
		m_pWavePropPgMgr->AddRef();
	}

	CDLSComponent* pComponent = pNode->GetComponent();
	ASSERT(pComponent);
	IDMUSProdFramework* pIFramework = pComponent->m_pIFramework;
	ASSERT(pIFramework);
	pIFramework->AllocMemoryStream(FT_RUNTIME, GUID_CurrentVersion, &m_pIMemHeaderStream);
}



//////////////////////////////////////////////////////////////////////
//
//	CWave::~CWave()
//
//////////////////////////////////////////////////////////////////////
CWave::~CWave()
{
	ASSERT(m_pWaveNode);
	CDLSComponent* pComponent = m_pWaveNode->GetComponent();
	ASSERT(pComponent);
	IDMUSProdFramework* pIFramework = pComponent->m_pIFramework;

	// If we are in a Property Page Manager we need to remove ourselves before we go away
	IDMUSProdPropSheet *pIPropSheet;
	if(SUCCEEDED(pIFramework->QueryInterface(IID_IDMUSProdPropSheet, (void**) &pIPropSheet)))
	{
		if(pIPropSheet->IsEqualPageManagerObject(this) == S_OK)
		{
			pIPropSheet->RemovePageManagerByObject(this);
		}
		else
		{
			if(m_pWavePropPgMgr)
			{
				m_pWavePropPgMgr->RemoveObject(this);
			}
		}
		pIPropSheet->Release();
	}
	
	if(m_pWavePropPgMgr)
	{
		DWORD refCount = m_pWavePropPgMgr->Release();
		
		if(refCount == 0) 
			m_pWavePropPgMgr = NULL;
	}

	while(m_arrIntermediateFormats.GetSize() > 0)
	{
		delete[] m_arrIntermediateFormats[0];
		m_arrIntermediateFormats.RemoveAt(0);
	}

	DeleteWaveObjectBuffers(&m_CompressedWavObj);
	DeleteWaveObjectBuffers(&m_OriginalWavObj);
	DeleteWaveObjectBuffers(&m_DecompressedWavObj);

	if(m_pDataManager)
	{
		delete m_pDataManager;
		m_pDataManager = NULL;
	}

	if(m_pIMemHeaderStream)
	{
		m_pIMemHeaderStream->Release();
		m_pIMemHeaderStream = NULL;
	}

	if(m_pDummyInstrument)
	{
		m_pDummyInstrument->Release();
		m_pDummyInstrument = NULL;
	}
}

//////////////////////////////////////////////////////////////////////
//
//	CWave ::QueryInterface()
//
//////////////////////////////////////////////////////////////////////
HRESULT CWave::QueryInterface(REFIID riid, LPVOID *ppvObj)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

    if(::IsEqualIID(riid, IID_IPersist)
	||::IsEqualIID(riid, IID_IUnknown))
    {
        AddRef();
        *ppvObj = (IPersist*)this;
        return S_OK;
    }

    if(::IsEqualIID(riid, IID_IPersistStream))
    {
        AddRef();
        *ppvObj = (IPersistStream*)this;
        return S_OK;
    } 

	if( ::IsEqualIID(riid, IID_IDMUSProdPropPageObject) )
    {
        AddRef();
        *ppvObj = (IDMUSProdPropPageObject*)this;
        return S_OK;
    }

    *ppvObj = NULL;
    return E_NOINTERFACE;
}

//////////////////////////////////////////////////////////////////////
//
//	CWave::AddRef()
//
//////////////////////////////////////////////////////////////////////
ULONG CWave::AddRef()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	AfxOleLockApp();
    return InterlockedIncrement(&m_lRef);
}

//////////////////////////////////////////////////////////////////////
//
//	CWave::Release()
//
//////////////////////////////////////////////////////////////////////
ULONG CWave::Release()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
    ASSERT(m_lRef != 0);

	InterlockedDecrement(&m_lRef); 

    if(m_lRef == 0)
    {
        delete this;
        return 0;
    }
	AfxOleUnlockApp();
    return m_lRef;
}


/////////////////////////////////////////////////////////////////////////////
// CWave IDMUSProdPropPageObject implementation

/////////////////////////////////////////////////////////////////////////////
// CWave IDMUSProdPropPageObject::GetData

HRESULT CWave::GetData(void** ppData)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT(ppData);

	*ppData = this;

	return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
// CWave IDMUSProdPropPageObject::SetData

HRESULT CWave::SetData(void* pData)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT(pData);

	return E_NOTIMPL;
}

/////////////////////////////////////////////////////////////////////////////
// CWave IDMUSProdPropPageObject::OnRemoveFromPageManager

HRESULT CWave::OnRemoveFromPageManager(void)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
// CWave IDMUSProdPropPageObject::OnShowProperties

HRESULT CWave::OnShowProperties(void)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	HRESULT hr = E_FAIL;
	ASSERT(m_pWaveNode);

	CDLSComponent* pComponent = m_pWaveNode->GetComponent();
	ASSERT(pComponent);
	IDMUSProdFramework* pIFramework = pComponent->m_pIFramework;


	// Show the Collection properties
	IDMUSProdPropSheet* pIPropSheet;

	hr = pIFramework->QueryInterface(IID_IDMUSProdPropSheet, (void**)&pIPropSheet);
	if(SUCCEEDED(hr))
	{
		int nActivePage = (int) CWavePropPgMgr::dwLastSelPage;
		hr = pIPropSheet->SetPageManager(m_pWavePropPgMgr);
		
		if(SUCCEEDED(hr))
		{
			m_pWavePropPgMgr->SetObject(this);
			pIPropSheet->SetActivePage(short(nActivePage)); 
		}

		pIPropSheet->Show(TRUE);
		pIPropSheet->Release();
	}

	// Set the wave node as the selecetd node if it's not already selected
	m_pWaveNode->SetSelected();

	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CWave IPersist implementation

HRESULT CWave::GetClassID(CLSID* pClsId)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

    ASSERT(pClsId != NULL);

    memset(pClsId, 0, sizeof( CLSID ));

    return E_NOTIMPL;
}

/////////////////////////////////////////////////////////////////////////////
// CWave IPersistStream implementation

/////////////////////////////////////////////////////////////////////////////
//
// CWave IPersistStream::IsDirty
//
//////////////////////////////////////////////////////////////////////
HRESULT CWave::IsDirty()
{
    // I want to know if I am called
	ASSERT(FALSE);

	AFX_MANAGE_STATE(_afxModuleAddrThis);
	return E_NOTIMPL;
}

/////////////////////////////////////////////////////////////////////////////
//
// CWave IPersistStream::GetSizeMax
//
//////////////////////////////////////////////////////////////////////
HRESULT CWave::GetSizeMax( ULARGE_INTEGER FAR* /*pcbSize*/ )
{
    // I want to know if I am called
	ASSERT(FALSE);

	AFX_MANAGE_STATE(_afxModuleAddrThis);
	return E_NOTIMPL;
}

/////////////////////////////////////////////////////////////////////////////
//
// CWave IPersistStream::Load
//
//////////////////////////////////////////////////////////////////////
HRESULT CWave::Load(IStream* pIStream)
{
    AFX_MANAGE_STATE(_afxModuleAddrThis);

    ASSERT( pIStream != NULL );
	HRESULT hr = E_FAIL;
	MMCKINFO ckMain;
    IDMUSProdRIFFStream* pRiffStream = NULL;

    hr = AllocRIFFStream(pIStream, &pRiffStream);                
	if (SUCCEEDED(hr))
	{
		ckMain.fccType = mmioFOURCC('W','A','V','E');
		if( pRiffStream->Descend( &ckMain, NULL, MMIO_FINDRIFF ) == 0 )
		{
			hr = Load(pRiffStream, &ckMain);  
		}
    }

    if (pRiffStream)
    {
        pRiffStream->Release();
    }

	return hr;
}

/////////////////////////////////////////////////////////////////////////////
//
// CWave IPersistStream::Save
//
//////////////////////////////////////////////////////////////////////
HRESULT CWave::Save(IStream* pIStream, BOOL fClearDirty)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

    ASSERT(pIStream);
    
    HRESULT hr = E_FAIL;

    IDMUSProdRIFFStream* pRiffStream = NULL;

    hr = AllocRIFFStream(pIStream, &pRiffStream);                
	if (SUCCEEDED(hr))
	{
        hr = Save(pRiffStream, MMIO_CREATERIFF, TRUE);  //fullsave is true.
    }

    if (pRiffStream)
    {
        pRiffStream->Release();
    }

    if(m_pCollection && fClearDirty )
    {
        m_pCollection->ClearDirtyFlag();
    }

    return hr;

}

HRESULT CWave::Load(IDMUSProdRIFFStream* pIRiffStream, MMCKINFO* pckMain)
{
	IStream* pIStream = pIRiffStream->GetStream();
	ASSERT(pIStream);
	if(pIStream == NULL)
	{
		return E_OUTOFMEMORY;
	}

	// Remember where the stream pointer is positioned
	DWORD dwStreamPosition = StreamTell(pIStream);

	// Load the header first
	if(FAILED(LoadHeader(pIRiffStream, pckMain)))
	{
		pIStream->Release();
		return E_FAIL;
	}

	// Load the data
	StreamSeek(pIStream, dwStreamPosition, STREAM_SEEK_SET );

	// Initialize the data manager
	ASSERT(m_pDataManager);
	if(FAILED(m_pDataManager->Initialize(pIStream)))
	{
		TRACE("--- DataManager::Initialize Failed ---\n");
		pIStream->Release();
		return E_FAIL;
	}

	pIStream->Release();

	// Always give precedence to the legacy RSMPL loop structure
	// Otherwise we might end up ignoring changes made to the wave 
	// files in SoundForge etc. which also have WSMPL chunks in them
	if (m_fReadSMPL)
    {
		// The RSMPL structure field dwMIDIPitchFraction keeps a +ve value 
		// that is the fraction of a semitone above the untiy note
		// WSMP on the other hand let's you have a fine tune value between 
		// -12 to +12 semitones. Since we always give RSMPL chunk the precedence 
		// copying the RSMPL values into WSMPL struct will make the unitynote 
		// and fine tune values jump which results in some problems...
		// So we check if the values are basically the same and if they are we use
		// the WSMPL values instead of RSMPL. Easy enough?
		short sUnityNote = m_rWSMP.usUnityNote;
		short sFineTune = m_rWSMP.sFineTune;
		CopySMPLToWSMP();
		if(IsUnityNoteAndFractionSame(m_rRSMPL, sUnityNote, sFineTune))
		{
			m_rWSMP.usUnityNote = sUnityNote;
			m_rWSMP.sFineTune = sFineTune;
		}

	}
	else
	{
		CopyWSMPToSMPL();
	}

	// Set the loop flag
	if(m_rWSMP.cSampleLoops > 0)
	{
		m_bPlayLooped = true;
	}
	else
	{
		m_bPlayLooped = false;
	}

	// Validate the loop values...
	// These might have been set to illegal values outside Producer
	if(m_rWLOOP.ulStart > m_dwWaveLength)
	{
		m_rWLOOP.ulStart = 0;
	}
	
	if(m_rWLOOP.ulStart + m_rWLOOP.ulLength > m_dwWaveLength || m_rWLOOP.ulStart + m_rWLOOP.ulLength < MINIMUM_VALID_LOOPLENGTH)
	{
		m_rWLOOP.ulLength = m_dwWaveLength - m_rWLOOP.ulStart;
	}

	// The compressed loop also gets modified
	RememberLoopBeforeCompression();
	RememberLoopAfterCompression();

	return S_OK;
}

// Loads all the information about the wave except the actual wave data
HRESULT CWave::LoadHeader(IDMUSProdRIFFStream* pIRiffStream, MMCKINFO* pckMain)
{
	ASSERT(pIRiffStream);
	if(pIRiffStream == NULL)
	{
		return E_POINTER;
	}

	ASSERT(pckMain);
	if(pckMain == NULL)
	{
		return E_POINTER;
	}
	
	IStream* pIStream = pIRiffStream->GetStream();
	ASSERT(pIStream);
	if(pIStream == NULL)
	{
		return E_OUTOFMEMORY;
	}

	m_bLoadingRuntime = true;

	IDMUSProdPersistInfo* pIJazzPersistInfo;
	if(SUCCEEDED(pIStream->QueryInterface(IID_IDMUSProdPersistInfo,(void**) &pIJazzPersistInfo)))
	{
		DMUSProdStreamInfo	StreamInfo;
		FileType	ftSaveType;

		pIJazzPersistInfo->GetStreamInfo(&StreamInfo);
		ftSaveType = StreamInfo.ftFileType;

		if(ftSaveType == FT_RUNTIME || ftSaveType == FT_UNKNOWN)
		{
			m_bLoadingRuntime = true;
		}
		else
		{
			m_bLoadingRuntime = false;
		}
		
		pIJazzPersistInfo->Release();		
	}

	bool bReadDMUSWaveHeader = false;

	m_fReadFormat = FALSE;
	m_fReadWSMP = FALSE; 
	m_fReadSMPL = FALSE; 
	
	// Clean the wave objects
	CleanWaveObject(&m_OriginalWavObj);
	CleanWaveObject(&m_CompressedWavObj);
	CleanWaveObject(&m_DecompressedWavObj);

	// Walk down the RIFF file looking for chunks
	MMCKINFO ck;
	ck.ckid = 0;
	ck.fccType = 0;
	while(pIRiffStream->Descend(&ck, pckMain, 0) == 0)
	{
		switch(ck.ckid)
		{
			// Load the DRAG chunk
			case FOURCC_DRAG: 
			{
				if(FAILED(ReadDRAG(pIStream, &ck)))
				{
					pIStream->Release();
					return E_FAIL;
				}
				break;
			}

			case DMUS_FOURCC_GUID_CHUNK:
			{
				if(FAILED(ReadGUID(pIStream, &ck)))
				{
					pIStream->Release();
					return E_FAIL;
				}

				break;
			}

			// Load the stereo wave info chunk
			case FOURCC_WVST:
			{
				if(FAILED(ReadWVST(pIStream, &ck)))
				{
					pIStream->Release();
					return E_FAIL;
				}
				break;
			}

			case DMUS_FOURCC_WAVEHEADER_CHUNK:
			{
				_DMUS_IO_WAVE_HEADER waveHeader;
				
				DWORD cb = 0;
				HRESULT hr = pIStream->Read(&waveHeader, sizeof(_DMUS_IO_WAVE_HEADER), &cb) ;
				if(FAILED(hr) || cb != sizeof(_DMUS_IO_WAVE_HEADER))
				{
					return hr = E_FAIL;
				}

				m_bStreaming = waveHeader.dwFlags & DMUS_WAVEF_STREAMING;
				m_bNoPreroll = waveHeader.dwFlags & DMUS_WAVEF_NOPREROLL;
				m_dwReadAheadTime = (DWORD)waveHeader.rtReadAhead / 10000;
				if(m_dwReadAheadTime < MIN_READAHEAD)
				{
					m_dwReadAheadTime = MIN_READAHEAD;
				}
				else if(m_dwReadAheadTime > MAX_READAHEAD)
				{
					m_dwReadAheadTime = MAX_READAHEAD;
				}

				bReadDMUSWaveHeader = true;

				break;
			}

			// Load the chunk with compression information
			case FOURCC_WAVU:
			{
				if(FAILED(ReadWAVU(pIStream, &ck)))
				{
					pIStream->Release();
					return E_FAIL;
				}
				break;
			}

			// RIFF LIST chunk...could be info or an nunknown chunk
			case FOURCC_LIST:
			{
				if(ck.fccType == FOURCC_INFO)
				{
					m_Info.Load(pIRiffStream, &ck);
				}
				else
				{
					// Could be a corrupt RIFF file...
                    // We'll just read the entire LIST chunk
                    DWORD dwStreamPosition = StreamTell(pIStream);
                    m_UnknownChunk.Load(pIRiffStream, &ck, TRUE);
                    StreamSeek(pIStream, dwStreamPosition, STREAM_SEEK_SET );

				}

				break;
			}

			// Load the wave format chunk
			case FOURCC_FMT:
			{
				if(FAILED(ReadFMT(pIStream, &ck)))
				{
					pIStream->Release();
					return E_FAIL;
				}
				m_fReadFormat = TRUE;
				break;
			}

			// Read the WSMPL chunk
			case FOURCC_WSMP:
			{
				if(FAILED(ReadWSMP(pIStream, &ck)))
				{
					pIStream->Release();
					return E_FAIL;
				}

				m_fReadWSMP = TRUE;
				break;
			}

			// Read the RSMPL chunk
			case FOURCC_SMPL:
			{
				if(FAILED(ReadSMPL(pIStream, &ck)))
				{
					pIStream->Release();
					return E_FAIL;
				}

				m_fReadSMPL = TRUE;
				break;
			}

			// Read the data chunk size but NOT the actual data
			case FOURCC_DATA:
			{
				m_dwDataOffset = StreamTell(pIStream);
				if(FAILED(ReadDataInfo(pIStream, &ck)))
				{
					pIStream->Release();
					return E_FAIL;
				}
				break;
			}

			// Ignore these chunks
			case FOURCC_EDIT:
			case FOURCC_FACT:
			{
				break;
			}

			// Whatever other chunks get loaded as unknown chunks
			default:
			{
				m_UnknownChunk.Load(pIRiffStream, &ck, FALSE);
				break;
			}
		}

		pIRiffStream->Ascend(&ck, 0);
		ck.ckid = 0;
		ck.fccType = 0;
	}

	pIStream->Release();

	if(bReadDMUSWaveHeader == false)
	{
		CheckSizeAndSetStreaming();
	}

	return S_OK;
}

void CWave::CheckSizeAndSetStreaming()
{
	UINT nSampleSize = m_rWaveformat.wBitsPerSample / 8;
	DWORD dwWaveLength = m_dwDataSize / nSampleSize;
	DWORD dwPlayTime = dwWaveLength / m_rWaveformat.nSamplesPerSec;

	// Can't set this on a wave in a collection
	// Shouldn't even get here
	if(m_pWaveNode->IsInACollection())
	{
		return;
	}
	if(dwPlayTime > 5)
	{
		m_bStreaming = TRUE;
		m_dwReadAheadTime = 500;
	}
}


HRESULT CWave::WriteGUIDChunk(IDMUSProdRIFFStream* pIRiffStream)
{
	ASSERT(pIRiffStream);
	if(pIRiffStream == NULL)
	{
		return E_POINTER;
	}

	IStream* pIStream = pIRiffStream->GetStream();
	ASSERT(pIStream);
	if(pIStream == NULL)
	{
		return E_POINTER;
	}

	// Write the DMUS_FOURCC_GUID_CHUNK
	MMCKINFO ck;
	ck.ckid = DMUS_FOURCC_GUID_CHUNK;
	HRESULT hr = pIRiffStream->CreateChunk(&ck, 0);
	if(FAILED(hr))
	{
		pIStream->Release();
		return E_FAIL;
	}

	DWORD cb = 0;
	GUID guidFile = m_pWaveNode->GetFileGUID();
	hr = pIStream->Write((LPSTR)&guidFile, sizeof(GUID), &cb);
	if(FAILED(hr))
	{
		pIStream->Release();
		return E_FAIL;
	}

	if(FAILED(pIRiffStream->Ascend(&ck, 0)))
	{
		pIStream->Release();
		return E_FAIL;
	}

	pIStream->Release();

	return S_OK;

}

HRESULT CWave::ReadDRAG(IStream* pIStream, MMCKINFO* pckMain)
{
	ASSERT(pIStream);
	if(pIStream == NULL)
	{
		return E_POINTER;
	}

	ASSERT(pckMain);
	if(pckMain == NULL)
	{
		return E_POINTER;
	}

	DWORD cb = 0;
	HRESULT hr = pIStream->Read(&m_dwPreviousRegionLinkID, sizeof(DWORD), &cb) ;
	if(FAILED(hr) || cb != sizeof(DWORD))
	{
		return E_FAIL;
	}

	return hr;
}


HRESULT CWave::ReadGUID(IStream* pIStream, MMCKINFO* pckMain)
{
	ASSERT(m_pWaveNode);
	if(m_pWaveNode == NULL)
	{
		return E_UNEXPECTED;
	}

	ASSERT(pIStream);
	if(pIStream == NULL)
	{
		return E_POINTER;
	}

	ASSERT(pckMain);
	if(pckMain == NULL)
	{
		return E_POINTER;
	}

	DWORD cb = 0;
	HRESULT hr = pIStream->Read(&m_pWaveNode->m_guidFile, sizeof(GUID), &cb);
	if(FAILED(hr) || cb != sizeof(GUID))
	{
		return E_FAIL;
	}

	// This will happen when the node gets added to the nodes list in CDLSComponent
	// LoadRIFFChunk doesn't necessarily add the node to the list and other componenets
	// may want to check for duplicate nodes (ContainerDesigner)
	// Fixed for ManBugs 37114
	// m_pWaveNode->SetFileGUID(guidFile);

	return hr;
}


HRESULT CWave::ReadWAVU(IStream* pIStream, MMCKINFO* pckMain)
{
	ASSERT(pIStream);
	if(pIStream == NULL)
	{
		return E_POINTER;
	}

	ASSERT(pckMain);
	if(pckMain == NULL)
	{
		return E_POINTER;
	}

	DWORD cb = 0;
	// Read the flag which indiactes Runtime or Designtime File
	HRESULT hr = pIStream->Read(&m_bLoadingRuntime, sizeof(bool), &cb);
	if(FAILED(hr) || cb != sizeof(bool))
	{
		return E_FAIL;
	}

	// Read the flag that indicates compression
	hr = pIStream->Read(&m_bCompressed, sizeof(bool), &cb);
	if(FAILED(hr) || cb != sizeof(bool))
	{
		return E_FAIL;
	}

	// Init the necessary wave objects
	if(m_bCompressed)
	{
		if(!m_bLoadingRuntime)
		{
			// Read the format we have to compress the wave to...
			hr = pIStream->Read((LPSTR) &(m_CompressedWavObj.WaveFormatEx), sizeof(WAVEFORMATEX), &cb);	
			if(FAILED(hr) || cb != sizeof(WAVEFORMATEX))
			{
				m_bCompressed = false;
				AfxMessageBox(IDS_ERR_UNSUPPORTED_COMPRESSION_FORMAT);
				return E_FAIL;
			}

			// Compressed waves might have extra information in the header
			// Subtract one byte each from the total chunk size for the 
			// runtime/designtime and compressed flags
			ASSERT(pckMain->cksize - 2 >= sizeof(WAVEFORMATEX));
			DWORD cbExtra = m_CompressedWavObj.WaveFormatEx.cbSize;
			if (cbExtra > 0)
			{
				if(FAILED(SafeAllocBuffer(&m_CompressedWavObj.pbExtractWaveFormatData, cbExtra)))
					return E_OUTOFMEMORY;

				hr = pIStream->Read(m_CompressedWavObj.pbExtractWaveFormatData, cbExtra, &cb);
				if(FAILED(hr))
				{
					delete[] m_CompressedWavObj.pbExtractWaveFormatData;
					return E_FAIL;
				}
				ASSERT(cbExtra == cb);
			}
            
            if(pckMain->cksize > sizeof(WAVEFORMATEX) + cbExtra + 2)
            {
                cb = 0;
                hr = pIStream->Read(&m_dwDecompressedStart, sizeof(DWORD), &cb);
                if(FAILED(hr) || cb != sizeof(DWORD))
                {
                    delete[] m_CompressedWavObj.pbExtractWaveFormatData;
                    return E_FAIL;
                }
            }

		}
		else if(m_bLoadingRuntime)
		{
			// Read the format we need to decompress to...
			hr = pIStream->Read((LPSTR) &(m_rWaveformat), sizeof(WAVEFORMATEX), &cb);	
			if(FAILED(hr) || cb != sizeof(WAVEFORMATEX) || m_rWaveformat.wFormatTag != WAVE_FORMAT_PCM)
			{
				AfxMessageBox(IDS_ERR_RUNTIME_UNSUPPORTED_COMPRESSION_FORMAT);
				return E_FAIL;
			}

            if(pckMain->cksize > sizeof(WAVEFORMATEX) + 2)
            {
                cb = 0;
                hr = pIStream->Read(&m_dwDecompressedStart, sizeof(DWORD), &cb);
                if(FAILED(hr) || cb != sizeof(DWORD))
                    return E_FAIL;
            }


            // Make sure the average bytes per sec is correct
            m_rWaveformat.nAvgBytesPerSec = m_rWaveformat.nSamplesPerSec * m_rWaveformat.nBlockAlign;

            CopyMemory(&(m_OriginalWavObj.WaveFormatEx), &m_rWaveformat, sizeof(WAVEFORMATEX));

            m_bUseFormatSuggest = FALSE;
		}
	}

	return S_OK;

}


HRESULT CWave::ReadFMT(IStream* pIStream, MMCKINFO* pckMain)
{
	ASSERT(pIStream);
	if(pIStream == NULL)
	{
		return E_POINTER;
	}

	ASSERT(pckMain);
	if(pckMain == NULL)
	{
		return E_POINTER;
	}

	DWORD cSize = sizeof(WAVEFORMATEX);
	if( pckMain->cksize < sizeof(WAVEFORMATEX) )
	{
		cSize = pckMain->cksize;
	}
	
	DWORD cb = 0;
    WAVEFORMATEX wfxTemp;
	HRESULT hr = pIStream->Read( &wfxTemp, cSize, &cb );
	if(FAILED(hr))
	{
		return E_FAIL;
	}

	// Check for the sample sizes
	if(wfxTemp.wFormatTag == 1 && wfxTemp.wBitsPerSample != 8 && wfxTemp.wBitsPerSample != 16)
	{
		AfxMessageBox(IDS_ERR_WRONGSAMPLESIZE, MB_ICONEXCLAMATION);
		return E_FAIL;
	}

	// Just warn for the sample rates not between 3KHz and 80KHz
	if(wfxTemp.nSamplesPerSec < 3072 || wfxTemp.nSamplesPerSec > 81920)
	{
		AfxMessageBox(IDS_WARN_SAMPLERATE, MB_ICONEXCLAMATION);
	}


    // Is this in PCM format?
	if(wfxTemp.wFormatTag == WAVE_FORMAT_PCM) 
	{
        // Make sure we have the correct average bytes per sec
        wfxTemp.nAvgBytesPerSec = wfxTemp.nSamplesPerSec * wfxTemp.nBlockAlign;

		CopyMemory(&m_rWaveformat, &wfxTemp, sizeof(wfxTemp));
		
		// Copy this into the Original Wav Object
		CopyMemory(&(m_OriginalWavObj.WaveFormatEx), &wfxTemp, sizeof(wfxTemp));

		// If WAVE_FORMAT_PCM the extra info size should be zero
		m_rWaveformat.cbSize = 0;
		m_OriginalWavObj.WaveFormatEx.cbSize = 0;

		return S_OK;
	}
	else if(m_bLoadingRuntime)
	{
		// this muct be a wave file compressed outside of Producer?
		m_bCompressed = true;
	}

	// If it's a compressed runtime file, initialize the CompressedWavObj
	if(m_bCompressed && m_bLoadingRuntime)
	{
		CopyMemory(&(m_CompressedWavObj.WaveFormatEx), &wfxTemp, sizeof(wfxTemp));

		// Now we need the extra info bits
		if(m_CompressedWavObj.WaveFormatEx.cbSize)
		{
			if(m_CompressedWavObj.pbExtractWaveFormatData)
			{
				delete[] m_CompressedWavObj.pbExtractWaveFormatData;
				m_CompressedWavObj.pbExtractWaveFormatData = NULL;
			}

			if(FAILED(SafeAllocBuffer(&m_CompressedWavObj.pbExtractWaveFormatData, m_CompressedWavObj.WaveFormatEx.cbSize)))
			{
				return E_OUTOFMEMORY;
			}

			hr = pIStream->Read(m_CompressedWavObj.pbExtractWaveFormatData, wfxTemp.cbSize, &cb);
			if(FAILED(hr) || cb != wfxTemp.cbSize)
			{
				delete[] m_CompressedWavObj.pbExtractWaveFormatData;
				return E_FAIL;
			}
		}

		if(m_bUseFormatSuggest == TRUE)
		{
			BYTE* pbSrcFormat = NULL;
			if(FAILED(SafeAllocBuffer(&pbSrcFormat, sizeof(WAVEFORMATEX) + wfxTemp.cbSize)))
			{
				return E_OUTOFMEMORY;
			}
			CopyMemory(pbSrcFormat, &m_CompressedWavObj.WaveFormatEx, sizeof(WAVEFORMATEX));
			CopyMemory(((BYTE*)pbSrcFormat) + sizeof(WAVEFORMATEX), m_CompressedWavObj.pbExtractWaveFormatData, wfxTemp.cbSize);
			
			if(MMSYSERR_NOERROR != acmFormatSuggest(NULL, ((WAVEFORMATEX*)pbSrcFormat), &m_rWaveformat, sizeof(WAVEFORMATEX), ACM_FORMATSUGGESTF_WFORMATTAG))
			{
				delete[] pbSrcFormat;
				return E_FAIL;
			}

            CopyMemory(&(m_OriginalWavObj.WaveFormatEx), &m_rWaveformat, sizeof(WAVEFORMATEX));

            delete[] pbSrcFormat;
		}
	}
	else 
	{
		AfxMessageBox(IDS_WAVE_NOT_PCM, MB_ICONEXCLAMATION); 
		return E_FAIL;
	}

	return S_OK;

}


HRESULT CWave::ReadWSMP(IStream* pIStream, MMCKINFO* pckMain)
{
	ASSERT(pIStream);
	if(pIStream == NULL)
	{
		return E_POINTER;
	}

	ASSERT(pckMain);
	if(pckMain == NULL)
	{
		return E_POINTER;
	}

	DWORD cSize = sizeof(WSMPL) + sizeof(WLOOP);
	if(pckMain->cksize < (sizeof(WSMPL) + sizeof(WLOOP)))
	{
		cSize = pckMain->cksize;
	}

	DWORD cb = 0;
	HRESULT hr = pIStream->Read(&m_rWSMP, cSize, &cb);
	if(FAILED(hr) || cb != cSize)
	{
		return E_FAIL;
	}

	return S_OK;
}



HRESULT CWave::ReadSMPL(IStream* pIStream, MMCKINFO* pckMain)
{
	ASSERT(pIStream);
	if(pIStream == NULL)
	{
		return E_POINTER;
	}

	ASSERT(pckMain);
	if(pckMain == NULL)
	{
		return E_POINTER;
	}

	DWORD cSize = (sizeof(RSMPL) + sizeof(RLOOP));
	if(pckMain->cksize < (sizeof(RSMPL) + sizeof(RLOOP)))
	{
		cSize = pckMain->cksize;
	}
    
	DWORD cb = 0;
	HRESULT hr = pIStream->Read( &m_rRSMPL, cSize, &cb );
	if(FAILED(hr) || cb != cSize)
	{
		return E_FAIL;
	}

	return S_OK;

}


HRESULT CWave::ReadDataInfo(IStream* pIStream, MMCKINFO* pckMain)
{
	ASSERT(pIStream);
	if(pIStream == NULL)
	{
		return E_POINTER;
	}

	ASSERT(pckMain);
	if(pckMain == NULL)
	{
		return E_POINTER;
	}

	// Get the data size but the wavelength calculation should happen in the 
	// derived objects depending on whether the wave is mono or multichannel
	if(m_bCompressed && m_bLoadingRuntime)
	{
		m_CompressedWavObj.dwDataSize = pckMain->cksize;
	}
	else
	{
		m_dwDataSize = pckMain->cksize;
		m_OriginalWavObj.dwDataSize = m_dwDataSize;
	}

	return S_OK;
}

HRESULT CWave::ReadData(IStream* pIStream, MMCKINFO* pckMain, DWORD dwOffset, DWORD dwLength, BYTE* pbData)
{
	ASSERT(pIStream);
	if(pIStream == NULL)
	{
		return E_POINTER;
	}

	ASSERT(pckMain);
	if(pckMain == NULL)
	{
		return E_POINTER;
	}

	ASSERT(pbData);
	if(pbData == NULL)
	{
		return E_INVALIDARG;
	}

	DWORD cb = 0;
	StreamSeek(pIStream, dwOffset, STREAM_SEEK_SET);
	HRESULT hr = pIStream->Read(pbData, dwLength, &cb);
	if(FAILED(hr) || cb != dwLength)
	{
		return E_FAIL;
	}

	return S_OK;	
}


//////////////////////////////////////////////////////////////////////
//
//	CWave::CopySMPLToWSMP()
//
//////////////////////////////////////////////////////////////////////
void CWave::CopySMPLToWSMP()
{
    DWORD dwTemp;
    m_rWSMP.usUnityNote = (USHORT) m_rRSMPL.dwMIDIUnityNote;
    dwTemp = m_rRSMPL.dwMIDIPitchFraction >> 16;
    dwTemp *= 100;
    dwTemp >>= 16;
    m_rWSMP.sFineTune = (short) dwTemp;
    m_rWSMP.cSampleLoops = m_rRSMPL.cSampleLoops;
    m_rWLOOP.ulStart = m_rRLOOP.dwStart;
    m_rWLOOP.ulLength = (m_rRLOOP.dwEnd + 1) - m_rRLOOP.dwStart;
    m_rWLOOP.ulType = m_rRLOOP.dwType;
}

//////////////////////////////////////////////////////////////////////
//
//	CWave::CopyWSMPToSMPL()
//
//////////////////////////////////////////////////////////////////////
void CWave::CopyWSMPToSMPL()
{
    long lTemp = m_rWSMP.sFineTune;
	m_rRSMPL.dwMIDIUnityNote = m_rWSMP.usUnityNote;
	
	// dwMIDIPitchFraction is always +ve
	while (lTemp < 0)
	{
		m_rRSMPL.dwMIDIUnityNote--;
		lTemp += 100;
	}
	
	while(lTemp >= 100)
	{
		m_rRSMPL.dwMIDIUnityNote++;
		lTemp -= 100;
	}

    lTemp <<= 16;
    lTemp /= 100;
    m_rRSMPL.dwMIDIPitchFraction = (DWORD) lTemp << 16;
    m_rRSMPL.cSampleLoops = m_rWSMP.cSampleLoops;
    m_rRLOOP.dwStart = m_rWLOOP.ulStart;
    m_rRLOOP.dwEnd = m_rWLOOP.ulStart + m_rWLOOP.ulLength - 1;
    m_rRLOOP.dwType = m_rWLOOP.ulType;    
}



HRESULT CWave::PromptForSaveFileName(CString& sSaveFileName, CString& sSavePath)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	ASSERT(m_pWaveNode);
	if(m_pWaveNode == NULL)
		return E_FAIL;

	// Open the saveas dialog
	HRESULT		hr = S_OK;
    CHAR szFilter[30] = "Wave Files (*.wav)|*.wav||";
    CFileDialog FileDlg(FALSE, "WAV", GetName().GetBuffer(0), OFN_HIDEREADONLY|OFN_OVERWRITEPROMPT, szFilter, NULL);

    if (FileDlg.DoModal() == IDOK)
    {
        sSaveFileName = FileDlg.GetFileName();
		sSavePath = FileDlg.GetPathName();
		return S_OK;
	}

	return E_FAIL;
}

HRESULT CWave::SaveAs(IStream* pIStream, bool bPromptForFileName)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	ASSERT(m_pWaveNode);
	if(m_pWaveNode == NULL)
		return E_FAIL;

	// We need to get a stream for a file if the passed stream is NULL
	if(pIStream == NULL && bPromptForFileName == false)
	{
		return E_FAIL;
	}
	
	// We don't need to prompt for a filename if a valid stream is passed 
	if(pIStream && bPromptForFileName)
	{
		return E_FAIL;
	}


	CDLSComponent* pComponent = m_pWaveNode->GetComponent();
	ASSERT(pComponent);
	if(pComponent == NULL)
		return E_FAIL;

	IDMUSProdFramework* pIFramework = pComponent->m_pIFramework;
	if(pIFramework == NULL)
		return E_FAIL;


	HRESULT hr = E_FAIL;
	CString sSavePath = "";

	if(bPromptForFileName)
	{
		// Open the saveas dialog
		CString sSaveFileName = "";
		if(SUCCEEDED(PromptForSaveFileName(sSaveFileName, sSavePath)))
		{
			hr = AllocStreamToFile(&pIStream, sSaveFileName.GetBuffer(0), 0);
			sSaveFileName.ReleaseBuffer();
		}
		else
		{
			return hr;
		}
	}

	if(pIStream)
	{
		// Save out the current wave as a .wav file on disk.
		// Turn of compression flag for save. We will always
		// save compressed if it is compressed.
		bool bNeedToSetCompression = false;

		if(SUCCEEDED(hr = SaveAs(pIStream)))
		{
			if(!sSavePath.IsEmpty())
			{
				// Release the stream so it may be used again.
				if(bPromptForFileName && pIStream)
				{
					pIStream->Release();
				}

				BSTR bstrFileName = sSavePath.AllocSysString();
				pIFramework->ShowFile(bstrFileName);
			}
		}
		
		if(bNeedToSetCompression)
			m_bCompressed = true;

	}

	return hr;
}

HRESULT CWave::SaveAs(IStream* pIStream)
{
	ASSERT(pIStream);
	if(pIStream == NULL)
		return E_POINTER;

	HRESULT hr = E_FAIL;

	if(pIStream)
	{
		hr = Save(pIStream, FALSE);
	}
	
	return hr;
}


HRESULT CWave::WriteDataToStream(IStream* pIStream, DWORD dwStartSample, DWORD dwLength, DWORD& dwSamplesWritten)
{
	ASSERT(pIStream);
	if(pIStream == NULL)
	{
		return E_POINTER;
	}

	UINT nSampleSize = m_rWaveformat.wBitsPerSample / 8;
	UINT nChannels = m_rWaveformat.nChannels;
		
	// The data range could be huge so we need to do this in chunks of 4K
	DWORD dwChunkSize = 4096;	
	dwSamplesWritten = 0;
	DWORD dwChunkStart = dwStartSample;
	DWORD dwSamplesToWrite = dwLength;
	DWORD dwBytesWritten = 0;

	while((int)dwSamplesToWrite > 0)
	{
		BYTE* pbData = NULL;
		DWORD cbRead = 0;
		if(FAILED(GetData(dwChunkStart, dwSamplesToWrite, &pbData, cbRead)))
		{
			return E_FAIL;
		}
		
		// Write it to IStream
		DWORD cbWritten = 0;
		HRESULT hr = pIStream->Write((LPSTR)pbData, cbRead, &cbWritten);
		if(FAILED(hr) || cbWritten != cbRead)
		{
			delete[] pbData;
			return E_FAIL;
		}

		delete[] pbData;
		dwSamplesWritten += cbWritten / nSampleSize / nChannels;
		dwSamplesToWrite -= dwSamplesWritten;
		dwChunkStart += dwSamplesWritten;
		dwBytesWritten += cbWritten;
	}

	return S_OK;
}

void CWave::SetName(CString sName)
{
	LONG cChannels = GetChannelCount();
	LONG iChannel;

	// set name of wave and all channels
	m_Info.m_csName = sName;
	if (cChannels > 1)
		for (iChannel = 0; iChannel < cChannels; iChannel++)
			GetChannel(iChannel)->m_Info.m_csName = sName;

	// update the instrument and instrument editor if we're in a collection
	if(m_pCollection)
	{
		CCollectionInstruments* plstInstruments = m_pCollection->GetInstruments();
		CInstrument* pInstrument = plstInstruments->GetHead();
		while (pInstrument) // for all instruments go thru all regions
		{
			CInstrumentRegions* plstRegions = pInstrument->GetRegions();
			CRegion* pRegion = plstRegions->GetHead();
			while (pRegion)
			{
				if (IsReferencedBy(pRegion->m_pWave))
					{
					pInstrument->RefreshUI(true);
					break; // no need to go over other regions, we updated the whole instrument
					}
				
				pRegion = pRegion->GetNext();
			}
			pInstrument = pInstrument->GetNext();
		}
	}

	ASSERT(m_pWaveNode);
	CDLSComponent* pComponent = m_pWaveNode->GetComponent();
	ASSERT(pComponent);
	IDMUSProdFramework* pIFramework = pComponent->m_pIFramework;

	// update the property page if it's showing
	if(m_pWavePropPgMgr)
	{
		IDMUSProdPropSheet* pIPropSheet;
		if(SUCCEEDED(pIFramework->QueryInterface(IID_IDMUSProdPropSheet, (void**)&pIPropSheet)))
		{
			if(pIPropSheet->IsShowing() == S_OK && pIPropSheet->IsEqualPageManagerObject(this) == S_OK)
			{
				m_pWavePropPgMgr->SetObject(this);
			}
			RELEASE(pIPropSheet);
		}
	}
}


void CWave::RefreshPropertyPage()
{
	ASSERT(m_pWaveNode);
	CDLSComponent* pComponent = m_pWaveNode->GetComponent();
	ASSERT(pComponent);

	IDMUSProdPropSheet* pIPropSheet = NULL;

	if(SUCCEEDED(pComponent->m_pIFramework->QueryInterface(IID_IDMUSProdPropSheet, (void**)&pIPropSheet)))
	{
		if(pIPropSheet->IsShowing() == S_OK && pIPropSheet->IsEqualPageManagerObject(this) == S_OK)
		{
			// Change the wave property page if it's up.
			if (m_pWavePropPgMgr)
				m_pWavePropPgMgr->RefreshData();
			
			// Update the loop points for the popertypage
			CWavePropPg* pWavePropPg = m_pWavePropPgMgr->m_pWavePage;
			CWaveInfoPropPg* pWaveInfoPropPg = m_pWavePropPgMgr->m_pWaveInfoPage;
			CWaveCompressionPropPage* pWaveCompressionPropPg = m_pWavePropPgMgr->m_pWaveCompressionPage;

			DWORD dwLastSelPage = m_pWavePropPgMgr->dwLastSelPage;

			if(dwLastSelPage == WAVE_PROP_PAGE)
				pWavePropPg->InitializeDialogValues();
			else if(dwLastSelPage == WAVE_INFO_PAGE)
				pWaveInfoPropPg->InitializeDialogValues();
			else if(dwLastSelPage == WAVE_COMPRESSION_PAGE)
				pWaveCompressionPropPg->InitializeDialogValues();
		}
		
		RELEASE(pIPropSheet);
	}
	
}

void CWave::Replace()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT(m_pWaveNode);
	if(m_pWaveNode == NULL)
		return;

	m_pWaveNode->Stop( TRUE );

	if(m_pCollection != NULL)
		{
		// replace in a DLS collection

		// Put up a file open dilaog.
		CString sFileName;
		CHAR szFilter[39] = "Wave Files (*.wav;*.wvp)|*.wav;*.wvp||";
		CFileDialog fileDlg(TRUE, "WAV", NULL, OFN_FILEMUSTEXIST | OFN_ENABLESIZING , szFilter, NULL);
		
		if(fileDlg.DoModal() == IDOK)
			{
			sFileName = fileDlg.GetFileName();
			if(sFileName.IsEmpty())
				return;

			m_pCollection->m_Waves.ReplaceWave(m_pWaveNode, sFileName);
			}
		}
	else
		{
		// replace outside of a DLS collection
		IDMUSProdDocType*	pIDocType;
		IDMUSProdNode*		pINewWaveNode;

		// get framework
		IDMUSProdFramework* pIFramework = theApp.m_pFramework;
		if (pIFramework == NULL)
			{
			ASSERT(FALSE); // no framework
			return;
			}

		// Get DocType for DLS collections
		if (FAILED(pIFramework->FindDocTypeByNodeId(GUID_WaveNode, &pIDocType)))
			return;

		// load File Open dialog prompt
		CString strOpenDlgTitle;
		strOpenDlgTitle.LoadString( IDS_FILE_OPEN_ANY_WAVE );

		// Display File open dialog
		if( pIFramework->OpenFile(pIDocType, strOpenDlgTitle.AllocSysString(), m_pWaveNode, &pINewWaveNode) != S_OK )
			{
			// Did not open a file, or opened file other than wave file
			if( pINewWaveNode )
				pINewWaveNode->Release();
			return;
			}

		if (pIDocType)
			pIDocType->Release();

		// update all references to point to the new file
		pIFramework->NotifyNodes(m_pWaveNode, FRAMEWORK_FileReplaced, pINewWaveNode);

		// tree is now holding on to new node
		pINewWaveNode->Release();
					
		// delete the old file
		m_pWaveNode->DeleteNode(FALSE);
		}
}

CString CWave::GetName()
{
	return m_Info.m_csName;
}


void CWave::SetCollection(CCollection* pCollection)
{
	// We don't check for the validity of the pointer 
	// because we might want to set the collection to NULL
	m_pCollection = pCollection;
}

CCollection* CWave::GetCollection() const
{
	return m_pCollection;
}


BOOL CWave::WaveIsPlaying()
{
	return m_bIsPlaying;
}


CWaveNode* CWave::GetNode() const
{
	return m_pWaveNode;
}

CWaveCtrl* CWave::GetWaveEditor() const
{
	ASSERT(m_pWaveNode);
	if(m_pWaveNode == NULL)
		return NULL;

	return m_pWaveNode->GetWaveEditor();
}

bool CWave::IsStereo()
{
	return m_pWaveNode->IsStereo();
}

HRESULT CWave::SafeAllocBuffer(BYTE** ppbBuffer, DWORD dwSize)
{
	BYTE* pbTemp = new BYTE[dwSize];
	if(pbTemp == NULL)
	{
		return E_OUTOFMEMORY;
	}

	ZeroMemory(pbTemp, dwSize);
	*ppbBuffer = pbTemp;

	return S_OK;
}

int CWave::GetNumberOfLoops()
{
	return m_rWSMP.cSampleLoops;
}

DWORD CWave::GetWaveLength()
{
	return m_dwWaveLength;
}

bool CWave::IsLooped()
{
	return m_bPlayLooped != 0;
}

void CWave::SetLooped(bool bLoop)
{
	m_bPlayLooped = bLoop;
}

WSMPL CWave::GetWSMPL()
{
	return m_rWSMP;
}

WLOOP CWave::GetWLOOP()
{
	return m_rWLOOP;
}

RSMPL CWave::GetRSMPL()
{
	return m_rRSMPL;
}

RLOOP CWave::GetRLOOP()
{
	return m_rRLOOP;
}

void CWave::SetWSMPL(WSMPL& newWSMPL)
{
	CopyMemory(&m_rWSMP, &newWSMPL, sizeof(WSMPL));
	
	// Always keep RSMPL in sync with WSMPL
	CopyWSMPToSMPL();
}


void CWave::SetWLOOP(WLOOP& newWLOOP)
{
	CopyMemory(&m_rWLOOP, &newWLOOP, sizeof(WLOOP));

	// Always keep WLOOP and RLOOP in sync
	m_rRLOOP.dwStart = m_rWLOOP.ulStart;
    m_rRLOOP.dwEnd = m_rWLOOP.ulStart + m_rWLOOP.ulLength - 1;
    m_rRLOOP.dwType = m_rWLOOP.ulType;    
}


void CWave::SetRSMPL(RSMPL& newRSMPL)
{
	CopyMemory(&m_rRSMPL, &newRSMPL, sizeof(RSMPL));
}


void CWave::SetRLOOP(RLOOP& newRLOOP)
{
	CopyMemory(&m_rRLOOP, &newRLOOP, sizeof(RLOOP));
}


DWORD CWave::GetDataSize()
{
	return m_dwDataSize;
}


HRESULT CWave::SetLoop(DWORD dwStart, DWORD dwEnd)
{
    // The synth deals with the WSMPL and WLOOP values
    // But we want to save the smpl values also
	WSMPL waveWSMPL = GetWSMPL();
	WLOOP waveLoop = GetWLOOP();
	RSMPL waveRSMPL = GetRSMPL();
	RLOOP waveRLoop = GetRLOOP();

    waveWSMPL.cSampleLoops = 1;
    
	waveLoop.ulStart = dwStart;
    waveLoop.ulLength = (dwEnd + 1) - dwStart;

    waveRSMPL.cSampleLoops = 1;
    waveRLoop.dwStart = (DWORD)dwStart;
    waveRLoop.dwEnd = (DWORD)dwEnd;
	
	m_bPlayLooped = true;

	SetWSMPL(waveWSMPL);
	SetWLOOP(waveLoop);
	SetRSMPL(waveRSMPL);
	SetRLOOP(waveRLoop);
	
	// Set the compressed loop points also
	RememberLoopAfterCompression();

	if(FAILED(UpdateWave()))
	{
		return E_FAIL;
	}

	UpdateLoopInRegions();
    UpdateDummyInstrument();

	SetDirtyFlag();

	return S_OK;
}

WAVEFORMATEX* CWave::CopyWaveFormat(const WAVEFORMATEX* pwfxSrc, bool bCompress)
{
	ASSERT(pwfxSrc);
	if(pwfxSrc == NULL)
		return NULL;

	DWORD dwSrcExtraBytes = 0;

#ifdef MSAUDIO
	if(pwfxSrc->wFormatTag == WMAUDIO_FORMAT_TAG || pwfxSrc->wFormatTag == MSAUDIO_FORMAT_TAG)
	{
		dwSrcExtraBytes = sizeof(MSAUDIO_KEY);
	}
#endif
	
	// Make copies of the original formats
	WAVEFORMATEX* pwfxSrcCopy = (WAVEFORMATEX*) new BYTE[sizeof(WAVEFORMATEX) + pwfxSrc->cbSize + dwSrcExtraBytes];
	// Out of memory?
	if(pwfxSrcCopy == NULL)
		return NULL;

	ZeroMemory(pwfxSrcCopy, sizeof(WAVEFORMATEX) + pwfxSrc->cbSize);

	CopyMemory(pwfxSrcCopy, pwfxSrc, sizeof(WAVEFORMATEX) + pwfxSrc->cbSize);

#ifdef MSAUDIO
	if(pwfxSrcCopy->wFormatTag == WMAUDIO_FORMAT_TAG || pwfxSrcCopy->wFormatTag == MSAUDIO_FORMAT_TAG)
	{
		if(bCompress)
			strcpy((char*)(pwfxSrcCopy) + pwfxSrcCopy->cbSize + sizeof(WAVEFORMATEX), MSAUDIO_KEY);
		else
			strcpy((char*)(pwfxSrcCopy) + pwfxSrcCopy->cbSize + sizeof(WAVEFORMATEX), MSAUDIO_DEC_KEY);

		// Ummm...both keys have the same size
		pwfxSrcCopy->cbSize += sizeof(MSAUDIO_KEY);
	}
#endif

	return pwfxSrcCopy;
}


HRESULT CWave::CopyWaveObject(const DMUSP_WAVEOBJECT* pSrcWaveObject, DMUSP_WAVEOBJECT*  pDstWaveObject, DWORD dwDataBufferSize)
{
	ASSERT(pSrcWaveObject);
	if(pSrcWaveObject == NULL)
		return E_FAIL;

	ASSERT(pDstWaveObject);
	if(pDstWaveObject == NULL)
		return E_FAIL;

	if(dwDataBufferSize == 0xFFFFFFFF)
		dwDataBufferSize = pSrcWaveObject->dwDataSize;
	
	CopyMemory(&(pDstWaveObject->WaveFormatEx), &(pSrcWaveObject->WaveFormatEx), sizeof(WAVEFORMATEX));
	
	if(pSrcWaveObject->WaveFormatEx.cbSize && pSrcWaveObject->pbExtractWaveFormatData)
	{
		pDstWaveObject->pbExtractWaveFormatData = new BYTE[pSrcWaveObject->WaveFormatEx.cbSize];
		
		// Out of memory??
		if(pDstWaveObject->pbExtractWaveFormatData == NULL)
		{
			return E_FAIL;
		}
			
		ZeroMemory(((BYTE*)pDstWaveObject->pbExtractWaveFormatData), pSrcWaveObject->WaveFormatEx.cbSize);
		CopyMemory(((BYTE*)pDstWaveObject->pbExtractWaveFormatData), ((BYTE*)pSrcWaveObject->pbExtractWaveFormatData), pSrcWaveObject->WaveFormatEx.cbSize);
	}

	if(pSrcWaveObject->pbData != NULL)
	{
		pDstWaveObject->pbData = new BYTE[dwDataBufferSize];
		
		// Out of memory??
		if(pDstWaveObject->pbData == NULL)
		{
			if(pDstWaveObject->pbExtractWaveFormatData)
				delete[] pDstWaveObject->pbExtractWaveFormatData;

			return E_FAIL;
		}

		ZeroMemory(((BYTE*)pDstWaveObject->pbData), dwDataBufferSize);
		CopyMemory(((BYTE*)pDstWaveObject->pbData), ((BYTE*)pSrcWaveObject->pbData), pSrcWaveObject->dwDataSize);

		pDstWaveObject->dwDataSize = dwDataBufferSize;
	}
	else
	{
		pDstWaveObject->pbData = NULL;
		pDstWaveObject->dwDataSize = 0;
	}

	return S_OK;
}

// Deletes the buffers allocated in the WaveObject
void CWave::DeleteWaveObjectBuffers(DMUSP_WAVEOBJECT* pWaveObject)
{
	ASSERT(pWaveObject);
	if(pWaveObject)
	{
		if(pWaveObject->pbData)
		{
			delete[] pWaveObject->pbData;
			pWaveObject->pbData = NULL;
		}
		
		if(pWaveObject->pbExtractWaveFormatData)
		{
			delete[] pWaveObject->pbExtractWaveFormatData;
			pWaveObject->pbExtractWaveFormatData = NULL;
		}
	}
}


void CWave::CleanWaveObject(DMUSP_WAVEOBJECT* pWaveObject)
{
	if(pWaveObject)
	{
		DeleteWaveObjectBuffers(pWaveObject);
		ZeroMemory(pWaveObject, sizeof(DMUSP_WAVEOBJECT));
	}
}


bool CWave::IsUnityNoteAndFractionSame(const RSMPL& rsmpl, short sUnityNote, short sFineTune)
{
    long lTemp = sFineTune;
	DWORD dwMIDIUnityNote = sUnityNote;
	
	// dwMIDIPitchFraction is always +ve
	while (lTemp < 0)
	{
		dwMIDIUnityNote--;
		lTemp += 100;
	}
	
	while(lTemp >= 100)
	{
		dwMIDIUnityNote++;
		lTemp -= 100;
	}

    lTemp <<= 16;
    lTemp /= 100;
    DWORD dwMIDIPitchFraction = (DWORD) lTemp << 16;

	if(rsmpl.dwMIDIUnityNote == dwMIDIUnityNote && rsmpl.dwMIDIPitchFraction == dwMIDIPitchFraction)
		return true;
	else
		return false;
}



// This code was partly lifted and modified from the WMAudio encoder app source...
HRESULT CWave::CalculateConversionSteps(const WAVEFORMATEX* pwfxSrc, const WAVEFORMATEX* pwfxDst, bool bEncode)
{

	ASSERT(pwfxSrc);
	ASSERT(pwfxDst);

	MMRESULT mmr = ACMERR_NOTPOSSIBLE;
	HRESULT hr = E_FAIL;

	// Clean up the previous objects if any left
	while(m_arrIntermediateFormats.GetSize() > 0)
	{
		delete[] m_arrIntermediateFormats[0];
		m_arrIntermediateFormats.RemoveAt(0);
	}

	// Make copies of the original formats
	WAVEFORMATEX* pwfxSrcCopy = CopyWaveFormat(pwfxSrc, bEncode);
	if(pwfxSrcCopy == NULL)
		return E_FAIL;

	WAVEFORMATEX* pwfxDstCopy = CopyWaveFormat(pwfxDst, bEncode);
	if(pwfxDstCopy == NULL)
		return E_FAIL;

    ///////////////////////////////////////////////////////////////////////////////////
    //  BUGBUG!! We're shorting the multistep conversion for DX8 as API can't handle it
    ///////////////////////////////////////////////////////////////////////////////////
    m_arrIntermediateFormats.Add(pwfxSrcCopy);
    m_arrIntermediateFormats.Add(pwfxDstCopy);
    return S_OK;


	// Short-cicuit the mulitstep conversion if we're dealing with the WMAudio codecs
	if((pwfxDstCopy->wFormatTag == WMAUDIO_FORMAT_TAG || pwfxDstCopy->wFormatTag == MSAUDIO_FORMAT_TAG) &&
		pwfxDstCopy->nChannels == pwfxSrcCopy->nChannels &&
		pwfxDstCopy->wBitsPerSample == pwfxSrcCopy->wBitsPerSample)
	{
		pwfxSrcCopy->nSamplesPerSec = pwfxDstCopy->nSamplesPerSec;
		pwfxSrcCopy->nAvgBytesPerSec = pwfxSrcCopy->nSamplesPerSec * pwfxSrcCopy->nBlockAlign;

		m_arrIntermediateFormats.Add(pwfxSrcCopy);
		m_arrIntermediateFormats.Add(pwfxDstCopy);
		return S_OK;
	}

	if((pwfxSrcCopy->wFormatTag == WMAUDIO_FORMAT_TAG || pwfxSrcCopy->wFormatTag == MSAUDIO_FORMAT_TAG) &&
		pwfxDstCopy->nChannels == pwfxSrcCopy->nChannels &&
		pwfxDstCopy->wBitsPerSample == pwfxSrcCopy->wBitsPerSample)
	{
		pwfxDstCopy->nSamplesPerSec = pwfxSrcCopy->nSamplesPerSec;
		pwfxDstCopy->nAvgBytesPerSec = pwfxDstCopy->nSamplesPerSec * pwfxDstCopy->nBlockAlign;

		m_arrIntermediateFormats.Add(pwfxSrcCopy);
		m_arrIntermediateFormats.Add(pwfxDstCopy);
		return S_OK;
	}

	// Determine if we have to massage the input into an intermediate form of PCM
    WAVEFORMATEX* pwfxPCM1 = (WAVEFORMATEX*) new BYTE[sizeof(WAVEFORMATEX)];
	ZeroMemory(pwfxPCM1, sizeof(WAVEFORMATEX));
    pwfxPCM1->wFormatTag = WAVE_FORMAT_PCM;

	mmr = acmFormatSuggest(NULL, pwfxSrcCopy, pwfxPCM1, sizeof(WAVEFORMATEX), ACM_FORMATSUGGESTF_WFORMATTAG);
    if(MMSYSERR_NODRIVER == mmr )
	{
		delete[] pwfxSrcCopy;
		delete[] pwfxDstCopy;
		return E_FAIL;
	}

    // Determine if the compressor can generate requested format without an intermediate step.
    WAVEFORMATEX* pwfxPCM2 = (WAVEFORMATEX*) new BYTE[sizeof(WAVEFORMATEX)];;
	ZeroMemory(pwfxPCM2, sizeof(WAVEFORMATEX));
    pwfxPCM2->wFormatTag = WAVE_FORMAT_PCM;

    mmr = acmFormatSuggest(NULL, pwfxDstCopy, pwfxPCM2, sizeof(WAVEFORMATEX), ACM_FORMATSUGGESTF_WFORMATTAG);
    if(MMSYSERR_NODRIVER == mmr )
    {
		delete[] pwfxSrcCopy;
		delete[] pwfxDstCopy;

        return E_FAIL;
    }

	// First format is the source format
	m_arrIntermediateFormats.Add(pwfxSrcCopy);

    // Figure out how many steps we need
	int nSteps = 1;

    BOOL fInputPCM  = (WAVE_FORMAT_PCM == pwfxSrc->wFormatTag);
    BOOL fOutputPCM = (WAVE_FORMAT_PCM == pwfxDst->wFormatTag);

    BOOL fOutputVox = IsVoxwareCodec(pwfxDst->wFormatTag);
    
    DWORD dwInSampRate = pwfxSrc->nSamplesPerSec;
    if( fOutputVox && pwfxSrc->nChannels == pwfxDst->nChannels &&
        dwInSampRate >= pwfxDst->nSamplesPerSec && (dwInSampRate == 8000 || dwInSampRate == 11025 ||
        dwInSampRate == 16000 || dwInSampRate == 22050 || dwInSampRate == 44100))
    {
        //
        // Voxware can convert directly from any PCM... with a few caveats:
        // 1) The number of channels must match.
        // 2) The output sample rate must be less than or equal to the input
        // sample rate
        //
        if( fInputPCM )
        {
            nSteps = 1;
        }
        else
        {
            nSteps = 2;
        }
    }
    else
    {
        // The input and output is PCM
        if( fInputPCM && fOutputPCM )
		{
            nSteps = 1;

		}
        // Input is PCM and the intermediate output PCM matches it
        else if( fInputPCM  && 0 == memcmp( pwfxSrc, pwfxPCM2, sizeof(PCMWAVEFORMAT) ) )
        {
            nSteps = 1;
        }
        
		// Output is PCM and the intermediate input PCM matches it
        else if( fOutputPCM && 0 == memcmp( pwfxDst, pwfxPCM1, sizeof(PCMWAVEFORMAT) ) )
        {
			// Convert directly from source to destination
            nSteps = 1;                   
        }
        else if( fInputPCM || fOutputPCM )
        {
			// Need one intermediate conversion
            nSteps = 2;                   
        }
        else
        {
			// Slowest conversion possible.
            nSteps = 3;                   
        }
    }

	// Correct ASSUMPTION about single step.    
    switch( nSteps )                  
    {
        case 1:                         // Assumption was correct.
		{
			if(pwfxPCM1)
				delete[] pwfxPCM1;
			
			if(pwfxPCM2)
				delete[] pwfxPCM2;
            break;
		}

        case 2:                         // Insert one intermediate step in between.
        {
			if(fInputPCM)
			{
				m_arrIntermediateFormats.Add(pwfxPCM2);
				delete[] pwfxPCM1;
			}
			else
			{
				m_arrIntermediateFormats.Add(pwfxPCM1);
				delete[] pwfxPCM2;


			}

            break;
        }

        case 3:                         // Add two intermediate step.
		{
            m_arrIntermediateFormats.Add(pwfxPCM1);  // Insert input conversion.
            m_arrIntermediateFormats.Add(pwfxPCM2);	 // Insert the output conversion
            
			break;
		}
    }

	
	// Last format is the desired destination format
	m_arrIntermediateFormats.Add(pwfxDstCopy);


    return S_OK;
}

HRESULT CWave::ConvertWave(const WAVEFORMATEX* pwfxSource, const WAVEFORMATEX* pwfxDest, BYTE* pbSource, const DWORD dwSourceSize, BYTE** ppbDest, DWORD& cbConverted)
{
	ASSERT(pwfxSource);
	if(pwfxSource == NULL)
	{
		return E_POINTER;
	}

	ASSERT(pwfxDest);
	if(pwfxDest == NULL)
	{
		return E_POINTER;
	}

	ASSERT(pbSource);
	if(pbSource == NULL)
	{
		return E_POINTER;
	}

	// Do we have anything to convert?
	if(dwSourceSize <= 0)
	{
		return E_INVALIDARG;
	}

	DMUSP_WAVEOBJECT sourceWave;
	ZeroMemory(&sourceWave, sizeof(DMUSP_WAVEOBJECT));
	sourceWave.dwDataSize = dwSourceSize;
	sourceWave.pbData = pbSource;
	CopyMemory(&sourceWave.WaveFormatEx, pwfxSource, sizeof(WAVEFORMATEX));
	if(pwfxSource->wFormatTag != 1 && pwfxSource->cbSize != 0)
	{
		if(FAILED(SafeAllocBuffer(&(sourceWave.pbExtractWaveFormatData), pwfxSource->cbSize)))
		{
			return E_OUTOFMEMORY;
		}
		CopyMemory(sourceWave.pbExtractWaveFormatData, ((BYTE*)pwfxSource) + sizeof(WAVEFORMATEX), pwfxSource->cbSize);
	}

	DMUSP_WAVEOBJECT destWave;
	ZeroMemory(&destWave, sizeof(DMUSP_WAVEOBJECT));
	
	bool bCompress = pwfxDest->wFormatTag != 1 ? true : false;

	if(FAILED(ConvertWave(sourceWave, pwfxDest, destWave, bCompress)))
	{
		if(sourceWave.pbExtractWaveFormatData)
		{
			delete[] sourceWave.pbExtractWaveFormatData;
			sourceWave.pbExtractWaveFormatData = NULL;
		}

		cbConverted = 0;
		return E_FAIL;
	}

	*ppbDest = destWave.pbData;
	cbConverted = destWave.dwDataSize;

	if(sourceWave.pbExtractWaveFormatData)
	{
		delete[] sourceWave.pbExtractWaveFormatData;
		sourceWave.pbExtractWaveFormatData = NULL;
	}
	
	if(destWave.pbExtractWaveFormatData)
	{
		delete[] destWave.pbExtractWaveFormatData;
		destWave.pbExtractWaveFormatData = NULL;
	}

	return S_OK;
}



HRESULT CWave::ConvertWave(const DMUSP_WAVEOBJECT& sourceWave, const WAVEFORMATEX* pwfxDst, DMUSP_WAVEOBJECT& convertedWaveObj, bool bCompress, DWORD dwSilenceSamples)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	ASSERT(pwfxDst);
	if(pwfxDst == NULL)
		return E_FAIL;

	// Some codecs chop off the end (like MSAudio beta V1 that does not handle the ACM_STREAMCONVERTF_END flag)
	// So we keep track of the lost bytes and append that much silence so we don't lose any real data
	DWORD dwSilenceBytes = dwSilenceSamples;
	if(sourceWave.WaveFormatEx.wBitsPerSample > 8)
		dwSilenceBytes = dwSilenceBytes * 2;

	// Used only to keep track of opened MSAudio Beta V1 driver
	bool bCloseBetaDriver = false;

	DWORD dwExtraBytes = 0;
	if(sourceWave.WaveFormatEx.wFormatTag != WAVE_FORMAT_PCM)
		dwExtraBytes = sourceWave.WaveFormatEx.cbSize;

	WAVEFORMATEX* pwfxSrc = (WAVEFORMATEX*) new BYTE[sizeof(WAVEFORMATEX) + dwExtraBytes];
	
	// Out of memory??
	if(pwfxSrc == NULL)
	{
		return E_FAIL;
	}

	ZeroMemory(pwfxSrc, sizeof(WAVEFORMATEX) + dwExtraBytes);
	CopyMemory(pwfxSrc, &(sourceWave.WaveFormatEx), sizeof(WAVEFORMATEX));
	CopyMemory(((BYTE*)pwfxSrc) + sizeof(WAVEFORMATEX), sourceWave.pbExtractWaveFormatData, dwExtraBytes);  

	DWORD cbMaxInBuffer = sourceWave.dwDataSize;
	DWORD dwInBuffer = cbMaxInBuffer + dwSilenceBytes;
	DWORD dwBlockAlign = pwfxDst->nBlockAlign;

	// Keep the original source size
	DWORD dwOriginalSrcSize = sourceWave.dwDataSize + dwSilenceBytes;

	// Get the number of intermediate formats required for the conversion to be possible
	if(FAILED(CalculateConversionSteps(pwfxSrc, pwfxDst, bCompress)))
	{
		delete[] pwfxSrc;
		return E_FAIL;
	}

	// Cleanup previous compression
	DeleteWaveObjectBuffers(&convertedWaveObj);

	// Get a temporary buffer to hold the source wave
	DMUSP_WAVEOBJECT tempSrcObject;
	ZeroMemory(&tempSrcObject, sizeof(DMUSP_WAVEOBJECT));
	
	if(FAILED(CopyWaveObject(&sourceWave, &tempSrcObject, dwInBuffer)))
	{
		delete[] pwfxSrc;
		return E_FAIL;
	}
	
	// Convert through all intermediate formats
	for(int nIndex = 0; nIndex < m_arrIntermediateFormats.GetSize() - 1; nIndex++)
	{
		// Source format
		WAVEFORMATEX* pSrcWaveFormat = (WAVEFORMATEX*)m_arrIntermediateFormats[nIndex];
		ASSERT(pSrcWaveFormat);

		// Destination format
		WAVEFORMATEX* pDstWaveFormat = (WAVEFORMATEX*)m_arrIntermediateFormats[nIndex + 1];
		ASSERT(pDstWaveFormat);

		// First time convertedWaveObj.pbData is guaranteed to be NULL
		if(nIndex != 0  && convertedWaveObj.pbData != NULL)
		{
			if(pDstWaveFormat->wFormatTag == WMAUDIO_FORMAT_TAG)
			{
				WMAUDIO2WAVEFORMAT* pWMAudio = (WMAUDIO2WAVEFORMAT*) pDstWaveFormat;
				dwBlockAlign = pWMAudio->dwSuperBlockAlign;
			}

			DWORD cbMaxInRequired = MulDiv(dwBlockAlign, pSrcWaveFormat->nAvgBytesPerSec, pDstWaveFormat->nAvgBytesPerSec);
			if(cbMaxInRequired > cbMaxInBuffer)
			{
				// We need a big buffer to hold enough input samples to create an output frame.
				dwInBuffer = cbMaxInRequired * 2;
			}
			else
			{
				dwInBuffer = convertedWaveObj.dwDataSize;
			}

			dwOriginalSrcSize = convertedWaveObj.dwDataSize;
			if(FAILED(CopyWaveObject(&convertedWaveObj, &tempSrcObject, dwInBuffer)))
			{
				return E_FAIL;
			}

			CleanWaveObject(&convertedWaveObj);
		}

		HACMDRIVER hACMDriver = NULL;

#ifdef MSAUDIO
		if(pDstWaveFormat->wFormatTag == MSAUDIO_FORMAT_TAG)
		{
			MMRESULT mmr = acmDriverOpen(&hACMDriver, m_CompressionManager.m_hMSAudioV1BetaDriverID, 0);
			if(mmr == MMSYSERR_NOERROR)
			{
				bCloseBetaDriver = true;
			}
		}
#endif MSAUDIO

		// Find the best driver for PCM format except if we're using MSAudio in which case use the beta V1 driver
		HACMSTREAM has;
		MMRESULT mmr = acmStreamOpen(&has, hACMDriver, pSrcWaveFormat, pDstWaveFormat, NULL, 0, 0, 0);

		if(mmr != MMSYSERR_NOERROR)
		{
			DeleteWaveObjectBuffers(&tempSrcObject);
			delete[] pwfxSrc;
			if(bCloseBetaDriver)
				acmDriverClose(hACMDriver, 0);
			return E_FAIL;	
		}

		// Get the size of the output buffer
		DWORD dwOutPutBytes = 0; 
		mmr = acmStreamSize(has, dwInBuffer, &dwOutPutBytes, ACM_STREAMSIZEF_SOURCE);

		if(mmr != MMSYSERR_NOERROR || dwOutPutBytes == 0)
		{
			acmStreamClose(has, 0);		
			DeleteWaveObjectBuffers(&tempSrcObject);
			delete[] pwfxSrc;
			if(bCloseBetaDriver)
				acmDriverClose(hACMDriver, 0);
			return E_FAIL;	
		}

		ACMSTREAMHEADER ashdr;
		ZeroMemory(&ashdr, sizeof(ashdr));
		ashdr.cbStruct = sizeof(ashdr);

		ashdr.pbSrc = (BYTE*) tempSrcObject.pbData;
		ashdr.cbSrcLength = dwOriginalSrcSize;

		// Add a littel extra room
		//dwOutPutBytes = dwOutPutBytes * 3 / 2;
		ashdr.cbDstLength = dwOutPutBytes;

		if(FAILED(SafeAllocBuffer(&ashdr.pbDst, dwOutPutBytes)))
		{
			acmStreamClose(has, 0);
			DeleteWaveObjectBuffers(&tempSrcObject);
			delete[] pwfxSrc;
			if(bCloseBetaDriver)
			{
				acmDriverClose(hACMDriver, 0);
			}

			return E_OUTOFMEMORY;	
		}

		BYTE* pTempOutBuffer = NULL;
		if(FAILED(SafeAllocBuffer(&pTempOutBuffer, dwOutPutBytes)))
		{
			acmStreamClose(has, 0);
			DeleteWaveObjectBuffers(&tempSrcObject);
			delete[] pwfxSrc;
			delete[] ashdr.pbDst;
			if(bCloseBetaDriver)
			{
				acmDriverClose(hACMDriver, 0);
			}

			return E_OUTOFMEMORY;	
		}

		mmr = acmStreamPrepareHeader(has, &ashdr, 0);	
		if(mmr != MMSYSERR_NOERROR || (ashdr.fdwStatus & ACMSTREAMHEADER_STATUSF_PREPARED) == 0)
		{
			acmStreamClose(has, 0);
			delete[] ashdr.pbDst;
			delete[] pTempOutBuffer;
			DeleteWaveObjectBuffers(&tempSrcObject);
			delete[] pwfxSrc;
			if(bCloseBetaDriver)
				acmDriverClose(hACMDriver, 0);
			return E_FAIL;	
		}

		// Keeps track of the length of the output buffer...
		DWORD dwDstOffset = 0;
		for (DWORD dwSrcConverted = 0; dwSrcConverted < dwOriginalSrcSize;)
		{
			ashdr.cbDstLengthUsed = 0;
			ashdr.cbSrcLengthUsed = 0;

			mmr = acmStreamConvert(has, &ashdr, ACM_STREAMCONVERTF_BLOCKALIGN );
			if(mmr != MMSYSERR_NOERROR)
			{
				break;
			}

			// See how much of the source was actually converted
			dwSrcConverted += ashdr.cbSrcLengthUsed;
			if(dwSrcConverted < tempSrcObject.dwDataSize)
				memmove(ashdr.pbSrc, ashdr.pbSrc + ashdr.cbSrcLengthUsed, tempSrcObject.dwDataSize - dwSrcConverted);
			
			ashdr.cbSrcLength = dwOriginalSrcSize - dwSrcConverted;

			if(ashdr.cbDstLengthUsed == 0)
			{
				break;
			}
			
			// Copy the converted output
			CopyMemory(pTempOutBuffer + dwDstOffset, ashdr.pbDst, ashdr.cbDstLengthUsed);
			dwDstOffset += ashdr.cbDstLengthUsed;
		}

		// CleanUp Pass
		// MSAudio V1 beta codec can not handle the ACM_STREAMCONVERTF_END flag and will crash
		while(1 && pDstWaveFormat->wFormatTag != MSAUDIO_FORMAT_TAG)
		{
			ashdr.cbSrcLengthUsed = 0;
			ashdr.cbDstLengthUsed = 0;

			mmr = acmStreamConvert(has, &ashdr, ACM_STREAMCONVERTF_BLOCKALIGN | ACM_STREAMCONVERTF_END);
			if(mmr != MMSYSERR_NOERROR)
			{
				break;
			}

			// See how much of the source was actually converted
			dwSrcConverted += ashdr.cbSrcLengthUsed;
			if(dwSrcConverted != 0 && dwSrcConverted < tempSrcObject.dwDataSize)
				memmove(ashdr.pbSrc, ashdr.pbSrc + ashdr.cbSrcLengthUsed, tempSrcObject.dwDataSize - dwSrcConverted);
			ashdr.cbSrcLength = dwOriginalSrcSize - dwSrcConverted;

			if(ashdr.cbDstLengthUsed == 0)
			{
				break;
			}
			
			// Copy the converted output
			CopyMemory(pTempOutBuffer + dwDstOffset, ashdr.pbDst, ashdr.cbDstLengthUsed);
			dwDstOffset += ashdr.cbDstLengthUsed;
		}

		// Flush...
		// MSAudio V1 beta codec can not handle the ACM_STREAMCONVERTF_END flag and will crash
		if(ashdr.cbDstLengthUsed == 0 && pDstWaveFormat->wFormatTag != MSAUDIO_FORMAT_TAG /*&& pDstWaveFormat->wFormatTag != WMAUDIO_FORMAT_TAG*/)
		{
			ashdr.cbSrcLengthUsed = 0;
			ashdr.cbDstLengthUsed = 0;

			mmr = acmStreamConvert(has, &ashdr, ACM_STREAMCONVERTF_END);
			if(mmr == MMSYSERR_NOERROR && ashdr.cbDstLengthUsed != 0)
			{
				// Copy the converted output
				CopyMemory(pTempOutBuffer + dwDstOffset, ashdr.pbDst, ashdr.cbDstLengthUsed);
				dwDstOffset += ashdr.cbDstLengthUsed;
			}
		}

		if(mmr != MMSYSERR_NOERROR)
		{
			acmStreamUnprepareHeader(has, &ashdr, 0);		
			acmStreamClose(has, 0);		

			delete [] ashdr.pbDst;
			DeleteWaveObjectBuffers(&tempSrcObject);
			delete[] pwfxSrc;
			delete[] pTempOutBuffer;
			if(bCloseBetaDriver)
			{
				acmDriverClose(hACMDriver, 0);
			}

			return E_FAIL;	
		}

		// Need to reset or acmStreamUnprepareHeader will return with an error
		ashdr.cbSrcLength = dwOriginalSrcSize;
		ashdr.cbDstLength = dwOutPutBytes;

		mmr = acmStreamUnprepareHeader(has, &ashdr, 0);
		if(mmr != MMSYSERR_NOERROR)
		{
			acmStreamClose(has, 0);		
			DeleteWaveObjectBuffers(&tempSrcObject);
			delete [] ashdr.pbDst;
			delete[] pwfxSrc;
			delete[] pTempOutBuffer;
			if(bCloseBetaDriver)
				acmDriverClose(hACMDriver, 0);
			return E_FAIL;	
		}
		
		// Close the ACM stream
		mmr = acmStreamClose(has, 0);
		
		if(mmr != MMSYSERR_NOERROR)
		{
			DeleteWaveObjectBuffers(&tempSrcObject);
			delete [] ashdr.pbDst;
			delete[] pwfxSrc;
			delete[] pTempOutBuffer;
			if(bCloseBetaDriver)
				acmDriverClose(hACMDriver, 0);
			return E_FAIL;	
		}

		CopyMemory(&(convertedWaveObj.WaveFormatEx), pDstWaveFormat, sizeof(WAVEFORMATEX));

		if(pDstWaveFormat->cbSize > 0)
		{
			DWORD dwExtraBytes = pDstWaveFormat->cbSize;
			
			// Pull out the MSAUDIO_KEY
			if(convertedWaveObj.WaveFormatEx.wFormatTag == WMAUDIO_FORMAT_TAG || convertedWaveObj.WaveFormatEx.wFormatTag == MSAUDIO_FORMAT_TAG)
			{
				dwExtraBytes = pDstWaveFormat->cbSize - sizeof(MSAUDIO_KEY);
				convertedWaveObj.WaveFormatEx.cbSize = (USHORT)dwExtraBytes;
			}

			convertedWaveObj.pbExtractWaveFormatData = new BYTE[dwExtraBytes];
			
			if(convertedWaveObj.pbExtractWaveFormatData == NULL)
			{
				DeleteWaveObjectBuffers(&tempSrcObject);
				delete[] pwfxSrc;
				if(bCloseBetaDriver)
					acmDriverClose(hACMDriver, 0);
				return E_FAIL;
			}
			else
			{
				ZeroMemory(convertedWaveObj.pbExtractWaveFormatData, dwExtraBytes);
				CopyMemory(convertedWaveObj.pbExtractWaveFormatData, (((BYTE*)pDstWaveFormat) + sizeof(WAVEFORMATEX)), dwExtraBytes);
			}
		}

		convertedWaveObj.pbData = new BYTE[dwDstOffset];

		// Out of memory??
		if(convertedWaveObj.pbData == NULL)
		{
			delete [] ashdr.pbDst;
			delete[] pTempOutBuffer;
			DeleteWaveObjectBuffers(&tempSrcObject);
			if(bCloseBetaDriver)
				acmDriverClose(hACMDriver, 0);

			return E_FAIL;
		}
		
		ZeroMemory(convertedWaveObj.pbData, dwDstOffset);
		CopyMemory(convertedWaveObj.pbData, pTempOutBuffer, dwDstOffset);
		convertedWaveObj.dwDataSize = dwDstOffset;
		
		delete [] ashdr.pbDst;
		delete[] pTempOutBuffer;
		DeleteWaveObjectBuffers(&tempSrcObject);
		if(bCloseBetaDriver)
			acmDriverClose(hACMDriver, 0);
	}
 
	// If we're decompressing MSAudio file then compute how many
	// silent samples in the beginning we need to throw away....
	if(!bCompress && pwfxSrc->wFormatTag == WMAUDIO_FORMAT_TAG)
	{
		// V1
		int nVersion = 1;
		if(pwfxSrc->wFormatTag == WMAUDIO_FORMAT_TAG)
			nVersion = 2;	// V2
		
		int	nSamplesPerSec = pwfxSrc->nSamplesPerSec;
		DWORD dwBitPerSec = pwfxSrc->nSamplesPerSec * pwfxSrc->wBitsPerSample;
		int nNumChannels = pwfxSrc->nChannels;
		
		int nActualSamples = msaudioGetSamplePerFrame(nSamplesPerSec, dwBitPerSec, nNumChannels, nVersion);
		if(pwfxSrc->wBitsPerSample == 16)
			nActualSamples *= 2;

		if((int)convertedWaveObj.dwDataSize > nActualSamples)
		{
			DWORD dwActualDataSize = convertedWaveObj.dwDataSize - nActualSamples;
			BYTE* pTempBuffer = new BYTE[dwActualDataSize];
			if(pTempBuffer)
			{
				ZeroMemory(pTempBuffer, dwActualDataSize);
				CopyMemory(pTempBuffer, convertedWaveObj.pbData + nActualSamples, dwActualDataSize);
				delete[] convertedWaveObj.pbData;
				convertedWaveObj.pbData = pTempBuffer;
				convertedWaveObj.dwDataSize = dwActualDataSize;
			}
		}
	}

	// Reset the waveformat values we changed if we're decompressing and the format is PCM
	if(bCompress == false && convertedWaveObj.WaveFormatEx.wFormatTag == 1)
	{
		convertedWaveObj.WaveFormatEx.nSamplesPerSec = pwfxDst->nSamplesPerSec;
		convertedWaveObj.WaveFormatEx.nAvgBytesPerSec = convertedWaveObj.WaveFormatEx.nSamplesPerSec * convertedWaveObj.WaveFormatEx.nBlockAlign;
	}

	delete[] pwfxSrc;
	return S_OK;
}


// If there's a difference between the decompressed and the original 
// append silence equivalent to that difference and compress again
HRESULT CWave::FindSampleLoss(const WAVEFORMATEX* pwfxDest, DWORD& dwDifference)
{
	HRESULT hr = E_FAIL;
	ASSERT(pwfxDest);
	if(pwfxDest == NULL)
		return E_FAIL;

	// What is the original wave's length?
	DWORD dwOldWaveLength = m_OriginalWavObj.dwDataSize;
	if(m_OriginalWavObj.WaveFormatEx.wBitsPerSample != 8)
		dwOldWaveLength = m_OriginalWavObj.dwDataSize >> 1;
	
	DMUSP_WAVEOBJECT tempCompressedWaveObject;
	DMUSP_WAVEOBJECT tempDeCompressedWaveObject;

	ZeroMemory(&(tempCompressedWaveObject), sizeof(DMUSP_WAVEOBJECT));
	ZeroMemory(&(tempDeCompressedWaveObject), sizeof(DMUSP_WAVEOBJECT));

	// Compress the wave and if it succeeds...
	if(SUCCEEDED(ConvertWave(m_OriginalWavObj, pwfxDest, tempCompressedWaveObject, true)))
	{
		// ...decompress the wave
		if(FAILED(ConvertWave(tempCompressedWaveObject, &(m_rWaveformat), tempDeCompressedWaveObject, false)))
		{
			CleanWaveObject(&tempCompressedWaveObject);
			return E_FAIL;
		}
		// Then find out the difference in wavelengths
		// and append the silence...
		DWORD dwNewWaveLength = tempDeCompressedWaveObject.dwDataSize;
		if(tempDeCompressedWaveObject.WaveFormatEx.wBitsPerSample != 8)
			dwNewWaveLength = tempDeCompressedWaveObject.dwDataSize >> 1;

		dwDifference = abs(dwOldWaveLength - dwNewWaveLength);

		CleanWaveObject(&tempCompressedWaveObject);
		CleanWaveObject(&tempDeCompressedWaveObject);

		hr = S_OK;
	}

	return hr;
}


// Copied from MSAUDIO.CPP
int CWave::msaudioGetSamplePerFrame(int cSamplePerSec, DWORD dwBitPerSec, int cNumChannels, int nVersion)
{
	// return NEW samples coming into a frame; actual samples in a frame
	// should be * 2 due to 50% overlapping window
	int cSamplePerFrame;
    if (cSamplePerSec <= 8000) 
	{
        cSamplePerFrame = 512;
    }
    else if (cSamplePerSec <= 11025)
        cSamplePerFrame = 512;
    else if (cSamplePerSec <= 16000)
        cSamplePerFrame = 512;
    else if (cSamplePerSec <= 22050)
        cSamplePerFrame = 1024;
    else if (cSamplePerSec <= 32000)
	{
		if(nVersion == 1)
			cSamplePerFrame = 1024;
		else
			cSamplePerFrame = 2048;
	}
    else if (cSamplePerSec <= 44100)
        cSamplePerFrame = 2048;
    else if (cSamplePerSec <= 48000)
        cSamplePerFrame = 2048;
    else
        return 0;
    WORD wBytesPerFrame = WORD(((cSamplePerFrame*dwBitPerSec + cSamplePerSec/2)/cSamplePerSec + 7)/8);
    if (wBytesPerFrame <= 1) 
	{   // silence mode
        while (wBytesPerFrame == 0) 
		{
            cSamplePerFrame *= 2;           // save more bits; quartz can't take too big a value
            wBytesPerFrame = WORD(((cSamplePerFrame*dwBitPerSec + cSamplePerSec/2)/cSamplePerSec + 7)/8);
        }
    }
    return cSamplePerFrame;
}

int CWave::GetTimePlayed()
{
	return m_nTimePlayed;
}

CWaveDataManager* CWave::GetDataManager()
{
	return m_pDataManager;
}

HRESULT CWave::GetData(DWORD dwStartSample, DWORD dwLength, BYTE** ppbData, DWORD& dwBytesRead, bool bGetUncompressedOnly)
{
	dwBytesRead = 0;

	ASSERT(m_pDataManager);
	if(m_pDataManager == NULL)
	{
		return E_FAIL;
	}

	if(dwLength == 0)
	{
		dwBytesRead = 0;
		return S_OK;
	}

	int nSampleSize = m_rWaveformat.wBitsPerSample / 8;
	int nChannels = m_rWaveformat.nChannels;
   
    if(bGetUncompressedOnly)
    {
        nSampleSize = m_OriginalWavObj.WaveFormatEx.wBitsPerSample / 8;
        nChannels = m_OriginalWavObj.WaveFormatEx.nChannels;
    }

    DWORD dwBufferSize = dwLength * nSampleSize * nChannels;

	if(FAILED(SafeAllocBuffer(ppbData, dwBufferSize)))
	{
		return E_FAIL;
	}

	EnterCriticalSection(&m_pWaveNode->m_CriticalSection);
	if(FAILED(m_pDataManager->GetData(dwStartSample, dwLength, *ppbData, dwBytesRead, bGetUncompressedOnly)))
	{
		LeaveCriticalSection(&m_pWaveNode->m_CriticalSection);
		delete[] *ppbData;
		dwBytesRead = 0;
		return E_FAIL;
	}

	LeaveCriticalSection(&m_pWaveNode->m_CriticalSection);
	return S_OK;
}


HRESULT CWave::GetAllUncompressedData(BYTE** ppbData, DWORD* pdwSize)
{
    ASSERT(pdwSize);
    if(pdwSize == NULL)
    {
        return E_POINTER;
    }

	ASSERT(m_pDataManager);
	if(m_pDataManager == NULL)
	{
		return E_FAIL;
	}

	EnterCriticalSection(&m_pWaveNode->m_CriticalSection);
	if(FAILED(m_pDataManager->GetAllUncompressedData(ppbData, pdwSize)))
	{
		LeaveCriticalSection(&m_pWaveNode->m_CriticalSection);
		*pdwSize = 0;
		return E_FAIL;
	}

	LeaveCriticalSection(&m_pWaveNode->m_CriticalSection);
	return S_OK;

}

HRESULT CWave::WriteDataToClipboard(IStream* pIStream, DWORD dwStartSample, DWORD dwClipLength)
{
	ASSERT(pIStream);
	if(pIStream == NULL)
	{
		return E_POINTER;
	}

	IDMUSProdRIFFStream* pIRiffStream = NULL;
	HRESULT hr = AllocRIFFStream( pIStream, &pIRiffStream );
	if(FAILED(hr))
	{
		pIStream->Release();
		return hr;
	}
	
	// Create wave riff header
	MMCKINFO ckMain;
	ckMain.fccType = mmioFOURCC('W','A','V','E');
	hr = pIRiffStream->CreateChunk(&ckMain, MMIO_CREATERIFF);
	if(FAILED(hr))
	{
		return E_FAIL;
	}


	MMCKINFO ck;
	DWORD cb = 0;

	// Create format chunk
	ck.ckid = mmioFOURCC('f','m','t',' ');
	hr = pIRiffStream->CreateChunk(&ck, 0);
	if(FAILED(hr))
	{
		pIRiffStream->Release();
		return E_FAIL;
	}

	hr = pIStream->Write((LPSTR) &(m_rWaveformat), sizeof(WAVEFORMATEX), &cb);	
	if (FAILED(hr) || cb != sizeof(WAVEFORMATEX))
	{
		pIRiffStream->Release();
		return E_FAIL;
	}
	
	if (FAILED(pIRiffStream->Ascend(&ck, 0)))
	{
		pIRiffStream->Release();
		return E_FAIL;
	}

	
	// Save data
	ck.ckid = mmioFOURCC('d','a','t','a') ;
	hr = pIRiffStream->CreateChunk(&ck,0);
	if(FAILED(hr))
	{
		pIRiffStream->Release();
		return E_FAIL;
	}

	BYTE* pbData = NULL;
	DWORD dwDataSize = 0;
	if(FAILED(GetData(dwStartSample, dwClipLength, &pbData, dwDataSize)))
	{
		return E_OUTOFMEMORY;
	}

	if(FAILED(pIStream->Write((LPSTR) pbData, dwDataSize, &cb)))	
	{
		delete[] pbData;
		return E_FAIL;
	}

	delete[] pbData;

	hr = pIRiffStream->Ascend(&ck, 0);
	if(FAILED(hr))
	{
		pIRiffStream->Release();
		return E_FAIL;
	}

	pIRiffStream->Ascend(&ckMain, 0);
	pIRiffStream->Release();

	return S_OK;
}


HRESULT CWave::ReadDataFromClipbaord(IStream* pIStream, WAVEFORMATEX& wfxClipFormat, BYTE** ppbData, DWORD& dwDataSize)
{
	ASSERT(pIStream);
	if(pIStream == NULL)
	{
		return E_POINTER;
	}

	IDMUSProdRIFFStream* pIRiffStream = NULL;
	if (FAILED(AllocRIFFStream(pIStream, &pIRiffStream)))
	{
		return E_FAIL;
	}


	// Seek to beginning of stream
	LARGE_INTEGER liTemp;
	liTemp.QuadPart = 0;
	pIStream->Seek(liTemp, STREAM_SEEK_SET, NULL);

	ZeroMemory(&wfxClipFormat, sizeof(WAVEFORMATEX));

	dwDataSize = 0;

	MMCKINFO ckMain;
	MMCKINFO ck;
	ckMain.fccType = mmioFOURCC('W','A','V','E') ;
	if(pIRiffStream->Descend( &ckMain, NULL, MMIO_FINDRIFF ) == 0 )
	{
		bool bReadFormat = false;

		DWORD cb = 0;
		ck.ckid = 0;
		ck.fccType = 0;
		while( pIRiffStream->Descend(&ck, &ckMain, 0) == 0)
		{
			switch (ck.ckid) 
			{
				case mmioFOURCC('f','m','t',' '):
				{
					DWORD dwReadSize = 0;
					bReadFormat = TRUE;
					if(ck.cksize < sizeof(WAVEFORMATEX))
					{
						dwReadSize = ck.cksize;
					}
					else
					{
						dwReadSize = sizeof(WAVEFORMATEX);
					}

					HRESULT hr = pIStream->Read(&wfxClipFormat, dwReadSize, &cb);
					if(FAILED(hr) || cb != dwReadSize)
					{
						pIRiffStream->Release();
						return E_FAIL;
					}
					
					if(wfxClipFormat.wFormatTag != WAVE_FORMAT_PCM)
					{
						pIRiffStream->Release();
						return E_FAIL;
					}

					if(wfxClipFormat.nSamplesPerSec != m_rWaveformat.nSamplesPerSec)
					{
						if (IDCANCEL == AfxMessageBox(IDS_WAVE_SAMPLE_RATE, MB_ICONEXCLAMATION | MB_OKCANCEL))
						{
							pIRiffStream->Release();
							return E_FAIL;
						}
					}
					
					break;            
				}
				
				case mmioFOURCC('d','a','t','a'):
				{
					if (bReadFormat)
					{
						if(FAILED(SafeAllocBuffer(ppbData, ck.cksize)))
						{
							return E_OUTOFMEMORY;
						}
						
						if(*ppbData != NULL)
						{
							HRESULT hr = pIStream->Read(*ppbData, ck.cksize, &cb );
							if(FAILED(hr) || cb != ck.cksize)
							{
								delete[] *ppbData;
								pIRiffStream->Release();
								return E_FAIL;
							}

							dwDataSize = ck.cksize;

							// Use files less than 1M
							/*if(dwDataSize >= (1 << 20))    
							{
								AfxMessageBox(IDS_WAVE_OVER_ONE_MEG, MB_ICONEXCLAMATION);
								delete[] *ppbData;
								pIRiffStream->Release();
								return E_FAIL;
							}*/
						}
						else
						{
							// Out Of Memory!!
							pIRiffStream->Release();
							return E_OUTOFMEMORY;
						}
					}
					else 
					{
						// Format must come first in a wave RIFF file
						pIRiffStream->Release();
						return E_FAIL;
					}
					
					break;
				}

				default:
					break;
			}

			if (ck.cksize == 0)
				break;

			pIRiffStream->Ascend( &ck, 0 );
			ck.ckid = 0;
			ck.fccType = 0;
		}
	}
	else
	{
		return E_FAIL;
	}
	
	pIRiffStream->Release();
	return S_OK;
}

HRESULT CWave::Fade(bool bFadeDirection, DWORD dwStart, DWORD dwEnd)
{
	int nSelectedSamples = abs(dwEnd - dwStart);
	int nBytesPerSample = 1;
	if(m_rWaveformat.wBitsPerSample > 8)
	{
		nBytesPerSample = m_rWaveformat.wBitsPerSample / 8;
	}

	int nChannels = m_rWaveformat.nChannels;

	BYTE* pbData = NULL;
	DWORD cb = 0;
	if(FAILED(GetData(dwStart, nSelectedSamples, &pbData, cb)))
	{
		return E_FAIL;
	}

	// If this is a stereo wave then the actual number of samples is doubled
	// But we still want to calculate the fade factor on the passed length..
	int nSelectionLength = nSelectedSamples * nChannels;

	for(int nSampleCount = 0; nSampleCount <= nSelectionLength; nSampleCount++)
	{
		if(nBytesPerSample == 2)
		{
			short* pnData = (short*)pbData;
			int nSampleValue = pnData[nSampleCount];
			
			if(bFadeDirection)
			{
				nSampleValue = (int)((nSampleValue * ((float)(nSampleCount) / nSelectionLength)) + 0.5);
			}
			else
			{
				nSampleValue = (int)((nSampleValue * ((float)(nSelectionLength - nSampleCount) / nSelectionLength)) + 0.5);
			}
			
			pnData[nSampleCount] = short(nSampleValue);
		}
		else if(nBytesPerSample == 1)
		{
			BYTE byteSampleValue = *(pbData + nSampleCount);
			__int8 nSignedValue = byteSampleValue - 128;
			
			if(bFadeDirection)
			{
				nSignedValue = (__int8)((nSignedValue * ((float)(nSampleCount) / nSelectedSamples)) + 0.5);
			}
			else
			{
				nSignedValue = (__int8)((nSignedValue * ((float)(nSelectionLength - nSampleCount) / nSelectedSamples)) + 0.5);
			}
			
			*(pbData + nSampleCount) = nSignedValue + 128;
		}
	}

	// Remove the old data and replace with the faded out
	if(FAILED(m_pDataManager->RemoveData(dwStart, nSelectedSamples)))
	{
		delete[] pbData;
		return E_FAIL;
	}

	if(FAILED(m_pDataManager->InsertData(dwStart, pbData, nSelectedSamples)))
	{
		delete[] pbData;
		return E_FAIL;
	}

	return S_OK;
}

inline double resize_h(double t)
{
	double o;
	t=fabs(t);
	if (t<1.0)
	{
		o=7.0*t*t*t-12.0*t*t+16.0/3.0;
	}
	else if (t<2.0)
	{
		o=-7.0*t*t*t/3.0+12.0*t*t-20.0*t+32.0/3.0;
	}
	else o=0.0;
	return o;
}

// Minify, or downsample
void Downsample16Bit(const short *pwInput, // Source
               short *pwOutput, // Destination
               const int nInputSampleLength,
			   const int nInputStart,
               const int nOutputSampleLength,
			   const DWORD dwNumChannels,
			   const double sx )
{
	for (int x=0; x<nOutputSampleLength; x++)
	{
		for (DWORD dwChannel = 0; dwChannel < dwNumChannels; dwChannel++)
		{
			double rs=0.0;
            double ttSum=0.0;

			for (int t=(int)floor(-2.0+x/sx); t<=ceil(2.0+x/sx); t++)
			{
    			double tt = resize_h(x-t*sx);
                ttSum+=tt;

				int nIndex = nInputStart + t;
				if( nIndex >= 0 && nIndex < nInputSampleLength )
				{
					rs+=double(pwInput[nIndex * dwNumChannels + dwChannel])*tt;
				}
			}
			rs /= ttSum;
			if (rs>32767.0)
				rs=32767.0;
			if (rs<-32768.0)
				rs=-32768.0;
			pwOutput[x * dwNumChannels + dwChannel]= short(rs);
		}
	}
}

// Magnify, or upsample
void Upsample16Bit(const short *pwInput, // Source
               short *pwOutput, // Destination
               const int nInputSampleLength,
			   const int nInputStart,
               const int nOutputSampleLength,
			   const DWORD dwNumChannels,
			   const double sx )
{
	for (int x=0; x<nOutputSampleLength; x++)
	{
		for (DWORD dwChannel = 0; dwChannel < dwNumChannels; dwChannel++)
		{
		    double rs=0.0;
		    for (int t=(int)floor(-2.0+x/sx); t<=ceil(2.0+x/sx); t++)
		    {
				int nIndex = nInputStart + t;
			    if ((nIndex<nInputSampleLength)&&(nIndex>=0))
			    {
    				double tt=resize_h(x/sx-t);
					rs+=double(pwInput[nIndex * dwNumChannels + dwChannel])*tt;
			    }
		    }
            rs /= 6.0;
		    if (rs>32767.0)
			    rs=32767.0;
		    if (rs<-32768.0)
			    rs=-32768.0;
			pwOutput[x * dwNumChannels + dwChannel]=short(rs);
        }
	}
}

// Minify, or downsample
void Downsample8Bit(const BYTE *pbInput, // Source
               BYTE *pbOutput, // Destination
               const int nInputSampleLength,
			   const int nInputStart,
               const int nOutputSampleLength,
			   const DWORD dwNumChannels,
			   const double sx )
{
	for (int x=0; x<nOutputSampleLength; x++)
	{
		for (DWORD dwChannel = 0; dwChannel < dwNumChannels; dwChannel++)
		{
			double rs=0.0;
            double ttSum=0.0;

			for (int t=(int)floor(-2.0+x/sx); t<=ceil(2.0+x/sx); t++)
			{
    			double tt = resize_h(x-t*sx);
                ttSum+=tt;
				int nIndex = nInputStart + t;
				if( nIndex >= 0 && nIndex < nInputSampleLength )
				{
					rs+=double(int(pbInput[nIndex * dwNumChannels + dwChannel]) - 128)*tt;
				}
			}
			rs /= ttSum;
			if (rs>127.0)
				rs=127.0;
			if (rs<-128.0)
				rs=-128.0;
			pbOutput[x * dwNumChannels + dwChannel]= int(rs) + 128;
		}
	}
}

// Magnify, or upsample
void Upsample8Bit(const BYTE *pbInput, // Source
               BYTE *pbOutput, // Destination
               const int nInputSampleLength,
			   const int nInputStart,
               const int nOutputSampleLength,
			   const DWORD dwNumChannels,
			   const double sx )
{
	for (int x=0; x<nOutputSampleLength; x++)
	{
		for (DWORD dwChannel = 0; dwChannel < dwNumChannels; dwChannel++)
		{
		    double rs=0.0;
		    for (int t=(int)floor(-2.0+x/sx); t<=ceil(2.0+x/sx); t++)
		    {
				int nIndex = nInputStart + t;
			    if ((nIndex<nInputSampleLength)&&(nIndex>=0))
			    {
    				double tt=resize_h(x/sx-t);
					rs+=double(int(pbInput[nIndex * dwNumChannels + dwChannel]) - 128)*tt;
			    }
		    }
            rs /= 6.0;
		    if (rs>127.0)
			    rs=127.0;
		    if (rs<-128.0)
			    rs=-128.0;
			pbOutput[x * dwNumChannels + dwChannel]=int(rs) + 128;
        }
	}
}

HRESULT CWave::Resample(DWORD dwNewSampleRate)
{
	if( m_rWaveformat.nSamplesPerSec == dwNewSampleRate )
	{
		return S_OK;
	}

	UINT nBytesPerSample = m_rWaveformat.wBitsPerSample / 8;
	UINT nSampleSize = nBytesPerSample * m_rWaveformat.nChannels;
		
	// The data range could be huge so we need to do this in chunks of 8K
	// Unfortunately, using chunks we end up moving everything 3 samples earlier.
	// So, for now we resample the entire wave at once.
	const DWORD dwChunkSize = m_dwWaveLength;	
	DWORD dwChunkStart = 0;
	DWORD dwSamplesToWrite = m_dwWaveLength;
	DWORD dwOrigStart = 0;
	const int nHalfBasis = 3;

	while( dwSamplesToWrite > 0)
	{
		// Read in a chunk of data
		BYTE* pbData = NULL;
		DWORD cbRead = 0;
		const DWORD dwSamplesRead = min( dwChunkSize, dwSamplesToWrite);
		if( FAILED(GetData(dwChunkStart, dwSamplesRead, &pbData, cbRead))
		||	(cbRead / nSampleSize) != dwSamplesRead )
		{
			return E_FAIL;
		}

		// Compute the samples in this chunk to start and end resampling at
		DWORD dwSampleToStartAt, dwSampleToEndAt;

		// Flag whether or not we're in the first or last chunk
		// If there is only one chunk, then these should stay false
		bool fEndChunk = false;
		bool fStartChunk = false;

		// If we're going to do this again
		if( dwSamplesRead < dwSamplesToWrite )
		{
			// If this is the first chunk
			if( dwChunkStart == 0 )
			{
				fStartChunk = true;
				dwSampleToStartAt = 0;
				dwSampleToEndAt = dwSamplesRead - nHalfBasis;
			}
			else
			{
				dwSampleToStartAt = nHalfBasis;
				dwSampleToEndAt = dwSamplesRead - nHalfBasis * 2;
			}
		}
		// If this is the entire waveform
		else if( dwSamplesRead == m_dwWaveLength )
		{
			dwSampleToStartAt = 0;
			dwSampleToEndAt = dwSamplesRead;
		}
		// Else this is the end chunk
		else
		{
			fEndChunk = true;
			dwSampleToStartAt = nHalfBasis;
			dwSampleToEndAt = dwSamplesRead;
		}

		// Compute the number of samples we're resizing to
		const DWORD dwResampledSize = DWORD(RESAMPLE_SIZE_CHANGE(dwNewSampleRate, m_rWaveformat.nSamplesPerSec, dwOrigStart + dwSampleToEndAt) - RESAMPLE_SIZE_CHANGE(dwNewSampleRate, m_rWaveformat.nSamplesPerSec, dwOrigStart + dwSampleToStartAt));

		// Allocate the buffer to resample into
		BYTE *pbResampledData = new BYTE[dwResampledSize * nSampleSize];
		if( !pbResampledData )
		{
			delete[] pbData;
			return E_FAIL;
		}		

		/*
		// Simple pitch shift without speed up or slowing down..
		{
			const DWORD dwSizeToCopy = min(dwResampledSize, dwSampleToEndAt - dwSampleToStartAt);
			DWORD dwLeft = dwResampledSize;
			BYTE *pbDest = pbResampledData;
			while( dwLeft > 0 )
			{
				memcpy( pbDest, pbData, dwSizeToCopy * nSampleSize );
				dwLeft -= dwSizeToCopy;
				pbDest += dwSizeToCopy * nSampleSize;
			}
		}
		*/

		// Actual resampling
		const BYTE *pbStart = pbData + dwSampleToStartAt * m_rWaveformat.nChannels * nBytesPerSample;
		if( nBytesPerSample == 1 )
		{
			if( dwNewSampleRate < m_rWaveformat.nSamplesPerSec )
			{
				Downsample8Bit( pbStart, pbResampledData, dwSamplesRead, dwSampleToStartAt, dwResampledSize, m_rWaveformat.nChannels, double(dwNewSampleRate) / double(m_rWaveformat.nSamplesPerSec) );
			}
			else
			{
				Upsample8Bit( pbStart, pbResampledData, dwSamplesRead, dwSampleToStartAt, dwResampledSize, m_rWaveformat.nChannels, double(dwNewSampleRate) / double(m_rWaveformat.nSamplesPerSec) );
			}
		}
		else if( nBytesPerSample == 2 )
		{
			if( dwNewSampleRate < m_rWaveformat.nSamplesPerSec )
			{
				Downsample16Bit( (short *)pbStart, (short *)pbResampledData, dwSamplesRead, dwSampleToStartAt, dwResampledSize, m_rWaveformat.nChannels, double(dwNewSampleRate) / double(m_rWaveformat.nSamplesPerSec) );
			}
			else
			{
				Upsample16Bit( (short *)pbStart, (short *)pbResampledData, dwSamplesRead, dwSampleToStartAt, dwResampledSize, m_rWaveformat.nChannels, double(dwNewSampleRate) / double(m_rWaveformat.nSamplesPerSec) );
			}
		}

		// Delete the original data, since we no longer need it
		delete[] pbData;

		// If this is the end chunk, we need to remove nHalfBasis more samples
		// If this is the start chunk, we need to remove nHalfBasis fewer samples
		DWORD dwRemoveSize = (fEndChunk ? nHalfBasis : 0) + (fStartChunk ? -nHalfBasis : 0) + dwSampleToEndAt - dwSampleToStartAt;

		// Remove the old data and replace with the faded out
		if(FAILED(m_pDataManager->RemoveData(dwChunkStart, dwRemoveSize)))
		{
			delete[] pbResampledData;
			return E_FAIL;
		}

		// Update the wave size, since we've removed a chunk of data
		m_OriginalWavObj.dwDataSize -= dwRemoveSize * nSampleSize;
		m_dwDataSize = m_OriginalWavObj.dwDataSize;
		m_dwWaveLength -= dwRemoveSize;

		// Insert the new (resampled) data
		if(FAILED(InsertWaveData(pbResampledData, m_rWaveformat, dwResampledSize, dwChunkStart)))
		{
			delete[] pbResampledData;
			return E_FAIL;
		}

		// Update the wave size, since we've inserted the resampled data
		dwSamplesToWrite -= dwRemoveSize;
		dwChunkStart += dwResampledSize;
		dwOrigStart += dwRemoveSize;
	}

	// Update the loop points
	m_rRLOOP.dwStart = DWORD(RESAMPLE_SIZE_CHANGE(dwNewSampleRate, m_rWaveformat.nSamplesPerSec, m_rRLOOP.dwStart));
	m_rRLOOP.dwEnd = DWORD(RESAMPLE_SIZE_CHANGE(dwNewSampleRate, m_rWaveformat.nSamplesPerSec, m_rRLOOP.dwEnd));
	SetLoop( m_rRLOOP.dwStart, m_rRLOOP.dwEnd );

	// Update the selection
	CWaveCtrl* pWaveEditor = GetWaveEditor();
	if (pWaveEditor != NULL)
	{
		CDLSComponent* pComponent = NULL;
		CWaveNode* pWaveNode = GetNode();
		if(pWaveNode)
		{
			pComponent = pWaveNode->GetComponent();
		}

		int nSelStart, nSelEnd;
		pWaveEditor->GetSelection(nSelStart, nSelEnd);
		nSelStart = int(RESAMPLE_SIZE_CHANGE(dwNewSampleRate, m_rWaveformat.nSamplesPerSec, nSelStart));;
		nSelEnd = int(RESAMPLE_SIZE_CHANGE(dwNewSampleRate, m_rWaveformat.nSamplesPerSec, nSelEnd));;
		pWaveEditor->SetSelection(nSelStart, nSelEnd, (pComponent != NULL) && pComponent->IsSnapToZero());
	}

	// Update the sample rate
	m_rWaveformat.nSamplesPerSec = dwNewSampleRate;
    m_rWaveformat.nAvgBytesPerSec = dwNewSampleRate * nSampleSize;
	m_OriginalWavObj.WaveFormatEx.nSamplesPerSec = m_rWaveformat.nSamplesPerSec;
	m_OriginalWavObj.WaveFormatEx.nAvgBytesPerSec = m_rWaveformat.nAvgBytesPerSec;

	return S_OK;
}


HRESULT CWave::PrepareForSave(CString sNewFileName)	
{
	ASSERT(m_pDataManager);
	if(m_pDataManager == NULL)
	{
		return E_POINTER;
	}
	
	// We need to rename ourselves if we're NOT in a collection
	if(m_pCollection == NULL)
	{
		if(FAILED(m_pDataManager->RenameSource(sNewFileName)))
		{
			return E_FAIL;
		}
	}

	return S_OK;
}



HRESULT CWave::CleanupAfterSave(CString sFileName)
{
	ASSERT(m_pDataManager);
	if(m_pDataManager == NULL)
	{
		return E_FAIL;
	}
	
	ASSERT(m_pWaveNode);
	if(m_pWaveNode == NULL)
	{
		return E_FAIL;
	}

	if(FAILED(m_pDataManager->Initialize(sFileName, m_dwHeaderOffset, m_dwDataOffset, true)))
	{
		return E_FAIL;
	}

	// Set the name for the wave node 
	m_pWaveNode->SetFileName(sFileName);

    m_pWaveNode->SetSourceInTempFile(FALSE);

	return S_OK;
}


CString CWave::GetUndoMenuText(bool bRedo)
{
    ASSERT(m_pDataManager);
    if(m_pDataManager == NULL)
    {
        return "";
    }

    return m_pDataManager->GetUndoMenuText(bRedo);
}


HRESULT CWave::Undo()
{
    ASSERT(m_pDataManager);
    if(m_pDataManager == NULL)
    {
        return E_FAIL;
    }

    return m_pDataManager->Undo();
}


HRESULT CWave::Redo()
{
    ASSERT(m_pDataManager);
    if(m_pDataManager == NULL)
    {
        return E_FAIL;
    }

    return m_pDataManager->Redo();
}

HRESULT CWave::PopUndoState()
{
    ASSERT(m_pDataManager);
    if(m_pDataManager == NULL)
    {
        return E_FAIL;
    }

    return m_pDataManager->PopUndoState();
}

void CWave::UpdateOnUndo(HEADER_INFO headerInfo)
{
	m_dwWaveLength = headerInfo.m_dwWaveLength;
	m_dwDataSize = m_dwWaveLength * (m_rWaveformat.wBitsPerSample / 8) * m_rWaveformat.nChannels;
	if(m_bCompressed)
	{
		m_DecompressedWavObj.dwDataSize = m_dwDataSize;
	}
	else
	{
		m_OriginalWavObj.dwDataSize = m_dwDataSize;
	}
    
    m_bCompressed = headerInfo.m_bCompressed;

	SetWSMPL(headerInfo.m_rWSMP);
	SetWLOOP(headerInfo.m_rWLOOP);
	SetRSMPL(headerInfo.m_rRSMP);
	SetRLOOP(headerInfo.m_rRLOOP);


	if(m_rWSMP.cSampleLoops > 0)
	{
		m_bPlayLooped = true;
	}
	else
	{
		m_bPlayLooped = false;
	}

	m_bStreaming = headerInfo.m_bStreaming;
	m_bNoPreroll = headerInfo.m_bNoPreroll;
	m_dwReadAheadTime = headerInfo.m_dwReadAheadTime;
	m_dwDecompressedStart = headerInfo.m_dwDecompressedStart;

	// Update the sample rate
	m_rWaveformat.nSamplesPerSec = headerInfo.m_dwSamplerate;
    m_rWaveformat.nAvgBytesPerSec = headerInfo.m_dwSamplerate * (m_rWaveformat.wBitsPerSample / 8) * m_rWaveformat.nChannels;
	m_OriginalWavObj.WaveFormatEx.nSamplesPerSec = m_rWaveformat.nSamplesPerSec;
	m_OriginalWavObj.WaveFormatEx.nAvgBytesPerSec = m_rWaveformat.nAvgBytesPerSec;
}

void CWave::NotifyWaveChange(bool bSetDirtyFlag)
{
	ASSERT(m_pWaveNode);
	if(m_pWaveNode == NULL)
	{
		return;
	}

	CDLSComponent* pComponent = m_pWaveNode->GetComponent();
	ASSERT(pComponent);
	if(pComponent == NULL)
	{
		return;
	}

	IDMUSProdFramework* pIFramework = pComponent->m_pIFramework;
	ASSERT(pIFramework);
	if(pIFramework == NULL)
	{
		return;
	}

	// Create a new version GUID
	m_pWaveNode->CreateNewVersionGUID();

	IDMUSProdNode* pIDocRootNode = NULL;
	if(SUCCEEDED(m_pWaveNode->GetDocRootNode(&pIDocRootNode)))
	{
		pIFramework->NotifyNodes(pIDocRootNode, WAVENODE_DataChange, NULL);
		pIDocRootNode->Release();
	}

	if (bSetDirtyFlag)
		SetDirtyFlag();
}


IStream* CWave::GetHeaderMemStream()
{
	return m_pIMemHeaderStream;
}

HRESULT	 CWave::UpdateHeaderStream()
{
	ASSERT(m_pWaveNode);
	if(m_pWaveNode == NULL)
	{
		return E_UNEXPECTED;
	}

	if(m_pIMemHeaderStream)
	{
		m_pIMemHeaderStream->Release();
		m_pIMemHeaderStream = NULL;
	}
	
	CDLSComponent* pComponent = m_pWaveNode->GetComponent();
	ASSERT(pComponent);
	IDMUSProdFramework* pIFramework = pComponent->m_pIFramework;
	ASSERT(pIFramework);
	if(FAILED(pIFramework->AllocMemoryStream(FT_RUNTIME, GUID_CurrentVersion, &m_pIMemHeaderStream)))
	{
		return E_FAIL;
	}

	HRESULT hr = WriteRIFFHeaderToStream(m_pIMemHeaderStream, &m_dwRIFFHeaderSize);
	StreamSeek(m_pIMemHeaderStream, 0, STREAM_SEEK_SET);

	//m_pWaveNode->ReloadDirectSoundWave();

	return hr;
}


DWORD CWave::GetRIFFHeaderSize()
{
	return m_dwRIFFHeaderSize;
}


void CWave::SetHeaderOffset(DWORD dwOffset)
{
	m_dwHeaderOffset = dwOffset;
}


void CWave::SetDataOffset(DWORD dwOffset)
{
	m_dwDataOffset = dwOffset;
}	


void CWave::ValidateDummyPatch()
{
    AFX_MANAGE_STATE(_afxModuleAddrThis);
	CDLSComponent* pComponent = m_pWaveNode->GetComponent();
	ASSERT(pComponent);
	if(pComponent == NULL)
	{
		return;
	}

	if(m_pDummyInstrument == NULL)
	{
		return;
	}

	HRESULT hr = pComponent->IsValidDummyPatch(m_pDummyInstrument, m_pDummyInstrument->m_rInstHeader.Locale.ulBank, m_pDummyInstrument->m_rInstHeader.Locale.ulInstrument);
	if (!SUCCEEDED(hr))
	{
		BYTE DummyMSB = 0;
		BYTE DummyLSB = 0;
		BYTE DummyPatch = 0;

		hr = pComponent->GetNextValidDummyPatch(m_pDummyInstrument, &DummyMSB, &DummyLSB, &DummyPatch);
		if (SUCCEEDED(hr))
		{
			m_pDummyInstrument->m_rInstHeader.Locale.ulBank = MAKE_BANK(0, DummyMSB, DummyLSB);
			m_pDummyInstrument->m_rInstHeader.Locale.ulInstrument = (ULONG) DummyPatch;
			m_pDummyInstrument->UpdateInstrument();
		}
		else
		{//To Do: warn user 
		}
	}
}

CInstrument* CWave::GetDummyInstrument()
{
	return m_pDummyInstrument;
}


void CWave::TurnOffMidiNotes()
{

	if( m_bIsPlaying )
	{
		HRESULT hr = E_FAIL;
		ASSERT(m_pWaveNode);
		CDLSComponent* pComponent = m_pWaveNode->GetComponent();
		ASSERT(pComponent);

		hr = pComponent->PlayMIDIEvent(MIDI_NOTEOFF,
    									(BYTE)m_sUnityNoteUsedToTriggerPlay,
										DEFAULT_VELOCITY,
    									0,
										m_pDummyInstrument->IsDrum());	
       if (SUCCEEDED(hr))
       {
			pComponent->m_pIConductor->SetBtnStates(m_pWaveNode, BS_PLAY_ENABLED | BS_NO_AUTO_UPDATE);
            m_bIsPlaying = FALSE;
       }
	}
}

HRESULT CWave::Play(BOOL /*fPlayFromStart*/)
{
	HRESULT hr = S_OK;
	if(m_pDummyInstrument)
	{	
		ASSERT(m_pWaveNode);
		CDLSComponent* pComponent = m_pWaveNode->GetComponent();
		ASSERT(pComponent);

		m_pDummyInstrument->UpdatePatch();
		hr = pComponent->PlayMIDIEvent(MIDI_NOTEON,
									  (BYTE)m_rWSMP.usUnityNote, // Use wave's unity note
									  DEFAULT_VELOCITY,
									  5, // Time
									  m_pDummyInstrument->IsDrum());   

		
		// figure out latency
		REFERENCE_TIME rtLatency, rtNow;
		MUSIC_TIME mtNow;
		pComponent->m_pIPerformance->GetLatencyTime(&rtLatency);
		pComponent->m_pIPerformance->GetTime(&rtNow, &mtNow);

		DWORD lLatencyMS = (DWORD)((rtLatency - rtNow) / 10000);

		// Record when wave started playing, taking into account latency
		m_nTimePlayed = ::GetTickCount() + lLatencyMS;

		// Remember what note was sent to trigger play.
		// This will be used when stop is clicked. We don't need to specify it here
		// because this stop is sent immediately.
		m_sUnityNoteUsedToTriggerPlay = m_rWSMP.usUnityNote;

		if (SUCCEEDED(hr))
		{
			// Set playing flag to true
			m_bIsPlaying = TRUE;
		}
	}

	return hr;
}

void CWave::ReleaseDummyInstruments()
{
	if(m_pDummyInstrument)
	{
		if(m_pDummyInstrument->Release() == 0)
		{
			m_pDummyInstrument = NULL;
		}
	}
}

BOOL CWave::IsStreamingWave()
{
	return m_bStreaming;
}

BOOL CWave::IsNoPrerollWave()
{
	return m_bNoPreroll;
}

void CWave::SetStreamingWave(BOOL bStream)
{
	ASSERT(m_pWaveNode);
	if(m_pWaveNode == NULL)
	{
		return;
	}

	// Can't set this on a wave in a collection
	// Shouldn't even get here
	if(m_pWaveNode->IsInACollection())
	{
		return;
	}

	m_bStreaming = bStream;
	if(SUCCEEDED(UpdateHeaderStream()))
	{
		m_pWaveNode->ReloadDirectSoundWave();
		NotifyWaveChange(false);
	}
}

void CWave::SetNoPrerollWave(BOOL bNoPreroll)
{
	ASSERT(m_pWaveNode);
	if(m_pWaveNode == NULL)
	{
		return;
	}

	// Can't set this on a wave in a collection
	// Shouldn't even get here
	if(m_pWaveNode->IsInACollection())
	{
		return;
	}

	m_bNoPreroll = bNoPreroll;
	if(SUCCEEDED(UpdateHeaderStream()))
	{
		m_pWaveNode->ReloadDirectSoundWave();
		NotifyWaveChange(false);
	}
}


DWORD CWave::GetReadAheadTime()
{
	return m_dwReadAheadTime;
}

void CWave::SetReadAheadTime(DWORD dwReadAheadTime)
{
	ASSERT(m_pWaveNode);
	if(m_pWaveNode == NULL)
	{
		return;
	}

	// Can't set this on a wave in a collection
	// Shouldn't even get here
	if(m_pWaveNode->IsInACollection())
	{
		return;
	}

	m_dwReadAheadTime = dwReadAheadTime;
	if(SUCCEEDED(UpdateHeaderStream()))
	{
		m_pWaveNode->ReloadDirectSoundWave();
		NotifyWaveChange(false);
	}
}


HRESULT CWave::GetStreamingWaveHeader(_DMUS_IO_WAVE_HEADER* pStreamingWaveHeader)
{
	ASSERT(pStreamingWaveHeader);
	if(pStreamingWaveHeader == NULL)
	{
		return E_POINTER;
	}
	
	// Convert from milliseconds to REFERENCE_TIME
	pStreamingWaveHeader->rtReadAhead = (__int64)((double)m_dwReadAheadTime * 10000);
	pStreamingWaveHeader->dwFlags = m_bStreaming != FALSE ? DMUS_WAVEF_STREAMING : 0;
	if( m_bNoPreroll )
	{
		pStreamingWaveHeader->dwFlags |= DMUS_WAVEF_NOPREROLL;
	}

	return S_OK;
}


void CWave::RememberLoopBeforeCompression()
{
	// Copy the m_rWLOOP struct into m_rWLOOPUncompressed
	ZeroMemory(&m_rWLOOPUncompressed, sizeof(WLOOP));
	CopyMemory(&m_rWLOOPUncompressed, &m_rWLOOP, sizeof(WLOOP));
}


void CWave::RevertToLoopBeforeCompression()
{
	CopyMemory(&m_rWLOOP, &m_rWLOOPUncompressed, sizeof(WLOOP));
    ValidateWLoop(&m_rWLOOP);
	CopyWSMPToSMPL();
}


void CWave::RememberLoopAfterCompression()
{
	// Copy the m_rWLOOP struct into m_rWLOOPCompressed
	ZeroMemory(&m_rWLOOPCompressed, sizeof(WLOOP));
	CopyMemory(&m_rWLOOPCompressed, &m_rWLOOP, sizeof(WLOOP));
}

/* reverts to the saved decompressed start and loop points */
void CWave::RevertToAfterCompression() 
{
	// retrieve loop settings
	CopyMemory(&m_rWLOOP, &m_rWLOOPCompressed, sizeof(WLOOP));

	// make sure Decompressed Start is within bounds
	if (m_dwDecompressedStart > m_dwWaveLength)
		m_dwDecompressedStart = 0;

	// make sure loop are within bounds
    ValidateWLoop(&m_rWLOOP);
	CopyWSMPToSMPL();
}

void CWave::ValidateWLoop(WLOOP* pWLOOP)
{
    ASSERT(pWLOOP);
    if(pWLOOP == NULL)
    {
        return;
    }

	DWORD dwLoopMax = GetDwSelMax();
    if(pWLOOP->ulStart + pWLOOP->ulLength >= dwLoopMax)
    {
        pWLOOP->ulLength = dwLoopMax - pWLOOP->ulStart;
    }

    if(pWLOOP->ulStart + pWLOOP->ulLength <= MINIMUM_VALID_LOOPLENGTH)
    {
        pWLOOP->ulLength = MINIMUM_VALID_LOOPLENGTH;
    }
}

HRESULT	CWave::OnWaveBufferUpdated()
{
	ASSERT(m_pDataManager);
	if(m_pDataManager == NULL)
		return E_FAIL;

	// Update the header info
	m_pDataManager->UpdateHeaderInfo();

	// notify of wave changes
	NotifyWaveChange(true);

	return S_OK; 
}

void CWave::SetDirtyFlag()
{
	ASSERT(m_pWaveNode);
	if(m_pWaveNode)
	{
		if(m_pWaveNode->IsInACollection())
		{
			ASSERT(m_pCollection);
			if(m_pCollection)
			{
				m_pCollection->SetDirtyFlag();
				return;
			}
		}
		m_pWaveNode->SetDirtyFlag();
	}
}

void CWave::ClearDirtyFlag()
{
	ASSERT(m_pWaveNode);
	if(m_pWaveNode)
	{
		if(m_pWaveNode->IsInACollection())
		{
			ASSERT(m_pCollection);
			if(m_pCollection)
			{
				m_pCollection->ClearDirtyFlag();
				return;
			}
		}
		m_pWaveNode->ClearDirtyFlag();
	}
}


CString	CWave::SampleToTime(DWORD dwSample)
{
	DWORD dwSampleRate = m_rWaveformat.nSamplesPerSec;
	DWORD dwSamplesPerMillisec = dwSampleRate / 1000;
	DWORD dwSamplesPerMinute = dwSampleRate * 60;
	DWORD dwSamplesPerHour = dwSamplesPerMinute * 60;
	
	int nMillisecOffset = (dwSample / dwSamplesPerMillisec) % 1000;
	int nSecondOffset = (dwSample / dwSampleRate) % 60;
	int nMinuteOffset = (dwSample / dwSamplesPerMinute) % 60;
	int nHourOffset = (dwSample / dwSamplesPerHour) % 60;
	
	CString sTime;
	sTime.Format("%02d.%03d", nSecondOffset, nMillisecOffset);
	
	if(nMinuteOffset > 0)
	{
		CString sMinuteTime;
		sMinuteTime.Format("%02d:%s", nMinuteOffset, sTime);
		sTime = sMinuteTime;
	}

	if(nHourOffset > 0)
	{
		CString sHourTime;
		sHourTime.Format("%02d:%s", nHourOffset, sTime);
		sTime = sHourTime;
	}

	return sTime;
}

GUID CWave::GetFileGUID()
{
	return m_pWaveNode->GetFileGUID();
}

void CWave::SetFileGUID(GUID guidNew)
{
	ASSERT(m_pWaveNode);
	if(m_pWaveNode == NULL)
	{
		return;
	}

	CDLSComponent* pComponent = m_pWaveNode->GetComponent();
	ASSERT(pComponent);
	if(pComponent == NULL)
	{
		return;
	}


	IDMUSProdFramework* pIFramework = pComponent->m_pIFramework;
	ASSERT(pIFramework);
	if(pIFramework == NULL)
	{
		return;
	}

	m_pWaveNode->SetFileGUID(guidNew);

	// Notify the nodes that this nodes GUID changed
	IDMUSProdNode* pIDocRootNode = NULL;
	if(SUCCEEDED(m_pWaveNode->GetDocRootNode(&pIDocRootNode)))
	{
		pIFramework->NotifyNodes(pIDocRootNode, DOCROOT_GuidChange, NULL);
		pIDocRootNode->Release();
	}
}

HRESULT	CWave::SaveUndoState(UINT uUndoStrID)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT(m_pDataManager);
	if(m_pDataManager == NULL)
		return E_FAIL;

	CString	csMenuText;
 	csMenuText.LoadString(uUndoStrID);
	return m_pDataManager->SaveUndoState(csMenuText);
}

USHORT CWave::GetUnityNote()
{
	return m_rWSMP.usUnityNote;
}

void CWave::SetWaveID(DWORD dwID)
{
	m_dwId = dwID;
}

DWORD CWave::GetWaveID() const
{
	return m_dwId;
}

bool CWave::GetWaveForID(DWORD dwID)
{
	return (m_dwId == dwID);
}

// =========================================================================
// Creates a dummy instrument that will be used to play the wave.
// Each collection has a unique id, which is decremented by 1 for every 
// subsequent collection so that all collections that are downloaded have
// a unique id for its instruments. (pc, msb,lsb)
// =========================================================================
void CWave::SetupDummyInstrument()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	// If we already have a dummy instrument release the old one and create a new one
	if(m_pDummyInstrument)
	{
		return;
	}

	ASSERT(m_pWaveNode);
	CDLSComponent* pComponent = m_pWaveNode->GetComponent();
	ASSERT(pComponent);

	// If m_pDummyInstrument is null when we try to play we'll put up an error message.
    m_pDummyInstrument = new CInstrument(pComponent);
    if(m_pDummyInstrument) 
    { 
		// Check for default articulation
		CArticulation* pArticulation = m_pDummyInstrument->GetCurrentArticulation();
        if(pArticulation)
        {
            CRegion * pRegion = new CRegion(pComponent);
            if(pRegion)
            {
				BYTE DummyMSB = 0;
				BYTE DummyLSB = 0;
				BYTE DummyPatch = 0;

                // Set the msb, lsb and pc of this instrument.
                // Note: This must be a unique number so that the collections are unique also.
				pComponent->GetNextValidDummyPatch(m_pDummyInstrument, &DummyMSB, &DummyLSB, &DummyPatch);

                m_pDummyInstrument->m_rInstHeader.Locale.ulBank = MAKE_BANK(0, DummyMSB, DummyLSB);
                m_pDummyInstrument->m_rInstHeader.Locale.ulInstrument = (ULONG) DummyPatch;

                // If there is looping set in the wave, the release should be 0
                // because then the playing will be stopped by a Stop command.
                memcpy(&(pRegion->m_rWSMP), &(m_rWSMP), sizeof(WSMPL));
                if(m_bPlayLooped)
                {   
                    // Copy the wloop structure
                    memcpy(&(pRegion->m_rWLOOP), &(m_rWLOOP), sizeof(WLOOP));
					ArticParams* pArticParams = pArticulation->GetArticParams();
                    pArticParams->m_VolEG.m_tcRelease = Mils2TimeCents(0);
                }
                else
                {
                    pRegion->m_rWSMP.cSampleLoops = 0;
					ArticParams* pArticParams = pArticulation->GetArticParams();
                    pArticParams->m_VolEG.m_tcRelease = Mils2TimeCents(0);
                }
                    
                // Add wave to region
                pRegion->m_pWave = this;
				m_pWaveNode->AddRef();

				pRegion->m_rWaveLink.fusOptions = (GetChannelCount() > 1) ? F_WAVELINK_MULTICHANNEL : 0;
			#ifdef _DEBUG
				pRegion->m_rWaveLink.ulTableIndex = 0xDEAD;
			#endif

                // Add the instrument to the region
                pRegion->m_pInstrument = m_pDummyInstrument;

                // Add the region to the instruments' list of regions.
                m_pDummyInstrument->m_Regions.AddTail(pRegion);
				
				// Download Instrument
				POSITION position = pComponent->m_lstDLSPortDownload.GetHeadPosition();
				while(position)
				{
					IDirectMusicPortDownload* pIDMPortDownload = pComponent->m_lstDLSPortDownload.GetNext(position);
					ASSERT(pIDMPortDownload);

					if(pIDMPortDownload)
					{
						m_pDummyInstrument->DM_Init(pIDMPortDownload);
						m_pDummyInstrument->Download(pIDMPortDownload);
					}
				}
				
                // Update Patch
                m_pDummyInstrument->UpdatePatch();          
            } 
        } 
    }
}

void CWave::UpdateLoopInRegions()
{
    AFX_MANAGE_STATE(_afxModuleAddrThis);
    
	// Go thru all regions and change values in the regions that
    // refer to the wave being edited if the override flag is not set.
    if(m_pCollection == NULL)
		return;

    CInstrument * pInstrument = m_pCollection->m_Instruments.GetHead();
    while (pInstrument) // for all instruments go thru all regions
    {
    	bool bInstrumentNeedsUpdate = false;
        CRegion * pRegion = pInstrument->m_Regions.GetHead();
        while (pRegion)
        {
            if (IsReferencedBy(pRegion->m_pWave))
            {
                // is override Playback set?
                if (!pRegion->m_bOverrideWaveMoreSettings)
                {
                    pRegion->m_rWSMP.cSampleLoops = pRegion->m_pWave->GetWSMPL().cSampleLoops;
                    pRegion->m_rWLOOP = pRegion->m_pWave->GetWLOOP();
                    bInstrumentNeedsUpdate = true;
                }
            }
            pRegion = pRegion->GetNext();
        } // while pregion

		// update instrument if we changed any of its regions
        if (bInstrumentNeedsUpdate)
			pInstrument->UpdateInstrument();

        pInstrument = pInstrument->GetNext();
    }
}

/* returns whether the passed-in wave points to this one or any of its channels */
bool CWave::IsReferencedBy(CWave *pWave)
{
	// check wave
	if (pWave == this)
		return true;

	// check all channels (except for mono, where wave == channel)
	LONG cChannels = GetChannelCount();
	if (cChannels > 1)
		for (LONG iChannel = 0; iChannel < cChannels; iChannel++)
			if (GetChannel(iChannel) == pWave)
				return true;

	return false;
}

void CWave::UpdateRefRegions()
{
    AFX_MANAGE_STATE(_afxModuleAddrThis);

    // Go thru all regions and update the instrument that owns the regions that
    // refer to the wave being edited.
	if(m_pCollection == NULL)
	{
		return;
	}

    CInstrument * pInstrument = m_pCollection->m_Instruments.GetHead();
    while (pInstrument) // for all instruments go thru all regions
    {
        CRegion * pRegion = pInstrument->m_Regions.GetHead();
        while (pRegion)
        {
            if (IsReferencedBy(pRegion->m_pWave))
            {
                // updatesynth. 
                ASSERT(pRegion->m_pInstrument);
        		pRegion->m_pInstrument->UpdateInstrument();
				break;
            }
            pRegion = pRegion->GetNext();
        } // while pregion
        pInstrument = pInstrument->GetNext();
    }
}

void CWave::UpdateDummyInstrument()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	if(m_pDummyInstrument == NULL)
	{
		return;
	}

    // Copy the wsmp and smpl regions from the wave to the region in the collection.
    CRegion* pRegion = m_pDummyInstrument->m_Regions.GetHead();
    ASSERT(pRegion);

	// Copy the wsmp structure
	memcpy(&(pRegion->m_rWSMP), &(m_rWSMP), sizeof(WSMPL));
	
	// Copy the wloop structure
	memcpy(&(pRegion->m_rWLOOP), &(m_rWLOOP), sizeof(WLOOP));
  
    // Now download
	if(m_dwWaveLength > 0)
	{
		m_pDummyInstrument->UpdateInstrument();
	}
}

/* returns whether decompressed start should be taken into account for displaying or playing */
bool CWave::FConsiderDecompressedStart()
{
/* TODO: Re-enable this when we support decompressed start again
#ifndef DMP_XBOX
	// controls are enabled only if wave is compressed, and in a DLS collection
	bool bConsider = false;
	if (m_bCompressed)
		{
		CWaveNode* pWaveNode = GetNode();
		ASSERT(pWaveNode);
		if ((pWaveNode != NULL) && pWaveNode->IsInACollection())
			bConsider = true;
		}

	return bConsider;
#else
*/
	return false;
/*
#endif
*/
}

/* UI wrapper that attempts to set the decompressed start to the given value */
HRESULT CWave::HrSetDecompressedStart(DWORD dwDecompressedStart)
{
	ASSERT(FConsiderDecompressedStart()); // this shouldn't be called

	// range checking
	int intUpper = min(m_dwWaveLength, UD_MAXVAL);
	if (dwDecompressedStart > (DWORD)intUpper)
		dwDecompressedStart = (DWORD)intUpper;

	// ensure loop values are high enough
	bool fChanged = false;
	WLOOP waveLoop = GetWLOOP();
	DWORD dwLoopStart = waveLoop.ulStart + m_dwDecompressedStart;
	DWORD dwLoopEnd = dwLoopStart + waveLoop.ulLength;
	if (dwLoopStart < dwDecompressedStart)
		{
		dwLoopStart = dwDecompressedStart;
		fChanged = true;
		}
	if (dwLoopEnd < dwDecompressedStart)
		{
		dwLoopEnd = dwDecompressedStart;
		fChanged = true;
		}
	if (dwLoopEnd < dwLoopStart)
		{
		dwLoopEnd = dwLoopStart;
		fChanged = true;
		}

	// bail if no change
	if ((dwDecompressedStart == m_dwDecompressedStart) && !fChanged)
		return S_FALSE;

	// save the undo state
	if (FAILED(SaveUndoState(IDS_UNDO_DECOMPRESSEDSTART)))
		return E_FAIL;

	// update wave data, offset selection and loop to new decompressed start
	long nDelta = dwDecompressedStart - m_dwDecompressedStart;
	m_dwDecompressedStart = dwDecompressedStart;
	waveLoop.ulStart = dwLoopStart - dwDecompressedStart;
	waveLoop.ulLength = dwLoopEnd - dwLoopStart;
	SetWLOOP(waveLoop);

	// Copy the loop information to the legacy structure
	CopyWSMPToSMPL();

	// the compressed loop also gets modified
	RememberLoopAfterCompression();

	// update header info (also notified of change and sets dirty flag)
	if (FAILED(OnWaveBufferUpdated()))
		{
		PopUndoState();
		return E_FAIL;
		}

	// update synth, and all regions referencing this wave
	UpdateWave();
	UpdateLoopStartAndLengthInRegions();
	UpdateDummyInstrument();

	CDLSComponent* pComponent = NULL;
	CWaveNode* pWaveNode = GetNode();
	if(pWaveNode)
		pComponent = pWaveNode->GetComponent();
	else
		{
		ASSERT(FALSE); // missing component
		pComponent = NULL;
		}	

	// offset selection in wave editor, and redraw
	CWaveCtrl* pWaveEditor = GetWaveEditor();
	if (pWaveEditor != NULL)
		{
		int nSelStart, nSelEnd;
		pWaveEditor->GetSelection(nSelStart, nSelEnd);
		nSelStart -= nDelta;
		nSelEnd -= nDelta;
		pWaveEditor->SetSelection(nSelStart, nSelEnd, (pComponent != NULL) && pComponent->IsSnapToZero());
		pWaveEditor->InvalidateRect(NULL);
		}

	// refresh property page
	if (pComponent != NULL)
		{
		IDMUSProdPropSheet* pIPropSheet;
		if (SUCCEEDED(pComponent->m_pIFramework->QueryInterface(IID_IDMUSProdPropSheet, (void**)&pIPropSheet)))
			{
			if(pIPropSheet->IsShowing() == S_OK)
				OnShowProperties();
			pIPropSheet->Release();
			}
		}

	return S_OK;
}

/* UI wrapper that validates loop start and end. Caller should only save undo state and set loop values on success. */
HRESULT CWave::HrValidateLoopValues(DWORD &dwLoopStart, DWORD &dwLoopLength, const bool bLockLoopLength)
{
	HRESULT hr = S_OK;
	WLOOP waveLoop = GetWLOOP();

#if MINIMUM_VALID_LOOPSTART > 0
	// If the start of the loop is less than the minimum valid we set it right...
	if (dwLoopStart < MINIMUM_VALID_LOOPSTART)
		{
		dwLoopStart = MINIMUM_VALID_LOOPSTART;
		hr = E_FAIL;
		}
#endif

	// If the start value exceeds the maximum possible value 
	// it's an error so we set it right back to the old value
	DWORD dwLoopMax = GetDwSelMax();
	if (dwLoopStart > dwLoopMax - MINIMUM_VALID_LOOPLENGTH)
		{
		AfxMessageBox(IDS_ERR_INVALID_LOOPSTART, MB_ICONEXCLAMATION);

		dwLoopStart = waveLoop.ulStart;
		hr = E_FAIL;
		}

	// If the loop length is less than the minimum valid we set it right...
	if (dwLoopLength < MINIMUM_VALID_LOOPLENGTH)
		{
		AfxMessageBox(IDS_LOOP_TOO_SMALL, MB_ICONEXCLAMATION);

		dwLoopLength = waveLoop.ulLength;
		hr  = E_FAIL;
		}

	// If the length of the loop exceeds the total wavelength and the loop length is *NOT LOCKED*
	// then we set it to the maximum possible looplength
	if (dwLoopStart + dwLoopLength > dwLoopMax)
		{
		if (!bLockLoopLength)
			dwLoopLength = dwLoopMax - dwLoopStart;
		else
			dwLoopStart = waveLoop.ulStart;

		hr = E_FAIL;
		}

	if (dwLoopLength >= MSSYNTH_LOOP_LIMIT)
		{
		int nChoice = AfxMessageBox(IDS_WARN_MSSYNTH_LOOP_LIMIT, MB_OKCANCEL);
		if (nChoice == IDCANCEL)
			{
			dwLoopLength = MSSYNTH_LOOP_LIMIT - 1;
			hr = E_FAIL;
			}
		}

	return hr;
}

/* loop start has changed in wave, update all regions referencing the wave */
void CWave::UpdateLoopStartAndLengthInRegions()
{
    // Go thru all regions and chenge values in the regions that
    // refer to the wave being edited if the override flag is not set.
	CCollection* pCollection = GetCollection();
	if(!pCollection)
		return;

	WLOOP waveLoop = GetWLOOP();

    CInstrument * pInstrument = pCollection->m_Instruments.GetHead();

    while (pInstrument) // for all instruments go thru all regions
    {
        CRegion * pRegion = pInstrument->m_Regions.GetHead();
        while (pRegion)
        {
            if (pRegion->m_pWave == this)
            {
                // is override Playback set?
                if (!pRegion->m_bOverrideWaveMoreSettings)
                {
                    pRegion->m_rWLOOP.ulStart = waveLoop.ulStart;
                    pRegion->m_rWLOOP.ulLength = waveLoop.ulLength;
                    // updatesynth. 
                    ASSERT(pRegion->m_pInstrument);
        			pRegion->m_pInstrument->UpdateInstrument();
                }
            }
            pRegion = pRegion->GetNext();
        } // while pregion
        pInstrument = pInstrument->GetNext();
    }
}

/* ensures the given sample count is within selection boundaries */
void CWave::ConstrainToSelectionBoundaries(int& nSel)
{
	DWORD dwDecompressedStart = GetDwDecompressedStart(true);
	int nSelMin = -(int)(dwDecompressedStart);
	int nSelMax = m_dwWaveLength-dwDecompressedStart-1;

	if (nSel < nSelMin)
		nSel = nSelMin;
	else if (nSel > nSelMax)
		nSel = nSelMax;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\DLSDesigner\WaveCompressionManager.cpp ===
// CWaveCompressionManager Implementation file
//

#include "stdafx.h"
#include "dlsdesigner.h"
#include "WaveNode.h"
#include "wave.h"
#include "WaveCompressionManager.h"
#include "resource.h"


#ifdef _DEBUG
#define new DEBUG_NEW
#define _CRTDBG_MAP_ALLOC
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// 

/*****************************************************
// Constructs a Compression Manager for a Wave object
******************************************************/
CWaveCompressionManager::CWaveCompressionManager():
	m_bGotDrivers(false)
{}

CWaveCompressionManager::~CWaveCompressionManager()
{
	ClearFormatCollection();
	ClearDriverCollection();
}

/*******************************************************
// Gets all the supported drivers for the wave object.
// The drivers are collected in a CArray object.
********************************************************/
BOOL CWaveCompressionManager::GetSupportedDrivers()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if (m_bGotDrivers)
		return TRUE;
	m_bGotDrivers = true;

	CWaitCursor cursor;
	MMRESULT mmr = acmDriverEnum(acmDriverEnumCallback, (DWORD)this, 0);
	
	if(mmr != MMSYSERR_NOERROR)
	{
		TRACE0("Failed to load one or more ACM drivers");
		return FALSE;
	}
	return TRUE;
}

/*******************************************************
// Gets the suported audio formats for a driver
********************************************************/
// The index must map to a valid index in the collection of supported drivers.
typedef struct _FormatEnumCallbackInfo {
	CWave *pWave;
	CTypedPtrArray<class CPtrArray,struct _SUPPORTED_FORMAT_INFO *> *parrSupportedFormats;
} FormatEnumCallbackInfo;


#ifdef DMP_XBOX
#define IMAADPCM_BITS_PER_SAMPLE        4
#define IMAADPCM_HEADER_LENGTH          4
#define XBOX_ADPCM_SAMPLES_PER_BLOCK    64

/****************************************************************************
 *
 *  CalculateEncodeAlignment
 *
 *  Description:
 *      Calculates an encoded data block alignment based on a PCM sample
 *      count and an alignment multiplier.
 *
 *  Arguments:
 *      WORD [in]: channel count.
 *      WORD [in]: PCM samples per block.
 *
 *  Returns:  
 *      WORD: alignment, in bytes.
 *
 ****************************************************************************/

WORD CalculateEncodeAlignment
(
    WORD                    nChannels
)
{
    const WORD              nEncodedSampleBits  = nChannels * IMAADPCM_BITS_PER_SAMPLE;
    const WORD              nHeaderBytes        = nChannels * IMAADPCM_HEADER_LENGTH;
    WORD                    nBlockAlign;

    //
    // Calculate the raw block alignment that XBOX_ADPCM_SAMPLES_PER_BLOCK dictates.  This
    // value may include a partial encoded sample, so be sure to round up.
    //
    // Start with the samples-per-block, minus 1.  The first sample is actually
    // stored in the header.
    //

    nBlockAlign = XBOX_ADPCM_SAMPLES_PER_BLOCK - 1;

    //
    // Convert to encoded sample size
    //

    nBlockAlign *= nEncodedSampleBits;
    nBlockAlign += 7;
    nBlockAlign /= 8;

    //
    // The stereo encoder requires that there be at least two DWORDs to process
    //

    nBlockAlign += 7;
    nBlockAlign /= 8;
    nBlockAlign *= 8;

    //
    // Add the header
    //

    nBlockAlign += nHeaderBytes;

    return nBlockAlign;
}

void CreateXboxAdpcmFormat
(
    WORD                    nChannels, 
    DWORD                   nSamplesPerSec, 
    LPIMAADPCMWAVEFORMAT    pwfx
)
{
    pwfx->wfx.wFormatTag = XBOXADPCM_FORMAT_TAG;
    pwfx->wfx.nChannels = nChannels;
    pwfx->wfx.nSamplesPerSec = nSamplesPerSec;
    pwfx->wfx.nBlockAlign = CalculateEncodeAlignment(nChannels);
    pwfx->wfx.nAvgBytesPerSec = nSamplesPerSec * pwfx->wfx.nBlockAlign / XBOX_ADPCM_SAMPLES_PER_BLOCK;
    pwfx->wfx.wBitsPerSample = IMAADPCM_BITS_PER_SAMPLE;
    pwfx->wfx.cbSize = sizeof(*pwfx) - sizeof(pwfx->wfx);
    pwfx->wSamplesPerBlock = XBOX_ADPCM_SAMPLES_PER_BLOCK;
}

#endif // DMP_XBOX

/* fills m_arrSupportedFormats with formats supported by given driver, and for given wave */
void CWaveCompressionManager::GetSupportedFormats(const FORMAT_TAG_INF0* pFormatInfo, CWave *pWave)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	ASSERT(m_bGotDrivers);
	ASSERT(pWave);

	ASSERT(pFormatInfo != (const void *)-1);
	ASSERT(pFormatInfo != NULL);

	// Clear all the previously collected formats
	ClearFormatCollection();
	
	ACMFORMATDETAILS afd;
	ZeroMemory(&afd, sizeof(ACMFORMATDETAILS));
	afd.cbStruct = sizeof(afd);

	DWORD dwMaxFormatSize = 0;
	afd.dwFormatTag = pFormatInfo->dwFormatTag;

	MMRESULT mmr = acmMetrics((HACMOBJ)(pFormatInfo->hadid), ACM_METRIC_MAX_SIZE_FORMAT, &dwMaxFormatSize);

	HACMDRIVER had = NULL;
	if(mmr == MMSYSERR_NOERROR)
	{
		mmr = acmDriverOpen(&had, pFormatInfo->hadid, 0);
	}

	if(mmr == MMSYSERR_NOERROR)
	{
		afd.cbwfx = dwMaxFormatSize;
		afd.pwfx = (WAVEFORMATEX *) new	BYTE[dwMaxFormatSize];
		if(afd.pwfx)
		{
			ZeroMemory(afd.pwfx, dwMaxFormatSize);
			afd.dwFormatTag = (DWORD) (pFormatInfo->dwFormatTag);
			afd.pwfx->wFormatTag = (WORD) (pFormatInfo->dwFormatTag);
			
			FormatEnumCallbackInfo feci;
			feci.pWave = pWave;
			feci.parrSupportedFormats = &m_arrSupportedFormats;

			acmFormatEnum(had, &afd, acmFormatEnumCallback, (DWORD)&feci, ACM_FORMATENUMF_WFORMATTAG);
			delete[] afd.pwfx;
		}

#ifdef DMP_XBOX
		// If there are no supported formats, check to see if the wave's current sample rate is supported
		if( m_arrSupportedFormats.GetSize() == 0
		&&	XBOXADPCM_FORMAT_TAG == pFormatInfo->dwFormatTag )
		{
			// Source format
			LPWAVEFORMATEX pwfxSrc = &(pWave->m_rWaveformat);

			// Destination format
			IMAADPCMWAVEFORMAT wfxDst;
			ZeroMemory( &wfxDst, sizeof(IMAADPCMWAVEFORMAT) );

			// We don't want stereo formats if the wave is not a TRUE stereo wave
			// But we want the stereo formats if it's a stereo wave NOT in a collection
			bool bIsStereo = pWave->GetNode()->IsStereo();
			CCollection* pCollection = pWave->GetNode()->GetCollection();

			CreateXboxAdpcmFormat( (bIsStereo && pCollection == NULL) ? 2 : 1, pwfxSrc->nSamplesPerSec, &wfxDst );

			MMRESULT mmr = acmStreamOpen(NULL, NULL, pwfxSrc, (WAVEFORMATEX *)(&wfxDst), NULL, 0, 0, ACM_STREAMOPENF_QUERY);
			if(mmr == MMSYSERR_NOERROR)
			{
				SUPPORTED_FORMAT_INFO* pSupportedFormat = new SUPPORTED_FORMAT_INFO;

				if( wfxDst.wfx.nChannels == 1 )
				{
					pSupportedFormat->sSupportedFormatName.FormatMessage( IDS_XBADPCM_MONO, wfxDst.wfx.nSamplesPerSec );
				}
				else
				{
					pSupportedFormat->sSupportedFormatName.FormatMessage( IDS_XBADPCM_STEREO, wfxDst.wfx.nSamplesPerSec );
				}
				
				// Allocate exactly what size is required for this WAVEFORMATEX struct
				int nExtraBytes = wfxDst.wfx.cbSize;

				pSupportedFormat->pWaveFormatEx = (WAVEFORMATEX*) new BYTE[sizeof(WAVEFORMATEX) + nExtraBytes];
				CopyMemory(pSupportedFormat->pWaveFormatEx, &wfxDst, sizeof(WAVEFORMATEX) + nExtraBytes);

				m_arrSupportedFormats.Add(pSupportedFormat);
			}
		}
#endif // DMP_XBOX

		acmDriverClose(had, 0);
	}
}


/****************************************************************
// Gets the suported audio formats for a driver for a Format Tag
*****************************************************************/
BOOL CWaveCompressionManager::GetSupportedFormats(WORD wFormatTag, CWave *pWave)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	ASSERT(m_bGotDrivers);

	int nDrivers = m_arrFormatTags.GetSize();

	for(int nCount = 0; nCount < nDrivers; nCount++)
	{
		if(m_arrFormatTags[nCount]->dwFormatTag == wFormatTag)
		{
			GetSupportedFormats(m_arrFormatTags[nCount], pWave);
			return TRUE;
		}
	}

	return FALSE;
}


/*******************************************************
// Deletes all the pointers from the format collection
********************************************************/
void CWaveCompressionManager::ClearFormatCollection()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	while(m_arrSupportedFormats.GetSize() > 0)
	{
		SUPPORTED_FORMAT_INFO* pSupportedFormatInfo = (SUPPORTED_FORMAT_INFO*)m_arrSupportedFormats[0];
		m_arrSupportedFormats.RemoveAt(0);
		
		if(pSupportedFormatInfo->pWaveFormatEx)
			delete pSupportedFormatInfo->pWaveFormatEx;
		delete  pSupportedFormatInfo;
		pSupportedFormatInfo = NULL;
	}
}

/*******************************************************
// Deletes all the pointers from the drivers collection
********************************************************/
void CWaveCompressionManager::ClearDriverCollection()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	while(m_arrFormatTags.GetSize() > 0)
	{
		FORMAT_TAG_INF0* pDriverInfo = (FORMAT_TAG_INF0*)m_arrFormatTags[0];
		m_arrFormatTags.RemoveAt(0);
		delete pDriverInfo;
		pDriverInfo = NULL;
	}

	while(m_arrPCMFormatTags.GetSize() > 0)
	{
		FORMAT_TAG_INF0* pDriverInfo = (FORMAT_TAG_INF0*)m_arrPCMFormatTags[0];
		m_arrPCMFormatTags.RemoveAt(0);
		delete pDriverInfo;
		pDriverInfo = NULL;
	}
}


BOOL CALLBACK CWaveCompressionManager::acmDriverEnumCallback(HACMDRIVERID hadid, DWORD dwInstance, DWORD fdwSupport)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	
	HACMDRIVER had = NULL;
	MMRESULT mmr1 = acmDriverOpen(&had, hadid, 0);
	MMRESULT mmr2 = MMSYSERR_NOERROR; 					
	
	if(mmr1 == MMSYSERR_NOERROR)
	{
		mmr1 = EnumFormatTags(&had, dwInstance);
		mmr2 = acmDriverClose(had, 0);
	}
	
	if(mmr1 != MMSYSERR_NOERROR || mmr2 != MMSYSERR_NOERROR)
	{
		return FALSE;
	}
	
	return TRUE;
}

MMRESULT CWaveCompressionManager::EnumFormatTags(HACMDRIVER *phad, DWORD dwInstance)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT(phad);

	ACMFORMATTAGDETAILS aftd;
	ZeroMemory(&aftd, sizeof(ACMFORMATTAGDETAILS));
	aftd.cbStruct = sizeof(aftd);
	
	MMRESULT mmr = acmFormatTagEnum(*phad, &aftd, CWaveCompressionManager::acmFormatTagEnumCallback, dwInstance,	0);

	return mmr;
}

BOOL CALLBACK CWaveCompressionManager::acmFormatTagEnumCallback(HACMDRIVERID hadid, LPACMFORMATTAGDETAILS paftd,  
									   DWORD dwInstance, DWORD fdwSupport)

{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	ASSERT(paftd);

	CWaveCompressionManager* pCompressionManager = (CWaveCompressionManager*)dwInstance;
	ASSERT(pCompressionManager);
	if (NULL == pCompressionManager)
	{
		return FALSE;
	}

	FORMAT_TAG_INF0* pfi = new FORMAT_TAG_INF0;
	
	if(pfi == NULL)
	{
		return FALSE;
	}

	pfi->sDriverName = paftd->szFormatTag;
	pfi->hadid = hadid;
	pfi->dwFormatTag = paftd->dwFormatTag;

#ifdef DMP_XBOX
	// We only support Xbox ADPCM
	if(paftd->dwFormatTag != XBOXADPCM_FORMAT_TAG)
	{
		delete pfi;
		return TRUE;
	}
#endif // DMP_XBOX

	// We do not want PCM in our list
	if(lstrcmp(paftd->szFormatTag, "PCM") == 0)
	{
		pCompressionManager->m_arrPCMFormatTags.Add(pfi);
	}
	else
	{
		pCompressionManager->m_arrFormatTags.Add(pfi);
	}

	if(paftd->dwFormatTag == MSAUDIO_FORMAT_TAG)
    {
		pCompressionManager->m_hMSAudioV1BetaDriverID = hadid;
    }
	
	return TRUE;
}

BOOL CALLBACK CWaveCompressionManager::acmFormatEnumCallback(HACMDRIVERID hadid,
	LPACMFORMATDETAILS pafd, DWORD dwInstance, DWORD fdwSupport)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	
	ASSERT(pafd);
	FormatEnumCallbackInfo *pfeci = (FormatEnumCallbackInfo *)dwInstance;
	ASSERT(pfeci);
	
	if (pfeci->pWave == NULL)
		return FALSE;

	LPWAVEFORMATEX pwfxSrc = &((pfeci->pWave)->m_rWaveformat);
	LPWAVEFORMATEX pwfxDst = pafd->pwfx;

	// We don't want stereo formats if the wave is not a TRUE stereo wave
	// But we want the stereo formats if it's a stereo wave NOT in a collection
	CWaveNode* pWaveNode = pfeci->pWave->GetNode();
	ASSERT(pWaveNode);
	CCollection* pCollection = pWaveNode->GetCollection();
	bool bIsStereo = pWaveNode->IsStereo();

	if((bIsStereo == false || pCollection) && pwfxDst->nChannels > 1)
		return TRUE;
	
	// If this is a TRUE stereo wave use only stereo wave formats
	if(bIsStereo && pCollection == NULL && pwfxDst->nChannels != 2)
		return TRUE;

	if(pwfxDst->wFormatTag != MSAUDIO_FORMAT_TAG && pwfxDst->wFormatTag != WMAUDIO_FORMAT_TAG)
	{
		MMRESULT mmr = acmStreamOpen(NULL, NULL, pwfxSrc, pwfxDst, NULL, 0, 0, ACM_STREAMOPENF_QUERY);
		if(mmr != MMSYSERR_NOERROR)
		{
			if(mmr == ACMERR_NOTPOSSIBLE)
			{
				return TRUE;
			}
			return FALSE;
		}
	}

	SUPPORTED_FORMAT_INFO* pSupportedFormat = new SUPPORTED_FORMAT_INFO;

	pSupportedFormat->sSupportedFormatName = pafd->szFormat;
	
	// Allocate exactly what size is required for this WAVEFORMATEX struct
	int nExtraBytes = 0;
	if(pafd->pwfx->wFormatTag != WAVE_FORMAT_PCM)
		nExtraBytes = pafd->pwfx->cbSize;

	pSupportedFormat->pWaveFormatEx = (WAVEFORMATEX*) new BYTE[sizeof(WAVEFORMATEX) + nExtraBytes];
	CopyMemory(pSupportedFormat->pWaveFormatEx, pafd->pwfx, sizeof(WAVEFORMATEX) + nExtraBytes);

	pfeci->parrSupportedFormats->Add(pSupportedFormat);

	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\DLSDesigner\WaveCompressionManager.h ===
#ifndef __WAVECOMPRESSIONMANAGER_H__
#define __WAVECOMPRESSIONMANAGER_H__

// WaveCompressionManager.h : header file
//

#include <mmsystem.h>
#include <mmreg.h>
#include <msacm.h>

class CWave;


//================================================================
// Borrowed definitions from MSAudio team
//================================================================
#define VOXWARE_METAVOICE_FORMAT_TAG                116
#define VOXWARE_METASOUND_FORMAT_TAG                117
#define IsVoxwareCodec(dwFormatTag) ( (VOXWARE_METASOUND_FORMAT_TAG == dwFormatTag) || (VOXWARE_METAVOICE_FORMAT_TAG == dwFormatTag) )

#define  SCODE_FROM_ACM( x ) (x ? ((HRESULT) (((x) & 0x0000FFFF) | (FACILITY_ACM << 16) | 0xC0000000)) : 0 )

#define MSAUDIO_FORMAT_TAG	352	// V1
#define WMAUDIO_FORMAT_TAG	353	// V2

#ifdef DMP_XBOX
#define XBOXADPCM_FORMAT_TAG 105
extern void CreateXboxAdpcmFormat( WORD nChannels, DWORD nSamplesPerSec, LPIMAADPCMWAVEFORMAT pwfx );
#endif // DMP_XBOX

// Keys required for MS Audio 4.0 CODEC
// Both Codecs use the same keys
#define MSAUDIO_KEY "F6DC9830-BC79-11d2-A9D0-006097926036"
#define MSAUDIO_DEC_KEY "1A0F78F0-EC8A-11d2-BBBE-006008320064"
#define MSAUDIOWAVEFORMATEX_EXTRA_BYTES	4

#pragma pack(1)
// Special format for V1
typedef struct msaudio1waveformat_tag {
    WAVEFORMATEX wfx;
    WORD         wSamplesPerBlock; // only counting "new" samples "= half of what will be used due to overlapping
    WORD         wEncodeOptions;
} MSAUDIO1WAVEFORMAT;

typedef MSAUDIO1WAVEFORMAT FAR  *LPMSAUDIO1WAVEFORMAT;


// Special format for V2
typedef struct wmaudio2waveformat_tag {
    WAVEFORMATEX wfx;
    DWORD        dwSamplesPerBlock; // only counting "new" samples "= half of what will be used due to overlapping
    WORD         wEncodeOptions;
    DWORD        dwSuperBlockAlign; // the big size...  should be multiples of wfx.nBlockAlign.
} WMAUDIO2WAVEFORMAT;

typedef WMAUDIO2WAVEFORMAT FAR  *LPWMAUDIO2WAVEFORMAT;

#pragma pack()

//=================================================================


// Keeps the information about a driver
typedef struct _FORMAT_TAG_INF0
{
	CString			sDriverName;
	HACMDRIVERID	hadid;
	DWORD			dwFormatTag;

} FORMAT_TAG_INF0;

// Keeps the information about a supported 
// format for a particular driver.
typedef struct _SUPPORTED_FORMAT_INFO
{
	CString			sSupportedFormatName;
	WAVEFORMATEX*	pWaveFormatEx;

} SUPPORTED_FORMAT_INFO;
	
class CWaveCompressionManager
{
	friend class CWaveCompressionPropPage;

//Construction
public:
	CWaveCompressionManager();
	~CWaveCompressionManager();

// Implementation
	BOOL GetSupportedDrivers();
	BOOL GetSupportedFormats(WORD wFormatTag, CWave *pWave);

	/* fills m_arrSupportedFormats with formats supported by given driver, and for given wave */
	void GetSupportedFormats(const FORMAT_TAG_INF0* pFormatInfo, CWave *pWave);

private:
	void ClearDriverCollection();
	void ClearFormatCollection();
	
	static MMRESULT EnumFormatTags(HACMDRIVER *phad, DWORD dwInstance);
	
	static BOOL CALLBACK acmDriverEnumCallback(HACMDRIVERID hadid,
									DWORD dwInstance,
									DWORD fdwSupport);

	static BOOL CALLBACK acmFormatTagEnumCallback(HACMDRIVERID hadid,           
									   LPACMFORMATTAGDETAILS paftd,  
									   DWORD dwInstance,             
									   DWORD fdwSupport);

	static BOOL CALLBACK acmFormatEnumCallback(HACMDRIVERID hadid,           
									LPACMFORMATDETAILS pafd,  
									DWORD dwInstance,             
									DWORD fdwSupport);

//Attributes
public:
	HACMDRIVERID								m_hMSAudioV1BetaDriverID;	// Keep the driver ID for the Beta V1 codec...we need to use 
																			// this specifically when opening a stream for a conversion 
																			// using this codec as the new V2 lists this codec as well...

private:
	bool										m_bGotDrivers;				// m_arrFormatTags and m_arrPCMFormatTags have been filled
	CTypedPtrArray<CPtrArray, FORMAT_TAG_INF0*>	m_arrFormatTags;			// Keeps all the registred drivers in FORMAT_TAG_INFO objects 
	CTypedPtrArray<CPtrArray, FORMAT_TAG_INF0*>	m_arrPCMFormatTags;			// Keeps the drivers that can handle PCM formats
	CTypedPtrArray<CPtrArray, SUPPORTED_FORMAT_INFO*>	m_arrSupportedFormats;		// Collects the supported Wave-Audio formats for a Format Tag
};

#endif // __WAVECOMPRESSIONMANAGER_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\DLSDesigner\WaveCompressionPropPage.cpp ===
// WaveCompressionPropPage.cpp : implementation file
//

#include "stdafx.h"
#include "DLSDesignerDLL.h"

#include "dlsdesigner.h"
#include "WavePropPgMgr.h"
#include "Collection.h"
#include "WavENode.h"
#include "Wave.h"
#include "MonoWave.h"
#include "WaveCompressionManager.h"
#include "WaveCompressionPropPage.h"
#include "ProgressDialog.h"
#include "AdpcmLoopWarnDlg.h"


#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CWaveCompressionPropPage property page

IMPLEMENT_DYNCREATE(CWaveCompressionPropPage, CPropertyPage)

int CWaveCompressionPropPage::m_nLastCompressionType = 0;
int CWaveCompressionPropPage::m_nLastCompressionAttribute = 0;

CWaveCompressionPropPage::CWaveCompressionPropPage() : CPropertyPage(CWaveCompressionPropPage::IDD),
m_pWave(NULL),
m_bTypeCBClosed(true),	
m_bAttributesCBClosed(true),
m_fNeedToDetach(FALSE),
m_hConversionEvent(0)
{
	//{{AFX_DATA_INIT(CWaveCompressionPropPage)
	//}}AFX_DATA_INIT

	m_hConversionEvent = ::CreateEvent(NULL, TRUE, FALSE, "Conversion Complete");
}

CWaveCompressionPropPage::~CWaveCompressionPropPage()
{
	::CloseHandle(m_hConversionEvent);
}

void CWaveCompressionPropPage::DoDataExchange(CDataExchange* pDX)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	
	CPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CWaveCompressionPropPage)
	DDX_Control(pDX, IDC_NOPREROLL_CHECK, m_NoPrerollCheck);
	DDX_Control(pDX, IDC_DECOMPRESSEDDATASTART_STATIC2, m_DecompressedStartLabel2);
	DDX_Control(pDX, IDC_DECOMPRESSEDDATASTART_STATIC, m_DecompressedStartLabel);
	DDX_Control(pDX, IDC_DECOMPRESSEDDATASTART_EDIT, m_DecompressedStartEdit);
	DDX_Control(pDX, IDC_MS_STATIC, m_MSLabel);
	DDX_Control(pDX, IDC_READ_AHEAD_STATIC, m_ReadAheadLabel);
	DDX_Control(pDX, IDC_STREAM_CHECK, m_StreamCheck);
	DDX_Control(pDX, IDC_READAHEAD_SPIN, m_ReadAheadSpin);
	DDX_Control(pDX, IDC_READAHEAD_SAMPLES_STATIC, m_ReadAheadStatic);
	DDX_Control(pDX, IDC_READAHEAD_EDIT, m_ReadAheadEdit);
	DDX_Control(pDX, IDC_WAVE_SIZE, m_WaveSize);
	DDX_Control(pDX, IDC_COMPRESSION_RATIO, m_CompressionRatio);
	DDX_Control(pDX, IDC_COMBO1, m_TypeComboBox);
	DDX_Control(pDX, IDC_COMBO2, m_AttributesComboBox);
	//}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(CWaveCompressionPropPage, CPropertyPage)
	//{{AFX_MSG_MAP(CWaveCompressionPropPage)
	ON_WM_CREATE()
	ON_WM_DESTROY()
	ON_CBN_SELCHANGE(IDC_COMBO1, OnSelchangeCombo1)
	ON_BN_CLICKED(IDC_COMPRESSED, OnCompressed)
	ON_CBN_SELCHANGE(IDC_COMBO2, OnSelchangeCombo2)
	ON_CBN_CLOSEUP(IDC_COMBO1, OnCloseupCombo1)
	ON_CBN_CLOSEUP(IDC_COMBO2, OnCloseupCombo2)
	ON_CBN_DROPDOWN(IDC_COMBO2, OnDropdownCombo2)
	ON_CBN_DROPDOWN(IDC_COMBO1, OnDropdownCombo1)
	ON_BN_CLICKED(IDC_STREAM_CHECK, OnStreamCheck)
	ON_NOTIFY(UDN_DELTAPOS, IDC_READAHEAD_SPIN, OnDeltaposReadaheadSpin)
	ON_EN_KILLFOCUS(IDC_READAHEAD_EDIT, OnKillfocusReadaheadEdit)
	ON_EN_KILLFOCUS(IDC_DECOMPRESSEDDATASTART_EDIT, OnKillfocusDecompressedStartEdit)
	ON_BN_CLICKED(IDC_NOPREROLL_CHECK, OnNoprerollCheck)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CWaveCompressionPropPage message handlers and other functions

void CWaveCompressionPropPage::SetObject(CWave* pWave) 
{
	m_pWave = pWave;
}

int CWaveCompressionPropPage::OnCreate(LPCREATESTRUCT lpCreateStruct) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	// Attach the window to the property page structure.
	// This has been done once already in the main application
	// since the main application owns the property sheet.
	// It needs to be done here so that the window handle can
	// be found in the DLLs handle map.
	if(!FromHandlePermanent(m_hWnd))
	{
		HWND hWnd = m_hWnd;
		m_hWnd = NULL;
		Attach( hWnd );
	
		m_fNeedToDetach = TRUE;
	}

	if (CPropertyPage::OnCreate(lpCreateStruct) == -1)
		return -1;

	// create decompressed data start spinner
	// Note: I use UDS_SETBUDDYINT, because I set the max of the spinner to UD_MAXVAL (about 32K), even if the wave is bigger
	CRect rc;
	if (m_DecompressedStartSpin.Create(WS_CHILD | WS_VISIBLE | UDS_ARROWKEYS | UDS_NOTHOUSANDS | UDS_ALIGNRIGHT | UDS_SETBUDDYINT, rc, this, IDC_DECOMPRESSEDDATASTART_SPIN) == 0)
		return -1;

	return 0;
}

void CWaveCompressionPropPage::OnDestroy() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	// Detach the window from the property page structure.
	// This will be done again by the main application since
	// it owns the property sheet.  It needs o be done here
	// so that the window handle can be removed from the
	// DLLs handle map.
	if( m_fNeedToDetach && m_hWnd != NULL )
	{
		HWND hWnd = m_hWnd;
		Detach();
		m_hWnd = hWnd;
	}

	ClearTypeComboBox();
	ClearAttributesComboBox();

	CPropertyPage::OnDestroy();
}

BOOL CWaveCompressionPropPage::OnInitDialog()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	CPropertyPage::OnInitDialog();
	
	if(m_pWave)
	{
		// compression driver
		CWave::m_CompressionManager.GetSupportedDrivers();
		FillTypeComboBox();
	}

	// position up-down control
	m_DecompressedStartSpin.SetWindowPos(&m_DecompressedStartEdit, 0, 0, 0, 0, SWP_NOACTIVATE | SWP_NOMOVE | SWP_NOSIZE);
	m_DecompressedStartSpin.SetBuddy(&m_DecompressedStartEdit);

	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

void CWaveCompressionPropPage::FillTypeComboBox()
{
	int nDrivers = CWave::m_CompressionManager.m_arrFormatTags.GetSize();

	for(int nCount = 0; nCount < nDrivers; nCount++)
	{
		FORMAT_TAG_INF0* pFormatInfo = (FORMAT_TAG_INF0*)CWave::m_CompressionManager.m_arrFormatTags[nCount];
		ASSERT(pFormatInfo);

		// Get the wave node to check the format. We will not display the WMA format for stereo waves, not in a collection
		if (m_pWave)
			{
			CWaveNode* pWaveNode = m_pWave->GetNode();
			if ((NULL != pWaveNode) && 
				(false == pWaveNode->IsInACollection()) &&
				(MSAUDIO_FORMAT_TAG == pFormatInfo->dwFormatTag || WMAUDIO_FORMAT_TAG == pFormatInfo->dwFormatTag))
				continue;
			}

		int nIndex = m_TypeComboBox.AddString(pFormatInfo->sDriverName.GetBuffer(0));
		pFormatInfo->sDriverName.ReleaseBuffer();
		if(nIndex != CB_ERR)
		{
			int nResult  = m_TypeComboBox.SetItemDataPtr(nIndex, pFormatInfo);
			if(nResult == CB_ERR)
			{
				m_TypeComboBox.DeleteString(nIndex);
			}
		}
	}
}

BOOL CWaveCompressionPropPage::OnSetActive() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	InitializeDialogValues();
	return CPropertyPage::OnSetActive();
}

void CWaveCompressionPropPage::ClearTypeComboBox()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	
	int nCount = m_TypeComboBox.GetCount();

	if(nCount > 0) 
	{
		for(int i = 0; i < nCount; i++)
			m_TypeComboBox.DeleteString(i);
	}
}

// Go through the items in the types combo and set the selection to the passed format tag
void CWaveCompressionPropPage::SetSelectedCompressionType(WORD wFormatTag)
{
	int nTypesCount = m_TypeComboBox.GetCount();

	for(int nCount = 0; nCount < nTypesCount; nCount++)
	{
		FORMAT_TAG_INF0* pFormatTagInfo = (FORMAT_TAG_INF0*) m_TypeComboBox.GetItemDataPtr(nCount);
		
		if(pFormatTagInfo && pFormatTagInfo->dwFormatTag == wFormatTag)
		{
			m_TypeComboBox.SetCurSel(nCount);
			FillAttributesComboBox(pFormatTagInfo);
			return;
		}
	}
}


void CWaveCompressionPropPage::SetSelectedFormat(const WAVEFORMATEX* pWaveFormat)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	int nCount = m_AttributesComboBox.GetCount();

	for(int nIndex = 0; nIndex < nCount; nIndex++)
	{
		WAVEFORMATEX* pFormatInfo = (WAVEFORMATEX*) m_AttributesComboBox.GetItemDataPtr(nIndex);
		ASSERT(pFormatInfo);
		if(pFormatInfo == NULL)
		{
			return;
		}

		if(pFormatInfo->wFormatTag == pWaveFormat->wFormatTag &&
			pFormatInfo->wBitsPerSample == pWaveFormat->wBitsPerSample &&
			pFormatInfo->nChannels == pWaveFormat->nChannels &&
			pFormatInfo->nAvgBytesPerSec == pWaveFormat->nAvgBytesPerSec)
		{
			m_AttributesComboBox.SetCurSel(nIndex);
			return;
		}
	}
}



void CWaveCompressionPropPage::ClearAttributesComboBox()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	
	int nCount = m_AttributesComboBox.GetCount();
	
	if(nCount > 0)
	{
		for(int i = nCount - 1; i >= 0; i--)
		{
			m_AttributesComboBox.DeleteString(i);
		}
	}
}

void CWaveCompressionPropPage::FillAttributesComboBox(const FORMAT_TAG_INF0* pFormatInfo)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT(pFormatInfo != (const void *)-1);

	ClearAttributesComboBox();

	int nSupportedFormats = 0;
	if (pFormatInfo != NULL)
		{
		CWave::m_CompressionManager.GetSupportedFormats(pFormatInfo, m_pWave);
		nSupportedFormats = CWave::m_CompressionManager.m_arrSupportedFormats.GetSize();
		}

	if(nSupportedFormats == 0)
	{
		m_AttributesComboBox.AddString("No valid compression");
	}

	for(int nCount = 0; nCount < nSupportedFormats; nCount++)
	{
		SUPPORTED_FORMAT_INFO* pFormatInfo = (SUPPORTED_FORMAT_INFO*) CWave::m_CompressionManager.m_arrSupportedFormats[nCount];

		int nIndex = m_AttributesComboBox.AddString(pFormatInfo->sSupportedFormatName.GetBuffer(0));
		pFormatInfo->sSupportedFormatName.ReleaseBuffer();
		if(nIndex != CB_ERR)
		{
			int nResult = m_AttributesComboBox.SetItemDataPtr(nIndex, pFormatInfo->pWaveFormatEx);
			if(nResult == CB_ERR)
				m_AttributesComboBox.DeleteString(nIndex);
		}
	}

	m_AttributesComboBox.SetCurSel(0);
}


void CWaveCompressionPropPage::OnCompressed() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
    ASSERT(m_pWave);
    if (!m_pWave)
    	return;

	CWaveCtrl* pWaveEditor = m_pWave->GetWaveEditor();
	CButton *pCheckBox = (CButton*) GetDlgItem(IDC_COMPRESSED);
	int nChecked = pCheckBox->GetCheck();

	// Save the state for undo/redo
	if(FAILED(m_pWave->SaveUndoState(IDS_UNDO_COMPRESSION)))
	{
		pCheckBox->SetCheck(nChecked ? 0 : 1);
		return;
	}

	if(nChecked)
	{

#ifdef DMP_XBOX
		if( m_pWave->IsLooped() )
		{
			// Try and get the destination format
			WAVEFORMATEX* pwfxDst = NULL;
			int nCurSel = m_AttributesComboBox.GetCurSel();
			if(nCurSel != CB_ERR)
			{
				void* pvoid = m_AttributesComboBox.GetItemDataPtr(nCurSel);
				if(pvoid != (void *)-1 && pvoid != NULL)
				{
					pwfxDst = (LPWAVEFORMATEX)pvoid;
				}
			}

			WLOOP waveLoop = m_pWave->GetWLOOP();
			if( (waveLoop.ulStart % 64) != 0
			||	(waveLoop.ulLength % 64) != 0 )
			{
				// If there is a destination format and we're supposed to show the warning
				if( pwfxDst && !m_pWave->GetNode()->GetComponent()->IsNoShowBadXboxLoopWarning() )
				{
					CAdpcmLoopWarnDlg* pAdpcmLoopWarnDlg = new CAdpcmLoopWarnDlg(m_pWave->GetNode()->GetComponent(), m_pWave->m_rWaveformat.nSamplesPerSec, waveLoop.ulStart, waveLoop.ulLength, this);
					int nRes = pAdpcmLoopWarnDlg->DoModal();
					if( IDOK == nRes )
					{
						// We don't want stereo formats if the wave is not a TRUE stereo wave
						// But we want the stereo formats if it's a stereo wave NOT in a collection
						bool bIsStereo = m_pWave->GetNode()->IsStereo();
						CCollection* pCollection = m_pWave->GetNode()->GetCollection();

						// Modify the sample rate and insert silence
						if( XBADPCM_UPSAMPLE == pAdpcmLoopWarnDlg->m_xbChange )
						{
							CWaitCursor wait;
							m_pWave->Resample( pAdpcmLoopWarnDlg->m_dwUpsampleSampleRate );
							m_pWave->InsertSilence( 0, pAdpcmLoopWarnDlg->m_dwUpsampleInserted );

							// Change destination format to match new sample rate
							CreateXboxAdpcmFormat( (bIsStereo && pCollection == NULL) ? 2 : 1, pAdpcmLoopWarnDlg->m_dwUpsampleSampleRate, (LPIMAADPCMWAVEFORMAT)pwfxDst );
						}
						else if( XBADPCM_DOWNSAMPLE == pAdpcmLoopWarnDlg->m_xbChange )
						{
							CWaitCursor wait;
							m_pWave->Resample( pAdpcmLoopWarnDlg->m_dwDownsampleSampleRate );
							m_pWave->InsertSilence( 0, pAdpcmLoopWarnDlg->m_dwDownsampleInserted );

							// Change destination format to match new sample rate
							CreateXboxAdpcmFormat( (bIsStereo && pCollection == NULL) ? 2 : 1, pAdpcmLoopWarnDlg->m_dwDownsampleSampleRate, (LPIMAADPCMWAVEFORMAT)pwfxDst );
						}
					}
					delete pAdpcmLoopWarnDlg;
					if( IDOK != nRes )
					{
						pCheckBox->SetCheck(nChecked ? 0 : 1);
						return;
					}
				}
			}
		}
#endif // DMP_XBOX

		if (!Compress())
		{
			AfxMessageBox(IDS_ERR_COMPRESSION_FAILED, MB_OK | MB_ICONEXCLAMATION);

LFailed:
			// Couldn't compress successfully so set the compression off and Pop the undo state
            m_pWave->PopUndoState();
			pCheckBox = (CButton*) GetDlgItem(IDC_COMPRESSED); // window was refreshed
			pCheckBox->SetCheck(nChecked ? 0 : 1);
			EnableDecompressedStartControls();
			return;
		}
        
        // Look at and listen to the Decompressed wave
		if(FAILED(m_pWave->SwitchCompression(true)))
			goto LFailed;

		m_pWave->RevertToAfterCompression();

        if(FAILED(m_pWave->OnWaveBufferUpdated()))
        {
            if(m_pWave->IsLooped())
			{
				m_pWave->RevertToLoopBeforeCompression();
			}

            goto LFailed;
        }
	}
	else
	{
        
	 	// Look at and listen to the original wave now
		if(FAILED(m_pWave->SwitchCompression(false)))
			goto LFailed;

        // Remember the previous loop points
		// Update the loop points if it's looped...
		if(m_pWave->IsLooped())
		{
			m_pWave->RememberLoopAfterCompression();
			m_pWave->RevertToLoopBeforeCompression();
		}
		
        if(FAILED(m_pWave->OnWaveBufferUpdated()))
        {
		    m_pWave->RevertToAfterCompression();
            goto LFailed;
        }
	}

    m_pWave->UpdateLoopInRegions();
	SetCompressionInfo();

	EnableDecompressedStartControls();

	// remember compression setting for other waves
	if (nChecked)
		m_nLastCompressionType = m_TypeComboBox.GetCurSel();
}

void CWaveCompressionPropPage::OnSelchangeCombo1() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	
	BOOL bState = m_TypeComboBox.GetDroppedState();
	if(bState && m_bTypeCBClosed != true)
		return;

	int nCurSel = m_TypeComboBox.GetCurSel();

	// Has the compression entry changed?
	if(nCurSel == CB_ERR)
		return;

	// We need to see what attribute this compression format supports...
	FORMAT_TAG_INF0 *pfti = (FORMAT_TAG_INF0 *)m_TypeComboBox.GetItemDataPtr(nCurSel);
	FillAttributesComboBox(pfti);

	// if wave is not compressed, no more work to do
    if (!m_pWave->m_bCompressed)
    	return;

	// uncompress wave and ready it for new compression
    m_pWave->SaveUndoState(IDS_UNDO_COMPRESSION);
	if(FAILED(m_pWave->SwitchCompression(false)) || FAILED(m_pWave->OnWaveBufferUpdated()))
		{
        m_pWave->PopUndoState();

		// Out of memory??? We failed in updating the wave 
		// So revert back to the old selection
		m_TypeComboBox.SetCurSel(m_nLastCompressionType);
		return;
		}

	m_pWave->UpdateLoopInRegions();

    // turn off compression checkbox
	CButton* pCheckBox = (CButton*) GetDlgItem(IDC_COMPRESSED);
	if(pCheckBox)
		pCheckBox->SetCheck(0);

	m_nLastCompressionType = nCurSel;
	SetCompressionInfo();
}

void CWaveCompressionPropPage::OnSelchangeCombo2() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	ASSERT(m_pWave);
	if(m_pWave == NULL)
		return;

	BOOL bState = m_AttributesComboBox.GetDroppedState();
	if(bState && m_bAttributesCBClosed != true)
		return;

	int nCurSel = m_AttributesComboBox.GetCurSel();

	// Is the wave is already compressed with this attribute?
	if(nCurSel == m_nLastCompressionAttribute && m_pWave->m_bCompressed)
		return;

    m_pWave->SaveUndoState(IDS_UNDO_COMPRESSION);

	// we'll compress if uncompressed, or uncompressed if already compressed (in another format)
	bool bCompress = !m_pWave->m_bCompressed;

	// attempt to compress
	if (bCompress && !Compress())
		{
LFailed:
		if (bCompress)
	        AfxMessageBox(IDS_ERR_COMPRESSION_FAILED, MB_OK | MB_ICONEXCLAMATION);

        m_pWave->PopUndoState();
		m_AttributesComboBox.SetCurSel(m_nLastCompressionAttribute);
        return;
		}

	// switch compression state, download wave
    if (FAILED(m_pWave->SwitchCompression(bCompress)) || FAILED(m_pWave->OnWaveBufferUpdated()))
    	goto LFailed;
    	
    m_pWave->UpdateLoopInRegions();

	// update property page
    m_nLastCompressionAttribute = nCurSel;
    CButton* pCheckBox = (CButton*) GetDlgItem(IDC_COMPRESSED);
    if(pCheckBox)
	    pCheckBox->SetCheck(bCompress ? 1 : 0);
    SetCompressionInfo();
	EnableDecompressedStartControls();
				    
    // Give the focus back to this dropdown
    m_AttributesComboBox.SetFocus();
}

UINT AFX_CDECL UpdateControllingFunction( LPVOID pParam )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	HANDLE* phConversionEvent = (HANDLE*) pParam;

	CProgressDialog progressDlg;
	
	while(WaitForSingleObject(*phConversionEvent, 10) != WAIT_OBJECT_0)
	{
		progressDlg.m_ProgressBar.StepIt();
	}
	
	// Finish it!
	progressDlg.m_ProgressBar.SetPos(100);
	
	// Shoot yourself in the head...
	::AfxEndThread(0);

	return 0;
}



bool CWaveCompressionPropPage::Compress()
{
	ASSERT(m_pWave);

	// There's nothing to compress
	if(m_pWave == NULL)
		return false;

	CWaitCursor wait;
	ResetEvent(m_hConversionEvent);

	int nCurSel = m_AttributesComboBox.GetCurSel();
	if(nCurSel != CB_ERR)
	{
		void* pvoid = m_AttributesComboBox.GetItemDataPtr(nCurSel);
		if(pvoid != (void *)-1 && pvoid != NULL)
		{
			// Start the progress bar thread
			CWinThread* pUpdateThread = ::AfxBeginThread(UpdateControllingFunction, &m_hConversionEvent);
			pUpdateThread->m_bAutoDelete = TRUE;
			
			WAVEFORMATEX* pwfxDst = (LPWAVEFORMATEX)pvoid;

			ASSERT(pwfxDst->wFormatTag != 0);
			if(pwfxDst->wFormatTag == 0)
			{
				return false;
			}

			if(m_pWave->IsLooped())
			{
				m_pWave->RememberLoopBeforeCompression();
			}

			if(SUCCEEDED(m_pWave->Compress(pwfxDst)))
			{
				// Repaint the wave with new values
				CWaveCtrl* pWaveEditor = m_pWave->GetWaveEditor();
				if(pWaveEditor)
				{
					pWaveEditor->InvalidateControl(); 
				}

				// Set the checkbox to compressed...
				CButton *pCheckBox = (CButton*) GetDlgItem(IDC_COMPRESSED);
				if(pCheckBox)
				{
					pCheckBox->SetCheck(1);
				}

				
				::SetEvent(m_hConversionEvent);
				return true;
			}

			// Compression failed
			::SetEvent(m_hConversionEvent);
						
			CButton *pCheckBox = (CButton*) GetDlgItem(IDC_COMPRESSED);
			if(pCheckBox)
			{
				pCheckBox->SetCheck(0);
			}
		}
	}
	return false;
}


void CWaveCompressionPropPage::OnCloseupCombo1() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	m_bTypeCBClosed = true;
}

void CWaveCompressionPropPage::OnDropdownCombo1() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	m_bTypeCBClosed = false;	
}

void CWaveCompressionPropPage::OnCloseupCombo2() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	m_bAttributesCBClosed = true;
}

void CWaveCompressionPropPage::OnDropdownCombo2() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	m_bAttributesCBClosed = false;	
}


void CWaveCompressionPropPage::SetCompressionInfo()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	ASSERT(m_pWave);
	if(m_pWave == NULL)
		return;

	// Set the wave size text
	CString sWindowText;
	float fCompressionRatio = 1.0;
	DWORD dwWaveSize = m_pWave->GetUncompressedDataSize();

	if(m_pWave->m_bCompressed)
	{
		DWORD dwCompressedWaveSize = m_pWave->GetCompressedDataSize();
		if(dwCompressedWaveSize != 0)
		{
			fCompressionRatio = ((float)dwWaveSize / dwCompressedWaveSize);
			dwWaveSize = dwCompressedWaveSize;
		}
	}

	sWindowText.Format("%d bytes", dwWaveSize);
	m_WaveSize.SetWindowText(sWindowText);

	sWindowText.Format("1:%f", fCompressionRatio);
	m_CompressionRatio.SetWindowText(sWindowText);
}


void CWaveCompressionPropPage::InitializeDialogValues()
{
	if(m_pWave)
	{
		CButton* pCheckBox = (CButton*) GetDlgItem(IDC_COMPRESSED);

		if(pCheckBox)
		{
			if (m_pWave->m_bCompressed)
			{
				pCheckBox->SetCheck(1);
				
				// Set the selected compression to whatever was selected
				// Set from the format tag.
				SetSelectedCompressionType((WORD)m_pWave->GetCompressionFormatTag());
				
				WAVEFORMATEX wfxCompression;
				if(SUCCEEDED(m_pWave->GetCompressionFormat(&wfxCompression)))
				{
					SetSelectedFormat(&wfxCompression);
				}
			}
			else
			{
				pCheckBox->SetCheck(0);
				
				// Set the selected compression to whatever was selected in the last wave compresed
				// Set from the format tag.
				if(m_TypeComboBox.SetCurSel(m_nLastCompressionType) != CB_ERR)
                {
					FORMAT_TAG_INF0 *pfti = (FORMAT_TAG_INF0 *)m_TypeComboBox.GetItemDataPtr(m_nLastCompressionType);
				    FillAttributesComboBox(pfti);
				    m_AttributesComboBox.SetCurSel(m_nLastCompressionAttribute);
                }
			}

			m_DecompressedStartSpin.SetRange32(0, min(m_pWave->m_dwWaveLength, UD_MAXVAL));
			m_DecompressedStartSpin.SetPos(m_pWave->GetDwDecompressedStart(true));
			EnableDecompressedStartControls();
		}

		SetCompressionInfo();

		m_ReadAheadSpin.SetRange(MIN_READAHEAD, MAX_READAHEAD);
		CWaveNode* pWaveNode = m_pWave->GetNode();
		ASSERT(pWaveNode);
		
		m_StreamCheck.SetCheck(m_pWave->IsStreamingWave());
		m_NoPrerollCheck.SetCheck(m_pWave->IsNoPrerollWave());

		BOOL bEnableStreamingControls = pWaveNode->IsInACollection() ? FALSE : TRUE;
		EnableStreamingControls(bEnableStreamingControls);

		CString sReadAheadTime;
		DWORD dwReadAheadTime = m_pWave->GetReadAheadTime();
		sReadAheadTime.Format("%d", dwReadAheadTime);
		m_ReadAheadEdit.SetWindowText(sReadAheadTime);
		m_ReadAheadSpin.SetPos(dwReadAheadTime);
		
		UpdateReadAheadSamples(dwReadAheadTime);
	}
    
	CWavePropPgMgr::dwLastSelPage = WAVE_COMPRESSION_PAGE;
}

void CWaveCompressionPropPage::OnStreamCheck() 
{
	ASSERT(m_pWave);
	if(m_pWave == NULL)
	{
		return;
	}

	int nStreamCheck = m_StreamCheck.GetCheck();
	if(FAILED(m_pWave->SaveUndoState(IDS_UNDO_STREAMING)))
	{
		int nResetCheck = 0;
		if(nStreamCheck == 0)
		{
			nResetCheck = 1;
		}
		m_StreamCheck.SetCheck(nResetCheck);
		return;
	}

	BOOL bStream = nStreamCheck == 1 ? TRUE : FALSE;
	m_pWave->SetStreamingWave(bStream);
	m_pWave->SetDirtyFlag();
	EnableReadAheadControls(bStream);
}

void CWaveCompressionPropPage::OnNoprerollCheck() 
{
	ASSERT(m_pWave);
	if(m_pWave == NULL)
	{
		return;
	}

	int nNoPrerollCheck = m_NoPrerollCheck.GetCheck();
	if(FAILED(m_pWave->SaveUndoState(IDS_UNDO_NOPREROLL)))
	{
		int nResetCheck = 0;
		if(nNoPrerollCheck == 0)
		{
			nResetCheck = 1;
		}
		m_NoPrerollCheck.SetCheck(nResetCheck);
		return;
	}

	BOOL bNoPreroll = nNoPrerollCheck == 1 ? TRUE : FALSE;
	m_pWave->SetNoPrerollWave(bNoPreroll);
	m_pWave->SetDirtyFlag();
}

void CWaveCompressionPropPage::OnDeltaposReadaheadSpin(NMHDR* pNMHDR, LRESULT* pResult) 
{
	ASSERT(m_pWave);
	if(m_pWave == NULL)
	{
		return;
	}

	NM_UPDOWN* pNMUpDown = (NM_UPDOWN*)pNMHDR;
	
	OnKillfocusReadaheadEdit();
	
	*pResult = 0;
}

void CWaveCompressionPropPage::OnKillfocusReadaheadEdit() 
{
	ASSERT(m_pWave);
	if(m_pWave == NULL)
	{
		return;
	}

	CString sReadAhead;
	m_ReadAheadEdit.GetWindowText(sReadAhead);
	DWORD dwReadAheadTime = atoi(sReadAhead);
	if(dwReadAheadTime > MAX_READAHEAD)
	{
		dwReadAheadTime = MAX_READAHEAD;
	}
	else if(dwReadAheadTime < MIN_READAHEAD)
	{
		dwReadAheadTime = MIN_READAHEAD;
	}

	if(FAILED(m_pWave->SaveUndoState(IDS_UNDO_READAHEAD_TIME)))
	{
		dwReadAheadTime = m_pWave->GetReadAheadTime();
	}

	sReadAhead.Format("%d", dwReadAheadTime);
	m_ReadAheadEdit.SetWindowText(sReadAhead);

	m_pWave->SetReadAheadTime(dwReadAheadTime);
	m_pWave->SetDirtyFlag();
	UpdateReadAheadSamples(dwReadAheadTime);
}

void CWaveCompressionPropPage::EnableStreamingControls(BOOL bEnable)
{
	m_StreamCheck.EnableWindow(bEnable);
	if(bEnable == FALSE)
	{
		EnableReadAheadControls(bEnable);
	}
	else
	{
		int nStreamCheck = m_StreamCheck.GetCheck();
		BOOL bStream = nStreamCheck == 1 ? TRUE : FALSE;
		EnableReadAheadControls(bStream);
	}
}

void CWaveCompressionPropPage::EnableReadAheadControls(BOOL bEnable)
{
	m_ReadAheadEdit.EnableWindow(bEnable);
	m_ReadAheadSpin.EnableWindow(bEnable);
	m_ReadAheadStatic.EnableWindow(bEnable);
	m_ReadAheadLabel.EnableWindow(bEnable);
	m_MSLabel.EnableWindow(bEnable);
	m_NoPrerollCheck.EnableWindow(bEnable);
}

void CWaveCompressionPropPage::EnableDecompressedStartControls() 
{
	bool bEnable = m_pWave->FConsiderDecompressedStart();
	m_DecompressedStartSpin.EnableWindow(bEnable);
	m_DecompressedStartEdit.EnableWindow(bEnable);
	m_DecompressedStartLabel.EnableWindow(bEnable);
	m_DecompressedStartLabel2.EnableWindow(bEnable);
}

void CWaveCompressionPropPage::UpdateReadAheadSamples(DWORD dwReadAheadTime)
{
	ASSERT(m_pWave);
	if(m_pWave == NULL)
	{
		return;
	}

	DWORD dwSampleRatePerMS = m_pWave->m_rWaveformat.nSamplesPerSec / 1000;
	DWORD dwReadAheadSamples = 	dwReadAheadTime * dwSampleRatePerMS;

	CString sReadAheadSamples;
	sReadAheadSamples.Format("%d samples", dwReadAheadSamples);
	m_ReadAheadStatic.SetWindowText(sReadAheadSamples);
}

void CWaveCompressionPropPage::OnKillfocusDecompressedStartEdit() 
{
	ASSERT(m_pWave);
	if(m_pWave == NULL)
		return;

	// range checking
	if (FAILED(m_pWave->HrSetDecompressedStart(GetDlgItemInt(IDC_DECOMPRESSEDDATASTART_EDIT, NULL, FALSE))))
		SetDlgItemInt(IDC_DECOMPRESSEDDATASTART_EDIT, m_pWave->GetDwDecompressedStart(false));
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\DLSDesigner\WaveCompressionPropPage.h ===
#if !defined(AFX_WAVECOMPRESSIONPROPPAGE_H__395B7B27_C929_11D1_A876_00C04FA3726E__INCLUDED_)
#define AFX_WAVECOMPRESSIONPROPPAGE_H__395B7B27_C929_11D1_A876_00C04FA3726E__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// WaveCompressionPropPage.h : header file
//
#include "resource.h"
#include <mmsystem.h>
#include <mmreg.h>
#include <msacm.h>
#include "WaveCompressionManager.h"

class CWave;
class CWaveCompressionManager;

/////////////////////////////////////////////////////////////////////////////
// CWaveCompressionPropPage dialog

class CWaveCompressionPropPage : public CPropertyPage
{
	DECLARE_DYNCREATE(CWaveCompressionPropPage)

// Construction
public:
	CWaveCompressionPropPage();
	~CWaveCompressionPropPage();

	void SetObject(CWave* pWave);

	void FillAttributesComboBox(const FORMAT_TAG_INF0* pFormatInfo);
	void SetCompressionInfo();
	void InitializeDialogValues();


// Dialog Data
	//{{AFX_DATA(CWaveCompressionPropPage)
	enum { IDD = IDD_WAVE_COMPRESSION_PROP_PAGE };
	CButton	m_NoPrerollCheck;
	CStatic	m_DecompressedStartLabel2;
	CStatic	m_DecompressedStartLabel;
	CEdit	m_DecompressedStartEdit;
	CStatic	m_MSLabel;
	CStatic	m_ReadAheadLabel;
	CButton	m_StreamCheck;
	CSpinButtonCtrl	m_ReadAheadSpin;
	CStatic	m_ReadAheadStatic;
	CEdit	m_ReadAheadEdit;
	CStatic	m_WaveSize;
	CStatic	m_CompressionRatio;
	CComboBox	m_TypeComboBox;
	CComboBox	m_AttributesComboBox;
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CWaveCompressionPropPage)
	public:
	virtual BOOL OnSetActive();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CWaveCompressionPropPage)
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	afx_msg void OnDestroy();
	virtual BOOL OnInitDialog();
	afx_msg void OnSelchangeCombo1();
	afx_msg void OnCompressed();
	afx_msg void OnSelchangeCombo2();
	afx_msg void OnCloseupCombo1();
	afx_msg void OnCloseupCombo2();
	afx_msg void OnDropdownCombo2();
	afx_msg void OnDropdownCombo1();
	afx_msg void OnStreamCheck();
	afx_msg void OnDeltaposReadaheadSpin(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnKillfocusReadaheadEdit();
	afx_msg void OnKillfocusDecompressedStartEdit();
	afx_msg void OnNoprerollCheck();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

private:
	void	FillTypeComboBox();
	void	ClearTypeComboBox();
	void	ClearAttributesComboBox();
	bool	Compress();
	void	SetSelectedCompressionType(WORD wFormatTag);
	void	SetSelectedFormat(const WAVEFORMATEX* pWaveFormat);	
	void	EnableStreamingControls(BOOL bEnable = TRUE);
	void	EnableReadAheadControls(BOOL bEnable = TRUE);
	void	EnableDecompressedStartControls();
	void	UpdateReadAheadSamples(DWORD dwReadAheadTime);
	

//Attributes
private:
	static int m_nLastCompressionType;
	static int m_nLastCompressionAttribute;

public:
    CWave*	m_pWave;	 
	bool	m_bTypeCBClosed;	
	bool	m_bAttributesCBClosed;	

	BOOL	m_fNeedToDetach;
	HANDLE	m_hConversionEvent;

	CSpinButtonCtrl m_DecompressedStartSpin;
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_WAVECOMPRESSIONPROPPAGE_H__395B7B27_C929_11D1_A876_00C04FA3726E__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\DLSDesigner\WaveCtl.cpp ===
// =========================================================================
//  Implementation of the wave editor.
//
//  TODO: Change snaptpzero based on spec.
// =========================================================================
// WaveCtl.cpp : Implementation of the CWaveCtrl ActiveX Control class.

#include "stdafx.h"
#include "DLSDesignerDLL.h"
#include "WaveNode.h"
#include "Wave.h"
#include "WaveDataManager.h"
#include "WaveRefNode.h"
#include "MonoWave.h"
#include "WaveCtl.h"
#include "Collection.h"
#include "Instrument.h"
#include "Region.h"
#include "Articulation.h"
#include "Conductor.h"
#include "aboutdlg.h"
#include "WavePropPgMgr.h"
#include "waveproppg.h"
#include "RiffStrm.h"
#include "DLSDefsPlus.h"
#include <math.h>
#include "InsertSilenceDlg.h"
#include "ResampleDlg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


#define	ID_WAVE_PLAYBACK_TIMER		100
#define ID_WAVE_AUTOSCROLL_TIMER	ID_WAVE_PLAYBACK_TIMER + 1


IMPLEMENT_DYNCREATE(CWaveCtrl, COleControl)
/////////////////////////////////////////////////////////////////////////////
// Message map

BEGIN_MESSAGE_MAP(CWaveCtrl, COleControl)
	//{{AFX_MSG_MAP(CWaveCtrl)
	ON_WM_SIZE()
	ON_WM_CREATE()
	ON_WM_DESTROY()
	ON_COMMAND(ID_EDIT_REDO, OnEditRedo)
	ON_UPDATE_COMMAND_UI(ID_EDIT_REDO, OnUpdateEditRedo)
	ON_COMMAND(ID_EDIT_UNDO, OnEditUndo)
	ON_UPDATE_COMMAND_UI(ID_EDIT_UNDO, OnUpdateEditUndo)
	ON_WM_HSCROLL()
	ON_WM_DRAWITEM()
	ON_WM_LBUTTONDOWN()
	ON_WM_LBUTTONUP()
	ON_WM_MOUSEMOVE()
	ON_WM_CONTEXTMENU()
	ON_COMMAND(IDM_SNAP_TO_ZERO, OnSnapToZero)
	ON_WM_KEYDOWN()
	ON_WM_KEYUP()
	ON_COMMAND(IDM_SET_LOOP_FROM_SELECTION, OnSetLoopFromSelection)
	ON_COMMAND(IDM_PROPERTIES, OnProperties)
	ON_WM_SETFOCUS()
	ON_COMMAND(ID_APP_ABOUT, OnAppAbout)
	ON_UPDATE_COMMAND_UI(IDM_SET_LOOP_FROM_SELECTION, OnUpdateSetLoopFromSelection)
	ON_COMMAND(ID_EDIT_COPY, OnEditCopy)
	ON_UPDATE_COMMAND_UI(ID_EDIT_COPY, OnUpdateEditCopy)
	ON_COMMAND(IDM_COPY, OnCopy)
	ON_UPDATE_COMMAND_UI(IDM_COPY, OnUpdateCopy)
	ON_COMMAND(ID_EDIT_PASTE, OnEditPaste)
	ON_COMMAND(IDM_PASTE, OnPaste)
	ON_UPDATE_COMMAND_UI(ID_EDIT_PASTE, OnUpdateEditPaste)
	ON_UPDATE_COMMAND_UI(IDM_PASTE, OnUpdatePaste)
	ON_COMMAND(ID_EDIT_CUT, OnEditCut)
	ON_UPDATE_COMMAND_UI(ID_EDIT_CUT, OnUpdateEditCut)
	ON_COMMAND(IDM_CUT, OnCut)
	ON_UPDATE_COMMAND_UI(IDM_CUT, OnUpdateCut)
	ON_WM_KILLFOCUS()
	ON_WM_TIMER()
	ON_COMMAND(IDM_HELP_FINDER, OnHelpFinder)
	ON_WM_LBUTTONDBLCLK()
	ON_COMMAND(IDM_DELETE, OnDelete)
	ON_UPDATE_COMMAND_UI(IDM_DELETE, OnUpdateDelete)
	ON_COMMAND(ID_EDIT_DELETE, OnEditDelete)
	ON_UPDATE_COMMAND_UI(ID_EDIT_DELETE, OnUpdateEditDelete)
	ON_COMMAND(IDM_COPY_LOOP, OnCopyLoop)
	ON_COMMAND(IDM_WAVEEDITORREGION_FADE_IN, OnRegionFadeIn)
	ON_COMMAND(IDM_WAVEEDITORREGION_FADE_OUT, OnRegionFadeOut)
	ON_UPDATE_COMMAND_UI(IDM_WAVEEDITORREGION_FADE_IN, OnUpdateRegionFadeIn)
	ON_UPDATE_COMMAND_UI(IDM_WAVEEDITORREGION_FADE_OUT, OnUpdateRegionFadeOut)
	ON_UPDATE_COMMAND_UI(IDM_COPY_LOOP, OnUpdateCopyLoop)
	ON_COMMAND(ID_EDIT_SELECTALL, OnSelectAll)
	ON_UPDATE_COMMAND_UI(ID_EDIT_SELECTALL, OnUpdateSelectAll)
	ON_COMMAND(IDM_FIND_BEST_LOOP, OnFindBestLoop)
	ON_UPDATE_COMMAND_UI(IDM_FIND_BEST_LOOP, OnUpdateFindBestLoop)
	ON_UPDATE_COMMAND_UI(IDM_DECOMPRESS_START, OnUpdateDecompressStart)
	ON_WM_RBUTTONDOWN()
	ON_COMMAND(IDM_DECOMPRESS_START, OnDecompressStart)
	ON_COMMAND(IDM_INSERT_SILENCE, OnInsertSilence)
	ON_UPDATE_COMMAND_UI(IDM_INSERT_SILENCE, OnUpdateInsertSilence)
	ON_COMMAND(IDM_RESAMPLE, OnResample)
	ON_UPDATE_COMMAND_UI(IDM_RESAMPLE, OnUpdateResample)
	//}}AFX_MSG_MAP
	ON_OLEVERB(AFX_IDS_VERB_PROPERTIES, OnProperties)
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// Dispatch map

BEGIN_DISPATCH_MAP(CWaveCtrl, COleControl)
	//{{AFX_DISPATCH_MAP(CWaveCtrl)
	// NOTE - ClassWizard will add and remove dispatch map entries
	//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_DISPATCH_MAP
	DISP_FUNCTION_ID(CWaveCtrl, "AboutBox", DISPID_ABOUTBOX, AboutBox, VT_EMPTY, VTS_NONE)
END_DISPATCH_MAP()


/////////////////////////////////////////////////////////////////////////////
// Event map

BEGIN_EVENT_MAP(CWaveCtrl, COleControl)
	//{{AFX_EVENT_MAP(CWaveCtrl)
	// NOTE - ClassWizard will add and remove event map entries
	//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_EVENT_MAP
END_EVENT_MAP()

/////////////////////////////////////////////////////////////////////////////
// CWaveCtrl Interface map

BEGIN_INTERFACE_MAP(CWaveCtrl, COleControl)
    INTERFACE_PART(CWaveCtrl, IID_IOleInPlaceActiveObject, MyOleInPlaceActiveObject)
    INTERFACE_PART(CWaveCtrl, IID_IDMUSProdEditor, Editor)
END_INTERFACE_MAP()

/////////////////////////////////////////////////////////////////////////////
// Property pages

// TODO: Add more property pages as needed.  Remember to increase the count!
/*
BEGIN_PROPPAGEIDS(CWaveCtrl, 1)
END_PROPPAGEIDS(CWaveCtrl)
*/

/////////////////////////////////////////////////////////////////////////////
// Initialize class factory and guid

IMPLEMENT_OLECREATE_EX(CWaveCtrl, "DLS Designer.WaveCtrl.1",
	0xbc964e8e, 0x96f7, 0x11d0, 0x89, 0xaa, 0, 0xa0, 0xc9, 0x5, 0x41, 0x29)


/////////////////////////////////////////////////////////////////////////////
// Type library ID and version

IMPLEMENT_OLETYPELIB(CWaveCtrl, _tlid, _wVerMajor, _wVerMinor)


/////////////////////////////////////////////////////////////////////////////
// Interface IDs

const IID BASED_CODE IID_DWave =
		{ 0xbc964e8c, 0x96f7, 0x11d0, { 0x89, 0xaa, 0, 0xa0, 0xc9, 0x5, 0x41, 0x29 } };
const IID BASED_CODE IID_DWaveEvents =
		{ 0xbc964e8d, 0x96f7, 0x11d0, { 0x89, 0xaa, 0, 0xa0, 0xc9, 0x5, 0x41, 0x29 } };


/////////////////////////////////////////////////////////////////////////////
// Control type information

static const DWORD BASED_CODE _dwWaveOleMisc =
	OLEMISC_ACTIVATEWHENVISIBLE |
	OLEMISC_SETCLIENTSITEFIRST |
	OLEMISC_INSIDEOUT |
	OLEMISC_CANTLINKINSIDE |
	OLEMISC_RECOMPOSEONRESIZE |
	OLEMISC_SIMPLEFRAME;

IMPLEMENT_OLECTLTYPE(CWaveCtrl, IDS_WAVE, _dwWaveOleMisc)


/////////////////////////////////////////////////////////////////////////////
// CWaveCtrl::CWaveCtrlFactory::UpdateRegistry -
// Adds or removes system registry entries for CWaveCtrl

BOOL CWaveCtrl::CWaveCtrlFactory::UpdateRegistry(BOOL bRegister)
{
	// TODO: Verify that your control follows apartment-model threading rules.
	// Refer to MFC TechNote 64 for more information.
	// If your control does not conform to the apartment-model rules, then
	// you must modify the code below, changing the 6th parameter from
	// afxRegApartmentThreading to 0.

	if (bRegister)
		return AfxOleRegisterControlClass(
			AfxGetInstanceHandle(),
			m_clsid,
			m_lpszProgID,
			IDS_WAVE,
			IDB_WAVE,
			afxRegApartmentThreading,
			_dwWaveOleMisc,
			_tlid,
			_wVerMajor,
			_wVerMinor);
	else
		return AfxOleUnregisterClass(m_clsid, m_lpszProgID);
}


/////////////////////////////////////////////////////////////////////////////
// CWaveCtrl::CWaveCtrl - Constructor

CWaveCtrl::CWaveCtrl() : 
m_pWave(NULL),
m_pWaveNode(NULL),
m_pDummyInstrument(NULL),
m_hMenuInPlace(NULL),
m_hAcceleratorTable(NULL),
m_hKeyStatusBar(NULL),
m_hSIZEWECursor(NULL),
m_hSizeLoopStartCursor(NULL),
m_hSizeLoopEndCursor(NULL),
m_hPrevCursor(NULL),
m_bSizeCursorSet(false),
m_bInSelMode(false),
m_bDraggingLoop(false),
m_nDragDir(_NONE),
m_pRMenu(NULL),
m_dwCookie(0),
m_pClipboardDataObject(NULL),
m_dwMaxScrollPos(0),
m_nSamplesPerPixelBeforeZoom(0),
m_nSnapStart(0),
m_nSnapEnd(0),
m_nStartSel(0),
m_nEndSel(0)
{
/////////////////////////////////////////////////////////////////////////
// Following commented out to prevent 3 ASSERTS that occur
// because we are not building a typelib
//	InitializeIIDs(&IID_DWave, &IID_DWaveEvents);
//
// Following code copied from InitializeIIDs (since we cannot override)
	m_piidPrimary = &IID_DWave;
	m_piidEvents = &IID_DWaveEvents;
	EnableTypeLib();	// Needed to prevent ASSERT when closing editor
	InitStockEventMask();
	InitStockPropMask();
//////////////////////////////////////////////////////////////////////////

	EnableSimpleFrame();
    m_nxSampleOffset = 0;
    m_nZoomFactor = 0xFF;	// Default zoom is 1:8.
    m_nSamplesPerPixel = 8; // Default is 8 samples per pixel.

	for(int i = 0; i < 128; i++)
	{
		m_nMIDINoteOns[i] = 0;
	}

	m_nPlaybackPos = 0;
	m_uiTimer = 0;
}   


/////////////////////////////////////////////////////////////////////////////
// CWaveCtrl::~CWaveCtrl - Destructor

CWaveCtrl::~CWaveCtrl()
{
    // We had done an extra addref on the wave node 
	if(m_pWave)
	{
		m_pWaveNode->Release();
	}

	if( m_pClipboardDataObject != NULL)
	{
		if( S_OK == OleIsCurrentClipboard( m_pClipboardDataObject ))
		{
			OleFlushClipboard();
		}
		m_pClipboardDataObject->Release();
	}

	// free cursors
	if (m_bSizeCursorSet)
		SetCursor(m_hPrevCursor);
	if (m_hSizeLoopStartCursor != NULL)
		DestroyCursor(m_hSizeLoopStartCursor);
	if (m_hSizeLoopEndCursor != NULL)
		DestroyCursor(m_hSizeLoopEndCursor);
}


/////////////////////////////////////////////////////////////////////////////
// CWaveCtrl IDMUSProdEditor implementation

/////////////////////////////////////////////////////////////////////////////
// CWaveCtrl::XEditor::AddRef

STDMETHODIMP_(ULONG) CWaveCtrl::XEditor::AddRef()
{
	METHOD_PROLOGUE_EX_( CWaveCtrl, Editor )

	return (ULONG)pThis->ExternalAddRef();
}


/////////////////////////////////////////////////////////////////////////////
// CWaveCtrl::XEditor::Release

STDMETHODIMP_(ULONG) CWaveCtrl::XEditor::Release()
{
	METHOD_PROLOGUE_EX_( CWaveCtrl, Editor )

	return (ULONG)pThis->ExternalRelease();
}


/////////////////////////////////////////////////////////////////////////////
// CWaveCtrl::XEditor::QueryInterface

STDMETHODIMP CWaveCtrl::XEditor::QueryInterface( REFIID iid, LPVOID* ppvObj )
{
	METHOD_PROLOGUE_EX_( CWaveCtrl, Editor )

	return (HRESULT)pThis->ExternalQueryInterface( &iid, ppvObj );
}


/////////////////////////////////////////////////////////////////////////////
// CWaveCtrl::XEditor::AttachObjects implementation

HRESULT CWaveCtrl::XEditor::AttachObjects(IDMUSProdNode* pNode)
{
	METHOD_MANAGE_STATE( CWaveCtrl, Editor )

	ASSERT_VALID( pThis );
	ASSERT( pNode != NULL );

	GUID guidNode;

	pNode->GetNodeId( &guidNode );
	if( ::IsEqualGUID( guidNode, GUID_WaveRefNode ) )
	{
		CWaveRefNode* pWaveRefNode = (CWaveRefNode *)pNode;
		ASSERT( pWaveRefNode->m_pWaveNode != NULL );
		pThis->m_pWaveNode = pWaveRefNode->m_pWaveNode;
	}
	else
	{
		pThis->m_pWaveNode = (CWaveNode*) pNode;
	}
	
	pThis->m_pWave = pThis->m_pWaveNode->GetWave();
	pThis->m_pWaveNode->AddRef();

	return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
// CInstrumentCtrl::XEditor::OnViewProperties implementation

HRESULT CWaveCtrl::XEditor::OnViewProperties()
{
	METHOD_MANAGE_STATE( CWaveCtrl, Editor )
	ASSERT_VALID( pThis );
	if (pThis->m_pWaveNode)
    {
        return pThis->m_pWaveNode->OnViewProperties();
    }
	return E_NOTIMPL;
}

/////////////////////////////////////////////////////////////////////////////
// CWaveCtrl::XEditor::OnInitMenuFilePrint

HRESULT CWaveCtrl::XEditor::OnInitMenuFilePrint( HMENU hMenu, UINT nMenuId )
{
	METHOD_MANAGE_STATE( CWaveCtrl, Editor )

	::EnableMenuItem( hMenu, nMenuId, (MF_GRAYED | MF_BYCOMMAND) );

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CWaveCtrl::XEditor::OnFilePrint

HRESULT CWaveCtrl::XEditor::OnFilePrint( void )
{
	METHOD_MANAGE_STATE( CWaveCtrl, Editor )

	return E_NOTIMPL;
}


/////////////////////////////////////////////////////////////////////////////
// CWaveCtrl::XEditor::OnInitMenuFilePrintPreview

HRESULT CWaveCtrl::XEditor::OnInitMenuFilePrintPreview( HMENU hMenu, UINT nMenuId )
{
	METHOD_MANAGE_STATE( CWaveCtrl, Editor )

	::EnableMenuItem( hMenu, nMenuId, (MF_GRAYED | MF_BYCOMMAND) );

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CWaveCtrl::XEditor::OnFilePrintPreview

HRESULT CWaveCtrl::XEditor::OnFilePrintPreview( void )
{
	METHOD_MANAGE_STATE( CWaveCtrl, Editor )

	return E_NOTIMPL;
}


/////////////////////////////////////////////////////////////////////////////
// CWaveCtrl::XEditor::OnF1Help implementation

HRESULT CWaveCtrl::XEditor::OnF1Help()
{
	METHOD_MANAGE_STATE( CWaveCtrl, Editor )
	ASSERT_VALID( pThis );
	
    // Determine name of DMUSProd.exe help file
	CString strHelpFileName;

	if( theApp.GetHelpFileName( strHelpFileName ) )
	{
		strHelpFileName += "::/htm/WaveEditor.htm";
		::HtmlHelp( NULL, strHelpFileName, HH_DISPLAY_TOPIC, 0 );
	}
	
	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
// CWaveCtrl::XMyOleInPlaceActiveObject implementation

STDMETHODIMP_(ULONG) CWaveCtrl::XMyOleInPlaceActiveObject::AddRef()
{
	METHOD_MANAGE_STATE( CWaveCtrl, MyOleInPlaceActiveObject )
	ASSERT_VALID( pThis );

	return (ULONG)pThis->ExternalAddRef();
}

STDMETHODIMP_(ULONG) CWaveCtrl::XMyOleInPlaceActiveObject::Release()
{
	METHOD_MANAGE_STATE( CWaveCtrl, MyOleInPlaceActiveObject )
	ASSERT_VALID( pThis );

	return (ULONG)pThis->ExternalRelease();
}

STDMETHODIMP CWaveCtrl::XMyOleInPlaceActiveObject::QueryInterface( REFIID iid, LPVOID* ppvObj )
{
	METHOD_MANAGE_STATE( CWaveCtrl, MyOleInPlaceActiveObject )
	ASSERT_VALID( pThis );

	return (HRESULT)pThis->ExternalQueryInterface( &iid, ppvObj );
}

STDMETHODIMP CWaveCtrl::XMyOleInPlaceActiveObject::GetWindow( HWND* lphwnd )
{
	METHOD_MANAGE_STATE( CWaveCtrl, MyOleInPlaceActiveObject )
	ASSERT_VALID( pThis );

	return pThis->m_xOleInPlaceActiveObject.GetWindow( lphwnd );
}

STDMETHODIMP CWaveCtrl::XMyOleInPlaceActiveObject::ContextSensitiveHelp( BOOL fEnterMode )
{
	METHOD_MANAGE_STATE( CWaveCtrl, MyOleInPlaceActiveObject )
	ASSERT_VALID( pThis );

	return pThis->m_xOleInPlaceActiveObject.ContextSensitiveHelp( fEnterMode );
}

STDMETHODIMP CWaveCtrl::XMyOleInPlaceActiveObject::TranslateAccelerator( LPMSG lpmsg )
{
	METHOD_MANAGE_STATE( CWaveCtrl, MyOleInPlaceActiveObject )
	ASSERT_VALID( pThis );
	
	// Translate only if the wavectrl has the focus
	CWnd* pWnd = pThis->GetFocus();
	if(pWnd == pThis || pThis->IsChild(pWnd))
	{
		if( ::TranslateAccelerator(pThis->m_hWnd, pThis->m_hAcceleratorTable, lpmsg) )
		{
			return S_OK;
		}
	}

	return S_FALSE;
}

STDMETHODIMP CWaveCtrl::XMyOleInPlaceActiveObject::OnFrameWindowActivate( BOOL fActivate )
{
	METHOD_MANAGE_STATE( CWaveCtrl, MyOleInPlaceActiveObject )
	ASSERT_VALID( pThis );

	CDLSComponent* pComponent = pThis->m_pWaveNode->GetComponent();
	ASSERT(pComponent);
	
	if ( !fActivate )
	{
		if (pThis->m_bSizeCursorSet)
		{
			pThis->ReleaseCapture();
			pThis->m_bInSelMode = false;
        
			pThis->SetSizeCursor(false);    
			pThis->m_nDragDir = _NONE;
			pThis->InvalidateRect(NULL);
		}
	}
	
	return pThis->m_xOleInPlaceActiveObject.OnFrameWindowActivate( fActivate );
}

STDMETHODIMP CWaveCtrl::XMyOleInPlaceActiveObject::OnDocWindowActivate( BOOL fActivate )
{
	METHOD_MANAGE_STATE( CWaveCtrl, MyOleInPlaceActiveObject )
	ASSERT_VALID( pThis );

	CDLSComponent* pComponent = pThis->m_pWaveNode->GetComponent();
	ASSERT(pComponent);

	if ( fActivate )
	{
		pThis->m_pWaveNode->OnViewProperties();
		pThis->SetFocus();
	}
	else
	{
		if (pThis->m_bSizeCursorSet)
		{
			pThis->ReleaseCapture();
			pThis->m_bInSelMode = false;
        
			pThis->SetSizeCursor(false);    
			pThis->m_nDragDir = _NONE;
			pThis->InvalidateRect(NULL);
		}

	}
	return pThis->m_xOleInPlaceActiveObject.OnDocWindowActivate( fActivate );
}

STDMETHODIMP CWaveCtrl::XMyOleInPlaceActiveObject::ResizeBorder(
	LPCRECT, LPOLEINPLACEUIWINDOW, BOOL fFrameWindow )
{
	METHOD_MANAGE_STATE( CWaveCtrl, MyOleInPlaceActiveObject )
	ASSERT_VALID( pThis );

    if( fFrameWindow == TRUE)
	{
		pThis->OnShowToolBars();
	}

	return S_OK;
}

STDMETHODIMP CWaveCtrl::XMyOleInPlaceActiveObject::EnableModeless( BOOL fEnable )
{
	METHOD_MANAGE_STATE( CWaveCtrl, MyOleInPlaceActiveObject )
	ASSERT_VALID( pThis );

	return pThis->m_xOleInPlaceActiveObject.EnableModeless( fEnable );
}

// ==========================================================================
// CWaveCtrl::OnDraw - Drawing function
// ==========================================================================
void CWaveCtrl::OnDraw(CDC* pdc, const CRect& rcBounds, const CRect& rcInvalid)
{			
	AFX_MANAGE_STATE(_afxModuleAddrThis);
    ASSERT(pdc);
	
	CBitmap	bmBlank;
	CRect rcClientArea, rcScrollBar;
	
	GetClientRect(&rcClientArea);
	if(m_HScrollBar)
	{
		m_HScrollBar.GetWindowRect(&rcScrollBar);
		rcClientArea.bottom -= (rcScrollBar.bottom - rcScrollBar.top);
	}

	if (rcClientArea.Width() <= 0 || rcClientArea.Height() <= 0) 
	{
		// Avoid division by zero; don't bother drawing anything
		return;
	}
	
	BOOL bStatus = bmBlank.CreateCompatibleBitmap(pdc, rcClientArea.right, rcClientArea.bottom);
    ASSERT(bStatus);

	// Create a memory dc so that we can draw by doing one blt to the screen.
	CDC memdc;
    bStatus = memdc.CreateCompatibleDC(pdc);
    ASSERT(bStatus);

    // Select an empty bitmap into the dc. 
	CBitmap* pOldbm = memdc.SelectObject(&bmBlank);

    // Draw the WHITE background. 
	memdc.FillSolidRect(rcBounds, RGB(255, 255, 255));

	CRect rcWave = rcClientArea;

	// Fill the area BEFORE the decompressed start of the wave (if compressed) with GRAY
	DWORD dwDecompressedStart = m_pWave->GetDwDecompressedStart(true);
	if (dwDecompressedStart > 0)
		{
		// gray background
		int xRectRight = SampleToPixel(dwDecompressedStart, false);
		if (xRectRight >= rcBounds.left)
			memdc.FillSolidRect(rcBounds.left, rcBounds.top, xRectRight, rcBounds.bottom, GetSysColor(COLOR_BTNFACE));
		}
	
	// Fill the area AFTER the end of the wave with GRAY
	DWORD dwLength= m_pWave->m_dwWaveLength - 1;
	DWORD dwRectLeft = 0;
	if((int)dwLength >= 1)
	{
		dwRectLeft = SampleToPixel(dwLength, false);
	}

	if((int)dwRectLeft < rcBounds.right)
	{
		CRect rectGray(dwRectLeft, rcBounds.top, rcBounds.right, rcBounds.bottom);
		memdc.FillSolidRect(rectGray, GetSysColor(COLOR_BTNFACE));
		rcWave.SubtractRect(&rcWave, &rectGray);
	}

    int nStart = SampleToPixel(m_nStartSel, true);
    int nEnd = SampleToPixel(m_nEndSel, true);

    // If we have a region selected, draw it.    
    if(nStart != nEnd) 
    {
		int nSelectionStart = nStart;
		int nSelectionEnd = nEnd;

		if(nStart > rcClientArea.right)
		{
			nSelectionStart = rcWave.right;
		}
		if(nEnd > rcClientArea.right)
		{
			nSelectionEnd = rcWave.right;
		}

        CRect rect(nSelectionStart, 0, nSelectionEnd, rcWave.bottom);
        memdc.FillSolidRect(&rect, PALETTERGB(255, 0, 0));
    }
    else
    {
		// Draw selection cursor
        if (nStart)
			memdc.FillSolidRect(nStart, 0, 1, rcWave.bottom, RGB(255, 0, 0));
    }

	// Ask the wave to draw
	m_pWaveNode->DrawWave(&memdc, rcWave);

    // Draw the loop start and end points.
	if (m_bDraggingLoop)
		{
		// draw loop point being dragged
		DrawLoopCursor(memdc, PS_DASH, m_ptDraggedLoop.x, m_nDragDir);

		// if loop length is locked, draw both markers (fix 48682)
		if (m_pWave->m_pWavePropPgMgr && m_pWave->m_pWavePropPgMgr->m_pWavePage && m_pWave->m_pWavePropPgMgr->m_pWavePage->IsLoopLengthLocked())
			{
			// compute delta for other loop point
			WLOOP waveLoop = m_pWave->GetWLOOP();
			int nLoopLength = waveLoop.ulLength;
			if (m_nDragDir == _END)
				nLoopLength = -nLoopLength;

			// draw it
			DrawLoopCursor(memdc, PS_DASH,
				SampleToPixel(PixelToSample(m_ptDraggedLoop.x, true)+nLoopLength, true),
				(m_nDragDir == _START) ? _END : _START);
			}
		}

	DrawLoopPoints(&memdc);

    // Blt the memdc to the screen
	bStatus = pdc->BitBlt(0, 0, rcClientArea.right, rcClientArea.bottom, &memdc, 0, 0, SRCCOPY);

    ASSERT(bStatus);
 	
	// Select the GDI Objects out of the memory DC and delete it
	memdc.SelectObject(pOldbm); 
    bStatus = memdc.DeleteDC(); 
    ASSERT(bStatus);

    UpdateStatusBar();
	
	CRect rectTemp = rcInvalid;
	UpdatePlaybackPos(0, &rectTemp);
}



/////////////////////////////////////////////////////////////////////////////
// CWaveCtrl::DoPropExchange - Persistence support

void CWaveCtrl::DoPropExchange(CPropExchange* pPX)
{
    AFX_MANAGE_STATE(_afxModuleAddrThis);

	ExchangeVersion(pPX, MAKELONG(_wVerMinor, _wVerMajor));
	COleControl::DoPropExchange(pPX);

	// TODO: Call PX_ functions for each persistent custom property.

}


/////////////////////////////////////////////////////////////////////////////
// CWaveCtrl::AboutBox - Display an "About" box to the user

void CWaveCtrl::AboutBox()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	CDialog dlgAbout(IDD_ABOUTBOX_WAVE);
	dlgAbout.DoModal();
}


/////////////////////////////////////////////////////////////////////////////
// CWaveCtrl message handlers

void CWaveCtrl::OnSize(UINT nType, int cx, int cy) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	COleControl::OnSize(nType, cx, cy);
    
	// Move the scrollbar
    RECT rc;
    GetClientRect(&rc);
    int nHeight = GetSystemMetrics(SM_CYHSCROLL);
    rc.bottom = cy;
    rc.right = cx - 2*nHeight;
    rc.top = cy-nHeight;
    rc.left = 0;
    m_HScrollBar.MoveWindow(&rc, true);
    
	// Calc the range of scrollbar.
    ResetScrollBar();

    // Move the buttons also. CButton derives from CWnd.
    rc.left = rc.right; //from previous
    rc.right = rc.left + nHeight;
    m_BtnZoomIn.MoveWindow(&rc, true);

    // Now the second button.
    rc.left = rc.right;
    rc.right = cx;
    m_BtnZoomOut.MoveWindow(&rc, true);

	// Keep zoom within limits
	SetZoomFactor(m_nZoomFactor);

	// CONSIDER: Do all these movewindows need to set repaint = true or only the
    // last one?
}

// =============================================================================
//  OnCreate
// =============================================================================
int CWaveCtrl::OnCreate(LPCREATESTRUCT lpCreateStruct) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

    if (COleControl::OnCreate(lpCreateStruct) == -1)
		return -1;

	CDLSComponent* pComponent = m_pWaveNode->GetComponent();
	ASSERT(pComponent);

    ASSERT(m_pWave);

    // Plug in the pointer to this wavectrl in the wave.
    m_pWaveNode->SetWaveEditor(this);

    // Set the Looped mode in the wave. default is true if loops set else it's 
    // whatever the person asked for in property page.
    m_pWave->m_bPlayLooped = (m_pWave->m_rWSMP.cSampleLoops != 0);

	// Load control's in-place menu
	m_hMenuInPlace = ::LoadMenu(theApp.m_hInstance, MAKEINTRESOURCE(IDM_DLS_DESIGNER));

    // load the right click menu

	m_pRMenu = new CMenu();
	if (m_pRMenu)
    {
        if ( m_pRMenu->LoadMenu(IDM_WAVE_EDITOR_REGION_RMENU))
        {   //loaded successfully
			if(pComponent->IsSnapToZero() == TRUE)
				m_pRMenu->CheckMenuItem(IDM_SNAP_TO_ZERO, MF_CHECKED);
			else
				m_pRMenu->CheckMenuItem(IDM_SNAP_TO_ZERO, MF_UNCHECKED);

        }
        else
        {
            delete m_pRMenu;
            m_pRMenu = NULL;
        }
    }
	
	// Create the horizontal scrollbar.
    RECT rc;
    int nHeight = GetSystemMetrics(SM_CYHSCROLL);
    rc.top = rc.left = 0;
    rc.right = lpCreateStruct->cx - 2*nHeight;
    rc.bottom = lpCreateStruct->cy;
	
	CStatic hiddenStatic;
	hiddenStatic.Create("", WS_CHILD, rc, this);

    m_HScrollBar.Create(WS_CHILD | WS_VISIBLE | SBS_HORZ | SBS_BOTTOMALIGN, 
                            rc, this, IDC_HSCROLLBAR);

    // Create the zoomin-out buttons then Load the bitmaps
    rc.right = rc.bottom = nHeight;
	m_BtnZoomIn.Create( "+", BS_OWNERDRAW | BS_PUSHBUTTON | WS_CHILD | WS_VISIBLE, rc, this, BTN_ZOOMIN );
    m_BtnZoomIn.LoadBitmaps( IDB_ZOOMIN, IDB_ZOOMINDOWN );

	m_BtnZoomOut.Create( "-", BS_OWNERDRAW | BS_PUSHBUTTON | WS_CHILD | WS_VISIBLE, rc, this, BTN_ZOOMOUT );
    m_BtnZoomOut.LoadBitmaps( IDB_ZOOMOUT, IDB_ZOOMOUTDOWN );
             
    // Create the default status string.
    SetupDefaultStatusText();
	
    m_hAcceleratorTable = LoadAccelerators(AfxGetInstanceHandle(),MAKEINTRESOURCE(IDR_DLS_ACCELERATOR));

	// Do the necessary things with the property page
	IDMUSProdPropSheet* pIPropSheet = NULL;
	if(SUCCEEDED(pComponent->m_pIFramework->QueryInterface(IID_IDMUSProdPropSheet, (void**)&pIPropSheet)))
	{
		if(pIPropSheet->IsShowing() == S_OK && pIPropSheet->IsEqualPageManagerObject(m_pWave) == S_OK)
		{
			// Change the wave property page if it's up.
			if (m_pWave->m_pWavePropPgMgr && m_pWave->m_pWavePropPgMgr->m_pWavePage)
			{
				m_pWave->m_pWavePropPgMgr->m_pWavePage->EnableSelectionControls(true);
			}
		}

		RELEASE(pIPropSheet);
	}

	// Set the timer for autoscroll
	SetTimer(ID_WAVE_AUTOSCROLL_TIMER, 10, NULL);

    return 0;
}

// =============================================================================
//  OnDestroy
// =============================================================================
void CWaveCtrl::OnDestroy() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	COleControl::OnDestroy();

	ASSERT(m_pWaveNode->GetComponent());

	if(m_hMenuInPlace)
	{
		::DestroyMenu(m_hMenuInPlace);
		m_hMenuInPlace = NULL;
	}

	// delete the context menu
	if (m_pRMenu)
	{
		delete m_pRMenu;
	}

	// Unplug in the pointer to this wavectrl in the wave.
	m_pWaveNode->SetWaveEditor(NULL);
}

// =============================================================================
//  OnCreate
// =============================================================================
HMENU CWaveCtrl::OnGetInPlaceMenu() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	return m_hMenuInPlace;
}

void CWaveCtrl::OnEditRedo() 
{
    AFX_MANAGE_STATE(_afxModuleAddrThis);

	// No Wave?
	ASSERT(m_pWave);
	if(m_pWave == NULL)
	{
		return;
	}

	if(FAILED(m_pWave->Redo()))
	{
		return;
	}

	SetupDefaultStatusText();
	
    m_pWave->OnWaveBufferUpdated();
	
	m_pWave->RefreshPropertyPage();
	SetSelectionBounds();
	UpdateSelectionInPropertyPage();
	UpdateLoopInPropertyPage();

	m_nSamplesPerPixelBeforeZoom = m_nSamplesPerPixel;
	ResetScrollBar();
	InvalidateRect(NULL);
}

void CWaveCtrl::OnUpdateEditRedo(CCmdUI* pCmdUI) 
{
	CString		csMenuText,csShortCut;

	AFX_MANAGE_STATE(_afxModuleAddrThis);
	
	csMenuText.LoadString(IDS_REDO_MENU_TEXT);
	csShortCut.LoadString(IDS_REDO_SHORTCUT_TEXT);

	ASSERT(m_pWave);
	if(m_pWave == NULL)
	{
		return;
	}
	
    CString sStateName = m_pWave->GetUndoMenuText(true);
	if(!sStateName.IsEmpty())
	{
		pCmdUI->Enable(TRUE);
		pCmdUI->SetText(csMenuText + _T(" ") + sStateName + csShortCut);
	}
	else 
	{
		pCmdUI->Enable(FALSE);
		pCmdUI->SetText(csMenuText + csShortCut);
	}
}

void CWaveCtrl::OnEditUndo() 
{
    AFX_MANAGE_STATE(_afxModuleAddrThis);
	
	// No Wave?
	ASSERT(m_pWave);
	if(m_pWave == NULL)
	{
		return;
	}

	if(FAILED(m_pWave->Undo()))
	{
		return;
	}
	
	SetupDefaultStatusText();
		
    m_pWave->OnWaveBufferUpdated();

	m_pWave->RefreshPropertyPage();
	SetSelectionBounds();
	UpdateSelectionInPropertyPage();
	UpdateLoopInPropertyPage();

	m_nSamplesPerPixelBeforeZoom = m_nSamplesPerPixel;
	ResetScrollBar();
	InvalidateRect(NULL);
}

void CWaveCtrl::OnUpdateEditUndo(CCmdUI* pCmdUI) 
{
	CString		csMenuText,csShortCut;

	AFX_MANAGE_STATE(_afxModuleAddrThis);
	
	csMenuText.LoadString(IDS_UNDO_MENU_TEXT);
	csShortCut.LoadString(IDS_UNDO_SHORTCUT_TEXT);

    ASSERT(m_pWave);
    if(m_pWave == NULL)
    {
        return;
    }

	CString sStateName = m_pWave->GetUndoMenuText();

	if(!sStateName.IsEmpty())
	{
		pCmdUI->Enable(TRUE);
		pCmdUI->SetText(csMenuText + _T(" ") + sStateName + csShortCut);
	}
	else 
	{
		pCmdUI->Enable(FALSE);
		pCmdUI->SetText(csMenuText + csShortCut);
	}
}

void CWaveCtrl::OnHScroll(UINT nSBCode, UINT nPos, CScrollBar* pScrollBar) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

    // we only want to process the control scroll bar!!
    // In case anyone makes the window scrollable!
    ASSERT(pScrollBar);

	SCROLLINFO	stgInfo;

    switch(nSBCode)
    {
    case SB_LINELEFT:
    {
		// 20 pixels left
        m_nCurPos -= 20; 
    }
    break;

    case SB_LINERIGHT:
    {
        // 20 pixels right
        m_nCurPos += 20; 
    }
    break;

    case SB_PAGELEFT:
    {
		stgInfo.cbSize = sizeof(SCROLLINFO);
        stgInfo.fMask = SIF_ALL;
		m_HScrollBar.GetScrollInfo(&stgInfo,SIF_ALL);

        m_nCurPos -= stgInfo.nPage;
    }
    break;

    case SB_PAGERIGHT:
    {
		stgInfo.cbSize = sizeof(SCROLLINFO);
        stgInfo.fMask = SIF_ALL;
		m_HScrollBar.GetScrollInfo(&stgInfo,SIF_ALL);

        m_nCurPos += stgInfo.nPage;
    }
    break;

	case SB_THUMBTRACK:
    case SB_THUMBPOSITION:
    {
		stgInfo.cbSize = sizeof(SCROLLINFO);
        stgInfo.fMask = SIF_TRACKPOS;
		m_HScrollBar.GetScrollInfo(&stgInfo,SIF_TRACKPOS);
		m_nCurPos = stgInfo.nTrackPos;
    }
    break;
        
    default:
        break;

    }   //switch

    // set the scrollpos.
    if (m_nCurPos > 0)
    {
        m_nCurPos = min(m_dwMaxScrollPos, (DWORD)m_nCurPos);
    }
    else
    {
        m_nCurPos = max (0, m_nCurPos);
    }

    if (m_nZoomFactor >= 0)
    {
        m_nxSampleOffset = m_nCurPos * m_nSamplesPerPixel;
    }
    else
    {
        m_nxSampleOffset = m_nCurPos/m_nSamplesPerPixel;
    }

    pScrollBar->SetScrollPos(m_nCurPos, true);
    // cause a ondraw to be called.
    InvalidateRect(NULL);   
}

// ===================================================================================
// ===================================================================================
void CWaveCtrl::OnDrawItem(int nIDCtl, LPDRAWITEMSTRUCT lpDrawItemStruct) 
{
	// TODO: Add your message handler code here and/or call default
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	
	COleControl::OnDrawItem(nIDCtl, lpDrawItemStruct);
}

// ===================================================================================
//  OnCommand
//      Handles the button-click notifications
// ===================================================================================
BOOL CWaveCtrl::OnCommand(WPARAM wParam, LPARAM lParam) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

    switch(LOWORD(wParam))
    {
        case BTN_ZOOMIN:
			SetZoomFactor(--m_nZoomFactor);
			return TRUE;

        case BTN_ZOOMOUT:
			SetZoomFactor(++m_nZoomFactor);
			return TRUE;
                
        case ID_APP_ABOUT:
            ASSERT(TRUE);
            break;
    }

    return COleControl::OnCommand(wParam, lParam);

}

// ===================================================================================
// OnLButtonDown
//      Draws a line to show which sample is selected unless it's received while
//      dragging out a region.
// ===================================================================================
void CWaveCtrl::OnLButtonDown(UINT nFlags, CPoint point) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	ASSERT(m_pWaveNode);
	if(m_pWaveNode == NULL)
	{
		return;
	}

	CDLSComponent* pComponent = m_pWaveNode->GetComponent();
	ASSERT(pComponent);
	if(pComponent == NULL)
	{
		return;
	}

    // Convert to pixels.
    int nStart = SampleToPixel(m_nStartSel, true);
    int nEnd = SampleToPixel(m_nEndSel, true);
	
	int nLoopStart = SampleToPixel(m_pWave->m_rWLOOP.ulStart, true);
	int nLoopEnd = SampleToPixel(m_pWave->m_rWLOOP.ulLength + m_pWave->m_rWLOOP.ulStart - 1, true);
	bool bWaveIsLooped = (m_pWave->m_bPlayLooped != 0);

    // Check for end point first. In the case of a new line,
    // we always assume that the end is being dragged out.
	DRAGCURSOR dc;
#ifdef _DEBUG
	dc = dcArrow;
#endif
    if(point.x <= nEnd + 1 && point.x >= nEnd - 1)
    {
        m_nDragDir = _END;
		dc = dcSizeSelection;
    }
	else if(bWaveIsLooped && point.x <= nLoopEnd + 1 && point.x >= nLoopEnd - 1)
    {
        m_nDragDir = _END;
		m_bDraggingLoop = true;
		dc = dcSizeLoopEnd;
    }
    else if (point.x <= nStart+1 && point.x >= nStart-1)  
    {
        m_nDragDir = _START;
		dc = dcSizeSelection;
    }
	else if(bWaveIsLooped && point.x <= nLoopStart + 1 && point.x >= nLoopStart - 1)  
    {
        m_nDragDir = _START;
		m_bDraggingLoop = true;
		dc = dcSizeLoopStart;
    }
    else
    {
        int nSel = PixelToSample(point.x, true);
		SnapToSelectionBoundaries(nSel);
		m_nStartSel = m_nEndSel = nSel; // since there's no region.
        m_nDragDir = _END;
		dc = dcSizeSelection;
    }
	ASSERT(dc != dcArrow);

    UpdateStatusBar();

    m_bInSelMode = true;
    SetSizeCursor(true, dc);    // change to move cursor.
    SetCapture();

	// Show the wave's properties if the property page is up
	IDMUSProdPropSheet* pIPropSheet = NULL;
	if(SUCCEEDED(pComponent->m_pIFramework->QueryInterface(IID_IDMUSProdPropSheet, (void**)&pIPropSheet)))
	{
		if(pIPropSheet->IsShowing() == S_OK)
		{	
			m_pWave->OnShowProperties();
		}
		
		RELEASE(pIPropSheet);
	}

	SetFocus();
}

// ===================================================================================
// ===================================================================================
void CWaveCtrl::OnLButtonUp(UINT nFlags, CPoint point) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	ASSERT(m_pWave);
	if(m_pWave == NULL)
	{
		return;
	}

	if(m_pWaveNode == NULL)
	{
		return;
	}

    if (m_bSizeCursorSet)
    {
        ReleaseCapture();
	    m_bInSelMode = false;

		if(m_bDraggingLoop)
		{
			SetDraggedLoopPoint(point);
		}

		m_bDraggingLoop = false;
        
        SetSizeCursor(false);    
        m_nDragDir = _NONE;
        InvalidateRect(NULL);
		
		CDLSComponent* pComponent = m_pWaveNode->GetComponent();
		ASSERT(pComponent);
		if(pComponent == NULL)
		{
			return;
		}

		// Snap to zero is turned on?
		if(pComponent->IsSnapToZero())
		{
			SnapToZero();
		}

		UpdateSelectionInPropertyPage(false);
    }

    if (m_nStartSel > m_nEndSel)
    {
        SwapPoints();
    }

	SetFocus();
}

// ===================================================================================
// OnMouseMove
//  Sets the m_nStartSel and m_nEndSel points and draws it by calling InvalidateRect.
// ===================================================================================
void CWaveCtrl::OnMouseMove(UINT nFlags, CPoint point) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	// No Wave?
	ASSERT(m_pWave);
	if(m_pWave == NULL)
		return;

	if((int)m_pWave->m_dwWaveLength <= 0)
		return;

    RECT rc;
    GetClientRect(&rc); 

    int nStart = SampleToPixel(m_nStartSel, true);
    int nEnd = SampleToPixel(m_nEndSel, true);
	
	int nLoopStart = SampleToPixel(m_pWave->m_rWLOOP.ulStart, true);
	int nLoopEnd = SampleToPixel(m_pWave->m_rWLOOP.ulLength + m_pWave->m_rWLOOP.ulStart - 1, true);
	bool bWaveIsLooped = (m_pWave->m_bPlayLooped != 0);

    ASSERT(nStart >= 0);
    ASSERT(nEnd >= 0);

	// we're not currently dragging a region or loop points
    if (!m_bInSelMode)  
    {
        if (point.x <= nEnd + 1 && point.x >= nEnd - 1)
        {
            m_nDragDir = _END;
	        SetSizeCursor(true, dcSizeSelection);
        }
        else if(point.x <= nStart + 1 && point.x >= nStart - 1)
        {
			m_nDragDir = _START;
	        SetSizeCursor(true, dcSizeSelection);
        }
		else if(bWaveIsLooped && point.x <= nLoopEnd + 1 && point.x >= nLoopEnd - 1)
        {
            m_nDragDir = _END;
	        SetSizeCursor(true, dcSizeLoopEnd);
        }
		else if(bWaveIsLooped && point.x <= nLoopStart + 1 && point.x >= nLoopStart - 1)
        {
			m_nDragDir = _START;
	        SetSizeCursor(true, dcSizeLoopStart);
        }
    }
    else    //we're dragging a region. lbtndown is received but no lbtnup.
    {
		if(!m_bDraggingLoop)
			SetSelection(point);
		else
			m_ptDraggedLoop = point;	
        
		// Invalidate only the changed rect
		InvalidateRect(NULL);
    }
}


void CWaveCtrl::SetSelection(CPoint ptSelection)
{
	DWORD dwOldStartSel = m_nStartSel;
	DWORD dwOldEndSel = m_nEndSel;

	if (m_nDragDir == _START)
    {
		m_nStartSel = PixelToSample(ptSelection.x, true);
		SnapToSelectionBoundaries(m_nStartSel);
    }
    else if (m_nDragDir == _END)
    {
		m_nEndSel = PixelToSample(ptSelection.x, true);
		SnapToSelectionBoundaries(m_nEndSel);
    }

	int nSelMin = -(int)(m_pWave->GetDwDecompressedStart(true));

	// All this to make sure we preserve the selection length.....
	if(m_pWave && m_pWave->m_pWavePropPgMgr && m_pWave->m_pWavePropPgMgr->m_pWavePage)
	{
		if(m_pWave->m_pWavePropPgMgr->m_pWavePage->IsSelectionLengthLocked())
		{
			if(m_nDragDir == _START)
			{
				m_nEndSel += m_nStartSel - dwOldStartSel;
				int nSelMax = (int)m_pWave->m_dwWaveLength + nSelMin;
				if(m_nEndSel > nSelMax)
				{
					m_nEndSel = nSelMax;
					m_nStartSel = m_nEndSel - (dwOldEndSel - dwOldStartSel);
				}
			}
			else if(m_nDragDir == _END)
			{
				m_nStartSel += m_nEndSel - dwOldEndSel;
				if(m_nStartSel < nSelMin)
				{
					m_nStartSel = nSelMin;
					m_nEndSel = m_nStartSel + (dwOldEndSel - dwOldStartSel);
				}
			}
		}
	}
}

void CWaveCtrl::SetDraggedLoopPoint(CPoint ptDraggedPoint)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	// No Wave? Huh?
	ASSERT(m_pWave);
	if(m_pWave == NULL)
	{
		return;
	}

	// Not dragging loop point? How did we get here?
	if(!m_bDraggingLoop || m_nDragDir == _NONE)
	{
		return;
	}

	// Is the loop length locked?
	bool bLoopLengthLocked = false;
	if(m_pWave->m_pWavePropPgMgr && m_pWave->m_pWavePropPgMgr->m_pWavePage)
	{
		bLoopLengthLocked = m_pWave->m_pWavePropPgMgr->m_pWavePage->IsLoopLengthLocked();
	}

	WLOOP waveLoop = m_pWave->GetWLOOP();

	DWORD dwLoopLength = waveLoop.ulLength;
	int nLoopStart = waveLoop.ulStart;
	int nLoopEnd = waveLoop.ulStart + waveLoop.ulLength;
	
	bool bWaveIsLooped = m_pWave->IsLooped();

	int nNewPosition = PixelToSample(ptDraggedPoint.x, true);
	if(m_nDragDir == _START)
	{
		nLoopStart = nNewPosition;
		if(bLoopLengthLocked)
			nLoopEnd = nLoopStart + dwLoopLength;
	}
	if(m_nDragDir == _END)
	{
		nLoopEnd = nNewPosition;
		if(bLoopLengthLocked)
			nLoopStart = nLoopEnd - dwLoopLength;
	}

	int nLoopMax = (int)m_pWave->GetDwSelMax();
	nLoopStart = max(0, nLoopStart);
	if (nLoopStart > nLoopMax)
		nLoopStart = nLoopMax;
	nLoopEnd = max(0, nLoopEnd);
	if (nLoopEnd > nLoopMax)
		nLoopEnd = nLoopMax;

	// Swap the points if necessary
	if (nLoopStart > nLoopEnd)
	{
		int nTemp = nLoopStart;
		nLoopStart = nLoopEnd;
		nLoopEnd = nTemp;
	}

	DWORD dwNewLoopLength = nLoopEnd - nLoopStart;
	if(bLoopLengthLocked)
	{
		dwNewLoopLength = dwLoopLength;
		if(nLoopStart + (int)dwNewLoopLength > nLoopMax)
		{
			nLoopStart = nLoopMax - dwLoopLength;
		}
	}
	
	if(dwNewLoopLength < MINIMUM_VALID_LOOPLENGTH)
	{
		return;
	}

	if(bLoopLengthLocked && dwLoopLength != dwNewLoopLength)
	{
		return;
	}

	// Save the undo state
	if(FAILED(SaveStateForUndo(IDS_UNDO_MODIFY_LOOP)))
	{
		return;
	}

	if(dwNewLoopLength >= MSSYNTH_LOOP_LIMIT)
	{
		CWnd* pWnd = GetFocus();
		int nChoice = AfxMessageBox(IDS_WARN_MSSYNTH_LOOP_LIMIT, MB_OKCANCEL);
		if(pWnd)
		{
			pWnd->SetFocus();
		}
		
		if(nChoice == IDCANCEL)
		{
			dwNewLoopLength = MSSYNTH_LOOP_LIMIT - 1;
		}
	}

	// Set the loop value now...
	waveLoop.ulStart = nLoopStart;
	waveLoop.ulLength = dwNewLoopLength;

	m_pWave->SetWLOOP(waveLoop);

	if(FAILED(m_pWave->UpdateWave()))
	{
		return;
	}

	UpdateLoopInRegions();
    m_pWave->UpdateDummyInstrument();

	UpdateLoopInPropertyPage();
	
    // Dirty the collection so we know the file gets saved
	CCollection* pCollection = m_pWave->GetCollection();
	if(pCollection)
	{
		pCollection->SetDirtyFlag();
	}

    InvalidateRect(NULL);
}

void CWaveCtrl::OnUpdateEditPaste(CCmdUI* pCmdUI) 
{
    AFX_MANAGE_STATE(_afxModuleAddrThis);

	if(IsClipboardFormatAvailable(CF_WAVE))
		pCmdUI->Enable(true);
	else
		pCmdUI->Enable(false);
	
}

void CWaveCtrl::OnUpdatePaste(CCmdUI* pCmdUI) 
{
    AFX_MANAGE_STATE(_afxModuleAddrThis);

	if(IsClipboardFormatAvailable(CF_WAVE))
		pCmdUI->Enable(true);
	else
		pCmdUI->Enable(false);
}


void CWaveCtrl::OnUpdateSetLoopFromSelection(CCmdUI* pCmdUI) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	// disable if selection has negative values
	if ((m_nStartSel < 0) || (m_nEndSel < 0))
		{
		pCmdUI->Enable(FALSE);
		return;
		}

	// command update UI handler
	// disable the snaptozero menu if there is no region selected.
	UpdateSelectionCmdUI(pCmdUI);
}

void CWaveCtrl::OnEditDelete() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	DeleteSelection();
}

void CWaveCtrl::OnUpdateEditDelete(CCmdUI* pCmdUI) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	ASSERT(m_pWave);
	if(m_pWave == NULL)
	{
		return;
	}

	if(m_pWave->m_bCompressed)
	{
		pCmdUI->Enable(FALSE);
		return;
	}

	UpdateSelectionCmdUI(pCmdUI);
}


void CWaveCtrl::OnDelete() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	DeleteSelection();
}

void CWaveCtrl::OnUpdateDelete(CCmdUI* pCmdUI) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	ASSERT(m_pWave);
	if(m_pWave == NULL)
	{
		return;
	}

	if(m_pWave->m_bCompressed)
	{
		pCmdUI->Enable(FALSE);
		return;
	}

	UpdateSelectionCmdUI(pCmdUI);
}


void CWaveCtrl::OnUpdateEditCopy(CCmdUI* pCmdUI) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	ASSERT(m_pWave);
	if(m_pWave == NULL)
	{
		return;
	}

	if(m_pWave->m_bCompressed)
	{
		pCmdUI->Enable(FALSE);
		return;
	}

	UpdateSelectionCmdUI(pCmdUI);
}

void CWaveCtrl::OnUpdateCopy(CCmdUI* pCmdUI) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	ASSERT(m_pWave);
	if(m_pWave == NULL)
	{
		return;
	}

	if(m_pWave->m_bCompressed)
	{
		pCmdUI->Enable(FALSE);
		return;
	}

	UpdateSelectionCmdUI(pCmdUI);
}

void CWaveCtrl::OnUpdateCut(CCmdUI* pCmdUI) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	ASSERT(m_pWave);
	if(m_pWave == NULL)
	{
		return;
	}

	if(m_pWave->m_bCompressed)
	{
		pCmdUI->Enable(FALSE);
		return;
	}

	UpdateSelectionCmdUI(pCmdUI);
}

void CWaveCtrl::OnUpdateEditCut(CCmdUI* pCmdUI) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	ASSERT(m_pWave);
	if(m_pWave == NULL)
	{
		return;
	}

	if(m_pWave->m_bCompressed)
	{
		pCmdUI->Enable(FALSE);
		return;
	}

	UpdateSelectionCmdUI(pCmdUI);
}

void CWaveCtrl::OnSelectAll() 
{
	ASSERT(m_pWave);
	if(m_pWave == NULL)
	{
		return;
	}

	DWORD dwDecompressedStart = m_pWave->GetDwDecompressedStart(true);
	SetSelection(-(int)(dwDecompressedStart), m_pWave->m_dwWaveLength - dwDecompressedStart - 1);
	InvalidateRect(NULL);
}

void CWaveCtrl::OnUpdateSelectAll(CCmdUI* pCmdUI) 
{
	ASSERT(m_pWave);
	if(m_pWave == NULL)
	{
		return;
	}

	if(m_pWave->m_dwWaveLength == 0)
	{
		pCmdUI->Enable(false);
	}
	else
	{
		pCmdUI->Enable(true);
	}
}



void CWaveCtrl::UpdateSelectionCmdUI(CCmdUI * pCmdUI)
{
    AFX_MANAGE_STATE(_afxModuleAddrThis);

	// Disabled if no selection
	if ( m_nEndSel - m_nStartSel < 1)
	{
		pCmdUI->Enable(false);
	}
	else
	{
		pCmdUI->Enable(true);
	}
}


// ===================================================================================
// ===================================================================================
void CWaveCtrl::OnContextMenu(CWnd* pWnd, CPoint point) 
{
    AFX_MANAGE_STATE(_afxModuleAddrThis);
    ASSERT(m_pRMenu);
	if(m_pRMenu == NULL)
	{
		return;
	}

	CDLSComponent* pComponent = m_pWaveNode->GetComponent();
	ASSERT(pComponent);
	if(pComponent == NULL)
	{
		return;
	}

	ASSERT(m_pWave);
	if(m_pWave == NULL)
	{
		return;
	}

	// Load the popup menu.
	CMenu* pPopupMenu = NULL;

    pPopupMenu = m_pRMenu->GetSubMenu(0);
    if (pPopupMenu)
    {
        ASSERT(IsMenu(pPopupMenu->m_hMenu));
        pPopupMenu->TrackPopupMenu(TPM_LEFTALIGN | TPM_RIGHTBUTTON | TPM_LEFTBUTTON,
								   point.x,
								   point.y,
								   this,
								   NULL);
	}
}

// ===================================================================================
// ===================================================================================
void CWaveCtrl::OnSnapToZero() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
    ASSERT(m_pRMenu);

	CDLSComponent* pComponent = m_pWaveNode->GetComponent();
	ASSERT(pComponent);


    // the checked state toggles. 
    if (m_pRMenu->CheckMenuItem(IDM_SNAP_TO_ZERO, MF_BYCOMMAND) == MF_CHECKED)
    {
        m_pRMenu->CheckMenuItem(IDM_SNAP_TO_ZERO, MF_UNCHECKED);
		pComponent->SetSnapToZero(FALSE);
    }
    else
    {
	    pComponent->SetSnapToZero(TRUE);
        m_pRMenu->CheckMenuItem(IDM_SNAP_TO_ZERO, MF_CHECKED);
    }

    if (pComponent->IsSnapToZero() == TRUE)
    {
		// This sets the m_nSnapStart and End values also.
        SnapToZero();   
        // Cause a redraw; OnDraw will update statusbar.
        InvalidateRect(NULL);   

		IDMUSProdPropSheet* pIPropSheet = NULL;
		if(SUCCEEDED(pComponent->m_pIFramework->QueryInterface(IID_IDMUSProdPropSheet, (void**)&pIPropSheet)))
		{
			if(pIPropSheet->IsShowing() == S_OK && pIPropSheet->IsEqualPageManagerObject(m_pWave) == S_OK)
			{	
				// Update the property page
				if(m_pWave->m_pWavePropPgMgr && m_pWave->m_pWavePropPgMgr->m_pWavePage)
				{
					m_pWave->m_pWavePropPgMgr->m_pWavePage->SetSelection(m_nStartSel, m_nEndSel);
					m_pWave->m_pWavePropPgMgr->m_pWavePage->SetSelectionLengthLock(false);
				}
			}

			RELEASE(pIPropSheet);
		}
    }
}


// =========================================================================
// TODO: Handle errors!
//
// =========================================================================
void CWaveCtrl::OnKeyDown(UINT nChar, UINT nRepCnt, UINT nFlags) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
    ASSERT(m_pWave);
	if(m_pWave == NULL)
	{
		return;
	}

    switch(nChar)
    {
		case VK_SPACE :
		{
      		if(m_nMIDINoteOns[m_pWave->m_rWSMP.usUnityNote] > 0)
            {
                break;
            }

            m_pWave->Play(TRUE);
			m_nMIDINoteOns[m_pWave->m_rWSMP.usUnityNote]++;
			break;
		}

		case VK_DELETE :
		{
			DeleteSelection();
			break;
		}

		case VK_INSERT:
			OnInsertSilence();
			break;

		case 'a':
		case 'A':
		{
			// Don't react to Ctrl + Alt + A...that's a shortcut for transport play button....
			BOOL bCtrl = (GetKeyState(VK_CONTROL) & 0x8000);
			BOOL bAlt = (GetKeyState(VK_MENU) & 0x8000);
			BOOL bShift = (GetKeyState(VK_SHIFT) & 0x8000);
			if(bCtrl && !bAlt && !bShift)
			{
				OnSelectAll();
			}
			break;
		}

		case 'I':
		case 'i':
		{
			SetZoomFactor(--m_nZoomFactor);
			break;
		}

		case 'O':
		case 'o':
		{
			SetZoomFactor(++m_nZoomFactor);
			break;
		}
    }
}

void CWaveCtrl::DeleteSelection()
{
	ASSERT(m_pWave);
	if(m_pWave == NULL)
		return;

	CWaveDataManager* pDataManager = m_pWave->GetDataManager();
	ASSERT(pDataManager);
	if(pDataManager == NULL)
		return;

	// Can not allow modifications to a compressed wave.
	if(m_pWave->m_bCompressed == true)
	{
		CWnd* pWnd = GetFocus();
		AfxMessageBox(IDS_ERR_DELETE_ON_COMPRESSED_WAVE, MB_ICONEXCLAMATION); 
		if(pWnd)
			pWnd->SetFocus();
		return;
	}

	if((int)m_pWave->m_dwWaveLength <= 1)
		return;

	if(FAILED(SaveStateForUndo(IDS_UNDO_DELETE_SELECTION)))
		return;
	
	if(FAILED(RemoveSelection()))
	{
		// We don't delete the state because the action
		// may fail due to insuffcient memory in update 
		// for the synth. In that case the data has already 
		// been removed and deleting the state will mean 
		// that the user can't go back to the original state
		if(FAILED(pDataManager->Undo()))
			return;
	}

	if(FAILED(m_pWave->OnWaveBufferUpdated()))
	{
		pDataManager->Undo();
		return;
	}

	UpdateStatusBar();
	UpdateRefRegions();

	// Update the sample length in the property page
	m_pWave->RefreshPropertyPage();

	ResetScrollBar();
	
	// HACK! HACK! This recalculates the scroll position and 
	// prevents the jump/disappearance of the wave
	OnHScroll(0, m_nCurPos, &m_HScrollBar);
	InvalidateRect(NULL);

}

// =========================================================================
// =========================================================================
void CWaveCtrl::OnKeyUp(UINT nChar, UINT nRepCnt, UINT nFlags) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	switch (nChar)
    {
    case VK_SPACE:     // 32
		while (m_nMIDINoteOns[m_pWave->m_rWSMP.usUnityNote] > 0)
        {

			m_pWaveNode->Stop( TRUE );
            m_nMIDINoteOns[m_pWave->m_rWSMP.usUnityNote]--;
        }
	}	
}


// =========================================================================
// =========================================================================
void CWaveCtrl::OnProperties() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	
    // Call the onshowproperties in the CWave.
    if (m_pWave)
    {
        m_pWave->OnShowProperties();
    }
}


// =========================================================================
// =========================================================================
void CWaveCtrl::OnSetFocus(CWnd* pOldWnd) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	COleControl::OnSetFocus(pOldWnd);

    UpdateStatusBar();
}       


// ===========================================================================
// Private Functions
// ===========================================================================
void CWaveCtrl::ResetScrollBar(void)
{
    // compute the new range.
    // Get the width of the window. Assuming zoom == 1 for now.
	AFX_MANAGE_STATE(_afxModuleAddrThis);
    RECT rc;
	int nRemPixels;

    GetClientRect(&rc);
	if (m_nZoomFactor >= 0)
	{
		nRemPixels = ((m_pWave->m_dwWaveLength)/m_nSamplesPerPixel) - rc.right;
	}
	else
	{
		nRemPixels = ((m_pWave->m_dwWaveLength)*m_nSamplesPerPixel) - rc.right;
	}

/**************************************************************************************/
/*	ScrollBar parameters are a little funky. PageSize is supposed to be the amount    */
/*  of data that can fit into one screen. MaxScroll is the highest value that would   */
/*  be used in a call to SetScrollPos() on the scrollbar (if given a number greater   */
/*  than the max specified here the scrollbar would set its position to max). But     */
/*  dragging the thumb returns a different range of values. The Maximum value ret-    */
/*  urned by the thumb is given by: MaxScrollPos = MaxRangeValue - (PageSize - 1)     */
/*	where MaxRangeValue and PageSize are specified in SetScrollInfo. Consequently I   */
/*  am going to set the MaxRangeVal such that the m_dwMaxScrollPosition is the range  */
/*  and enforce that on the range of values determined for clicking the arrow buttons.*/
/*  (as opposed to querying the scrollbar for it's range to enforce the limit.)		  */
/**************************************************************************************/

	m_dwMaxScrollPos = max (0, nRemPixels + 100);

	int nPageSize;
	int nMaxHScroll;
	nPageSize = m_dwMaxScrollPos ? min((int)m_dwMaxScrollPos, rc.right) : rc.right;
	nMaxHScroll = m_dwMaxScrollPos + (nPageSize - 1);

	SCROLLINFO	stgInfo;
	stgInfo.cbSize = sizeof(SCROLLINFO);
	stgInfo.fMask = SIF_PAGE | SIF_RANGE;
	stgInfo.nPage = nPageSize;
	stgInfo.nMin = 0;
	stgInfo.nMax = nMaxHScroll;
	m_HScrollBar.SetScrollInfo(&stgInfo,true);

    // Get the current position - In case of zoom we need to reset the scroll pos.
	int nCenterSample;
	int nWidth;

	// Determine the center sample of the selection
	nCenterSample = m_nStartSel + ((m_nEndSel - m_nStartSel) / 2);

	// Check and do the needful if the center of 
	// the selection is not in the client rect 
	int nTempSamplesPerPixel = m_nSamplesPerPixel;
	m_nSamplesPerPixel = m_nSamplesPerPixelBeforeZoom;
	DWORD dwFirstSample = PixelToSample(rc.left, false);
	DWORD dwLastSample = PixelToSample(rc.right, false);
	m_nSamplesPerPixel = nTempSamplesPerPixel;

	
	if(nCenterSample < (int)dwFirstSample || nCenterSample > (int)dwLastSample)
	{
		nCenterSample = dwFirstSample + ((dwLastSample - dwFirstSample) / 2);
	}
	
	// Get the width, in samples of one screen
	if (m_nZoomFactor >= 0)
		nWidth = (rc.right) * m_nSamplesPerPixel;
	else
		nWidth = (rc.right) / m_nSamplesPerPixel;

	// Set offset so as to center the selection
	m_nxSampleOffset = (nCenterSample - (nWidth / 2));
	m_nxSampleOffset = max(0,m_nxSampleOffset);
	
    // Setup the scroll pos to reflect the current sampleoffset.
	if (m_nZoomFactor >= 0)
	{
		m_nCurPos = (m_nxSampleOffset / m_nSamplesPerPixel);
	}
	else
	{
		m_nCurPos = (m_nxSampleOffset * m_nSamplesPerPixel);
	}
    m_HScrollBar.SetScrollPos(m_nCurPos);
}

// ===================================================================================
// SetSizeCursor.
//      taken from regionkeyboard.
// ===================================================================================
void CWaveCtrl::SetSizeCursor(bool bOn, DRAGCURSOR dc)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	/*if (bOn == m_bSizeCursorSet)
		return;*/

	if(bOn)
		{
		HCURSOR hcursor;
		switch (dc)
			{
			case dcSizeLoopStart:
				if (m_hSizeLoopStartCursor == NULL)
					m_hSizeLoopStartCursor = theApp.LoadCursor(MAKEINTRESOURCE(IDC_SIZEWE_GREEN));
				hcursor = m_hSizeLoopStartCursor;
				break;
				
			case dcSizeLoopEnd:
				if (m_hSizeLoopEndCursor == NULL)
					m_hSizeLoopEndCursor = theApp.LoadCursor(MAKEINTRESOURCE(IDC_SIZEWE_BLUE));
				hcursor = m_hSizeLoopEndCursor;
				break;
				
			default:
				ASSERT(FALSE); // unknown drag cursor
				// fall thru

			case dcSizeSelection:
				if (m_hSIZEWECursor == NULL)
					m_hSIZEWECursor = theApp.LoadStandardCursor(MAKEINTRESOURCE(IDC_SIZEWE));
				hcursor = m_hSIZEWECursor;
				break;
			}

		if (hcursor != NULL)
		{
			m_bSizeCursorSet = true;
			m_hPrevCursor = SetCursor(hcursor);
		}
	}
	else
	{
		ASSERT(dc == dcArrow);
		m_bSizeCursorSet = false;
		SetCursor(m_hPrevCursor);
	}
}

// ===================================================================================
// 
// ===================================================================================
// Returns the sample that draws at this pixel. Counts from start if bCountFromDecompressedStart is false. Sample can be negative.
int CWaveCtrl::PixelToSample(int xVal, bool bCountFromDecompressedStart)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

    int nSample = 0;

    if (m_nZoomFactor < 0)
    {   // we're zoomed in.
        nSample = xVal/m_nSamplesPerPixel;
    }
    else
    {
        nSample = xVal * m_nSamplesPerPixel;
    }

    nSample += m_nxSampleOffset;

	if (bCountFromDecompressedStart)
		nSample -= m_pWave->GetDwDecompressedStart(true);

    return nSample;
}

// ===================================================================================
// ===================================================================================
// Returns the pixel the sample should draw at. Counts from start if bCountFromDecompressedStart is false. Sample can be negative.
int CWaveCtrl::SampleToPixel(int nSamp, bool bCountFromDecompressedStart)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if (bCountFromDecompressedStart)
		nSamp += m_pWave->GetDwDecompressedStart(true);

    if ( (nSamp == 0) || ( (int)nSamp < m_nxSampleOffset ) )
        return 0;

    int nx = 0;
    if (m_nZoomFactor < 0)
    {
        nx = (nSamp - m_nxSampleOffset) * m_nSamplesPerPixel ;
    }
    else
    {
        nx = (nSamp - m_nxSampleOffset)/m_nSamplesPerPixel;
    }

    return nx;
}

// ===================================================================================
//  Set the zoom factor to a new value.  If the zoom factor is out of range, it is
//  adjusted.  The allowable range is based on the size of the wave sample and the
//  size of the window.  Calling SetZoomFactor(m_nZoomFactor) has the effect of
//  assuring the zoom factor is within limits.
// ===================================================================================
void CWaveCtrl::SetZoomFactor(int nNewZoomFactor)
{
	CRect rect;
	GetClientRect(&rect);

	double dMaxSampsPerPixel = ((double)m_pWave->m_dwWaveLength / rect.right);
	int nMaxZoomFactor = (int)ceil(log(dMaxSampsPerPixel) / log(2));

    m_nZoomFactor = min(m_nZoomFactor, nMaxZoomFactor);
	m_nZoomFactor = max(m_nZoomFactor, -5);
    
	m_nSamplesPerPixelBeforeZoom = m_nSamplesPerPixel;

	m_nSamplesPerPixel = 1 << abs(m_nZoomFactor);
    
	ResetScrollBar();
    InvalidateRect(NULL);
}
 
// ===================================================================================
// ===================================================================================
void CWaveCtrl::UpdateStatusBar()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

    char sz[255] = "Zoom ";
    char szT[255];

    if (m_nZoomFactor == 0)
    {
        strcat(sz, " 1:1");
    }
    else if (m_nZoomFactor > 0) // zoomed out
    {
        strcat(sz, "1:");
        _itoa(1 << m_nZoomFactor, szT, 10);
        strcat(sz, szT);
    }
    else if (m_nZoomFactor < 0) //zoomed in.
    {
        _itoa(1 << abs(m_nZoomFactor), szT, 10);
        strcat(sz, szT);
        strcat(sz, ":1");
    }

	CDLSComponent* pComponent = m_pWaveNode->GetComponent();
	ASSERT(pComponent);

    // Setup the status bar text for the 1st pane
    // Setup the status bar text.
    CString cstr1(sz);      //NOTE: only 10 chars displayed in status bar.
  	BSTR bstr1 = cstr1.AllocSysString();
	pComponent->m_pIFramework->SetStatusBarPaneText( m_hKeyStatusBar, 0, bstr1, TRUE );

	// Swap the selection points if start > end
	DWORD dwSelectionStart = m_nStartSel;
	DWORD dwSelectionEnd = m_nEndSel;
	DWORD dwTemp = m_nStartSel;
	if(dwSelectionStart > dwSelectionEnd)
	{
		dwSelectionStart = dwSelectionEnd;
		dwSelectionEnd = dwTemp;
	}

    sz[0] = '\0';
    if (m_nStartSel == 0 && m_nEndSel == 0)
    {
        strcat(sz, m_szDefault);
    }
    else
    {
		
		CString sStartTime = m_pWave->SampleToTime(dwSelectionStart);
		CString sEndTime = m_pWave->SampleToTime(dwSelectionEnd);
		
        strcat(sz, " Samples ");
        _itoa(dwSelectionStart, szT, 10);
        strcat(sz, szT);
		strcat(sz, " (Time ");
		strcat(sz,  sStartTime);
		strcat(sz, ")");
        strcat(sz, " thru ");
        _itoa(dwSelectionEnd, szT, 10);
        strcat(sz, szT);
		strcat(sz, " (Time ");
		strcat(sz, sEndTime);
		strcat(sz, ")");
        strcat(sz, " selected.");
    }

    //Setup the status bar text.
    CString cstr2(sz);  //NOTE: only 30 chars displayed.
	int nLength = cstr2.GetLength();
    BSTR bstr2 = cstr2.AllocSysString();
	
	pComponent->m_pIFramework->SetStatusBarPaneInfo( m_hKeyStatusBar, 1, SBS_SUNKEN, nLength );
	pComponent->m_pIFramework->SetStatusBarPaneText( m_hKeyStatusBar, 1, bstr2, TRUE );
}


// ===================================================================================
// ===================================================================================
void CWaveCtrl::DrawLoopPoints(CDC* pDC)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	ASSERT(m_pWave);
	if(m_pWave == NULL)
		return;
	
	WLOOP waveLoop = m_pWave->GetWLOOP();
    if(waveLoop.ulLength >= 1)
    {
		int nPenStyle = m_pWave->IsLooped() ? PS_SOLID : PS_DOT;

		// start loop sample
		DrawLoopCursor(*pDC, nPenStyle, SampleToPixel(waveLoop.ulStart, true), _START);
        
		// end loop sample
		int nEnd = waveLoop.ulLength + waveLoop.ulStart - 1;
		DrawLoopCursor(*pDC, nPenStyle, SampleToPixel(nEnd, true), _END);
    }
}


// ===================================================================================
// SnapToZero
//  If m_pWave->m_bSnapToZero is true, the selection moves to a point where the value is >= the zero
//  line and the previous sample is below the zero line. 
//  The search is in both directions and the closest sample that satisfies this
//  conditionis chosen.
// ===================================================================================
void CWaveCtrl::SnapToZero(void)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	
	// No wave??
	ASSERT(m_pWave);
	if(m_pWave == NULL)
		return;
	
	// No component?
	CDLSComponent* pComponent = m_pWaveNode->GetComponent();
	ASSERT(pComponent);
	if(pComponent == NULL)
		return;

	// Snap to zero is turned on?
    ASSERT(pComponent->IsSnapToZero() == TRUE);

    // Check what the values are. If they're the same that we did a snap on before, don't do it again.
    bool bSnapStart = (m_nSnapStart != m_nStartSel); 
    bool bSnapEnd = (m_nSnapEnd != m_nEndSel);
	if (bSnapStart || bSnapEnd)
		{
		DWORD dwDecompressedStart = m_pWave->GetDwDecompressedStart(true);

		if(bSnapStart)
		{
			DWORD dwStartSel = m_nStartSel+dwDecompressedStart;
			m_pWave->SnapToZero(dwStartSel);
			m_nSnapStart = m_nStartSel = dwStartSel-dwDecompressedStart;
		}
		
		if(bSnapEnd)
		{
			DWORD dwEndSel = m_nEndSel+dwDecompressedStart;
			m_pWave->SnapToZero(dwEndSel);
			m_nSnapEnd = m_nEndSel = dwEndSel-dwDecompressedStart;
		}
	}
}


// =========================================================================
// =========================================================================
void CWaveCtrl::OnSetLoopFromSelection() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	// loop points must be positive
	if ((m_nStartSel < 0) || (m_nEndSel < 0))
		{
		ASSERT(FALSE);
		return;
		}

	if(m_pWave->m_dwWaveLength < MINIMUM_VALID_LOOPLENGTH)
		return;

	if(FAILED(SaveStateForUndo(m_pWave->m_bPlayLooped ? IDS_UNDO_LOOPPOINTS : IDS_UNDO_LOOPSETTINGS)))
		return;

	// Take the current region selection and set it to be the loop points.
    if (m_nStartSel > m_nEndSel)
        SwapPoints();

	if(abs(m_nEndSel - m_nStartSel) < MINIMUM_VALID_LOOPLENGTH)
	{
		CWnd* pWnd = GetFocus();
		AfxMessageBox(IDS_LOOP_SELECTION_TOO_SMALL, MB_ICONEXCLAMATION);
		if(pWnd)
			pWnd->SetFocus();
		return;
	}

	if(abs(m_nEndSel - m_nStartSel) >= MSSYNTH_LOOP_LIMIT)
	{
		CWnd* pWnd = GetFocus();
		int nChoice = AfxMessageBox(IDS_WARN_MSSYNTH_LOOP_LIMIT, MB_OKCANCEL);
		if(pWnd)
			pWnd->SetFocus();
		if(nChoice == IDCANCEL)
			return;
	}

    if(FAILED(m_pWave->SetLoop(m_nStartSel, m_nEndSel)))
		return;

	UpdateLoopInPropertyPage();
	m_pWave->NotifyWaveChange(true);
    InvalidateRect(NULL);
}


// =========================================================================
//  SetupDefaultStatusText
// =========================================================================
void CWaveCtrl::SetupDefaultStatusText()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

    ASSERT(m_pWave);

	char szT[20];
    _itoa(m_pWave->m_rWaveformat.nSamplesPerSec, m_szDefault, 10);
    strcat(m_szDefault, " Hz ");
    _itoa(m_pWave->m_rWaveformat.wBitsPerSample, szT, 10);
    strcat(m_szDefault, szT);
    strcat(m_szDefault, " bit "); 
	if(m_pWave->IsStereo())
	{
		strcat(m_szDefault, "Stereo, ");
	}
	else
	{
		strcat(m_szDefault, "Mono, ");
	}

    _itoa(m_pWave->m_dwWaveLength, szT, 10);
    strcat(m_szDefault, szT);
    strcat(m_szDefault, " samples");

}


// =========================================================================
//  SwapPoints
//      Swaps the Start and End Selection points.
// =========================================================================
void CWaveCtrl::SwapPoints()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
    DWORD nT = m_nStartSel;
	int dwSnapT = m_nSnapStart; 
    
	m_nStartSel = m_nEndSel;
	m_nSnapStart = m_nSnapEnd;

    m_nEndSel = nT;
	m_nSnapEnd = dwSnapT;
}

// =========================================================================
// Update the playback position during wave play. nNewPos should be a pixel
// position of where the new playback position is.  If pRectInvalid != NULL,
// the previous playback pos is simply redrawn, and nNewPos is ignored.
// =========================================================================
void CWaveCtrl::UpdatePlaybackPos(int nNewPos, CRect* pRectInvalid /* = NULL */)
{
	static bool bPrevWasRedraw = false;		// was previous call a redraw request?
	static CRect rectInvalidPrev;			// the previous invalid rectangle

	if (nNewPos == m_nPlaybackPos) {
		return;
	}

	CDC * pdc = GetDC();
	ASSERT(pdc);

	// Return without doing anything if we fail to get the DC
	if(pdc == NULL)
		return;
	
	// draw in inverted mode
	int nOldMode = pdc->SetROP2(R2_NOT);
	
	RECT rc;
	GetClientRect(&rc);
	
	if (m_nPlaybackPos != 0) 
	{
		
		// figure out drawing/erasing rectangle
		CRect rectDraw;
		if (pRectInvalid != NULL)
			rectDraw = *pRectInvalid;
		else if (bPrevWasRedraw)
			rectDraw = rectInvalidPrev;
		else 
			rectDraw = rc;
		
		// erase old playback pos (or redraw if pRectInvalid != NULL)
		if (m_nPlaybackPos >= rectDraw.left && m_nPlaybackPos <= rectDraw.right) 
		{
			pdc->MoveTo(m_nPlaybackPos, rectDraw.top);
			pdc->LineTo(m_nPlaybackPos, rectDraw.bottom);
			// keep track of prev invalid rect
			if (pRectInvalid)
				rectInvalidPrev = *pRectInvalid;
			bPrevWasRedraw = (pRectInvalid != NULL);
		}
	}

	if (pRectInvalid == NULL) 
	{
		m_nPlaybackPos = nNewPos;

		if (m_nPlaybackPos != 0) 
		{
			// draw new playback pos
			pdc->MoveTo(m_nPlaybackPos, 0);
			pdc->LineTo(m_nPlaybackPos, rc.bottom);
		}
	}
	
	// restore drawing mode
	pdc->SetROP2(nOldMode);
	ReleaseDC(pdc);
}

// =========================================================================
// Prepare timer for keeping track of sample playback.
// =========================================================================
void CWaveCtrl::PreparePlaybackTimer()
{
	m_uiTimer = SetTimer(ID_WAVE_PLAYBACK_TIMER, 10, NULL);
	m_bPlayedLooped = (m_pWave->m_bPlayLooped == TRUE);
	m_sPlayFineTune = m_pWave->m_rWSMP.sFineTune; 
	if (m_bPlayedLooped) {
		m_nPlayLoopStart = m_pWave->m_rWLOOP.ulStart;
		m_nPlayLoopLength = m_pWave->m_rWLOOP.ulLength;
	}

}

// =========================================================================
// Kill timer for keeping track of sample playback.
// =========================================================================
void CWaveCtrl::KillPlaybackTimer()
{
	if (m_uiTimer) {
		// kill playback timer
		KillTimer(ID_WAVE_PLAYBACK_TIMER);
		m_uiTimer = 0;
		// stop showing playback pos
		UpdatePlaybackPos(0);
	}
}

void CWaveCtrl::OnAppAbout() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	CAboutDlg AboutDlg;
	AboutDlg.DoModal();
	
}

// =========================================================================
//  Restores status bars
// =========================================================================
void CWaveCtrl::OnHideToolBars() 
{
    AFX_MANAGE_STATE(_afxModuleAddrThis);
    ASSERT( m_pWaveNode != NULL );	// Need m_pWave to remove status bar panes
	if(m_pWaveNode)
    {
		CDLSComponent* pComponent = m_pWaveNode->GetComponent();
		ASSERT(pComponent);

        pComponent->m_pIFramework->RestoreStatusBar( m_hKeyStatusBar );
    }

	m_hKeyStatusBar = NULL;
}

// =========================================================================
//  Sets up status bar
// =========================================================================
void CWaveCtrl::OnShowToolBars() 
{
    AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( m_pInPlaceFrame == NULL )
	{
		return;
	}

	m_pInPlaceFrame->SetActiveObject( &m_xMyOleInPlaceActiveObject, NULL );
    
	// Create status bar panes if they don't already exist
	if( m_hKeyStatusBar == NULL )
	{
		if(m_pWaveNode)
		{
			CDLSComponent* pComponent = m_pWaveNode->GetComponent();
			ASSERT(pComponent);

			pComponent->m_pIFramework->SetNbrStatusBarPanes( 2, SBLS_EDITOR, &m_hKeyStatusBar );
    		pComponent->m_pIFramework->SetStatusBarPaneInfo( m_hKeyStatusBar, 0, SBS_SUNKEN, 10);
    		pComponent->m_pIFramework->SetStatusBarPaneInfo( m_hKeyStatusBar, 1, SBS_SUNKEN, 34 );
		}
	}

	if( m_pInPlaceDoc != NULL )
	{
		m_pInPlaceDoc->SetActiveObject( &m_xMyOleInPlaceActiveObject, NULL );
	}
		
}

void CWaveCtrl::OnEditCopy() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	if(m_pWave->m_bCompressed)
	{
		CWnd* pWnd = GetFocus();
		AfxMessageBox(IDS_ERR_CLIPBOARD_ON_COMPRESSED_WAVE, MB_ICONEXCLAMATION); 
		if(pWnd)
			pWnd->SetFocus();

		return;
	}
	CopySelectionToClipboard();	
}


void CWaveCtrl::OnCopy() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	if(m_pWave->m_bCompressed)
	{
		CWnd* pWnd = GetFocus();
		AfxMessageBox(IDS_ERR_CLIPBOARD_ON_COMPRESSED_WAVE, MB_ICONEXCLAMATION); 
		if(pWnd)
			pWnd->SetFocus();
		return;
	}

	CopySelectionToClipboard();	
}

void CWaveCtrl::OnEditPaste() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	if(m_pWave->m_bCompressed)
	{
		CWnd* pWnd = GetFocus();
		AfxMessageBox(IDS_ERR_CLIPBOARD_ON_COMPRESSED_WAVE, MB_ICONEXCLAMATION); 
		if(pWnd)
			pWnd->SetFocus();
		return;
	}

	PasteFromClipboard();
	UpdateStatusBar();
	m_pWave->RefreshPropertyPage();
}

void CWaveCtrl::OnPaste() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	if(m_pWave->m_bCompressed)
	{
		CWnd* pWnd = GetFocus();
		AfxMessageBox(IDS_ERR_CLIPBOARD_ON_COMPRESSED_WAVE, MB_ICONEXCLAMATION); 
		if(pWnd)
			pWnd->SetFocus();
		return;
	}

	PasteFromClipboard();
	UpdateStatusBar();
	m_pWave->RefreshPropertyPage();
}

void CWaveCtrl::OnEditCut() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	if(m_pWave->m_bCompressed)
	{
		CWnd* pWnd = GetFocus();
		AfxMessageBox(IDS_ERR_CLIPBOARD_ON_COMPRESSED_WAVE, MB_ICONEXCLAMATION); 
		if(pWnd)
			pWnd->SetFocus();
		return;
	}

	if((int)m_pWave->m_dwWaveLength <= 0)
		return;

	CutSelectionToClipboard();
	UpdateStatusBar();
	m_pWave->RefreshPropertyPage();
}


void CWaveCtrl::OnCut() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	if(m_pWave->m_bCompressed)
	{
		CWnd* pWnd = GetFocus();
		AfxMessageBox(IDS_ERR_CLIPBOARD_ON_COMPRESSED_WAVE, MB_ICONEXCLAMATION); 
		if(pWnd)
			pWnd->SetFocus();
		return;
	}

	if((int)m_pWave->m_dwWaveLength <= 1)
		return;

	CutSelectionToClipboard();
	UpdateStatusBar();
	m_pWave->RefreshPropertyPage();
}

void CWaveCtrl::CutSelectionToClipboard()
{
    AFX_MANAGE_STATE(_afxModuleAddrThis);
	ASSERT(m_pWave);
	if(m_pWave == NULL)
		return;

	CWaveDataManager* pDataManager = m_pWave->GetDataManager();
	ASSERT(pDataManager);
	if(pDataManager == NULL)
		return;

	if(FAILED(CopySelectionToClipboard()))
		return;

	// Out Of Memory??
	if(FAILED(SaveStateForUndo(IDS_WAVE_CUT_UNDO_TEXT)))
		return;

	if(FAILED(RemoveSelection()))
	{
		// We don't delete the state because the action
		// may fail due to insuffcient memory in update 
		// for the synth. In that case the data has already 
		// been removed and deleting the state will mean 
		// that the user can't go back to the original state
		pDataManager->Undo();
		return;
	}

	// Pop the undo state if the update fails
	if(FAILED(m_pWave->OnWaveBufferUpdated()))
	{
		pDataManager->Undo();
		return;
	}
	
	UpdateStatusBar();
	UpdateRefRegions();

	m_pWave->RefreshPropertyPage();

	ResetScrollBar();
	
	// HACK! HACK! This recalculates the scroll position and 
	// prevents the jump/disappearance of the wave
	OnHScroll(0, m_nCurPos, &m_HScrollBar);
	InvalidateRect(NULL);
}

HRESULT CWaveCtrl::CopySelectionToClipboard()
{
    AFX_MANAGE_STATE(_afxModuleAddrThis);
		
	DWORD dwStartSel = m_nStartSel;
	DWORD dwEndSel = m_nEndSel;

	CDllJazzDataObject* pDataObject = new CDllJazzDataObject;
	ASSERT(pDataObject);
	if(pDataObject == NULL)
	{
		// Error
		return E_OUTOFMEMORY;
	}

	IStream* pIStream = NULL;
	if(FAILED(CreateStreamOnHGlobal(NULL, TRUE, &pIStream)))
	{
		// Errror
		return E_OUTOFMEMORY;
	}

	if(FAILED(m_pWave->CopySelectionToClipboard(pIStream, dwStartSel, dwEndSel)))
	{
		pIStream->Release();
		return E_FAIL;
	}

	HRESULT hr = pDataObject->AddClipFormat(CF_WAVE, pIStream);
	
	if(m_pClipboardDataObject != NULL)
	{
		m_pClipboardDataObject->Release();
	}
	
	m_pClipboardDataObject = pDataObject;

	if(S_OK != OleSetClipboard(pDataObject))
	{
		hr = E_FAIL;
	}

	pIStream->Release();
	return hr;
}

void CWaveCtrl::PasteFromClipboard()
{
    AFX_MANAGE_STATE(_afxModuleAddrThis);

	IStream*				pIStream = NULL;
	CDllJazzDataObject*		pJazzDataObject = NULL;
	IDataObject*			pIDataObject = NULL;
	HRESULT					hr = E_FAIL;
	short*					pnBuffer = NULL;

	
	ASSERT(m_pWave);
	if(m_pWave == NULL)
	{
		return;
	}


	CWaveDataManager* pDataManager = m_pWave->GetDataManager();
	ASSERT(pDataManager);
	if(pDataManager == NULL)
	{
		return;
	}

	
	if(FAILED(SaveStateForUndo(IDS_WAVE_PASTE_UNDO_TEXT)))
	{
		return;
	}


	hr = OleGetClipboard(&pIDataObject);
	if ( FAILED(hr) )
	{
		//error
		return;
	}
	
	pJazzDataObject = new CDllJazzDataObject;
	if (pJazzDataObject == NULL)
	{
		//error
		return;
	}
	
	if( SUCCEEDED (	pJazzDataObject->IsClipFormatAvailable(pIDataObject, CF_WAVE) ) )
	{
		if( SUCCEEDED(pJazzDataObject->AttemptRead(pIDataObject, CF_WAVE, &pIStream) ) )
		{
			DWORD dwDecompressedStart = m_pWave->GetDwDecompressedStart(true);

			// Check if the start selection is valid...
			int nSelMax = m_pWave->GetDwSelMax();
			if(m_nStartSel > nSelMax)
				m_nStartSel = nSelMax;

			if(FAILED(m_pWave->PasteSelectionFromClipboard(pIStream, m_nStartSel+dwDecompressedStart)))
			{
				goto ERROR_EXIT;
			}

			if(FAILED(m_pWave->OnWaveBufferUpdated()))
			{
				// Call Undo here because the insertion of data has succeeded
				// and the failure is most likely due to out of memory while
				// downloading to the synth....if we just delete the state the
				// synth will not be in sync with what we hold...
				pDataManager->Undo();
				goto ERROR_EXIT;
			}
			
			UpdateRefRegions();
			
			SetupDefaultStatusText();

			ResetScrollBar();
			InvalidateRect(NULL);
		}
	}
	else
	{
		pIDataObject->Release();
		return;
	}
ERROR_EXIT:
	pIDataObject->Release();
	pIStream->Release();
	pJazzDataObject->Release();
}

HRESULT CWaveCtrl::RemoveSelection()
{
    AFX_MANAGE_STATE(_afxModuleAddrThis);
	HRESULT hr = S_OK;
	if(m_pWave == NULL)
	{
		return E_FAIL;
	}

	if((int)m_pWave->m_dwWaveLength <= 0)
	{
		return E_FAIL;
	}

	DWORD dwStartSel = m_nStartSel;
	DWORD dwEndSel = m_nEndSel;

	WSMPL waveWSMPL = m_pWave->GetWSMPL();
	WLOOP waveLoop = m_pWave->GetWLOOP();
	RSMPL waveRSMPL = m_pWave->GetRSMPL();
	RLOOP waveRLoop = m_pWave->GetRLOOP();

	// Are we trimming the beginning of a looped wave?
	bool bCutBeforeLoopStart = false;
	if(m_nStartSel <= (int)waveLoop.ulStart)
		bCutBeforeLoopStart = true;

	if(FAILED(m_pWave->RemoveSelection(dwStartSel, dwEndSel)))
	{
		return E_FAIL;
	}
	
	if((int)dwStartSel <= 0)
		dwStartSel = 1;

	DWORD dwSamplesRemoved = abs(dwEndSel - dwStartSel);
	m_nSnapStart = m_nSnapEnd = m_nEndSel = m_nStartSel = dwStartSel - 1;

	int nLoops = 0;
	bool bPlayLooped = false;

	DWORD dwWaveLength = m_pWave->GetWaveLength();

	// Adjust the loop points
	if(dwWaveLength >= MINIMUM_VALID_LOOPLENGTH)
	{
		// Adjust the loop start if the samples before it have been trimmed...
		if(bCutBeforeLoopStart)
			waveLoop.ulStart -= dwSamplesRemoved;

		if(((int)waveLoop.ulStart) > (int)dwWaveLength)
			waveLoop.ulStart = dwWaveLength - waveLoop.ulLength;

		if(((int)waveLoop.ulStart) < 0)
			waveLoop.ulStart = 0;
		
		if(waveLoop.ulStart + waveLoop.ulLength > dwWaveLength)
			waveLoop.ulLength = dwWaveLength - waveLoop.ulStart;

		if(m_pWave->IsLooped())
		{
			nLoops = 1;
			bPlayLooped = m_pWave->IsLooped();
		}
	}
	else
	{
		waveLoop.ulStart = 0;
		waveLoop.ulLength = 1;
	}

	// The synth deals with the WSMPL and WLOOP values
    // But we want to save the smpl values also
    waveWSMPL.cSampleLoops = nLoops;
    waveRSMPL.cSampleLoops = nLoops;
    waveRLoop.dwStart = waveLoop.ulStart;
    waveRLoop.dwEnd = waveLoop.ulStart + waveLoop.ulLength;

	m_pWave->SetWSMPL(waveWSMPL);
	m_pWave->SetWLOOP(waveLoop);
	m_pWave->SetRSMPL(waveRSMPL);
	m_pWave->SetRLOOP(waveRLoop);

	m_pWave->SetLooped(bPlayLooped);

	UpdateLoopInPropertyPage();
	UpdateSelectionInPropertyPage();
	
	SetupDefaultStatusText();
	UpdateStatusBar();

	return hr;
}

void CWaveCtrl::OnKillFocus(CWnd* pNewWnd) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);		

	COleControl::OnKillFocus(pNewWnd);
}

void CWaveCtrl::TurnOffMidiNotes()
{
    AFX_MANAGE_STATE(_afxModuleAddrThis);

	CDLSComponent* pComponent = m_pWaveNode->GetComponent();
	ASSERT(pComponent);
	if(pComponent == NULL)
		return;

	for(BYTE i = 0; i < 128; i++)
	{
        while (m_nMIDINoteOns[i] > 0)
        {
	        pComponent->PlayMIDIEvent(MIDI_NOTEOFF, i, DEFAULT_VELOCITY, 0, false);
            m_nMIDINoteOns[i]--;
        }
    }
}

void CWaveCtrl::UpdateLoopInRegions()
{
    AFX_MANAGE_STATE(_afxModuleAddrThis);
    ASSERT(m_pWave);
	if(m_pWave == NULL)
		return;

	m_pWave->UpdateLoopInRegions();
}

void CWaveCtrl::UpdateRefRegions()
{
    AFX_MANAGE_STATE(_afxModuleAddrThis);
    ASSERT(m_pWave);
	if(m_pWave == NULL)
		return;

	m_pWave->UpdateRefRegions();
}


void CWaveCtrl::OnTimer(UINT nIDEvent) 
{
    AFX_MANAGE_STATE(_afxModuleAddrThis);
	
	COleControl::OnTimer(nIDEvent);
	if(nIDEvent == ID_WAVE_AUTOSCROLL_TIMER && m_bInSelMode)
	{
		bool bUpdateSelection = false;
		
		// LEFT = false; RIGHT = true
		bool bScrollDirection = false;		

		RECT rcClient;
		GetClientRect(&rcClient);

		CPoint ptCursor;
		GetCursorPos(&ptCursor);
		ScreenToClient(&ptCursor);

		DWORD dwFirstSample = PixelToSample(rcClient.left, false);
		DWORD dwLastSample = PixelToSample(rcClient.right, false);
		
		// Reset the scroll position if the cursor is outside the frame
		if(ptCursor.x <= 0 && (int)dwFirstSample >= 0)
		{
			int nDiff = rcClient.left - ptCursor.x;

			// Faster scroll if the window is maximixed
			ASSERT(m_pWaveNode);
			HWND hwndEditor;
			m_pWaveNode->GetEditorWindow(&hwndEditor);
			if(::IsZoomed(hwndEditor))
				nDiff = 100;

			m_nCurPos = m_nCurPos - nDiff;
		
			bUpdateSelection = true;
		}
		else if(ptCursor.x > rcClient.right)
		{
			int nDiff = ptCursor.x - rcClient.right;
			
			// Faster scroll if the window is maximixed
			ASSERT(m_pWaveNode);
			HWND hwndEditor;
			m_pWaveNode->GetEditorWindow(&hwndEditor);
			if(::IsZoomed(hwndEditor))
				nDiff = 100;

			DWORD dwSampleAtCursor = PixelToSample(ptCursor.x, false);
			if(dwSampleAtCursor > dwLastSample)
				m_nCurPos = m_nCurPos + nDiff;

			bUpdateSelection = true;
			bScrollDirection = true;
		}

		if (m_nCurPos > 0)
		{
			m_nCurPos = min(m_dwMaxScrollPos, (DWORD)m_nCurPos);
		}
		else
		{
			m_nCurPos = max (0, m_nCurPos);
		}

		if (m_nZoomFactor >= 0)
		{
			m_nxSampleOffset = m_nCurPos * m_nSamplesPerPixel;
		}
		else
		{
			m_nxSampleOffset = m_nCurPos/m_nSamplesPerPixel;
		}

		m_HScrollBar.SetScrollPos(m_nCurPos, true);
		InvalidateRect(NULL);   

		if(bUpdateSelection && !m_bDraggingLoop)
		{
			GetClientRect(&rcClient);
			if(bScrollDirection)
				SetSelection(CPoint(rcClient.right, rcClient.bottom));
			else
				SetSelection(CPoint(rcClient.left, rcClient.bottom));
		}
	}

	if (nIDEvent == ID_WAVE_PLAYBACK_TIMER) 
	{
		// Calc new playback position
		int nElapsedTime = GetTickCount() - m_pWave->GetTimePlayed();
		if (nElapsedTime < 0) return;
		
		// Playback freq is affect
		double freq = pow(2, (double)m_sPlayFineTune / 1200) * 
			m_pWave->m_rWaveformat.nSamplesPerSec;
		
		double pos = (double)nElapsedTime/1000 * freq;

		// Update pos if wave is looped
		if (m_bPlayedLooped && m_nPlayLoopLength != 0) 
		{
			int nEndLoop = m_nPlayLoopStart + m_nPlayLoopLength;
			if (pos > nEndLoop) 
			{
				pos -= m_nPlayLoopStart;
				pos = (int)pos % m_nPlayLoopLength;
				pos += m_nPlayLoopStart;
			}
		}			

		if (pos > m_pWave->GetDwSelMax()) 
		{
			// If we are pas the sample's length, stop showing playback pos
			m_pWaveNode->Stop( TRUE );
			m_nCurPos = 0;
			OnHScroll(SB_PAGELEFT, m_nCurPos, &m_HScrollBar);
		}
		else 
		{
			// Update display of playback position
			int nNewPos = SampleToPixel((int)pos, true);

			if(nNewPos == 0 && m_pWave->m_bPlayLooped)
			{
				if (m_nZoomFactor < 0)
				{
					nNewPos = (int)((pos - m_nxSampleOffset) * m_nSamplesPerPixel);
				}
				else
				{
					nNewPos = (int)((pos - m_nxSampleOffset) / m_nSamplesPerPixel);
				}

				m_nCurPos += (nNewPos - 40);
				OnHScroll(SB_PAGELEFT, m_nCurPos, &m_HScrollBar);
			}
			else
			{

				RECT rcClient;
				GetClientRect(&rcClient);

				// Scroll one page left
				if(nNewPos < rcClient.left)
				{
					OnHScroll(SB_PAGELEFT, m_nCurPos, &m_HScrollBar);
				}
				else if(nNewPos > rcClient.right)
				{
					OnHScroll(SB_PAGERIGHT, m_nCurPos, &m_HScrollBar);
				}
			}

			nNewPos = max(0, nNewPos);

			UpdatePlaybackPos(nNewPos);
		}
	}

}

void CWaveCtrl::OnHelpFinder() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

    // Determine name of DMUSProd.exe help file
	CString strHelpFileName;

	if( theApp.GetHelpFileName( strHelpFileName ) )
	{
		strHelpFileName += "::/htm/directmusicproducer.htm";
		::HtmlHelp( NULL, strHelpFileName, HH_DISPLAY_TOPIC, 0 );
	}
}

// Save the state for Undo
HRESULT CWaveCtrl::SaveStateForUndo(UINT uUndoTextID)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	ASSERT(m_pWave);
	if(m_pWave == NULL)
	{
		return E_FAIL;
	}

	if(FAILED(m_pWave->SaveUndoState(uUndoTextID)))
	{
		AfxMessageBox(IDS_ERR_INSUFFICIENT_MEMORY, MB_OK | MB_ICONEXCLAMATION);
		return E_FAIL;
	}
	
	return S_OK;
}

void CWaveCtrl::SetSelection(int nSelectionStart, int nSelectionEnd, BOOL bDoSnap)
{
	ASSERT(m_pWave);
	if(m_pWave == NULL)
		return;

	m_nStartSel = nSelectionStart;
	m_nEndSel = nSelectionEnd;

	CDLSComponent* pComponent = m_pWaveNode->GetComponent();
	ASSERT(pComponent);
	if(pComponent == NULL)
		return;

	if(bDoSnap)
	{
		CDLSComponent* pComponent = m_pWaveNode->GetComponent();
		ASSERT(pComponent);

		if(pComponent->IsSnapToZero() == TRUE)
		{
			SnapToZero();
			UpdateSelectionInPropertyPage(false);
		}
	}
	else if(pComponent->IsSnapToZero() == TRUE)
	{
		// Brute force!
		m_nSnapStart = nSelectionStart;
		m_nSnapEnd = nSelectionEnd;
	}

	InvalidateRect(NULL);
}

void CWaveCtrl::OnLButtonDblClk(UINT nFlags, CPoint point) 
{
	ASSERT(m_pWave);
	if(m_pWave == NULL)
		return;

	// Don't select anything in a 0 length wave
	if((int)m_pWave->m_dwWaveLength <= 0)
		return;

	CDLSComponent* pComponent = m_pWaveNode->GetComponent();
	ASSERT(pComponent);
	
	// Turn SnapToZero off 
	if (pComponent->IsSnapToZero() == TRUE)
    {
        OnSnapToZero();
    }

	// Tuen of the selection length lock
	IDMUSProdPropSheet* pIPropSheet = NULL;
	if(SUCCEEDED(pComponent->m_pIFramework->QueryInterface(IID_IDMUSProdPropSheet, (void**)&pIPropSheet)))
	{
		if(pIPropSheet->IsShowing() == S_OK && pIPropSheet->IsEqualPageManagerObject(m_pWave) == S_OK)
		{	
			m_pWave->m_pWavePropPgMgr->m_pWavePage->SetSelectionLengthLock(false);
		}

		RELEASE(pIPropSheet);
	}


	DWORD dwSampleClicked = PixelToSample(point.x, true);

	if(!m_pWave->m_bPlayLooped)
	{
		m_nStartSel = 0;
		m_nEndSel = m_pWave->m_dwWaveLength - 1;
	}
	else if(dwSampleClicked <= m_pWave->m_rWLOOP.ulStart)
	{
		m_nStartSel = 0;
		m_nEndSel = m_pWave->m_rWLOOP.ulStart - 1;
	}
	else if(dwSampleClicked > m_pWave->m_rWLOOP.ulStart && dwSampleClicked <= (m_pWave->m_rWLOOP.ulStart + m_pWave->m_rWLOOP.ulLength))
	{
		m_nStartSel = m_pWave->m_rWLOOP.ulStart;
		m_nEndSel = (m_pWave->m_rWLOOP.ulStart + m_pWave->m_rWLOOP.ulLength - 1);
	}
	else if(dwSampleClicked > (m_pWave->m_rWLOOP.ulStart + m_pWave->m_rWLOOP.ulLength))
	{
		m_nStartSel = (m_pWave->m_rWLOOP.ulStart + m_pWave->m_rWLOOP.ulLength + 1);
		m_nEndSel = m_pWave->m_dwWaveLength - 1;
	}

	InvalidateRect(NULL);
	UpdateSelectionInPropertyPage();

	
	COleControl::OnLButtonDblClk(nFlags, point);
}

	
void CWaveCtrl::UpdateSelectionInPropertyPage(bool bBroadcastUpdate)
{
	CDLSComponent* pComponent = m_pWaveNode->GetComponent();
	ASSERT(pComponent);
	if(pComponent == NULL)
		return;

	IDMUSProdPropSheet* pIPropSheet = NULL;
	if(SUCCEEDED(pComponent->m_pIFramework->QueryInterface(IID_IDMUSProdPropSheet, (void**)&pIPropSheet)))
	{
		if(pIPropSheet->IsShowing() == S_OK && pIPropSheet->IsEqualPageManagerObject(m_pWave) == S_OK)
		{	
			// Update the property page
			if(m_pWave->m_pWavePropPgMgr && m_pWave->m_pWavePropPgMgr->m_pWavePage)
			{
				m_pWave->m_pWavePropPgMgr->m_pWavePage->SetSelection(m_nStartSel, m_nEndSel, bBroadcastUpdate);
				if (pComponent->IsSnapToZero() == TRUE)
					m_pWave->m_pWavePropPgMgr->m_pWavePage->SetSelectionLengthLock(false);
			}
		}

		RELEASE(pIPropSheet);
	}
}

void CWaveCtrl::UpdateLoopInPropertyPage()
{
	ASSERT(m_pWave);
	ASSERT(m_pWaveNode);

	CDLSComponent* pComponent = m_pWaveNode->GetComponent();
	ASSERT(pComponent);

	IDMUSProdPropSheet* pIPropSheet = NULL;
	if(SUCCEEDED(pComponent->m_pIFramework->QueryInterface(IID_IDMUSProdPropSheet, (void**)&pIPropSheet)))
	{
		if(pIPropSheet->IsShowing() == S_OK && pIPropSheet->IsEqualPageManagerObject(m_pWave) == S_OK)
		{
			// Change the wave property page if it's up.
			if (m_pWave->m_pWavePropPgMgr)
			{
				if (m_pWave->m_pWavePropPgMgr->m_pWavePage)
				{
					if(m_pWave->m_dwWaveLength < MINIMUM_VALID_LOOPLENGTH)
					{
						m_pWave->m_bPlayLooped = false;
						m_pWave->m_pWavePropPgMgr->m_pWavePage->EnableLoopControls(false);
					}

					m_pWave->m_pWavePropPgMgr->m_pWavePage->m_dwLoopStart = m_pWave->m_rWLOOP.ulStart;
					m_pWave->m_pWavePropPgMgr->m_pWavePage->m_dwLoopLength = m_pWave->m_rWLOOP.ulLength;
					
					// update prop page 
					m_pWave->m_pWavePropPgMgr->m_pWavePage->InitializeDialogValues();
					m_pWave->m_pWavePropPgMgr->m_pWavePage->UpdateData(FALSE);

					// the compressed loop also gets modified
					m_pWave->RememberLoopAfterCompression();
				}
			}

		}

		RELEASE(pIPropSheet);
	}
}

void CWaveCtrl::GetSelection(int& nSelectionStart, int& nSelectionEnd)
{
	nSelectionStart = m_nStartSel;
	nSelectionEnd = m_nEndSel;
}

void CWaveCtrl::SetSelectionBounds()
{
	ASSERT(m_pWave);
	if(m_pWave == NULL)
		return;

	DWORD dwDecompressedStart = m_pWave->GetDwDecompressedStart(true);

	int nSelMax = m_pWave->m_dwWaveLength-dwDecompressedStart;
	if(m_nStartSel >= nSelMax)
		m_nStartSel = nSelMax - 1;
	if(m_nEndSel >= nSelMax)
		m_nEndSel = nSelMax - 1;

	int nSelMin = -(int)dwDecompressedStart;
	if(m_nStartSel < nSelMin)
		m_nStartSel = nSelMin;
	if(m_nEndSel < nSelMin)
		m_nEndSel = nSelMin;

	if(m_nEndSel < m_nStartSel)
		m_nEndSel = m_nStartSel;
}

void CWaveCtrl::OnCopyLoop() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	ASSERT(m_pWave);
	if(m_pWave == NULL)
	{
		return;
	}

	// Wave's not looped?
	if(!m_pWave->IsLooped())
	{
		return;
	}

	if(FAILED(SaveStateForUndo(IDS_LOOP_COPY)))
	{
		return;
	}

	if(FAILED(m_pWave->CopyLoop()))
	{
		//m_pUndoMgr->DeleteState();
		return;
	}

    UpdateLoopInPropertyPage();
	m_pWave->NotifyWaveChange(true);
    InvalidateRect(NULL);
}

void CWaveCtrl::OnInsertSilence() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	ASSERT(m_pWave);
	if(m_pWave == NULL)
	{
		return;
	}

	CInsertSilenceDlg *pInsertSilenceDlg = new CInsertSilenceDlg(m_pWave->m_rWaveformat.nSamplesPerSec, this);
	if( !pInsertSilenceDlg )
	{
		return;
	}

	int nResult = pInsertSilenceDlg->DoModal();
	DWORD dwLength = pInsertSilenceDlg->GetSampleLength();
	delete pInsertSilenceDlg;

	if( IDOK != nResult )
	{
		return;
	}

	if(FAILED(SaveStateForUndo(IDS_UNDO_INS_SILENCE)))
	{
		return;
	}

	if(FAILED(m_pWave->InsertSilence(m_nStartSel, dwLength)))
	{
		//m_pUndoMgr->DeleteState();
		return;
	}

	if(FAILED(m_pWave->OnWaveBufferUpdated()))
    {
        return;
    }

    UpdateLoopInPropertyPage();
    InvalidateRect(NULL);
}

void CWaveCtrl::OnRegionFadeIn() 
{
	ASSERT(m_pWave);
	if(m_pWave == NULL)
	{
		return;
	}

	CWaveDataManager* pDataManager = m_pWave->GetDataManager();
	ASSERT(pDataManager);
	if(pDataManager == NULL)
	{
		return;
	}

	if(FAILED(SaveStateForUndo(IDS_UNDO_FADEIN)))
	{
		return;
	}

	if(FAILED(Fade()))
	{
		pDataManager->Undo();
	}
}

void CWaveCtrl::OnRegionFadeOut() 
{
	ASSERT(m_pWave);
	if(m_pWave == NULL)
	{
		return;
	}

	CWaveDataManager* pDataManager = m_pWave->GetDataManager();
	ASSERT(pDataManager);
	if(pDataManager == NULL)
	{
		return;
	}

	if(FAILED(SaveStateForUndo(IDS_UNDO_FADEOUT)))
	{
		return;
	}

	if(FAILED(Fade(false)))
	{
		pDataManager->Undo();
	}
}


HRESULT CWaveCtrl::Fade(bool bFadeDirection)
{
	ASSERT(m_pWave);
	if(m_pWave == NULL)
	{
		return E_FAIL;
	}

	if(FAILED(m_pWave->Fade(bFadeDirection, m_nStartSel, m_nEndSel)))
	{
		return E_FAIL;
	}

	if(FAILED(m_pWave->OnWaveBufferUpdated()))
    {
        return E_FAIL;
    }

	InvalidateRect(NULL);
	return S_OK;
}

void CWaveCtrl::OnUpdateRegionFadeIn(CCmdUI* pCmdUI) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	ASSERT(m_pWave);
	if(m_pWave == NULL)
	{
		return;
	}

	if(m_pWave->m_bCompressed)
	{
		pCmdUI->Enable(FALSE);
		return;
	}

	UpdateSelectionCmdUI(pCmdUI);
}

void CWaveCtrl::OnUpdateRegionFadeOut(CCmdUI* pCmdUI) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	ASSERT(m_pWave);
	if(m_pWave == NULL)
	{
		return;
	}

	if(m_pWave->m_bCompressed)
	{
		pCmdUI->Enable(FALSE);
		return;
	}

	UpdateSelectionCmdUI(pCmdUI);
}

void CWaveCtrl::OnUpdateCopyLoop(CCmdUI* pCmdUI) 
{
	ASSERT(m_pWave);
	if(m_pWave == NULL)
		return;
	
	if(m_pWave->m_bCompressed)
	{
		pCmdUI->Enable(FALSE);
	}
	else
	{
		pCmdUI->Enable(TRUE);
	}
}

void CWaveCtrl::OnUpdateInsertSilence(CCmdUI* pCmdUI) 
{
	ASSERT(m_pWave);
	if(m_pWave == NULL)
		return;
	
	if(m_pWave->m_bCompressed)
	{
		pCmdUI->Enable(FALSE);
	}
	else
	{
		pCmdUI->Enable(TRUE);
	}
}

int CWaveCtrl::GetScrolledSamples()
{
	return m_nxSampleOffset;
}

int CWaveCtrl::GetSamplesPerPixel()
{
	return m_nSamplesPerPixel;
}

int CWaveCtrl::GetZoomFactor()
{
	return m_nZoomFactor;
}


void CWaveCtrl::OnFindBestLoop() 
{
	ASSERT(m_pWave);
	if(m_pWave == NULL)
	{
		return;
	}

	WLOOP wloop = m_pWave->GetWLOOP();
	DWORD dwLoopStart = wloop.ulStart;

	DWORD dwLoopEnd = 0;
	DWORD dwSearchEnd = m_nEndSel;
	if(m_nStartSel == m_nEndSel)
	{
		dwSearchEnd = m_pWave->GetWaveLength() - 1;
	}
	
	CWaitCursor wait;

	if(SUCCEEDED(m_pWave->FindBestLoop(dwLoopStart, m_nStartSel, dwSearchEnd, 128, &dwLoopEnd)))
	{
		SaveStateForUndo(IDS_UNDO_BEST_LOOP);
		m_pWave->SetLoop(dwLoopStart, dwLoopEnd);
		UpdateLoopInPropertyPage();
		m_pWave->NotifyWaveChange(true);
		InvalidateRect(NULL);
	}

}

void CWaveCtrl::OnUpdateFindBestLoop(CCmdUI* pCmdUI) 
{
	ASSERT(m_pWave);
	if(m_pWave == NULL)
	{
		return;
	}

	if(m_pWave->IsLooped())
	{
		pCmdUI->Enable(TRUE);
	}
	else
	{
		pCmdUI->Enable(FALSE);
	}
}

void CWaveCtrl::OnUpdateDecompressStart(CCmdUI* pCmdUI) 
{
	ASSERT(m_pWave);
	if(m_pWave == NULL)
		return;

	pCmdUI->Enable(m_pWave->FConsiderDecompressedStart());
}

void CWaveCtrl::OnRButtonDown(UINT nFlags, CPoint point) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	ASSERT(m_pWaveNode);
	if(m_pWaveNode == NULL)
	{
		return;
	}

	// Activate transport if not activated
	CDLSComponent* pComponent = m_pWaveNode->GetComponent();
	ASSERT(pComponent);
	if(pComponent == NULL)
	{
		return;
	}

	pComponent->m_pIConductor->SetActiveTransport(m_pWaveNode, BS_PLAY_ENABLED | BS_NO_AUTO_UPDATE);
	
	COleControl::OnRButtonDown(nFlags, point);
}

void CWaveCtrl::OnDecompressStart() 
{
	ASSERT(m_pWave);
    if (m_pWave)
    	m_pWave->HrSetDecompressedStart(m_nStartSel+m_pWave->GetDwDecompressedStart(true));
}

/* ensures the given sample count is within selection boundaries */
void CWaveCtrl::SnapToSelectionBoundaries(int& nSel)
{
	ASSERT(m_pWave);
	if (m_pWave == NULL)
		return;

	DWORD dwDecompressedStart = m_pWave->GetDwDecompressedStart(true);
	int nSelMin = -(int)(dwDecompressedStart);
	int nSelMax = m_pWave->m_dwWaveLength-1-dwDecompressedStart;

	if (nSel < nSelMin)
		nSel = nSelMin;
	else if (nSel > nSelMax)
		nSel = nSelMax;
}

/* draws the given loop cursor using the given pen style */
void CWaveCtrl::DrawLoopCursor(CDC &dc, int nPenStyle, int x, DRAGDIR dd)
{
	ASSERT((dd == _START) || (dd == _END)); // unknown loop marker

	CRect rcClient;
	GetClientRect(&rcClient);
	if (x <= rcClient.right)
		{
		CPen pen(nPenStyle, 1, (dd == _START) ? RGB(0, 255, 0) : RGB(0, 0, 255));
		CPen* pOldPen = dc.SelectObject(&pen);
		ASSERT(pOldPen);
		dc.MoveTo(x, 0);
		dc.LineTo(x, rcClient.bottom);
		dc.SelectObject(pOldPen);
		}
}

void CWaveCtrl::OnResample() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	ASSERT(m_pWave);
	if(m_pWave == NULL)
	{
		return;
	}

	CResampleDlg *pResampleDlg = new CResampleDlg(m_pWave->m_rWaveformat.nSamplesPerSec, this);
	if( !pResampleDlg )
	{
		return;
	}

	const int nResult = pResampleDlg->DoModal();
	const DWORD dwSampleRate = pResampleDlg->GetSampleRate();
	delete pResampleDlg;

	if( IDOK != nResult
	||	dwSampleRate == m_pWave->m_rWaveformat.nSamplesPerSec )
	{
		return;
	}

	if(FAILED(SaveStateForUndo(IDS_UNDO_RESAMPLE)))
	{
		return;
	}

	CWaitCursor wait;

	if(FAILED(m_pWave->Resample(dwSampleRate)))
	{
		//m_pUndoMgr->DeleteState();
		return;
	}

	if(FAILED(m_pWave->OnWaveBufferUpdated()))
    {
        return;
    }

    UpdateLoopInPropertyPage();
    InvalidateRect(NULL);
}

void CWaveCtrl::OnUpdateResample(CCmdUI* pCmdUI) 
{
	ASSERT(m_pWave);
	if(m_pWave == NULL)
		return;
	
	if(m_pWave->m_bCompressed)
	{
		pCmdUI->Enable(FALSE);
	}
	else
	{
		pCmdUI->Enable(TRUE);
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\DLSDesigner\WaveCtl.h ===
#if !defined(AFX_WAVECTL_H__BC964EAE_96F7_11D0_89AA_00A0C9054129__INCLUDED_)
#define AFX_WAVECTL_H__BC964EAE_96F7_11D0_89AA_00A0C9054129__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

// ================================================================
// constants used by wavectl
// ================================================================
const int PAGE_SIZE_IN_PIXELS = 20;
const int MAX_ZOOM_OUT = 16;
const int START= 1;
typedef enum {
	_NONE = 0,
	_START = 1,
	_END = 2
} DRAGDIR;

typedef enum {
	dcArrow,
	dcSizeSelection,
	dcSizeLoopStart,
	dcSizeLoopEnd,
} DRAGCURSOR;

class CWave;
class CWaveNode;
class CUndoMan;

// ================================================================
//
// WaveCtl.h : Declaration of the CWaveCtrl ActiveX Control class.
//
// ================================================================

/////////////////////////////////////////////////////////////////////////////
// CWaveCtrl : See WaveCtl.cpp for implementation.

class CWaveCtrl : public COleControl
{
friend class CDLSComponent;
	DECLARE_DYNCREATE(CWaveCtrl)

// Constructor
public:
	CWaveCtrl();

	CWave* GetWave() {return(m_pWave);}

	void	PreparePlaybackTimer();
	void	KillPlaybackTimer();
	void	SetSelection(int nSelectionStart, int nSelectionEnd, BOOL bDoSnap = TRUE);		// Sets the selection
	void	GetSelection(int& nSelectionStart, int& nSelectionEnd);	// Gets the selection
	
	int		GetScrolledSamples();	// Returns m_nxSampleOffset
	int		GetSamplesPerPixel();	// Returns the number of samples that map per pixel (changes with the zoom ratio)
	int		GetZoomFactor();		// Returns the zoom factor

	// Returns the sample that draws at this pixel. Counts from start if bCountFromDecompressedStart is false. Sample can be negative.
    int		PixelToSample(int x, bool bCountFromDecompressedStart);

	// Returns the pixel the sample should draw at. Counts from start if bCountFromDecompressedStart is false. Sample can be negative.
	int		SampleToPixel(int n, bool bCountFromDecompressedStart);

// Attributes
private:
	void	UpdateRefRegions();
	void	UpdateLoopInRegions();
	void	TurnOffMidiNotes();
	void	CutSelectionToClipboard();
	void	SetSelection(CPoint ptSelection);
	void	SetDraggedLoopPoint(CPoint ptDraggedPoint);
	HRESULT RemoveSelection();
	void	UpdateSelectionCmdUI(CCmdUI* pCmdUI);
	void	PasteFromClipboard();
	HRESULT	CopySelectionToClipboard();
	void	UpdatePlaybackPos(int nNewPos, CRect* pRectInvalid = NULL);
	

	HMENU			m_hMenuInPlace;
	HACCEL			m_hAcceleratorTable;
	HANDLE			m_hKeyStatusBar;
	CToolBar*		m_pToolBar;
	CWaveNode*		m_pWaveNode;
	CWave*			m_pWave;
    CScrollBar      m_HScrollBar;
    int             m_nxSampleOffset;				// The number of scrolled samples.
    short           m_nZoomFactor;
    CBitmapButton   m_BtnZoomIn;
    CBitmapButton   m_BtnZoomOut;
    int             m_nSamplesPerPixel;				// Reflects amount of zoom. In case of zoom < 0, this is the number of *pixels* per sample
	int				m_nSamplesPerPixelBeforeZoom;	// Used only to decide wheree to zoom in !! This is a HACK !!

    int				m_nStartSel;					// In samples, from decompressed start
    int				m_nEndSel;						// In samples, from decompressed start
    BOOL			m_bInSelMode;					// If we're currently dragging out a selection.
	bool			m_bDraggingLoop;				// Set is we're dragging a loop point 			
    DRAGDIR			m_nDragDir;						// What's being dragged: selection, loop start, or loop end

	HCURSOR			m_hSIZEWECursor;
	HCURSOR			m_hPrevCursor;
	HCURSOR			m_hSizeLoopStartCursor;
	HCURSOR			m_hSizeLoopEndCursor;
	
	bool			m_bSizeCursorSet;
    BOOL			m_bSnapToZero;
    int				m_nSnapStart;					// Snapped-to-zero value for start of selection
    int				m_nSnapEnd;
    DWORD			m_dwMaxScrollPos;
	int				m_nCurPos;						// This was in a static variable local to OnHScroll()
    CHAR			m_szDefault[50];

    CInstrument*	m_pDummyInstrument;

    CMenu *			m_pRMenu;
    CString			m_cstr;        

    DWORD			m_dwCookie;

	WORD			m_nMIDINoteOns[128];			// From instrument.h
	UINT			m_uiTimer;						// Id of timer object used for keeping track of playback
	int				m_nPlaybackPos;
	bool			m_bPlayedLooped;
	int				m_nPlayLoopStart;
	int				m_nPlayLoopLength;
	short			m_sPlayFineTune;
	CPoint			m_ptDraggedLoop;


// Methods
private:
    void			ResetScrollBar();
	void			SetZoomFactor(int nNewZoomFactor);
	void			SetSizeCursor(bool bOn, DRAGCURSOR dc = dcArrow);
    void			SnapToZero(void);
    void			UpdateStatusBar(void);
    void			DrawLoopPoints(CDC * pdc);
    void			SetupDefaultStatusText(void);
	void			SwapPoints(void);
	void			UpdateSelectionInPropertyPage(bool bBroadcastUpdate = true);
	void			UpdateLoopInPropertyPage();
	void			DeleteSelection();
	void			SetSelectionBounds();
	HRESULT			Fade(bool bFadeDirection = true);	// bFadeDirection == true -> Fade In; false -> Out

	/* ensures the given sample count is within selection boundaries */
	void			SnapToSelectionBoundaries(int& nSel);

	/* draws the given loop cursor using the given pen style */
	void			DrawLoopCursor(CDC &dc, int nPenStyle, int x, DRAGDIR dd);

protected:
	CDllJazzDataObject*		m_pClipboardDataObject;
	
// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CWaveCtrl)
	public:
	virtual void OnDraw(CDC* pdc, const CRect& rcBounds, const CRect& rcInvalid);
	virtual void DoPropExchange(CPropExchange* pPX);
	virtual HMENU OnGetInPlaceMenu();
	virtual void OnHideToolBars();
	virtual void OnShowToolBars();
	protected:
	virtual BOOL OnCommand(WPARAM wParam, LPARAM lParam);
	//}}AFX_VIRTUAL

// Implementation
protected:
	~CWaveCtrl();

	DECLARE_OLECREATE_EX(CWaveCtrl)    // Class factory and guid
	DECLARE_OLETYPELIB(CWaveCtrl)      // GetTypeInfo
	//DECLARE_PROPPAGEIDS(CWaveCtrl)     // Property page IDs
	DECLARE_OLECTLTYPE(CWaveCtrl)		// Type name and misc status

// Message maps
	//{{AFX_MSG(CWaveCtrl)
	afx_msg void AboutBox();
	afx_msg void OnSize(UINT nType, int cx, int cy);
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	afx_msg void OnDestroy();
	afx_msg void OnEditRedo();
	afx_msg void OnUpdateEditRedo(CCmdUI* pCmdUI);
	afx_msg void OnEditUndo();
	afx_msg void OnUpdateEditUndo(CCmdUI* pCmdUI);
	afx_msg void OnHScroll(UINT nSBCode, UINT nPos, CScrollBar* pScrollBar);
	afx_msg void OnDrawItem(int nIDCtl, LPDRAWITEMSTRUCT lpDrawItemStruct);
	afx_msg void OnLButtonDown(UINT nFlags, CPoint point);
	afx_msg void OnLButtonUp(UINT nFlags, CPoint point);
	afx_msg void OnMouseMove(UINT nFlags, CPoint point);
	afx_msg void OnContextMenu(CWnd* pWnd, CPoint point);
	afx_msg void OnSnapToZero();
	afx_msg void OnKeyDown(UINT nChar, UINT nRepCnt, UINT nFlags);
	afx_msg void OnKeyUp(UINT nChar, UINT nRepCnt, UINT nFlags);
	afx_msg void OnSetLoopFromSelection();
	afx_msg void OnProperties();
	afx_msg void OnSetFocus(CWnd* pOldWnd);
	afx_msg void OnAppAbout();
	afx_msg void OnUpdateSetLoopFromSelection(CCmdUI* pCmdUI);
	afx_msg void OnEditCopy();
	afx_msg void OnUpdateEditCopy(CCmdUI* pCmdUI);
	afx_msg void OnCopy();
	afx_msg void OnUpdateCopy(CCmdUI* pCmdUI);
	afx_msg void OnEditPaste();
	afx_msg void OnPaste();
	afx_msg void OnUpdateEditPaste(CCmdUI* pCmdUI);
	afx_msg void OnUpdatePaste(CCmdUI* pCmdUI);
	afx_msg void OnEditCut();
	afx_msg void OnUpdateEditCut(CCmdUI* pCmdUI);
	afx_msg void OnCut();
	afx_msg void OnUpdateCut(CCmdUI* pCmdUI);
	afx_msg void OnKillFocus(CWnd* pNewWnd);
	afx_msg void OnTimer(UINT nIDEvent);
	afx_msg void OnHelpFinder();
	afx_msg void OnLButtonDblClk(UINT nFlags, CPoint point);
	afx_msg void OnDelete();
	afx_msg void OnUpdateDelete(CCmdUI* pCmdUI);
	afx_msg void OnEditDelete();
	afx_msg void OnUpdateEditDelete(CCmdUI* pCmdUI);
	afx_msg void OnCopyLoop();
	afx_msg void OnRegionFadeIn();
	afx_msg void OnRegionFadeOut();
	afx_msg void OnUpdateRegionFadeIn(CCmdUI* pCmdUI);
	afx_msg void OnUpdateRegionFadeOut(CCmdUI* pCmdUI);
	afx_msg void OnUpdateCopyLoop(CCmdUI* pCmdUI);
	afx_msg void OnSelectAll();
	afx_msg void OnUpdateSelectAll(CCmdUI* pCmdUI);
	afx_msg void OnFindBestLoop();
	afx_msg void OnUpdateFindBestLoop(CCmdUI* pCmdUI);
	afx_msg void OnUpdateDecompressStart(CCmdUI* pCmdUI);
	afx_msg void OnRButtonDown(UINT nFlags, CPoint point);
	afx_msg void OnDecompressStart();
	afx_msg void OnInsertSilence();
	afx_msg void OnUpdateInsertSilence(CCmdUI* pCmdUI);
	afx_msg void OnResample();
	afx_msg void OnUpdateResample(CCmdUI* pCmdUI);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

// Dispatch maps
	//{{AFX_DISPATCH(CWaveCtrl)
		// NOTE - ClassWizard will add and remove member functions here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_DISPATCH
	DECLARE_DISPATCH_MAP()


// Event maps
	//{{AFX_EVENT(CWaveCtrl)
		// NOTE - ClassWizard will add and remove member functions here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_EVENT
	DECLARE_EVENT_MAP()

// Dispatch and event IDs
public:
	HRESULT SaveStateForUndo(UINT uUndoTextID);
	
	// IOleInPlaceActiveObject
	BEGIN_INTERFACE_PART(MyOleInPlaceActiveObject, IOleInPlaceActiveObject)
		INIT_INTERFACE_PART(CWaveCtrl, MyOleInPlaceActiveObject)
		STDMETHOD(GetWindow)(HWND*);
		STDMETHOD(ContextSensitiveHelp)(BOOL);
		STDMETHOD(TranslateAccelerator)(LPMSG);
		STDMETHOD(OnFrameWindowActivate)(BOOL);
		STDMETHOD(OnDocWindowActivate)(BOOL);
		STDMETHOD(ResizeBorder)(LPCRECT, LPOLEINPLACEUIWINDOW, BOOL);
		STDMETHOD(EnableModeless)(BOOL);
	END_INTERFACE_PART(MyOleInPlaceActiveObject)

    // IDMUSProdEditor functions
	BEGIN_INTERFACE_PART(Editor, IDMUSProdEditor)
		STDMETHOD(AttachObjects)(IDMUSProdNode*);
		STDMETHOD(OnInitMenuFilePrint)(HMENU, UINT);
		STDMETHOD(OnFilePrint)();
		STDMETHOD(OnInitMenuFilePrintPreview)(HMENU, UINT);
		STDMETHOD(OnFilePrintPreview)();
		STDMETHOD(OnViewProperties)();
		STDMETHOD(OnF1Help)();
	END_INTERFACE_PART(Editor)
	
	DECLARE_INTERFACE_MAP()
	

	enum {
	//{{AFX_DISP_ID(CWaveCtrl)
		// NOTE: ClassWizard will add and remove enumeration elements here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_DISP_ID
	};
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_WAVECTL_H__BC964EAE_96F7_11D0_89AA_00A0C9054129__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\DLSDesigner\WaveDataManager.cpp ===
//////////////////////////////////////////////////////
//
// CWaveDataManager Implementation 
//
//////////////////////////////////////////////////////

#include "stdafx.h"
#include "WaveDataManager.h"
#include "WaveUndoManager.h"
#include "Wave.h"
#include "WaveNode.h"
#include "StereoWave.h"
#include "MonoWave.H"
#include "DLSDesignerDLL.h"
#include "riffstrm.h"
#include "WaveFileHandler.h"
#include "WaveTempFileHandler.h"
#include "WaveSourceFileHandler.h"
#include "WaveDelta.h"

/////////////////////////////////////////////////////
//
// CWaveDataManager::CWaveDataManager
//
/////////////////////////////////////////////////////
CWaveDataManager::CWaveDataManager(CWave* pWave, CString sSourceFileName, CString sTempFilePath) : 
m_pWave(pWave), 
m_sSourceFileName(sSourceFileName), 
m_sTempFilePath(sTempFilePath),
m_pTempFileHandler(NULL), 
m_pSourceFileHandler(NULL), 
m_pCopyFileHandler(NULL), 
m_pDecompFileHandler(NULL),
m_pUndoManager(NULL),
m_plstDeltas(NULL),
m_bInInit(FALSE),
m_bDecompressedDesignTime(FALSE),
m_bDecompressedRunTime(FALSE),
m_bNeedToMakeSrcDelta(FALSE),
m_plstUncompressedDeltas(NULL)
{
	ASSERT(pWave);

	CWaveNode* pWaveNode = m_pWave->GetNode(); 
	bool bInACollection = pWaveNode->IsInACollection();

	// Create the source file handler
	m_pSourceFileHandler = new CWaveSourceFileHandler(sSourceFileName, bInACollection);
	ASSERT(m_pSourceFileHandler);

	// Create a temp file name and keep it
	// The actual temp file will be created at the first edit time 
	char szTempFileName[MAX_PATH];

	CString sPrefix = "DMP";
	CString sExtension = "tmp";
	if(FAILED(CreateUniqueTempFile(sPrefix, sExtension, m_sTempFileName)))
	{
		GetTempFileName(m_sTempFilePath, sPrefix, 0, szTempFileName);
		m_sTempFileName = szTempFileName;
	}

	// Create a temp file name to keep the decompressed data 
	// The actual decomp file will be created at the first compression time 
	char szDecompFileName[MAX_PATH];
	if(FAILED(CreateUniqueTempFile(sPrefix, sExtension, m_sDecompFileName)))
	{
		GetTempFileName(m_sTempFilePath, sPrefix, 0, szDecompFileName);
		m_sDecompFileName = szDecompFileName;
	}

	// Create the undo manager
	m_pUndoManager = new CWaveUndoManager(this);

	// Create the delta list
	m_plstDeltas = new CPtrList();
}

// This creates only the decop file handler...used for individual channels of a stereo wave
CWaveDataManager::CWaveDataManager(CWave* pWave, CString sTempFilePath) : 
m_pWave(pWave), 
m_sTempFilePath(sTempFilePath),
m_pTempFileHandler(NULL), 
m_pSourceFileHandler(NULL), 
m_pCopyFileHandler(NULL), 
m_pDecompFileHandler(NULL),
m_plstDeltas(NULL),
m_bInInit(FALSE)
{
	ASSERT(pWave);

	CWaveNode* pWaveNode = m_pWave->GetNode(); 
	bool bInACollection = pWaveNode->IsInACollection();

	// Create a temp file name to keep the decompressed data 
	// The actual decomp file will be created at the first compression time 
	char szDecompFileName[MAX_PATH];
	
	CString sPrefix = "DMP";
	CString sExtension = "tmp";
	if(FAILED(CreateUniqueTempFile(sPrefix, sExtension, m_sDecompFileName)))
	{
		GetTempFileName(m_sTempFilePath, sPrefix, 0, szDecompFileName);
		m_sDecompFileName = szDecompFileName;
	}

	// Create the undo manager
	m_pUndoManager = new CWaveUndoManager(this);
}




CWaveDataManager::~CWaveDataManager()
{
	if(m_pSourceFileHandler)
	{
		delete m_pSourceFileHandler;
		m_pSourceFileHandler = NULL;
	}

	if(m_pTempFileHandler)
	{
		delete m_pTempFileHandler;
		m_pTempFileHandler = NULL;
	}

	// Delete the created temp file
	DeleteFile(m_sTempFileName);

	if(m_pCopyFileHandler)
	{
		delete m_pCopyFileHandler;
		m_pCopyFileHandler = NULL;

		// Delete the copied source file
		DeleteFile(m_sCopyFileName);
	}

	if(m_pDecompFileHandler)
	{
		delete m_pDecompFileHandler;
		m_pDecompFileHandler = NULL;
	}

	// Delete the decomp data file
	DeleteFile(m_sDecompFileName);

	if(m_pUndoManager)
	{
		delete m_pUndoManager;
	}

	// Delete the delta list that's with us
	if(m_plstDeltas)
	{
		while(!m_plstDeltas->IsEmpty())
		{
			delete m_plstDeltas->RemoveHead();
		}

		delete m_plstDeltas;
	}

    if(m_plstUncompressedDeltas)
    {
        while(m_plstUncompressedDeltas->IsEmpty() == FALSE)
        {
            delete (CWaveDelta*)m_plstUncompressedDeltas->RemoveHead();
        }

        delete m_plstUncompressedDeltas;
        m_plstUncompressedDeltas = NULL;
    }

}


///////////////////////////////////////////////////
//
// CWaveDataManager::Initialize
//
// NOTE!! This method assumes that header has been read AND 
// the pIStream is positioned just after (12 bytes) the 
// WAVE chunk header
//
///////////////////////////////////////////////////
HRESULT CWaveDataManager::Initialize(IStream* pIStream)
{
	ASSERT(m_pWave);
	if(m_pWave == NULL)
	{
		return E_POINTER;
	}

	ASSERT(pIStream);
	if(pIStream == NULL)
	{
		return E_POINTER;
	}

	if(m_pSourceFileHandler == NULL)
	{
		return E_FAIL;
	}

    CWaveNode* pWaveNode = m_pWave->GetNode();
	ASSERT(pWaveNode);
	if(pWaveNode == NULL)
	{
		return E_UNEXPECTED;
	}

	CDLSComponent* pComponent = pWaveNode->GetComponent();
	ASSERT(pComponent);
	if(pComponent == NULL)
	{
		return E_UNEXPECTED;
	}

	// Update the header information
	UpdateHeaderInfo();

	// Set the start offset
	DWORD dwHeaderOffset = StreamTell(pIStream);
	
	// Take out the header bytes
	dwHeaderOffset -= 12; 
	m_pSourceFileHandler->SetStartOffset(dwHeaderOffset);
	if(FAILED(m_pSourceFileHandler->ResetOffsets()))
	{
		return E_FAIL;
	}

	while(!m_plstDeltas->IsEmpty())
	{
		delete m_plstDeltas->RemoveHead();

	}

	m_pUndoManager->Initialize();

	// The first delta is always the entire unmodified wave data
	DWORD dwDataOffset = m_pSourceFileHandler->GetDataOffset();
	DWORD dwDataSize = m_pWave->m_OriginalWavObj.dwDataSize;
	DWORD dwLength = m_pWave->GetWaveLength();

	m_pWave->SetHeaderOffset(dwHeaderOffset);
	m_pWave->SetDataOffset(dwDataOffset);

	// Initialize the decomp file if we're loading a runtime
	// compressed wave file....
	if(m_pWave->m_bLoadingRuntime && m_pWave->m_bCompressed)
	{
		DWORD dwCodec = m_pWave->m_rWaveformat.wFormatTag;
		if(FAILED(DecompressRuntimeData()))
		{
			
			if(pComponent->IsInFailedCodecs(dwCodec) == FALSE)
			{
				pComponent->AddToFailedCodecs(dwCodec);

				CString sErrMsg;
				CString sName = "";
				BSTR bstrName;
				if(SUCCEEDED(pWaveNode->GetName(&bstrName)))
				{
					sName = bstrName;
					::SysFreeString(bstrName);
				}
				if(pWaveNode->IsInACollection())
				{
					sErrMsg.Format(IDS_ERR_DLS_RUNTIME_UNSUPPORTED_COMPRESSION_FORMAT, sName);
				}
				else
				{
					sErrMsg.Format(IDS_ERR_WVP_RUNTIME_UNSUPPORTED_COMPRESSION_FORMAT, sName);
				}

				AfxMessageBox(sErrMsg);
			}

			return E_FAIL;
		}
		
		// Check if this was previously in the failed codecs and remove it
		pComponent->RemoveFromFailedCodecs(dwCodec);

        m_bDecompressedRunTime = TRUE;
        m_bDecompressedDesignTime = FALSE;
	}
	else if(m_pWave->m_bCompressed)
	{
		if(FAILED(DecompressDesigntimeData()))
		{
			static bool bShowMessage = true;
			if(bShowMessage)
			{
				AfxMessageBox(IDS_ERR_UNSUPPORTED_COMPRESSION_FORMAT);
			}

			bShowMessage = false;
			m_pWave->m_bCompressed = false;
			m_pWave->CleanWaveObject(&m_pWave->m_CompressedWavObj);
		}
		else
		{
            m_bDecompressedDesignTime = TRUE;
            m_bDecompressedRunTime = FALSE;
		}
	}

    dwDataSize = m_pWave->m_OriginalWavObj.dwDataSize;
    dwLength = dwDataSize / (m_pWave->m_OriginalWavObj.WaveFormatEx.wBitsPerSample / 8);
    dwLength /= m_pWave->m_OriginalWavObj.WaveFormatEx.nChannels;

    // Are we reading from the copied decomp file?
    // In that case our offset is 0
    if(m_pCopyFileHandler != NULL)
    {
        dwDataOffset = 0;
    }

    CWaveDelta* pDelta = new CWaveDelta(0, 0, dwLength, dwDataOffset, FALSE);
	if(pDelta == NULL)
	{
		return E_OUTOFMEMORY;
	}
	
	m_plstDeltas->AddTail(pDelta);

    m_bNeedToMakeSrcDelta = m_bDecompressedDesignTime;

    if(FAILED(UpdateUncompressedDeltas()))
    {
        return E_FAIL;
    }

	return S_OK;
}


/////////////////////////////////////////////////////
//
// CWaveDataManager::GetData
//
/////////////////////////////////////////////////////
HRESULT CWaveDataManager::GetData(DWORD dwStartSample, DWORD dwLength, BYTE* pbData, DWORD& dwBytesRead, bool bGetUncompressed)
{
	ASSERT(m_pWave);
	if(m_pWave == NULL)
	{
		return E_FAIL;
	}

	ASSERT(pbData);
	if(pbData == NULL)
	{
		return E_POINTER;
	}

    CWaveNode* pWaveNode = m_pWave->GetNode();
    ASSERT(pWaveNode);
    if(pWaveNode == NULL)
    {
        return E_UNEXPECTED;
    }

	ASSERT(m_plstDeltas);
	if(m_plstDeltas == NULL)
	{
		return E_FAIL;
	}

    bool bReadFromCopy = false;

	// If the wave is compressed we want to read from the decomp file
    // Unless this was a runtime decompressed file....the source then 
    // is comrpessed so we should pick up the data from the decomp file
	if((m_pWave->m_bCompressed == true && bGetUncompressed == false) || 
        (bGetUncompressed == true && m_bDecompressedRunTime == TRUE && pWaveNode->IsInACollection() == false))
	{
		return GetDecompData(dwStartSample, dwLength, pbData, dwBytesRead);
	}
    else if(m_pCopyFileHandler && pWaveNode->IsSourceInTempFile() == TRUE && pWaveNode->IsInACollection() == true)
    {
        bReadFromCopy = true;
	}

	// The wave data might be deleted...so don't fail just return S_OK
	if(dwLength == 0)
	{
		return S_OK;
	}

	BOOL bStereo = m_pWave->IsTrueStereo();
	int nChannels = bStereo ? 2 : 1;
	int nSampleSize = m_pWave->m_rWaveformat.wBitsPerSample / 8;

    CPtrList* plstDeltas = m_plstDeltas;
    if(bGetUncompressed)
    {
        nSampleSize = m_pWave->m_OriginalWavObj.WaveFormatEx.wBitsPerSample / 8;

        ASSERT(m_plstUncompressedDeltas);
        if(m_plstUncompressedDeltas == NULL)
        {
            return E_FAIL;
        }
        
        plstDeltas = m_plstUncompressedDeltas;
    }


    // This is set to TRUE only when decompressing design-time waves
    // The only delta we have at this point is the decompressed delta
    // We need to go to the original wave to get the uncompressed wave data
    if(m_bNeedToMakeSrcDelta)
    {
        m_bNeedToMakeSrcDelta = false;

        int nDeltas = plstDeltas->GetCount();
        ASSERT(nDeltas== 1);
        
        if(nDeltas == 1)
        {
            DWORD dwSrcSize = m_pWave->m_OriginalWavObj.dwDataSize;
            DWORD dwSrcLength = dwSrcSize / nChannels;
            if(nSampleSize == 2)
            {
                dwSrcLength = dwSrcSize >> 1;
            }

            // Modify the old delta to point to the uncompressed source....
            // It should have been cloned and saved in SaveUndoState call
            CWaveDelta* pDelta = (CWaveDelta*)plstDeltas->GetHead();
            ASSERT(pDelta);
            if(pDelta)
            {
                pDelta->SetLength(dwSrcLength);
            }

            // Adjust the uncomrpessed deltas too
            if(m_plstUncompressedDeltas && m_plstUncompressedDeltas->GetCount() == 1)
            {
                CWaveDelta* pDelta = (CWaveDelta*)m_plstUncompressedDeltas->GetHead();
                ASSERT(pDelta);
                if(pDelta)
                {
                    pDelta->SetLength(dwSrcLength);
                }
            }
        }
        else
        {
            return E_UNEXPECTED;
        }
    }



	// Search the deltas where the datas lie
	POSITION startPosition = NULL;
	POSITION endPosition = NULL;
	POSITION position = plstDeltas->GetHeadPosition();
	while(position)
	{
		POSITION tempPosition = position;
		CWaveDelta* pDelta = (CWaveDelta*) plstDeltas->GetNext(position);
		ASSERT(pDelta);
		if(pDelta->IsSampleInDelta(dwStartSample))
		{
			startPosition = tempPosition;
		}
		
		if(pDelta->IsSampleInDelta(dwStartSample + (dwLength - 1)))
		{
			endPosition = tempPosition;
		}
	}

	if(startPosition == NULL || endPosition == NULL)
	{
		return E_FAIL;
	}
	
	HRESULT hr = E_FAIL;
	dwBytesRead = 0;
	DWORD dwStartSampleForBuffer = dwStartSample;
	DWORD dwBufferSize = dwLength * nChannels * nSampleSize;
	DWORD dwSamplesToRead = dwLength;
	BYTE* pbCurrent = pbData;
	
	bool bContinue = true;
	position = startPosition;
	while(position && bContinue)
	{
		// Continue until we read the end position delta
		bContinue = position == endPosition ? false : true;

		CWaveDelta* pDelta = (CWaveDelta*) plstDeltas->GetNext(position);		
		ASSERT(pDelta);
		DWORD cb = 0;
		if(FAILED(hr = GetData(pDelta, dwStartSampleForBuffer, dwSamplesToRead, pbCurrent, cb, bReadFromCopy)))
		{
			hr = E_FAIL;
			break;
		}

		// How many smaples did we read just now?
		// Add them to the total number bytes read so far
		dwBytesRead += cb;

		// how many samples have we read so far?
		DWORD dwSamplesRead = cb / nSampleSize;

		// What's the start for the next buffer then?
		// We might be reading interleaved stereo data so consider channels...
		dwStartSampleForBuffer += dwSamplesRead / nChannels; 

		// how much of the buffer is filled up now?
		dwBufferSize -= dwBytesRead;

		// How many samples do we have left to read?
		dwSamplesToRead = dwLength - ((dwBytesRead / nSampleSize) / nChannels);

		// Move the pointer to the data buffer by the correct amount...
		pbCurrent = pbData + dwBytesRead;
		
	}

	return hr;
}

/////////////////////////////////////////////////////
//
// CWaveDataManager::GetData
//
/////////////////////////////////////////////////////
HRESULT CWaveDataManager::GetData(CWaveDelta* pDelta, DWORD dwStartSample, DWORD dwLength, BYTE* pbData, DWORD& dwBytesRead, bool bReadFromCopy)
{
	ASSERT(m_pWave);
	if(m_pWave == NULL)
	{
		return E_FAIL;
	}

	ASSERT(pDelta);
	if(pDelta == NULL)
	{
		return E_POINTER;
	}

	ASSERT(pbData);
	if(pbData == NULL)
	{
		return E_POINTER;
	}

	if(bReadFromCopy)
	{
		ASSERT(m_pCopyFileHandler);
		if(m_pCopyFileHandler == NULL)
		{
			return E_FAIL;
		}
	}

	BOOL bStereo = m_pWave->IsTrueStereo();


	int nChannels = bStereo ? 2 : 1;
	int nSampleSize = m_pWave->m_rWaveformat.wBitsPerSample / 8;

	BOOL bIsEditDelta = pDelta->IsEditDelta();
	DWORD dwDeltaLength = pDelta->GetLength();
	DWORD dwDeltaActualStart = pDelta->GetActualPosition();
	DWORD dwDeltaActualEnd = dwDeltaActualStart + dwDeltaLength;
	DWORD dwFileOffset = pDelta->GetFileOffset();

	if(dwStartSample < dwDeltaActualStart || dwStartSample > dwDeltaActualEnd)
	{
		dwBytesRead = 0;
		return E_FAIL;
	}

	if((dwStartSample + dwLength) > dwDeltaActualEnd)
	{
		dwLength = dwDeltaActualEnd - dwStartSample;
	}

	CWaveFileHandler* pFileHandler = m_pSourceFileHandler;
	if(bReadFromCopy)
	{
		pFileHandler = m_pCopyFileHandler;
	}

	UINT nBytesToRead = dwLength * nSampleSize * nChannels;
	if(bIsEditDelta)
	{
		ASSERT(m_pTempFileHandler);
		pFileHandler = m_pTempFileHandler;
	}

	if(pFileHandler == NULL)
	{
		return E_FAIL;
	}

	DWORD dwStartDiff = dwStartSample - dwDeltaActualStart;
	DWORD dwOffsetDiff = dwStartDiff * nSampleSize * nChannels;
	DWORD dwReadOffset = dwFileOffset + dwOffsetDiff;

    // If we're reading from the decompressed file copy then we don't have an offset
    // The offset with the delta in this case is the offset in the original source file
    // which has the compressed data....this is especially important for runtime collections
    /*if(bReadFromCopy)
	{
        dwReadOffset = 0;
    }*/
	
	DWORD cb = 0;
	if(FAILED(pFileHandler->ReadData(dwReadOffset, nBytesToRead, pbData, cb)))
	{
		return E_FAIL;
	}

	dwBytesRead += cb;

	return S_OK;
}


HRESULT CWaveDataManager::InsertData(DWORD dwInsertAt, BYTE* pbData, DWORD dwLength)
{
	ASSERT(m_pWave);
	if(m_pWave == NULL)
	{
		return E_FAIL;
	}

	ASSERT(pbData);
	if(pbData == NULL)
	{
		return E_POINTER;
	}

	if(m_pTempFileHandler == NULL)
	{
		m_pTempFileHandler = new CWaveTempFileHandler(m_sTempFileName);
		ASSERT(m_pTempFileHandler);
		if(m_pTempFileHandler == NULL)
		{
			return E_OUTOFMEMORY;
		}
	}

	BOOL bStereo = m_pWave->IsTrueStereo();
	int nChannels = bStereo ? 2 : 1;
	int nSampleSize = m_pWave->m_rWaveformat.wBitsPerSample / 8;

	// Write the insertion data to the temp file and remember the file offset
	DWORD dwTempFileOffset = m_pTempFileHandler->SeekToEnd();
	DWORD dwBytesToWrite = dwLength * nChannels * nSampleSize;
	m_pTempFileHandler->Write((void*)pbData, dwBytesToWrite);
	
	// Create the new insertion delta
	CWaveDelta* pInsertDelta = new CWaveDelta(dwInsertAt, 0, dwLength, dwTempFileOffset, TRUE);
	if(pInsertDelta == NULL)
	{
		return E_OUTOFMEMORY;
	}

	// Find out the position where the data needs to be inserted
	POSITION position = m_plstDeltas->GetHeadPosition();
	while(position)
	{
		POSITION insertionPosition = position;
		CWaveDelta* pDelta = (CWaveDelta*) m_plstDeltas->GetNext(position);
		ASSERT(pDelta);

		if(pDelta->IsSampleInDelta(dwInsertAt) == TRUE)
		{
			// Split the existing delta so we can insert the new data
			DWORD dwOldDeltaLength = pDelta->GetLength();
			DWORD dwOldFileOffset = pDelta->GetFileOffset();
			DWORD dwOldDeltaPosition = pDelta->GetActualPosition();
			DWORD dwOldStartSample = pDelta->GetStartSample();
			BOOL bEditDelta = pDelta->IsEditDelta();

			DWORD dwNewLength = 0;
			if(dwInsertAt > 0)
			{
				dwNewLength = dwInsertAt - dwOldDeltaPosition;	
			}

			DWORD dwSplitDeltaPosition = dwInsertAt + dwLength;
			DWORD dwSplitDeltaLength = dwOldDeltaLength - dwNewLength;
			DWORD dwSplitDeltaStart = dwOldStartSample + dwNewLength;
			
			BOOL bIsStereo = m_pWave->IsTrueStereo();
			int nBytesPerSample = m_pWave->m_rWaveformat.wBitsPerSample / 8;

			DWORD dwStartSampleDifference = dwSplitDeltaStart - dwOldStartSample;
			DWORD dwSpitDeltaFileOffset = dwOldFileOffset + (dwStartSampleDifference * nBytesPerSample * nChannels);
				
			CWaveDelta* pSplitDelta = NULL;
			if(dwSplitDeltaLength > 0)
			{
				pSplitDelta = new CWaveDelta(dwSplitDeltaPosition, dwSplitDeltaStart, dwSplitDeltaLength, dwSpitDeltaFileOffset, bEditDelta);
				if(pSplitDelta == NULL)
				{
					return E_OUTOFMEMORY;
				}
			}

			// For the first half of the split delta only the length changes
			pDelta->SetLength(dwNewLength);

			// Insert the new insertion delta before the second half of the split delta
			insertionPosition = m_plstDeltas->InsertAfter(insertionPosition, pInsertDelta);

			// Insert the second half of the split delta
			if(pSplitDelta)
			{
				m_plstDeltas->InsertAfter(insertionPosition, pSplitDelta);
			}

			ResetActualDeltaStarts();

			return S_OK;
		}
	}

	// We didn't find this insertion position in any of the deltas...add it to the end
	m_plstDeltas->AddTail(pInsertDelta);

	return S_OK;
}


HRESULT CWaveDataManager::RemoveData(DWORD dwStartSample, DWORD dwSamples)
{
	ASSERT(m_pWave);
	if(m_pWave == NULL)
	{
		return E_FAIL;
	}
	
	BOOL bStereo = m_pWave->IsTrueStereo();
	int nChannels = bStereo ? 2 : 1;
	int nSampleSize = m_pWave->m_rWaveformat.wBitsPerSample / 8;

	DWORD dwStart = dwStartSample;
	DWORD dwLength = dwSamples;

	POSITION position = m_plstDeltas->GetHeadPosition();
	while(position)
	{
		POSITION insertionPosition = position;
		CWaveDelta* pDelta = (CWaveDelta*) m_plstDeltas->GetNext(position);
		ASSERT(pDelta);

		// What's our end sample?
		DWORD dwEndSample = dwStart + (dwLength - 1);

		// Get the delta params
		DWORD dwDeltaPosition = pDelta->GetActualPosition();
		DWORD dwDeltaStart = pDelta->GetStartSample();
		DWORD dwDeltaLength = pDelta->GetLength();
		DWORD dwFileOffset = pDelta->GetFileOffset();
		DWORD dwDeltaEnd = dwDeltaPosition + dwDeltaLength;
		BOOL bEditDelta = pDelta->IsEditDelta();

		// If the start and end are in the same delta we need to split that delta
		if(pDelta->IsSampleInDelta(dwStart) && pDelta->IsSampleInDelta(dwEndSample))
		{
			DWORD dwSamplesRemoved = dwLength;
			DWORD dwBytesRemoved = dwLength * nSampleSize * nChannels;
			DWORD dwNewDeltaLength = dwStart - dwDeltaPosition;

			DWORD dwSplitPosition = dwDeltaPosition + dwNewDeltaLength;
			DWORD dwSplitLength = dwDeltaEnd - dwSplitPosition - dwSamplesRemoved;
			DWORD dwSplitStart = dwDeltaStart + dwNewDeltaLength + dwLength;
			DWORD dwStartDiff = dwSplitStart - dwDeltaStart;
			DWORD dwSplitFileOffset = dwFileOffset + (dwStartDiff * nSampleSize * nChannels);

			// Create the split delta
			CWaveDelta* pSplitDelta = new CWaveDelta(dwSplitPosition, dwSplitStart, dwSplitLength, dwSplitFileOffset, bEditDelta);
			ASSERT(pSplitDelta);
			if(pSplitDelta == NULL)
			{
				return E_OUTOFMEMORY;
			}

			// Update old delta and insert the split one
			pDelta->SetLength(dwNewDeltaLength);
			m_plstDeltas->InsertAfter(insertionPosition, pSplitDelta);

			break;
		}
		else if(pDelta->IsSampleInDelta(dwStart))
		{
			// Only the length changes for the start delta
			DWORD dwSamplesRemoved = dwDeltaEnd - dwStart;
			DWORD dwNewDeltaLength = dwDeltaLength - dwSamplesRemoved;

			pDelta->SetLength(dwNewDeltaLength);

			dwStart += dwSamplesRemoved;
			dwLength -= dwSamplesRemoved;
		}
		else if(pDelta->IsSampleInDelta(dwEndSample))
		{
			// The actual position of the delta shifts as well as the start sample, length and the file offset
			DWORD dwNewPosition = dwEndSample;
			DWORD dwSamplesRemoved = dwNewPosition - dwDeltaPosition;
			DWORD dwBytesRemoved = dwSamplesRemoved * nSampleSize * nChannels;
			DWORD dwNewFileOffset = dwFileOffset + dwBytesRemoved;
			DWORD dwNewStart = dwDeltaStart + dwSamplesRemoved;
			DWORD dwNewLength = dwDeltaLength - dwSamplesRemoved;

			// Set the new values on the delta
			pDelta->SetActualPosition(dwNewPosition);
			pDelta->SetLength(dwNewLength);
			pDelta->SetFileOffset(dwNewFileOffset);
			pDelta->SetStartSample(dwNewStart);
		}
	}

	// Make sure all actual positions are correct
	ResetActualDeltaStarts();

	return S_OK;
}


void CWaveDataManager::ResetActualDeltaStarts()
{
	// Go through the list and remove all deltas of 0 length
	POSITION position = m_plstDeltas->GetHeadPosition();
	while(position)
	{
		POSITION oldPosition = position;
		CWaveDelta* pDelta = (CWaveDelta*) m_plstDeltas->GetNext(position);
		ASSERT(pDelta);
		if(pDelta->GetLength() == 0)
		{
			m_plstDeltas->RemoveAt(oldPosition);
			delete pDelta;
		}
	}

	// Now reset the positions
	DWORD dwStart = 0;
	position = m_plstDeltas->GetHeadPosition();
	while(position)
	{
		CWaveDelta* pDelta = (CWaveDelta*) m_plstDeltas->GetNext(position);
		ASSERT(pDelta);
		
		pDelta->SetActualPosition(dwStart);
		dwStart += pDelta->GetLength();
	}
}


HRESULT CWaveDataManager::CopyDecompFile()
{
	// Have we already copied the source??
	// We don't need to do it again, do we?
	ASSERT(m_pCopyFileHandler == NULL);
	if(m_pCopyFileHandler != NULL)
	{
		return S_OK;
	}

	// Create a temp filename for the copy
	if(m_sCopyFileName.IsEmpty())
	{
		char szCopyFileName[MAX_PATH];

		CString sPrefix = "DMP";
		CString sExtension = "tmp";
		if(FAILED(CreateUniqueTempFile(sPrefix, sExtension, m_sCopyFileName)))
		{
			GetTempFileName(m_sTempFilePath, sPrefix, 0, szCopyFileName);
			m_sCopyFileName = szCopyFileName;	
		}
	}

	// Copy the file
	if(CopyFile(m_sDecompFileName, m_sCopyFileName, FALSE) == FALSE)
	{
		DWORD dwLastError = GetLastError();
		LPVOID lpvError;
		FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM, NULL, dwLastError, MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), (LPTSTR)&lpvError, 0, NULL);
		CString sDetails;
		sDetails.Format("\n%s", (LPCSTR)lpvError);
		AfxMessageBox(sDetails);
		return E_FAIL;
	}

	// Create the file handler for the copy
	m_pCopyFileHandler = new CWaveFileHandler(m_sCopyFileName, CFile::modeRead);
	ASSERT(m_pCopyFileHandler);
	if(m_pCopyFileHandler == NULL)
	{
		return E_OUTOFMEMORY;
	}

	return S_OK;		
}


HRESULT CWaveDataManager::SaveUncompressedDataToStream(IStream* pIStream, DWORD& dwBytesWritten)
{
	ASSERT(m_pWave);
	if(m_pWave == NULL)
	{
		return E_FAIL;
	}

	ASSERT(pIStream);
	if(pIStream == NULL)
	{
		return E_POINTER;
	}

	IDMUSProdRIFFStream* pIRiffStream = NULL;
	if(FAILED(AllocRIFFStream(pIStream, &pIRiffStream)))
	{
		return E_OUTOFMEMORY;
	}

	BOOL bStereo = m_pWave->IsTrueStereo();
	int nChannels = bStereo ? 2 : 1;
	int nSampleSize = m_pWave->m_OriginalWavObj.WaveFormatEx.wBitsPerSample / 8;

	dwBytesWritten = 0;
	
	// We need to write the data in chunks as the data size might be really huge
	DWORD dwSamplesWritten = 0;
	DWORD dwStart = 0;
	
	// We'll write WAVE_DATA_BUFFER_SIZE samples at a time
	// Unless the wave is small enough to read in one shot
    DWORD dwDataSize = m_pWave->m_OriginalWavObj.dwDataSize;
    DWORD dwWaveLength = nSampleSize == 1 ? (dwDataSize / nChannels) : ((dwDataSize >> 1) / nChannels);
	DWORD dwLength = dwWaveLength > WAVE_DATA_BUFFER_SIZE ? WAVE_DATA_BUFFER_SIZE : dwWaveLength;

	while(dwSamplesWritten < dwWaveLength)
	{
		DWORD dwBytesToWrite = dwLength * nChannels * nSampleSize;
		BYTE* pbData = NULL;
		DWORD cb = 0;

        if(FAILED(m_pWave->SafeAllocBuffer(&pbData, dwBytesToWrite)))
        {
            dwBytesWritten = 0;
            pIRiffStream->Release();
            return E_OUTOFMEMORY;
        }

		if(FAILED(GetData(dwStart, dwLength, pbData, cb, true)))
		{
            delete[] pbData;
			dwBytesWritten = 0;
			pIRiffStream->Release();
			return E_FAIL;
		}

		DWORD cbStream = 0;
		if(FAILED(pIStream->Write((void*)pbData, cb, &cbStream)) || cbStream != cb)
		{
			delete[] pbData;
			pIRiffStream->Release();
			return E_FAIL;
		}
	
		dwBytesWritten += cb;
		dwSamplesWritten += (cb / nSampleSize) / nChannels;
		dwStart = dwSamplesWritten;
		dwLength = (dwWaveLength - dwSamplesWritten);
		dwLength = dwLength > WAVE_DATA_BUFFER_SIZE ? WAVE_DATA_BUFFER_SIZE : dwLength;
		delete[] pbData;
	}
	
	pIRiffStream->Release();

	ASSERT(dwSamplesWritten == dwWaveLength);
	return S_OK;
}


HRESULT	CWaveDataManager::CreateDecompFile()
{
	// We might have an earlier file with the decompressed data
	// Delete that handler and create a new one...
	if(m_pDecompFileHandler)
	{
		delete m_pDecompFileHandler;
		m_pDecompFileHandler = NULL;
	}
	
	m_pDecompFileHandler = new CWaveFileHandler(m_sDecompFileName, CFile::modeCreate | CFile::modeReadWrite);
	if(m_pDecompFileHandler == NULL)
	{
		return E_OUTOFMEMORY;
	}

	return S_OK;
}


HRESULT CWaveDataManager::WriteDecompressedData(BYTE* pbData, DWORD dwDataSize)
{
	ASSERT(pbData);
	if(pbData == NULL)
	{
		return E_POINTER;
	}

	ASSERT(m_pDecompFileHandler);
	if(m_pDecompFileHandler == NULL)
	{
		return E_FAIL;
	}

	// Append the passed data
	m_pDecompFileHandler->SeekToEnd();
	
	try
	{
		m_pDecompFileHandler->Write((void*)pbData, dwDataSize);
	}
	catch(CFileException e)
	{
		return E_FAIL;
	}

	return S_OK;
}

HRESULT CWaveDataManager::GetDecompData(DWORD dwStartSample, DWORD dwLength, BYTE* pbData, DWORD& dwBytesRead)
{
	// Do we have a decomp file handler?
	ASSERT(m_pDecompFileHandler);
	if(m_pDecompFileHandler == NULL)
	{
		return E_FAIL;
	}

	ASSERT(m_pWave);
	if(m_pWave == NULL)
	{
		return E_FAIL;
	}
	
	BOOL bStereo = m_pWave->IsTrueStereo();
	int nChannels = bStereo ? 2 : 1;
	int nSampleSize = m_pWave->m_rWaveformat.wBitsPerSample / 8;

	// Must have a preallocated buffer passed...
	ASSERT(pbData);
	if(pbData == NULL)
	{
		return E_POINTER;
	}

	// Get the offset to the start sample and the bytes to read
	DWORD dwReadOffset = dwStartSample * nChannels * nSampleSize;
	DWORD dwBytesToRead = dwLength * nChannels * nSampleSize;

	DWORD cb = 0;
	if(FAILED(m_pDecompFileHandler->ReadData(dwReadOffset, dwBytesToRead, pbData, cb)))
	{
		dwBytesRead = 0;
		return E_FAIL;
	}

	dwBytesRead = cb;

	return S_OK;
}


HRESULT CWaveDataManager::RenameSource(CString sNewSourceName)
{
	if(FAILED(CloseSourceHandler()))
	{
		return E_FAIL;
	}

	// Rename the file
	try
	{
		m_pSourceFileHandler->Rename(m_sSourceFileName, sNewSourceName);
	}
	catch(CFileException e)
	{
		return E_FAIL;
	}

	return OnSourceRenamed(sNewSourceName);

}



HRESULT CWaveDataManager::OnSourceRenamed(CString sNewSourceFile)
{
	// Close the previous file if it's open
	ASSERT(m_pSourceFileHandler);
	if(m_pSourceFileHandler == NULL)
	{
		return E_POINTER;
	}
	
	if(m_pSourceFileHandler->Open(sNewSourceFile, CFile::modeRead | CFile::typeBinary | CFile::shareDenyNone, NULL) == 0)
	{
		return E_FAIL;
	}

	m_sSourceFileName = sNewSourceFile;

	return S_OK;
}


CString CWaveDataManager::GetSourceFileName()
{
	return m_sSourceFileName;
}


HRESULT CWaveDataManager::Initialize(CString sFileName, DWORD dwHeaderOffset, DWORD dwDataOffset, bool bDeleteOldSource)
{
	ASSERT(!sFileName.IsEmpty());
	if(sFileName.IsEmpty())
	{
		return E_INVALIDARG;
	}

	ASSERT(m_pWave);
	if(m_pWave == NULL)
	{
		return E_FAIL;
	}

    CWaveNode* pWaveNode = m_pWave->GetNode();
    ASSERT(pWaveNode);
    if(pWaveNode == NULL)
    {
        return E_UNEXPECTED;
    }

	ASSERT(m_pSourceFileHandler);
	if(m_pSourceFileHandler == NULL)
	{
		return E_FAIL;
	}

	m_bInInit = TRUE;

	// Update the header information
	UpdateHeaderInfo();

    // we don't do anything if our source is outside of a collection
    // and this is not a cleanup after the save where we delete the temp file
    if(bDeleteOldSource == false && 
        pWaveNode->IsSourceInTempFile() == TRUE &&
        pWaveNode->IsInACollection() == TRUE)
    {
        return S_FALSE;
    }

	// Close the old temp file created before save 
	if(m_pSourceFileHandler->m_hFile != CFile::hFileNull)
	{
		m_pSourceFileHandler->Close();
	}
	
	// Delete the temp file only if we're NOT in a collection
	if(bDeleteOldSource)
	{
		if(m_pWave->GetCollection() == NULL)
		{	
			DeleteFile(m_sSourceFileName);
		}

        while(!m_plstDeltas->IsEmpty())
	    {
		    delete m_plstDeltas->RemoveHead();
	    }
	}

	if (FAILED(OnSourceRenamed(sFileName)))
		return E_FAIL;

    BOOL bSetCopyDeltaOffset = FALSE;
    if(m_pCopyFileHandler && m_bDecompressedRunTime == TRUE && pWaveNode->IsInACollection() == FALSE)
    {
        delete m_pCopyFileHandler;
		m_pCopyFileHandler = NULL;

		// Delete the copied source file
		DeleteFile(m_sCopyFileName);
        bSetCopyDeltaOffset = TRUE;
    }


	// The first delta is always the entire unmodified wave data
    // But keep the offset difference first
    // Just adjust the offsets for all deltas
    int nDataOffsetDiff = 0;
    if(bDeleteOldSource == false && pWaveNode->IsSourceInTempFile() == FALSE)
    {
        nDataOffsetDiff = dwDataOffset - m_pSourceFileHandler->GetDataOffset();
    }

	m_pSourceFileHandler->SetDataOffset(dwDataOffset);
	m_pSourceFileHandler->SetStartOffset(dwHeaderOffset);

	DWORD dwDataSize = m_HeaderInfo.m_dwDataSize;
	DWORD dwLength = m_HeaderInfo.m_dwWaveLength;

    if(bDeleteOldSource)
    {
	    CWaveDelta* pDelta = new CWaveDelta(0, 0, dwLength, dwDataOffset, FALSE);
	    if(pDelta == NULL)
	    {
		    return E_OUTOFMEMORY;
	    }
	    
        m_plstDeltas->AddTail(pDelta);

        // If the wave is compressed make sure we create the source delta when required
        if(m_pWave->m_bCompressed)
        {
            m_bNeedToMakeSrcDelta = TRUE;
        }

	    m_pUndoManager->Initialize();

	    // Delete any temporary files created earlier
	    if(m_pTempFileHandler)
	    {
		    delete m_pTempFileHandler;
		    m_pTempFileHandler = NULL;

		    // Delete the created temp file
		    DeleteFile(m_sTempFileName);
	    }

        UpdateUncompressedDeltas();
    }
    else
    {
        POSITION position = m_plstDeltas->GetHeadPosition();
        while(position)
        {
            CWaveDelta* pDelta = (CWaveDelta*)m_plstDeltas->GetNext(position);
            ASSERT(pDelta);
            if(pDelta && pDelta->IsEditDelta() == FALSE)
            {
                if(bSetCopyDeltaOffset)
                {
                    pDelta->SetFileOffset(dwDataOffset);
                }
                else
                {
                    pDelta->SetFileOffset(pDelta->GetFileOffset() + nDataOffsetDiff);
                }
            }
        }

        // Do the same thing for the uncompressed deltas
        if(m_plstUncompressedDeltas)
        {
            position = m_plstUncompressedDeltas->GetHeadPosition();
            while(position)
            {
                CWaveDelta* pDelta = (CWaveDelta*)m_plstUncompressedDeltas->GetNext(position);
                ASSERT(pDelta);
                if(pDelta && pDelta->IsEditDelta() == FALSE)
                {
                    if(bSetCopyDeltaOffset)
                    {
                        pDelta->SetFileOffset(dwDataOffset);
                    }
                    else
                    {
                        pDelta->SetFileOffset(pDelta->GetFileOffset() + nDataOffsetDiff);
                    }
                }
            }
        }
    }

	m_bInInit = FALSE;

    m_bDecompressedDesignTime = FALSE;
    m_bDecompressedRunTime = FALSE;

	return S_OK;
}


HRESULT CWaveDataManager::CloseSourceHandler()
{
	ASSERT(m_pSourceFileHandler);
	if(m_pSourceFileHandler == NULL)
	{
		return E_POINTER;
	}

	if(m_pSourceFileHandler->m_hFile != CFile::hFileNull)
	{
		m_pSourceFileHandler->Close();
	}

	return S_OK;
}


HRESULT CWaveDataManager::DecompressDesigntimeData()
{
	ASSERT(m_pWave);
	if(m_pWave == NULL)
	{
		return E_FAIL;
	}

	ASSERT(m_pSourceFileHandler);
	if(m_pSourceFileHandler == NULL)
	{
		return E_POINTER;
	}

	if(FAILED(CreateDecompFile()))
	{
		return E_FAIL;
	}

    CWaveNode* pWaveNode = m_pWave->GetNode();
    ASSERT(pWaveNode);
    if(pWaveNode == NULL)
    {
        return E_UNEXPECTED;
    }

    if(pWaveNode->IsInACollection() == FALSE && 
        (m_pWave->m_CompressedWavObj.WaveFormatEx.wFormatTag == WMAUDIO_FORMAT_TAG || 
        m_pWave->m_CompressedWavObj.WaveFormatEx.wFormatTag == MSAUDIO_FORMAT_TAG))
    {
        return E_FAIL;
    }

	int nExtraBytes = m_pWave->m_CompressedWavObj.WaveFormatEx.cbSize;
	WAVEFORMATEX* pwfxDest = NULL;
	if(FAILED(m_pWave->SafeAllocBuffer((BYTE**)&pwfxDest, sizeof(WAVEFORMATEX) + nExtraBytes)))
	{
		return E_OUTOFMEMORY;
	}

	CopyMemory((BYTE*)pwfxDest, (BYTE*)&(m_pWave->m_CompressedWavObj.WaveFormatEx), sizeof(WAVEFORMATEX));
	CopyMemory((BYTE*)pwfxDest + sizeof(WAVEFORMATEX), m_pWave->m_CompressedWavObj.pbExtractWaveFormatData, nExtraBytes);

	WAVEFORMATEX wfxSource = m_pWave->m_OriginalWavObj.WaveFormatEx;

	int nBytesPerSample = wfxSource.wBitsPerSample / 8;
	int nChannels = wfxSource.nChannels;

	DWORD dwUncompressedSize = m_pWave->m_OriginalWavObj.dwDataSize;
	DWORD dwDecompressedSize = 0;
	DWORD dwCompressedSize = 0;
	DWORD dwBytesConverted = 0;
	DWORD dwBytesToConvert = dwUncompressedSize; 
	DWORD dwSamplesToConvert = (dwUncompressedSize / nBytesPerSample) / nChannels;
	DWORD dwDataOffset = m_pSourceFileHandler->GetDataOffset();
	
	while(dwBytesConverted < dwUncompressedSize)
	{
		/*if(dwSamplesToConvert > WAVE_DATA_BUFFER_SIZE * 2)
		{
			dwBytesToConvert  = WAVE_DATA_BUFFER_SIZE * nChannels * nBytesPerSample;
		}*/

		BYTE* pbData = NULL;
		if(FAILED(m_pWave->SafeAllocBuffer(&pbData, dwBytesToConvert)))
		{
			delete[] pwfxDest;
			return E_OUTOFMEMORY;
		}

		DWORD cbRead = 0;
		if(FAILED(m_pSourceFileHandler->ReadData(dwDataOffset + dwBytesConverted, dwBytesToConvert, pbData, cbRead)))
		{
			delete[] pbData;
			delete[] pwfxDest;
			return E_FAIL;
		}

		// Compress the data now
		DWORD cbCompressed = 0;
		BYTE* pbCompressed = NULL;
		if(FAILED(m_pWave->ConvertWave(&wfxSource, pwfxDest, pbData, cbRead, &pbCompressed, cbCompressed)))
		{
			delete[] pbData;
			delete[] pwfxDest;
			return E_FAIL;
		}

		delete[] pbData;
		dwCompressedSize += cbCompressed;

		// Decompress the data now
		DWORD cbDecompressed = 0;
		BYTE* pbDecompressed = NULL;
		if(FAILED(m_pWave->ConvertWave(pwfxDest, &wfxSource, pbCompressed, cbCompressed, &pbDecompressed, cbDecompressed)))
		{
			delete[] pbCompressed;
			delete[] pwfxDest;
			return E_FAIL;
		}

		dwBytesConverted += cbRead;
		dwBytesToConvert = dwUncompressedSize - dwBytesConverted;
		dwSamplesToConvert = (dwBytesToConvert / nBytesPerSample) / nChannels;
		dwDecompressedSize += cbDecompressed;
	
		if(FAILED(WriteDecompressedData(pbDecompressed, cbDecompressed)))
		{
			delete[] pbCompressed;
			delete[] pbDecompressed;
			delete[] pwfxDest;
			return E_FAIL;
		}

		delete[] pbCompressed;
		delete[] pbDecompressed;
	}

	// Delete the temporary destination waveformat buffer
	if(pwfxDest)
	{
		delete[] pwfxDest;
	}

	m_pWave->m_dwWaveLength = (dwDecompressedSize / nBytesPerSample) / nChannels;
	m_pWave->m_dwDataSize = dwDecompressedSize;

	m_pWave->m_DecompressedWavObj.dwDataSize = dwDecompressedSize;
	CopyMemory(&(m_pWave->m_DecompressedWavObj.WaveFormatEx), &wfxSource, sizeof(WAVEFORMATEX));

	m_pWave->m_CompressedWavObj.dwDataSize = dwCompressedSize;
	
	if(m_pWave->IsStereo())
	{
		CWaveNode* pWaveNode = m_pWave->GetNode();
		ASSERT(pWaveNode);
		if(pWaveNode->IsInACollection() == false)
		{
			CStereoWave* pStereoWave = dynamic_cast<CStereoWave*>(pWaveNode->GetWave());
			ASSERT(pStereoWave);
			if(pStereoWave)
			{
				if(FAILED(pStereoWave->UpdateChannelsForStereoCompression()))
				{
					return E_FAIL;
				}
			}
		}
	}

	UpdateHeaderInfo();

	return S_OK;
}



HRESULT	CWaveDataManager::DecompressRuntimeData()
{
	ASSERT(m_pWave);
	if(m_pWave == NULL)
	{
		return E_FAIL;
	}

	ASSERT(m_pSourceFileHandler);
	if(m_pSourceFileHandler == NULL)
	{
		return E_POINTER;
	}

	if(FAILED(CreateDecompFile()))
	{
		return E_FAIL;
	}

    CWaveNode* pWaveNode = m_pWave->GetNode();
    ASSERT(pWaveNode);
    if(pWaveNode == NULL)
    {
        return E_UNEXPECTED;
    }

    if(pWaveNode->IsInACollection() == FALSE && 
        (m_pWave->m_CompressedWavObj.WaveFormatEx.wFormatTag == WMAUDIO_FORMAT_TAG || 
        m_pWave->m_CompressedWavObj.WaveFormatEx.wFormatTag == MSAUDIO_FORMAT_TAG))
    {
        return E_FAIL;
    }

	WAVEFORMATEX wfxDest = m_pWave->m_OriginalWavObj.WaveFormatEx;

	UINT nExtraBytes = m_pWave->m_CompressedWavObj.WaveFormatEx.cbSize;
	WAVEFORMATEX* pwfxCompression = NULL;
	if(FAILED(m_pWave->SafeAllocBuffer((BYTE**)&pwfxCompression, sizeof(WAVEFORMATEX) + nExtraBytes)))
	{
		return E_OUTOFMEMORY;
	}

	CopyMemory((BYTE*)pwfxCompression, &m_pWave->m_CompressedWavObj.WaveFormatEx, sizeof(WAVEFORMATEX));
	CopyMemory((BYTE*)pwfxCompression + sizeof(WAVEFORMATEX), m_pWave->m_CompressedWavObj.pbExtractWaveFormatData, nExtraBytes);

	// Gotta decompress in chunks
	DWORD dwCompressedSize = m_pWave->m_CompressedWavObj.dwDataSize;
	DWORD dwDecompressedSize = 0;
	DWORD dwConverted = 0;
	DWORD dwLength = dwCompressedSize;
	DWORD dwDataOffset = m_pSourceFileHandler->GetDataOffset();

	while(dwConverted < dwCompressedSize)
	{
		/*if(dwLength > WAVE_DATA_BUFFER_SIZE * 2)
		{
			dwLength = WAVE_DATA_BUFFER_SIZE;
		}*/

		BYTE* pbData = NULL;
		if(FAILED(m_pWave->SafeAllocBuffer(&pbData, dwLength)))
		{
			delete[] pwfxCompression;
			return E_OUTOFMEMORY;
		}

		DWORD cb = 0;
		if(FAILED(m_pSourceFileHandler->ReadData(dwDataOffset + dwConverted, dwLength, pbData, cb)))
		{
			delete[] pbData;
			delete[] pwfxCompression;
			return E_FAIL;
		}

		// Convert the data now
		DWORD cbDecompressed = 0;
		BYTE* pbDecompressed = NULL;
		if(FAILED(m_pWave->ConvertWave(pwfxCompression, &wfxDest, pbData, cb, &pbDecompressed, cbDecompressed)))
		{
			delete[] pbData;
			delete[] pwfxCompression;
			return E_FAIL;
		}

		if(cb > 0 && cbDecompressed == 0)
		{
			delete[] pbData;
			delete[] pwfxCompression;
			return E_FAIL;
		}

		dwConverted += cb;
		dwLength = dwCompressedSize - dwConverted;
		dwDecompressedSize += cbDecompressed;
	
		if(FAILED(WriteDecompressedData(pbDecompressed, cbDecompressed)))
		{
			delete[] pbData;
			delete[] pbDecompressed;
			delete[] pwfxCompression;
			return E_FAIL;
		}

		delete[] pbData;
		delete[] pbDecompressed;
	}

	if(pwfxCompression)
	{
		delete[] pwfxCompression;
		pwfxCompression = NULL;
	}

	int nBytesPerSample = wfxDest.wBitsPerSample / 8;
	int nChannels = wfxDest.nChannels;
	
	m_pWave->m_dwWaveLength = (dwDecompressedSize / nBytesPerSample) / nChannels;
	m_pWave->m_dwDataSize = dwDecompressedSize;

	m_pWave->m_DecompressedWavObj.dwDataSize = dwDecompressedSize;
	CopyMemory(&(m_pWave->m_DecompressedWavObj.WaveFormatEx), &wfxDest, sizeof(WAVEFORMATEX));

	// The original object also becomes the same format
	m_pWave->m_OriginalWavObj.dwDataSize = dwDecompressedSize;
	CopyMemory(&(m_pWave->m_rWaveformat), &wfxDest, sizeof(WAVEFORMATEX));

	if(m_pWave->IsStereo())
	{
		CWaveNode* pWaveNode = m_pWave->GetNode();
		ASSERT(pWaveNode);
		if(pWaveNode->IsInACollection() == false)
		{
			CStereoWave* pStereoWave = dynamic_cast<CStereoWave*>(pWaveNode->GetWave());
			ASSERT(pStereoWave);
			if(pStereoWave)
			{
				if(FAILED(pStereoWave->UpdateChannelsForStereoCompression()))
				{
					return E_FAIL;
				}
			}
		}
	}

	UpdateHeaderInfo();

    if(pWaveNode->IsInACollection())
    {
        if(FAILED(CopyDecompFile()))
        {
            return E_FAIL;
        }

        pWaveNode->SetSourceInTempFile(TRUE);
    }

	return S_OK;
}

HRESULT CWaveDataManager::SaveUndoState(CString sStateName)
{
	ASSERT(m_pWave);
	if(m_pWave == NULL)
		return E_FAIL;

	ASSERT(m_pUndoManager);
	if(m_pUndoManager == NULL)
		return E_FAIL;

	CPtrList* pClonedList = NULL;
	if(FAILED(CloneDeltaList(m_plstDeltas, &pClonedList)))
		return E_FAIL;

	// Ensure the loop points, sample rate, etc. are all current
	UpdateHeaderInfo();

    LPWAVEFORMATEX pwfxCompression = NULL;
    if(m_pWave->m_bCompressed)
	    {
        pwfxCompression = (LPWAVEFORMATEX) new BYTE[sizeof(WAVEFORMATEX) + m_pWave->m_CompressedWavObj.WaveFormatEx.cbSize];
        if(pwfxCompression == NULL)
        	{
			while (!pClonedList->IsEmpty())
				delete pClonedList->RemoveHead();
			delete pClonedList;
            return E_OUTOFMEMORY;
        	}

        CopyMemory((BYTE*)pwfxCompression, (BYTE*)&m_pWave->m_CompressedWavObj.WaveFormatEx, sizeof(WAVEFORMATEX));
        CopyMemory((BYTE*)pwfxCompression + sizeof(WAVEFORMATEX), m_pWave->m_CompressedWavObj.pbExtractWaveFormatData, m_pWave->m_CompressedWavObj.WaveFormatEx.cbSize);
	    }

	return m_pUndoManager->SaveState(sStateName, pClonedList, &m_HeaderInfo, pwfxCompression);
}

HRESULT CWaveDataManager::Undo()
{
	ASSERT(m_pUndoManager);
	if(m_pUndoManager == NULL)
	{
		return E_FAIL;
	}

	// Clone the delta list and pass it
	CPtrList* pDeltaList = NULL;
	if(FAILED(CloneDeltaList(m_plstDeltas, &pDeltaList)))
	{
		return E_FAIL;
	}

	// Ensure the loop points, sample rate, etc. are all current
	UpdateHeaderInfo();

    // We pass the compression format to the undo manager...
    // It may decide to keep it if it's saving a redo state or it will delete it to avoid leaks
    // Our contract is providing all the necessary information to persist in the state....
    LPWAVEFORMATEX pwfxCompression = NULL;
    if(m_pWave->m_bCompressed)
    {
        pwfxCompression = (LPWAVEFORMATEX) new BYTE[sizeof(WAVEFORMATEX) + m_pWave->m_CompressedWavObj.WaveFormatEx.cbSize];
        if(pwfxCompression == NULL)
        {
            return E_OUTOFMEMORY;
        }

        CopyMemory((BYTE*)pwfxCompression, (BYTE*)&m_pWave->m_CompressedWavObj.WaveFormatEx, sizeof(WAVEFORMATEX));
        CopyMemory((BYTE*)pwfxCompression + sizeof(WAVEFORMATEX), m_pWave->m_CompressedWavObj.pbExtractWaveFormatData, m_pWave->m_CompressedWavObj.WaveFormatEx.cbSize);
    }

	CPtrList* pNewList = NULL;
	if(FAILED(m_pUndoManager->Undo(pDeltaList, &pNewList, &m_HeaderInfo, &pwfxCompression)))
	{
		return E_FAIL;
	}

	CWaveNode* pWaveNode = m_pWave->GetNode();
	ASSERT(pWaveNode);
	if(pWaveNode == NULL)
	{
		return E_FAIL;
	}

	EnterCriticalSection(&pWaveNode->m_CriticalSection);
	
	CPtrList* pOldDeltas = m_plstDeltas;
	if(FAILED(CloneDeltaList(pNewList, &m_plstDeltas)))
	{
		LeaveCriticalSection(&pWaveNode->m_CriticalSection);
		return E_FAIL;
	}

	LeaveCriticalSection(&pWaveNode->m_CriticalSection);

	// Delete the old list
	while(!pOldDeltas->IsEmpty())
	{
		delete pOldDeltas->RemoveHead();
	}
	delete pOldDeltas;

    if(m_HeaderInfo.m_bCompressed)
    {
        if(FAILED(m_pWave->Compress(pwfxCompression, true)))
        {
            return E_FAIL;
        }

        // Adjust the header info for the newly compressed length
        m_HeaderInfo.m_dwDataSize = m_pWave->GetDataSize();
	    m_HeaderInfo.m_dwWaveLength = m_pWave->GetWaveLength();
    }

	// Get the new wavelength for the wave
	m_pWave->UpdateOnUndo(m_HeaderInfo);

	return S_OK;
}


HRESULT CWaveDataManager::Redo()
{
	ASSERT(m_pUndoManager);
	if(m_pUndoManager == NULL)
	{
		return E_FAIL;
	}

    LPWAVEFORMATEX pwfxCompression = NULL;

	// Get the new delta list
	CPtrList* pNewList = NULL;
	if(FAILED(m_pUndoManager->Redo(&pNewList, &m_HeaderInfo, &pwfxCompression)))
	{
		return E_FAIL;
	}

	CWaveNode* pWaveNode = m_pWave->GetNode();
	ASSERT(pWaveNode);
	if(pWaveNode == NULL)
	{
		return E_FAIL;
	}

	EnterCriticalSection(&pWaveNode->m_CriticalSection);
	CPtrList* pOldDeltas = m_plstDeltas;
	if(FAILED(CloneDeltaList(pNewList, &m_plstDeltas)))
	{
		LeaveCriticalSection(&pWaveNode->m_CriticalSection);
		return E_FAIL;
	}

	LeaveCriticalSection(&pWaveNode->m_CriticalSection);

	// Delete the old list
	while(!pOldDeltas->IsEmpty())
	{
		delete pOldDeltas->RemoveHead();
	}
	delete pOldDeltas;


    if(m_HeaderInfo.m_bCompressed)
    {
        if(FAILED(m_pWave->Compress(pwfxCompression, true)))
        {
            return E_FAIL;
        }

        // Adjust the header info for the newly compressed length
        m_HeaderInfo.m_dwDataSize = m_pWave->GetDataSize();
	    m_HeaderInfo.m_dwWaveLength = m_pWave->GetWaveLength();
    }

	// Get the new wavelength for the wave
	m_pWave->UpdateOnUndo(m_HeaderInfo);

	return S_OK;
}


HRESULT CWaveDataManager::PopUndoState()
{
    ASSERT(m_pUndoManager);
    if(m_pUndoManager == NULL)
    {
        return E_UNEXPECTED;
    }

    return m_pUndoManager->PopUndoState();
}


CString CWaveDataManager::GetUndoMenuText(bool bRedo)
{
    ASSERT(m_pUndoManager);
    if(m_pUndoManager == NULL)
    {
        return "";
    }

	if(!bRedo)
	{
		return m_pUndoManager->GetCurrentStateName();
	}

	return m_pUndoManager->GetRedoStateName();
}

HRESULT CWaveDataManager::CloneDeltaList(CPtrList* pDeltaList, CPtrList** ppClonedList)
{
	ASSERT(pDeltaList);
	if(pDeltaList == NULL)
	{
		return E_POINTER;
	}

	CPtrList* pClonedList = new CPtrList;

	POSITION position = pDeltaList->GetHeadPosition();
	while(position)
	{
		CWaveDelta* pDelta = (CWaveDelta*) pDeltaList->GetNext(position);
		ASSERT(pDelta);
		DWORD dwActualPos = pDelta->GetActualPosition();
		DWORD dwStartSample = pDelta->GetStartSample();
		DWORD dwLength = pDelta->GetLength();
		DWORD dwFileOffset = pDelta->GetFileOffset();
		BOOL bEditDelta = pDelta->IsEditDelta();

		CWaveDelta* pClonedDelta = new CWaveDelta(dwActualPos, dwStartSample, dwLength, dwFileOffset, bEditDelta);
		pClonedList->AddTail(pClonedDelta);
	}

	*ppClonedList = pClonedList;
	return S_OK;
}


DWORD CWaveDataManager::GetWavelength()
{
	DWORD dwLength = 0;
	POSITION position = m_plstDeltas->GetHeadPosition();
	while(position)
	{
		CWaveDelta* pDelta = (CWaveDelta*) m_plstDeltas->GetNext(position);
		ASSERT(pDelta);
		dwLength += pDelta->GetLength();
	}

	return dwLength;
}

void CWaveDataManager::UpdateHeaderInfo()
{
	ASSERT(m_pWave);
	if(m_pWave == NULL)
		return;

	CWaveNode* pWaveNode = m_pWave->GetNode();
	ASSERT(pWaveNode);
	if(pWaveNode == NULL)
		return;

	m_HeaderInfo.m_rWSMP = m_pWave->GetWSMPL();
	m_HeaderInfo.m_rRSMP = m_pWave->GetRSMPL();
	m_HeaderInfo.m_rWLOOP = m_pWave->GetWLOOP();
	m_HeaderInfo.m_rRLOOP = m_pWave->GetRLOOP();
	m_HeaderInfo.m_dwDataSize = m_pWave->GetDataSize();
	m_HeaderInfo.m_dwWaveLength = m_pWave->GetWaveLength();
	m_HeaderInfo.m_bCompressed = m_pWave->m_bCompressed;
	m_HeaderInfo.m_bStreaming = m_pWave->IsStreamingWave();
	m_HeaderInfo.m_bNoPreroll = m_pWave->IsNoPrerollWave();
	m_HeaderInfo.m_dwReadAheadTime = m_pWave->GetReadAheadTime();
	m_HeaderInfo.m_dwDecompressedStart = m_pWave->GetDwDecompressedStart(false);
	m_HeaderInfo.m_dwSamplerate = m_pWave->m_rWaveformat.nSamplesPerSec;

	if(SUCCEEDED(m_pWave->UpdateHeaderStream()))
	{
		if(m_bInInit == FALSE)
			pWaveNode->ReloadDirectSoundWave();
	}
}

HRESULT CWaveDataManager::GetSourceData(DWORD dwStartOffset, DWORD dwLength, BYTE** ppbData, DWORD& cbRead)
{
	ASSERT(m_pWave);
	if(m_pWave == NULL)
	{
		return E_FAIL;
	}

	ASSERT(m_pSourceFileHandler);
	if(m_pSourceFileHandler == NULL)
	{
		return E_FAIL;
	}

	if(dwLength == 0)
	{
		cbRead = 0;
		return S_OK;
	}

	BYTE* pbData = NULL;
	if(FAILED(m_pWave->SafeAllocBuffer(&pbData, dwLength)))
	{
		return E_OUTOFMEMORY;
	}

	DWORD dwDataOffset = m_pSourceFileHandler->GetDataOffset();
	DWORD cb = 0;
	if(FAILED(m_pSourceFileHandler->ReadData(dwDataOffset + dwStartOffset, dwLength, pbData, cbRead)))
	{
		delete[] pbData;
		cbRead = 0;
		return E_FAIL;
	}

	*ppbData = pbData;

	return S_OK;
}

HRESULT CWaveDataManager::CreateUniqueTempFile(CString sPrefix, CString sExtension, CString& sTempFileName)
{
	if(sExtension.IsEmpty())
	{
		sExtension = "tmp";
	}

	CString sFileExt = "." + sExtension;

	char szTempPath[MAX_PATH];
	DWORD dwSuccess = GetTempPath(MAX_PATH, szTempPath);
	CString sTempPath = szTempPath;	

	GUID guidFileName;
	if(SUCCEEDED(::CoCreateGuid(&guidFileName)))
	{
		LPOLESTR psz;
		if( SUCCEEDED( ::StringFromIID(guidFileName, &psz) ) )
		{
			TCHAR szGuid[100];
			WideCharToMultiByte( CP_ACP, 0, psz, -1, szGuid, sizeof(szGuid), NULL, NULL );
			CoTaskMemFree( psz );
			
			sTempFileName = sTempPath + sPrefix + szGuid + sFileExt;

			CFile tempFile;
			try
			{
				tempFile.Open(sTempFileName, CFile::modeCreate);
				tempFile.Close();
			}
			catch(CFileException e)
			{
				return E_FAIL;
			}

			return S_OK;
		}
	}

	return E_FAIL;
}


HRESULT CWaveDataManager::GetAllUncompressedData(BYTE** ppbData, DWORD* pdwSize)
{
    ASSERT(m_pWave);
    if(m_pWave == NULL)
    {
        return E_UNEXPECTED;
    }

    ASSERT(pdwSize);
    if(pdwSize == NULL)
    {
        return E_POINTER;
    }

    BOOL bTrueStereo = m_pWave->IsTrueStereo();
    int nSampleSize = m_pWave->m_OriginalWavObj.WaveFormatEx.wBitsPerSample;
    int nChannels = bTrueStereo ? 2 : 1;

    DWORD dwSize = m_pWave->m_OriginalWavObj.dwDataSize;
    DWORD dwLength = nSampleSize == 8 ? dwSize : dwSize >> 1;
    dwLength /= nChannels;

    if(FAILED(m_pWave->SafeAllocBuffer(ppbData, dwSize)))
    {
        return E_OUTOFMEMORY;
    }

    DWORD cbRead = 0;
    if(FAILED(GetData(0, dwLength, *ppbData, cbRead, true)))
    {
        delete[] *ppbData;
        return E_FAIL;
    }

    *pdwSize = cbRead;
    return S_OK;
}


HRESULT CWaveDataManager::UpdateUncompressedDeltas()
{
    if(m_plstUncompressedDeltas)
    {
        while(m_plstUncompressedDeltas->IsEmpty() == FALSE)
        {
            delete (CWaveDelta*)m_plstUncompressedDeltas->RemoveHead();
        }

        delete m_plstUncompressedDeltas;
        m_plstUncompressedDeltas = NULL;
    }

    CPtrList* pClonedList = NULL;
	if(FAILED(CloneDeltaList(m_plstDeltas, &pClonedList)))
	{
		return E_FAIL;
	}

    m_plstUncompressedDeltas = pClonedList;

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\DLSDesigner\WaveDelta.h ===
#ifndef __WAVEDELTA_H__
#define __WAVEDELTA_H__

class CWaveDelta
{
	// Construction
public:
	CWaveDelta();
	CWaveDelta(DWORD dwActualPosition, DWORD dwStartSample, DWORD dwLength, DWORD dwFileOffset, BOOL bEditDelta = FALSE);
	
	// Methods
public:

	BOOL IsSampleInDelta(DWORD dwSample);

	BOOL IsEditDelta();

	DWORD GetActualPosition();
	void SetActualPosition(DWORD dwPosition);
	
	DWORD GetFileOffset();
	void SetFileOffset(DWORD dwFileOffset);

	DWORD GetStartSample();
	void SetStartSample(DWORD dwSample);

	DWORD GetLength();
	void SetLength(DWORD dwLength);

	// Attributes
private:
	DWORD m_dwActualPosition;
	DWORD m_dwStartSample;
	DWORD m_dwLength;
	DWORD m_dwFileOffset;
	BOOL  m_bEditDelta; 
};

#endif __WAVEDELTA_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\DLSDesigner\WaveDataManager.h ===
#ifndef __WAVEDATAMANAGER_H__
#define __WAVEDATAMANAGER_H__

#include <afxtempl.h>
#include "wave.h"
#include "dls1.h"


class CWave;
class CWaveUndoManager;
class CWaveFileHandler;
class CWaveSourceFileHandler;
class CWaveDelta;

class CWaveDataManager
{
	
public:
	// Construction
	CWaveDataManager(CWave* pWave, CString sSourceFileName, CString sTempFilePath); // Standard c'tor
	CWaveDataManager(CWave* pWave, CString sTempFilePath);							// Constructs only decomp file handler
	~CWaveDataManager();
	
public:
	// Methods
	HRESULT Initialize(IStream* pIStream);					// Initializes the offsets, primes the delta list
	HRESULT Initialize(CString sFileName, 
						DWORD dwHeaderOffset, 
						DWORD dwDataOffset, 
						bool bDeleteOldSource = false);		// Initializes the delta list

	HRESULT CopyDecompFile();								// Makes a copy of the source file in the temp directory and keeps the name
	HRESULT	CreateDecompFile();								// Create a temp file to keep the decompressed data
	HRESULT CloseSourceHandler();							// Close the source file handler for saving
	HRESULT RenameSource(CString sNewSourceName);			// Rename the source file
	HRESULT OnSourceRenamed(CString sNewSourceFile);		// The source file name changed so reinitialize everything
	HRESULT CloneDeltaList(CPtrList* pDeltaList, 
						  CPtrList** ppClonedList);

	void	UpdateHeaderInfo();								// Gets the header info from the wave

	DWORD	GetWavelength();
	
	// Operations on data
	HRESULT GetData(DWORD dwStartSample, DWORD dwLength, BYTE* pbData, 
					DWORD& dwBytesRead, bool bGetUncompressed = false);	// Gets a chunk of data from source/temp files

	HRESULT GetDecompData(DWORD dwStartSample, DWORD dwLength, 
						BYTE* pbData, DWORD& dwBytesRead);				// Gets a chunk of decompressed data from the decomp file
	
	HRESULT GetSourceData(DWORD dwStartOffset, DWORD dwLength, BYTE** pbData, DWORD& cbRead);

    HRESULT GetAllUncompressedData(BYTE** ppbData, DWORD* pdwSize);


	HRESULT InsertData(DWORD dwInsertAt, BYTE* pbData, DWORD dwLength);	// Inserts data into the temp file
	HRESULT RemoveData(DWORD dwStartSample, DWORD dwSamples);			// Splits the delta list to keep tracks of the deletes
	HRESULT WriteDecompressedData(BYTE* pbData, DWORD dwDataSize);		// Writes the decompressed data to the decomp file
	HRESULT	DecompressRuntimeData();									// Decompresses the runtime comnpressed wavedata and puts in the decomp file
	HRESULT DecompressDesigntimeData();									// Compresses and Decompresses the design-time wave data

    HRESULT UpdateUncompressedDeltas();

	// Methods to work with undo/redo
	HRESULT SaveUndoState(CString sStateName);
	HRESULT Undo();
	HRESULT Redo();
	CString GetUndoMenuText(bool bRedo = false);
    HRESULT PopUndoState();
		
	// Helpers for persistance
	HRESULT SaveUncompressedDataToStream(IStream* pIStream, DWORD& dwBytesWritten);	// Create a 'data' chunk into the stream
	
	// General purpose accessors/mutators
	CString GetSourceFileName();

	// Temp file creation
	static	HRESULT CreateUniqueTempFile(CString sPrefix, CString sExtension, CString& sTempFileName);

private:

	HRESULT GetData(CWaveDelta* pDelta, DWORD dwStartSample, DWORD dwLength, BYTE* pbData, DWORD& dwBytesRead, bool bReadFromCopy = false);
	void	ResetActualDeltaStarts();

	// Attributes
private:
	
	CString m_sSourceFileName;
	CString m_sCopyFileName;
	CString m_sTempFilePath;
	CString m_sTempFileName;
	CString m_sDecompFileName;

	CWave*					m_pWave;
	CWaveUndoManager*		m_pUndoManager;

	CWaveSourceFileHandler* m_pSourceFileHandler;
	CWaveFileHandler*		m_pTempFileHandler;
	CWaveFileHandler*		m_pCopyFileHandler;
	CWaveFileHandler*		m_pDecompFileHandler;
	

	CPtrList*				m_plstDeltas;
    CPtrList*               m_plstUncompressedDeltas;
	HEADER_INFO				m_HeaderInfo;	

	BOOL					m_bInInit;
    BOOL                    m_bDecompressedRunTime;
    BOOL                    m_bDecompressedDesignTime;
    BOOL                    m_bNeedToMakeSrcDelta;
};

#endif // __WAVEDATAMANAGER_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\DLSDesigner\WaveDelta.cpp ===
/////////////////////////////////////////////
//
// CWaveDelta Implementation
//
//////////////////////////////////////////////

#include "stdafx.h"
#include "WaveDelta.h"

//////////////////////////////////////////////
//
// CWaveDelta::CWaveDelta
//
//////////////////////////////////////////////

CWaveDelta::CWaveDelta():
m_dwActualPosition(0), 
m_dwStartSample(0),
m_dwLength(0), 
m_dwFileOffset(0), 
m_bEditDelta(false)
{

}


CWaveDelta::CWaveDelta(DWORD dwActualPosition, DWORD dwStartSample, DWORD dwLength,  DWORD dwFileOffset, BOOL bEditDelta) :
m_dwActualPosition(dwActualPosition), 
m_dwStartSample(dwStartSample),
m_dwLength(dwLength), 
m_dwFileOffset(dwFileOffset), 
m_bEditDelta(bEditDelta)
{

} 

BOOL CWaveDelta::IsSampleInDelta(DWORD dwSample)
{
	if(dwSample >= m_dwActualPosition && dwSample < m_dwActualPosition + m_dwLength)
	{
		return TRUE;
	}

	return FALSE;
}


void CWaveDelta::SetActualPosition(DWORD dwPosition)
{
	m_dwActualPosition = dwPosition;
}


DWORD CWaveDelta::GetLength()
{
	return m_dwLength;
}

void CWaveDelta::SetLength(DWORD dwLength)
{
	m_dwLength = dwLength;
}

void CWaveDelta::SetFileOffset(DWORD dwFileOffset)
{
	m_dwFileOffset = dwFileOffset;
}

DWORD CWaveDelta::GetActualPosition()
{
	return m_dwActualPosition;
}


DWORD CWaveDelta::GetFileOffset()
{
	return m_dwFileOffset;
}


DWORD CWaveDelta::GetStartSample()
{
	return m_dwStartSample;
}


void CWaveDelta::SetStartSample(DWORD dwSample)
{
	m_dwStartSample = dwSample; 
}

BOOL CWaveDelta::IsEditDelta()
{
	return m_bEditDelta;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\DLSDesigner\WaveDocType.cpp ===
// WavDocType.cpp : implementation file
//

#include "stdafx.h"

#include "DLSDesignerDLL.h"
#include "DLSDesigner.h"
#include "WaveDocType.h"
#include "WaveNode.h"
#include "riffstrm.h"
#include "dls1.h"
#include <mmsystem.h>
#include <dmusicf.h>

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CWaveDocType constructor/destructor

CWaveDocType::CWaveDocType(CDLSComponent* pComponent)
{
	ASSERT(pComponent != NULL);

    m_dwRef = 0;
	m_pComponent = pComponent;
}

CWaveDocType::~CWaveDocType()
{
}

/////////////////////////////////////////////////////////////////////////////
// CWaveDocType IUnknown implementation

HRESULT CWaveDocType::QueryInterface( REFIID riid, LPVOID FAR* ppvObj )
{
 	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( ::IsEqualIID(riid, IID_IDMUSProdDocType)
	||  ::IsEqualIID(riid, IID_IDMUSProdDocType8)
	||  ::IsEqualIID(riid, IID_IUnknown) )
    {
        AddRef();
        *ppvObj = (IDMUSProdDocType8 *)this;
        return S_OK;
    }

    *ppvObj = NULL;
    return E_NOINTERFACE;
}

ULONG CWaveDocType::AddRef()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	AfxOleLockApp();
    return ++m_dwRef;
}

ULONG CWaveDocType::Release()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
    ASSERT( m_dwRef != 0 );

	AfxOleUnlockApp();
    --m_dwRef;

    if( m_dwRef == 0 )
    {
        delete this;
        return 0;
    }

    return m_dwRef;
}

/////////////////////////////////////////////////////////////////////////////
// CWaveDocType IDMUSProdDocType implementation

/////////////////////////////////////////////////////////////////////////////
// CWaveDocType::GetResourceId

HRESULT CWaveDocType::GetResourceId(HINSTANCE* phInstance, UINT* pnResourceId)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	*phInstance   = theApp.m_hInstance;
	*pnResourceId = IDR_WAVE_DOCTYPE;

	return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
// CWaveDocType::DoesExtensionMatch

HRESULT CWaveDocType::DoesExtensionMatch( BSTR bstrExt )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	CString strExt = bstrExt;
	::SysFreeString( bstrExt );

	CString strDocTypeExt;
	TCHAR   achBuffer[MAX_BUFFER];

	if( ::LoadString(theApp.m_hInstance, IDR_WAVE_DOCTYPE, achBuffer, MID_BUFFER) == 0 )
	{
		return E_FAIL;
	}

	if( AfxExtractSubString(strDocTypeExt, achBuffer, CDocTemplate::filterExt) )
	{
		ASSERT( strDocTypeExt[0] == '.' );

		BOOL fContinue = TRUE;
		CString strDocExt;
		int nFindPos;

		nFindPos = strDocTypeExt.Find( _T(";") );
		while( fContinue )
		{
			if( nFindPos == -1 )
			{
				fContinue = FALSE;

				nFindPos = strDocTypeExt.Find( _T(".") );
				if( nFindPos != 0 )
				{
					break;
				}
				strDocExt = strDocTypeExt;
			}
			else
			{
				strDocExt = strDocTypeExt.Left( nFindPos );
				strDocTypeExt = strDocTypeExt.Right( strDocTypeExt.GetLength() - (nFindPos + 1) ); 
			}

			if( _tcsicmp(strExt, strDocExt) == 0 )
			{
				return S_OK;	// extension matches 
			}

			nFindPos = strDocTypeExt.Find( _T(";") );
		}
	}

	return S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// CWaveDocType::DoesIdMatch

HRESULT CWaveDocType::DoesIdMatch(REFGUID rguid)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

    if(::IsEqualGUID(rguid, GUID_WaveNode))
	{
		return S_OK;
	}

	return S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// CWaveDocType::AllocNode

HRESULT STDMETHODCALLTYPE CWaveDocType::AllocNode(REFGUID rguid, IDMUSProdNode** ppINode)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	ASSERT(m_pComponent != NULL);

	*ppINode = NULL;

    if( ::IsEqualGUID(rguid, GUID_WaveNode) == FALSE )
	{
		return E_INVALIDARG;
	}

	CWaveNode* pWaveNode = NULL;

	// Create a new Collection 
	if(FAILED(CWaveNode::CreateWaveNode(m_pComponent, &pWaveNode)))
	{
		return E_FAIL;
	}

	m_pComponent->AddToWaveNodesList(pWaveNode);
	// Register it with the transport
	pWaveNode->RegisterWithTransport();
	*ppINode = (IDMUSProdNode*) pWaveNode;

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CWaveDocType:::OnFileNew

HRESULT CWaveDocType::OnFileNew(IDMUSProdProject* pITargetProject, IDMUSProdNode* pITargetDirectoryNode,
							   IDMUSProdNode** ppRootNode)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	IDMUSProdNode* pWaveNode;

	HRESULT hr = E_FAIL;

	ASSERT( m_pComponent != NULL );
	ASSERT( m_pComponent->m_pIFramework != NULL );

	*ppRootNode = NULL;

	// Create a new DLS 
	hr = AllocNode( GUID_WaveNode, &pWaveNode );
	if( SUCCEEDED ( hr ) )
	{
		// Set root and parent node of ALL children
		theApp.SetNodePointers( pWaveNode, pWaveNode, NULL);
		
		// Insert the DLS node into the Project Tree		
		hr = m_pComponent->m_pIFramework->AddNode(pWaveNode, NULL); 

		if(SUCCEEDED(hr))
		{
			*ppRootNode = pWaveNode;
			return S_OK;
		}

		pWaveNode->Release();
	}

	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CWaveDocType::OnFileOpen

HRESULT CWaveDocType::OnFileOpen(IStream* pIStream, IDMUSProdProject* pITargetProject,
								IDMUSProdNode* pITargetDirectoryNode, IDMUSProdNode** ppRootNode )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	CString strFileName;
	HRESULT hr = E_FAIL;
	ASSERT( m_pComponent != NULL );

	CWaveNode* pWaveNode = NULL;
	*ppRootNode = NULL;

	CString sFilePath;
	IDMUSProdPersistInfo* pIJazzPersistInfo;
	if(SUCCEEDED(pIStream->QueryInterface(IID_IDMUSProdPersistInfo,(void**) &pIJazzPersistInfo)))
	{
		BSTR bstrFileName;
		pIJazzPersistInfo->GetFileName(&bstrFileName);
		sFilePath = bstrFileName;
		SysFreeString(bstrFileName);
		pIJazzPersistInfo->Release();
	}

	// Create the wave node and load it from pIStream
	if(FAILED(CWaveNode::CreateWaveNode(m_pComponent, pIStream, sFilePath, &pWaveNode, NULL, false)))
	{
		return E_FAIL;
	}

	// Set root and parent node of ALL children
	theApp.SetNodePointers( pWaveNode, pWaveNode, NULL);
		
	// Insert the DLS node into the Project Tree
	hr = m_pComponent->m_pIFramework->AddNode(pWaveNode, NULL);

	if(SUCCEEDED(hr))
	{
		hr  = pWaveNode->InitAndDownload();
		
		// Check if the wave has a name 
		BSTR bstrNodeName;
		pWaveNode->GetName(&bstrNodeName);
		CString sNodeName = bstrNodeName;
		SysFreeString(bstrNodeName);

		IDMUSProdPersistInfo* pIJazzPersistInfo;
		if(SUCCEEDED(pIStream->QueryInterface(IID_IDMUSProdPersistInfo,(void**) &pIJazzPersistInfo)))
		{
			BSTR bstrFileName;
			pIJazzPersistInfo->GetFileName(&bstrFileName);
			CString sFilePath = bstrFileName;
			SysFreeString(bstrFileName);
			pWaveNode->SetFileName(sFilePath);
		
			if(sNodeName.IsEmpty())
			{
				CString sFileName = bstrFileName;

				// We just need the filename not the whole path
				int nExtension = sFileName.ReverseFind('.');
				int nLastSlash = sFileName.ReverseFind('\\') + 1;
				
				// Take out the extension
				int nLength = sFileName.GetLength();
				sFileName = sFileName.Left(nExtension);
				
				// Take out the path
				nLength = sFileName.GetLength();
				sFileName = sFileName.Right(nLength - nLastSlash);
				
				// Set the name
				bstrFileName = sFileName.AllocSysString();
				pWaveNode->SetNodeName(bstrFileName);
	
			}

			pIJazzPersistInfo->Release();		
		}
	}



	if(SUCCEEDED(hr))
	{
		*ppRootNode = pWaveNode;
		m_pComponent->AddToWaveNodesList(pWaveNode);
		// Register it with the transport
		pWaveNode->RegisterWithTransport();
		return S_OK;
	}
	
	pWaveNode->Release();
	return hr;
}

/////////////////////////////////////////////////////////////////////////////
// CWaveDocType::IsFileTypeExtension

HRESULT CWaveDocType::IsFileTypeExtension(FileType ftFileType, BSTR bstrExt)    
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	CString strExt = bstrExt;
	::SysFreeString(bstrExt);

	strExt.MakeLower();

	switch(ftFileType)
	{
		case FT_DESIGN:
			if(strExt == _T(".wvp"))
			{
				return S_OK;
			}
			break;

		case FT_RUNTIME:
			if(strExt == _T(".wav"))
			{
				return S_OK;
			}
			break;
	}

	return S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// CWaveDocType IDMUSProdDocType::OnFileSave

HRESULT CWaveDocType::OnFileSave(IStream* pIStream, IDMUSProdNode* pIDocRootNode)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	ASSERT(pIStream);
	if(pIStream == NULL)
		return E_FAIL;

	CWaveNode* pWaveNode = (CWaveNode*) pIDocRootNode;
	if(pWaveNode && pIStream)
	{
		HRESULT hr = pWaveNode->SaveAs(pIStream);
		return hr;
	}

	return E_FAIL;
}

/////////////////////////////////////////////////////////////////////////////
// CWaveDocType IDMUSProdDocType::GetListInfo

HRESULT CWaveDocType::GetListInfo( IStream* pIStream, DMUSProdListInfo* pListInfo )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

    IDMUSProdRIFFStream* pIRiffStream;
    MMCKINFO ckMain;
	MMCKINFO ck;
	DWORD dwSize;
	DWORD dwByteCount;
	CString csName;
	GUID guidWave;

	ASSERT( pIStream != NULL );
    ASSERT( pListInfo != NULL );

	if( pIStream == NULL
	||  pListInfo == NULL )
	{
		return E_INVALIDARG;
	}

	memset( &guidWave, 0, sizeof(GUID) );

	// Check for 'WAVE' RIFF header
	if( SUCCEEDED( AllocRIFFStream( pIStream, &pIRiffStream ) ) )
	{
		ckMain.fccType = mmioFOURCC('W', 'A', 'V', 'E');
		if( pIRiffStream->Descend( &ckMain, NULL, MMIO_FINDRIFF ) == 0 )
		{
			DWORD dwPos = StreamTell( pIStream );

			// Get Wave GUID
			ck.ckid = DMUS_FOURCC_GUID_CHUNK;
			if( pIRiffStream->Descend( &ck, &ckMain, MMIO_FINDCHUNK ) == 0 )
			{
				dwSize = min( ck.cksize, sizeof( GUID ) );
				if( FAILED ( pIStream->Read( &guidWave, dwSize, &dwByteCount ) )
				||  dwByteCount != dwSize )
				{
					memset( &guidWave, 0, sizeof(GUID) );
				}
			}

		    StreamSeek( pIStream, dwPos, STREAM_SEEK_SET );

			// Get Wave name
			ck.fccType = mmioFOURCC('I','N','F','O') ;
			if( pIRiffStream->Descend( &ck, &ckMain, MMIO_FINDLIST ) == 0 )
			{
				ck.ckid = mmioFOURCC('I','N','A','M') ;
				if( pIRiffStream->Descend( &ck, &ckMain, MMIO_FINDCHUNK ) == 0 )
				{
					void* pString = new char[ck.cksize];
					if( pString )
					{
						memset( pString, 0, ck.cksize );
	
						if( FAILED ( pIStream->Read( pString, ck.cksize, &dwByteCount ) )
						||  dwByteCount != ck.cksize )
						{
							memset( pString, 0, ck.cksize );
						}
						csName = (char *)pString;
						delete pString;
					}
				}
			}
		}

		RELEASE( pIRiffStream );
	}

	if( csName.IsEmpty() )
	{
		// Use filename minus extension
		IDMUSProdPersistInfo* pIPersistInfo;
		if(SUCCEEDED(pIStream->QueryInterface(IID_IDMUSProdPersistInfo,(void**) &pIPersistInfo)))
		{
			TCHAR achFName[_MAX_FNAME];
			BSTR bstrFileName;
		
			pIPersistInfo->GetFileName(&bstrFileName);
			CString sFileName = bstrFileName;
			::SysFreeString(bstrFileName);
			_tsplitpath( sFileName, NULL, NULL, achFName, NULL );
			csName = achFName;
			pIPersistInfo->Release();
		}
	}

	if( !csName.IsEmpty() )
	{
		pListInfo->bstrName = csName.AllocSysString();
		memcpy( &pListInfo->guidObject, &guidWave, sizeof(GUID) );

		// Must check pListInfo->wSize before populating additional fields
		return S_OK;
	}

	return E_FAIL;
}


/////////////////////////////////////////////////////////////////////////////
// CWaveDocType::GetObjectDescriptorFromNode

HRESULT CWaveDocType::GetObjectDescriptorFromNode( IDMUSProdNode* pIDocRootNode, void* pObjectDesc )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	
	// Make sure method was passed a Wave Node
	CWaveNode* pWave;
	GUID guidNodeId;
	if( SUCCEEDED ( pIDocRootNode->GetNodeId ( &guidNodeId ) ) )
	{
		if( !( IsEqualGUID ( guidNodeId, GUID_WaveNode ) ) )
		{
			return E_INVALIDARG;
		}
	}
	pWave = (CWaveNode *)pIDocRootNode;

	return pWave->GetObjectDescriptor( pObjectDesc );
}


/////////////////////////////////////////////////////////////////////////////
// CWaveDocType::GetObjectRiffId

HRESULT CWaveDocType::GetObjectRiffId( GUID guidNodeId, DWORD* pckid, DWORD* pfccType )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( pckid == NULL
	||  pfccType == NULL )
	{
		return E_POINTER;
	}

	// Make sure method was passed a Wave Node
	if( IsEqualGUID ( guidNodeId, GUID_WaveNode ) ) 
	{
		*pckid = FOURCC_RIFF;
		*pfccType = mmioFOURCC('W', 'A', 'V', 'E');
		return S_OK;
	}

	return E_INVALIDARG;
}


/////////////////////////////////////////////////////////////////////////////
// CWaveDocType::GetObjectExt

HRESULT CWaveDocType::GetObjectExt( GUID guidNodeId, FileType ftFileType, BSTR* pbstrExt )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( pbstrExt == NULL )
	{
		return E_POINTER;
	}

	// Make sure method was passed a Wave Node
	if( IsEqualGUID ( guidNodeId, GUID_WaveNode ) ) 
	{
		if( ftFileType == FT_DESIGN )
		{
			CString strExt = ".wvp";
			*pbstrExt = strExt.AllocSysString();
			return S_OK;
		}

		if( ftFileType == FT_RUNTIME )
		{
			CString strExt = ".wav";
			*pbstrExt = strExt.AllocSysString();
			return S_OK;
		}
	}

	return E_INVALIDARG;
}


/////////////////////////////////////////////////////////////////////////////
// CWaveDocType additional functions
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\DLSDesigner\WaveDocType.h ===
#ifndef __WAVEDOCTYPE_H__
#define __WAVEDOCTYPE_H__

// WaveDocType.h : header file
//
class CDLSComponent;

class CWaveDocType : public IDMUSProdDocType8
{
public:
    CWaveDocType( CDLSComponent* pComponent );
	~CWaveDocType();

    // IUnknown functions
    HRESULT STDMETHODCALLTYPE QueryInterface( REFIID riid, LPVOID *ppv );
    ULONG STDMETHODCALLTYPE AddRef();
    ULONG STDMETHODCALLTYPE Release();

    // IWaveDocType functions
    HRESULT STDMETHODCALLTYPE GetResourceId( HINSTANCE* phInstance, UINT* pnResourceId );
    HRESULT STDMETHODCALLTYPE DoesExtensionMatch( BSTR bstrExt );
    HRESULT STDMETHODCALLTYPE DoesIdMatch( REFGUID rguid);
    HRESULT STDMETHODCALLTYPE AllocNode( REFGUID rguid, IDMUSProdNode** ppINode );

    HRESULT STDMETHODCALLTYPE OnFileNew(IDMUSProdProject* pITargetProject,
										IDMUSProdNode* pITargetDirectoryNode, IDMUSProdNode** ppIDocRootNode);
    HRESULT STDMETHODCALLTYPE OnFileOpen(IStream* pIStream, IDMUSProdProject* pITargetProject,
										 IDMUSProdNode* pITargetDirectoryNode, IDMUSProdNode** ppIDocRootNode);
	HRESULT STDMETHODCALLTYPE OnFileSave(IStream* pIStream, IDMUSProdNode* pIDocRootNode);
    HRESULT STDMETHODCALLTYPE IsFileTypeExtension(FileType ftFileType, BSTR bstrExt);   
	HRESULT STDMETHODCALLTYPE GetListInfo( IStream* pIStream, DMUSProdListInfo* pListInfo );	

    // IDMUSProdDocType8 functions
    HRESULT STDMETHODCALLTYPE GetObjectDescriptorFromNode( IDMUSProdNode* pIDocRootNode, void* pObjectDesc );
    HRESULT STDMETHODCALLTYPE GetObjectRiffId( GUID guidNodeId, DWORD* pckid, DWORD* pfccType );
    HRESULT STDMETHODCALLTYPE GetObjectExt( GUID guidNodeId, FileType ftFileType, BSTR* pbstrExt );
	
	// Additional functions

private:
    CWaveDocType();

private:
    DWORD				m_dwRef;
	CDLSComponent*		m_pComponent;
};

#endif // __WAVEDOCTYPE_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\DLSDesigner\WaveFileHandler.cpp ===
/////////////////////////////////////////////////////////
//
// CWaveFileHandler Implementation
//
/////////////////////////////////////////////////////////

#include "stdafx.h"
#include "WaveFileHandler.h"


/////////////////////////////////////////////////////////
//
//	Construction :- CWaveFileHandler::CWaveFileHandler();
//
/////////////////////////////////////////////////////////
CWaveFileHandler::CWaveFileHandler(CString sFileName, UINT nOpenFlags) : CFile(sFileName, nOpenFlags | CFile::shareDenyNone | CFile::typeBinary)
{
	m_sFileName = sFileName;
}


/////////////////////////////////////////////////////////
//
// CWaveFileHandler::GetStartOffset
//
/////////////////////////////////////////////////////////
DWORD CWaveFileHandler::GetStartOffset()
{
	return m_dwStartOffset;
}

/////////////////////////////////////////////////////////
//
// CWaveFileHandler::SetStartOffset
//
/////////////////////////////////////////////////////////
DWORD CWaveFileHandler::GetDataOffset()
{
	return m_dwDataOffset;
}


/////////////////////////////////////////////////////////
//
// CWaveFileHandler::SetStartOffset
//
/////////////////////////////////////////////////////////
void CWaveFileHandler::SetStartOffset(DWORD dwOffset)
{
	m_dwStartOffset = dwOffset;
}

/////////////////////////////////////////////////////////
//
// CWaveFileHandler::SetDataOffset
//
/////////////////////////////////////////////////////////
void CWaveFileHandler::SetDataOffset(DWORD dwOffset)
{
	m_dwDataOffset = dwOffset;
}


/////////////////////////////////////////////////////////
//
// CWaveFileHandler::SeekToBegin()
//
/////////////////////////////////////////////////////////
void CWaveFileHandler::SeekToBegin()
{
	CFile::Seek(m_dwStartOffset, CFile::begin);
}

/////////////////////////////////////////////////////////
//
// CWaveFileHandler::SeekToData()
//
/////////////////////////////////////////////////////////
void CWaveFileHandler::SeekToData()
{
	CFile::Seek(m_dwDataOffset, CFile::begin);
}

//////////////////////////////////////////////////////
//
// CWaveFileHandler::ReadData
//
//////////////////////////////////////////////////////
HRESULT CWaveFileHandler::ReadData(DWORD dwOffset, DWORD dwLength, BYTE* pbData, DWORD& dwBytesRead)
{
	ASSERT(pbData);
	if(pbData == NULL)
	{
		return E_POINTER;
	}

	try
	{
		CFile::Seek(dwOffset, CFile::begin);
		dwBytesRead = Read((void*)pbData, dwLength);
		if(dwBytesRead == 0)
		{
			return E_FAIL;
		}
	}
	catch(CFileException e)
	{
		dwBytesRead = 0;
		return E_FAIL;
	}

	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\DLSDesigner\WaveFileHandler.h ===
#ifndef __WAVEFILEHANDLER_H__
#define __WAVEFILEHANDLER_H__


class CWaveFileHandler : public CFile
{

public:
	// Construction
	CWaveFileHandler(CString sFileName, UINT nOpenFlags);

public:
	// Methods to seek to marked position in the file
	void SeekToBegin();					// Seeks to the m_dwStartOffset into the file
	void SeekToData();					// Seeks to the m_dwDataOffset into the file

	// Accessors/Mutators for the offsets marks into the file
	virtual DWORD GetStartOffset();
	virtual DWORD GetDataOffset();

	virtual void SetStartOffset(DWORD dwOffset = 0);
	virtual void SetDataOffset(DWORD dwOffset);

	// Methods to deal with the data
	HRESULT ReadData(DWORD dwOffset, DWORD dwLength, BYTE* pbData, DWORD& dwBytesRead);
	
	// Attributes
	CString	m_sFileName;	// Name of the file opened

private:
	// The offsets are from the beginning of the file
	DWORD m_dwStartOffset;	// Offset to the start of WAVE chunk in the file; it's the position just before the WAVE RIFF header
	DWORD m_dwDataOffset;	// Offset to the start of DATA chunk in the file; it's the position right after the DATA chunk header i.e. sample 0 position
};


#endif // __WAVEFILEHANDLER_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\DLSDesigner\WaveInfoPropPg.cpp ===
// WaveInfoPropPg.cpp : implementation file
//

#include "stdafx.h"
#include "dlsdesigner.h"
#include "WaveInfoPropPg.h"
#include "WavePropPgMgr.h"
#include "Wave.h"
#include "collection.h"
#include "GuidDlg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CWaveInfoPropPg property page

IMPLEMENT_DYNCREATE(CWaveInfoPropPg, CPropertyPage)

CWaveInfoPropPg::CWaveInfoPropPg() : CPropertyPage(CWaveInfoPropPg::IDD), m_bSaveUndoState(true), m_bInInitialUpdate(false)
{
	//{{AFX_DATA_INIT(CWaveInfoPropPg)
	m_csAuthor = _T("");
	m_csComment = _T("");
	m_csCopyright = _T("");
	m_csSubject = _T("");
	m_dwLength = 0;
	m_dwSampleSize = 0;
	m_dwSampleRate = 0;
	//}}AFX_DATA_INIT

	m_fNeedToDetach = FALSE;
}

CWaveInfoPropPg::~CWaveInfoPropPg()
{
}

void CWaveInfoPropPg::DoDataExchange(CDataExchange* pDX)
{
	CPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CWaveInfoPropPg)
	DDX_Text(pDX, IDC_AUTHOR, m_csAuthor);
	DDX_Text(pDX, IDC_COMMENT, m_csComment);
	DDX_Text(pDX, IDC_COPYRIGHT, m_csCopyright);
	DDX_Text(pDX, IDC_SUBJECT, m_csSubject);
	DDX_Text(pDX, IDC_LENGTH, m_dwLength);
	DDX_Text(pDX, IDC_SAMPLESIZE, m_dwSampleSize);
	DDX_Text(pDX, IDC_SAMPLERATE, m_dwSampleRate);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CWaveInfoPropPg, CPropertyPage)
	//{{AFX_MSG_MAP(CWaveInfoPropPg)
	ON_EN_CHANGE(IDC_AUTHOR, OnChangeAuthor)
	ON_EN_CHANGE(IDC_COMMENT, OnChangeComment)
	ON_EN_CHANGE(IDC_COPYRIGHT, OnChangeCopyright)
	ON_EN_CHANGE(IDC_SUBJECT, OnChangeSubject)
	ON_WM_CREATE()
	ON_WM_DESTROY()
	ON_EN_KILLFOCUS(IDC_AUTHOR, OnKillfocusEdits)
	ON_EN_KILLFOCUS(IDC_COMMENT, OnKillfocusEdits)
	ON_EN_KILLFOCUS(IDC_COPYRIGHT, OnKillfocusEdits)
	ON_EN_KILLFOCUS(IDC_SUBJECT, OnKillfocusEdits)
	ON_BN_CLICKED(IDC_EDIT_GUID_BUTTON, OnEditGuidButton)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CWaveInfoPropPg message handlers

void CWaveInfoPropPg::OnChangeAuthor() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	if(m_bInInitialUpdate)
		return;

	ASSERT(m_pWave);
	if(m_pWave == NULL)
		return;

	BOOL bUpdate;
	bUpdate = UpdateData(TRUE);	

	if(bUpdate)
	{		
		if(m_pWave->m_Info.m_csEngineer != m_csAuthor)
		{
			CWaveCtrl* pWaveEditor = m_pWave->GetWaveEditor();
			if(m_bSaveUndoState && pWaveEditor)
			{
				m_bSaveUndoState = false;
				if(FAILED(pWaveEditor->SaveStateForUndo(IDS_UNDO_AUTHOR)))
				{
					m_bSaveUndoState = true;
					UpdateData(FALSE);
					return;
				}
			}
				
			m_pWave->m_Info.m_csEngineer = m_csAuthor;
			
			m_pWave->SetDirtyFlag();
		}
	}
	
}

void CWaveInfoPropPg::OnChangeComment() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	if(m_bInInitialUpdate)
		return;


    ASSERT(m_pWave);
    BOOL bUpdate = UpdateData(TRUE);
	if(bUpdate)
	{		
		if(m_pWave->m_Info.m_csComment != m_csComment)
		{
			CWaveCtrl* pWaveEditor = m_pWave->GetWaveEditor();
			if(m_bSaveUndoState && pWaveEditor)
			{
				m_bSaveUndoState = false;
				
				if(FAILED(pWaveEditor->SaveStateForUndo(IDS_UNDO_COMMENT)))
				{
					m_bSaveUndoState = true;
					UpdateData(FALSE);
					return;
				}
			}

			m_pWave->m_Info.m_csComment = m_csComment;
			m_pWave->SetDirtyFlag();
		}
	}

}

void CWaveInfoPropPg::OnChangeCopyright() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	if(m_bInInitialUpdate)
		return;

	ASSERT(m_pWave);

	BOOL bUpdate;
	bUpdate = UpdateData(TRUE);	

	if(bUpdate)
	{		
		if(m_pWave->m_Info.m_csCopyright != m_csCopyright)
		{
			CWaveCtrl* pWaveEditor = m_pWave->GetWaveEditor();
			if(m_bSaveUndoState && pWaveEditor)
			{
				m_bSaveUndoState = false;
				
				if(FAILED(pWaveEditor->SaveStateForUndo(IDS_UNDO_COPYRIGHT)))
				{
					m_bSaveUndoState = true;
					UpdateData(FALSE);
					return;
				}
			}

			m_pWave->m_Info.m_csCopyright = m_csCopyright;
			m_pWave->SetDirtyFlag();
		}
	}
	
}

void CWaveInfoPropPg::OnChangeSubject() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	if(m_bInInitialUpdate)
		return;

	ASSERT(m_pWave);

	BOOL bUpdate;
	bUpdate = UpdateData(TRUE);	

	if(bUpdate)
	{		
		if(m_pWave->m_Info.m_csSubject != m_csSubject)
		{
			CWaveCtrl* pWaveEditor = m_pWave->GetWaveEditor();
			if(m_bSaveUndoState && pWaveEditor)
			{
				m_bSaveUndoState = false;
				if(FAILED(pWaveEditor->SaveStateForUndo(IDS_UNDO_SUBJECT)))
				{
					m_bSaveUndoState = true;
					UpdateData(FALSE);
					return;
				}
			}

			m_pWave->m_Info.m_csSubject = m_csSubject;
			
			m_pWave->SetDirtyFlag();
		}
	}
	
}

BOOL CWaveInfoPropPg::OnSetActive() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

    if (m_pWave)
    {
//        EnableControls(TRUE);

	    m_csCopyright = m_pWave->m_Info.m_csCopyright;
	    m_csAuthor = m_pWave->m_Info.m_csEngineer;
	    m_csSubject = m_pWave->m_Info.m_csSubject;
	    m_csComment = m_pWave->m_Info.m_csComment;
        m_dwLength = m_pWave->m_dwWaveLength; 

        m_dwSampleRate = m_pWave->m_rWaveformat.nSamplesPerSec;
        m_dwSampleSize = m_pWave->m_rWaveformat.wBitsPerSample;
    }
    else
    {
//        EnableControls(FALSE);
    }

	CWavePropPgMgr::dwLastSelPage = WAVE_INFO_PAGE;

	return CPropertyPage::OnSetActive();
}

int CWaveInfoPropPg::OnCreate(LPCREATESTRUCT lpCreateStruct) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	// Attach the window to the property page structure.
	// This has been done once already in the main application
	// since the main application owns the property sheet.
	// It needs to be done here so that the window handle can
	// be found in the DLLs handle map.
	if(!FromHandlePermanent(m_hWnd))
	{
		HWND hWnd = m_hWnd;
		m_hWnd = NULL;
		Attach( hWnd );

		m_fNeedToDetach = TRUE;
	}

	if (CPropertyPage::OnCreate(lpCreateStruct) == -1)
		return -1;

    //initialize the values for the dialog.
    ASSERT(m_pWave);
    if (m_pWave)
    {
	    m_csCopyright = m_pWave->m_Info.m_csCopyright;
	    m_csAuthor = m_pWave->m_Info.m_csEngineer;
	    m_csSubject = m_pWave->m_Info.m_csSubject;
	    m_csComment = m_pWave->m_Info.m_csComment;
        m_dwLength = m_pWave->m_dwWaveLength; 

        m_dwSampleRate = m_pWave->m_rWaveformat.nSamplesPerSec;
        m_dwSampleSize = m_pWave->m_rWaveformat.wBitsPerSample;
    }

	return 0;
}

void CWaveInfoPropPg::OnDestroy() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	// Detach the window from the property page structure.
	// This will be done again by the main application since
	// it owns the property sheet.  It needs o be done here
	// so that the window handle can be removed from the
	// DLLs handle map.
	if( m_fNeedToDetach && m_hWnd != NULL )
	{
		HWND hWnd = m_hWnd;
		Detach();
		m_hWnd = hWnd;
	}

	CPropertyPage::OnDestroy();
		
}

void CWaveInfoPropPg::OnKillfocusEdits() 
{
	m_bSaveUndoState = true;
}

BOOL CWaveInfoPropPg::OnInitDialog() 
{
	CPropertyPage::OnInitDialog();

	CWnd* pCtrl = GetDlgItem(IDC_COMMENT);
	if(pCtrl)
		((CEdit*)pCtrl)->SetLimitText(COMMENT_TEXT_LIMIT);
	
	return FALSE;  // return TRUE unless you set the focus to a control
	               // EXCEPTION: OCX Property Pages should return FALSE
}

void CWaveInfoPropPg::InitializeDialogValues()
{
	m_bInInitialUpdate = true;

	m_csCopyright = m_pWave->m_Info.m_csCopyright;
	m_csAuthor = m_pWave->m_Info.m_csEngineer;
	m_csSubject = m_pWave->m_Info.m_csSubject;
	m_csComment = m_pWave->m_Info.m_csComment;
    m_dwLength = m_pWave->m_dwWaveLength; 

    m_dwSampleRate = m_pWave->m_rWaveformat.nSamplesPerSec;
    m_dwSampleSize = m_pWave->m_rWaveformat.wBitsPerSample;

	CWnd* pCtrl = GetDlgItem(IDC_SUBJECT);
	if(pCtrl)
	{
		pCtrl->SetWindowText(m_csSubject);
		pCtrl = NULL;
	}

	pCtrl = GetDlgItem(IDC_AUTHOR);
	if(pCtrl)
	{
		pCtrl->SetWindowText(m_csAuthor);
		pCtrl = NULL;
	}

	pCtrl = GetDlgItem(IDC_COPYRIGHT);
	if(pCtrl)
	{
		pCtrl->SetWindowText(m_csCopyright);
		pCtrl = NULL;
	}

	pCtrl = GetDlgItem(IDC_COMMENT);
	if(pCtrl)
	{
		pCtrl->SetWindowText(m_csComment);
		pCtrl = NULL;
	}
	
	CString sWindowText;
	sWindowText.Format("%d", m_dwLength);
	pCtrl = GetDlgItem(IDC_LENGTH);
	if(pCtrl)
	{
		pCtrl->SetWindowText(sWindowText);
		pCtrl = NULL;
	}

	sWindowText.Format("%d", m_dwSampleRate);
	pCtrl = GetDlgItem(IDC_SAMPLERATE);
	if(pCtrl)
	{
		pCtrl->SetWindowText(sWindowText);
		pCtrl = NULL;
	}

	sWindowText.Format("%d", m_dwSampleSize);
	pCtrl = GetDlgItem(IDC_SAMPLESIZE);
	if(pCtrl)
	{
		pCtrl->SetWindowText(sWindowText);
		pCtrl = NULL;
	}

	m_bInInitialUpdate = false;
}

void CWaveInfoPropPg::OnEditGuidButton() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	if( m_pWave)
	{
		CGuidDlg dlg;
		dlg.m_guid = m_pWave->GetFileGUID();
		if(dlg.DoModal() == IDOK)
		{
			//m_pCollection->m_pUndoMgr->SaveState( m_pCollection, theApp.m_hInstance, IDS_UNDO_STYLE_GUID );
			m_pWave->SetFileGUID(dlg.m_guid);
			m_pWave->NotifyWaveChange(true);
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\DLSDesigner\WaveInfoPropPg.h ===
#if !defined(AFX_WAVEINFOPROPPG_H__2AB46082_3441_11D1_8B4A_006097B01078__INCLUDED_)
#define AFX_WAVEINFOPROPPG_H__2AB46082_3441_11D1_8B4A_006097B01078__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// WaveInfoPropPg.h : header file
//
#include "resource.h"

const int COMMENT_TEXT_LIMIT = 1024;

class CWave;
/////////////////////////////////////////////////////////////////////////////
// CWaveInfoPropPg dialog
class CWaveInfoPropPg : public CPropertyPage
{
	DECLARE_DYNCREATE(CWaveInfoPropPg)

// Construction
public:
	CWaveInfoPropPg();
	~CWaveInfoPropPg();

	void SetObject(CWave* pWave) {m_pWave = pWave;}
	void InitializeDialogValues();

// Dialog Data
	//{{AFX_DATA(CWaveInfoPropPg)
	enum { IDD = IDD_WAVE_INFO_PROP_PAGE };
	CString	m_csAuthor;
	CString	m_csComment;
	CString	m_csCopyright;
	CString	m_csSubject;
	DWORD	m_dwLength;
	DWORD	m_dwSampleSize;
	DWORD	m_dwSampleRate;
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CWaveInfoPropPg)
	public:
	virtual BOOL OnSetActive();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CWaveInfoPropPg)
	afx_msg void OnChangeAuthor();
	afx_msg void OnChangeComment();
	afx_msg void OnChangeCopyright();
	afx_msg void OnChangeSubject();
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	afx_msg void OnDestroy();
	afx_msg void OnKillfocusEdits();
	virtual BOOL OnInitDialog();
	afx_msg void OnEditGuidButton();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

private:
    CWave*	m_pWave;
	BOOL	m_fNeedToDetach;
	bool	m_bSaveUndoState;
	bool	m_bInInitialUpdate;
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_WAVEINFOPROPPG_H__2AB46082_3441_11D1_8B4A_006097B01078__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\DLSDesigner\WaveNode.cpp ===
//////////////////////////////////////////////////////////////////////
//
// WaveNode.cpp : implementation file
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include <mmsystem.h>
#include <mmreg.h>
#include <msacm.h>
#include "DLSDesignerDLL.h"
#include "WaveNode.h"
#include "Wave.h"
#include "WaveDataManager.h"
#include "MonoWave.h"
#include "StereoWave.h"
#include "WaveStream.h"
#include "NewWaveDialog.h"
#include "Collection.h"
#include "CollectionWaves.h"
#include "DLSLoadSaveUtils.h"
#include "stream.h"
#include "Instrument.h"
#include "Wavectl.h"
#include "Timeline.h"
#include "DLSLoadSaveUtils.h"
#include <WaveTimelineDraw.h>
#include "dmusicf.h"
#include "DlsDefsPlus.h"



#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


//////////////////////////////////////////////////////////////////////
//
//	CWaveNode::CWaveNode();
//
//////////////////////////////////////////////////////////////////////
CWaveNode::CWaveNode(CDLSComponent* pComponent, bool bStereo) : m_pWaveCtrl(NULL), 
m_bStereo(bStereo),
m_bPastingWave(false),
m_bDragCopy(false),
m_pIDirectSoundWave(NULL),
m_pDirectSoundWaveStream(NULL),
m_bInCollection(false),
m_bIsDirty(FALSE),
m_bSrcInATempFile(FALSE),
m_hStopEvent(0)
{
	ASSERT( pComponent != NULL );

    m_lRef = 0;
	AddRef();

	m_pComponent = pComponent;
	m_pComponent->AddRef();

	m_pWave = NULL;
	m_pIRootNode = NULL;
	m_pIParentNode = NULL;
	m_hWndEditor = NULL;

	::CoCreateGuid(&m_guidWaveNode);

	::CoCreateGuid(&m_guidFile);

	::CoCreateGuid(&m_guidVersion);

	m_hStopEvent = ::CreateEvent(NULL, TRUE, FALSE, "Oneshot Timeout");
	
	InitializeCriticalSection(&m_CriticalSection);
}

//////////////////////////////////////////////////////////////////////
//
//	CWaveNode::~CWaveNode()
//
//////////////////////////////////////////////////////////////////////
CWaveNode::~CWaveNode()
{
	ASSERT(m_pComponent);

	::CloseHandle(m_hStopEvent);

	if(m_pIDirectSoundWave)
	{
		m_pIDirectSoundWave->Release();
		m_pIDirectSoundWave = NULL;
	}

	if(m_pDirectSoundWaveStream)
	{
		m_pDirectSoundWaveStream->Release();
		m_pDirectSoundWaveStream = NULL;
	}

	if(m_pWave)
	{
		m_pWave->Release();
	}

	if(m_pComponent)
	{
		m_pComponent->Release();
	}

	DeleteCriticalSection(&m_CriticalSection);
}

//////////////////////////////////////////////////////////////////////
//
//	CWavenode::CreateWaveNode
//
//////////////////////////////////////////////////////////////////////
HRESULT CWaveNode::CreateWaveNode(CDLSComponent* pComponent, CWaveNode** ppWaveNode)
{
	// Must have a component
	ASSERT(pComponent);
	if(pComponent == NULL)
		return E_POINTER;

	*ppWaveNode = NULL;

	// Throw up a dialog asking for the format
	CNewWaveDialog newWaveDlg;
	if(newWaveDlg.DoModal() == IDOK)
	{
		// Mono or stereo?
		int nChannels = 1;
		if(newWaveDlg.m_bLastSelectedStereo)
			nChannels = 2;

		// 8 bit or 16 bit?
		int nSampleSize = 16;
		if(newWaveDlg.m_bLastSelected8Bit)
			nSampleSize = 8;

		// What's the sample rate?
		DWORD dwSampleRate = atoi(newWaveDlg.m_sLastSelectedRate);

		// Get a temp file which we'll rename later
		// Get a temp file name
		char szTempPath[MAX_PATH];
		DWORD dwSuccess = GetTempPath(MAX_PATH, szTempPath);
		CString sTempPath = szTempPath;
		
		char szTempName[MAX_PATH];
		CString sTempName;
		
		CString sPrefix = "DMP";
		CString sExtension = "tmp";
		if(FAILED(CWaveDataManager::CreateUniqueTempFile(sPrefix, sExtension, sTempName)))
		{
			GetTempFileName(sTempPath, sPrefix, 0, szTempName);
			sTempName = szTempName;
		}

		// Create a new wave node
		CWaveNode* pWaveNode = NULL;
		if(nChannels == 1)
		{
			pWaveNode = new CWaveNode(pComponent, false);
			if(pWaveNode == NULL)
			{
				return E_OUTOFMEMORY;
			}

			pWaveNode->m_sFileName = sTempName;
			pWaveNode->m_pWave = new CMonoWave(pWaveNode, dwSampleRate, nSampleSize);
		}
		else if(nChannels == 2)
		{
			pWaveNode = new CWaveNode(pComponent, true);
			if(pWaveNode == NULL)
			{
				return E_OUTOFMEMORY;
			}

			pWaveNode->m_sFileName = sTempName;
			pWaveNode->m_pWave = new CStereoWave(pWaveNode, true, dwSampleRate, nSampleSize);
		}

		if(pWaveNode->m_pWave == NULL)
			return E_OUTOFMEMORY;

		*ppWaveNode = pWaveNode;

		return S_OK;
	}

	return E_FAIL;
}


//////////////////////////////////////////////////////////////////////
//
//	CWavenode::CreateWaveNode
//
//////////////////////////////////////////////////////////////////////
HRESULT CWaveNode::CreateWaveNode(CDLSComponent* pComponent, CCollectionWaves* pWavesCollection, IDMUSProdRIFFStream* pIRiffStream, MMCKINFO* pckMain, CWaveNode** ppWaveNode)
{
	ASSERT(pWavesCollection);
	if(pWavesCollection == NULL)
		return E_POINTER;

	// Must have a component
	ASSERT(pComponent);
	if(pComponent == NULL)
		return E_POINTER;

	// Must have a stream to load the wave from
	ASSERT(pIRiffStream);
	if(pIRiffStream == NULL)
		return E_POINTER;

	ASSERT(pckMain);
	if(pckMain == NULL)
		return E_POINTER;


	CWaveNode* pWaveNode = NULL;
	GUID guidStereoWave;
	::CoCreateGuid(&guidStereoWave);
	
	// Keep this in a temporary guid var
	GUID guidTemp;
	CopyGUID(guidStereoWave, guidTemp);

	bool bStereoWave= false;
	bool bTrueStereo = false;
	bool bRightChannel = false;
	
	// Find out if we already have partially loaded this stereo wave node
	if(SUCCEEDED(IsLoadingStereoWave(pIRiffStream, pckMain, bStereoWave, bTrueStereo, guidStereoWave, bRightChannel)))
	{
		if(bStereoWave && !bTrueStereo)
		{
			pWaveNode  = FindNodeForStereoGuid(pWavesCollection, guidStereoWave);
		}
	}

	CCollection* pCollection = pWavesCollection->GetCollection();
	ASSERT(pCollection);
	if(pCollection == NULL)
	{
		return E_FAIL;
	}

	CString sCollectionFileName = pCollection->GetNodeFileName();
	if(sCollectionFileName.IsEmpty())
	{
		// Get the name from the passed strream...at least it should know what file it's loading from right?
		// This is probably a collection embedded in a container....
		IStream* pIStream = pIRiffStream->GetStream();
		ASSERT(pIStream);
		if(pIStream == NULL)
		{
			return E_FAIL;
		}

		CString sFilePath;
		IDMUSProdPersistInfo* pIJazzPersistInfo;
		if(SUCCEEDED(pIStream->QueryInterface(IID_IDMUSProdPersistInfo,(void**) &pIJazzPersistInfo)))
		{
			BSTR bstrFileName;
			pIJazzPersistInfo->GetFileName(&bstrFileName);
			sCollectionFileName = bstrFileName;
			SysFreeString(bstrFileName);
			pIJazzPersistInfo->Release();

			// Set the name for the collection node
			pCollection->SetNodeFileName(sCollectionFileName);
		}
		else
		{
			pIStream->Release();
			return E_FAIL;
		}
		
		pIStream->Release();
	}
	
	// We don't so get one
	if(pWaveNode == NULL)
	{
		pWaveNode = new CWaveNode(pComponent);
		if(pWaveNode == NULL)
		{
			return E_OUTOFMEMORY;
		}
	}

	pWaveNode->SetFileName(sCollectionFileName);
	pWaveNode->m_bInCollection = true;

	if(SUCCEEDED(pWaveNode->Load(pIRiffStream, pckMain)))
	{
		pWaveNode->SetCollection(pCollection);
		*ppWaveNode = pWaveNode;
		return S_OK;
	}

	delete pWaveNode;
	*ppWaveNode = NULL;

	return E_FAIL;
}


// This method is called ONLY when inserting a NEW wave so we don't want to check for exisiting nodes
HRESULT CWaveNode::CreateWaveNode(CDLSComponent* pComponent, IStream* pIStream, CString sFileName, CWaveNode** ppWaveNode, CCollectionWaves* pWavesCollection, bool bInACollection)
{
	// Must have a component
	ASSERT(pComponent);
	if(pComponent == NULL)
	{
		return E_POINTER;
	}

	// Must have a stream to load the wave from
	ASSERT(pIStream);
	if(pIStream == NULL)
	{
		return E_POINTER;
	}

    CCollection* pCollection = NULL;
    if(bInACollection)
    {
        ASSERT(pWavesCollection);
        if(pWavesCollection == NULL)
        {
            return E_INVALIDARG;
        }

        pCollection = pWavesCollection->GetCollection();
        ASSERT(pCollection);
        if(pCollection == NULL)
        {
            return E_UNEXPECTED;
        }
    }

	CWaveNode* pWaveNode = new CWaveNode(pComponent);
	if(pWaveNode == NULL)
	{
		return E_OUTOFMEMORY;
	}

    pWaveNode->m_bInCollection = bInACollection;
	pWaveNode->SetFileName(sFileName);

	if(SUCCEEDED(pWaveNode->Load(pIStream)))
	{
        pWaveNode->SetCollection(pCollection);
		*ppWaveNode = pWaveNode;
		return S_OK;
	}

	delete pWaveNode;
	*ppWaveNode = NULL;

	return E_FAIL;
}

CWaveNode* CWaveNode::FindNodeForStereoGuid(CCollectionWaves* pWavesCollection, const GUID& guidStereoWave)
{
	if(pWavesCollection == NULL)
		return NULL;

	CWaveNode* pWaveNode = pWavesCollection->GetHead();
	
	while(pWaveNode)
	{
		if(pWaveNode->IsStereo())
		{
			CStereoWave* pWave = (CStereoWave*) pWaveNode->GetWave();
			if(pWave->GetGUID() == guidStereoWave)
			{
				return pWaveNode;
			}
		}
		
		pWaveNode = pWaveNode->GetNext();
	}

	return NULL;
}


void CWaveNode::CopyGUID(const GUID& guidSrc, GUID& guidDest)
{
	guidDest.Data1 = guidSrc.Data1;
	guidDest.Data2 = guidSrc.Data2;
	guidDest.Data3 = guidSrc.Data3;
	CopyMemory(&(guidDest.Data4), &(guidSrc.Data4), sizeof(BYTE) * 8);
}

//////////////////////////////////////////////////////////////////////
//
//	CWavenode::QueryInterface()
//
//////////////////////////////////////////////////////////////////////
HRESULT CWaveNode::QueryInterface(REFIID riid, LPVOID *ppvObj)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
    if(::IsEqualIID(riid, IID_IDMUSProdNode)
	|| ::IsEqualIID(riid, IID_IUnknown))
    {
        AddRef();
        *ppvObj = (IDMUSProdNode*)this;
        return S_OK;
    }

    if(::IsEqualIID(riid, IID_IPersist))
    {
        AddRef();
        *ppvObj = (IPersist*)this;
        return S_OK;
    }

    if(::IsEqualIID(riid, IID_IPersistStream))
    {
        AddRef();
        *ppvObj = (IPersistStream*)this;
        return S_OK;
    } 

	if(::IsEqualIID(riid, IID_IDMUSProdWaveTimelineDraw))
    {
        AddRef();
        *ppvObj = (IDMUSProdWaveTimelineDraw*)this;
        return S_OK;
    } 

	if(::IsEqualIID(riid, IID_IDMUSProdPropPageObject))
    {
        m_pWave->AddRef();
        *ppvObj = (IDMUSProdPropPageObject*)m_pWave;
        return S_OK;
    }

	if(::IsEqualIID(riid, IID_IDMUSProdNotifySink))
    {
        AddRef();
        *ppvObj = (IDMUSProdNotifySink*)this;
        return S_OK;
    }

    *ppvObj = NULL;
    return E_NOINTERFACE;
}

//////////////////////////////////////////////////////////////////////
//
//	CWaveNode::AddRef()
//
//////////////////////////////////////////////////////////////////////
ULONG CWaveNode::AddRef()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	AfxOleLockApp();
    return InterlockedIncrement(&m_lRef);
}

//////////////////////////////////////////////////////////////////////
//
//	CWaveNode::Release()
//
//////////////////////////////////////////////////////////////////////
ULONG CWaveNode::Release()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
    ASSERT(m_lRef != 0);

	InterlockedDecrement(&m_lRef); 

    if(m_lRef == 0)
    {
        delete this;
        return 0;
    }
	AfxOleUnlockApp();
    return m_lRef;
}

/////////////////////////////////////////////////////////////////////////////
// CWaveNode IDMUSProdNode implementation

//////////////////////////////////////////////////////////////////////
//
//	CWaveNode IDMUSProdNode::GetNodeImageIndex
//
//////////////////////////////////////////////////////////////////////
HRESULT CWaveNode::GetNodeImageIndex(short* pnFirstImage)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	
	ASSERT(pnFirstImage);
	
	ASSERT(m_pComponent != NULL);

	if(IsStereo())
	{
		return(m_pComponent->GetStereoWaveImageIndex(pnFirstImage));
	}

	return(m_pComponent->GetWaveImageIndex(pnFirstImage));
}

//////////////////////////////////////////////////////////////////////
//
//	CWaveNode IDMUSProdNode::GetComponent
//
//////////////////////////////////////////////////////////////////////
HRESULT CWaveNode::GetComponent(IDMUSProdComponent** ppIComponent)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( m_pComponent != NULL );

	return m_pComponent->QueryInterface( IID_IDMUSProdComponent, (void**)ppIComponent );
}

//////////////////////////////////////////////////////////////////////
//
//	CWaveNode IDMUSProdNode::GetDocRootNode
//
//////////////////////////////////////////////////////////////////////
HRESULT CWaveNode::GetDocRootNode(IDMUSProdNode** ppIRootNode)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if(m_pIRootNode)
	{
		m_pIRootNode->AddRef();
		*ppIRootNode = m_pIRootNode;
		return S_OK;
	}

	*ppIRootNode = NULL;
	return E_FAIL;

}

//////////////////////////////////////////////////////////////////////
//
//	CWaveNode IDMUSProdNode::SetDocRootNode
//
//////////////////////////////////////////////////////////////////////
HRESULT CWaveNode::SetDocRootNode(IDMUSProdNode* pIRootNode)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	ASSERT(pIRootNode != NULL);

	m_pIRootNode = pIRootNode;
//	m_pIRootNode->AddRef();		intentionally missing

	return S_OK;
}

//////////////////////////////////////////////////////////////////////
//
//	CWaveNode IDMUSProdNode::GetParentNode
//
//////////////////////////////////////////////////////////////////////
HRESULT CWaveNode::GetParentNode(IDMUSProdNode** ppIParentNode)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( ppIParentNode == NULL )
	{
		return E_POINTER;
	}

	*ppIParentNode = m_pIParentNode;

	if(m_pIParentNode)
	{
		m_pIParentNode->AddRef();
	}

	return S_OK;
}

//////////////////////////////////////////////////////////////////////
//
//	CWaveNode IDMUSProdNode::SetParentNode
//
//////////////////////////////////////////////////////////////////////
HRESULT CWaveNode::SetParentNode(IDMUSProdNode* pIParentNode)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	m_pIParentNode = pIParentNode;
//	m_pIParentNode->AddRef();		intentionally missing

	return S_OK;
}

//////////////////////////////////////////////////////////////////////
//
//	CWaveNode IDMUSProdNode::GetNodeId
//
//////////////////////////////////////////////////////////////////////
HRESULT CWaveNode::GetNodeId(GUID* pguid)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( pguid == NULL )
	{
		return E_POINTER;
	}

	*pguid = GUID_WaveNode;

	return S_OK;
}

//////////////////////////////////////////////////////////////////////
//
//	CWaveNode IDMUSProdNode::GetNodeName
//
//////////////////////////////////////////////////////////////////////
HRESULT CWaveNode::GetNodeName(BSTR* pbstrName)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	ASSERT(pbstrName);
    
	*pbstrName = m_pWave->GetName().AllocSysString();

	return S_OK;
}

//////////////////////////////////////////////////////////////////////
//
//	CWaveNode IDMUSProdNode::GetNodeNameMaxLength
//
//////////////////////////////////////////////////////////////////////
HRESULT CWaveNode::GetNodeNameMaxLength(short* pnMaxLength)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	
	ASSERT(pnMaxLength);

	*pnMaxLength = BUFFER_256;	// Can't edit Wave name.

	return S_OK;
}

//////////////////////////////////////////////////////////////////////
//
//	CWaveNode IDMUSProdNode::ValidateNodeName
//
//////////////////////////////////////////////////////////////////////
HRESULT CWaveNode::ValidateNodeName(BSTR bstrName)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	CString strName;

	strName = bstrName;
	
	::SysFreeString(bstrName);

	return S_OK;
}

//////////////////////////////////////////////////////////////////////
//
//	CWavenode IDMUSProdNode::SetNodeName
//
//////////////////////////////////////////////////////////////////////
HRESULT CWaveNode::SetNodeName(BSTR bstrName)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT(m_pWave);
	if(m_pWave == NULL)
	{
		return E_FAIL;
	}

	ASSERT(m_pComponent);
	if(m_pComponent == NULL)
	{
		return E_FAIL;
	}

	ASSERT(m_pComponent->m_pIFramework);
	if(m_pComponent->m_pIFramework == NULL)
	{
		return E_FAIL;
	}

	
    CString strName = bstrName;
	::SysFreeString( bstrName );

	m_pWave->SetName(strName);
	SetTransportName();

	// Send the name change notification
	if(m_pComponent->m_pIFramework)
	{
		m_pComponent->m_pIFramework->NotifyNodes(this, WAVENODE_NameChange, NULL);
	}


	return S_OK;
}

//////////////////////////////////////////////////////////////////////
//
//	CWaveNode IDMUSProdNode::GetEditorClsId
//
//////////////////////////////////////////////////////////////////////
HRESULT CWaveNode::GetEditorClsId(CLSID* pClsId)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

    *pClsId = CLSID_Wave;
	
	return S_OK;
}

//////////////////////////////////////////////////////////////////////
//
//	CWaveNode IDMUSProdNode::GetEditorTitle
//
//////////////////////////////////////////////////////////////////////
HRESULT CWaveNode::GetEditorTitle(BSTR* pbstrTitle)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	CString strTitle;

	strTitle = _T("Wave: ");
	strTitle += m_pWave->GetName();

    *pbstrTitle = strTitle.AllocSysString();

	return S_OK;
}

//////////////////////////////////////////////////////////////////////
//
//	CWaveNode IDMUSProdNode::GetEditorWindow
//
//////////////////////////////////////////////////////////////////////
HRESULT CWaveNode::GetEditorWindow(HWND* hWndEditor)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	*hWndEditor = m_hWndEditor;

	return S_OK;
}

//////////////////////////////////////////////////////////////////////
//
//	CWaveNode IDMUSProdNode::SetEditorWindow
//
//////////////////////////////////////////////////////////////////////
HRESULT CWaveNode::SetEditorWindow(HWND hWndEditor)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	m_hWndEditor = hWndEditor;

	return S_OK;
}

//////////////////////////////////////////////////////////////////////
//
//	CWaveNode IDMUSProdNode::UseOpenCloseImages
//
//////////////////////////////////////////////////////////////////////
HRESULT CWaveNode::UseOpenCloseImages(BOOL* pfUseOpenCloseImages)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT(pfUseOpenCloseImages);

	*pfUseOpenCloseImages = FALSE;

	return S_OK;
}

//////////////////////////////////////////////////////////////////////
//
//	CWaveNode IDMUSProdNode::GetRightClickMenuId
//
//////////////////////////////////////////////////////////////////////
HRESULT CWaveNode::GetRightClickMenuId(HINSTANCE* phInstance, UINT* pnMenuId)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT(pnMenuId);
	ASSERT(phInstance);

	*phInstance = theApp.m_hInstance;
	*pnMenuId = IDM_WAVE_NODE_RMENU;

	return S_OK;
}

//////////////////////////////////////////////////////////////////////
//
//	CWaveNode IDMUSProdNode::OnRightClickMenuInit
//
//////////////////////////////////////////////////////////////////////
HRESULT CWaveNode::OnRightClickMenuInit(HMENU hMenu)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	ASSERT(m_pWave);
	if(m_pWave == NULL)
	{
		return E_UNEXPECTED;
	}

	if(IsInACollection())
	{
		CCollection* pCollection = m_pWave->GetCollection();
		ASSERT(pCollection);
		if(pCollection)
		{
			DWORD dwMenuFlags = MF_BYCOMMAND | MF_ENABLED;
			DWORD dwWaveNodes = pCollection->WaveNodeCount();
			DWORD dwInstrumentCount = pCollection->InstrumentCount();
			if(dwWaveNodes == 1 && dwInstrumentCount >= 1)
			{
				dwMenuFlags = MF_GRAYED | MF_BYCOMMAND;
			}

			CMenu menu;
 			if(menu.Attach(hMenu))
			{
				menu.EnableMenuItem(IDM_DELETE, dwMenuFlags);
				menu.Detach();
			}
		}
	}

	return S_OK;
}

//////////////////////////////////////////////////////////////////////
//
//	CWaveNode IDMUSProdNode::OnRightClickMenuSelect
//
//////////////////////////////////////////////////////////////////////
HRESULT CWaveNode::OnRightClickMenuSelect(long lCommandId)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT(m_pComponent != NULL);
	ASSERT(m_pComponent->m_pIFramework != NULL);

	HRESULT hr = E_FAIL;
	IDMUSProdNode* pIParentNode;
	
	switch(lCommandId)
	{
		case IDM_OPEN:
			if(SUCCEEDED(m_pComponent->m_pIFramework->OpenEditor(this)))
			{
				hr = S_OK;
			}
			break;
		
        case IDM_SAVEAS:
            {
				hr = E_FAIL;
               if(m_pWave)
			   {
				   hr = m_pWave->SaveAs(NULL, true);
			   }
            }
    	break;

        case IDM_CUT:
			hr = E_NOTIMPL;			
			break;

		case IDM_COPY:
			hr = E_NOTIMPL;
			break;

		case IDM_PASTE:
			hr = E_NOTIMPL;
			break;

		case IDM_REPLACE:
			{
				if(m_pWave)
					m_pWave->Replace();
				break;
			}

		case IDM_DELETE:
			if ( ConfirmWaveDelete() )
			{
				if(SUCCEEDED(GetParentNode(&pIParentNode)))
				{
                    if(pIParentNode)
                    {
					    if(SUCCEEDED(pIParentNode->DeleteChildNode((IDMUSProdNode *)this, FALSE)))
					    {
						    hr = S_OK;				
					    }
					    pIParentNode->Release();
                    }
                    else if(pIParentNode == NULL)
                    {
                        hr = DeleteNode(false);
                    }
				}
			}
			break;

		case IDM_RENAME:
			if(SUCCEEDED(m_pComponent->m_pIFramework->EditNodeLabel((IDMUSProdNode *)this)))
			{
    			hr = S_OK;
			}
			break;
		
		case IDM_PROPERTIES:
			if(m_pWave)
			{
				hr = E_FAIL;
				if(SUCCEEDED(m_pWave->OnShowProperties()))
				{
					hr = S_OK;
				}
			}
			break;
	}

	return hr;

}

//////////////////////////////////////////////////////////////////////
//
//	CWaveNode IDMUSProdNode::DeleteChildNode
//
//////////////////////////////////////////////////////////////////////
HRESULT CWaveNode::DeleteChildNode(IDMUSProdNode* pIChildNode, BOOL fPromptUser)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	return E_FAIL;	// Not implemented.
}

//////////////////////////////////////////////////////////////////////
//
//	CWaveNode IDMUSProdNode::InsertChildNode
//
//////////////////////////////////////////////////////////////////////
HRESULT CWaveNode::InsertChildNode(IDMUSProdNode* pIChildNode)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	return E_FAIL;	// Not implemented.
}

//////////////////////////////////////////////////////////////////////
//
//	CWaveNode IDMUSProdNode::DeleteNode
//
//////////////////////////////////////////////////////////////////////
HRESULT CWaveNode::DeleteNode( BOOL fPromptUser )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT(m_pWave);
	if(m_pWave == NULL)
	{
		return E_UNEXPECTED;
	}

	IDMUSProdNode* pIParentNode = NULL;

	bool bDelete = true;
	if(IsInACollection())
	{
		CCollection* pCollection = m_pWave->GetCollection();
		CCollectionInstruments* pInstruments = pCollection->GetInstruments();
		DWORD dwWaveCount= pCollection->WaveNodeCount();
		DWORD dwInstrumentCount = pCollection->InstrumentCount();

		if(dwWaveCount == 1 && dwInstrumentCount == 1)
		{
			return E_FAIL;
		}
	}

	if(fPromptUser)
	{
		bDelete = ConfirmWaveDelete();
	}

	if(bDelete)
	{
		// Release the dummy instrument
		m_pWave->ReleaseDummyInstruments();

		// Remove yourself from the components wavenode list
		// You will not be in that list if you're in a collection 
		m_pComponent->DeleteFromWaveNodesList(this);

		UnRegisterFromTransport();

		if(SUCCEEDED(GetParentNode(&pIParentNode)))
		{
			if(pIParentNode)
			{
				HRESULT hr = pIParentNode->DeleteChildNode( this, FALSE );
				pIParentNode->Release();
				return hr;		
			}
		}

		// We need to close out all the open file handles
		if(FAILED(m_pWave->CloseSourceHandler()))
		{
			return E_FAIL;
		}

		// No parent so we delete ourself
		if(m_pComponent->m_pIFramework->RemoveNode(this, fPromptUser) == S_FALSE)
		{
			return E_FAIL;	
		}
		
		return S_OK;
	}

	return E_FAIL;
}

//////////////////////////////////////////////////////////////////////
//
//	CWaveNode IDMUSProdNode::GetFirstChild
//
//////////////////////////////////////////////////////////////////////
HRESULT CWaveNode::GetFirstChild(IDMUSProdNode** ppIFirstChildNode)
{
	// A Wave does not have any children	
	
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	
	return E_NOTIMPL;
}

//////////////////////////////////////////////////////////////////////
//
//	CWaveNode IDMUSProdNode::GetNextChild
//
//////////////////////////////////////////////////////////////////////
HRESULT CWaveNode::GetNextChild(IDMUSProdNode* pIChildNode, IDMUSProdNode** ppINextChildNode)
{
	// A Wave does not have any children	
	
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	
	return E_NOTIMPL;
}

//////////////////////////////////////////////////////////////////////
//
//	CWaveNode IDMUSProdNode::GetNodeListInfo
//
//////////////////////////////////////////////////////////////////////
HRESULT CWaveNode::GetNodeListInfo(DMUSProdListInfo* pListInfo)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( pListInfo == NULL )
	{
		return E_POINTER;
	}

	CString strDescriptor;
	CString strName = m_pWave->GetName();

    pListInfo->bstrName = strName.AllocSysString();
    pListInfo->bstrDescriptor = strDescriptor.AllocSysString();
	memcpy( &pListInfo->guidObject, &m_guidFile, sizeof(GUID) );

	// Must check pListInfo->wSize before populating additional fields
	return S_OK;
}

//////////////////////////////////////////////////////////////////////
//
//	CWaveNode IDMUSProdNode::OnNodeSelChanged
//
//////////////////////////////////////////////////////////////////////
HRESULT CWaveNode::OnNodeSelChanged(BOOL fSelected)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	HRESULT hr = S_OK;

	if(fSelected)
	{
		ASSERT(m_pComponent);
		if(m_pComponent == NULL)
		{
			return E_UNEXPECTED;
		}

		ASSERT(m_pComponent->m_pIConductor != NULL);
		if(m_pComponent->m_pIConductor == NULL)
		{
			return E_UNEXPECTED;
		}
		
		// Setup the dummy instrument in case we want to play the wave.
		m_pWave->SetupDummyInstrument();

		SetTransportName();
		UINT uButtonState = BS_PLAY_ENABLED | BS_NO_AUTO_UPDATE;
		if(m_pWave->WaveIsPlaying())
		{
			uButtonState = BS_STOP_ENABLED | BS_NO_AUTO_UPDATE;
		}
		
		m_pComponent->m_pIConductor->SetActiveTransport(this, uButtonState);
	}

	return hr; 
}


HRESULT CWaveNode::SetSelected(BOOL bSelect)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

    ASSERT(m_pComponent);
	if(m_pComponent == NULL)
	{
		return E_FAIL;
	}

	IDMUSProdFramework* pIFramework = m_pComponent->m_pIFramework;
	ASSERT(pIFramework);
	if(pIFramework == NULL)
	{
		return E_FAIL;
	}

	IDMUSProdNode* pSelectedNode = NULL;
	if(FAILED(pIFramework->GetSelectedNode(&pSelectedNode)))
	{
		return E_FAIL;
	}
	
	HRESULT hr = E_FAIL;
	if(this != pSelectedNode)
	{
		hr = pIFramework->SetSelectedNode(this);
	}

	pSelectedNode->Release();
	return hr;
}


HRESULT CWaveNode::CreateDataObject( IDataObject** ppIDataObject )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

    ASSERT(m_pComponent);
	if(m_pComponent == NULL)
	{
		return E_FAIL;
	}

	IDMUSProdFramework* pIFramework = m_pComponent->m_pIFramework;
	ASSERT(pIFramework);
	if(pIFramework == NULL)
	{
		return E_FAIL;
	}

	if(ppIDataObject == NULL)
	{
		return E_POINTER;
	}

	*ppIDataObject = NULL;

	// Create the CDllJazzDataObject 
	CDllJazzDataObject* pDataObject = new CDllJazzDataObject();
	if( pDataObject == NULL )
	{
		return E_OUTOFMEMORY;
	}

	IStream* pIStream = NULL;
	HRESULT hr = E_FAIL;
	if(SUCCEEDED(pIFramework->AllocMemoryStream(FT_DESIGN, GUID_CurrentVersion, &pIStream)))
	{
		IDMUSProdRIFFStream* pIRiffStream = NULL;
		if(FAILED(AllocRIFFStream(pIStream, &pIRiffStream)))
		{
			pIStream->Release();
			return E_OUTOFMEMORY;
		}
		
		SetDragCopy(false);
		if(FAILED(WriteDragChunkToStream(pIRiffStream)))
		{
			SetDragCopy(false);
			pIRiffStream->Release();
			pIStream->Release();
			return E_FAIL;
		}
		
		SetDragCopy(false);

		// Done with the RIFF stream
		pIRiffStream->Release();

		if(FAILED(hr = pDataObject->AddClipFormat(m_pComponent->m_cfWave, pIStream)))
		{
			pIStream->Release();
			return E_FAIL;
		}

		pIStream->Release();
	}

	if(SUCCEEDED(hr))
	{
		hr = E_FAIL;

		// Create a stream in CF_DMUSPROD_FILE format
		if(SUCCEEDED(m_pComponent->m_pIFramework->SaveClipFormat( m_pComponent->m_cfProducerFile, this, &pIStream ) ) )
		{
			// Container nodes represent files so we must also
			// place CF_DMUSPROD_FILE into CDllJazzDataObject
			hr = pDataObject->AddClipFormat(m_pComponent->m_cfProducerFile, pIStream);
			pIStream->Release();
		}
	}


	if(SUCCEEDED(hr))
	{
		// Already AddRef'd
		*ppIDataObject = pDataObject;	
	}
	else
	{
		pDataObject->Release();
	}

	return hr;
}

/////////////////////////////////////////////////////////////////////////////
//
// CWaveNode IDMUSProdNode::CanCut
//
//////////////////////////////////////////////////////////////////////
HRESULT CWaveNode::CanCut()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

    return S_OK;

}

/////////////////////////////////////////////////////////////////////////////
//
// CWaveNode IDMUSProdNode::CanCopy
//
//////////////////////////////////////////////////////////////////////
HRESULT CWaveNode::CanCopy()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
    return S_OK;

}

/////////////////////////////////////////////////////////////////////////////
//
// CWaveNode IDMUSProdNode::CanDelete
//
//////////////////////////////////////////////////////////////////////
HRESULT CWaveNode::CanDelete()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
    return S_OK;    

}

/////////////////////////////////////////////////////////////////////////////
//
// CWaveNode IDMUSProdNode::CanDeleteChildNode
//
//////////////////////////////////////////////////////////////////////
HRESULT CWaveNode::CanDeleteChildNode( IDMUSProdNode* pIChildNode )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
    return E_NOTIMPL;   // no children

}

/////////////////////////////////////////////////////////////////////////////
//
// CWaveNode IDMUSProdNode::CanPasteFromData
//
//////////////////////////////////////////////////////////////////////
HRESULT CWaveNode::CanPasteFromData( IDataObject* pIDataObject, BOOL* pfWillSetReference )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( pfWillSetReference == NULL )
	{
		return E_POINTER;
	}

	*pfWillSetReference = FALSE;

	if( pIDataObject == NULL )
	{
		return E_INVALIDARG;
	}

	// Stand alone Wave Nodes are not drop targets
	if(IsInACollection() == false)
	{
		return S_FALSE;
	}


	// Create a new CDllJazzDataObject and see if it can read the data object's format.
	CDllJazzDataObject* pDataObject = new CDllJazzDataObject();
	if( pDataObject == NULL )
	{
		return E_OUTOFMEMORY;
	}

	HRESULT hr = S_FALSE;

	if( SUCCEEDED (	pDataObject->IsClipFormatAvailable( pIDataObject, m_pComponent->m_cfWave)))
    {
        hr = S_OK;
    }

    pDataObject->Release();

    return hr;
}

/////////////////////////////////////////////////////////////////////////////
//
// CWaveNode IDMUSProdNode::PasteFromData
//
//////////////////////////////////////////////////////////////////////
HRESULT CWaveNode::PasteFromData( IDataObject* pIDataObject )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

    // Pass it to the parent to paste.
	if( m_pIRootNode != this )
	{
		if( m_pIParentNode )
		{
			return m_pIParentNode->ChildPasteFromData( pIDataObject, this );
		}
	}

	return E_FAIL;
}

/////////////////////////////////////////////////////////////////////////////
//
// CWaveNode IDMUSProdNode::CanChildPasteFromData
//
//////////////////////////////////////////////////////////////////////
HRESULT CWaveNode::CanChildPasteFromData( IDataObject* pIDataObject, IDMUSProdNode* pIChildNode,
									  BOOL* pfWillSetReference )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
    return E_NOTIMPL;   // no children

}

/////////////////////////////////////////////////////////////////////////////
//
// CWaveNode IDMUSProdNode::ChildPasteFromData
//
//////////////////////////////////////////////////////////////////////
HRESULT CWaveNode::ChildPasteFromData( IDataObject* pIDataObject, IDMUSProdNode* pIChildNode )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
    return E_NOTIMPL;   // no children

}

/////////////////////////////////////////////////////////////////////////////
// CWaveNode IDMUSProdNode::GetObject

HRESULT CWaveNode::GetObject( REFCLSID rclsid, REFIID riid, void** ppvObject )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if(::IsEqualCLSID(rclsid, CLSID_DirectSoundWave))
	{
		if(m_pIDirectSoundWave)
		{
			return m_pIDirectSoundWave->QueryInterface(riid, ppvObject);
		}
	}


	return E_NOTIMPL;
}

////////////////////////////////////////////////////////////////////////////////
//
// IDMUSProdnotifySink Implementation
//
////////////////////////////////////////////////////////////////////////////////
HRESULT CWaveNode::OnUpdate(IDMUSProdNode* pIDocRootNode, GUID guidUpdateType, VOID* pData)
{
	ASSERT(m_pWave);
	if(m_pWave == NULL)
	{
		return E_FAIL;
	}

	if(pIDocRootNode != m_pIRootNode)
	{
		return E_NOTIMPL;
	}

	static bool bActualNameChange = false;

	AFX_MANAGE_STATE(_afxModuleAddrThis);
	if(::IsEqualGUID( guidUpdateType, FRAMEWORK_BeforeFileSave))
	{
		ASSERT(pData);
		if(pData == NULL)
		{
			return E_INVALIDARG;
		}

		WCHAR* pwszFileName = (WCHAR*)pData;
		CString sFileName = pwszFileName;

		// Rename the file if we're the docroot
		if(IsInACollection() == false)
		{
			// We're not getting saved are we?
			if(m_sFileName != sFileName)
			{
				return S_OK;
			}

			// Get a temp file name
			char szTempPath[MAX_PATH];
			DWORD dwSuccess = GetTempPath(MAX_PATH, szTempPath);
			CString sTempPath = szTempPath;
			
			char szTempName[MAX_PATH];
			CString sTempName;
			
			CString sPrefix = "DMP";
			CString sExtension = "tmp";
			if(FAILED(CWaveDataManager::CreateUniqueTempFile(sPrefix, sExtension, sTempName)))
			{
				GetTempFileName(sTempPath, sPrefix, 0, szTempName);
				sTempName = szTempName;
			}

			// Delete the created file otherwise the rename will fail 
			DeleteFile(sTempName);

			EnterCriticalSection(&m_CriticalSection);
			if(FAILED(m_pWave->PrepareForSave(sTempName)))
			{
				LeaveCriticalSection(&m_CriticalSection);
				return E_FAIL;
			}

			LeaveCriticalSection(&m_CriticalSection);
		}
		return S_OK;
	}

	if(::IsEqualGUID(guidUpdateType, FRAMEWORK_AfterFileSave))
	{
		ASSERT(pData);
		if(pData == NULL)
		{
			return E_INVALIDARG;
		}

		WCHAR* pwszFileName = (WCHAR*)pData;
		CString sFileName = pwszFileName;

		if(IsInACollection() == false)
		{
			// We're not getting saved are we?
			if(m_sFileName != sFileName)
			{
				return S_OK;
			}

			EnterCriticalSection(&m_CriticalSection);
			if(FAILED(m_pWave->CleanupAfterSave(sFileName)))
			{
				LeaveCriticalSection(&m_CriticalSection);
				return E_FAIL;
			}

			LeaveCriticalSection(&m_CriticalSection);
		}

		return S_OK;
	}

	if(::IsEqualGUID( guidUpdateType, FRAMEWORK_BeforeFileNameChange))
	{
		// We need to close out all the open file handles
		bActualNameChange = true;
		EnterCriticalSection(&m_CriticalSection);
		if(FAILED(m_pWave->CloseSourceHandler()))
		{
			LeaveCriticalSection(&m_CriticalSection);
			bActualNameChange = false;
			return E_FAIL;
		}

		return S_OK;
	}

	if(::IsEqualGUID( guidUpdateType, FRAMEWORK_AbortFileNameChange))
	{
		bActualNameChange = false;
		if(FAILED(m_pWave->OnSourceRenamed(m_sFileName)))
		{
			LeaveCriticalSection(&m_CriticalSection);
			return E_FAIL;
		}

		LeaveCriticalSection(&m_CriticalSection);

		return S_OK;
	}

	if(::IsEqualGUID(guidUpdateType, FRAMEWORK_FileNameChange))
	{
		ASSERT(m_pComponent->m_pIFramework);
		if(m_pComponent->m_pIFramework == NULL)
		{
			return E_FAIL;
		}

		// Ge the new file name for the node
		BSTR bstrNodeFileName;
		if(FAILED(m_pComponent->m_pIFramework->GetNodeFileName((IDMUSProdNode*)this, &bstrNodeFileName)))
		{
            bActualNameChange = false;
			LeaveCriticalSection(&m_CriticalSection);
			return E_FAIL;
		}

		CString sFileName = bstrNodeFileName;
		::SysFreeString(bstrNodeFileName);

		// Are we already looking at the same file?
		if(m_sFileName == sFileName)
		{
            bActualNameChange = false;
			return S_OK;
		}

		// Keep the name with the wave node...
		SetFileName(sFileName);

		if(!bActualNameChange)
		{
			EnterCriticalSection(&m_CriticalSection);
		}

		if(FAILED(m_pWave->FileNameChanged(sFileName)))
		{
            bActualNameChange = false;
			LeaveCriticalSection(&m_CriticalSection);
			return E_FAIL;
		}

		LeaveCriticalSection(&m_CriticalSection);
		m_pWave->NotifyWaveChange(false);
        bActualNameChange = false;

		return S_OK;
	}

	if(::IsEqualGUID(guidUpdateType, FRAMEWORK_AfterFileOpen))
	{
        bActualNameChange = false;

		// Check if this is during a drop-paste
		if(m_bPastingWave)
		{
			m_bPastingWave = false;
			DeleteFile(m_sFileName);

			// We need to close out all the open file handles
			bActualNameChange = true;
			EnterCriticalSection(&m_CriticalSection);
			if(FAILED(m_pWave->CloseSourceHandler()))
			{
                bActualNameChange = false;
				LeaveCriticalSection(&m_CriticalSection);
				return E_FAIL;
			}

			try
			{
				CFile::Rename(m_sTempFileName, m_sFileName);
			}
			catch(CFileException e)
			{
                bActualNameChange = false;
				LeaveCriticalSection(&m_CriticalSection);
				return E_FAIL;
			}

			if(FAILED(m_pWave->FileNameChanged(m_sFileName)))
			{
                bActualNameChange = false;
				LeaveCriticalSection(&m_CriticalSection);
				return E_FAIL;
			}

			LeaveCriticalSection(&m_CriticalSection);
            bActualNameChange = false;

			return S_OK;

		}	
	}

	return E_NOTIMPL;
}



//////////////////////////////////////////////////////////////////////
//
//	CWaveNode IPersist::GetClassID
//
//////////////////////////////////////////////////////////////////////
HRESULT CWaveNode::GetClassID(CLSID* pClsId)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

    ASSERT(pClsId != NULL);

    memset(pClsId, 0, sizeof( CLSID ));

    return S_OK;
}

//////////////////////////////////////////////////////////////////////
// CWaveNode : IPersistStream Implementation
// This implementation is just a wrapper and basically calls the 
// methods implemented in the contained CWave object

//////////////////////////////////////////////////////////////////////
//
// CWaveNode IPersistStream::IsDirty
//
//////////////////////////////////////////////////////////////////////
HRESULT CWaveNode::IsDirty()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	return m_bIsDirty ? S_OK : S_FALSE;
}

//////////////////////////////////////////////////////////////////////
//
// CWaveNode IPersistStream::GetSizeMax
//
//////////////////////////////////////////////////////////////////////
HRESULT CWaveNode::GetSizeMax( ULARGE_INTEGER FAR* /*pcbSize*/ )
{
    // I want to know if I am called
	ASSERT(FALSE);

	AFX_MANAGE_STATE(_afxModuleAddrThis);
	return E_NOTIMPL;
}

//////////////////////////////////////////////////////////////////////
//
// CWaveNode IPersistStream::Load
//
//////////////////////////////////////////////////////////////////////
HRESULT CWaveNode::Load(IStream* pIStream)
{
    AFX_MANAGE_STATE(_afxModuleAddrThis);
	ASSERT(m_pComponent);
	if(m_pComponent == NULL)
	{
		return E_FAIL;
	}

	ASSERT(m_pComponent->m_pIFramework);
	if(m_pComponent->m_pIFramework == NULL)
	{
		return E_FAIL;
	}

	ASSERT(pIStream);
	if(pIStream == NULL)
	{
		return E_POINTER;
	}
	
	HRESULT hr = E_FAIL;
	MMCKINFO ckMain;
    IDMUSProdRIFFStream* pRiffStream = NULL;

	if(SUCCEEDED(hr = AllocRIFFStream(pIStream, &pRiffStream)))
	{
		DWORD dwPos = StreamTell(pIStream);
		hr = E_FAIL;
		ckMain.fccType = mmioFOURCC('W','A','V','E');
		while(pRiffStream->Descend(&ckMain, NULL, MMIO_FINDRIFF) == 0 )
		{
			if(FAILED(hr = Load(pRiffStream, &ckMain)))
			{
				pRiffStream->Release();
				return E_FAIL;
			}
			pRiffStream->Ascend(&ckMain, 0);
		}

		// We don't have any actual waves persisted in the stream
		// This might then be the drag chunk you think?
		if(FAILED(hr))
		{
			StreamSeek(pIStream, dwPos, STREAM_SEEK_SET);
			ckMain.ckid = FOURCC_DRAG;
			ckMain.fccType = 0;

			if(pRiffStream->Descend(&ckMain, NULL, MMIO_FINDCHUNK) == 0 )
			{
				if(FAILED(hr = PasteWave(pRiffStream, &ckMain)))
				{
					pRiffStream->Release();
					return E_FAIL;
				}

				pRiffStream->Ascend(&ckMain, 0);
			}
		}

		pRiffStream->Release();
	}


	if(SUCCEEDED(hr) && m_pIDirectSoundWave == NULL && m_bInCollection == false)
	{
		CreateDirectSoundWave();
	}

	ClearDirtyFlag();

	return hr;
}

HRESULT CWaveNode::PasteWave(IDMUSProdRIFFStream* pIRiffStream, MMCKINFO* pckDragged)
{
	ASSERT(pIRiffStream);
	if(pIRiffStream == NULL)
	{
		return E_POINTER;
	}

	ASSERT(pckDragged);
	if(pckDragged == NULL)
	{
		return E_POINTER;
	}

	ASSERT(m_pComponent);
	if(m_pComponent == NULL)
	{
		return E_FAIL;
	}
	
	IDMUSProdFramework* pIFramework = m_pComponent->m_pIFramework;
	ASSERT(pIFramework);
	if(pIFramework == NULL)
	{
		return E_FAIL;
	}

	IStream* pIStream = pIRiffStream->GetStream();
	ASSERT(pIStream);
	if(pIStream == NULL)
	{
		return E_FAIL;
	}

	// Get the node guid saved in the chunk
	GUID guidFile;
	DWORD cb = 0;
	HRESULT hr = pIStream->Read(&guidFile, sizeof(GUID), &cb);
	if(FAILED(hr) || cb != sizeof(GUID))
	{
		pIStream->Release();
		return E_FAIL;
	}


	GUID guidNode;
	cb = 0;
	hr = pIStream->Read(&guidNode, sizeof(GUID), &cb);
	if(FAILED(hr) || cb != sizeof(GUID))
	{
		pIStream->Release();
		return E_FAIL;
	}

	// Done with the stream
	pIStream->Release();
	pIRiffStream->Ascend(pckDragged, 0);

	// Find the wave node that owns this wave file
	IDMUSProdNode* pIDocRootNode = NULL;
	if(FAILED(pIFramework->FindDocRootNodeByFileGUID(guidFile, &pIDocRootNode)))
	{
		return E_FAIL;
	}

	// Get the file name for the node we're copying from
	BSTR bstrSourceFileName;
	if(FAILED(pIFramework->GetNodeFileName(pIDocRootNode, &bstrSourceFileName)))
	{
		pIDocRootNode->Release();
		return E_FAIL;
	}

	CString sSourceFileName = bstrSourceFileName;
	SysFreeString(bstrSourceFileName);

	// Get a temp file name to copy the source into
	char szTempPath[MAX_PATH];
	GetTempPath(MAX_PATH, szTempPath);
	char szTempFileName[MAX_PATH];

	CString sPrefix = "DMP";
	CString sExtension = "tmp";
	if(FAILED(CWaveDataManager::CreateUniqueTempFile(sPrefix, sExtension, m_sTempFileName)))
	{
		GetTempFileName(szTempPath, sPrefix, 0, szTempFileName);
		m_sTempFileName = szTempFileName;
	}

    m_bSrcInATempFile = TRUE;

	IStream* pIFileStream = NULL;
	if(FAILED(AllocStreamToFile(&pIFileStream, m_sTempFileName, 0)))
	{
		return E_FAIL;
	}

	CWaveNode* pSourceWaveNode = dynamic_cast<CWaveNode*>(pIDocRootNode);

	// This could be a wave in the collection
	if(pSourceWaveNode == NULL)
	{
		CCollection* pCollectionNode = dynamic_cast<CCollection*>(pIDocRootNode);
		ASSERT(pCollectionNode);
		if(pCollectionNode == NULL)
		{
			pIFileStream->Release();
			return E_FAIL;
		}

		if(FAILED(pCollectionNode->FindWaveNodeByGUID(guidNode, &pSourceWaveNode)))
		{
			pIFileStream->Release();
			return E_FAIL;
		}
	}

	ASSERT(pSourceWaveNode);
	if(pSourceWaveNode == NULL)
	{
		pIFileStream->Release();
		return E_FAIL;
	}

    // Ask the source wave to update it's uncompressed deltas
	if(FAILED(pSourceWaveNode->SaveAs(pIFileStream, false)))
	{
		pIFileStream->Release();
		return E_FAIL;
	}

	pIDocRootNode->Release();
	pIFileStream->Release();

	CString sOldName = m_sFileName;
	SetFileName(m_sTempFileName);

	// Now get a read stream from this file and load the wave
	if(FAILED(AllocStreamFromFile(&pIFileStream, m_sTempFileName, 0)))
	{
		DeleteFile(m_sTempFileName);
		m_sTempFileName = "";
		return E_FAIL;
	}

	if(FAILED(Load(pIFileStream)))
	{
		pIFileStream->Release();
		return E_FAIL;
	}

	if(IsInACollection())
	{
		SetPreviousRegionLinkIDs(pSourceWaveNode);
	}

	// Done with this stream
	pIFileStream->Release();

	// Remember that we're pasting waves
	m_bPastingWave = true;

	// Reset the correct name
	SetFileName(sOldName);

	return S_OK;
}


BOOL CWaveNode::IsSourceInTempFile()
{
    return m_bSrcInATempFile;
}

void CWaveNode::SetSourceInTempFile(BOOL bSourceInTempFile)
{
    m_bSrcInATempFile = bSourceInTempFile;
}


HRESULT CWaveNode::Load(IDMUSProdRIFFStream* pIRiffStream, MMCKINFO* pckMain)
{
	ASSERT(pIRiffStream);
	if(pIRiffStream == NULL)
		return E_POINTER;

	bool bLoadingStereo = false;
	bool bTrueStereo = false;
	bool bRightChannel = false;
	GUID guidStereoWave;
	::CoCreateGuid(&guidStereoWave);
	
	GUID guidTemp;
	CopyGUID(guidStereoWave, guidTemp);
	
	if(SUCCEEDED(IsLoadingStereoWave(pIRiffStream, pckMain, bLoadingStereo, bTrueStereo, guidStereoWave, bRightChannel)))
	{
		if(bLoadingStereo)
		{
			// If there's no GUID saved we know that it's a brand new TRUE Stereo Wave
			//BOOL bTrueStereo = ::IsEqualGUID(guidTemp, guidStereoWave);

			if(m_pWave && m_bStereo == false)
			{
				return E_FAIL;
			}
			
			if(m_pWave == NULL)
			{
				m_pWave = new CStereoWave(this, bTrueStereo);
				m_bStereo = true;
			}

			if(bTrueStereo)
			{
				if(FAILED(m_pWave->Load(pIRiffStream, pckMain)))
				{
					delete m_pWave;
					m_pWave = NULL;
					return E_FAIL;
				}
			}
			else
			{
				((CStereoWave*)m_pWave)->SetGUID(guidStereoWave);
				if(FAILED(((CStereoWave*)m_pWave)->Load(pIRiffStream, pckMain, bRightChannel)))
				{
					delete m_pWave;
					m_pWave = NULL;
					return E_FAIL;
				}
			}
		}
		else
		{
			if(m_pWave && m_bStereo == true)
			{
				return E_FAIL;
			}
			else if(m_pWave == NULL)
			{
				m_pWave = new CMonoWave(this);
				m_bStereo = false;
			}

			if(FAILED(m_pWave->Load(pIRiffStream, pckMain)))
			{
				delete m_pWave;
				m_pWave = NULL;
				return E_FAIL;
			}

		}
	}
	else
	{
		return E_FAIL;
	}

	ClearDirtyFlag();

	return S_OK;
}


///////////////////////////////////////////////////////////////////////////
//
// Creates a DirectSoundWave object
//
//////////////////////////////////////////////////////////////////////////
HRESULT CWaveNode::CreateDirectSoundWave()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	
	HRESULT hr = E_FAIL;

	// Create a DirectSoundWave object only when NOT in a collection
	if(m_pIDirectSoundWave == NULL && m_bInCollection == false)
	{
		if(SUCCEEDED(hr = ::CoCreateInstance(CLSID_DirectSoundWave, NULL, CLSCTX_INPROC, IID_IDirectSoundWave, (void**)&m_pIDirectSoundWave)))
		{
			IDirectMusicObject* pIDirectMusicObject = NULL;
			if(SUCCEEDED(hr = m_pIDirectSoundWave->QueryInterface(IID_IDirectMusicObject, (void**)&pIDirectMusicObject)))
			{
				if(m_pDirectSoundWaveStream == NULL)
				{
					m_pDirectSoundWaveStream = new CWaveStream(m_pWave);
				}

				if(m_pDirectSoundWaveStream)
				{
					// Persist the wave into the stream
					DMUS_OBJECTDESC objDesc;
					ZeroMemory(&objDesc, sizeof(DMUS_OBJECTDESC));

					objDesc.dwSize = sizeof(DMUS_OBJECTDESC);
					objDesc.dwValidData = DMUS_OBJ_STREAM;
					objDesc.pStream = m_pDirectSoundWaveStream;

					pIDirectMusicObject->SetDescriptor(&objDesc);

					IPersistStream* pIPersistStream;
					if(SUCCEEDED(hr = m_pIDirectSoundWave->QueryInterface(IID_IPersistStream, (void **)&pIPersistStream )))
					{
						StreamSeek(m_pDirectSoundWaveStream, 0, STREAM_SEEK_SET);
						hr = pIPersistStream->Load(m_pDirectSoundWaveStream);

						RELEASE(pIPersistStream);
					}
				}

				pIDirectMusicObject->Release();
			}
		}
	}

	// Cleanup if we failed
	if(FAILED(hr))
	{
		if(m_pDirectSoundWaveStream)
		{
			m_pDirectSoundWaveStream->Release();
			m_pDirectSoundWaveStream= NULL;
		}
		if(m_pIDirectSoundWave)
		{
			m_pIDirectSoundWave->Release();
			m_pIDirectSoundWave = NULL;
		}
	}

	return hr;
}


HRESULT	CWaveNode::ReloadDirectSoundWave()
{
	HRESULT hr = E_FAIL;
	if(m_pIDirectSoundWave)
	{
		// Do a reload on the wave
		IPersistStream* pIPersistStream = NULL;
		if(SUCCEEDED(hr = m_pIDirectSoundWave->QueryInterface(IID_IPersistStream, (void **)&pIPersistStream)))
		{
			StreamSeek(m_pDirectSoundWaveStream, 0, STREAM_SEEK_SET);
			hr = pIPersistStream->Load(m_pDirectSoundWaveStream);

			RELEASE(pIPersistStream);
		}
	}

	return hr;
}


/////////////////////////////////////////////////////////////////////////////
//
// CWaveNode IPersistStream::Save
//
//////////////////////////////////////////////////////////////////////
HRESULT CWaveNode::Save(IStream* pIStream, BOOL fClearDirty)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
    ASSERT(pIStream);
	if(pIStream == NULL)
		return E_POINTER;

	ASSERT(m_pWave);
	if(m_pWave == NULL)
		return E_FAIL;

	return m_pWave->Save(pIStream, fClearDirty);
}

HRESULT CWaveNode::SaveAs(IStream* pIStream, bool bPromptForFileName)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
    ASSERT(pIStream);
	if(pIStream == NULL)
		return E_POINTER;

	ASSERT(m_pWave);
	if(m_pWave == NULL)
		return E_FAIL;

	return m_pWave->SaveAs(pIStream, bPromptForFileName);
}


// =================================================================================
//
// IDMUSProdTransport methods
//
// =================================================================================


UINT AFX_CDECL WaveStopResetFunction(LPVOID pParam)
{
	WaveStopResetTimeEvent* resetTimeEvent = (WaveStopResetTimeEvent*) pParam;
	WaitForSingleObject(resetTimeEvent->pWaveNode->m_hStopEvent, resetTimeEvent->lWaitTime);

	resetTimeEvent->pWaveNode->Stop( TRUE );
	TRACE("Killing update thread\n");
	::AfxEndThread(0);

	return 0;
}


HRESULT CWaveNode::Play(BOOL /*fPlayFromStart*/)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	ResetEvent(m_hStopEvent);

	// Return failure if we don't have a valid port to play the wave
	if(m_pComponent->m_lstDLSPortDownload.IsEmpty())
	{
		AfxMessageBox(IDS_ERR_NO_PORT, MB_OK | MB_ICONEXCLAMATION);
		return E_FAIL;
	}

	if(m_pWave)
	{
		if(SUCCEEDED(m_pWave->Play(TRUE)))
		{
			// Setup a timer so we can keep track of playback
			if (m_pWaveCtrl && m_bTrackTimeCursor ) 
			{
				// tell the wave control playing has begun
				m_pWaveCtrl->PreparePlaybackTimer();
			}
			else if(m_pWave->IsLooped() == false)
			{
				m_ResetCallBackParams.lWaitTime = (long) ((DWORD)1000*((float)m_pWave->GetWaveLength() / m_pWave->m_rWaveformat.nSamplesPerSec));
				m_ResetCallBackParams.pWaveNode = this;

				CWinThread* pUpdateThread = ::AfxBeginThread(WaveStopResetFunction, &m_ResetCallBackParams);
				pUpdateThread->m_bAutoDelete = TRUE;

			}
					
			m_pComponent->m_pIConductor->SetBtnStates(this, BS_PLAY_CHECKED | BS_STOP_ENABLED  | BS_NO_AUTO_UPDATE);


			return S_OK;
		}
	}

	return E_FAIL;
}

HRESULT CWaveNode::Stop( BOOL /*fStopImmediate*/ )
{
    AFX_MANAGE_STATE(_afxModuleAddrThis);
	ASSERT(m_pWave);
	if(m_pWave == NULL)
	{
		return E_FAIL;
	}

	SetEvent(m_hStopEvent);

	if (m_pWaveCtrl) 
	{
		m_pWaveCtrl->KillPlaybackTimer();
	}

	m_pWave->TurnOffMidiNotes();

    ASSERT(m_pComponent);
	if(m_pComponent == NULL)
	{
		return E_UNEXPECTED;
	}

	// Register with the transport
	IDMUSProdConductor* pIConductor = m_pComponent->m_pIConductor;
	ASSERT(pIConductor);
	if(pIConductor)
	{
        pIConductor->TransportStopped(this);
    }

    return S_OK;
}

HRESULT CWaveNode::Transition ( )
{
    return E_NOTIMPL;
}

HRESULT CWaveNode::Record( BOOL fPressed )
{
	return E_NOTIMPL;
}

HRESULT CWaveNode::GetName(BSTR* pbstrName)
{
	if(m_pWave == NULL)
		return E_FAIL;
	
	*pbstrName = m_pWave->GetName().AllocSysString();
	return S_OK;
}

HRESULT CWaveNode::TrackCursor( BOOL fTrackCursor )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	m_bTrackTimeCursor = (fTrackCursor != 0);

	if( m_pWaveCtrl && m_pWave->WaveIsPlaying())
	{
		if( fTrackCursor )
		{
			// tell the wave control to start the cursor
			m_pWaveCtrl->PreparePlaybackTimer();
		}
		else
		{
			// tell the wave control to stop the cursor
			m_pWaveCtrl->KillPlaybackTimer();
		}
	}

	return S_OK;
}

//==================================================================
//
//	IDMUSProdWaveTimelineDraw methods
//
//==================================================================
HRESULT CWaveNode::DrawWave(IDMUSProdTimeline* pITimeline, HDC hDC, const CRect& rcClient, const long lScrollOffset, const WaveDrawParams* pWaveDrawParams, const WaveTimelineInfoParams* pWaveInfoParams)
{
	ASSERT(m_pWave);
	if(m_pWave == NULL)
	{
		return E_FAIL;
	}

	ASSERT(pITimeline);
	if(pITimeline == NULL)
	{
		return E_POINTER;
	}

	// Can't draw on a 0 width rect?
	ASSERT(rcClient.Width());
	if(rcClient.Width() <= 0)
	{
		return E_INVALIDARG;
	}


	ASSERT(pWaveDrawParams);
	if(pWaveDrawParams == NULL)
	{
		return E_POINTER;
	}

	ASSERT(pWaveInfoParams);
	if(pWaveInfoParams == NULL)
	{
		return E_POINTER;
	}

	if(pWaveDrawParams->cbSize < sizeof(WaveDrawParams))
	{
		return E_INVALIDARG;
	}

	if(pWaveInfoParams->cbSize < sizeof(WaveTimelineInfoParams))
	{
		return E_INVALIDARG;
	}

	// Collect the list of tempo changes between start time and end time
	CPtrList lstTempoChanges;
	DWORD dwGroupBits = pWaveInfoParams->dwGroupBits;
	REFERENCE_TIME rtOffset = pWaveInfoParams->rtOffset;
	REFERENCE_TIME rtStart = pWaveInfoParams->rtStart + rtOffset;
	REFERENCE_TIME rtEnd = rtStart + pWaveInfoParams->rtDuration;
	
	// Get the start and end in MUSIC_TIME units
	MUSIC_TIME mtStart = 0;
	if(FAILED(pITimeline->RefTimeToClocks(pWaveInfoParams->rtStart, &mtStart)))
	{
		return E_FAIL;
	}

	MUSIC_TIME mtEnd = 0;
	if(FAILED(pITimeline->RefTimeToClocks(rtEnd, &mtEnd)))
	{
		return E_FAIL;
	}

	// Get a CDC object from the hDC
	CDC dcClient;
	if(dcClient.Attach(hDC) == 0)
	{
		return E_FAIL;
	}

	// Collect the tempos now
	while(mtStart < mtEnd)
	{
		HRESULT hr = E_FAIL;
		DMUS_TEMPO_PARAM tempo;
		MUSIC_TIME mtNext = 0;
		if(SUCCEEDED(hr = pITimeline->GetParam(GUID_TempoParam, dwGroupBits, 0, mtStart, &mtNext, &tempo)))
		{
			REFERENCE_TIME rtTempoStart = 0;
			REFERENCE_TIME rtTempoEnd = 0;
			if(SUCCEEDED(hr = pITimeline->ClocksToRefTime(tempo.mtTime, &rtTempoStart)))
			{
				mtNext += mtStart;
				if(SUCCEEDED(hr = pITimeline->ClocksToRefTime((mtNext - 1), &rtTempoEnd)))
				{
					TempoChange* pTempoChange = new TempoChange;
					pTempoChange->rtTempoStart = rtTempoStart;
					pTempoChange->rtTempoEnd = rtTempoEnd;
					
					// The next tempo could be 0 in case of a default tempo or it wraps around
					if(mtNext == 0 || mtNext <= mtStart || rtTempoEnd > rtEnd)
					{
						if(pTempoChange->rtTempoStart < pWaveInfoParams->rtStart)
						{
							pTempoChange->rtTempoStart = pWaveInfoParams->rtStart;
						}

						pTempoChange->rtTempoEnd = rtEnd;
					}
					pTempoChange->dblTempo = tempo.dblTempo;
					lstTempoChanges.AddTail(pTempoChange);
					
					if(mtNext == 0 || mtNext <= mtStart)
					{
						break;
					}

					mtStart = mtNext;
				}
			}
		}

		// Delete the list if we failed
		if(FAILED(hr))
		{
			while(!lstTempoChanges.IsEmpty())
			{
				delete lstTempoChanges.RemoveHead();
				dcClient.Detach();
			}
			return E_FAIL;
		}
	}

	
	WAVEFORMATEX waveFormat = m_pWave->m_rWaveformat;
	DWORD dwSampleRate = waveFormat.nSamplesPerSec;
	if(FAILED(GetFineTunedSampleRate(pWaveInfoParams->lPitch, dwSampleRate)))
	{
		return E_FAIL;
	}

	DWORD dwWaveLength = m_pWave->GetWaveLength();

	if(rtOffset > 0)
	{
		// Draw the clipped boundaries for the wave...if we're clipped that is
		COLORREF clrClip = pWaveDrawParams->clrClipMarker;
		CPen clipMarker(PS_DOT, 0, clrClip);
		CPen* pOldPen = dcClient.SelectObject(&clipMarker);
		dcClient.MoveTo(rcClient.left, rcClient.top);
		dcClient.LineTo(rcClient.left, rcClient.bottom);
		dcClient.SelectObject(pOldPen);
	}
	else
	{
		// Mark the start of the wave
		COLORREF clrStart = pWaveDrawParams->clrStartMarker;
		CPen startPen(PS_SOLID, 0, clrStart);
		CPen* pOldPen = dcClient.SelectObject(&startPen);
		dcClient.MoveTo(rcClient.left, rcClient.top);
		dcClient.LineTo(rcClient.left, rcClient.bottom);
		dcClient.SelectObject(pOldPen);
	}

	// The first sample is at the offset from the start
	DWORD dwLastSampleDrawn = (DWORD)((((double)(rtOffset)/10000)/1000) * dwSampleRate);

	DWORD dwPlayLength = (DWORD)((((double)(pWaveInfoParams->rtDuration) / 10000) / 1000) * dwSampleRate);

	// The end sample is at rtDuration from the start sample
	DWORD dwEndSample = dwLastSampleDrawn + dwPlayLength;
	if(dwEndSample < (dwWaveLength - 1))
	{
		// Draw the clipped boundaries for the wave...if we're clipped that is
		COLORREF clrClip = pWaveDrawParams->clrClipMarker;
		CPen clipMarker(PS_DOT, 0, clrClip);
		CPen* pOldPen = dcClient.SelectObject(&clipMarker);
		dcClient.MoveTo(rcClient.right, rcClient.top);
		dcClient.LineTo(rcClient.right, rcClient.bottom);
		dcClient.SelectObject(pOldPen);
	}
	else
	{
		// Mark the end of the wave
		COLORREF clrEnd = pWaveDrawParams->clrEndMarker;
		CPen endPen(PS_SOLID, 0, clrEnd);
		CPen* pOldPen = dcClient.SelectObject(&endPen);
		dcClient.MoveTo(rcClient.right, rcClient.top);
		dcClient.LineTo(rcClient.right, rcClient.bottom);
		dcClient.SelectObject(pOldPen);
	}

	// Collect the error in every draw call..these are the samples not drawn due to 
	// the precision error in fSamplesPerPixel
	int nError = 0;

	// get clip rectangle
	CRect rcClip;
	::GetClipBox(hDC, &rcClip);
	REFERENCE_TIME rtClip;

	POSITION position = lstTempoChanges.GetHeadPosition();
	while(position)
	{
		TempoChange* pTempoChange = (TempoChange*) lstTempoChanges.GetNext(position);
		ASSERT(pTempoChange);
		if(pTempoChange)
		{
			// Get the samples per beat
			double dblBeatsPerSecond = pTempoChange->dblTempo / 60;
			double dblSamplesPerBeat = dwSampleRate / dblBeatsPerSecond;

			REFERENCE_TIME rtRectStart = pWaveInfoParams->rtStart;

			// Calculate how many samples we have to draw at this tempo 
			REFERENCE_TIME rtDrawStart = rtStart;
			rtDrawStart = (pTempoChange->rtTempoStart + rtOffset) > rtDrawStart ? (pTempoChange->rtTempoStart + rtOffset) : rtStart;
			rtRectStart = pTempoChange->rtTempoStart > rtRectStart ? pTempoChange->rtTempoStart : rtRectStart;
			// note that we could clip rtDrawStart to rcClip.left for speed... but then we'd have to change dwLastSampleDrawn too

			// end of draw
			REFERENCE_TIME rtDrawEnd;
			rtDrawEnd = rtEnd > (pTempoChange->rtTempoEnd + rtOffset) ? (pTempoChange->rtTempoEnd + rtOffset) : rtEnd;
			rtClip = 0;
			if (SUCCEEDED(pITimeline->PositionToRefTime(rcClip.right - (-lScrollOffset+1), &rtClip)))
				if (rtDrawEnd > rtClip+rtOffset)
					rtDrawEnd = rtClip+rtOffset;

			// Drawing duration in seconds
			double dblDrawDuration = ((double)(rtDrawEnd - rtDrawStart) / 10000) / 1000; 

			// Number of samples that are in this drawing duration
			double dblBeatsInChange = dblDrawDuration * dblBeatsPerSecond;
			double dblSamplesInChange = dblBeatsInChange * dblSamplesPerBeat;
			DWORD dwSamplesInChange = (DWORD)(dblSamplesInChange) + nError;
			
			// Get the samples per pixel and the clipped rect for drawing the wave
			CRect rcDraw = rcClient;
			long lStartPos = 0;
			if(SUCCEEDED(pITimeline->RefTimeToPosition(rtRectStart, &lStartPos)))
			{
				long lEndPos = 0;
				if(SUCCEEDED(pITimeline->RefTimeToPosition((rtDrawEnd - rtOffset), &lEndPos)))
				{
					lStartPos += -lScrollOffset + 1;
					lEndPos += -lScrollOffset + 1;
					rcDraw.left = lStartPos <= rcClient.left ? rcClient.left : lStartPos;
					rcDraw.right = lEndPos >= rcClient.right ? rcClient.right : lEndPos;
				}
			}

			//  Actually sample units per pixel
			float fSamplesPerPixel =  (((float)dwSamplesInChange / DRAW_UNIT_SIZE) / rcDraw.Width());

			//  Determine offset into wave (first sample to draw)
			if(	pWaveInfoParams->dwFlags & WAVE_LOOPED
			&&  dwLastSampleDrawn >= dwWaveLength )
			{
				DWORD dwLoopLength = pWaveInfoParams->dwLoopEnd - pWaveInfoParams->dwLoopStart;
				if( dwLoopLength )
				{
					dwLastSampleDrawn -= pWaveInfoParams->dwLoopStart;
					dwLastSampleDrawn  = dwLastSampleDrawn % dwLoopLength;
					dwLastSampleDrawn += pWaveInfoParams->dwLoopStart;
				}
			}

			DWORD dwTemp = dwLastSampleDrawn;
			
			EnterCriticalSection(&m_CriticalSection);
			m_pWave->OnDraw(&dcClient, rcDraw, lScrollOffset, dwLastSampleDrawn, dwSamplesInChange, fSamplesPerPixel, pWaveDrawParams, pWaveInfoParams);
			LeaveCriticalSection(&m_CriticalSection);

			// Update the error for the next draw
			dwLastSampleDrawn = dwTemp + dwSamplesInChange;
			//nError = (dwTemp + dwSamplesInChange) - dwLastSampleDrawn;
		}
	}

	// Detach the hDC
	dcClient.Detach();

	// Delete the tempo change list
	while(!lstTempoChanges.IsEmpty())
	{
		delete lstTempoChanges.RemoveHead();
	}

	return S_OK;	
}

HRESULT CWaveNode::GetWaveInfo(WaveInfoParams* pWaveInfoParams)
{
	ASSERT(m_pWave);
	if(m_pWave == NULL)
	{
		return E_FAIL;
	}

	ASSERT(pWaveInfoParams);
	if(pWaveInfoParams == NULL)
	{
		return E_POINTER;
	}

	ASSERT(pWaveInfoParams->cbSize == sizeof(WaveInfoParams));
	if(pWaveInfoParams->cbSize != sizeof(WaveInfoParams))
	{
		return E_INVALIDARG;
	}
	
	pWaveInfoParams->dwWaveDuration = m_pWave->GetWaveLength();

	WAVEFORMATEX waveFormat = m_pWave->m_rWaveformat;

	// Get the duration in REFERENCE_TIME
	double dblWaveLength = (double) m_pWave->GetWaveLength();
	double dblWaveDuration = dblWaveLength / waveFormat.nSamplesPerSec;
	REFERENCE_TIME rtDuration = (__int64)((dblWaveDuration * 10000) * 1000);		// Converts to 100 nanoseconds intervals

	// Set the loop information;
	pWaveInfoParams->dwFlags = 0;
	if(m_pWave->IsLooped())
	{
		pWaveInfoParams->dwFlags |= WAVE_LOOPED;
	}

	RLOOP rloop = m_pWave->GetRLOOP();
	pWaveInfoParams->dwLoopType = rloop.dwType;
	
	pWaveInfoParams->dwLoopStart = rloop.dwStart;
	pWaveInfoParams->dwLoopEnd = rloop.dwEnd;

	if(m_pWave->IsStreamingWave())
	{
		pWaveInfoParams->dwFlags |= WAVE_STREAMING;
	}
	
	double dblLoopStartTime = ((double)rloop.dwStart / waveFormat.nSamplesPerSec);
	double dblLoopEndTime = ((double)rloop.dwEnd / waveFormat.nSamplesPerSec);

	pWaveInfoParams->guidVersion = m_guidVersion;

	return S_OK;
}


HRESULT CWaveNode::SampleToRefTime(DWORD dwSample, REFERENCE_TIME* prtSampleTime, LONG lFineTuneCents)
{
	ASSERT(prtSampleTime);
	if(prtSampleTime == NULL)
	{
		return E_POINTER;
	}

	ASSERT(m_pWave);
	if(m_pWave == NULL)
	{
		return E_FAIL;
	}

	if(dwSample > m_pWave->GetWaveLength())
	{
		return E_FAIL;
	}
	

	WAVEFORMATEX waveFormat = m_pWave->m_rWaveformat;
	DWORD dwTunedSampleRate = waveFormat.nSamplesPerSec;
	if(FAILED(GetFineTunedSampleRate(lFineTuneCents, dwTunedSampleRate)))
	{
		return E_FAIL;
	}

	double dblSampleTime =  ((double)dwSample / dwTunedSampleRate);
	*prtSampleTime = (__int64)(((dblSampleTime * 10000) + 0.5) * 1000);

	return S_OK;
}


HRESULT CWaveNode::RefTimeToSample(REFERENCE_TIME rtSampleTime, DWORD* pdwSample, LONG lFineTuneCents)
{
	ASSERT(pdwSample);
	if(pdwSample == NULL)
	{
		return E_POINTER;
	}

	ASSERT(m_pWave);
	if(m_pWave == NULL)
	{
		return E_FAIL;
	}

	WAVEFORMATEX waveFormat = m_pWave->m_rWaveformat;
	DWORD dwTunedSampleRate = waveFormat.nSamplesPerSec;
	if(FAILED(GetFineTunedSampleRate(lFineTuneCents, dwTunedSampleRate)))
	{
		return E_FAIL;
	}

	double dblSampleTime = ((double)rtSampleTime / 10000) / 1000;
	*pdwSample = (DWORD)((dblSampleTime * dwTunedSampleRate) + 0.5);

	return S_OK;
}


HRESULT CWaveNode::GetFineTunedSampleRate(long lFineTuneCents, DWORD& dwTunedSampleRate)
{
	ASSERT(m_pWave);
	if(m_pWave == NULL)
	{
		return E_UNEXPECTED;
	}

	WAVEFORMATEX waveFormat = m_pWave->m_rWaveformat;

	// 1.059463094359 is 12th root of 2; 0.9438743126817 is 1/12th root of 2
	// If the pitch is shifted up then we have to divide by 12th root of 2
	// If the pitch is shifted down then we have to divide by 12th root of 2

	bool bPositiveTune = lFineTuneCents > 0 ? true : false;
	float fTimeShiftFactor = (float)(bPositiveTune ? 1.0005777895065548592967925757932 : 0.99942254414138074953252875691576);

	double dblTunedSampleRate = waveFormat.nSamplesPerSec;
	for(long lTuneCent = 0; lTuneCent < abs(lFineTuneCents); lTuneCent++)
	{
		dblTunedSampleRate *= fTimeShiftFactor;
	}

    dwTunedSampleRate = (DWORD)(dblTunedSampleRate + 0.5);

	return S_OK;
}


//==================================================================
//
//	Helper Methods
//
//==================================================================

CWave* CWaveNode::GetWave() const 
{
	return m_pWave;
}


CDLSComponent* CWaveNode::GetComponent() const 
{
	// We should always have a valid component right?
	ASSERT(m_pComponent);

	if(m_pComponent)
	{
		return m_pComponent;
	}

	return NULL;
}

void CWaveNode::SetCollection(CCollection* pCollection)
{
	ASSERT(m_pWave);
	if(m_pWave == NULL)
	{
		return;
	}

	m_bInCollection = false;
	if(pCollection)
	{
		m_bInCollection = true;
	}
	
	// We don't check for the pointer as we might want to set it to NULL
	m_pWave->SetCollection(pCollection);
}

// This can get called from the compression manager callbacks at the wave construction time
// At this time the node will have no wave but we don't want to see any asserts either.....
CCollection* CWaveNode::GetCollection() const
{
	if(m_pWave == NULL)
	{
		return NULL;
	}

	return m_pWave->GetCollection();
}

CWaveCtrl* CWaveNode::GetWaveEditor() const 
{
	return m_pWaveCtrl;
}

void CWaveNode::SetWaveEditor(CWaveCtrl* pWaveCtrl)
{
	// We don't check for NULL pointer since we might intentionally set it NULL
	m_pWaveCtrl = pWaveCtrl;
}

bool CWaveNode::ConfirmWaveDelete()
{
    AFX_MANAGE_STATE(_afxModuleAddrThis);
	ASSERT(m_pWave);
	if(m_pWave == NULL)
	{
		return false;
	}

	CString					csReferPrompt, csDeletePrompt, csDeleteTitle, csConfirmPrompt;
	CString					csInstName;
	IDMUSProdNode*			pIRef;
	BSTR					bsInstName;
	int						iResponse;
	int						iInstrNameBufferLength;

	csConfirmPrompt.LoadString(IDS_WAVE_DELETE_CONFIRM);	//"Are you sure you want to delete this wave?"
	csDeleteTitle.LoadString(IDS_WAVE_DELETE_CONFIRM_TITLE);//Title for message box

	CCollection* pCollection = m_pWave->GetCollection();

	if(pCollection && pCollection->IsWaveReferenced(m_pWave, &pIRef) )
	{
		pIRef->GetNodeName(&bsInstName);
		
		// Calculate the buffer length required to convert from BSTR
		iInstrNameBufferLength = WideCharToMultiByte(CP_ACP,0,bsInstName,-1,NULL,0,NULL,NULL);
		
		// Do actual conversion
		WideCharToMultiByte(CP_ACP,0,bsInstName,-1,csInstName.GetBuffer(iInstrNameBufferLength),iInstrNameBufferLength,NULL,NULL);
		csInstName.ReleaseBuffer(-1);
		
		CString sWaveName = m_pWave->GetName();
		csReferPrompt.Format(IDS_WAVE_REFERENCE_PROMPT,sWaveName.GetBuffer(0),csInstName.GetBuffer(0));
		sWaveName.ReleaseBuffer();
		csDeletePrompt = csReferPrompt+csConfirmPrompt;
	}
	else
	{
		csDeletePrompt = csConfirmPrompt;
	}
	
	iResponse = AfxMessageBox(csDeletePrompt, MB_YESNO|MB_ICONWARNING);
	if ( iResponse == IDNO)
	{
		return false;
	}
	else
	{
		return true;
	}
}



HRESULT CWaveNode::OnViewProperties()
{

	ASSERT(m_pComponent->m_pIFramework != NULL );

	HRESULT hr = E_FAIL;

	IDMUSProdPropSheet* pIPropSheet;

	if( SUCCEEDED ( m_pComponent->m_pIFramework->QueryInterface( IID_IDMUSProdPropSheet, (void**)&pIPropSheet ) ) )
	{
		if( pIPropSheet->IsShowing() == S_OK )
		{
			IDMUSProdPropPageObject* pIPageObject;

			if( SUCCEEDED ( this->QueryInterface( IID_IDMUSProdPropPageObject, (void **)&pIPageObject ) ) )
			{
				if( SUCCEEDED ( pIPageObject->OnShowProperties() ) )
				{
					hr = S_OK;
				}

				pIPageObject->Release();
			}
		}
		else
		{
			hr = S_OK;
		}

		pIPropSheet->Release();
	}

	return hr;
}

void CWaveNode::RefreshPropertyPage()
{
	ASSERT(m_pWave);
	if(m_pWave == NULL)
	{
		return;
	}

	m_pWave->RefreshPropertyPage();
}


HRESULT CWaveNode::InitAndDownload()
{
	ASSERT(m_pComponent);
	if(m_pComponent == NULL)
	{
		return E_FAIL;
	}

	// No ports to download to?
	if(m_pComponent->m_lstDLSPortDownload.IsEmpty())
	{
		return E_FAIL;
	}

	ASSERT(m_pWave);
	if(m_pWave == NULL)
	{
		return E_UNEXPECTED;
	}

	HRESULT	hr = S_OK;

	// Download the wave to all the ports
	POSITION position = m_pComponent->m_lstDLSPortDownload.GetHeadPosition();
	while(position)
	{
		IDirectMusicPortDownload* pIDMPortDownload = m_pComponent->m_lstDLSPortDownload.GetNext(position);
		ASSERT(pIDMPortDownload);

		hr = DM_Init(pIDMPortDownload);
		if(SUCCEEDED(hr))
		{
			hr = Download(pIDMPortDownload);
			if(!SUCCEEDED(hr))
			{
				if(hr & (DMUS_E_INSUFFICIENTBUFFER | DMUS_E_BUFFERNOTSET | DMUS_E_BUFFERNOTAVAILABLE))
				{
					// ashtat - BUGBUG! Need a better message...see Manbugs : 33331
					AfxMessageBox(IDS_ERR_DOWNLOAD_DLS_CONFIG);
				}
				AfxMessageBox(IDS_ERR_INIT_DOWNLOAD,MB_OK | MB_ICONEXCLAMATION);
			}
		}
		else if(hr & E_OUTOFMEMORY)
		{
			AfxMessageBox(IDS_ERR_WAVE_DOWNLOAD_FAILED, MB_OK | MB_ICONEXCLAMATION);
		}
	}

	return hr;
}

HRESULT CWaveNode::DownloadToAllPorts()
{
	ASSERT(m_pComponent);
	if(m_pComponent == NULL)
	{
		return E_FAIL;
	}

	// No ports to download to?
	if(m_pComponent->m_lstDLSPortDownload.IsEmpty())
	{
		return E_FAIL;
	}

	HRESULT	hr = S_OK;

	// Download the wave to all the ports
	POSITION position = m_pComponent->m_lstDLSPortDownload.GetHeadPosition();
	while(position)
	{
		IDirectMusicPortDownload* pIDMPortDownload = m_pComponent->m_lstDLSPortDownload.GetNext(position);
		ASSERT(pIDMPortDownload);
		if(pIDMPortDownload)
		{
			Download(pIDMPortDownload);
		}
	}

	return S_OK;
}

HRESULT CWaveNode::UnloadFromAllPorts()
{
	ASSERT(m_pComponent);
	if(m_pComponent == NULL)
	{
		return E_FAIL;
	}

	// No ports to download to?
	if(m_pComponent->m_lstDLSPortDownload.IsEmpty())
	{
		return E_FAIL;
	}

	HRESULT	hr = S_OK;

	// Download the wave to all the ports
	POSITION position = m_pComponent->m_lstDLSPortDownload.GetHeadPosition();
	while(position)
	{
		IDirectMusicPortDownload* pIDMPortDownload = m_pComponent->m_lstDLSPortDownload.GetNext(position);
		ASSERT(pIDMPortDownload);
		if(pIDMPortDownload)
		{
			Unload(pIDMPortDownload);
		}
	}

	return S_OK;
}


HRESULT	CWaveNode::DM_Init(IDirectMusicPortDownload* pIDMPortDownLoad)
{
	ASSERT(pIDMPortDownLoad);
	if(pIDMPortDownLoad == NULL)
		return E_POINTER;

	ASSERT(m_pWave);
	if(m_pWave == NULL)
		return E_POINTER;

	if(SUCCEEDED(m_pWave->DM_Init(pIDMPortDownLoad)))
		return S_OK;

	return E_FAIL;
}

HRESULT CWaveNode::Download(IDirectMusicPortDownload* pIDMPortDownLoad)
{
	ASSERT(pIDMPortDownLoad);
	if(pIDMPortDownLoad == NULL)
		return E_POINTER;

	ASSERT(m_pWave);
	if(m_pWave == NULL)
		return E_POINTER;

	// Okay to not download if the preference is set that way
	if(m_pComponent->IsAutoDownloadOkay() == FALSE)
	{
		return S_OK;
	}

	if(SUCCEEDED(m_pWave->Download(pIDMPortDownLoad)))
		return S_OK;

	return E_FAIL;
}

HRESULT	CWaveNode::Unload(IDirectMusicPortDownload* pIDMPortDownLoad)
{
	ASSERT(pIDMPortDownLoad);
	if(pIDMPortDownLoad == NULL)
		return E_POINTER;

	ASSERT(m_pWave);
	if(m_pWave == NULL)
		return E_POINTER;

	if(SUCCEEDED(m_pWave->Unload(pIDMPortDownLoad)))
		return S_OK;

	return E_FAIL;
}


HRESULT CWaveNode::IsLoadingStereoWave(IDMUSProdRIFFStream* pIRiffStream, MMCKINFO* pckMain, bool& bStereo, bool& bTrueStereo, GUID& guidStereoWave, bool& bRightChannel)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT(pIRiffStream);
	if(pIRiffStream == NULL)
		return E_POINTER;

	IStream* pIStream = pIRiffStream->GetStream();
	ASSERT(pIStream);

	// Remember where the stream pointer is positioned
	DWORD dwStreamPosition = StreamTell(pIStream);

	HRESULT hr = E_FAIL;
	DWORD cSize = 0;
	MMCKINFO ck;
	ck.ckid = mmioFOURCC('w','v','s','t');
	if(pIRiffStream->Descend(&ck, pckMain, MMIO_FINDCHUNK) == 0) 
	{
		DWORD cb = 0;
		bStereo = true;
		bTrueStereo = false;

		bRightChannel = false;
		
		hr = pIStream->Read(&bRightChannel, sizeof(bool), &cb);
		if(FAILED(hr) || cb != sizeof(bool))
		{
			pIStream->Release();
			pIRiffStream->Ascend(&ck, 0);
			return E_FAIL;
		}
		
		hr = pIStream->Read(&guidStereoWave, sizeof(GUID), &cb);
		if(FAILED(hr) || cb != sizeof(GUID))
		{
			pIStream->Release();
			pIRiffStream->Ascend(&ck, 0);
			return E_FAIL;
		}
	}
	else
	{
		ck.ckid = mmioFOURCC('f','m','t',' ');
		StreamSeek(pIStream, dwStreamPosition, STREAM_SEEK_SET);
		if(pIRiffStream->Descend(&ck, pckMain, MMIO_FINDCHUNK) == 0)
		{
			WAVEFORMATEX wfxTemp;
			if(ck.cksize < sizeof(WAVEFORMATEX))
			{
				cSize = ck.cksize;
			}
			else
			{
				cSize = sizeof(WAVEFORMATEX);
			}
			DWORD cb = 0;
			hr = pIStream->Read(&wfxTemp, cSize, &cb);
			if(FAILED(hr) || cb != cSize)
			{
				pIStream->Release();
				pIRiffStream->Ascend(&ck, 0);
				return E_FAIL;
			}

			if (wfxTemp.nChannels > 2)   // we only support mono and stereo files.
			{
				AfxMessageBox(IDS_WAVE_STEREO, MB_ICONEXCLAMATION); 
				pIRiffStream->Ascend(&ck, 0);
				pIStream->Release();
				return E_FAIL;
			}

			if(wfxTemp.nChannels == 2)
			{
				bStereo = true;
				bTrueStereo = true;
			}
			else
			{
				bStereo = false;
				bTrueStereo = false;
			}
		}
	}

	StreamSeek(pIStream, dwStreamPosition, STREAM_SEEK_SET );
	pIStream->Release();

	return hr;
}

bool CWaveNode::IsStereo()
{
	return m_bStereo;
}

bool CWaveNode::IsInACollection()
{
	return m_bInCollection;
}

HRESULT	CWaveNode::GetPlayTimeForTempo(int nTempo, DWORD& dwPlayTime)
{
	ASSERT(m_pWave);
	if(m_pWave == NULL)
		return E_FAIL;

	return m_pWave->GetPlayTimeForTempo(nTempo, dwPlayTime);
}

void CWaveNode::DrawWave(CDC* pDC, const CRect& rcClient)
{
	ASSERT(m_pWave);
	if(m_pWave == NULL)
		return;

	EnterCriticalSection(&m_CriticalSection);
	m_pWave->OnDraw(pDC, rcClient);
	LeaveCriticalSection(&m_CriticalSection);
}

HRESULT CWaveNode::GetObjectDescriptor( void* pObjectDesc )
{
	// Make sure method was passed a valid DMUS_OBJECTDESC pointer
	if( pObjectDesc == NULL ) 
	{
		ASSERT( FALSE );
		return E_POINTER;
	}

	DMUS_OBJECTDESC *pDMObjectDesc = (DMUS_OBJECTDESC *)pObjectDesc;

	if( pDMObjectDesc->dwSize == 0 ) 
	{
		ASSERT( FALSE );
		return E_INVALIDARG;
	}

	// Initialize DMUS_OBJECTDESC structure
	DWORD dwOrigSize = pDMObjectDesc->dwSize;
	memset( pDMObjectDesc, 0, dwOrigSize );
	pDMObjectDesc->dwSize = dwOrigSize;

	if( m_pWave == NULL )
	{
		return E_UNEXPECTED;
	}

	// Set values in DMUS_OBJECTDESC structure
//	pDMObjectDesc->dwValidData = (DMUS_OBJ_OBJECT | DMUS_OBJ_CLASS | DMUS_OBJ_VERSION | DMUS_OBJ_NAME );
	pDMObjectDesc->dwValidData = (DMUS_OBJ_OBJECT | DMUS_OBJ_CLASS | DMUS_OBJ_NAME );
	
	memcpy( &pDMObjectDesc->guidObject, &m_guidFile, sizeof(GUID) );
	memcpy( &pDMObjectDesc->guidClass, &CLSID_DirectSoundWave, sizeof(CLSID) );
//	pDMObjectDesc->vVersion.dwVersionMS = m_pWave->m_Version.dwVersionMS;
//	pDMObjectDesc->vVersion.dwVersionLS = m_pWave->m_Version.dwVersionLS;
	MultiByteToWideChar( CP_ACP, 0, m_pWave->GetName(), -1, pDMObjectDesc->wszName, DMUS_MAX_NAME );

	return S_OK;
}

void CWaveNode::SetFileName(CString sFileName)
{
	m_sFileName = sFileName;
}

CString CWaveNode::GetFileName()
{
	return m_sFileName;
}

GUID CWaveNode::GetGUID()
{
	return m_guidWaveNode;
}


void CWaveNode::CreateNewVersionGUID()
{
	::CoCreateGuid(&m_guidVersion);
}

GUID CWaveNode::GetVersionGUID()
{
	return m_guidVersion;
}


HRESULT CWaveNode::WriteDragChunkToStream(IDMUSProdRIFFStream* pIRiffStream)
{
	ASSERT(pIRiffStream);
	if(pIRiffStream == NULL)
	{
		return E_POINTER;
	}

	// We've already copied this node to the stream then....
	if(m_bDragCopy == true)
	{
		return S_OK;
	}

	// Get the GUID for the node and persist it in the data object
	GUID guidFile;
	if(FAILED(m_pComponent->m_pIFramework->GetNodeFileGUID(this, &guidFile)))
	{
		return E_FAIL;
	}

	IStream* pIStream = pIRiffStream->GetStream();
	ASSERT(pIStream);
	if(pIStream == NULL)
	{
		return E_FAIL;
	}

	// Create the drag-ck
	MMCKINFO ck;
	ck.ckid = FOURCC_DRAG;
	if(FAILED(pIRiffStream->CreateChunk(&ck, 0)))
	{
		pIStream->Release();
		return E_FAIL;
	}

	// Save the GUID
	DWORD cb = 0;
	HRESULT hr = pIStream->Write((LPCSTR)&guidFile, sizeof(GUID), &cb);
	if(FAILED(hr) || cb != sizeof(GUID))
	{
		pIStream->Release();
		return E_FAIL;
	}

	cb = 0;
	hr = pIStream->Write((LPCSTR)&m_guidWaveNode, sizeof(GUID), &cb);
	if(FAILED(hr) || cb != sizeof(GUID))
	{
		pIStream->Release();
		return E_FAIL;
	}

	if(FAILED(pIRiffStream->Ascend(&ck, 0)))
	{
		pIStream->Release();
		return E_FAIL;
	}
	
	m_bDragCopy = true;
	
	pIStream->Release();
	return S_OK;

}

bool CWaveNode::GetDragCopy()
{
	return m_bDragCopy;
}

void CWaveNode::SetDragCopy(bool bDragCopy)
{
	m_bDragCopy = bDragCopy;
}

void CWaveNode::SetDirtyFlag()
{
	ASSERT(m_pWave);
	if(m_pWave == NULL)
	{
		return;
	}

	// Set the node's dirty flag only if it's NOT in a collection
	if(IsInACollection() == false)
	{
		m_bIsDirty = TRUE;
	}
	else
	{
		CCollection* pCollection = GetCollection();
		ASSERT(pCollection);
		if(pCollection)
		{
			pCollection->SetDirtyFlag();
		}
	}
}

void CWaveNode::ClearDirtyFlag()
{
	m_bIsDirty = FALSE;
}

IDirectSoundWave* CWaveNode::GetDirectSoundWave()
{
	return m_pIDirectSoundWave;
}

GUID CWaveNode::GetFileGUID()
{
	return m_guidFile;
}

void CWaveNode::SetFileGUID(GUID guidNew)
{
	if(m_pComponent->IsInWaveNodesList(guidNew))
	{
		::CoCreateGuid(&m_guidFile);
	}
	else
	{
		m_guidFile = guidNew;
	}
}

void CWaveNode::SetPreviousRegionLinkIDs(CWaveNode* pSourceWaveNode)
{
	ASSERT(pSourceWaveNode);
	if(pSourceWaveNode == NULL)
	{
		return;
	}

	ASSERT(m_pWave);
	if(m_pWave == NULL)
	{
		return;
	}

	CWave* pSourceWave = pSourceWaveNode->GetWave();
	ASSERT(pSourceWave);
	if(pSourceWave == NULL)
	{
		return;
	}

	if(IsStereo() && pSourceWaveNode->IsStereo())
	{
		CStereoWave* pSource = dynamic_cast<CStereoWave*>(pSourceWave);
		ASSERT(pSource);
		if(pSource == NULL)
		{
			return;
		}

		CStereoWave* pThisWave = dynamic_cast<CStereoWave*>(m_pWave);
		ASSERT(pThisWave);
		if(pThisWave == NULL)
		{
			return;
		}

		CMonoWave* pSrcLeftWave = pSource->GetLeftChannel();
		ASSERT(pSrcLeftWave);
		if(pSrcLeftWave == NULL)
		{
			return;
		}

		CMonoWave* pSrcRightWave = pSource->GetRightChannel();
		ASSERT(pSrcRightWave);
		if(pSrcRightWave == NULL)
		{
			return;
		}

		DWORD dwLeftID = pSrcLeftWave->GetWaveID();
		DWORD dwRightID = pSrcRightWave->GetWaveID();

		pThisWave->SetPreviousRegionLinkIDs(dwLeftID, dwRightID);
	}
	else if(!IsStereo() && !pSourceWaveNode->IsStereo())
	{
		CMonoWave* pSource = dynamic_cast<CMonoWave*>(pSourceWave);
		ASSERT(pSource);
		if(pSource == NULL)
		{
			return;
		}

		CMonoWave* pThisWave = dynamic_cast<CMonoWave*>(m_pWave);
		ASSERT(pThisWave);
		if(pThisWave == NULL)
		{
			return;
		}
		
		pThisWave->SetPreviousRegionLinkID(pSource->GetWaveID());
	}
	else
	{
		// This can't be!!!
		ASSERT(0);
	}
}

void CWaveNode::SetTransportName()
{
	ASSERT(m_pWave);
	if(m_pWave == NULL)
	{
		return;
	}

	ASSERT(m_pComponent);
	if(m_pComponent == NULL)
	{
		return;
	}

	IDMUSProdConductor* pIConductor = m_pComponent->m_pIConductor;
	ASSERT(pIConductor);
	if(pIConductor== NULL)
	{
		return;
	}

	// The actual transport name is collection:wavename
	CString sWaveName = m_pWave->GetName();

	CString sCollectionName = "";
	CCollection* pCollection = m_pWave->GetCollection();
	if(pCollection)
	{
		BSTR bstrCollectionName;
		if(SUCCEEDED(pCollection->GetNodeName(&bstrCollectionName)))
		{
			sCollectionName = bstrCollectionName;
			SysFreeString(bstrCollectionName);
		}
	}
	else
	{
		sCollectionName.LoadString(IDS_WAVE_OBJECT_TEXT);
	}

	CString sTransportName = sCollectionName + ":" + sWaveName;

	// Set the name for the transport
	BSTR bstrWaveName = sTransportName.AllocSysString();
	pIConductor->SetTransportName(this, bstrWaveName);
}

void CWaveNode::RegisterWithTransport()
{
	ASSERT(m_pComponent);
	if(m_pComponent == NULL)
	{
		return;
	}

	// Register with the transport
	IDMUSProdConductor* pIConductor = m_pComponent->m_pIConductor;
	ASSERT(pIConductor);
	if(pIConductor)
	{
		pIConductor->RegisterTransport(this, 0);
		SetTransportName();
	}

}

void CWaveNode::UnRegisterFromTransport()
{
	ASSERT(m_pComponent);
	if(m_pComponent == NULL)
	{
		return;
	}

	// Register with the transport
	IDMUSProdConductor* pIConductor = m_pComponent->m_pIConductor;
	ASSERT(pIConductor);
	if(pIConductor)
	{
		pIConductor->UnRegisterTransport(this);
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\DLSDesigner\WaveNode.h ===
#ifndef __WAVENODE_H__
#define __WAVENODE_H__

// WaveNode.h : header file
//

#include "DLSComponent.h"
#include "DLSDocType.h"
#include "RiffStrm.h"
#include "DMusicc.h"
#include "DSoundP.h"
#include <WaveTimelineDraw.h>


struct WaveStopResetTimeEvent
{
	long		 lWaitTime;		// Length of the one shot wave in milliseconds
	CWaveNode*	 pWaveNode;		// Playing wave node
};

// CWaveNode definition
//=========================================================================================================
class CWave;
class CWaveCtrl;
class CCollectionWaves;
class CWaveStream;

class CWaveNode : public AListItem, public IDMUSProdNode, public IPersistStream, 
					public IDMUSProdTransport, public IDMUSProdWaveTimelineDraw, public IDMUSProdNotifySink
{

public:
    
	// Named constructors : Create method should be the only way to create this object
	static HRESULT CreateWaveNode(CDLSComponent* pComponent, IStream* pIStream, CString sFileName, CWaveNode** ppWaveNode, CCollectionWaves* pWavesCollection = NULL, bool bInACollection = false);
	static HRESULT CreateWaveNode(CDLSComponent* pComponent, CCollectionWaves* pWavesCollection, IDMUSProdRIFFStream* pIRiffStream, MMCKINFO* pckMain, CWaveNode** ppWaveNode);
	static HRESULT CreateWaveNode(CDLSComponent* pComponent, CWaveNode** ppWaveNode); 

    // IUnknown functions
    HRESULT STDMETHODCALLTYPE QueryInterface( REFIID riid, LPVOID *ppv );
    ULONG STDMETHODCALLTYPE AddRef();
    ULONG STDMETHODCALLTYPE Release();

    // IDMUSProdNode functions
	HRESULT STDMETHODCALLTYPE GetNodeImageIndex( short* pnFirstImage );

    HRESULT STDMETHODCALLTYPE GetComponent( IDMUSProdComponent** ppIComponent );
    HRESULT STDMETHODCALLTYPE GetDocRootNode( IDMUSProdNode** ppIRootNode );
    HRESULT STDMETHODCALLTYPE SetDocRootNode( IDMUSProdNode* pIRootNode );
    HRESULT STDMETHODCALLTYPE GetParentNode( IDMUSProdNode** ppIParentNode );
    HRESULT STDMETHODCALLTYPE SetParentNode( IDMUSProdNode* pIParentNode );
    HRESULT STDMETHODCALLTYPE GetNodeId( GUID* pguid );
    HRESULT STDMETHODCALLTYPE GetNodeName( BSTR* pbstrName );
    HRESULT STDMETHODCALLTYPE GetNodeNameMaxLength( short* pnMaxLength );
    HRESULT STDMETHODCALLTYPE ValidateNodeName( BSTR bstrName );
    HRESULT STDMETHODCALLTYPE SetNodeName( BSTR bstrName );

    HRESULT STDMETHODCALLTYPE GetEditorClsId( CLSID* pclsid );
    HRESULT STDMETHODCALLTYPE GetEditorTitle( BSTR* pbstrTitle );
    HRESULT STDMETHODCALLTYPE GetEditorWindow( HWND* hWndEditor );
    HRESULT STDMETHODCALLTYPE SetEditorWindow( HWND hWndEditor );

	HRESULT STDMETHODCALLTYPE UseOpenCloseImages( BOOL* pfUseOpenCloseImages );

    HRESULT STDMETHODCALLTYPE GetRightClickMenuId(HINSTANCE* phInstance, UINT* pnMenuId);
    HRESULT STDMETHODCALLTYPE OnRightClickMenuInit(HMENU hMenu);
    HRESULT STDMETHODCALLTYPE OnRightClickMenuSelect(long lCommandId);

    HRESULT STDMETHODCALLTYPE DeleteChildNode( IDMUSProdNode* pIChildNode, BOOL fPromptUser );
    HRESULT STDMETHODCALLTYPE InsertChildNode( IDMUSProdNode* pIChildNode );
    HRESULT STDMETHODCALLTYPE DeleteNode( BOOL fPromptUser );

	HRESULT STDMETHODCALLTYPE GetFirstChild(IDMUSProdNode** ppIFirstChildNode);
	HRESULT STDMETHODCALLTYPE GetNextChild(IDMUSProdNode* pIChildNode, IDMUSProdNode** ppINextChildNode);
	HRESULT STDMETHODCALLTYPE GetNodeListInfo(DMUSProdListInfo* pListInfo);

	HRESULT STDMETHODCALLTYPE OnNodeSelChanged( BOOL fSelected );
    
	// IDMUSProdNode : drag & drop methods
	HRESULT STDMETHODCALLTYPE CreateDataObject( IDataObject** ppIDataObject );
	HRESULT STDMETHODCALLTYPE CanCut();
	HRESULT STDMETHODCALLTYPE CanCopy();
	HRESULT STDMETHODCALLTYPE CanDelete();
	HRESULT STDMETHODCALLTYPE CanDeleteChildNode( IDMUSProdNode* pIChildNode );
	HRESULT STDMETHODCALLTYPE CanPasteFromData( IDataObject* pIDataObject, BOOL* pfWillSetReference );
	HRESULT STDMETHODCALLTYPE PasteFromData( IDataObject* pIDataObject );
	HRESULT STDMETHODCALLTYPE CanChildPasteFromData( IDataObject* pIDataObject, IDMUSProdNode* pIChildNode, BOOL* pfWillSetReference );
	HRESULT STDMETHODCALLTYPE ChildPasteFromData( IDataObject* pIDataObject, IDMUSProdNode* pIChildNode );

	HRESULT STDMETHODCALLTYPE GetObject( REFCLSID rclsid, REFIID riid, void** ppvObject );

    // IPersist functions
    STDMETHOD(GetClassID)(CLSID* pClsId);

    // IPersistStream functions
    STDMETHOD(IsDirty)();
    STDMETHOD(Load)( IStream* pIStream );
    STDMETHOD(Save)( IStream* pIStream, BOOL fClearDirty );
    STDMETHOD(GetSizeMax)( ULARGE_INTEGER FAR* pcbSize );

	// Drag-Drop Methods
	HRESULT WriteDragChunkToStream(IDMUSProdRIFFStream* pIRiffStream);
	HRESULT PasteWave(IDMUSProdRIFFStream* pIRiffStream, MMCKINFO* pckDragged);

	// Helper method to save waves as wave files
	HRESULT SaveAs(IStream* pIStream, bool bPromptForFileName = false); 

	// Helper method to retrieve object descriptor 
	HRESULT GetObjectDescriptor( void* pObjectDesc );

    // IDMUSProdTransport functions
	STDMETHOD(Play)(BOOL fPlayFromStart);
	STDMETHOD(Stop)(BOOL /*fStopImmediate*/);
    STDMETHOD(Transition)( );
	STDMETHOD(Record)(BOOL fPressed);
	STDMETHOD(GetName)(BSTR* pbstrName);
	STDMETHOD(TrackCursor)(BOOL fTrackCursor);

	// IDMUSProdWaveTimelineDraw methods
	HRESULT STDMETHODCALLTYPE DrawWave(IDMUSProdTimeline* pITimeline, HDC hDC, const CRect& rcClient, const long lOffset, const WaveDrawParams* pWaveDrawParams, const WaveTimelineInfoParams* pWaveInfoParams);
	HRESULT STDMETHODCALLTYPE GetWaveInfo(WaveInfoParams* pWaveInfoParams);
	HRESULT STDMETHODCALLTYPE SampleToRefTime(DWORD dwSample, REFERENCE_TIME* prtSampleTime, LONG lFineTuneCents);
	HRESULT STDMETHODCALLTYPE RefTimeToSample(REFERENCE_TIME rtSampleTime, DWORD* pdwSample, LONG lFineTuneCents);

	// IDMUSProdNotifySink method
	STDMETHOD(OnUpdate)(IDMUSProdNode* pIDocRootNode, GUID guidUpdateType, VOID* pData);

	// AListItem method
	CWaveNode* GetNext() {return(CWaveNode*)AListItem::GetNext();}

	// Accessors And Mutators
	GUID			GetFileGUID();								// Gets the m_guidFile that's written to DMUS_FOURCC_GUID_CHUNK
	void			SetFileGUID(GUID guidNew);					// Sets the m_guidFile that's written to DMUS_FOURCC_GUID_CHUNK
	CWave*			GetWave() const;
	CDLSComponent*	GetComponent() const;
	CCollection*	GetCollection() const;
	void			SetCollection(CCollection* pCollection);
	
	CWaveCtrl*	GetWaveEditor() const;
	void		SetWaveEditor(CWaveCtrl* pWaveCtrl);

	HRESULT	InitAndDownload();										// Downloads itself to all the ports
	HRESULT UnloadFromAllPorts();									// Unloads itself from all the ports
	HRESULT DownloadToAllPorts();									// Downloads itself to all the ports without doing DM_Init
	HRESULT	DM_Init(IDirectMusicPortDownload* pIDMPortDownLoad);	// Initializes the download buffers
	HRESULT	Download(IDirectMusicPortDownload* pIDMPortDownLoad);	// Downloads the Wave
	HRESULT	Unload(IDirectMusicPortDownload* pIDMPortDownLoad);		// Unloads the Wave

    BOOL    IsSourceInTempFile();
    void    SetSourceInTempFile(BOOL bSourceInTempFile);

	void	RegisterWithTransport();
	void	UnRegisterFromTransport();

	HRESULT	OnViewProperties();		// Shows the wave property page
	void	RefreshPropertyPage();	// Asks the wave to update it's property page

	bool	IsInACollection();		// Returns true if the node's in a collection
	bool	IsStereo();				// Does this nodes contain a stereo wave?

	HRESULT	GetPlayTimeForTempo(int nTempo, DWORD& dwPlayTime);	// Computes the time required for this wave to play once at the passed tempo
	void	DrawWave(CDC* pDC, const CRect& rcClient);			// Draws the wave on the passed DC within the passed bounding rect
	
	static void		CopyGUID(const GUID& guidSrc, GUID& guidDest);
	static HRESULT	IsLoadingStereoWave(IDMUSProdRIFFStream* pIRiffStream, MMCKINFO* pckMain, bool& bStereo, bool& bTrueStereo, GUID& guidStereoWave, bool& bRightChannel);	// Returns true if we're trying to load a stereo wave else false
	
	void	SetFileName(CString sFileName);
	CString GetFileName();

	GUID	GetGUID();
	void	CreateNewVersionGUID();
	GUID	GetVersionGUID();

	void	SetTransportName();
	HRESULT SetSelected(BOOL bSelect = TRUE);

	// Helpers for DirectSoundWave object
	HRESULT				CreateDirectSoundWave();	
	HRESULT				ReloadDirectSoundWave();
	IDirectSoundWave*	GetDirectSoundWave();

	HRESULT	GetFineTunedSampleRate(long lFineTuneCents, DWORD& dwTunedSampleRate);

	void	SetPreviousRegionLinkIDs(CWaveNode* pSourceWaveNode);

	bool	GetDragCopy();
	void	SetDragCopy(bool bDragCopy);

	void	SetDirtyFlag();
	void	ClearDirtyFlag();


public:
	CRITICAL_SECTION	m_CriticalSection;			// Needed to guard wave data access calls
	GUID				m_guidFile;					// GUID written to DMUS_FOURCC_GUID_CHUNK
	HANDLE				m_hStopEvent;			// Stop event

private:
	
	CWaveNode( CDLSComponent* pComponent, bool bStereo = false);
	~CWaveNode();

	HRESULT				Load(IDMUSProdRIFFStream* pIRiffStream, MMCKINFO* pckMain);
	static CWaveNode*	FindNodeForStereoGuid(CCollectionWaves* pWavesCollection, const GUID& guidStereoWave);
	bool				ConfirmWaveDelete(); // Confirms the delete action and deletes the wave

	GUID				m_guidVersion;				// GUID that identifies a particular version of the node
	IDirectSoundWave*	m_pIDirectSoundWave;		// DirectSoundWave object for the wave track
	CWaveStream*		m_pDirectSoundWaveStream;	// Stream that gets passed to the DirectSoundWave
	CPtrList			m_lstWaveTrackDownload;		// List of ports and pchannels that the wave is downloaded to

	WaveStopResetTimeEvent	m_ResetCallBackParams;  // Event to reset the play state for the playing wave

	long			m_lRef;			// Reference counter
	IDMUSProdNode*	m_pIRootNode;	// DocRoot node for this wave
	IDMUSProdNode*	m_pIParentNode;	// Parent node of this wave

	CDLSComponent*	m_pComponent;	// DLS Component
	bool			m_bInCollection;// Is the node in a DLS collection?
	CWave*			m_pWave;		// Wave object
	bool			m_bStereo;		// This wave is a stereo wave
	CWaveCtrl*		m_pWaveCtrl;	// The Wave Editor
	HWND			m_hWndEditor;	// Handle to the editor window

	bool			m_bTrackTimeCursor;	// Are we showing the cursor as the wave plays?

	CString			m_sFileName;		// The wave file name with the complete path

	bool			m_bDragCopy;		// To mark if wave node has been copied for drag-drop of instruments
	bool			m_bPastingWave;		// Flag to remember we're pasting a wave
	CString			m_sTempFileName;	// Temp file used during pasting waves
    BOOL            m_bSrcInATempFile;     // Flag to indicate the wave data lives in a temp source file; not saved to a WVP or a DLP file yet

	GUID			m_guidWaveNode;		// GUID that uniquelyu identifies this node

	BOOL			m_bIsDirty;			// Flag to mark this file as modified so user can be prompted...

	

};

#endif // __WAVENODE_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\DLSDesigner\WavePropPg.h ===
#if !defined(AFX_WAVEPROPPG_H__59101182_E95D_11D0_876A_00AA00C08146__INCLUDED_)
#define AFX_WAVEPROPPG_H__59101182_E95D_11D0_876A_00AA00C08146__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// WavePropPg.h : header file
//

#include "resource.h"
#include "myslider.h"
#include "wave.h"

#define DM_VALIDATE (WM_USER + 1000)

class CWave;
class CWavePropPgMgr;

/////////////////////////////////////////////////////////////////////////////
// CWavePropPg dialog

class CWavePropPg : public CPropertyPage, CSliderCollection
{
	DECLARE_DYNCREATE(CWavePropPg)

// Construction
public:
	CWavePropPg();
	~CWavePropPg();

	virtual BOOL OnInitDialog();

	void SetObject(CWave* pWave);
	

	void	SetPropMgr(CWavePropPgMgr* pPropMgr) {m_pPropMgr = pPropMgr;}
	void	EnableControls(void);
    void	EnableLoopControls(BOOL bEnable);
	void	EnableSelectionControls(BOOL bEnable);
    void	InitializeDialogValues();
	HRESULT ValidateAndSetLoopValues(DWORD dwLoopStart, DWORD dwLoopLength, bool bSaveUndoState = true);
	void	SetSelection(int nSelectionStart = 0, int nSelectionEnd = 0, bool bSetEditor = true, bool bDoSnap = true);
	bool	IsSelectionLengthLocked();
	bool	IsLoopLengthLocked();
	void	SetSelectionLengthLock(bool bLock);
	void	SetWaveLoopType(ULONG ulLoopType);
		
// Dialog Data
	//{{AFX_DATA(CWavePropPg)
	enum { IDD = IDD_WAVE_PROP_PAGE };
	CSpinButtonCtrl	m_SelectionStartSpin;
	CSpinButtonCtrl	m_SelectionLengthSpin;
	CButton	m_SelectionLengthLockCheck;
	CSpinButtonCtrl	m_SelectionEndSpin;
	CSpinButtonCtrl	m_LoopStartSpin;
	CSpinButtonCtrl	m_LoopLengthSpin;
	CButton	m_LoopLengthLockCheck;
	CButton	m_LoopCheck;
	CSpinButtonCtrl	m_LoopEndSpin;
	CEdit	m_LoopEndEdit;
	CEdit	m_LoopStartEdit;
	CEdit	m_LoopLengthEdit;
	CEdit	m_RootNoteEdit;
	CSpinButtonCtrl	m_RootNoteSpin;
	BOOL	m_fAllowCompression;
	BOOL	m_fAllowTruncation;
	DWORD	m_dwLength;
	//}}AFX_DATA

	DWORD	m_dwLoopLength;
	DWORD	m_dwLoopStart;


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CWavePropPg)
	public:
	virtual BOOL OnSetActive();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	virtual BOOL OnCommand(WPARAM wParam, LPARAM lParam);
	virtual BOOL OnNotify(WPARAM wParam, LPARAM lParam, LRESULT* pResult);
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CWavePropPg)
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	afx_msg void OnDestroy();
	afx_msg void OnHScroll(UINT nSBCode, UINT nPos, CScrollBar* pScrollBar);
	afx_msg void OnKillfocusRootNote();
	afx_msg void OnKillfocusLoopLength();
	afx_msg void OnKillfocusLoopStart();
	afx_msg void OnSampleTruncation();
	afx_msg void OnSampleCompression();
	afx_msg LRESULT OnValidate(UINT wParam, long lParam);
	afx_msg void OnDeltaposRootNoteSpin(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnLoopCheck();
	afx_msg void OnKillfocusLoopEnd();
	afx_msg void OnDeltaposLoopEndSpin(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnLoopLengthLockCheck();
	afx_msg void OnDeltaposLoopLengthSpin(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnDeltaposLoopStartSpin(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnKillfocusSelectionEnd();
	afx_msg void OnDeltaposSelectionEndSpin(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnKillfocusSelectionLength();
	afx_msg void OnSelectionLengthLockCheck();
	afx_msg void OnDeltaposSelectionLengthSpin(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnKillfocusSelectionStart();
	afx_msg void OnDeltaposSelectionStartSpin(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnForwardLoopRadio();
	afx_msg void OnLoopAndReleaseRadio();
	afx_msg void OnLButtonDblClk(UINT nFlags, CPoint point);
	//}}AFX_MSG
	
	DECLARE_MESSAGE_MAP()
	afx_msg void OnEditChange( UINT nEditControl );
	enum { fLOOP_START = 0x01,	fLOOP_LENGTH = 0x02, fROOT_NOTE = 0x04 };

	// CSliderCollection overrides
	virtual bool OnSliderUpdate(MySlider *pms, DWORD dwmscupdf);

private:
	// update region properties methods
    void	UpdateAttenuationInRegions(void);
    void	UpdateFineTuneInRegions(void);
    void	UpdateSampleTruncationInRegions(void);
    void	UpdateSampleCompressionInRegions(void);
    void	UpdateRootNoteInRegions(void);
    void	UpdatePlaybackSettingsInRegions(void);
	void	UpdateDbAttenuation();
	void	UpdateFineTune();
	bool	ValidateLoopLength();
	bool	ValidateLoopStart();
	HRESULT	UpdateRootNote(USHORT usNewNote);
	void	UpdateRootNoteText(int note);
	USHORT	GetNoteInEditBox();
	void	PostValidate(UINT nControl);
	void	EnableControl(UINT ID, BOOL bEnable = true);
	void	Swap(int& nSelectionStart, int& nSelectionEnd);
	void	EnableLoopTypeButtons(BOOL bEnable = TRUE);
	BOOL	CheckSliderForDefaultClick(MySlider& msSlider, CPoint point);

	/* ensures the given selection length fits within boundaries */
	void ConstrainSelectionLength(int& nSelLen);

	/* if necessary, snaps the given selection value in the given direction */
	void EnsureSnap(int& nSel, UINT nSnapDirection);

    LONG		m_lFineTune;
    LONG		m_lAttenuation;

	MySlider*	m_pmsFineTune;
    MySlider*	m_pmsAttenuation;

	BOOL	m_fNeedToDetach;
    BOOL	m_fOneShot;
	BOOL	m_fActivateLoop;
    BOOL	m_fInitialUpdate;
	DWORD	m_bfTouched;			// Bit field for "has control been changed by user?"
	bool	m_bTouchedByProgram;	// Did program call SetWindowText() on this control?
	bool	m_bLockLoopLength;		// Lock the loop length?
	bool	m_bLockSelectionLength;	// Lock the selection Length?
	int		m_nSelectionStart;		// Start of the wave selection; reflected on the wave editor, counted from decompressed start
	int		m_nSelectionEnd;		// End of the wave selection, counted from decompressed start
	bool	m_bInLoopUpdate;


    CWave*	m_pWave;

	CWavePropPgMgr*	m_pPropMgr;

	
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_WAVEPROPPG_H__59101182_E95D_11D0_876A_00AA00C08146__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\DLSDesigner\WavePropPgMgr.h ===
//////////////////////////////////////////////////////////////////////
//
// WavePropPgMgr.h
//
//////////////////////////////////////////////////////////////////////

#ifndef WAVEPROPPGMGR_H
#define WAVEPROPPGMGR_H

#include "DllBasePropPageManager.h"

class CWavePropPg;
class CWaveInfoPropPg;
class CWaveCompressionPropPage;

#define WAVE_PROP_PAGE			0
#define WAVE_INFO_PAGE			1
#define WAVE_COMPRESSION_PAGE	2

//////////////////////////////////////////////////////////////////////
//  CWavePropPgMgr

class CWavePropPgMgr : public CDllBasePropPageManager 
{
    friend class CWaveCtrl;
	friend class CWave;

public:
	CWavePropPgMgr();
	virtual ~CWavePropPgMgr();

    // IJazzPropPageManager functions
    HRESULT STDMETHODCALLTYPE GetPropertySheetTitle( BSTR* pbstrTitle, BOOL* pfAddPropertiesText );
    HRESULT STDMETHODCALLTYPE GetPropertySheetPages( IDMUSProdPropSheet* pIPropSheet, LONG* hPropSheetPage[], short* pnNbrPages );

    HRESULT STDMETHODCALLTYPE RefreshData();
	//additional metheods
public:
	void ShowPropSheet();
	// Member variables

public:
	static DWORD dwLastSelPage;

private:
	CWavePropPg*				m_pWavePage;
    CWaveInfoPropPg*			m_pWaveInfoPage;
	CWaveCompressionPropPage*	m_pWaveCompressionPage;
};

#endif // #ifndef WAVEPROPPGMGR_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\DLSDesigner\WavePropPgMgr.cpp ===
//////////////////////////////////////////////////////////////////////
//
// WavePropPgMgr.cpp : implementation file
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "WavePropPgMgr.h"
#include "WavePropPg.h"
#include "WaveNode.h"
#include "Wave.h"
#include "Collection.h"
#include "WaveInfoPropPg.h"
#include "WaveCompressionPropPage.h"

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#define new DEBUG_NEW
#endif

DWORD CWavePropPgMgr::dwLastSelPage = 0;

//////////////////////////////////////////////////////////////////////
// CWavePropPgMgr Construction/Destruction
//////////////////////////////////////////////////////////////////////

CWavePropPgMgr::CWavePropPgMgr() : 
m_pWavePage(NULL), 
m_pWaveInfoPage(NULL),
m_pWaveCompressionPage(NULL)
{
}

CWavePropPgMgr::~CWavePropPgMgr()
{
	if(m_pWavePage)
		delete m_pWavePage;

	if(m_pWaveInfoPage)
		delete m_pWaveInfoPage;

	if(m_pWaveCompressionPage)
		delete m_pWaveCompressionPage;
}

/////////////////////////////////////////////////////////////////////////////
// CWavePropPgMgr IJazzPropPageManager implementation

/////////////////////////////////////////////////////////////////////////////
// CWavePropPgMgr IJazzPropPageManager::GetPropertySheetTitle

HRESULT CWavePropPgMgr::GetPropertySheetTitle(BSTR* pbstrTitle, BOOL* pfAddPropertiesText)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT(pbstrTitle);
	ASSERT(pfAddPropertiesText);

	*pfAddPropertiesText = TRUE;

	CWave* pWave;

	if(m_pIPropPageObject && (SUCCEEDED (m_pIPropPageObject->GetData((void **)&pWave))))
	{
		BSTR bstrWaveName;
		CWaveNode* pWaveNode = pWave->GetNode();
		ASSERT(pWaveNode);
		pWaveNode->GetNodeName(&bstrWaveName);
		CString sWaveName = bstrWaveName;
		SysFreeString(bstrWaveName);

		BSTR bstrCollectionName;
		CCollection* pCollection = pWave->GetCollection();
		CString sCollectionName = "";
		if(pCollection)
		{
			pCollection->GetNodeName(&bstrCollectionName);
			sCollectionName = bstrCollectionName;
			SysFreeString(bstrCollectionName);
			sCollectionName += " - ";
		}

		CString sTitle;
		sTitle.Format(IDS_WAVE_PROPPAGE_TITLE, sCollectionName, sWaveName);
		*pbstrTitle = sTitle.AllocSysString();
	}
	else
	{
		CString strTitle;
		strTitle.LoadString(IDS_WAVE_TEXT);
		*pbstrTitle = strTitle.AllocSysString();
	}

	return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
// CWavePropPgMgr IJazzPropPageManager::GetPropertySheetPages

HRESULT CWavePropPgMgr::GetPropertySheetPages(IDMUSProdPropSheet* pIPropSheet, LONG* hPropSheetPage[], short* pnNbrPages)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( (hPropSheetPage == NULL)
	||  (pnNbrPages == NULL) )
	{
		return E_POINTER;
	}

	if( pIPropSheet == NULL )
	{
		return E_INVALIDARG;
	}

	m_pIPropSheet = pIPropSheet;
	m_pIPropSheet->AddRef();

	hPropSheetPage[0] = NULL;
	*pnNbrPages = 0;

	// Add General tab
	HPROPSHEETPAGE hPage;
	short nNbrPages = 0;

    if (m_pWavePage == NULL)
        m_pWavePage = new CWavePropPg();

	if(m_pWavePage)
	{
		hPage = ::CreatePropertySheetPage((LPPROPSHEETPAGE)&m_pWavePage->m_psp);
		if(hPage)
		{
			hPropSheetPage[nNbrPages] = (LONG *)hPage;
			nNbrPages++;
		}			
	}

	if(m_pWaveInfoPage == NULL)
    	m_pWaveInfoPage = new CWaveInfoPropPg();

	if(m_pWaveInfoPage)
	{
		hPage = ::CreatePropertySheetPage((LPPROPSHEETPAGE)&m_pWaveInfoPage->m_psp);
		if(hPage)
		{
			hPropSheetPage[nNbrPages] = (LONG *)hPage;
			nNbrPages++;
		}			
	}

	if(m_pWaveCompressionPage == NULL)
		m_pWaveCompressionPage = new CWaveCompressionPropPage;

	if(m_pWaveCompressionPage)
	{
		hPage = ::CreatePropertySheetPage((LPPROPSHEETPAGE)&m_pWaveCompressionPage->m_psp);
		if(hPage)
		{
			hPropSheetPage[nNbrPages] = (LONG *)hPage;
			nNbrPages++;
		}			
	}

	// Set number of pages
	*pnNbrPages = nNbrPages; 

	return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
// CWavePropPgMgr IJazzPropPageManager::RefreshData

HRESULT CWavePropPgMgr::RefreshData(void)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	CWave* pWave = NULL;
	
	if(m_pIPropPageObject == NULL)
	{
		pWave = NULL;
	}
	else if(FAILED(m_pIPropPageObject->GetData((void **)&pWave)))
	{
		return E_FAIL;
	}

	if(m_pWavePage == NULL || m_pWaveInfoPage == NULL || m_pWaveCompressionPage == NULL)
		return E_FAIL;

	m_pWavePage->SetObject(pWave);
	m_pWavePage->SetPropMgr(this);
    m_pWaveInfoPage->SetObject(pWave);
	m_pWaveCompressionPage->SetObject(pWave);

	return S_OK;
}

void CWavePropPgMgr::ShowPropSheet()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	
	SetObject(m_pIPropPageObject);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\DLSDesigner\WaveRefNode.cpp ===
// WaveRefNode.cpp : implementation file
//

#include "stdafx.h"
#include "DLSDesignerDLL.h"

#include "WaveNode.h"
#include "WaveRefNode.h"
#include "DllJazzDataObject.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


/////////////////////////////////////////////////////////////////////////////
// CWaveRefNode constructor/destructor

CWaveRefNode::CWaveRefNode( CDLSComponent* pComponent )
{
	ASSERT( pComponent != NULL );

	m_pComponent = pComponent;
	m_pComponent->AddRef();

    m_dwRef = 0;
	AddRef();

	m_pIDocRootNode = NULL;
	m_pIParentNode = NULL;
	m_pWaveNode = NULL;
}

CWaveRefNode::~CWaveRefNode()
{
	RELEASE( m_pWaveNode );
	RELEASE( m_pComponent );
}


/////////////////////////////////////////////////////////////////////////////
// CWaveRefNode IUnknown implementation

HRESULT CWaveRefNode::QueryInterface( REFIID riid, LPVOID FAR* ppvObj )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

    if( ::IsEqualIID(riid, IID_IDMUSProdNode)
	||  ::IsEqualIID(riid, IID_IUnknown) )
    {
        AddRef();
        *ppvObj = (IDMUSProdNode *)this;
        return S_OK;
    }

    if( ::IsEqualIID(riid, IID_IDMUSProdReferenceNode) )
    {
        AddRef();
        *ppvObj = (IDMUSProdReferenceNode *)this;
        return S_OK;
    }

    *ppvObj = NULL;
    return E_NOINTERFACE;
}

ULONG CWaveRefNode::AddRef()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	AfxOleLockApp(); 
    return ++m_dwRef;
}

ULONG CWaveRefNode::Release()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

    ASSERT( m_dwRef != 0 );

	AfxOleUnlockApp(); 
    --m_dwRef;

    if( m_dwRef == 0 )
    {
        delete this;
        return 0;
    }

    return m_dwRef;
}


/////////////////////////////////////////////////////////////////////////////
// CWaveRefNode IDMUSProdNode implementation

/////////////////////////////////////////////////////////////////////////////
// CWaveRefNode IDMUSProdNode::GetNodeImageIndex

HRESULT CWaveRefNode::GetNodeImageIndex( short* pnFirstImage )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( m_pComponent != NULL );

	if(m_pWaveNode && m_pWaveNode->IsStereo())
	{
		return( m_pComponent->GetStereoWaveRefImageIndex(pnFirstImage) );
	}

	return( m_pComponent->GetWaveRefImageIndex(pnFirstImage) );
}


/////////////////////////////////////////////////////////////////////////////
// CWaveRefNode IDMUSProdNode::GetFirstChild

HRESULT CWaveRefNode::GetFirstChild( IDMUSProdNode** ppIFirstChildNode )
{
//	AFX_MANAGE_STATE(_afxModuleAddrThis);
	UNREFERENCED_PARAMETER(ppIFirstChildNode);

    return E_NOTIMPL;	// WaveRefNode node does not have children
}


/////////////////////////////////////////////////////////////////////////////
// CWaveRefNode IDMUSProdNode::GetNextChild

HRESULT CWaveRefNode::GetNextChild( IDMUSProdNode* pIChildNode, IDMUSProdNode** ppINextChildNode )
{
//	AFX_MANAGE_STATE(_afxModuleAddrThis);
	UNREFERENCED_PARAMETER(pIChildNode);
	UNREFERENCED_PARAMETER(ppINextChildNode);

    return E_NOTIMPL;	// WaveRefNode node does not have children
}


/////////////////////////////////////////////////////////////////////////////
// CWaveRefNode IDMUSProdNode::GetComponent

HRESULT CWaveRefNode::GetComponent( IDMUSProdComponent** ppIComponent )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( m_pComponent != NULL );

	return m_pComponent->QueryInterface( IID_IDMUSProdComponent, (void**)ppIComponent );
}


/////////////////////////////////////////////////////////////////////////////
// CWaveRefNode IDMUSProdNode::GetDocRootNode

HRESULT CWaveRefNode::GetDocRootNode( IDMUSProdNode** ppIDocRootNode )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( m_pIDocRootNode )
	{
		m_pIDocRootNode->AddRef();
		*ppIDocRootNode = m_pIDocRootNode;
		return S_OK;
	}

	*ppIDocRootNode = NULL;
	return E_FAIL;
}


/////////////////////////////////////////////////////////////////////////////
// CWaveRefNode IDMUSProdNode::SetDocRootNode

HRESULT CWaveRefNode::SetDocRootNode( IDMUSProdNode* pIDocRootNode )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( pIDocRootNode != NULL );

	m_pIDocRootNode = pIDocRootNode;
//	m_pIDocRootNode->AddRef();		intentionally missing

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CWaveRefNode IDMUSProdNode::GetParentNode

HRESULT CWaveRefNode::GetParentNode( IDMUSProdNode** ppIParentNode )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( m_pIParentNode != NULL );

	m_pIParentNode->AddRef();
	*ppIParentNode = m_pIParentNode;

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CWaveRefNode IDMUSProdNode::SetParentNode

HRESULT CWaveRefNode::SetParentNode( IDMUSProdNode* pIParentNode )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( pIParentNode != NULL );

	m_pIParentNode = pIParentNode;
//	m_pIParentNode->AddRef();		intentionally missing

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CWaveRefNode IDMUSProdNode::GetNodeId

HRESULT CWaveRefNode::GetNodeId( GUID* pguid )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( pguid == NULL )
	{
		return E_POINTER;
	}

	*pguid = GUID_WaveRefNode;

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CWaveRefNode IDMUSProdNode::GetNodeName

HRESULT CWaveRefNode::GetNodeName( BSTR* pbstrName )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( m_pWaveNode == NULL )
	{
		TCHAR achNoWave[MID_BUFFER];

		::LoadString( theApp.m_hInstance, IDS_NO_WAVE, achNoWave, MID_BUFFER );
		CString strNoWave = achNoWave;
		*pbstrName = strNoWave.AllocSysString();
		return S_OK;
	}

    return m_pWaveNode->GetNodeName( pbstrName );
}


/////////////////////////////////////////////////////////////////////////////
// CWaveRefNode IDMUSProdNode::GetNodeNameMaxLength

HRESULT CWaveRefNode::GetNodeNameMaxLength( short* pnMaxLength )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	*pnMaxLength = -1;	// Can't rename a WaveRefNode node

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CWaveRefNode IDMUSProdNode::ValidateNodeName

HRESULT CWaveRefNode::ValidateNodeName( BSTR bstrName )
{
//	AFX_MANAGE_STATE(_afxModuleAddrThis);
	UNREFERENCED_PARAMETER(bstrName);

	return E_NOTIMPL;	// Can't rename a WaveRefNode node
}


/////////////////////////////////////////////////////////////////////////////
// CWaveRefNode IDMUSProdNode::SetNodeName

HRESULT CWaveRefNode::SetNodeName( BSTR bstrName )
{
//	AFX_MANAGE_STATE(_afxModuleAddrThis);
	UNREFERENCED_PARAMETER(bstrName);

	return E_NOTIMPL;	// Can't rename a WaveRefNode node
}


/////////////////////////////////////////////////////////////////////////////
// CWaveRefNode IDMUSProdNode::GetNodeListInfo

HRESULT CWaveRefNode::GetNodeListInfo( DMUSProdListInfo* pListInfo )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( m_pWaveNode == NULL )
	{
		return E_FAIL;
	}

    return m_pWaveNode->GetNodeListInfo( pListInfo );
}


/////////////////////////////////////////////////////////////////////////////
// CWaveRefNode IDMUSProdNode::GetEditorClsId

HRESULT CWaveRefNode::GetEditorClsId( CLSID* pClsId )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( m_pWaveNode == NULL )
	{
		return E_FAIL;
	}

    return m_pWaveNode->GetEditorClsId( pClsId );
}


/////////////////////////////////////////////////////////////////////////////
// CWaveRefNode IDMUSProdNode::GetEditorTitle

HRESULT CWaveRefNode::GetEditorTitle( BSTR* pbstrTitle )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( m_pWaveNode == NULL )
	{
		return E_FAIL;
	}

    return m_pWaveNode->GetEditorTitle( pbstrTitle );
}


/////////////////////////////////////////////////////////////////////////////
// CWaveRefNode IDMUSProdNode::GetEditorWindow

HRESULT CWaveRefNode::GetEditorWindow( HWND* hWndEditor )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( m_pWaveNode == NULL )
	{
		return E_FAIL;
	}

    return m_pWaveNode->GetEditorWindow( hWndEditor );
}


/////////////////////////////////////////////////////////////////////////////
// CWaveRefNode IDMUSProdNode::SetEditorWindow

HRESULT CWaveRefNode::SetEditorWindow( HWND hWndEditor )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( m_pWaveNode == NULL )
	{
		return E_FAIL;
	}

    return m_pWaveNode->SetEditorWindow( hWndEditor );
}


/////////////////////////////////////////////////////////////////////////////
// CWaveRefNode IDMUSProdNode::UseOpenCloseImages

HRESULT CWaveRefNode::UseOpenCloseImages( BOOL* pfUseOpenCloseImages )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	*pfUseOpenCloseImages = FALSE;

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CWaveRefNode IDMUSProdNode::GetRightClickMenuId

HRESULT CWaveRefNode::GetRightClickMenuId( HINSTANCE* phInstance, UINT* pnMenuId )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	*phInstance = theApp.m_hInstance;
	*pnMenuId   = IDM_WAVEREF_NODE_RMENU;

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CWaveRefNode IDMUSProdNode::OnRightClickMenuInit

HRESULT CWaveRefNode::OnRightClickMenuInit( HMENU hMenu )
{
//	AFX_MANAGE_STATE(_afxModuleAddrThis);
	UNREFERENCED_PARAMETER(hMenu);

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CWaveRefNode IDMUSProdNode::OnRightClickMenuSelect

HRESULT CWaveRefNode::OnRightClickMenuSelect( long lCommandId )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	switch( lCommandId )
	{
		case IDM_PROPERTIES:
			if( m_pWaveNode )
			{
				return m_pWaveNode->OnRightClickMenuSelect( lCommandId );
			}
			break;

		default:
			return E_FAIL;
	}

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CWaveRefNode IDMUSProdNode::DeleteChildNode

HRESULT CWaveRefNode::DeleteChildNode( IDMUSProdNode* pIChildNode, BOOL fPromptUser )
{
//	AFX_MANAGE_STATE(_afxModuleAddrThis);
	UNREFERENCED_PARAMETER(pIChildNode);
	UNREFERENCED_PARAMETER(fPromptUser);

	return E_NOTIMPL;	// WaveRefNode nodes do not have children
}


/////////////////////////////////////////////////////////////////////////////
// CWaveRefNode IDMUSProdNode::InsertChildNode

HRESULT CWaveRefNode::InsertChildNode( IDMUSProdNode* pIChildNode )
{
//	AFX_MANAGE_STATE(_afxModuleAddrThis);
	UNREFERENCED_PARAMETER(pIChildNode);

	return E_NOTIMPL;	// WaveRefNode nodes do not have children
}


/////////////////////////////////////////////////////////////////////////////
// CWaveRefNode IDMUSProdNode::DeleteNode

HRESULT CWaveRefNode::DeleteNode( BOOL fPromptUser )
{
//	AFX_MANAGE_STATE(_afxModuleAddrThis);
	UNREFERENCED_PARAMETER(fPromptUser);

	return E_FAIL;		// Cannot delete WaveRefNode node?????
}


/////////////////////////////////////////////////////////////////////////////
// CWaveRefNode IDMUSProdNode::OnNodeSelChanged

HRESULT CWaveRefNode::OnNodeSelChanged( BOOL fSelected )
{
//	AFX_MANAGE_STATE(_afxModuleAddrThis);
	UNREFERENCED_PARAMETER(fSelected);

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CWaveRefNode IDMUSProdNode::CreateDataObject

HRESULT CWaveRefNode::CreateDataObject( IDataObject** ppIDataObject )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( ppIDataObject == NULL )
	{
		return E_POINTER;
	}

	*ppIDataObject = NULL;

	if( m_pWaveNode )
	{
		// Let Wave create data object
		return m_pWaveNode->CreateDataObject( ppIDataObject );
	}

	return E_FAIL;
}


/////////////////////////////////////////////////////////////////////////////
// CWaveRefNode IDMUSProdNode::CanCut

HRESULT CWaveRefNode::CanCut( void )
{
//	AFX_MANAGE_STATE(_afxModuleAddrThis);
 
	return CanDelete();
}


/////////////////////////////////////////////////////////////////////////////
// CWaveRefNode IDMUSProdNode::CanCopy

HRESULT CWaveRefNode::CanCopy( void )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
 
	if( m_pWaveNode )
	{
		return S_OK;	// Will copy the Wave
	}

	return S_FALSE;
}


/////////////////////////////////////////////////////////////////////////////
// CWaveRefNode IDMUSProdNode::CanDelete

HRESULT CWaveRefNode::CanDelete( void )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( m_pIParentNode != NULL );

	return m_pIParentNode->CanDeleteChildNode( this );
}


/////////////////////////////////////////////////////////////////////////////
// CWaveRefNode IDMUSProdNode::CanDeleteChildNode

HRESULT CWaveRefNode::CanDeleteChildNode( IDMUSProdNode* pIChildNode )
{
//	AFX_MANAGE_STATE(_afxModuleAddrThis);
	UNREFERENCED_PARAMETER(pIChildNode);

	ASSERT( 0 );

	return E_NOTIMPL;	// Wave Reference nodes do not have children
}


/////////////////////////////////////////////////////////////////////////////
// CWaveRefNode IDMUSProdNode::CanPasteFromData

HRESULT CWaveRefNode::CanPasteFromData( IDataObject* pIDataObject, BOOL* pfWillSetReference )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( pfWillSetReference == NULL )
	{
		return E_POINTER;
	}

	*pfWillSetReference = FALSE;

	if( pIDataObject == NULL )
	{
		return E_INVALIDARG;
	}

	// Create a new CDllJazzDataObject and see if it contains a Wave
	CDllJazzDataObject* pDataObject = new CDllJazzDataObject();
	if( pDataObject == NULL )
	{
		return E_OUTOFMEMORY;
	}
	
	HRESULT hr = pDataObject->IsClipFormatAvailable( pIDataObject, m_pComponent->m_cfWave );

	RELEASE( pDataObject );

	if( SUCCEEDED ( hr ) )
	{
		ASSERT( m_pIParentNode != NULL );

		// Let parent decide whether it wants to paste a Wave
		return m_pIParentNode->CanChildPasteFromData( pIDataObject, this, pfWillSetReference );
	}

	if( m_pWaveNode )
	{
		// Let WaveNode decide what can be dropped
		return m_pWaveNode->CanPasteFromData( pIDataObject, pfWillSetReference );
	}

	return S_FALSE;
}


/////////////////////////////////////////////////////////////////////////////
// CWaveRefNode IDMUSProdNode::PasteFromData

HRESULT CWaveRefNode::PasteFromData( IDataObject* pIDataObject )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( pIDataObject == NULL )
	{
		return E_INVALIDARG;
	}

	// Create a new CDllJazzDataObject and see if it contains a WaveNode
	CDllJazzDataObject* pDataObject = new CDllJazzDataObject();
	if( pDataObject == NULL )
	{
		return E_OUTOFMEMORY;
	}
	
	HRESULT hr = pDataObject->IsClipFormatAvailable( pIDataObject, m_pComponent->m_cfWave );

	RELEASE( pDataObject );

	if( SUCCEEDED ( hr ) )
	{
		ASSERT( m_pIParentNode != NULL );

		// Let parent handle pasting of WaveNode
		return m_pIParentNode->ChildPasteFromData( pIDataObject, this );
	}

	if( m_pWaveNode )
	{
		// Let WaveNode handle paste
		return m_pWaveNode->PasteFromData( pIDataObject );
	}

	return E_FAIL;
}


/////////////////////////////////////////////////////////////////////////////
// CWaveRefNode IDMUSProdNode::CanChildPasteFromData

HRESULT CWaveRefNode::CanChildPasteFromData( IDataObject* pIDataObject, IDMUSProdNode* pIChildNode,
										  BOOL* pfWillSetReference )
{
//	AFX_MANAGE_STATE(_afxModuleAddrThis);
	UNREFERENCED_PARAMETER(pIDataObject);
	UNREFERENCED_PARAMETER(pIChildNode);
	UNREFERENCED_PARAMETER(pfWillSetReference);

	return E_NOTIMPL;			// Wave Reference nodes do not have children
}


/////////////////////////////////////////////////////////////////////////////
// CWaveRefNode IDMUSProdNode::ChildPasteFromData

HRESULT CWaveRefNode::ChildPasteFromData( IDataObject* pIDataObject, IDMUSProdNode* pIChildNode )
{
//	AFX_MANAGE_STATE(_afxModuleAddrThis);
	UNREFERENCED_PARAMETER(pIDataObject);
	UNREFERENCED_PARAMETER(pIChildNode);

	return E_NOTIMPL;			// Wave Reference nodes do not have children
}


/////////////////////////////////////////////////////////////////////////////
// CWaveRefNode IDMUSProdNode::GetObject

HRESULT CWaveRefNode::GetObject( REFCLSID rclsid, REFIID riid, void** ppvObject )
{
//	AFX_MANAGE_STATE(_afxModuleAddrThis);
	UNREFERENCED_PARAMETER(rclsid);
	UNREFERENCED_PARAMETER(riid);
	UNREFERENCED_PARAMETER(ppvObject);

	return E_NOTIMPL;
}


/////////////////////////////////////////////////////////////////////////////
// CWaveRefNode IDMUSProdReferenceNode implementation

/////////////////////////////////////////////////////////////////////////////
// CWaveRefNode IDMUSProdReferenceNode::GetReferencedFile

HRESULT CWaveRefNode::GetReferencedFile( IDMUSProdNode** ppIDocRootNode )
{
 	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( ppIDocRootNode == NULL )
	{
		return E_POINTER;
	}

	*ppIDocRootNode = NULL;

	if( m_pWaveNode )
	{
		m_pWaveNode->AddRef();
		*ppIDocRootNode = m_pWaveNode;
		return S_OK;
	}

    return E_FAIL;
}


/////////////////////////////////////////////////////////////////////////////
// CWaveRefNode::IDMUSProdReferenceNode::SetReferencedFile

HRESULT CWaveRefNode::SetReferencedFile( IDMUSProdNode* pIDocRootNode )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( pIDocRootNode )
	{
		// Make sure method was passed a DocRootNode
		IDMUSProdNode* pINode;
		if( FAILED ( pIDocRootNode->GetDocRootNode ( &pINode ) ) )
		{
			pINode = NULL;
		}
		if( pIDocRootNode != pINode )
		{
			RELEASE( pINode );
			return E_INVALIDARG;
		}
		RELEASE( pINode );

		// Make sure method was passed a Wave Node
		GUID guidNodeId;
		if( SUCCEEDED ( pIDocRootNode->GetNodeId ( &guidNodeId ) ) )
		{
			if( !( IsEqualGUID ( guidNodeId, GUID_WaveNode ) ) )
			{
				return E_INVALIDARG;
			}
		}
	}

	// Release previous DocRoot Node
	RELEASE( m_pWaveNode );

	// Link to new DocRoot Node
	if( pIDocRootNode )
	{
		m_pWaveNode = (CWaveNode *)pIDocRootNode;
		m_pWaveNode->AddRef();
	}

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CWaveRefNode Additional functions
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\DLSDesigner\WavePropPg.cpp ===
// WavePropPg.cpp : implementation file
//

#include "stdafx.h"
#include "dlsdesigner.h"
#include "WavePropPg.h"
#include "WaveNode.h"
#include "Wave.h"
#include "monoWave.h"
#include "Collection.h"
#include "instrument.h"
#include "region.h"
#include "WavePropPgMgr.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

#define BUFFER_64 64

class CRegion;
extern BOOL isValidNoteString(char * psz);
 
/////////////////////////////////////////////////////////////////////////////
// CWavePropPg property page

IMPLEMENT_DYNCREATE(CWavePropPg, CPropertyPage)

CWavePropPg::CWavePropPg() :
CPropertyPage(CWavePropPg::IDD),
CSliderCollection(2),
m_pWave(NULL),
m_pPropMgr(NULL),
m_fOneShot(true),  
m_fActivateLoop(false),   //TODO: this must be !m_fOneShot. Keep one variable.
m_fInitialUpdate(false),
m_bfTouched(0),
m_fNeedToDetach(FALSE),
m_bTouchedByProgram(false),
m_dwLoopStart(MINIMUM_VALID_LOOPSTART),
m_dwLoopLength(0),
m_bLockLoopLength(false),
m_bLockSelectionLength(false),
m_nSelectionStart(0),
m_nSelectionEnd(0),
m_bInLoopUpdate(false),
m_pmsFineTune(NULL)
{
	//{{AFX_DATA_INIT(CWavePropPg)
	m_fAllowCompression = FALSE;
	m_fAllowTruncation = FALSE;
	m_dwLength = 0;
	//}}AFX_DATA_INIT
	CSliderCollection::Init(this);
}

CWavePropPg::~CWavePropPg()
{
}

void CWavePropPg::SetObject(CWave* pWave)
{
	m_pWave = pWave; 
	
	if(pWave == NULL) // huh?
		return;

	m_fOneShot = (m_pWave->IsLooped() == false);
    m_fActivateLoop = !m_fOneShot;

	UpdateData(FALSE);
}


BOOL CWavePropPg::OnInitDialog()
{
	BOOL retval;

	m_bTouchedByProgram = true;
	retval = CDialog::OnInitDialog();
	m_bTouchedByProgram = false;

	m_LoopLengthSpin.SetRange(UD_MINVAL, UD_MAXVAL);
	m_LoopStartSpin.SetRange(UD_MINVAL, UD_MAXVAL);
	m_LoopEndSpin.SetRange(UD_MINVAL, UD_MAXVAL);
	m_SelectionStartSpin.SetRange(UD_MINVAL, UD_MAXVAL);
	m_SelectionLengthSpin.SetRange(UD_MINVAL, UD_MAXVAL);
	m_SelectionEndSpin.SetRange(UD_MINVAL, UD_MAXVAL);


	if(m_pWave && m_pWave->GetWaveEditor())
	{
		EnableSelectionControls(true);
		EnableControl(IDC_SELECTION_LENGTH_LOCK_CHECK, true);
	}
	else
	{
		EnableSelectionControls(false);
		EnableControl(IDC_SELECTION_LENGTH_LOCK_CHECK, false);
	}
	SetSelectionLengthLock(m_bLockSelectionLength);

	// create and hook up the sliders
	CSliderCollection::Free(); // refresh sliders after a page switch

	m_pmsFineTune = Insert(
		IDC_FINE_TUNE, //slider
		IDC_SEMI_TONES,    //edit box
		IDC_SEMI_TONES_SPIN,
		MYSLIDER_PITCHCENTS,
		0,
		IDS_UNDO_FINETUNE,
		&m_lFineTune);
    
	m_pmsAttenuation = Insert(
		IDC_ATTENUATION,   //slider
		IDC_DB_ATTENUATION,  //editbox
		IDC_DB_ATTENUATION_SPIN,
		MYSLIDER_VOLUME,
		0,
		IDS_UNDO_ATTENUATION,
		&m_lAttenuation);
	
	// Initialize the values.
	InitializeDialogValues();
	
	return retval;
}
/////////////////////////////////////////////////////////////////////////////
// CCollectionPropPg::EnableControls

void CWavePropPg::EnableControls() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

    EnableLoopControls(m_fActivateLoop);
}

void CWavePropPg::DoDataExchange(CDataExchange* pDX)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	
	CPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CWavePropPg)
	DDX_Control(pDX, IDC_SELECTION_START_SPIN, m_SelectionStartSpin);
	DDX_Control(pDX, IDC_SELECTION_LENGTH_SPIN, m_SelectionLengthSpin);
	DDX_Control(pDX, IDC_SELECTION_LENGTH_LOCK_CHECK, m_SelectionLengthLockCheck);
	DDX_Control(pDX, IDC_SELECTION_END_SPIN, m_SelectionEndSpin);
	DDX_Control(pDX, IDC_LOOP_START_SPIN, m_LoopStartSpin);
	DDX_Control(pDX, IDC_LOOP_LENGTH_SPIN, m_LoopLengthSpin);
	DDX_Control(pDX, IDC_LOOP_LENGTH_LOCK_CHECK, m_LoopLengthLockCheck);
	DDX_Control(pDX, IDC_LOOP_CHECK, m_LoopCheck);
	DDX_Control(pDX, IDC_LOOP_END_SPIN, m_LoopEndSpin);
	DDX_Control(pDX, IDC_LOOP_END, m_LoopEndEdit);
	DDX_Control(pDX, IDC_LOOP_START, m_LoopStartEdit);
	DDX_Control(pDX, IDC_LOOP_LENGTH, m_LoopLengthEdit);
	DDX_Control(pDX, IDC_ROOT_NOTE, m_RootNoteEdit);
	DDX_Control(pDX, IDC_ROOT_NOTE_SPIN, m_RootNoteSpin);
	DDX_Check(pDX, IDC_SAMPLE_COMPRESSION, m_fAllowCompression);
	DDX_Check(pDX, IDC_SAMPLE_TRUNCATION, m_fAllowTruncation);
	DDX_Text(pDX, IDC_LENGTH, m_dwLength);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CWavePropPg, CPropertyPage)
	//{{AFX_MSG_MAP(CWavePropPg)
	ON_WM_CREATE()
	ON_WM_DESTROY()
	ON_WM_HSCROLL()
	ON_EN_KILLFOCUS(IDC_ROOT_NOTE, OnKillfocusRootNote)
	ON_EN_KILLFOCUS(IDC_LOOP_LENGTH, OnKillfocusLoopLength)
	ON_EN_KILLFOCUS(IDC_LOOP_START, OnKillfocusLoopStart)
	ON_BN_CLICKED(IDC_SAMPLE_TRUNCATION, OnSampleTruncation)
	ON_BN_CLICKED(IDC_SAMPLE_COMPRESSION, OnSampleCompression)
	ON_MESSAGE(DM_VALIDATE,OnValidate)
	ON_NOTIFY(UDN_DELTAPOS, IDC_ROOT_NOTE_SPIN, OnDeltaposRootNoteSpin)
	ON_BN_CLICKED(IDC_LOOP_CHECK, OnLoopCheck)
	ON_EN_KILLFOCUS(IDC_LOOP_END, OnKillfocusLoopEnd)
	ON_NOTIFY(UDN_DELTAPOS, IDC_LOOP_END_SPIN, OnDeltaposLoopEndSpin)
	ON_BN_CLICKED(IDC_LOOP_LENGTH_LOCK_CHECK, OnLoopLengthLockCheck)
	ON_NOTIFY(UDN_DELTAPOS, IDC_LOOP_LENGTH_SPIN, OnDeltaposLoopLengthSpin)
	ON_NOTIFY(UDN_DELTAPOS, IDC_LOOP_START_SPIN, OnDeltaposLoopStartSpin)
	ON_EN_KILLFOCUS(IDC_SELECTION_END, OnKillfocusSelectionEnd)
	ON_NOTIFY(UDN_DELTAPOS, IDC_SELECTION_END_SPIN, OnDeltaposSelectionEndSpin)
	ON_EN_KILLFOCUS(IDC_SELECTION_LENGTH, OnKillfocusSelectionLength)
	ON_BN_CLICKED(IDC_SELECTION_LENGTH_LOCK_CHECK, OnSelectionLengthLockCheck)
	ON_NOTIFY(UDN_DELTAPOS, IDC_SELECTION_LENGTH_SPIN, OnDeltaposSelectionLengthSpin)
	ON_EN_KILLFOCUS(IDC_SELECTION_START, OnKillfocusSelectionStart)
	ON_NOTIFY(UDN_DELTAPOS, IDC_SELECTION_START_SPIN, OnDeltaposSelectionStartSpin)
	ON_BN_CLICKED(IDC_FORWARD_LOOP_RADIO, OnForwardLoopRadio)
	ON_BN_CLICKED(IDC_LOOP_AND_RELEASE_RADIO, OnLoopAndReleaseRadio)
	ON_WM_LBUTTONDBLCLK()
	//}}AFX_MSG_MAP
	ON_CONTROL_RANGE(EN_CHANGE, IDC_LOOP_START, IDC_ROOT_NOTE, OnEditChange)
	
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CWavePropPg message handlers

void CWavePropPg::OnEditChange( UINT nEditControl )
{
	if ( m_bTouchedByProgram )
		return;
	switch ( nEditControl )
	{
		case IDC_LOOP_START:
			m_bfTouched = fLOOP_START;
			break;
		case IDC_LOOP_LENGTH:
			m_bfTouched = fLOOP_LENGTH;
			break;
		case IDC_ROOT_NOTE:
			m_bfTouched |= fROOT_NOTE;
			break;
		default:
			break;
	}
}

BOOL CWavePropPg::OnSetActive() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);	

	bool bSetEditorAndSnap = true;
		   
    if (m_pWave)
    {
		CWaveCtrl* pWaveEditor = m_pWave->GetWaveEditor();
        InitializeDialogValues();
		if(pWaveEditor)
		{
			pWaveEditor->GetSelection(m_nSelectionStart, m_nSelectionEnd);
			bSetEditorAndSnap = false;
		}

        EnableControls();
    }
	
	if(m_pWave == NULL || (m_pWave && m_pWave->GetWaveEditor() == NULL))
	{
		EnableSelectionControls(false);
		EnableControl(IDC_SELECTION_LENGTH_LOCK_CHECK, false);
	}
	else
	{
		EnableSelectionControls(true);
		EnableControl(IDC_SELECTION_LENGTH_LOCK_CHECK, true);
	}
	
	SetSelectionLengthLock(m_bLockSelectionLength);
	SetSelection(m_nSelectionStart, m_nSelectionEnd, bSetEditorAndSnap, bSetEditorAndSnap);

	CWavePropPgMgr::dwLastSelPage = WAVE_PROP_PAGE;

	return CPropertyPage::OnSetActive();
}

int CWavePropPg::OnCreate(LPCREATESTRUCT lpCreateStruct) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	// Attach the window to the property page structure.
	// This has been done once already in the main application
	// since the main application owns the property sheet.
	// It needs to be done here so that the window handle can
	// be found in the DLLs handle map.
	if(!FromHandlePermanent(m_hWnd))
	{
		HWND hWnd = m_hWnd;
		m_hWnd = NULL;
		Attach( hWnd );

		m_fNeedToDetach = TRUE;
	}

	if (CPropertyPage::OnCreate(lpCreateStruct) == -1)
		return -1;
    
	return 0;
}

void CWavePropPg::OnDestroy() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	// Detach the window from the property page structure.
	// This will be done again by the main application since
	// it owns the property sheet.  It needs o be done here
	// so that the window handle can be removed from the
	// DLLs handle map.
	if( m_fNeedToDetach && m_hWnd != NULL )
	{
		HWND hWnd = m_hWnd;
		Detach();
		m_hWnd = hWnd;
	}

	CPropertyPage::OnDestroy();
}


void CWavePropPg::OnLoopCheck() 
{
    AFX_MANAGE_STATE(_afxModuleAddrThis);
	ASSERT(m_pWave);
	if(m_pWave == NULL)
		return;

	// Can't set a loop for a wave too short
	if(m_pWave->m_dwWaveLength < MINIMUM_VALID_LOOPLENGTH)
	{
		m_LoopCheck.SetCheck(0);
		EnableLoopTypeButtons(FALSE);
		return;
	}

	WSMPL waveWSMPL = m_pWave->GetWSMPL();

	CWaveCtrl* pWaveEditor = m_pWave->GetWaveEditor();

	// Check if the values in the edits are legal...
#if MINIMUM_VALID_LOOPSTART > 0
	if(m_dwLoopStart < MINIMUM_VALID_LOOPSTART || m_dwLoopLength < MINIMUM_VALID_LOOPLENGTH)
#else
	if(m_dwLoopLength < MINIMUM_VALID_LOOPLENGTH)
#endif
	{
		OnKillfocusLoopStart();
	}
	// Save the state for undo/redo
	else if(pWaveEditor)
	{
		if(FAILED(pWaveEditor->SaveStateForUndo(IDS_UNDO_LOOPSETTINGS)))
		{
			// Out Of Memory??
			CButton* pRadioBtn = (CButton*) GetDlgItem(IDC_LOOP_CHECK);
			if(pRadioBtn)
			{
				int nState = pRadioBtn->GetCheck();	
				if(nState == 0)
					m_LoopCheck.SetCheck(1);
				else
					m_LoopCheck.SetCheck(0);
			}
			return;
		}
	}

    CButton* pRadioBtn = (CButton*) GetDlgItem(IDC_LOOP_CHECK);
	if(pRadioBtn)
	{
		int nState = pRadioBtn->GetCheck();	
	
		switch(nState)
		{
			case 0:
			{
				m_fActivateLoop = false;
				EnableLoopControls(false);
                waveWSMPL.cSampleLoops = 0;
                m_pWave->SetLooped(false);
				break;
			}
		
			case 1:
			{
				m_fActivateLoop = true;
				EnableLoopControls(true);
                waveWSMPL.cSampleLoops = 1;		
                m_pWave->SetLooped(true);
				break;
			}
		}

        m_fOneShot = !m_fActivateLoop;

		m_pWave->SetWSMPL(waveWSMPL);

        //m_pWave->CopyWSMPToSMPL();
		m_pWave->UpdateWave();
		m_pWave->UpdateDummyInstrument();

		UpdatePlaybackSettingsInRegions();

		if(pWaveEditor)
		{
			pWaveEditor->InvalidateRect(NULL);
		}

	    // notify of change and set dirty flag
		m_pWave->NotifyWaveChange(true);
	}	
}

// ========================================================================
// ========================================================================

void CWavePropPg::EnableLoopControls(BOOL bEnable)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

    EnableControl(IDC_LOOP_START, bEnable);
	EnableControl(IDC_LOOP_START_SPIN, bEnable);
	EnableControl(IDC_LOOP_END, bEnable);
	EnableControl(IDC_LOOP_END_SPIN, bEnable);

	if(bEnable)
	{
		EnableControl(IDC_LOOP_LENGTH, !m_bLockLoopLength);
		EnableControl(IDC_LOOP_LENGTH_SPIN, !m_bLockLoopLength);
	}
	else
	{
		EnableControl(IDC_LOOP_LENGTH, bEnable);
		EnableControl(IDC_LOOP_LENGTH_SPIN, bEnable);
	}

	EnableControl(IDC_LOOP_LENGTH_LOCK_CHECK, bEnable);
	EnableLoopTypeButtons(bEnable);
}


void CWavePropPg::EnableSelectionControls(BOOL bEnable)
{
	EnableControl(IDC_SELECTION_START, bEnable);
	EnableControl(IDC_SELECTION_START_SPIN, bEnable);
	EnableControl(IDC_SELECTION_END, bEnable);
	EnableControl(IDC_SELECTION_END_SPIN, bEnable);

	if(bEnable)
	{
		EnableControl(IDC_SELECTION_LENGTH, !m_bLockSelectionLength);
		EnableControl(IDC_SELECTION_LENGTH_SPIN, !m_bLockSelectionLength);
	}
	else
	{
		EnableControl(IDC_SELECTION_LENGTH, bEnable);
		EnableControl(IDC_SELECTION_LENGTH_SPIN, bEnable);
	}

	EnableControl(IDC_SELECTION_LENGTH_LOCK_CHECK, bEnable);
}


void CWavePropPg::EnableControl(UINT ID, BOOL bEnable)
{
	CWnd* pCtrl = GetDlgItem(ID);
	if(pCtrl)
		pCtrl->EnableWindow(bEnable);
}


void CWavePropPg::InitializeDialogValues()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	m_fInitialUpdate = true;

	m_pmsFineTune->SetValue(this, m_lFineTune);
	m_pmsAttenuation->SetValue(this, m_lAttenuation);
	
    if (m_pWave)
    {
		WSMPL waveWSMPL =  m_pWave->GetWSMPL();

	    m_lFineTune = (long) waveWSMPL.sFineTune << 16;
	    m_lAttenuation = (long) waveWSMPL.lAttenuation;
        
        // set the sliders
	    m_pmsFineTune->SetValue(this, m_lFineTune);
	    m_pmsAttenuation->SetValue(this, m_lAttenuation);

		// Sample length
		m_dwLength = m_pWave->m_dwWaveLength;
		CWnd *pCtrl = GetDlgItem(IDC_LENGTH);    
		CString sText;
		sText.Format("%d", m_dwLength);
	    if(pCtrl)
	    {
		    pCtrl->SetWindowText(sText);
			pCtrl = NULL;
	    }

        //Now playback.
		WLOOP waveLoop = m_pWave->GetWLOOP();

#if MINIMUM_VALID_LOOPSTART > 0
		// Can't have a loop start at sample 0 can we?
		if(waveLoop.ulStart >= MINIMUM_VALID_LOOPSTART)
		{
			m_dwLoopStart = waveLoop.ulStart;
		}
		else
		{
			waveLoop.ulStart = m_dwLoopStart;
		}
#else
		m_dwLoopStart = waveLoop.ulStart;
#endif
		
		// Can't have a loop length less than MINIMUM_VALID_LOOPLENGTH can we?
		if(waveLoop.ulLength >= MINIMUM_VALID_LOOPLENGTH)
		{
			m_dwLoopLength = waveLoop.ulLength;
		}
		else if(m_pWave->m_dwWaveLength >= MINIMUM_VALID_LOOPLENGTH)
		{
			waveLoop.ulLength = m_pWave->m_dwWaveLength;
		}
		else
		{
			waveLoop.ulLength = MINIMUM_VALID_LOOPLENGTH;
		}

		if(waveLoop.ulLength >= MSSYNTH_LOOP_LIMIT && m_pWave->IsLooped() == false)
		{
			waveLoop.ulLength = MSSYNTH_LOOP_LIMIT - 1;
			m_dwLoopLength = waveLoop.ulLength;
		}


        m_fAllowTruncation = !(waveWSMPL.fulOptions & F_WSMP_NO_TRUNCATION);
	    m_fAllowCompression = !(waveWSMPL.fulOptions & F_WSMP_NO_COMPRESSION);
        m_fOneShot = (m_pWave->IsLooped() == false);
        m_fActivateLoop = !m_fOneShot;

		// Set the loop type button states
		SetWaveLoopType(waveLoop.ulType);

		// Update the modified wave WSMPL and WLOOP values
		m_pWave->SetWSMPL(waveWSMPL);
		m_pWave->SetWLOOP(waveLoop);

        // set root note data
		ASSERT(m_RootNoteSpin.GetSafeHwnd());
        m_RootNoteSpin.SetRange(0, 127);
		m_RootNoteSpin.SetPos((long) waveWSMPL.usUnityNote);
		ASSERT(m_RootNoteEdit.GetSafeHwnd());
		UpdateRootNoteText(waveWSMPL.usUnityNote);

        //set text in the edit boxes.
	    char text[BUFFER_64];
	    sprintf(text, "%d", m_dwLoopLength);
		m_bTouchedByProgram = true;
		m_LoopLengthEdit.SetWindowText(text);
		m_bTouchedByProgram = false;

        sprintf(text, "%d", m_dwLoopStart);
		m_bTouchedByProgram = true;
		m_LoopStartEdit.SetWindowText(text);
		m_bTouchedByProgram = false;

		sprintf(text, "%d", (m_dwLoopStart + m_dwLoopLength - 1));
		m_bTouchedByProgram = true;
		m_LoopEndEdit.SetWindowText(text);
		m_bTouchedByProgram = false;


        // set the checkboxes
        CButton* pBtn = (CButton *) GetDlgItem(IDC_ONE_SHOT);
	    if(pBtn)
	    {
		    pBtn->SetCheck(m_fOneShot);
	    }

	    pBtn = (CButton *) GetDlgItem(IDC_LOOP_CHECK);
	    if(pBtn)
	    {
		    pBtn->SetCheck(!m_fOneShot);
	    }
		EnableLoopControls(!m_fOneShot);

        //Now the compression and truncation checkboxes.
	    pBtn = (CButton *) GetDlgItem(IDC_SAMPLE_TRUNCATION);
	    if(pBtn)
	    {
		    pBtn->SetCheck(m_fAllowTruncation);
	    }

	    pBtn = (CButton *) GetDlgItem(IDC_SAMPLE_COMPRESSION);
	    if(pBtn)
	    {
		    pBtn->SetCheck(m_fAllowCompression);
	    }

    } //if m_pWave
	m_fInitialUpdate = false;
}

void CWavePropPg::UpdateDbAttenuation() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	if(m_fInitialUpdate) 
	{
		return;
	}

	BOOL bUpdate = FALSE;
	bUpdate = UpdateData(TRUE);	
	
    if(bUpdate && m_pWave)
    {
		WSMPL waveWSMPL =  m_pWave->GetWSMPL();
		if (waveWSMPL.lAttenuation != m_lAttenuation)
        {
			CWaveCtrl* pWaveEditor = m_pWave->GetWaveEditor();
			if(pWaveEditor)
			{
				if(FAILED(pWaveEditor->SaveStateForUndo(IDS_UNDO_ATTENUATION)))
				{
					// Out Of Memory??
					m_lAttenuation = (long) waveWSMPL.lAttenuation;
					m_pmsAttenuation->SetValue(this, m_lAttenuation);
					UpdateData(FALSE);
					return;
				}
			}
		}
		else
			return;

        waveWSMPL.lAttenuation = m_lAttenuation;

		// Update the wave SMPL values
		m_pWave->SetWSMPL(waveWSMPL);
        m_pWave->CopyWSMPToSMPL();
            
		m_pWave->UpdateWave();
		// Change the values in all the regions that refer to this wave 
        // and have not selected to override wave properties.
        UpdateAttenuationInRegions();

		m_pWave->UpdateDummyInstrument();
		m_pWave->NotifyWaveChange(true);
    }
}

void CWavePropPg::UpdateFineTune() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);


	if ( m_fInitialUpdate ) 
		return;

    BOOL bUpdate;
	bUpdate = UpdateData(TRUE);	

	if(bUpdate && m_pWave)
	{		
		WSMPL waveWSMPL =  m_pWave->GetWSMPL();
		if(waveWSMPL.sFineTune != (WORD) (m_lFineTune >> 16))
		{
			CWaveCtrl* pWaveEditor = m_pWave->GetWaveEditor();
			if(pWaveEditor)
			{
				if(FAILED(pWaveEditor->SaveStateForUndo(IDS_UNDO_FINETUNE)))
				{
					// Out Of Memory??
					m_lFineTune = (long) waveWSMPL.sFineTune << 16;
					m_pmsFineTune->SetValue(this, m_lFineTune);
					UpdateData(FALSE);
					return;
				}
			}
		}
		else
			return;

		waveWSMPL.sFineTune = (WORD) (m_lFineTune >> 16);

		// Update the wave WSMPL values
		m_pWave->SetWSMPL(waveWSMPL);
        m_pWave->CopyWSMPToSMPL();

		m_pWave->UpdateWave();

        // Change the values in all the regions that refer to this wave 
        // and have not selected to override wave properties.
        UpdateFineTuneInRegions();

		m_pWave->UpdateDummyInstrument();
		m_pWave->NotifyWaveChange(true);
	}    	
}

void CWavePropPg::OnHScroll(UINT nSBCode, UINT nPos, CScrollBar* pScrollBar) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	CSliderCollection::OnHScroll(nSBCode, nPos, pScrollBar);
	CPropertyPage::OnHScroll(nSBCode, nPos, pScrollBar);
}

LRESULT CWavePropPg::OnValidate(UINT wParam, long lParam)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	PostValidate(wParam);
	return 0;
}

void CWavePropPg::OnKillfocusRootNote() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	if(m_pWave == NULL)
		return;

	USHORT usNewNote = GetNoteInEditBox();
	WSMPL waveWSMPL = m_pWave->GetWSMPL();
	if(FAILED(UpdateRootNote(usNewNote)))
	{
		UpdateRootNoteText(waveWSMPL.usUnityNote);
	}

	m_bfTouched &= ~fROOT_NOTE;
}

HRESULT CWavePropPg::UpdateRootNote(USHORT usNewNote)
{
	if (!m_pWave) 
		return E_FAIL;

	WSMPL waveWSMPL =  m_pWave->GetWSMPL();

	// update the wave if the note's different
	if (usNewNote != waveWSMPL.usUnityNote) 
	{
		CWaveCtrl* pWaveEditor = m_pWave->GetWaveEditor();
		// Save the state for undo/redo
		if(pWaveEditor)
		{
			if(FAILED(pWaveEditor->SaveStateForUndo(IDS_UNDO_ROOTNOTE)))
			{
				// Out of Memory??
				return E_FAIL;	
			}
		}

		waveWSMPL.usUnityNote = usNewNote;
		m_pWave->SetWSMPL(waveWSMPL);
		m_pWave->CopyWSMPToSMPL();
		m_pWave->UpdateWave();
		// update the regions that use this wave.
		UpdateRootNoteInRegions();
		m_pWave->UpdateDummyInstrument();
		m_pWave->NotifyWaveChange(true);
	}

	return S_OK;
}

void CWavePropPg::UpdateRootNoteText(int note)
{
	ASSERT(note >= 0 && note <= 127);
	char pszNote[20];
	notetostring((DWORD)note, pszNote);
	m_RootNoteEdit.SetWindowText(pszNote);
}

// get the note typed by the user in the edit box, if valid. if not valid,
// returns the current unity note for the wave.
USHORT CWavePropPg::GetNoteInEditBox()
{
	ASSERT(m_pWave);
	
	WSMPL waveWSMPL = m_pWave->GetWSMPL();

	USHORT usNote;
	CString strNote;
	m_RootNoteEdit.GetWindowText(strNote);
	LPSTR lpsBuf = strNote.GetBuffer(3);
	if (isValidNoteString(lpsBuf)) 
	{
		usNote = stringtonote(lpsBuf);
	}
	else 
	{
		usNote = waveWSMPL.usUnityNote;
	}
	
	// reset the note in the edit box
	char szNote[20];
	notetostring(usNote, szNote);
	m_bTouchedByProgram = true;
	m_RootNoteEdit.SetWindowText(szNote);
	m_bTouchedByProgram = false;
	
	
	return usNote;
}

HRESULT CWavePropPg::ValidateAndSetLoopValues(DWORD dwLoopStart, DWORD dwLoopLength, bool bSaveUndoState)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	HRESULT hr = S_OK;

	ASSERT(m_pWave);
	if(m_pWave == NULL)
		return E_FAIL;

	WLOOP waveLoop = m_pWave->GetWLOOP();
	CWaveCtrl* pWaveEditor = m_pWave->GetWaveEditor();
	CWnd* pWndWithFocus = GetFocus();

	if(m_bInLoopUpdate)
	{
		TRACE("\nBusy doing wave loop update!\n");
		return E_FAIL;
	}

	BOOL bWaveWasPlaying = m_pWave->WaveIsPlaying();

	m_bInLoopUpdate = true;
	TRACE("\nSetting busy signal for wave loop update!\n");

	// validate loop values
	hr = m_pWave->HrValidateLoopValues(dwLoopStart, dwLoopLength, m_bLockLoopLength);

	// Set the actual values only if they're different
	if(SUCCEEDED(hr) && (m_dwLoopStart != dwLoopStart || m_dwLoopLength != dwLoopLength))
	{
		// Save the undo state first
		if(pWaveEditor && bSaveUndoState)
		{
			if(FAILED(pWaveEditor->SaveStateForUndo(IDS_UNDO_LOOPPOINTS)))
			{
				// Out Of Memory??
				hr = E_FAIL;
			}
		}
	}

	// Set the values now
	if(SUCCEEDED(hr))
	{
		m_dwLoopStart = dwLoopStart;
		waveLoop.ulStart = m_dwLoopStart;

		m_dwLoopLength = dwLoopLength;
		waveLoop.ulLength = dwLoopLength;
	}

	CString sWindowText;
	sWindowText.Format("%d", m_dwLoopStart);
	m_LoopStartEdit.SetWindowText(sWindowText);

	sWindowText.Format("%d", (m_dwLoopStart + m_dwLoopLength - 1));
	m_LoopEndEdit.SetWindowText(sWindowText);
	
	sWindowText.Format("%d", m_dwLoopLength);
	m_LoopLengthEdit.SetWindowText(sWindowText);

	if(FAILED(hr))
	{
		m_bInLoopUpdate = false;
		UpdateData(FALSE);
		return hr;
	}

	UpdateData(TRUE);

	m_pWave->SetWLOOP(waveLoop);

	// Copy the loop information to the legacy structure
	m_pWave->CopyWSMPToSMPL();

	// the compressed loop also gets modified
	m_pWave->RememberLoopAfterCompression();

	// Update the wave in all the regions that reference it
	m_pWave->UpdateWave();
	m_pWave->UpdateLoopStartAndLengthInRegions();
	m_pWave->UpdateDummyInstrument();
	
	// notify of change and set dirty flag
	m_pWave->NotifyWaveChange(true);

	if (pWaveEditor)
		pWaveEditor->InvalidateRect(NULL);

	m_bInLoopUpdate = false;
	
	if(pWndWithFocus)
	{
		pWndWithFocus->SetFocus();
	}

	if(bWaveWasPlaying)
	{
        CWaveNode* pWaveNode = m_pWave->GetNode();
        ASSERT(pWaveNode);
        if(pWaveNode)
        {
            pWaveNode->Stop(TRUE);
		    pWaveNode->Play(FALSE);
        }
	}

	return hr;
}



// ========================================================================
// ========================================================================
void CWavePropPg::OnSampleTruncation() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	ASSERT(m_pWave);

    if (m_pWave)
    {
		WSMPL waveWSMPL = m_pWave->GetWSMPL();

	    BOOL bUpdate = false;
	    bUpdate = UpdateData(TRUE);	

	    if(bUpdate)
	    {
			CWaveCtrl* pWaveEditor = m_pWave->GetWaveEditor();
			// Save the state for undo/redo
			if(pWaveEditor)
			{
				if(FAILED(pWaveEditor->SaveStateForUndo(IDS_UNDO_OVERRIDE_ALLOWTRUNCATION)))
				{
					// Couldn't save the undo state!! Out Of Memory??
					m_fAllowTruncation = !m_fAllowTruncation;
					UpdateData(FALSE);
					return;
				}
			}


		    if(m_fAllowTruncation)
            {
			    waveWSMPL.fulOptions &= ~F_WSMP_NO_TRUNCATION;
		    }
		    else
		    {
			    waveWSMPL.fulOptions |= F_WSMP_NO_TRUNCATION;
		    }
			
			m_pWave->SetWSMPL(waveWSMPL);

            // update regions that use this wave
			UpdateSampleTruncationInRegions();

			// notify of change and set dirty flag
			m_pWave->NotifyWaveChange(true);
	    }
    }
}

// ========================================================================
// ========================================================================
void CWavePropPg::OnSampleCompression() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

    if (m_pWave)
    {
		WSMPL waveWSMPL = m_pWave->GetWSMPL();

	    BOOL bUpdate = false;
	    bUpdate = UpdateData(TRUE);	
		if(bUpdate)
	    {
			CWaveCtrl* pWaveEditor = m_pWave->GetWaveEditor();
			// Save the state for undo/redo
			if(pWaveEditor)
			{
				if(FAILED(pWaveEditor->SaveStateForUndo(IDS_UNDO_OVERRIDE_ALLOWCOMPRESSION)))
				{
					// Couldn't save the undo state!! Out Of Memory??
					m_fAllowCompression = !m_fAllowCompression;
					UpdateData(FALSE);
					return;
				}
			}

		    if(m_fAllowCompression)
		    {
			    waveWSMPL.fulOptions &= ~F_WSMP_NO_COMPRESSION;
            }
            else
		    {		
			    waveWSMPL.fulOptions |= F_WSMP_NO_COMPRESSION;
		    }

			m_pWave->SetWSMPL(waveWSMPL);

            // update regions that use this wave
            UpdateSampleCompressionInRegions();

		    // notify of change and set dirty flag
			m_pWave->NotifyWaveChange(true);
	    }
    }	
}


// ========================================================================
// UpdateAttenuationInRegions
// ========================================================================
void CWavePropPg::UpdateAttenuationInRegions()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
    
	// Go thru all regions and chenge values in the regions that
    // refer to the wave being edited if the override flag is not set.
	CCollection* pCollection = m_pWave->GetCollection();
	if(pCollection == NULL)
	{
		return;
	}

	WSMPL waveWSMPL = m_pWave->GetWSMPL();

    CInstrument * pInstrument = pCollection->m_Instruments.GetHead();	
    while (pInstrument) // for all instruments go thru all regions
    {

        CRegion * pRegion = pInstrument->m_Regions.GetHead();
        while (pRegion)
        {
			// Do we refer to the same WaveNode?
            if (pRegion->GetWaveNode() == m_pWave->GetNode())
            {
                // is override attenuation set?
                if (!pRegion->m_bOverrideWaveAttenuation)
                {
                    pRegion->m_rWSMP.lAttenuation = waveWSMPL.lAttenuation;
                    // updatesynth. 
                    ASSERT(pRegion->m_pInstrument);
                    ASSERT(pRegion->m_pInstrument->m_pCollection);
        			pRegion->m_pInstrument->UpdateInstrument();
					pRegion->m_pInstrument->RefreshRegion();
                }
            }

            pRegion = pRegion->GetNext();

        } // while pregion

        pInstrument = pInstrument->GetNext();
    }
}

// ========================================================================
// UpdateFineTuneInRegions
// ========================================================================
void CWavePropPg::UpdateFineTuneInRegions()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
    // Go thru all regions and chenge values in the regions that
    // refer to the wave being edited if the override flag is not set.
	CCollection* pCollection = m_pWave->GetCollection();
	if(!pCollection)
	{
		return;
	}
    
	CInstrument * pInstrument = pCollection->m_Instruments.GetHead();

	WSMPL waveWSMPL = m_pWave->GetWSMPL();

    while (pInstrument) // for all instruments go thru all regions
    {
        CRegion * pRegion = pInstrument->m_Regions.GetHead();
        while (pRegion)
        {
            if (pRegion->GetWaveNode() == m_pWave->GetNode())
            {
                // is override attenuation set?
                if (!pRegion->m_bOverrideWaveFineTune)
                {
                    pRegion->m_rWSMP.sFineTune = waveWSMPL.sFineTune;
                    // updatesynth. 
                    ASSERT(pRegion->m_pInstrument);
                    ASSERT(pRegion->m_pInstrument->m_pCollection);
        			pRegion->m_pInstrument->UpdateInstrument();
                }
            }

            pRegion = pRegion->GetNext();

        } // while pregion

        pInstrument = pInstrument->GetNext();
    }
}

// ========================================================================
// UpdateSampleTruncationInRegions
// ========================================================================
void CWavePropPg::UpdateSampleTruncationInRegions()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	ASSERT(m_pWave);
	if(m_pWave == NULL)
	{
		return;
	}
    
	// Go thru all regions and chenge values in the regions that
    // refer to the wave being edited if the override flag is not set.
	CCollection* pCollection = m_pWave->GetCollection();
	if(!pCollection)
	{
		return;
	}

	WSMPL waveWSMPL = m_pWave->GetWSMPL();

    CInstrument * pInstrument = pCollection->m_Instruments.GetHead();

    while (pInstrument) // for all instruments go thru all regions
    {

        CRegion * pRegion = pInstrument->m_Regions.GetHead();
        while (pRegion)
        {
            if (pRegion->GetWaveNode() == m_pWave->GetNode())
            {
                // is override attenuation set?
                if (!pRegion->m_bOverrideWaveMoreSettings)
                {
                    pRegion->m_rWSMP.fulOptions = waveWSMPL.fulOptions;
                    // updatesynth. 
                    ASSERT(pRegion->m_pInstrument);
                    ASSERT(pRegion->m_pInstrument->m_pCollection);
        			pRegion->m_pInstrument->UpdateInstrument();
                }
            }

            pRegion = pRegion->GetNext();

        } // while pregion

        pInstrument = pInstrument->GetNext();
    }
}

// ========================================================================
// UpdateSampleCompressionInRegions
// ========================================================================
void CWavePropPg::UpdateSampleCompressionInRegions()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	ASSERT(m_pWave);
	if(!m_pWave)
	{
		return;
	}

    // Go thru all regions and chenge values in the regions that
    // refer to the wave being edited if the override flag is not set.
	CCollection* pCollection = m_pWave->GetCollection();
	if(!pCollection)
	{
		return;
	}

	WSMPL waveWSMPL = m_pWave->GetWSMPL();

    CInstrument* pInstrument = pCollection->m_Instruments.GetHead();

    while (pInstrument) // for all instruments go thru all regions
    {

        CRegion * pRegion = pInstrument->m_Regions.GetHead();
        while (pRegion)
        {
            if (pRegion->GetWaveNode() == m_pWave->GetNode())
            {
                // is override attenuation set?
                if (!pRegion->m_bOverrideWaveMoreSettings)
                {
                    pRegion->m_rWSMP.fulOptions = waveWSMPL.fulOptions;
                    // updatesynth. 
                    ASSERT(pRegion->m_pInstrument);
                    ASSERT(pRegion->m_pInstrument->m_pCollection);
        			pRegion->m_pInstrument->UpdateInstrument();
                }
            }

            pRegion = pRegion->GetNext();

        } // while pregion

        pInstrument = pInstrument->GetNext();
    }
}

// ========================================================================
// UpdateRootNoteInRegions
// ========================================================================
void CWavePropPg::UpdateRootNoteInRegions()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	ASSERT(m_pWave);

	if(!m_pWave)
	{
		return;
	}

    // Go thru all regions and chenge values in the regions that
    // refer to the wave being edited if the override flag is not set.
	CCollection* pCollection = m_pWave->GetCollection();
	if(!pCollection)
	{
		return;
	}
    
	WSMPL waveWSMPL = m_pWave->GetWSMPL();

    CInstrument * pInstrument = pCollection->m_Instruments.GetHead();
    while (pInstrument) // for all instruments go thru all regions
    {
        CRegion * pRegion = pInstrument->m_Regions.GetHead();
        while (pRegion)
        {
            if (pRegion->GetWaveNode() == m_pWave->GetNode())
            {
                // is override attenuation set?
                if (!pRegion->m_bOverrideWaveRootNote)
                {
                    pRegion->m_rWSMP.usUnityNote = waveWSMPL.usUnityNote;
					pInstrument->RefreshUI(true);
                    // updatesynth. 
                    ASSERT(pRegion->m_pInstrument);
                    ASSERT(pRegion->m_pInstrument->m_pCollection);
        			pRegion->m_pInstrument->UpdateInstrument();
                }
            }

            pRegion = pRegion->GetNext();

        } // while pregion

        pInstrument = pInstrument->GetNext();
    }
}


// ========================================================================
// UpdatePlaybackSettingsInRegions
// ========================================================================
void CWavePropPg::UpdatePlaybackSettingsInRegions()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	if(!m_pWave)
	{
		return;
	}

    // Go thru all regions and chenge values in the regions that
    // refer to the wave being edited if the override flag is not set.
	CCollection* pCollection = m_pWave->GetCollection();
	if(!pCollection)
	{
		return;
	}

    CInstrument * pInstrument = pCollection->m_Instruments.GetHead();
    while (pInstrument) // for all instruments go thru all regions
    {
        CRegion * pRegion = pInstrument->m_Regions.GetHead();
        while (pRegion)
        {
			if (pRegion->GetWaveNode() == m_pWave->GetNode())
			{
				// is override playback settings set?
				if (!pRegion->m_bOverrideWaveMoreSettings)
				{
					WSMPL regionWaveWSMPL = pRegion->m_pWave->GetWSMPL();
					WLOOP regionWaveLoop = pRegion->m_pWave->GetWLOOP();

					pRegion->m_rWSMP.cSampleLoops = regionWaveWSMPL.cSampleLoops;
					memcpy(&pRegion->m_rWLOOP, &regionWaveLoop , sizeof(pRegion->m_rWLOOP));
					// update the synth.
					ASSERT(pRegion->m_pInstrument);
        			pRegion->m_pInstrument->UpdateInstrument();
				}
			}
            pRegion = pRegion->GetNext();
        } // while pregion
        pInstrument = pInstrument->GetNext();
    }
}


void CWavePropPg::PostValidate(UINT	nControl)
{
	m_pPropMgr->ShowPropSheet();
	CWnd * pWnd = GetDlgItem(nControl);
	if (IsWindow(pWnd->GetSafeHwnd()))
    {
        pWnd->SetFocus();
        ((CEdit *)pWnd)->SetSel(0, -1);
    }
}

void CWavePropPg::OnDeltaposRootNoteSpin(NMHDR* pNMHDR, LRESULT* pResult) 
{
	NM_UPDOWN* pNMUpDown = (NM_UPDOWN*)pNMHDR;
	
	if (m_bTouchedByProgram) return;

	USHORT usNote = GetNoteInEditBox();

	int nNewPos = usNote + pNMUpDown->iDelta;
	
	if (nNewPos < 0) nNewPos = 0; else if (nNewPos > 127) nNewPos = 127;
	*pResult = 0;
	
	if(SUCCEEDED(UpdateRootNote((USHORT)nNewPos)))
		UpdateRootNoteText(nNewPos);
}

void CWavePropPg::OnKillfocusLoopStart() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	DWORD dwLoopStart = GetDlgItemInt(IDC_LOOP_START);
	DWORD dwLoopEnd = GetDlgItemInt(IDC_LOOP_END);
	DWORD dwLoopLength = m_dwLoopLength;
	
	if(!m_bLockLoopLength)
		dwLoopLength = dwLoopEnd - dwLoopStart + 1;

	if((int)dwLoopLength < MINIMUM_VALID_LOOPLENGTH)
		dwLoopLength = MINIMUM_VALID_LOOPLENGTH;

	if(dwLoopStart + dwLoopLength > m_pWave->m_dwWaveLength)
		dwLoopStart = m_pWave->m_dwWaveLength - dwLoopLength;

	if(m_bLockLoopLength)
		dwLoopEnd = dwLoopStart + m_dwLoopLength - 1;

	if(m_bLockLoopLength && (dwLoopStart + dwLoopLength) > m_pWave->m_dwWaveLength - 1)
	{
		CString sWindowText;
		sWindowText.Format("%d", m_dwLoopStart);
		m_LoopStartEdit.SetWindowText(sWindowText);
		return;
	}

	ValidateAndSetLoopValues(dwLoopStart, dwLoopLength);
}

void CWavePropPg::OnKillfocusLoopLength() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	
	CString sLoopValue;
	
	m_LoopLengthEdit.GetWindowText(sLoopValue);
	DWORD dwLoopLength = (DWORD)_ttol(sLoopValue);

	ValidateAndSetLoopValues(m_dwLoopStart, dwLoopLength);
}

void CWavePropPg::OnKillfocusLoopEnd() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	
	CString sLoopValue;
	m_LoopEndEdit.GetWindowText(sLoopValue);
	DWORD dwLoopEnd = (DWORD)_ttol(sLoopValue);

	if(dwLoopEnd > m_pWave->m_dwWaveLength - 1)
		dwLoopEnd = m_pWave->m_dwWaveLength - 1;
	// Always false
	//else if(dwLoopEnd < 0)
	//	dwLoopEnd = 0;

	
	DWORD dwLoopStart = m_dwLoopStart;
	DWORD dwLoopLength = m_dwLoopLength;

	// If the length is locked the start point gets modified;
	// else the length is adjusted for the end point
	if(m_bLockLoopLength)
		dwLoopStart = dwLoopEnd - (m_dwLoopLength - 1);
	else
		dwLoopLength = abs(dwLoopEnd - dwLoopStart + 1);

	if(m_bLockLoopLength && (int)dwLoopStart < 0)
	{
		CString sWindowText;
		sWindowText.Format("%d", (m_dwLoopStart + m_dwLoopLength));
		m_LoopEndEdit.SetWindowText(sWindowText);
		return;
	}
		
	ValidateAndSetLoopValues(dwLoopStart, dwLoopLength);
}

void CWavePropPg::OnDeltaposLoopEndSpin(NMHDR* pNMHDR, LRESULT* pResult) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	NM_UPDOWN* pNMUpDown = (NM_UPDOWN*)pNMHDR;

	// If the length is locked the start point gets modified;
	// else the length is adjusted for the end point
	if(m_bLockLoopLength)
		OnDeltaposLoopStartSpin(pNMHDR, pResult);
	else
		OnDeltaposLoopLengthSpin(pNMHDR, pResult);

	*pResult = 1;
}

void CWavePropPg::OnLoopLengthLockCheck() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	m_bLockLoopLength = m_LoopLengthLockCheck.GetCheck() != 0;

	// If length is locked don't allow the edit
	if(m_bLockLoopLength == 1)
	{
		m_LoopLengthEdit.EnableWindow(false);
		m_LoopLengthSpin.EnableWindow(false);
	}
	else
	{
		m_LoopLengthEdit.EnableWindow(true);
		m_LoopLengthSpin.EnableWindow(true);
	}
}

void CWavePropPg::OnDeltaposLoopLengthSpin(NMHDR* pNMHDR, LRESULT* pResult) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	NM_UPDOWN* pNMUpDown = (NM_UPDOWN*)pNMHDR;
	int iDelta = pNMUpDown->iDelta;
	
	DWORD dwLoopLength = m_dwLoopLength + iDelta;
	if((int)dwLoopLength < MINIMUM_VALID_LOOPLENGTH)
		dwLoopLength = MINIMUM_VALID_LOOPLENGTH;
	else if((m_dwLoopStart + dwLoopLength) > m_pWave->m_dwWaveLength)
		dwLoopLength = m_pWave->m_dwWaveLength - m_dwLoopStart;

	CString sLoopValue;
	m_LoopStartEdit.GetWindowText(sLoopValue);
	DWORD dwLoopStart = (DWORD)_ttol(sLoopValue);

	ValidateAndSetLoopValues(dwLoopStart, dwLoopLength);
	
	*pResult = 1;
}

void CWavePropPg::OnDeltaposLoopStartSpin(NMHDR* pNMHDR, LRESULT* pResult) 
{
	NM_UPDOWN* pNMUpDown = (NM_UPDOWN*)pNMHDR;
	int iDelta = pNMUpDown->iDelta;

	DWORD dwLoopStart = m_dwLoopStart + iDelta;
	DWORD dwLoopLength = m_dwLoopLength;
	if(!m_bLockLoopLength)
	{
		dwLoopLength -= iDelta;
		if((int)dwLoopLength < MINIMUM_VALID_LOOPLENGTH)
			dwLoopLength = MINIMUM_VALID_LOOPLENGTH;
	}

	if((int)dwLoopStart < MINIMUM_VALID_LOOPSTART)
		dwLoopStart = MINIMUM_VALID_LOOPSTART;
	
	if(dwLoopStart + dwLoopLength > m_pWave->m_dwWaveLength)
		dwLoopStart = m_pWave->m_dwWaveLength - dwLoopLength;
		
	ValidateAndSetLoopValues(dwLoopStart, dwLoopLength);
	
	*pResult = 1;
}

void CWavePropPg::OnKillfocusSelectionEnd() 
{
	int nSelectionEnd = GetDlgItemInt(IDC_SELECTION_END);
	if(m_pWave->m_dwWaveLength == 0)
		nSelectionEnd = m_nSelectionEnd;

	m_pWave->ConstrainToSelectionBoundaries(nSelectionEnd);

	int nSelectionStart = m_nSelectionStart;
	if (nSelectionEnd < nSelectionStart)
		nSelectionStart = nSelectionEnd;

	if(m_bLockSelectionLength)
		nSelectionStart = nSelectionEnd - (m_nSelectionEnd - m_nSelectionStart);
	
	SetSelection(nSelectionStart, nSelectionEnd);
}

void CWavePropPg::OnDeltaposSelectionEndSpin(NMHDR* pNMHDR, LRESULT* pResult) 
{
	NM_UPDOWN* pNMUpDown = (NM_UPDOWN*)pNMHDR;
	int iDelta = pNMUpDown->iDelta;
	if(m_pWave->m_dwWaveLength == 0)
		iDelta = 0;

	int nSelectionEnd = m_nSelectionEnd;
	nSelectionEnd += iDelta;

	m_pWave->ConstrainToSelectionBoundaries(nSelectionEnd);

	int nSelectionStart = m_nSelectionStart;
	if (nSelectionEnd < nSelectionStart)
		nSelectionStart = nSelectionEnd;

	if(m_bLockSelectionLength)
		nSelectionStart = nSelectionEnd - (m_nSelectionEnd - m_nSelectionStart);

	// Check for Snap
	EnsureSnap(nSelectionEnd, (iDelta < 0) ? SNAP_BACKWARD : SNAP_FORWARD);

	SetSelection(nSelectionStart, nSelectionEnd, true, false);
	
	*pResult = 1;
}

void CWavePropPg::OnKillfocusSelectionLength() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	int nSelectionLength = GetDlgItemInt(IDC_SELECTION_LENGTH);
	if(m_pWave->m_dwWaveLength == 0)
		nSelectionLength = 0;

	ConstrainSelectionLength(nSelectionLength);
	SetSelection(m_nSelectionStart, m_nSelectionStart + nSelectionLength - 1);
}

void CWavePropPg::OnSelectionLengthLockCheck() 
{
	m_bLockSelectionLength = m_SelectionLengthLockCheck.GetCheck() != 0;
	
	// Turn SnapToZero On/Off
	if(m_pWave)
	{
		const CWaveNode* pWaveNode = m_pWave->GetNode();
		if(pWaveNode)
		{
			CDLSComponent* pComponent = pWaveNode->GetComponent();
			ASSERT(pComponent);
			
			pComponent->SetSnapToZero(!m_bLockSelectionLength);
		}
	}

	SetSelectionLengthLock(m_bLockSelectionLength);
}

void CWavePropPg::OnDeltaposSelectionLengthSpin(NMHDR* pNMHDR, LRESULT* pResult) 
{
	NM_UPDOWN* pNMUpDown = (NM_UPDOWN*)pNMHDR;
	int iDelta = pNMUpDown->iDelta;

	if(m_pWave->m_dwWaveLength == 0)
		iDelta = 0;

	int nSelectionLength  = m_nSelectionEnd - m_nSelectionStart;
	nSelectionLength += iDelta;

	ConstrainSelectionLength(nSelectionLength);
	int nSelectionEnd = m_nSelectionStart + nSelectionLength;

	// Check for Snap
	EnsureSnap(nSelectionEnd, (iDelta < 0) ? SNAP_BACKWARD : SNAP_FORWARD);

	SetSelection(m_nSelectionStart, nSelectionEnd, true, false);
	*pResult = 1;
}

void CWavePropPg::OnKillfocusSelectionStart() 
{
	int nSelectionStart = GetDlgItemInt(IDC_SELECTION_START);
	if(m_pWave->m_dwWaveLength == 0)
		nSelectionStart = m_nSelectionStart;

	m_pWave->ConstrainToSelectionBoundaries(nSelectionStart);

	int nSelectionEnd = m_nSelectionEnd;
	if (nSelectionStart > nSelectionEnd)
		nSelectionEnd = nSelectionStart;

	if (m_bLockSelectionLength && ((m_nSelectionEnd - m_nSelectionStart) + nSelectionStart < (int)m_pWave->m_dwWaveLength))
		nSelectionEnd = (m_nSelectionEnd - m_nSelectionStart) + nSelectionStart;

	SetSelection(nSelectionStart, nSelectionEnd);
}

void CWavePropPg::OnDeltaposSelectionStartSpin(NMHDR* pNMHDR, LRESULT* pResult) 
{
	NM_UPDOWN* pNMUpDown = (NM_UPDOWN*)pNMHDR;
	int iDelta = pNMUpDown->iDelta;

	if(m_pWave->m_dwWaveLength == 0)
	{
		iDelta = 0;
	}

	int nSelectionStart = m_nSelectionStart+iDelta;
	m_pWave->ConstrainToSelectionBoundaries(nSelectionStart);

	int nSelectionEnd = m_nSelectionEnd;
	if (nSelectionStart > nSelectionEnd)
		nSelectionEnd = nSelectionStart;

	if(m_bLockSelectionLength)
		nSelectionEnd = nSelectionStart + (m_nSelectionEnd - m_nSelectionStart);

	int nSelMax = m_pWave->m_dwWaveLength-m_pWave->GetDwDecompressedStart(true);
	if(m_bLockSelectionLength && nSelectionEnd > nSelMax-1)
	{
		nSelectionEnd = nSelMax-1;
		nSelectionStart = nSelectionEnd - (m_nSelectionEnd - m_nSelectionStart);
	}

	// Check for Snap
	EnsureSnap(nSelectionStart, (iDelta < 0) ? SNAP_BACKWARD : SNAP_FORWARD);

	SetSelection(nSelectionStart, nSelectionEnd, true, false);
	
	*pResult = 1;
}

void CWavePropPg::SetSelection(int nSelectionStart, int nSelectionEnd, bool bSetEditor, bool bDoSnap)
{
	if(nSelectionStart > nSelectionEnd)
		Swap(nSelectionStart, nSelectionEnd);

	if(m_bLockSelectionLength && (nSelectionEnd - nSelectionStart) != (m_nSelectionEnd - m_nSelectionStart))
	{
		nSelectionStart = m_nSelectionStart;
		nSelectionEnd = m_nSelectionEnd;
	}

	m_nSelectionStart = nSelectionStart;
	m_nSelectionEnd = nSelectionEnd;

	SetDlgItemInt(IDC_SELECTION_START, nSelectionStart);
	SetDlgItemInt(IDC_SELECTION_END, nSelectionEnd);
	SetDlgItemInt(IDC_SELECTION_LENGTH, nSelectionEnd - nSelectionStart + 1);

	if(bSetEditor && m_pWave) 
	{
		CWaveCtrl* pWaveEditor = m_pWave->GetWaveEditor();
		if(pWaveEditor)
			pWaveEditor->SetSelection(m_nSelectionStart, m_nSelectionEnd, bDoSnap);
	}
}

bool CWavePropPg::IsSelectionLengthLocked()
{
	return m_bLockSelectionLength;
}

bool CWavePropPg::IsLoopLengthLocked()
{
	return m_bLockLoopLength;
}

void CWavePropPg::SetSelectionLengthLock(bool bLock)
{
	m_bLockSelectionLength = bLock;

	if(m_pWave && m_pWave->GetWaveEditor())
	{
		CWaveCtrl* pWaveEditor = m_pWave->GetWaveEditor();
		EnableControl(IDC_SELECTION_LENGTH, !m_bLockSelectionLength);
		EnableControl(IDC_SELECTION_LENGTH_SPIN, !m_bLockSelectionLength);

		pWaveEditor->InvalidateRect(NULL);
	}
	else
	{
		EnableControl(IDC_SELECTION_LENGTH, false);
		EnableControl(IDC_SELECTION_LENGTH_SPIN, false);
		EnableControl(IDC_SELECTION_LENGTH_LOCK_CHECK, false);
	}

	m_SelectionLengthLockCheck.SetCheck(bLock);
}

void CWavePropPg::Swap(int& nSelectionStart, int& nSelectionEnd)
{
	int nTemp = nSelectionStart;
	nSelectionStart = nSelectionEnd;
	nSelectionEnd = nTemp;
}

void CWavePropPg::OnForwardLoopRadio() 
{
	ASSERT(m_pWave);
	if(m_pWave== NULL)
	{
		return;
	}

	CWaveCtrl* pWaveEditor = m_pWave->GetWaveEditor();
	if(pWaveEditor)
	{
		if(FAILED(pWaveEditor->SaveStateForUndo(IDS_UNDO_WAVE_LOOP_TYPE)))
		{
			return;
		}
	}

	SetWaveLoopType(WLOOP_TYPE_FORWARD);
	m_pWave->NotifyWaveChange(true);
}

void CWavePropPg::OnLoopAndReleaseRadio() 
{
	ASSERT(m_pWave);
	if(m_pWave== NULL)
	{
		return;
	}

	CWaveCtrl* pWaveEditor = m_pWave->GetWaveEditor();
	if(pWaveEditor)
	{
		if(FAILED(pWaveEditor->SaveStateForUndo(IDS_UNDO_WAVE_LOOP_TYPE)))
		{
			return;
		}
	}

	SetWaveLoopType(WLOOP_TYPE_RELEASE);
	m_pWave->NotifyWaveChange(true);
}

void CWavePropPg::SetWaveLoopType(ULONG ulLoopType)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	ASSERT(m_pWave);
	if(m_pWave == NULL)
	{
		return;
	}

	CButton* pForwardLoopBtn = (CButton*)GetDlgItem(IDC_FORWARD_LOOP_RADIO);
	CButton* pLoopReleaseBtn = (CButton*)GetDlgItem(IDC_LOOP_AND_RELEASE_RADIO);
	ASSERT(pForwardLoopBtn);
	ASSERT(pLoopReleaseBtn);
	if(pForwardLoopBtn == NULL || pLoopReleaseBtn == NULL)
	{
		return;
	}

	if(ulLoopType == WLOOP_TYPE_FORWARD)
	{
		pForwardLoopBtn->SetCheck(1);
		pLoopReleaseBtn->SetCheck(0);
	}

	if(ulLoopType == WLOOP_TYPE_RELEASE)
	{
		pForwardLoopBtn->SetCheck(0);
		pLoopReleaseBtn->SetCheck(1);
	}

	WLOOP waveLoop = m_pWave->GetWLOOP();
	if(waveLoop.ulType != ulLoopType)
	{
		waveLoop.ulType = ulLoopType;

		m_pWave->SetWLOOP(waveLoop);
		m_pWave->CopyWSMPToSMPL();
		m_pWave->UpdateWave();
		m_pWave->UpdateDummyInstrument();

		UpdatePlaybackSettingsInRegions();

		// Set flag so we know to save file 
		m_pWave->NotifyWaveChange(true);
	}
}

void CWavePropPg::EnableLoopTypeButtons(BOOL bEnable)
{
	CButton* pForwardLoopBtn = (CButton*)GetDlgItem(IDC_FORWARD_LOOP_RADIO);
	CButton* pLoopReleaseBtn = (CButton*)GetDlgItem(IDC_LOOP_AND_RELEASE_RADIO);
	ASSERT(pForwardLoopBtn);
	ASSERT(pLoopReleaseBtn);
	if(pForwardLoopBtn == NULL || pLoopReleaseBtn == NULL)
	{
		return;
	}

	pForwardLoopBtn->EnableWindow(bEnable);
	pLoopReleaseBtn->EnableWindow(bEnable);
}

void CWavePropPg::OnLButtonDblClk(UINT nFlags, CPoint point) 
{
	bool bWaveChanged = false;
	WSMPL waveWSMPL = m_pWave->GetWSMPL();
	if(CheckSliderForDefaultClick(*m_pmsAttenuation, point) == TRUE)
	{
		waveWSMPL.lAttenuation = 0;
		bWaveChanged = true;
	}

	if(CheckSliderForDefaultClick(*m_pmsFineTune, point) == TRUE)
	{
		waveWSMPL.sFineTune = 0;
		bWaveChanged = true;
	}

	if(bWaveChanged)
	{
		// Update the wave SMPL values
		m_pWave->SetWSMPL(waveWSMPL);
		m_pWave->CopyWSMPToSMPL();
    
		m_pWave->UpdateWave();
		// Change the values in all the regions that refer to this wave 
		// and have not selected to override wave properties.
		UpdateAttenuationInRegions();

		m_pWave->UpdateDummyInstrument();
		m_pWave->NotifyWaveChange(true);
	}
	
	CPropertyPage::OnLButtonDblClk(nFlags, point);
}

BOOL CWavePropPg::CheckSliderForDefaultClick(MySlider& msSlider, CPoint point)
{
	ASSERT(m_pWave);
	if(m_pWave == NULL)
	{
		return FALSE;
	}

	CSliderCtrl* pSlider = (CSliderCtrl*)GetDlgItem(msSlider.SliderID());
	if(pSlider)
	{
		CRect rectThumb;
		pSlider->GetThumbRect(&rectThumb);
		if(rectThumb.PtInRect(point))
		{
			CWaveCtrl* pWaveEditor = m_pWave->GetWaveEditor();
			if(FAILED(pWaveEditor->SaveStateForUndo(msSlider.GetUndoStringID())))
			{
				return FALSE;
			}
			
			msSlider.SetValue(this, msSlider.GetDefaultValue());
			return TRUE;
		}
	}

	return FALSE;
}

BOOL CWavePropPg::OnCommand(WPARAM wParam, LPARAM lParam) 
{
	LRESULT lResult;
	if (CSliderCollection::OnCommand(wParam, lParam, &lResult))
		return lResult;

	return CPropertyPage::OnCommand(wParam, lParam);
}

BOOL CWavePropPg::OnNotify(WPARAM wParam, LPARAM lParam, LRESULT* pResult) 
{
	LRESULT lResult;
	if (CSliderCollection::OnNotify(wParam, lParam, &lResult))
		return lResult;
	
	return CPropertyPage::OnNotify(wParam, lParam, pResult);
}

bool CWavePropPg::OnSliderUpdate(MySlider *pms, DWORD dwmscupdf)
{
	switch (dwmscupdf)
		{
		case dwmscupdfStart:
			return true; // save state is done on End of updates

		case dwmscupdfEnd:
			if (pms == m_pmsAttenuation)
				UpdateDbAttenuation();
			else
				{
				ASSERT(pms == m_pmsFineTune); // slider not handled
				UpdateFineTune();
				}
			return true;

		default:
			ASSERT(FALSE);
			return false;
		}
}

/* ensures the given selection length fits within boundaries */
void CWavePropPg::ConstrainSelectionLength(int& nSelLen)
{
	if (nSelLen < 1)
		nSelLen = (m_nSelectionEnd - m_nSelectionStart) + 1;
	else
		{
		int nSelMax = m_pWave->m_dwWaveLength-m_pWave->GetDwDecompressedStart(true);
		if ((m_nSelectionStart + nSelLen) >= nSelMax)
			nSelLen = nSelMax - m_nSelectionStart;
		}
}

/* if necessary, snaps the given selection value in the given direction */
void CWavePropPg::EnsureSnap(int& nSel, UINT nSnapDirection)
{
	if(m_pWave)
		{
		CWaveNode* pWaveNode = m_pWave->GetNode();
		ASSERT(pWaveNode);
		if(pWaveNode)
			{
			CDLSComponent* pComponent = pWaveNode->GetComponent();
			ASSERT(pComponent);
			if(pComponent && pComponent->IsSnapToZero())
				{
				DWORD dwDecompressedStart = m_pWave->GetDwDecompressedStart(true);
				DWORD dwSel = nSel+dwDecompressedStart;
				m_pWave->SnapToZero(dwSel, nSnapDirection);
				nSel= dwSel-dwDecompressedStart;
				}
			}
		}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\DLSDesigner\WaveRefNode.h ===
#ifndef __WAVEREFNODE_H__
#define __WAVEREFNODE_H__

// WaveRefNode.h : header file
//

#include "DLSComponent.h"
#include "WaveDocType.h"
#include "RiffStrm.h"

class CWaveRefNode : public IDMUSProdNode, public IDMUSProdReferenceNode
{
public:
    CWaveRefNode( CDLSComponent* pComponent );
	~CWaveRefNode();

    // IUnknown functions
    HRESULT STDMETHODCALLTYPE QueryInterface( REFIID riid, LPVOID *ppv );
    ULONG STDMETHODCALLTYPE AddRef();
    ULONG STDMETHODCALLTYPE Release();

    // IDMUSProdNode functions
	HRESULT STDMETHODCALLTYPE GetNodeImageIndex( short* pnNbrFirstImage );
    HRESULT STDMETHODCALLTYPE GetFirstChild( IDMUSProdNode** ppIFirstChildNode );
    HRESULT STDMETHODCALLTYPE GetNextChild( IDMUSProdNode* pIChildNode, IDMUSProdNode** ppINextChildNode );

    HRESULT STDMETHODCALLTYPE GetComponent( IDMUSProdComponent** ppIComponent );
    HRESULT STDMETHODCALLTYPE GetDocRootNode( IDMUSProdNode** ppIDocRootNode );
    HRESULT STDMETHODCALLTYPE SetDocRootNode( IDMUSProdNode* pIDocRootNode );
    HRESULT STDMETHODCALLTYPE GetParentNode( IDMUSProdNode** ppIParentNode );
    HRESULT STDMETHODCALLTYPE SetParentNode( IDMUSProdNode* pIParentNode );
    HRESULT STDMETHODCALLTYPE GetNodeId( GUID* pguid );
    HRESULT STDMETHODCALLTYPE GetNodeName( BSTR* pbstrName );
    HRESULT STDMETHODCALLTYPE GetNodeNameMaxLength( short* pnMaxLength );
    HRESULT STDMETHODCALLTYPE ValidateNodeName( BSTR bstrName );
    HRESULT STDMETHODCALLTYPE SetNodeName( BSTR bstrName );
	HRESULT STDMETHODCALLTYPE GetNodeListInfo( DMUSProdListInfo* pListInfo );

    HRESULT STDMETHODCALLTYPE GetEditorClsId( CLSID* pclsid );
    HRESULT STDMETHODCALLTYPE GetEditorTitle( BSTR* pbstrTitle );
    HRESULT STDMETHODCALLTYPE GetEditorWindow( HWND* hWndEditor );
    HRESULT STDMETHODCALLTYPE SetEditorWindow( HWND hWndEditor );

	HRESULT STDMETHODCALLTYPE UseOpenCloseImages( BOOL* pfUseOpenCloseImages );

    HRESULT STDMETHODCALLTYPE GetRightClickMenuId( HINSTANCE* phInstance, UINT* pnResourceId );
    HRESULT STDMETHODCALLTYPE OnRightClickMenuInit( HMENU hMenu );
    HRESULT STDMETHODCALLTYPE OnRightClickMenuSelect( long lCommandId );

    HRESULT STDMETHODCALLTYPE DeleteChildNode( IDMUSProdNode* pIChildNode, BOOL fPromptUser );
    HRESULT STDMETHODCALLTYPE InsertChildNode( IDMUSProdNode* pIChildNode );
    HRESULT STDMETHODCALLTYPE DeleteNode( BOOL fPromptUser );

	HRESULT STDMETHODCALLTYPE OnNodeSelChanged( BOOL fSelected );

	HRESULT STDMETHODCALLTYPE CreateDataObject( IDataObject** ppIDataObject );
	HRESULT STDMETHODCALLTYPE CanCut();
	HRESULT STDMETHODCALLTYPE CanCopy();
	HRESULT STDMETHODCALLTYPE CanDelete();
	HRESULT STDMETHODCALLTYPE CanDeleteChildNode( IDMUSProdNode* pIChildNode );
	HRESULT STDMETHODCALLTYPE CanPasteFromData( IDataObject* pIDataObject, BOOL* pfWillSetReference );
	HRESULT STDMETHODCALLTYPE PasteFromData( IDataObject* pIDataObject );
	HRESULT STDMETHODCALLTYPE CanChildPasteFromData( IDataObject* pIDataObject, IDMUSProdNode* pIChildNode, BOOL* pfWillSetReference );
	HRESULT STDMETHODCALLTYPE ChildPasteFromData( IDataObject* pIDataObject, IDMUSProdNode* pIChildNode );

	HRESULT STDMETHODCALLTYPE GetObject( REFCLSID rclsid, REFIID riid, void** ppvObject ); 

    // IDMUSProdReferenceNode functions
	HRESULT STDMETHODCALLTYPE GetReferencedFile( IDMUSProdNode** ppIDocRootNode );
	HRESULT STDMETHODCALLTYPE SetReferencedFile( IDMUSProdNode* pIDocRootNode );

	//Additional functions

public:
	CWaveNode*			m_pWaveNode;		// WaveRefNode refers to this CWaveNode

private:
    DWORD				m_dwRef;
	CDLSComponent*		m_pComponent;
	IDMUSProdNode*		m_pIDocRootNode;
	IDMUSProdNode*	    m_pIParentNode;
};

#endif // __WAVEREFNODE_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\DLSDesigner\WaveSourceFileHandler.h ===
#ifndef __WAVESOURCEFILEHANDLER_H__
#define __WAVESOURCEFILEHANDLER_H__

#include "WaveFileHandler.h"
#include "RiffStrm.h"

class CWaveSourceFileHandler : public CWaveFileHandler
{

public:
	// Construction
	CWaveSourceFileHandler(CString sFileName, bool bInACollection);	// Opens the file for READ 

	// Method to load chunks from the header
	HRESULT LoadChunk(MMCKINFO* pckFind, BYTE* pbData, DWORD& dwBytesRead); 
	
	// Reset the offsets of the header and data chunks in the file
	HRESULT ResetOffsets();	

	// Called when the source file is being renamed
	HRESULT OnRename(CString sNewName);

	
private:
	HRESULT AllocRIFFStreamFromFile(IStream** ppIStream, IDMUSProdRIFFStream** ppIRiffStream); // Open a READ stream to the source file
	bool m_bInACollection;
	
};
#endif // __WAVESOURCEFILEHANDLER_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\DLSDesigner\WaveSourceFileHandler.cpp ===
/////////////////////////////////////////////////////////
//
// WaveSourceFileHandler Implementation
//
/////////////////////////////////////////////////////////

#include "stdafx.h"
#include "WaveSourceFileHandler.h"
#include "Wave.h"
#include "stream.h"
#include "RiffStrm.h"


////////////////////////////////////////////////////////////////////////////////////
//
//	Construction :- CWaveSourceFileHandler::CWaveSourceFileHandler
//
/////////////////////////////////////////////////////////////////////////////////////
CWaveSourceFileHandler::CWaveSourceFileHandler(CString sFileName, bool bInACollection) : CWaveFileHandler(sFileName, CFile::modeRead)
{
	m_bInACollection = bInACollection;
}


//////////////////////////////////////
//
//	CWaveSourceFileHandler::LoadChunk
//
//////////////////////////////////////
HRESULT CWaveSourceFileHandler::LoadChunk(MMCKINFO* pckFind,  BYTE* pbData, DWORD& dwBytesRead)
{
	ASSERT(pckFind);
	if(pckFind == NULL)
	{
		return E_POINTER;
	}

	HRESULT hr = E_FAIL;

	// Get a stream for the file
	IStream* pIStream = NULL;
	IDMUSProdRIFFStream* pIRiffStream = NULL;
	if(SUCCEEDED(hr = AllocRIFFStreamFromFile(&pIStream, &pIRiffStream)))
	{
		// Set the stream pointer to the start of header 
		DWORD dwHeaderOffset = GetStartOffset();
		StreamSeek(pIStream, dwHeaderOffset, STREAM_SEEK_SET);
		
		// Find the WAVE chunk
		MMCKINFO ckMain;
		UINT nFlags = MMIO_FINDRIFF;
		ckMain.ckid = 0;
		ckMain.fccType = mmioFOURCC('W','A','V','E');
			
		UINT nSuccess =  pIRiffStream->Descend(&ckMain, NULL, nFlags);
		if(nSuccess != 0)
		{
			nFlags = MMIO_FINDLIST;
			ckMain.ckid = FOURCC_LIST;
			ckMain.fccType = FOURCC_wave;
			StreamSeek(pIStream, dwHeaderOffset, STREAM_SEEK_SET);
			nSuccess =  pIRiffStream->Descend(&ckMain, NULL, nFlags);
		}

		if(nSuccess == 0)
		{
			// Look for the required chunk
			if(SUCCEEDED(hr = pIRiffStream->Descend(pckFind, &ckMain, MMIO_FINDCHUNK)))
			{
				pbData = new BYTE[pckFind->cksize];
				if(pbData == NULL)
				{
					pIRiffStream->Release();
					pIStream->Release();
					return E_OUTOFMEMORY;
				}

				hr = pIStream->Read(pbData, pckFind->cksize, &dwBytesRead);
				if(FAILED(hr) || pckFind->cksize != dwBytesRead)
				{
					dwBytesRead = 0;
					delete[] pbData;
					pbData = NULL;
				}
			}
		}


		pIRiffStream->Release();
		pIStream->Release();
	}

	return hr;
}


//////////////////////////////////////////////////////
//
// CWaveSourceFileHandler::ResetOffsets
//
//////////////////////////////////////////////////////
HRESULT CWaveSourceFileHandler::ResetOffsets()
{
	HRESULT hr = E_FAIL;

	// Get a stream for the file
	IStream* pIStream = NULL;
	IDMUSProdRIFFStream* pIRiffStream = NULL;
	if(SUCCEEDED(hr = AllocRIFFStreamFromFile(&pIStream, &pIRiffStream)))
	{
		// Set the stream pointer to the start of header 
		DWORD dwHeaderOffset = GetStartOffset();
		StreamSeek(pIStream, dwHeaderOffset, STREAM_SEEK_SET);
		
		// Find the WAVE chunk
		MMCKINFO ckMain;
		UINT nFlags = MMIO_FINDRIFF;
		ckMain.fccType = mmioFOURCC('W','A','V','E');

		UINT nSuccess = pIRiffStream->Descend(&ckMain, NULL, nFlags);
		if(nSuccess != 0)
		{
			nFlags = MMIO_FINDLIST;
			ckMain.ckid = FOURCC_LIST;
			ckMain.fccType = FOURCC_wave;
			StreamSeek(pIStream, dwHeaderOffset, STREAM_SEEK_SET);
			nSuccess = pIRiffStream->Descend(&ckMain, NULL, nFlags);
		}
		
		// We have some corrupted DLS collections
		// MANBUGS: 42247
		if(nSuccess != 0)
		{
			nFlags = MMIO_FINDLIST;
			ckMain.ckid = FOURCC_LIST;
			ckMain.fccType = mmioFOURCC('W','A','V','E');
			StreamSeek(pIStream, dwHeaderOffset, STREAM_SEEK_SET);
			nSuccess = pIRiffStream->Descend(&ckMain, NULL, nFlags);
		}

		if(nSuccess == 0)
		{
			DWORD dwHeaderOffset = StreamTell(pIStream);
			
			// Subtract the RIFF header bytes and set the offset
			dwHeaderOffset -= 12; 
			SetStartOffset(dwHeaderOffset);

			// Look for the required chunk
			MMCKINFO ck;
			ck.ckid = FOURCC_DATA;
			//ck.fccType = 0;
			if(pIRiffStream->Descend(&ck, &ckMain, MMIO_FINDCHUNK) == 0)
			{
				DWORD dwDataOffset = StreamTell(pIStream);
				SetDataOffset(dwDataOffset);

				hr = S_OK;
			}
		}
		else
		{
			hr = E_FAIL;
		}

		pIRiffStream->Release();
		pIStream->Release();
	}

	return hr;
}


//////////////////////////////////////////////////////
//
// CWaveSourceFileHandler::AllocRIFFStreamFromFile
//
//////////////////////////////////////////////////////
HRESULT CWaveSourceFileHandler::AllocRIFFStreamFromFile(IStream** ppIStream, IDMUSProdRIFFStream** ppIRiffStream)
{
	HRESULT hr = E_FAIL;
	if(SUCCEEDED(hr = AllocStreamFromFile(ppIStream, m_sFileName, 0)))
	{
		hr = AllocRIFFStream(*ppIStream, ppIRiffStream);
	}

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\DLSDesigner\WaveStream.cpp ===
//////////////////////////////////////////////////////////////////////
//
// WaveStream.cpp : Implementation file
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "WaveNode.h"
#include "Wave.h"
#include "WaveDataManager.h"
#include "WaveStream.h"


#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

CWaveStream::CWaveStream(CWave* pWave) : m_pWave(pWave), m_lRef(0)
{
	ASSERT(pWave);
	m_dwCurrentPos = 0;
	AddRef();
}

CWaveStream::CWaveStream(CWaveStream* pWaveStream) : m_lRef(0)
{
	ASSERT(pWaveStream);
	m_pWave = pWaveStream->m_pWave;
	m_dwCurrentPos = pWaveStream->m_dwCurrentPos;
	AddRef();
}


CWaveStream::~CWaveStream()
{
}


//////////////////////////////////////////////////////////////////////
//
//	CWaveStream::QueryInterface()
//
//////////////////////////////////////////////////////////////////////
HRESULT CWaveStream::QueryInterface(REFIID riid, LPVOID *ppvObj)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

    if(IsEqualIID(riid, IID_IUnknown))
    {
        AddRef();
        *ppvObj = this;
        return S_OK;
    }

    if(::IsEqualIID(riid, IID_IStream))
    {
        AddRef();
        *ppvObj = (IStream*)this;
        return S_OK;
    } 

    *ppvObj = NULL;
    return E_NOINTERFACE;
}

//////////////////////////////////////////////////////////////////////
//
//	CWaveStream::AddRef()
//
//////////////////////////////////////////////////////////////////////
ULONG CWaveStream::AddRef()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	AfxOleLockApp();
    return InterlockedIncrement(&m_lRef);
}

//////////////////////////////////////////////////////////////////////
//
//	CWaveStream::Release()
//
//////////////////////////////////////////////////////////////////////
ULONG CWaveStream::Release()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
    ASSERT(m_lRef != 0);

	InterlockedDecrement(&m_lRef); 

    if(m_lRef == 0)
    {
        delete this;
        return 0;
    }
	
	AfxOleUnlockApp();
    return m_lRef;
}


HRESULT CWaveStream::Read(void* pv, ULONG cb, ULONG* pcbRead)
{
	ASSERT(pv);
	if(pv == NULL)
	{
		return E_POINTER;
	}

	ASSERT(pcbRead);
	if(pcbRead == NULL)
	{
		return E_POINTER;
	}

	ASSERT(m_pWave);
	if(m_pWave == NULL)
	{
		return E_FAIL;
	}

	DWORD dwHeaderSize = m_pWave->GetRIFFHeaderSize();
	DWORD dwDataSize = m_pWave->GetDataSize();
	DWORD dwFileSize = dwHeaderSize + dwDataSize;

	if(m_dwCurrentPos < dwHeaderSize && m_dwCurrentPos + cb <= dwHeaderSize)
	{
		IStream* pIStream = m_pWave->GetHeaderMemStream();
		ASSERT(pIStream);
		if(pIStream == NULL)
		{
			return E_FAIL;
		}

		if(FAILED(pIStream->Read(pv, cb, pcbRead)))
		{
			return E_FAIL;
		}

		// Update the position
		m_dwCurrentPos += *pcbRead;
		return S_OK;

	}

	if(m_dwCurrentPos >= dwHeaderSize && m_dwCurrentPos + cb <= dwFileSize)
	{
		// We need to read cb number of bytes of wave data
		// Convert that to samples
		int nBytesPerSample = m_pWave->m_rWaveformat.wBitsPerSample / 8;
		int nChannels = m_pWave->m_rWaveformat.nChannels;

		DWORD dwStart = ((m_dwCurrentPos - dwHeaderSize) / nBytesPerSample) / nChannels;
		DWORD dwLength = (cb / nBytesPerSample) / nChannels;

		DWORD cbRead = 0;
		CWaveDataManager* pDataManager = m_pWave->GetDataManager();
		ASSERT(pDataManager);
		if(pDataManager == NULL)
		{
			return E_UNEXPECTED;
		}

		CWaveNode* pWaveNode = m_pWave->GetNode();
		ASSERT(pWaveNode);
		if(pWaveNode == NULL)
		{
			return E_UNEXPECTED;
		}

		EnterCriticalSection(&pWaveNode->m_CriticalSection);
		HRESULT hr = pDataManager->GetData(dwStart, dwLength, (BYTE*)pv, cbRead);
		LeaveCriticalSection(&pWaveNode->m_CriticalSection);
		if(FAILED(hr))
		{
			return hr;
		}

		m_dwCurrentPos += cbRead;
		*pcbRead = cbRead;

		return S_OK;
	}

	return E_FAIL;
}


HRESULT CWaveStream::Write(void const* pv, ULONG cb, ULONG * pcbWritten)
{
	ASSERT(0);
	return E_NOTIMPL;
}



HRESULT CWaveStream::Seek(LARGE_INTEGER dlibMove, DWORD dwOrigin, ULARGE_INTEGER* plibNewPosition)
{
	ASSERT(m_pWave);
	if(m_pWave == NULL)
	{
		return E_FAIL;
	}

	DWORD dwHeaderSize = m_pWave->GetRIFFHeaderSize();
	DWORD dwDataSize = m_pWave->GetDataSize();
	DWORD dwWaveFileSize = dwHeaderSize + dwDataSize;
	
	long  lSeekPosition = 0;
	if(dwOrigin == STREAM_SEEK_SET)
	{
		lSeekPosition = dlibMove.LowPart;
	}
	if(dwOrigin == STREAM_SEEK_CUR)
	{
		lSeekPosition = m_dwCurrentPos + dlibMove.LowPart;
	}
	if(dwOrigin == STREAM_SEEK_END)
	{
		lSeekPosition = dwWaveFileSize - dlibMove.LowPart;
	}

	// reject seeking before start, but not after end (fix 50785)
	if(lSeekPosition < 0)
	{
		return E_FAIL;
	}

	if(plibNewPosition)
	{
		plibNewPosition->LowPart = lSeekPosition;
		plibNewPosition->HighPart = 0L;
	}

	m_dwCurrentPos = (DWORD) lSeekPosition;

	return S_OK;
}


HRESULT CWaveStream::SetSize(ULARGE_INTEGER libNewSize)
{
	return E_NOTIMPL;
}


HRESULT CWaveStream::CopyTo(IStream * pstm, ULARGE_INTEGER cb, ULARGE_INTEGER* pcbRead, ULARGE_INTEGER* pcbWritten)
{
	ASSERT(0);
	return E_NOTIMPL;
}


HRESULT CWaveStream::Commit(DWORD grfCommitFlags)
{
	ASSERT(0);
	return E_NOTIMPL;
}


HRESULT CWaveStream::Revert(void)
{
	ASSERT(0);
	return E_NOTIMPL;
}


HRESULT CWaveStream::LockRegion(ULARGE_INTEGER libOffset, ULARGE_INTEGER cb, DWORD dwLockType)
{
	ASSERT(0);
	return E_NOTIMPL;
}


HRESULT CWaveStream::UnlockRegion(ULARGE_INTEGER libOffset, ULARGE_INTEGER cb, DWORD dwLockType)
{
	ASSERT(0);
	return E_NOTIMPL;
}


HRESULT CWaveStream::Stat(STATSTG* pstatstg, DWORD grfStatFlag)
{
	ASSERT(0);
	return E_NOTIMPL;
}


HRESULT CWaveStream::Clone(IStream** ppstm)
{
	CWaveStream* pClonedStream = new CWaveStream(this);
	if(pClonedStream == NULL)
	{
		return E_FAIL;
	}

	*ppstm = (IStream*)pClonedStream;
	
	return S_OK;
}

HRESULT CWaveStream::GetWaveFileSize(DWORD* pdwWaveFileSize)
{
	ASSERT(m_pWave);
	if(m_pWave == NULL)
	{
		return E_FAIL;
	}

	ASSERT(pdwWaveFileSize);
	if(pdwWaveFileSize == NULL)
	{
		return E_POINTER;
	}

	DWORD dwHeaderSize = m_pWave->GetRIFFHeaderSize();
	DWORD dwDataSize = m_pWave->GetDataSize();

	return dwHeaderSize + dwDataSize;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\DLSDesigner\WaveTempFileHandler.h ===
#ifndef __WAVETEMPFILEHANDLER_H__
#define __WAVETEMPFILEHANDLER_H__

#include "WaveFileHandler.h"

class CWaveTempFileHandler : public CWaveFileHandler
{
	// Construction
public:
	CWaveTempFileHandler(CString sTempFileName);
};

#endif // __WAVETEMPFILEHANDLER_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\DLSDesigner\WaveTempFileHandler.cpp ===
////////////////////////////////////////////////////
//
// CWaveTempFileHandler Implementation
//
////////////////////////////////////////////////////

#include "stdafx.h"
#include "winbase.h"
#include "WaveTempFileHandler.h"


////////////////////////////////////////////////////
//
// Construction:- CWaveTempFileHandler::CWaveTempFileHandler
//
////////////////////////////////////////////////////
CWaveTempFileHandler::CWaveTempFileHandler(CString sTempFileName) : CWaveFileHandler(sTempFileName, CFile::modeCreate | CFile::modeNoTruncate | CFile::modeReadWrite)
{
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\DLSDesigner\WaveStream.h ===
#ifndef __WAVESTREAM_H__
#define __WAVESTREAM_H__

class CWaveDataManager;


class CWaveStream : public IStream
{

public:

	CWaveStream(CWave* pWave);
	~CWaveStream();

	
public:

	// IUnknown functions
    HRESULT STDMETHODCALLTYPE QueryInterface( REFIID riid, LPVOID *ppv );
    ULONG	STDMETHODCALLTYPE AddRef();
    ULONG	STDMETHODCALLTYPE Release();

	// ISequentialStream Methods
	HRESULT STDMETHODCALLTYPE Read(void* pv, ULONG cb, ULONG* pcbRead);
	HRESULT STDMETHODCALLTYPE Write(void const* pv, ULONG cb, ULONG* pcbWritten);

	// IStream methods
	HRESULT STDMETHODCALLTYPE Seek(LARGE_INTEGER dlibMove, DWORD dwOrigin, ULARGE_INTEGER* plibNewPosition);
	HRESULT STDMETHODCALLTYPE SetSize(ULARGE_INTEGER libNewSize);
	HRESULT STDMETHODCALLTYPE CopyTo(IStream* pstm, ULARGE_INTEGER cb, ULARGE_INTEGER* pcbRead, ULARGE_INTEGER* pcbWritten);
	HRESULT STDMETHODCALLTYPE Commit(DWORD grfCommitFlags);
	HRESULT STDMETHODCALLTYPE Revert(void);
	HRESULT STDMETHODCALLTYPE LockRegion(ULARGE_INTEGER libOffset, ULARGE_INTEGER cb, DWORD dwLockType);
	HRESULT STDMETHODCALLTYPE UnlockRegion(ULARGE_INTEGER libOffset, ULARGE_INTEGER cb, DWORD dwLockType);
	HRESULT STDMETHODCALLTYPE Stat(STATSTG* pstatstg, DWORD grfStatFlag);
	HRESULT STDMETHODCALLTYPE Clone(IStream** ppstm);

private:
	CWaveStream(CWaveStream* pWaveStream);	// Copy ctor
	HRESULT GetWaveFileSize(DWORD* pdwWaveFileSize);

private:

	DWORD			m_dwCurrentPos;
	CWave*			m_pWave;

	long			m_lRef;


};


#endif // __WAVESTREAM_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\DLSDesigner\WaveUndoManager.h ===
#ifndef __WAVEUNDOMANAGER_H__
#define __WAVEUNDOMANAGER_H__

#include <afxtempl.h>
#include "WaveDataManager.h"

class CWaveDataManager;

class CWaveState
{
public:
	// Construction
	CWaveState(CString sStateName, CPtrList* pDeltaList, HEADER_INFO* pHeaderInfo, LPWAVEFORMATEX pwfxCompression);
	~CWaveState();

	// Methods
	CString		GetStateName();
	CPtrList*	GetDeltaList();
	HEADER_INFO	GetHeaderInfo();
    
    LPWAVEFORMATEX GetCompressionFormat();

private:

	CPtrList*	    m_pDeltaList;
	CString		    m_sStateName;
	HEADER_INFO	    m_HeaderInfo;
    LPWAVEFORMATEX  m_pwfxCompression; // Valid only if m_bCompressed flag is set in the header info
};


class CWaveUndoManager
{

public:
	// Construction
	CWaveUndoManager(CWaveDataManager* pDataManager);
	~CWaveUndoManager();

public:
	// Methods

	HRESULT Initialize();						 // Gets rid of all the old states and adds the passed list as the first state 
	
	HRESULT SaveState(CString sStateName, CPtrList* pDeltaList, HEADER_INFO* pHeaderInfo, LPWAVEFORMATEX pwfxCompression = NULL);
	HRESULT Undo(CPtrList* plstCurrent, CPtrList** pNewDeltaList, HEADER_INFO* pHeaderInfo, LPWAVEFORMATEX* ppwfxCompression);
	HRESULT Redo(CPtrList** pNewDeltaList, HEADER_INFO* pHeaderInfo, LPWAVEFORMATEX* ppwfxCompression);
    HRESULT PopUndoState();

	CString GetCurrentStateName();
	CString GetRedoStateName();

private:
	void	EmptyQueue();

private:
	CWaveDataManager*	m_pDataManager;
	POSITION			m_posCurrent;

	// flags to keep track of special conditions when we have to 
	// decide if we have a valid undo/redo state to support....
	// e.g. when we have only one state in the state list 
	bool		m_bUndoOK;	 
	bool		m_bRedoOK;
	bool		m_bCreateRedo;


	CTypedPtrList<CPtrList, CWaveState*> m_lstStates;
};


#endif // __WAVEUNDOMANAGER_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\DLSDesigner\WaveUndoManager.cpp ===
#include "stdafx.h"
#include "WaveUndoManager.h"
#include "WaveDataManager.h"

/////////////////////////////////////////////////////////////////
//
// CWaveState Implementation
//
/////////////////////////////////////////////////////////////////
CWaveState::CWaveState(CString sStateName, CPtrList* pDeltaList, HEADER_INFO* pHeaderInfo, LPWAVEFORMATEX pwfxCompression):
m_sStateName(sStateName), 
m_pDeltaList(pDeltaList), 
m_pwfxCompression(pwfxCompression)
{
	CopyMemory(&m_HeaderInfo, pHeaderInfo, sizeof(HEADER_INFO));
}


CWaveState::~CWaveState()
{
	// Delete the delta list
	while(!m_pDeltaList->IsEmpty())
	{
		delete m_pDeltaList->RemoveHead();
	}

	delete m_pDeltaList;

    if(m_pwfxCompression)
    {
        delete[] (BYTE*)m_pwfxCompression;
    }
}


CString CWaveState::GetStateName()
{
	return m_sStateName;
}


CPtrList* CWaveState::GetDeltaList()
{
	return m_pDeltaList;
}

HEADER_INFO	CWaveState::GetHeaderInfo()
{
	return m_HeaderInfo;
}


LPWAVEFORMATEX CWaveState::GetCompressionFormat()
{
    return m_pwfxCompression;
}

/////////////////////////////////////////////////////////////////
//
// CWaveUndoManager Implementation
//
/////////////////////////////////////////////////////////////////
CWaveUndoManager::CWaveUndoManager(CWaveDataManager* pDataManager)
{
	m_pDataManager = pDataManager;
	m_posCurrent = NULL;

	m_bUndoOK = true;
	m_bRedoOK = true;
	m_bCreateRedo = false;
}


CWaveUndoManager::~CWaveUndoManager()
{
	EmptyQueue();
}


HRESULT CWaveUndoManager::Initialize()
{
	EmptyQueue();

	m_bUndoOK = true;
	m_bRedoOK = false;

	return S_OK;
}

void CWaveUndoManager::EmptyQueue()
{
	while(!m_lstStates.IsEmpty())
	{
		delete m_lstStates.RemoveHead();
	}

	m_posCurrent = NULL;
}


HRESULT CWaveUndoManager::SaveState(CString sStateName, CPtrList* pDeltaList, HEADER_INFO* pHeaderInfo, LPWAVEFORMATEX pwfxCompression)
{
	ASSERT(pDeltaList);
	if(pDeltaList == NULL)
	{
		return E_POINTER;
	}

	// Delete all the states after the current position
	POSITION position = m_posCurrent;
	if(position && m_bUndoOK == true && m_bCreateRedo == true)
	{
		m_lstStates.GetNext(position);
	}

	while(position)
	{
		POSITION oldPosition = position;
		CWaveState* pState = (CWaveState*)m_lstStates.GetNext(position);
		m_lstStates.RemoveAt(oldPosition);
		ASSERT(pState);
		if(pState)
		{
			delete pState;
		}
	}

	CWaveState* pNewState = new CWaveState(sStateName, pDeltaList, pHeaderInfo, pwfxCompression);
	m_posCurrent = m_lstStates.AddTail(pNewState);
	
	if(m_bCreateRedo == false)
	{
		m_bUndoOK = true;
		m_bRedoOK = false;
	}

	m_bCreateRedo = true;


	return S_OK;
}


HRESULT CWaveUndoManager::Undo(CPtrList* plstCurrent, CPtrList** pNewDeltaList, HEADER_INFO* pHeaderInfo, LPWAVEFORMATEX* ppwfxCompression)
{
	ASSERT(plstCurrent);
	if(plstCurrent == NULL)
	{
		return E_POINTER;
	}

	if(m_bUndoOK == false)
	{
		return E_FAIL;
	}

	POSITION undoPosition = m_posCurrent;
	m_lstStates.GetPrev(undoPosition);
	if(undoPosition == NULL)
	{
		undoPosition = m_posCurrent;
	}

	CWaveState* pUndoState = (CWaveState*) m_lstStates.GetAt(undoPosition);
	ASSERT(pUndoState);

	// Add a redo state
	if(m_posCurrent == m_lstStates.GetTailPosition() && m_bCreateRedo)
	{
		// Delete all redo nodes from this point
		POSITION position = m_posCurrent;
		if(FAILED(SaveState(pUndoState->GetStateName(), plstCurrent, pHeaderInfo, *ppwfxCompression)))
		{
			return E_FAIL;
		}
		
		undoPosition = m_posCurrent;
		m_lstStates.GetPrev(undoPosition);
		pUndoState = (CWaveState*) m_lstStates.GetAt(undoPosition);
		m_bCreateRedo = false;
	}
    else
    {
        // We don't need to keep the compression format
        delete[] (BYTE*) *ppwfxCompression;
    }

	*pNewDeltaList = pUndoState->GetDeltaList();

	HEADER_INFO headerInfo = pUndoState->GetHeaderInfo();
	CopyMemory(pHeaderInfo, &headerInfo, sizeof(HEADER_INFO));

    if(headerInfo.m_bCompressed)
    {
        *ppwfxCompression = pUndoState->GetCompressionFormat();
    }


	if(undoPosition == m_lstStates.GetHeadPosition())
	{
		m_bUndoOK = false;
		m_bRedoOK = true;
		m_posCurrent = undoPosition;
	}
	else
	{
		m_bRedoOK = true;
		m_bUndoOK = true;
		m_posCurrent = undoPosition;
	}

	return S_OK;
}

HRESULT CWaveUndoManager::Redo(CPtrList** pNewDeltaList, HEADER_INFO* pHeaderInfo, LPWAVEFORMATEX* ppwfxCompression)
{
	ASSERT(pHeaderInfo);
	if(pHeaderInfo == NULL)
	{
		return E_POINTER;
	}

	if(m_bRedoOK == false)
	{
		return E_FAIL;
	}

	POSITION redoPosition = m_posCurrent;
	m_lstStates.GetNext(redoPosition);
	if(redoPosition == NULL)
	{
		redoPosition = m_posCurrent;
	}
	
	CWaveState* pUndoState = (CWaveState*) m_lstStates.GetAt(redoPosition);
	ASSERT(pUndoState);
	*pNewDeltaList = pUndoState->GetDeltaList();

	HEADER_INFO headerInfo = pUndoState->GetHeaderInfo();
	CopyMemory(pHeaderInfo, &headerInfo, sizeof(HEADER_INFO));

    if(headerInfo.m_bCompressed)
    {
        *ppwfxCompression = pUndoState->GetCompressionFormat();
    }

	if(redoPosition == m_lstStates.GetTailPosition())
	{
		m_bRedoOK = false;

		m_bUndoOK = true;
		m_posCurrent = redoPosition;
	}
	else
	{
		m_bRedoOK = true;
		m_bUndoOK = true;
		m_posCurrent = redoPosition;
	}

	return S_OK;
}


HRESULT CWaveUndoManager::PopUndoState()
{
    if(m_lstStates.GetCount() == 0)
    {
        return S_FALSE;
    }

    CWaveState* pState = m_lstStates.RemoveTail();
    if(pState)
    {
        delete pState;
    }

    m_posCurrent = m_lstStates.GetTailPosition();

    return S_OK;
}

CString CWaveUndoManager::GetCurrentStateName()
{
	if(m_posCurrent && m_bUndoOK)
	{
		POSITION undoPosition = m_posCurrent;
		if(m_bCreateRedo == false)
		{
			m_lstStates.GetPrev(undoPosition);
		}
		if(undoPosition == NULL)
		{
			undoPosition = m_posCurrent;
		}

		if(undoPosition)
		{
			CWaveState* pState = m_lstStates.GetAt(undoPosition);
			return pState->GetStateName();
		}
	
	}

	return "";
}

CString CWaveUndoManager::GetRedoStateName()
{
	if(m_posCurrent && m_bRedoOK)
	{
		POSITION redoPosition = m_posCurrent;
		if(redoPosition == NULL)
		{
			redoPosition = m_posCurrent;
		}

		CWaveState* pState = (CWaveState*) m_lstStates.GetAt(redoPosition);
		return pState->GetStateName();
	}

	return "";
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\DLSDesigner\RemovedFromProject\ArticulationEditor.cpp ===
// ArticulationEditor.cpp : implementation file
//

#include "stdafx.h"
#include "resource.h"
#include "DLSDesignerDLL.h"
#include "DLSDesigner.h"
#include "jazz.h"
#include "ArticulationCtl.h"
#include "ArticulationEditor.h"
#include "Articulation.h"
#include "Instrument.h"

#include "region.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CArticulationEditor

IMPLEMENT_DYNCREATE(CArticulationEditor, CFormView)

CArticulationEditor::CArticulationEditor(CArticulationCtrl* parent)
	: CFormView(CArticulationEditor::IDD)
{
	m_parent = parent;
	
	CArticulation* pArticulation = m_parent->GetArticulation();
	
	ASSERT(pArticulation != NULL);

#ifdef _DEBUG	
	pArticulation->ValidateParent();
#endif

	m_ArticParams = pArticulation->GetArticParams();
	
	if(pArticulation->m_pInstrument)
	{
		// Articulation is owned by an instrument			
		m_pCollection = (pArticulation->m_pInstrument)->m_pCollection;
	}
	else
	{
		// Articulation is owned by a region
		m_pCollection = ((pArticulation->m_pRegion)->m_pInstrument)->m_pCollection;
	}

	//{{AFX_DATA_INIT(CArticulationEditor)
	//}}AFX_DATA_INIT
}

CArticulationEditor::~CArticulationEditor()
{
}

void CArticulationEditor::DoDataExchange(CDataExchange* pDX)
{
	CFormView::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CArticulationEditor)
	DDX_Control(pDX, IDC_VEG_ADSRENVELOPECTRL, m_VEGASDREnvelope);
	DDX_Control(pDX, IDC_PEG_ADSRENVELOPECTRL, m_PEGADSREnvelope);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CArticulationEditor, CFormView)
	//{{AFX_MSG_MAP(CArticulationEditor)
	ON_WM_HSCROLL()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CArticulationEditor diagnostics

#ifdef _DEBUG
void CArticulationEditor::AssertValid() const
{
	CFormView::AssertValid();
}

void CArticulationEditor::Dump(CDumpContext& dc) const
{
	CFormView::Dump(dc);
}
#endif //_DEBUG

/////////////////////////////////////////////////////////////////////////////
// CArticulationEditor message handlers

BOOL CArticulationEditor::Create(LPCTSTR lpszClassName, LPCTSTR lpszWindowName, DWORD dwStyle, const RECT& rect, CWnd* pParentWnd, UINT nID, CCreateContext* pContext) 
{
	// TODO: Add your specialized code here and/or call the base class
	
	return CFormView::Create(lpszClassName, lpszWindowName, dwStyle, rect, pParentWnd, nID, pContext);
}

BEGIN_EVENTSINK_MAP(CArticulationEditor, CFormView)
    //{{AFX_EVENTSINK_MAP(CArticulationEditor)
	ON_EVENT(CArticulationEditor, IDC_PEG_ADSRENVELOPECTRL, 2 /* ADSREAttackTimeChanged */, OnADSREAttackTimeChangedPegAdsrenvelopectrl, VTS_I4)
	ON_EVENT(CArticulationEditor, IDC_PEG_ADSRENVELOPECTRL, 3 /* ADSREReleaseTimeChanged */, OnADSREReleaseTimeChangedPegAdsrenvelopectrl, VTS_I4)
	ON_EVENT(CArticulationEditor, IDC_PEG_ADSRENVELOPECTRL, 1 /* ADSREDecayTimeChanged */, OnADSREDecayTimeChangedPegAdsrenvelopectrl, VTS_I4)
	ON_EVENT(CArticulationEditor, IDC_PEG_ADSRENVELOPECTRL, 4 /* ADSRESustainLevelChanged */, OnADSRESustainLevelChangedPegAdsrenvelopectrl, VTS_I4)
	ON_EVENT(CArticulationEditor, IDC_VEG_ADSRENVELOPECTRL, 4 /* ADSRESustainLevelChanged */, OnADSRESustainLevelChangedVegAdsrenvelopectrl, VTS_I4)
	ON_EVENT(CArticulationEditor, IDC_VEG_ADSRENVELOPECTRL, 3 /* ADSREReleaseTimeChanged */, OnADSREReleaseTimeChangedVegAdsrenvelopectrl, VTS_I4)
	ON_EVENT(CArticulationEditor, IDC_VEG_ADSRENVELOPECTRL, 2 /* ADSREAttackTimeChanged */, OnADSREAttackTimeChangedVegAdsrenvelopectrl, VTS_I4)
	ON_EVENT(CArticulationEditor, IDC_VEG_ADSRENVELOPECTRL, 1 /* ADSREDecayTimeChanged */, OnADSREDecayTimeChangedVegAdsrenvelopectrl, VTS_I4)
	//}}AFX_EVENTSINK_MAP
END_EVENTSINK_MAP()

void CArticulationEditor::OnInitialUpdate() 
{
	CFormView::OnInitialUpdate();

	m_LFOParams = m_ArticParams.m_LFO;
	m_VEGParams = m_ArticParams.m_VolEG;
    m_PEGParams = m_ArticParams.m_PitchEG;
    m_MSCParams = m_ArticParams.m_Misc;

// LFO
	m_msLFOFrequency.Init(this, 
					      IDC_LFO_FREQUENCY, 
					      IDC_LFO_DFREQUENCY, 
                          MYSLIDER_LFORANGE,
					      &m_LFOParams.m_pcFrequency);

	m_msLFODelay.Init(this, 
				      IDC_LFO_DELAY, 
				      IDC_LFO_DDELAY, 
                      MYSLIDER_LFODELAY,
				      &m_LFOParams.m_tcDelay);
    
	m_msLFOVolumeScale.Init(this, 
						    IDC_LFO_VOLUME, 
						    IDC_LFO_DVOLUME, 
						    MYSLIDER_VOLUMECENTS,
						    &m_LFOParams.m_gcVolumeScale);

	m_msLFOPitchScale.Init(this, 
						   IDC_LFO_PITCH, 
						   IDC_LFO_DPITCH, 
						   MYSLIDER_PITCHCENTS,
						   &m_LFOParams.m_pcPitchScale);

	m_msLFOMWToVolume.Init(this, 
						   IDC_LFO_MW2VOLUME, 
						   IDC_LFO_DMW2VOLUME, 
						   MYSLIDER_VOLUMECENTS,
						   &m_LFOParams.m_gcMWToVolume);

	m_msLFOMWToPitch.Init(this, 
					      IDC_LFO_MW2PITCH, 
					      IDC_LFO_DMW2PITCH, 
					      MYSLIDER_PITCHCENTS,
					      &m_LFOParams.m_pcMWToPitch);

// Misc
	m_msMSCDefaultPan.Init(this, 
						   IDC_MSC_PAN, 
						   IDC_MSC_DPAN, 
						   MYSLIDER_PAN,
						   &m_MSCParams.m_ptDefaultPan);

// VEG
	m_msVEGVel2Attack.Init(this, 
						   IDC_VEG_VEL2ATTACK, 
						   IDC_VEG_DVEL2ATTACK, 
						   MYSLIDER_TIMESCALE,
						   &m_VEGParams.m_tcVel2Attack);
    
	m_msVEGKey2Decay.Init(this, 
					      IDC_VEG_KEY2DECAY, 
					      IDC_VEG_DKEY2DECAY, 
					      MYSLIDER_TIMESCALE,
					      &m_VEGParams.m_tcKey2Decay);
// PEG
	m_msPEGVel2Attack.Init(this, 
						   IDC_PEG_VEL2ATTACK, 
						   IDC_PEG_DVEL2ATTACK, 
						   MYSLIDER_TIMESCALE,
						   &m_PEGParams.m_tcVel2Attack);
    
	m_msPEGKey2Decay.Init(this, 
						  IDC_PEG_KEY2DECAY, 
						  IDC_PEG_DKEY2DECAY, 
						  MYSLIDER_TIMESCALE,
					      &m_PEGParams.m_tcKey2Decay);
    
	m_msPEGRange.Init(this, 
					  IDC_PEG_RANGE, 
					  IDC_PEG_DRANGE, 
                      MYSLIDER_PITCHCENTS,
				      &m_PEGParams.m_pcRange);
	DWORD dw;

	dw = TimeCents2Mils(m_ArticParams.m_PitchEG.m_tcRelease);
	m_PEGADSREnvelope.SetReleaseTime(dw ? (dw <= MAXDSRTIME ? dw : MAXDSRTIME) : 1);
	dw = TimeCents2Mils(m_ArticParams.m_PitchEG.m_tcAttack);
	m_PEGADSREnvelope.SetAttachTime(dw ? (dw <= MAXDSRTIME ? dw : MAXDSRTIME) : 1);
	dw = TimeCents2Mils(m_ArticParams.m_PitchEG.m_tcDecay);
	m_PEGADSREnvelope.SetDecayTime(dw ? (dw <= MAXDSRTIME ? dw : MAXDSRTIME) : 1);

	int temp = (m_ArticParams.m_PitchEG.m_ptSustain) >> 16;
	m_PEGADSREnvelope.SetSustainLevel(temp);
	
	dw = TimeCents2Mils(m_ArticParams.m_VolEG.m_tcRelease);
	m_VEGASDREnvelope.SetReleaseTime(dw ? (dw <= MAXDSRTIME ? dw : MAXDSRTIME) : 1);
	dw = TimeCents2Mils(m_ArticParams.m_VolEG.m_tcAttack);
	m_VEGASDREnvelope.SetAttachTime(dw ? (dw <= MAXDSRTIME ? dw : MAXDSRTIME) : 1);
	dw = TimeCents2Mils(m_ArticParams.m_VolEG.m_tcDecay);
	m_VEGASDREnvelope.SetDecayTime(dw ? (dw <= MAXDSRTIME ? dw : MAXDSRTIME) : 1);

	temp = (m_ArticParams.m_VolEG.m_ptSustain) >> 16;	
	m_VEGASDREnvelope.SetSustainLevel(temp);
}

void CArticulationEditor::OnHScroll(UINT nSBCode, UINT nPos, CScrollBar* pScrollBar) 
{
//	LFO
    MySlider *pSlider = NULL;
	if (pScrollBar != NULL)
	{
        int nID = pScrollBar->GetDlgCtrlID();
        switch (nID)
        {
        case IDC_LFO_FREQUENCY :
            pSlider = &m_msLFOFrequency;
            break;
        case IDC_LFO_DELAY :
            pSlider = &m_msLFODelay;
            break;
        case IDC_LFO_VOLUME :
            pSlider = &m_msLFOVolumeScale;
            break;
        case IDC_LFO_PITCH :
            pSlider = &m_msLFOPitchScale;
            break;
        case IDC_LFO_MW2VOLUME :
            pSlider = &m_msLFOMWToVolume;
            break;
        case IDC_LFO_MW2PITCH :
            pSlider = &m_msLFOMWToPitch;
            break;
// MISC
        case IDC_MSC_PAN :
            pSlider = &m_msMSCDefaultPan;
            break;
// VEG
        case IDC_VEG_VEL2ATTACK :
            pSlider = &m_msVEGVel2Attack;
            break;
        case IDC_VEG_KEY2DECAY :
            pSlider = &m_msVEGKey2Decay;
            break;
// PEG
        case IDC_PEG_VEL2ATTACK :
            pSlider = &m_msPEGVel2Attack;
            break;
        case IDC_PEG_KEY2DECAY :
            pSlider = &m_msPEGKey2Decay;
            break;
        case IDC_PEG_RANGE :
            pSlider = &m_msPEGRange;
            break;
        default:
            pSlider = NULL;
            break;
        }

		m_ArticParams.m_LFO = m_LFOParams;
		m_ArticParams.m_VolEG = m_VEGParams;
		m_ArticParams.m_PitchEG = m_PEGParams;
		m_ArticParams.m_Misc = m_MSCParams;

        if (pSlider != NULL)
        {
            pSlider->SetPosition(this,nSBCode,nPos);
        }

#ifdef DLS_UPDATE_SYNTH
	m_pCollection->UpdateSynth(m_parent->m_pArticulation, UPDATE_ARTICULATION);
#endif

    }


	CFormView::OnHScroll(nSBCode, nPos, pScrollBar);
}

void CArticulationEditor::OnADSREAttackTimeChangedPegAdsrenvelopectrl(long NewAttackTime) 
{
	char text[64];
	sprintf(text, "%02d", NewAttackTime);
	CWnd* pDisplay = GetDlgItem(IDC_PEG_DATTACK);
	pDisplay->SetWindowText(text);

	m_PEGParams.m_tcAttack = Mils2TimeCents(NewAttackTime);
	m_ArticParams.m_PitchEG.m_tcAttack = m_PEGParams.m_tcAttack;

#ifdef DLS_UPDATE_SYNTH
			m_pCollection->UpdateSynth(m_parent->m_pArticulation, UPDATE_ARTICULATION);
#endif

}

void CArticulationEditor::OnADSREReleaseTimeChangedPegAdsrenvelopectrl(long NewReleaseTime) 
{
	char text[64];
	sprintf(text, "%02d", NewReleaseTime);
	CWnd * pDisplay = GetDlgItem(IDC_PEG_DRELEASE);
	pDisplay->SetWindowText(text);

	m_PEGParams.m_tcRelease = Mils2TimeCents(NewReleaseTime);
	m_ArticParams.m_PitchEG.m_tcRelease = m_PEGParams.m_tcRelease;

#ifdef DLS_UPDATE_SYNTH
			m_pCollection->UpdateSynth(m_parent->m_pArticulation, UPDATE_ARTICULATION);
#endif

}

void CArticulationEditor::OnADSREDecayTimeChangedPegAdsrenvelopectrl(long NewDecayTime) 
{
	char text[64];
	sprintf(text, "%02d", NewDecayTime);
	CWnd * pDisplay = GetDlgItem(IDC_PEG_DDECAY);
	pDisplay->SetWindowText(text);

	m_PEGParams.m_tcDecay = Mils2TimeCents(NewDecayTime);
	m_ArticParams.m_PitchEG.m_tcDecay = m_PEGParams.m_tcDecay;

#ifdef DLS_UPDATE_SYNTH
			m_pCollection->UpdateSynth(m_parent->m_pArticulation, UPDATE_ARTICULATION);
#endif

}

void CArticulationEditor::OnADSRESustainLevelChangedPegAdsrenvelopectrl(long NewSustainLevel) 
{
	char text[64];
	sprintf(text, "%02d", NewSustainLevel);
	CWnd * pDisplay = GetDlgItem(IDC_PEG_DSUSTAIN);
	pDisplay->SetWindowText(text);

//	m_PEGParams.m_ptSustain = Mils2TimeCents(NewSustainLevel);
//	m_ArticParams.m_PitchEG.m_ptSustain = m_PEGParams.m_ptSustain;

#ifdef DLS_UPDATE_SYNTH
			m_pCollection->UpdateSynth(m_parent->m_pArticulation, UPDATE_ARTICULATION);
#endif
}

void CArticulationEditor::OnADSRESustainLevelChangedVegAdsrenvelopectrl(long NewSustainLevel) 
{
	char text[64];
	sprintf(text, "%02d", NewSustainLevel);
	CWnd * pDisplay = GetDlgItem(IDC_VEG_DSUSTAIN);
	pDisplay->SetWindowText(text);

//	m_VEGParams.m_ptSustain = Mils2TimeCents(NewSustainLevel);
//	m_ArticParams.m_VolEG.m_ptSustain = m_VEGParams.m_ptSustain;

#ifdef DLS_UPDATE_SYNTH
	m_pCollection->UpdateSynth(m_parent->m_pArticulation, UPDATE_ARTICULATION);
#endif
}

void CArticulationEditor::OnADSREReleaseTimeChangedVegAdsrenvelopectrl(long NewReleaseTime) 
{
	char text[64];
	sprintf(text, "%02d", NewReleaseTime);
	CWnd * pDisplay = GetDlgItem(IDC_VEG_DRELEASE);
	pDisplay->SetWindowText(text);

	m_VEGParams.m_tcRelease = Mils2TimeCents(NewReleaseTime);
	m_ArticParams.m_VolEG.m_tcRelease = m_VEGParams.m_tcRelease;

#ifdef DLS_UPDATE_SYNTH
	m_pCollection->UpdateSynth(m_parent->m_pArticulation, UPDATE_ARTICULATION);
#endif
}

void CArticulationEditor::OnADSREAttackTimeChangedVegAdsrenvelopectrl(long NewAttackTime) 
{
	char text[64];
	sprintf(text, "%02d", NewAttackTime);
	CWnd* pDisplay = GetDlgItem(IDC_VEG_DATTACK);
	pDisplay->SetWindowText(text);

	m_VEGParams.m_tcAttack = Mils2TimeCents(NewAttackTime);
	m_ArticParams.m_VolEG.m_tcAttack = m_VEGParams.m_tcAttack;

#ifdef DLS_UPDATE_SYNTH
	m_pCollection->UpdateSynth(m_parent->m_pArticulation, UPDATE_ARTICULATION);
#endif
}

void CArticulationEditor::OnADSREDecayTimeChangedVegAdsrenvelopectrl(long NewDecayTime) 
{
	char text[64];
	sprintf(text, "%02d", NewDecayTime);
	CWnd * pDisplay = GetDlgItem(IDC_VEG_DDECAY);
	pDisplay->SetWindowText(text);

	m_VEGParams.m_tcDecay = Mils2TimeCents(NewDecayTime);
	m_ArticParams.m_VolEG.m_tcDecay = m_VEGParams.m_tcDecay;

#ifdef DLS_UPDATE_SYNTH
	m_pCollection->UpdateSynth(m_parent->m_pArticulation, UPDATE_ARTICULATION);
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\DLSDesigner\RemovedFromProject\ArticulationCtl.h ===
#if !defined(AFX_ARTICULATIONCTL_H__BC964EB3_96F7_11D0_89AA_00A0C9054129__INCLUDED_)
#define AFX_ARTICULATIONCTL_H__BC964EB3_96F7_11D0_89AA_00A0C9054129__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include "dlsdesigner.h"
#include "ArticulationEditor.h"

class CArticulation;

// ArticulationCtl.h : Declaration of the CArticulationCtrl ActiveX Control class.

/////////////////////////////////////////////////////////////////////////////
// CArticulationCtrl : See ArticulationCtl.cpp for implementation.

class CArticulationCtrl : public COleControl
{
	DECLARE_DYNCREATE(CArticulationCtrl)

// Constructor
public:
	CArticulationCtrl();
	~CArticulationCtrl();

	CArticulation * GetArticulation() {return(m_pArticulation);}

// Attributes
public:
	CArticulation*		m_pArticulation;

private:
	WORD            m_nMIDINoteOns[128];	// J3 do we need this
	HWND				m_hWndContainer;
	HMENU				m_hMenuInPlace;
	CToolBar*			m_pToolBar;
	CArticulationEditor* m_pArticulationEditor; 

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CArticulationCtrl)
	public:
	virtual void OnDraw(CDC* pdc, const CRect& rcBounds, const CRect& rcInvalid);
	virtual void DoPropExchange(CPropExchange* pPX);
	virtual void OnResetState();
	//}}AFX_VIRTUAL

// Implementation
protected:


	DECLARE_OLECREATE_EX(CArticulationCtrl)    // Class factory and guid
	DECLARE_OLETYPELIB(CArticulationCtrl)      // GetTypeInfo
	DECLARE_PROPPAGEIDS(CArticulationCtrl)     // Property page IDs
	DECLARE_OLECTLTYPE(CArticulationCtrl)		// Type name and misc status

// Message maps
	//{{AFX_MSG(CArticulationCtrl)
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	afx_msg void OnSize(UINT nType, int cx, int cy);
	afx_msg void OnKeyDown(UINT nChar, UINT nRepCnt, UINT nFlags);
	afx_msg void OnKeyUp(UINT nChar, UINT nRepCnt, UINT nFlags);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

// Dispatch maps
	//{{AFX_DISPATCH(CArticulationCtrl)
		// NOTE - ClassWizard will add and remove member functions here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_DISPATCH
	DECLARE_DISPATCH_MAP()

	afx_msg void AboutBox();

// Event maps
	//{{AFX_EVENT(CArticulationCtrl)
		// NOTE - ClassWizard will add and remove member functions here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_EVENT
	DECLARE_EVENT_MAP()

// Dispatch and event IDs
public:

	// IOleInPlaceActiveObject
	BEGIN_INTERFACE_PART(MyOleInPlaceActiveObject, IOleInPlaceActiveObject)
		INIT_INTERFACE_PART(COleControl, MyOleInPlaceActiveObject)
		STDMETHOD(GetWindow)(HWND*);
		STDMETHOD(ContextSensitiveHelp)(BOOL);
		STDMETHOD(TranslateAccelerator)(LPMSG);
		STDMETHOD(OnFrameWindowActivate)(BOOL);
		STDMETHOD(OnDocWindowActivate)(BOOL);
		STDMETHOD(ResizeBorder)(LPCRECT, LPOLEINPLACEUIWINDOW, BOOL);
		STDMETHOD(EnableModeless)(BOOL);
	END_INTERFACE_PART(MyOleInPlaceActiveObject)

    // IJazzEditor functions
	BEGIN_INTERFACE_PART(Editor, IJazzEditor)
		STDMETHOD(AttachObjects)(IJazzNode*, IOleUndoManager*);
		STDMETHOD(OnInitMenuFilePrint)(HMENU, UINT);
		STDMETHOD(OnFilePrint)();
		STDMETHOD(OnInitMenuFilePrintPreview)(HMENU, UINT);
		STDMETHOD(OnFilePrintPreview)();
	END_INTERFACE_PART(Editor)

	DECLARE_INTERFACE_MAP()

	enum {
	//{{AFX_DISP_ID(CArticulationCtrl)
		// NOTE: ClassWizard will add and remove enumeration elements here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_DISP_ID
	};
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_ARTICULATIONCTL_H__BC964EB3_96F7_11D0_89AA_00A0C9054129__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\DLSDesigner\RemovedFromProject\ArticulationPpg.h ===
#if !defined(AFX_ARTICULATIONPPG_H__BC964EB5_96F7_11D0_89AA_00A0C9054129__INCLUDED_)
#define AFX_ARTICULATIONPPG_H__BC964EB5_96F7_11D0_89AA_00A0C9054129__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

// ArticulationPpg.h : Declaration of the CArticulationPropPage property page class.

////////////////////////////////////////////////////////////////////////////
// CArticulationPropPage : See ArticulationPpg.cpp.cpp for implementation.

class CArticulationPropPage : public COlePropertyPage
{
	DECLARE_DYNCREATE(CArticulationPropPage)
	DECLARE_OLECREATE_EX(CArticulationPropPage)

// Constructor
public:
	CArticulationPropPage();

// Dialog Data
	//{{AFX_DATA(CArticulationPropPage)
	enum { IDD = IDD_PROPPAGE_ARTICULATION };
		// NOTE - ClassWizard will add data members here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_DATA

// Implementation
protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support

// Message maps
protected:
	//{{AFX_MSG(CArticulationPropPage)
	afx_msg void OnCancelMode();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_ARTICULATIONPPG_H__BC964EB5_96F7_11D0_89AA_00A0C9054129__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\DLSDesigner\RemovedFromProject\ArticulationPpg.cpp ===
// ArticulationPpg.cpp : Implementation of the CArticulationPropPage property page class.

#include "stdafx.h"
#include "DLSDesignerDLL.h"
#include "ArticulationPpg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


IMPLEMENT_DYNCREATE(CArticulationPropPage, COlePropertyPage)


/////////////////////////////////////////////////////////////////////////////
// Message map

BEGIN_MESSAGE_MAP(CArticulationPropPage, COlePropertyPage)
	//{{AFX_MSG_MAP(CArticulationPropPage)
	ON_WM_CANCELMODE()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// Initialize class factory and guid

IMPLEMENT_OLECREATE_EX(CArticulationPropPage, "DLSDESIGNER.ArticulationPropPage.1",
	0xbc964e93, 0x96f7, 0x11d0, 0x89, 0xaa, 0, 0xa0, 0xc9, 0x5, 0x41, 0x29)


/////////////////////////////////////////////////////////////////////////////
// CArticulationPropPage::CArticulationPropPageFactory::UpdateRegistry -
// Adds or removes system registry entries for CArticulationPropPage

BOOL CArticulationPropPage::CArticulationPropPageFactory::UpdateRegistry(BOOL bRegister)
{
	if (bRegister)
		return AfxOleRegisterPropertyPageClass(AfxGetInstanceHandle(),
			m_clsid, IDS_ARTICULATION_PPG);
	else
		return AfxOleUnregisterClass(m_clsid, NULL);
}


/////////////////////////////////////////////////////////////////////////////
// CArticulationPropPage::CArticulationPropPage - Constructor

CArticulationPropPage::CArticulationPropPage() :
	COlePropertyPage(IDD, IDS_ARTICULATION_PPG_CAPTION)
{
	//{{AFX_DATA_INIT(CArticulationPropPage)
	// NOTE: ClassWizard will add member initialization here
	//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_DATA_INIT
}


/////////////////////////////////////////////////////////////////////////////
// CArticulationPropPage::DoDataExchange - Moves data between page and properties

void CArticulationPropPage::DoDataExchange(CDataExchange* pDX)
{
	//{{AFX_DATA_MAP(CArticulationPropPage)
	// NOTE: ClassWizard will add DDP, DDX, and DDV calls here
	//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_DATA_MAP
	DDP_PostProcessing(pDX);
}


/////////////////////////////////////////////////////////////////////////////
// CArticulationPropPage message handlers

void CArticulationPropPage::OnCancelMode() 
{
	COlePropertyPage::OnCancelMode();
	
	// TODO: Add your message handler code here
	
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\DLSDesigner\RemovedFromProject\ArticulationCtl.cpp ===
// ArticulationCtl.cpp : Implementation of the CArticulationCtrl ActiveX Control class.

#include "stdafx.h"
#include "DLSDesignerDLL.h"
#include "Articulation.h"
#include "ArticulationCtl.h"
#include "ArticulationPpg.h"
#include "DLSLoadSaveUtils.h"
#include "Instrument.h"
#include "region.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


IMPLEMENT_DYNCREATE(CArticulationCtrl, COleControl)


/////////////////////////////////////////////////////////////////////////////
// Message map

BEGIN_MESSAGE_MAP(CArticulationCtrl, COleControl)
	//{{AFX_MSG_MAP(CArticulationCtrl)
	ON_WM_CREATE()
	ON_WM_SIZE()
	ON_WM_KEYDOWN()
	ON_WM_KEYUP()
	//}}AFX_MSG_MAP
	ON_OLEVERB(AFX_IDS_VERB_PROPERTIES, OnProperties)
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// Dispatch map

BEGIN_DISPATCH_MAP(CArticulationCtrl, COleControl)
	//{{AFX_DISPATCH_MAP(CArticulationCtrl)
	// NOTE - ClassWizard will add and remove dispatch map entries
	//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_DISPATCH_MAP
	DISP_FUNCTION_ID(CArticulationCtrl, "AboutBox", DISPID_ABOUTBOX, AboutBox, VT_EMPTY, VTS_NONE)
END_DISPATCH_MAP()


/////////////////////////////////////////////////////////////////////////////
// Event map

BEGIN_EVENT_MAP(CArticulationCtrl, COleControl)
	//{{AFX_EVENT_MAP(CArticulationCtrl)
	// NOTE - ClassWizard will add and remove event map entries
	//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_EVENT_MAP
END_EVENT_MAP()

/////////////////////////////////////////////////////////////////////////////
// CArticulationCtrl Interface map

BEGIN_INTERFACE_MAP(CArticulationCtrl, COleControl)
    INTERFACE_PART(CArticulationCtrl, IID_IOleInPlaceActiveObject, MyOleInPlaceActiveObject)
    INTERFACE_PART(CArticulationCtrl, IID_IJazzEditor, Editor)
END_INTERFACE_MAP()

/////////////////////////////////////////////////////////////////////////////
// Property pages

// TODO: Add more property pages as needed.  Remember to increase the count!
BEGIN_PROPPAGEIDS(CArticulationCtrl, 1)
	PROPPAGEID(CArticulationPropPage::guid)
END_PROPPAGEIDS(CArticulationCtrl)


/////////////////////////////////////////////////////////////////////////////
// Initialize class factory and guid

IMPLEMENT_OLECREATE_EX(CArticulationCtrl, "DLSDESIGNER.ArticulationCtrl.1",
	0xbc964e92, 0x96f7, 0x11d0, 0x89, 0xaa, 0, 0xa0, 0xc9, 0x5, 0x41, 0x29)


/////////////////////////////////////////////////////////////////////////////
// Type library ID and version

IMPLEMENT_OLETYPELIB(CArticulationCtrl, _tlid, _wVerMajor, _wVerMinor)


/////////////////////////////////////////////////////////////////////////////
// Interface IDs

const IID BASED_CODE IID_DArticulation =
		{ 0xbc964e90, 0x96f7, 0x11d0, { 0x89, 0xaa, 0, 0xa0, 0xc9, 0x5, 0x41, 0x29 } };
const IID BASED_CODE IID_DArticulationEvents =
		{ 0xbc964e91, 0x96f7, 0x11d0, { 0x89, 0xaa, 0, 0xa0, 0xc9, 0x5, 0x41, 0x29 } };


/////////////////////////////////////////////////////////////////////////////
// Control type information

static const DWORD BASED_CODE _dwArticulationOleMisc =
	OLEMISC_ACTIVATEWHENVISIBLE |
	OLEMISC_SETCLIENTSITEFIRST |
	OLEMISC_INSIDEOUT |
	OLEMISC_CANTLINKINSIDE |
	OLEMISC_RECOMPOSEONRESIZE |
	OLEMISC_SIMPLEFRAME;

IMPLEMENT_OLECTLTYPE(CArticulationCtrl, IDS_ARTICULATION, _dwArticulationOleMisc)


/////////////////////////////////////////////////////////////////////////////
// CArticulationCtrl::CArticulationCtrlFactory::UpdateRegistry -
// Adds or removes system registry entries for CArticulationCtrl

BOOL CArticulationCtrl::CArticulationCtrlFactory::UpdateRegistry(BOOL bRegister)
{
	// TODO: Verify that your control follows apartment-model threading rules.
	// Refer to MFC TechNote 64 for more information.
	// If your control does not conform to the apartment-model rules, then
	// you must modify the code below, changing the 6th parameter from
	// afxRegApartmentThreading to 0.

	if (bRegister)
		return AfxOleRegisterControlClass(
			AfxGetInstanceHandle(),
			m_clsid,
			m_lpszProgID,
			IDS_ARTICULATION,
			IDB_ARTICULATION,
			afxRegApartmentThreading,
			_dwArticulationOleMisc,
			_tlid,
			_wVerMajor,
			_wVerMinor);
	else
		return AfxOleUnregisterClass(m_clsid, m_lpszProgID);

}


/////////////////////////////////////////////////////////////////////////////
// CArticulationCtrl::CArticulationCtrl - Constructor

CArticulationCtrl::CArticulationCtrl() : m_pArticulationEditor(NULL), m_pArticulation(NULL)
{
	InitializeIIDs(&IID_DArticulation, &IID_DArticulationEvents);
	
	TRACE0("Entering constructor of CArticulation");

	EnableSimpleFrame();

	// J3 we need to do this better maybe a global class that contains m_nMIDINoteOns

	for(int i = 0; i < 128; i++)
	{
		m_nMIDINoteOns[i] = 0;
	}

	// TODO: Initialize your control's instance data here.
}


/////////////////////////////////////////////////////////////////////////////
// CArticulationCtrl::~CArticulationCtrl - Destructor

CArticulationCtrl::~CArticulationCtrl()
{
	if(m_pArticulation)
	{
		m_pArticulation->Release();
	}
}

/////////////////////////////////////////////////////////////////////////////
// CArticulationCtrl IJazzEditor implementation

/////////////////////////////////////////////////////////////////////////////
// CArticulationCtrl::XEditor::AddRef

STDMETHODIMP_(ULONG) CArticulationCtrl::XEditor::AddRef()
{
	METHOD_PROLOGUE_EX_( CArticulationCtrl, Editor )

	return (ULONG)pThis->ExternalAddRef();
}


/////////////////////////////////////////////////////////////////////////////
// CArticulationCtrl::XEditor::Release

STDMETHODIMP_(ULONG) CArticulationCtrl::XEditor::Release()
{
	METHOD_PROLOGUE_EX_( CArticulationCtrl, Editor )

	return (ULONG)pThis->ExternalRelease();
}


/////////////////////////////////////////////////////////////////////////////
// CArticulationCtrl::XEditor::QueryInterface

STDMETHODIMP CArticulationCtrl::XEditor::QueryInterface( REFIID iid, LPVOID* ppvObj )
{
	METHOD_PROLOGUE_EX_( CArticulationCtrl, Editor )

	return (HRESULT)pThis->ExternalQueryInterface( &iid, ppvObj );
}


/////////////////////////////////////////////////////////////////////////////
// CArticulationCtrl::XEditor::AttachObjects implementation

HRESULT CArticulationCtrl::XEditor::AttachObjects( IJazzNode* pNode, IOleUndoManager* pUndoManager )
{
	METHOD_MANAGE_STATE( CArticulationCtrl, Editor )

	ASSERT_VALID( pThis );
	ASSERT( pNode != NULL );

	pThis->m_pArticulation = (CArticulation *)pNode;
	pThis->m_pArticulation->AddRef();

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CArticulationCtrl::XEditor::OnInitMenuFilePrint

HRESULT CArticulationCtrl::XEditor::OnInitMenuFilePrint( HMENU hMenu, UINT nMenuId )
{
	METHOD_MANAGE_STATE( CArticulationCtrl, Editor )

	::EnableMenuItem( hMenu, nMenuId, (MF_GRAYED | MF_BYCOMMAND) );

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CArticulationCtrl::XEditor::OnFilePrint

HRESULT CArticulationCtrl::XEditor::OnFilePrint( void )
{
	METHOD_MANAGE_STATE( CArticulationCtrl, Editor )

	return E_NOTIMPL;
}


/////////////////////////////////////////////////////////////////////////////
// CArticulationCtrl::XEditor::OnInitMenuFilePrintPreview

HRESULT CArticulationCtrl::XEditor::OnInitMenuFilePrintPreview( HMENU hMenu, UINT nMenuId )
{
	METHOD_MANAGE_STATE( CArticulationCtrl, Editor )

	::EnableMenuItem( hMenu, nMenuId, (MF_GRAYED | MF_BYCOMMAND) );

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CArticulationCtrl::XEditor::OnFilePrintPreview

HRESULT CArticulationCtrl::XEditor::OnFilePrintPreview( void )
{
	METHOD_MANAGE_STATE( CArticulationCtrl, Editor )

	return E_NOTIMPL;
}


/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
// CArticulationCtrl::XMyOleInPlaceActiveObject implementation

STDMETHODIMP_(ULONG) CArticulationCtrl::XMyOleInPlaceActiveObject::AddRef()
{
	METHOD_MANAGE_STATE( CArticulationCtrl, MyOleInPlaceActiveObject )
	ASSERT_VALID( pThis );

	return pThis->m_xOleInPlaceActiveObject.AddRef();
}

STDMETHODIMP_(ULONG) CArticulationCtrl::XMyOleInPlaceActiveObject::Release()
{
	METHOD_MANAGE_STATE( CArticulationCtrl, MyOleInPlaceActiveObject )
	ASSERT_VALID( pThis );

	return pThis->m_xOleInPlaceActiveObject.Release();
}

STDMETHODIMP CArticulationCtrl::XMyOleInPlaceActiveObject::QueryInterface( REFIID iid, LPVOID* ppvObj )
{
	METHOD_MANAGE_STATE( CArticulationCtrl, MyOleInPlaceActiveObject )
	ASSERT_VALID( pThis );

	return pThis->m_xOleInPlaceActiveObject.QueryInterface( iid, ppvObj );
}

STDMETHODIMP CArticulationCtrl::XMyOleInPlaceActiveObject::GetWindow( HWND* lphwnd )
{
	METHOD_MANAGE_STATE( CArticulationCtrl, MyOleInPlaceActiveObject )
	ASSERT_VALID( pThis );

	return pThis->m_xOleInPlaceActiveObject.GetWindow( lphwnd );
}

STDMETHODIMP CArticulationCtrl::XMyOleInPlaceActiveObject::ContextSensitiveHelp( BOOL fEnterMode )
{
	METHOD_MANAGE_STATE( CArticulationCtrl, MyOleInPlaceActiveObject )
	ASSERT_VALID( pThis );

	return pThis->m_xOleInPlaceActiveObject.ContextSensitiveHelp( fEnterMode );
}

STDMETHODIMP CArticulationCtrl::XMyOleInPlaceActiveObject::TranslateAccelerator( LPMSG lpmsg )
{
	METHOD_MANAGE_STATE( CArticulationCtrl, MyOleInPlaceActiveObject )
	ASSERT_VALID( pThis );

	return pThis->m_xOleInPlaceActiveObject.TranslateAccelerator( lpmsg );
}

STDMETHODIMP CArticulationCtrl::XMyOleInPlaceActiveObject::OnFrameWindowActivate( BOOL fActivate )
{
	METHOD_MANAGE_STATE( CArticulationCtrl, MyOleInPlaceActiveObject )
	ASSERT_VALID( pThis );

	return pThis->m_xOleInPlaceActiveObject.OnFrameWindowActivate( fActivate );
}

STDMETHODIMP CArticulationCtrl::XMyOleInPlaceActiveObject::OnDocWindowActivate( BOOL fActivate )
{
	METHOD_MANAGE_STATE( CArticulationCtrl, MyOleInPlaceActiveObject )
	ASSERT_VALID( pThis );

	return pThis->m_xOleInPlaceActiveObject.OnDocWindowActivate( fActivate );
}

STDMETHODIMP CArticulationCtrl::XMyOleInPlaceActiveObject::ResizeBorder(
	LPCRECT, LPOLEINPLACEUIWINDOW, BOOL fFrameWindow )
{
	METHOD_MANAGE_STATE( CArticulationCtrl, MyOleInPlaceActiveObject )
	ASSERT_VALID( pThis );

    if( fFrameWindow == TRUE )
	{
		pThis->OnShowToolBars();
	}

	return S_OK;
}

STDMETHODIMP CArticulationCtrl::XMyOleInPlaceActiveObject::EnableModeless( BOOL fEnable )
{
	METHOD_MANAGE_STATE( CArticulationCtrl, MyOleInPlaceActiveObject )
	ASSERT_VALID( pThis );

	return pThis->m_xOleInPlaceActiveObject.EnableModeless( fEnable );
}


/////////////////////////////////////////////////////////////////////////////
// CArticulationCtrl::OnDraw - Drawing function

void CArticulationCtrl::OnDraw(
			CDC* pdc, const CRect& rcBounds, const CRect& rcInvalid)
{
}


/////////////////////////////////////////////////////////////////////////////
// CArticulationCtrl::DoPropExchange - Persistence support

void CArticulationCtrl::DoPropExchange(CPropExchange* pPX)
{
	ExchangeVersion(pPX, MAKELONG(_wVerMinor, _wVerMajor));
	COleControl::DoPropExchange(pPX);

	// TODO: Call PX_ functions for each persistent custom property.

}


/////////////////////////////////////////////////////////////////////////////
// CArticulationCtrl::OnResetState - Reset control to default state

void CArticulationCtrl::OnResetState()
{
	COleControl::OnResetState();  // Resets defaults found in DoPropExchange

	// TODO: Reset any other control state here.
}


/////////////////////////////////////////////////////////////////////////////
// CArticulationCtrl::AboutBox - Display an "About" box to the user

void CArticulationCtrl::AboutBox()
{
	CDialog dlgAbout(IDD_ABOUTBOX_ARTICULATION);
	dlgAbout.DoModal();
}


/////////////////////////////////////////////////////////////////////////////
// CArticulationCtrl message handlers

int CArticulationCtrl::OnCreate(LPCREATESTRUCT lpCreateStruct) 
{
	if (COleControl::OnCreate(lpCreateStruct) == -1)
		return -1;

	if( m_pInPlaceFrame )
	{
		m_pInPlaceFrame->GetWindow( &m_hWndContainer );
	}
	else
	{
		// out of place active?
		if( m_bOpen )
		{
			m_hWndContainer = GetParent()->GetSafeHwnd();
		}
	}

		// Create Collection's view
	m_pArticulationEditor = new CArticulationEditor(this);

	if( m_pArticulationEditor == NULL )
	{
		return -1;
	}

	if(m_pArticulationEditor->Create(NULL, 
									 "WindowName", 
									 WS_CHILD | WS_VISIBLE, 
									 CRect( 0, 0, 800, 400 ), 
									 this, 
									 999, 
									 NULL) == 0)
	{
		return -1;
	}

	m_pArticulationEditor->OnInitialUpdate();

	return 0;
}

void CArticulationCtrl::OnSize(UINT nType, int cx, int cy) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	COleControl::OnSize(nType, cx, cy);
	
	m_pArticulationEditor->MoveWindow( 0, 0, cx, cy );
}

void CArticulationCtrl::OnKeyDown(UINT nChar, UINT nRepCnt, UINT nFlags) 
{
	TRACE0("Inside CArticulationCtrl::OnKeyDown");
	m_pArticulation->UpdatePatch();	 	


// J3 we want to use Validate Parent here and any where else.
	if(m_pArticulation->m_pInstrument)
	{
		ASSERT(m_pArticulation->m_pRegion == NULL);
		
		m_pArticulation->m_nMIDINote = (m_pArticulation->m_pInstrument)->m_nMIDINote;

	}
	else if(m_pArticulation->m_pRegion)
	{
		ASSERT(m_pArticulation->m_pInstrument == NULL);
		m_pArticulation->m_pRegion->m_nMIDINote = ((m_pArticulation->m_pRegion)->m_rRgnHeader.RangeKey.usLow +
			    		   (m_pArticulation->m_pRegion)->m_rRgnHeader.RangeKey.usHigh + 1) >> 1;

		m_pArticulation->m_nMIDINote = m_pArticulation->m_pRegion->m_nMIDINote;
		
	}
	else
	{
		// Problem; we should never get here if we do 
		// Articulation does not have a parent
		ASSERT(FALSE);
	}

	switch (nChar)
    {
		case 32 :  // Space bar
			if(m_nMIDINoteOns[m_pArticulation->m_nMIDINote] > 0)
			{
				break;
			}

			// J3 Do we need to do this
			((m_pArticulation->m_pComponent)->m_pIConductor)->PlayMIDIEvent(MIDI_NOTEON,
													   m_pArticulation->m_nMIDINote,
													   110,
													   0);
		m_nMIDINoteOns[m_pArticulation->m_nMIDINote]++;
        break;
	}
}

void CArticulationCtrl::OnKeyUp(UINT nChar, UINT nRepCnt, UINT nFlags) 
{
	switch (nChar)
    {
		case 32 :  // Space bar
// J3 Do we need to do this
		while (m_nMIDINoteOns[m_pArticulation->m_nMIDINote] > 0)
        {
			((m_pArticulation->m_pComponent)->m_pIConductor)->PlayMIDIEvent(MIDI_NOTEOFF,
													   m_pArticulation->m_nMIDINote,
													   110,
													   0);

			m_nMIDINoteOns[m_pArticulation->m_nMIDINote]--;
		}
        break;
	}
//	COleControl::OnKeyUp(nChar, nRepCnt, nFlags);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\DLSDesigner\RemovedFromProject\ArticulationEditor.h ===
//{{AFX_INCLUDES()
#include "adsrenvelope.h"
//}}AFX_INCLUDES
#if !defined(AFX_ARTICULATIONEDITOR_H__D0620364_CB9E_11D0_876A_00AA00C08146__INCLUDED_)
#define AFX_ARTICULATIONEDITOR_H__D0620364_CB9E_11D0_876A_00AA00C08146__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// ArticulationEditor.h : header file
//

const int MAXDSRTIME = 40000;

/////////////////////////////////////////////////////////////////////////////
// CArticulationEditor form view

#ifndef __AFXEXT_H__
#include <afxext.h>
#endif

#include "myslider.h"
#include "DLSLoadSaveUtils.h"
#include "collection.h"

class CArticulationEditor : public CFormView
{
friend class CArticulationCtrl;

protected:
	CArticulationEditor(CArticulationCtrl* parent = NULL);           // protected constructor used by dynamic creation

	DECLARE_DYNCREATE(CArticulationEditor)

// Form Data
private:
	CArticulationCtrl*		m_parent;
	ArticParams				m_ArticParams;
	LFOParams				m_LFOParams;
    MySlider			    m_msLFOFrequency;
    MySlider			    m_msLFODelay;
    MySlider				m_msLFOVolumeScale;
    MySlider				m_msLFOPitchScale;
    MySlider				m_msLFOMWToVolume;
    MySlider				m_msLFOMWToPitch;
	
	MSCParams   m_MSCParams;
    MySlider    m_msMSCDefaultPan;

	PEGParams   m_PEGParams;
    MySlider    m_msPEGVel2Attack;
    MySlider    m_msPEGKey2Decay;
	MySlider    m_msPEGRange;
	
	VEGParams   m_VEGParams;
    MySlider    m_msVEGVel2Attack;
    MySlider    m_msVEGKey2Decay;
    
	CCollection*	m_pCollection;

	//{{AFX_DATA(CArticulationEditor)
	enum { IDD = IDD_ARTICULATION };
	CADSREnvelope	m_VEGASDREnvelope;
	CADSREnvelope	m_PEGADSREnvelope;
	//}}AFX_DATA

// Attributes
public:

// Operations
public:

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CArticulationEditor)
	public:
	virtual BOOL Create(LPCTSTR lpszClassName, LPCTSTR lpszWindowName, DWORD dwStyle, const RECT& rect, CWnd* pParentWnd, UINT nID, CCreateContext* pContext = NULL);
	virtual void OnInitialUpdate();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	virtual ~CArticulationEditor();
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

	// Generated message map functions
	//{{AFX_MSG(CArticulationEditor)
	afx_msg void OnHScroll(UINT nSBCode, UINT nPos, CScrollBar* pScrollBar);
	afx_msg void OnADSREAttackTimeChangedPegAdsrenvelopectrl(long NewAttackTime);
	afx_msg void OnADSREReleaseTimeChangedPegAdsrenvelopectrl(long NewReleaseTime);
	afx_msg void OnADSREDecayTimeChangedPegAdsrenvelopectrl(long NewDecayTime);
	afx_msg void OnADSRESustainLevelChangedPegAdsrenvelopectrl(long NewSustainLevel);
	afx_msg void OnADSRESustainLevelChangedVegAdsrenvelopectrl(long NewSustainLevel);
	afx_msg void OnADSREReleaseTimeChangedVegAdsrenvelopectrl(long NewReleaseTime);
	afx_msg void OnADSREAttackTimeChangedVegAdsrenvelopectrl(long NewAttackTime);
	afx_msg void OnADSREDecayTimeChangedVegAdsrenvelopectrl(long NewDecayTime);
	DECLARE_EVENTSINK_MAP()
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_ARTICULATIONEDITOR_H__D0620364_CB9E_11D0_876A_00AA00C08146__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\DLSDesigner\RemovedFromProject\CollectionCtl.cpp ===
// CollectionCtl.cpp : Implementation of the CCollectionCtrl ActiveX Control class.

#include "stdafx.h"
#include "DLSDesignerDLL.h"
#include "DLSDesigner.h"
#include "jazz.h"
#include "Collection.h"
#include "CollectionCtl.h"
#include "CollectionPpg.h"
#include "CollectionEditor.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


IMPLEMENT_DYNCREATE(CCollectionCtrl, COleControl)


/////////////////////////////////////////////////////////////////////////////
// Message map

BEGIN_MESSAGE_MAP(CCollectionCtrl, COleControl)
	//{{AFX_MSG_MAP(CCollectionCtrl)
	ON_WM_CREATE()
	ON_WM_SIZE()
	ON_WM_KEYDOWN()
	ON_WM_KEYUP()
	//}}AFX_MSG_MAP
	ON_OLEVERB(AFX_IDS_VERB_PROPERTIES, OnProperties)
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// Dispatch map

BEGIN_DISPATCH_MAP(CCollectionCtrl, COleControl)
	//{{AFX_DISPATCH_MAP(CCollectionCtrl)
	// NOTE - ClassWizard will add and remove dispatch map entries
	//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_DISPATCH_MAP
	DISP_FUNCTION_ID(CCollectionCtrl, "AboutBox", DISPID_ABOUTBOX, AboutBox, VT_EMPTY, VTS_NONE)
END_DISPATCH_MAP()


/////////////////////////////////////////////////////////////////////////////
// Event map

BEGIN_EVENT_MAP(CCollectionCtrl, COleControl)
	//{{AFX_EVENT_MAP(CCollectionCtrl)
	// NOTE - ClassWizard will add and remove event map entries
	//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_EVENT_MAP
END_EVENT_MAP()

/////////////////////////////////////////////////////////////////////////////
// CCollectionCtrl Interface map

BEGIN_INTERFACE_MAP(CCollectionCtrl, COleControl)
    INTERFACE_PART(CCollectionCtrl, IID_IOleInPlaceActiveObject, MyOleInPlaceActiveObject)
    INTERFACE_PART(CCollectionCtrl, IID_IJazzEditor, Editor)
END_INTERFACE_MAP()

/////////////////////////////////////////////////////////////////////////////
// Property pages

// TODO: Add more property pages as needed.  Remember to increase the count!
BEGIN_PROPPAGEIDS(CCollectionCtrl, 1)
	PROPPAGEID(CCollectionPropPage::guid)
END_PROPPAGEIDS(CCollectionCtrl)


/////////////////////////////////////////////////////////////////////////////
// Initialize class factory and guid

IMPLEMENT_OLECREATE_EX(CCollectionCtrl, "DLSDESIGNER.CollectionCtrl.1",
	0xbc964e86, 0x96f7, 0x11d0, 0x89, 0xaa, 0, 0xa0, 0xc9, 0x5, 0x41, 0x29)


/////////////////////////////////////////////////////////////////////////////
// Type library ID and version

IMPLEMENT_OLETYPELIB(CCollectionCtrl, _tlid, _wVerMajor, _wVerMinor)


/////////////////////////////////////////////////////////////////////////////
// Interface IDs

const IID BASED_CODE IID_DCollection =
		{ 0xbc964e84, 0x96f7, 0x11d0, { 0x89, 0xaa, 0, 0xa0, 0xc9, 0x5, 0x41, 0x29 } };
const IID BASED_CODE IID_DCollectionEvents =
		{ 0xbc964e85, 0x96f7, 0x11d0, { 0x89, 0xaa, 0, 0xa0, 0xc9, 0x5, 0x41, 0x29 } };


/////////////////////////////////////////////////////////////////////////////
// Control type information

static const DWORD BASED_CODE _dwCollectionOleMisc =
	OLEMISC_ACTIVATEWHENVISIBLE |
	OLEMISC_SETCLIENTSITEFIRST |
	OLEMISC_INSIDEOUT |
	OLEMISC_CANTLINKINSIDE |
	OLEMISC_RECOMPOSEONRESIZE;

IMPLEMENT_OLECTLTYPE(CCollectionCtrl, IDS_COLLECTION, _dwCollectionOleMisc)


/////////////////////////////////////////////////////////////////////////////
// CCollectionCtrl::CCollectionCtrlFactory::UpdateRegistry -
// Adds or removes system registry entries for CCollectionCtrl

BOOL CCollectionCtrl::CCollectionCtrlFactory::UpdateRegistry(BOOL bRegister)
{
	// TODO: Verify that your control follows apartment-model threading rules.
	// Refer to MFC TechNote 64 for more information.
	// If your control does not conform to the apartment-model rules, then
	// you must modify the code below, changing the 6th parameter from
	// afxRegApartmentThreading to 0.

	if (bRegister)
		return AfxOleRegisterControlClass(
			AfxGetInstanceHandle(),
			m_clsid,
			m_lpszProgID,
			IDS_COLLECTION,
			IDB_COLLECTION,
			afxRegApartmentThreading,
			_dwCollectionOleMisc,
			_tlid,
			_wVerMajor,
			_wVerMinor);
	else
		return AfxOleUnregisterClass(m_clsid, m_lpszProgID);
}


/////////////////////////////////////////////////////////////////////////////
// CCollectionCtrl::CCollectionCtrl - Constructor

CCollectionCtrl::CCollectionCtrl() : m_pCollectionEditor(NULL), m_pCollection(NULL)
{
	InitializeIIDs(&IID_DCollection, &IID_DCollectionEvents);

	// TODO: Initialize your control's instance data here.
}


/////////////////////////////////////////////////////////////////////////////
// CCollectionCtrl::~CCollectionCtrl - Destructor

CCollectionCtrl::~CCollectionCtrl()
{
	if(m_pCollection)
	{
		m_pCollection->Release();
	}
}

/////////////////////////////////////////////////////////////////////////////
// CCollectionCtrl IJazzEditor implementation

/////////////////////////////////////////////////////////////////////////////
// CCollectionCtrl::XEditor::AddRef

STDMETHODIMP_(ULONG) CCollectionCtrl::XEditor::AddRef()
{
	METHOD_PROLOGUE_EX_( CCollectionCtrl, Editor )

	return (ULONG)pThis->ExternalAddRef();
}


/////////////////////////////////////////////////////////////////////////////
// CCollectionCtrl::XEditor::Release

STDMETHODIMP_(ULONG) CCollectionCtrl::XEditor::Release()
{
	METHOD_PROLOGUE_EX_( CCollectionCtrl, Editor )

	return (ULONG)pThis->ExternalRelease();
}


/////////////////////////////////////////////////////////////////////////////
// CCollectionCtrl::XEditor::QueryInterface

STDMETHODIMP CCollectionCtrl::XEditor::QueryInterface( REFIID iid, LPVOID* ppvObj )
{
	METHOD_PROLOGUE_EX_( CCollectionCtrl, Editor )

	return (HRESULT)pThis->ExternalQueryInterface( &iid, ppvObj );
}


/////////////////////////////////////////////////////////////////////////////
// CCollectionCtrl::XEditor::AttachObjects implementation

HRESULT CCollectionCtrl::XEditor::AttachObjects( IJazzNode* pNode, IOleUndoManager* pUndoManager )
{
	METHOD_MANAGE_STATE( CCollectionCtrl, Editor )

	ASSERT_VALID( pThis );
	ASSERT( pNode != NULL );

	pThis->m_pCollection = (CCollection *)pNode;
	pThis->m_pCollection->AddRef();

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CCollectionCtrl::XEditor::OnInitMenuFilePrint

HRESULT CCollectionCtrl::XEditor::OnInitMenuFilePrint( HMENU hMenu, UINT nMenuId )
{
	METHOD_MANAGE_STATE( CCollectionCtrl, Editor )

	::EnableMenuItem( hMenu, nMenuId, (MF_GRAYED | MF_BYCOMMAND) );

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CCollectionCtrl::XEditor::OnFilePrint

HRESULT CCollectionCtrl::XEditor::OnFilePrint( void )
{
	METHOD_MANAGE_STATE( CCollectionCtrl, Editor )

	return E_NOTIMPL;
}


/////////////////////////////////////////////////////////////////////////////
// CCollectionCtrl::XEditor::OnInitMenuFilePrintPreview

HRESULT CCollectionCtrl::XEditor::OnInitMenuFilePrintPreview( HMENU hMenu, UINT nMenuId )
{
	METHOD_MANAGE_STATE( CCollectionCtrl, Editor )

	::EnableMenuItem( hMenu, nMenuId, (MF_GRAYED | MF_BYCOMMAND) );

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CCollectionCtrl::XEditor::OnFilePrintPreview

HRESULT CCollectionCtrl::XEditor::OnFilePrintPreview( void )
{
	METHOD_MANAGE_STATE( CCollectionCtrl, Editor )

	return E_NOTIMPL;
}


/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
// CCollectionCtrl::XMyOleInPlaceActiveObject implementation

STDMETHODIMP_(ULONG) CCollectionCtrl::XMyOleInPlaceActiveObject::AddRef()
{
	METHOD_MANAGE_STATE( CCollectionCtrl, MyOleInPlaceActiveObject )
	ASSERT_VALID( pThis );

	return pThis->m_xOleInPlaceActiveObject.AddRef();
}

STDMETHODIMP_(ULONG) CCollectionCtrl::XMyOleInPlaceActiveObject::Release()
{
	METHOD_MANAGE_STATE( CCollectionCtrl, MyOleInPlaceActiveObject )
	ASSERT_VALID( pThis );

	return pThis->m_xOleInPlaceActiveObject.Release();
}

STDMETHODIMP CCollectionCtrl::XMyOleInPlaceActiveObject::QueryInterface( REFIID iid, LPVOID* ppvObj )
{
	METHOD_MANAGE_STATE( CCollectionCtrl, MyOleInPlaceActiveObject )
	ASSERT_VALID( pThis );

	return pThis->m_xOleInPlaceActiveObject.QueryInterface( iid, ppvObj );
}

STDMETHODIMP CCollectionCtrl::XMyOleInPlaceActiveObject::GetWindow( HWND* lphwnd )
{
	METHOD_MANAGE_STATE( CCollectionCtrl, MyOleInPlaceActiveObject )
	ASSERT_VALID( pThis );

	return pThis->m_xOleInPlaceActiveObject.GetWindow( lphwnd );
}

STDMETHODIMP CCollectionCtrl::XMyOleInPlaceActiveObject::ContextSensitiveHelp( BOOL fEnterMode )
{
	METHOD_MANAGE_STATE( CCollectionCtrl, MyOleInPlaceActiveObject )
	ASSERT_VALID( pThis );

	return pThis->m_xOleInPlaceActiveObject.ContextSensitiveHelp( fEnterMode );
}

STDMETHODIMP CCollectionCtrl::XMyOleInPlaceActiveObject::TranslateAccelerator( LPMSG lpmsg )
{
	METHOD_MANAGE_STATE( CCollectionCtrl, MyOleInPlaceActiveObject )
	ASSERT_VALID( pThis );

	return pThis->m_xOleInPlaceActiveObject.TranslateAccelerator( lpmsg );
}

STDMETHODIMP CCollectionCtrl::XMyOleInPlaceActiveObject::OnFrameWindowActivate( BOOL fActivate )
{
	METHOD_MANAGE_STATE( CCollectionCtrl, MyOleInPlaceActiveObject )
	ASSERT_VALID( pThis );

	return pThis->m_xOleInPlaceActiveObject.OnFrameWindowActivate( fActivate );
}

STDMETHODIMP CCollectionCtrl::XMyOleInPlaceActiveObject::OnDocWindowActivate( BOOL fActivate )
{
	METHOD_MANAGE_STATE( CCollectionCtrl, MyOleInPlaceActiveObject )
	ASSERT_VALID( pThis );

	return pThis->m_xOleInPlaceActiveObject.OnDocWindowActivate( fActivate );
}

STDMETHODIMP CCollectionCtrl::XMyOleInPlaceActiveObject::ResizeBorder(
	LPCRECT, LPOLEINPLACEUIWINDOW, BOOL fFrameWindow )
{
	METHOD_MANAGE_STATE( CCollectionCtrl, MyOleInPlaceActiveObject )
	ASSERT_VALID( pThis );

    if( fFrameWindow == TRUE )
	{
		pThis->OnShowToolBars();
	}

	return S_OK;
}

STDMETHODIMP CCollectionCtrl::XMyOleInPlaceActiveObject::EnableModeless( BOOL fEnable )
{
	METHOD_MANAGE_STATE( CCollectionCtrl, MyOleInPlaceActiveObject )
	ASSERT_VALID( pThis );

	return pThis->m_xOleInPlaceActiveObject.EnableModeless( fEnable );
}

/////////////////////////////////////////////////////////////////////////////
// CCollectionCtrl::OnDraw - Drawing function

void CCollectionCtrl::OnDraw(
			CDC* pdc, const CRect& rcBounds, const CRect& rcInvalid)
{
}


/////////////////////////////////////////////////////////////////////////////
// CCollectionCtrl::DoPropExchange - Persistence support

void CCollectionCtrl::DoPropExchange(CPropExchange* pPX)
{
	ExchangeVersion(pPX, MAKELONG(_wVerMinor, _wVerMajor));
	COleControl::DoPropExchange(pPX);

	// TODO: Call PX_ functions for each persistent custom property.

}


/////////////////////////////////////////////////////////////////////////////
// CCollectionCtrl::OnResetState - Reset control to default state

void CCollectionCtrl::OnResetState()
{
	COleControl::OnResetState();  // Resets defaults found in DoPropExchange
	IJazzFramework *pFramework = theApp.GetFramework();
	if (pFramework)
	{
		IJazzComponent *pDLS;
		pFramework->FindComponent(CLSID_DLSComponent,&pDLS);
		if (pDLS)
		{
			IDLSQueryInstruments *pDLSQuery;
			pDLS->QueryInterface(IID_IDLSQueryInstruments,(void **)&pDLSQuery);
			if (pDLSQuery)
			{
				signed char szCollectionName[200];
				pDLSQuery->ResetCollectionList();
				while (pDLSQuery->GetNextCollection(szCollectionName,200))
				{
					char szOutput[300];
					sprintf(szOutput,"%s:\n",szCollectionName);
					OutputDebugString(szOutput);
					pDLSQuery->ResetInstrumentList(szCollectionName);
					BYTE bMSB, bLSB, bPC;
					BOOL fDrums;
					signed char szName[200];
					while (pDLSQuery->GetNextInstrument(
									&bMSB, &bLSB, &bPC, &fDrums, szName, 200))
					{
						sprintf(szOutput,"\t%s: %ld,%ld,%ld, Drums: %ld, ",
							szName,(long)bMSB,(long)bLSB,(long)bPC,fDrums);
						pDLSQuery->GetInstrumentName(szCollectionName, 
									  bMSB,bLSB,bPC,fDrums,szName,200); 
						OutputDebugString(szOutput);
						sprintf(szOutput,"GetName returns %s\n", szName);
						OutputDebugString(szOutput);
					}
				}
				pDLSQuery->Release();
			}
			pDLS->Release();
		}
	}
	// TODO: Reset any other control state here.
}


/////////////////////////////////////////////////////////////////////////////
// CCollectionCtrl::AboutBox - Display an "About" box to the user

void CCollectionCtrl::AboutBox()
{
	CDialog dlgAbout(IDD_ABOUTBOX_COLLECTION);
	dlgAbout.DoModal();

}


/////////////////////////////////////////////////////////////////////////////
// CCollectionCtrl message handlers

int CCollectionCtrl::OnCreate(LPCREATESTRUCT lpCreateStruct) 
{
	if (COleControl::OnCreate(lpCreateStruct) == -1)
		return -1;
	
	// Create Collection's view
	m_pCollectionEditor = new CCollectionEditor(this);

	if( m_pCollectionEditor == NULL )
	{
		return -1;
	}

	if(m_pCollectionEditor->Create(NULL, 
								"WindowName", 
								WS_CHILD | WS_VISIBLE, 
								CRect( 0, 0, 800, 400 ), 
								this, 
								888, 
								NULL) == 0)
	{
		return -1;
	}


	m_pCollectionEditor->OnInitialUpdate(); 
	return 0;
}



	


void CCollectionCtrl::OnSize(UINT nType, int cx, int cy) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	COleControl::OnSize(nType, cx, cy);
	
	m_pCollectionEditor->MoveWindow( 0, 0, cx, cy );
}

void CCollectionCtrl::OnKeyDown(UINT nChar, UINT nRepCnt, UINT nFlags) 
{
	// TODO: Add your message handler code here and/or call default
	
	COleControl::OnKeyDown(nChar, nRepCnt, nFlags);
}

void CCollectionCtrl::OnKeyUp(UINT nChar, UINT nRepCnt, UINT nFlags) 
{
	// TODO: Add your message handler code here and/or call default
	
	COleControl::OnKeyUp(nChar, nRepCnt, nFlags);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\DLSDesigner\RemovedFromProject\CollectionEditor.h ===
#if !defined(AFX_COLLECTIONEDITOR_H__FA332522_C73E_11D0_876A_00AA00C08146__INCLUDED_)
#define AFX_COLLECTIONEDITOR_H__FA332522_C73E_11D0_876A_00AA00C08146__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
//  : header file
//

/////////////////////////////////////////////////////////////////////////////
// CCollectionEditor 

#ifndef __AFXEXT_H__
#include <afxext.h>
#endif

class CCollectionCtrl;

class CCollectionEditor : public CFormView
{
friend class CCollectionCtrl;

protected:
	CCollectionEditor(CCollectionCtrl* parent = NULL);         
	DECLARE_DYNCREATE(CCollectionEditor)

// Form Data
public:
	//{{AFX_DATA(CCollectionEditor)
	enum { IDD = IDD_COLLECTION };
	DWORD	m_dwVersion1;
	DWORD	m_dwVersion2;
	DWORD	m_dwVersion3;
	DWORD	m_dwVersion4;
	DWORD	m_dwSampleCount;
	CString	m_csSubject;
	CString	m_csName;
	CString	m_csEngineer;
	CString	m_csCopyright;
	CString	m_csComment;
	DWORD	m_dwArticCount;
	DWORD	m_dwInstCount;
	DWORD	m_dwRegionCount;
	DWORD	m_dwWaveCount;
	//}}AFX_DATA

// Attributes
public:

// Operations
public:

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CCollectionEditor)
	public:
	virtual BOOL Create(LPCTSTR lpszClassName, LPCTSTR lpszWindowName, DWORD dwStyle, const RECT& rect, CWnd* pParentWnd, UINT nID, CCreateContext* pContext = NULL);
	virtual void OnInitialUpdate();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	virtual ~CCollectionEditor();

#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

private:
	CCollectionCtrl* m_parent;

	// Generated message map functions
	//{{AFX_MSG(CCollectionEditor)
	afx_msg void OnChangeArticCount();
	afx_msg void OnChangeComment();
	afx_msg void OnChangeCopyright();
	afx_msg void OnChangeEngineer();
	afx_msg void OnChangeInstCount();
	afx_msg void OnChangeName();
	afx_msg void OnChangeRegionCount();
	afx_msg void OnChangeSampleCount();
	afx_msg void OnChangeSubject();
	afx_msg void OnChangeVer1();
	afx_msg void OnChangeVer2();
	afx_msg void OnChangeVer3();
	afx_msg void OnChangeVer4();
	afx_msg void OnChangeWaveCount();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_COLLECTIONEDITOR_H__FA332522_C73E_11D0_876A_00AA00C08146__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\DLSDesigner\RemovedFromProject\CollectionEditor.cpp ===
// CollectionView.cpp : implementation file
//

#include "stdafx.h"
#include "resource.h"
#include "dlsdesigner.h"
#include "Collection.h"
#include "CollectionCtl.h"
#include "CollectionEditor.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CCollectionEditor

IMPLEMENT_DYNCREATE(CCollectionEditor, CFormView)

CCollectionEditor::CCollectionEditor(CCollectionCtrl* parent)
				 : CFormView(CCollectionEditor::IDD)
{
	m_parent = parent;

	//{{AFX_DATA_INIT(CCollectionEditor)
	m_dwVersion1 = 0;
	m_dwVersion2 = 0;
	m_dwVersion3 = 0;
	m_dwVersion4 = 0;
	m_dwSampleCount = 0;
	m_csSubject = _T("");
	m_csName = _T("");
	m_csEngineer = _T("");
	m_csCopyright = _T("");
	m_csComment = _T("");
	m_dwArticCount = 0;
	m_dwInstCount = 0;
	m_dwRegionCount = 0;
	m_dwWaveCount = 0;
	//}}AFX_DATA_INIT
}

CCollectionEditor::~CCollectionEditor()
{
}

void CCollectionEditor::DoDataExchange(CDataExchange* pDX)
{
	CFormView::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CCollectionEditor)
	DDX_Text(pDX, IDC_VER_1, m_dwVersion1);
	DDV_MinMaxDWord(pDX, m_dwVersion1, 0, 65535);
	DDX_Text(pDX, IDC_VER_2, m_dwVersion2);
	DDV_MinMaxDWord(pDX, m_dwVersion2, 0, 65535);
	DDX_Text(pDX, IDC_VER_3, m_dwVersion3);
	DDV_MinMaxDWord(pDX, m_dwVersion3, 0, 65535);
	DDX_Text(pDX, IDC_VER_4, m_dwVersion4);
	DDV_MinMaxDWord(pDX, m_dwVersion4, 0, 65535);
	DDX_Text(pDX, IDC_SAMPLE_COUNT, m_dwSampleCount);
	DDV_MinMaxDWord(pDX, m_dwSampleCount, 0, 1000000000);
	DDX_Text(pDX, IDC_SUBJECT, m_csSubject);
	DDX_Text(pDX, IDC_NAME, m_csName);
	DDX_Text(pDX, IDC_ENGINEER, m_csEngineer);
	DDX_Text(pDX, IDC_COPYRIGHT, m_csCopyright);
	DDX_Text(pDX, IDC_COMMENT, m_csComment);
	DDX_Text(pDX, IDC_ARTIC_COUNT, m_dwArticCount);
	DDX_Text(pDX, IDC_INST_COUNT, m_dwInstCount);
	DDX_Text(pDX, IDC_REGION_COUNT, m_dwRegionCount);
	DDX_Text(pDX, IDC_WAVE_COUNT, m_dwWaveCount);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CCollectionEditor, CFormView)
	//{{AFX_MSG_MAP(CCollectionEditor)
	ON_EN_CHANGE(IDC_ARTIC_COUNT, OnChangeArticCount)
	ON_EN_CHANGE(IDC_COMMENT, OnChangeComment)
	ON_EN_CHANGE(IDC_COPYRIGHT, OnChangeCopyright)
	ON_EN_CHANGE(IDC_ENGINEER, OnChangeEngineer)
	ON_EN_CHANGE(IDC_INST_COUNT, OnChangeInstCount)
	ON_EN_CHANGE(IDC_NAME, OnChangeName)
	ON_EN_CHANGE(IDC_REGION_COUNT, OnChangeRegionCount)
	ON_EN_CHANGE(IDC_SAMPLE_COUNT, OnChangeSampleCount)
	ON_EN_CHANGE(IDC_SUBJECT, OnChangeSubject)
	ON_EN_CHANGE(IDC_VER_1, OnChangeVer1)
	ON_EN_CHANGE(IDC_VER_2, OnChangeVer2)
	ON_EN_CHANGE(IDC_VER_3, OnChangeVer3)
	ON_EN_CHANGE(IDC_VER_4, OnChangeVer4)
	ON_EN_CHANGE(IDC_WAVE_COUNT, OnChangeWaveCount)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CCollectionEditor diagnostics

#ifdef _DEBUG
void CCollectionEditor::AssertValid() const
{
	CFormView::AssertValid();
}

void CCollectionEditor::Dump(CDumpContext& dc) const
{
	CFormView::Dump(dc);
}
#endif //_DEBUG

/////////////////////////////////////////////////////////////////////////////
// CCollectionEditor message handlers

BOOL CCollectionEditor::Create(LPCTSTR lpszClassName, LPCTSTR lpszWindowName, DWORD dwStyle, const RECT& rect, CWnd* pParentWnd, UINT nID, CCreateContext* pContext) 
{
	// TODO: Add your specialized code here and/or call the base class
	
	return CFormView::Create(lpszClassName, lpszWindowName, dwStyle, rect, pParentWnd, nID, pContext);
}

void CCollectionEditor::OnInitialUpdate() 
{
	CCollection *pCollection = m_parent->GetCollection();

	m_csName = pCollection->m_Info.m_csName;
	m_csCopyright = pCollection->m_Info.m_csCopyright;
	m_csEngineer = pCollection->m_Info.m_csEngineer;
	m_csSubject = pCollection->m_Info.m_csSubject;
	m_csComment = pCollection->m_Info.m_csComment;
    m_dwSampleCount = pCollection->SampleCount();
	m_dwArticCount = pCollection->ArticulationCount();
	m_dwInstCount = pCollection->InstrumentCount();
	m_dwWaveCount = pCollection->WaveCount();
	m_dwRegionCount = pCollection->RegionCount();
	m_dwVersion1 = HIWORD(pCollection->m_rVersion.dwVersionMS);
	m_dwVersion2 = LOWORD(pCollection->m_rVersion.dwVersionMS);
	m_dwVersion3 = HIWORD(pCollection->m_rVersion.dwVersionLS);
	m_dwVersion4 = LOWORD(pCollection->m_rVersion.dwVersionLS);

	CFormView::OnInitialUpdate();
}

void CCollectionEditor::OnChangeArticCount() 
{
	ASSERT(FALSE);
}

void CCollectionEditor::OnChangeComment() 
{
	BOOL b;
	b = UpdateData(TRUE);	

	if(b)
	{
		CCollection *pCollection = m_parent->GetCollection();			
		pCollection->m_Info.m_csComment = m_csComment;
	}
	else
	{
		// Add better error handling for J3
	}
}

void CCollectionEditor::OnChangeCopyright() 
{
	BOOL b;
	b = UpdateData(TRUE);	

	if(b)
	{
		CCollection *pCollection = m_parent->GetCollection();		
		pCollection->m_Info.m_csCopyright = m_csCopyright;
	}
	else
	{
		// Add better error handling for J3
	}
}

void CCollectionEditor::OnChangeEngineer() 
{
	BOOL b;
	b = UpdateData(TRUE);	

	if(b)
	{
		CCollection *pCollection = m_parent->GetCollection();			
		pCollection->m_Info.m_csEngineer = m_csEngineer;	
	}
	else
	{
		// Add better error handling for J3
	}
}

void CCollectionEditor::OnChangeInstCount() 
{
	ASSERT(FALSE);
}

void CCollectionEditor::OnChangeName() 
{
	BOOL b;
	b = UpdateData(TRUE);	

	if(b)
	{
		CCollection *pCollection = m_parent->GetCollection();			
        pCollection->m_Info.m_csName = m_csName;
		
		BSTR bstrName = pCollection->m_Info.m_csName.AllocSysString();
		pCollection->SetNodeName(bstrName);
	}
	else
	{
		// Add better error handling for J3
	}
}

void CCollectionEditor::OnChangeRegionCount() 
{
	ASSERT(FALSE);
}

void CCollectionEditor::OnChangeSampleCount() 
{
	ASSERT(FALSE);
}

void CCollectionEditor::OnChangeSubject() 
{
	BOOL b;
	b = UpdateData(TRUE);	

	if(b)
	{
		CCollection *pCollection = m_parent->GetCollection();			
        pCollection->m_Info.m_csSubject = m_csSubject;
	}
	else
	{
		// Add better error handling for J3
	}
}

void CCollectionEditor::OnChangeVer1() 
{
	BOOL b;
	b = UpdateData(TRUE);	

	if(b)
	{
		CCollection *pCollection = m_parent->GetCollection();			
		pCollection->m_rVersion.dwVersionMS = (m_dwVersion1 << 16) | m_dwVersion2;
	}
	else
	{
		// Add better error handling for J3
	}
}

void CCollectionEditor::OnChangeVer2() 
{
	BOOL b;
	b = UpdateData(TRUE);	

	if(b)
	{
		CCollection *pCollection = m_parent->GetCollection();			
		pCollection->m_rVersion.dwVersionMS = (m_dwVersion1 << 16) | m_dwVersion2;
	}
	else
	{
		// Add better error handling for J3
	}
}

void CCollectionEditor::OnChangeVer3() 
{
	BOOL b;
	b = UpdateData(TRUE);	

	if(b)
	{
		CCollection *pCollection = m_parent->GetCollection();			
		pCollection->m_rVersion.dwVersionLS = (m_dwVersion3 << 16) | m_dwVersion4;
	}
	else
	{
		// Add better error handling for J3
	}
}

void CCollectionEditor::OnChangeVer4() 
{
	BOOL b;
	b = UpdateData(TRUE);	

	if(b)
	{
		CCollection *pCollection = m_parent->GetCollection();			
		pCollection->m_rVersion.dwVersionLS = (m_dwVersion3 << 16) | m_dwVersion4;
	}
	else
	{
		// Add better error handling for J3
	}
}

void CCollectionEditor::OnChangeWaveCount() 
{
	ASSERT(FALSE);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\DLSDesigner\RemovedFromProject\CollectionCtl.h ===
#if !defined(AFX_COLLECTIONCTL_H__BC964EA4_96F7_11D0_89AA_00A0C9054129__INCLUDED_)
#define AFX_COLLECTIONCTL_H__BC964EA4_96F7_11D0_89AA_00A0C9054129__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include "CollectionEditor.h"

// CollectionCtl.h : Declaration of the CCollectionCtrl ActiveX Control class.

/////////////////////////////////////////////////////////////////////////////
// CCollectionCtrl : See CollectionCtl.cpp for implementation.

class CCollectionCtrl : public COleControl
{
	DECLARE_DYNCREATE(CCollectionCtrl)

// Constructor
public:
	CCollectionCtrl();
	CCollection* GetCollection() {return(m_pCollection);}

// Attributes
public:

private:
	HWND				m_hWndContainer;
	HMENU				m_hMenuInPlace;
	CToolBar*			m_pToolBar;
	CCollection*		m_pCollection;
	CCollectionEditor*	m_pCollectionEditor;

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CCollectionCtrl)
	public:
	virtual void OnDraw(CDC* pdc, const CRect& rcBounds, const CRect& rcInvalid);
	virtual void DoPropExchange(CPropExchange* pPX);
	virtual void OnResetState();
	//}}AFX_VIRTUAL

// Implementation
protected:
	~CCollectionCtrl();

	DECLARE_OLECREATE_EX(CCollectionCtrl)    // Class factory and guid
	DECLARE_OLETYPELIB(CCollectionCtrl)      // GetTypeInfo
	DECLARE_PROPPAGEIDS(CCollectionCtrl)     // Property page IDs
	DECLARE_OLECTLTYPE(CCollectionCtrl)		// Type name and misc status

// Message maps
	//{{AFX_MSG(CCollectionCtrl)
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	afx_msg void OnSize(UINT nType, int cx, int cy);
	afx_msg void OnKeyDown(UINT nChar, UINT nRepCnt, UINT nFlags);
	afx_msg void OnKeyUp(UINT nChar, UINT nRepCnt, UINT nFlags);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

// Dispatch maps
	//{{AFX_DISPATCH(CCollectionCtrl)
		// NOTE - ClassWizard will add and remove member functions here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_DISPATCH
	DECLARE_DISPATCH_MAP()

	afx_msg void AboutBox();

// Event maps
	//{{AFX_EVENT(CCollectionCtrl)
		// NOTE - ClassWizard will add and remove member functions here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_EVENT
	DECLARE_EVENT_MAP()

// Dispatch and event IDs
public:

	// IOleInPlaceActiveObject
	BEGIN_INTERFACE_PART(MyOleInPlaceActiveObject, IOleInPlaceActiveObject)
		INIT_INTERFACE_PART(COleControl, MyOleInPlaceActiveObject)
		STDMETHOD(GetWindow)(HWND*);
		STDMETHOD(ContextSensitiveHelp)(BOOL);
		STDMETHOD(TranslateAccelerator)(LPMSG);
		STDMETHOD(OnFrameWindowActivate)(BOOL);
		STDMETHOD(OnDocWindowActivate)(BOOL);
		STDMETHOD(ResizeBorder)(LPCRECT, LPOLEINPLACEUIWINDOW, BOOL);
		STDMETHOD(EnableModeless)(BOOL);
	END_INTERFACE_PART(MyOleInPlaceActiveObject)

    // IJazzEditor functions
	BEGIN_INTERFACE_PART(Editor, IJazzEditor)
		STDMETHOD(AttachObjects)(IJazzNode*, IOleUndoManager*);
		STDMETHOD(OnInitMenuFilePrint)(HMENU, UINT);
		STDMETHOD(OnFilePrint)();
		STDMETHOD(OnInitMenuFilePrintPreview)(HMENU, UINT);
		STDMETHOD(OnFilePrintPreview)();
	END_INTERFACE_PART(Editor)

	DECLARE_INTERFACE_MAP()

	enum {
	//{{AFX_DISP_ID(CCollectionCtrl)
		// NOTE: ClassWizard will add and remove enumeration elements here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_DISP_ID
	};
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_COLLECTIONCTL_H__BC964EA4_96F7_11D0_89AA_00A0C9054129__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\DLSDesigner\RemovedFromProject\CollectionPpg.cpp ===
// CollectionPpg.cpp : Implementation of the CCollectionPropPage property page class.

#include "stdafx.h"
#include "DLSDesignerDLL.h"
#include "CollectionPpg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


IMPLEMENT_DYNCREATE(CCollectionPropPage, COlePropertyPage)


/////////////////////////////////////////////////////////////////////////////
// Message map

BEGIN_MESSAGE_MAP(CCollectionPropPage, COlePropertyPage)
	//{{AFX_MSG_MAP(CCollectionPropPage)
	// NOTE - ClassWizard will add and remove message map entries
	//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// Initialize class factory and guid

IMPLEMENT_OLECREATE_EX(CCollectionPropPage, "DLSDESIGNER.CollectionPropPage.1",
	0xbc964e87, 0x96f7, 0x11d0, 0x89, 0xaa, 0, 0xa0, 0xc9, 0x5, 0x41, 0x29)


/////////////////////////////////////////////////////////////////////////////
// CCollectionPropPage::CCollectionPropPageFactory::UpdateRegistry -
// Adds or removes system registry entries for CCollectionPropPage

BOOL CCollectionPropPage::CCollectionPropPageFactory::UpdateRegistry(BOOL bRegister)
{
	if (bRegister)
		return AfxOleRegisterPropertyPageClass(AfxGetInstanceHandle(),
			m_clsid, IDS_COLLECTION_PPG);
	else
		return AfxOleUnregisterClass(m_clsid, NULL);
}


/////////////////////////////////////////////////////////////////////////////
// CCollectionPropPage::CCollectionPropPage - Constructor

CCollectionPropPage::CCollectionPropPage() :
	COlePropertyPage(IDD, IDS_COLLECTION_PPG_CAPTION)
{
	//{{AFX_DATA_INIT(CCollectionPropPage)
	// NOTE: ClassWizard will add member initialization here
	//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_DATA_INIT
}


/////////////////////////////////////////////////////////////////////////////
// CCollectionPropPage::DoDataExchange - Moves data between page and properties

void CCollectionPropPage::DoDataExchange(CDataExchange* pDX)
{
	//{{AFX_DATA_MAP(CCollectionPropPage)
	// NOTE: ClassWizard will add DDP, DDX, and DDV calls here
	//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_DATA_MAP
	DDP_PostProcessing(pDX);
}


/////////////////////////////////////////////////////////////////////////////
// CCollectionPropPage message handlers
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\DLSDesigner\RemovedFromProject\CollectionPpg.h ===
#if !defined(AFX_COLLECTIONPPG_H__BC964EA6_96F7_11D0_89AA_00A0C9054129__INCLUDED_)
#define AFX_COLLECTIONPPG_H__BC964EA6_96F7_11D0_89AA_00A0C9054129__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

// CollectionPpg.h : Declaration of the CCollectionPropPage property page class.

////////////////////////////////////////////////////////////////////////////
// CCollectionPropPage : See CollectionPpg.cpp.cpp for implementation.

class CCollectionPropPage : public COlePropertyPage
{
	DECLARE_DYNCREATE(CCollectionPropPage)
	DECLARE_OLECREATE_EX(CCollectionPropPage)

// Constructor
public:
	CCollectionPropPage();

// Dialog Data
	//{{AFX_DATA(CCollectionPropPage)
	enum { IDD = IDD_PROPPAGE_COLLECTION };
		// NOTE - ClassWizard will add data members here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_DATA

// Implementation
protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support

// Message maps
protected:
	//{{AFX_MSG(CCollectionPropPage)
		// NOTE - ClassWizard will add and remove member functions here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_COLLECTIONPPG_H__BC964EA6_96F7_11D0_89AA_00A0C9054129__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\DLSDesigner\RemovedFromProject\DLSRiffID.h ===
#ifndef __DLSRIFFID_H__
#define __DLSRIFFID_H__

// DLSRiffId.h : header file
//

#define MAKETAG( ch0, ch1, ch2, ch3 )                                \
                ( (DWORD)(BYTE)(ch0) | ( (DWORD)(BYTE)(ch1) << 8 ) |    \
                ( (DWORD)(BYTE)(ch2) << 16 ) | ( (DWORD)(BYTE)(ch3) << 24 ) )

#define RIFF_TAG						MAKETAG('R','I','F','F')
#define LIST_TAG						MAKETAG('L','I','S','T')

#define ID_DLS_FOLDER					MAKETAG('F','D','L','S')
#define ID_COLLECTION_NODE				MAKETAG('N','C','o','l')
#define ID_INSTRUMENT_FOLDER			MAKETAG('F','I','n','s')
#define ID_INSTRUMENT_NODE				MAKETAG('N','I','n','s')
#define ID_ARTICULATION_NODE			MAKETAG('N','A','r','t')
#define ID_REGION_FOLDER				MAKETAG('F','R','e','g')
#define ID_REGION_NODE					MAKETAG('N','R','e','g')
#define ID_VARCHOICES_FOLDER			MAKETAG('F','V','a','r')
#define ID_WAVE_FOLDER					MAKETAG('F','W','a','v')
#define ID_WAVE_NODE					MAKETAG('N','W','a','v')

#define DLS_REGION_EXTRA_CHUNK			mmioFOURCC('d','m','p','r')
#endif // __DLSRIFFID_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\DLSDesigner\RemovedFromProject\edittag.h ===
//////////////////////////////////////////////////////////////////////
//
//	EditTag.h
//
//////////////////////////////////////////////////////////////////////

#ifndef _INC_EDITTAG
#define _INC_EDITTAG

#define FOURCC_EDIT	mmioFOURCC('e','d','i','t')
#define FOURCC_MSYN mmioFOURCC('m','s','y','n')

#endif // _INC_EDITTAG
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\DLSDesigner\RemovedFromProject\dls.h ===
//==========================================================================;
//
//  dls.h
//
//
//  Description:
//
//  Interface defines and structures for the Instrument Collection Form
//  RIFF DLS.
//
//
//  Written by Sonic Foundry 1996.  Released for public use.
//
//==========================================================================;

#ifndef _INC_DLS
#define _INC_DLS

///////////////////////////////////////////////////////////////////////////
//
//
// Layout of an instrument collection:
//
//
// RIFF [] 'DLS ' [colh,INSTLIST,WAVEPOOL,INFOLIST]
//
// INSTLIST
// LIST [] 'lins'
//               LIST [] 'ins ' [insh,RGNLIST,ARTLIST,INFOLIST]
//               LIST [] 'ins ' [insh,RGNLIST,ARTLIST,INFOLIST]
//               LIST [] 'ins ' [insh,RGNLIST,ARTLIST,INFOLIST]
//
// RGNLIST
// LIST [] 'lrgn' 
//               LIST [] 'rgn '  [rgnh,wsmp,wlnk,ARTLIST]
//               LIST [] 'rgn '  [rgnh,wsmp,wlnk,ARTLIST]
//               LIST [] 'rgn '  [rgnh,wsmp,wlnk,ARTLIST]
//
// ARTLIST
// LIST [] 'lart'
//         'art1' level 1 Articulation connection graph
//         'art2' level 2 Articulation connection graph
//         '3rd1' Possible 3rd party articulation structure 1
//         '3rd2' Possible 3rd party articulation structure 2 .... and so on
//
// WAVEPOOL 
// ptbl [] [pool table]
// LIST [] 'wvpl'
//               [path],
//               [path],
//               LIST [] 'wave',RIFFWAVE
//               LIST [] 'wave',RIFFWAVE
//               LIST [] 'wave',RIFFWAVE
//               LIST [] 'wave',RIFFWAVE
//               LIST [] 'wave',RIFFWAVE
//
// INFOLIST
// LIST [] 'INFO' 
//               'icmt' 'One of those crazy comments.'
//               'icop' 'Copyright (C) 1996 Sonic Foundry'
//
///////////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////////
// FOURCC's used in the DLS file
///////////////////////////////////////////////////////////////////////////

#define FOURCC_DLS   mmioFOURCC('D','L','S',' ')
#define FOURCC_COLH  mmioFOURCC('c','o','l','h')
#define FOURCC_WVPL  mmioFOURCC('w','v','p','l')
#define FOURCC_PTBL  mmioFOURCC('p','t','b','l')
#define FOURCC_PATH  mmioFOURCC('p','a','t','h')
#define FOURCC_wave  mmioFOURCC('w','a','v','e')
#define FOURCC_LINS  mmioFOURCC('l','i','n','s')
#define FOURCC_INS   mmioFOURCC('i','n','s',' ')
#define FOURCC_INSH  mmioFOURCC('i','n','s','h')
#define FOURCC_LRGN  mmioFOURCC('l','r','g','n')
#define FOURCC_RGN   mmioFOURCC('r','g','n',' ')
#define FOURCC_RGNH  mmioFOURCC('r','g','n','h')
#define FOURCC_LART  mmioFOURCC('l','a','r','t')
#define FOURCC_ART1  mmioFOURCC('a','r','t','1')
#define FOURCC_WLNK  mmioFOURCC('w','l','n','k')
#define FOURCC_WSMP  mmioFOURCC('w','s','m','p')
#define FOURCC_VERS  mmioFOURCC('v','e','r','s')

///////////////////////////////////////////////////////////////////////////
// Articulation connection graph definitions 
///////////////////////////////////////////////////////////////////////////

// Generic Sources
#define CONN_SRC_NONE              0x0000
#define CONN_SRC_LFO               0x0001
#define CONN_SRC_KEYONVELOCITY     0x0002
#define CONN_SRC_KEYNUMBER         0x0003
#define CONN_SRC_EG1               0x0004
#define CONN_SRC_EG2               0x0005
#define CONN_SRC_PITCHWHEEL        0x0006

// Midi Controllers 0-127
#define CONN_SRC_CC1               0x0081
#define CONN_SRC_CC7               0x0087
#define CONN_SRC_CC10              0x008a
#define CONN_SRC_CC11              0x008b

// Generic Destinations
#define CONN_DST_NONE              0x0000
#define CONN_DST_ATTENUATION       0x0001
#define CONN_DST_RESERVED          0x0002
#define CONN_DST_PITCH             0x0003
#define CONN_DST_PAN               0x0004

// LFO Destinations
#define CONN_DST_LFO_FREQUENCY     0x0104
#define CONN_DST_LFO_STARTDELAY    0x0105

// EG1 Destinations
#define CONN_DST_EG1_ATTACKTIME    0x0206
#define CONN_DST_EG1_DECAYTIME     0x0207
#define CONN_DST_EG1_RESERVED      0x0208
#define CONN_DST_EG1_RELEASETIME   0x0209
#define CONN_DST_EG1_SUSTAINLEVEL  0x020a

// EG2 Destinations
#define CONN_DST_EG2_ATTACKTIME    0x030a
#define CONN_DST_EG2_DECAYTIME     0x030b
#define CONN_DST_EG2_RESERVED      0x030c
#define CONN_DST_EG2_RELEASETIME   0x030d
#define CONN_DST_EG2_SUSTAINLEVEL  0x030e

#define CONN_TRN_NONE              0x0000
#define CONN_TRN_CONCAVE           0x0001

typedef struct _DLSVERSION {
  DWORD    dwVersionMS;
  DWORD    dwVersionLS;
}DLSVERSION, FAR *LPDLSVERSION;
				   

typedef struct _CONNECTION {
  USHORT   usSource;
  USHORT   usControl;
  USHORT   usDestination;
  USHORT   usTransform;
  LONG     lScale;
  }CONNECTION, FAR *LPCONNECTION;


// Level 1 Articulation Data

typedef struct _CONNECTIONLIST {
  ULONG    cbSize;            // size of the connection list structure
  ULONG    cConnections;      // count of connections in the list
  } CONNECTIONLIST, FAR *LPCONNECTIONLIST;



///////////////////////////////////////////////////////////////////////////
// Generic type defines for regions and instruments
///////////////////////////////////////////////////////////////////////////

typedef struct _RGNRANGE {
  USHORT usLow;
  USHORT usHigh;
}RGNRANGE, FAR * LPRGNRANGE;

#define F_INSTRUMENT_DRUMS      0x80000000

typedef struct _MIDILOCALE {
  ULONG ulBank;
  ULONG ulInstrument;
}MIDILOCALE, FAR *LPMIDILOCALE;

///////////////////////////////////////////////////////////////////////////
// Header structures found in an DLS file for collection, instruments, and
// regions.
///////////////////////////////////////////////////////////////////////////

#define F_RGN_OPTION_SELFNONEXCLUSIVE  0x0001

typedef struct _RGNHEADER {
  RGNRANGE RangeKey;            // Key range 
  RGNRANGE RangeVelocity;       // Velocity Range 
  USHORT   fusOptions;          // Synthesis options for this range
  USHORT   usKeyGroup;          // Key grouping for non simultaneous play
                                // 0 = no group, 1 up is group
                                // for Level 1 only groups 1-15 are allowed
}RGNHEADER, FAR *LPRGNHEADER;

typedef struct _INSTHEADER {
  ULONG      cRegions;          // Count of regions in this instrument
  MIDILOCALE Locale;            // Intended MIDI locale of this instrument
}INSTHEADER, FAR *LPINSTHEADER;

typedef struct _DLSHEADER {
  ULONG      cInstruments;      // Count of instruments in the collection
}DLSHEADER, FAR *LPDLSHEADER;

//////////////////////////////////////////////////////////////////////////////
// definitions for the Wave link structure
//////////////////////////////////////////////////////////////////////////////

// ****  For level 1 only WAVELINK_CHANNEL_MONO is valid  ****
// ulChannel allows for up to 32 channels of audio with each bit position
// specifiying a channel of playback

#define WAVELINK_CHANNEL_LEFT    0x0001l
#define WAVELINK_CHANNEL_RIGHT   0x0002l

#define F_WAVELINK_PHASE_MASTER  0x0001

typedef struct _WAVELINK { // any paths or links are stored right after struct
  USHORT   fusOptions;     // options flags for this wave
  USHORT   usPhaseGroup;   // Phase grouping for locking channels
  ULONG    ulChannel;      // channel placement
  ULONG    ulTableIndex;   // index into the wave pool table, 0 based
}WAVELINK, FAR *LPWAVELINK;

#define POOL_CUE_NULL  0xffffffffl

typedef struct _POOLCUE { 
//  ULONG    ulEntryIndex;   // Index entry in the list
  ULONG    ulOffset;       // Offset to the entry in the list
}POOLCUE, FAR *LPPOOLCUE;

typedef struct _POOLTABLE {
  ULONG    cbSize;            // size of the pool table structure
  ULONG    cCues;             // count of cues in the list
  } POOLTABLE, FAR *LPPOOLTABLE;

//////////////////////////////////////////////////////////////////////////////
// Structures for the "wsmp" chunk
//////////////////////////////////////////////////////////////////////////////

#define F_WSMP_NO_TRUNCATION     0x0001l
#define F_WSMP_NO_COMPRESSION    0x0002l


typedef struct _rwsmp {
  ULONG   cbSize;
  USHORT  usUnityNote;         // MIDI Unity Playback Note
  SHORT   sFineTune;           // Fine Tune in log tuning
  LONG    lAttenuation;        // Overall Attenuation to be applied to data
  ULONG   fulOptions;          // Flag options 
  ULONG   cSampleLoops;        // Count of Sample loops, 0 loops is one shot
  } WSMPL, FAR *LPWSMPL;


// This loop type is a normal forward playing loop which is continually
// played until the envelope reaches an off threshold in the release
// portion of the volume envelope

#define WLOOP_TYPE_FORWARD   0

typedef struct _rloop {
  ULONG cbSize;
  ULONG ulType;              // Loop Type
  ULONG ulStart;             // Start of loop in samples
  ULONG ulLength;            // Length of loop in samples
} WLOOP, FAR *LPWLOOP;

#endif //_INC_DLS
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\DLSDesigner\RemovedFromProject\Enum.cpp ===
// Enum.cpp : implementation file
//

#include "stdafx.h"

#include "DLSDesignerDLL.h"
#include "Collection.h"
#include "Instrument.h"
#include "Enum.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// CEnumCollectionFolder construction

CEnumCollectionFolder::CEnumCollectionFolder()
{
    ASSERT( 1 );
}

CEnumCollectionFolder::CEnumCollectionFolder( AList *pList )
{
    m_dwRef = 1;
    m_dwPos   = 0;
	m_pList = pList;
}


/////////////////////////////////////////////////////////////////////////////
// CEnumCollectionFolder IUnknown implementation

HRESULT CEnumCollectionFolder::QueryInterface( REFIID riid, LPVOID FAR* ppvObj )
{
    if( ::IsEqualIID(riid, IID_IEnumJazzNodes)
	||  ::IsEqualIID(riid, IID_IUnknown) )
    {
        AddRef();
        *ppvObj = this;
        return S_OK;
    }

    *ppvObj = NULL;
    return E_NOINTERFACE;
}

ULONG CEnumCollectionFolder::AddRef()
{
    return ++m_dwRef;
}

ULONG CEnumCollectionFolder::Release()
{
    ASSERT( m_dwRef != 0 );

    --m_dwRef;

    if( m_dwRef == 0 )
    {
        delete this;
        return 0;
    }

    return m_dwRef;
}


/////////////////////////////////////////////////////////////////////////////
// CEnumCollectionFolder IEnumJazzNodes implementation

HRESULT CEnumCollectionFolder::Next( ULONG celt, IJazzNode __RPC_FAR* __RPC_FAR* rgelt, ULONG __RPC_FAR* pceltFetched )
{
    ULONG ulFetched;
	IJazzNode* pNode;
	CCollection* pCollection;
    HRESULT hr;

    if( celt == 0 || ( celt > 1 && pceltFetched == NULL ) )
    {
        return E_INVALIDARG;
    }

    ulFetched = 0;
    hr = S_OK;
    
	do
    {
		pCollection = (CCollection *) m_pList->GetItem( m_dwPos++ );
		if (!pCollection)	// End of list?
		{
			hr = S_FALSE;
			break;
		}

		if( !SUCCEEDED ( pCollection->QueryInterface( IID_IJazzNode, (void**)&pNode ) ) )
		{
            hr = S_FALSE;
            break;
		}
		pNode->Release();	// intentional Release()
        *rgelt++ = pNode;
        ++ulFetched;
    }
	while( --celt > 0 );

    if( pceltFetched != NULL )
    {
        *pceltFetched = ulFetched;
    }

    return hr;
}

HRESULT CEnumCollectionFolder::Skip( ULONG celt )
{
	m_dwPos += celt;
    return S_OK;
}

HRESULT CEnumCollectionFolder::Reset()
{
    m_dwPos = 0;
    return S_OK;
}

HRESULT CEnumCollectionFolder::Clone( IEnumJazzNodes __RPC_FAR* __RPC_FAR* ppEnum )
{
    CEnumCollectionFolder* pEnum;

    if( ppEnum == NULL )
    {
        return E_INVALIDARG;
    }

    pEnum = new CEnumCollectionFolder( m_pList );

    if( pEnum == NULL )
    {
        return E_OUTOFMEMORY;
    }

    *ppEnum = pEnum;

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\DLSDesigner\RemovedFromProject\InstrumentPpg.cpp ===
// InstrumentPpg.cpp : Implementation of the CInstrumentPropPage property page class.

#include "stdafx.h"
#include "DLSDesignerDLL.h"
#include "InstrumentPpg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


IMPLEMENT_DYNCREATE(CInstrumentPropPage, COlePropertyPage)


/////////////////////////////////////////////////////////////////////////////
// Message map

BEGIN_MESSAGE_MAP(CInstrumentPropPage, COlePropertyPage)
	//{{AFX_MSG_MAP(CInstrumentPropPage)
	// NOTE - ClassWizard will add and remove message map entries
	//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// Initialize class factory and guid

IMPLEMENT_OLECREATE_EX(CInstrumentPropPage, "DLSDESIGNER.InstrumentPropPage.1",
	0xbc964e8b, 0x96f7, 0x11d0, 0x89, 0xaa, 0, 0xa0, 0xc9, 0x5, 0x41, 0x29)


/////////////////////////////////////////////////////////////////////////////
// CInstrumentPropPage::CInstrumentPropPageFactory::UpdateRegistry -
// Adds or removes system registry entries for CInstrumentPropPage

BOOL CInstrumentPropPage::CInstrumentPropPageFactory::UpdateRegistry(BOOL bRegister)
{
	if (bRegister)
		return AfxOleRegisterPropertyPageClass(AfxGetInstanceHandle(),
			m_clsid, IDS_INSTRUMENT_PPG);
	else
		return AfxOleUnregisterClass(m_clsid, NULL);
}


/////////////////////////////////////////////////////////////////////////////
// CInstrumentPropPage::CInstrumentPropPage - Constructor

CInstrumentPropPage::CInstrumentPropPage() :
	COlePropertyPage(IDD, IDS_INSTRUMENT_PPG_CAPTION)
{
	//{{AFX_DATA_INIT(CInstrumentPropPage)
	// NOTE: ClassWizard will add member initialization here
	//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_DATA_INIT
}


/////////////////////////////////////////////////////////////////////////////
// CInstrumentPropPage::DoDataExchange - Moves data between page and properties

void CInstrumentPropPage::DoDataExchange(CDataExchange* pDX)
{
	//{{AFX_DATA_MAP(CInstrumentPropPage)
	// NOTE: ClassWizard will add DDP, DDX, and DDV calls here
	//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_DATA_MAP
	DDP_PostProcessing(pDX);
}


/////////////////////////////////////////////////////////////////////////////
// CInstrumentPropPage message handlers
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\DLSDesigner\RemovedFromProject\InstrumentEditor.h ===
#if !defined(AFX_INSTRUMENTEDITOR_H__D0620363_CB9E_11D0_876A_00AA00C08146__INCLUDED_)
#define AFX_INSTRUMENTEDITOR_H__D0620363_CB9E_11D0_876A_00AA00C08146__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// InstrumentEditor.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CInstrumentEditor form view

#ifndef __AFXEXT_H__
#include <afxext.h>
#endif

#include "Collection.h"

class CInstrument;
class CInstrumentCtrl;

class CInstrumentEditor : public CFormView
{
friend class CInstrumentCtrl;

protected:
	CInstrumentEditor(CInstrumentCtrl *parent = NULL);	// protected constructor used by dynamic creation
	DECLARE_DYNCREATE(CInstrumentEditor)

// Form Data
public:
	//{{AFX_DATA(CInstrumentEditor)
	enum { IDD = IDD_INSTRUMENT };
	UINT	m_wBank;
	UINT	m_wBank2;
	UINT	m_wPatch;
	BOOL	m_fIsDrumKit;
	//}}AFX_DATA

// Attributes
public:

// Operations
public:

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CInstrumentEditor)
	public:
	virtual BOOL Create(LPCTSTR lpszClassName, LPCTSTR lpszWindowName, DWORD dwStyle, const RECT& rect, CWnd* pParentWnd, UINT nID, CCreateContext* pContext = NULL);
	virtual void OnInitialUpdate();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	virtual ~CInstrumentEditor();
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

private:
	CInstrumentCtrl* m_parent;
	CInstrument* m_pInstrument;
	CCollection* m_pCollection;

	// Generated message map functions
	//{{AFX_MSG(CInstrumentEditor)
	afx_msg void OnChangeBank();
	afx_msg void OnChangeBank2();
	afx_msg void OnDrums();
	afx_msg void OnChangePatch();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_INSTRUMENTEDITOR_H__D0620363_CB9E_11D0_876A_00AA00C08146__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\DLSDesigner\RemovedFromProject\InstrumentPpg.h ===
#if !defined(AFX_INSTRUMENTPPG_H__BC964EAB_96F7_11D0_89AA_00A0C9054129__INCLUDED_)
#define AFX_INSTRUMENTPPG_H__BC964EAB_96F7_11D0_89AA_00A0C9054129__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

// InstrumentPpg.h : Declaration of the CInstrumentPropPage property page class.

////////////////////////////////////////////////////////////////////////////
// CInstrumentPropPage : See InstrumentPpg.cpp.cpp for implementation.

class CInstrumentPropPage : public COlePropertyPage
{
	DECLARE_DYNCREATE(CInstrumentPropPage)
	DECLARE_OLECREATE_EX(CInstrumentPropPage)

// Constructor
public:
	CInstrumentPropPage();

// Dialog Data
	//{{AFX_DATA(CInstrumentPropPage)
	enum { IDD = IDD_PROPPAGE_INSTRUMENT };
		// NOTE - ClassWizard will add data members here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_DATA

// Implementation
protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support

// Message maps
protected:
	//{{AFX_MSG(CInstrumentPropPage)
		// NOTE - ClassWizard will add and remove member functions here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_INSTRUMENTPPG_H__BC964EAB_96F7_11D0_89AA_00A0C9054129__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\DLSDesigner\RemovedFromProject\InstrumentEditor.cpp ===
// InstrumentEditor.cpp : implementation file
//

#include "stdafx.h"
#include "resource.h"
#include "dlsdesigner.h"
#include "jazz.h"
#include "InstrumentEditor.h"
#include "InstrumentCtl.h"
#include "Instrument.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CInstrumentEditor

IMPLEMENT_DYNCREATE(CInstrumentEditor, CFormView)

CInstrumentEditor::CInstrumentEditor(CInstrumentCtrl* parent)
	: CFormView(CInstrumentEditor::IDD), m_parent(NULL), m_pInstrument(NULL),
	m_pCollection(NULL)

{
	m_parent = parent;

	m_pInstrument = m_parent->GetInstrument();
	m_pInstrument->AddRef();
	
	m_pCollection = m_pInstrument->GetParentCollection();
	m_pCollection->AddRef();

	//{{AFX_DATA_INIT(CInstrumentEditor)
	m_wBank = 0;
	m_wBank2 = 0;
	m_wPatch = 0;
	m_fIsDrumKit = FALSE;
	//}}AFX_DATA_INIT
}

CInstrumentEditor::~CInstrumentEditor()
{
	if(m_pInstrument)
	{
		m_pInstrument->Release();
	}

	if(m_pCollection)
	{
		m_pCollection->Release();
	}

}

void CInstrumentEditor::DoDataExchange(CDataExchange* pDX)
{
	CFormView::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CInstrumentEditor)
	DDX_Text(pDX, IDC_BANK, m_wBank);
	DDV_MinMaxUInt(pDX, m_wBank, 0, 127);
	DDX_Text(pDX, IDC_BANK2, m_wBank2);
	DDV_MinMaxUInt(pDX, m_wBank2, 0, 127);
	DDX_Text(pDX, IDC_PATCH, m_wPatch);
	DDV_MinMaxUInt(pDX, m_wPatch, 0, 127);
	DDX_Check(pDX, IDC_DRUMS, m_fIsDrumKit);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CInstrumentEditor, CFormView)
	//{{AFX_MSG_MAP(CInstrumentEditor)
	ON_EN_CHANGE(IDC_BANK, OnChangeBank)
	ON_EN_CHANGE(IDC_BANK2, OnChangeBank2)
	ON_BN_CLICKED(IDC_DRUMS, OnDrums)
	ON_EN_CHANGE(IDC_PATCH, OnChangePatch)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CInstrumentEditor diagnostics

#ifdef _DEBUG
void CInstrumentEditor::AssertValid() const
{
	CFormView::AssertValid();
}

void CInstrumentEditor::Dump(CDumpContext& dc) const
{
	CFormView::Dump(dc);
}
#endif //_DEBUG

/////////////////////////////////////////////////////////////////////////////
// CInstrumentEditor message handlers

BOOL CInstrumentEditor::Create(LPCTSTR lpszClassName, LPCTSTR lpszWindowName, DWORD dwStyle, const RECT& rect, CWnd* pParentWnd, UINT nID, CCreateContext* pContext) 
{
	// TODO: Add your specialized code here and/or call the base class
	
	return CFormView::Create(lpszClassName, lpszWindowName, dwStyle, rect, pParentWnd, nID, pContext);
}

void CInstrumentEditor::OnInitialUpdate() 
{
	CFormView::OnInitialUpdate();

	char text[64];
	CWnd * pDisplay = NULL;

	m_wBank =  (m_pInstrument->m_rInstHeader.Locale.ulBank >> 8) & 0x7F;
	sprintf(text, "%d", m_wBank);
	pDisplay = GetDlgItem(IDC_BANK);	

	if(pDisplay)
	{
		pDisplay->SetWindowText(text);	
	}

	pDisplay = NULL;

	m_wBank2 = m_pInstrument->m_rInstHeader.Locale.ulBank & 0x7F;
	sprintf(text, "%d", m_wBank2);
	
	pDisplay = GetDlgItem(IDC_BANK2);
	if(pDisplay)
	{
		pDisplay->SetWindowText(text);	
	}

	pDisplay = NULL;
	
	m_fIsDrumKit = TRUE && m_pInstrument->m_rInstHeader.Locale.ulBank & F_INSTRUMENT_DRUMS;

	pDisplay = GetDlgItem(IDC_DRUMS);	
	if(pDisplay)
	{
		int state = m_fIsDrumKit ? 1 : 0;

		((CButton *)pDisplay)->SetCheck(state);
	}
	
	pDisplay = NULL;
	
	m_wPatch = m_pInstrument->m_rInstHeader.Locale.ulInstrument;
	sprintf(text, "%d", m_wPatch);	
	
	pDisplay = GetDlgItem(IDC_PATCH);		
	if(pDisplay)
	{
		pDisplay->SetWindowText(text);	
	}
}

void CInstrumentEditor::OnChangeBank() 
{
	BOOL b;
	b = UpdateData(TRUE);	

	if(b)
	{
        m_pInstrument->m_rInstHeader.Locale.ulBank = (m_wBank << 8) + m_wBank2;
#ifdef DLS_UPDATE_SYNTH
	m_pCollection->UpdateSynth(NULL, UPDATE_ALL);
#endif
	}
	else
	{
		// Add better error handling for J3
	}
}

void CInstrumentEditor::OnChangeBank2() 
{
	BOOL b;
	b = UpdateData(TRUE);	

	if(b)
	{
        m_pInstrument->m_rInstHeader.Locale.ulBank = (m_wBank << 8) + m_wBank2;

#ifdef DLS_UPDATE_SYNTH
	m_pCollection->UpdateSynth(NULL, UPDATE_ALL);
#endif
	}
	else
	{
		// Add better error handling for J3
	}
}

void CInstrumentEditor::OnDrums() 
{
	BOOL b;
	b = UpdateData(TRUE);	

	if(b)
	{
        if(m_fIsDrumKit)
	    {			
			m_pInstrument->m_rInstHeader.Locale.ulBank |= F_INSTRUMENT_DRUMS;
		}
		else
		{
			// Should there be an else for J3
//			ASSERT(FALSE);
		}
#ifdef DLS_UPDATE_SYNTH
m_pCollection->UpdateSynth(m_pInstrument, UPDATE_INSTRUMENT);
#endif
	}
	else
	{
		// Add better error handling for J3
	}
}

void CInstrumentEditor::OnChangePatch() 
{
	BOOL b;
	b = UpdateData(TRUE);	

	if(b)
	{		m_pInstrument->m_rInstHeader.Locale.ulInstrument = m_wPatch;
#ifdef DLS_UPDATE_SYNTH
	m_pCollection->UpdateSynth(NULL, UPDATE_ALL);
#endif
	}
	else
	{
		// Add better error handling for J3
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\DLSDesigner\RemovedFromProject\enum.h ===
#ifndef __ENUM_H__
#define __ENUM_H__

// Enum.h : header file
//

#include "alist.h"

class CRegion;
class CInstrument;
class CWave;
class CCollection;
class CArticulation;


/////////////////////////////////////////////////////////////////////////////
// CEnumCollectionFolder

class CEnumCollectionFolder : public IEnumJazzNodes
{
public:
    CEnumCollectionFolder( AList *pList );

    // IUnknown functions
    HRESULT STDMETHODCALLTYPE QueryInterface( REFIID riid, LPVOID *ppv );
    ULONG STDMETHODCALLTYPE AddRef();
    ULONG STDMETHODCALLTYPE Release();

    // IEnum functions
    HRESULT STDMETHODCALLTYPE Next( ULONG celt, IJazzNode __RPC_FAR* __RPC_FAR* rgelt, ULONG __RPC_FAR* pceltFetched );
    HRESULT STDMETHODCALLTYPE Skip( ULONG celt );
    HRESULT STDMETHODCALLTYPE Reset();
    HRESULT STDMETHODCALLTYPE Clone( IEnumJazzNodes __RPC_FAR* __RPC_FAR* ppenum );

private:
    CEnumCollectionFolder();

private:
    DWORD			m_dwRef;
	DWORD			m_dwPos;
    AList *			m_pList;
};

/////////////////////////////////////////////////////////////////////////////
// CEnumWave

class CEnumWave : public IEnumJazzNodes
{
public:
    CEnumWave( CWave* pWave );

    // IUnknown functions
    HRESULT STDMETHODCALLTYPE QueryInterface( REFIID riid, LPVOID *ppv );
    ULONG STDMETHODCALLTYPE AddRef();
    ULONG STDMETHODCALLTYPE Release();

    // IEnum functions
    HRESULT STDMETHODCALLTYPE Next( ULONG celt, IJazzNode __RPC_FAR* __RPC_FAR* rgelt, ULONG __RPC_FAR* pceltFetched );
    HRESULT STDMETHODCALLTYPE Skip( ULONG celt );
    HRESULT STDMETHODCALLTYPE Reset();
    HRESULT STDMETHODCALLTYPE Clone( IEnumJazzNodes __RPC_FAR* __RPC_FAR* ppenum );

private:
    CEnumWave();
	IJazzNode* FindAtPosition();

private:
    DWORD			m_dwRef;
    DWORD			m_dwPos;
    CWave*			m_pWave;
};


#endif // __ENUM_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\DLSDesigner\RemovedFromProject\RegionCtl.h ===
#if !defined(AFX_REGIONCTL_H__BC964EB8_96F7_11D0_89AA_00A0C9054129__INCLUDED_)
#define AFX_REGIONCTL_H__BC964EB8_96F7_11D0_89AA_00A0C9054129__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include "RegionEditor.h"

// RegionCtl.h : Declaration of the CRegionCtrl ActiveX Control class.

/////////////////////////////////////////////////////////////////////////////
// CRegionCtrl : See RegionCtl.cpp for implementation.

class CRegionCtrl : public COleControl
{
	DECLARE_DYNCREATE(CRegionCtrl)

// Constructor
public:
	CRegionCtrl();

	CRegion * GetRegion() {return(m_pRegion);}

// Attributes
public:
	CRegion*		m_pRegion;

private:
	WORD            m_nMIDINoteOns[128];	// J3 do we need this
	HWND			m_hWndContainer;
	HMENU			m_hMenuInPlace;
	CToolBar*		m_pToolBar;
	CRegionEditor*	m_pRegionEditor;

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CRegionCtrl)
	public:
	virtual void OnDraw(CDC* pdc, const CRect& rcBounds, const CRect& rcInvalid);
	virtual void DoPropExchange(CPropExchange* pPX);
	virtual void OnResetState();
	//}}AFX_VIRTUAL

// Implementation
protected:
	~CRegionCtrl();

	DECLARE_OLECREATE_EX(CRegionCtrl)    // Class factory and guid
	DECLARE_OLETYPELIB(CRegionCtrl)      // GetTypeInfo
	DECLARE_PROPPAGEIDS(CRegionCtrl)     // Property page IDs
	DECLARE_OLECTLTYPE(CRegionCtrl)		// Type name and misc status

// Message maps
	//{{AFX_MSG(CRegionCtrl)
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	afx_msg void OnSize(UINT nType, int cx, int cy);
	afx_msg void OnKeyDown(UINT nChar, UINT nRepCnt, UINT nFlags);
	afx_msg void OnKeyUp(UINT nChar, UINT nRepCnt, UINT nFlags);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

// Dispatch maps
	//{{AFX_DISPATCH(CRegionCtrl)
		// NOTE - ClassWizard will add and remove member functions here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_DISPATCH
	DECLARE_DISPATCH_MAP()

	afx_msg void AboutBox();

// Event maps
	//{{AFX_EVENT(CRegionCtrl)
		// NOTE - ClassWizard will add and remove member functions here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_EVENT
	DECLARE_EVENT_MAP()

// Dispatch and event IDs
public:

	// IOleInPlaceActiveObject
	BEGIN_INTERFACE_PART(MyOleInPlaceActiveObject, IOleInPlaceActiveObject)
		INIT_INTERFACE_PART(COleControl, MyOleInPlaceActiveObject)
		STDMETHOD(GetWindow)(HWND*);
		STDMETHOD(ContextSensitiveHelp)(BOOL);
		STDMETHOD(TranslateAccelerator)(LPMSG);
		STDMETHOD(OnFrameWindowActivate)(BOOL);
		STDMETHOD(OnDocWindowActivate)(BOOL);
		STDMETHOD(ResizeBorder)(LPCRECT, LPOLEINPLACEUIWINDOW, BOOL);
		STDMETHOD(EnableModeless)(BOOL);
	END_INTERFACE_PART(MyOleInPlaceActiveObject)

    // IJazzEditor functions
	BEGIN_INTERFACE_PART(Editor, IJazzEditor)
		STDMETHOD(AttachObjects)(IJazzNode*, IOleUndoManager*);
		STDMETHOD(OnInitMenuFilePrint)(HMENU, UINT);
		STDMETHOD(OnFilePrint)();
		STDMETHOD(OnInitMenuFilePrintPreview)(HMENU, UINT);
		STDMETHOD(OnFilePrintPreview)();
	END_INTERFACE_PART(Editor)

	DECLARE_INTERFACE_MAP()

	enum {
	//{{AFX_DISP_ID(CRegionCtrl)
		// NOTE: ClassWizard will add and remove enumeration elements here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_DISP_ID
	};
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_REGIONCTL_H__BC964EB8_96F7_11D0_89AA_00A0C9054129__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\DLSDesigner\RemovedFromProject\RegionCtl.cpp ===
// RegionCtl.cpp : Implementation of the CRegionCtrl ActiveX Control class.

#include "stdafx.h"
#include "DLSDesignerDLL.h"
#include "Region.h"
#include "RegionCtl.h"
#include "RegionPpg.h"
#include "DLSLoadSaveUtils.h" // J3 may no longer need

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


IMPLEMENT_DYNCREATE(CRegionCtrl, COleControl)


/////////////////////////////////////////////////////////////////////////////
// Message map

BEGIN_MESSAGE_MAP(CRegionCtrl, COleControl)
	//{{AFX_MSG_MAP(CRegionCtrl)
	ON_WM_CREATE()
	ON_WM_SIZE()
	ON_WM_KEYDOWN()
	ON_WM_KEYUP()
	//}}AFX_MSG_MAP
	ON_OLEVERB(AFX_IDS_VERB_PROPERTIES, OnProperties)
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// Dispatch map

BEGIN_DISPATCH_MAP(CRegionCtrl, COleControl)
	//{{AFX_DISPATCH_MAP(CRegionCtrl)
	// NOTE - ClassWizard will add and remove dispatch map entries
	//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_DISPATCH_MAP
	DISP_FUNCTION_ID(CRegionCtrl, "AboutBox", DISPID_ABOUTBOX, AboutBox, VT_EMPTY, VTS_NONE)
END_DISPATCH_MAP()


/////////////////////////////////////////////////////////////////////////////
// Event map

BEGIN_EVENT_MAP(CRegionCtrl, COleControl)
	//{{AFX_EVENT_MAP(CRegionCtrl)
	// NOTE - ClassWizard will add and remove event map entries
	//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_EVENT_MAP
END_EVENT_MAP()

/////////////////////////////////////////////////////////////////////////////
// CRegionCtrl Interface map

BEGIN_INTERFACE_MAP(CRegionCtrl, COleControl)
    INTERFACE_PART(CRegionCtrl, IID_IOleInPlaceActiveObject, MyOleInPlaceActiveObject)
    INTERFACE_PART(CRegionCtrl, IID_IJazzEditor, Editor)
END_INTERFACE_MAP()

/////////////////////////////////////////////////////////////////////////////
// Property pages

// TODO: Add more property pages as needed.  Remember to increase the count!
BEGIN_PROPPAGEIDS(CRegionCtrl, 1)
	PROPPAGEID(CRegionPropPage::guid)
END_PROPPAGEIDS(CRegionCtrl)


/////////////////////////////////////////////////////////////////////////////
// Initialize class factory and guid

IMPLEMENT_OLECREATE_EX(CRegionCtrl, "DLSDESIGNER.RegionCtrl.1",
	0xbc964e96, 0x96f7, 0x11d0, 0x89, 0xaa, 0, 0xa0, 0xc9, 0x5, 0x41, 0x29)


/////////////////////////////////////////////////////////////////////////////
// Type library ID and version

IMPLEMENT_OLETYPELIB(CRegionCtrl, _tlid, _wVerMajor, _wVerMinor)


/////////////////////////////////////////////////////////////////////////////
// Interface IDs

const IID BASED_CODE IID_DRegion =
		{ 0xbc964e94, 0x96f7, 0x11d0, { 0x89, 0xaa, 0, 0xa0, 0xc9, 0x5, 0x41, 0x29 } };
const IID BASED_CODE IID_DRegionEvents =
		{ 0xbc964e95, 0x96f7, 0x11d0, { 0x89, 0xaa, 0, 0xa0, 0xc9, 0x5, 0x41, 0x29 } };


/////////////////////////////////////////////////////////////////////////////
// Control type information

static const DWORD BASED_CODE _dwRegionOleMisc =
	OLEMISC_ACTIVATEWHENVISIBLE |
	OLEMISC_SETCLIENTSITEFIRST |
	OLEMISC_INSIDEOUT |
	OLEMISC_CANTLINKINSIDE |
	OLEMISC_RECOMPOSEONRESIZE;

IMPLEMENT_OLECTLTYPE(CRegionCtrl, IDS_REGION, _dwRegionOleMisc)


/////////////////////////////////////////////////////////////////////////////
// CRegionCtrl::CRegionCtrlFactory::UpdateRegistry -
// Adds or removes system registry entries for CRegionCtrl

BOOL CRegionCtrl::CRegionCtrlFactory::UpdateRegistry(BOOL bRegister)
{
	// TODO: Verify that your control follows apartment-model threading rules.
	// Refer to MFC TechNote 64 for more information.
	// If your control does not conform to the apartment-model rules, then
	// you must modify the code below, changing the 6th parameter from
	// afxRegApartmentThreading to 0.

	if (bRegister)
		return AfxOleRegisterControlClass(
			AfxGetInstanceHandle(),
			m_clsid,
			m_lpszProgID,
			IDS_REGION,
			IDB_REGION,
			afxRegApartmentThreading,
			_dwRegionOleMisc,
			_tlid,
			_wVerMajor,
			_wVerMinor);
	else
		return AfxOleUnregisterClass(m_clsid, m_lpszProgID);
}


/////////////////////////////////////////////////////////////////////////////
// CRegionCtrl::CRegionCtrl - Constructor

CRegionCtrl::CRegionCtrl() : m_pRegionEditor(NULL), m_pRegion(NULL)
{
	InitializeIIDs(&IID_DRegion, &IID_DRegionEvents);

// J3 we need to do this better maybe a global class that contains m_nMIDINoteOns

	for(int i = 0; i < 128; i++)
	{
		m_nMIDINoteOns[i] = 0;
	}

	// TODO: Initialize your control's instance data here.
}


/////////////////////////////////////////////////////////////////////////////
// CRegionCtrl::~CRegionCtrl - Destructor

CRegionCtrl::~CRegionCtrl()
{
	if(m_pRegion)
	{
		m_pRegion->Release();
		m_pRegion = NULL;
	}
}

/////////////////////////////////////////////////////////////////////////////
// CRegionCtrl IJazzEditor implementation

/////////////////////////////////////////////////////////////////////////////
// CRegionCtrl::XEditor::AddRef

STDMETHODIMP_(ULONG) CRegionCtrl::XEditor::AddRef()
{
	METHOD_PROLOGUE_EX_( CRegionCtrl, Editor )

	return (ULONG)pThis->ExternalAddRef();
}


/////////////////////////////////////////////////////////////////////////////
// CRegionCtrl::XEditor::Release

STDMETHODIMP_(ULONG) CRegionCtrl::XEditor::Release()
{
	METHOD_PROLOGUE_EX_( CRegionCtrl, Editor )

	return (ULONG)pThis->ExternalRelease();
}


/////////////////////////////////////////////////////////////////////////////
// CRegionCtrl::XEditor::QueryInterface

STDMETHODIMP CRegionCtrl::XEditor::QueryInterface( REFIID iid, LPVOID* ppvObj )
{
	METHOD_PROLOGUE_EX_( CRegionCtrl, Editor )

	return (HRESULT)pThis->ExternalQueryInterface( &iid, ppvObj );
}


/////////////////////////////////////////////////////////////////////////////
// CRegionCtrl::XEditor::AttachObjects implementation

HRESULT CRegionCtrl::XEditor::AttachObjects( IJazzNode* pNode, IOleUndoManager* pUndoManager )
{
	METHOD_MANAGE_STATE( CRegionCtrl, Editor )

	ASSERT_VALID( pThis );
	ASSERT( pNode != NULL );

	pThis->m_pRegion = (CRegion *)pNode;
	pThis->m_pRegion->AddRef();

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CRegionCtrl::XEditor::OnInitMenuFilePrint

HRESULT CRegionCtrl::XEditor::OnInitMenuFilePrint( HMENU hMenu, UINT nMenuId )
{
	METHOD_MANAGE_STATE( CRegionCtrl, Editor )

	::EnableMenuItem( hMenu, nMenuId, (MF_GRAYED | MF_BYCOMMAND) );

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CRegionCtrl::XEditor::OnFilePrint

HRESULT CRegionCtrl::XEditor::OnFilePrint( void )
{
	METHOD_MANAGE_STATE( CRegionCtrl, Editor )

	return E_NOTIMPL;
}


/////////////////////////////////////////////////////////////////////////////
// CRegionCtrl::XEditor::OnInitMenuFilePrintPreview

HRESULT CRegionCtrl::XEditor::OnInitMenuFilePrintPreview( HMENU hMenu, UINT nMenuId )
{
	METHOD_MANAGE_STATE( CRegionCtrl, Editor )

	::EnableMenuItem( hMenu, nMenuId, (MF_GRAYED | MF_BYCOMMAND) );

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CRegionCtrl::XEditor::OnFilePrintPreview

HRESULT CRegionCtrl::XEditor::OnFilePrintPreview( void )
{
	METHOD_MANAGE_STATE( CRegionCtrl, Editor )

	return E_NOTIMPL;
}


/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
// CRegionCtrl::XMyOleInPlaceActiveObject implementation

STDMETHODIMP_(ULONG) CRegionCtrl::XMyOleInPlaceActiveObject::AddRef()
{
	METHOD_MANAGE_STATE( CRegionCtrl, MyOleInPlaceActiveObject )
	ASSERT_VALID( pThis );

	return pThis->m_xOleInPlaceActiveObject.AddRef();
}

STDMETHODIMP_(ULONG) CRegionCtrl::XMyOleInPlaceActiveObject::Release()
{
	METHOD_MANAGE_STATE( CRegionCtrl, MyOleInPlaceActiveObject )
	ASSERT_VALID( pThis );

	return pThis->m_xOleInPlaceActiveObject.Release();
}

STDMETHODIMP CRegionCtrl::XMyOleInPlaceActiveObject::QueryInterface( REFIID iid, LPVOID* ppvObj )
{
	METHOD_MANAGE_STATE( CRegionCtrl, MyOleInPlaceActiveObject )
	ASSERT_VALID( pThis );

	return pThis->m_xOleInPlaceActiveObject.QueryInterface( iid, ppvObj );
}

STDMETHODIMP CRegionCtrl::XMyOleInPlaceActiveObject::GetWindow( HWND* lphwnd )
{
	METHOD_MANAGE_STATE( CRegionCtrl, MyOleInPlaceActiveObject )
	ASSERT_VALID( pThis );

	return pThis->m_xOleInPlaceActiveObject.GetWindow( lphwnd );
}

STDMETHODIMP CRegionCtrl::XMyOleInPlaceActiveObject::ContextSensitiveHelp( BOOL fEnterMode )
{
	METHOD_MANAGE_STATE( CRegionCtrl, MyOleInPlaceActiveObject )
	ASSERT_VALID( pThis );

	return pThis->m_xOleInPlaceActiveObject.ContextSensitiveHelp( fEnterMode );
}

STDMETHODIMP CRegionCtrl::XMyOleInPlaceActiveObject::TranslateAccelerator( LPMSG lpmsg )
{
	METHOD_MANAGE_STATE( CRegionCtrl, MyOleInPlaceActiveObject )
	ASSERT_VALID( pThis );

	return pThis->m_xOleInPlaceActiveObject.TranslateAccelerator( lpmsg );
}

STDMETHODIMP CRegionCtrl::XMyOleInPlaceActiveObject::OnFrameWindowActivate( BOOL fActivate )
{
	METHOD_MANAGE_STATE( CRegionCtrl, MyOleInPlaceActiveObject )
	ASSERT_VALID( pThis );

	return pThis->m_xOleInPlaceActiveObject.OnFrameWindowActivate( fActivate );
}

STDMETHODIMP CRegionCtrl::XMyOleInPlaceActiveObject::OnDocWindowActivate( BOOL fActivate )
{
	METHOD_MANAGE_STATE( CRegionCtrl, MyOleInPlaceActiveObject )
	ASSERT_VALID( pThis );

	return pThis->m_xOleInPlaceActiveObject.OnDocWindowActivate( fActivate );
}

STDMETHODIMP CRegionCtrl::XMyOleInPlaceActiveObject::ResizeBorder(
	LPCRECT, LPOLEINPLACEUIWINDOW, BOOL fFrameWindow )
{
	METHOD_MANAGE_STATE( CRegionCtrl, MyOleInPlaceActiveObject )
	ASSERT_VALID( pThis );

    if( fFrameWindow == TRUE )
	{
		pThis->OnShowToolBars();
	}

	return S_OK;
}

STDMETHODIMP CRegionCtrl::XMyOleInPlaceActiveObject::EnableModeless( BOOL fEnable )
{
	METHOD_MANAGE_STATE( CRegionCtrl, MyOleInPlaceActiveObject )
	ASSERT_VALID( pThis );

	return pThis->m_xOleInPlaceActiveObject.EnableModeless( fEnable );
}

/////////////////////////////////////////////////////////////////////////////
// CRegionCtrl::OnDraw - Drawing function

void CRegionCtrl::OnDraw(
			CDC* pdc, const CRect& rcBounds, const CRect& rcInvalid)
{
}


/////////////////////////////////////////////////////////////////////////////
// CRegionCtrl::DoPropExchange - Persistence support

void CRegionCtrl::DoPropExchange(CPropExchange* pPX)
{
	ExchangeVersion(pPX, MAKELONG(_wVerMinor, _wVerMajor));
	COleControl::DoPropExchange(pPX);

	// TODO: Call PX_ functions for each persistent custom property.

}


/////////////////////////////////////////////////////////////////////////////
// CRegionCtrl::OnResetState - Reset control to default state

void CRegionCtrl::OnResetState()
{
	COleControl::OnResetState();  // Resets defaults found in DoPropExchange

	// TODO: Reset any other control state here.
}


/////////////////////////////////////////////////////////////////////////////
// CRegionCtrl::AboutBox - Display an "About" box to the user

void CRegionCtrl::AboutBox()
{
	CDialog dlgAbout(IDD_ABOUTBOX_REGION);
	dlgAbout.DoModal();
}


/////////////////////////////////////////////////////////////////////////////
// CRegionCtrl message handlers

int CRegionCtrl::OnCreate(LPCREATESTRUCT lpCreateStruct) 
{
	if (COleControl::OnCreate(lpCreateStruct) == -1)
		return -1;
	
		// Create Collection's view
	m_pRegionEditor = new CRegionEditor(this);

	if( m_pRegionEditor == NULL )
	{
		return -1;
	}

	if(m_pRegionEditor->Create(NULL, 
							   "WindowName", 
							   WS_CHILD | WS_VISIBLE, 
							   CRect( 0, 0, 800, 400 ), 
							   this, 
							   888, 
							   NULL) == 0)
	{
		return -1;
	}


	m_pRegionEditor->OnInitialUpdate(); 
	return 0;
}

void CRegionCtrl::OnSize(UINT nType, int cx, int cy) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	COleControl::OnSize(nType, cx, cy);
	
	m_pRegionEditor->MoveWindow( 0, 0, cx, cy );
}

void CRegionCtrl::OnKeyDown(UINT nChar, UINT nRepCnt, UINT nFlags) 
{
	m_pRegion->UpdatePatch();
	switch (nChar)
    {
		case 32 :  // Space bar
			
   			if(m_nMIDINoteOns[m_pRegion->m_nMIDINote] > 0)
			{
				break;
			}
			
			m_pRegion->m_nMIDINote = (m_pRegion->m_rRgnHeader.RangeKey.usLow +
					       			  m_pRegion->m_rRgnHeader.RangeKey.usHigh + 1) >> 1;

			((m_pRegion->m_pComponent)->m_pIConductor)->PlayMIDIEvent(MIDI_NOTEON,
			   													      m_pRegion->m_nMIDINote,
																	  110,
																	  0);
			// J3 Do we need to do this                
			m_nMIDINoteOns[m_pRegion->m_nMIDINote]++;
		break;
	}	

	// TODO: Add your message handler code here and/or call default
	
//	COleControl::OnKeyDown(nChar, nRepCnt, nFlags);
}

void CRegionCtrl::OnKeyUp(UINT nChar, UINT nRepCnt, UINT nFlags) 
{
	switch (nChar)
    {
		case 32 :  // Space bar
// J3 Do we need to do this
		while (m_nMIDINoteOns[m_pRegion->m_nMIDINote] > 0)
		{
			((m_pRegion->m_pComponent)->m_pIConductor)->PlayMIDIEvent(MIDI_NOTEOFF,
													   m_pRegion->m_nMIDINote,
													   110,
													   0); 

			m_nMIDINoteOns[m_pRegion->m_nMIDINote]--;
		}
        break;
	}	
	

	// TODO: Add your message handler code here and/or call default
	
//	COleControl::OnKeyUp(nChar, nRepCnt, nFlags);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\DLSDesigner\RemovedFromProject\RegionEditor.cpp ===
// RegionEditor.cpp : implementation file
//

#include "stdafx.h"
#include "resource.h"
#include "dlsdesigner.h"

#include "Collection.h"
#include "Instrument.h"
#include "RegionCtl.h"
#include "RegionEditor.h"
#include "wave.h"
#include "DLSLoadSaveUtils.h" // J3 Need

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CRegionEditor

IMPLEMENT_DYNCREATE(CRegionEditor, CFormView)

CRegionEditor::CRegionEditor(CRegionCtrl *parent)
	: CFormView(CRegionEditor::IDD)
{
	m_parent = parent;
	m_pRegion = m_parent->GetRegion();
	m_pRegion->AddRef();
	CInstrument* pInstrument = m_pRegion->GetInstrument();
	m_pCollection = pInstrument->GetParentCollection();
	m_pWaves = &(m_pCollection->m_Waves);
	m_pWaves->AddRef();

	//{{AFX_DATA_INIT(CRegionEditor)
	m_dwLoopStart = 0;
	m_dwLoopLength = 0;
	m_fOneShot = FALSE;
	m_fAllowOverlap = FALSE;
	m_fAllowCompress = FALSE;
	m_fAllowTruncate = FALSE;
	//}}AFX_DATA_INIT
}

CRegionEditor::~CRegionEditor()
{
	if(m_pRegion)
	{
		m_pRegion->Release();
	}

	if(m_pWaves)
	{
		m_pWaves->Release();
	}
}

void CRegionEditor::DoDataExchange(CDataExchange* pDX)
{
	CFormView::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CRegionEditor)
	DDX_Text(pDX, IDC_LOOPSTART, m_dwLoopStart);
	DDV_MinMaxDWord(pDX, m_dwLoopStart, 0, 10000000);
	DDX_Text(pDX, IDC_LOOPLENGTH, m_dwLoopLength);
	DDV_MinMaxDWord(pDX, m_dwLoopLength, 0, 10000000);
	DDX_Check(pDX, IDC_ONESHOT, m_fOneShot);
	DDX_Check(pDX, IDC_OVERLAP, m_fAllowOverlap);
	DDX_Check(pDX, IDC_ALLOW_COMPRESS, m_fAllowCompress);
	DDX_Check(pDX, IDC_ALLOW_TRUNCATE, m_fAllowTruncate);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CRegionEditor, CFormView)
	//{{AFX_MSG_MAP(CRegionEditor)
	ON_BN_CLICKED(IDC_GETWAVE, OnGetwave)
	ON_WM_HSCROLL()
	ON_CBN_SELCHANGE(IDC_WAVELINK, OnSelchangeWavelink)
	ON_BN_CLICKED(IDC_ALLOW_TRUNCATE, OnAllowTruncate)
	ON_BN_CLICKED(IDC_ALLOW_COMPRESS, OnAllowCompress)
	ON_BN_CLICKED(IDC_OVERLAP, OnOverlap)
	ON_EN_CHANGE(IDC_LOOPLENGTH, OnChangeLooplength)
	ON_EN_CHANGE(IDC_LOOPSTART, OnChangeLoopstart)
	ON_BN_CLICKED(IDC_ONESHOT, OnOneshot)
	ON_EN_CHANGE(IDC_DGROUP, OnChangeDgroup)
	ON_EN_CHANGE(IDC_DTUNE, OnChangeDtune)
	ON_EN_CHANGE(IDC_DATTENUATION, OnChangeDattenuation)
	ON_EN_CHANGE(IDC_DUNITYNOTE, OnChangeDunitynote)
	ON_EN_CHANGE(IDC_ELRANGE, OnChangeElrange)
	ON_EN_CHANGE(IDC_EURANGE, OnChangeEurange)
	ON_WM_KEYDOWN()
	ON_WM_KEYUP()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CRegionEditor diagnostics

#ifdef _DEBUG
void CRegionEditor::AssertValid() const
{
	CFormView::AssertValid();
}

void CRegionEditor::Dump(CDumpContext& dc) const
{
	CFormView::Dump(dc);
}
#endif //_DEBUG

/////////////////////////////////////////////////////////////////////////////
// CRegionEditor message handlers

BOOL CRegionEditor::Create(LPCTSTR lpszClassName, LPCTSTR lpszWindowName, DWORD dwStyle, const RECT& rect, CWnd* pParentWnd, UINT nID, CCreateContext* pContext) 
{
	// TODO: Add your specialized code here and/or call the base class
	
	return CFormView::Create(lpszClassName, lpszWindowName, dwStyle, rect, pParentWnd, nID, pContext);
}

void CRegionEditor::OnGetwave() 
{
	if(m_pWave != NULL)
    {
        m_msTune.SetValue(this,m_pWave->m_rWSMP.sFineTune << 16);
        m_msAttenuation.SetValue(this,m_pWave->m_rWSMP.lAttenuation);
        m_msUnityNote.SetValue(this,m_pWave->m_rWSMP.usUnityNote);
        m_dwLoopStart = m_pWave->m_rWLOOP.ulStart;
        m_dwLoopLength = m_pWave->m_rWLOOP.ulLength;
        m_fOneShot = (m_pWave->m_rWSMP.cSampleLoops == 0);
        m_fAllowCompress = !(m_pWave->m_rWSMP.fulOptions & F_WSMP_NO_COMPRESSION);
        m_fAllowTruncate = !(m_pWave->m_rWSMP.fulOptions & F_WSMP_NO_TRUNCATION);
        UpdateData(FALSE);
    }	
}

void CRegionEditor::OnHScroll(UINT nSBCode, UINT nPos, CScrollBar* pScrollBar) 
{
	MySlider *pSlider = NULL;
	if (pScrollBar != NULL)
	{
        int nID = pScrollBar->GetDlgCtrlID();
        switch (nID)
        {
        case IDC_URANGE :
            pSlider = &m_msUpperRange;
            break;
        case IDC_LRANGE :
            pSlider = &m_msLowerRange;
            break;
        case IDC_GROUP :
            pSlider = &m_msGroup;
            break;
        case IDC_TUNE :
            pSlider = &m_msTune;
            break;
        case IDC_ATTENUATION :
            pSlider = &m_msAttenuation;
            break;
        case IDC_UNITYNOTE :
            pSlider = &m_msUnityNote;
            break;
        default:
            pSlider = NULL;
            break;
        }
        if (pSlider != NULL)
        {
            pSlider->SetPosition(this,nSBCode,nPos);
        }
    }

	CFormView::OnHScroll(nSBCode, nPos, pScrollBar);
}

void CRegionEditor::OnSelchangeWavelink() 
{
    CComboBox *pCombo = (CComboBox *) GetDlgItem(IDC_WAVELINK);
    if (pCombo != NULL)
    {
        int index = pCombo->GetCurSel();
		if (index != CB_ERR)
		{
			CWave * pWave = (CWave *) pCombo->GetItemDataPtr(index);
			if (pWave != m_pWave)
			{
				if (m_pRegion->m_pWave != NULL)
	            {
			        m_pRegion->m_pWave->Release();
				}
				
				m_pRegion->m_pWave = pWave;
				m_pWave = pWave;

				if (m_pRegion->m_pWave != NULL)
		        {
					m_pRegion->m_pWave->AddRef();
				}

			}
		}

#ifdef DLS_UPDATE_SYNTH
	m_pCollection->UpdateSynth(NULL, UPDATE_ALL);
#endif
	}
}

void CRegionEditor::OnInitialUpdate() 
{
	m_dwUpperRange = m_pRegion->m_rRgnHeader.RangeKey.usHigh;
	m_dwLowerRange = m_pRegion->m_rRgnHeader.RangeKey.usLow;
	m_dwGroup = m_pRegion->m_rRgnHeader.usKeyGroup;
	m_lFineTune = (long) m_pRegion->m_rWSMP.sFineTune << 16;
	m_lAttenuation = (long) m_pRegion->m_rWSMP.lAttenuation;
	m_lUnityNote = (long) m_pRegion->m_rWSMP.usUnityNote;
	m_dwLoopStart = m_pRegion->m_rWLOOP.ulStart;
	m_dwLoopLength = m_pRegion->m_rWLOOP.ulLength;
	m_fAllowTruncate = !(m_pRegion->m_rWSMP.fulOptions & F_WSMP_NO_TRUNCATION);
	m_fAllowCompress = !(m_pRegion->m_rWSMP.fulOptions & F_WSMP_NO_COMPRESSION);
	m_fAllowOverlap = (m_pRegion->m_rRgnHeader.fusOptions & F_RGN_OPTION_SELFNONEXCLUSIVE);
	m_fOneShot = (m_pRegion->m_rWSMP.cSampleLoops == 0);
	m_pWave = m_pRegion->m_pWave;

	CWave *pWave;

    CComboBox *pCombo = (CComboBox *) GetDlgItem(IDC_WAVELINK);
	m_msUpperRange.Init(this, IDC_URANGE, IDC_EURANGE, 
                    MYSLIDER_NOTE,(long *)&m_dwUpperRange);
	m_msLowerRange.Init(this, IDC_LRANGE, IDC_ELRANGE, 
                    MYSLIDER_NOTE,(long *)&m_dwLowerRange);
	m_msGroup.Init(this, IDC_GROUP, IDC_DGROUP, 
                    MYSLIDER_GROUP,(long *)&m_dwGroup);
    m_msTune.Init(this, IDC_TUNE, IDC_DTUNE,
                    MYSLIDER_PITCHCENTS, &m_lFineTune);
    m_msAttenuation.Init(this, IDC_ATTENUATION, IDC_DATTENUATION,
                    MYSLIDER_VOLUME, &m_lAttenuation);
    m_msUnityNote.Init(this, IDC_UNITYNOTE, IDC_DUNITYNOTE,
                    MYSLIDER_NOTE, &m_lUnityNote);
    if (pCombo != NULL)
    {
       pWave = m_pWaves->GetHead();
        for (; pWave != NULL; pWave = pWave->GetNext())
        {
            BSTR waveName;
			pWave->GetNodeName(&waveName);

			int index = pCombo->AddString(CString(waveName));
            pCombo->SetItemDataPtr(index, pWave);
            if (pWave == m_pWave)
            {
                pCombo->SetCurSel(index);
            }
        }
    }

	CFormView::OnInitialUpdate();
}

void CRegionEditor::OnAllowTruncate() 
{
	BOOL b;
	b = UpdateData(TRUE);	

	if(b)
	{
		if(m_fAllowTruncate)
        {
			m_pRegion->m_rWSMP.fulOptions &= ~F_WSMP_NO_TRUNCATION;
		}
		else
		{
			m_pRegion->m_rWSMP.fulOptions |= F_WSMP_NO_TRUNCATION;
		}
#ifdef DLS_UPDATE_SYNTH
		m_pCollection->UpdateSynth((m_parent->m_pRegion)->m_pInstrument,UPDATE_INSTRUMENT);
#endif
	}
	else
	{
		// Add better error handling for J3
	}
}

void CRegionEditor::OnAllowCompress() 
{
	BOOL b;
	b = UpdateData(TRUE);	

	if(b)
	{
		if(m_fAllowCompress)
		{
			m_pRegion->m_rWSMP.fulOptions &= ~F_WSMP_NO_COMPRESSION;
        }
        else
		{		
			m_pRegion->m_rWSMP.fulOptions |= F_WSMP_NO_COMPRESSION;
		}
#ifdef DLS_UPDATE_SYNTH
		m_pCollection->UpdateSynth((m_parent->m_pRegion)->m_pInstrument,UPDATE_INSTRUMENT);
#endif
	}
	else
	{
		// Add better error handling for J3
	}
}

void CRegionEditor::OnOverlap() 
{
	BOOL b;
	b = UpdateData(TRUE);	

	if(b)
	{
		if(m_fAllowOverlap)
		{
			m_pRegion->m_rRgnHeader.fusOptions |= F_RGN_OPTION_SELFNONEXCLUSIVE;
		}
		else
		{
			m_pRegion->m_rRgnHeader.fusOptions &= ~F_RGN_OPTION_SELFNONEXCLUSIVE;
		}
#ifdef DLS_UPDATE_SYNTH
		m_pCollection->UpdateSynth((m_parent->m_pRegion)->m_pInstrument,UPDATE_INSTRUMENT);
#endif
	}
	else
	{
		// Add better error handling for J3
	}
}

void CRegionEditor::OnChangeLooplength() 
{
	BOOL b;
	b = UpdateData(TRUE);	

	if(b)
	{
		m_pRegion->m_rWLOOP.ulLength = m_dwLoopLength;
#ifdef DLS_UPDATE_SYNTH
		m_pCollection->UpdateSynth((m_parent->m_pRegion)->m_pInstrument,UPDATE_INSTRUMENT);
#endif
	}
	else
	{
		// Add better error handling for J3
	}
}

void CRegionEditor::OnChangeLoopstart() 
{
	BOOL b;
	b = UpdateData(TRUE);	

	if(b)
	{
		m_pRegion->m_rWLOOP.ulStart = m_dwLoopStart;
#ifdef DLS_UPDATE_SYNTH
		m_pCollection->UpdateSynth((m_parent->m_pRegion)->m_pInstrument,UPDATE_INSTRUMENT);
#endif
	}
	else
	{
		// Add better error handling for J3
	}
}

void CRegionEditor::OnOneshot() 
{
	BOOL b;
	b = UpdateData(TRUE);	

	if(b)
	{
		if(m_fOneShot)
		{
			m_pRegion->m_rWSMP.cSampleLoops = 0;
		}
		else
		{
			m_pRegion->m_rWSMP.cSampleLoops = 1;
		}
#ifdef DLS_UPDATE_SYNTH
		m_pCollection->UpdateSynth((m_parent->m_pRegion)->m_pInstrument,UPDATE_INSTRUMENT);
#endif
	}
	else
	{
		// Add better error handling for J3
	}
}

void CRegionEditor::OnChangeDgroup() 
{
	BOOL b;
	b = UpdateData(FALSE);	

	if(b)
	{
		m_pRegion->m_rRgnHeader.usKeyGroup = (USHORT) m_dwGroup;
#ifdef DLS_UPDATE_SYNTH
		m_pCollection->UpdateSynth((m_parent->m_pRegion)->m_pInstrument,UPDATE_INSTRUMENT);
#endif
	}
	else
	{
		// Add better error handling for J3
	}
}

void CRegionEditor::OnChangeDtune() 
{
	BOOL b;
	b = UpdateData(FALSE);	

	if(b)
	{
		m_pRegion->m_rWSMP.sFineTune = (WORD) (m_lFineTune >> 16);
#ifdef DLS_UPDATE_SYNTH
		m_pCollection->UpdateSynth((m_parent->m_pRegion)->m_pInstrument,UPDATE_INSTRUMENT);
#endif

	}
	else
	{
		// Add better error handling for J3
	}
}

void CRegionEditor::OnChangeDattenuation() 
{
	BOOL b;
	b = UpdateData(FALSE);	

	if(b)
	{
		m_pRegion->m_rWSMP.lAttenuation = (DWORD) m_lAttenuation;
#ifdef DLS_UPDATE_SYNTH
		m_pCollection->UpdateSynth((m_parent->m_pRegion)->m_pInstrument,UPDATE_INSTRUMENT);
#endif
	}
	else
	{
		// Add better error handling for J3
	}
}

void CRegionEditor::OnChangeDunitynote() 
{
	static count = 0;
	BOOL b;
	b = UpdateData(FALSE);	

	if(b)
	{
		m_pRegion->m_rWSMP.usUnityNote = (WORD) m_lUnityNote;
#ifdef DLS_UPDATE_SYNTH
		if(count)
		{
		m_pCollection->UpdateSynth((m_parent->m_pRegion)->m_pInstrument,UPDATE_INSTRUMENT);
		}
		count++;
#endif
	}
	else
	{
		// Add better error handling for J3
	}
}

void CRegionEditor::OnChangeElrange() 
{
	BOOL b;
	b = UpdateData(FALSE);	

	if(b)
	{
		m_pRegion->m_rRgnHeader.RangeKey.usLow = (WORD) m_dwLowerRange;
#ifdef DLS_UPDATE_SYNTH
		m_pCollection->UpdateSynth((m_parent->m_pRegion)->m_pInstrument,UPDATE_INSTRUMENT);
#endif
	}
	else
	{
		// Add better error handling for J3
	}
}

void CRegionEditor::OnChangeEurange() 
{
	BOOL b;
	b = UpdateData(FALSE);	

	if(b)
	{
		m_pRegion->m_rRgnHeader.RangeKey.usHigh = (WORD) m_dwUpperRange;
#ifdef DLS_UPDATE_SYNTH
		m_pCollection->UpdateSynth((m_parent->m_pRegion)->m_pInstrument,UPDATE_INSTRUMENT);
#endif
	}
	else
	{
		// Add better error handling for J3
	}
}

void CRegionEditor::OnKeyDown(UINT nChar, UINT nRepCnt, UINT nFlags) 
{
	CFormView::OnKeyDown(nChar, nRepCnt, nFlags);
}

void CRegionEditor::OnKeyUp(UINT nChar, UINT nRepCnt, UINT nFlags) 
{
	CFormView::OnKeyUp(nChar, nRepCnt, nFlags);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\DLSDesigner\RemovedFromProject\RegionPpg.h ===
#if !defined(AFX_REGIONPPG_H__BC964EBA_96F7_11D0_89AA_00A0C9054129__INCLUDED_)
#define AFX_REGIONPPG_H__BC964EBA_96F7_11D0_89AA_00A0C9054129__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

// RegionPpg.h : Declaration of the CRegionPropPage property page class.

////////////////////////////////////////////////////////////////////////////
// CRegionPropPage : See RegionPpg.cpp.cpp for implementation.

class CRegionPropPage : public COlePropertyPage
{
	DECLARE_DYNCREATE(CRegionPropPage)
	DECLARE_OLECREATE_EX(CRegionPropPage)

// Constructor
public:
	CRegionPropPage();

// Dialog Data
	//{{AFX_DATA(CRegionPropPage)
	enum { IDD = IDD_PROPPAGE_REGION };
		// NOTE - ClassWizard will add data members here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_DATA

// Implementation
protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support

// Message maps
protected:
	//{{AFX_MSG(CRegionPropPage)
		// NOTE - ClassWizard will add and remove member functions here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_REGIONPPG_H__BC964EBA_96F7_11D0_89AA_00A0C9054129__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\DLSDesigner\RemovedFromProject\RegionPpg.cpp ===
// RegionPpg.cpp : Implementation of the CRegionPropPage property page class.

#include "stdafx.h"
#include "DLSDesignerDLL.h"
#include "RegionPpg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


IMPLEMENT_DYNCREATE(CRegionPropPage, COlePropertyPage)


/////////////////////////////////////////////////////////////////////////////
// Message map

BEGIN_MESSAGE_MAP(CRegionPropPage, COlePropertyPage)
	//{{AFX_MSG_MAP(CRegionPropPage)
	// NOTE - ClassWizard will add and remove message map entries
	//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// Initialize class factory and guid

IMPLEMENT_OLECREATE_EX(CRegionPropPage, "DLSDESIGNER.RegionPropPage.1",
	0xbc964e97, 0x96f7, 0x11d0, 0x89, 0xaa, 0, 0xa0, 0xc9, 0x5, 0x41, 0x29)


/////////////////////////////////////////////////////////////////////////////
// CRegionPropPage::CRegionPropPageFactory::UpdateRegistry -
// Adds or removes system registry entries for CRegionPropPage

BOOL CRegionPropPage::CRegionPropPageFactory::UpdateRegistry(BOOL bRegister)
{
	if (bRegister)
		return AfxOleRegisterPropertyPageClass(AfxGetInstanceHandle(),
			m_clsid, IDS_REGION_PPG);
	else
		return AfxOleUnregisterClass(m_clsid, NULL);
}


/////////////////////////////////////////////////////////////////////////////
// CRegionPropPage::CRegionPropPage - Constructor

CRegionPropPage::CRegionPropPage() :
	COlePropertyPage(IDD, IDS_REGION_PPG_CAPTION)
{
	//{{AFX_DATA_INIT(CRegionPropPage)
	// NOTE: ClassWizard will add member initialization here
	//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_DATA_INIT
}


/////////////////////////////////////////////////////////////////////////////
// CRegionPropPage::DoDataExchange - Moves data between page and properties

void CRegionPropPage::DoDataExchange(CDataExchange* pDX)
{
	//{{AFX_DATA_MAP(CRegionPropPage)
	// NOTE: ClassWizard will add DDP, DDX, and DDV calls here
	//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_DATA_MAP
	DDP_PostProcessing(pDX);
}


/////////////////////////////////////////////////////////////////////////////
// CRegionPropPage message handlers
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\DLSDesigner\RemovedFromProject\WavePpg.cpp ===
// WavePpg.cpp : Implementation of the CWavePropPage property page class.

#include "stdafx.h"
#include "DLSDesignerDLL.h"
#include "WavePpg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


IMPLEMENT_DYNCREATE(CWavePropPage, COlePropertyPage)


/////////////////////////////////////////////////////////////////////////////
// Message map

BEGIN_MESSAGE_MAP(CWavePropPage, COlePropertyPage)
	//{{AFX_MSG_MAP(CWavePropPage)
	// NOTE - ClassWizard will add and remove message map entries
	//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// Initialize class factory and guid

IMPLEMENT_OLECREATE_EX(CWavePropPage, "DLSDESIGNER.WavePropPage.1",
	0xbc964e8f, 0x96f7, 0x11d0, 0x89, 0xaa, 0, 0xa0, 0xc9, 0x5, 0x41, 0x29)


/////////////////////////////////////////////////////////////////////////////
// CWavePropPage::CWavePropPageFactory::UpdateRegistry -
// Adds or removes system registry entries for CWavePropPage

BOOL CWavePropPage::CWavePropPageFactory::UpdateRegistry(BOOL bRegister)
{
	if (bRegister)
		return AfxOleRegisterPropertyPageClass(AfxGetInstanceHandle(),
			m_clsid, IDS_WAVE_PPG);
	else
		return AfxOleUnregisterClass(m_clsid, NULL);
}


/////////////////////////////////////////////////////////////////////////////
// CWavePropPage::CWavePropPage - Constructor

CWavePropPage::CWavePropPage() :
	COlePropertyPage(IDD, IDS_WAVE_PPG_CAPTION)
{
	//{{AFX_DATA_INIT(CWavePropPage)
	// NOTE: ClassWizard will add member initialization here
	//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_DATA_INIT
}


/////////////////////////////////////////////////////////////////////////////
// CWavePropPage::DoDataExchange - Moves data between page and properties

void CWavePropPage::DoDataExchange(CDataExchange* pDX)
{
	//{{AFX_DATA_MAP(CWavePropPage)
	// NOTE: ClassWizard will add DDP, DDX, and DDV calls here
	//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_DATA_MAP
	DDP_PostProcessing(pDX);
}


/////////////////////////////////////////////////////////////////////////////
// CWavePropPage message handlers
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\DLSDesigner\RemovedFromProject\RegionEditor.h ===
#if !defined(AFX_REGIONEDITOR_H__D0620362_CB9E_11D0_876A_00AA00C08146__INCLUDED_)
#define AFX_REGIONEDITOR_H__D0620362_CB9E_11D0_876A_00AA00C08146__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// RegionEditor.h : header file
//

#include "myslider.h"

/////////////////////////////////////////////////////////////////////////////
// CRegionEditor form view

class CWave;

#ifndef __AFXEXT_H__
#include <afxext.h>
#endif

#include "DLSDesignerDLL.h"
#include "DLSDesigner.h"
#include "RiffStrm.h"
#include "CollectionWaves.h"
#include "Region.h"

class CRegionEditor : public CFormView
{
friend class CRegionCtrl;

protected:
	CRegionEditor(CRegionCtrl *parent = NULL);	// protected constructor used by dynamic creation
	DECLARE_DYNCREATE(CRegionEditor)

// Form Data
public:
	MySlider			m_msUpperRange;
    MySlider			m_msLowerRange;
    MySlider			m_msGroup;
    MySlider			m_msTune;
    MySlider			m_msAttenuation;
    MySlider			m_msUnityNote;
    DWORD				m_dwUpperRange;
	DWORD				m_dwLowerRange;
    DWORD				m_dwGroup;
    long				m_lFineTune;
    long				m_lAttenuation;
    long				m_lUnityNote;

	CRegion*			m_pRegion;
	CCollectionWaves*	m_pWaves;
	CWave*				m_pWave;
	CCollection*		m_pCollection;

	//{{AFX_DATA(CRegionEditor)
	enum { IDD = IDD_REGION };
	DWORD	m_dwLoopStart;
	DWORD	m_dwLoopLength;
	BOOL	m_fOneShot;
	BOOL	m_fAllowOverlap;
	BOOL	m_fAllowCompress;
	BOOL	m_fAllowTruncate;
	//}}AFX_DATA

// Attributes
public:

// Operations
public:

private:
CRegionCtrl*	m_parent;


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CRegionEditor)
	public:
	virtual BOOL Create(LPCTSTR lpszClassName, LPCTSTR lpszWindowName, DWORD dwStyle, const RECT& rect, CWnd* pParentWnd, UINT nID, CCreateContext* pContext = NULL);
	virtual void OnInitialUpdate();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	virtual ~CRegionEditor();
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

	// Generated message map functions
	//{{AFX_MSG(CRegionEditor)
	afx_msg void OnGetwave();
	afx_msg void OnHScroll(UINT nSBCode, UINT nPos, CScrollBar* pScrollBar);
	afx_msg void OnSelchangeWavelink();
	afx_msg void OnAllowTruncate();
	afx_msg void OnAllowCompress();
	afx_msg void OnOverlap();
	afx_msg void OnChangeLooplength();
	afx_msg void OnChangeLoopstart();
	afx_msg void OnOneshot();
	afx_msg void OnChangeDgroup();
	afx_msg void OnChangeDtune();
	afx_msg void OnChangeDattenuation();
	afx_msg void OnChangeDunitynote();
	afx_msg void OnChangeElrange();
	afx_msg void OnChangeEurange();
	afx_msg void OnKeyDown(UINT nChar, UINT nRepCnt, UINT nFlags);
	afx_msg void OnKeyUp(UINT nChar, UINT nRepCnt, UINT nFlags);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_REGIONEDITOR_H__D0620362_CB9E_11D0_876A_00AA00C08146__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\DLSDesigner\RemovedFromProject\WavePpg.h ===
#if !defined(AFX_WAVEPPG_H__BC964EB0_96F7_11D0_89AA_00A0C9054129__INCLUDED_)
#define AFX_WAVEPPG_H__BC964EB0_96F7_11D0_89AA_00A0C9054129__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

// WavePpg.h : Declaration of the CWavePropPage property page class.

////////////////////////////////////////////////////////////////////////////
// CWavePropPage : See WavePpg.cpp.cpp for implementation.

class CWavePropPage : public COlePropertyPage
{
	DECLARE_DYNCREATE(CWavePropPage)
	DECLARE_OLECREATE_EX(CWavePropPage)

// Constructor
public:
	CWavePropPage();

// Dialog Data
	//{{AFX_DATA(CWavePropPage)
	enum { IDD = IDD_PROPPAGE_WAVE };
		// NOTE - ClassWizard will add data members here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_DATA

// Implementation
protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support

// Message maps
protected:
	//{{AFX_MSG(CWavePropPage)
		// NOTE - ClassWizard will add and remove member functions here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_WAVEPPG_H__BC964EB0_96F7_11D0_89AA_00A0C9054129__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\DMUSProdGUID\DMUSProdGUID.c ===
// DMUSProdGUID.c : Contains GUIDs not found in MIDL generated Jazz_i.c
//
#include <objbase.h>
#include <initguid.h>
#include <dmusprod.h>
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\DMUSProdGUIDPrivate\DMUSProdGUIDPrivate.c ===
// DMUSProdGUIDPrivate.c : Contains GUIDs not found in MIDL generated Jazz_i.c
//
#include <objbase.h>
#include <initguid.h>
#include <DMPPrivate.h>
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\Framework\Bookmark.h ===
// Bookmark.h: interface for the CBookmark class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_BOOKMARK_H__1FD3A982_F2D7_11D0_89AE_00A0C9054129__INCLUDED_)
#define AFX_BOOKMARK_H__1FD3A982_F2D7_11D0_89AE_00A0C9054129__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000


class CComponentView;

class CBookmark  
{
public:
	CBookmark();
	virtual ~CBookmark();

public:
	BOOL Create();
	HRESULT LoadBookmark( IDMUSProdRIFFStream* pIRiffStream, MMCKINFO* pckMain );
	HRESULT SaveBookmark( CProject* pProject, IDMUSProdRIFFStream* pIRiffStream );
	void Apply( BOOL fCloseWindows );
	BOOL IsForThisProject( CProject* pProject );
	void MergeBookmark( CBookmark* pBookmark );
	void Duplicate();
	void AdjustFileReferenceChunks( IDMUSProdRIFFStream* pIRiffStream, MMCKINFO* pckMain, BOOL* pfChanged );
	BOOL IsValid();

private:
	HRESULT SaveGUID( IDMUSProdRIFFStream* pIRiffStream );
	HRESULT SaveInfoList( IDMUSProdRIFFStream* pIRiffStream );
	HRESULT SaveNodeName( IDMUSProdRIFFStream* pIRiffStream, LPCTSTR szNodeName );
	short GetZOrder( CMDIChildWnd* pFrame );
	void AddToEditorList( CComponentDoc* pComponentDoc, CComponentView* pComponentView );
	BOOL OpenEditor( wpWindowPlacement* pWP );
	void SetWP();

// member variables
public:
	CString m_strName;
    GUID	m_guid;			// Bookmark's GUID	

private:
    CTypedPtrList<CPtrList, wpWindowPlacement*> m_lstEditors;
    CTypedPtrList<CPtrList, bkComponentState*> m_lstComponents;

};

#endif // !defined(AFX_BOOKMARK_H__1FD3A982_F2D7_11D0_89AE_00A0C9054129__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\Framework\Bookmark.cpp ===
// Bookmark.cpp: implementation of the CBookmark class.
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "JazzApp.h"
#include "MainFrm.h"
#include "ioJazzDoc.h"
#include <mmreg.h>

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#define new DEBUG_NEW
#endif


//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CBookmark::CBookmark()
{
	CoCreateGuid( &m_guid ); 
}

CBookmark::~CBookmark()
{
	// Free editor list
	wpWindowPlacement* pWP;
	while( !m_lstEditors.IsEmpty() )
	{
		pWP = static_cast<wpWindowPlacement*>( m_lstEditors.RemoveHead() );
		delete pWP;
	}

	// Free component list
	bkComponentState* pCS;
	while( !m_lstComponents.IsEmpty() )
	{
		pCS = static_cast<bkComponentState*>( m_lstComponents.RemoveHead() );
		if( pCS->pComponentStateInfo )
		{
			GlobalFree( pCS->pComponentStateInfo );
		}
		delete pCS;
	}
}


//////////////////////////////////////////////////////////////////////
// CBookmark GetZOrder

short CBookmark::GetZOrder( CMDIChildWnd* pFrame )
{
	CWnd* pWnd;

	CWnd* pWndParent = pFrame->GetParent();
	if( pWndParent == NULL )
	{
		return -1;
	}

	short nZOrder = 0;

	pWnd = pWndParent->GetTopWindow();
	while( pWnd )
	{
		if( pWnd == pFrame )
		{
			return nZOrder;
		}

		pWnd = pWnd->GetNextWindow();
		nZOrder++;
	}

	return -1;
}


//////////////////////////////////////////////////////////////////////
// CBookmark AddToEditorList

void CBookmark::AddToEditorList( CComponentDoc* pComponentDoc, CComponentView* pComponentView )
{
	ASSERT( pComponentDoc != NULL );
	ASSERT( pComponentView != NULL );
	
	if( pComponentDoc->m_pFileNode == NULL 
	||  pComponentView->m_pINode == NULL )
	{
		// View does not yet have an editor associated with it
		return;
	}

	// Get Node's GUID
	GUID guidNodeId;
	if( FAILED ( pComponentView->m_pINode->GetNodeId ( &guidNodeId ) ) )
	{
		return;
	}

	// Get Node's name
	BSTR bstrName;
	if( FAILED ( pComponentView->m_pINode->GetNodeName ( &bstrName ) ) )
	{
		return;
	}
	CString strName = bstrName;
	::SysFreeString( bstrName );

	// Get Frame window
	CMDIChildWnd* pFrame = (CMDIChildWnd *)pComponentView->GetParentFrame();
	ASSERT_VALID( pFrame );

	// Get Frame's WINDOWPLACEMENT information
	WINDOWPLACEMENT wp;

	wp.length = sizeof(wp);
	if( pFrame->GetWindowPlacement( &wp ) == 0 )
	{
		return;
	}

	// Get Frame's Z-Order information
	short nZOrder = GetZOrder( pFrame );

	// Allocate wpWindowPlacement struct
	wpWindowPlacement* pWP = new wpWindowPlacement;
	if( pWP )
	{
		pWP->strNodeName = strName;
		memcpy( &pWP->guidFile, &pComponentDoc->m_pFileNode->m_guid, sizeof( pWP->guidFile ) );
		memcpy( &pWP->guidNodeId, &guidNodeId, sizeof( pWP->guidNodeId ) );
		pWP->lTreePos = theApp.m_pFramework->GetWPTreePos( pComponentView->m_pINode );

		pWP->nInternalUse = nZOrder;

		pWP->wp.length = sizeof(pWP->wp);
		pWP->wp.flags = wp.flags;
		pWP->wp.showCmd = wp.showCmd;
		pWP->wp.ptMinPosition = wp.ptMinPosition;
		pWP->wp.ptMaxPosition = wp.ptMaxPosition;
		pWP->wp.rcNormalPosition = wp.rcNormalPosition;

		// Place in list according to Z-Order
		if( !m_lstEditors.IsEmpty() )
		{
			wpWindowPlacement* pWPList;
			POSITION pos = m_lstEditors.GetHeadPosition();

			while( pos )
			{
				pWPList = m_lstEditors.GetNext( pos );

				if( pWPList->nInternalUse < pWP->nInternalUse )
				{
					pos = m_lstEditors.Find( pWPList );
					if( pos != NULL )
					{
						m_lstEditors.InsertBefore( pos, pWP );
						return;
					}
				}
			}
		}

		m_lstEditors.AddTail( pWP );
	}
}


//////////////////////////////////////////////////////////////////////
// CBookmark Create

BOOL CBookmark::Create( void )
{
	ASSERT( m_lstEditors.IsEmpty() );
	ASSERT( m_lstComponents.IsEmpty() );

	// Build open Editor list
	CDocTemplate* pTemplate;
	CComponentDoc* pComponentDoc;
	CComponentView* pComponentView;

	if( theApp.m_pDocManager )
	{
		// walk all templates in the application
		POSITION pos = theApp.m_pDocManager->GetFirstDocTemplatePosition();
		while( pos != NULL )
		{
			pTemplate = theApp.m_pDocManager->GetNextDocTemplate( pos );
			ASSERT_VALID( pTemplate );
			ASSERT_KINDOF( CDocTemplate, pTemplate );

			// walk all documents in the template
			POSITION pos2 = pTemplate->GetFirstDocPosition();
			while( pos2 )
			{
				pComponentDoc = (CComponentDoc *)pTemplate->GetNextDoc( pos2 );
				ASSERT_VALID( pComponentDoc );

				if( pComponentDoc->IsKindOf( RUNTIME_CLASS(CComponentDoc) ) )
				{
					POSITION pos3 = pComponentDoc->GetFirstViewPosition();
					while( pos3 )
					{
						pComponentView = (CComponentView *)pComponentDoc->GetNextView( pos3 );
						ASSERT_VALID( pComponentView );

						if( pComponentView
						&&  pComponentView->IsKindOf( RUNTIME_CLASS(CComponentView) ) )
						{
							if( pComponentView->m_fSeed == FALSE )
							{
								AddToEditorList( pComponentDoc, pComponentView );
							}
						}
					}
				}
			}
		}
	}

	// Build component State list
	IDMUSProdComponent* pIComponent;
	IDMUSProdComponent* pINextComponent;
	IPersistStream* pIPS;
	IStream* pIMemStream;
	DWORD dwByteCount;
	STATSTG statstg;

    HRESULT hr = theApp.m_pFramework->GetFirstComponent( &pINextComponent );
	while( SUCCEEDED( hr )  &&  pINextComponent )
    {
		pIComponent = pINextComponent;

		if( SUCCEEDED ( pIComponent->QueryInterface( IID_IPersistStream, (void **)&pIPS ) ) )
		{
			// Create a memory stream
			if( SUCCEEDED ( AllocMemoryStream ( FT_DESIGN, GUID_Bookmark, &pIMemStream ) ) )
			{
				// Place component state information in the stream
				if( SUCCEEDED ( pIPS->Save( pIMemStream, FALSE ) ) )
				{
					// Get size of stream
					if( SUCCEEDED ( pIMemStream->Stat( &statstg, STATFLAG_NONAME ) ) )
					{
						CJzComponent* pJzComponent = theApp.m_pFramework->GetJzComponent( pIComponent );
						if( pJzComponent )
						{
							// Populate the bkComponentState structure
							bkComponentState* pCS = new bkComponentState;
							if( pCS )
							{
								// Store the Component's CLSID
								pCS->clsidComponent = pJzComponent->m_clsidComponent;

								// Store the Component's state info
								pCS->dwComponentStateInfoSize = statstg.cbSize.LowPart;
								pCS->pComponentStateInfo = (BYTE *)GlobalAlloc( GPTR, pCS->dwComponentStateInfoSize );
								if( pCS->pComponentStateInfo )
								{
									StreamSeek( pIMemStream, 0, STREAM_SEEK_SET );
									if( SUCCEEDED ( pIMemStream->Read( pCS->pComponentStateInfo, pCS->dwComponentStateInfoSize, &dwByteCount ) )
									&&  dwByteCount == pCS->dwComponentStateInfoSize )
									{
										// Place the Component's state information in the list
										m_lstComponents.AddTail( pCS );
									}
									else
									{
										GlobalFree( pCS->pComponentStateInfo );
										delete pCS;
									}
								}
								else
								{
									delete pCS;
								}
							}
						}
					}
				}

				pIMemStream->Release();
			}

			pIPS->Release();
		}

	    hr = theApp.m_pFramework->GetNextComponent( pIComponent, &pINextComponent );
		pIComponent->Release();
    }

	return TRUE;
}


//////////////////////////////////////////////////////////////////////
// CBookmark LoadBookmark

HRESULT CBookmark::LoadBookmark( IDMUSProdRIFFStream* pIRiffStream, MMCKINFO* pckMain )
{
    IStream*    pIStream;
	MMCKINFO	ck;
	MMCKINFO	ckList;
	MMCKINFO	ckList2;
	DWORD		dwByteCount;
	DWORD		dwSize;
    HRESULT     hr = S_OK;

    pIStream = pIRiffStream->GetStream();
	ASSERT( pIStream != NULL );

    while( pIRiffStream->Descend( &ck, pckMain, 0 ) == 0 )
	{
        switch( ck.ckid )
		{
			case DMUS_FOURCC_GUID_CHUNK:
				dwSize = min( ck.cksize, sizeof( GUID ) );
				hr = pIStream->Read( &m_guid, dwSize, &dwByteCount );
				if( FAILED( hr )
				||  dwByteCount != dwSize )
				{
					hr = E_FAIL;
					goto ON_ERROR;
				}
				break;

			case FOURCC_LIST:
				switch( ck.fccType )
				{
					case FOURCC_INFO_LIST:
					case FOURCC_UNFO_LIST:
						while( pIRiffStream->Descend( &ckList, &ck, 0 ) == 0 )
						{
							switch( ckList.ckid )
							{
								case RIFFINFO_INAM:
								case FOURCC_UNAM_CHUNK:
									ReadMBSfromWCS( pIStream, ckList.cksize, &m_strName );
									break;
							}
					        pIRiffStream->Ascend( &ckList, 0 );
						}
						break;

					case FOURCC_BOOKMARK_EDITOR_LIST:
					{
						wpWindowPlacement* pWP = new wpWindowPlacement;
						if( pWP )
						{
							m_lstEditors.AddTail( pWP );

							while( pIRiffStream->Descend( &ckList, &ck, 0 ) == 0 )
							{
								switch( ckList.ckid )
								{
									case FOURCC_BOOKMARK_EDITOR_WP_CHUNK:
									{
										ioWindowPlacement ioWP;

										dwSize = min( ckList.cksize, sizeof( ioWindowPlacement ) );
										hr = pIStream->Read( &ioWP, dwSize, &dwByteCount );
										if( FAILED( hr )
										||  dwByteCount != dwSize )
										{
											hr = E_FAIL;
											goto ON_ERROR;
										}

										memcpy( &pWP->guidFile, &ioWP.guidFile, sizeof( pWP->guidFile ) );
										memcpy( &pWP->guidNodeId, &ioWP.guidNodeId, sizeof( pWP->guidNodeId ) );
										pWP->lTreePos = ioWP.lTreePos;

										pWP->wp.length = sizeof(pWP->wp);
										pWP->wp.flags = ioWP.wp.flags;
										pWP->wp.showCmd = ioWP.wp.showCmd;
										pWP->wp.ptMinPosition = ioWP.wp.ptMinPosition;
										pWP->wp.ptMaxPosition = ioWP.wp.ptMaxPosition;
										pWP->wp.rcNormalPosition = ioWP.wp.rcNormalPosition;
										break;
									}
								
									case FOURCC_LIST:
										switch( ckList.fccType )
										{
											case FOURCC_INFO_LIST:
											case FOURCC_UNFO_LIST:
												while( pIRiffStream->Descend( &ckList2, &ckList, 0 ) == 0 )
												{
													switch( ckList2.ckid )
													{
														case FOURCC_UNFO_NODE_NAME:
															ReadMBSfromWCS( pIStream, ckList2.cksize, &pWP->strNodeName );
															break;
													}
													pIRiffStream->Ascend( &ckList2, 0 );
												}
												break;
										}
										break;
								}
								pIRiffStream->Ascend( &ckList, 0 );
							}
						}
						break;
					}


					case FOURCC_BOOKMARK_COMPONENT_LIST:
					{
						bkComponentState* pCS = new bkComponentState;

						if( pCS == NULL )
						{
							hr = E_OUTOFMEMORY;
							goto ON_ERROR;
						}

						while( pIRiffStream->Descend( &ckList, &ck, 0 ) == 0 )
						{
							switch( ckList.ckid )
							{
								case DMUS_FOURCC_GUID_CHUNK:
								{
									dwSize = min( ckList.cksize, sizeof( GUID ) );
									hr = pIStream->Read( &pCS->clsidComponent, dwSize, &dwByteCount );
									if( FAILED( hr )
									||  dwByteCount != dwSize )
									{
										delete pCS;
										hr = E_FAIL;
										goto ON_ERROR;
									}
									break;
								}

								case FOURCC_BOOKMARK_COMPONENT_CHUNK:
								{
									pCS->dwComponentStateInfoSize = ckList.cksize;
									pCS->pComponentStateInfo = (BYTE *)GlobalAlloc( GPTR, pCS->dwComponentStateInfoSize );
									if( pCS->pComponentStateInfo == NULL )
									{
										delete pCS;
										hr = E_OUTOFMEMORY;
										goto ON_ERROR;
									}
									hr = pIStream->Read( pCS->pComponentStateInfo, pCS->dwComponentStateInfoSize, &dwByteCount );
									if( FAILED( hr )
									||  dwByteCount != pCS->dwComponentStateInfoSize )
									{
										hr = E_FAIL;
										GlobalFree( pCS->pComponentStateInfo );
										delete pCS;
										goto ON_ERROR;
									}
									m_lstComponents.AddTail( pCS );
									break;
								}
							}
							pIRiffStream->Ascend( &ckList, 0 );
						}
						break;
					}
				}
				break;
        }

        pIRiffStream->Ascend( &ck, 0 );
    }

ON_ERROR:
    pIStream->Release();
	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CBookmark::SaveNodeName

HRESULT CBookmark::SaveNodeName( IDMUSProdRIFFStream* pIRiffStream, LPCTSTR szNodeName )
{
	IStream* pIStream;
	HRESULT hr;
    MMCKINFO ckMain;
    MMCKINFO ck;
	CString strName = szNodeName;

    pIStream = pIRiffStream->GetStream();
	ASSERT( pIStream != NULL );

	// Write INFO LIST header
	ckMain.fccType = FOURCC_UNFO_LIST;
	if( pIRiffStream->CreateChunk(&ckMain, MMIO_CREATELIST) != 0 )
	{
		hr = E_FAIL;
		goto ON_ERROR;
	}

	// Write Node name
	{
		ck.ckid = FOURCC_UNFO_NODE_NAME;
		if( pIRiffStream->CreateChunk( &ck, 0 ) != 0 )
		{
			hr = E_FAIL;
			goto ON_ERROR;
		}

		hr = SaveMBStoWCS( pIStream, &strName );
		if( FAILED( hr ) )
		{
			goto ON_ERROR;
		}

		if( pIRiffStream->Ascend(&ck, 0) != 0 )
		{
			hr = E_FAIL;
			goto ON_ERROR;
		}
	}

	if( pIRiffStream->Ascend(&ckMain, 0) != 0 )
	{
		hr = E_FAIL;
		goto ON_ERROR;
	}

ON_ERROR:
    pIStream->Release();
    return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CBookmark::SaveGUID

HRESULT CBookmark::SaveGUID( IDMUSProdRIFFStream* pIRiffStream )
{
	IStream* pIStream;
	HRESULT hr;
	MMCKINFO ck;
	DWORD dwBytesWritten;

    pIStream = pIRiffStream->GetStream();
	ASSERT( pIStream != NULL );

	// Write GUID chunk header
	ck.ckid = FOURCC_GUID_CHUNK;
	if( pIRiffStream->CreateChunk( &ck, 0 ) != 0 )
	{
		hr = E_FAIL;
		goto ON_ERROR;
	}

	// Write Bookmark GUID
	hr = pIStream->Write( &m_guid, sizeof(GUID), &dwBytesWritten);
	if( FAILED( hr )
	||  dwBytesWritten != sizeof(GUID) )
	{
        hr = E_FAIL;
        goto ON_ERROR;
	}
	
	if( pIRiffStream->Ascend( &ck, 0 ) != 0 )
	{
 		hr = E_FAIL;
		goto ON_ERROR;
	}

ON_ERROR:
    pIStream->Release();
    return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CBookmark::SaveInfoList

HRESULT CBookmark::SaveInfoList( IDMUSProdRIFFStream* pIRiffStream )
{
	IStream* pIStream;
	HRESULT hr;
    MMCKINFO ckMain;
    MMCKINFO ck;
	CString strName;

    pIStream = pIRiffStream->GetStream();
	ASSERT( pIStream != NULL );

	// Write INFO LIST header
	ckMain.fccType = FOURCC_UNFO_LIST;
	if( pIRiffStream->CreateChunk(&ckMain, MMIO_CREATELIST) != 0 )
	{
		hr = E_FAIL;
		goto ON_ERROR;
	}

	// Prepare Bookmark name
	if( m_strName.IsEmpty() )
	{
		strName = _T("Default");
	}
	else
	{
		strName = m_strName;
	}

	// Write Bookmark name
	{
		ck.ckid = FOURCC_UNAM_CHUNK;
		if( pIRiffStream->CreateChunk( &ck, 0 ) != 0 )
		{
			hr = E_FAIL;
			goto ON_ERROR;
		}

		hr = SaveMBStoWCS( pIStream, &strName );
		if( FAILED( hr ) )
		{
			goto ON_ERROR;
		}

		if( pIRiffStream->Ascend(&ck, 0) != 0 )
		{
			hr = E_FAIL;
			goto ON_ERROR;
		}
	}

	if( pIRiffStream->Ascend(&ckMain, 0) != 0 )
	{
		hr = E_FAIL;
		goto ON_ERROR;
	}

ON_ERROR:
    pIStream->Release();
    return hr;
}


//////////////////////////////////////////////////////////////////////
// CBookmark SaveBookmark

HRESULT CBookmark::SaveBookmark( CProject* pProject, IDMUSProdRIFFStream* pIRiffStream )
{
	IStream* pIStream;
    MMCKINFO ckMain;
    MMCKINFO ck;
	HRESULT hr = S_OK;
	DWORD dwBytesWritten;
	POSITION pos;
	CFileNode* pFileNode;
	ioWindowPlacement ioWP;
	wpWindowPlacement* pWP;
	bkComponentState* pCS;

    pIStream = pIRiffStream->GetStream();
	ASSERT( pIStream != NULL );

	// Save Bookmark GUID
	hr = SaveGUID( pIRiffStream );
	if( FAILED ( hr ) )
	{
        goto ON_ERROR;
	}

	// Save Bookmark name
	hr = SaveInfoList( pIRiffStream );
	if( FAILED ( hr ) )
	{
        goto ON_ERROR;
	}

	// Save Editor WindowPlacement information
    pos = m_lstEditors.GetHeadPosition();
    while( pos )
    {
		pWP = m_lstEditors.GetNext( pos );

		// Only save part of Bookmark relating to this Project
		pFileNode = pProject->GetFileByGUID( pWP->guidFile );
		if( pFileNode == NULL )
		{
			continue;
		}
		pFileNode->Release();
		pFileNode = NULL;

		// Write FOURCC_BOOKMARK_EDITOR_LIST header
		ckMain.fccType = FOURCC_BOOKMARK_EDITOR_LIST;
		if( pIRiffStream->CreateChunk(&ckMain, MMIO_CREATELIST) != 0 )
		{
			hr = E_FAIL;
			goto ON_ERROR;
		}

		// Save Node name
		hr = SaveNodeName( pIRiffStream, pWP->strNodeName );
		if( FAILED ( hr ) )
		{
			hr = E_FAIL;
			goto ON_ERROR;
		}

		// Save ioWindowPlacement struct
		{
			// Write FOURCC_BOOKMARK_EDITOR_WP_CHUNK chunk header
			ck.ckid = FOURCC_BOOKMARK_EDITOR_WP_CHUNK;
			if( pIRiffStream->CreateChunk( &ck, 0 ) != 0 )
			{
				hr = E_FAIL;
				goto ON_ERROR;
			}

			// Prepare ioWindowPlacement struct
			memcpy( &ioWP.guidFile, &pWP->guidFile, sizeof( ioWP.guidFile ) );
			memcpy( &ioWP.guidNodeId, &pWP->guidNodeId, sizeof( ioWP.guidNodeId ) );
			ioWP.lTreePos = pWP->lTreePos;

			ioWP.wp.length = sizeof(ioWP.wp);
			ioWP.wp.flags = pWP->wp.flags;
			ioWP.wp.showCmd = pWP->wp.showCmd;
			ioWP.wp.ptMinPosition = pWP->wp.ptMinPosition;
			ioWP.wp.ptMaxPosition = pWP->wp.ptMaxPosition;
			ioWP.wp.rcNormalPosition = pWP->wp.rcNormalPosition;

			// Write ioWindowPlacement struct
			hr = pIStream->Write( &ioWP, sizeof(ioWindowPlacement), &dwBytesWritten);
			if( FAILED( hr )
			||  dwBytesWritten != sizeof(ioWindowPlacement) )
			{
				hr = E_FAIL;
				goto ON_ERROR;
			}
			
			if( pIRiffStream->Ascend( &ck, 0 ) != 0 )
			{
 				hr = E_FAIL;
				goto ON_ERROR;
			}
		}		
		
		if( pIRiffStream->Ascend(&ckMain, 0) != 0 )
		{
			hr = E_FAIL;
			goto ON_ERROR;
		}
    }

	// Save Component state information
    pos = m_lstComponents.GetHeadPosition();
    while( pos )
    {
		pCS = m_lstComponents.GetNext( pos );

		// Write FOURCC_BOOKMARK_COMPONENT_LIST header
		ckMain.fccType = FOURCC_BOOKMARK_COMPONENT_LIST;
		if( pIRiffStream->CreateChunk(&ckMain, MMIO_CREATELIST) != 0 )
		{
			hr = E_FAIL;
			goto ON_ERROR;
		}
	
		// Save Component CLSID
		{
			// Write GUID chunk header
			ck.ckid = FOURCC_GUID_CHUNK;
			if( pIRiffStream->CreateChunk( &ck, 0 ) != 0 )
			{
				hr = E_FAIL;
				goto ON_ERROR;
			}

			// Write Component GUID
			hr = pIStream->Write( &pCS->clsidComponent, sizeof(GUID), &dwBytesWritten);
			if( FAILED( hr )
			||  dwBytesWritten != sizeof(GUID) )
			{
				hr = E_FAIL;
				goto ON_ERROR;
			}
			
			if( pIRiffStream->Ascend( &ck, 0 ) != 0 )
			{
 				hr = E_FAIL;
				goto ON_ERROR;
			}
		}

		// Save Component state info chunk
		{
			// Write FOURCC_BOOKMARK_COMPONENT_CHUNK chunk header
			ck.ckid = FOURCC_BOOKMARK_COMPONENT_CHUNK;
			if( pIRiffStream->CreateChunk( &ck, 0 ) != 0 )
			{
				hr = E_FAIL;
				goto ON_ERROR;
			}

			// Write FOURCC_BOOKMARK_COMPONENT_CHUNK data
			hr = pIStream->Write( pCS->pComponentStateInfo,
								  pCS->dwComponentStateInfoSize,
								  &dwBytesWritten );
			if( FAILED( hr )
			||  dwBytesWritten != pCS->dwComponentStateInfoSize )
			{
				hr = E_FAIL;
				goto ON_ERROR;
			}
	
			if( pIRiffStream->Ascend( &ck, 0 ) != 0 )
			{
 				hr = E_FAIL;
				goto ON_ERROR;
			}
		}

		if( pIRiffStream->Ascend(&ckMain, 0) != 0 )
		{
			hr = E_FAIL;
			goto ON_ERROR;
		}
    }

ON_ERROR:
    pIStream->Release();

	return hr;
}


//////////////////////////////////////////////////////////////////////
// CBookmark OpenEditor

BOOL CBookmark::OpenEditor( wpWindowPlacement* pWP )
{
	CFileNode* pFileNode = NULL;
	CTreeCtrl* pTreeCtrl;
	HTREEITEM hItem;

	BOOL fSuccess = FALSE;

	// Get the FileNode
	pFileNode = theApp.GetFileByGUID( pWP->guidFile );
	if( pFileNode == NULL )
	{
		goto ON_ERR;
	}

	// Make sure the FileNode's file is loaded
	if( pFileNode->m_pIChildNode == NULL )
	{
		CString strFileName;
		pFileNode->ConstructFileName( strFileName );
		
		// Open the file
		theApp.m_nShowNodeInTree++;
		theApp.OpenTheFile( strFileName, TGT_FILENODE );
		theApp.m_nShowNodeInTree--;
	}
	if( pFileNode->m_pIChildNode == NULL )
	{
		goto ON_ERR;
	}

	// Find the corresponding node in the Project Tree
	hItem = theApp.m_pFramework->FindTreeItemByWP( pWP );
	if( hItem == NULL )
	{
		goto ON_ERR;
	}
		
	// Apply WP Settings to the node
	theApp.m_pFramework->ApplyWPSettings( hItem, pWP );

	// Open the Node's Editor
	pTreeCtrl = theApp.GetProjectTreeCtrl();
	if( pTreeCtrl )
	{
		CJzNode* pJzNode = (CJzNode *)pTreeCtrl->GetItemData( hItem );
		if( pJzNode )
		{
			IDMUSProdNode* pINode = pJzNode->m_pINode;
			ASSERT( pINode != NULL );
	
			theApp.m_pFramework->OpenEditor( pINode );
	
			fSuccess = TRUE;
		}
	}

ON_ERR:
	if( pFileNode )
	{
		pFileNode->Release();
	}

	return fSuccess;
}


//////////////////////////////////////////////////////////////////////
// CBookmark SetWP

void CBookmark::SetWP( void )
{
	CDocTemplate* pTemplate;
	CComponentDoc* pComponentDoc;
	CComponentView* pComponentView;
	CFrameWnd* pFrame;
	HTREEITEM hItem;
	CJzNode* pJzNode;

	CTreeCtrl* pTreeCtrl = theApp.GetProjectTreeCtrl();
	if( pTreeCtrl == NULL )
	{
		return;
	}

	if( theApp.m_pDocManager )
	{
		// walk all templates in the application
		POSITION pos = theApp.m_pDocManager->GetFirstDocTemplatePosition();
		while( pos != NULL )
		{
			pTemplate = theApp.m_pDocManager->GetNextDocTemplate( pos );
			ASSERT_VALID( pTemplate );
			ASSERT_KINDOF( CDocTemplate, pTemplate );

			// walk all documents in the template
			POSITION pos2 = pTemplate->GetFirstDocPosition();
			while( pos2 )
			{
				pComponentDoc = (CComponentDoc *)pTemplate->GetNextDoc( pos2 );
				ASSERT_VALID( pComponentDoc );

				if( pComponentDoc->IsKindOf( RUNTIME_CLASS(CComponentDoc) ) )
				{
					POSITION pos3 = pComponentDoc->GetFirstViewPosition();
					while( pos3 )
					{
						pComponentView = (CComponentView *)pComponentDoc->GetNextView( pos3 );
						ASSERT_VALID( pComponentView );

						if( pComponentView
						&&  pComponentView->IsKindOf( RUNTIME_CLASS(CComponentView) ) )
						{
							if( pComponentView->m_fSeed == FALSE )
							{
								if( pComponentView->m_pINode )
								{
									hItem = theApp.m_pFramework->FindTreeItem( pComponentView->m_pINode );
									if( hItem )
									{
										pJzNode = (CJzNode *)pTreeCtrl->GetItemData( hItem );
										if( pJzNode )
										{
											if( pJzNode->m_wp.length != 0 )
											{
												pJzNode->m_wp.length = sizeof(pJzNode->m_wp);
												pFrame = pComponentView->GetParentFrame();
												pFrame->SetWindowPlacement( &pJzNode->m_wp );
											}
										}
									}
								}
							}
						}
					}
				}
			}
		}
	}
}


//////////////////////////////////////////////////////////////////////
// CBookmark Apply

void CBookmark::Apply( BOOL fCloseWindows )
{
	// Close all open Editors
	if( fCloseWindows )
	{
		theApp.OnWindowCloseAll();
	}

	// Restore state of Components
	IDMUSProdComponent* pIComponent;
	IPersistStream* pIPS;
	IStream* pIMemStream;
	bkComponentState* pCS;
	DWORD dwBytesWritten;

    POSITION pos = m_lstComponents.GetHeadPosition();
    while( pos )
    {
		pCS = m_lstComponents.GetNext( pos );

		if( SUCCEEDED ( theApp.m_pFramework->FindComponent( pCS->clsidComponent, &pIComponent) ) )
		{
			if( SUCCEEDED ( pIComponent->QueryInterface( IID_IPersistStream, (void**)&pIPS ) ) )
			{
				// Create a memory stream
				if( SUCCEEDED ( AllocMemoryStream ( FT_DESIGN, GUID_Bookmark, &pIMemStream ) ) )
				{
					// Place component state information in the stream
					if( SUCCEEDED ( pIMemStream->Write( pCS->pComponentStateInfo, pCS->dwComponentStateInfoSize, &dwBytesWritten ) )
					&&  dwBytesWritten == pCS->dwComponentStateInfoSize )
					{
						// Hand state info to the Component
						StreamSeek( pIMemStream, 0, STREAM_SEEK_SET );
						pIPS->Load( pIMemStream );
					}

					pIMemStream->Release();
				}

				pIPS->Release();
			}

			pIComponent->Release();
		}
	}


	// Open all Editors in the Editor list
	wpWindowPlacement* pWP;
    
	pos = m_lstEditors.GetHeadPosition();
    while( pos )
    {
		pWP = m_lstEditors.GetNext( pos );

		OpenEditor( pWP );
	}

	// Now that all Editors are open,
	// reapply WP to get correct minimized/maximized state
	SetWP();
}


//////////////////////////////////////////////////////////////////////
// CBookmark IsForThisProject

BOOL CBookmark::IsForThisProject( CProject* pProject )
{
	wpWindowPlacement* pWP;
	CFileNode* pFileNode;

    POSITION pos = m_lstEditors.GetHeadPosition();
    while( pos )
    {
		pWP = m_lstEditors.GetNext( pos );

		pFileNode = pProject->GetFileByGUID( pWP->guidFile );
		if( pFileNode )
		{
			pFileNode->Release();
			return TRUE;
		}
	}

	return FALSE;
}


//////////////////////////////////////////////////////////////////////
// CBookmark IsValid

BOOL CBookmark::IsValid( void )
{
	wpWindowPlacement* pWP;
	CFileNode* pFileNode;

    POSITION pos = m_lstEditors.GetHeadPosition();
    while( pos )
    {
		pWP = m_lstEditors.GetNext( pos );

		pFileNode = theApp.GetFileByGUID( pWP->guidFile );
		if( pFileNode )
		{
			pFileNode->Release();
			return TRUE;
		}
	}

	return FALSE;
}


//////////////////////////////////////////////////////////////////////
// CBookmark MergeBookmark

void CBookmark::MergeBookmark( CBookmark* pBookmark )
{
	wpWindowPlacement* pWP;

	while( !pBookmark->m_lstEditors.IsEmpty() )
	{
		// Remove editor from pBookmark
		pWP = static_cast<wpWindowPlacement*>( pBookmark->m_lstEditors.RemoveHead() );

		// Add editor to this bookmark
		m_lstEditors.AddTail( pWP );
	}
}


/////////////////////////////////////////////////////////////////////////////
// CBookmark AdjustFileReferenceChunks

void CBookmark::AdjustFileReferenceChunks( IDMUSProdRIFFStream* pIRIFFStream, MMCKINFO* pckMain, BOOL* pfChanged )
{
	MMCKINFO ck;
	DWORD dwByteCount;
	DWORD dwSize;
	DWORD dwPos;
	ioFileRef iFileRef;
			
	if( theApp.m_fInDuplicateProject == FALSE )
	{
		// Only call when we are duplicating a Project
		// because this method depends on existence
		// of m_lstFileGUIDs.
		ASSERT( 0 );
		return;
	}

    IStream* pIStream = pIRIFFStream->GetStream();
	ASSERT( pIStream != NULL );

	// Rewrite all file reference chunks written by the Framework
	while( pIRIFFStream->Descend( &ck, pckMain, 0 ) == 0 )
	{
		switch( ck.ckid )
		{
			case FOURCC_DMUSPROD_FILEREF:
				dwSize = min( ck.cksize, sizeof( ioFileRef ) );

				// Read the FileRef chunk data
				dwPos = StreamTell( pIStream );
				if( SUCCEEDED ( pIStream->Read( &iFileRef, dwSize, &dwByteCount ) ) 
				&&  dwByteCount == dwSize )
				{
					// Get the new GUID
					GUID guidNewFile;
					if( theApp.GetNewGUIDForDuplicateFile( iFileRef.guidFile, &guidNewFile ) )
					{
						memcpy( &iFileRef.guidFile, &guidNewFile, sizeof( iFileRef.guidFile ) );

						// Rewrite the reference chunk with the new GUID
					    StreamSeek( pIStream, dwPos, STREAM_SEEK_SET );
						if( SUCCEEDED ( pIStream->Write( &iFileRef, dwSize, &dwByteCount ) ) 
						&&  dwByteCount == dwSize )
						{
							*pfChanged = TRUE;
						}
					}
				}
				break;

			case FOURCC_RIFF:
			case FOURCC_LIST:
				AdjustFileReferenceChunks( pIRIFFStream, &ck, pfChanged );
				break;


			default:
				break;
		}

		pIRIFFStream->Ascend( &ck, 0 );
	}

	pIStream->Release();
}


/////////////////////////////////////////////////////////////////////////////
// CBookmark Duplicate

void CBookmark::Duplicate( void )
{
	CMainFrame* pMainFrame = (CMainFrame *)theApp.m_pMainWnd;
	ASSERT( pMainFrame != NULL );

	if( theApp.m_fInDuplicateProject == FALSE )
	{
		// Only call when we are duplicating a Project
		// because this method depends on existence
		// of m_lstFileGUIDs.
		ASSERT( 0 );
		return;
	}

	// Duplicate the Bookmark
	CBookmark* pBookmark = new CBookmark;
	if( pBookmark )
	{
		// Set the name
		pBookmark->m_strName = m_strName;

		// Duplicate the editors
		wpWindowPlacement* pWPList;
		wpWindowPlacement* pWP;
		POSITION pos = m_lstEditors.GetHeadPosition();
		while( pos )
		{
			pWPList = m_lstEditors.GetNext( pos );

			pWP = new wpWindowPlacement;
			if( pWP )
			{
				*pWP = *pWPList;

				GUID guidNewFile;
				if( theApp.GetNewGUIDForDuplicateFile( pWP->guidFile, &guidNewFile ) )
				{
					memcpy( &pWP->guidFile, &guidNewFile, sizeof( pWP->guidFile ) );
				}

				pBookmark->m_lstEditors.AddTail( pWP );
			}
		}

		// Duplicate the component state information
		bkComponentState* pCSList;
		bkComponentState* pCS;
		pos = m_lstComponents.GetHeadPosition();
		while( pos )
		{
			pCSList = m_lstComponents.GetNext( pos );

			pCS = new bkComponentState; 
			if( pCS )
			{
				// Store the Component's CLSID
				pCS->clsidComponent = pCSList->clsidComponent;

				// Store the Component's state info
				pCS->dwComponentStateInfoSize = pCSList->dwComponentStateInfoSize;
				pCS->pComponentStateInfo = (BYTE *)GlobalAlloc( GPTR, pCS->dwComponentStateInfoSize );
				if( pCS->pComponentStateInfo )
				{
					memcpy( pCS->pComponentStateInfo, pCSList->pComponentStateInfo, pCS->dwComponentStateInfoSize );

					// If RIFF format, fix all file reference chunks written by the Framework
					if( memcmp( pCS->pComponentStateInfo, "RIFF", 4 ) == 0
					||  memcmp( pCS->pComponentStateInfo, "LIST", 4 ) == 0 )
					{
						// Get a memory stream
						IStream* pIMemStream;
						if( SUCCEEDED ( theApp.m_pFramework->AllocMemoryStream( FT_DESIGN, GUID_CurrentVersion, &pIMemStream ) ) )
						{
							// Get a RIFF stream
							IDMUSProdRIFFStream* pIRIFFStream;
							if( SUCCEEDED ( AllocRIFFStream( pIMemStream, &pIRIFFStream ) ) )
							{
								DWORD dwByteCount;

								// Place pCS->pComponentStateInfo into a stream
								if( SUCCEEDED ( pIMemStream->Write( pCS->pComponentStateInfo, pCS->dwComponentStateInfoSize, &dwByteCount ) ) 
								&&  dwByteCount == pCS->dwComponentStateInfoSize )
								{
									StreamSeek( pIMemStream, 0, STREAM_SEEK_SET );

									BOOL fChanged = FALSE;

									AdjustFileReferenceChunks( pIRIFFStream, NULL, &fChanged );
									if( fChanged )
									{
										StreamSeek( pIMemStream, 0, STREAM_SEEK_SET );
										pIMemStream->Read( pCS->pComponentStateInfo, pCS->dwComponentStateInfoSize, &dwByteCount );
									}
								}

								pIRIFFStream->Release();
							}

							pIMemStream->Release();
						}
					}

					pBookmark->m_lstComponents.AddTail( pCS );
				}
				else
				{
					delete pCS;
				}
			}
		}

		// Add the Bookmark to the list of Bookmarks
		if( pMainFrame->m_wndBookmarkToolBar.AddBookmark( pBookmark, FALSE ) == FALSE )
		{
			delete pBookmark;
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\Framework\ChildFrm.cpp ===
// ChildFrm.cpp : implementation of the CChildFrame class
//

#include "stdafx.h"
#include "JazzApp.h"
#include "MainFrm.h"
#include "ComponentCntrItem.h"
#include "ChildFrm.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


/////////////////////////////////////////////////////////////////////////////
// CChildFrame

IMPLEMENT_DYNCREATE(CChildFrame, CMDIChildWnd)

BEGIN_MESSAGE_MAP(CChildFrame, CMDIChildWnd)
	//{{AFX_MSG_MAP(CChildFrame)
	ON_WM_GETMINMAXINFO()
	ON_WM_MDIACTIVATE()
	ON_WM_NCRBUTTONDOWN()
	ON_WM_MOUSEACTIVATE()
	ON_WM_NCLBUTTONDOWN()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CChildFrame construction/destruction

CChildFrame::CChildFrame()
{
	// TODO: add member initialization code here
	
}

CChildFrame::~CChildFrame()
{
}
	
/////////////////////////////////////////////////////////////////////////////
// CChildFrame SetFocusToEditor

void CChildFrame::SetFocusToEditor( void )
{
	// Get the MDI child window's active view
	CComponentView *pView = (CComponentView *)GetActiveView();

	if( pView
	&&  pView->IsKindOf( RUNTIME_CLASS(CComponentView) ) )
	{
		CWnd* pWnd = pView->GetNextWindow( GW_CHILD );
		if( pWnd )
		{
			pWnd = pWnd->GetNextWindow( GW_CHILD );
			if( pWnd )
			{
				CWnd* pWndCtl = pWnd->GetNextDlgTabItem( pWnd );
				if( pWndCtl )
				{
					pWndCtl->SetFocus();
				}
				else
				{
					pWnd->SetFocus();
				}
			}
		}
	}
}


/////////////////////////////////////////////////////////////////////////////
// CChildFrame PreCreateWindow

BOOL CChildFrame::PreCreateWindow(CREATESTRUCT& cs)
{
	// TODO: Modify the Window class or styles here by modifying
	//  the CREATESTRUCT cs

	return CMDIChildWnd::PreCreateWindow(cs);
}

/////////////////////////////////////////////////////////////////////////////
// CChildFrame diagnostics

#ifdef _DEBUG
void CChildFrame::AssertValid() const
{
	AFX_MANAGE_STATE( AfxGetAppModuleState() );
	CMDIChildWnd::AssertValid();
}

void CChildFrame::Dump(CDumpContext& dc) const
{
	CMDIChildWnd::Dump(dc);
}

#endif //_DEBUG


/////////////////////////////////////////////////////////////////////////////
// CChildFrame message handlers

/////////////////////////////////////////////////////////////////////////////
// CChildFrame::OnGetMinMaxInfo

void CChildFrame::OnGetMinMaxInfo( MINMAXINFO FAR* lpMMI ) 
{
    lpMMI->ptMinTrackSize.x = 80;
    lpMMI->ptMinTrackSize.y = 40;
	
	CComponentView* pView = (CComponentView *)GetActiveView();

	if( pView
	&&  pView->m_pINode
	&&  pView->m_pEditorCtrl )
	{
		CWnd* pWnd = pView->m_pEditorCtrl->GetInPlaceWindow(); 
		if( pWnd )
		{
			CWnd* pWndChild = pWnd->GetWindow( GW_CHILD );
			if( pWndChild )
			{
				pWndChild->SendMessage( WM_GETMINMAXINFO, 0, (LPARAM)lpMMI );
			}
		}
	}
}


/////////////////////////////////////////////////////////////////////////////
// CChildFrame::OnMouseActivate

int CChildFrame::OnMouseActivate( CWnd* pDesktopWnd, UINT nHitTest, UINT message ) 
{
	if( nHitTest == HTCLIENT )
	{
		CComponentView* pView = (CComponentView *)GetActiveView();

		if( pView
		&&  pView->m_pINode )
		{
			if( pView->m_pIProject )
			{
				// Set the active Project to the Project containing this View
				theApp.SetActiveProject( (CProject *)pView->m_pIProject );
			}
		}
	}
	
	return CMDIChildWnd::OnMouseActivate( pDesktopWnd, nHitTest, message );
}


/////////////////////////////////////////////////////////////////////////////
// CChildFrame::OnUpdateFrameMenu

void CChildFrame::OnUpdateFrameMenu( BOOL bActivate, CWnd* pActivateWnd, HMENU hMenuAlt )
{
	CMDIFrameWnd* pFrame = GetMDIFrame();

	if (hMenuAlt == NULL && bActivate)
	{
		// attempt to get default menu from document
		CDocument* pDoc = GetActiveDocument();
		if (pDoc != NULL)
			hMenuAlt = pDoc->GetDefaultMenu();
	}

	// use default menu stored in frame if none from document
	if (hMenuAlt == NULL)
		hMenuAlt = m_hMenuShared;

	if (hMenuAlt != NULL && bActivate)
	{
		ASSERT(pActivateWnd == this);

		// activating child, set parent menu
		::SendMessage(pFrame->m_hWndMDIClient, WM_MDISETMENU,
			(WPARAM)hMenuAlt, (LPARAM)pFrame->GetWindowMenuPopup(hMenuAlt));
	}
	else if (hMenuAlt != NULL && !bActivate && pActivateWnd == NULL)
	{
		// destroying last child
		HMENU hMenuLast = NULL;
		::SendMessage(pFrame->m_hWndMDIClient, WM_MDISETMENU,
			(WPARAM)pFrame->m_hMenuDefault, (LPARAM)hMenuLast);
	}
//	else
//	{
//		// refresh MDI Window menu (even if non-shared menu)
//		::SendMessage(pFrame->m_hWndMDIClient, WM_MDIREFRESHMENU, 0, 0);
//	}
}


/////////////////////////////////////////////////////////////////////////////
// CChildFrame::OnMDIActivate

void CChildFrame::OnMDIActivate( BOOL bActivate, CWnd* pActivateWnd, CWnd* pDeactivateWnd ) 
{
	if( bActivate == TRUE )
	{
		CComponentView* pView = (CComponentView *)GetActiveView();

		if( pView )
		{
			if( pView->m_pINode )
			{
				// Highlight the corresponding node in the Project Tree
				theApp.m_pFramework->ShowTreeNode( pView->m_pINode );
			}

			if( pView->m_pIProject )
			{
				// Set the active Project to the Project containing this View
				theApp.SetActiveProject( (CProject *)pView->m_pIProject );
			}
		}
	}

	CMDIChildWnd::OnMDIActivate( bActivate, pActivateWnd, pDeactivateWnd );
	
	if( bActivate == FALSE )
	{
		if( pDeactivateWnd->IsZoomed() )
		{
			CMainFrame* pMainFrame = (CMainFrame *)theApp.m_pMainWnd;
			if( pMainFrame )
			{
				pMainFrame->RecalcLayout( TRUE );
			}
		}
	}

	if( bActivate )
	{
		if( pActivateWnd->IsZoomed() )
		{
			ShowWindow( SW_SHOWNOACTIVATE );
			ShowWindow( SW_SHOWMAXIMIZED );
		}

		SetFocusToEditor();
	}
}


/////////////////////////////////////////////////////////////////////////////
// CChildFrame::OnNcRButtonDown

void CChildFrame::OnNcRButtonDown( UINT nHitTest, CPoint point ) 
{
	CMDIChildWnd::OnNcRButtonDown( nHitTest, point );

	if( (nHitTest == HTCAPTION)
	&&  (GetKeyState(VK_RBUTTON) < 0) )
	{
		CMainFrame* pMainFrame = (CMainFrame *)theApp.m_pMainWnd;
		ASSERT( pMainFrame != NULL );
		CComponentView* pView = (CComponentView *)GetActiveView();

		if( pView
		&&  pView->m_pINode )
		{
			SetFocusToEditor();
			pMainFrame->m_wndTreeBar.RightClickMenu( pView->m_pINode, point );
		}
	}
}


/////////////////////////////////////////////////////////////////////////////
// CChildFrame::OnNcLButtonDown

void CChildFrame::OnNcLButtonDown( UINT nHitTest, CPoint point ) 
{
	CMDIChildWnd::OnNcLButtonDown( nHitTest, point );

	if( nHitTest == HTCAPTION )
	{
		// User clicked in title bar so display properties for associated node
		CMainFrame* pMainFrame = (CMainFrame *)theApp.m_pMainWnd;
		ASSERT( pMainFrame != NULL );

		CComponentView* pView = (CComponentView *)GetActiveView();

		if( pView
		&&  pView->m_pINode )
		{
			CTreeCtrl* pTreeCtrl = theApp.GetProjectTreeCtrl();
			if( pTreeCtrl )
			{
				IDMUSProdPropSheet* pIPropSheet = theApp.GetPropertySheet();
				if( pIPropSheet )
				{
					if( pIPropSheet->IsShowing() == S_OK )
					{
						BOOL fHaveProperties = FALSE;

						// Get properties for node
						IDMUSProdPropPageObject* pIPageObject;
						if( SUCCEEDED ( pView->m_pINode->QueryInterface( IID_IDMUSProdPropPageObject, (void **)&pIPageObject ) ) )
						{
							fHaveProperties = TRUE;
							if( pIPropSheet->IsEqualPageManagerObject(pIPageObject) != S_OK )
							{
								pIPageObject->OnShowProperties();
							}
							pIPageObject->Release();
						}

						if( fHaveProperties == FALSE )
						{
							// Display 'No Properties'
							if( pMainFrame->m_wndProperties.m_pPropertySheet )
							{
								pMainFrame->m_wndProperties.m_pPropertySheet->RemoveCurrentPageManager();
							}
						}
					}

					pIPropSheet->Release();
				}
			}

			SetFocusToEditor();
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\Framework\ChildFrm.h ===
#if !defined(CHILDFRM_H__B6AED00E_3BDF_11D0_89AC_00A0C9054129__INCLUDED_)
#define CHILDFRM_H__B6AED00E_3BDF_11D0_89AC_00A0C9054129__INCLUDED_

// ChildFrm.h : interface of the CChildFrame class
//
/////////////////////////////////////////////////////////////////////////////

class CChildFrame : public CMDIChildWnd
{
	DECLARE_DYNCREATE(CChildFrame)
public:
	CChildFrame();

// Attributes
public:

// Operations
public:

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CChildFrame)
	public:
	virtual BOOL PreCreateWindow(CREATESTRUCT& cs);
	//}}AFX_VIRTUAL
	virtual void OnUpdateFrameMenu(BOOL bActive, CWnd* pActivateWnd,
		HMENU hMenuAlt);

// Implementation
public:
	virtual ~CChildFrame();

	void SetFocusToEditor();

#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

// Generated message map functions
protected:
	//{{AFX_MSG(CChildFrame)
	afx_msg void OnGetMinMaxInfo(MINMAXINFO FAR* lpMMI);
	afx_msg void OnMDIActivate(BOOL bActivate, CWnd* pActivateWnd, CWnd* pDeactivateWnd);
	afx_msg void OnNcRButtonDown(UINT nHitTest, CPoint point);
	afx_msg int OnMouseActivate(CWnd* pDesktopWnd, UINT nHitTest, UINT message);
	afx_msg void OnNcLButtonDown(UINT nHitTest, CPoint point);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(CHILDFRM_H__B6AED00E_3BDF_11D0_89AC_00A0C9054129__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\Framework\ClientToolBar.cpp ===
// ClientToolBar.cpp : implementation file
//

#include "stdafx.h"
#include "JazzApp.h"
#include "MainFrm.h"
#include "ClientToolBar.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

#define VERSION_WIN4    MAKELONG(0, 4)
#define VERSION_IE3     MAKELONG(70, 4)
#define VERSION_IE4     MAKELONG(71, 4)
#define VERSION_IE401   MAKELONG(72, 4)

struct AFX_DLLVERSIONINFO
{
		DWORD cbSize;
		DWORD dwMajorVersion;                   // Major version
		DWORD dwMinorVersion;                   // Minor version
		DWORD dwBuildNumber;                    // Build number
		DWORD dwPlatformID;                     // DLLVER_PLATFORM_*
};

typedef HRESULT (CALLBACK* AFX_DLLGETVERSIONPROC)(AFX_DLLVERSIONINFO *);

int _afxComCtlVersion = -1;

DWORD AFXAPI _AfxGetComCtlVersion()
{
	// return cached version if already determined...
	if (_afxComCtlVersion != -1)
		return _afxComCtlVersion;

	// otherwise determine comctl32.dll version via DllGetVersion
	HINSTANCE hInst = ::GetModuleHandleA("COMCTL32.DLL");
	ASSERT(hInst != NULL);
	AFX_DLLGETVERSIONPROC pfn;
	pfn = (AFX_DLLGETVERSIONPROC)GetProcAddress(hInst, "DllGetVersion");
	DWORD dwVersion = VERSION_WIN4;
	if (pfn != NULL)
	{
		AFX_DLLVERSIONINFO dvi;
		memset(&dvi, 0, sizeof(dvi));
		dvi.cbSize = sizeof(dvi);
		HRESULT hr = (*pfn)(&dvi);
		if (SUCCEEDED(hr))
		{
			ASSERT(dvi.dwMajorVersion <= 0xFFFF);
			ASSERT(dvi.dwMinorVersion <= 0xFFFF);
			dwVersion = MAKELONG(dvi.dwMinorVersion, dvi.dwMajorVersion);
		}
	}
	_afxComCtlVersion = dwVersion;
	return dwVersion;
}

int _afxDropDownWidth = -1;

int AFXAPI _AfxGetDropDownWidth()
{
	// return cached version if already determined...
	if (_afxDropDownWidth != -1)
		return _afxDropDownWidth;

	// otherwise calculate it...
	HDC hDC = GetDC(NULL);
	ASSERT(hDC != NULL);
	HFONT hFont = NULL, hFontOld = NULL;
	if ((hFont = CreateFont(GetSystemMetrics(SM_CYMENUCHECK), 0, 0, 0,
		FW_NORMAL, 0, 0, 0, SYMBOL_CHARSET, 0, 0, 0, 0, _T("Marlett"))) != NULL)
		hFontOld = (HFONT)SelectObject(hDC, hFont);
	VERIFY(GetCharWidth(hDC, '6', '6', &_afxDropDownWidth));
	if (hFont != NULL)
	{
		hFont = (HFONT)SelectObject(hDC, hFontOld);
		DeleteObject(hFont);
	}
	ReleaseDC(NULL, hDC);
	ASSERT(_afxDropDownWidth != -1);
	return _afxDropDownWidth;
}

/////////////////////////////////////////////////////////////////////////////
// CClientToolBar

CClientToolBar::CClientToolBar( IDMUSProdToolBar* pIToolBar )
{
	ASSERT( pIToolBar != NULL );

	m_pIToolBar = pIToolBar;
	m_pIToolBar->AddRef();

	m_sizeDefaultButton = m_sizeButton;

	m_hInstance = AfxGetInstanceHandle();	// default instance

	_AfxGetComCtlVersion();

	_AfxGetDropDownWidth();
}

CClientToolBar::~CClientToolBar()
{
	if( m_pIToolBar )
	{
		m_pIToolBar->Release();
	}
}


/////////////////////////////////////////////////////////////////////////////
// CClientToolBar overrides

/////////////////////////////////////////////////////////////////////////////
// CClientToolBar::OnUpdateCmdUI

void CClientToolBar::OnUpdateCmdUI( CFrameWnd* pTarget, BOOL bDisableIfNoHndler )
{
	CToolBar::OnUpdateCmdUI( pTarget, FALSE );
}


/////////////////////////////////////////////////////////////////////////////
// CClientToolBar::OnToolHitTest

int CClientToolBar::OnToolHitTest( CPoint point, TOOLINFO* pTI ) const
{
    ASSERT_VALID( this );
    ASSERT( ::IsWindow(m_hWnd) );

    // Check child windows first by calling CControlBar
	CRect rect;

    int nControlID = CControlBar::OnToolHitTest( point, pTI );
    if( nControlID != -1 )
	{
		// Cursor over control in toolbar
		CWnd* pWnd = GetDlgItem( nControlID );
		if( pWnd )
		{
			CWnd* pWndParent = pWnd->GetParent();
			pWnd->GetClientRect( &rect );
			pWnd->ClientToScreen( &rect );
			pWndParent->ScreenToClient( &rect );
			if( pTI != NULL && pTI->cbSize >= 40 )	// 40 = sizeof(AfxOldTOOLINFO)
			{
				pTI->uFlags |= TTF_IDISHWND; 
				pTI->uId = (UINT)pWnd->m_hWnd;
			}
		}
		else
		{
			nControlID = -1;
		}
    }
	else
	{
		// Now hit test against CToolBar buttons
		CClientToolBar* pBar = (CClientToolBar*)this;
		int nButtons = (int)pBar->DefWindowProc( TB_BUTTONCOUNT, 0, 0 );

		for( int i = 0; i < nButtons; i++ )
		{
			TBBUTTON button;

			if( pBar->DefWindowProc(TB_GETITEMRECT, i, (LPARAM)&rect)
			&&  rect.PtInRect(point)
			&&  pBar->DefWindowProc(TB_GETBUTTON, i, (LPARAM)&button)
			&& !(button.fsStyle & TBSTYLE_SEP) )
			{
				nControlID = GetItemID( i );
				break;
			}
        }
	}

	if( nControlID > 0 )
	{
		if( pTI != NULL && pTI->cbSize >= 40 )	// 40 = sizeof(AfxOldTOOLINFO)
        {
			TCHAR szFullText[256];
			CString strTipText;

            pTI->hwnd = m_hWnd;
            pTI->rect = rect;
            if( !(pTI->uFlags & TTF_IDISHWND) )
			{
				pTI->uId = nControlID;
			}
			pTI->uFlags |= TTF_ALWAYSTIP;
			pTI->hinst = NULL;
			::LoadString( m_hInstance, nControlID, szFullText, sizeof(szFullText) / sizeof(TCHAR) );
			AfxExtractSubString( strTipText, szFullText, 1, '\n' );
		    _tcsncpy( szFullText, strTipText, sizeof(szFullText) / sizeof(TCHAR ));
			pTI->lpszText = _tcsdup( szFullText );
        }

		return nControlID;
	}
	else
	{
		CMainFrame* pMainFrame = (CMainFrame *)theApp.m_pMainWnd;
		ASSERT( pMainFrame != NULL );

		CString strText;
		
		strText.LoadString( AFX_IDS_IDLEMESSAGE );
		pMainFrame->m_wndStatusBar.SetWindowText( strText );
	}

	return -1;
}


/////////////////////////////////////////////////////////////////////////////
// CClientToolBar::SetStatusText

BOOL CClientToolBar::SetStatusText( int nControlID )
{
	if( CToolBar::SetStatusText(nControlID) == TRUE )
	{
		if( nControlID != -1 )
		{
			TCHAR szFullText[256];
			CString strHelpText;

			CMainFrame* pMainFrame = (CMainFrame *)theApp.m_pMainWnd;
			ASSERT( pMainFrame != NULL );

			::LoadString( m_hInstance, nControlID, szFullText, sizeof(szFullText) / sizeof(TCHAR) );
			AfxExtractSubString( strHelpText, szFullText, 0, '\n' );
			pMainFrame->m_wndStatusBar.SetWindowText( strHelpText );
		}

		return TRUE;
	}

	return FALSE;
}


BEGIN_MESSAGE_MAP(CClientToolBar, CToolBar)
	//{{AFX_MSG_MAP(CClientToolBar)
	ON_WM_ERASEBKGND()
	ON_WM_WINDOWPOSCHANGED()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// CClientToolBar message handlers

CSize CClientToolBar::CalcDynamicLayout(int nLength, DWORD dwMode)
{
	// Hack to make the Output status toolbar resize work
	// BEGIN CHANGED MFC CODE
	if( nLength == -1 && dwMode == 0x06 )
	{
		dwMode |= LM_COMMIT;
	}
	// END CHANGED MFC CODE

	if ((nLength == -1) && !(dwMode & LM_MRUWIDTH) && !(dwMode & LM_COMMIT) &&
		((dwMode & LM_HORZDOCK) || (dwMode & LM_VERTDOCK)))
	{
		return CalcFixedLayout(dwMode & LM_STRETCH, dwMode & LM_HORZDOCK);
	}
	return CalcLayout(dwMode, nLength);
}

CSize CClientToolBar::CalcFixedLayout(BOOL bStretch, BOOL bHorz)
{
	DWORD dwMode = bStretch ? LM_STRETCH : 0;
	dwMode |= bHorz ? LM_HORZ : 0;

	return CalcLayout(dwMode);
}

#define CX_OVERLAP  0

CSize CClientToolBar::CalcSize(TBBUTTON* pData, int nCount)
{
	ASSERT(pData != NULL && nCount > 0);

	CPoint cur(0,0);
	CSize sizeResult(0,0);

	DWORD dwExtendedStyle = DefWindowProc(TB_GETEXTENDEDSTYLE, 0, 0);

	for (int i = 0; i < nCount; i++)
	{
		//WINBUG: The IE4 version of COMCTL32.DLL calculates the separation
		//  on a TBSTYLE_WRAP button as 100% of the value in iBitmap compared
		//  to the other versions which calculate it at 2/3 of that value.
		//  This is actually a bug which should be fixed in IE 4.01, so we
		//  only do the 100% calculation specifically for IE4.
		int cySep = pData[i].iBitmap;
		ASSERT(_afxComCtlVersion != -1);
		if (!(GetStyle() & TBSTYLE_FLAT) && _afxComCtlVersion != VERSION_IE4)
			cySep = cySep * 2 / 3;

		if (pData[i].fsState & TBSTATE_HIDDEN)
			continue;

		int cx = m_sizeButton.cx;
		if (pData[i].fsStyle & TBSTYLE_SEP)
		{
			// a separator represents either a height or width
			if (pData[i].fsState & TBSTATE_WRAP)
				sizeResult.cy = max(cur.y + m_sizeButton.cy + cySep, sizeResult.cy);
			else
			{
				sizeResult.cx = max(cur.x + pData[i].iBitmap, sizeResult.cx);
				// BEGIN CHANGED MFC CODE
				// a separator that has a command ID is not
				// a separator, but a custom control.
				// So, ensure it also updates the current height
				if( pData[i].idCommand != 0 )
				{
					sizeResult.cy = max(cur.y + m_sizeButton.cy, sizeResult.cy);
				}
				// END CHANGED MFC CODE
			}
		}
		else
		{
			// check for dropdown style, but only if the buttons are being drawn
			if ((pData[i].fsStyle & TBSTYLE_DROPDOWN) &&
				(dwExtendedStyle & TBSTYLE_EX_DRAWDDARROWS))
			{
				// add size of drop down
				ASSERT(_afxDropDownWidth != -1);
				cx += _afxDropDownWidth;
			}
			/*
			// BEGIN CHANGED MFC CODE
			else
			{
				TBBUTTONINFO tbButtonInfo;
				tbButtonInfo.cbSize = sizeof(TBBUTTONINFO);
				tbButtonInfo.dwMask = TBIF_SIZE;
				if( DefWindowProc( TB_GETBUTTONINFO, (WPARAM)(INT)pData[i].idCommand, (LPARAM)(LPTBBUTTONINFO)&tbButtonInfo ) != -1 )
				{
					cx = max( cx, tbButtonInfo.cx );
				}
			}
			// END CHANGED MFC CODE
			*/
			sizeResult.cx = max(cur.x + cx, sizeResult.cx);
			sizeResult.cy = max(cur.y + m_sizeButton.cy, sizeResult.cy);
		}

		if (pData[i].fsStyle & TBSTYLE_SEP)
			cur.x += pData[i].iBitmap;
		else
			cur.x += cx - CX_OVERLAP;

		if (pData[i].fsState & TBSTATE_WRAP)
		{
			cur.x = 0;
			cur.y += m_sizeButton.cy;
			if (pData[i].fsStyle & TBSTYLE_SEP)
				cur.y += cySep;
		}
	}
	return sizeResult;
}

int CClientToolBar::WrapToolBar(TBBUTTON* pData, int nCount, int nWidth)
{
	ASSERT(pData != NULL && nCount > 0);

	int nResult = 0;
	int x = 0;
	for (int i = 0; i < nCount; i++)
	{
		pData[i].fsState &= ~TBSTATE_WRAP;

		if (pData[i].fsState & TBSTATE_HIDDEN)
			continue;

		int dx, dxNext;
		if (pData[i].fsStyle & TBSTYLE_SEP)
		{
			dx = pData[i].iBitmap;
			dxNext = dx;
		}
		else
		{
			dx = m_sizeButton.cx;
			dxNext = dx - CX_OVERLAP;
		}

		if (x + dx > nWidth)
		{
			BOOL bFound = FALSE;
			for (int j = i; j >= 0  &&  !(pData[j].fsState & TBSTATE_WRAP); j--)
			{
				// Find last separator that isn't hidden
				// a separator that has a command ID is not
				// a separator, but a custom control.
				if ((pData[j].fsStyle & TBSTYLE_SEP) &&
					(pData[j].idCommand == 0) &&
					!(pData[j].fsState & TBSTATE_HIDDEN))
				{
					bFound = TRUE; i = j; x = 0;
					pData[j].fsState |= TBSTATE_WRAP;
					nResult++;
					break;
				}
			}
			if (!bFound)
			{
				for (int j = i - 1; j >= 0 && !(pData[j].fsState & TBSTATE_WRAP); j--)
				{
					// Never wrap anything that is hidden,
					// or any custom controls
					if ((pData[j].fsState & TBSTATE_HIDDEN) ||
						((pData[j].fsStyle & TBSTYLE_SEP) &&
						(pData[j].idCommand != 0)))
						continue;

					bFound = TRUE; i = j; x = 0;
					pData[j].fsState |= TBSTATE_WRAP;
					nResult++;
					break;
				}
				if (!bFound)
					x += dxNext;
			}
		}
		else
			x += dxNext;
	}
	return nResult + 1;
}

void  CClientToolBar::SizeToolBar(TBBUTTON* pData, int nCount, int nLength, BOOL bVert)
{
	ASSERT(pData != NULL && nCount > 0);

	if (!bVert)
	{
		int nMin, nMax, nTarget, nCurrent, nMid;

		// Wrap ToolBar as specified
		nMax = nLength;
		nTarget = WrapToolBar(pData, nCount, nMax);

		// Wrap ToolBar vertically
		nMin = 0;
		nCurrent = WrapToolBar(pData, nCount, nMin);

		if (nCurrent != nTarget)
		{
			while (nMin < nMax)
			{
				nMid = (nMin + nMax) / 2;
				nCurrent = WrapToolBar(pData, nCount, nMid);

				if (nCurrent == nTarget)
					nMax = nMid;
				else
				{
					if (nMin == nMid)
					{
						WrapToolBar(pData, nCount, nMax);
						break;
					}
					nMin = nMid;
				}
			}
		}
		CSize size = CalcSize(pData, nCount);
		WrapToolBar(pData, nCount, size.cx);
	}
	else
	{
		CSize sizeMax, sizeMin, sizeMid;

		// Wrap ToolBar vertically
		WrapToolBar(pData, nCount, 0);
		sizeMin = CalcSize(pData, nCount);

		// Wrap ToolBar horizontally
		WrapToolBar(pData, nCount, 32767);
		sizeMax = CalcSize(pData, nCount);

		while (sizeMin.cx < sizeMax.cx)
		{
			sizeMid.cx = (sizeMin.cx + sizeMax.cx) / 2;
			WrapToolBar(pData, nCount, sizeMid.cx);
			sizeMid = CalcSize(pData, nCount);

			if (nLength < sizeMid.cy)
			{
				if (sizeMin == sizeMid)
				{
					WrapToolBar(pData, nCount, sizeMax.cx);
					return;
				}
				sizeMin = sizeMid;
			}
			else if (nLength > sizeMid.cy)
			{
				if (sizeMax == sizeMid)
				{
					WrapToolBar(pData, nCount, sizeMin.cx);
					return;
				}
				sizeMax = sizeMid;
			}
			else
				return;
		}
	}
}

struct _AFX_CONTROLPOS
{
	int nIndex, nID;
	CRect rectOldPos;
};

CSize CClientToolBar::CalcLayout(DWORD dwMode, int nLength)
{
	ASSERT_VALID(this);
	ASSERT(::IsWindow(m_hWnd));
	if (dwMode & LM_HORZDOCK)
		ASSERT(dwMode & LM_HORZ);

	int nCount;
	TBBUTTON* pData = NULL;
	CSize sizeResult(0,0);

	//BLOCK: Load Buttons
	{
		nCount = DefWindowProc(TB_BUTTONCOUNT, 0, 0);
		if (nCount != 0)
		{
			int i;
			pData = new TBBUTTON[nCount];
			for (i = 0; i < nCount; i++)
				_GetButton(i, &pData[i]);
		}
	}

	if (nCount > 0)
	{
		if (!(m_dwStyle & CBRS_SIZE_FIXED))
		{
			BOOL bDynamic = m_dwStyle & CBRS_SIZE_DYNAMIC;

			if (bDynamic && (dwMode & LM_MRUWIDTH))
				SizeToolBar(pData, nCount, m_nMRUWidth);
			else if (bDynamic && (dwMode & LM_HORZDOCK))
				SizeToolBar(pData, nCount, 32767);
			else if (bDynamic && (dwMode & LM_VERTDOCK))
				SizeToolBar(pData, nCount, 0);
			else if (bDynamic && (nLength != -1))
			{
				CRect rect; rect.SetRectEmpty();
				CalcInsideRect(rect, (dwMode & LM_HORZ));
				BOOL bVert = (dwMode & LM_LENGTHY);
				int nLen = nLength + (bVert ? rect.Height() : rect.Width());

				SizeToolBar(pData, nCount, nLen, bVert);
			}
			else if (bDynamic && (m_dwStyle & CBRS_FLOATING))
				SizeToolBar(pData, nCount, m_nMRUWidth);
			else
				SizeToolBar(pData, nCount, (dwMode & LM_HORZ) ? 32767 : 0);
		}

		sizeResult = CalcSize(pData, nCount);

		if (dwMode & LM_COMMIT)
		{
			_AFX_CONTROLPOS* pControl = NULL;
			int nControlCount = 0;
			BOOL bIsDelayed = m_bDelayedButtonLayout;
			m_bDelayedButtonLayout = FALSE;

			for (int i = 0; i < nCount; i++)
				if ((pData[i].fsStyle & TBSTYLE_SEP) && (pData[i].idCommand != 0))
					nControlCount++;

			if (nControlCount > 0)
			{
				pControl = new _AFX_CONTROLPOS[nControlCount];
				nControlCount = 0;

				for(int i = 0; i < nCount; i++)
				{
					if ((pData[i].fsStyle & TBSTYLE_SEP) && (pData[i].idCommand != 0))
					{
						pControl[nControlCount].nIndex = i;
						pControl[nControlCount].nID = pData[i].idCommand;

						CRect rect;
						GetItemRect(i, &rect);
						ClientToScreen(&rect);
						pControl[nControlCount].rectOldPos = rect;

						nControlCount++;
					}
				}
			}

			if ((m_dwStyle & CBRS_FLOATING) && (m_dwStyle & CBRS_SIZE_DYNAMIC))
				m_nMRUWidth = sizeResult.cx;
			for (i = 0; i < nCount; i++)
				_SetButton(i, &pData[i]);

			if (nControlCount > 0)
			{
				for (int i = 0; i < nControlCount; i++)
				{
					CWnd* pWnd = GetDlgItem(pControl[i].nID);
					if (pWnd != NULL)
					{
						CRect rect;
						pWnd->GetWindowRect(&rect);
						CPoint pt = rect.TopLeft() - pControl[i].rectOldPos.TopLeft();
						GetItemRect(pControl[i].nIndex, &rect);
						pt = rect.TopLeft() + pt;
						pWnd->SetWindowPos(NULL, pt.x, pt.y, 0, 0, SWP_NOACTIVATE | SWP_NOSIZE | SWP_NOZORDER);
					}
				}
				delete[] pControl;
			}
			m_bDelayedButtonLayout = bIsDelayed;
		}
		delete[] pData;
	}

	//BLOCK: Adjust Margins
	{
		CRect rect; rect.SetRectEmpty();
		CalcInsideRect(rect, (dwMode & LM_HORZ));
		sizeResult.cy -= rect.Height();
		sizeResult.cx -= rect.Width();

		CSize size = CControlBar::CalcFixedLayout((dwMode & LM_STRETCH), (dwMode & LM_HORZ));
		sizeResult.cx = max(sizeResult.cx, size.cx);
		sizeResult.cy = max(sizeResult.cy, size.cy);
	}
	return sizeResult;
}

void CClientToolBar::_GetButton(int nIndex, TBBUTTON* pButton)
{
	/* BEGIN CHANGED MFC CODE
	CToolBar* pBar = (CToolBar*)this;
	VERIFY(pBar->DefWindowProc(TB_GETBUTTON, nIndex, (LPARAM)pButton));
	*/
	VERIFY(DefWindowProc(TB_GETBUTTON, nIndex, (LPARAM)pButton));
	// END CHANGED MFC CODE
	pButton->fsState ^= TBSTATE_ENABLED;
}

void CClientToolBar::_SetButton(int nIndex, TBBUTTON* pButton)
{
	// get original button state
	TBBUTTON button;
	VERIFY(DefWindowProc(TB_GETBUTTON, nIndex, (LPARAM)&button));

	// prepare for old/new button comparsion
	button.bReserved[0] = 0;
	button.bReserved[1] = 0;
	// TBSTATE_ENABLED == TBBS_DISABLED so invert it
	pButton->fsState ^= TBSTATE_ENABLED;
	pButton->bReserved[0] = 0;
	pButton->bReserved[1] = 0;

	// nothing to do if they are the same
	if (memcmp(pButton, &button, sizeof(TBBUTTON)) != 0)
	{
		// don't redraw everything while setting the button
		DWORD dwStyle = GetStyle();
		ModifyStyle(WS_VISIBLE, 0);
		VERIFY(DefWindowProc(TB_DELETEBUTTON, nIndex, 0));

		// BEGIN CHANGED MFC CODE
		/* This causes drawing bugs for the edit controls in the toolbars
		// Force a recalc of the toolbar's layout to work around a comctl bug
		int iTextRows;
		iTextRows = (int)::SendMessage(m_hWnd, TB_GETTEXTROWS, 0, 0);
		::SendMessage(m_hWnd, WM_SETREDRAW, FALSE, 0);
		::SendMessage(m_hWnd, TB_SETMAXTEXTROWS, iTextRows+1, 0);
		::SendMessage(m_hWnd, TB_SETMAXTEXTROWS, iTextRows, 0);
		::SendMessage(m_hWnd, WM_SETREDRAW, TRUE, 0);
		*/
		// END CHANGED MFC CODE

		VERIFY(DefWindowProc(TB_INSERTBUTTON, nIndex, (LPARAM)pButton));
		ModifyStyle(0, dwStyle & WS_VISIBLE);

		// invalidate appropriate parts
		if (((pButton->fsStyle ^ button.fsStyle) & TBSTYLE_SEP) ||
			((pButton->fsStyle & TBSTYLE_SEP) && pButton->iBitmap != button.iBitmap))
		{
			// changing a separator
			Invalidate();
		}
		else
		{
			// invalidate just the button
			CRect rect;
			if (DefWindowProc(TB_GETITEMRECT, nIndex, (LPARAM)&rect))
				InvalidateRect(rect);
		}
	}
}

BOOL CClientToolBar::OnEraseBkgnd(CDC* pDC) 
{
	if (::IsWindow(m_hWnd)
	&&	m_sizeButton != m_sizeDefaultButton )
	{
		// set the sizes via TB_SETBITMAPSIZE and TB_SETBUTTONSIZE
		VERIFY(::SendMessage(m_hWnd, TB_SETBUTTONSIZE, 0, MAKELONG(m_sizeButton.cx, m_sizeButton.cy)));

		// Uncommenting this causes an infinite loop
		//Invalidate();   // just to be nice if called when toolbar is visible
	}
	
	return CToolBar::OnEraseBkgnd(pDC);
}

void CClientToolBar::OnWindowPosChanged(WINDOWPOS FAR* lpwndpos) 
{
	CToolBar::OnWindowPosChanged(lpwndpos);

	if( m_pIToolBar
	&&	(lpwndpos->flags & (SWP_SHOWWINDOW | SWP_HIDEWINDOW)) )
	{
		IDMUSProdToolBar8 *pToolBar8;
		if( SUCCEEDED( m_pIToolBar->QueryInterface( IID_IDMUSProdToolBar8, (void **)&pToolBar8 ) ) )
		{
			if( lpwndpos->flags & SWP_SHOWWINDOW )
			{
				pToolBar8->ShowToolBar( TRUE );
			}
			else // if ( lpwndpos->flags & SWP_HIDEWINDOW )
			{
				pToolBar8->ShowToolBar( FALSE );
			}
			pToolBar8->Release();
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\Framework\Abhs.cpp ===
// abhs.cpp
//
// Implements AllocBindHostService.
//
// Important: This .cpp file assumes a zero-initializing global "new" operator.
//
// doc MMCTL
//

#include "stdafx.h"
#include "HelpBindHost.h"


/* @func int | UNICODEToANSI |

        Converts a UNICODE string to ANSI.

@rdesc  Returns the same integer as WideCharToMultiByte.  0 means "failed."

@parm   LPSTR | pchDst | The buffer that will hold the output ANSI string.

@parm   LPCWSTR | pwchSrc | The input UNICODE string.  NULL is interpreted as
        a zero-length string.

@parm   int | cchDstMax | The size of <p pchDst>, in characters.  If <p pchDst>
		is declared as char pchDst[32], for example, <p cchDstMax> should be 32.
		If <p pchDst> isn't large enough to hold the ANSI string (including the
		terminating NULL), <p pchDst> is set to zero length and 0 is returned.
		(In debug versions, an assertion also occurs.)

@comm   If you want to determine the ANSI buffer size required for a given
		UNICODE string pwchSrc, you can call UNICODEToANSI(NULL, pwchSrc, 0).
		This returns the required buffer size in characters, including space
		for the terminating NULL.

@ex		Here is code (without debug checks) that dynamically allocates the ANSI
		buffer and converts the UNICODE string pwchSrc: |

			int cchDst;
			char *pchDst;
			cchDst = UNICODEToANSI(NULL, pwchSrc, 0);
			pchDst = new char [cchDst];
			UNICODEToANSI(pchDst, pwchSrc, cchDst)

*/
STDAPI_(int) UNICODEToANSI(LPSTR pchDst, LPCWSTR pwchSrc, int cchDstMax)
{
	// (We allow the caller to pass a cchDstMax value of 0 and a NULL pchDst to
	// indicate "tell me the buffer size I need, including the NULL.")

	ASSERT(pchDst != NULL || 0 == cchDstMax);
	ASSERT(cchDstMax >= 0);

	#ifdef _DEBUG

	// Make sure we won't exceed the length of the user-supplied buffer,
	// pchDst.  The following call returns the number of characters required to
	// store the converted string, including the terminating NULL.

    if(cchDstMax > 0)
	{
		int iChars;
	
		iChars =
		  	WideCharToMultiByte(CP_ACP, 0, pwchSrc ? pwchSrc : OLESTR(""),
							    -1, NULL, 0, NULL, NULL); 
		ASSERT(iChars <= cchDstMax);
	}

	#endif

	int iReturn;

	iReturn = WideCharToMultiByte(CP_ACP, 0, pwchSrc ? pwchSrc : OLESTR( "" ), 
								  -1, pchDst, cchDstMax, NULL, NULL); 

	if (0 == iReturn)
	{
		// The conversion failed.  Return an empty string.

		if (pchDst != NULL)
			pchDst[0] = 0;

		ASSERT(FALSE);
	}

	return (iReturn);
}

/* @func int | ANSIToUNICODE |

        Converts an ANSI string to UNICODE.

@parm   LPWSTR | pwchDst | The buffer that will hold the output UNICODE string.

@parm   LPCSTR | pchSrc | The input ANSI string.

@parm   int | cwchDstMax | The size of <p pwchDst>, in wide characters.  If
		pwchDst is declared as OLECHAR pwchDst[32], for example, cwchDstMax
		should be 32.

*/
STDAPI_(int) ANSIToUNICODE(LPWSTR pwchDst, LPCSTR pchSrc, int cwchDstMax)
{

	ASSERT( pwchDst );
	ASSERT( pchSrc );

    return MultiByteToWideChar(CP_ACP, 0, pchSrc, -1, pwchDst, cwchDstMax);
}


//////////////////////////////////////////////////////////////////////////////
// CBindHostServiceCallback
//
// Implements IBindStatusCallback.
//

struct CBindHostServiceCallback : IBindStatusCallback
{
///// general object state
    ULONG           m_cRef;         // object reference count
    IBindCtx *      m_pbc;          // context that this object is registered in
    IBindStatusCallback* m_pbsc;    // client-provided IBindStatusCallback
    IBinding *      m_pb;           // provided in OnStartBinding()

///// construction and destruction
    CBindHostServiceCallback(IBindStatusCallback *pbsc);
    ~CBindHostServiceCallback();
    void AttachBindCtx(IBindCtx *pbc);

///// IUnknown methods
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppvObj);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

///// IBindStatusCallback methods
    STDMETHODIMP OnStartBinding(DWORD dwReserved, IBinding *pib);
    STDMETHODIMP GetPriority(LONG *pnPriority);
    STDMETHODIMP OnLowResource(DWORD reserved);
    STDMETHODIMP OnProgress(ULONG ulProgress, ULONG ulProgressMax,
        ULONG ulStatusCode, LPCWSTR szStatusText);
    STDMETHODIMP OnStopBinding(HRESULT hresult, LPCWSTR szError);
    STDMETHODIMP GetBindInfo(DWORD *grfBINDF, BINDINFO *pbindinfo);
    STDMETHODIMP OnDataAvailable(DWORD grfBSCF, DWORD dwSize,
        FORMATETC *pformatetc, STGMEDIUM *pstgmed);
    STDMETHODIMP OnObjectAvailable(REFIID riid, IUnknown *punk);
};


/////////////////////////////////////////////////////////////////////////////
// CBindHostServiceCallback Creation & Destruction
//

CBindHostServiceCallback::CBindHostServiceCallback(IBindStatusCallback *pbsc) :
	m_pb(NULL),
	m_pbc(NULL)
{
    TRACE("BindHostService 0x%08lx created\n", this);

    // initialize IUnknown
    m_cRef = 1;

    // other initialization
    m_pbsc = pbsc;
    if (m_pbsc != NULL)
        m_pbsc->AddRef();
}

CBindHostServiceCallback::~CBindHostServiceCallback()
{
    TRACE("BindHostService 0x%08lx destroyed\n", this);

    // cleanup
    if (m_pb != NULL)
        m_pb->Release();
    if (m_pbc != NULL)
        m_pbc->Release();
    if (m_pbsc != NULL)
        m_pbsc->Release();
}

void CBindHostServiceCallback::AttachBindCtx(IBindCtx *pbc)
{
	AFX_MANAGE_STATE( AfxGetAppModuleState() );

    m_pbc = pbc;
    if (m_pbc != NULL)
        m_pbc->AddRef();
}


//////////////////////////////////////////////////////////////////////////////
// CBindHostServiceCallback IUnknown Implementation
//

STDMETHODIMP CBindHostServiceCallback::QueryInterface(REFIID riid, LPVOID *ppv)
{
	AFX_MANAGE_STATE( AfxGetAppModuleState() );

    *ppv = NULL;

#ifdef _DEBUG
//    char ach[200];
//    TRACE("BindHostServiceCallback::QI('%s')\n", DebugIIDName(riid, ach));
#endif

    if (IsEqualIID(riid, IID_IUnknown) ||
        IsEqualIID(riid, IID_IBindStatusCallback))
        *ppv = (IBindStatusCallback *) this;
    else
        return E_NOINTERFACE;

    ((IUnknown *) *ppv)->AddRef();
    return S_OK;
}

STDMETHODIMP_(ULONG) CBindHostServiceCallback::AddRef()
{
	AFX_MANAGE_STATE( AfxGetAppModuleState() );

    return ++m_cRef;
}

STDMETHODIMP_(ULONG) CBindHostServiceCallback::Release()
{
	AFX_MANAGE_STATE( AfxGetAppModuleState() );

    if (--m_cRef == 0L)
    {
        // free the object
        delete this;
        return 0;
    }
    else
        return m_cRef;
}


/////////////////////////////////////////////////////////////////////////////
// CBindHostServiceCallback IBindStatusCallback Methods
//

STDMETHODIMP CBindHostServiceCallback::OnStartBinding(DWORD dwReserved,
    IBinding *pb)
{
	AFX_MANAGE_STATE( AfxGetAppModuleState() );

    TRACE("BindHostService: IBindStatusCallback::OnStartBinding\n");

    // cache caller-provided IBinding
    if (m_pb != NULL)
        m_pb->Release();
    m_pb = pb;
    if (m_pb != NULL)
        m_pb->AddRef();

    if (m_pbsc != NULL)
        return m_pbsc->OnStartBinding(dwReserved, pb);
    else
        return S_OK;
}

STDMETHODIMP CBindHostServiceCallback::GetPriority(LONG *pnPriority)
{
	AFX_MANAGE_STATE( AfxGetAppModuleState() );

    TRACE("BindHostService: IBindStatusCallback::GetPriority\n");

    if (m_pbsc != NULL)
        return m_pbsc->GetPriority(pnPriority);
    else
        return E_FAIL;
}

STDMETHODIMP CBindHostServiceCallback::OnLowResource(DWORD reserved)
{
	AFX_MANAGE_STATE( AfxGetAppModuleState() );

    TRACE("BindHostService: IBindStatusCallback::OnLowResource\n");

    if (m_pbsc != NULL)
        return m_pbsc->OnLowResource(reserved);
    else
        return E_FAIL;
}

STDMETHODIMP CBindHostServiceCallback::OnProgress(ULONG ulProgress,
    ULONG ulProgressMax, ULONG ulStatusCode, LPCWSTR szStatusText)
{
	AFX_MANAGE_STATE( AfxGetAppModuleState() );

    TRACE("BindHostService: IBindStatusCallback::OnProgress(%u/%u, %d)\n",
        ulProgress, ulProgressMax, ulStatusCode);

#ifdef _DEBUG
    if (szStatusText != NULL)
    {
		int nLen = UNICODEToANSI(NULL, szStatusText, 0);
        char *ach = new char[nLen];
		if (NULL != ach)
		{
			UNICODEToANSI(ach, szStatusText, nLen);
			TRACE("...'%s'\n", ach);
			delete [] ach;
		}
    }
#endif

    if (m_pbsc != NULL)
        return m_pbsc->OnProgress(ulProgress, ulProgressMax, ulStatusCode,
            szStatusText);
    else
        return S_OK;
}

STDMETHODIMP CBindHostServiceCallback::OnStopBinding(HRESULT hresult,
    LPCWSTR szError)
{
	AFX_MANAGE_STATE( AfxGetAppModuleState() );

    TRACE("BindHostService: IBindStatusCallback::OnStopBinding\n");

    // free caller-provided IBinding
    if (m_pb != NULL)
        m_pb->Release();
    m_pb = NULL;

#ifdef _DEBUG
    if (szError != NULL)
    {
		int nLen = UNICODEToANSI(NULL, szError, 0);
        char *ach = new char[nLen];
		if (NULL != ach)
		{
			UNICODEToANSI(ach, szError, nLen);
			TRACE("...'%s'\n", ach);
			delete [] ach;
		}
    }
#endif

    // forward OnStopBinding(), but ignore return code
    if (m_pbsc != NULL)
    	m_pbsc->OnStopBinding(hresult, szError);

    // revoke ourselves from the IBindCtx we're registered in
    if (m_pbc != NULL)
    {
        TRACE("BindHostService: RevokeBindStatusCallback\n");
        HelpRevokeBindStatusCallback(m_pbc, this);
    }

    // don't use local variables anymore -- <this> may have been
    // deleted by RevokeBindStatusCallback() above
    return 0;
}

STDMETHODIMP CBindHostServiceCallback::GetBindInfo(DWORD *grfBINDF,
    BINDINFO *pbindinfo)
{
	AFX_MANAGE_STATE( AfxGetAppModuleState() );

    TRACE("BindHostService: IBindStatusCallback::GetBindInfo\n");

    if (m_pbsc != NULL)
        return m_pbsc->GetBindInfo(grfBINDF, pbindinfo);

    memset(pbindinfo, 0, pbindinfo->cbSize);
	pbindinfo->cbSize = sizeof(BINDINFO);
    *grfBINDF = BINDF_ASYNCHRONOUS;
    return S_OK;
}

STDMETHODIMP CBindHostServiceCallback::OnDataAvailable(DWORD grfBSCF,
    DWORD dwSize, FORMATETC *pformatetc, STGMEDIUM *pstgmed)
{
	AFX_MANAGE_STATE( AfxGetAppModuleState() );

    TRACE("BindHostService: IBindStatusCallback::OnDataAvailable (dwSize=%d)\n",
        dwSize);

    if (m_pbsc != NULL)
        return m_pbsc->OnDataAvailable(grfBSCF, dwSize, pformatetc, pstgmed);
    else
        return S_OK;
}

STDMETHODIMP CBindHostServiceCallback::OnObjectAvailable(REFIID riid,
    IUnknown *punk)
{
	AFX_MANAGE_STATE( AfxGetAppModuleState() );

    TRACE("BindHostService: IBindStatusCallback::OnObjectAvailable\n");

    if (m_pbsc != NULL)
        return m_pbsc->OnObjectAvailable(riid, punk);
    else
        return S_OK;
}



//////////////////////////////////////////////////////////////////////////////
// CBindHostService
//
// Implements IServiceProvider, which provides an implementation of IBindHost
// to the embedded control.
//

struct CBindHostService : IServiceProvider, IBindHost
{
///// general object state
    ULONG           m_cRef;         // object reference count
    OLECHAR         m_aochContainerFileName[_MAX_PATH]; // files rel. to this

///// construction and destruction
    CBindHostService(LPCTSTR szContainerFileName, HRESULT *phr);

///// IUnknown methods
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppvObj);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

///// IServiceProvider implementation
    STDMETHODIMP QueryService(REFGUID rsid, REFIID iid, void **ppvObj);

///// IBindHost methods
    STDMETHODIMP CreateMoniker(LPOLESTR szName, IBindCtx *pbc, IMoniker **ppmk,
         DWORD dwReserved);
    STDMETHODIMP MonikerBindToStorage(IMoniker *pmk, IBindCtx *pbc,
        IBindStatusCallback *pbsc, REFIID riid, void **ppvObj);
    STDMETHODIMP MonikerBindToObject(IMoniker *pmk, IBindCtx *pbc,
        IBindStatusCallback *pbsc, REFIID riid, void **ppvObj);
};


/////////////////////////////////////////////////////////////////////////////
// BindHostService Creation & Destruction
//

/* @func HRESULT | AllocBindHostService |

        Allocates an implementation of <i IServiceProvider> which provides
        the <i IBindHost> service (SID_IBindHost, IID_IBindHost), which
        provides for relative path name resolution when using functions
        such as <f URLOpenStream>.

@parm   LPCTSTR | szContainerFileName | The name of the file that
        relative path names will be relative to.  For example, if
        <p szContainerFileName> is "c:\\foo\\bar.htm" and the caller
        calls <f URLOpenStream> to open "blorg.gif", then the file
        "file://c:\\foo\\blorg.gif" will be opened (assuming that
        the <i IUnknown *> parameter of <f URLOpenStream> implements
        <i IServiceProvider> which delegates to *<p ppsp>).  If
        <p szContainerFileName> is NULL or "", then file names
        are assumed to be relative to the current directory.
        <p szContainerFileName> should be under _MAX_PATH characters
        in length.

@parm   IServiceProvider * * | ppsp | Where to store a pointer to the
        newly created object.  NULL is stored in *<p ppsp> on error.

@comm   Whenver the container's file name changes, the old <i IBindHost>
        servie provider should be freed and <f AllocBindHostService> should be
        called again to create a new <i IBindHost> service provider.
*/
STDAPI AllocBindHostService(LPCTSTR szContainerFileName,
    IServiceProvider **ppsp)
{
	AFX_MANAGE_STATE( AfxGetAppModuleState() );

    HRESULT hr;
    // create the Windows object
    if ((*ppsp = (IServiceProvider *)
            new CBindHostService(szContainerFileName, &hr)) == NULL)
        return E_OUTOFMEMORY;
    if (FAILED(hr))
        (*ppsp)->Release();

    return hr;
}

CBindHostService::CBindHostService(LPCTSTR szContainerFileName, HRESULT *phr)
{
	AFX_MANAGE_STATE( AfxGetAppModuleState() );

    // initialize IUnknown
    m_cRef = 1;

    // set <m_aochContainerFileName> to be the path to the currently-loaded
    // file (e.g. HTML file); if there is no HTML file loaded, then set
    // <m_aochContainerFileName> to the name of a hypothetical document "x"
    // in the current directory (so that files opened by e.g. URLOpenStream
    // will be relative to the current directory)
    if ((szContainerFileName == NULL) || (szContainerFileName[0] == 0))
    {
        // no file is loaded, so we'll act as though this file
        // (e.g. the HTML file) is saved in the current directory...

        // make <ach> contain the name of a hypothetical file "x"
        // within the current directory
        char ach[MAX_PATH];
        if (GetCurrentDirectory(sizeof(ach) - 1, ach) == 0)
            goto ERR_FAIL;
        if (ach[0] == 0)
            goto ERR_FAIL;
        char *pch = ach + lstrlen(ach);
        if ((pch[-1] != '\\') && (pch[-1] != ':'))
            lstrcat(ach, "\\x");

        // convert file path to Unicode, in <aochContainerFileName>
        ANSIToUNICODE(m_aochContainerFileName, ach,
            sizeof(m_aochContainerFileName) / 
                sizeof(*m_aochContainerFileName));
    }
    else
    {
        // convert <ach> to a fully qualified path
        OFSTRUCT of;
        if (OpenFile(szContainerFileName, &of, OF_PARSE) == HFILE_ERROR)
            goto ERR_FAIL;

        // convert file path to Unicode, in <aochContainerFileName>
        ANSIToUNICODE(m_aochContainerFileName, of.szPathName,
            sizeof(m_aochContainerFileName) /
                sizeof(*m_aochContainerFileName));
    }

    goto EXIT;

EXIT:

    *phr = S_OK;
    return;

ERR_FAIL:

    *phr = E_FAIL;
    return;
}


//////////////////////////////////////////////////////////////////////////////
// BindHostService IUnknown Implementation
//

STDMETHODIMP CBindHostService::QueryInterface(REFIID riid, LPVOID *ppv)
{
	AFX_MANAGE_STATE( AfxGetAppModuleState() );

    *ppv = NULL;

#ifdef _DEBUG
//    char ach[200];
//    TRACE("BindHostService::QI('%s')\n", DebugIIDName(riid, ach));
#endif

    if (IsEqualIID(riid, IID_IUnknown) ||
        IsEqualIID(riid, IID_IServiceProvider))
        *ppv = (IServiceProvider *) this;
    else
    if (IsEqualIID(riid, IID_IBindHost))
        *ppv = (IBindHost *) this;
    else
        return E_NOINTERFACE;

    ((IUnknown *) *ppv)->AddRef();
    return S_OK;
}

STDMETHODIMP_(ULONG) CBindHostService::AddRef()
{
	AFX_MANAGE_STATE( AfxGetAppModuleState() );

    return ++m_cRef;
}

STDMETHODIMP_(ULONG) CBindHostService::Release()
{
	AFX_MANAGE_STATE( AfxGetAppModuleState() );

    if (--m_cRef == 0L)
    {
        // free the object
        delete this;
        return 0;
    }
    else
        return m_cRef;
}


/////////////////////////////////////////////////////////////////////////////
// BindHostService IServiceProvider Implementation
//

STDMETHODIMP CBindHostService::QueryService(REFGUID rsid, REFIID riid,
    void **ppvObj)
{
	AFX_MANAGE_STATE( AfxGetAppModuleState() );

#if 1
    if (!IsEqualGUID(rsid, SID_IBindHost))
        return E_FAIL; // should be SVC_E_UNKNOWNSERVICE, which I can't find

    return QueryInterface(riid, ppvObj);
#else
    return E_FAIL;
#endif
}


/////////////////////////////////////////////////////////////////////////////
// BindHostService IBindHost Implementation
//

STDMETHODIMP CBindHostService::CreateMoniker(LPOLESTR szName, IBindCtx *pbc,
    IMoniker **ppmk, DWORD dwReserved)
{
	AFX_MANAGE_STATE( AfxGetAppModuleState() );

    HRESULT         hrReturn = S_OK; // function return code
    CBindHostServiceCallback *pbscTmp = NULL; // for CreateAsyncBindCtx()
    IBindCtx *      pbcTmp = NULL;  // temporary bind context
    IMoniker *      pmkLeft = NULL; // left part of new moniker
    IMoniker *      pmkRight = NULL; // right part of new moniker
    ULONG           ul;

	#ifdef _DEBUG
	{
		int nLen = UNICODEToANSI(NULL, szName, 0);
        char *ach = new char[nLen];
		if (NULL != ach)
		{
			UNICODEToANSI(ach, szName, nLen);
			TRACE("BindHostService: IBindHost::CreateMoniker('%s')\n", ach);
			delete [] ach;
		}
	}
	#endif

    // ensure correct cleanup
    *ppmk = NULL;

    // if <pbc> is NULL, make it be a valid temporary IBindCtx
    if (pbc == NULL)
    {
        if ((pbscTmp = new CBindHostServiceCallback(NULL)) == NULL)
            goto ERR_OUTOFMEMORY;
        if (FAILED(hrReturn = HelpCreateAsyncBindCtx(0, pbscTmp, 0, &pbcTmp)))
            goto ERR_EXIT;
        pbc = pbcTmp;
    }

    // make <pmkLeft> refer to <m_aochContainerFileName>
    if (FAILED(hrReturn = HelpMkParseDisplayNameEx(pbc, m_aochContainerFileName,
            &ul, &pmkLeft)))
        goto ERR_EXIT;

#if 0
    if (FAILED(hrReturn = pbc->RegisterObjectParam(SZ_URLCONTEXT, pmkLeft)))
        goto ERR_EXIT;
#endif
#if 0

    // make <pmkRight> refer to <szName>
    if (FAILED(hrReturn = HelpMkParseDisplayNameEx(pbc, szName, &ul,
            &pmkRight)))
        goto ERR_EXIT;

    // make <*ppmk> refer to <pmkRight> relative to the directory
    // containing <pmkLeft>
    if (FAILED(hrReturn = pmkLeft->ComposeWith(pmkRight, FALSE, ppmk)))
        goto ERR_EXIT;

#else

    // make <*ppmk> refer to <pmkRight> relative to the directory
    // containing <pmkLeft>
    if (FAILED(hrReturn = HelpCreateURLMoniker(pmkLeft, szName, ppmk)))
        goto ERR_EXIT;

#endif

#ifdef _DEBUG
    // display information about <*ppmk>
    {
        LPOLESTR osz;
        if (SUCCEEDED((*ppmk)->GetDisplayName(pbc, NULL, &osz)))
        {
			int nLen = UNICODEToANSI(NULL, osz, 0);
			char *ach = new char[nLen];
			if (NULL != ach)
			{
				UNICODEToANSI(ach, osz, nLen);
	            TRACE("...display name: '%s'\n", ach);
				delete [] ach;
			}

            CoTaskMemFree(osz);
        }
    }
#endif

    goto EXIT;

ERR_OUTOFMEMORY:

    hrReturn = E_OUTOFMEMORY;
    goto ERR_EXIT;

ERR_EXIT:

    // error cleanup
    if (*ppmk != NULL)
    {
        (*ppmk)->Release();
        *ppmk = NULL;
    }
    goto EXIT;

EXIT:

    // normal cleanup
    if (pmkLeft != NULL)
        pmkLeft->Release();
    if (pmkRight != NULL)
        pmkRight->Release();
    if (pbcTmp != NULL)
        pbcTmp->Release();
    if (pbscTmp != NULL)
        pbscTmp->Release();

    return hrReturn;
}

STDMETHODIMP CBindHostService::MonikerBindToStorage(IMoniker *pmk,
    IBindCtx *pbc, IBindStatusCallback *pbsc, REFIID riid, void **ppvObj)
{
	AFX_MANAGE_STATE( AfxGetAppModuleState() );

    HRESULT         hrReturn = S_OK; // function return code
    CBindHostServiceCallback *pbscTmp = NULL; // for CreateAsyncBindCtx()
    IBindCtx *      pbcTmp = NULL;  // temporary bind context

    TRACE("BindHostService: IBindHost::MonikerBindToStorage\n");

    // create an IBindStatusCallback to monitor the binding operation;
    // delegate to the caller-provided <pbsc>
    if ((pbscTmp = new CBindHostServiceCallback(pbsc)) == NULL)
        goto ERR_OUTOFMEMORY;

    // if <pbc> is NULL, make it be a valid temporary IBindCtx;
    // in any case, register <pbscTmp> with the IBindCtx
    if (pbc == NULL)
    {
        if (FAILED(hrReturn = HelpCreateAsyncBindCtx(0, pbscTmp, 0, &pbcTmp)))
            goto ERR_EXIT;
        pbc = pbcTmp;
    }
    else
    {
        if (FAILED(hrReturn = HelpRegisterBindStatusCallback(pbc, pbscTmp,
                /*BSCO_ALLONIBSC*/0, 0)))
            goto ERR_EXIT;
    }

    // tell <pbscTmp> that it's registered in <pbc>; <pbscTmp> will call
    // RevokeBindStatusCallback() in its OnStopBinding()
    pbscTmp->AttachBindCtx(pbc);

#ifdef _DEBUG
    // display information about <pmk>
    {
        LPOLESTR osz;
        if (SUCCEEDED(pmk->GetDisplayName(pbc, NULL, &osz)))
        {
			int nLen = UNICODEToANSI(NULL, osz, 0);
			char *ach = new char[nLen];
			if (NULL != ach)
			{
				UNICODEToANSI(ach, osz, nLen);
	            TRACE("...display name: '%s'\n", ach);
				delete [] ach;
			}

            CoTaskMemFree(osz);
        }
    }
#endif

    // bind to the caller-requested type of storage
    if (FAILED(hrReturn = pmk->BindToStorage(pbc, NULL, riid, ppvObj)))
        goto ERR_EXIT;

    goto EXIT;

ERR_OUTOFMEMORY:

    hrReturn = E_OUTOFMEMORY;
    goto ERR_EXIT;

ERR_EXIT:

    // error cleanup
    // (nothing to do)
    goto EXIT;

EXIT:

    // normal cleanup
    if (pbcTmp != NULL)
        pbcTmp->Release();
    if (pbscTmp != NULL)
        pbscTmp->Release();

    return hrReturn;
}

STDMETHODIMP CBindHostService::MonikerBindToObject(IMoniker *pmk,
    IBindCtx *pbc, IBindStatusCallback *pbsc, REFIID riid, void **ppvObj)
{
	AFX_MANAGE_STATE( AfxGetAppModuleState() );

    TRACE("BindHostService: IBindHost::MonikerBindToObject: E_NOTIMPL"
        " --> this will case URL file access to fail!\n");
    return E_NOTIMPL;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\Framework\ClientToolBar.h ===
#if !defined(AFX_CLIENTTOOLBAR_H__04E207C2_C636_11D0_89AE_00A0C9054129__INCLUDED_)
#define AFX_CLIENTTOOLBAR_H__04E207C2_C636_11D0_89AE_00A0C9054129__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// ClientToolBar.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CClientToolBar window

class CClientToolBar : public CToolBar
{
// Construction
public:
	CClientToolBar( IDMUSProdToolBar* pIToolBar );

// Attributes
public:
	HINSTANCE			m_hInstance;
	IDMUSProdToolBar*	m_pIToolBar;

// Operations
public:

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CClientToolBar)
	//}}AFX_VIRTUAL
	virtual BOOL SetStatusText(int nHit);
    virtual int OnToolHitTest(CPoint point, TOOLINFO* pTI) const;
    virtual void OnUpdateCmdUI(CFrameWnd* pTarget, BOOL bDisableIfNoHndler);
	virtual CSize CalcFixedLayout(BOOL bStretch, BOOL bHorz);
	virtual CSize CalcDynamicLayout(int nLength, DWORD nMode);

protected:
	CSize CalcLayout(DWORD nMode, int nLength = -1);
	CSize CalcSize(TBBUTTON* pData, int nCount);
	int WrapToolBar(TBBUTTON* pData, int nCount, int nWidth);
	void SizeToolBar(TBBUTTON* pData, int nCount, int nLength, BOOL bVert = FALSE);
	void _SetButton(int nIndex, TBBUTTON* pButton);
	void _GetButton(int nIndex, TBBUTTON* pButton);

	CSize m_sizeDefaultButton; // default button size

// Implementation
public:
	virtual ~CClientToolBar();


	// Generated message map functions
protected:
	//{{AFX_MSG(CClientToolBar)
	afx_msg BOOL OnEraseBkgnd(CDC* pDC);
	afx_msg void OnWindowPosChanged(WINDOWPOS FAR* lpwndpos);
	//}}AFX_MSG

	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_CLIENTTOOLBAR_H__04E207C2_C636_11D0_89AE_00A0C9054129__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\Framework\CloseProjectDlg.h ===
#if !defined(AFX_CLOSEPROJECTDLG_H__7F1702C3_28E7_11D3_B44B_00105A2796DE__INCLUDED_)
#define AFX_CLOSEPROJECTDLG_H__7F1702C3_28E7_11D3_B44B_00105A2796DE__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// CloseProjectDlg.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CCloseProjectDlg dialog

class CCloseProjectDlg : public CDialog
{
// Construction
public:
	CCloseProjectDlg(CWnd* pParent = NULL);   // standard constructor

// Dialog Data
	//{{AFX_DATA(CCloseProjectDlg)
	enum { IDD = IDD_CLOSE_PROJECT };
	CStatic	m_staticPrompt2;
	CStatic	m_staticPrompt1;
	CListBox	m_lstbxFiles;
	//}}AFX_DATA

public:
	CProject*	m_pProject;

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CCloseProjectDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CCloseProjectDlg)
	virtual BOOL OnInitDialog();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_CLOSEPROJECTDLG_H__7F1702C3_28E7_11D3_B44B_00105A2796DE__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\Framework\CntrItem.h ===
#if !defined(CNTRITEM_H__B6AED015_3BDF_11D0_89AC_00A0C9054129__INCLUDED_)
#define CNTRITEM_H__B6AED015_3BDF_11D0_89AC_00A0C9054129__INCLUDED_

// CntrItem.h : interface of the CJazzCntrItem class
//

class CJazzDoc;
class CJazzView;

class CJazzCntrItem : public COleClientItem
{
	DECLARE_SERIAL(CJazzCntrItem)

// Constructors
public:
	CJazzCntrItem(CJazzDoc* pContainer = NULL);
		// Note: pContainer is allowed to be NULL to enable IMPLEMENT_SERIALIZE.
		//  IMPLEMENT_SERIALIZE requires the class have a constructor with
		//  zero arguments.  Normally, OLE items are constructed with a
		//  non-NULL document pointer.

// Attributes
public:
	CJazzDoc* GetDocument()
		{ return (CJazzDoc*)COleClientItem::GetDocument(); }
	CJazzView* GetActiveView()
		{ return (CJazzView*)COleClientItem::GetActiveView(); }

	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CJazzCntrItem)
	public:
	virtual void OnChange(OLE_NOTIFICATION wNotification, DWORD dwParam);
	virtual void OnActivate();
	protected:
	virtual void OnGetItemPosition(CRect& rPosition);
	virtual void OnDeactivateUI(BOOL bUndoable);
	virtual BOOL OnChangeItemPosition(const CRect& rectPos);
	//}}AFX_VIRTUAL

// Implementation
public:
	~CJazzCntrItem();
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif
	virtual void Serialize(CArchive& ar);
};

/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(CNTRITEM_H__B6AED015_3BDF_11D0_89AC_00A0C9054129__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\Framework\CloseProjectDlg.cpp ===
// CloseProjectDlg.cpp : implementation file
//

#include "stdafx.h"
#include "JazzApp.h"
#include "CloseProjectDlg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CCloseProjectDlg dialog


CCloseProjectDlg::CCloseProjectDlg(CWnd* pParent /*=NULL*/)
	: CDialog(CCloseProjectDlg::IDD, pParent)
{
	//{{AFX_DATA_INIT(CCloseProjectDlg)
	//}}AFX_DATA_INIT

	m_pProject = NULL;
}


void CCloseProjectDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CCloseProjectDlg)
	DDX_Control(pDX, IDC_PROMPT2, m_staticPrompt2);
	DDX_Control(pDX, IDC_PROMPT1, m_staticPrompt1);
	DDX_Control(pDX, IDC_LISTBOX_FILES, m_lstbxFiles);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CCloseProjectDlg, CDialog)
	//{{AFX_MSG_MAP(CCloseProjectDlg)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CCloseProjectDlg message handlers

BOOL CCloseProjectDlg::OnInitDialog() 
{
	CDialog::OnInitDialog();

	ASSERT( m_pProject != NULL );	

	if( m_pProject )
	{
		// Set prompts
		CString strText;
		AfxFormatString1( strText, IDS_PROMPT1_CLOSE_PROJECT, m_pProject->m_strName );
		m_staticPrompt1.SetWindowText( strText );
		AfxFormatString1( strText, IDS_PROMPT2_CLOSE_PROJECT, m_pProject->m_strName );
		m_staticPrompt2.SetWindowText( strText );

		// Fill file listbox
		CFileNode* pFileNode;
		CFileNode* pTheFileNode;
		CJzNotifyNode* pJzNotifyNode;
		POSITION posNotifyList;
		CDC* pDC;
		CSize sizeText;
		int nCurExtent;
		BOOL fDisplayFile;

		POSITION pos = m_pProject->m_lstFiles.GetHeadPosition();
		while( pos )
		{
			pFileNode = m_pProject->m_lstFiles.GetNext( pos );

			fDisplayFile = FALSE;

			posNotifyList = pFileNode->m_lstNotifyNodes.GetHeadPosition();
			while( posNotifyList )
			{
				pJzNotifyNode = static_cast<CJzNotifyNode*>( pFileNode->m_lstNotifyNodes.GetNext(posNotifyList) );
				
				pTheFileNode = theApp.GetFileByGUID( pJzNotifyNode->m_guidFile );
				if( pTheFileNode )
				{
					if( pTheFileNode->m_pProject != m_pProject )
					{
						fDisplayFile = TRUE;
					}

					pTheFileNode->Release();

					if( fDisplayFile )
					{
						pFileNode->ConstructFileName( strText );
						m_lstbxFiles.AddString( strText );

						// Set horizontal extent
						nCurExtent = m_lstbxFiles.GetHorizontalExtent();
						pDC = m_lstbxFiles.GetDC();
						if( pDC )
						{
							sizeText = pDC->GetTextExtent( strText );

							if( sizeText.cx > nCurExtent )
							{
								m_lstbxFiles.SetHorizontalExtent( sizeText.cx );
							}
							m_lstbxFiles.ReleaseDC( pDC );
						}
						break;
					}
				}
			}
		}
	}

	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\Framework\CommonDoc.cpp ===
// CommonDoc.cpp : implementation file
//

#include "stdafx.h"
#include "JazzApp.h"
#include "SavePrompt.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CCommonDoc

IMPLEMENT_DYNCREATE(CCommonDoc, COleDocument)


/////////////////////////////////////////////////////////////////////////////
// CCommonDoc::CCommonDoc

CCommonDoc::CCommonDoc()
{
	m_pIDocRootNode = NULL;

	AfxOleLockApp();
}


/////////////////////////////////////////////////////////////////////////////
// CCommonDoc::~CCommonDoc

CCommonDoc::~CCommonDoc()
{
	if( m_pIDocRootNode )
	{
		IDMUSProdNode* pINode = NULL;

		HTREEITEM hItem = theApp.m_pFramework->FindTreeItem( m_pIDocRootNode );
		if( hItem )
		{
			CTreeCtrl* pTreeCtrl = theApp.GetProjectTreeCtrl();
			if( pTreeCtrl )
			{
				// Remove DocRoot's FileNode
				hItem = pTreeCtrl->GetNextItem( hItem, TVGN_PARENT );
				if( hItem )
				{
					CJzNode* pJzNode = (CJzNode *)pTreeCtrl->GetItemData( hItem );
					if( pJzNode )
					{
						pINode = pJzNode->m_pINode;
					}
				}

				if( pINode == NULL )
				{
					pINode = m_pIDocRootNode;
				}

				theApp.m_pFramework->RemoveNodes( pINode );
			}
		}
	}

	if( m_pIDocRootNode )
	{
		m_pIDocRootNode->Release();
	}

	AfxOleUnlockApp();
}


/////////////////////////////////////////////////////////////////////////////
// CCommonDoc::SaveAndCloseDoc

BOOL CCommonDoc::SaveAndCloseDoc( void )
{
	if( SaveModified() )
	{
		OnCloseDocument();
		return TRUE;
	}

	return FALSE;
}


BEGIN_MESSAGE_MAP(CCommonDoc, COleDocument)
	//{{AFX_MSG_MAP(CCommonDoc)
		// NOTE - the ClassWizard will add and remove mapping macros here.
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// CCommonDoc diagnostics

#ifdef _DEBUG
void CCommonDoc::AssertValid() const
{
	AFX_MANAGE_STATE( AfxGetAppModuleState() );
	COleDocument::AssertValid();
}

void CCommonDoc::Dump(CDumpContext& dc) const
{
	COleDocument::Dump(dc);
}
#endif //_DEBUG


/////////////////////////////////////////////////////////////////////////////
// CCommonDoc serialization

void CCommonDoc::Serialize(CArchive& ar)
{
	if (ar.IsStoring())
	{
		// TODO: add storing code here
	}
	else
	{
		// TODO: add loading code here
	}
}


/////////////////////////////////////////////////////////////////////////////
// CCommonDoc commands
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\Framework\CommonDoc.h ===
#ifndef __COMMONDOC_H__
#define __COMMONDOC_H__

// CommonDoc.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CCommonDoc document

class CCommonDoc : public COleDocument
{
protected:
	CCommonDoc();           // protected constructor used by dynamic creation
	DECLARE_DYNCREATE(CCommonDoc)

// Attributes
public:
	IDMUSProdNode*	m_pIDocRootNode;

// Operations
public:
	virtual BOOL SaveAndCloseDoc();

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CCommonDoc)
	public:
	virtual void Serialize(CArchive& ar);   // overridden for document i/o
	protected:
	//}}AFX_VIRTUAL

// Implementation
public:
	virtual ~CCommonDoc();
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

	// Generated message map functions
protected:
	//{{AFX_MSG(CCommonDoc)
		// NOTE - the ClassWizard will add and remove member functions here.
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // __COMMONDOC_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\Framework\ComponentCntrItem.h ===
#ifndef __COMPONENTCNTRITEM_H__
#define __COMPONENTCNTRITEM_H__

// ComponentCntrItem.h : interface of the CComponentCntrItem class
//

class CComponentDoc;
class CComponentView;

class CComponentCntrItem : public COleClientItem
{
	DECLARE_SERIAL(CComponentCntrItem)

// Constructors
public:
	CComponentCntrItem(CComponentDoc* pContainer = NULL);
		// Note: pContainer is allowed to be NULL to enable IMPLEMENT_SERIALIZE.
		//  IMPLEMENT_SERIALIZE requires the class have a constructor with
		//  zero arguments.  Normally, OLE items are constructed with a
		//  non-NULL document pointer.

// Attributes
public:
	CComponentDoc* GetDocument()
		{ return (CComponentDoc*)COleClientItem::GetDocument(); }
	CComponentView* GetActiveView()
		{ return (CComponentView*)COleClientItem::GetActiveView(); }

	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CComponentCntrItem)
	public:
	virtual void OnChange(OLE_NOTIFICATION wNotification, DWORD dwParam);
	virtual void OnActivate();
	protected:
	virtual void OnGetItemPosition(CRect& rPosition);
	virtual void OnDeactivateUI(BOOL bUndoable);
	virtual BOOL OnChangeItemPosition(const CRect& rectPos);
	//}}AFX_VIRTUAL

// Interface Maps
public:
	// IServiceProvider
	BEGIN_INTERFACE_PART(ServiceProvider, IServiceProvider)
		INIT_INTERFACE_PART(COleClientItem, ServiceProvider)
		STDMETHOD(QueryService)(REFGUID rsid, REFIID iid, void **ppvObj);
	END_INTERFACE_PART(ServiceProvider)

	// IDispatch for ambient properties
    BEGIN_INTERFACE_PART(Dispatch, IDispatch)
		INIT_INTERFACE_PART(COleClientItem, Dispatch)
		STDMETHOD(GetTypeInfoCount)(UINT*);
		STDMETHOD(GetTypeInfo)(UINT, LCID, LPTYPEINFO*);
		STDMETHOD(GetIDsOfNames)(REFIID, LPOLESTR*, UINT, LCID, DISPID*);
		STDMETHOD(Invoke)(DISPID, REFIID, LCID, WORD, DISPPARAMS*, VARIANT*, EXCEPINFO*, UINT*);
    END_INTERFACE_PART(Dispatch)

	DECLARE_INTERFACE_MAP()

// Implementation
public:
	~CComponentCntrItem();
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif
	virtual void Serialize(CArchive& ar);
};

/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.


#endif // __COMPONENTCNTRITEM_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\Framework\CntrItem.cpp ===
// CntrItem.cpp : implementation of the CJazzCntrItem class
//

#include "stdafx.h"
#include "JazzApp.h"

#include "JazzView.h"
#include "CntrItem.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


/////////////////////////////////////////////////////////////////////////////
// CJazzCntrItem implementation

IMPLEMENT_SERIAL(CJazzCntrItem, COleClientItem, 0)

CJazzCntrItem::CJazzCntrItem(CJazzDoc* pContainer)
	: COleClientItem(pContainer)
{
	// TODO: add one-time construction code here
	
}

CJazzCntrItem::~CJazzCntrItem()
{
	// TODO: add cleanup code here
	
}

void CJazzCntrItem::OnChange(OLE_NOTIFICATION nCode, DWORD dwParam)
{
	ASSERT_VALID(this);

	COleClientItem::OnChange(nCode, dwParam);

	// When an item is being edited (either in-place or fully open)
	//  it sends OnChange notifications for changes in the state of the
	//  item or visual appearance of its content.

	// TODO: invalidate the item by calling UpdateAllViews
	//  (with hints appropriate to your application)

	GetDocument()->UpdateAllViews(NULL);
		// for now just update ALL views/no hints
}

BOOL CJazzCntrItem::OnChangeItemPosition(const CRect& rectPos)
{
	ASSERT_VALID(this);

	// During in-place activation CJazzCntrItem::OnChangeItemPosition
	//  is called by the server to change the position of the in-place
	//  window.  Usually, this is a result of the data in the server
	//  document changing such that the extent has changed or as a result
	//  of in-place resizing.
	//
	// The default here is to call the base class, which will call
	//  COleClientItem::SetItemRects to move the item
	//  to the new position.

	if (!COleClientItem::OnChangeItemPosition(rectPos))
		return FALSE;

	// TODO: update any cache you may have of the item's rectangle/extent

	return TRUE;
}

void CJazzCntrItem::OnGetItemPosition(CRect& rPosition)
{
	ASSERT_VALID(this);

	// During in-place activation, CJazzCntrItem::OnGetItemPosition
	//  will be called to determine the location of this item.  The default
	//  implementation created from AppWizard simply returns a hard-coded
	//  rectangle.  Usually, this rectangle would reflect the current
	//  position of the item relative to the view used for activation.
	//  You can obtain the view by calling CJazzCntrItem::GetActiveView.

	// TODO: return correct rectangle (in pixels) in rPosition

	rPosition.SetRect(10, 10, 210, 210);
}

void CJazzCntrItem::OnActivate()
{
    // Allow only one inplace activate item per frame
    CJazzView* pView = GetActiveView();
    ASSERT_VALID(pView);
    COleClientItem* pItem = GetDocument()->GetInPlaceActiveItem(pView);
    if (pItem != NULL && pItem != this)
        pItem->Close();
    
    COleClientItem::OnActivate();
}

void CJazzCntrItem::OnDeactivateUI(BOOL bUndoable)
{
	COleClientItem::OnDeactivateUI(bUndoable);

    // Hide the object if it is not an outside-in object
    DWORD dwMisc = 0;
    m_lpObject->GetMiscStatus(GetDrawAspect(), &dwMisc);
    if (dwMisc & OLEMISC_INSIDEOUT)
        DoVerb(OLEIVERB_HIDE, NULL);
}

void CJazzCntrItem::Serialize(CArchive& ar)
{
	ASSERT_VALID(this);

	// Call base class first to read in COleClientItem data.
	// Since this sets up the m_pDocument pointer returned from
	//  CJazzCntrItem::GetDocument, it is a good idea to call
	//  the base class Serialize first.
	COleClientItem::Serialize(ar);

	// now store/retrieve data specific to CJazzCntrItem
	if (ar.IsStoring())
	{
		// TODO: add storing code here
	}
	else
	{
		// TODO: add loading code here
	}
}

/////////////////////////////////////////////////////////////////////////////
// CJazzCntrItem diagnostics

#ifdef _DEBUG
void CJazzCntrItem::AssertValid() const
{
	AFX_MANAGE_STATE( AfxGetAppModuleState() );
	COleClientItem::AssertValid();
}

void CJazzCntrItem::Dump(CDumpContext& dc) const
{
	COleClientItem::Dump(dc);
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\Framework\ComponentCntrItem.cpp ===
// ComponentCntrItem.cpp : implementation of the CComponentCntrItem class
//

#include "stdafx.h"
#include "JazzApp.h"
#include "ComponentCntrItem.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


/////////////////////////////////////////////////////////////////////////////
// CComponentCntrItem Interface map

BEGIN_INTERFACE_MAP(CComponentCntrItem, COleClientItem)
    INTERFACE_PART(CComponentCntrItem, IID_IServiceProvider, ServiceProvider)
    INTERFACE_PART(CComponentCntrItem, IID_IDispatch, Dispatch)
END_INTERFACE_MAP()


/////////////////////////////////////////////////////////////////////////////
// CComponentCntrItem implementation

IMPLEMENT_SERIAL(CComponentCntrItem, COleClientItem, 0)

CComponentCntrItem::CComponentCntrItem(CComponentDoc* pContainer)
	: COleClientItem(pContainer)
{
	// TODO: add one-time construction code here
	
}

CComponentCntrItem::~CComponentCntrItem()
{
	// TODO: add cleanup code here
	
}

void CComponentCntrItem::OnChange(OLE_NOTIFICATION nCode, DWORD dwParam)
{
	ASSERT_VALID(this);

	COleClientItem::OnChange(nCode, dwParam);

	// When an item is being edited (either in-place or fully open)
	//  it sends OnChange notifications for changes in the state of the
	//  item or visual appearance of its content.

	// TODO: invalidate the item by calling UpdateAllViews
	//  (with hints appropriate to your application)

	GetDocument()->UpdateAllViews(NULL);
		// for now just update ALL views/no hints
}

BOOL CComponentCntrItem::OnChangeItemPosition(const CRect& rectPos)
{
	ASSERT_VALID(this);

	// During in-place activation CComponentCntrItem::OnChangeItemPosition
	//  is called by the server to change the position of the in-place
	//  window.  Usually, this is a result of the data in the server
	//  document changing such that the extent has changed or as a result
	//  of in-place resizing.
	//
	// The default here is to call the base class, which will call
	//  COleClientItem::SetItemRects to move the item
	//  to the new position.

	if (!COleClientItem::OnChangeItemPosition(rectPos))
		return FALSE;

	// TODO: update any cache you may have of the item's rectangle/extent

	return TRUE;
}

void CComponentCntrItem::OnGetItemPosition(CRect& rPosition)
{
	ASSERT_VALID(this);

	// During in-place activation, CComponentCntrItem::OnGetItemPosition
	//  will be called to determine the location of this item.  The default
	//  implementation created from AppWizard simply returns a hard-coded
	//  rectangle.  Usually, this rectangle would reflect the current
	//  position of the item relative to the view used for activation.
	//  You can obtain the view by calling CComponentCntrItem::GetActiveView.

	// TODO: return correct rectangle (in pixels) in rPosition

	rPosition.SetRect(10, 10, 210, 210);
}

void CComponentCntrItem::OnActivate()
{
    // Allow only one inplace activate item per frame
    CComponentView* pView = GetActiveView();
    ASSERT_VALID(pView);
    COleClientItem* pItem = GetDocument()->GetInPlaceActiveItem(pView);
    if (pItem != NULL && pItem != this)
        pItem->Close();
    
    COleClientItem::OnActivate();
}

void CComponentCntrItem::OnDeactivateUI(BOOL bUndoable)
{
	COleClientItem::OnDeactivateUI(bUndoable);

    // Hide the object if it is not an outside-in object
    DWORD dwMisc = 0;
    m_lpObject->GetMiscStatus(GetDrawAspect(), &dwMisc);
    if (dwMisc & OLEMISC_INSIDEOUT)
        DoVerb(OLEIVERB_HIDE, NULL);
}

void CComponentCntrItem::Serialize(CArchive& ar)
{
	ASSERT_VALID(this);

	// Call base class first to read in COleClientItem data.
	// Since this sets up the m_pDocument pointer returned from
	//  CComponentCntrItem::GetDocument, it is a good idea to call
	//  the base class Serialize first.
	COleClientItem::Serialize(ar);

	// now store/retrieve data specific to CComponentCntrItem
	if (ar.IsStoring())
	{
		// TODO: add storing code here
	}
	else
	{
		// TODO: add loading code here
	}
}

/////////////////////////////////////////////////////////////////////////////
// CComponentCntrItem diagnostics

#ifdef _DEBUG
void CComponentCntrItem::AssertValid() const
{
	AFX_MANAGE_STATE( AfxGetAppModuleState() );
	COleClientItem::AssertValid();
}

void CComponentCntrItem::Dump(CDumpContext& dc) const
{
	COleClientItem::Dump(dc);
}
#endif

/////////////////////////////////////////////////////////////////////////////


/////////////////////////////////////////////////////////////////////////////
// CComponentCntrItem IServiceProvider implementation

/////////////////////////////////////////////////////////////////////////////
// CComponentCntrItem::XServiceProvider::QueryInterface

STDMETHODIMP CComponentCntrItem::XServiceProvider::QueryInterface( REFIID iid, LPVOID* ppvObj )
{
	METHOD_PROLOGUE_EX_( CComponentCntrItem, ServiceProvider )

	return (HRESULT)pThis->ExternalQueryInterface( &iid, ppvObj );
}


/////////////////////////////////////////////////////////////////////////////
// CComponentCntrItem::XServiceProvider::AddRef

STDMETHODIMP_(ULONG) CComponentCntrItem::XServiceProvider::AddRef()
{
	METHOD_PROLOGUE_EX_( CComponentCntrItem, ServiceProvider )

	return (ULONG)pThis->ExternalAddRef();
}


/////////////////////////////////////////////////////////////////////////////
// CComponentCntrItem::XServiceProvider::Release

STDMETHODIMP_(ULONG) CComponentCntrItem::XServiceProvider::Release()
{
	METHOD_PROLOGUE_EX_( CComponentCntrItem, ServiceProvider )

	return (ULONG)pThis->ExternalRelease();
}


/////////////////////////////////////////////////////////////////////////////
// CComponentCntrItem::XServiceProvider::QueryService implementation

STDMETHODIMP CComponentCntrItem::XServiceProvider::QueryService( REFGUID rsid, REFIID riid, void **ppvObj )
{
	METHOD_PROLOGUE_EX_( CComponentCntrItem, ServiceProvider )

	if( ppvObj == NULL )
	{
		return E_POINTER;
	}

	*ppvObj = NULL;

	if( !IsEqualGUID ( rsid, SID_IBindHost ) )
	{
        return E_FAIL;	// should be SVC_E_UNKNOWNSERVICE, which I can't find
	}

	if( theApp.m_pIServiceProvider == NULL )
	{
		return E_FAIL;
	}

    return theApp.m_pIServiceProvider->QueryService( rsid, riid, ppvObj );
}


/////////////////////////////////////////////////////////////////////////////
// CComponentCntrItem IDispatch implementation	

/////////////////////////////////////////////////////////////////////////////
// CComponentCntrItem IDispatch::QueryInterface

STDMETHODIMP CComponentCntrItem::XDispatch::QueryInterface( REFIID iid, LPVOID* ppvObj )
{
	METHOD_PROLOGUE_EX_( CComponentCntrItem, Dispatch )

	return (HRESULT)pThis->ExternalQueryInterface( &iid, ppvObj );
}


/////////////////////////////////////////////////////////////////////////////
// CComponentCntrItem IDispatch::AddRef

STDMETHODIMP_(ULONG) CComponentCntrItem::XDispatch::AddRef()
{
	METHOD_PROLOGUE_EX_( CComponentCntrItem, Dispatch )

	return (ULONG)pThis->ExternalAddRef();
}


/////////////////////////////////////////////////////////////////////////////
// CComponentCntrItem::XDispatch::Release

STDMETHODIMP_(ULONG) CComponentCntrItem::XDispatch::Release()
{
	METHOD_PROLOGUE_EX_( CComponentCntrItem, Dispatch )

	return (ULONG)pThis->ExternalRelease();
}
	
/////////////////////////////////////////////////////////////////////////////
// CComponentCntrItem IDispatch::GetTypeInfoCount

HRESULT CComponentCntrItem::XDispatch::GetTypeInfoCount( UINT* pctInfo )
{
	METHOD_PROLOGUE_EX_( CComponentCntrItem, Dispatch )

	*pctInfo = 0;

	return S_OK;
}

	
/////////////////////////////////////////////////////////////////////////////
// CComponentCntrItem IDispatch::GetTypeInfo

HRESULT CComponentCntrItem::XDispatch::GetTypeInfo( UINT itinfo, LCID lcid, ITypeInfo** ppITypeInfo )
{
	METHOD_PROLOGUE_EX_( CComponentCntrItem, Dispatch )

	*ppITypeInfo = NULL;

	return E_NOTIMPL;
}

	
/////////////////////////////////////////////////////////////////////////////
// CComponentCntrItem IDispatch::GetIDsOfNames

HRESULT CComponentCntrItem::XDispatch::GetIDsOfNames( REFIID riid, LPOLESTR* rgszNames,
													  UINT cNames, LCID lcid, DISPID* rgDispID )
{
	METHOD_PROLOGUE_EX_( CComponentCntrItem, Dispatch )

	*rgszNames = NULL;
	*rgDispID = NULL;

	return E_NOTIMPL;
}

	
/////////////////////////////////////////////////////////////////////////////
// CComponentCntrItem IDispatch::Invoke
	
HRESULT CComponentCntrItem::XDispatch::Invoke( DISPID dispIDMember, REFIID riid, LCID lcid,
											   unsigned short wFlags, DISPPARAMS* pDispParams,
											   VARIANT* pVarResult, EXCEPINFO* pExcepInfo,
											   UINT* puArgErr)
{
	METHOD_PROLOGUE_EX_( CComponentCntrItem, Dispatch )

	HRESULT hr;
	VARIANT varResult;

	if( riid != IID_NULL )
	{
		return E_INVALIDARG;
	}

	if( pVarResult == NULL )
	{
		pVarResult = &varResult;
	}

	VariantInit( pVarResult );

	//The most common case is Boolean; use as an initial type.
	V_VT(pVarResult) = VT_BOOL;

	//Anything but a property get is invalid.
	if( !(DISPATCH_PROPERTYGET & wFlags) )
	{
		return DISP_E_MEMBERNOTFOUND;
	}

	hr = S_OK;

	switch( dispIDMember )
	{
		case DISPID_AMBIENT_LOCALEID:
			V_I4(pVarResult) = GetThreadLocale();
			V_VT(pVarResult) = VT_I4;
			break;

		case DISPID_AMBIENT_USERMODE:
			V_BOOL(pVarResult) = TRUE;
			break;

		case DISPID_AMBIENT_UIDEAD:
			V_BOOL(pVarResult) = FALSE;
			break;

		case DISPID_AMBIENT_SUPPORTSMNEMONICS:
			V_BOOL(pVarResult) = TRUE;
			break;

		case DISPID_AMBIENT_SHOWGRABHANDLES:
			V_BOOL(pVarResult) = FALSE;
			break;

		case DISPID_AMBIENT_SHOWHATCHING:
			V_BOOL(pVarResult) = FALSE;
			break;

		case DISPID_AMBIENT_MESSAGEREFLECT:
			V_BOOL(pVarResult) = FALSE;
			break;

		case DISPID_AMBIENT_AUTOCLIP:
			V_BOOL(pVarResult) = FALSE;
			break;

		default:
			hr = DISP_E_MEMBERNOTFOUND;
			break;
	}

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\Framework\ComponentDoc.cpp ===
// ComponentDoc.cpp : implementation file
//

#include "stdafx.h"
#include "JazzApp.h"
#include "MainFrm.h"
#include "ComponentCntrItem.h"
#include "SavePrompt.h"
#include "NotifyList.h"
#include <DLSDesigner.h>

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CComponentDoc

IMPLEMENT_DYNCREATE(CComponentDoc, CCommonDoc)

CComponentDoc::CComponentDoc()
{
	m_pFileNode = NULL;
	m_pIDocType = NULL;
	m_bAction = DOC_ACTION_NONE;
}


/////////////////////////////////////////////////////////////////////////////
// CComponentDoc::OnNewDocument

BOOL CComponentDoc::OnNewDocument()
{
	CJazzDocTemplate* pDocTemplate;
	IDMUSProdProject* pIProject;

	// Find IDMUSProdDocType interface
	ASSERT( m_pIDocType == NULL );
	pDocTemplate = (CJazzDocTemplate *)GetDocTemplate();
	ASSERT( pDocTemplate != NULL );
	m_pIDocType = pDocTemplate->m_pIDocType;
	m_pIDocType->AddRef();
	ASSERT( m_pIDocType != NULL );

	// MFC new document processing
	if (!COleDocument::OnNewDocument())
	{
		return FALSE;
	}

	// Create FileNode
	m_pFileNode = new CFileNode;
	if( m_pFileNode == NULL )
	{
		return FALSE;
	}
	m_pFileNode->AddRef();
	m_pFileNode->m_pComponentDoc = this;
//	m_pFileNode->m_pComponentDoc->AddRef();		intentionally missing

	// Determine path of FileNode
	CString strPath;

	theApp.m_nFileTarget = TGT_SELECTEDNODE;
	IDMUSProdNode* pIDirNode = theApp.m_pFramework->DetermineParentNode( NULL );
	theApp.m_nFileTarget = TGT_PROJECT;

	if( pIDirNode )
	{
		GUID guidNodeId;
		if( SUCCEEDED ( pIDirNode->GetNodeId( &guidNodeId ) ) )
		{
			if( IsEqualGUID ( guidNodeId, GUID_ProjectFolderNode )
			||  IsEqualGUID ( guidNodeId, GUID_DirectoryNode ) )
			{
				CDirectoryNode* pDirNode = (CDirectoryNode *)pIDirNode;
				pDirNode->ConstructPath( strPath );
			}
		}
	}

	// Get IDMUSProdProject for this file
	if( FAILED ( theApp.m_pFramework->FindProject( pIDirNode, &pIProject ) ) )
	{
		return FALSE;
	}
	CProject* pProject = (CProject *)pIProject;

	ASSERT( m_pIDocRootNode == NULL );
	if(	theApp.m_strImportFileName.IsEmpty() )
	{
		// Create a new file
		theApp.DoWaitCursor( TRUE );
		HRESULT hr = m_pIDocType->OnFileNew( pIProject, pIDirNode, &m_pIDocRootNode );
		theApp.DoWaitCursor( FALSE );

		// Override the default name with name from CFileNewDlg
		if( SUCCEEDED ( hr )
		&&  m_pIDocRootNode )
		{
			if( theApp.m_strNewFileName.IsEmpty() == FALSE )
			{
				BSTR bstrName = theApp.m_strNewFileName.AllocSysString();
				m_pIDocRootNode->SetNodeName( bstrName );
			}
		}
		
		if( FAILED( hr ) )
		{
			pIProject->Release();
			return FALSE;
		}
	}
	else
	{
		// Open the file and have the Component load (import) it
		IStream* pIStream;
		BSTR bstrPathName = theApp.m_strImportFileName.AllocSysString();

		if( FAILED ( theApp.m_pFramework->AllocFileStream(bstrPathName, GENERIC_READ, FT_UNKNOWN,
														  GUID_AllZeros, pIDirNode, &pIStream) ) )
		{
			pIProject->Release();
			return FALSE;
		}

		// Start tracking File Open
		if( theApp.m_pJzTrackFileOpen == NULL )
		{
			theApp.m_pJzTrackFileOpen = new CJzTrackFileOpen;
		}
		if( theApp.m_pJzTrackFileOpen )
		{
			theApp.m_pJzTrackFileOpen->AddRef();
		}

		theApp.DoWaitCursor( TRUE );
		HRESULT hr = m_pIDocType->OnFileOpen( pIStream, pIProject, pIDirNode, &m_pIDocRootNode );
		theApp.DoWaitCursor( FALSE );

		// Stop tracking File Open
		if( theApp.m_pJzTrackFileOpen )
		{
			theApp.m_pJzTrackFileOpen->Release();
		}
		
		if( FAILED( hr )
		||  m_pIDocRootNode == NULL )
		{
			HINSTANCE hInstance = AfxGetResourceHandle();
			AfxSetResourceHandle( theApp.m_hInstance );

			CString strMsg;
			AfxFormatString1( strMsg, IDS_ERR_CANNOT_IMPORT_FILE, theApp.m_strImportFileName );
			AfxMessageBox( strMsg );

			AfxSetResourceHandle( hInstance );

			pIProject->Release();
			pIStream->Release();
			return FALSE;
		}
		pIStream->Release();
	}
	ASSERT( m_pIDocRootNode != NULL );
	pIProject->Release();
	pIProject = NULL;

	// Set the FileNode's child node
	m_pFileNode->InsertChildNode( m_pIDocRootNode );

	// Set the FileNode's parent node
	m_pFileNode->SetParentNode( pIDirNode );

	// Get name of DocRoot
	CString strDocRootName;
	BSTR bstrDocRootName;
	if(	theApp.m_strImportFileName.IsEmpty() )
	{
		if( SUCCEEDED ( m_pIDocRootNode->GetNodeName( &bstrDocRootName ) ) )
		{
			strDocRootName = bstrDocRootName;
			::SysFreeString( bstrDocRootName );
		}
		if( strDocRootName.IsEmpty() )
		{
			pDocTemplate->GetDocString( strDocRootName, CDocTemplate::docName );
			if( strDocRootName.IsEmpty() )
			{
				// Use generic 'untitled'
				VERIFY( strDocRootName.LoadString( AFX_IDS_UNTITLED ) );
			}

			// Append "1" to docName 
			CString strNbr;
			strNbr.Format( "%d", 1 );
			strDocRootName += strNbr;
		}
	}
	else
	{
		TCHAR achName[_MAX_FNAME];
		_tsplitpath( theApp.m_strImportFileName, NULL, NULL, achName, NULL );
		strDocRootName = achName;
	}
	ASSERT( strDocRootName.IsEmpty() == FALSE );

	// Determine filename (may have to adjust document title)
	CString strProposedFileName;
	SetTitle( strDocRootName );
	DetermineDefaultFileName( m_pFileNode->m_strName );
	m_pFileNode->ConstructFileName( strProposedFileName );
	theApp.GetUniqueFileName( strProposedFileName, m_pFileNode->m_strName );
	SetTitle( m_pFileNode->m_strName );

	// Add file to CProject file list
	pProject->AddFile( m_pFileNode );

	// Limit length of DocRoot text
	short nMaxLength;

	theApp.SplitOutFileName( m_pFileNode->m_strName, FALSE, strDocRootName );
	if( SUCCEEDED ( m_pIDocRootNode->GetNodeNameMaxLength(&nMaxLength) ) )
	{
		if( nMaxLength > 0 )
		{
			if( strDocRootName.GetLength() > nMaxLength )
			{
				strDocRootName = strDocRootName.Left( nMaxLength );
			}
		}
	}

	// Set DocRoot node name
	bstrDocRootName = strDocRootName.AllocSysString();
	m_pIDocRootNode->SetNodeName( bstrDocRootName );

	// Force SetNodeName to handle setting of FileNode node name
	bstrDocRootName = m_pFileNode->m_strName.AllocSysString();
	m_pFileNode->m_strName.Empty();
	m_pFileNode->SetNodeName( bstrDocRootName );

	// Save file
	CString strFileName;
	m_pFileNode->ConstructFileName( strFileName );
	if( DoSave ( strFileName ) )
	{
		// Place document nodes in Project Tree
		if( SUCCEEDED ( pIDirNode->InsertChildNode( m_pFileNode ) )
		&&  SUCCEEDED ( theApp.m_pFramework->AddNode( m_pIDocRootNode, m_pFileNode ) ) )
		{
			CTreeCtrl* pTreeCtrl = theApp.GetProjectTreeCtrl();

			CDirectoryNode* pDirNode = (CDirectoryNode *)pIDirNode;
			if( pDirNode->m_hItem )
			{
				CMainFrame* pMainFrame = (CMainFrame *)theApp.m_pMainWnd;
				ASSERT( pMainFrame != NULL );
				pMainFrame->m_wndTreeBar.SortChildren( pDirNode->m_hItem );
			}

			theApp.CleanUpNotifyLists( m_pFileNode, FALSE );

			if( theApp.m_nShowNodeInTree == SHOW_NODE_IN_TREE )
			{
				if( pTreeCtrl )
				{
					pTreeCtrl->SetFocus();
				}
			}
			theApp.m_pFramework->ShowTreeNode( m_pFileNode );

			if( m_pFileNode->m_hChildItem )
			{
				if( pTreeCtrl )
				{
					if( theApp.m_nShowNodeInTree == SHOW_NODE_IN_TREE )
					{
						pTreeCtrl->EnsureVisible( m_pFileNode->m_hChildItem );
					}
					if( pTreeCtrl->ItemHasChildren(m_pFileNode->m_hChildItem) )
					{
						pTreeCtrl->Expand( m_pFileNode->m_hChildItem, TVE_EXPAND );
					}
				}
			}

			if( m_pFileNode->m_pIChildNode )
			{
				if( theApp.m_fOpenEditorWindow )
				{
					OpenEditorWindow( m_pFileNode->m_pIChildNode );
				}
			}
			return TRUE;
		}
	}

	// Remove file from CProject file list
	pProject->RemoveFile( m_pFileNode );

	return FALSE;
}

CComponentDoc::~CComponentDoc()
{
	if( m_pFileNode )
	{
		theApp.CleanUpNotifyLists( m_pFileNode, TRUE );

		m_pFileNode->m_pComponentDoc = NULL;
		m_pFileNode->Release();
	}

	if( m_pIDocType )
	{
		m_pIDocType->Release();
	}
}


/////////////////////////////////////////////////////////////////////////////
// CComponentDoc::CreateNewWindow

CFrameWnd* CComponentDoc::CreateNewWindow( IDMUSProdNode* pINode ) 
{
	HINSTANCE hInstance;

	CJazzDocTemplate* pTemplate = (CJazzDocTemplate *)GetDocTemplate();
	ASSERT_VALID(pTemplate);

	hInstance = AfxGetResourceHandle();
	AfxSetResourceHandle( pTemplate->m_hInstance );

	CFrameWnd* pFrame = pTemplate->CreateNewFrame( this, NULL );

	AfxSetResourceHandle( hInstance );

	if( pFrame == NULL )
	{
		TRACE0("Warning: failed to create new frame.\n");
		return NULL;     // command failed
	}

	CJzNode* pJzNode = NULL;

	// Set Editor WindowPlacement
	CTreeCtrl* pTreeCtrl = theApp.GetProjectTreeCtrl();
	if( pTreeCtrl )
	{
		HTREEITEM hItem = theApp.m_pFramework->FindTreeItem( pINode );
		if( hItem )
		{
			pJzNode = (CJzNode *)pTreeCtrl->GetItemData( hItem );
			if( pJzNode )
			{
				if( pJzNode->m_wp.length != 0 )
				{
					pJzNode->m_wp.length = sizeof(pJzNode->m_wp);

					int nOrigShowCmd = pJzNode->m_wp.showCmd;
					pJzNode->m_wp.showCmd = SW_HIDE;
					if( pJzNode->m_wp.rcNormalPosition.left < 0 )
					{
						pJzNode->m_wp.rcNormalPosition.right -= pJzNode->m_wp.rcNormalPosition.left;
						pJzNode->m_wp.rcNormalPosition.left = 0;
					}
					if( pJzNode->m_wp.rcNormalPosition.top < 0 )
					{
						pJzNode->m_wp.rcNormalPosition.bottom -= pJzNode->m_wp.rcNormalPosition.top;
						pJzNode->m_wp.rcNormalPosition.top = 0;
					}
					pFrame->SetWindowPlacement( &pJzNode->m_wp );
					pJzNode->m_wp.showCmd = nOrigShowCmd;
				}
			}
		}
	}

	pTemplate->InitialUpdateFrame( pFrame, this );

	// Get Editor WindowPlacement
	if( pJzNode )
	{
		if( pJzNode->m_wp.length == 0 )
		{
			pJzNode->m_wp.length = sizeof(pJzNode->m_wp);
			if( pFrame->GetWindowPlacement( &pJzNode->m_wp ) == 0 )
			{
				ZeroMemory( &pJzNode->m_wp, sizeof(pJzNode->m_wp) );
			}
		}
	}

	return pFrame;
}


/////////////////////////////////////////////////////////////////////////////
// CComponentDoc::OpenEditorWindow

void CComponentDoc::OpenEditorWindow( IDMUSProdNode* pINode ) 
{
	CComponentCntrItem* pCntrItem = NULL;
	CComponentView* pView = NULL;
	CMainFrame* pMainFrame;
	CFrameWnd* pFrame;
	CLSID clsidEditor;
	IDMUSProdEditor* pIEditor;
	HWND  hWndEditor;
	CWnd* pWndEditor;
	CRect rect;

	ASSERT( pINode != NULL );

	pMainFrame = (CMainFrame *)theApp.m_pMainWnd;
	ASSERT( pMainFrame != NULL );
	
	CWnd* pWndActive = pMainFrame->MDIGetActive();

	// If editor already open just bring window to front
	if( SUCCEEDED ( pINode->GetEditorWindow(&hWndEditor) ) )
	{
		if( hWndEditor )
		{
			pWndEditor = CWnd::FromHandlePermanent( hWndEditor );
			if( pWndEditor )
			{
				if( pWndEditor->IsIconic() )
				{
					pMainFrame->MDIRestore( pWndEditor );
				}
				pMainFrame->MDIActivate( pWndEditor );
				return;
			}
		}
	}

	TRY
	{
		if( SUCCEEDED( pINode->GetEditorClsId(&clsidEditor) ) )
		{
			pFrame = CreateNewWindow( pINode );
			if( pFrame == NULL )
			{
				AfxThrowMemoryException();		// any exception will do
			}
			ASSERT_VALID( pFrame );

			pFrame->ModifyStyle( FWS_ADDTOTITLE, 0, 0 );
			pView = (CComponentView *)pFrame->GetActiveView();
			ASSERT_VALID( pView );
			
			pView->m_pINode = pINode;
			pView->m_pINode->AddRef();
			pView->m_pINode->SetEditorWindow( pFrame->GetSafeHwnd() );

			IDMUSProdProject* pIProject;
			if( SUCCEEDED ( theApp.m_pFramework->FindProject( pView->m_pINode, &pIProject ) ) )
			{
				pView->m_pIProject = pIProject;
			}

			// Set Window Title
			{
				BSTR bstrTitle;
				CString strTitle;

				pView->m_pINode->GetEditorTitle( &bstrTitle );
				strTitle = bstrTitle;
				::SysFreeString( bstrTitle );
				pFrame->SetWindowText( strTitle );
			}

			pCntrItem = new CComponentCntrItem( this );
			ASSERT_VALID( pCntrItem );

			if( !pCntrItem->CreateNewItem( clsidEditor ) )
			{
				AfxThrowMemoryException();		// any exception will do
			}
			
			// Attach object to the control 
			ASSERT( pCntrItem->m_lpObject != NULL );
			if( SUCCEEDED ( pCntrItem->m_lpObject->QueryInterface( IID_IDMUSProdEditor, (void**)&pIEditor ) ) )
			{
				pView->m_pIEditor = pIEditor;
				pIEditor->AttachObjects( pINode );
			}
			else
			{
				AfxThrowMemoryException();		// any exception will do
			}

			// Force WS_CLIPCHILDREN style
			pFrame->ModifyStyle( 0, WS_CLIPCHILDREN, 0 );

			ASSERT_VALID( pCntrItem );
			pCntrItem->DoVerb( OLEIVERB_SHOW, static_cast<CComponentView*>( pView ) );
			ASSERT_VALID( pCntrItem );

			// Force a WM_GETMINMAXINFO 
			CWnd* pWndParent = pFrame->GetParent();
			if( pWndParent )
			{
				CRect rect;
				pFrame->GetWindowRect( &rect );
				pWndParent->ScreenToClient( &rect );
				pFrame->MoveWindow( &rect, TRUE );
			}

			pView->m_pEditorCtrl = pCntrItem;			
			pView->GetWindowRect( &rect );
			pView->SendMessage( WM_SIZE, SIZE_RESTORED, MAKELPARAM(rect.Width(), rect.Height()) );
			
			// If no other editors are open maximize the window 
			if( pWndActive == NULL )
			{
				pFrame->ShowWindow( SW_SHOWMAXIMIZED );
			}

			// Highlight the corresponding node in the Project Tree
			theApp.m_pFramework->ShowTreeNode( pView->m_pINode );
		}
	}

	CATCH( CException, e )
	{
		AfxMessageBox( IDP_FAILED_TO_CREATE );
		if( pCntrItem != NULL )
		{
			ASSERT_VALID( pCntrItem );
			pCntrItem->Delete();
		}
		if( pFrame != NULL )
		{
			ASSERT_VALID( pFrame );
			PreCloseFrame( pFrame );
			pFrame->DestroyWindow();
		}
	}
	END_CATCH
}


/////////////////////////////////////////////////////////////////////////////
// CComponentDoc::CloseAllViews

void CComponentDoc::CloseAllViews( BOOL fAutoDelete )
{
	CComponentView* pView;
	CFrameWnd* pFrame;
	BOOL fKeepGoing;

	// destroy all frames viewing this document
	// but keep the seed view so document won't get destroyed
	BOOL bAutoDelete = m_bAutoDelete;
	m_bAutoDelete = fAutoDelete;

	fKeepGoing = TRUE;
	while( !m_viewList.IsEmpty()  &&  (fKeepGoing == TRUE) )
	{
		fKeepGoing = FALSE;

		POSITION pos = GetFirstViewPosition();
		if( pos )
		{
			pView = (CComponentView *)GetNextView( pos );
			ASSERT_VALID( pView );

			while( pView  &&  (pView->m_fSeed == TRUE) )		// skip over seed view
			{
				pView = (CComponentView *)GetNextView( pos );
			}

			// keep the seed view so that the document
			// won't get destroyed for having zero views
			if( pView  &&  (pView->m_fSeed == FALSE) )
			{
				// get the frame associated with the view and close it
				// this will destroy the view as well
				ASSERT_VALID( pView );
				pFrame = pView->GetParentFrame();
				ASSERT_VALID( pFrame );
				PreCloseFrame( pFrame );
				pFrame->DestroyWindow();

				fKeepGoing = TRUE;
			}
		}

	}

	m_bAutoDelete = bAutoDelete;
}


/////////////////////////////////////////////////////////////////////////////
// CComponentDoc::CloseViewsByNode

BOOL CComponentDoc::CloseViewsByNode( IDMUSProdNode* pINode )
{
	CComponentView* pView;
	CFrameWnd* pFrame;
	BOOL fKeepGoing;
	BOOL fClosedEditor = FALSE;

	// destroy all frames viewing this document
	// but keep the seed view so document won't get destroyed
	BOOL bAutoDelete = m_bAutoDelete;
	m_bAutoDelete = FALSE;

	fKeepGoing = TRUE;
	POSITION pos = GetFirstViewPosition();

	while( pos  &&  (fKeepGoing == TRUE) )
	{
		fKeepGoing = FALSE;

		pView = (CComponentView *)GetNextView( pos );
		ASSERT_VALID( pView );

		while( pView  &&  (pView->m_fSeed == TRUE) )		// skip over seed view
		{
			pView = (CComponentView *)GetNextView( pos );
		}

		// keep the seed view so that the document
		// won't get destroyed for having zero views
		if( pView
		&&  pView->m_fSeed == FALSE )
		{
			if( pView->m_pINode == pINode )
			{
				// get the frame associated with the view and close it
				// this will destroy the view as well
				ASSERT_VALID( pView );
				pFrame = pView->GetParentFrame();
				pFrame->ActivateFrame();
				ASSERT_VALID( pFrame );
				PreCloseFrame( pFrame );
				pFrame->SendMessage( WM_CLOSE );

				fClosedEditor = TRUE;
			}

			fKeepGoing = TRUE;
		}
	}

	m_bAutoDelete = bAutoDelete;

	return fClosedEditor;
}


/////////////////////////////////////////////////////////////////////////////
// CComponentDoc::RevertDocument

BOOL CComponentDoc::RevertDocument( void ) 
{
	BOOL fSuccess = FALSE;

	CString strFileName = GetPathName();

	ASSERT( m_pFileNode != NULL );
	ASSERT( AfxIsValidString(strFileName) );

	if( !strFileName.IsEmpty() )	// Have a filename
	{
		DWORD dwAttributes = GetFileAttributes( strFileName );
		if( dwAttributes != 0xFFFFFFFF )	// File exists
		{
			// Set Project Tree position
			theApp.SetProjectTreePosition( m_pFileNode );

			// Remove file's notify list
			CNotifyList nl;
			nl.Detach( m_pFileNode );

			// Revert the file
			if( SUCCEEDED ( m_pFileNode->DeleteNode( FALSE ) ) )
			{
				if( theApp.OpenTheFile( strFileName, TGT_FILENODE_SAVEAS ) )
				{
					fSuccess = TRUE;
				}
			}

			// Reattach file's notify list
			CFileNode* pFileNode = theApp.FindFileNode( strFileName );
			if( pFileNode )
			{
				nl.Attach( pFileNode );
			}
		}
	}

	return fSuccess;
}


/////////////////////////////////////////////////////////////////////////////
// CComponentDoc::IsModified

BOOL CComponentDoc::IsModified( void )
{
	BOOL fModified = FALSE;

	if( m_pIDocRootNode )
	{
		IPersistStream *pIPS;

		m_pIDocRootNode->QueryInterface( IID_IPersistStream, (void **)&pIPS );
		if( pIPS )
		{
			if( pIPS->IsDirty() == S_OK)
			{
				fModified = TRUE;
			}

			pIPS->Release();
		}
	}

	return fModified;
}


/////////////////////////////////////////////////////////////////////////////
// CComponentDoc::SaveModified

// Same as COleDocument::SaveModified with following exception: 
// Call to UpdateModifiedFlag() was removed.  We do not want to force
// modified flag to signify a dirty file.

BOOL CComponentDoc::SaveModified() 
{
	AFX_MANAGE_STATE( AfxGetAppModuleState() );

	CString strName;
	CString strPrompt;
	int nSavePromptAction;

	// Following "if" statement from COleDocument::SaveModified
	if (::InSendMessage())
	{
		POSITION pos = GetStartPosition();
		COleClientItem* pItem;
		while( (pItem = GetNextClientItem(pos)) != NULL )
		{
			ASSERT( pItem->m_lpObject != NULL );
			SCODE sc = pItem->m_lpObject->IsUpToDate();
			if( sc != OLE_E_NOTRUNNING && FAILED(sc) )
			{
				// inside inter-app SendMessage limits the user's choices
				strName = m_strPathName;
				if( strName.IsEmpty() )
				{
					VERIFY(strName.LoadString(AFX_IDS_UNTITLED));
				}

				AfxFormatString1( strPrompt, AFX_IDP_ASK_TO_DISCARD, strName );

				return AfxMessageBox( strPrompt, MB_OKCANCEL|MB_DEFBUTTON2,
										AFX_IDP_ASK_TO_DISCARD ) == IDOK;
			}
		}
	}

	// Remainder of code based on CDocument::SaveModified
	// CDocument::SaveModified was changed to customize
	// the buttons on the save prompt message box.

	if( !IsModified() )
	{
		return TRUE;        // ok to continue
	}

	BOOL fNewFile = FALSE;
	
	// Get name/title of document
	if( m_strPathName.IsEmpty() )
	{
		fNewFile = TRUE;

		// get name based on caption
		strName = m_strTitle;
		if( strName.IsEmpty() )
		{
			VERIFY( strName.LoadString(AFX_IDS_UNTITLED) );
		}
	}
	else
	{
		// Get name based on file title of path name
		theApp.SplitOutFileName( m_strPathName, TRUE, strName );
	}

	CString strFilterName;

	CJazzDocTemplate* pDocTemplate = (CJazzDocTemplate *)GetDocTemplate();
	ASSERT( pDocTemplate != NULL );
	if( pDocTemplate )
	{
		pDocTemplate->GetDocString( strFilterName, CDocTemplate::docName );
	}

	if( fNewFile )
	{
		AfxFormatString2( strPrompt, IDS_SAVEPROMPT_SAVEAS, strFilterName, strName );
	}
	else
	{
		AfxFormatString2( strPrompt, IDS_SAVEPROMPT_SAVE, strFilterName, strName );
	}

	if( theApp.m_nSavePromptAction == 0 )
	{
		CSavePromptDlg spDlg( &strPrompt );
		::MessageBeep( MB_ICONEXCLAMATION );
		nSavePromptAction = spDlg.DoModal();
	}
	else
	{
		nSavePromptAction = theApp.m_nSavePromptAction;
	}

	switch( nSavePromptAction )
	{
		case IDCANCEL:
			return FALSE;       // don't continue

		case IDYES:
			if( !DoFileSave() )
				return FALSE;	// don't continue
			break;

		case ID_YESALL:
			theApp.m_nSavePromptAction = nSavePromptAction;
			if( !DoFileSave() )
				return FALSE;	// don't continue
			break;

		case IDNO:
			break;

		case ID_NOALL:
			theApp.m_nSavePromptAction = nSavePromptAction;
			break;

		default:
			ASSERT( FALSE );
			break;
	}

	return TRUE;    // keep going
}


/////////////////////////////////////////////////////////////////////////////
// CComponentDoc::SaveAndCloseDoc

BOOL CComponentDoc::SaveAndCloseDoc( void )
{
	BOOL fContinue = TRUE;

	if( m_bAction == DOC_ACTION_NONE )	// Don't prompt again if DOC_ACTION in progress
	{
		fContinue = SaveModified();
	}

	if( fContinue )
	{
		OnCloseDocument();
		return TRUE;
	}

	return FALSE;
}


/////////////////////////////////////////////////////////////////////////////
// CComponentDoc::SaveComponentFileIfModified

BOOL CComponentDoc::SaveComponentFileIfModified( void )	// Customizes buttons on save prompt
{
	return SaveModified();
}


BEGIN_MESSAGE_MAP(CComponentDoc, CCommonDoc)
	//{{AFX_MSG_MAP(CComponentDoc)
	ON_COMMAND(ID_FILE_RUNTIME_SAVEAS, OnFileRuntimeSaveAs)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CComponentDoc diagnostics

#ifdef _DEBUG
void CComponentDoc::AssertValid() const
{
	AFX_MANAGE_STATE( AfxGetAppModuleState() );
	CCommonDoc::AssertValid();
}

void CComponentDoc::Dump(CDumpContext& dc) const
{
	CCommonDoc::Dump(dc);
}
#endif //_DEBUG

/////////////////////////////////////////////////////////////////////////////
// CComponentDoc serialization

void CComponentDoc::Serialize(CArchive& ar)
{
}


/////////////////////////////////////////////////////////////////////////////
// CComponentDoc commands

/////////////////////////////////////////////////////////////////////////////
// CComponentDoc::OnOpenDocument

BOOL CComponentDoc::OnOpenDocument( LPCTSTR szPathName ) 
{
	CJazzDocTemplate* pDocTemplate;
	CDirectoryNode* pParentDirNode;
	IDMUSProdProject* pIProject;
	CNotifyList nl;		// Used to transfer new file pointer when overwriting existing file
	
	ASSERT( szPathName != NULL );
	ASSERT( AfxIsValidString(szPathName) );

	// Find the parent node in the Project Tree
	IDMUSProdNode* pIParentNode = theApp.m_pFramework->DetermineParentNode( szPathName );
	if( pIParentNode == NULL )
	{
		return FALSE;
	}

	pParentDirNode = (CDirectoryNode *)pIParentNode;

	// Find IDMUSProdDocType interface
	ASSERT( m_pIDocType == NULL );
	pDocTemplate = (CJazzDocTemplate *)GetDocTemplate();
	ASSERT( pDocTemplate != NULL );
	m_pIDocType = pDocTemplate->m_pIDocType;
	m_pIDocType->AddRef();
	ASSERT( m_pIDocType != NULL );

	BOOL fInsertFileNode = FALSE;
	ASSERT( m_pFileNode == NULL );

	// Get FileNode based on target location in the Project
	{
		CString strOrigFileName;
		CString strNewFileName;
		CString strNewPathName;
		CString strRuntimeFileName;
		CString strRuntimePathName;

		// Split out name of file
		theApp.SplitOutFileName( szPathName, TRUE, strOrigFileName );

		// Get new directory
		pParentDirNode->ConstructPath( strNewPathName );

		// Append "runtime" name of file to the new directory
		theApp.AdjustFileName( FT_RUNTIME, strOrigFileName, strRuntimeFileName );
		strRuntimePathName = strNewPathName + strRuntimeFileName;

		// Append "design" name of file to the new directory
		theApp.AdjustFileName( FT_DESIGN, strOrigFileName, strNewFileName );
		strNewPathName += strNewFileName;
	
		// See if the FileNode exists
		if( strRuntimePathName.CompareNoCase( szPathName ) == 0 )
		{
			m_pFileNode = theApp.FindFileNode( strRuntimePathName );
		}
		else
		{
			m_pFileNode = theApp.FindFileNode( strNewPathName );
			if( m_pFileNode )
			{
				if( strNewPathName.CompareNoCase( szPathName ) != 0 )
				{
					// A different file wants to reside on this FileNode
					// Make sure user wants to override existing file
					CString strRelativePath;
					CString strMsg;
					BOOL fReturn;

					// A different file with the same name already exists in the Project
					// See if the user wants to overwrite it
					if( m_pFileNode->ConstructRelativePath( strRelativePath ) )
					{
						strRelativePath = _T("..\\") + strRelativePath;
						if( strRelativePath.Right(1) != _T("\\") )
						{
							strRelativePath += _T("\\");
						}
						strRelativePath += strNewFileName;
					}

					HINSTANCE hInstance = AfxGetResourceHandle();
					AfxSetResourceHandle( theApp.m_hInstance );

					AfxFormatString2( strMsg, IDS_OVERWRITE_EXISTING, m_pFileNode->m_pProject->m_strName, strRelativePath );
					if( strOrigFileName.CompareNoCase(strRuntimeFileName) == 0 )
					{
						IDMUSProdDocType* pIWaveDocType;
						if( FAILED ( theApp.m_pFramework->FindDocTypeByNodeId( GUID_WaveNode, &pIWaveDocType ) ) )
						{
							pIWaveDocType = NULL;
						}

						IDMUSProdDocType* pIDLSDocType;
						if( FAILED ( theApp.m_pFramework->FindDocTypeByNodeId( GUID_CollectionNode, &pIDLSDocType ) ) )
						{
							pIDLSDocType = NULL;
						}

						CString strMsg2;
						if( m_pIDocType == pIWaveDocType
						||  m_pIDocType == pIDLSDocType )
						{
							strMsg2.LoadString( IDS_OVERWRITE_EXISTING_WAVE_WARNING );
						}
						else
						{
							strMsg2.LoadString( IDS_OVERWRITE_EXISTING_RUNTIME_WARNING );
						}
						strMsg += _T( "\n\n" );
						strMsg += strMsg2;

						if( pIWaveDocType )
						{
							pIWaveDocType->Release();
						}
						if( pIDLSDocType )
						{
							pIDLSDocType->Release();
						}
					}
					fReturn = AfxMessageBox( strMsg, MB_YESNO|MB_DEFBUTTON2 );
					
					AfxSetResourceHandle( hInstance );
					
					if( fReturn == IDNO )
					{
						m_pFileNode = NULL;
						return FALSE;
					}

					// Close the old file so that we can overwrite it
					if( m_pFileNode->m_pComponentDoc )
					{
						ASSERT( m_pFileNode->m_pIChildNode != NULL );

						// Remove file's notify list
						nl.Detach( m_pFileNode );

						// Notify attached nodes that this file is being replaced
//						theApp.m_pFramework->NotifyNodes( m_pFileNode->m_pIChildNode, FRAMEWORK_FileDeleted, NULL );
						
						// Remove old notify list
//						m_pFileNode->EmptyNotifyNodesList();

						// Remove association with DocRoot before DeleteNode() 
						ASSERT( m_pFileNode->m_pComponentDoc->m_pIDocRootNode != NULL );
						m_pFileNode->m_pComponentDoc->m_pIDocRootNode->Release();
						m_pFileNode->m_pComponentDoc->m_pIDocRootNode = NULL;

						// Remove DocRoot node from Project Tree
						m_pFileNode->m_pIChildNode->DeleteNode( FALSE );
						m_pFileNode->m_pIChildNode->Release();
						m_pFileNode->m_pIChildNode = NULL;
						m_pFileNode->m_hChildItem = NULL;

						// Close the document
						m_pFileNode->m_pComponentDoc->OnCloseDocument();
					}
				}
			}
		}
	}

	// Create a new FileNode
	if( m_pFileNode == NULL )
	{
		fInsertFileNode = TRUE;

		m_pFileNode = new CFileNode;
		if( m_pFileNode == NULL )
		{
			return FALSE;
		}
	}

	if( m_pFileNode->m_pComponentDoc )
	{
		// Nothing to do because file is already open
		// This scenario happens when user dblclks on file
		// in Explorer and restoring Project state opens 
		// the file from within DetermineParentNode called
		// above.
		ASSERT( m_pFileNode->m_pIChildNode != NULL );
		ASSERT( m_pFileNode->m_pComponentDoc != this );
		m_pFileNode = NULL;
		// Sets m_fShellCommandOK flag to TRUE so that app won't shut
		// itself down thinking that the open failed
		theApp.m_fShellCommandOK = TRUE;
		return FALSE;
	}

	m_pFileNode->AddRef();
	m_pFileNode->m_pComponentDoc = this;
//	m_pFileNode->m_pComponentDoc->AddRef();		intentionally missing

	WCHAR awszPathName[MAX_PATH];
	MultiByteToWideChar( CP_ACP, 0, szPathName, -1, awszPathName, (size_t)MAX_PATH );

	// Needed so others can query m_pFileNode->m_fInOnOpenDocument status
	if( fInsertFileNode )
	{
		// Get ListInfo
		CString strFileName = szPathName;
		BSTR bstrFileName = strFileName.AllocSysString();

		IStream* pIStream;
		if( SUCCEEDED ( theApp.m_pFramework->AllocFileStream ( bstrFileName, GENERIC_READ, FT_UNKNOWN,
															   GUID_AllZeros, pIParentNode, &pIStream ) ) )
		{
			DMUSProdListInfo ListInfo;
			ZeroMemory( &ListInfo, sizeof(ListInfo) );
			ListInfo.wSize = sizeof(ListInfo);

			if( SUCCEEDED ( m_pIDocType->GetListInfo ( pIStream, &ListInfo ) ) )
			{
				if( ListInfo.bstrName )
				{
					m_pFileNode->m_strListInfoName = ListInfo.bstrName;
					::SysFreeString( ListInfo.bstrName );
				}
				if( ListInfo.bstrDescriptor )
				{
					m_pFileNode->m_strListInfoDescriptor = ListInfo.bstrDescriptor;
					::SysFreeString( ListInfo.bstrDescriptor );
				}
				memcpy( &m_pFileNode->m_guidListInfoObject, &ListInfo.guidObject, sizeof(GUID) );
			}

			pIStream->Release();
		}
	}

	// Open the file
	IStream* pIStream;
	CString strPathName = szPathName;
	BSTR bstrPathName = strPathName.AllocSysString();

	if( FAILED ( theApp.m_pFramework->AllocFileStream(bstrPathName, GENERIC_READ, FT_UNKNOWN,
													  GUID_AllZeros, pParentDirNode, &pIStream) ) )
	{
		if( fInsertFileNode )
		{
			m_pFileNode->Release();
			m_pFileNode = NULL;
		}
		return FALSE;
	}

	// Get IDMUSProdProject for this file
	if( FAILED ( theApp.m_pFramework->FindProject( pParentDirNode, &pIProject ) ) )
	{
		if( fInsertFileNode )
		{
			m_pFileNode->Release();
			m_pFileNode = NULL;
		}
		pIStream->Release();
		return FALSE;
	}

	// Start tracking File Open
	if( theApp.m_pJzTrackFileOpen == NULL )
	{
		theApp.m_pJzTrackFileOpen = new CJzTrackFileOpen;
	}
	if( theApp.m_pJzTrackFileOpen )
	{
		theApp.m_pJzTrackFileOpen->AddRef();
	}

	CProject* pProject = (CProject *)pIProject;

	// Set state so others can query m_pFileNode->m_fInOnOpenDocument status
	if( fInsertFileNode )
	{
		CString strFileName;
		theApp.SplitOutFileName( szPathName, TRUE, strFileName );
		m_pFileNode->m_strName = strFileName;
		m_pFileNode->SetParentNode( pIParentNode );
		pProject->AddFile( m_pFileNode );
	}
	
	m_pFileNode->m_fInOnOpenDocument = TRUE;
	HRESULT hr = m_pIDocType->OnFileOpen( pIStream, pIProject, pParentDirNode, &m_pIDocRootNode );
	m_pFileNode->m_fInOnOpenDocument = FALSE;

	// File is done loading so reset state
	if( fInsertFileNode )
	{
		pProject->RemoveFile( m_pFileNode );	
	}	

	// Stop tracking File Open
	if( theApp.m_pJzTrackFileOpen )
	{
		theApp.m_pJzTrackFileOpen->Release();
	}

	pIStream->Release();
	pIStream = NULL;
	pIProject->Release();
	pIProject = NULL;

	if( FAILED( hr )
	||  m_pIDocRootNode == NULL )
	{
		if( hr != E_OUTOFMEMORY )
		{
			HINSTANCE hInstance = AfxGetResourceHandle();
			AfxSetResourceHandle( theApp.m_hInstance );

			CString strMsg;
			AfxFormatString1( strMsg, IDS_ERR_NOT_COMPONENT_FILE, szPathName );
			AfxMessageBox( strMsg );

			AfxSetResourceHandle( hInstance );
		}

		if( fInsertFileNode )
		{
			m_pFileNode->Release();
			m_pFileNode = NULL;
		}
		return FALSE;
	}

	// Set the FileNode's child node
	m_pFileNode->InsertChildNode( m_pIDocRootNode );

	// Insert FileNode when necessary
	if( fInsertFileNode )
	{
		if( FAILED ( pIParentNode->InsertChildNode( m_pFileNode ) ) )
		{
			m_pFileNode->DeleteChildNode( m_pIDocRootNode, FALSE );
			if( fInsertFileNode )
			{
				m_pFileNode->Release();
				m_pFileNode = NULL;
			}
			return FALSE;
		}
	}

	// Set the FileNode's name
	CString strFileName;
	theApp.SplitOutFileName( szPathName, TRUE, strFileName );
	BSTR bstrFileName = strFileName.AllocSysString();
	m_pFileNode->SetNodeName( bstrFileName );

	// Add nodes to the Project Tree
	if( SUCCEEDED ( theApp.m_pFramework->AddNode( m_pIDocRootNode, m_pFileNode ) ) )
	{
		CTreeCtrl* pTreeCtrl = theApp.GetProjectTreeCtrl();

		CDirectoryNode* pParentNode = (CDirectoryNode *)pIParentNode;
		if( pParentNode->m_hItem )
		{
			CMainFrame* pMainFrame = (CMainFrame *)theApp.m_pMainWnd;
			ASSERT( pMainFrame != NULL );
			pMainFrame->m_wndTreeBar.SortChildren( pParentNode->m_hItem );
		}

		m_pFileNode->MoveWPListToNodes();
		theApp.CleanUpNotifyLists( m_pFileNode, FALSE );

		if( theApp.m_nShowNodeInTree == SHOW_NODE_IN_TREE )
		{
			if( pTreeCtrl )
			{
				pTreeCtrl->SetFocus();
			}
		}
		theApp.m_pFramework->ShowTreeNode( m_pFileNode );

		if( m_pFileNode->m_hChildItem )
		{
			if( pTreeCtrl )
			{
				if( theApp.m_nShowNodeInTree == SHOW_NODE_IN_TREE )
				{
					pTreeCtrl->EnsureVisible( m_pFileNode->m_hChildItem );
					pTreeCtrl->SelectItem( m_pFileNode->m_hChildItem );
				}
				if( pTreeCtrl->ItemHasChildren(m_pFileNode->m_hChildItem) )
				{
					pTreeCtrl->Expand( m_pFileNode->m_hChildItem, TVE_EXPAND );
				}
			}
		}

		// Attach file's notify list
		// 'nl' list will be empty unless overwriting the file
		// This keeps file references intact when overwriting files
		// linked to other files
		nl.Attach( m_pFileNode );

		// Notify connected nodes that we have successfully loaded
		m_pFileNode->SendLoadFinishedNotifications();

		// FRAMEWORK_AfterFileOpen
		IDMUSProdNotifySink* pINotifySink;
		if( SUCCEEDED ( m_pIDocRootNode->QueryInterface( IID_IDMUSProdNotifySink, (void **)&pINotifySink ) ) )
		{
			pINotifySink->OnUpdate( m_pIDocRootNode, FRAMEWORK_AfterFileOpen, awszPathName );
			pINotifySink->Release();
		}

		return TRUE;
	}

	// Remove the FileNode's child node
	m_pFileNode->DeleteChildNode( m_pIDocRootNode, FALSE );

	// Remove FileNode when necessary
	if( fInsertFileNode )
	{
		pIParentNode->DeleteChildNode( m_pFileNode, FALSE );
		m_pFileNode->Release();
		m_pFileNode = NULL;
	}
	
	return FALSE;
}


/////////////////////////////////////////////////////////////////////////////
// CComponentDoc::OnSaveDocument

BOOL CComponentDoc::OnSaveDocument( LPCTSTR szPathName ) 
{
	ASSERT( szPathName != NULL );
	ASSERT( AfxIsValidString(szPathName) );
	ASSERT( m_pIDocRootNode != NULL );
	ASSERT( m_pFileNode != NULL );

	IStream* pIStream;
	FileType ftFileType;
	GUID guidVersion;
	BOOL fSuccess = FALSE;

	if( theApp.m_nRuntimeSave == DOC_RUNTIME_SAVE
	||  theApp.m_nRuntimeSave == DOC_RUNTIME_SAVE_ALL )
	{
		ftFileType = FT_RUNTIME;
		guidVersion = GUID_CurrentVersion;
	}
	else
	{
		ftFileType = FT_DESIGN;
		guidVersion = GUID_CurrentVersion;
	}

	CString strPathName = szPathName;
	BSTR bstrPathName = strPathName.AllocSysString();

	WCHAR awszPathName[MAX_PATH];
	MultiByteToWideChar( CP_ACP, 0, szPathName, -1, awszPathName, (size_t)MAX_PATH );

	// FRAMEWORK_BeforeFileSave
	IDMUSProdNotifySink* pINotifySink;
	if( SUCCEEDED ( m_pIDocRootNode->QueryInterface( IID_IDMUSProdNotifySink, (void **)&pINotifySink ) ) )
	{
		pINotifySink->OnUpdate( m_pIDocRootNode, FRAMEWORK_BeforeFileSave, awszPathName );
		pINotifySink->Release();
	}

	if( SUCCEEDED ( theApp.m_pFramework->AllocFileStream(bstrPathName, GENERIC_WRITE, ftFileType,
														 guidVersion, NULL, &pIStream) ) )
	{
		CJazzDocTemplate* pDocTemplate = (CJazzDocTemplate *)GetDocTemplate();
		ASSERT( pDocTemplate != NULL );

		IDMUSProdDocType* pIDocType = pDocTemplate->m_pIDocType;
		ASSERT( pIDocType != NULL );

		HRESULT hr = pIDocType->OnFileSave( pIStream, m_pIDocRootNode );

		if( SUCCEEDED ( hr ) )
		{
			fSuccess = TRUE;
		}
		else if( hr == E_NOTIMPL )
		{
			IPersistStream *pIPS;

			m_pIDocRootNode->QueryInterface( IID_IPersistStream, (void **)&pIPS );
			if( pIPS )
			{
				BOOL fClearDirty;

				if( theApp.m_nRuntimeSave == DOC_RUNTIME_SAVE
				||  theApp.m_nRuntimeSave == DOC_RUNTIME_SAVE_ALL )
				{
					fClearDirty = FALSE;
				}
				else
				{
					fClearDirty = TRUE;
				}

				if( SUCCEEDED ( pIPS->Save(pIStream, fClearDirty) ) )
				{
					fSuccess = TRUE;
				}

				pIPS->Release();
			}
		}

		pIStream->Release();
	}

	if( fSuccess )
	{
		// Store the Runtime filename
		if( ftFileType == FT_RUNTIME )
		{
			CString strDefaultRuntimeFile;

			m_pFileNode->ConstructRuntimePath( strDefaultRuntimeFile );
			strDefaultRuntimeFile += m_pFileNode->m_strRuntimeFileName;
			
			// Only store if equal to the default runtime filename
			if( strDefaultRuntimeFile.CompareNoCase( szPathName ) == 0 )
			{
				m_pFileNode->m_strRuntimeFile = szPathName;
			}
		}

		// Refresh Property sheet
		IDMUSProdPropSheet* pIPropSheet = theApp.GetPropertySheet();
		if( pIPropSheet )
		{
			pIPropSheet->RefreshTitleByObject( m_pFileNode );
			pIPropSheet->RefreshActivePageByObject( m_pFileNode );
			pIPropSheet->Release();
		}
	}

	// FRAMEWORK_AfterFileSave
	if( SUCCEEDED ( m_pIDocRootNode->QueryInterface( IID_IDMUSProdNotifySink, (void **)&pINotifySink ) ) )
	{
		pINotifySink->OnUpdate( m_pIDocRootNode, FRAMEWORK_AfterFileSave, awszPathName );
		pINotifySink->Release();
	}

	return fSuccess;
}


/////////////////////////////////////////////////////////////////////////////
// CComponentDoc::CanCloseFrame

BOOL CComponentDoc::CanCloseFrame( CFrameWnd* pFrame ) 
{
	return TRUE;	// Always ok to close a Component Frame
					// CJazzDoc::SaveModified() takes care of SaveModified()
					// for all of the Component documents.

//	return CCommonDoc::CanCloseFrame(pFrame);
}


/////////////////////////////////////////////////////////////////////////////
// CComponentDoc::AppendFilterSuffix

void CComponentDoc::AppendFilterSuffix( CString& filter, OPENFILENAME_NT4& ofn, CString* pstrDefaultExt )
{
	//Get the document's DocTemplate
	CJazzDocTemplate* pDocTemplate = (CJazzDocTemplate *)GetDocTemplate();
	ASSERT_VALID( pDocTemplate );
	ASSERT_KINDOF( CJazzDocTemplate, pDocTemplate );
	ASSERT( pDocTemplate->m_pIDocType != NULL );

	FileType ftFileType = FT_DESIGN;

	if( theApp.m_nRuntimeSave == DOC_RUNTIME_SAVE
	||  theApp.m_nRuntimeSave == DOC_RUNTIME_SAVE_ALL )
	{
		ftFileType = FT_RUNTIME;
	}

	CString strFilterExt, strFilterName;

	if( pDocTemplate->GetDocString( strFilterExt, CDocTemplate::filterExt )
	&&  !strFilterExt.IsEmpty()
	&&  pDocTemplate->GetDocString( strFilterName, CDocTemplate::filterName )
	&&  !strFilterName.IsEmpty() )
	{
		// a file based document template - add to filter list
		ASSERT( strFilterExt[0] == '.' );

		BOOL fContinue = TRUE;
		CString strMyFilter;
		CString strMyExt;
		CString strExt;
		BSTR bstrExt;
		int nFindPos;

		nFindPos = strFilterExt.Find( _T("*") );
		while( fContinue )
		{
			if( nFindPos == -1 )
			{
				fContinue = FALSE;

				nFindPos = strFilterExt.Find( _T(".") );
				if( nFindPos != 0 )
				{
					break;
				}
				strExt = strFilterExt;
			}
			else
			{
				strExt = strFilterExt.Left( nFindPos - 1 );
				strFilterExt = strFilterExt.Right( strFilterExt.GetLength() - (nFindPos + 1) ); 
			}
			bstrExt = strExt.AllocSysString();

			if( pDocTemplate->m_pIDocType->IsFileTypeExtension(ftFileType, bstrExt) == S_OK )
			{
				if( ofn.nFilterIndex == 0 )
				{
					nFindPos = strFilterName.Find( _T("*") );
					if( nFindPos != -1 )
					{
						strMyFilter = strFilterName.Left( nFindPos );
						strMyFilter += (TCHAR)'*';
						strMyFilter += strExt;

						strMyExt += (TCHAR)'*';
						strMyExt += strExt;

						if( pstrDefaultExt != NULL )
						{
							// set the default extension
							*pstrDefaultExt = ((LPCTSTR)strExt) + 1;  // skip the '.'
							ofn.lpstrDefExt = (LPTSTR)(LPCTSTR)(*pstrDefaultExt);
							ofn.nFilterIndex = ofn.nMaxCustFilter + 1;
						}
					}
					ASSERT( strMyFilter.IsEmpty() == FALSE );
					ASSERT( strMyExt.IsEmpty() == FALSE );
				}
				else
				{
					strMyFilter += (TCHAR)';';
					strMyFilter += (TCHAR)'*';
					strMyFilter += strExt;

					strMyExt += (TCHAR)';';
					strMyExt += (TCHAR)'*';
					strMyExt += strExt;
				}

			}

			nFindPos = strFilterExt.Find( _T("*") );
		}

		// add to filter
		filter = strMyFilter;
		ASSERT(!filter.IsEmpty());  // must have a file type name
		filter += (TCHAR)')';		
		filter += (TCHAR)'\0';		// next string please
		filter += strMyExt;
		filter += (TCHAR)'\0';		// next string please
		ofn.nMaxCustFilter++;
	}
}


/////////////////////////////////////////////////////////////////////////////
// CComponentDoc::DoPromptFileSave

BOOL CComponentDoc::DoPromptFileSave( CJazzDocTemplate* pDocTemplate, UINT nResourceID, CString& fileName )
{
	AFX_MANAGE_STATE( AfxGetAppModuleState() );

	ASSERT( m_pFileNode != NULL );
	ASSERT( pDocTemplate != NULL );
	ASSERT_VALID( pDocTemplate );
	
	CFileDialog dlgFile( FALSE );

	CString strTitle;
	VERIFY( strTitle.LoadString( nResourceID ) );

	dlgFile.m_ofn.Flags |= ( OFN_HIDEREADONLY | OFN_PATHMUSTEXIST );

	CString strFilter;
	CString strDefault;

	AppendFilterSuffix( strFilter, dlgFile.m_ofn, &strDefault );

	// Append the "*.*" all files filter
	CString allFilter;
	VERIFY( allFilter.LoadString( AFX_IDS_ALLFILTER ) );
	strFilter += allFilter;
	strFilter += (TCHAR)'\0';   // next string please
	strFilter += _T("*.*");
	strFilter += (TCHAR)'\0';   // last string
	dlgFile.m_ofn.nMaxCustFilter++;

	dlgFile.m_ofn.lpstrFilter = strFilter;
	dlgFile.m_ofn.lpstrTitle = strTitle;
	dlgFile.m_ofn.lpstrFile = fileName.GetBuffer( _MAX_PATH );

	// Get the default directory for this template
	CString strDefaultDir;

	if( theApp.m_nRuntimeSave == DOC_RUNTIME_SAVE
	||  theApp.m_nRuntimeSave == DOC_RUNTIME_SAVE_ALL )
	{
		// Determine default runtime filename
		m_pFileNode->ConstructRuntimePath( strDefaultDir );
	}
	else
	{
		// Split path from filename
		m_pFileNode->ConstructFileName( strDefaultDir );
		int nFindPos = strDefaultDir.ReverseFind( (TCHAR)'\\' );
		if( nFindPos != -1 )
		{
			strDefaultDir = strDefaultDir.Left( nFindPos );
		}
//		theApp.GetDefaultDirForFileSave( dlgFile.m_ofn.lpstrFile, strDefaultDir );
	}
	if( !strDefaultDir.IsEmpty() )
	{
		dlgFile.m_ofn.lpstrInitialDir = strDefaultDir;
	}

	BOOL bResult = dlgFile.DoModal() == IDOK ? TRUE : FALSE;
	fileName.ReleaseBuffer();

	// Store the default directory for the next File Open/Save dialog
	if( bResult )
	{
		if( theApp.m_nRuntimeSave != DOC_RUNTIME_SAVE
		&&  theApp.m_nRuntimeSave != DOC_RUNTIME_SAVE_ALL )
		{
			theApp.SetDefaultDirForFileSave( dlgFile.m_ofn.lpstrFile, NULL );
		}
	}

	return bResult;
}


/////////////////////////////////////////////////////////////////////////////
// CComponentDoc::DetermineDefaultFileName

void CComponentDoc::DetermineDefaultFileName( CString& strName )
{
	int nFindPos;

	strName.Empty();
	
	//Get the document's DocTemplate
	CJazzDocTemplate* pDocTemplate = (CJazzDocTemplate *)GetDocTemplate();
	ASSERT( pDocTemplate != NULL );

	// Determine whether or not a Runtime save
	FileType ftFileType = FT_DESIGN;

	if( theApp.m_nRuntimeSave == DOC_RUNTIME_SAVE
	||  theApp.m_nRuntimeSave == DOC_RUNTIME_SAVE_ALL )
	{
		ftFileType = FT_RUNTIME;
	}

	// Figure out the "proposed" filename
	CString strFileName = GetPathName();
	ASSERT( AfxIsValidString(strFileName) );

	if( (strFileName.IsEmpty())
	||  (ftFileType == FT_RUNTIME) )
	{
		if( strFileName.IsEmpty() )
		{
			strName = GetTitle();

			// check for dubious filename
			int iBad = strName.FindOneOf( _T("%;/\\") );
			if( iBad != -1 )
			{
				strName.ReleaseBuffer( iBad );
			}
		}
		else
		{
			// Get name based on file title of path name
			theApp.SplitOutFileName( strFileName, TRUE, strName );

			// Remove extension
			nFindPos = strName.ReverseFind( (TCHAR)'.' );
			if( nFindPos != -1 )
			{
				strName = strName.Left( nFindPos );
			}
		}

		// append default extension
		if( pDocTemplate->m_pIDocType )
		{
			CString strFilterExt;

			if( pDocTemplate->GetDocString(strFilterExt, CDocTemplate::filterExt)
			&&  !strFilterExt.IsEmpty() )
			{
				ASSERT( strFilterExt[0] == '.' );

				BOOL fContinue = TRUE;
				CString strExt;
				BSTR bstrExt;

				nFindPos = strFilterExt.Find( _T("*") );
				while( fContinue )
				{
					if( nFindPos == -1 )
					{
						fContinue = FALSE;

						nFindPos = strFilterExt.Find( _T(".") );
						if( nFindPos != 0 )
						{
							break;
						}
						strExt = strFilterExt;
					}
					else
					{
						strExt = strFilterExt.Left( nFindPos - 1 );
						strFilterExt = strFilterExt.Right( strFilterExt.GetLength() - (nFindPos + 1) ); 
					}
					bstrExt = strExt.AllocSysString();

					if( pDocTemplate->m_pIDocType->IsFileTypeExtension(ftFileType, bstrExt) == S_OK )
					{
						strName += strExt;
						break;
					}

					nFindPos = strFilterExt.Find( _T("*") );
				}
			}
		}
	}
	else
	{
		// Get name based on file title of path name
		theApp.SplitOutFileName( strFileName, TRUE, strName );
	}
}


/////////////////////////////////////////////////////////////////////////////
// CComponentDoc::DoSave

BOOL CComponentDoc::DoSave( LPCTSTR szPathName, BOOL bReplace )
{
	CString strName;
	CString strPath;
	CString strFileName;
	BOOL fSuccess = FALSE;
	BOOL fContinue = TRUE;
	BOOL fReplace = bReplace;
	BOOL fSaveAs = FALSE;
	int nFindPos;

	ASSERT( m_pFileNode != NULL );
	ASSERT( m_pIDocRootNode != NULL );

	// Get the document's DocTemplate
	CJazzDocTemplate* pDocTemplate = (CJazzDocTemplate *)GetDocTemplate();
	ASSERT( pDocTemplate != NULL );

	if( theApp.m_nRuntimeSave == DOC_RUNTIME_SAVE
	||  theApp.m_nRuntimeSave == DOC_RUNTIME_SAVE_ALL )
	{
		CString strDefaultRuntimeFileName;

		// Runtime files are separate entities that exist outside
		// of the Project.
		// Do not replace document filename or title with "Runtime" filename.
		fReplace = FALSE;

		// Determine default runtime filename
		m_pFileNode->ConstructRuntimePath( strPath );
		strName = m_pFileNode->m_strRuntimeFileName;
		strFileName = strPath + strName;
		strDefaultRuntimeFileName = strFileName;

		// Make sure the path exists
		fContinue = theApp.CreateTheDirectory( strPath );
		if( fContinue )
		{
			// Display 'Save As' dialog for the "Runtime" file
			if( szPathName == NULL
			||  theApp.m_nRuntimeSave == DOC_RUNTIME_SAVE )
			{
				fContinue = DoPromptFileSave( pDocTemplate, IDS_RUNTIME_SAVEAS, strName );
				strFileName = strName;

				// Determine the new "Runtime" default directory
				if( fContinue )
				{
					if( theApp.m_nRuntimeSave == DOC_RUNTIME_SAVE
					||  theApp.m_nRuntimeSave == DOC_RUNTIME_SAVE_ALL )
					{
						if( strFileName.CompareNoCase( strDefaultRuntimeFileName ) != 0 )
						{
							CString strTitle;
							CString strMsg;
							CString strTemp;
							CString strRelativePath;

							strTitle.LoadString( IDS_RUNTIME_DEFAULT_TITLE );

							m_pFileNode->ConstructRelativePath( strRelativePath );
							if( !strRelativePath.IsEmpty() )
							{
								if( strRelativePath.Right(1) != _T("\\") )
								{
									strRelativePath += _T("\\");
								}
							}
							strRelativePath += m_pFileNode->m_strName;

							AfxFormatString1( strMsg, IDS_RUNTIME_DEFAULT_MSG1, strRelativePath );
							AfxFormatString1( strTemp, IDS_RUNTIME_DEFAULT_MSG2, strDefaultRuntimeFileName );
							strMsg += strTemp;
							AfxFormatString1( strTemp, IDS_RUNTIME_DEFAULT_MSG3, strFileName );
							strMsg += strTemp;

							CMainFrame* pMainFrame = (CMainFrame *)theApp.m_pMainWnd;
							ASSERT( pMainFrame != NULL );

							switch( pMainFrame->MessageBox( strMsg, strTitle, MB_YESNOCANCEL ) )
							{
								case IDYES:
									m_pFileNode->LinkToRuntimeFile( strFileName );
									break;

								case IDCANCEL:
									fContinue = FALSE;
									break;
							}
						}
					}
				}
			}
		}
	}
	else
	{
		if( szPathName == NULL )
		{
			// Do not replace design document filename or title with "Save As" filename.
			fReplace = FALSE;
			fSaveAs = TRUE;

			strName = m_pFileNode->m_strName;
			fContinue = DoPromptFileSave( pDocTemplate, AFX_IDS_SAVEFILE, strName );
			strFileName = strName;
		}
		else
		{
			strFileName = szPathName;

			// Make sure the path exists
			nFindPos = strFileName.ReverseFind( (TCHAR)'\\' );
			if( nFindPos != -1 )
			{
				strPath = strFileName.Left( nFindPos + 1 );
				fContinue = theApp.CreateTheDirectory( strPath );
			}
		}
	}

	if( fContinue )
	{
		fSuccess = CCommonDoc::DoSave( strFileName, fReplace );

		if( fSuccess )
		{
			if( fSaveAs )
			{
				// See if the newly created file is in any of the opened Projects
				CProject* pProject = theApp.GetProjectByFileName( strFileName );
				if( pProject )
				{
					// Display the newly created file in the Project Tree
					theApp.OpenTheFile( strFileName, TGT_FILENODE_SAVEAS );
					pProject->Release();
				}
			}

			// Figure out new name for FileNode 
			strFileName = GetPathName();
			ASSERT( AfxIsValidString(strFileName) );

			nFindPos = strFileName.ReverseFind( (TCHAR)'\\' );
			if( nFindPos != -1 )
			{
				strFileName = strFileName.Right( strFileName.GetLength() - nFindPos - 1 );
				if( !strFileName.IsEmpty() )
				{
					theApp.m_pFramework->SetNodeName( m_pFileNode, strFileName );
				}
			}
		}
	}

	return fSuccess;
}


/////////////////////////////////////////////////////////////////////////////
// CComponentDoc::OnFileRuntimeSaveAs

void CComponentDoc::OnFileRuntimeSaveAs() 
{
	theApp.m_nRuntimeSave = DOC_RUNTIME_SAVE;

	DoSave( NULL );

	theApp.m_nRuntimeSave = DOC_NOT_RUNTIME_SAVE;
}


/////////////////////////////////////////////////////////////////////////////
// CComponentDoc::SetPathName

void CComponentDoc::SetPathName( LPCTSTR lpszPathName, BOOL bAddToMRU )
{
	CString strOrigPathName = m_strPathName;

	CCommonDoc::SetPathName( lpszPathName, FALSE );

	if( strOrigPathName.IsEmpty() )
	{
		return;
	}

	if(	theApp.m_fSendFileNameChangeNotification )
	{
		if( m_pFileNode
		&&  m_pFileNode->m_pIChildNode )
		{
			// Notify connected nodes that file name has changed
			theApp.m_pFramework->NotifyNodes( m_pFileNode->m_pIChildNode, FRAMEWORK_FileNameChange, NULL );

			// Notify m_pChildNode that filename has changed
			IDMUSProdNotifySink* pINotifySink;
			if( SUCCEEDED ( m_pFileNode->m_pIChildNode->QueryInterface( IID_IDMUSProdNotifySink, (void **)&pINotifySink ) ) )
			{
				pINotifySink->OnUpdate( m_pFileNode->m_pIChildNode, FRAMEWORK_FileNameChange, NULL );
				pINotifySink->Release();
			}
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\Framework\ComponentView.cpp ===
// ComponentView.cpp : implementation file
//

#include "stdafx.h"
#include "JazzApp.h"
#include "MainFrm.h"
#include "ComponentCntrItem.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CComponentView

IMPLEMENT_DYNCREATE(CComponentView, CView)

CComponentView::CComponentView()
{
	m_pEditorCtrl = NULL;
	m_pINode = NULL;
	m_pIProject = NULL;
	m_pIEditor = NULL;
	m_fSeed = FALSE;
}

CComponentView::~CComponentView()
{
	if( m_pINode )
	{
		m_pINode->Release();
	}

	if( m_pIProject )
	{
		m_pIProject->Release();
	}

	if( m_pIEditor )
	{
		m_pIEditor->Release();
	}
}


BEGIN_MESSAGE_MAP(CComponentView, CView)
	//{{AFX_MSG_MAP(CComponentView)
	ON_WM_SIZE()
	ON_WM_SETFOCUS()
	ON_WM_DESTROY()
	ON_UPDATE_COMMAND_UI(ID_FILE_SAVE, OnUpdateFileSave)
	ON_UPDATE_COMMAND_UI(ID_FILE_SAVE_AS, OnUpdateFileSaveAs)
	ON_UPDATE_COMMAND_UI(ID_FILE_PRINT, OnUpdateFilePrint)
	ON_COMMAND(ID_FILE_PRINT, OnFilePrint)
	ON_UPDATE_COMMAND_UI(ID_FILE_PRINT_PREVIEW, OnUpdateFilePrintPreview)
	ON_COMMAND(ID_FILE_PRINT_PREVIEW, OnFilePrintPreview)
	ON_UPDATE_COMMAND_UI(ID_FILE_PRINT_SETUP, OnUpdateFilePrintSetup)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CComponentView drawing

void CComponentView::OnInitialUpdate()
{
	CView::OnInitialUpdate();

	m_pEditorCtrl = NULL;
}

void CComponentView::OnDraw(CDC* pDC)
{
	CComponentDoc* pDoc = GetDocument();
	ASSERT_VALID( pDoc );
}


/////////////////////////////////////////////////////////////////////////////
// OLE Client support and commands

BOOL CComponentView::IsSelected(const CObject* pDocItem) const
{
	// The implementation below is adequate if your selection consists of
	//  only CComponentCntrItem objects.  To handle different selection
	//  mechanisms, the implementation here should be replaced.

	// TODO: implement this function that tests for a selected OLE client item

	return pDocItem == m_pEditorCtrl;
}

/////////////////////////////////////////////////////////////////////////////
// CComponentView diagnostics

#ifdef _DEBUG
void CComponentView::AssertValid() const
{
	AFX_MANAGE_STATE( AfxGetAppModuleState() );
	CView::AssertValid();
}

void CComponentView::Dump(CDumpContext& dc) const
{
	CView::Dump(dc);
}
#endif //_DEBUG


//////////////////////////////////////////////////////////////////////////////
// CComponentView::GetDocument

CComponentDoc* CComponentView::GetDocument() // non-debug version is inline
{
	ASSERT( m_pDocument->IsKindOf(RUNTIME_CLASS(CComponentDoc)) );

	return (CComponentDoc*)m_pDocument;
}


/////////////////////////////////////////////////////////////////////////////
// CComponentView message handlers

//////////////////////////////////////////////////////////////////////////////
// CComponentView::OnSize

void CComponentView::OnSize( UINT nType, int cx, int cy ) 
{
	CView::OnSize(nType, cx, cy);

	COleClientItem* pActiveItem = GetDocument()->GetInPlaceActiveItem( this );

	if( pActiveItem != NULL )
	{
		CRect rect;

		GetClientRect( &rect );
		pActiveItem->SetItemRects( &rect );
	}
}


//////////////////////////////////////////////////////////////////////////////
// CComponentView::OnSetFocus

void CComponentView::OnSetFocus( CWnd* pOldWnd ) 
{
	CView::OnSetFocus( pOldWnd );
}


//////////////////////////////////////////////////////////////////////////////
// CComponentView::OnDestroy

void CComponentView::OnDestroy() 
{
	// Save Editor WindowPlacement
	if( m_pINode )
	{
		CTreeCtrl* pTreeCtrl = theApp.GetProjectTreeCtrl();
		if( pTreeCtrl )
		{
			HTREEITEM hItem = theApp.m_pFramework->FindTreeItem( m_pINode );
			if( hItem )
			{
				CJzNode* pJzNode = (CJzNode *)pTreeCtrl->GetItemData( hItem );
				if( pJzNode )
				{
					CFrameWnd* pFrame = GetParentFrame();
					if( pFrame )
					{
						pJzNode->m_wp.length = sizeof(pJzNode->m_wp);
						if( pFrame->GetWindowPlacement( &pJzNode->m_wp ) == 0 )
						{
							ZeroMemory( &pJzNode->m_wp, sizeof(pJzNode->m_wp) );
						}
					}
				}
			}
		}
	}

	CView::OnDestroy();

	CComponentDoc* pDoc = GetDocument();
	ASSERT_VALID( pDoc );

	if( m_pEditorCtrl )
	{
		m_pEditorCtrl->Release( OLECLOSE_NOSAVE );  // release OLE object
		pDoc->RemoveItem( m_pEditorCtrl );				// disconnect from document
		m_pEditorCtrl->InternalRelease();			// may 'delete m_pEditorCtrl'
	}
	
	if( m_pINode )
	{
		m_pINode->SetEditorWindow( NULL );
	}
}


//////////////////////////////////////////////////////////////////////////////
// CComponentView::OnUpdate

void CComponentView::OnUpdate( CView* pSender, LPARAM lHint, CObject* pHint ) 
{
	if( lHint == 1 )
	{
		// PChannel name just changed
		RedrawWindow( NULL, NULL, RDW_INVALIDATE | RDW_UPDATENOW | RDW_ALLCHILDREN );
	}
	else
	{
		CView::OnUpdate( pSender, lHint, pHint );
	}
}


//////////////////////////////////////////////////////////////////////////////
// CComponentView::OnActivateView

void CComponentView::OnActivateView( BOOL bActivate, CView* pActivateView, CView* pDeactiveView ) 
{
	CView::OnActivateView( bActivate, pActivateView, pDeactiveView );
}


//////////////////////////////////////////////////////////////////////////////
// CComponentView::OnUpdateFileSave

void CComponentView::OnUpdateFileSave( CCmdUI* pCmdUI ) 
{
	CString strMenuText;
	CString strMenuHotKey;

	strMenuText.LoadString( IDS_SAVE_MENU_TEXT );
	strMenuHotKey.LoadString( IDS_SAVE_MENU_HOTKEY );

	if( m_pINode )
	{
		CString strFileName;
		
		CComponentDoc* pDoc = (CComponentDoc* )GetDocument();
		strFileName = pDoc->GetPathName();
		
		if( strFileName.IsEmpty() == FALSE )
		{
			int nFindPos = strFileName.ReverseFind( (TCHAR)'\\' );
			if( nFindPos != -1 )
			{
				strFileName = strFileName.Right( strFileName.GetLength() - nFindPos - 1 );
			}
			strMenuText += _T(" ");
			strMenuText += strFileName;
			strMenuText += strMenuHotKey;
			pCmdUI->SetText( strMenuText );
			pCmdUI->Enable( TRUE );
			return;
		}
	}

	strMenuText += strMenuHotKey;
	pCmdUI->SetText( strMenuText );
	pCmdUI->Enable( FALSE );
}


//////////////////////////////////////////////////////////////////////////////
// CComponentView::OnUpdateFileSaveAs

void CComponentView::OnUpdateFileSaveAs( CCmdUI* pCmdUI ) 
{
	CString strMenuText;

	if( m_pINode )
	{
		CString strFileName;
		
		CComponentDoc* pDoc = (CComponentDoc* )GetDocument();
		strFileName = pDoc->GetPathName();
		
		if( strFileName.IsEmpty() == FALSE )
		{
			int nFindPos = strFileName.ReverseFind( (TCHAR)'\\' );
			if( nFindPos != -1 )
			{
				strFileName = strFileName.Right( strFileName.GetLength() - nFindPos - 1 );
			}

			AfxFormatString1( strMenuText, IDS_SAVEAS_MENU_TEXT, strFileName );
			pCmdUI->SetText( strMenuText );
			pCmdUI->Enable( TRUE );
			return;
		}
	}

	AfxFormatString1( strMenuText, IDS_SAVEAS_MENU_TEXT, _T("") );
	pCmdUI->SetText( strMenuText );
	pCmdUI->Enable( FALSE );
}


//////////////////////////////////////////////////////////////////////////////
// CComponentView::OnUpdateFilePrint

void CComponentView::OnUpdateFilePrint( CCmdUI* pCmdUI ) 
{
	ASSERT( m_pIEditor != NULL );
	
	UINT nFlags = MF_DISABLED;

	if( m_pIEditor )
	{
		if( pCmdUI->m_pMenu )
		{
			m_pIEditor->OnInitMenuFilePrint( pCmdUI->m_pMenu->GetSafeHmenu(), ID_FILE_PRINT );
			nFlags = pCmdUI->m_pMenu->GetMenuState( ID_FILE_PRINT, MF_BYCOMMAND );
		}
	}

	// Following done to prevent MFC from overriding values set in OnInitMenuFilePrint()
	if( nFlags & MF_DISABLED
	||  nFlags & MF_GRAYED )
	{
		pCmdUI->Enable( FALSE );
	}
	else
	{
		pCmdUI->Enable( TRUE );
	}
}


//////////////////////////////////////////////////////////////////////////////
// CComponentView::OnFilePrint

void CComponentView::OnFilePrint() 
{
	ASSERT( m_pIEditor != NULL );
	
	if( m_pIEditor )
	{
		m_pIEditor->OnFilePrint();
	}
}


//////////////////////////////////////////////////////////////////////////////
// CComponentView::OnUpdateFilePrintPreview

void CComponentView::OnUpdateFilePrintPreview( CCmdUI* pCmdUI ) 
{
	ASSERT( m_pIEditor != NULL );
	
	UINT nFlags = MF_DISABLED;

	if( m_pIEditor )
	{
		if( pCmdUI->m_pMenu )
		{
			m_pIEditor->OnInitMenuFilePrintPreview( pCmdUI->m_pMenu->GetSafeHmenu(), ID_FILE_PRINT_PREVIEW );
			nFlags = pCmdUI->m_pMenu->GetMenuState( ID_FILE_PRINT_PREVIEW, MF_BYCOMMAND );
		}
	}

	// Following done to prevent MFC from overriding values set in OnInitMenuFilePrint()
	if( nFlags & MF_DISABLED
	||  nFlags & MF_GRAYED )
	{
		pCmdUI->Enable( FALSE );
	}
	else
	{
		pCmdUI->Enable( TRUE );
	}
}


//////////////////////////////////////////////////////////////////////////////
// CComponentView::OnFilePrintPreview

void CComponentView::OnFilePrintPreview() 
{
	ASSERT( m_pIEditor != NULL );
	
	if( m_pIEditor )
	{
		m_pIEditor->OnFilePrintPreview();
	}
}


//////////////////////////////////////////////////////////////////////////////
// CComponentView::OnUpdateFilePrintSetup

void CComponentView::OnUpdateFilePrintSetup( CCmdUI* pCmdUI ) 
{
	// Only enable 'Print Setup' if editor can print something
	OnUpdateFilePrint( pCmdUI );
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\Framework\ComponentView.h ===
#ifndef __COMPONENTVIEW_H__
#define __COMPONENTVIEW_H__

// ComponentView.h : header file
//

class CComponentDoc;
class CComponentCntrItem;

/////////////////////////////////////////////////////////////////////////////
// CComponentView view

class CComponentView : public CView
{
public:
	CComponentView();           // protected constructor used by dynamic creation
	virtual ~CComponentView();
	DECLARE_DYNCREATE(CComponentView)

// Attributes
public:
	IDMUSProdNode*	  m_pINode;
	IDMUSProdProject* m_pIProject;
	IDMUSProdEditor*  m_pIEditor;
	BOOL			  m_fSeed;	// view created from File Open/New
								// this view needs to stick around
								// until document is being destroyed
// Operations
public:
	CComponentDoc* GetDocument();
	// m_pSelection holds the selection to the current CBassCntrItem.
	// For many applications, such a member variable isn't adequate to
	//  represent a selection, such as a multiple selection or a selection
	//  of objects that are not CBassCntrItem objects.  This selection
	//  mechanism is provided just to help you get started.

	CComponentCntrItem* m_pEditorCtrl;

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CComponentView)
	public:
	virtual BOOL IsSelected(const CObject* pDocItem) const;
	protected:
	virtual void OnDraw(CDC* pDC);      // overridden to draw this view
	virtual void OnInitialUpdate();     // first time after construct
	virtual void OnActivateView(BOOL bActivate, CView* pActivateView, CView* pDeactiveView);
	virtual void OnUpdate(CView* pSender, LPARAM lHint, CObject* pHint);
	//}}AFX_VIRTUAL

// Implementation
protected:
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

	// Generated message map functions
	//{{AFX_MSG(CComponentView)
	afx_msg void OnSize(UINT nType, int cx, int cy);
	afx_msg void OnSetFocus(CWnd* pOldWnd);
	afx_msg void OnDestroy();
	afx_msg void OnUpdateFileSave(CCmdUI* pCmdUI);
	afx_msg void OnUpdateFileSaveAs(CCmdUI* pCmdUI);
	afx_msg void OnUpdateFilePrint(CCmdUI* pCmdUI);
	afx_msg void OnFilePrint();
	afx_msg void OnUpdateFilePrintPreview(CCmdUI* pCmdUI);
	afx_msg void OnFilePrintPreview();
	afx_msg void OnUpdateFilePrintSetup(CCmdUI* pCmdUI);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // __COMPONENTVIEW_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\Framework\DeleteFileDlg.cpp ===
// DeleteFileDlg.cpp : implementation file
//

#include "stdafx.h"
#include "JazzApp.h"
#include "DeleteFileDlg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CDeleteFileDlg dialog


CDeleteFileDlg::CDeleteFileDlg(CWnd* pParent /*=NULL*/)
	: CDialog(CDeleteFileDlg::IDD, pParent)
{
	//{{AFX_DATA_INIT(CDeleteFileDlg)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT
}


void CDeleteFileDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CDeleteFileDlg)
	DDX_Control(pDX, IDC_PROMPT, m_staticPrompt);
	DDX_Control(pDX, IDC_LISTBOX_FILES, m_listFiles);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CDeleteFileDlg, CDialog)
	//{{AFX_MSG_MAP(CDeleteFileDlg)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CDeleteFileDlg message handlers

BOOL CDeleteFileDlg::OnInitDialog() 
{
	CDialog::OnInitDialog();

	ASSERT( m_pFileNode != NULL );
	
	CString strText;

	AfxFormatString1( strText, IDS_PROMPT_DELETE_FILE, m_pFileNode->m_strName );
	m_staticPrompt.SetWindowText( strText );

	CJzNotifyNode* pJzNotifyNode;
	CFileNode* pFileNode;
	CDC* pDC;
	CSize sizeText;
	int nCurExtent;

	// Add files to listbox
	POSITION pos = m_pFileNode->m_lstNotifyNodes.GetHeadPosition();
	while( pos )
	{
		pJzNotifyNode = static_cast<CJzNotifyNode*>( m_pFileNode->m_lstNotifyNodes.GetNext(pos) );
		
		pFileNode = theApp.GetFileByGUID( pJzNotifyNode->m_guidFile );
		if( pFileNode )
		{
			pFileNode->ConstructFileName( strText );
			m_listFiles.AddString( strText );
			pFileNode->Release();
			pFileNode = NULL;

			// Set horizontal extent
			nCurExtent = m_listFiles.GetHorizontalExtent();

			pDC = m_listFiles.GetDC();
			if( pDC )
			{
				sizeText = pDC->GetTextExtent( strText );

				if( sizeText.cx > nCurExtent )
				{
					m_listFiles.SetHorizontalExtent( sizeText.cx );
				}

				m_listFiles.ReleaseDC( pDC );
			}
		}
	}
	
	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\Framework\ComponentDoc.h ===
#ifndef __COMPONENTDOC_H__
#define __COMPONENTDOC_H__

// ComponentDoc.h : header file
//

#ifndef OPENFILENAME_NT4
#define OPENFILENAME_NT4 OPENFILENAME
#endif

class CComponentView;

/////////////////////////////////////////////////////////////////////////////
// CComponentDoc document

class CComponentDoc : public CCommonDoc
{
friend class CFileNode;

protected:
	CComponentDoc();			// protected constructor used by dynamic creation
	DECLARE_DYNCREATE(CComponentDoc)

// Attributes
public:
	CFileNode*		  m_pFileNode;
	IDMUSProdDocType* m_pIDocType;
	BYTE			  m_bAction;	// Doc being 1=deleted or 2=reverted

// Overrides
public:
	virtual BOOL DoSave( LPCTSTR szPathName, BOOL bReplace = TRUE );

// Operations
public:
	void OpenEditorWindow( IDMUSProdNode* pINode );
	void CloseAllViews( BOOL fAutoDelete );
	BOOL CloseViewsByNode( IDMUSProdNode* pINode );
	BOOL SaveAndCloseDoc();
	BOOL SaveComponentFileIfModified();
	BOOL RevertDocument();

private:
	CFrameWnd* CreateNewWindow( IDMUSProdNode* pINode );
	void AppendFilterSuffix( CString& filter, OPENFILENAME_NT4& ofn, CString* pstrDefaultExt );
	BOOL DoPromptFileSave( CJazzDocTemplate* pDocTemplate, UINT nResourceID, CString& fileName );
	void DetermineDefaultFileName( CString& strName );

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CComponentDoc)
	public:
	virtual void SetPathName(LPCTSTR lpszPathName, BOOL bAddToMRU = TRUE);
	virtual void Serialize(CArchive& ar);   // overridden for document i/o
	virtual BOOL OnOpenDocument(LPCTSTR szPathName);
	virtual BOOL OnSaveDocument(LPCTSTR szPathName);
	virtual BOOL CanCloseFrame(CFrameWnd* pFrame);
	virtual BOOL IsModified();
	protected:
	virtual BOOL OnNewDocument();
	virtual BOOL SaveModified();
	//}}AFX_VIRTUAL

// Implementation
public:
	virtual ~CComponentDoc();
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

	// Generated message map functions
protected:
	//{{AFX_MSG(CComponentDoc)
	afx_msg void OnFileRuntimeSaveAs();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // __COMPONENTDOC_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\Framework\DeleteProjectDlg.cpp ===
// DeleteProjectDlg.cpp : implementation file
//

#include "stdafx.h"
#include "JazzApp.h"
#include "DeleteProjectDlg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CDeleteProjectDlg dialog


CDeleteProjectDlg::CDeleteProjectDlg(CWnd* pParent /*=NULL*/)
	: CDialog(CDeleteProjectDlg::IDD, pParent)
{
	//{{AFX_DATA_INIT(CDeleteProjectDlg)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT

	m_pProject = NULL;
	m_nWhichFiles = DPF_NO_FILES;
	m_fRuntimePrompt = FALSE;
}


void CDeleteProjectDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CDeleteProjectDlg)
	DDX_Control(pDX, IDC_PROMPT_RUNTIME, m_checkRuntimePrompt);
	DDX_Control(pDX, IDOK, m_btnOK);
	DDX_Control(pDX, IDC_DESIGN_FILES, m_radioDesignFiles);
	DDX_Control(pDX, IDC_ALL_FILES, m_radioAllFiles);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CDeleteProjectDlg, CDialog)
	//{{AFX_MSG_MAP(CDeleteProjectDlg)
	ON_BN_CLICKED(IDC_ALL_FILES, OnAllFiles)
	ON_BN_CLICKED(IDC_DESIGN_FILES, OnDesignFiles)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CDeleteProjectDlg message handlers

/////////////////////////////////////////////////////////////////////////////
// CDeleteProjectDlg::OnInitDialog

BOOL CDeleteProjectDlg::OnInitDialog() 
{
	ASSERT( m_pProject != NULL );
	
	CDialog::OnInitDialog();
	
	CString strText;

	AfxFormatString1( strText, IDS_DELETE_ALL_FILES1, m_pProject->m_strName );
	m_radioDesignFiles.SetWindowText( strText );

	AfxFormatString1( strText, IDS_DELETE_ALL_FILES2, m_pProject->m_strName );
	m_radioAllFiles.SetWindowText( strText );

	m_radioDesignFiles.SetCheck( 1 );
	
	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}


/////////////////////////////////////////////////////////////////////////////
// CDeleteProjectDlg::OnAllFiles

void CDeleteProjectDlg::OnAllFiles() 
{
	m_checkRuntimePrompt.EnableWindow( TRUE );
}


/////////////////////////////////////////////////////////////////////////////
// CDeleteProjectDlg::OnDesignFiles

void CDeleteProjectDlg::OnDesignFiles() 
{
	m_checkRuntimePrompt.EnableWindow( FALSE );
}


/////////////////////////////////////////////////////////////////////////////
// CDeleteProjectDlg::OnOK

void CDeleteProjectDlg::OnOK() 
{
	if( m_radioAllFiles.GetCheck() == 1 )
	{
		m_nWhichFiles = DPF_ALL_FILES; 

		if( m_checkRuntimePrompt.GetCheck() == 1 )
		{
			m_fRuntimePrompt = TRUE;
		}
	}
	else if( m_radioDesignFiles.GetCheck() == 1 )
	{
		m_nWhichFiles = DPF_DESIGN_FILES; 
	}
	
	CDialog::OnOK();
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\Framework\DeleteFileDlg.h ===
#if !defined(AFX_DELETEFILEDLG_H__5E922342_3044_11D1_89AE_00A0C9054129__INCLUDED_)
#define AFX_DELETEFILEDLG_H__5E922342_3044_11D1_89AE_00A0C9054129__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// DeleteFileDlg.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CDeleteFileDlg dialog

class CDeleteFileDlg : public CDialog
{
// Construction
public:
	CDeleteFileDlg(CWnd* pParent = NULL);   // standard constructor

// Dialog Data
	//{{AFX_DATA(CDeleteFileDlg)
	enum { IDD = IDD_DELETE_FILE };
	CStatic	m_staticPrompt;
	CListBox	m_listFiles;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CDeleteFileDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Member variables
public:
	CFileNode*	m_pFileNode;

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CDeleteFileDlg)
	virtual BOOL OnInitDialog();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_DELETEFILEDLG_H__5E922342_3044_11D1_89AE_00A0C9054129__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\Framework\DeleteProjectDlg.h ===
#if !defined(AFX_DELETEPROJECTDLG_H__9EA7A743_707F_11D1_89AE_00A0C9054129__INCLUDED_)
#define AFX_DELETEPROJECTDLG_H__9EA7A743_707F_11D1_89AE_00A0C9054129__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif

// _MSC_VER >= 1000
// DeleteProjectDlg.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CDeleteProjectDlg dialog

class CDeleteProjectDlg : public CDialog
{
// Construction
public:
	CDeleteProjectDlg(CWnd* pParent = NULL);   // standard constructor

// Dialog Data
	//{{AFX_DATA(CDeleteProjectDlg)
	enum { IDD = IDD_DELETEPROJECT };
	CButton	m_checkRuntimePrompt;
	CButton	m_btnOK;
	CButton	m_radioDesignFiles;
	CButton	m_radioAllFiles;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CDeleteProjectDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Member variables
public:
	CProject*	m_pProject;
	short		m_nWhichFiles;
	BOOL		m_fRuntimePrompt;

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CDeleteProjectDlg)
	virtual BOOL OnInitDialog();
	afx_msg void OnAllFiles();
	afx_msg void OnDesignFiles();
	virtual void OnOK();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_DELETEPROJECTDLG_H__9EA7A743_707F_11D1_89AE_00A0C9054129__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\Framework\EditLabel.cpp ===
// EditLabel.cpp : implementation file
//

#include "stdafx.h"
#include "JazzApp.h"
#include "EditLabel.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


/////////////////////////////////////////////////////////////////////////////
// CEditLabel

CEditLabel::CEditLabel( IDMUSProdNode* pINode )
{
	ASSERT( pINode != NULL );

	m_pINode = pINode;
}

CEditLabel::~CEditLabel()
{
}


BEGIN_MESSAGE_MAP(CEditLabel, CEdit)
	//{{AFX_MSG_MAP(CEditLabel)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// CEditLabel message handlers

/////////////////////////////////////////////////////////////////////////////
// CEditLabel::PreTranslateMessage

BOOL CEditLabel::PreTranslateMessage( MSG* pMsg ) 
{
	switch( pMsg->message )
	{
		case WM_KEYUP:
			{
				CTreeCtrl* pTreeCtrl = theApp.GetProjectTreeCtrl();

				if( pTreeCtrl )
				{
					switch( pMsg->wParam )
					{
						case VK_ESCAPE:
							pTreeCtrl->PostMessage( TVM_ENDEDITLABELNOW, TRUE, 0 );
							return TRUE;
					}
				}
			}
			break;

		case WM_KEYDOWN:
			if( !(pMsg->lParam & 0x40000000) )
			{
				CTreeCtrl* pTreeCtrl = theApp.GetProjectTreeCtrl();

				if( pTreeCtrl )
				{
					switch( pMsg->wParam )
					{
						case VK_RETURN:
							pTreeCtrl->PostMessage( TVM_ENDEDITLABELNOW, FALSE, 0 );
							return TRUE;

						case VK_ESCAPE:
							pTreeCtrl->PostMessage( TVM_ENDEDITLABELNOW, TRUE, 0 );
							return TRUE;

						case 0x43:  // VK_C
							if( GetAsyncKeyState(VK_CONTROL) & 0x8000 )
							{
								Copy();
							}
							return FALSE;

						case 0x56:	// VK_V
							if( GetAsyncKeyState(VK_CONTROL) & 0x8000 )
							{
								Paste();
							}
							return FALSE;

						case 0x58:	// VK_X
							if( GetAsyncKeyState(VK_CONTROL) & 0x8000 )
							{
								Cut();
							}
							return FALSE;

						case 0x5A:	// VK_Z
							if( GetAsyncKeyState(VK_CONTROL) & 0x8000 )
							{
								BSTR bstrNodeName;

								if( SUCCEEDED ( m_pINode->GetNodeName( &bstrNodeName ) ) )
								{
									SetSel( 0, -1 );
									ReplaceSel( CString(bstrNodeName) );
									::SysFreeString( bstrNodeName );
									SetSel( 0, -1 );
								}
							}
							return FALSE;
					}
				}
			}
			break;
	}
	
	return CEdit::PreTranslateMessage( pMsg );
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\Framework\DirectoryNode.cpp ===
// DirectoryNode.cpp: implementation of the CDirectoryNode class.
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "JazzApp.h"
#include "MainFrm.h"
#include "direct.h"
#include "Timeline.h"
#include "StripMgr.h"
#include "DLSDesigner.h"
#include "SegmentDesigner.h"

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#define new DEBUG_NEW
#endif


// {3B119360-CBAE-11d0-89AE-00A0C9054129}
const GUID GUID_DirectoryNode = 
{ 0x3b119360, 0xcbae, 0x11d0, { 0x89, 0xae, 0x0, 0xa0, 0xc9, 0x5, 0x41, 0x29 } };


//////////////////////////////////////////////////////////////////////
// CDirectoryNode Construction/Destruction
//////////////////////////////////////////////////////////////////////

CDirectoryNode::CDirectoryNode()
{
    m_dwRef = 0;

	m_pIParentNode = NULL;
	m_hItem = NULL;
}

CDirectoryNode::~CDirectoryNode()
{
	IDMUSProdNode* pINode;

	while( !m_lstNodes.IsEmpty() )
	{
		pINode = static_cast<IDMUSProdNode*>( m_lstNodes.RemoveHead() );
		if( pINode )
		{
			DeleteChildNode( pINode, FALSE );
			pINode->Release();
		}
	}
}


/////////////////////////////////////////////////////////////////////////////
// CDirectoryNode IUnknown implementation

HRESULT CDirectoryNode::QueryInterface( REFIID riid, LPVOID FAR* ppvObj )
{
	AFX_MANAGE_STATE( AfxGetAppModuleState() );

    if( ::IsEqualIID(riid, IID_IDMUSProdNode)
	||  ::IsEqualIID(riid, IID_IUnknown) )
    {
        AddRef();
        *ppvObj = (IDMUSProdNode *)this;
        return S_OK;
    }

    if( ::IsEqualIID(riid, IID_IDMUSProdPropPageObject) )
    {
		IDMUSProdProject* pIProject; 

		if( SUCCEEDED ( theApp.m_pFramework->FindProject( this, &pIProject ) ) )
		{
			HRESULT hr = pIProject->QueryInterface( riid, ppvObj );
			pIProject->Release();
			return hr;
		}

		*ppvObj = NULL;
		return E_NOINTERFACE;
    }

    *ppvObj = NULL;
    return E_NOINTERFACE;
}

ULONG CDirectoryNode::AddRef()
{
	AFX_MANAGE_STATE( AfxGetAppModuleState() );

    return ++m_dwRef;
}

ULONG CDirectoryNode::Release()
{
	AFX_MANAGE_STATE( AfxGetAppModuleState() );

    ASSERT( m_dwRef != 0 );

    --m_dwRef;

    if( m_dwRef == 0 )
    {
        delete this;
        return 0;
    }

    return m_dwRef;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectoryNode IDMUSProdNode implementation

/////////////////////////////////////////////////////////////////////////////
// CDirectoryNode IDMUSProdNode::GetNodeImageIndex

HRESULT CDirectoryNode::GetNodeImageIndex( short* pnFirstImage )
{
	AFX_MANAGE_STATE( AfxGetAppModuleState() );

	// Store directory path
	CString strPath;
	ConstructPath( strPath );
	
	// See if this directory contains a Producer Project
	WIN32_FIND_DATA	fd;
	TCHAR achFileMask[_MAX_PATH + 1];

	wsprintf( achFileMask, "%s%s.pro", strPath, m_strName );

	HANDLE hFind = FindFirstFile( achFileMask, &fd );
	if( hFind == INVALID_HANDLE_VALUE )
	{
		// Directory does not contain a Producer Project
		*pnFirstImage = theApp.m_nFirstImage + FIRST_DIRECTORY_IMAGE;
	}
	else
	{
		// Directory contains a Producer Project
		*pnFirstImage = theApp.m_nFirstImage + FIRST_PROJECT_IMAGE;
		FindClose( hFind );
	}

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectoryNode IDMUSProdNode::GetFirstChild

HRESULT CDirectoryNode::GetFirstChild( IDMUSProdNode** ppIFirstChildNode )
{
	AFX_MANAGE_STATE( AfxGetAppModuleState() );

	if( ppIFirstChildNode == NULL )
	{
		return E_POINTER;
	}
	
	*ppIFirstChildNode = NULL;

	if( !m_lstNodes.IsEmpty() )
	{
		IDMUSProdNode* pINode = static_cast<IDMUSProdNode*>( m_lstNodes.GetHead() );
		
		if( pINode )
		{
			pINode->AddRef();
			*ppIFirstChildNode = pINode;
		}
	}

    return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectoryNode IDMUSProdNode::GetNextChild

HRESULT CDirectoryNode::GetNextChild( IDMUSProdNode* pIChildNode, IDMUSProdNode** ppINextChildNode )
{
	AFX_MANAGE_STATE( AfxGetAppModuleState() );

	if( ppINextChildNode == NULL )
	{
		return E_POINTER;
	}
	
	*ppINextChildNode = NULL;

	if( pIChildNode == NULL )
	{
		return E_INVALIDARG;
	}

	IDMUSProdNode* pINode;

    POSITION pos = m_lstNodes.GetHeadPosition();

    while( pos )
    {
        pINode = m_lstNodes.GetNext( pos );
		if( pINode == pIChildNode )
		{
			if( pos )
			{
				pINode = m_lstNodes.GetNext( pos );

				pINode->AddRef();
				*ppINextChildNode = pINode;
			}
			break;
		}
    }

    return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectoryNode IDMUSProdNode::GetComponent

HRESULT CDirectoryNode::GetComponent( IDMUSProdComponent** ppIComponent )
{
//	AFX_MANAGE_STATE( AfxGetAppModuleState() );

    return E_NOTIMPL;	// DirectoryNode node is not associated with a Component
}


/////////////////////////////////////////////////////////////////////////////
// CDirectoryNode IDMUSProdNode::GetDocRootNode

HRESULT CDirectoryNode::GetDocRootNode( IDMUSProdNode** ppIDocRootNode )
{
//	AFX_MANAGE_STATE( AfxGetAppModuleState() );

    return E_NOTIMPL;	// DirectoryNode node is not associated with a Document
}


/////////////////////////////////////////////////////////////////////////////
// CDirectoryNode IDMUSProdNode::SetDocRootNode

HRESULT CDirectoryNode::SetDocRootNode( IDMUSProdNode* pIDocRootNode )
{
//	AFX_MANAGE_STATE( AfxGetAppModuleState() );

    return E_NOTIMPL;	// DirectoryNode node is not associated with a Document
}


/////////////////////////////////////////////////////////////////////////////
// CDirectoryNode IDMUSProdNode::GetParentNode

HRESULT CDirectoryNode::GetParentNode( IDMUSProdNode** ppIParentNode )
{
	AFX_MANAGE_STATE( AfxGetAppModuleState() );

	ASSERT( m_pIParentNode != NULL );

	if( ppIParentNode == NULL )
	{
		return E_POINTER;
	}

	m_pIParentNode->AddRef();
	*ppIParentNode = m_pIParentNode;

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectoryNode IDMUSProdNode::SetParentNode

HRESULT CDirectoryNode::SetParentNode( IDMUSProdNode* pIParentNode )
{
	AFX_MANAGE_STATE( AfxGetAppModuleState() );

	ASSERT( pIParentNode != NULL );

	if( pIParentNode == NULL )
	{
		return E_INVALIDARG;
	}

	m_pIParentNode = pIParentNode;
//	m_pIParentNode->AddRef();		intentionally missing

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectoryNode IDMUSProdNode::GetNodeId

HRESULT CDirectoryNode::GetNodeId( GUID* pguid )
{
	AFX_MANAGE_STATE( AfxGetAppModuleState() );

	if( pguid == NULL )
	{
		return E_POINTER;
	}

	*pguid = GUID_DirectoryNode;

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectoryNode IDMUSProdNode::GetNodeName

HRESULT CDirectoryNode::GetNodeName( BSTR* pbstrName )
{
	AFX_MANAGE_STATE( AfxGetAppModuleState() );

	if( pbstrName == NULL )
	{
		return E_POINTER;
	}

    *pbstrName = m_strName.AllocSysString();

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectoryNode IDMUSProdNode::GetNodeNameMaxLength

HRESULT CDirectoryNode::GetNodeNameMaxLength( short* pnMaxLength )
{
	AFX_MANAGE_STATE( AfxGetAppModuleState() );

	if( pnMaxLength == NULL )
	{
		return E_POINTER;
	}

	*pnMaxLength = MAX_LENGTH_DIR_NAME;

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectoryNode IDMUSProdNode::ValidateNodeName

HRESULT CDirectoryNode::ValidateNodeName( BSTR bstrName )
{
	AFX_MANAGE_STATE( AfxGetAppModuleState() );

	CString strName = bstrName;
	::SysFreeString( bstrName );

	int iBad = strName.FindOneOf( _T("\\/:*?\"<>;|#%") );
	if( iBad != -1 )
	{
		AfxMessageBox( IDS_ERR_FOLDER_CHAR );
		return S_FALSE;
	}

	// Determine node's old filename
	CString strOldPathName;
	ConstructPath( strOldPathName );

	// Store original name
	CString strOrigName = m_strName;
	m_strName = strName;

	// Determine node's new filename
	CString strNewPathName;
	ConstructPath( strNewPathName );

	// restore original name
	m_strName = strOrigName;

	if( strNewPathName.GetLength() >= _MAX_DIR )
	{
		AfxMessageBox( IDS_ERR_FILENAME_LENGTH );
		return S_FALSE;
	}

	// Make sure we aren't trying to rename the current directory
	TCHAR achCurrentDir[_MAX_PATH + 1];
	DWORD dwNbrBytes = ::GetCurrentDirectory( _MAX_PATH, achCurrentDir );
	if( (dwNbrBytes > 0) 
	&&  (dwNbrBytes < _MAX_PATH) )
	{
		CString strCurrentDir = achCurrentDir;
		strCurrentDir +=  + (TCHAR)'\\';

		if( _tcsicmp( strCurrentDir, strOldPathName ) == 0 )
		{
			int nFindPos = strCurrentDir.ReverseFind( (TCHAR)'\\' );
			if( nFindPos != -1 )
			{
				strCurrentDir = strCurrentDir.Left( nFindPos );

				nFindPos = strCurrentDir.ReverseFind( (TCHAR)'\\' );
				if( nFindPos != -1 )
				{
					strCurrentDir = strCurrentDir.Left( nFindPos );
					::SetCurrentDirectory( strCurrentDir );
				}
			}
		}
	}

	// Notify connected nodes filenames are about to change
	if(	theApp.m_fSendFileNameChangeNotification )
	{
		NotifyAllFiles( FRAMEWORK_BeforeFileNameChange );
	}

	// Rename node directory to the new path
	if( theApp.RenameThePath(strOldPathName, strNewPathName, strOldPathName) == FALSE )
	{
		// Notify connected nodes filename change was aborted
		if(	theApp.m_fSendFileNameChangeNotification )
		{
			NotifyAllFiles( FRAMEWORK_AbortFileNameChange );
		}
		return S_FALSE;
	}

	// Adjust Project Folders
	IDMUSProdProject* pIProject;

	if( SUCCEEDED ( theApp.m_pFramework->FindProject( this, &pIProject ) ) )
	{
		CProject* pProject = (CProject *)pIProject;

		// Update path to affected Project folders
		pProject->AdjustProjectFolders( strOldPathName, strNewPathName );

		pIProject->Release();
	}

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectoryNode IDMUSProdNode::SetNodeName

HRESULT CDirectoryNode::SetNodeName( BSTR bstrName )
{
	AFX_MANAGE_STATE( AfxGetAppModuleState() );

	CString strName = bstrName;
	::SysFreeString( bstrName );

	// Change node name
	m_strName = strName;

	// Rename path to all open documents
	IDMUSProdProject* pIProject;

	if( SUCCEEDED ( theApp.m_pFramework->FindProject( this, &pIProject ) ) )
	{
		CProject* pProject = (CProject *)pIProject;

		// Update path to all open documents
		pProject->RenameOpenDocuments();

		pIProject->Release();
	}

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectoryNode IDMUSProdNode::GetNodeListInfo

HRESULT CDirectoryNode::GetNodeListInfo( DMUSProdListInfo* pListInfo )
{
//	AFX_MANAGE_STATE( AfxGetAppModuleState() );

	return E_NOTIMPL;
}

	
/////////////////////////////////////////////////////////////////////////////
// CDirectoryNode IDMUSProdNode::GetEditorClsId

HRESULT CDirectoryNode::GetEditorClsId( CLSID* pClsId )
{
//	AFX_MANAGE_STATE( AfxGetAppModuleState() );

	return E_NOTIMPL;	// DirectoryNode is not associated with an editor
}


/////////////////////////////////////////////////////////////////////////////
// CDirectoryNode IDMUSProdNode::GetEditorTitle

HRESULT CDirectoryNode::GetEditorTitle( BSTR* pbstrTitle )
{
//	AFX_MANAGE_STATE( AfxGetAppModuleState() );

	return E_NOTIMPL;	// DirectoryNode is not associated with an editor
}


/////////////////////////////////////////////////////////////////////////////
// CDirectoryNode IDMUSProdNode::GetEditorWindow

HRESULT CDirectoryNode::GetEditorWindow( HWND* hWndEditor )
{
//	AFX_MANAGE_STATE( AfxGetAppModuleState() );

	return E_NOTIMPL;	// DirectoryNode is not associated with an editor
}


/////////////////////////////////////////////////////////////////////////////
// CDirectoryNode IDMUSProdNode::SetEditorWindow

HRESULT CDirectoryNode::SetEditorWindow( HWND hWndEditor )
{
//	AFX_MANAGE_STATE( AfxGetAppModuleState() );

	return E_NOTIMPL;	// DirectoryNode is not associated with an editor
}


/////////////////////////////////////////////////////////////////////////////
// CDirectoryNode IDMUSProdNode::UseOpenCloseImages

HRESULT CDirectoryNode::UseOpenCloseImages( BOOL* pfUseOpenCloseImages )
{
	AFX_MANAGE_STATE( AfxGetAppModuleState() );

	if( pfUseOpenCloseImages == NULL )
	{
		return E_POINTER;
	}

	*pfUseOpenCloseImages = TRUE;

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectoryNode IDMUSProdNode::GetRightClickMenuId

HRESULT CDirectoryNode::GetRightClickMenuId( HINSTANCE* phInstance, UINT* pnMenuId )
{
	AFX_MANAGE_STATE( AfxGetAppModuleState() );

	*phInstance = AfxGetResourceHandle();
	*pnMenuId   = IDM_DIRECTORY_NODE_RMENU;

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectoryNode IDMUSProdNode::OnRightClickMenuInit

HRESULT CDirectoryNode::OnRightClickMenuInit( HMENU hMenu )
{
	AFX_MANAGE_STATE( AfxGetAppModuleState() );

	CMainFrame* pMainFrame = (CMainFrame *)theApp.m_pMainWnd;
	ASSERT( pMainFrame != NULL );

	CMenu menu;

	if( menu.Attach(hMenu) )
	{
		// IDM_IMPORT_MID, IDM_IMPORT_WAV, IDM_IMPORT_WAV_VAR and IDM_IMPORT_SEC
		IDMUSProdComponent* pIComponent;
		if( SUCCEEDED ( theApp.m_pFramework->FindComponent( CLSID_SegmentComponent, &pIComponent ) ) )
		{
			menu.EnableMenuItem( 5, (MF_ENABLED | MF_BYPOSITION) );
			pIComponent->Release();

			if( SUCCEEDED ( theApp.m_pFramework->FindComponent( CLSID_DLSComponent, &pIComponent ) ) )
			{
				menu.EnableMenuItem( IDM_IMPORT_WAV, (MF_ENABLED | MF_BYCOMMAND) );
				menu.EnableMenuItem( IDM_IMPORT_WAV_VAR, (MF_ENABLED | MF_BYCOMMAND) );
				pIComponent->Release();
			}
			else
			{
				menu.EnableMenuItem( IDM_IMPORT_WAV, (MF_GRAYED | MF_BYCOMMAND) );
				menu.EnableMenuItem( IDM_IMPORT_WAV_VAR, (MF_GRAYED | MF_BYCOMMAND) );
			}
		}
		else
		{
			menu.EnableMenuItem( 5, (MF_GRAYED | MF_BYPOSITION) );
		}
		
		// IDM_PASTE
		{
			IDataObject* pIDataObject;
			BOOL fWillSetReference;

			menu.EnableMenuItem( IDM_PASTE, (MF_GRAYED | MF_BYCOMMAND) );

			if( SUCCEEDED ( ::OleGetClipboard( &pIDataObject ) ) )
			{
				if( CanPasteFromData( pIDataObject, &fWillSetReference ) == S_OK )
				{
					menu.EnableMenuItem( IDM_PASTE, (MF_ENABLED | MF_BYCOMMAND) );
				}
				
				pIDataObject->Release();
			}
		}

		// IDM_SORT_FILENAME, IDM_SORT_FILETYPE and IDM_SORT_FILESIZE
		int nTreeSortType = pMainFrame->m_wndTreeBar.GetSortType();
		menu.CheckMenuItem( IDM_SORT_FILENAME, (nTreeSortType == TREE_SORTBY_NAME) ? MF_CHECKED : MF_UNCHECKED );
		menu.CheckMenuItem( IDM_SORT_FILETYPE, (nTreeSortType == TREE_SORTBY_TYPE) ? MF_CHECKED : MF_UNCHECKED );
		menu.CheckMenuItem( IDM_SORT_FILESIZE, (nTreeSortType == TREE_SORTBY_SIZE) ? MF_CHECKED : MF_UNCHECKED );

		menu.Detach();
	}

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectoryNode IDMUSProdNode::OnRightClickMenuSelect

HRESULT CDirectoryNode::OnRightClickMenuSelect( long lCommandId )
{
	AFX_MANAGE_STATE( AfxGetAppModuleState() );

	CMainFrame* pMainFrame = (CMainFrame *)theApp.m_pMainWnd;
	ASSERT( pMainFrame != NULL );

	HRESULT hr = E_FAIL;

	switch( lCommandId )
	{
		case IDM_NEW:
			theApp.OnFileNew();
			hr = S_OK;
			break;

		case IDM_INSERT_FILE:
			theApp.OnFileOpen();
			hr = S_OK;
			break;

		case IDM_NEWFOLDER:
			NewFolder();
			hr = S_OK;
			break;

		case IDM_IMPORT_MID:
			theApp.OnImportMid();
			hr = S_OK;
			break;

		case IDM_IMPORT_WAV:
			theApp.OnImportWav();
			hr = S_OK;
			break;

		case IDM_IMPORT_WAV_VAR:
			theApp.OnImportWavVariations();
			hr = S_OK;
			break;

		case IDM_IMPORT_SEC:
			theApp.OnImportSec();
			hr = S_OK;
			break;

		case IDM_PASTE:
			pMainFrame->m_wndTreeBar.OnEditPaste();
			hr = S_OK;
			break;

		case IDM_RENAME:
			if( SUCCEEDED ( theApp.m_pFramework->EditNodeLabel((IDMUSProdNode *)this) ) )
			{
				hr = S_OK;
			}
			break;

		case IDM_DELETE:
			if( pMainFrame->m_wndTreeBar.DeleteTreeNode( this, DTN_PROMPT_USER ) )
			{
				hr = S_OK;
			}
			break;

		case IDM_SORT_FILENAME:
			pMainFrame->m_wndTreeBar.SetSortType( TREE_SORTBY_NAME );
			hr = S_OK;
			break;

		case IDM_SORT_FILETYPE:
			pMainFrame->m_wndTreeBar.SetSortType( TREE_SORTBY_TYPE );
			hr = S_OK;
			break;

		case IDM_SORT_FILESIZE:
			pMainFrame->m_wndTreeBar.SetSortType( TREE_SORTBY_SIZE );
			hr = S_OK;
			break;

		case IDM_PROPERTIES:
		{
			IDMUSProdProject* pIProject;

			if( SUCCEEDED ( theApp.m_pFramework->FindProject( this, &pIProject ) ) )
			{
				CProject* pProject = (CProject *)pIProject;

				pProject->OnShowProperties();

				pIProject->Release();
				hr = S_OK;
			}
			break;
		}
	}

	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectoryNode IDMUSProdNode::DeleteChildNode

HRESULT CDirectoryNode::DeleteChildNode( IDMUSProdNode* pIChildNode, BOOL fPromptUser )
{
	AFX_MANAGE_STATE( AfxGetAppModuleState() );

	ASSERT( pIChildNode != NULL );

	if( pIChildNode == NULL )
	{
		return E_INVALIDARG;
	}

	GUID guidNodeId;

	if( FAILED ( pIChildNode->GetNodeId( &guidNodeId ) ) )
	{
		return E_FAIL;
	}

	if( !IsEqualGUID (guidNodeId, GUID_DirectoryNode)
	&&  !IsEqualGUID (guidNodeId, GUID_FileNode) )
	{
		return E_INVALIDARG;
	}

	if( IsEqualGUID ( guidNodeId, GUID_FileNode ) )
	{
		CFileNode* pFileNode = (CFileNode *)pIChildNode;

		if( pFileNode->m_pIChildNode )
		{
			GUID guidUpdateType;

			if( theApp.m_fDeleteFromTree )
			{
				guidUpdateType = FRAMEWORK_FileDeleted;
			}
			else
			{
				guidUpdateType = FRAMEWORK_FileClosed;
			}

			CJzNotifyNode* pJzNotifyNode;
			IDMUSProdNotifySink* pINotifySink;

			// Notify connected nodes that file is being removed from Project Tree
			POSITION pos = pFileNode->m_lstNotifyNodes.GetHeadPosition();
			while( pos != NULL )
			{
				pJzNotifyNode = static_cast<CJzNotifyNode*>( pFileNode->m_lstNotifyNodes.GetNext(pos) );
				if( pJzNotifyNode->m_pINotifyThisNode )
				{
					if( SUCCEEDED ( pJzNotifyNode->m_pINotifyThisNode->QueryInterface( IID_IDMUSProdNotifySink, (void **)&pINotifySink ) ) )
					{
						pINotifySink->OnUpdate( pFileNode->m_pIChildNode, guidUpdateType, NULL );
						pINotifySink->Release();
					}
				}
			}
		}

		// Cleanup m_lstNotifyNodes
		pFileNode->EmptyNotifyNodesList();

		if( pFileNode->m_pProject )
		{
			// Remove from CProject file list
			pFileNode->m_pProject->RemoveFile( pFileNode );
		}

		pFileNode->ReleaseDocument();
	}

	// Remove node from Project Tree
	theApp.m_pFramework->RemoveNode( pIChildNode, fPromptUser );

	// Remove from CDirectoryNode Node list
	POSITION pos = m_lstNodes.Find( pIChildNode );
	if( pos )
	{
		m_lstNodes.RemoveAt( pos );
		pIChildNode->Release();
	}

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectoryNode IDMUSProdNode::InsertChildNode

HRESULT CDirectoryNode::InsertChildNode( IDMUSProdNode* pIChildNode )
{
	AFX_MANAGE_STATE( AfxGetAppModuleState() );

	ASSERT( pIChildNode != NULL );

	if( pIChildNode == NULL )
	{
		return E_INVALIDARG;
	}

	GUID guidNodeId;

	if( FAILED ( pIChildNode->GetNodeId( &guidNodeId ) ) )
	{
		return E_FAIL;
	}

	if( !IsEqualGUID (guidNodeId, GUID_DirectoryNode)
	&&  !IsEqualGUID (guidNodeId, GUID_FileNode) )
	{
		return E_INVALIDARG;
	}

	pIChildNode->AddRef();

	// Add to CDirectoryNode Node list
	m_lstNodes.AddTail( pIChildNode );

	// Set parent node
	pIChildNode->SetParentNode( (IDMUSProdNode *)this );

	if( IsEqualGUID ( guidNodeId, GUID_FileNode ) )
	{
		IDMUSProdProject* pIProject;

		if( SUCCEEDED ( theApp.m_pFramework->FindProject( this, &pIProject ) ) )
		{
			CProject* pProject = (CProject *)pIProject;
			CFileNode* pFileNode = (CFileNode *)pIChildNode;

			// Add to CProject file list
			pProject->AddFile( pFileNode );

			pIProject->Release();
		}
		else
		{
			return E_FAIL;
		}
	}

	// Add node to Project Tree
	if( FAILED ( theApp.m_pFramework->AddNode(pIChildNode, (IDMUSProdNode *)this) ) )
	{
		DeleteChildNode( pIChildNode, FALSE );
		return E_FAIL;
	}

	if( IsEqualGUID ( guidNodeId, GUID_DirectoryNode ) )
	{
		// Create directory on hard drive
		CDirectoryNode* pDirNode = (CDirectoryNode *)pIChildNode;
		CString strPath;
		pDirNode->ConstructPath( strPath );
		theApp.CreateTheDirectory( strPath );
	}

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectoryNode IDMUSProdNode::DeleteNode

HRESULT CDirectoryNode::DeleteNode( BOOL fPromptUser )
{
	AFX_MANAGE_STATE( AfxGetAppModuleState() );

	IDMUSProdNode* pIParentNode;

	if( SUCCEEDED ( GetParentNode(&pIParentNode) ) )
	{
		if( pIParentNode )
		{
			HRESULT hr = pIParentNode->DeleteChildNode( this, fPromptUser );
			pIParentNode->Release();
			return hr;
		}
	}

	return E_FAIL;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectoryNode IDMUSProdNode::OnNodeSelChanged

HRESULT CDirectoryNode::OnNodeSelChanged( BOOL fSelected )
{
	AFX_MANAGE_STATE( AfxGetAppModuleState() );

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectoryNode IDMUSProdNode::GetObject

HRESULT CDirectoryNode::GetObject( REFCLSID rclsid, REFIID riid, void** ppvObject )
{
//	AFX_MANAGE_STATE( AfxGetAppModuleState() );

	return E_NOTIMPL;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectoryNode IDMUSProdNode::CreateDataObject

HRESULT CDirectoryNode::CreateDataObject( IDataObject** ppIDataObject )
{
	AFX_MANAGE_STATE( AfxGetAppModuleState() );

	if( ppIDataObject == NULL )
	{
		return E_POINTER;
	}

	*ppIDataObject = NULL;

	return E_NOTIMPL;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectoryNode IDMUSProdNode::CanCut

HRESULT CDirectoryNode::CanCut( void )
{
//	AFX_MANAGE_STATE( AfxGetAppModuleState() );

	return S_FALSE;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectoryNode IDMUSProdNode::CanCopy

HRESULT CDirectoryNode::CanCopy( void )
{
//	AFX_MANAGE_STATE( AfxGetAppModuleState() );

	return S_FALSE;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectoryNode IDMUSProdNode::CanDelete

HRESULT CDirectoryNode::CanDelete( void )
{
//	AFX_MANAGE_STATE(_afxModuleAddrThis);

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectoryNode IDMUSProdNode::CanDeleteChildNode

HRESULT CDirectoryNode::CanDeleteChildNode( IDMUSProdNode* pIChildNode )
{
//	AFX_MANAGE_STATE( AfxGetAppModuleState() );

	// Should not get here!
	ASSERT( 0 );

	return E_NOTIMPL;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectoryNode IDMUSProdNode::CanPasteFromData

HRESULT CDirectoryNode::CanPasteFromData( IDataObject* pIDataObject, BOOL* pfWillSetReference )
{
	AFX_MANAGE_STATE( AfxGetAppModuleState() );
	
	if( pfWillSetReference == NULL )
	{
		return E_POINTER;
	}

	*pfWillSetReference = FALSE;

	if( pIDataObject == NULL )
	{
		return E_INVALIDARG;
	}

	// If data object has one of the registered file clipboard formats
	if( theApp.m_pFramework->FindFileClipFormat( pIDataObject ) )
	{
		// It must also have a CF_DMUSPROD_FILE format
		CAppJazzDataObject* pDataObject = new CAppJazzDataObject();
		if( pDataObject )
		{
			HRESULT hr = pDataObject->IsClipFormatAvailable( pIDataObject, theApp.m_pFramework->m_cfProducerFile );
			pDataObject->Release();
			
			if( SUCCEEDED ( hr ) )
			{
				return S_OK;
			}
		}

		return S_FALSE;
	}

	// Directory node can also paste a CF_DMUSPROD_FILE
	// without one of the registered file clipboard formats
	CAppJazzDataObject* pDataObject = new CAppJazzDataObject();
	if( pDataObject )
	{
		HRESULT hr = pDataObject->IsClipFormatAvailable( pIDataObject, theApp.m_pFramework->m_cfProducerFile );
		pDataObject->Release();
		
		if( SUCCEEDED ( hr ) )
		{
			return S_OK;
		}
	}

	return S_FALSE;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectoryNode IDMUSProdNode::GetPasteFileName

HRESULT CDirectoryNode::GetPasteFileName( CFProducerFile* pcfProducerFile, CString& strFileName )
{
	if( pcfProducerFile == NULL )
	{
		return E_INVALIDARG;
	}

	// Determine path of File
	CString strPath;

	theApp.m_nFileTarget = TGT_SELECTEDNODE;
	IDMUSProdNode* pIDirNode = theApp.m_pFramework->DetermineParentNode( NULL );
	theApp.m_nFileTarget = TGT_PROJECT;

	if( pIDirNode )
	{
		GUID guidNodeId;
		if( SUCCEEDED ( pIDirNode->GetNodeId( &guidNodeId ) ) )
		{
			if( IsEqualGUID ( guidNodeId, GUID_ProjectFolderNode )
			||  IsEqualGUID ( guidNodeId, GUID_DirectoryNode ) )
			{
				CDirectoryNode* pDirNode = (CDirectoryNode *)pIDirNode;
				pDirNode->ConstructPath( strPath );
			}
		}
	}

	if( strPath.IsEmpty() )
	{
		return E_FAIL;
	}

	int nFindPos = pcfProducerFile->strFileName.ReverseFind( (TCHAR)'.' );
	if( nFindPos == -1 )
	{
		return E_FAIL;
	}

	// Extract the filename's name
	CString strName = pcfProducerFile->strFileName.Left( nFindPos );

	// Extract the filename's extension
	CString strExt = pcfProducerFile->strFileName.Right( pcfProducerFile->strFileName.GetLength() - nFindPos );

	// Determine proposed filename
	CString strProposedFileName = strPath + strName + strExt;
	
	// Make sure we have a unique filename
	CString strFName;

	theApp.GetUniqueFileName( strProposedFileName, strFName );
	strFileName = strPath + strFName;

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectoryNode IDMUSProdNode::PasteOpenFile

HRESULT CDirectoryNode::PasteOpenFile( CFProducerFile* pcfProducerFile, IStream* pIMemStream, IDMUSProdDocType* pIDocType )
{
	HRESULT hr;

	if( pcfProducerFile == NULL
	||  pIMemStream == NULL
	||  pIDocType == NULL )
	{
		return E_INVALIDARG;
	}

	// Get file's name
	CString strFileName;

	if( FAILED ( GetPasteFileName( pcfProducerFile, strFileName ) ) )
	{
		return E_FAIL;
	}

	// Get the original file's name
	CString strOrigFileName;

	CFileNode* pFileNode = theApp.GetFileByGUID( pcfProducerFile->guidFile );
	if( pFileNode )
	{
		pFileNode->ConstructFileName( strOrigFileName );
		pFileNode->Release();
		pFileNode = NULL;
	}

	// Paste the file
	STATSTG			statstg;
	ULARGE_INTEGER	uliSizeOut, uliSizeRead, uliSizeWritten;

	// Get pIMemStream's size
	hr = pIMemStream->Stat( &statstg, STATFLAG_NONAME );
	if( FAILED( hr ) )
	{
		return E_FAIL;
	}
	uliSizeOut = statstg.cbSize;

	// Get an IStream pointer to the file we are creating for the paste
	IStream* pIStream;

	BSTR bstrFileName = strFileName.AllocSysString();

	if( SUCCEEDED ( theApp.m_pFramework->AllocFileStream(bstrFileName, GENERIC_WRITE, FT_DESIGN,
					GUID_CurrentVersion, NULL, &pIStream) ) )
	{
		// Copy pIMemStream into pIStream
		hr = pIMemStream->CopyTo( pIStream, uliSizeOut, &uliSizeRead, &uliSizeWritten );
		pIStream->Release();

		if( FAILED( hr )
		||  uliSizeRead.QuadPart != uliSizeOut.QuadPart
		||  uliSizeWritten.QuadPart != uliSizeOut.QuadPart )
		{

			// If the storage ran out of space, return STG_E_MEDIUMFULL, otherwise just return E_FAIL
			if( hr == STG_E_MEDIUMFULL )
			{
				return hr;
			}
			return E_FAIL;
		}

		// Now open the file to create a document and place it in the Project Tree
		CComponentDoc* pComponentDoc = (CComponentDoc *)theApp.OpenTheFile( strFileName, TGT_SELECTEDNODE );

		// If filename has been altered, sync the object name
		if( pComponentDoc
		&&  pComponentDoc->m_pIDocRootNode )
		{
			// Extract the filename's name
			CString strNewName = strFileName;
			int nFindPos = strNewName.ReverseFind( (TCHAR)'.' );
			if( nFindPos != -1 )
			{
				strNewName = strNewName.Left( nFindPos );
				nFindPos = strNewName.ReverseFind( (TCHAR)'\\' );
				if( nFindPos != -1 )
				{
					strNewName = strNewName.Right( strNewName.GetLength() - nFindPos - 1 );
				}
			}

			// Extract the original filename's name
			CString strOrigName = strOrigFileName;
			nFindPos = strOrigName.ReverseFind( (TCHAR)'.' );
			if( nFindPos != -1 )
			{
				strOrigName = strOrigName.Left( nFindPos );
				nFindPos = strOrigName.ReverseFind( (TCHAR)'\\' );
				if( nFindPos != -1 )
				{
					strOrigName = strOrigName.Right( strOrigName.GetLength() - nFindPos - 1 );
				}
			}

			// Has filename been altered to make it unique?
			if( strNewName.CompareNoCase( strOrigName ) != 0 )
			{
				// Does current name equal original filename?
				BSTR bstrName;
				if( SUCCEEDED ( pComponentDoc->m_pIDocRootNode->GetNodeName( &bstrName ) ) )
				{
					CString strName = bstrName;
					::SysFreeString( bstrName );

					if( strName.CompareNoCase( strOrigName ) == 0 )
					{
						// Set object's name to the new filename
						bstrName = strNewName.AllocSysString();
						pComponentDoc->m_pIDocRootNode->SetNodeName( bstrName );
						theApp.m_pFramework->RefreshNode( pComponentDoc->m_pIDocRootNode );
					}
				}
			}
		}
	}

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectoryNode IDMUSProdNode::PasteShutFile

HRESULT CDirectoryNode::PasteShutFile( CFProducerFile* pcfProducerFile )
{
	if( pcfProducerFile == NULL )
	{
		return E_INVALIDARG;
	}

	// Get the new file's name
	CString strFileName;

	if( FAILED ( GetPasteFileName( pcfProducerFile, strFileName ) ) )
	{
		return E_FAIL;
	}

	// Get the original file's name
	CString strOrigFileName;

	CFileNode* pFileNode = theApp.GetFileByGUID( pcfProducerFile->guidFile );
	if( pFileNode )
	{
		pFileNode->ConstructFileName( strOrigFileName );
		pFileNode->Release();
		pFileNode = NULL;
	}
	if( strOrigFileName.IsEmpty() )
	{
		return E_FAIL;
	}

	// Copy the file
	if( theApp.CopyTheFile( strOrigFileName, strFileName, TRUE ) )
	{
		// Create the new FileNode
		CFileNode* pNewFileNode = new CFileNode;
		
		if( pNewFileNode )
		{
			int nFindPos = strFileName.ReverseFind( (TCHAR)'\\' );
			if( nFindPos != -1 )
			{
				strFileName = strFileName.Right( strFileName.GetLength() - nFindPos - 1 );
			}

			// Add file to Project Tree
			pNewFileNode->m_strName = strFileName;
			InsertChildNode( pNewFileNode );
			pNewFileNode->m_strName.Empty();

			BSTR bstrFileName = strFileName.AllocSysString();
			pNewFileNode->SetNodeName( bstrFileName );

			// Sync List info
			pNewFileNode->SyncListInfo();

			return S_OK;
		}
	}

	return E_FAIL;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectoryNode IDMUSProdNode::PasteFromData

HRESULT CDirectoryNode::PasteFromData( IDataObject* pIDataObject )
{
	AFX_MANAGE_STATE( AfxGetAppModuleState() );

	if( pIDataObject == NULL )
	{
		return E_INVALIDARG;
	}

	IStream* pIStream = NULL;

	// Read CF_DMUSPROD_FILE information
	BOOL fCF_DMUSPROD_FILE = FALSE;
	CFProducerFile cfProducerFile;

	if( SUCCEEDED ( theApp.m_pFramework->LoadClipFormat( pIDataObject, theApp.m_pFramework->m_cfProducerFile, &pIStream ) ) )
	{
		if( SUCCEEDED ( theApp.m_pFramework->LoadCF_DMUSPROD_FILE( pIStream, &cfProducerFile ) ) )
		{
			fCF_DMUSPROD_FILE = TRUE;
		}

		pIStream->Release();
		pIStream = NULL;
	}

	if( fCF_DMUSPROD_FILE == FALSE )
	{
		return E_FAIL;
	}

	// Get stream of file data (if present)
	BOOL fFileStream = FALSE;
	IDMUSProdDocType* pIDocType = NULL;

	UINT uClipFormat = theApp.m_pFramework->FindFileClipFormat( pIDataObject );
	if( uClipFormat )
	{
		if( SUCCEEDED ( theApp.m_pFramework->LoadClipFormat( pIDataObject, uClipFormat, &pIStream ) ) )
		{
			if( SUCCEEDED ( theApp.m_pFramework->FindDocTypeByClipFormat( uClipFormat, &pIDocType ) ) )
			{
				fFileStream = TRUE;
			}
		}
	}

	HRESULT hr = E_FAIL;

	// Paste the file
	if( fFileStream )
	{
		// Adjust filename
		CString strExt;

		if( SUCCEEDED ( theApp.m_pFramework->FindExtensionByClipFormat( uClipFormat, strExt ) ) )
		{
			int nFindPos = cfProducerFile.strFileName.ReverseFind( (TCHAR)'.' );
			if( nFindPos != -1 )
			{
				cfProducerFile.strFileName = cfProducerFile.strFileName.Left( nFindPos );
			}
			cfProducerFile.strFileName += strExt;
		}

		// Do the paste
		hr = PasteOpenFile( &cfProducerFile, pIStream, pIDocType );
		pIStream->Release();
		pIDocType->Release();
	}
	else
	{
		hr = PasteShutFile( &cfProducerFile );
	}

	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectoryNode IDMUSProdNode::CanChildPasteFromData

HRESULT CDirectoryNode::CanChildPasteFromData( IDataObject* pIDataObject, IDMUSProdNode* pIChildNode,
											   BOOL* fWillSetReference )
{
//	AFX_MANAGE_STATE( AfxGetAppModuleState() );

	// Should not get here!
	ASSERT( 0 );

	return E_NOTIMPL;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectoryNode IDMUSProdNode::ChildPasteFromData

HRESULT CDirectoryNode::ChildPasteFromData( IDataObject* pIDataObject, IDMUSProdNode* pIChildNode )
{
//	AFX_MANAGE_STATE( AfxGetAppModuleState() );

	// Should not get here!
	ASSERT( 0 );

	return E_NOTIMPL;
}


/////////////////////////////////////////////////////////////////////////////
// Additional methods

/////////////////////////////////////////////////////////////////////////////
// CDirectoryNode DeleteDirectoryToRecycleBin

BOOL CDirectoryNode::DeleteDirectoryToRecycleBin( void )
{
	IDMUSProdNode* pINode;
	GUID guidNodeId;

	theApp.DoWaitCursor( TRUE );

	CMainFrame* pMainFrame = (CMainFrame *)theApp.m_pMainWnd;
	ASSERT( pMainFrame != NULL );

	BOOL fAllFilesDeleted = TRUE;

	// Store directory path
	CString strDir;
	ConstructPath( strDir );
	
	// Delete each file in the directory
	POSITION pos = m_lstNodes.GetHeadPosition();
	while( pos != NULL )
	{
		pINode = static_cast<IDMUSProdNode*>( m_lstNodes.GetNext(pos) );
		pINode->AddRef();

		pINode->GetNodeId( &guidNodeId );

		// Delete sub-directory
		if( ::IsEqualGUID ( guidNodeId, GUID_DirectoryNode ) )
		{
			CDirectoryNode* pDirNode = (CDirectoryNode *)pINode;

			fAllFilesDeleted = pDirNode->DeleteDirectoryToRecycleBin();
		}

		// Delete file
		else if( ::IsEqualGUID ( guidNodeId, GUID_FileNode ) )
		{
			CFileNode* pFileNode = (CFileNode *)pINode;

			CJzNotifyNode* pJzNotifyNode;
			CFileNode* pNotifyFileNode;
			CString strFileName;
			WORD wFlags = 0;

			// Set wFlags to DTN_PROMPT_REFERENCES if pFileNode referenced by a file in another directory
			POSITION pos = pFileNode->m_lstNotifyNodes.GetHeadPosition();
			while( pos )
			{
				pJzNotifyNode = static_cast<CJzNotifyNode*>( pFileNode->m_lstNotifyNodes.GetNext(pos) );
				
				pNotifyFileNode = theApp.GetFileByGUID( pJzNotifyNode->m_guidFile );
				if( pNotifyFileNode )
				{
					pNotifyFileNode->ConstructFileName( strFileName );

					if( strFileName.Find( strDir ) != 0 )
					{
						wFlags = DTN_PROMPT_REFERENCES;
					}

					pNotifyFileNode->Release();
				}
			}
			
			if( pMainFrame->m_wndTreeBar.DeleteTreeNode( pFileNode, wFlags ) == FALSE )
			{
				fAllFilesDeleted = FALSE;
			}

			theApp.DoWaitCursor( TRUE );
		}

		pINode->Release();
	}

	// Delete this Directory
	if( fAllFilesDeleted )
	{
		// Delete directory node
		theApp.m_fDeleteFromTree = TRUE;
		if( SUCCEEDED ( DeleteNode( FALSE ) ) )
		{
			// Delete directory from hard drive
			theApp.DeleteEmptyDirToRecycleBin( strDir );
		}
		theApp.m_fDeleteFromTree = FALSE;
	}

	theApp.DoWaitCursor( FALSE );

	return fAllFilesDeleted;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectoryNode ConstructPath

void CDirectoryNode::ConstructPath( CString& strPath )
{
	strPath.Empty();

	CString strName;
	BSTR bstrName;

	GUID guidNodeId;
	IDMUSProdNode* pINode = this;

	while( pINode )
	{
		strName.Empty();

		if( SUCCEEDED ( pINode->GetNodeId( &guidNodeId ) ) )
		{
			if( IsEqualGUID ( guidNodeId, GUID_ProjectFolderNode ) )
			{
				CProject* pProject = (CProject *)pINode;
				strName = pProject->m_strProjectDir;
			}
			else
			{
				if( SUCCEEDED ( pINode->GetNodeName( &bstrName ) ) )
				{
					strName = bstrName;
					::SysFreeString( bstrName );
				}
			}
		}

		if( !strName.IsEmpty() )
		{
			if( strName.Right(1) != _T("\\") )
			{
				strName += _T("\\");
			}

			strPath = strName + strPath;
		}

		if( pINode != this )
		{
			pINode->Release();
		}

		if( FAILED ( pINode->GetParentNode( &pINode ) ) )
		{
			pINode = NULL;
		}
	}
}


/////////////////////////////////////////////////////////////////////////////
// CDirectoryNode NewFolder

void CDirectoryNode::NewFolder( void )
{
	CString strNewDir;
	CString strNewSubDir;
	CString strNewFolderText;

	// Derive a name for the new folder
	CString strPath;
	ConstructPath( strPath );

	strNewFolderText.LoadString( IDS_NEW_FOLDER );

	BOOL fContinue = TRUE;
	int i = 0;

	while( fContinue )
	{
		if( i > 0 )
		{
			strNewSubDir.Format( "%s %s%d%s", strNewFolderText, _T("("), i, _T(")") );
		}
		else
		{
			strNewSubDir = strNewFolderText;
		}

		strNewDir = strPath + strNewSubDir;

		DWORD dwAttributes = GetFileAttributes( strNewDir );

		if( (dwAttributes == 0xFFFFFFFF)
		|| !(dwAttributes & FILE_ATTRIBUTE_DIRECTORY) )
		{
			// directory does not exist
			fContinue = FALSE;
		}

		i++;
	}

	// Create the new directory node and insert it into the Project Tree
	CDirectoryNode* pDirNode = new CDirectoryNode;

	if( pDirNode )
	{
		pDirNode->m_strName = strNewSubDir;
		InsertChildNode( pDirNode );

		theApp.m_pFramework->EditNodeLabel( pDirNode );
	}
}


/////////////////////////////////////////////////////////////////////////////
// CDirectoryNode GetSubDirectoryByName

CDirectoryNode* CDirectoryNode::GetSubDirectoryByName( LPCTSTR szName )
{
	CDirectoryNode* pTheDirNode = NULL;
	CDirectoryNode* pDirNode;
	IDMUSProdNode* pINode;
	GUID guidNodeId;

    POSITION pos = m_lstNodes.GetHeadPosition();

    while( pos )
    {
        pINode = m_lstNodes.GetNext( pos );

		if( SUCCEEDED ( pINode->GetNodeId( &guidNodeId )  ) )
		{
			if( ::IsEqualGUID( guidNodeId, GUID_DirectoryNode ) )
			{
				pDirNode = (CDirectoryNode* )pINode;

				if( pDirNode->m_strName.CompareNoCase( szName ) == 0 )
				{
					pTheDirNode = pDirNode;
					break;
				}
			}
		}
	}

	return pTheDirNode;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectoryNode FindDirNode

CDirectoryNode* CDirectoryNode::FindDirNode( LPCTSTR szPathName )
{
	CDirectoryNode* pTheDirNode = NULL;
	CDirectoryNode* pDirNode;
	IDMUSProdNode* pINode;
	CString strPath;
	GUID guidNodeId;

    POSITION pos = m_lstNodes.GetHeadPosition();
    while( pos )
    {
        pINode = m_lstNodes.GetNext( pos );

		if( SUCCEEDED ( pINode->GetNodeId( &guidNodeId )  ) )
		{
			if( ::IsEqualGUID( guidNodeId, GUID_DirectoryNode ) )
			{
				pDirNode = (CDirectoryNode* )pINode;

				pDirNode->ConstructPath( strPath );

				if( strPath.CompareNoCase( szPathName ) == 0 )
				{
					pTheDirNode = pDirNode;
				}
				else
				{
					pTheDirNode = pDirNode->FindDirNode( szPathName );
				}
			}
		}

		if( pTheDirNode )
		{
			break;
		}
	}

	return pTheDirNode;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectoryNode NotifyAllFiles

void CDirectoryNode::NotifyAllFiles( GUID guidNotification )
{
	GUID guidNodeId;

	POSITION pos = m_lstNodes.GetHeadPosition();
	while( pos != NULL )
	{
		IDMUSProdNode* pINode = static_cast<IDMUSProdNode*>( m_lstNodes.GetNext(pos) );

		pINode->GetNodeId( &guidNodeId );

		// Handle sub-directories
		if( ::IsEqualGUID ( guidNodeId, GUID_DirectoryNode ) )
		{
			CDirectoryNode* pDirNode = (CDirectoryNode *)pINode;

			pDirNode->NotifyAllFiles( guidNotification );
		}

		// Handle files
		else if( ::IsEqualGUID ( guidNodeId, GUID_FileNode ) )
		{
			CFileNode* pFileNode = (CFileNode *)pINode;

			if( pFileNode->m_pIChildNode )
			{
				// Notify connected nodes that filename is about to change
				theApp.m_pFramework->NotifyNodes( pFileNode->m_pIChildNode, guidNotification, NULL );

				// Notify m_pChildNode that filename is about to change
				IDMUSProdNotifySink* pINotifySink;
				if( SUCCEEDED ( pFileNode->m_pIChildNode->QueryInterface( IID_IDMUSProdNotifySink, (void **)&pINotifySink ) ) )
				{
					pINotifySink->OnUpdate( pFileNode->m_pIChildNode, guidNotification, NULL );
					pINotifySink->Release();
				}
			}
		}
	}
}


/////////////////////////////////////////////////////////////////////////////
// CDirectoryNode::SortTree

void CDirectoryNode::SortTree( void )
{
	CMainFrame* pMainFrame = (CMainFrame *)theApp.m_pMainWnd;
	ASSERT( pMainFrame != NULL );

    // Sort all sub-Directory nodes
	POSITION pos = m_lstNodes.GetHeadPosition();
    while( pos )
    {
        IDMUSProdNode* pIDirNode = m_lstNodes.GetNext( pos );

		GUID guidNodeId;
		if( SUCCEEDED ( pIDirNode->GetNodeId( &guidNodeId ) ) )
		{
			if( IsEqualGUID ( guidNodeId, GUID_DirectoryNode ) )
			{
				CDirectoryNode* pDirNode = (CDirectoryNode *)pIDirNode;

				pDirNode->SortTree();
			}
		}
	}

	// Sort this Directory node
	HTREEITEM hItem = theApp.m_pFramework->FindTreeItem( this );
	if( hItem )
	{
		pMainFrame->m_wndTreeBar.SortChildren( hItem );
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\Framework\FileNewDlg.h ===
#if !defined(AFX_FILENEWDLG_H__0A8494DE_8B10_4113_A5FA_17D6F08CD8F8__INCLUDED_)
#define AFX_FILENEWDLG_H__0A8494DE_8B10_4113_A5FA_17D6F08CD8F8__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// FileNewDlg.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CFileNewDlg dialog

class CFileNewDlg : public CDialog
{
// Construction
public:
	CFileNewDlg(CWnd* pParent = NULL);   // standard constructor
	~CFileNewDlg();

// Dialog Data
	//{{AFX_DATA(CFileNewDlg)
	enum { IDD = IDD_FILE_NEW };
	CButton	m_checkUseDefaultNames;
	CEdit	m_editName;
	CListBox	m_lstbxTypes;
	//}}AFX_DATA

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CFileNewDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	void FillTypeListBox();

	// Generated message map functions
	//{{AFX_MSG(CFileNewDlg)
	virtual void OnOK();
	virtual BOOL OnInitDialog();
	afx_msg void OnCheckUseDefaultNames();
	afx_msg void OnDoubleClickedCheckUseDefaultNames();
	afx_msg void OnDblClkLstbxTypes();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

private:
	CString			m_strTempName;

public:
	int				m_nNbrSelItems;
	CDocTemplate**	m_apTemplate;
	CString			m_strDefaultName;	
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_FILENEWDLG_H__0A8494DE_8B10_4113_A5FA_17D6F08CD8F8__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\Framework\DirectoryNode.h ===
// DirectoryNode.h: interface for the CDirectoryNode class.
//
//////////////////////////////////////////////////////////////////////

#ifndef __DIRECTORYNODE_H__
#define __DIRECTORYNODE_H__


//////////////////////////////////////////////////////////////////////
//  CDirectoryNode

class CDirectoryNode : public IDMUSProdNode
{
friend class CProject;

public:
	CDirectoryNode();
	virtual ~CDirectoryNode();

    // IUnknown functions
    virtual HRESULT STDMETHODCALLTYPE QueryInterface( REFIID riid, LPVOID *ppv );
    virtual ULONG STDMETHODCALLTYPE AddRef();
    virtual ULONG STDMETHODCALLTYPE Release();

    // IDMUSProdNode functions
	virtual HRESULT STDMETHODCALLTYPE GetNodeImageIndex( short* pnFirstImage );
	virtual HRESULT STDMETHODCALLTYPE UseOpenCloseImages( BOOL* pfUseOpenCloseImages );

    virtual HRESULT STDMETHODCALLTYPE GetFirstChild( IDMUSProdNode** ppIFirstChildNode );
    virtual HRESULT STDMETHODCALLTYPE GetNextChild( IDMUSProdNode* pIChildNode, IDMUSProdNode** ppINextChildNode );

    virtual HRESULT STDMETHODCALLTYPE GetComponent( IDMUSProdComponent** ppIComponent );
    virtual HRESULT STDMETHODCALLTYPE GetDocRootNode( IDMUSProdNode** ppIDocRootNode );
    virtual HRESULT STDMETHODCALLTYPE SetDocRootNode( IDMUSProdNode* pIDocRootNode );
    virtual HRESULT STDMETHODCALLTYPE GetParentNode( IDMUSProdNode** ppIParentNode );
    virtual HRESULT STDMETHODCALLTYPE SetParentNode( IDMUSProdNode* pIParentNode );

    virtual HRESULT STDMETHODCALLTYPE GetNodeId( GUID* pguid );
    virtual HRESULT STDMETHODCALLTYPE GetNodeName( BSTR* pbstrName );
    virtual HRESULT STDMETHODCALLTYPE GetNodeNameMaxLength( short* pnMaxLength );
    virtual HRESULT STDMETHODCALLTYPE ValidateNodeName( BSTR bstrName );
    virtual HRESULT STDMETHODCALLTYPE SetNodeName( BSTR bstrName );
    virtual HRESULT STDMETHODCALLTYPE GetNodeListInfo( DMUSProdListInfo* pListInfo );

    virtual HRESULT STDMETHODCALLTYPE GetEditorClsId( CLSID* pclsid );
    virtual HRESULT STDMETHODCALLTYPE GetEditorTitle( BSTR* pbstrTitle );
    virtual HRESULT STDMETHODCALLTYPE GetEditorWindow( HWND* hWndEditor );
    virtual HRESULT STDMETHODCALLTYPE SetEditorWindow( HWND hWndEditor );

    virtual HRESULT STDMETHODCALLTYPE GetRightClickMenuId( HINSTANCE* phInstance, UINT* pnResourceId );
    virtual HRESULT STDMETHODCALLTYPE OnRightClickMenuInit( HMENU hMenu );
    virtual HRESULT STDMETHODCALLTYPE OnRightClickMenuSelect( long lCommandId );

    virtual HRESULT STDMETHODCALLTYPE DeleteChildNode( IDMUSProdNode* pIChildNode, BOOL fPromptUser );
    virtual HRESULT STDMETHODCALLTYPE InsertChildNode( IDMUSProdNode* pIChildNode );
    virtual HRESULT STDMETHODCALLTYPE DeleteNode( BOOL fPromptUser );

	virtual HRESULT STDMETHODCALLTYPE OnNodeSelChanged( BOOL fSelected );

	virtual HRESULT STDMETHODCALLTYPE CreateDataObject( IDataObject** ppIDataObject );
	virtual HRESULT STDMETHODCALLTYPE CanCut();
	virtual HRESULT STDMETHODCALLTYPE CanCopy();
	virtual HRESULT STDMETHODCALLTYPE CanDelete();
	virtual HRESULT STDMETHODCALLTYPE CanDeleteChildNode( IDMUSProdNode* pIChildNode );
	virtual HRESULT STDMETHODCALLTYPE CanPasteFromData( IDataObject* pIDataObject, BOOL* pfWillSetReference );
	virtual HRESULT STDMETHODCALLTYPE PasteFromData( IDataObject* pIDataObject );
	virtual HRESULT STDMETHODCALLTYPE CanChildPasteFromData( IDataObject* pIDataObject, IDMUSProdNode* pIChildNode, BOOL* pfWillSetReference );
	virtual HRESULT STDMETHODCALLTYPE ChildPasteFromData( IDataObject* pIDataObject, IDMUSProdNode* pIChildNode );

	virtual HRESULT STDMETHODCALLTYPE GetObject( REFCLSID rclsid, REFIID riid, void** ppvObject ); 

	//Additional methods
public:
	BOOL DeleteDirectoryToRecycleBin();
	void ConstructPath( CString& strPath );
	void NewFolder();
	CDirectoryNode* GetSubDirectoryByName( LPCTSTR szName );
	CDirectoryNode* FindDirNode( LPCTSTR szPathName );
	void NotifyAllFiles( GUID guidNotification );
	void SortTree();

private:
	HRESULT PasteOpenFile( CFProducerFile* pcfProducerFile, IStream* pIMemStream, IDMUSProdDocType* pIDocType );
	HRESULT PasteShutFile( CFProducerFile* pcfProducerFile );
	HRESULT GetPasteFileName( CFProducerFile* pcfProducerFile, CString& strFileName );

	// Member variables
private:
    CTypedPtrList<CPtrList, IDMUSProdNode*> m_lstNodes;

	IDMUSProdNode*	m_pIParentNode;

protected:
    DWORD		m_dwRef;

public:
	CString		m_strName;
	HTREEITEM	m_hItem;	// Node's HTREEITEM in Project Tree
};

#endif //__DIRECTORYNODE_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\Framework\FileNewDlg.cpp ===
// FileNewDlg.cpp : implementation file
//

#include "stdafx.h"
#include "JazzApp.h"
#include "FileNewDlg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CFileNewDlg dialog

CFileNewDlg::CFileNewDlg(CWnd* pParent /*=NULL*/)
	: CDialog(CFileNewDlg::IDD, pParent)
{
	//{{AFX_DATA_INIT(CFileNewDlg)
	//}}AFX_DATA_INIT

	m_nNbrSelItems = 0;
	m_apTemplate = NULL;
}

CFileNewDlg::~CFileNewDlg()
{
	if( m_apTemplate )
	{
		delete [] m_apTemplate;
	}
}


/////////////////////////////////////////////////////////////////////////////
// CFileNewDlg::FillTypeListBox

void CFileNewDlg::FillTypeListBox( void ) 
{
	CString strText;
	int nPos;

	// Empty list box
	m_lstbxTypes.ResetContent();

	// Add DocTypes
	if( theApp.m_pDocManager )
	{
		POSITION pos = theApp.m_pDocManager->GetFirstDocTemplatePosition();
		while( pos )
		{
			CDocTemplate* pTemplate = theApp.m_pDocManager->GetNextDocTemplate( pos );

			// Get text for listbox
			pTemplate->GetDocString( strText, CDocTemplate::fileNewName );

			// Add string to listbox
			if( strText.IsEmpty() == FALSE )
			{
				nPos = m_lstbxTypes.AddString( strText );
				m_lstbxTypes.SetItemDataPtr( nPos, pTemplate );
			}
		}
	}
}


void CFileNewDlg::DoDataExchange(CDataExchange* pDX)
{
	AFX_MANAGE_STATE( AfxGetAppModuleState() );

	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CFileNewDlg)
	DDX_Control(pDX, IDC_CHECK_USE_DEFAULT_NAMES, m_checkUseDefaultNames);
	DDX_Control(pDX, IDC_EDIT_NAME, m_editName);
	DDX_Control(pDX, IDC_LSTBX_TYPES, m_lstbxTypes);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CFileNewDlg, CDialog)
	//{{AFX_MSG_MAP(CFileNewDlg)
	ON_BN_CLICKED(IDC_CHECK_USE_DEFAULT_NAMES, OnCheckUseDefaultNames)
	ON_BN_DOUBLECLICKED(IDC_CHECK_USE_DEFAULT_NAMES, OnDoubleClickedCheckUseDefaultNames)
	ON_LBN_DBLCLK(IDC_LSTBX_TYPES, OnDblClkLstbxTypes)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// CFileNewDlg message handlers

/////////////////////////////////////////////////////////////////////////////
// CFileNewDlg::OnInitDialog

BOOL CFileNewDlg::OnInitDialog( void ) 
{
	AFX_MANAGE_STATE( AfxGetAppModuleState() );

	CDialog::OnInitDialog();
	
	// "File Types" list box
	FillTypeListBox();
	m_lstbxTypes.SetSel( 0 );
	m_lstbxTypes.SetFocus();

	// "Name" edit control
	m_editName.EnableWindow( FALSE );
	m_checkUseDefaultNames.SetCheck( 1 );
	
	return FALSE;
}


/////////////////////////////////////////////////////////////////////////////
// CFileNewDlg::OnCheckUseDefaultNames

void CFileNewDlg::OnCheckUseDefaultNames( void ) 
{
	if( m_checkUseDefaultNames.GetCheck() )
	{
		m_editName.GetWindowText( m_strTempName );
		m_editName.EnableWindow( FALSE );
		m_editName.SetWindowText( NULL );
	}
	else
	{
		m_editName.SetWindowText( m_strTempName );
		m_editName.EnableWindow( TRUE );
		m_editName.SetFocus();
		m_editName.SetSel( 0, -1 );
	}
}


/////////////////////////////////////////////////////////////////////////////
// CFileNewDlg::OnDoubleClickedCheckUseDefaultNames

void CFileNewDlg::OnDoubleClickedCheckUseDefaultNames( void ) 
{
	OnCheckUseDefaultNames() ;
}


/////////////////////////////////////////////////////////////////////////////
// CFileNewDlg::OnDblClkLstbxTypes

void CFileNewDlg::OnDblClkLstbxTypes( void ) 
{
	OnOK();
}


/////////////////////////////////////////////////////////////////////////////
// CFileNewDlg::OnOK

void CFileNewDlg::OnOK( void ) 
{
	AFX_MANAGE_STATE( AfxGetAppModuleState() );

	m_strDefaultName.Empty();

	if( m_checkUseDefaultNames.GetCheck() == 0 )
	{
		m_editName.GetWindowText( m_strTempName );

		if( m_strTempName.IsEmpty() )
		{
			AfxMessageBox( IDS_ERR_NAME_EMPTY );
			return;
		}

		int iBad = m_strTempName.FindOneOf( _T("\\/:*?\"<>;|%") );
		if( iBad != -1 )
		{
			AfxMessageBox( IDS_ERR_FILE_CHAR );
			return;
		}

		m_strDefaultName = m_strTempName;
	}

	m_nNbrSelItems = m_lstbxTypes.GetSelCount();
	if( m_nNbrSelItems > 0 )
	{
		int* pnSelItems = new int[m_nNbrSelItems];
		if( pnSelItems )
		{
			m_apTemplate = new CDocTemplate*[m_nNbrSelItems];
			if( m_apTemplate )
			{
				m_lstbxTypes.GetSelItems( m_nNbrSelItems, pnSelItems );

				for( int i = 0;  i < m_nNbrSelItems ;  i++ )
				{
					m_apTemplate[i] = (CDocTemplate *)m_lstbxTypes.GetItemDataPtr( pnSelItems[i] );
				}
			}

			delete [] pnSelItems;
		}
	}
	
	CDialog::OnOK();
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\Framework\FileNode.cpp ===
// FileNode.cpp: implementation of the CFileNode class.
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "JazzApp.h"
#include "MainFrm.h"
#include "ioJazzDoc.h"
#include "TabFileDesign.h"
#include "TabFileRuntime.h"

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#define new DEBUG_NEW
#endif


// {B8520A40-CB9E-11d0-89AE-00A0C9054129}
const GUID GUID_FileNode = 
{ 0xb8520a40, 0xcb9e, 0x11d0, { 0x89, 0xae, 0x0, 0xa0, 0xc9, 0x5, 0x41, 0x29 } };

// {89A55C20-6BC5-11d1-89AE-00A0C9054129}
static const GUID GUID_FilePropPageManager = 
{ 0x89a55c20, 0x6bc5, 0x11d1, { 0x89, 0xae, 0x0, 0xa0, 0xc9, 0x5, 0x41, 0x29 } };


short CFilePropPageManager::sm_nActiveTab = 0;

//////////////////////////////////////////////////////////////////////
// CFilePropPageManager Construction/Destruction
//////////////////////////////////////////////////////////////////////

CFilePropPageManager::CFilePropPageManager()
{
	m_pTabDesign = NULL;
	m_pTabRuntime = NULL;
	m_GUIDManager = GUID_FilePropPageManager;
}

CFilePropPageManager::~CFilePropPageManager()
{
	if( m_pTabDesign )
	{
		delete m_pTabDesign;
	}

	if( m_pTabRuntime )
	{
		delete m_pTabRuntime;
	}
}


/////////////////////////////////////////////////////////////////////////////
// CFilePropPageManager::RemoveCurrentObject

void CFilePropPageManager::RemoveCurrentObject( void )
{
	if( m_pIPropPageObject == NULL )
	{
		return;
	}

	m_pIPropPageObject->OnRemoveFromPageManager();
	m_pIPropPageObject = NULL;
}


/////////////////////////////////////////////////////////////////////////////
// CFilePropPageManager IDMUSProdPropPageManager::GetPropertySheetTitle

HRESULT CFilePropPageManager::GetPropertySheetTitle( BSTR* pbstrTitle, BOOL* pfAddPropertiesText )
{
	AFX_MANAGE_STATE( AfxGetAppModuleState() );

	if( (pbstrTitle == NULL)
	||  (pfAddPropertiesText == NULL) )
	{
		return E_POINTER;
	}

	*pfAddPropertiesText = TRUE;

	CString strFile;

	HINSTANCE hInstance = AfxGetResourceHandle();
	AfxSetResourceHandle( theApp.m_hInstance );
	strFile.LoadString( IDS_FILE_TEXT );
	AfxSetResourceHandle( hInstance );

	CString strTitle = strFile;

	CFileNode *pFileNode;

	if( m_pIPropPageObject
	&& (SUCCEEDED (m_pIPropPageObject->GetData((void **)&pFileNode))) )
	{
		CString strFilterName;

		CString strExt;
		int nFindPos = pFileNode->m_strName.ReverseFind( (TCHAR)'.' );
		if( nFindPos != -1 )
		{
			strExt = pFileNode->m_strName.Right( pFileNode->m_strName.GetLength() - nFindPos );
		}

		IDMUSProdDocType* pIDocType;
		BSTR bstrExt = strExt.AllocSysString();

		if( SUCCEEDED ( theApp.m_pFramework->FindDocTypeByExtension( bstrExt, &pIDocType ) ) )
		{
			CJazzDocTemplate* pTemplate = theApp.FindDocTemplate( pIDocType );
			if( pTemplate )
			{
				pTemplate->GetDocString( strFilterName, CDocTemplate::docName );
			}
			pIDocType->Release();
		}

		strTitle = pFileNode->m_strName + _T(" ");
		if( !strFilterName.IsEmpty() )
		{
			strTitle += strFilterName + _T(" ");
		}
		strTitle += strFile;
	}

	*pbstrTitle = strTitle.AllocSysString();

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CFilePropPageManager IDMUSProdPropPageManager::GetPropertySheetPages

HRESULT CFilePropPageManager::GetPropertySheetPages( IDMUSProdPropSheet* pIPropSheet, LONG* hPropSheetPage[], short* pnNbrPages )
{
	AFX_MANAGE_STATE( AfxGetAppModuleState() );

	if( (hPropSheetPage == NULL)
	||  (pnNbrPages == NULL) )
	{
		return E_POINTER;
	}

	if( pIPropSheet == NULL )
	{
		return E_INVALIDARG;
	}

	m_pIPropSheet = pIPropSheet;
	m_pIPropSheet->AddRef();

	hPropSheetPage[0] = NULL;
	*pnNbrPages = 0;

	HINSTANCE hInstance = AfxGetResourceHandle();
	AfxSetResourceHandle( theApp.m_hInstance );

	// Add Design tab
	HPROPSHEETPAGE hPage;
	short nNbrPages = 0;

	m_pTabDesign = new CTabFileDesign( this );
	if( m_pTabDesign )
	{
		hPage = ::CreatePropertySheetPage( (LPCPROPSHEETPAGE)&m_pTabDesign->m_psp );
		if( hPage )
		{
			hPropSheetPage[nNbrPages] = (LONG *)hPage;
			nNbrPages++;
		}			
	}

	// Add Runtime tab
	m_pTabRuntime = new CTabFileRuntime( this );
	if( m_pTabRuntime )
	{
		hPage = ::CreatePropertySheetPage( (LPCPROPSHEETPAGE)&m_pTabRuntime->m_psp );
		if( hPage )
		{
			hPropSheetPage[nNbrPages] = (LONG *)hPage;
			nNbrPages++;
		}			
	}

	AfxSetResourceHandle( hInstance );

	// Set number of pages
	*pnNbrPages = nNbrPages;

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CFilePropPageManager IDMUSProdPropPageManager::OnRemoveFromPropertySheet

HRESULT CFilePropPageManager::OnRemoveFromPropertySheet()
{
	AFX_MANAGE_STATE( AfxGetAppModuleState() );

	ASSERT( m_pIPropSheet != NULL );
	m_pIPropSheet->GetActivePage( &CFilePropPageManager::sm_nActiveTab );

	CAppBasePropPageManager::OnRemoveFromPropertySheet();

	theApp.m_pIPageManager = NULL;

	Release();	// delete myself

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CFilePropPageManager IDMUSProdPropPageManager::RefreshData

HRESULT CFilePropPageManager::RefreshData( void )
{
	AFX_MANAGE_STATE( AfxGetAppModuleState() );

	CFileNode* pFileNode;
	
	if( m_pIPropPageObject == NULL )
	{
		pFileNode = NULL;
	}
	else if( FAILED ( m_pIPropPageObject->GetData( (void **)&pFileNode ) ) )
	{
		return E_FAIL;
	}

	m_pTabDesign->SetFile( pFileNode );
	m_pTabRuntime->SetFile( pFileNode );

	return S_OK;
}

//////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////
// CFileNode Construction/Destruction
//////////////////////////////////////////////////////////////////////

CFileNode::CFileNode()
{
    m_dwRef = 0;

	CoCreateGuid( &m_guid ); 

	m_pIParentNode = NULL;
	m_pIChildNode = NULL;
	m_pProject = NULL;
	m_pComponentDoc = NULL;

	m_hItem = NULL;
	m_hChildItem = NULL;
	m_fInOnOpenDocument = FALSE;

	m_wFlags = FSF_NOFLAGS;
	m_nRuntimeSaveAction = RSA_NOACTION;

	memset( &m_guidListInfoObject, 0, sizeof(GUID) );
}

CFileNode::~CFileNode()
{
	ASSERT( m_fInOnOpenDocument == FALSE );

	IDMUSProdPropSheet* pIPropSheet = theApp.GetPropertySheet();
	if( pIPropSheet )
	{
		pIPropSheet->RemovePageManagerByObject( this );
		pIPropSheet->Release();
	}

	theApp.CleanUpNotifyLists( this, FALSE );

	// Cleanup m_lstWP
	wpWindowPlacement* pWP;
	while( !m_lstWP.IsEmpty() )
	{
		pWP = static_cast<wpWindowPlacement*>( m_lstWP.RemoveHead() );
		delete pWP;
	}

	// Cleanup m_lstNotifyNodes
	EmptyNotifyNodesList();

	// Cleanup m_lstNotifyWhenLoadFinished
	IDMUSProdNotifySink* pINotifySink;
	ASSERT( m_lstNotifyWhenLoadFinished.IsEmpty() );
	while( !m_lstNotifyWhenLoadFinished.IsEmpty() )
	{
		pINotifySink = static_cast<IDMUSProdNotifySink*>( m_lstNotifyWhenLoadFinished.RemoveHead() );
		pINotifySink->Release();
	}

	// Remove FileNode's child (associated document)
	if( m_pIChildNode )
	{
		DeleteChildNode( m_pIChildNode, FALSE );
	}
}


/////////////////////////////////////////////////////////////////////////////
// CFileNode IUnknown implementation

HRESULT CFileNode::QueryInterface( REFIID riid, LPVOID FAR* ppvObj )
{
	AFX_MANAGE_STATE( AfxGetAppModuleState() );

    if( ::IsEqualIID(riid, IID_IDMUSProdNode)
	||  ::IsEqualIID(riid, IID_IUnknown) )
    {
        AddRef();
        *ppvObj = (IDMUSProdNode *)this;
        return S_OK;
    }

    if( ::IsEqualIID(riid, IID_IDMUSProdPropPageObject) )
    {
        AddRef();
        *ppvObj = (IDMUSProdPropPageObject *)this;
        return S_OK;
    }

    *ppvObj = NULL;
    return E_NOINTERFACE;
}

ULONG CFileNode::AddRef()
{
	AFX_MANAGE_STATE( AfxGetAppModuleState() );

    return ++m_dwRef;
}

ULONG CFileNode::Release()
{
	AFX_MANAGE_STATE( AfxGetAppModuleState() );

    ASSERT( m_dwRef != 0 );

    --m_dwRef;

    if( m_dwRef == 0 )
    {
        delete this;
        return 0;
    }

    return m_dwRef;
}


/////////////////////////////////////////////////////////////////////////////
// CFileNode IDMUSProdNode implementation

/////////////////////////////////////////////////////////////////////////////
// CFileNode IDMUSProdNode::GetNodeImageIndex

HRESULT CFileNode::GetNodeImageIndex( short* pnFirstImage )
{
	AFX_MANAGE_STATE( AfxGetAppModuleState() );

	if( pnFirstImage == NULL )
	{
		return E_POINTER;
	}

	if( IsProducerFile() )
	{
		// Set the default tree image
		*pnFirstImage = theApp.m_nFirstImage + FIRST_PRODUCER_FILE_IMAGE;

		// Determine file extension
		CString strExt;
		int nFindPos = m_strName.ReverseFind( (TCHAR)'.' );
		if( nFindPos != -1 )
		{
			strExt = m_strName.Right( m_strName.GetLength() - nFindPos );
		}
		BSTR bstrExt = strExt.AllocSysString();
		
		// Find DocType
		IDMUSProdDocType* pIDocType;
		if( SUCCEEDED ( theApp.m_pFramework->FindDocTypeByExtension( bstrExt, &pIDocType ) ) )
		{
			CJazzDocTemplate* pTemplate = theApp.FindDocTemplate( pIDocType );
			if( pTemplate )
			{
				short nTreeImageIndex = pTemplate->GetTreeImageIndex();
				if( nTreeImageIndex != -1 )
				{
					// Override the default tree image
					*pnFirstImage = nTreeImageIndex;
				}
			}

			pIDocType->Release();
		}
	}
	else
	{
		*pnFirstImage = theApp.m_nFirstImage + FIRST_FILE_IMAGE;
	}

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CFileNode IDMUSProdNode::GetFirstChild

HRESULT CFileNode::GetFirstChild( IDMUSProdNode** ppIFirstChildNode )
{
//	AFX_MANAGE_STATE( AfxGetAppModuleState() );

    return E_NOTIMPL;	// FileNode node does not manage its children
}


/////////////////////////////////////////////////////////////////////////////
// CFileNode IDMUSProdNode::GetNextChild

HRESULT CFileNode::GetNextChild( IDMUSProdNode* pIChildNode, IDMUSProdNode** ppINextChildNode )
{
//	AFX_MANAGE_STATE( AfxGetAppModuleState() );

    return E_NOTIMPL;	// FileNode node does not manage its children
}


/////////////////////////////////////////////////////////////////////////////
// CFileNode IDMUSProdNode::GetComponent

HRESULT CFileNode::GetComponent( IDMUSProdComponent** ppIComponent )
{
//	AFX_MANAGE_STATE( AfxGetAppModuleState() );

    return E_NOTIMPL;	// FileNode node is not associated with a Component
}


/////////////////////////////////////////////////////////////////////////////
// CFileNode IDMUSProdNode::GetDocRootNode

HRESULT CFileNode::GetDocRootNode( IDMUSProdNode** ppIDocRootNode )
{
//	AFX_MANAGE_STATE( AfxGetAppModuleState() );

    return E_NOTIMPL;	// intentionally not implemented
}


/////////////////////////////////////////////////////////////////////////////
// CFileNode IDMUSProdNode::SetDocRootNode

HRESULT CFileNode::SetDocRootNode( IDMUSProdNode* pIDocRootNode )
{
//	AFX_MANAGE_STATE( AfxGetAppModuleState() );

    return E_NOTIMPL;	// intentionally not implemented
}


/////////////////////////////////////////////////////////////////////////////
// CFileNode IDMUSProdNode::GetParentNode

HRESULT CFileNode::GetParentNode( IDMUSProdNode** ppIParentNode )
{
	AFX_MANAGE_STATE( AfxGetAppModuleState() );

	ASSERT( m_pIParentNode != NULL );

	if( ppIParentNode == NULL )
	{
		return E_POINTER;
	}

	m_pIParentNode->AddRef();
	*ppIParentNode = m_pIParentNode;

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CFileNode IDMUSProdNode::SetParentNode

HRESULT CFileNode::SetParentNode( IDMUSProdNode* pIParentNode )
{
	AFX_MANAGE_STATE( AfxGetAppModuleState() );

	ASSERT( pIParentNode != NULL );

	if( pIParentNode == NULL )
	{
		return E_INVALIDARG;
	}

	m_pIParentNode = pIParentNode;
//	m_pIParentNode->AddRef();		intentionally missing

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CFileNode IDMUSProdNode::GetNodeId

HRESULT CFileNode::GetNodeId( GUID* pguid )
{
	AFX_MANAGE_STATE( AfxGetAppModuleState() );

	if( pguid == NULL )
	{
		return E_POINTER;
	}

	*pguid = GUID_FileNode;

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CFileNode IDMUSProdNode::GetNodeName

HRESULT CFileNode::GetNodeName( BSTR* pbstrName )
{
	AFX_MANAGE_STATE( AfxGetAppModuleState() );

	if( pbstrName == NULL )
	{
		return E_POINTER;
	}

    *pbstrName = m_strName.AllocSysString();

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CFileNode IDMUSProdNode::GetNodeNameMaxLength

HRESULT CFileNode::GetNodeNameMaxLength( short* pnMaxLength )
{
	AFX_MANAGE_STATE( AfxGetAppModuleState() );

	if( pnMaxLength == NULL )
	{
		return E_POINTER;
	}

	*pnMaxLength = MAX_LENGTH_FILE_NAME;

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CFileNode IDMUSProdNode::ValidateNodeName

HRESULT CFileNode::ValidateNodeName( BSTR bstrName )
{
	AFX_MANAGE_STATE( AfxGetAppModuleState() );

	CString strName = bstrName;
	::SysFreeString( bstrName );

	int iBad = strName.FindOneOf( _T("\\/:*?\"<>;|%") );
	if( iBad != -1 )
	{
		AfxMessageBox( IDS_ERR_FILE_CHAR );
		return S_FALSE;
	}

	// Determine node's old filename
	CString strOldFileName;
	ConstructFileName( strOldFileName );

	// Determine node's old extension
	CString strExt;
	int nFindPos = m_strName.ReverseFind( (TCHAR)'.' );
	if( nFindPos != -1 )
	{
		strExt = m_strName.Right( m_strName.GetLength() - nFindPos );
	}

	// If necessary, add extension to new name
	CString strNewExt = strName.Right( strExt.GetLength() );
	if( strNewExt != strExt )
	{
		strName += strExt;
	}

	// Make sure name does not exceed max chars
	if( strName.GetLength() > MAX_LENGTH_FILE_NAME )
	{
		AfxMessageBox( IDS_ERR_NAME_LENGTH );
		return S_FALSE;
	}

	// Determine node's new filename
	CString strOrigName = m_strName;
	m_strName = strName;
	CString strNewFileName;
	ConstructFileName( strNewFileName );
	m_strName = strOrigName;

	// Make sure path does not exceed max chars
	if( strNewFileName.GetLength() >= _MAX_DIR )
	{
		AfxMessageBox( IDS_ERR_FILENAME_LENGTH );
		return S_FALSE;
	}

	// Notify connected nodes
	if(	theApp.m_fSendFileNameChangeNotification )
	{
		if( m_pIChildNode )
		{
			// Notify connected nodes that file name is about to change
			theApp.m_pFramework->NotifyNodes( m_pIChildNode, FRAMEWORK_BeforeFileNameChange, NULL );

			// Notify m_pChildNode that filename has changed
			IDMUSProdNotifySink* pINotifySink;
			if( SUCCEEDED ( m_pIChildNode->QueryInterface( IID_IDMUSProdNotifySink, (void **)&pINotifySink ) ) )
			{
				pINotifySink->OnUpdate( m_pIChildNode, FRAMEWORK_BeforeFileNameChange, NULL );
				pINotifySink->Release();
			}
		}
	}

	// Change filename to new filename
	if( theApp.RenameThePath(strOldFileName, strNewFileName, strOldFileName) == FALSE )
	{
		// Notify connected nodes
		if(	theApp.m_fSendFileNameChangeNotification )
		{
			if( m_pIChildNode )
			{
				// Notify connected nodes that file name is about to change
				theApp.m_pFramework->NotifyNodes( m_pIChildNode, FRAMEWORK_AbortFileNameChange, NULL );

				// Notify m_pChildNode that filename has changed
				IDMUSProdNotifySink* pINotifySink;
				if( SUCCEEDED ( m_pIChildNode->QueryInterface( IID_IDMUSProdNotifySink, (void **)&pINotifySink ) ) )
				{
					pINotifySink->OnUpdate( m_pIChildNode, FRAMEWORK_AbortFileNameChange, NULL );
					pINotifySink->Release();
				}
			}
		}
		return S_FALSE;
	}

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CFileNode IDMUSProdNode::SetNodeName

HRESULT CFileNode::SetNodeName( BSTR bstrName )
{
	AFX_MANAGE_STATE( AfxGetAppModuleState() );

	ASSERT( m_pProject != NULL );
	ASSERT( theApp.m_pFramework != NULL );

	CString strName = bstrName;
	::SysFreeString( bstrName );

	if( m_strName == strName )
	{
		return S_OK;
	}

	if( theApp.m_fUserChangedNodeName )
	{
		// Determine node's old extension
		CString strExt;
		int nFindPos = m_strName.ReverseFind( (TCHAR)'.' );
		if( nFindPos != -1 )
		{
			strExt = m_strName.Right( m_strName.GetLength() - nFindPos );
		}

		// If necessary, add extension to new name
		CString strNewExt = strName.Right( strExt.GetLength() );
		if( strNewExt != strExt )
		{
			strName += strExt;
		}
	}

	// Store the new name
	CString strOrigName = m_strName;
	m_strName = strName;

	// Change text in Project Tree
	HTREEITEM hItem = theApp.m_pFramework->FindTreeItem( this );
	if( hItem )
	{
		CTreeCtrl* pTreeCtrl = theApp.GetProjectTreeCtrl();
		if( pTreeCtrl )
		{
			// Update label in the Project Tree
			pTreeCtrl->SetItemText( hItem, m_strName );
		}
	}

	// Change name of DocRootNode
	if( m_pIChildNode )
	{
		BSTR bstrDocRootName;
		if( SUCCEEDED ( m_pIChildNode->GetNodeName( &bstrDocRootName ) ) )
		{
			CString strDocRootName = bstrDocRootName;
			::SysFreeString( bstrDocRootName );

			CString strNameMinusExt;
			int nFindPos = strOrigName.ReverseFind( (TCHAR)'.' );
			if( nFindPos != -1 )
			{
				strNameMinusExt = strOrigName.Left( nFindPos );
			}

			if( strDocRootName.Compare( strNameMinusExt ) == 0 )
			{
				// Names were equal so continue to keep in sync
				nFindPos = m_strName.ReverseFind( (TCHAR)'.' );
				if( nFindPos != -1 )
				{
					strNameMinusExt = m_strName.Left( nFindPos );
				}
				bstrDocRootName = strNameMinusExt.AllocSysString();
				if( m_pIChildNode->ValidateNodeName( bstrDocRootName ) == S_OK )
				{
					bstrDocRootName = strNameMinusExt.AllocSysString();
					m_pIChildNode->SetNodeName( bstrDocRootName );
					theApp.m_pFramework->RefreshNode( m_pIChildNode );
				}
			}
		}
	}

	// Change Document name
	if( m_pIParentNode 
	&&  m_pComponentDoc )
	{
		CString strFileName;
		
		ConstructFileName( strFileName );
		m_pComponentDoc->SetPathName( strFileName, FALSE );
	}

	// Change the runtime filename
	int nFindPos = m_strName.ReverseFind( (TCHAR)'.' );
	if( nFindPos != -1 )
	{
		CString strRuntimeFileName;

		theApp.AdjustFileName( FT_RUNTIME, strOrigName, strRuntimeFileName );

		if( m_strRuntimeFileName.IsEmpty()
		||	m_strRuntimeFileName.CompareNoCase( strRuntimeFileName ) == 0 )
		{
			CString strNextRuntimeFile;
			
			theApp.AdjustFileName( FT_RUNTIME, m_strName, m_strRuntimeFileName );
			ConstructRuntimePath( strNextRuntimeFile );
			strNextRuntimeFile += m_strRuntimeFileName;
			
			if( m_strRuntimeFile.IsEmpty() == FALSE
			&&	m_strRuntimeFile.CompareNoCase( strNextRuntimeFile ) != 0 )
			{
				if( theApp.RenameThePath( m_strRuntimeFile, strNextRuntimeFile, m_strRuntimeFile ) == TRUE )
				{
					m_strRuntimeFile = strNextRuntimeFile;
				}
			}
		}
	}

	// Refresh Property sheet
	IDMUSProdPropSheet* pIPropSheet = theApp.GetPropertySheet();
	if( pIPropSheet )
	{
		pIPropSheet->RefreshTitleByObject( this );
		pIPropSheet->RefreshActivePageByObject( this );
		pIPropSheet->Release();
	}

	return S_OK;	// For now just set programmatically
}


/////////////////////////////////////////////////////////////////////////////
// CFileNode IDMUSProdNode::GetNodeListInfo

HRESULT CFileNode::GetNodeListInfo( DMUSProdListInfo* pListInfo )
{
	AFX_MANAGE_STATE( AfxGetAppModuleState() );

	WORD wOrigSize = pListInfo->wSize;
    memset( pListInfo, 0, wOrigSize );
	pListInfo->wSize = wOrigSize;
	
	if( m_pIChildNode )
	{
		return m_pIChildNode->GetNodeListInfo( pListInfo );
	}

	pListInfo->bstrName = m_strListInfoName.AllocSysString();
    pListInfo->bstrDescriptor = m_strListInfoDescriptor.AllocSysString();
    memcpy( &pListInfo->guidObject, &m_guidListInfoObject, sizeof(GUID) );

	// Must check pListInfo->wSize before populating additional fields

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CFileNode IDMUSProdNode::GetEditorClsId

HRESULT CFileNode::GetEditorClsId( CLSID* pClsId )
{
//	AFX_MANAGE_STATE( AfxGetAppModuleState() );

	return E_NOTIMPL;	// FileNode is not associated with an editor
}


/////////////////////////////////////////////////////////////////////////////
// CFileNode IDMUSProdNode::GetEditorTitle

HRESULT CFileNode::GetEditorTitle( BSTR* pbstrTitle )
{
//	AFX_MANAGE_STATE( AfxGetAppModuleState() );

	return E_NOTIMPL;	// FileNode is not associated with an editor
}


/////////////////////////////////////////////////////////////////////////////
// CFileNode IDMUSProdNode::GetEditorWindow

HRESULT CFileNode::GetEditorWindow( HWND* hWndEditor )
{
//	AFX_MANAGE_STATE( AfxGetAppModuleState() );

	return E_NOTIMPL;	// FileNode is not associated with an editor
}


/////////////////////////////////////////////////////////////////////////////
// CFileNode IDMUSProdNode::SetEditorWindow

HRESULT CFileNode::SetEditorWindow( HWND hWndEditor )
{
//	AFX_MANAGE_STATE( AfxGetAppModuleState() );

	return E_NOTIMPL;	// FileNode is not associated with an editor
}


/////////////////////////////////////////////////////////////////////////////
// CFileNode IDMUSProdNode::UseOpenCloseImages

HRESULT CFileNode::UseOpenCloseImages( BOOL* pfUseOpenCloseImages )
{
	AFX_MANAGE_STATE( AfxGetAppModuleState() );

	if( pfUseOpenCloseImages == NULL )
	{
		return E_POINTER;
	}

	*pfUseOpenCloseImages = FALSE;

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CFileNode IDMUSProdNode::GetRightClickMenuId

HRESULT CFileNode::GetRightClickMenuId( HINSTANCE* phInstance, UINT* pnMenuId )
{
	AFX_MANAGE_STATE( AfxGetAppModuleState() );

	*phInstance = AfxGetResourceHandle();
	*pnMenuId   = IDM_FILE_NODE_RMENU;

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CFileNode IDMUSProdNode::OnRightClickMenuInit

HRESULT CFileNode::OnRightClickMenuInit( HMENU hMenu )
{
	AFX_MANAGE_STATE( AfxGetAppModuleState() );

	CMenu menu;

	if( menu.Attach(hMenu) )
	{
		// IDM_CUT
		if( CanCut() == S_OK )
		{
			menu.EnableMenuItem( IDM_CUT, (MF_ENABLED | MF_BYCOMMAND) );
		}
		else
		{
			menu.EnableMenuItem( IDM_CUT, (MF_GRAYED | MF_BYCOMMAND) );
		}
		
		// IDM_COPY
		if( CanCopy() == S_OK )
		{
			menu.EnableMenuItem( IDM_COPY, (MF_ENABLED | MF_BYCOMMAND) );
		}
		else
		{
			menu.EnableMenuItem( IDM_COPY, (MF_GRAYED | MF_BYCOMMAND) );
		}

		// IDM_PASTE
		{
			IDataObject* pIDataObject;
			BOOL fWillSetReference;

			menu.EnableMenuItem( IDM_PASTE, (MF_GRAYED | MF_BYCOMMAND) );

			if( SUCCEEDED ( ::OleGetClipboard( &pIDataObject ) ) )
			{
				if( CanPasteFromData( pIDataObject, &fWillSetReference ) == S_OK )
				{
					menu.EnableMenuItem( IDM_PASTE, (MF_ENABLED | MF_BYCOMMAND) );
				}
				
				pIDataObject->Release();
			}
		}

		// IDM_SAVE, IDM_SAVEAS, IDM_REVERT
		if( m_pIChildNode )
		{
			CString strMenuText;

			menu.GetMenuString( IDM_SAVE, strMenuText, MF_BYCOMMAND );
			strMenuText += _T(" ");
			strMenuText += m_strName;
			menu.ModifyMenu( IDM_SAVE, (MF_STRING | MF_BYCOMMAND), IDM_SAVE, strMenuText );

			menu.EnableMenuItem( IDM_SAVE, (MF_ENABLED | MF_BYCOMMAND) );
			menu.EnableMenuItem( IDM_SAVEAS, (MF_ENABLED | MF_BYCOMMAND) );
			menu.EnableMenuItem( IDM_REVERT, (MF_ENABLED | MF_BYCOMMAND) );
		}
		else
		{
			menu.EnableMenuItem( IDM_SAVE, (MF_GRAYED | MF_BYCOMMAND) );
			menu.EnableMenuItem( IDM_SAVEAS, (MF_GRAYED | MF_BYCOMMAND) );
			menu.EnableMenuItem( IDM_REVERT, (MF_GRAYED | MF_BYCOMMAND) );
		}

		// IDM_RUNTIME_SAVEAS
		if( m_pComponentDoc )
		{
			menu.EnableMenuItem( IDM_RUNTIME_SAVEAS, (MF_ENABLED | MF_BYCOMMAND) );
		}
		else
		{
			menu.EnableMenuItem( IDM_RUNTIME_SAVEAS, (MF_GRAYED | MF_BYCOMMAND) );
		}

		menu.Detach();
	}

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CFileNode IDMUSProdNode::OnRightClickMenuSelect

HRESULT CFileNode::OnRightClickMenuSelect( long lCommandId )
{
	AFX_MANAGE_STATE( AfxGetAppModuleState() );

	CMainFrame* pMainFrame = (CMainFrame *)theApp.m_pMainWnd;
	ASSERT( pMainFrame != NULL );

	HRESULT hr = E_FAIL;

	switch( lCommandId )
	{
		case IDM_SAVE:
			if( m_pIChildNode )
			{
				hr = theApp.m_pFramework->SaveNode( m_pIChildNode );
			}
			break;

		case IDM_SAVEAS:
			if( m_pIChildNode )
			{
				hr = theApp.m_pFramework->SaveNodeAsNewFile( m_pIChildNode );
			}
			break;

		case IDM_REVERT:
			if( m_pIChildNode )
			{
				hr = theApp.m_pFramework->RevertFileToSaved( m_pIChildNode );
			}
			break;

		case IDM_RUNTIME_SAVEAS:
			if( m_pComponentDoc )
			{
				m_pComponentDoc->OnFileRuntimeSaveAs();
				hr = S_OK;
			}
			break;

		case IDM_CUT:
			pMainFrame->m_wndTreeBar.OnEditCut();
			hr = S_OK;
			break;

		case IDM_COPY:
			pMainFrame->m_wndTreeBar.OnEditCopy();
			hr = S_OK;
			break;

		case IDM_PASTE:
			pMainFrame->m_wndTreeBar.OnEditPaste();
			hr = S_OK;
			break;

		case IDM_RENAME:
			if( SUCCEEDED ( theApp.m_pFramework->EditNodeLabel((IDMUSProdNode *)this) ) )
			{
				hr = S_OK;
			}
			break;

		case IDM_DELETE:
			if( pMainFrame->m_wndTreeBar.DeleteTreeNode( this, DTN_PROMPT_USER ) )
			{
				hr = S_OK;
			}
			break;

		case IDM_PROPERTIES:
			OnShowProperties();
			hr = S_OK;
			break;
	}

	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CFileNode IDMUSProdNode::DeleteChildNode

HRESULT CFileNode::DeleteChildNode( IDMUSProdNode* pIChildNode, BOOL fPromptUser )
{
	AFX_MANAGE_STATE( AfxGetAppModuleState() );

	ASSERT( pIChildNode != NULL );
	ASSERT( pIChildNode == m_pIChildNode );

	// Avoid eventual recursive call to m_pIChildNode->DeleteNode
	if( theApp.m_fInDocRootDelete == FALSE )
	{
		m_pIChildNode->DeleteNode( fPromptUser );
	}

	m_pIChildNode->Release();
	m_pIChildNode = NULL;
	m_hChildItem = NULL;

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CFileNode IDMUSProdNode::InsertChildNode

HRESULT CFileNode::InsertChildNode( IDMUSProdNode* pIChildNode )
{
	AFX_MANAGE_STATE( AfxGetAppModuleState() );

	ASSERT( pIChildNode != NULL );

	ReleaseDocument();

	m_pIChildNode = pIChildNode;
	m_pIChildNode->AddRef();

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CFileNode IDMUSProdNode::DeleteNode

HRESULT CFileNode::DeleteNode( BOOL fPromptUser )
{
	AFX_MANAGE_STATE( AfxGetAppModuleState() );

	HRESULT hr = E_FAIL;

	// Remove FileNode
	IDMUSProdNode* pIParentNode;

	if( SUCCEEDED ( GetParentNode(&pIParentNode) ) )
	{
		if( pIParentNode )
		{
			hr = pIParentNode->DeleteChildNode( this, fPromptUser );
			pIParentNode->Release();
		}
	}

	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CFileNode IDMUSProdNode::OnNodeSelChanged

HRESULT CFileNode::OnNodeSelChanged( BOOL fSelected )
{
	AFX_MANAGE_STATE( AfxGetAppModuleState() );

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CFileNode IDMUSProdNode::CreateDataObject

HRESULT CFileNode::CreateDataObject( IDataObject** ppIDataObject )
{
	AFX_MANAGE_STATE( AfxGetAppModuleState() );

	if( m_pIChildNode )
	{
		return m_pIChildNode->CreateDataObject( ppIDataObject );
	}

	// FileNode will create data object containing CF_DMUSPROD_FILE
	if( ppIDataObject == NULL )
	{
		return E_POINTER;
	}

	*ppIDataObject = NULL;

	// Create the CAppJazzDataObject 
	CAppJazzDataObject* pDataObject = new CAppJazzDataObject();
	if( pDataObject == NULL )
	{
		return E_OUTOFMEMORY;
	}

	HRESULT hr = E_FAIL;

	IStream* pIStream;

	// Create a stream in CF_DMUSPROD_FILE format
	if( SUCCEEDED ( theApp.m_pFramework->SaveClipFormat( theApp.m_pFramework->m_cfProducerFile, this, &pIStream ) ) )
	{
		// Place CF_DMUSPROD_FILE into CDllJazzDataObject
		if( SUCCEEDED ( pDataObject->AddClipFormat( theApp.m_pFramework->m_cfProducerFile, pIStream ) ) )
		{
			hr = S_OK;
		}

		pIStream->Release();
	}

	if( SUCCEEDED ( hr ) )
	{
		*ppIDataObject = pDataObject;	// already AddRef'd
	}
	else
	{
		pDataObject->Release();
	}

	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CFileNode IDMUSProdNode::CanCut

HRESULT CFileNode::CanCut( void )
{
	AFX_MANAGE_STATE( AfxGetAppModuleState() );

	if( m_pIChildNode )
	{
		return m_pIChildNode->CanCut();
	}

	// Cannot 'Cut' file unless it has been opened
	return S_FALSE;
}


/////////////////////////////////////////////////////////////////////////////
// CFileNode IDMUSProdNode::CanCopy

HRESULT CFileNode::CanCopy( void )
{
	AFX_MANAGE_STATE( AfxGetAppModuleState() );

	if( m_pIChildNode )
	{
		return m_pIChildNode->CanCopy();
	}

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CFileNode IDMUSProdNode::CanDelete

HRESULT CFileNode::CanDelete( void )
{
	AFX_MANAGE_STATE( AfxGetAppModuleState() );

	if( m_pIChildNode )
	{
		return m_pIChildNode->CanDelete();
	}

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CFileNode IDMUSProdNode::CanDeleteChildNode

HRESULT CFileNode::CanDeleteChildNode( IDMUSProdNode* pIChildNode )
{
//	AFX_MANAGE_STATE( AfxGetAppModuleState() );

	// Should not get here!
	ASSERT( 0 );

	return E_NOTIMPL;
}


/////////////////////////////////////////////////////////////////////////////
// CFileNode IDMUSProdNode::CanPasteFromData

HRESULT CFileNode::CanPasteFromData( IDataObject* pIDataObject, BOOL* pfWillSetReference )
{
	AFX_MANAGE_STATE( AfxGetAppModuleState() );
	
	if( pfWillSetReference == NULL )
	{
		return E_POINTER;
	}

	*pfWillSetReference = FALSE;

	if( m_pIChildNode )
	{
		return m_pIChildNode->CanPasteFromData( pIDataObject, pfWillSetReference );
	}

	return S_FALSE;
}


/////////////////////////////////////////////////////////////////////////////
// CFileNode IDMUSProdNode::PasteFromData

HRESULT CFileNode::PasteFromData( IDataObject* pIDataObject )
{
	AFX_MANAGE_STATE( AfxGetAppModuleState() );

	if( m_pIChildNode )
	{
		return m_pIChildNode->PasteFromData( pIDataObject );
	}

	return E_FAIL;
}


/////////////////////////////////////////////////////////////////////////////
// CFileNode IDMUSProdNode::CanChildPasteFromData

HRESULT CFileNode::CanChildPasteFromData( IDataObject* pIDataObject, IDMUSProdNode* pIChildNode,
										  BOOL* pfWillSetReference )
{
//	AFX_MANAGE_STATE( AfxGetAppModuleState() );

	// Should not get here!
	ASSERT( 0 );

	return E_NOTIMPL;
}


/////////////////////////////////////////////////////////////////////////////
// CFileNode IDMUSProdNode::ChildPasteFromData

HRESULT CFileNode::ChildPasteFromData( IDataObject* pIDataObject, IDMUSProdNode* pIChildNode )
{
//	AFX_MANAGE_STATE( AfxGetAppModuleState() );

	// Should not get here!
	ASSERT( 0 );

	return E_NOTIMPL;
}


/////////////////////////////////////////////////////////////////////////////
// CFileNode IDMUSProdNode::GetObject

HRESULT CFileNode::GetObject( REFCLSID rclsid, REFIID riid, void** ppvObject )
{
//	AFX_MANAGE_STATE( AfxGetAppModuleState() );

	return E_NOTIMPL;
}


/////////////////////////////////////////////////////////////////////////////
// Additional methods

/////////////////////////////////////////////////////////////////////////////
// CFileNode LinkToRuntimeFile

void CFileNode::LinkToRuntimeFile( LPCTSTR szRuntimeFileName )
{
	CString strFileName = szRuntimeFileName;
	CString strPath;
	CString strName;
	CString strExt;
	CString strRuntimeFolder;

	ASSERT( m_pProject != NULL );

	// Split path from filename
	int nFindPos = strFileName.ReverseFind( (TCHAR)'\\' );
	if( nFindPos != -1 )
	{
		strPath = strFileName.Left( nFindPos + 1 );
		strName = strFileName.Right( strFileName.GetLength() - nFindPos - 1 );
	}

	// Extract extension from filename
	nFindPos = strFileName.ReverseFind( (TCHAR)'.' );
	if( nFindPos != -1 )
	{
		strExt = strFileName.Right( strFileName.GetLength() - nFindPos );
	}
	ASSERT( !strExt.IsEmpty() );

	// Get the current runtime folder
	ConstructRuntimePath( strRuntimeFolder );

	// Set the new default runtime folder
	if( strRuntimeFolder.CompareNoCase( strPath ) != 0 )
	{
		CString strDefaultRuntimeFolder;

		m_pProject->GetDefaultRuntimeFolderByExt( strExt, strDefaultRuntimeFolder );
		if( strDefaultRuntimeFolder.CompareNoCase( strPath ) == 0 )
		{
			m_strRuntimeFolder.Empty();
		}
		else
		{
			m_strRuntimeFolder = strPath;
		}
	}

	// Set the new default runtime filename
	m_strRuntimeFileName = strName;

	// Set the new runtime file
	m_strRuntimeFile = szRuntimeFileName;

	// Refresh Property sheet
	IDMUSProdPropSheet* pIPropSheet = theApp.GetPropertySheet();
	if( pIPropSheet )
	{
		pIPropSheet->RefreshActivePageByObject( this );
		pIPropSheet->Release();
	}
}


/////////////////////////////////////////////////////////////////////////////
// CFileNode ConstructFileName

void CFileNode::ConstructFileName( CString& strFileName )
{
	strFileName.Empty();

	GUID guidNodeId;
	IDMUSProdNode* pINode;

	if( FAILED ( GetParentNode ( &pINode ) ) )
	{
		pINode = NULL;
	}

	ASSERT( pINode != NULL );

	if( pINode )
	{
		CString strPath;

		if( SUCCEEDED ( pINode->GetNodeId( &guidNodeId ) ) )
		{
			if( IsEqualGUID ( guidNodeId, GUID_ProjectFolderNode )
			||  IsEqualGUID ( guidNodeId, GUID_DirectoryNode ) )
			{
				CDirectoryNode* pDirNode = (CDirectoryNode *)pINode;
				pDirNode->ConstructPath( strPath );
			}
		}

		if( !strPath.IsEmpty() )
		{
			strFileName = strPath + m_strName;
		}

		pINode->Release();
	}
}


/////////////////////////////////////////////////////////////////////////////
// CFileNode ConstructRuntimePath

void CFileNode::ConstructRuntimePath( CString& strRuntimePath )
{
	ASSERT( m_pProject != NULL );

	strRuntimePath.Empty();

	// See if user has selected specific folder for this file
	if( !m_strRuntimeFolder.IsEmpty() )
	{
		strRuntimePath = m_strRuntimeFolder;
		return;
	}

	// See if there is a default runtime folder for this file extension
	CString strExt;

	int nFindPos = m_strName.ReverseFind( (TCHAR)'.' );
	if( nFindPos != -1 )
	{
		strExt = m_strName.Right( m_strName.GetLength() - nFindPos );
	}
	ASSERT( !strExt.IsEmpty() );

	m_pProject->GetDefaultRuntimeFolderByExt( strExt, strRuntimePath );
}


/////////////////////////////////////////////////////////////////////////////
// CFileNode ConstructRelativePath

BOOL CFileNode::ConstructRelativePath( CString& strRelativePath )
{
	BOOL fSuccess = FALSE;

	ASSERT( m_pProject != NULL );

	strRelativePath.Empty();

	GUID guidNodeId;
	IDMUSProdNode* pINode;

	if( FAILED ( GetParentNode ( &pINode ) ) )
	{
		pINode = NULL;
	}

	ASSERT( pINode != NULL );

	if( pINode )
	{
		if( SUCCEEDED ( pINode->GetNodeId( &guidNodeId ) ) )
		{
			if( IsEqualGUID ( guidNodeId, GUID_ProjectFolderNode )
			||  IsEqualGUID ( guidNodeId, GUID_DirectoryNode ) )
			{
				CDirectoryNode* pDirNode = (CDirectoryNode *)pINode;
				pDirNode->ConstructPath( strRelativePath );
			}
		}

		if( !strRelativePath.IsEmpty() )
		{
			if( strRelativePath.Find( m_pProject->m_strProjectDir ) == 0 )
			{
				// Strip Project directory from path
				strRelativePath = strRelativePath.Right( strRelativePath.GetLength() - m_pProject->m_strProjectDir.GetLength() );

				// Remove last backslash
				if( strRelativePath.Right(1) == _T("\\") )
				{
					strRelativePath = strRelativePath.Left( strRelativePath.GetLength() - 1 );
				}
				
				fSuccess = TRUE;
			}
		}

		pINode->Release();
	}

	return fSuccess;
}


/////////////////////////////////////////////////////////////////////////////
// CFileNode SyncListInfo

void CFileNode::SyncListInfo()
{
	// Force sync if DMUSProdListInfo fields are empty
	if( m_strListInfoName.IsEmpty()
	&&  m_strListInfoDescriptor.IsEmpty() )
	{
		m_wFlags |= FSF_DOSYNC;
	}

	// Force sync if DMUSProdListInfo object GUID is GUID_AllZeros
	if( ::IsEqualGUID(m_guidListInfoObject, GUID_AllZeros) )
	{
		m_wFlags |= FSF_DOSYNC;
	}

	// No work if we are already in sync
	if( !(m_wFlags & FSF_DOSYNC) )
	{
		return;
	}

	// Initialize DMUSProdListInfo fields
	m_strListInfoName.Empty();
	m_strListInfoDescriptor.Empty();
    memset( &m_guidListInfoObject, 0, sizeof(GUID) );
	

	// Get complete path/filename
	CString strFileName;
	ConstructFileName( strFileName );

	// Get IDMUSProdDocType* for the file
	IDMUSProdDocType* pIDocType = theApp.GetDocType( strFileName );

	if( pIDocType )
	{

		// Open the file
		IStream* pIStream;
		BSTR bstrFileName = strFileName.AllocSysString();

		if( SUCCEEDED ( theApp.m_pFramework->AllocFileStream ( bstrFileName, GENERIC_READ, FT_UNKNOWN,
															   GUID_AllZeros, m_pIParentNode, &pIStream ) ) )
		{
			DMUSProdListInfo ListInfo;

			ZeroMemory( &ListInfo, sizeof(ListInfo) );
			ListInfo.wSize = sizeof(ListInfo);

			if( SUCCEEDED ( pIDocType->GetListInfo ( pIStream, &ListInfo ) ) )
			{
				if( ListInfo.bstrName )
				{
					m_strListInfoName = ListInfo.bstrName;
					::SysFreeString( ListInfo.bstrName );

				}

				if( ListInfo.bstrDescriptor )
				{
					m_strListInfoDescriptor = ListInfo.bstrDescriptor;
					::SysFreeString( ListInfo.bstrDescriptor );

				}

				memcpy( &m_guidListInfoObject, &ListInfo.guidObject, sizeof(GUID) );
			}

			m_wFlags &= ~FSF_DOSYNC;

			pIStream->Release();
		}

		pIDocType->Release();
	}
}


/////////////////////////////////////////////////////////////////////////////
// CFileNode MoveWPListToNodes

void CFileNode::MoveWPListToNodes( void )
{
	// Value in m_pIChildNode means file has been loaded
	ASSERT( m_pIChildNode != NULL );

	wpWindowPlacement* pWP;
	HTREEITEM hItem;

	// Empty WP list
	while( !m_lstWP.IsEmpty() )
	{
		pWP = static_cast<wpWindowPlacement*>( m_lstWP.RemoveHead() );

		// Find the corresponding node in the Project Tree
		hItem = theApp.m_pFramework->FindTreeItemByWP( pWP );
		if( hItem )
		{
			// Apply WP Settings to the node
			theApp.m_pFramework->ApplyWPSettings( hItem, pWP );
		}

		delete pWP;
	}
}


/////////////////////////////////////////////////////////////////////////////
// CFileNode EmptyNotifyNodesList

void CFileNode::EmptyNotifyNodesList()
{
	CJzNotifyNode* pJzNotifyNode;

	while( !m_lstNotifyNodes.IsEmpty() )
	{
		pJzNotifyNode = static_cast<CJzNotifyNode*>( m_lstNotifyNodes.RemoveHead() );
		delete( pJzNotifyNode );
	}
}


/////////////////////////////////////////////////////////////////////////////
// CFileNode ReleaseDocument

void CFileNode::ReleaseDocument()
{
	// Remove FileNode's child (associated document)
	if( m_pIChildNode )
	{
		if( m_pComponentDoc )
		{
			m_pComponentDoc->OnCloseDocument();		// No Save - Unconditional close!!!!!!!

			CMainFrame* pMainFrame = (CMainFrame *)theApp.m_pMainWnd;
			if( pMainFrame )
			{
				pMainFrame->RecalcLayout( TRUE );
			}
		}

		DeleteChildNode( m_pIChildNode, FALSE );
	}
}


/////////////////////////////////////////////////////////////////////////////
// CFileNode IsProducerFile

BOOL CFileNode::IsProducerFile( void )
{
	if( m_pIChildNode )
	{
		return TRUE;
	}

	IDMUSProdDocType* pIDocType = theApp.GetDocType( m_strName );

	if( pIDocType )
	{
		pIDocType->Release();
		return TRUE;
	}

	return FALSE;
}


/////////////////////////////////////////////////////////////////////////////
// CFileNode::SaveTreeNodesWP

HRESULT CFileNode::SaveTreeNodesWP( IDMUSProdRIFFStream* pIRiffStream, CTreeCtrl* pTreeCtrl, HTREEITEM hItem ) 
{
	HRESULT hr = S_OK;
	HTREEITEM hChildItem;
	CJzNode* pJzNode;
	wpWindowPlacement WP;

	ASSERT( pIRiffStream != NULL );
	ASSERT( pTreeCtrl != NULL );
	ASSERT( hItem != NULL );

	while( hItem )
	{
		pJzNode = (CJzNode *)pTreeCtrl->GetItemData( hItem );
		if( pJzNode )
		{
			ASSERT( pJzNode->m_pINode != NULL );

			if( pJzNode->m_wp.length != 0 )
			{
				// Get Node Name
				BSTR bstrNodeName;
				if( SUCCEEDED ( pJzNode->m_pINode->GetNodeName ( &bstrNodeName ) ) )
				{
					WP.strNodeName = bstrNodeName;
					::SysFreeString( bstrNodeName );

					// Get Node ID
					if( SUCCEEDED ( pJzNode->m_pINode->GetNodeId ( &WP.guidNodeId ) ) )
					{
						memcpy( &WP.guidFile, &m_guid, sizeof( WP.guidFile ) );
						WP.lTreePos = theApp.m_pFramework->GetWPTreePos( pJzNode->m_pINode );

						WP.wp.length = sizeof(WP.wp);
						WP.wp.flags = pJzNode->m_wp.flags;
						WP.wp.showCmd = pJzNode->m_wp.showCmd;
						WP.wp.ptMinPosition = pJzNode->m_wp.ptMinPosition;
						WP.wp.ptMaxPosition = pJzNode->m_wp.ptMaxPosition;
						WP.wp.rcNormalPosition = pJzNode->m_wp.rcNormalPosition;

						hr = SaveNodeWP( pIRiffStream, &WP );		
					}
				}
			}
		}

		if( FAILED ( hr ) )
		{
			break;
		}

		// Handle Node's children
		hChildItem = hItem;
		while( hChildItem = pTreeCtrl->GetNextItem(hChildItem, TVGN_CHILD) )
		{
			hr = SaveTreeNodesWP( pIRiffStream, pTreeCtrl, hChildItem );
			if( FAILED ( hr ) )
			{
				break;
			}
		}

		if( FAILED ( hr ) )
		{
			break;
		}

		hItem = pTreeCtrl->GetNextItem( hItem, TVGN_NEXT );
	}

	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CFileNode SaveTheFile

HRESULT CFileNode::SaveTheFile( IDMUSProdRIFFStream* pIRiffStream )
{
	IStream* pIStream;
	HRESULT hr;
	POSITION pos;
	MMCKINFO ck;

    pIStream = pIRiffStream->GetStream();
	ASSERT( pIStream != NULL );

	// Write File list header
	ck.fccType = FOURCC_FILE_LIST;
	if( pIRiffStream->CreateChunk(&ck, MMIO_CREATELIST) != 0 )
	{
		hr = E_FAIL;
		goto ON_ERROR;
	}

	// Save Filename chunk
	hr = SaveFileNameChunk( pIRiffStream );
	if( FAILED ( hr ) )
	{
		goto ON_ERROR;
	}

	// Save File chunk
	hr = SaveFileChunk( pIRiffStream );
	if( FAILED ( hr ) )
	{
		goto ON_ERROR;
	}

	// Save File's notify list
	if( m_lstNotifyNodes.GetCount() > 0 )
	{
		hr = SaveNotifyNodesList( pIRiffStream );
		if( FAILED ( hr ) )
		{
			goto ON_ERROR;
		}
	}

	// Save File info
	hr = SaveFileInfo( pIRiffStream );
	if( FAILED ( hr ) )
	{
		goto ON_ERROR;
	}

	// Save WindowPlacement information for nodes in Project Tree
	if( m_hChildItem )
	{
		CTreeCtrl* pTreeCtrl = theApp.GetProjectTreeCtrl();
		if( pTreeCtrl )
		{
			hr = SaveTreeNodesWP( pIRiffStream, pTreeCtrl, m_hChildItem );
			if( FAILED ( hr ) )
			{
				goto ON_ERROR;
			}
		}
	}
	else
	{
		wpWindowPlacement* pWP;

		pos = m_lstWP.GetHeadPosition();
		while( pos )
		{
			pWP = m_lstWP.GetNext( pos );

			hr = SaveNodeWP( pIRiffStream, pWP );		
			if( FAILED ( hr ) )
			{
				goto ON_ERROR;
			}
		}
	}
	
	if( pIRiffStream->Ascend( &ck, 0 ) != 0 )
	{
 		hr = E_FAIL;
		goto ON_ERROR;
	}

ON_ERROR:
    pIStream->Release();
    return hr;
}



/////////////////////////////////////////////////////////////////////////////
// CFileNode SaveFileNameChunk

HRESULT CFileNode::SaveFileNameChunk( IDMUSProdRIFFStream* pIRiffStream )
{
	IStream* pIStream;
	HRESULT hr;
	MMCKINFO ck;
	CString strRelativePath;

    pIStream = pIRiffStream->GetStream();
	ASSERT( pIStream != NULL );

	// Get the file's relative path
	if( ConstructRelativePath( strRelativePath ) )
	{
		if( !strRelativePath.IsEmpty() )
		{
			strRelativePath += _T("\\");
		}
		strRelativePath += m_strName;
	}
	if( strRelativePath.IsEmpty() )
	{
		hr = E_FAIL;
		goto ON_ERROR;
	}

	// Write filename (relative path)
	ck.ckid = FOURCC_NAME_CHUNK;
	if( pIRiffStream->CreateChunk( &ck, 0 ) != 0 )
	{
		hr = E_FAIL;
		goto ON_ERROR;
	}

	hr = SaveMBStoWCS( pIStream, &strRelativePath );
	if( FAILED( hr ) )
	{
		goto ON_ERROR;
	}

	if( pIRiffStream->Ascend(&ck, 0) != 0 )
	{
		hr = E_FAIL;
		goto ON_ERROR;
	}

ON_ERROR:
    pIStream->Release();
    return hr;
}

/////////////////////////////////////////////////////////////////////////////
// CFileNode SaveFileChunk

HRESULT CFileNode::SaveFileChunk( IDMUSProdRIFFStream* pIRiffStream )
{
	IStream* pIStream;
	HRESULT hr;
	MMCKINFO ck;
	DWORD dwBytesWritten;
	HANDLE hFile;
	CString strFileName;
	ioJzFile oJzFile;

    pIStream = pIRiffStream->GetStream();
	ASSERT( pIStream != NULL );

	// Get the file's complete path/filename
	ConstructFileName( strFileName );
	if( strFileName.IsEmpty() )
	{
		hr = E_FAIL;
		goto ON_ERROR;
	}

	// Write File chunk header
	ck.ckid = FOURCC_FILE_CHUNK;
	if( pIRiffStream->CreateChunk( &ck, 0 ) != 0 )
	{
		hr = E_FAIL;
		goto ON_ERROR;
	}

	// Prepare ioJzFile structure
	memset( &oJzFile, 0, sizeof(ioJzFile) );
	memcpy( &oJzFile.m_guidFile, &m_guid, sizeof(GUID) );

	// Get the DMUSProdListInfo's guidObject field
	DMUSProdListInfo TreeListInfo;
	ZeroMemory( &TreeListInfo, sizeof(TreeListInfo) );
	TreeListInfo.wSize = sizeof(TreeListInfo);
	GetNodeListInfo ( &TreeListInfo );
	if( TreeListInfo.bstrName )
	{
		::SysFreeString( TreeListInfo.bstrName );
	}
	if( TreeListInfo.bstrDescriptor )
	{
		::SysFreeString( TreeListInfo.bstrDescriptor );
	}
	memcpy( &oJzFile.m_guidListInfoObject, &TreeListInfo.guidObject, sizeof(GUID) );

	// Get file information
    hFile = ::CreateFile( strFileName, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING,
						  FILE_ATTRIBUTE_NORMAL, NULL );
	if( hFile != INVALID_HANDLE_VALUE )
	{
		//		File size
		DWORD dwFileSize = GetFileSize( hFile, NULL );
		if( dwFileSize !=  0xFFFFFFFF )
		{
			oJzFile.m_dwSize = dwFileSize;
		}

		//		Modified
		FILETIME ftModified;

		if( ::GetFileTime(hFile, NULL, NULL, &ftModified) )
		{
			oJzFile.m_ftModified = ftModified;
		}

		CloseHandle( hFile );
	}

	// Write File chunk data
	hr = pIStream->Write( &oJzFile, sizeof(ioJzFile), &dwBytesWritten);
	if( FAILED( hr )
	||  dwBytesWritten != sizeof(ioJzFile) )
	{
        hr = E_FAIL;
        goto ON_ERROR;
	}

	if( pIRiffStream->Ascend(&ck, 0) != 0 )
	{
		hr = E_FAIL;
		goto ON_ERROR;
	}

ON_ERROR:
    pIStream->Release();
    return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CFileNode SaveFileInfo
	
HRESULT CFileNode::SaveFileInfo( IDMUSProdRIFFStream* pIRiffStream )
{
	IStream* pIStream;
	HRESULT hr;
    MMCKINFO ckMain;
    MMCKINFO ck;
	CString strText;

    pIStream = pIRiffStream->GetStream();
	ASSERT( pIStream != NULL );

	// Write INFO LIST header
	ckMain.fccType = FOURCC_UNFO_LIST;
	if( pIRiffStream->CreateChunk(&ckMain, MMIO_CREATELIST) != 0 )
	{
		hr = E_FAIL;
		goto ON_ERROR;
	}

	// Write name of most recently saved Runtime file
	if( !m_strRuntimeFile.IsEmpty() )
	{
		ck.ckid = FOURCC_UNFO_RUNTIME_FILE;
		if( pIRiffStream->CreateChunk( &ck, 0 ) != 0 )
		{
			hr = E_FAIL;
			goto ON_ERROR;
		}

		hr = SaveMBStoWCS( pIStream, &m_strRuntimeFile );
		if( FAILED( hr ) )
		{
			goto ON_ERROR;
		}

		if( pIRiffStream->Ascend(&ck, 0) != 0 )
		{
			hr = E_FAIL;
			goto ON_ERROR;
		}
	}

	// Write folder used when saving Runtime file
	if( !m_strRuntimeFolder.IsEmpty() )
	{
		ck.ckid = FOURCC_UNFO_RUNTIME_FOLDER;
		if( pIRiffStream->CreateChunk( &ck, 0 ) != 0 )
		{
			hr = E_FAIL;
			goto ON_ERROR;
		}

		hr = SaveMBStoWCS( pIStream, &m_strRuntimeFolder );
		if( FAILED( hr ) )
		{
			goto ON_ERROR;
		}

		if( pIRiffStream->Ascend(&ck, 0) != 0 )
		{
			hr = E_FAIL;
			goto ON_ERROR;
		}
	}

	// Write name used when saving Runtime file
	if( !m_strRuntimeFileName.IsEmpty() )
	{
		ck.ckid = FOURCC_UNFO_RUNTIME_NAME;
		if( pIRiffStream->CreateChunk( &ck, 0 ) != 0 )
		{
			hr = E_FAIL;
			goto ON_ERROR;
		}

		hr = SaveMBStoWCS( pIStream, &m_strRuntimeFileName );
		if( FAILED( hr ) )
		{
			goto ON_ERROR;
		}

		if( pIRiffStream->Ascend(&ck, 0) != 0 )
		{
			hr = E_FAIL;
			goto ON_ERROR;
		}
	}

	// Fill the DMUSProdListInfo structure
	DMUSProdListInfo TreeListInfo;

	ZeroMemory( &TreeListInfo, sizeof(TreeListInfo) );
	TreeListInfo.wSize = sizeof(TreeListInfo);
	GetNodeListInfo ( &TreeListInfo );

	// Write DocRoot node name
	if( TreeListInfo.bstrName )
	{
		strText = TreeListInfo.bstrName;
		::SysFreeString( TreeListInfo.bstrName );

		if( !strText.IsEmpty() )
		{
			ck.ckid = FOURCC_UNFO_NODE_NAME;
			if( pIRiffStream->CreateChunk( &ck, 0 ) != 0 )
			{
				hr = E_FAIL;
				goto ON_ERROR;
			}

			hr = SaveMBStoWCS( pIStream, &strText );
			if( FAILED( hr ) )
			{
				goto ON_ERROR;
			}

			if( pIRiffStream->Ascend(&ck, 0) != 0 )
			{
				hr = E_FAIL;
				goto ON_ERROR;
			}
		}
	}

	// Write DocRoot node descriptor
	if( TreeListInfo.bstrDescriptor )
	{
		strText = TreeListInfo.bstrDescriptor;
		::SysFreeString( TreeListInfo.bstrDescriptor );

		if( !strText.IsEmpty() )
		{
			ck.ckid = FOURCC_UNFO_NODE_DESC;
			if( pIRiffStream->CreateChunk( &ck, 0 ) != 0 )
			{
				hr = E_FAIL;
				goto ON_ERROR;
			}

			hr = SaveMBStoWCS( pIStream, &strText );
			if( FAILED( hr ) )
			{
				goto ON_ERROR;
			}

			if( pIRiffStream->Ascend(&ck, 0) != 0 )
			{
				hr = E_FAIL;
				goto ON_ERROR;
			}
		}
	}

	if( pIRiffStream->Ascend(&ckMain, 0) != 0 )
	{
		hr = E_FAIL;
		goto ON_ERROR;
	}

ON_ERROR:
    pIStream->Release();
    return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CFileNode SaveNotifyNodesList
	
HRESULT CFileNode::SaveNotifyNodesList( IDMUSProdRIFFStream* pIRiffStream )
{
	IStream* pIStream;
	HRESULT hr;
	MMCKINFO ck;
	DWORD dwBytesWritten;
	CJzNotifyNode* pJzNotifyNode;
	POSITION pos;

    pIStream = pIRiffStream->GetStream();
	ASSERT( pIStream != NULL );

	// Write File chunk header
	ck.ckid = FOURCC_NOTIFY_CHUNK;
	if( pIRiffStream->CreateChunk( &ck, 0 ) != 0 )
	{
		hr = E_FAIL;
		goto ON_ERROR;
	}

	// Write each GUID in the notify list
	pos = m_lstNotifyNodes.GetHeadPosition();
	while( pos )
	{
		pJzNotifyNode = static_cast<CJzNotifyNode*>( m_lstNotifyNodes.GetNext(pos) );

		hr = pIStream->Write( &pJzNotifyNode->m_guidFile, sizeof(GUID), &dwBytesWritten);
		if( FAILED( hr )
		||  dwBytesWritten != sizeof(GUID) )
		{
			hr = E_FAIL;
			goto ON_ERROR;
		}
	}

	if( pIRiffStream->Ascend(&ck, 0) != 0 )
	{
		hr = E_FAIL;
		goto ON_ERROR;
	}

ON_ERROR:
    pIStream->Release();
    return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CFileNode SaveNodeWP
	
HRESULT CFileNode::SaveNodeWP( IDMUSProdRIFFStream* pIRiffStream, wpWindowPlacement* pWP )
{
	IStream* pIStream;
	HRESULT hr;
	MMCKINFO ckMain;
	MMCKINFO ck;

    pIStream = pIRiffStream->GetStream();
	ASSERT( pIStream != NULL );

	// Write Node list header
	ckMain.fccType = FOURCC_NODE_LIST;
	if( pIRiffStream->CreateChunk(&ckMain, MMIO_CREATELIST) != 0 )
	{
		hr = E_FAIL;
		goto ON_ERROR;
	}

	// Save Node name
	ck.ckid = FOURCC_NAME_CHUNK;
	if( pIRiffStream->CreateChunk( &ck, 0 ) != 0 )
	{
		hr = E_FAIL;
		goto ON_ERROR;
	}

	hr = SaveMBStoWCS( pIStream, &pWP->strNodeName );
	if( FAILED( hr ) )
	{
		goto ON_ERROR;
	}

	if( pIRiffStream->Ascend(&ck, 0) != 0 )
	{
		hr = E_FAIL;
		goto ON_ERROR;
	}

	// Save Node chunk
	hr = SaveNodeWPChunk( pIRiffStream, pWP );
	if( FAILED ( hr ) )
	{
		goto ON_ERROR;
	}
	
	if( pIRiffStream->Ascend( &ckMain, 0 ) != 0 )
	{
 		hr = E_FAIL;
		goto ON_ERROR;
	}

ON_ERROR:
    pIStream->Release();
    return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CFileNode SaveNodeWPChunk
	
HRESULT CFileNode::SaveNodeWPChunk( IDMUSProdRIFFStream* pIRiffStream, wpWindowPlacement* pWP )
{
	IStream* pIStream;
	HRESULT hr;
	MMCKINFO ck;
	DWORD dwBytesWritten;
	ioJzNode oJzNode;

    pIStream = pIRiffStream->GetStream();
	ASSERT( pIStream != NULL );

	// Write Node chunk header
	ck.ckid = FOURCC_EDITOR_WP_CHUNK;
	if( pIRiffStream->CreateChunk( &ck, 0 ) != 0 )
	{
		hr = E_FAIL;
		goto ON_ERROR;
	}

	// Prepare ioJzNode structure
	memset( &oJzNode, 0, sizeof(ioJzNode) );

	memcpy( &oJzNode.m_guidNodeId, &pWP->guidNodeId, sizeof(GUID) );
	oJzNode.m_lTreePos = pWP->lTreePos;
	oJzNode.m_wpEditor.length = sizeof(oJzNode.m_wpEditor);
	oJzNode.m_wpEditor.flags = pWP->wp.flags;
	oJzNode.m_wpEditor.showCmd = pWP->wp.showCmd;
	oJzNode.m_wpEditor.ptMinPosition = pWP->wp.ptMinPosition;
	oJzNode.m_wpEditor.ptMaxPosition = pWP->wp.ptMaxPosition;
	oJzNode.m_wpEditor.rcNormalPosition = pWP->wp.rcNormalPosition;

	// Write Node chunk data
	hr = pIStream->Write( &oJzNode, sizeof(ioJzNode), &dwBytesWritten);
	if( FAILED( hr )
	||  dwBytesWritten != sizeof(ioJzNode) )
	{
        hr = E_FAIL;
        goto ON_ERROR;
	}

	if( pIRiffStream->Ascend(&ck, 0) != 0 )
	{
		hr = E_FAIL;
		goto ON_ERROR;
	}

ON_ERROR:
    pIStream->Release();
    return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CFileNode LoadNodeWP

HRESULT CFileNode::LoadNodeWP( IDMUSProdRIFFStream* pIRiffStream, MMCKINFO* pckMain, wpWindowPlacement* pWP )
{
    IStream* pIStream;
	MMCKINFO ck;
	DWORD dwByteCount;
	DWORD dwSize;
    HRESULT hr = E_FAIL;

    pIStream = pIRiffStream->GetStream();
	ASSERT( pIStream != NULL );

	while( pIRiffStream->Descend( &ck, pckMain, 0 ) == 0 )
	{
		switch( ck.ckid )
		{
			case FOURCC_NAME_CHUNK:
				ReadMBSfromWCS( pIStream, ck.cksize, &pWP->strNodeName );
				break;

			case FOURCC_EDITOR_WP_CHUNK:
			{
				ioJzNode iJzNode;

				dwSize = min( ck.cksize, sizeof( ioJzNode ) );
				hr = pIStream->Read( &iJzNode, dwSize, &dwByteCount );
				if( FAILED( hr )
				||  dwByteCount != dwSize )
				{
					hr = E_FAIL;
					goto ON_ERROR;
				}

				memcpy( &pWP->guidFile, &m_guid, sizeof(GUID) );
				memcpy( &pWP->guidNodeId, &iJzNode.m_guidNodeId, sizeof(GUID) );
				pWP->lTreePos = iJzNode.m_lTreePos;
				pWP->wp.length = sizeof(pWP->wp);
				pWP->wp.flags = iJzNode.m_wpEditor.flags;
				pWP->wp.showCmd = iJzNode.m_wpEditor.showCmd;
				pWP->wp.ptMinPosition = iJzNode.m_wpEditor.ptMinPosition;
				pWP->wp.ptMaxPosition = iJzNode.m_wpEditor.ptMaxPosition;
				pWP->wp.rcNormalPosition = iJzNode.m_wpEditor.rcNormalPosition;
				break;
			}
		}

		pIRiffStream->Ascend( &ck, 0 );
	}

ON_ERROR:
    pIStream->Release();
    return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CFileNode LoadTheFile

HRESULT CFileNode::LoadTheFile( IDMUSProdRIFFStream* pIRiffStream, MMCKINFO* pckMain )
{
    IStream* pIStream;
	MMCKINFO ck;
	MMCKINFO ckList;
	DWORD dwByteCount;
	DWORD dwSize;
	HANDLE hFile;
    HRESULT hr = E_FAIL;

	ASSERT( m_pProject != NULL );

    pIStream = pIRiffStream->GetStream();
	ASSERT( pIStream != NULL );

	// Read through the chunks in the File list
    while( pIRiffStream->Descend( &ck, pckMain, 0 ) == 0 )
	{
		switch( ck.ckid )
		{
			case FOURCC_NAME_CHUNK:
			{
				CString strName;
				BSTR bstrName;

				ReadMBSfromWCS( pIStream, ck.cksize, &strName );
				bstrName = strName.AllocSysString();
				SetNodeName( bstrName );
				break;
			}

			case FOURCC_FILE_CHUNK:
			{
				DWORD dwFileSize;
				FILETIME ftModified;
			    ioJzFile iJzFile;
				CString strFileName;

				dwSize = min( ck.cksize, sizeof( ioJzFile ) );
				hr = pIStream->Read( &iJzFile, dwSize, &dwByteCount );
				if( FAILED( hr )
				||  dwByteCount != dwSize )
				{
					hr = E_FAIL;
					goto ON_ERROR;
				}

				memcpy( &m_guid, &iJzFile.m_guidFile, sizeof(GUID) );
				memcpy( &m_guidListInfoObject, &iJzFile.m_guidListInfoObject, sizeof(GUID) );

				// Get file information
				strFileName = m_pProject->m_strProjectDir + m_strName;
				hFile = ::CreateFile( strFileName, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING,
									  FILE_ATTRIBUTE_NORMAL, NULL );
				if( hFile != INVALID_HANDLE_VALUE )
				{
					dwFileSize = GetFileSize( hFile, NULL );
					::GetFileTime( hFile, NULL, NULL, &ftModified );
					CloseHandle( hFile );
				}
				else
				{
					dwFileSize = 0;
					ftModified.dwLowDateTime = 0;
					ftModified.dwHighDateTime = 0;
				}

				// Determine if file DMUSProdListInfo is out of date
				if( dwFileSize != iJzFile.m_dwSize
				||  ftModified.dwLowDateTime != iJzFile.m_ftModified.dwLowDateTime
				||  ftModified.dwHighDateTime != iJzFile.m_ftModified.dwHighDateTime )
				{
					m_wFlags |= FSF_DOSYNC;
				}
				break;
			}

			case FOURCC_NOTIFY_CHUNK:
			{
				CJzNotifyNode* pJzNotifyNode;

				dwSize = ck.cksize;
				while( dwSize )
				{
					pJzNotifyNode = new CJzNotifyNode;
					if( pJzNotifyNode == NULL )
					{
						hr = E_OUTOFMEMORY;
						goto ON_ERROR;
					}

					hr = pIStream->Read( &pJzNotifyNode->m_guidFile, sizeof(GUID), &dwByteCount );
					if( FAILED( hr )
					||  dwByteCount != sizeof(GUID) )
					{
						goto ON_ERROR;
					}

					// Bypass if this file is in another Project and is already open.
					if( theApp.IsFileOpenInDiffProject( pJzNotifyNode->m_guidFile, m_pProject ) )
					{
						delete pJzNotifyNode;
					}
					else
					{
						// At this point use count is zero
						m_lstNotifyNodes.AddTail( pJzNotifyNode );
					}

					dwSize -= sizeof(GUID);
					if( (dwSize > 0)
					&&  (dwSize < sizeof(GUID)) )
					{
						hr = E_FAIL;
						goto ON_ERROR;
					}
				}
				break;
			}

			case FOURCC_LIST:
				switch( ck.fccType )
				{
					case FOURCC_INFO_LIST:
					case FOURCC_UNFO_LIST:
						while( pIRiffStream->Descend( &ckList, &ck, 0 ) == 0 )
						{
							switch( ckList.ckid )
							{
								case FOURCC_UNFO_NODE_NAME:
									ReadMBSfromWCS( pIStream, ckList.cksize, &m_strListInfoName );
									break;

								case FOURCC_UNFO_NODE_DESC:
									ReadMBSfromWCS( pIStream, ckList.cksize, &m_strListInfoDescriptor );
									break;

								case FOURCC_UNFO_RUNTIME_FILE:
									ReadMBSfromWCS( pIStream, ckList.cksize, &m_strRuntimeFile );
									break;

								case FOURCC_UNFO_RUNTIME_FOLDER:
									ReadMBSfromWCS( pIStream, ckList.cksize, &m_strRuntimeFolder );
									break;

								case FOURCC_UNFO_RUNTIME_NAME:
									ReadMBSfromWCS( pIStream, ckList.cksize, &m_strRuntimeFileName );
									break;
							}
							pIRiffStream->Ascend( &ckList, 0 );
						}
						break;

					case FOURCC_NODE_LIST:
					{
						wpWindowPlacement* pWP;

						pWP = new wpWindowPlacement;
						if( pWP == NULL )
						{
							hr = E_OUTOFMEMORY ;
			                goto ON_ERROR;
						}

						hr = LoadNodeWP( pIRiffStream, &ck, pWP );
						if( FAILED( hr ) )
						{
							delete pWP;
			                goto ON_ERROR;
						}
						
						m_lstWP.AddTail( pWP );
						break;
					}
				}
				break;
		}

		pIRiffStream->Ascend( &ck, 0 );
	}

ON_ERROR:
    pIStream->Release();
    return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CFileNode IDMUSProdPropPageObject implementation

/////////////////////////////////////////////////////////////////////////////
// CFileNode IDMUSProdPropPageObject::GetData

HRESULT CFileNode::GetData( void** ppData )
{
	AFX_MANAGE_STATE( AfxGetAppModuleState() );

	if( ppData == NULL )
	{
		return E_POINTER;
	}

	*ppData = this;

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CFileNode IDMUSProdPropPageObject::SetData

HRESULT CFileNode::SetData( void* pData )
{
	AFX_MANAGE_STATE( AfxGetAppModuleState() );

	return E_NOTIMPL;
}


/////////////////////////////////////////////////////////////////////////////
// CFileNode IDMUSProdPropPageObject::OnRemoveFromPageManager

HRESULT CFileNode::OnRemoveFromPageManager( void )
{
	AFX_MANAGE_STATE( AfxGetAppModuleState() );

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CFileNode IDMUSProdPropPageObject::OnShowProperties

HRESULT CFileNode::OnShowProperties( void )
{
	AFX_MANAGE_STATE( AfxGetAppModuleState() );

	// Get the Project page manager
	CFilePropPageManager* pPageManager;

	if( theApp.m_pIPageManager
	&&  theApp.m_pIPageManager->IsEqualPageManagerGUID( GUID_FilePropPageManager ) == S_OK )
	{
		pPageManager = (CFilePropPageManager *)theApp.m_pIPageManager;
	}
	else
	{
		pPageManager = new CFilePropPageManager();
	}

	if( pPageManager == NULL )
	{
		return E_FAIL;
	}

	// Show the FileNode properties
	IDMUSProdPropSheet* pIPropSheet = theApp.GetPropertySheet();
	if( pIPropSheet )
	{
		short nActiveTab = CFilePropPageManager::sm_nActiveTab;

		if( SUCCEEDED ( pIPropSheet->SetPageManager(pPageManager) ) )
		{
			theApp.m_pIPageManager = pPageManager;
			pPageManager->SetObject( this );
			pIPropSheet->SetActivePage( nActiveTab ); 
		}

		pIPropSheet->Show( TRUE );
		pIPropSheet->Release();
	}

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CFileNode AddToNotifyList

void CFileNode::AddToNotifyList( IDMUSProdNode* pINotifyThisNode )
{
	ASSERT( pINotifyThisNode != NULL );
	if( pINotifyThisNode == NULL )
	{
		return;
	}

	CJzNotifyNode* pJzNotifyNode;

	// Just increment m_nUseCount if pINotifyThisNode already in list
	POSITION pos = m_lstNotifyNodes.GetHeadPosition();
	while( pos )
	{
		pJzNotifyNode = static_cast<CJzNotifyNode*>( m_lstNotifyNodes.GetNext(pos) );

		if( pJzNotifyNode->m_pINotifyThisNode == pINotifyThisNode )
		{
			pJzNotifyNode->m_nUseCount++;
			return;
		}
	}

	// Get the CFileNode associated with pINotifyThisNode
	CFileNode* pNotifyFileNode = NULL;
	CComponentDoc* pComponentDoc = theApp.FindComponentDocument( pINotifyThisNode );
	if( pComponentDoc )
	{
		pNotifyFileNode = pComponentDoc->m_pFileNode;
	}

	// Create a new CJzNotifyNode
	pJzNotifyNode = new CJzNotifyNode;
	if( pJzNotifyNode )
	{
		pJzNotifyNode->m_pINotifyThisNode = pINotifyThisNode;
		pJzNotifyNode->m_pINotifyThisNode->AddRef();
		pJzNotifyNode->m_nUseCount++;

		if( pNotifyFileNode )
		{
			memcpy( &pJzNotifyNode->m_guidFile, &pNotifyFileNode->m_guid, sizeof(pNotifyFileNode->m_guid) );
		}

		m_lstNotifyNodes.AddTail( pJzNotifyNode );
	}
}


/////////////////////////////////////////////////////////////////////////////
// CFileNode RemoveFromNotifyList

void CFileNode::RemoveFromNotifyList( IDMUSProdNode* pINotifyThisNode )
{
	ASSERT( pINotifyThisNode != NULL );
	if( pINotifyThisNode == NULL )
	{
		return;
	}

	CJzNotifyNode* pJzNotifyNode;

	POSITION pos1 = m_lstNotifyNodes.GetHeadPosition();
	while( pos1 )
	{
		pJzNotifyNode = static_cast<CJzNotifyNode*>( m_lstNotifyNodes.GetNext(pos1) );

		if( pJzNotifyNode->m_pINotifyThisNode == pINotifyThisNode )
		{
			pJzNotifyNode->m_nUseCount--;
				
			if( pJzNotifyNode->m_nUseCount <= 0 )
			{
				POSITION pos2 = m_lstNotifyNodes.Find( pJzNotifyNode );
				if( pos2 )
				{
					m_lstNotifyNodes.RemoveAt( pos2 );
				}

				delete pJzNotifyNode;
			}
		}
	}
}

/////////////////////////////////////////////////////////////////////////////
// CFileNode AddToNotifyWhenLoadFinished

void CFileNode::AddToNotifyWhenLoadFinished( IDMUSProdNotifySink* pINotifySink )
{
	ASSERT( pINotifySink != NULL );

	if( pINotifySink )
	{
		pINotifySink->AddRef();
		m_lstNotifyWhenLoadFinished.AddTail( pINotifySink );
	}
}

/////////////////////////////////////////////////////////////////////////////
// CFileNode SendLoadFinishedNotifications

void CFileNode::SendLoadFinishedNotifications( void )
{
	ASSERT( m_pIChildNode != NULL );

	while( !m_lstNotifyWhenLoadFinished.IsEmpty() )
	{
		IDMUSProdNotifySink* pINotifySink = m_lstNotifyWhenLoadFinished.RemoveHead();

		pINotifySink->OnUpdate( m_pIChildNode, FRAMEWORK_FileLoadFinished, &m_guid );  
		pINotifySink->Release();
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\Framework\EditLabel.h ===
#if !defined(AFX_EDITLABEL_H__3C8C0742_BBBC_11D0_89AE_00A0C9054129__INCLUDED_)
#define AFX_EDITLABEL_H__3C8C0742_BBBC_11D0_89AE_00A0C9054129__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// EditLabel.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CEditLabel window

class CEditLabel : public CEdit
{
// Construction
public:
	CEditLabel( IDMUSProdNode* pINode );

// Attributes
protected:
	IDMUSProdNode* m_pINode;

// Operations
public:

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CEditLabel)
	public:
	virtual BOOL PreTranslateMessage(MSG* pMsg);
	//}}AFX_VIRTUAL

// Implementation
public:
	virtual ~CEditLabel();

	// Generated message map functions
protected:
	//{{AFX_MSG(CEditLabel)
	//}}AFX_MSG

	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_EDITLABEL_H__3C8C0742_BBBC_11D0_89AE_00A0C9054129__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\Framework\FileNode.h ===
// FileNode.h: interface for the CFileNode class.
//
//////////////////////////////////////////////////////////////////////

#ifndef __FILENODE_H__
#define __FILENODE_H__

class CProject;
class CTabFileDesign;
class CTabFileRuntime;

// Flags used when loading a Project
#define FSF_NOFLAGS		0x0000
#define FSF_DOSYNC		0x0001	// File needs synced
#define FSF_EXISTS		0x0002	// File exists on disk

// "Runtime" save actions
#define RSA_NOACTION	0
#define RSA_SAVE		1
#define RSA_SKIP		2


//////////////////////////////////////////////////////////////////////
//  CFilePropPageManager

class CFilePropPageManager : public CAppBasePropPageManager 
{
friend class CTabFileDesign;
friend class CTabFileRuntime;

public:
	CFilePropPageManager();
	virtual ~CFilePropPageManager();

    // IDMUSProdPropPageManager functions
    HRESULT STDMETHODCALLTYPE GetPropertySheetTitle( BSTR* pbstrTitle, BOOL* pfAddPropertiesText );
    HRESULT STDMETHODCALLTYPE GetPropertySheetPages( IDMUSProdPropSheet* pIPropSheet, LONG* hPropSheetPage[], short* pnNbrPages );
	HRESULT STDMETHODCALLTYPE OnRemoveFromPropertySheet();
    HRESULT STDMETHODCALLTYPE RefreshData();

	// Additional functions
private:
	void RemoveCurrentObject( void );

	// Member variables
private:
	CTabFileDesign*		m_pTabDesign;
	CTabFileRuntime*	m_pTabRuntime;

public:
	static short		sm_nActiveTab;
};


//////////////////////////////////////////////////////////////////////
//  CFileNode

class CFileNode : public IDMUSProdNode, public IDMUSProdPropPageObject
{
friend class CFramework;
friend class CProject;
friend class CComponentDoc;
friend class CDirectoryNode;
friend class CTreeBar;
friend class CDeleteFileDlg;
friend class CRuntimeDupeDlg;
friend class CNotifyList;
friend class CCloseProjectDlg;

public:
	CFileNode();
	virtual ~CFileNode();

    // IUnknown functions
    HRESULT STDMETHODCALLTYPE QueryInterface( REFIID riid, LPVOID *ppv );
    ULONG STDMETHODCALLTYPE AddRef();
    ULONG STDMETHODCALLTYPE Release();

    // IDMUSProdNode functions
	HRESULT STDMETHODCALLTYPE GetNodeImageIndex( short* pnFirstImage );
	HRESULT STDMETHODCALLTYPE UseOpenCloseImages( BOOL* pfUseOpenCloseImages );

    HRESULT STDMETHODCALLTYPE GetFirstChild( IDMUSProdNode** ppIFirstChildNode );
    HRESULT STDMETHODCALLTYPE GetNextChild( IDMUSProdNode* pIChildNode, IDMUSProdNode** ppINextChildNode );

    HRESULT STDMETHODCALLTYPE GetComponent( IDMUSProdComponent** ppIComponent );
    HRESULT STDMETHODCALLTYPE GetDocRootNode( IDMUSProdNode** ppIDocRootNode );
    HRESULT STDMETHODCALLTYPE SetDocRootNode( IDMUSProdNode* pIDocRootNode );
    HRESULT STDMETHODCALLTYPE GetParentNode( IDMUSProdNode** ppIParentNode );
    HRESULT STDMETHODCALLTYPE SetParentNode( IDMUSProdNode* pIParentNode );

    HRESULT STDMETHODCALLTYPE GetNodeId( GUID* pguid );
    HRESULT STDMETHODCALLTYPE GetNodeName( BSTR* pbstrName );
    HRESULT STDMETHODCALLTYPE GetNodeNameMaxLength( short* pnMaxLength );
    HRESULT STDMETHODCALLTYPE ValidateNodeName( BSTR bstrName );
    HRESULT STDMETHODCALLTYPE SetNodeName( BSTR bstrName );
    HRESULT STDMETHODCALLTYPE GetNodeListInfo( DMUSProdListInfo* pListInfo );

    HRESULT STDMETHODCALLTYPE GetEditorClsId( CLSID* pclsid );
    HRESULT STDMETHODCALLTYPE GetEditorTitle( BSTR* pbstrTitle );
    HRESULT STDMETHODCALLTYPE GetEditorWindow( HWND* hWndEditor );
    HRESULT STDMETHODCALLTYPE SetEditorWindow( HWND hWndEditor );

    HRESULT STDMETHODCALLTYPE GetRightClickMenuId( HINSTANCE* phInstance, UINT* pnResourceId );
    HRESULT STDMETHODCALLTYPE OnRightClickMenuInit( HMENU hMenu );
    HRESULT STDMETHODCALLTYPE OnRightClickMenuSelect( long lCommandId );

    HRESULT STDMETHODCALLTYPE DeleteChildNode( IDMUSProdNode* pIChildNode, BOOL fPromptUser );
    HRESULT STDMETHODCALLTYPE InsertChildNode( IDMUSProdNode* pIChildNode );
    HRESULT STDMETHODCALLTYPE DeleteNode( BOOL fPromptUser );

	HRESULT STDMETHODCALLTYPE OnNodeSelChanged( BOOL fSelected );

	HRESULT STDMETHODCALLTYPE CreateDataObject( IDataObject** ppIDataObject );
	HRESULT STDMETHODCALLTYPE CanCut();
	HRESULT STDMETHODCALLTYPE CanCopy();
	HRESULT STDMETHODCALLTYPE CanDelete();
	HRESULT STDMETHODCALLTYPE CanDeleteChildNode( IDMUSProdNode* pIChildNode );
	HRESULT STDMETHODCALLTYPE CanPasteFromData( IDataObject* pIDataObject, BOOL* pfWillSetReference );
	HRESULT STDMETHODCALLTYPE PasteFromData( IDataObject* pIDataObject );
	HRESULT STDMETHODCALLTYPE CanChildPasteFromData( IDataObject* pIDataObject, IDMUSProdNode* pIChildNode, BOOL* pfWillSetReference );
	HRESULT STDMETHODCALLTYPE ChildPasteFromData( IDataObject* pIDataObject, IDMUSProdNode* pIChildNode );

	HRESULT STDMETHODCALLTYPE GetObject( REFCLSID rclsid, REFIID riid, void** ppvObject ); 

    // IDMUSProdPropPageObject functions
    HRESULT STDMETHODCALLTYPE GetData( void** ppData );
    HRESULT STDMETHODCALLTYPE SetData( void* pData );
	HRESULT STDMETHODCALLTYPE OnRemoveFromPageManager();
	HRESULT STDMETHODCALLTYPE OnShowProperties();

	//Additional methods
	void ReleaseDocument();
	BOOL IsProducerFile();

public:
	HRESULT LoadTheFile( IDMUSProdRIFFStream* pIRiffStream, MMCKINFO* pckMain );
	HRESULT SaveTheFile( IDMUSProdRIFFStream* pIRiffStream );
	void LinkToRuntimeFile( LPCTSTR szRuntimeFileName );
	void ConstructFileName( CString& strFileName );
	void ConstructRuntimePath( CString& strRuntimePath );
	BOOL ConstructRelativePath( CString& strRelativePath );
	void SyncListInfo();
	void MoveWPListToNodes();
	void EmptyNotifyNodesList();
	void AddToNotifyWhenLoadFinished( IDMUSProdNotifySink* pINotifySink );
	void SendLoadFinishedNotifications();

private:	
	HRESULT SaveFileChunk( IDMUSProdRIFFStream* pIRiffStream );
	HRESULT SaveFileNameChunk( IDMUSProdRIFFStream* pIRiffStream );
	HRESULT SaveFileInfo( IDMUSProdRIFFStream* pIRiffStream );
	HRESULT SaveNotifyNodesList( IDMUSProdRIFFStream* pIRiffStream );

	HRESULT LoadNodeWP( IDMUSProdRIFFStream* pIRiffStream, MMCKINFO* pckMain, wpWindowPlacement* pWP );
	HRESULT SaveNodeWP( IDMUSProdRIFFStream* pIRiffStream, wpWindowPlacement* pWP );
	HRESULT SaveNodeWPChunk( IDMUSProdRIFFStream* pIRiffStream, wpWindowPlacement* pWP );

	HRESULT SaveTreeNodesWP( IDMUSProdRIFFStream* pIRiffStream, CTreeCtrl* pTreeCtrl, HTREEITEM hItem );

	void AddToNotifyList( IDMUSProdNode* pINotifyThisNode ); 
	void RemoveFromNotifyList( IDMUSProdNode* pINotifyThisNode ); 

	// Member variables
private:
    DWORD			m_dwRef;
	IDMUSProdNode*	m_pIParentNode;
	CString			m_strListInfoName;
	CString			m_strListInfoDescriptor;
	GUID			m_guidListInfoObject;
    CTypedPtrList<CPtrList, CJzNotifyNode*> m_lstNotifyNodes;
	WORD			m_wFlags;
	short			m_nRuntimeSaveAction;

    CTypedPtrList<CPtrList, IDMUSProdNotifySink*> m_lstNotifyWhenLoadFinished;

public:
    GUID			m_guid;					// File's "DirectMusic Producer" GUID	
	CProject*		m_pProject;				// File's Project
	CComponentDoc*	m_pComponentDoc;		// File's Document
	HTREEITEM		m_hItem;				// File's HTREEITEM in Project Tree
	HTREEITEM		m_hChildItem;			// DocRoot's HTREEITEM in Project Tree
	IDMUSProdNode*	m_pIChildNode;			// File's DocRoot Node
	BOOL			m_fInOnOpenDocument;	// In process of loading the file
	CString			m_strName;
	CString			m_strRuntimeFile;		// Last saved Runtime file
	CString			m_strRuntimeFolder;		// Folder used when saving Runtime file		
	CString			m_strRuntimeFileName;	// Name used when saving Runtime file (funk.sty)
    CTypedPtrList<CPtrList, wpWindowPlacement*> m_lstWP;
};

#endif //__FILENODE_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\Framework\HelpBindHost.h ===
// HelpBindHost.h
//
// Declares functions etc. to help implement IBindHost
//

#ifndef __HelpBindHost_H__
#define __HelpBindHost_H__

void CleanupUrlmonStubs();

STDAPI AllocBindHostService(LPCTSTR szContainerFileName,
    IServiceProvider **ppsp);

	// Wrappers for URLMON functions.
// These wrappers are defined so we can run without urlmon.dll existing
// on the target system. This is useful only for the Netscape Plugin.
//
// These definitions depend on symbols defined in urlmon.h (e.g.
// IBindStatusCallback). 
STDAPI HelpCreateAsyncBindCtx(DWORD reserved, IBindStatusCallback *pBSCb, IEnumFORMATETC *pEFetc, IBindCtx **ppBC);
STDAPI HelpCreateURLMoniker(LPMONIKER pMkCtx, LPCWSTR szURL, LPMONIKER FAR * ppmk);
STDAPI HelpMkParseDisplayNameEx(IBindCtx *pbc, LPCWSTR szDisplayName, ULONG *pchEaten, LPMONIKER *ppmk);
STDAPI HelpRegisterBindStatusCallback(LPBC pBC, IBindStatusCallback *pBSCb, IBindStatusCallback** ppBSCBPrev, DWORD dwReserved);
STDAPI HelpRevokeBindStatusCallback(LPBC pBC, IBindStatusCallback *pBSCb);
STDAPI HelpURLOpenStreamA(LPUNKNOWN punk, LPCSTR szURL, DWORD dwReserved, LPBINDSTATUSCALLBACK pbsc);
STDAPI HelpURLDownloadToCacheFileA(LPUNKNOWN punk, LPCSTR szURL, LPTSTR szFile, DWORD cch, DWORD dwReserved, LPBINDSTATUSCALLBACK pbsc);

#endif // __HelpBindHost_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\Framework\Framework.h ===
#ifndef __FRAMEWORK_H__
#define __FRAMEWORK_H__

// Framework.h : header file
//

/*-----------
@doc DMUSPROD
-----------*/

#include <afxtempl.h>


/////////////////////////////////////////////////////////////////////////////
// DirectMusic Producer WindowPlacement Structures 
//

#pragma pack(2)

typedef struct ioWindowPlacement		// Editor window placement information (File IO)
{
	GUID guidFile;
	GUID guidNodeId;
	long lTreePos;

	WINDOWPLACEMENT wp;
} ioWindowPlacement;


typedef struct wpWindowPlacement		// Editor window placement information
{
	CString	strNodeName;
	GUID	guidFile;
	GUID	guidNodeId;
	long	lTreePos;

	short	nInternalUse;				// CBookmark::Create uses to establish Z-Order 

	WINDOWPLACEMENT wp;
} wpWindowPlacement;


typedef struct bkComponentState			// Component state information
{
	CLSID	clsidComponent;
	void*   pComponentStateInfo;		// State info for Component
	DWORD	dwComponentStateInfoSize;	// Size of state info
} bkComponentState;


typedef struct CFProducerFile			// Used when working with CF_DMUSPROD_FILE clipboard data
{
    GUID	guidFile;
	CString strFileName;
} CFProducerFile;

#pragma pack()


/*======================================================================================
STRUCT:  DMUSPRODFILEREFINFO
========================================================================================
@struct DMUSProdFileRefInfo | Contains information used to describe a file reference.
 
@field WORD | wSize | Size of this structure.  Must be filled prior to calling a
		method that populates the remaining DMUSProdFileRefInfo fields. 
@field GUID | guidFile | Producer generated GUID associated with the referenced file.
@field GUID | guidDocRootNodeId | NodeId describing the object associated with the
		referenced file.

--------------------------------------------------------------------------------------*/


class CFileNode;
class CClientToolBar;


/////////////////////////////////////////////////////////////////////////////
// CJzComponent

class CJzComponent
{
// Constructor
public:
	CJzComponent( CLSID clsidComponent, IDMUSProdComponent* pIComponent );
	virtual ~CJzComponent();

// Attributes
public:
	CLSID				m_clsidComponent;
	IDMUSProdComponent* m_pIComponent;
	BOOL				m_fInitialized;
};


/////////////////////////////////////////////////////////////////////////////
// CJzMenu

class CJzMenu
{
// Constructor
public:
	CJzMenu( IDMUSProdMenu* pIMenu, UINT nCommandID );
	virtual ~CJzMenu();

// Attributes
public:
	IDMUSProdMenu* m_pIMenu;
	UINT 	   m_nCommandID;
};


/////////////////////////////////////////////////////////////////////////////
// CJzToolBar

class CJzToolBar
{
// Constructor
public:
	CJzToolBar();
	virtual ~CJzToolBar();

// Attributes
public:
	CClientToolBar*	m_pClientToolBar;
	UINT 			m_nControlID;
};


/////////////////////////////////////////////////////////////////////////////
// CJzNode

class CJzNode
{
// Constructor
public:
	CJzNode( IDMUSProdNode* pINode );
	virtual ~CJzNode();

// Attributes
public:
	IDMUSProdNode*		m_pINode;
	WINDOWPLACEMENT m_wp;
};


/////////////////////////////////////////////////////////////////////////////
// CJzNotifyNode

class CJzNotifyNode
{
// Constructor
public:
	CJzNotifyNode();
	virtual ~CJzNotifyNode();

// Attributes
public:
	IDMUSProdNode*	m_pINotifyThisNode;
	GUID			m_guidFile;
	int				m_nUseCount;
};


/////////////////////////////////////////////////////////////////////////////
// CJzClipFormat

class CJzClipFormat
{
// Constructor
public:
	CJzClipFormat( UINT uClipFormat, LPCTSTR szExt );
	virtual ~CJzClipFormat();

// Attributes
public:
	UINT		m_uClipFormat;
	CString		m_strExt;
};


/////////////////////////////////////////////////////////////////////////////
// CJzSharedObject

class CJzSharedObject
{
// Constructor
public:
	CJzSharedObject( REFCLSID clsid, IUnknown* pIUnknown );
	virtual ~CJzSharedObject();

// Attributes
public:
	CLSID 	   m_clsid;
	IUnknown*  m_pIUnknown;
};


/*======================================================================================
OBJECT:  DIRECTMUSIC PRODUCER FRAMEWORK OBJECT
========================================================================================
@object Framework | Represents DMUSProd.exe.

@supint IDMUSProdFramework | Provides the means for a DirectMusic Producer <o Component>
		to plug into the DirectMusic Producer application.  Implemented by DirectMusic
		Producer.
@supint IDMUSProdFileRefChunk | Methods to save and load Producer specific file
		reference RIFF chunks.  Implemented by DirectMusic Producer.
@supint IDMUSProdLoaderRefChunk | Embeds file reference RIFF chunks into a stream for the
		purpose of enabling an implementation of IDirectMusicLoader to resolve file references.
		Implemented by DirectMusic Producer.

@comm
	DMUSProd.exe manages the one and only Framework object.  This object is created
	during application launch and exists throughout the entire DirectMusic Producer
	work session.

	The Framework object is responsible for managing DirectMusic Producer projects.
	It owns the Project Tree and implements <i IDMUSProdFramework> so that DirectMusic
	Producer Components can plug into its functionality.  It also implements
	<i IDMUSProdFileRefChunk> and <i IDMUSProdLoaderRefChunk> to help Components
	manage file references.
--------------------------------------------------------------------------------------*/

/////////////////////////////////////////////////////////////////////////////
// CFramework 

class CFramework : public IDMUSProdFramework8, public IDMUSProdFileRefChunk, public IDMUSProdLoaderRefChunk
{
public:
	CFramework(); 
	virtual ~CFramework();

    // IUnknown methods
    HRESULT STDMETHODCALLTYPE QueryInterface( REFIID riid, LPVOID *ppv );
    ULONG STDMETHODCALLTYPE AddRef();
    ULONG STDMETHODCALLTYPE Release();

/* --------------------------------------------------------------------------
@interface IDMUSProdFramework | 
	This interface allows a DirectMusic Producer <o Component> object to function within
	DMUSProd.exe.

@comm
	<i IDMUSProdFramework> provides the means for Components to hook into the <o Framework>
	through the Framework's Project Tree and 'Add-Ins' menu.  In addition, it allows a Component
	to register additional file types that can be created, opened and saved through the
	Framework's File New, File Open and File Save commands.  It provides the doorway for
	communication amongst Components. It also provides access to the Framework's status bar
	and the ability to create application-wide toolbars.

@base public | IUnknown

@xref  <o Framework> Object, <i IDMUSProdComponent>, <i IDMUSProdDocType>, <i IDMUSProdNode>, <i IDMUSProdEditor>, <i IDMUSProdRIFFExt>, <i IDMUSProdMenu>, <i IDMUSProdToolBar>
-------------------------------------------------------------------------- */

	// IDMUSProdFramework methods
// @meth HRESULT | FindComponent| Returns a pointer to the specified Component's IDMUSProdComponent
// interface.
        HRESULT STDMETHODCALLTYPE FindComponent( REFCLSID rclsid, IDMUSProdComponent** ppIComponent );
// @meth HRESULT | GetFirstComponent| Returns an IDMUSProdComponent interface pointer for the first
// Component in the Framework's list of registered Components.
        HRESULT STDMETHODCALLTYPE GetFirstComponent( IDMUSProdComponent** ppIFirstComponent );
// @meth HRESULT | GetNextComponent| Returns an IDMUSProdComponent interface pointer for the next
// Component in the Framework's list of registered Components.
        HRESULT STDMETHODCALLTYPE GetNextComponent( IDMUSProdComponent* pIComponent, IDMUSProdComponent** ppINextComponent );

// @meth HRESULT | AddDocType| Registers a document type with the Framework.
		HRESULT STDMETHODCALLTYPE AddDocType( IDMUSProdDocType* pIDocType );
// @meth HRESULT | FindDocTypeByExtension| Returns a pointer to the specified file extension's
// IDMUSProdDocType interface.
		HRESULT STDMETHODCALLTYPE FindDocTypeByExtension( BSTR bstrExt, IDMUSProdDocType** ppIDocType );
// @meth HRESULT | FindDocTypeByNodeId| Returns a pointer to the specified id's IDMUSProdDocType
// interface.
        HRESULT STDMETHODCALLTYPE FindDocTypeByNodeId( REFGUID rguid, IDMUSProdDocType** ppIDocType );
// @meth HRESULT | GetFirstDocType| Returns an IDMUSProdDocType interface pointer for the first
// DocType in the Framework's list of registered DocTypes.
        HRESULT STDMETHODCALLTYPE GetFirstDocType( IDMUSProdDocType** ppIFirstDocType );
// @meth HRESULT | GetNextDocType| Returns an IDMUSProdDocType interface pointer for the next
// DocType in the Framework's list of registered DocTypes.
        HRESULT STDMETHODCALLTYPE GetNextDocType( IDMUSProdDocType* pIDocType, IDMUSProdDocType** ppINextDocType );
// @meth HRESULT | CreateNewFile| Invokes the Framework's File New command and returns a new file of
// the type described through <p pIDocType>.
		HRESULT STDMETHODCALLTYPE CreateNewFile( IDMUSProdDocType* pIDocType, IDMUSProdNode* pITreePositionNode, IDMUSProdNode** ppIDocRootNode );
// @meth HRESULT | OpenFile| Invokes the Framework's File Open command and returns a file of
// the type described through <p pIDocType>.
	HRESULT STDMETHODCALLTYPE OpenFile( IDMUSProdDocType* pIDocType, BSTR bstrTitle, IDMUSProdNode* pITreePositionNode, IDMUSProdNode** ppIDocRootNode );
// @meth HRESULT | CopyFile| Returns a copy of the file specified in <p pIDocRootNode>.
        HRESULT STDMETHODCALLTYPE CopyFile( IDMUSProdNode* pIDocRootNode, IDMUSProdNode* pITreePositionNode, IDMUSProdNode** ppINewDocRootNode );
// @meth HRESULT | ShowFile| Displays a newly created file in the Project Tree.
        HRESULT STDMETHODCALLTYPE ShowFile( BSTR bstrFileName );

// @meth HRESULT | RegisterClipFormatForFile| Registers a file's clipboard format with the Framework.
		HRESULT STDMETHODCALLTYPE RegisterClipFormatForFile( UINT uClipFormat, BSTR bstrExt );
// @meth HRESULT | SaveClipFormat| Returns a stream containing the specifed clipboard format for <p pINode>.
		HRESULT STDMETHODCALLTYPE SaveClipFormat( UINT uClipFormat, IDMUSProdNode* pINode, IStream** ppIStream );
// @meth HRESULT | GetDocRootNodeFromData| Returns an IDMUSProdNode interface pointer for the DocRoot node copied into
// <p pIDataObject>.
		HRESULT STDMETHODCALLTYPE GetDocRootNodeFromData( IDataObject* pIDataObject, IDMUSProdNode** ppIDocRootNode );

// @meth HRESULT | AllocFileStream| Returns an IStream interface pointer for the file specified in <p bstrFileName>.
		HRESULT STDMETHODCALLTYPE AllocFileStream( BSTR bstrFileName, DWORD dwDesiredAccess, FileType ftFileType, GUID guidDataFormat, IDMUSProdNode* pITargetFolderNode, IStream **ppIStream );
// @meth HRESULT | AllocMemoryStream| Returns an IStream interface pointer for a newly created memory stream.
		HRESULT STDMETHODCALLTYPE AllocMemoryStream( FileType ftFileType, GUID guidDataFormat, IStream **ppIStream );

// @meth HRESULT | GetFirstProject| Returns an IDMUSProdProject interface pointer for the first
// Project in the application's list of Projects.
        HRESULT STDMETHODCALLTYPE GetFirstProject( IDMUSProdProject** ppIFirstProject );
// @meth HRESULT | GetNextProject| Returns an IDMUSProdProject interface pointer for the next
// Project in the application's list of Projects.
        HRESULT STDMETHODCALLTYPE GetNextProject( IDMUSProdProject* pIProject, IDMUSProdProject** ppINextProject );
// @meth HRESULT | FindProject| Returns an IDMUSProdProject interface pointer for the Project
// containing <p pINode>.
        HRESULT STDMETHODCALLTYPE FindProject( IDMUSProdNode* pINode, IDMUSProdProject** ppIProject );
// @meth HRESULT | IsProjectEqual| Determines whether <p pIDocRootNode1> and <p pIDocRootNode2> are
// in the same Project.
        HRESULT STDMETHODCALLTYPE IsProjectEqual( IDMUSProdNode* pIDocRootNode1, IDMUSProdNode* pIDocRootNode2 );

// @meth HRESULT | AddNodeImageList| Adds images to the Project Tree's image list.
        HRESULT STDMETHODCALLTYPE AddNodeImageList( HANDLE hImageList, short* pnNbrFirstImage );
// @meth HRESULT | GetNodeFileName| Returns the path/filename of the file associated with <p pINode>.
		HRESULT STDMETHODCALLTYPE GetNodeFileName( IDMUSProdNode* pINode, BSTR* pbstrFileName );
// @meth HRESULT | GetNodeFileGUID| Returns the Producer generated GUID assigned to the file associated with <p pINode>.
		HRESULT STDMETHODCALLTYPE GetNodeFileGUID( IDMUSProdNode* pINode, GUID* pguidFile );
// @meth HRESULT | RevertFileToSaved| Reverts the document associated with <p pINode> to its
// last saved state.
		HRESULT STDMETHODCALLTYPE RevertFileToSaved( IDMUSProdNode* pINode );
// @meth HRESULT | SaveNode| Invokes the Framework's File Save command for the document
// associated with the DocRoot node of <p pINode>.
		HRESULT STDMETHODCALLTYPE SaveNode( IDMUSProdNode* pINode );
// @meth HRESULT | SaveNodeAsNewFile| Invokes the Framework's File Save As command to create a new
// file for the node specified in <p pINode>.
		HRESULT STDMETHODCALLTYPE SaveNodeAsNewFile( IDMUSProdNode* pINode );

// @meth HRESULT | AddNode|  Adds one or more nodes to the Project Tree.
		HRESULT STDMETHODCALLTYPE AddNode( IDMUSProdNode* pITopNode, IDMUSProdNode* pIParentNode );
// @meth HRESULT | RemoveNode| Removes one or more nodes from the Project Tree.
		HRESULT STDMETHODCALLTYPE RemoveNode( IDMUSProdNode* pITopNode, BOOL fPromptUser  );
// @meth HRESULT | FindDocRootNode| Returns an IDMUSProdNode interface pointer for the matching DocRoot node.
	    HRESULT STDMETHODCALLTYPE FindDocRootNode( GUID guidProject, IDMUSProdDocType* pIDocType, BSTR bstrNodeName, BSTR bstrNodeDescriptor, IDMUSProdNode** ppIDocRootNode );
// @meth HRESULT | FindDocRootNodeByFileGUID| Returns an IDMUSProdNode interface pointer for the matching DocRoot node.
	    HRESULT STDMETHODCALLTYPE FindDocRootNodeByFileGUID( GUID guidFile, IDMUSProdNode** ppIDocRootNode );
// @meth HRESULT | GetBestGuessDocRootNode | Returns an IDMUSProdNode interface pointer for the closest matching DocRoot node.
        HRESULT STDMETHODCALLTYPE GetBestGuessDocRootNode( IDMUSProdDocType* pIDocType, BSTR bstrNodeName, IDMUSProdNode* pITreePositionNode, IDMUSProdNode** ppIDocRootNode );
// @meth HRESULT | GetSelectedNode | Returns the Project Tree's currently selected node.
        HRESULT STDMETHODCALLTYPE GetSelectedNode( IDMUSProdNode** ppINode );
// @meth HRESULT | SetSelectedNode| Highlights the Project Tree node associated with <p pINode>.
		HRESULT STDMETHODCALLTYPE SetSelectedNode( IDMUSProdNode* pINode );
// @meth HRESULT | RefreshNode| Refreshes and redraws the Project Tree node associated with <p pINode>.
		HRESULT STDMETHODCALLTYPE RefreshNode( IDMUSProdNode* pINode );
// @meth HRESULT | SortChildNodes| Sorts the Project Tree child nodes associated with <p pINode>.
		HRESULT STDMETHODCALLTYPE SortChildNodes( IDMUSProdNode* pINode );
// @meth HRESULT | EditNodeLabel| Begins in-place editing of the specified node's text.
		HRESULT STDMETHODCALLTYPE EditNodeLabel( IDMUSProdNode* pINode );
// @meth HRESULT | OpenEditor| Opens an editor for <p pINode>.
		HRESULT STDMETHODCALLTYPE OpenEditor( IDMUSProdNode* pINode );
// @meth HRESULT | CloseEditor| Closes the editor for <p pINode>.
		HRESULT STDMETHODCALLTYPE CloseEditor( IDMUSProdNode* pINode );

// @meth HRESULT | AddToNotifyList| Adds <p pINotifyThisNode> to the list of nodes notified when
//		the state of <p pIDocRootNode> changes.
		HRESULT STDMETHODCALLTYPE AddToNotifyList( IDMUSProdNode* pIDocRootNode, IDMUSProdNode* pINotifyThisNode );
// @meth HRESULT | RemoveFromNotifyList| Removes <p pINotifyThisNode> from the list of nodes notified
//		when the state of <p pIDocRootNode> changes.
		HRESULT STDMETHODCALLTYPE RemoveFromNotifyList( IDMUSProdNode* pIDocRootNode, IDMUSProdNode* pINotifyThisNode );
// @meth HRESULT | NotifyNodes| Notifies all nodes linked to <p pIChangedDocRootNode> via calls to 
//		<p AddToNotifyList()> that the state of <p pIChangedDocRootNode> has changed.
		HRESULT STDMETHODCALLTYPE NotifyNodes( IDMUSProdNode* pIChangedDocRootNode, GUID guidUpdateType, void* pData );

// @meth HRESULT | AddMenuItem| Adds an item to the Framework's 'Add-Ins' menu.
		HRESULT STDMETHODCALLTYPE AddMenuItem( IDMUSProdMenu* pIMenu );
// @meth HRESULT | RemoveMenuItem| Removes an item from the Framework's 'Add-Ins' menu.
		HRESULT STDMETHODCALLTYPE RemoveMenuItem( IDMUSProdMenu* pIMenu );
// @meth HRESULT | AddToolBar| Adds a toolbar to the Framework.
		HRESULT STDMETHODCALLTYPE AddToolBar( IDMUSProdToolBar* pIToolBar );
// @meth HRESULT | RemoveToolBar| Removes a toolbar from the Framework.
		HRESULT STDMETHODCALLTYPE RemoveToolBar( IDMUSProdToolBar* pIToolBar );

// @meth HRESULT | SetNbrStatusBarPanes| Creates panes in the Framework's status bar.
		HRESULT STDMETHODCALLTYPE SetNbrStatusBarPanes( int nCount, short nLifeSpan, HANDLE* phKey );
// @meth HRESULT | SetStatusBarPaneInfo| Sets the specified status bar pane to a new
// style and width.
		HRESULT STDMETHODCALLTYPE SetStatusBarPaneInfo( HANDLE hKey, int nIndex, StatusBarStyle sbStyle, int nMaxChars );
// @meth HRESULT | SetStatusBarPaneText| Sets the text of the specified status bar pane.
		HRESULT STDMETHODCALLTYPE SetStatusBarPaneText( HANDLE hKey, int nIndex, BSTR bstrText, BOOL bUpdate );
// @meth HRESULT | RestoreStatusBar| Removes panes from the Framework's status bar.
		HRESULT STDMETHODCALLTYPE RestoreStatusBar( HANDLE hKey );

// @meth HRESULT | StartProgressBar| Creates a progress bar control in the Framework's
// status bar.
		HRESULT STDMETHODCALLTYPE StartProgressBar( int nLower, int nUpper, BSTR bstrPrompt, HANDLE* phKey );
// @meth HRESULT | SetProgressBarPos| Sets the current position of the progress bar control.
		HRESULT STDMETHODCALLTYPE SetProgressBarPos( HANDLE hKey, int nPos );
// @meth HRESULT | SetProgressBarStep| Specifies the step increment for the progress bar control.
		HRESULT STDMETHODCALLTYPE SetProgressBarStep( HANDLE hKey, UINT nValue );
// @meth HRESULT | StepProgressBar| Advances current position of the progress bar control by the step
// increment.
		HRESULT STDMETHODCALLTYPE StepProgressBar( HANDLE hKey );
// @meth HRESULT | EndProgressBar| Removes the progress bar control from the Framework's
// status bar. 
		HRESULT STDMETHODCALLTYPE EndProgressBar( HANDLE hKey );

// @meth HRESULT | GetSharedObject| Allows one or more DirectMusic Producer Components to share
// the same COM object.
		HRESULT STDMETHODCALLTYPE GetSharedObject( REFCLSID rclsid, REFIID riid, void** ppvObject ); 

	// IDMUSProdFramework8 methods
// @meth HRESULT | GetNodeRuntimeFileName| Returns the runtime filename for <p pINode>.
		HRESULT STDMETHODCALLTYPE GetNodeRuntimeFileName( IDMUSProdNode* pINode, BSTR* pbstrRuntimeFileName );
// @meth HRESULT | ResolveBestGuessWhenLoadFinished| Adds <p pINotifySink> to a list which will receive
// FRAMEWORK_FileLoadFinished notifications, and returns a Producer generated GUID assigned to the
// referenced file. 
        HRESULT STDMETHODCALLTYPE ResolveBestGuessWhenLoadFinished( IDMUSProdDocType* pIDocType, BSTR bstrNodeName, IDMUSProdNode* pITreePositionNode, IDMUSProdNotifySink* pINotifySink, GUID* pguidFile );

/* --------------------------------------------------------------------------
@interface IDMUSProdFileRefChunk | 
	This interface contains methods to manage DirectMusic Producer file reference RIFF chunks.

@comm
	A file may need to associate itself with other files in its <o Project>.  For example,
	a Band may use one or more DLS files.  In order to establish a connection to other files,
	the saved Band contains one or more file reference chunks each pointing to a DLS file.

	<i IDMUSProdFileRefChunk> provides a standard way for DirectMusic Producer <o Component>s
	to place DirectMusic Producer file reference RIFF chunks in the design-time version of
	their files.  These chunks contain enough information so that DirectMusic Producer can 
	load the referenced file when the file is opened.

    <i IDMUSProdFileRefChunk> places Producer specific file reference chunks in streams so that
	links can be re-established within Producer the next time the file is opened by Producer.
	<i IDMUSProdLoaderRefChunk> places DirectMusic file reference chunks in streams so that links
	can be established when the file is loaded into the DirectMusic DLLs either externally or 
	via Producer.

	A DirectMusic Producer Component can call <om IDMUSProdFramework::QueryInterface> to
	obtain a pointer to the <o Framework>'s <i IDMUSProdFileRefChunk> interface.	

@base public | IUnknown

@xref  <o Node> Object, <i IDMUSProdComponent>, <i IDMUSProdFramework>, <i IDMUSProdNode>
-------------------------------------------------------------------------- */

	// IDMUSProdFileRefChunk methods
// @meth HRESULT | LoadRefChunk | Reads a DirectMusic Producer file reference RIFF chunk,
// loads the referenced file, and returns a pointer to the referenced file's DocRoot node.
        HRESULT STDMETHODCALLTYPE LoadRefChunk( IStream* pIStream, IDMUSProdNode** ppIDocRootNode );
// @meth HRESULT | SaveRefChunk | Saves a DirectMusic Producer file reference RIFF chunk.
        HRESULT STDMETHODCALLTYPE SaveRefChunk( IStream* pIStream, IDMUSProdNode* pIRefNode );
// @meth HRESULT | GetChunkSize | Returns the size of a DirectMusic Producer file reference RIFF
// chunk.
        HRESULT STDMETHODCALLTYPE GetChunkSize( DWORD* pdwSize );
// @meth HRESULT | ResolveWhenLoadFinished| Adds <p pINotifySink> to a list which will receive
//	FRAMEWORK_FileLoadFinished notifications, reads a DirectMusic Producer file reference RIFF chunk,
// and returns the Producer generated GUID assigned to the referenced file.
		HRESULT STDMETHODCALLTYPE ResolveWhenLoadFinished( IStream* pIStream, IDMUSProdNotifySink* pINotifySink, GUID* pguidFile );
// @meth HRESULT | GetFileRefInfo | Reads a DirectMusic Producer file reference RIFF chunk,
// and fills a DMUSProdFileRefInfo structure with information about the reference.
        HRESULT STDMETHODCALLTYPE GetFileRefInfo( IStream* pIStream, DMUSProdFileRefInfo* pFileRefInfo );

/* --------------------------------------------------------------------------
@interface IDMUSProdLoaderRefChunk | 
	This interface provides the means to embed file reference chunks into a stream for the
	purpose of enabling an implementation of IDirectMusicLoader to resolve file references.

@comm
	A file may need to associate itself with other files in its <o Project>.  For example,
	a Band may use one or more DLS files.  In order to establish a connection to other files,
	the saved Band contains one or more file reference chunks each pointing to a DLS file.

	<i IDMUSProdLoaderRefChunk> provides a standard way for DirectMusic Producer <o Component>s
	to place file reference chunks in the runtime versions of their DirectMusic files.  The
	DirectMusic Loader object, as well as other implementations of IDirectMusicLoader, know how
	to resolve the file reference chunks written through this interface.

    <i IDMUSProdFileRefChunk> places Producer specific file reference chunks in streams so that
	links can be re-established within Producer the next time the file is opened by Producer.
	<i IDMUSProdLoaderRefChunk> places DirectMusic file reference chunks in streams so that links
	can be established when the file is loaded into the DirectMusic DLLs either externally or 
	via Producer.

	A DirectMusic Producer Component can call <om IDMUSProdFramework::QueryInterface> to
	obtain a pointer to the <o Framework>'s <i IDMUSProdLoaderRefChunk> interface.	

@base public | IUnknown

@xref  <i IDMUSProdComponent>, <i IDMUSProdFramework>
-------------------------------------------------------------------------- */

	// IDMUSProdLoaderRefChunk methods
// @meth HRESULT | SaveRefChunkForLoader | Embeds a RIFF chunk into <p pIStream> that enables an
// implementation of IDirectMusicLoader to resolve file references.
		HRESULT STDMETHODCALLTYPE SaveRefChunkForLoader( IStream* pIStream, IDMUSProdNode* pIRefNode, REFCLSID rclsid, void*  pObjectDesc, WhichLoader wlWhichLoader );

	// Additional methods
public:
	HRESULT STDMETHODCALLTYPE StartWaitCursor();
	HRESULT STDMETHODCALLTYPE EndWaitCursor();
	BOOL LoadComponents();
	BOOL InitComponents();
	void CleanUp();
	void FreeComponents();
	void FreeDocTypes();
	void FreeClipFormats();
	void FreeSharedObjects();
	void OnActivateApp( BOOL fActive );
	BOOL RegisterClipboardFormats();
	void OnInitAddInsMenu( CMenu* pAddInsMenu );
	BOOL OnSelectAddInsMenu( UINT nCommandID );
	void GetAddInsMenuHelpText( UINT nCommandID, CString& rMessage ); 
	void FixAddInsMenu();
	void RedrawClientToolbars();
	BOOL RemoveNodes( IDMUSProdNode* pINode );
	BOOL SetNodeName( IDMUSProdNode* pINode, LPCTSTR szNewName );
	CJzComponent* GetJzComponent( IDMUSProdComponent* pIComponent );
	IDMUSProdNode* DetermineParentNode( LPCTSTR szFileName );
	HTREEITEM FindTreeItem( IDMUSProdNode* pINode );
	HTREEITEM FindTreeProjectByGUID( GUID guidProject );
	BOOL ShowTreeNode( IDMUSProdNode* pINode );
	void InsertViewMenuItem( CJzToolBar* pJzToolbar );
	void RemoveViewMenuItem( CJzToolBar* pJzToolbar );
	void OnInitViewMenu( CMenu* pViewMenu );
	BOOL OnSelectViewMenu( UINT nCommandID );
	void GetViewMenuHelpText( UINT nCommandID, CString& rMessage ); 
	void FixViewMenu();
	void SyncEditorTitles( IDMUSProdNode* pINode );
	HRESULT SyncNodeName( IDMUSProdNode* pINode, BOOL fRedraw );
	HRESULT SyncNodeIcon( IDMUSProdNode* pINode, BOOL fRedraw );
	HRESULT LoadClipFormat( IDataObject* pIDataObject, UINT uClipFormat, IStream** ppIStream );
	HRESULT LoadCF_DMUSPROD_FILE( IStream* pIStream , CFProducerFile* pProducerFile );
	HRESULT SaveCF_DMUSPROD_FILE( IDMUSProdNode* pINode, IStream** ppIStream );

	BOOL AreYouSure( IDMUSProdNode* pINode );
	HTREEITEM FindTreeItemByWP( wpWindowPlacement* pWP );
	void ApplyWPSettings( HTREEITEM hItem, wpWindowPlacement* pWP );
	long GetWPTreePos( IDMUSProdNode* pINode );
	BOOL AddComponentDocTemplates();
	BOOL IsDocRootNode( IDMUSProdNode* pIDocRootNode );
	UINT FindFileClipFormat( IDataObject* pIDataObject );
	HRESULT FindDocTypeByClipFormat( UINT uClipFormat, IDMUSProdDocType** ppIDocType );
	HRESULT FindExtensionByClipFormat( UINT uClipFormat, CString& strExt );

private:
	long CountWPTreePos( CTreeCtrl* pTreeCtrl, IDMUSProdNode* pINode, long lTreePos, HTREEITEM hItem );
	HTREEITEM SearchTreeForWP( CTreeCtrl* pTreeCtrl, wpWindowPlacement* pWP, long lTreePos, HTREEITEM hItem );
	HTREEITEM SearchTree( CTreeCtrl* pTreeCtrl, IDMUSProdNode* pINode, HTREEITEM hItem );
	BOOL AddNodes( IDMUSProdNode* pINode, HTREEITEM hParent );
	HRESULT ReadTheRefChunk( IDMUSProdRIFFStream* pIRiffStream, MMCKINFO* pckMain, IDMUSProdNode** ppIDocRootNode );
	HRESULT WriteTheRefChunk( IDMUSProdRIFFStream* pIRiffStream, CFileNode* pFileNode );
	HRESULT WriteTheRefChunkForLoader( IDMUSProdRIFFStream* pIRiffStream, LPDMUS_OBJECTDESC pObjectDesc );
	HRESULT CreateFileFromDataObject( IDataObject* pIDataObject );
	HRESULT WriteTheFileFromDataObject( CFProducerFile* pcfProducerFile, IStream* pIMemStream, IDMUSProdDocType* pIDocType );

// Attributes
private:
    DWORD	m_dwRef;
	UINT	m_nNextMenuID;
	UINT	m_nNextToolBarID;
    CTypedPtrList<CPtrList, CJzComponent*> m_lstComponents;
    CTypedPtrList<CPtrList, IDMUSProdDocType*> m_lstDocTypes;
    CTypedPtrList<CPtrList, CJzMenu*> m_lstMenus;
    CTypedPtrList<CPtrList, CJzToolBar*> m_lstToolBars;
    CTypedPtrList<CPtrList, CJzClipFormat*> m_lstClipFormats;
    CTypedPtrList<CPtrList, CJzSharedObject*> m_lstSharedObjects;

public:
	UINT	m_cfProducerFile;		// CF_DMUSPROD_FILE clipboard format
};

/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // __FRAMEWORK_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\Framework\ioJazzDoc.h ===
#ifndef __IOJAZZDOC_H__
#define __IOJAZZDOC_H__

// DirectMusic Producer Project structures


#define FOURCC_PROJECT_FORM				mmioFOURCC('J','A','Z','P')
#define FOURCC_PROJECT_LIST				mmioFOURCC('p','r','o','j')
#define FOURCC_PROJECT_CHUNK			mmioFOURCC('p','j','c','t')
#define FOURCC_PROJECT_PCHANNEL_NAMES	mmioFOURCC('p','j','p','n')
#define FOURCC_OPEN_EDITORS_LIST		mmioFOURCC('o','p','e','n')
#define FOURCC_BOOKMARK_LIST			mmioFOURCC('b','k','m','k')
#define FOURCC_BOOKMARK_EDITOR_LIST		mmioFOURCC('e','d','t','r')
#define FOURCC_BOOKMARK_EDITOR_WP_CHUNK	mmioFOURCC('e','d','t','w')
#define FOURCC_BOOKMARK_COMPONENT_LIST	mmioFOURCC('c','o','m','p')
#define FOURCC_BOOKMARK_COMPONENT_CHUNK	mmioFOURCC('c','o','m','h')
#define FOURCC_FILE_LIST				mmioFOURCC('f','i','l','e')
#define FOURCC_FILE_CHUNK				mmioFOURCC('f','i','l','h')
#define FOURCC_NOTIFY_CHUNK				mmioFOURCC('n','t','f','y')
#define FOURCC_NODE_LIST				mmioFOURCC('n','o','d','e')
#define FOURCC_NAME_CHUNK				mmioFOURCC('n','a','m','e')
#define FOURCC_EDITOR_WP_CHUNK			mmioFOURCC('e','d','w','p')
#define FOURCC_RUNTIME_FOLDERS_LIST		mmioFOURCC('r','f','l','d')
#define FOURCC_RUNTIME_FOLDER_LIST		mmioFOURCC('f','l','d','r')
#define FOURCC_PATH_CHUNK				mmioFOURCC('p','a','t','h')
#define FOURCC_FILTER_CHUNK				mmioFOURCC('f','l','t','r')
#define FOURCC_GUID_CHUNK				mmioFOURCC('g','u','i','d')


#define FOURCC_INFO_LIST				mmioFOURCC('I','N','F','O')
#define FOURCC_UNFO_LIST				mmioFOURCC('U','N','F','O')
#define FOURCC_UNAM_CHUNK				mmioFOURCC('U','N','A','M')
#define FOURCC_UNFO_COMMENT				mmioFOURCC('c','m','n','t')
#define FOURCC_UNFO_NODE_NAME			mmioFOURCC('n','n','a','m')
#define FOURCC_UNFO_NODE_DESC			mmioFOURCC('n','d','s','c')
#define FOURCC_UNFO_RUNTIME_FILE		mmioFOURCC('r','f','i','l')
#define FOURCC_UNFO_RUNTIME_FOLDER		mmioFOURCC('r','d','i','r')
#define FOURCC_UNFO_RUNTIME_NAME		mmioFOURCC('r','n','a','m')

#pragma pack(2)

struct ioJzProject
{
	GUID				m_guidProject;		// Every Project has a GUID
};

struct ioJzFile
{
	GUID				m_guidFile;				// Every file has a GUID
	FILETIME			m_ftModified;			// Modified time of file
	DWORD				m_dwSize;				// Size of file
	GUID				m_guidListInfoObject;	// GUID for file's DMUSProdListInfo info 
};

struct ioJzNode
{
	GUID				m_guidNodeId;		// Every node has an ID; i.e. GUID_StyleNode
	long				m_lTreePos;			// Position of this node in this file
	WINDOWPLACEMENT		m_wpEditor;			// Window placement info for this node's editor
};

struct ioPChannelName
{
	DWORD				m_dwPChannel;		// PChannel number
	DWORD				m_dwStrCount;		// Number of WCHARs in PChannel name, including NULL
	WCHAR*				m_pwstrName;		// Null-terminated PChannel name
};

#pragma pack()


/*
RIFF
(
	'JAZP'				// DirectMusic Producer Project File
	<proj-list>			// Project information 
	[<file-list>]		// Files in Project
)

	// <proj-list>
	proj
	(
		<pjct-ck>			// Project chunk 
		[<INFO-list>]		// Comments
		[<pjpn-ck>]			// PChannel name
	)

		// <pjct-ck>
		pjct
		(
			WORD sizeof(ioJzProject)
			<ioJzProject>
			Username (unicode)
		)

		// [<UNFO-list>]
		LIST
		(
			'UNFO'
			[<cmmt>]		// Comments (FOURCC_UNFO_COMMENT)
		)

		// [<pjpn-ck]
		pjpn
		(
			<ioPChannelName>	// Any number of ioPChannelName structures
		)

	// [<file-list>]
	LIST
	(
		'file'
		<name-ck>		// Filename (relative path)
		<filh-ck>		// File header chunk
		[<ntfy-ck>]		// List of GUIDs for files in this file's notify list
		[<INFO-list>]	// NodeName, NodeDescriptor
		[<node-list>]	// List of WINDOWPLACEMENT info for individual node editors
	)

		// <name-ck>
		name
		(
			Filename - relative path (unicode)
		)

		// <filh-ck>
		filh
		(
			<ioJzFile>
		)

		// [<ntfy-ck>]
		'ntfy'
		(
			// GUID's for all files in this file's notify list
		)

		// [<INFO-list>]
		LIST
		(
			'INFO'
			[<nnam>]	// Node Name
			[<ndsc>]	// Node Descriptor
		)

		// [<node-list>]
		LIST
		(
			'node'
			<name-ck>		// Node name
			<edwp-ck>		// Associated editor's WINDOWPLACEMENT information
		)

			// <name-ck>
			name
			(
				Node name (unicode)
			)

			// <edwp-ck>
			edwp
			(
				<ioJzNode>
			)
*/

#endif // __IOJAZZDOC_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\Framework\FileStream.cpp ===
//////////////////////////////////////////////////////////////////////////////
// CFileStream

/*-----------
@doc DMUSPROD
-----------*/

#include "stdafx.h"
#include "JazzApp.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


/*======================================================================================
STRUCT:  DMUSPRODSTREAMINFO
========================================================================================
@struct DMUSProdStreamInfo | Contains additional information about a stream created by
	calling either <om IDMUSProdFramework::AllocFileStream> or <om IDMUSProdFramework::AllocMemoryStream>.
	
@field FileType | ftFileType | Type of stream. FT_DESIGN, FT_RUNTIME, or FT_UNKNOWN.
@field GUID | guidDataFormat | GUID identifying data format of stream.
@field IDMUSProdNode | pITargetDirectoryNode | <i IDMUSProdNode> interface pointer to the
		Project Tree Directory <o Node> that will contain this file.
--------------------------------------------------------------------------------------*/


/*======================================================================================
INTERFACE:  IDMUSPRODPERSISTINFO
========================================================================================
@interface IDMUSProdPersistInfo | 
	This interface provides access to additional information for consideration when
	persisting objects through an IStream interface.  
	
	<i IDMUSProdFramework> provides two methods which return pointers to an IStream interface: 
	<om IDMUSProdFramework.AllocFileStream> and <om IDMUSProdFramework.AllocMemoryStream>.
	Streams returned by these methods also implement the <i IDMUSProdPersistInfo>
	interface for the purpose of making available additional information about the stream.
	In particular, these methods associate a file type and data format with the streams they
	create.  In addition, <om IDMUSProdFramework.AllocFileStream> associates a target directory
	node with each stream having a <p dwDesiredAccess> of GENERIC_READ.
  
	An object can obtain a pointer to a stream's <i IDMUSProdPersistInfo> interface via a call to
	<om IStream::QueryInterface>.  <om IDMUSProdPersistInfo.GetStreamInfo> returns the <p ftFileType>,
	<p guidDataFormat>, and <p pITargetDirectoryNode> associated with a stream.  <p pITargetDirectory>
	will always be NULL for streams created via <om IDMUSProdFramework.AllocMemoryStream>.

@meth HRESULT | GetFileName | Returns the path/filename of the file associated with 
	this stream.
@meth HRESULT | GetStreamInfo | Fills a DMUSProdStreamInfo structure with information about
	this stream.
@meth HRESULT | IsInEmbeddedFileList | Determines whether <p pIDocRootNode> is already embedded
	in this stream.
@meth HRESULT | AddToEmbeddedFileList | Adds <p pIDocRootNode> to the list of files embedded
	in this stream.
	
@base public | IUnknown

@xref <om IDMUSProdFramework.AllocFileStream>, <om IDMUSProdFramework.AllocMemoryStream>
-------------------------------------------------------------------------- */


//////////////////////////////////////////////////////////////////////////////
// CFileStream class

struct CFileStream : IStream, public IDMUSProdPersistInfo,
							  public IDirectMusicGetLoader
{
///// object state
    ULONG           m_dwRef;				// object reference count
    HANDLE          m_hFile;				// file handle
	IDMUSProdNode*	m_pITargetDirectoryNode;// IDMUSProdNode interface pointer to the Project Tree
											//		Directory node that will contain this file
	CString			m_strFileName;			// file name
	FileType		m_ftFileType;			// Runtime or design-time
	GUID			m_guidDataFormat;		// specific format of data in stream
											// current file format, older file format, strip, etc

	CTypedPtrList<CPtrList, IDMUSProdNode*> m_lstEmbeddedFiles;

// construction and destruction
    CFileStream( HANDLE hFile, LPCTSTR szFileName, FileType ftFileType, GUID guidDataFormat,
				 IDMUSProdNode* pITargetDirectoryNode )
	{
		m_dwRef = 1;
		m_hFile = hFile;
		m_strFileName = szFileName;
		m_ftFileType = ftFileType;
		memcpy( &m_guidDataFormat, &guidDataFormat, sizeof(guidDataFormat) );
		m_pITargetDirectoryNode = pITargetDirectoryNode;
	}
    ~CFileStream()
	{
		// Release all items in m_lstEmbeddedFiles
		while( !m_lstEmbeddedFiles.IsEmpty() )
		{
			IDMUSProdNode* pIDocRootNode = m_lstEmbeddedFiles.RemoveHead();
			pIDocRootNode->Release();
		}

		CloseHandle( m_hFile );
	}

/////  IUnknown methods
    STDMETHODIMP QueryInterface( REFIID riid, LPVOID FAR* ppvObj )
    {
        if( IsEqualIID( riid, IID_IUnknown )
        ||  IsEqualIID( riid, IID_IStream ) )
        {
            *ppvObj = (IStream *)this;
            AddRef();
            return NOERROR;
        }
        if( IsEqualIID( riid, IID_IDMUSProdPersistInfo ) )
        {
            *ppvObj = (IDMUSProdPersistInfo *)this;
            AddRef();
            return NOERROR;
        }
        if( IsEqualIID( riid, IID_IDirectMusicGetLoader ) )
        {
            *ppvObj = (IDirectMusicGetLoader *)this;
            AddRef();
            return NOERROR;
        }
        *ppvObj = NULL;
        return E_NOINTERFACE;
    }
    STDMETHODIMP_(ULONG) AddRef()
    {
        return ++m_dwRef;
    }
    STDMETHODIMP_(ULONG) Release()
    {
		if( --m_dwRef == 0L )
		{
			delete this;
			return 0;
		}
        return m_dwRef;
    }

/////  IStream methods
    STDMETHODIMP Read( void* pv, ULONG cb, ULONG* pcbRead )
    {
		ASSERT( cb != 0 );
		DWORD dw;

		int nReturn = ReadFile( m_hFile, pv, cb, &dw, NULL );
		if( pcbRead )
		{
			*pcbRead = dw;
		}
		if( nReturn
		&&  dw == cb )
		{
			return S_OK;
		}
		return E_FAIL;
    }
    STDMETHODIMP Write( const void* pv, ULONG cb, ULONG* pcbWritten )
    {
		DWORD dw;

		if( WriteFile( m_hFile, pv, cb, &dw, NULL ) &&
			dw == cb )
		{
			if( pcbWritten != NULL )
			{
				*pcbWritten = dw;
			}
			return S_OK;
		}
        return E_FAIL;
	}
    STDMETHODIMP Seek( LARGE_INTEGER dlibMove, DWORD dwOrigin, ULARGE_INTEGER* plibNewPosition )
    {
		DWORD dw;

		dw = SetFilePointer( m_hFile, dlibMove.LowPart, &dlibMove.HighPart, dwOrigin );
		if( dw == (DWORD)-1 )
		{
			return E_FAIL;
		}
		if( plibNewPosition != NULL )
		{
			plibNewPosition->LowPart = dw;
	        plibNewPosition->HighPart = dlibMove.HighPart;
		}
        return S_OK;
	}
    STDMETHODIMP SetSize(ULARGE_INTEGER /*libNewSize*/)
      { return E_NOTIMPL; }
	STDMETHODIMP CopyTo(IStream* pstm, ULARGE_INTEGER cb,
		ULARGE_INTEGER* pcbRead,
		ULARGE_INTEGER* pcbWritten)
	{
		// Validate pstm
		if ( pstm == NULL )
		{
			return E_INVALIDARG;
		}

		// Can only read and write an array of maximum size of a DWORD.
		if ( cb.HighPart != 0 )
		{
			return E_INVALIDARG;
		}

		// Pass on the target directory
		IDMUSProdSetPersistInfo* pISetPersistInfo;
		if( SUCCEEDED ( pstm->QueryInterface( IID_IDMUSProdSetPersistInfo, (void **)&pISetPersistInfo ) ) )
		{
			pISetPersistInfo->SetTargetDirectory( m_pITargetDirectoryNode );
			pISetPersistInfo->Release();
		}

		// Check if the user requested to copy zero bytes
		if ( cb.LowPart == 0 )
		{
			if( pcbRead )
			{
				pcbRead->QuadPart = 0;
			}
			if( pcbWritten )
			{
				pcbWritten->QuadPart = 0;
			}

			// Nothing more to do
			return S_OK;
		}

		// Initialize the array to NULL
		BYTE *pbaTemp = NULL;

		TRY
		{
			// Try and allocate a temporary array to store the data in
			pbaTemp = new BYTE[cb.LowPart];
		}
		CATCH(CException, e)
		{
			// Do nothing - handled by the if() statement below
		}
		END_CATCH

		// If allocation failes, return E_OUTOFMEMORY
		if ( pbaTemp == NULL )
		{
			return E_OUTOFMEMORY;
		}

		// Now, actually read in the data
		HRESULT hr;
		ULONG cbRead, cbWritten;
		hr = Read( pbaTemp, cb.LowPart, &cbRead );

		// Pass on how much data was read
		if ( pcbRead != NULL )
		{
			pcbRead->QuadPart = cbRead;
		}

		// Handle any error in the read
		if ( FAILED( hr ) )
		{
			delete []pbaTemp;
			return hr;
		}

		// Now, write out the data
		hr = pstm->Write( pbaTemp, cbRead, &cbWritten );

		// Delete the temporary array
		delete []pbaTemp;

		// Pass on how much data was written
		if ( pcbWritten != NULL )
		{
			pcbWritten->QuadPart = cbWritten;
		}

		// Return the result from the Write() call
		return hr;
	}
    STDMETHODIMP Commit(DWORD /*grfCommitFlags*/)
      { return E_NOTIMPL; }
    STDMETHODIMP Revert()
      { return E_NOTIMPL; }
    STDMETHODIMP LockRegion(ULARGE_INTEGER /*libOffset*/, ULARGE_INTEGER /*cb*/,
        DWORD /*dwLockType*/)
      { return E_NOTIMPL; }
    STDMETHODIMP UnlockRegion(ULARGE_INTEGER /*libOffset*/, ULARGE_INTEGER /*cb*/,
        DWORD /*dwLockType*/)
      { return E_NOTIMPL; }
    STDMETHODIMP Stat(STATSTG* /*pstatstg*/, DWORD /*grfStatFlag*/)
      { return E_NOTIMPL; }
    STDMETHODIMP Clone(IStream** /*ppstm*/)
      { return E_NOTIMPL; }


/*======================================================================================
METHOD:  IDMUSPRODPERSISTINFO::GETFILENAME
========================================================================================
@method HRESULT | IDMUSProdPersistInfo | GetFileName | Returns the path/filename of the file
		associated with this stream. 

@rvalue S_OK | The filename was returned in <p pbstrFileName>.
@rvalue E_POINTER | The address in <p pbstrFileName> is not valid.  For example, it may be NULL.
@rvalue E_FAIL | An error occurred and the filename was not returned.

@xref <i IDMUSProdPersistInfo>
--------------------------------------------------------------------------------------*/
    STDMETHOD(GetFileName)(
		BSTR* pbstrFileName		// @parm [out,retval]  Pointer to the caller-allocated variable
								// that receives the copy of the filename.  The caller must
								// free <p pbstrFileName> with SysFreeString when it is no longer
								// needed.
	)
	{
		if( pbstrFileName == NULL )
		{
			return E_POINTER;
		}

		*pbstrFileName = m_strFileName.AllocSysString();
		return S_OK;
	}

/*======================================================================================
METHOD:  IDMUSPRODPERSISTINFO::GETSTREAMINFO
========================================================================================
@method HRESULT | IDMUSProdPersistInfo | GetStreamInfo | Fills a <t DMUSProdStreamInfo>
		structure with information about this stream.

@comm
	Streams created through either <om IDMUSProdFramework.AllocFileStream> or
	<om IDMUSProdFramework.AllocMemoryStream> carry information communicating their file type
	and data format.  <om IDMUSProdPersistInfo.GetStreamInfo> provides the means for an object
	to obtain this information so that it can determine how to persist itself.

	The following file types may be returned in DMUSProdStreamInfo.ftFileType:

	FT_DESIGN: <tab>Design-time saves may include chunks of UI related information only used
	during editing.
	
	FT_RUNTIME: <tab>Runtime saves are invoked to create files for distribution.  Data should
	be saved in its most compact form.    

	FT_UNKNOWN: <tab>FT_UNKNOWN is only valid when <om IDMUSProdFramework::AllocFileStream>
	is called to open a file.
	
	DMUSProdStreamInfo.guidDataFormat indicates the specific format to be used when writing data
	into the stream.  Objects may create additional GUIDs to communicate specific data formats they
	need when persisting data.  The <o Framework> supplies the following GUIDs for general use:
	
	GUID_CurrentVersion: <tab><tab>Current version of the file format.

	GUID_CurrentVersion_OnlyUI: <tab>Current version of the file format (UI state information only).

	GUID_DirectMusicObject: <tab><tab>Stream being prepared to persist into a DirectMusic object.

	GUID_Bookmark: <tab><tab><tab>Framework uses this GUID when creating streams to include in bookmarks.

	GUID_AllZeros: <tab><tab><tab>GUID_AllZeros is only valid when <om IDMUSProdFramework::AllocFileStream>
	is called to open a file.

@rvalue S_OK | The stream information was returned successfully.
@rvalue E_POINTER | The address in <p pStreamInfo> is not valid. For example, it may be NULL.	

@xref <i IDMUSProdPersistInfo>, <om IDMUSProdFramework.AllocFileStream>, <om IDMUSProdFramework.AllocMemoryStream>, <i IDMUSProdDocType>, <om IDMUSProdDocType.IsFileTypeExtension>
--------------------------------------------------------------------------------------*/
    STDMETHOD(GetStreamInfo)(
		DMUSProdStreamInfo* pStreamInfo	// @parm [in] Pointer to a <t DMUSProdStreamInfo> structure.
	)
	{
		if( pStreamInfo == NULL )
		{
			return E_POINTER;
		}

		pStreamInfo->pITargetDirectoryNode = m_pITargetDirectoryNode;
		pStreamInfo->ftFileType = m_ftFileType;
		memcpy( &pStreamInfo->guidDataFormat, &m_guidDataFormat, sizeof(m_guidDataFormat) );
		return S_OK;
	}

/////  IDirectMusicGetLoader methods
	STDMETHOD( GetLoader )( IDirectMusicLoader ** ppLoader )
	{
		if( ppLoader == NULL )
		{
			return E_INVALIDARG;
		}

		if( theApp.m_pLoader == NULL )
		{
			theApp.m_pLoader = new CLoader;
		}

		if( theApp.m_pLoader )
		{
			*ppLoader = (IDirectMusicLoader*)theApp.m_pLoader;
			(*ppLoader)->AddRef();

			return S_OK;
		}

		return E_FAIL;
	}

/*======================================================================================
METHOD:  IDMUSPRODPERSISTINFO::ISINEMBEDDEDFILELIST
========================================================================================
@method HRESULT | IDMUSProdPersistInfo | IsInEmbeddedFileList | Determines whether
	<p pIDocRootNode> is already embedded in this stream. 

@rvalue S_OK | <p pIDocRootNode> is embedded in this stream.
@rvalue S_FALSE | <p pIDocRootNode> is not embedded in this stream.
@rvalue E_INVALIDARG | The address in <p pIDocRootNode> is not valid.  For example, it may be NULL.

@xref <i IDMUSProdPersistInfo>
--------------------------------------------------------------------------------------*/
    STDMETHOD(IsInEmbeddedFileList)(
		IDMUSProdNode* pIDocRootNode	// @parm [out,retval]  [in] Pointer to the DocRoot's
									//			<i IDMUSProdNode> interface.
	)
	{
		if( pIDocRootNode == NULL )
		{
			return E_INVALIDARG;
		}

		POSITION pos = m_lstEmbeddedFiles.GetHeadPosition();
		while( pos )
		{
			IDMUSProdNode* pIDocRootNodeList = m_lstEmbeddedFiles.GetNext( pos );

			if( pIDocRootNodeList == pIDocRootNode )
			{
				return S_OK;
			}
		}

		return S_FALSE;
	}

/*======================================================================================
METHOD:  IDMUSPRODPERSISTINFO::ADDTOEMBEDDEDFILELIST
========================================================================================
@method HRESULT | IDMUSProdPersistInfo | AddToEmbeddedFileList | Adds <p pIDocRootNode>
	to the list of files embedded in this stream. 

@rvalue S_OK | <p pIDocRootNode> was added to the list of files embedded in this stream.
@rvalue E_INVALIDARG | The address in <p pIDocRootNode> is not valid.  For example, it may be NULL.
@rvalue E_FAIL | An error occurred and <p pIDocRootNode> was not added to the list of files
		embedded in this stream.

@xref <i IDMUSProdPersistInfo>
--------------------------------------------------------------------------------------*/
    STDMETHOD(AddToEmbeddedFileList)(
		IDMUSProdNode* pIDocRootNode	// @parm [out,retval]  [in] Pointer to the DocRoot's
									//			<i IDMUSProdNode> interface.
	)
	{
		if( pIDocRootNode == NULL )
		{
			return E_INVALIDARG;
		}

		if( IsInEmbeddedFileList(pIDocRootNode) == S_FALSE )
		{
			pIDocRootNode->AddRef();
			m_lstEmbeddedFiles.AddHead( pIDocRootNode );
		}

		return S_OK;
	}
};


//////////////////////////////////////////////////////////////////////////////
// AllocFileStream

HRESULT AllocFileStream( LPCTSTR szFileName, DWORD dwDesiredAccess,
						 FileType ftFileType, GUID guidDataFormat,
						 IDMUSProdNode* pITargetDirectoryNode,
						 IStream **ppIStream )
{
    HANDLE       hFile;          // handle to open file
    CFileStream* pFileStream;    // IStream implementation

    // in case of error...
    *ppIStream = NULL;

    // open the file
    if( dwDesiredAccess == GENERIC_READ )
    {
        hFile = CreateFile( szFileName, dwDesiredAccess, FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL );
    }
    else if( dwDesiredAccess == GENERIC_WRITE )
    {
		// Must specify type of stream
		ASSERT( ftFileType != FT_UNKNOWN );
		if( ftFileType == FT_UNKNOWN )
		{
			return E_INVALIDARG;
		}

		// Target Directory node must be NULL
		pITargetDirectoryNode = NULL;

        hFile = CreateFile( szFileName, dwDesiredAccess, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL );
    }
    else
    {
        return E_INVALIDARG;
    }

    if( hFile == INVALID_HANDLE_VALUE )
	{
		CString strFileName = szFileName;

		int nFindPos = strFileName.ReverseFind( (TCHAR)'\\' );
		if( nFindPos != -1 )
		{
			strFileName = strFileName.Right( strFileName.GetLength() - nFindPos - 1 );
		}

		if( dwDesiredAccess == GENERIC_READ )
		{
			theApp.DisplaySystemError( IDS_SYSERR_OPEN, strFileName  );
		}
		else if( dwDesiredAccess == GENERIC_WRITE )
		{
			theApp.DisplaySystemError( IDS_SYSERR_SAVE, strFileName  );
		}

        return E_FAIL;
	}

    // create the Windows object
    pFileStream = new CFileStream( hFile, szFileName, ftFileType, guidDataFormat, pITargetDirectoryNode );
    if( pFileStream == NULL )
	{
		CloseHandle( hFile ); 
        return E_OUTOFMEMORY;
	}

    // return an IStream pointer
    *ppIStream = (IStream *)pFileStream;

    return S_OK;
}


//////////////////////////////////////////////////////////////////////////////
// AllocFileReadWriteStream

HRESULT AllocFileReadWriteStream( LPCTSTR szFileName, IStream **ppIStream )
{
    HANDLE       hFile;          // handle to open file
    CFileStream* pFileStream;    // IStream implementation

    // in case of error...
    *ppIStream = NULL;

    hFile = CreateFile( szFileName, (GENERIC_READ|GENERIC_WRITE), 0, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL );
    if( hFile == INVALID_HANDLE_VALUE )
	{
        return E_FAIL;
	}

    // create the Windows object
    pFileStream = new CFileStream( hFile, szFileName, FT_UNKNOWN, GUID_AllZeros, NULL );
    if( pFileStream == NULL )
	{
		CloseHandle( hFile ); 
        return E_OUTOFMEMORY;
	}

    // return an IStream pointer
    *ppIStream = (IStream *)pFileStream;

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\Framework\Framework.cpp ===
// Framework.cpp : implementation file
//

/*-----------
@doc DMUSPROD
-----------*/

#include "stdafx.h"
#include "JazzApp.h"
#include "MainFrm.h"
#include "Framework.h"
#include "ioJazzDoc.h"
#include "DeleteFileDlg.h"
#include "WhichProjectDlg.h"
#include "ClientToolBar.h"
#include <ContainerDesigner.h>
#include <PrivateUnpackingFiles.h>

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


/////////////////////////////////////////////////////////////////////////////
// CJzComponent constructor/destructor 

CJzComponent::CJzComponent( CLSID clsidComponent, IDMUSProdComponent* pIComponent )
{
	ASSERT( pIComponent != NULL );

    m_clsidComponent = clsidComponent;
	m_pIComponent = pIComponent;
	m_fInitialized = FALSE;
}


CJzComponent::~CJzComponent()
{
	if( m_pIComponent )
	{
		m_pIComponent->CleanUp();
		m_pIComponent->Release();
	}
}


/////////////////////////////////////////////////////////////////////////////
// CJzMenu constructor/destructor 

CJzMenu::CJzMenu( IDMUSProdMenu* pIMenu, UINT nCommandID )
{
	ASSERT( pIMenu != NULL );
	ASSERT( nCommandID >= FIRST_ADDINS_MENU_ID );

	m_pIMenu = pIMenu;
	m_pIMenu->AddRef();

    m_nCommandID = nCommandID;
}


CJzMenu::~CJzMenu()
{
	if( m_pIMenu )
	{
		m_pIMenu->Release();
	}
}


/////////////////////////////////////////////////////////////////////////////
// CJzToolBar constructor/destructor 

CJzToolBar::CJzToolBar()
{
    m_pClientToolBar = NULL;
    m_nControlID = -1;
}


CJzToolBar::~CJzToolBar()
{
	if( m_pClientToolBar )
	{
		if( m_pClientToolBar->GetSafeHwnd() )
		{
			m_pClientToolBar->DestroyWindow();
		}
		delete m_pClientToolBar;
	}
}


/////////////////////////////////////////////////////////////////////////////
// CJzNode constructor/destructor 

CJzNode::CJzNode( IDMUSProdNode* pINode )
{
	ASSERT( pINode != NULL );

	m_pINode = pINode;
	m_pINode->AddRef();

	ZeroMemory( &m_wp, sizeof(m_wp) );
}


CJzNode::~CJzNode()
{
	if( m_pINode )
	{
		m_pINode->Release();
	}
}


/////////////////////////////////////////////////////////////////////////////
// CJzNotifyNode constructor/destructor 

CJzNotifyNode::CJzNotifyNode()
{
    m_pINotifyThisNode = NULL;
	m_nUseCount = 0;

	memset( &m_guidFile, 0, sizeof(m_guidFile) );
}


CJzNotifyNode::~CJzNotifyNode()
{
	if( m_pINotifyThisNode )
	{
		m_pINotifyThisNode->Release();
	}
}


/////////////////////////////////////////////////////////////////////////////
// CJzClipFormat

CJzClipFormat::CJzClipFormat( UINT uClipFormat, LPCTSTR szExt )
{
	ASSERT( uClipFormat != 0 );
	ASSERT( szExt != NULL );

    m_uClipFormat = uClipFormat;
	m_strExt = szExt;
}


CJzClipFormat::~CJzClipFormat()
{
}


/////////////////////////////////////////////////////////////////////////////
// CJzSharedObject

CJzSharedObject::CJzSharedObject( REFCLSID clsid, IUnknown* pIUnknown )
{
	ASSERT( pIUnknown != NULL );

    m_clsid = clsid;

	m_pIUnknown = pIUnknown;
	m_pIUnknown->AddRef();
}


CJzSharedObject::~CJzSharedObject()
{
	if( m_pIUnknown )
	{
		m_pIUnknown->Release();
	}
}


/////////////////////////////////////////////////////////////////////////////
// CFramework constructor/destructor 

CFramework::CFramework()
{
    m_dwRef = 1;
	m_nNextMenuID = FIRST_ADDINS_MENU_ID;
	m_nNextToolBarID = FIRST_TOOLBAR_ID;
}

CFramework::~CFramework()
{
	CleanUp();
	theApp.m_pFramework = NULL;
}

void CFramework::CleanUp()
{
	FreeDocTypes();
	FreeComponents();
	FreeClipFormats();
	FreeSharedObjects();
}


/////////////////////////////////////////////////////////////////////////////
// CFramework implementation

/////////////////////////////////////////////////////////////////////////////
// CFramework::LoadComponents

BOOL CFramework::LoadComponents( void )
{
	HKEY	  hKeyOpen;
	HKEY	  hKeyOpenClsId;
	DWORD	  dwIndex;
	LONG	  lResult;
	BOOL	  fRegMsg = FALSE;
	BOOL	  fLoadClsId;
	DWORD	  dwType;
	DWORD	  dwCbData;
	FILETIME  ftFileTime;
	DWORD     dwSkipValue;
	IDMUSProdComponent* pIComponent;
	_TCHAR	  achClsId[MID_BUFFER];
	_TCHAR	  achName[MID_BUFFER];

	lResult = ::RegOpenKeyEx( HKEY_LOCAL_MACHINE,
						  	  _T("Software\\Microsoft\\DMUSProducer\\Components"),
							  0, KEY_READ, &hKeyOpen );
	if( lResult != ERROR_SUCCESS )
	{
		AfxMessageBox( IDS_ERR_NO_COMPONENTS );
		return FALSE;
	}

	dwIndex = 0;
	for( ; ; )
	{
		dwCbData = MID_BUFFER;
		lResult  = ::RegEnumKeyEx( hKeyOpen, dwIndex++, achClsId, &dwCbData,
								   NULL, NULL, NULL, &ftFileTime );
		if( lResult == ERROR_NO_MORE_ITEMS )
		{
			break;
		}
		if( lResult != ERROR_SUCCESS )
		{
			fRegMsg  = TRUE;
			AfxMessageBox( IDS_ERR_REG_COMPONENT );
			break;
		}

		_tcscpy( achName, _T("") );
		fLoadClsId = TRUE;
		lResult    = ::RegOpenKeyEx( hKeyOpen, achClsId,
								     0, KEY_QUERY_VALUE, &hKeyOpenClsId );
		if( lResult == ERROR_SUCCESS )
		{
			dwCbData = MID_BUFFER;
			lResult  = ::RegQueryValueEx( hKeyOpenClsId, _T(""), NULL,
										  &dwType, (LPBYTE)&achName, &dwCbData );
			if( (lResult != ERROR_SUCCESS)
			||  (dwType != REG_SZ) )
			{
				_tcscpy( achName, _T("") );
			}

			dwCbData = sizeof(DWORD);
			lResult  = ::RegQueryValueEx( hKeyOpenClsId, _T("Skip"), NULL,
										  &dwType, (LPBYTE)&dwSkipValue, &dwCbData );
			if( (lResult == ERROR_SUCCESS)
			&&  (dwType == REG_DWORD)
			&&  (dwSkipValue == 1) )
			{
				fLoadClsId = FALSE;
			}
		
			::RegCloseKey( hKeyOpenClsId );
		}

		if( fLoadClsId )
		{
			CLSID clsid;
			wchar_t awchClsId[80];

			if( MultiByteToWideChar( CP_ACP, 0, achClsId, -1, awchClsId, sizeof(awchClsId) / sizeof(wchar_t) ) != 0 )
			{
				IIDFromString( awchClsId, &clsid );
			}
			else
			{
				memset( &clsid, 0, sizeof(clsid) );
			}

			if( SUCCEEDED(::CoCreateInstance(clsid, NULL, CLSCTX_INPROC_SERVER,
						  IID_IDMUSProdComponent, (void**)&pIComponent)) )
			{
				CJzComponent* pJzComponent = new CJzComponent( clsid, pIComponent );
				if( pJzComponent )
				{
					m_lstComponents.AddTail( pJzComponent );
				}
				else
				{
					AfxMessageBox( IDS_ERR_MEMORY );
					pIComponent->Release();
				}
			}
			else
			{
				CString strMsg;

				AfxFormatString2( strMsg, IDS_ERR_LOAD_COMPONENT, achName, achClsId );
				AfxMessageBox( strMsg );
			}
		}
	}

	::RegCloseKey( hKeyOpen );

	return TRUE;
}


/////////////////////////////////////////////////////////////////////////////
// CFramework::InitComponents

BOOL CFramework::InitComponents( void )
{
	HRESULT hr;
	IDMUSProdComponent* pIComponent;
	IDMUSProdComponent* pINextComponent;

	BSTR bstrErrMsg = NULL;

    hr = GetFirstComponent( &pINextComponent );

	while( SUCCEEDED( hr )  &&  pINextComponent )
    {
		pIComponent = pINextComponent;

		CJzComponent* pJzComponent = GetJzComponent( pIComponent );
		ASSERT( pJzComponent != NULL );		// Should not happen!

		if( pJzComponent->m_fInitialized  )
		{
			hr = S_OK;
		}
		else
		{
			hr = pIComponent->Initialize( (IDMUSProdFramework *)this, &bstrErrMsg );
		}
		if( SUCCEEDED( hr ) )
		{
			pJzComponent->m_fInitialized = TRUE;

			hr = GetNextComponent( pIComponent, &pINextComponent );
		}
		else
		{
			BSTR	 bstrName;
			CString  strName;
			CString  strMsg;
			CString  strErrMsg;
			TCHAR    achClsId[MID_BUFFER];
			LPOLESTR pszClsId;

			if( hr == E_POINTER
			||  hr == E_INVALIDARG )
			{
				strErrMsg.LoadString( IDS_ERR_INVALIDARG );
			}
			else if( hr == E_OUTOFMEMORY )
			{
				strErrMsg.LoadString( IDS_ERR_NO_MEMORY );
			}
			else
			{
				if( bstrErrMsg )
				{
					strErrMsg = bstrErrMsg;
				}
			}
			if( bstrErrMsg )
			{
				::SysFreeString( bstrErrMsg );
			}

			if( SUCCEEDED ( pIComponent->GetName( &bstrName ) ) )
			{
				strName = bstrName;
				::SysFreeString( bstrName );
			}
			else
			{
				strName.Empty();
			}

			if( pJzComponent
			&&  SUCCEEDED( StringFromIID( pJzComponent->m_clsidComponent, &pszClsId ) ) )
			{
				WideCharToMultiByte( CP_ACP, 0, pszClsId, -1, achClsId, sizeof( achClsId ), NULL, NULL );
				CoTaskMemFree( pszClsId );
			}
			else
			{
				_tcscpy( achClsId, _T("") );
			}

		    hr = GetNextComponent( pIComponent, &pINextComponent );

			if( pJzComponent )
			{
				POSITION pos = m_lstComponents.Find( pJzComponent );
				if( pos )
				{
					m_lstComponents.RemoveAt( pos );
				}
				delete pJzComponent;
			}

			AfxFormatString2( strMsg, IDS_ERR_INIT_COMPONENT, strName, achClsId );
			strMsg += _T("\n\n");
			strMsg += strErrMsg;
			AfxMessageBox( strMsg );
		}

		pIComponent->Release();
    }

	return TRUE;
}


/////////////////////////////////////////////////////////////////////////////
// CFramework::FreeComponents

void CFramework::FreeComponents( void )
{
	CJzComponent* pJzComponent;

	while( !m_lstComponents.IsEmpty() )
	{
		pJzComponent = static_cast<CJzComponent*>( m_lstComponents.RemoveHead() );
		delete pJzComponent;
	}
}


/////////////////////////////////////////////////////////////////////////////
// CFramework::FreeDocTypes

void CFramework::FreeDocTypes( void )
{
	IDMUSProdDocType* pIDocType;

	while( !m_lstDocTypes.IsEmpty() )
	{
		pIDocType = static_cast<IDMUSProdDocType*>( m_lstDocTypes.RemoveHead() );
		pIDocType->Release();
	}
}


/////////////////////////////////////////////////////////////////////////////
// CFramework::FreeClipFormats

void CFramework::FreeClipFormats( void )
{
	CJzClipFormat* pJzClipFormat;

	while( !m_lstClipFormats.IsEmpty() )
	{
		pJzClipFormat = static_cast<CJzClipFormat*>( m_lstClipFormats.RemoveHead() );
		delete pJzClipFormat;
	}
}


/////////////////////////////////////////////////////////////////////////////
// CFramework::FreeSharedObjects

void CFramework::FreeSharedObjects( void )
{
	CJzSharedObject* pJzSharedObject;

	while( !m_lstSharedObjects.IsEmpty() )
	{
		pJzSharedObject = static_cast<CJzSharedObject*>( m_lstSharedObjects.RemoveHead() );
		delete pJzSharedObject;
	}
}


/////////////////////////////////////////////////////////////////////////////
// CFramework::OnActivateApp

void CFramework::OnActivateApp( BOOL fActive ) 
{
	CJzComponent* pJzComponent;

    POSITION pos = m_lstComponents.GetHeadPosition();
    while( pos )
    {
        pJzComponent = m_lstComponents.GetNext( pos );

		pJzComponent->m_pIComponent->OnActivateApp( fActive );
    }
}


/////////////////////////////////////////////////////////////////////////////
// CFramework::RegisterClipboardFormats

BOOL CFramework::RegisterClipboardFormats( void )
{
	m_cfProducerFile = ::RegisterClipboardFormat( CF_DMUSPROD_FILE );

	if( m_cfProducerFile == 0 )
	{
		return FALSE;
	}

	return TRUE;
}


/////////////////////////////////////////////////////////////////////////////
// CFramework::SetNodeName

BOOL CFramework::SetNodeName( IDMUSProdNode* pINode, LPCTSTR szNewName )
{
	if( pINode )
	{
		CString strNewName = szNewName;
		BSTR bstrNewName = strNewName.AllocSysString();

		pINode->SetNodeName( bstrNewName );

		HTREEITEM hItem = FindTreeItem( pINode );
		if( hItem )
		{
			CTreeCtrl* pTreeCtrl = theApp.GetProjectTreeCtrl();
			if( pTreeCtrl )
			{
				pTreeCtrl->SetItemText( hItem, strNewName );
				return TRUE;
			}
		}
	}

	return FALSE;
}


/////////////////////////////////////////////////////////////////////////////
// CFramework::DetermineParentNode

IDMUSProdNode* CFramework::DetermineParentNode( LPCTSTR szFileName )
{
	AFX_MANAGE_STATE( AfxGetAppModuleState() );

	CTreeCtrl* pTreeCtrl = theApp.GetProjectTreeCtrl();

	if( pTreeCtrl == NULL )
	{
		return NULL;
	}

	IDMUSProdNode* pIParentNode = NULL;

	switch( theApp.m_nFileTarget )
	{
		case TGT_FILENODE:
		{
			ASSERT( szFileName != NULL );

			CFileNode* pFileNode = theApp.FindFileNode( szFileName );
			ASSERT( pFileNode != NULL );

			if( pFileNode )
			{
				pIParentNode = pFileNode->m_pIParentNode;
				ASSERT( pIParentNode != NULL );
			}
			break;
		}

		case TGT_FILENODE_SAVEAS:
		{
			ASSERT( szFileName != NULL );

			CProject* pProject = theApp.GetProjectByFileName( szFileName );
			if( pProject )
			{
				CFileNode* pFileNode = pProject->FindFileNode( szFileName );

				if( pFileNode == NULL )
				{
					// Create a FileNode
					pFileNode = pProject->CreateFileNode( szFileName );
				}

				if( pFileNode )
				{
					pIParentNode = pFileNode->m_pIParentNode;
					ASSERT( pIParentNode != NULL );
				}

				pProject->Release();
			}
			break;
		}

		case TGT_SELECTEDNODE:
		{
			IDMUSProdProject* pIProject;
			GUID guidNodeId;

			// Make sure there is a Project
			theApp.GetFirstProject( &pIProject );
			if( pIProject )
			{
				pIProject->Release();
			}
			else
			{
				theApp.CreateNewProject();
			}

			// First directory node will be the parent
			HTREEITEM hItem = pTreeCtrl->GetSelectedItem();
			while( hItem )
			{
				CJzNode* pJzNode = (CJzNode *)pTreeCtrl->GetItemData( hItem );
				if( pJzNode )
				{
					ASSERT( pJzNode->m_pINode != NULL );

					if( pJzNode->m_pINode )
					{
						if( SUCCEEDED ( pJzNode->m_pINode->GetNodeId( &guidNodeId ) ) )
						{
							if( IsEqualGUID( guidNodeId, GUID_ProjectFolderNode )
							||  IsEqualGUID( guidNodeId, GUID_DirectoryNode ) )
							{
								pIParentNode = pJzNode->m_pINode;
								ASSERT( pIParentNode != NULL );
								break;
							}
						}
					}
				}

				hItem = pTreeCtrl->GetNextItem( hItem, TVGN_PARENT );
			}
			break;
		}
		
		case TGT_PROJECT:
		{
			CString strProjectFileName;

			theApp.FindProjectFileName( szFileName, strProjectFileName );
			if( strProjectFileName.IsEmpty() )
			{
				pIParentNode = (IDMUSProdNode *)theApp.CreateNewProject();
			}
			else
			{
				HINSTANCE hInstance = AfxGetResourceHandle();
				AfxSetResourceHandle( theApp.m_hInstance );

				CWhichProjectDlg wpDlg;
				wpDlg.m_strFileName = szFileName;
				int nResult = wpDlg.DoModal();

				AfxSetResourceHandle( hInstance );
			
				switch( nResult )
				{
					case IDC_NEW_PROJECT:
						pIParentNode = (IDMUSProdNode *)theApp.CreateNewProject();
						break;

					case IDC_USE_PROJECT:
						if( theApp.OpenDocumentFile( strProjectFileName ) )
						{
							CFileNode* pFileNode = theApp.FindFileNode( szFileName );
							if( pFileNode )
							{
								pIParentNode = pFileNode->m_pIParentNode;
								ASSERT( pIParentNode != NULL );
							}
						}
						break;
				}
			}
			break;
		}
	}

	return pIParentNode;
}


/////////////////////////////////////////////////////////////////////////////
// CFramework::SearchTree

HTREEITEM CFramework::SearchTree( CTreeCtrl* pTreeCtrl, IDMUSProdNode* pINode, HTREEITEM hItem )
{
	HTREEITEM hNodeItem = NULL;
	HTREEITEM hChildItem;
	IDMUSProdNode* pITreeNode;

	ASSERT( pTreeCtrl != NULL );
	ASSERT( pINode != NULL );
	ASSERT( hItem != NULL );

	while( hItem )
	{
		CJzNode* pJzNode = (CJzNode *)pTreeCtrl->GetItemData( hItem );
		if( pJzNode )
		{
			pITreeNode = pJzNode->m_pINode;
			ASSERT( pITreeNode != NULL );

			if( pITreeNode == pINode )
			{
				hNodeItem = hItem;
			}
			else
			{
				hChildItem = hItem;
				while( hChildItem = pTreeCtrl->GetNextItem(hChildItem, TVGN_CHILD) )
				{
					hNodeItem = SearchTree( pTreeCtrl, pINode, hChildItem );
					if( hNodeItem )
					{
						break;
					}
				}
			}
		}

		if( hNodeItem )
		{
			break;
		}

		hItem = pTreeCtrl->GetNextItem( hItem, TVGN_NEXT );
	}

	return hNodeItem;
}


/////////////////////////////////////////////////////////////////////////////
// CFramework::FindTreeItem

HTREEITEM CFramework::FindTreeItem( IDMUSProdNode* pINode )
{
	HTREEITEM hNodeItem = NULL;

	ASSERT( pINode != NULL );

	CTreeCtrl* pTreeCtrl = theApp.GetProjectTreeCtrl();
	if( pTreeCtrl == NULL )
	{
		return NULL;
	}

	HTREEITEM hItem = pTreeCtrl->GetNextItem( NULL, TVGN_CHILD );		// first child in tree

	if( hItem )
	{
		GUID guidNodeId;
		BOOL fSearchFinished = FALSE;

		if( SUCCEEDED ( pINode->GetNodeId( &guidNodeId ) ) )
		{
			if( ::IsEqualGUID( guidNodeId, GUID_ProjectFolderNode )
			||  ::IsEqualGUID( guidNodeId, GUID_DirectoryNode ) )
			{
				CDirectoryNode* pDirNode = (CDirectoryNode *)pINode;

				hNodeItem = pDirNode->m_hItem;
				fSearchFinished = TRUE;
			}
			else if( IsEqualGUID( guidNodeId, GUID_FileNode ) )
			{
				CFileNode* pFileNode = (CFileNode *)pINode;

				hNodeItem = pFileNode->m_hItem;
				fSearchFinished = TRUE;
			}
		}

		if( fSearchFinished == FALSE )
		{
			IDMUSProdNode* pIDocRootNode;

			if( SUCCEEDED ( pINode->GetDocRootNode( &pIDocRootNode ) ) )
			{
				if( pIDocRootNode )
				{
					CFileNode* pFileNode = theApp.GetFileByDocRootNode( pIDocRootNode );
					if( pFileNode )
					{
						HTREEITEM hDocRootItem = pFileNode->m_hChildItem;
						if( hDocRootItem )
						{
							if( pINode == pIDocRootNode )
							{
								hNodeItem = hDocRootItem;
							}
							else
							{
								// Search all nodes under DocRootNode
								hNodeItem = SearchTree( pTreeCtrl, pINode, hDocRootItem );
							}
						}

						pFileNode->Release();
					}

					pIDocRootNode->Release();
				}
			}
		}
	}

	return hNodeItem;
}


/////////////////////////////////////////////////////////////////////////////
// CFramework::FindTreeProjectByGUID

HTREEITEM CFramework::FindTreeProjectByGUID( GUID guidProject )
{
	HTREEITEM hProjectNodeItem = NULL;

	CTreeCtrl* pTreeCtrl = theApp.GetProjectTreeCtrl();
	if( pTreeCtrl == NULL )
	{
		return NULL;
	}

	HTREEITEM hItem = pTreeCtrl->GetNextItem( NULL, TVGN_CHILD );		// first child in tree
	
	IDMUSProdNode* pITreeNode;
	IDMUSProdProject* pITreeProject;
	GUID guidTreeProject;

	while( hItem )
	{
		CJzNode* pJzNode = (CJzNode *)pTreeCtrl->GetItemData( hItem );
		if( pJzNode )
		{
			pITreeNode = pJzNode->m_pINode;
			ASSERT( pITreeNode != NULL );

			if( SUCCEEDED ( pITreeNode->QueryInterface( IID_IDMUSProdProject, (void **)&pITreeProject ) ) )
			{
				if( SUCCEEDED ( pITreeProject->GetGUID ( &guidTreeProject ) ) )
				{
					if( IsEqualGUID( guidProject, guidTreeProject ) )
					{
						hProjectNodeItem = hItem;
					}
				}

				pITreeProject->Release();

				if( hProjectNodeItem )
				{
					break;
				}
			}
		}

		hItem = pTreeCtrl->GetNextItem( hItem, TVGN_NEXT );
	}

	return hProjectNodeItem;
}


/////////////////////////////////////////////////////////////////////////////
// CFramework::SearchTreeForWP

HTREEITEM CFramework::SearchTreeForWP( CTreeCtrl* pTreeCtrl, wpWindowPlacement* pWP, long lTreePos, HTREEITEM hItem )
{
	HTREEITEM hNodeItem = NULL;
	HTREEITEM hNodeItemSecondChoice = NULL;
	HTREEITEM hChildItem;
	IDMUSProdNode* pITreeNode;

	ASSERT( pTreeCtrl != NULL );
	ASSERT( pWP != NULL );
	ASSERT( hItem != NULL );

	while( hItem )
	{
		CJzNode* pJzNode = (CJzNode *)pTreeCtrl->GetItemData( hItem );
		if( pJzNode )
		{
			pITreeNode = pJzNode->m_pINode;
			ASSERT( pITreeNode != NULL );

			GUID guidNodeId;
			if( SUCCEEDED ( pITreeNode->GetNodeId( &guidNodeId ) ) )
			{
				// Is the Node ID equal?
				if( IsEqualGUID ( guidNodeId, pWP->guidNodeId ) )
				{
					BSTR bstrNodeName;
					if( SUCCEEDED ( pITreeNode->GetNodeName ( &bstrNodeName ) ) )
					{
						CString strNodeName = bstrNodeName;
						::SysFreeString( bstrNodeName );

						// Is node name equal?
						if( strNodeName == pWP->strNodeName )
						{
							// Is the tree position equal?
							if( lTreePos == pWP->lTreePos )
							{
								// This is a match
								hNodeItem = hItem;
								break;
							}
							else
							{
								// This is second choice
								hNodeItemSecondChoice = hItem;
							}
						}
					}
				}
			}
		}

		if( hNodeItem == NULL )
		{
			hChildItem = hItem;
			while( hChildItem = pTreeCtrl->GetNextItem(hChildItem, TVGN_CHILD) )
			{
				hNodeItem = SearchTreeForWP( pTreeCtrl, pWP, ++lTreePos, hChildItem );
				if( hNodeItem )
				{
					break;
				}
			}
		}

		if( hNodeItem )
		{
			break;
		}

		hItem = pTreeCtrl->GetNextItem( hItem, TVGN_NEXT );
		lTreePos++;
	}

	if( hNodeItem == NULL )
	{
		hNodeItem = hNodeItemSecondChoice;
	}

	return hNodeItem;
}


/////////////////////////////////////////////////////////////////////////////
// CFramework FindTreeItemByWP

HTREEITEM CFramework::FindTreeItemByWP( wpWindowPlacement* pWP )
{
	ASSERT( pWP != NULL );

	HTREEITEM hItemWP = NULL;

	// Get the FileNode
	CFileNode* pFileNode = theApp.GetFileByGUID( pWP->guidFile );
	if( pFileNode )
	{
		if( pFileNode->m_pIChildNode )
		{
			// Get the File's DocRoot node
			HTREEITEM hItem = theApp.m_pFramework->FindTreeItem( pFileNode->m_pIChildNode );
			if( hItem )
			{
				CTreeCtrl* pTreeCtrl = theApp.GetProjectTreeCtrl();
				if( pTreeCtrl )
				{
					// Get the
					hItemWP = SearchTreeForWP( pTreeCtrl, pWP, 1, hItem );
				}
			}
		}

		pFileNode->Release();
	}

	return hItemWP;
}


/////////////////////////////////////////////////////////////////////////////
// CFramework::CountWPTreePos

long CFramework::CountWPTreePos( CTreeCtrl* pTreeCtrl, IDMUSProdNode* pINode, long lTreePos, HTREEITEM hItem )
{
	long lPos = 0;
	HTREEITEM hChildItem;
	IDMUSProdNode* pITreeNode;

	ASSERT( pTreeCtrl != NULL );
	ASSERT( pINode != NULL );
	ASSERT( hItem != NULL );

	while( hItem )
	{
		CJzNode* pJzNode = (CJzNode *)pTreeCtrl->GetItemData( hItem );
		if( pJzNode )
		{
			pITreeNode = pJzNode->m_pINode;
			ASSERT( pITreeNode != NULL );

			// Is the node equal?
			if( pITreeNode == pINode )
			{
				lPos = lTreePos;
				break;
			}
		}

		if( lPos == 0 )
		{
			hChildItem = hItem;
			while( hChildItem = pTreeCtrl->GetNextItem(hChildItem, TVGN_CHILD) )
			{
				lPos = CountWPTreePos( pTreeCtrl, pINode, ++lTreePos, hChildItem );
				if( lPos )
				{
					break;
				}
			}
		}

		if( lPos )
		{
			break;
		}

		hItem = pTreeCtrl->GetNextItem( hItem, TVGN_NEXT );
		lTreePos++;
	}

	return lPos;
}


/////////////////////////////////////////////////////////////////////////////
// CFramework GetWPTreePos

long CFramework::GetWPTreePos( IDMUSProdNode* pINode )
{
	ASSERT( pINode != NULL );

	HTREEITEM hItem = NULL;
	CTreeCtrl* pTreeCtrl = theApp.GetProjectTreeCtrl();
	if( pTreeCtrl )
	{
		hItem = pTreeCtrl->GetNextItem( NULL, TVGN_CHILD );		// first child in tree
	}
	if( hItem == NULL )
	{
		return 0;
	}

	long lTreePos = 0;

	IDMUSProdNode* pIDocRootNode;

	if( SUCCEEDED ( pINode->GetDocRootNode( &pIDocRootNode ) ) )
	{
		if( pIDocRootNode )
		{
			// Find the DocRootNode
			CFileNode* pFileNode = theApp.GetFileByDocRootNode( pIDocRootNode );
			if( pFileNode )
			{
				HTREEITEM hDocRootItem = pFileNode->m_hChildItem;
				if( hDocRootItem )
				{
					// Return tree position of pINode
					lTreePos = CountWPTreePos( pTreeCtrl, pINode, 1, hDocRootItem );
				}

				pFileNode->Release();
			}

			pIDocRootNode->Release();
		}
	}

	return lTreePos;
}


/////////////////////////////////////////////////////////////////////////////
// CFramework ApplyWPSettings

void CFramework::ApplyWPSettings( HTREEITEM hItem, wpWindowPlacement* pWP )
{
	ASSERT( hItem != NULL );
	ASSERT( pWP != NULL );

	CTreeCtrl* pTreeCtrl = theApp.GetProjectTreeCtrl();
	if( pTreeCtrl )
	{
		CJzNode* pJzNode = (CJzNode *)pTreeCtrl->GetItemData( hItem );
		ASSERT( pJzNode != NULL );

		pJzNode->m_wp.length = sizeof(pJzNode->m_wp);
		pJzNode->m_wp.flags = pWP->wp.flags;
		pJzNode->m_wp.showCmd = pWP->wp.showCmd;
		pJzNode->m_wp.ptMinPosition = pWP->wp.ptMinPosition;
		pJzNode->m_wp.ptMaxPosition = pWP->wp.ptMaxPosition;
		pJzNode->m_wp.rcNormalPosition = pWP->wp.rcNormalPosition;
	}
}


/////////////////////////////////////////////////////////////////////////////
// CFramework::ShowTreeNode

BOOL CFramework::ShowTreeNode( IDMUSProdNode* pINode )
{
	if( theApp.m_nShowNodeInTree < 0 )
	{
		ASSERT( 0 );	// Should not happen
		theApp.m_nShowNodeInTree = SHOW_NODE_IN_TREE;
	}

	if( theApp.m_nShowNodeInTree == SHOW_NODE_IN_TREE )
	{
		if( pINode )
		{
			HTREEITEM hItem = FindTreeItem( pINode );

			if( hItem )
			{
				CTreeCtrl* pTreeCtrl = theApp.GetProjectTreeCtrl();
				if( pTreeCtrl )
				{
					CWnd* pWndHadFocus = CWnd::GetFocus();

					// BUG 52522: Let's disable 'auto-scrolling' in the project tree.  Files in use should continue to be highlighted, just not scrolled to.
					//pTreeCtrl->EnsureVisible( hItem );
					pTreeCtrl->LockWindowUpdate();
					HTREEITEM hItemFirstVis = pTreeCtrl->GetFirstVisibleItem();
					pTreeCtrl->SelectItem( hItem );
					if( hItemFirstVis )
					{
						pTreeCtrl->Select( hItemFirstVis, TVGN_FIRSTVISIBLE );
					}
					pTreeCtrl->UnlockWindowUpdate();

					if( pWndHadFocus == pTreeCtrl
					&&  pWndHadFocus != CWnd::GetFocus() )
					{
						pWndHadFocus->SetFocus();
					}

					return TRUE;
				}
			}
		}
	}

	return FALSE;
}


/////////////////////////////////////////////////////////////////////////////
// CFramework::RemoveNodes

BOOL CFramework::RemoveNodes( IDMUSProdNode* pINode )
{
	ASSERT( pINode != NULL );

	HTREEITEM hItem = FindTreeItem( pINode );

	if( hItem )
	{
		CTreeCtrl* pTreeCtrl = theApp.GetProjectTreeCtrl();
		if( pTreeCtrl )
		{
			HTREEITEM hParentItem = pTreeCtrl->GetParentItem( hItem );

			if( pTreeCtrl->DeleteItem(hItem) )
			{
				if( hParentItem )
				{
					if( pTreeCtrl->GetChildItem(hParentItem) == NULL )	// no children
					{
						CJzNode* pJzNode = (CJzNode *)pTreeCtrl->GetItemData( hParentItem );
						if( pJzNode )
						{
							IDMUSProdNode* pIParentNode = pJzNode->m_pINode;
							ASSERT( pIParentNode != NULL );
							
							if( pIParentNode )
							{
								BOOL fUseOpenCloseImages;

								pIParentNode->UseOpenCloseImages( &fUseOpenCloseImages );

								if( fUseOpenCloseImages == TRUE )
								{
									short nImage;

									UINT nState = pTreeCtrl->GetItemState( hParentItem, TVIS_EXPANDED );
									pTreeCtrl->SetItemState( hParentItem, nState & ~TVIS_EXPANDED, TVIS_EXPANDED );
									pIParentNode->GetNodeImageIndex( &nImage );
									pTreeCtrl->SetItemImage( hParentItem, nImage, nImage );
								}
							}
						}
					}
				}

				theApp.DrawProjectTree();
				return TRUE;
			}
		}
	}

	return FALSE;
}


/////////////////////////////////////////////////////////////////////////////
// CFramework::AddNodes

BOOL CFramework::AddNodes( IDMUSProdNode* pINode, HTREEITEM hParent )
{
	HRESULT hr;
    IDMUSProdNode* pIChild;
    IDMUSProdNode* pINextChild;
	CTreeCtrl* pTreeCtrl;
	HTREEITEM hItem;
	BSTR bstrNodeName;
	BOOL fUseOpenCloseImages;
    short nImage;

	ASSERT( pINode != NULL );
	if( pINode == NULL )
	{
		return FALSE;
	}

	pTreeCtrl = theApp.GetProjectTreeCtrl();
	if( pTreeCtrl == NULL )
	{
		return FALSE;
	}
	
	CJzNode* pJzNode = new CJzNode( pINode );
	if( pJzNode == NULL )
	{
		return FALSE;
	}

    pINode->GetNodeName( &bstrNodeName );
    pINode->GetNodeImageIndex( &nImage );
    
	hItem = pTreeCtrl->InsertItem( CString( bstrNodeName ), hParent );

	if( hItem )
	{
		GUID guidNodeId;

		pINode->GetNodeId( &guidNodeId );

		if( ::IsEqualGUID( guidNodeId, GUID_ProjectFolderNode )
		||  ::IsEqualGUID( guidNodeId, GUID_DirectoryNode ) )
		{
			CDirectoryNode* pDirNode = (CDirectoryNode *)pINode;

			pDirNode->m_hItem = hItem;
		}
		else if( ::IsEqualGUID( guidNodeId, GUID_FileNode ) )
		{
			CFileNode* pFileNode = (CFileNode *)pINode;

			pFileNode->m_hItem = hItem;
		}
		else
		{
			IDMUSProdNode* pIDocRootNode;

			if( SUCCEEDED ( pINode->GetDocRootNode( &pIDocRootNode ) ) )
			{
				if( pIDocRootNode )
				{
					if( pINode == pIDocRootNode )
					{
						CJzNode* pJzNode = (CJzNode *)pTreeCtrl->GetItemData( hParent );
						if( pJzNode )
						{
							ASSERT( pJzNode->m_pINode != NULL );

							if( pJzNode->m_pINode )
							{
								CFileNode* pFileNode = (CFileNode *)pJzNode->m_pINode;

								ASSERT( pFileNode->m_hChildItem == NULL ); 
								pFileNode->m_hChildItem = hItem;
							}
						}
					}

					pIDocRootNode->Release();
				}
			}
		}

		pINode->UseOpenCloseImages( &fUseOpenCloseImages );
		if( fUseOpenCloseImages == TRUE )
		{
			pTreeCtrl->SetItemImage( hItem, nImage, nImage );
		}
		else
		{
			pTreeCtrl->SetItemImage( hItem, nImage, nImage + 1 );
		}
		pTreeCtrl->SetItemData( hItem, reinterpret_cast<DWORD>( pJzNode ) );

		hr = pINode->GetFirstChild( &pINextChild );

		while( SUCCEEDED( hr )  &&  pINextChild )
		{
			pIChild = pINextChild;

			AddNodes( pIChild, hItem );

		    hr = pINode->GetNextChild( pIChild, &pINextChild );
			pIChild->Release();
		}
	}

	if( pTreeCtrl->GetNextItem( hItem, TVGN_CHILD ) )
	{
		CMainFrame* pMainFrame = (CMainFrame *)theApp.m_pMainWnd;
		ASSERT( pMainFrame != NULL );
		pMainFrame->m_wndTreeBar.SortChildren( hItem );
	}

	::SysFreeString( bstrNodeName );

	return TRUE;
}


/////////////////////////////////////////////////////////////////////////////
// CFramework::OnInitAddInsMenu

void CFramework::OnInitAddInsMenu( CMenu* pAddInsMenu )
{
	CJzMenu* pJzMenu;
	
	POSITION pos = m_lstMenus.GetHeadPosition();

    while( pos != NULL )
    {
        pJzMenu = static_cast<CJzMenu*>( m_lstMenus.GetNext(pos) );
		if( pJzMenu )
		{
			pJzMenu->m_pIMenu->OnMenuInit( pAddInsMenu->GetSafeHmenu(), pJzMenu->m_nCommandID );
		}
    }
}


/////////////////////////////////////////////////////////////////////////////
// CFramework::OnSelectAddInsMenu

BOOL CFramework::OnSelectAddInsMenu( UINT nCommandID )
{
	CJzMenu* pJzMenu;
	
	POSITION pos = m_lstMenus.GetHeadPosition();

    while( pos != NULL )
    {
        pJzMenu = static_cast<CJzMenu*>( m_lstMenus.GetNext(pos) );
		if( pJzMenu )
		{
			if( pJzMenu->m_nCommandID == nCommandID )
			{
				pJzMenu->m_pIMenu->OnMenuSelect();
				return TRUE;
			}
		}
    }

	return FALSE;
}


/////////////////////////////////////////////////////////////////////////////
// CFramework::GetAddInsMenuHelpText

void CFramework::GetAddInsMenuHelpText( UINT nCommandID, CString& rMessage )
{
	CJzMenu* pJzMenu;
	
	POSITION pos = m_lstMenus.GetHeadPosition();

    while( pos != NULL )
    {
        pJzMenu = static_cast<CJzMenu*>( m_lstMenus.GetNext(pos) );
		if( pJzMenu )
		{
			if( pJzMenu->m_nCommandID == nCommandID )
			{
				BSTR bstrMenuHelpText;

				pJzMenu->m_pIMenu->GetMenuHelpText( &bstrMenuHelpText );
				rMessage = bstrMenuHelpText;
				::SysFreeString( bstrMenuHelpText );
				break;
			}
		}
    }
}


/////////////////////////////////////////////////////////////////////////////
// CFramework::FixAddInsMenu

void CFramework::FixAddInsMenu( void )
{
	CMenu* pAddInsMenu = theApp.FindMenuByName( IDS_ADDINS_MENU_TEXT );
	if( pAddInsMenu == NULL )
	{
		return;
	}
	
	// remove crusty IDMUSProdMenu menu items
	UINT nMenuID = pAddInsMenu->GetMenuItemID( 0 );
	while( (nMenuID > FIRST_ADDINS_MENU_ID) && (nMenuID <= m_nNextMenuID) )
	{
		pAddInsMenu->RemoveMenu( nMenuID, MF_BYCOMMAND );
		nMenuID = pAddInsMenu->GetMenuItemID( 0 );
	}
	
	// insert separator
//	UINT nMenuState = pAddInsMenu->GetMenuState( 0, MF_BYPOSITION );
//	if( !(nMenuState & MF_SEPARATOR) )
//	{
//		pAddInsMenu->InsertMenu( 0, MF_BYPOSITION | MF_SEPARATOR ); 
//	}
	
	// insert current list of IDMUSProdMenu items
	CJzMenu* pJzMenu;

	POSITION pos = m_lstMenus.GetHeadPosition();

    while( pos != NULL )
    {
        pJzMenu = static_cast<CJzMenu*>( m_lstMenus.GetNext(pos) );
		if( pJzMenu )
		{
			CString strMenuText;
			BSTR bstrMenuText;

			pJzMenu->m_pIMenu->GetMenuText( &bstrMenuText );
			strMenuText = bstrMenuText;
			::SysFreeString( bstrMenuText );

			pAddInsMenu->InsertMenu( 0, MF_BYPOSITION | MF_STRING, pJzMenu->m_nCommandID, strMenuText ); 
		}
    }
}


/////////////////////////////////////////////////////////////////////////////
// CFramework::RedrawClientToolbars

void CFramework::RedrawClientToolbars()
{
	CJzToolBar* pJzToolBar;

	POSITION pos = m_lstToolBars.GetHeadPosition();
	while( pos )
	{
		pJzToolBar = static_cast<CJzToolBar*>( m_lstToolBars.GetNext(pos) );

		pJzToolBar->m_pClientToolBar->RedrawWindow( NULL, NULL, RDW_INVALIDATE | RDW_UPDATENOW | RDW_ALLCHILDREN );
	}
}


/////////////////////////////////////////////////////////////////////////////
// CFramework::InsertViewMenuItem

void CFramework::InsertViewMenuItem( CJzToolBar* pJzToolBar )
{
	ASSERT( pJzToolBar != NULL );
	ASSERT( pJzToolBar->m_pClientToolBar != NULL );
	ASSERT( pJzToolBar->m_pClientToolBar->m_pIToolBar != NULL );

	CMenu* pViewMenu = theApp.FindMenuByName( IDS_VIEW_MENU_TEXT );

	if( pViewMenu )
	{
		UINT nPosition = (pJzToolBar->m_nControlID - FIRST_TOOLBAR_ID) + FIRST_TOOLBAR_ITEM;

		BSTR bstrMenuText;
		pJzToolBar->m_pClientToolBar->m_pIToolBar->GetMenuText( &bstrMenuText );
		CString strMenuText = bstrMenuText;
		::SysFreeString( bstrMenuText );

		pViewMenu->InsertMenu( nPosition, MF_BYPOSITION | MF_STRING, pJzToolBar->m_nControlID, strMenuText ); 
	}
}


/////////////////////////////////////////////////////////////////////////////
// CFramework::RemoveViewMenuItem

void CFramework::RemoveViewMenuItem( CJzToolBar* pJzToolBar )
{
	ASSERT( pJzToolBar != NULL );

	CMenu* pViewMenu = theApp.FindMenuByName( IDS_VIEW_MENU_TEXT );

	if( pViewMenu )
	{
		pViewMenu->RemoveMenu( pJzToolBar->m_nControlID, MF_BYCOMMAND );
	}
}


/////////////////////////////////////////////////////////////////////////////
// CFramework::OnInitViewMenu

void CFramework::OnInitViewMenu( CMenu* pViewMenu )
{
	CMainFrame* pMainFrame = (CMainFrame *)theApp.m_pMainWnd;
	ASSERT( pMainFrame != NULL );

	CJzToolBar* pJzToolBar;
	CControlBar* pBar;
	UINT nChecked;
	UINT nEnabled;
	
	POSITION pos = m_lstToolBars.GetHeadPosition();

    while( pos != NULL )
    {
        pJzToolBar = static_cast<CJzToolBar*>( m_lstToolBars.GetNext(pos) );
		if( pJzToolBar )
		{
			nChecked = MF_UNCHECKED;
			nEnabled = MF_GRAYED;

			pBar = pMainFrame->GetControlBar( pJzToolBar->m_nControlID );
			if( pBar )
			{
				nEnabled = MF_ENABLED;
				if( (pBar->GetStyle() & WS_VISIBLE) )
				{
					nChecked = MF_CHECKED;
				}
			}

			::EnableMenuItem( pViewMenu->GetSafeHmenu(),
							  pJzToolBar->m_nControlID,
							  (nEnabled | MF_BYCOMMAND) );
			::CheckMenuItem(  pViewMenu->GetSafeHmenu(),
							  pJzToolBar->m_nControlID,
							  (nChecked | MF_BYCOMMAND) );
		}
    }
}


/////////////////////////////////////////////////////////////////////////////
// CFramework::OnSelectViewMenu

BOOL CFramework::OnSelectViewMenu( UINT nCommandID )
{
	if( (nCommandID >= FIRST_TOOLBAR_ID) && (nCommandID < m_nNextToolBarID) )
	{
		CMainFrame* pMainFrame = (CMainFrame *)theApp.m_pMainWnd;
		ASSERT( pMainFrame != NULL );

		CControlBar* pBar = pMainFrame->GetControlBar( nCommandID );
		if( pBar )
		{
			pMainFrame->OnBarCheck( nCommandID );
			return TRUE;
		}
	}

	return FALSE;
}


/////////////////////////////////////////////////////////////////////////////
// CFramework::FixViewMenu

void CFramework::FixViewMenu( void )
{
	CMenu* pViewMenu = theApp.FindMenuByName( IDS_VIEW_MENU_TEXT );
	if( pViewMenu == NULL )
	{
		return;
	}
	
	// remove crusty IDMUSProdToolBar menu items
	UINT nMenuID;

	nMenuID = pViewMenu->GetMenuItemID( FIRST_TOOLBAR_ITEM );
	while( (nMenuID >= FIRST_TOOLBAR_ID) && (nMenuID < m_nNextToolBarID) )
	{
		pViewMenu->RemoveMenu( nMenuID, MF_BYCOMMAND );
		nMenuID = pViewMenu->GetMenuItemID( FIRST_TOOLBAR_ITEM );
	}
	
	// insert current list of IDMUSProdToolBar items
	CJzToolBar* pJzToolBar;

	POSITION pos = m_lstToolBars.GetHeadPosition();

    while( pos != NULL )
    {
        pJzToolBar = static_cast<CJzToolBar*>( m_lstToolBars.GetNext(pos) );
		if( pJzToolBar )
		{
			InsertViewMenuItem( pJzToolBar ); 
		}
    }
}

	
/////////////////////////////////////////////////////////////////////////////
// CFramework::GetViewMenuHelpText

void CFramework::GetViewMenuHelpText( UINT nCommandID, CString& rMessage )
{
	CJzToolBar* pJzToolBar;
	
	POSITION pos = m_lstToolBars.GetHeadPosition();

    while( pos != NULL )
    {
        pJzToolBar = static_cast<CJzToolBar*>( m_lstToolBars.GetNext(pos) );
		if( pJzToolBar )
		{
			if( pJzToolBar->m_nControlID == nCommandID )
			{
				BSTR bstrMenuHelpText;

				pJzToolBar->m_pClientToolBar->m_pIToolBar->GetMenuHelpText( &bstrMenuHelpText );
				rMessage = bstrMenuHelpText;
				::SysFreeString( bstrMenuHelpText );
				break;
			}
		}
    }
}


/////////////////////////////////////////////////////////////////////////////
// CFramework::GetJzComponent

CJzComponent* CFramework::GetJzComponent( IDMUSProdComponent* pIComponent )
{
	CJzComponent* pTheJzComponent = NULL;

    POSITION pos = m_lstComponents.GetHeadPosition();

    while( pos )
    {
        CJzComponent* pJzComponent = m_lstComponents.GetNext( pos );
		if( pJzComponent->m_pIComponent == pIComponent )
		{
			pTheJzComponent = pJzComponent;
			break;
		}
    }

	return pTheJzComponent;
}


/////////////////////////////////////////////////////////////////////////////
// CFramework IDMUSProdFramework implementation

/////////////////////////////////////////////////////////////////////////////
// CFramework::QueryInterface

HRESULT CFramework::QueryInterface( REFIID iid, void FAR* FAR* ppvObj )
{
	AFX_MANAGE_STATE( AfxGetAppModuleState() );

	if( ::IsEqualIID(iid, IID_IDMUSProdPropSheet) )
	{
		CMainFrame* pMainFrame = (CMainFrame *)theApp.m_pMainWnd;
		if( pMainFrame
		&&  pMainFrame->m_wndProperties.m_pPropertySheet  )
		{
			return pMainFrame->m_wndProperties.m_pPropertySheet->QueryInterface( iid, ppvObj );
		}
		else
		{
		    *ppvObj = NULL;
		    return E_NOINTERFACE;
		}
	}

    if( ::IsEqualIID(iid, IID_IDMUSProdFramework)
    ||  ::IsEqualIID(iid, IID_IDMUSProdFramework8)
	||  ::IsEqualIID(iid, IID_IUnknown) )
    {
        AddRef();
        *ppvObj = (IDMUSProdFramework8 *)this;
        return S_OK;
    }

    if( ::IsEqualIID(iid, IID_IDMUSProdFileRefChunk) )
    {
        AddRef();
        *ppvObj = (IDMUSProdFileRefChunk *)this;
        return S_OK;
    }

    if( ::IsEqualIID(iid, IID_IDMUSProdLoaderRefChunk) )
    {
        AddRef();
        *ppvObj = (IDMUSProdLoaderRefChunk *)this;
        return S_OK;
    }

    *ppvObj = NULL;
    return E_NOINTERFACE;
}


/////////////////////////////////////////////////////////////////////////////
// CFramework::AddRef

ULONG CFramework::AddRef()
{
	AFX_MANAGE_STATE( AfxGetAppModuleState() );

    return ++m_dwRef;
}


/////////////////////////////////////////////////////////////////////////////
// CFramework::Release

ULONG CFramework::Release()
{
	AFX_MANAGE_STATE( AfxGetAppModuleState() );

    ASSERT( m_dwRef != 0 );

    --m_dwRef;

    if( m_dwRef == 0 )
    {
        delete this;
        return 0;
    }

    return m_dwRef;
}


/*======================================================================================
METHOD:  IDMUSPRODFRAMEWORK::FINDCOMPONENT
========================================================================================
@method HRESULT | IDMUSProdFramework | FindComponent | Returns a pointer to the specified
		Component's <i IDMUSProdComponent> interface.
 
@comm
	The Framework calls CoCreateInstance to obtain an <i IDMUSProdComponent> interface for each
	of the Component CLSID's registered under:

	[HKEY_LOCAL_MACHINE\Software\Microsoft\DMUSProducer\Components].

	<om IDMUSProdFramework.FindComponent> locates the <i IDMUSProdComponent> whose CLSID matches
	<p rclsid> and ensures the Component's <om IDMUSProdComponent.Initialize> method has been
	called before returning its pointer in <p ppIComponent>.

	A Component that uses other DirectMusic Producer Components must call
	<om IDMUSProdFramework.FindComponent> to obtain a pointer to each of the required Component's
	<i IDMUSProdComponent> interface.

@rvalue S_OK | The specified Component's <i IDMUSProdComponent> was returned in <p ppIComponent>.
@rvalue E_POINTER | The address in <p ppIComponent> is not valid.  For example, it may be NULL.

@ex The following excerpt from an <om IDMUSProdComponent.Initialize> method obtains interface
	pointers to the Conductor Component and the Band Editor Component: |

	// Get IDMUSProdConductor interface pointers 
	if( FAILED ( pIFramework->FindComponent( CLSID_CConductor,  &pIComponent ) )
	||  FAILED ( pIComponent->QueryInterface( IID_IDMUSProdConductor, (void**)&m_pIConductor ) ) )
	{
		CleanUp();
		if( pIComponent )
		{
			pIComponent->Release();
		}
		::LoadString( theApp.m_hInstance, IDS_ERR_MISSING_CONDUCTOR, achErrMsg, MID_BUFFER );
		strErrMsg = achErrMsg;
		*pbstrErrMsg = strErrMsg.AllocSysString();
		return E_FAIL;
	}
	pIComponent->Release();

	// Get the IDMUSProdComponent interface for the Band Editor Component 
	if( FAILED ( pIFramework->FindComponent( CLSID_BandComponent,  &m_pIBandComponent ) ) )
	{
		CleanUp();
		::LoadString( theApp.m_hInstance, IDS_ERR_MISSING_BAND, achErrMsg, MID_BUFFER );
		strErrMsg = achErrMsg;
		*pbstrErrMsg = strErrMsg.AllocSysString();
		return E_FAIL;
	}
	
@xref <i IDMUSProdComponent>, <i IDMUSProdFramework>, <om IDMUSProdFramework.GetFirstComponent>, <om IDMUSProdFramework.GetNextComponent>
--------------------------------------------------------------------------------------*/

/////////////////////////////////////////////////////////////////////////////
// CFramework::FindComponent

HRESULT CFramework::FindComponent(
	REFCLSID rclsid,				// @parm [in] CLSID of the Component to be found.
	IDMUSProdComponent** ppIComponent	// @parm [out,retval] Address of a variable to receive the  
									//		requested <i IDMUSProdComponent> interface.  If an error
									//		occurs, the implementation sets <p ppIComponent>
									//		to NULL.  On success, the caller is responsible
									//		for calling <om IDMUSProdComponent.Release>.
)
{
	AFX_MANAGE_STATE( AfxGetAppModuleState() );

	if( ppIComponent == NULL )
	{
		return E_POINTER;
	}

    *ppIComponent = NULL;

    POSITION pos = m_lstComponents.GetHeadPosition();

    while( pos )
    {
        CJzComponent* pJzComponent = m_lstComponents.GetNext( pos );

		if( IsEqualCLSID( pJzComponent->m_clsidComponent, rclsid ) )
		{
			if( pJzComponent->m_fInitialized == FALSE )
			{
				BSTR bstrErrMsg = NULL;

				if( SUCCEEDED( pJzComponent->m_pIComponent->Initialize(this, &bstrErrMsg) ) )
				{
					pJzComponent->m_fInitialized = TRUE;
				}
				if( bstrErrMsg )
				{
					::SysFreeString( bstrErrMsg );
				}
			}
			if( pJzComponent->m_fInitialized )
			{
				pJzComponent->m_pIComponent->AddRef();
				*ppIComponent = pJzComponent->m_pIComponent;
			}
			break;
		}
    }

	if( *ppIComponent )
	{
		return S_OK;
	}

	return E_FAIL;
}


/*======================================================================================
METHOD:  IDMUSPRODFRAMEWORK::GETFIRSTCOMPONENT
========================================================================================
@method HRESULT | IDMUSProdFramework | GetFirstComponent | Returns an <i IDMUSProdComponent>
		interface pointer for the first <o Component> in the <o Framework>'s list of
		registered Components.

@comm
	<p ppIFirstComponent> is set to NULL if the list is empty.

@rvalue S_OK | The first Component was returned in <p ppIFirstComponent>. 
@rvalue E_POINTER | The address in <p ppIFirstComponent> is not valid.  For example, it
		may be NULL.
@rvalue E_FAIL | An error occurred, and the first Component could not be returned.

@ex The following example calls <om IDMUSProdComponent::Initialize> for all Components
		registered with the Framework: |

BOOL CFramework::InitComponents( void )
{
	HRESULT hr;
	IDMUSProdComponent* pIComponent;
	IDMUSProdComponent* pINextComponent;
	BOOL fSuccess = FALSE;

	BSTR bstrErrMsg = NULL;

    hr = GetFirstComponent( &pINextComponent );

	while( SUCCEEDED( hr )  &&  pINextComponent )
    {
		pIComponent = pINextComponent;

		hr = pIComponent->Initialize( (IDMUSProdFramework *)this, &bstrErrMsg );
		if( SUCCEEDED( hr ) )
		{
			fSuccess = TRUE;
		}
		else
		{
			...		// Display error message
			...		// Free resources
		}

	    hr = GetNextComponent( pIComponent, &pINextComponent );
		pIComponent->Release();
    }

	return fSuccess;
}

@xref <i IDMUSProdComponent>, <i IDMUSProdFramework>, <om IDMUSProdFramework.FindComponent>, <om IDMUSProdFramework.GetNextComponent>
--------------------------------------------------------------------------------------*/

/////////////////////////////////////////////////////////////////////////////
// CFramework::GetFirstComponent

HRESULT CFramework::GetFirstComponent(
	IDMUSProdComponent** ppIFirstComponent	// @parm [out,retval] Address of a variable to receive the requested
										//		<i IDMUSProdComponent> interface.  If an error occurs, the 
										//		implementation sets <p ppIFirstComponent> to NULL.  On success, the
										//		caller is responsible for calling
										//		<om IDMUSProdComponent.Release>.
)
{
	AFX_MANAGE_STATE( AfxGetAppModuleState() );

	if( ppIFirstComponent == NULL )
	{
		return E_POINTER;
	}
	
	*ppIFirstComponent = NULL;

	if( !m_lstComponents.IsEmpty() )
	{
		CJzComponent* pJzComponent = static_cast<CJzComponent*>( m_lstComponents.GetHead() );
		
		if( pJzComponent )
		{
			pJzComponent->m_pIComponent->AddRef();
			*ppIFirstComponent = pJzComponent->m_pIComponent;
		}
	}

	return S_OK;
}


/*======================================================================================
METHOD:  IDMUSPRODFRAMEWORK::GETNEXTCOMPONENT
========================================================================================
@method HRESULT | IDMUSProdFramework | GetNextComponent | Returns an <i IDMUSProdComponent>
		interface pointer for the next <o Component> in the <o Framework>'s list of
		registered Components.

@comm
	Returns the Component located after <p pIComponent> in the Framework's list of
	registered Components.

	<p ppINextComponent> is set to NULL when the end of the list has been reached.

@rvalue S_OK | The next Component was returned in <p ppINextComponent>. 
@rvalue E_POINTER | The address in <p ppINextComponent> is not valid.  For example, it
		may be NULL.
@rvalue E_INVALIDARG | <p pIComponent> is not valid.  For example, it may be NULL.
@rvalue E_FAIL | An error occurred, and the next Component could not be returned.

@ex The following example calls <om IDMUSProdComponent::Initialize> for all Components
		registered with the Framework: |

BOOL CFramework::InitComponents( void )
{
	HRESULT hr;
	IDMUSProdComponent* pIComponent;
	IDMUSProdComponent* pINextComponent;
	BOOL fSuccess = FALSE;

	BSTR bstrErrMsg = NULL;

    hr = GetFirstComponent( &pINextComponent );

	while( SUCCEEDED( hr )  &&  pINextComponent )
    {
		pIComponent = pINextComponent;

		hr = pIComponent->Initialize( (IDMUSProdFramework *)this, &bstrErrMsg );
		if( SUCCEEDED( hr ) )
		{
			fSuccess = TRUE;
		}
		else
		{
			...		// Display error message
			...		// Free resources
		}

	    hr = GetNextComponent( pIComponent, &pINextComponent );
		pIComponent->Release();
    }

	return fSuccess;
}

@xref <i IDMUSProdComponent>, <i IDMUSProdFramework>, <om IDMUSProdFramework.GetFirstComponent>, <om IDMUSProdFramework.FindComponent>
--------------------------------------------------------------------------------------*/

/////////////////////////////////////////////////////////////////////////////
// CFramework::GetNextComponent

HRESULT CFramework::GetNextComponent(
	IDMUSProdComponent* pIComponent,		// @parm [in] A pointer to the previous Component in
											//		the Framework's list of registered Components.
	IDMUSProdComponent** ppINextComponent	// @parm [out,retval] Address of a variable to receive the
											//		requested <i IDMUSProdComponent>
											//		interface.  If an error occurs, the implementation
											//		sets <p ppINextComponent> to NULL.  On success, the
											//		caller is responsible for calling
											//		<om IDMUSProdComponent.Release>.
)
{
	AFX_MANAGE_STATE( AfxGetAppModuleState() );

	if( ppINextComponent == NULL )
	{
		return E_POINTER;
	}
	
	*ppINextComponent = NULL;

	if( pIComponent == NULL )
	{
		return E_INVALIDARG;
	}

	CJzComponent* pJzComponent;

    POSITION pos = m_lstComponents.GetHeadPosition();

    while( pos )
    {
        pJzComponent = m_lstComponents.GetNext( pos );
		if( pJzComponent->m_pIComponent == pIComponent )
		{
			if( pos )
			{
				pJzComponent = m_lstComponents.GetNext( pos );

				pJzComponent->m_pIComponent->AddRef();
				*ppINextComponent = pJzComponent->m_pIComponent;
			}
			break;
		}
    }

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CFramework::AddComponentDocTemplates

BOOL CFramework::AddComponentDocTemplates( void )
{
	IDMUSProdDocType* pIDocType;
	HINSTANCE hInstance;
	UINT nResourceId;

	POSITION pos = m_lstDocTypes.GetHeadPosition();

    while( pos )
    {
        pIDocType = m_lstDocTypes.GetNext( pos );

		if( FAILED ( pIDocType->GetResourceId(&hInstance, &nResourceId) )
		||  !(theApp.CreateDocTemplate( pIDocType, hInstance, nResourceId )) )
		{
			return FALSE;
		}
    }

	return TRUE;
}


/*======================================================================================
METHOD:  IDMUSPRODFRAMEWORK::ADDDOCTYPE
========================================================================================
@method HRESULT | IDMUSProdFramework | AddDocType | Registers a <o DocType> object with the
	<o Framework>.
 
@comm
	A Component's <om IDMUSProdComponent.Initialize> method can call <om IDMUSProdFramework.AddDocType>
	to include additional document types in the Framework's File New, File Open and
	File Save dialogs.

	<om IDMUSProdFramework.AddDocType> must receive a successful return from
	<om IDMUSProdDocType.GetResourceId> in order to complete successfully.

@rvalue S_OK | <p pIDocType> was registered successfully. 
@rvalue E_INVALIDARG | <p pIDocType> is not valid.  For example, it may be NULL.
@rvalue E_FAIL | <p pIDocType> could not be registered. 

@ex The following excerpt from an <om IDMUSProdComponent.Initialize> method registers
	an additional document type with the Framework: |

	IDMUSProdDocType* pIDocType;
	IDMUSProdFramework* pIFramework;

	pIDocType = new CStyleDocType( this );
    if( pIDocType == NULL )
    {
		CleanUp();
		::LoadString( theApp.m_hInstance, IDS_ERR_MEMORY, achErrMsg, MID_BUFFER );
		strErrMsg = achErrMsg;
		*pbstrErrMsg = strErrMsg.AllocSysString();
        return E_OUTOFMEMORY;
    }

	pIDocType->AddRef();

	if( FAILED ( pIFramework->AddDocType(pIDocType) ) )
	{
		CleanUp();
		::LoadString( theApp.m_hInstance, IDS_ERR_ADD_DOCTYPE, achErrMsg, MID_BUFFER );
		strErrMsg = achErrMsg;
		*pbstrErrMsg = strErrMsg.AllocSysString();
		return E_FAIL;
	}
	
@xref <o DocType> Object, <i IDMUSProdDocType>, <i IDMUSProdFramework>, <om IDMUSProdFramework.FindDocTypeByNodeId>, <om IDMUSProdFramework.FindDocTypeByExtension>, <om IDMUSProdFramework.GetFirstDocType>, <om IDMUSProdFramework.GetNextDocType>
--------------------------------------------------------------------------------------*/

/////////////////////////////////////////////////////////////////////////////
// CFramework::AddDocType

HRESULT CFramework::AddDocType(
	IDMUSProdDocType* pIDocType		// @parm [in] Pointer to the <i IDMUSProdDocType> interface
								//		being registered.
)
{
	AFX_MANAGE_STATE( AfxGetAppModuleState() );

	CString strFilter;
	CString strListFilter;
	IDMUSProdDocType* pIListDocType;
	HINSTANCE hInstance;
	UINT nResourceId;
	POSITION posLast;
	TCHAR achFullText[MAX_BUFFER];

	if( pIDocType == NULL )
	{
		return E_INVALIDARG;
	}

	// Get the HINSTANCE and resource ID for the new DocType
	HRESULT hr = pIDocType->GetResourceId( &hInstance, &nResourceId );
	if( FAILED ( hr ) )
	{
		return hr;
	}

	// Get the filter string for the new DocType
	::LoadString( hInstance, nResourceId, achFullText, MAX_BUFFER );
	AfxExtractSubString( strFilter, achFullText, CDocTemplate::filterName, '\n' );

	// Place the new DocType in list - sort by filter string
	POSITION pos = m_lstDocTypes.GetHeadPosition();
    while( pos )
    {
		posLast = pos;
        pIListDocType = m_lstDocTypes.GetNext( pos );

		if( SUCCEEDED ( pIListDocType->GetResourceId( &hInstance, &nResourceId ) ) )
		{
			::LoadString( hInstance, nResourceId, achFullText, MAX_BUFFER );
			AfxExtractSubString( strListFilter, achFullText, CDocTemplate::filterName, '\n' );

			if( strFilter.CompareNoCase( strListFilter ) < 0 )
			{
				pIDocType->AddRef();
				m_lstDocTypes.InsertBefore( posLast, pIDocType );
				return S_OK;
			}
		}
    }

	pIDocType->AddRef();
	m_lstDocTypes.AddTail( pIDocType );
	return S_OK;
}


/*======================================================================================
METHOD:  IDMUSPRODFRAMEWORK::FINDDOCTYPEBYEXTENSION
========================================================================================
@method HRESULT | IDMUSProdFramework | FindDocTypeByExtension | Returns a pointer to the
		<i IDMUSProdDocType> interface associated with file extension <p bstrExt>. 

@comm
	A Component's <om IDMUSProdComponent.Initialize> method can call <om IDMUSProdFramework.AddDocType>
	to include additional document types in the Framework's File New, File Open and
	File Save dialogs.

	<om IDMUSProdFramework.FindDocTypeByExtension> enumerates the <i IDMUSProdDocType> interfaces
	registered through <om IDMUSProdFramework.AddDocType> and calls
	<om IDMUSProdDocType.DoesExtensionMatch> to find the <i IDMUSProdDocType> interface whose
	file extension matches <p bstrExt>.

@rvalue S_OK | The specified file extension's <i IDMUSProdDocType> was returned in <p ppIDocType>.
@rvalue E_POINTER | The address in <p ppIDocType> is not valid.  For example, it may be NULL.
@rvalue E_FAIL | A matching <i IDMUSProdDocType> interface was not found.

@ex The following example searches for the <i IDMUSProdDocType> interface that manages
	Jazz Style files (*.sty): |

	IDMUSProdFramework* pIFramework;
	IDMUSProdDocType* pIDocType;
	CString strExt;
	BSTR bstrExt;

	strExt = ".sty";
	bstrExt = strExt.AllocSysString();
	if( SUCCEEDED ( pIFramework->FindDocTypeByExtension( bstrExt, &pIDocType ) ) )
	{
		pIDocType->Release();
	}
	
@xref <i IDMUSProdDocType>, <om IDMUSProdDocType.DoesExtensionMatch><i IDMUSProdFramework>, <om IDMUSProdFramework.AddDocType>, <om IDMUSProdFramework.FindDocTypeByNodeId>, <om IDMUSProdFramework.GetFirstDocType>, <om IDMUSProdFramework.GetNextDocType>
--------------------------------------------------------------------------------------*/

/////////////////////////////////////////////////////////////////////////////
// CFramework::FindDocTypeByExtension

HRESULT CFramework::FindDocTypeByExtension(
	BSTR bstrExt,					// @parm [in] File extension.  This method frees
									//		<p bstrExt> with SysFreeString when it is no
									//		longer needed.
	IDMUSProdDocType** ppIDocType	// 	@parm [out,retval] Address of a variable to receive the requested  
									//		<i IDMUSProdDocType> interface.  If an error occurs,
									//		the implementation sets <p ppIDocType> to NULL.
									//		On success, the caller is responsible for calling
									//		<om IDMUSProdDocType.Release>.
)
{
	AFX_MANAGE_STATE( AfxGetAppModuleState() );

	HRESULT hr;
	IDMUSProdDocType* pIDocType;
	IDMUSProdDocType* pINextDocType;
	BSTR bstrTheExt;

	CString strExt = bstrExt;
	::SysFreeString( bstrExt );

	if( ppIDocType == NULL )
	{
		return E_POINTER;
	}

	*ppIDocType = NULL;

    hr = GetFirstDocType( &pINextDocType );

	while( SUCCEEDED( hr )  &&  pINextDocType )
    {
		pIDocType = pINextDocType;

		bstrTheExt = strExt.AllocSysString();
		if( pIDocType->DoesExtensionMatch( bstrTheExt ) == S_OK )
		{
			*ppIDocType = pIDocType;
			break;
		}

	    hr = GetNextDocType( pIDocType, &pINextDocType );
		pIDocType->Release();
	}

	if( *ppIDocType )
	{
		return S_OK;
	}
	
	return E_FAIL;
}


/*======================================================================================
METHOD:  IDMUSPRODFRAMEWORK::FINDDOCTYPEBYNODEID
========================================================================================
@method HRESULT | IDMUSProdFramework | FindDocTypeByNodeId | Returns a pointer to the
		<i IDMUSProdDocType> interface associated with node ID <p rguid>. 

@comm
	A GUID identifies a type of Node.  For example, all Style Nodes have the same
	GUID, or node ID.  

	A Component's <om IDMUSProdComponent.Initialize> method can call <om IDMUSProdFramework.AddDocType>
	to include additional document types in the Framework's File New, File Open and
	File Save dialogs.

	<om IDMUSProdFramework.FindDocTypeByNodeId> enumerates the <i IDMUSProdDocType> interfaces
	registered through <om IDMUSProdFramework.AddDocType> and calls
	<om IDMUSProdDocType.DoesIdMatch> to find the <i IDMUSProdDocType> interface associated with
	the node ID specified in <p rguid>.

@rvalue S_OK | The specified id's <i IDMUSProdDocType> was returned in <p ppIDocType>.
@rvalue E_POINTER | The address in <p ppIDocType> is not valid.  For example, it may be NULL.
@rvalue E_FAIL | A matching <i IDMUSProdDocType> interface was not found.

@ex See <om IDMUSProdDocType.DoesIdMatch> for sample code. |
	
@xref <i IDMUSProdDocType>, <om IDMUSProdDocType.DoesIdMatch>, <i IDMUSProdFramework>, <om IDMUSProdFramework.AddDocType>, <om IDMUSProdFramework.FindDocTypeByExtension>, <om IDMUSProdFramework.GetFirstDocType>, <om IDMUSProdFramework.GetNextDocType>
--------------------------------------------------------------------------------------*/

/////////////////////////////////////////////////////////////////////////////
// CFramework::FindDocTypeByNodeId

HRESULT CFramework::FindDocTypeByNodeId(
	REFGUID rguid,					// @parm [in] Node ID.
	IDMUSProdDocType** ppIDocType	// @parm [out,retval] Address of a variable to receive the requested 
									//		<i IDMUSProdDocType> interface.  If an error occurs, the implementation
									//		sets <p ppIDocType> to NULL.  On success, the caller
									//		is responsible for calling <om IDMUSProdDocType.Release>.
)
{
	AFX_MANAGE_STATE( AfxGetAppModuleState() );

	HRESULT hr;
	IDMUSProdDocType* pIDocType;
	IDMUSProdDocType* pINextDocType;

	if( ppIDocType == NULL )
	{
		return E_POINTER;
	}

	*ppIDocType = NULL;

    hr = GetFirstDocType( &pINextDocType );

	while( SUCCEEDED( hr )  &&  pINextDocType )
    {
		pIDocType = pINextDocType;

		if( pIDocType->DoesIdMatch( rguid ) == S_OK )
		{
			*ppIDocType = pIDocType;
			break;
		}

	    hr = GetNextDocType( pIDocType, &pINextDocType );
		pIDocType->Release();
	}

	if( *ppIDocType )
	{
		return S_OK;
	}
	
	return E_FAIL;
}


/*======================================================================================
METHOD:  IDMUSPRODFRAMEWORK::GETFIRSTDOCTYPE
========================================================================================
@method HRESULT | IDMUSProdFramework | GetFirstDocType | Returns an <i IDMUSProdDocType>
		interface pointer for the first <o DocType> in the <o Framework>'s list of
		registered DocTypes.

@comm
	<p ppIFirstDocType> is set to NULL if the list is empty.

@rvalue S_OK | The first DocType was returned in <p ppIFirstDocType>. 
@rvalue E_POINTER | The address in <p ppIFirstDocType> is not valid.  For example, it may
		be NULL.
@rvalue E_FAIL | An error occurred, and the first DocType could not be returned.

@ex The following example returns a pointer to the <i IDMUSProdDocType> interface associated
	with file extension <p bstrExt>: |

HRESULT CFramework::FindDocTypeByExtension( BSTR bstrExt, IDMUSProdDocType** ppIDocType	)
{
	AFX_MANAGE_STATE( AfxGetAppModuleState() );

	HRESULT hr;
	IDMUSProdDocType* pIDocType;
	IDMUSProdDocType* pINextDocType;

	if( ppIDocType == NULL )
	{
		return E_POINTER;
	}

	*ppIDocType = NULL;

    hr = GetFirstDocType( &pINextDocType );

	while( SUCCEEDED( hr )  &&  pINextDocType )
    {
		pIDocType = pINextDocType;

		if( pIDocType->DoesExtensionMatch( bstrExt ) == S_OK )
		{
			*ppIDocType = pIDocType;
			break;
		}

	    hr = GetNextDocType( pIDocType, &pINextDocType );
		pIDocType->Release();
	}

	if( *ppIDocType )
	{
		return S_OK;
	}
	
	return E_FAIL;
}

@xref <i IDMUSProdDocType>, <om IDMUSProdDocType.DoesIdMatch>, <i IDMUSProdFramework>, <om IDMUSProdFramework.AddDocType>, <om IDMUSProdFramework.FindDocTypeByExtension>, <om IDMUSProdFramework.GetNextDocType>
--------------------------------------------------------------------------------------*/

/////////////////////////////////////////////////////////////////////////////
// CFramework::GetFirstDocType

HRESULT CFramework::GetFirstDocType(
	IDMUSProdDocType** ppIFirstDocType	// @parm [out,retval] Address of a variable to receive the requested 
									//		<i IDMUSProdDocType> interface.  If an error occurs, the implementation
									//		sets <p ppIFirstDocType> to NULL.  On success, the
									//		caller is responsible for calling
									//		<om IDMUSProdDocType.Release>.
)
{
	AFX_MANAGE_STATE( AfxGetAppModuleState() );

	if( ppIFirstDocType == NULL )
	{
		return E_POINTER;
	}
	
	*ppIFirstDocType = NULL;

	if( !m_lstDocTypes.IsEmpty() )
	{
		IDMUSProdDocType* pIDocType = static_cast<IDMUSProdDocType*>( m_lstDocTypes.GetHead() );
		
		if( pIDocType )
		{
			pIDocType->AddRef();
			*ppIFirstDocType = pIDocType;
		}
	}

	return S_OK;
}


/*======================================================================================
METHOD:  IDMUSPRODFRAMEWORK::GETNEXTDOCTYPE
========================================================================================
@method HRESULT | IDMUSProdFramework | GetNextDocType | Returns an <i IDMUSProdDocType>
		interface pointer for the next <o DocType> in the <o Framework>'s list of
		registered DocTypes.

@comm
	Returns the DocType located after <p pIDocType> in the Framework's list of
	registered DocTypes.

	<p ppINextDocType> is set to NULL when the end of the list has been reached.

@rvalue S_OK | The next DocType was returned in <p ppINextDocType>. 
@rvalue E_POINTER | The address in <p ppINextDocType> is not valid.  For example, it may
		be NULL.
@rvalue E_INVALIDARG | <p pIDocType> is not valid.  For example, it may be NULL.
@rvalue E_FAIL | An error occurred, and the next DocType could not be returned.

@ex The following example returns a pointer to the <i IDMUSProdDocType> interface associated
	with file extension <p bstrExt>: |

HRESULT CFramework::FindDocTypeByExtension( BSTR bstrExt, IDMUSProdDocType** ppIDocType	)
{
	AFX_MANAGE_STATE( AfxGetAppModuleState() );

	HRESULT hr;
	IDMUSProdDocType* pIDocType;
	IDMUSProdDocType* pINextDocType;

	if( ppIDocType == NULL )
	{
		return E_POINTER;
	}

	*ppIDocType = NULL;

    hr = GetFirstDocType( &pINextDocType );

	while( SUCCEEDED( hr )  &&  pINextDocType )
    {
		pIDocType = pINextDocType;

		if( pIDocType->DoesExtensionMatch( bstrExt ) == S_OK )
		{
			*ppIDocType = pIDocType;
			break;
		}

	    hr = GetNextDocType( pIDocType, &pINextDocType );
		pIDocType->Release();
	}

	if( *ppIDocType )
	{
		return S_OK;
	}
	
	return E_FAIL;
}

@xref <i IDMUSProdDocType>, <om IDMUSProdDocType.DoesIdMatch>, <i IDMUSProdFramework>, <om IDMUSProdFramework.AddDocType>, <om IDMUSProdFramework.FindDocTypeByExtension>, <om IDMUSProdFramework.GetFirstDocType>
--------------------------------------------------------------------------------------*/

/////////////////////////////////////////////////////////////////////////////
// CFramework::GetNextDocType

HRESULT CFramework::GetNextDocType(
	IDMUSProdDocType* pIDocType,		// @parm [in] A pointer to the previous DocType in
										//		the Framework's list of registered DocTypes.
	IDMUSProdDocType** ppINextDocType	// @parm [out,retval] Address of a variable to receive the requested  
										//		<i IDMUSProdDocType> interface.  If an error occurs, the implementation
										//		sets <p ppINextDocType> to NULL.  On success, the
										//		caller is responsible for calling
										//		<om IDMUSProdDocType.Release>.
)
{
	AFX_MANAGE_STATE( AfxGetAppModuleState() );

	if( ppINextDocType == NULL )
	{
		return E_POINTER;
	}
	
	*ppINextDocType = NULL;

	if( pIDocType == NULL )
	{
		return E_INVALIDARG;
	}

	IDMUSProdDocType* pIListDocType;

    POSITION pos = m_lstDocTypes.GetHeadPosition();

    while( pos )
    {
        pIListDocType = m_lstDocTypes.GetNext( pos );
		if( pIListDocType == pIDocType )
		{
			if( pos )
			{
				pIListDocType = m_lstDocTypes.GetNext( pos );

				pIListDocType->AddRef();
				*ppINextDocType = pIListDocType;
			}
			break;
		}
    }

	return S_OK;
}


/*======================================================================================
METHOD:  IDMUSPRODFRAMEWORK::CREATENEWFILE
========================================================================================
@method HRESULT | IDMUSProdFramework | CreateNewFile | Invokes the <o Framework>'s File New
	command and returns a new file of the type described through <p pIDocType>.

@comm
	This method provides the means for a Component to initiate a File New command.  

	Part of the Framework's File New processing uses <p pIDocType> to call
	<om IDMUSProdDocType.OnFileNew>.

@rvalue S_OK | The newly created file's top <i IDMUSProdNode> was returned in <p ppIDocRootNode>. 
@rvalue E_POINTER | The address in <p ppIDocRootNode> is not valid.  For example, it may
		be NULL.
@rvalue E_INVALIDARG | Either <p pIDocType> or <p pITreePositionNode> is not valid.
		For example, they may be NULL.
@rvalue E_FAIL | A new file could not be created. 

@ex The following example creates a new Style file and places it in the Project Tree in the
	same directory as <p pISegmentDocRootNode>: |

	IDMUSProdDocType* pIDocType;
	IDMUSProdNode* pIDocRootNode;

	if( SUCCEEDED ( m_pIFramework->FindDocTypeByNodeId( GUID_StyleNode, &pIDocType ) ) )
	{
		if( SUCCEEDED ( m_pIFramework->CreateNewFile( pIDocType, pISegmentDocRootNode, &pIDocRootNode ) ) )
		{
			pIDocRootNode->Release();
		}

		pIDocType->Release();
	}
	
@xref <i IDMUSProdDocType>, <i IDMUSProdFramework>, <om IDMUSProdFramework.OpenFile>
--------------------------------------------------------------------------------------*/

/////////////////////////////////////////////////////////////////////////////
// CFramework::CreateNewFile

HRESULT CFramework::CreateNewFile(
	IDMUSProdDocType* pIDocType,		// @parm [in] Pointer to the <i IDMUSProdDocType> interface which
										//		is used to determine the kind of file to create.
	IDMUSProdNode* pITreePositionNode,	// @parm [in] Pointer to the <o Node> used to determine where
										//		the newly created file should be placed in the Project
										//		Tree.
	IDMUSProdNode** ppIDocRootNode		// @parm [out,retval] Address of a variable to receive the requested  
										//		<i IDMUSProdNode> interface.  If an error occurs, the implementation
										//		sets <p ppIDocRootNode> to NULL.  On success, the caller
										//		is responsible for calling <om IDMUSProdNode.Release> when
										//		this pointer is no longer needed.
)
{
	AFX_MANAGE_STATE( AfxGetAppModuleState() );

	if( ppIDocRootNode == NULL )
	{
		return E_POINTER;
	}

	*ppIDocRootNode = NULL;

	if( pIDocType == NULL
	||  pITreePositionNode == NULL )
	{
		return E_INVALIDARG;
	}

	// Find the DocType's CJazzDocTemplate*
	CJazzDocTemplate* pDocTemplate = theApp.FindDocTemplate( pIDocType );
	if( pDocTemplate )
	{
		// Set Project Tree position
		theApp.SetProjectTreePosition( pITreePositionNode );

		// Create the file
		theApp.m_nFileTarget = TGT_SELECTEDNODE;
		CComponentDoc* pComponentDoc = (CComponentDoc *)pDocTemplate->OpenDocumentFile( NULL );
		theApp.m_nFileTarget = TGT_PROJECT;

		if( pComponentDoc )
		{
			if( pComponentDoc->m_pIDocRootNode )
			{
				pComponentDoc->m_pIDocRootNode->AddRef();
				*ppIDocRootNode = pComponentDoc->m_pIDocRootNode;
				return S_OK;
			}
		}
	}

	return E_FAIL;
}


/*======================================================================================
METHOD:  IDMUSPRODFRAMEWORK::OPENFILE
========================================================================================
@method HRESULT | IDMUSProdFramework | OpenFile | Invokes the <o Framework>'s File Open
	command and returns a file of the type described through <p pIDocType>.

@comm
	This method provides the means for a Component to initiate a File Open command.  

	The title of the File Open dialog is set to 'Open' when <p bstrTitle> is NULL.

	Part of the Framework's File Open processing uses <p pIDocType> to call
	<om IDMUSProdDocType.OnFileOpen>.

@rvalue S_OK | The file's top <i IDMUSProdNode> was returned in <p ppIDocRootNode>. 
@rvalue E_POINTER | The address in <p ppIDocRootNode> is not valid.  For example, it may
		be NULL.
@rvalue E_INVALIDARG | Either <p pIDocType> or <p pITreePositionNode> is not valid.
		For example, they may be NULL.
@rvalue E_FAIL | The file could not be opened. 

@ex The following example loads a Style file and places it in the Project Tree in the
	same directory as <p pISegmentDocRootNode>: |

	IDMUSProdDocType* pIDocType;
	IDMUSProdNode* pIDocRootNode;

	if( SUCCEEDED ( m_pIFramework->FindDocTypeByNodeId( GUID_StyleNode, &pIDocType ) ) )
	{
		if( SUCCEEDED ( m_pIFramework->OpenFile( pIDocType, NULL, pISegmentDocRootNode, &pIDocRootNode ) ) )
		{
			pIDocRootNode->Release();
		}

		pIDocType->Release();
	}
	
@xref <i IDMUSProdDocType>, <i IDMUSProdFramework>, <om IDMUSProdFramework.CreateNewFile>
--------------------------------------------------------------------------------------*/

/////////////////////////////////////////////////////////////////////////////
// CFramework::OpenFile

HRESULT CFramework::OpenFile(
	IDMUSProdDocType* pIDocType,	// @parm [in] Pointer to the <i IDMUSProdDocType> interface which
									//		is used to determine the kind of file to open.
	BSTR bstrTitle,					// @parm [in] Title used for the File Open dialog.  This method
									//		frees <p bstrTitle> with SysFreeString when it is no
									//		longer needed.
	IDMUSProdNode* pITreePositionNode,	// @parm [in] Pointer to the <o Node> used to determine where
									//		the newly created file should be placed in the Project
									//		Tree.
	IDMUSProdNode** ppIDocRootNode	// @parm [out,retval] Address of a variable to receive the requested  
									//		<i IDMUSProdNode> interface.  If an error occurs, the implementation
									//		sets <p ppIDocRootNode> to NULL.  On success, the caller
									//		is responsible for calling <om IDMUSProdNode.Release> when
									//		this pointer is no longer needed.
)
{
	AFX_MANAGE_STATE( AfxGetAppModuleState() );

	if( ppIDocRootNode == NULL )
	{
		return E_POINTER;
	}

	*ppIDocRootNode = NULL;

	if( pIDocType == NULL
	||  pITreePositionNode == NULL )
	{
		return E_INVALIDARG;
	}

	// Find the DocType's CJazzDocTemplate*
	CJazzDocTemplate* pTemplate = theApp.FindDocTemplate( pIDocType );
	if( pTemplate )
	{
		CString strFileName;

		// Prompt user for filename
		BOOL fHaveFileName = FALSE;
		while( fHaveFileName == FALSE )
		{
			CString strTitle;
			LPCTSTR szTitle = NULL;

			if( bstrTitle )
			{
				strTitle = bstrTitle;
				::SysFreeString( bstrTitle );
				szTitle = strTitle;
			}

			strFileName.Empty();
			if( theApp.DoPromptFileOpenSingle(strFileName, pTemplate, szTitle) )
			{
				// Make sure the user is not trying to open a Project file
				if( theApp.IsValidProjectFile( strFileName, FALSE ) == TRUE )
				{
					CString strMsg;

					HINSTANCE hInstance = AfxGetResourceHandle();
					AfxSetResourceHandle( theApp.m_hInstance );

					AfxFormatString1( strMsg, IDS_ERR_IS_PROJECT_FILE, strFileName );
					AfxMessageBox( strMsg );

					AfxSetResourceHandle( hInstance );
				}
				else
				{
					fHaveFileName = TRUE;
				}
			}
			else
			{
				return S_FALSE;
			}
		}

		// Set Project Tree position
		theApp.SetProjectTreePosition( pITreePositionNode );

		// Open the file
		CComponentDoc* pComponentDoc = (CComponentDoc *)theApp.OpenTheFile( strFileName, TGT_SELECTEDNODE );
		if( pComponentDoc )
		{
			if( pComponentDoc->m_pIDocRootNode )
			{
				// Make sure user opened the type of file that was expected
				if( pComponentDoc->m_pIDocType == pIDocType )
				{
					pComponentDoc->m_pIDocRootNode->AddRef();
					*ppIDocRootNode = pComponentDoc->m_pIDocRootNode;
					return S_OK;
				}
				else
				{
					CString strMsg;
					CString strFilterName;

					HINSTANCE hInstance = AfxGetResourceHandle();
					AfxSetResourceHandle( theApp.m_hInstance );

					pTemplate->GetDocString( strFilterName, CDocTemplate::docName );
					AfxFormatString2( strMsg, IDS_ERR_WRONG_FILE, strFileName, strFilterName );
					AfxMessageBox( strMsg );
	
					AfxSetResourceHandle( hInstance );
					return S_FALSE;
				}
			}
		}
	}

	return E_FAIL;
}


/*======================================================================================
METHOD:  IDMUSPRODFRAMEWORK::COPYFILE
========================================================================================
@method HRESULT | IDMUSProdFramework | CopyFile | Returns a copy of the file specified in
	<p pIDocRootNode>. 

@comm
	<p pIDocRootNode> must point to a DocRoot <o Node>.  A DocRoot node is the top node of
	a document, or file.  For example, the Style node of a Style file would be considered
	the DocRoot node of the Style.  The Band node of a Band file would be considered the
	DocRoot node of the Band file.

	This method saves the file specified in <p pIDocRootNode> using a name built from
	appending the filename of <p pIDocRootNode> to the path of <p pITreePositionNode>.  
	After the file has been successfully saved, <om IDMUSProdDocType.OnFileOpen> loads the
	new file and places its nodes into the Project Tree.  The DocRoot node of the newly
	created file is returned in <p ppINewDocRootNode>.

	if <p pIDocRootNode> does not already exist in the Project Tree, the filename of
	<p ppINewDocRootNode> will be derived by appending the the node name of <p pIDocRootNode>
	to the path of <p pITreePositionNode>.

@rvalue S_OK | A copy of the file specified in <p pIDocRootNode> was returned in
		<p ppINewDocRootNode>.
@rvalue E_POINTER | The address in <p ppINewDocRootNode> is not valid.  For example, it
		may be NULL.
@rvalue E_INVALIDARG | The value of either <p pIDocRootNode> or <p pITreePositionNode> is
		not valid.  For example, it may be NULL.
@rvalue E_FAIL | An error occurred, and the file could not be copied.

@ex The following example makes sure that a referenced file exists in the same Project as the
	file it references.  m_pIStyleRefNode contains an IDMUSProdNode interface pointer to the node
	used to display a referenced Style file:|

	IDMUSProdReferenceNode* pIReferenceNode;

	if( SUCCEEDED ( m_pIStyleRefNode->QueryInterface( IID_IDMUSProdReferenceNode, (void **)&pIReferenceNode ) ) )
	{
		IDMUSProdNode* pIStyleDocRootNode;

		if( SUCCEEDED ( pIReferenceNode->GetReferencedFile( &pIStyleDocRootNode ) ) )
		{
			if( pIFramework->IsProjectEqual( this, pIStyleDocRootNode ) == S_FALSE )
			{
				IDMUSProdNode* pINewDocRootNode;

				if( SUCCEEDED ( pIFramework->CopyFile( pIStyleDocRootNode, this, &pINewDocRootNode ) ) )
				{
					pIReferenceNode->SetReferencedFile( pINewDocRootNode );
					pINewDocRootNode->Release();
				}
			}

			pIStyleDocRootNode->Release();
		}

		pIReferenceNode->Release();
	}

@xref <i IDMUSProdFramework>, <om IDMUSProdFramework.IsProjectEqual>
--------------------------------------------------------------------------------------*/

/////////////////////////////////////////////////////////////////////////////
// CFramework::CopyFile

HRESULT CFramework::CopyFile(
	IDMUSProdNode* pIDocRootNode,	// @parm [in] Pointer to an <i IDMUSProdNode> interface which
									//		specifies the file to be copied.
	IDMUSProdNode* pITreePositionNode,	// @parm [in] Pointer to the Node used to determine where
									//		the newly created file should be placed in the Project
									//		Tree.
	IDMUSProdNode** ppINewDocRootNode	// @parm [out,retval] Address of a variable to receive the requested  
									//		IDMUSProdNode interface.  If an error occurs, the implementation
									//		sets <p ppINewDocRootNode> to NULL.  On success, the
									//		caller is responsible for calling <om IDMUSProdNode.Release>
									//		when this pointer is no longer needed.
)
{
	AFX_MANAGE_STATE( AfxGetAppModuleState() );

	if( ppINewDocRootNode == NULL )
	{
		return E_POINTER;
	}

	*ppINewDocRootNode = NULL;

	if( pITreePositionNode == NULL
	||  pIDocRootNode == NULL )
	{
		return E_INVALIDARG;
	}

	// Make sure pIDocRootNode really is a DocRootNode
	IDMUSProdNode* pINode;

	if( FAILED ( pIDocRootNode->GetDocRootNode( &pINode ) ) )
	{
		return E_FAIL;
	}
	ASSERT( pIDocRootNode == pINode );
	if( pINode == NULL )
	{
		return E_FAIL;
	}
	if( pIDocRootNode != pINode )
	{
		pINode->Release();
		return E_INVALIDARG;
	}
	pINode->Release();

	CString strNewFileName;

	// Get the pComponentDoc associated with pIDocRootNode
	CComponentDoc* pComponentDoc = theApp.FindComponentDocument( pIDocRootNode );
	if( pComponentDoc )
	{
		// Get the filename of pComponentDoc
		CString strFileName = pComponentDoc->GetPathName();

		// Determine the new filename
		BSTR bstrNewFileName;
		int nFindPos;

		if( FAILED ( GetNodeFileName( pITreePositionNode, &bstrNewFileName ) ) )
		{
			return E_FAIL;
		}
		strNewFileName = bstrNewFileName;
		::SysFreeString( bstrNewFileName );
		nFindPos = strNewFileName.ReverseFind( (TCHAR)'\\' );
		if( nFindPos == -1 )
		{
			return E_FAIL;
		}
		strNewFileName = strNewFileName.Left( nFindPos + 1 );
		nFindPos = strFileName.ReverseFind( (TCHAR)'\\' );
		if( nFindPos == -1 )
		{
			return E_FAIL;
		}
		strNewFileName += strFileName.Right( strFileName.GetLength() - nFindPos - 1 );

		// Save the new file
		if( pComponentDoc->DoSave( strNewFileName, FALSE ) == FALSE )
		{
			return E_FAIL;
		}
	}
	else
	{
		// Get path associated with pITreePositionNode
		GUID guidNodeId;
		CString strTargetPath;

		if( SUCCEEDED ( pITreePositionNode->GetNodeId( &guidNodeId ) ) )
		{
			if( ::IsEqualGUID(guidNodeId, GUID_ProjectFolderNode) == FALSE
			&&  ::IsEqualGUID(guidNodeId, GUID_DirectoryNode) == FALSE )
			{
				return E_FAIL;
			}

			CDirectoryNode* pDirNode = (CDirectoryNode *)pITreePositionNode;		
			pDirNode->ConstructPath( strTargetPath );
		}

		// Get guidNodeId of pIDocRootNode
		if( FAILED ( pIDocRootNode->GetNodeId( &guidNodeId ) ) )
		{
			return E_FAIL;
		}

		// Determine the new filename
		IDMUSProdDocType* pIDocType;
		if( SUCCEEDED ( FindDocTypeByNodeId( guidNodeId, &pIDocType ) ) )
		{
			IDMUSProdDocType8* pIDocType8;
			if( SUCCEEDED ( pIDocType->QueryInterface( IID_IDMUSProdDocType8, (void**)&pIDocType8 ) ) )
			{
				BSTR bstrExt;
				if( SUCCEEDED ( pIDocType8->GetObjectExt( guidNodeId, FT_DESIGN, &bstrExt ) ) )
				{
					CString strExt = bstrExt;
					::SysFreeString( bstrExt );

					BSTR bstrName;
					if( SUCCEEDED ( pIDocRootNode->GetNodeName( &bstrName ) ) )
					{
						CString strName = bstrName;
						::SysFreeString( bstrName );

						// Determine proposed filename
						CString strProposedFileName = strTargetPath + strName + strExt;
						
						// Make sure we have a unique filename
						CString strFName;

						theApp.GetUniqueFileName( strProposedFileName, strFName );
						strNewFileName = strTargetPath + strFName;
					}
				}

				pIDocType8->Release();
			}

			pIDocType->Release();
		}

		HRESULT hr = E_FAIL;

		// Save the file
		IStream* pIStream;
	    if( SUCCEEDED ( ::AllocFileStream(strNewFileName, GENERIC_WRITE, FT_DESIGN, GUID_CurrentVersion, pITreePositionNode, &pIStream) ) )
		{
			IPersistStream* pIPersistStream;

			if( SUCCEEDED ( pIDocRootNode->QueryInterface( IID_IPersistStream, (void**)&pIPersistStream ) ) )
			{
				if( SUCCEEDED ( pIPersistStream->Save( pIStream, FALSE ) ) )
				{
					hr = S_OK;
				}

				pIPersistStream->Release();
			}

			pIStream->Release();
		}

		if( FAILED ( hr ) )
		{
			return hr;
		}
	}

	// Set Project Tree position
	theApp.SetProjectTreePosition( pITreePositionNode );

	// Open the newly created file
	CComponentDoc* pNewComponentDoc = (CComponentDoc *)theApp.OpenTheFile( strNewFileName, TGT_SELECTEDNODE );
	if( pNewComponentDoc )
	{
		// Ensure the file node has a runtime file name
		if( pNewComponentDoc->m_pFileNode )
		{
			// Force SetNodeName to handle setting of FileNode node name
			BSTR bstrName = pNewComponentDoc->m_pFileNode->m_strName.AllocSysString();
			pNewComponentDoc->m_pFileNode->m_strName.Empty();
			pNewComponentDoc->m_pFileNode->SetNodeName( bstrName );
		}

		if( pNewComponentDoc->m_pIDocRootNode )
		{
			pNewComponentDoc->m_pIDocRootNode->AddRef();
			*ppINewDocRootNode = pNewComponentDoc->m_pIDocRootNode;
			return S_OK;
		}
	}

	return E_FAIL;
}


/*======================================================================================
METHOD:  IDMUSPRODFRAMEWORK::SHOWFILE
========================================================================================
@method HRESULT | IDMUSProdFramework | ShowFile | Displays a newly created file in the
	Project Tree.

@comm
	There may be times when a <o Component> creates a new file.  For example, a MIDI export
	feature would generate a new MIDI file.  <om IDMUSProdFramework::ShowFile> provides the
	means for a Component to display a newly created file in an open <o Project> in the
	Project Tree.

	<p bstrFileName> must point to the complete path/filename of an existing file.

	This method neither creates nor opens Projects.  It returns E_FAIL if the Project Tree
	does not already contain a Project folder in which to place <p bstrFileName>.  Sub-folders,
	however, will be created when necessary.

@rvalue S_OK | The file specified in <p bstrFileName> was added to the Project Tree.
@rvalue E_INVALIDARG | The value of <p bstrFileName> is not valid.  For example, it may be NULL.
@rvalue E_FAIL | An error occurred, and the file could not be displayed in the Project Tree.

@xref <i IDMUSProdFramework>
--------------------------------------------------------------------------------------*/

/////////////////////////////////////////////////////////////////////////////
// CFramework::ShowFile

HRESULT CFramework::ShowFile(
	BSTR bstrFileName				// @parm [in] Complete path and filename of the file to 
									//		be added to the Project Tree.  This method frees
									//		<p bstrFileName> with SysFreeString when it is
									//		no longer needed.
)
{
	AFX_MANAGE_STATE( AfxGetAppModuleState() );

	if( bstrFileName == NULL )
	{
		return E_INVALIDARG;
	}

	CString strFileName = bstrFileName;
	::SysFreeString( bstrFileName );

	// See if file already exists in Project tree
	CFileNode* pFileNode = theApp.FindFileNode( strFileName );
	if( pFileNode )
	{
		// Already exists in Project Tree, nothing to do so just exit
		return S_OK;
	}

	// Make sure file exists on hard drive
	DWORD dwAttributes = ::GetFileAttributes( strFileName );
	if( dwAttributes == 0xFFFFFFFF )
	{
		// File does not exist
		return E_FAIL;
	}

	// Make sure strFileName is not a directory
	if( dwAttributes & FILE_ATTRIBUTE_DIRECTORY )
	{
		// strFileName is a directory
		return E_FAIL;
	}

	HRESULT hr = E_FAIL;

	// See if the file resides in any of the open Projects
	CProject* pProject = theApp.GetProjectByFileName( strFileName );
	if( pProject )
	{
		// Find the parent node in the Project Tree
		theApp.m_nFileTarget = TGT_FILENODE_SAVEAS;
		IDMUSProdNode* pIParentNode = theApp.m_pFramework->DetermineParentNode( strFileName );
		theApp.m_nFileTarget = TGT_PROJECT;
		
		if( pIParentNode )
		{
			CDirectoryNode* pParentDirNode = (CDirectoryNode *)pIParentNode;

			// CFileNode should have been created in theApp.m_pFramework->DetermineParentNode()
			pFileNode = theApp.FindFileNode( strFileName );
			if( pFileNode )
			{
				CTreeCtrl* pTreeCtrl = theApp.GetProjectTreeCtrl();

				if( pParentDirNode->m_hItem )
				{
					CMainFrame* pMainFrame = (CMainFrame *)theApp.m_pMainWnd;
					ASSERT( pMainFrame != NULL );
					pMainFrame->m_wndTreeBar.SortChildren( pParentDirNode->m_hItem );
				}

				theApp.m_pFramework->ShowTreeNode( pFileNode );
				hr = S_OK;
			}
		}

		pProject->Release();
	}

	return hr;
}


/*======================================================================================
METHOD:  IDMUSPRODFRAMEWORK::REGISTERCLIPFORMATFORFILE
========================================================================================
@method HRESULT | IDMUSProdFramework | RegisterClipFormatForFile | Registers a file's clipboard
	format with the <o Framework>.
 
@comm
	A <o Component>'s <om IDMUSProdComponent.Initialize> method can call
	<om IDMUSProdFramework.RegisterClipFormatForFile> to make the Framework aware of clipboard
	formats that can be used to create files in the Project Tree.  

	Data objects which have the potential of being pasted as DirectMusic files must contain at
	least two clipboard formats:  CF_DMUSPROD_FILE, and their custom format for file content.  The
	custom format must be registered with the Framework via a call to
	<om IDMUSProdFramework.RegisterClipFormatForFile>.  CF_DMUSPROD_FILE clipboard formats are created
	by calling <om IDMUSProdFramework.SaveClipFormat>.
	
@rvalue S_OK | <p uClipFormat> was registered successfully. 
@rvalue E_INVALIDARG | Either <p uClipFormat> or <p bstrExt> is not valid.  For example,
	<p uClipFormat> may be zero.
@rvalue E_OUTOFMEMORY | Out of memory. 
@rvalue E_FAIL | <p uClipFormat> could not be registered. 

@ex The following excerpt from an <om IDMUSProdComponent.Initialize> method registers
	a Band file's clipboard format with the Framework: |

	#define CF_BAND "DMUSProd v.1 Band"
	#define CF_BANDLIST "DMUSProd v.1 Band List"
  
	// Register clipboard formats
	m_cfBand = ::RegisterClipboardFormat( CF_BAND );
	m_cfBandList = ::RegisterClipboardFormat( CF_BANDLIST );
	if( m_cfBand == 0
	||  m_cfBandList == 0 )
	{
		CleanUp();
		::LoadString( theApp.m_hInstance, IDS_ERR_REGISTER_CF, achErrMsg, MID_BUFFER );
		strErrMsg = achErrMsg;
		*pbstrErrMsg = strErrMsg.AllocSysString();
		return E_FAIL;
	}

	// Tell Framework that the CF_BAND format can be used to create a .bnj file 
	CString strExt = _T(".bnj");
	BSTR bstrExt = strExt.AllocSysString();
	if( !SUCCEEDED ( pIFramework->RegisterClipFormatForFile(m_cfBand, bstrExt) ) )
	{
		CleanUp();
		::LoadString( theApp.m_hInstance, IDS_ERR_ADD_CLIPFORMAT, achErrMsg, MID_BUFFER );
		strErrMsg = achErrMsg;
		*pbstrErrMsg = strErrMsg.AllocSysString();
		return E_FAIL;
	}

	// Register applicable doc types with the Framework 
	m_pIDocType = new CBandDocType( this );
    if( m_pIDocType == NULL )
    {
		CleanUp();
		::LoadString( theApp.m_hInstance, IDS_ERR_MEMORY, achErrMsg, MID_BUFFER );
		strErrMsg = achErrMsg;
		*pbstrErrMsg = strErrMsg.AllocSysString();
        return E_OUTOFMEMORY;
    }

	m_pIDocType->AddRef();

	if( !SUCCEEDED ( pIFramework->AddDocType(m_pIDocType) ) )
	{
		CleanUp();
		::LoadString( theApp.m_hInstance, IDS_ERR_ADD_DOCTYPE, achErrMsg, MID_BUFFER );
		strErrMsg = achErrMsg;
		*pbstrErrMsg = strErrMsg.AllocSysString();
		return E_FAIL;
	}

@xref <i IDMUSProdFramework>, <om IDMUSProdFramework.SaveClipFormat>, <om IDMUSProdFramework.GetDocRootNodeFromData>
--------------------------------------------------------------------------------------*/

/////////////////////////////////////////////////////////////////////////////
// CFramework::RegisterClipFormatForFile

HRESULT CFramework::RegisterClipFormatForFile(
	UINT uClipFormat,		// @parm [in] Clipboard format used to create files
							//		with an extension equal to <p bstrExt>.
	BSTR bstrExt			// @parm [in] File extension.  This method frees
							//		<p bstrExt> with SysFreeString when it is no
							//		longer needed.
)
{
	AFX_MANAGE_STATE( AfxGetAppModuleState() );

	if( bstrExt == NULL )
	{
		return E_INVALIDARG;
	}

	CString strExt = bstrExt;
	::SysFreeString( bstrExt );

	if( uClipFormat == 0 )
	{
		return E_INVALIDARG;
	}

	// Place the new ClipFormat in list
	CJzClipFormat* pJzClipFormat = new CJzClipFormat( uClipFormat, strExt ); 
	if( pJzClipFormat == NULL )
	{
		return E_OUTOFMEMORY;
	}

	m_lstClipFormats.AddTail( pJzClipFormat );
	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CFramework::LoadCF_DMUSPROD_FILE

HRESULT CFramework::LoadCF_DMUSPROD_FILE( IStream* pIStream, CFProducerFile* pProducerFile )
{
	HRESULT hr = E_FAIL;
    IDMUSProdRIFFStream* pIRiffStream = NULL;
	CString strFileName;
    MMCKINFO ck;
	DWORD dwSize;
    WORD wStructSize;
	ioCFProducerFile iCFProducerFile;
	
	if( pIStream == NULL
	||  pProducerFile == NULL )
	{
		return E_INVALIDARG;
	}

    // Create RIFF stream
	hr = AllocRIFFStream( pIStream, &pIRiffStream );
	if( FAILED( hr ) )
	{
		goto ON_ERROR;
	}

	// Find the FOURCC_CF_DMUSPROD_FILE chunk header
	ck.ckid = FOURCC_CF_DMUSPROD_FILE;
    if( pIRiffStream->Descend( &ck, NULL, MMIO_FINDCHUNK ) != 0 )
    {
		hr = E_FAIL;
		goto ON_ERROR;
	}

	// Read size of ioCFProducerFile structure
    dwSize = ck.cksize;
    pIStream->Read( &wStructSize, sizeof( wStructSize ), NULL );
    dwSize -= sizeof( wStructSize );

	// Initialize ioCFProducerFile structure
	memset( &iCFProducerFile, 0, sizeof(ioCFProducerFile) );

	// Read ioCFProducerFile structure
    if( wStructSize > sizeof(ioCFProducerFile) )
    {
        pIStream->Read( &iCFProducerFile, sizeof(ioCFProducerFile), NULL );
        StreamSeek( pIStream, wStructSize - sizeof(ioCFProducerFile), STREAM_SEEK_CUR );
    }
    else
    {
        pIStream->Read( &iCFProducerFile, wStructSize, NULL );
    }
    dwSize -= wStructSize;

	// Read filename (unicode format)
	if( dwSize > 0 )
	{
		ReadMBSfromWCS( pIStream, dwSize, &strFileName );
	}

	pProducerFile->guidFile = iCFProducerFile.guidFile;
	pProducerFile->strFileName = strFileName;
	hr = S_OK;

ON_ERROR:
	if( pIRiffStream )
	{
		pIRiffStream->Release();
	}

	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CFramework::LoadClipFormat

HRESULT CFramework::LoadClipFormat( IDataObject* pIDataObject, UINT uClipFormat, IStream** ppIStream )
{
	if( ppIStream == NULL )
	{
		return E_POINTER;
	}

	*ppIStream = NULL;

	if( pIDataObject == NULL
	||  uClipFormat == 0 )
	{
		return E_INVALIDARG;
	}

	// Create a new CDllJazzDataObject and see if it can read the data object's format.
	CAppJazzDataObject* pDataObject = new CAppJazzDataObject();
	if( pDataObject == NULL )
	{
		return E_OUTOFMEMORY;
	}

	HRESULT hr = E_FAIL;

	// Check to see if specified format is available
	if( SUCCEEDED (	pDataObject->IsClipFormatAvailable( pIDataObject, uClipFormat ) ) )
	{
		IStream* pIStream;

		// Get stream containing specified format
		if( SUCCEEDED (	pDataObject->AttemptRead( pIDataObject, uClipFormat, &pIStream ) ) )
		{
			LARGE_INTEGER liTemp;

			// Seek to beginning of stream
			liTemp.QuadPart = 0;
			pIStream->Seek( liTemp, STREAM_SEEK_SET, NULL );

			*ppIStream = pIStream;
			hr = S_OK;
		}
	}

	pDataObject->Release();

	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CFramework::SaveCF_DMUSPROD_FILE

HRESULT CFramework::SaveCF_DMUSPROD_FILE( IDMUSProdNode* pINode, IStream** ppIStream )
{
	HRESULT hr;
	CString strName;
    MMCKINFO ck;
	DWORD dwBytesWritten;
    WORD wStructSize;
	ioCFProducerFile oCFProducerFile;
	
	if( ppIStream == NULL )
	{
		return E_POINTER;
	}

	*ppIStream = NULL;

	if( pINode == NULL )
	{
		return E_INVALIDARG;
	}

	// Get CFileNode for pINode (when applicable)
	CFileNode* pFileNode = NULL;

	GUID guidNodeId;
	if( SUCCEEDED ( pINode->GetNodeId( &guidNodeId ) ) )
	{
		if( IsEqualGUID( guidNodeId, GUID_FileNode ) )
		{
			pFileNode = (CFileNode *)pINode;
		}
	}
	if( pFileNode == NULL )
	{
		if( IsDocRootNode( pINode ) )
		{
			CComponentDoc* pComponentDoc = theApp.FindComponentDocument( pINode );
			if( pComponentDoc )
			{
				pFileNode = pComponentDoc->m_pFileNode;
			}

			ASSERT( pFileNode != NULL );
		}
	}

    IStream* pIMemStream = NULL;
    IDMUSProdRIFFStream* pIRiffStream = NULL;

	// Create an IStream
	hr = AllocMemoryStream( FT_DESIGN, GUID_CurrentVersion, &pIMemStream );
	if( FAILED ( hr ) )
	{
		goto ON_ERROR;
	}

	// Create a RIFFStream
    hr = AllocRIFFStream( pIMemStream, &pIRiffStream );
	if( FAILED ( hr ) )
	{
		goto ON_ERROR;
	}

	// Write CF_DMUSPROD_FILE chunk header
	ck.ckid = FOURCC_CF_DMUSPROD_FILE;
	if( pIRiffStream->CreateChunk( &ck, 0 ) != 0 )
	{
		hr = E_FAIL;
		goto ON_ERROR;
	}

	// Save size of ioCFProducerFile structure
	wStructSize = sizeof(ioCFProducerFile);
	hr = pIMemStream->Write( &wStructSize, sizeof(wStructSize), &dwBytesWritten );
	if( FAILED( hr )
	||  dwBytesWritten != sizeof(wStructSize) )
	{
		hr = E_FAIL;
		goto ON_ERROR;
	}

	// Prepare ioCFProducerFile structure
	memset( &oCFProducerFile, 0, sizeof(ioCFProducerFile) );
	if( pFileNode )
	{
		memcpy( &oCFProducerFile.guidFile, &pFileNode->m_guid, sizeof( oCFProducerFile.guidFile ) );
	}
	else
	{
		oCFProducerFile.guidFile = GUID_AllZeros;
	}

	// Write ioCFProducerFile structure
	hr = pIMemStream->Write( &oCFProducerFile, sizeof(ioCFProducerFile), &dwBytesWritten);
	if( FAILED( hr )
	||  dwBytesWritten != sizeof(ioCFProducerFile) )
	{
        hr = E_FAIL;
        goto ON_ERROR;
	}

	// Determine name
	if( pFileNode )
	{
		strName = pFileNode->m_strName;
	}
	else
	{
		// Node is not a file so just save the node's name
		BSTR bstrNodeName;

		if( SUCCEEDED ( pINode->GetNodeName( &bstrNodeName ) ) )
		{
			strName = bstrNodeName;
			::SysFreeString( bstrNodeName );
		}
	}

	// Write name in unicode format
	hr = SaveMBStoWCS( pIMemStream, &strName );
	if( FAILED( hr ) )
	{
        hr = E_FAIL;
        goto ON_ERROR;
	}

	if( pIRiffStream->Ascend( &ck, 0 ) != 0 )
	{
 		hr = E_FAIL;
		goto ON_ERROR;
	}

	pIMemStream->AddRef();
	*ppIStream = pIMemStream;
	hr = S_OK;

ON_ERROR:
	if( pIRiffStream )
	{
		pIRiffStream->Release();
	}

	if( pIMemStream )
	{
		pIMemStream->Release();
	}

	return hr;
}


/*======================================================================================
METHOD:  IDMUSPRODFRAMEWORK::SAVECLIPFORMAT
========================================================================================
@method HRESULT | IDMUSProdFramework | SaveClipFormat | Returns a stream containing the
		specified clipboard format for <p pINode>.
 
@comm
	A <o Component>'s <om IDMUSProdComponent.Initialize> method can call
	<om IDMUSProdFramework.RegisterClipFormatForFile> to make the Framework aware of clipboard
	formats that can be used to create files in the Project Tree.  

	Data objects which have the potential of being pasted as DirectMusic files must contain at
	least two clipboard formats:  CF_DMUSPROD_FILE, and their custom format for file content.  The
	custom format must be registered with the Framework via a call to
	<om IDMUSProdFramework.RegisterClipFormatForFile>.  CF_DMUSPROD_FILE clipboard formats are created
	by calling <om IDMUSProdFramework.SaveClipFormat>.
	
    The following list contains valid values for <p uClipFormat>:

	CF_DMUSPROD_FILE<tab><tab>The Framework uses CF_DMUSPROD_FILE format when pasting streams into files.
	
 
@rvalue S_OK | <p uClipFormat> was created for < p pINode> and was returned in <p ppIStream>.
@rvalue E_POINTER | The address in <p ppIStream> is not valid.  For example, it may be NULL.
@rvalue E_INVALIDARG | Either <p uClipFormat> or <p pINode> is not valid.  For example,
	<p uClipFormat> may be zero.
@rvalue E_OUTOFMEMORY | Out of memory. 
@rvalue E_FAIL | An error occurred, and the stream could not be created. 

@ex The following example fills a data object with the clipboard formats needed to paste a Band
	file into the Project Tree:|

HRESULT CBand::CreateDataObject( IDataObject** ppIDataObject )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( m_pComponent != NULL );

	if( ppIDataObject == NULL )
	{
		return E_POINTER;
	}

	*ppIDataObject = NULL;

	// Create the CDllJazzDataObject 
	CDllJazzDataObject* pDataObject = new CDllJazzDataObject();
	if( pDataObject == NULL )
	{
		return E_OUTOFMEMORY;
	}

	IStream* pIStream;

	// Save Band into stream
	HRESULT hr = E_FAIL;

	if( SUCCEEDED ( theApp.m_pIFramework->AllocMemoryStream(FT_DESIGN, GUID_CurrentVersion, &pIStream) ) )
	{
		if( SUCCEEDED ( Save( pIStream, FALSE ) ) )
		{
			// Place CF_BAND into CDllJazzDataObject
			if( SUCCEEDED ( pDataObject->AddClipFormat( m_pComponent->m_cfBand, pIStream ) ) )
			{
				hr = S_OK;
			}
		}

		pIStream->Release();
	}

	if( SUCCEEDED ( hr ) )
	{
		hr = E_FAIL;

		// Create a stream in CF_DMUSPROD_FILE format
		if( SUCCEEDED ( theApp.m_pIFramework->SaveClipFormat( m_pComponent->m_cfProducerFile, this, &pIStream ) ) )
		{
			// There is the potential for a Band node to become a file
			// so we must also place CF_DMUSPROD_FILE into CDllJazzDataObject
			if( SUCCEEDED ( pDataObject->AddClipFormat( m_pComponent->m_cfProducerFile, pIStream ) ) )
			{
				hr = S_OK;
			}

			pIStream->Release();
		}
	}

	if( SUCCEEDED ( hr ) )
	{
		*ppIDataObject = pDataObject;	// already AddRef'd
	}
	else
	{
		pDataObject->Release();
	}

	return hr;
}


@xref <i IDMUSProdFramework>, <om IDMUSProdFramework.RegisterClipFormatForFile>, <om IDMUSProdFramework.GetDocRootNodeFromData>
--------------------------------------------------------------------------------------*/

/////////////////////////////////////////////////////////////////////////////
// CFramework::SaveClipFormat

HRESULT CFramework::SaveClipFormat(
	UINT uClipFormat,		// @parm [in] Clipboard format. 
	IDMUSProdNode* pINode,	// @parm [in] A pointer to the <o Node> whose clipboard
							//		format be returned in <p ppIStream>.
	IStream **ppIStream		// @parm [out,retval] Address of a variable to receive the requested
							//		<i IStream> interface.  If an error occurs, the implementation
							//		sets <p ppIStream> to NULL.  On success, the caller is responsible
							//		for calling <om IStream.Release>.
)
{
	AFX_MANAGE_STATE( AfxGetAppModuleState() );

	if( ppIStream == NULL )
	{
		return E_POINTER;
	}

	*ppIStream = NULL;

	if( uClipFormat == 0
	||  pINode == NULL )
	{
		return E_INVALIDARG;
	}

	if( uClipFormat == m_cfProducerFile )
	{
		// Create the CF_DMUSPROD_FILE stream
		return SaveCF_DMUSPROD_FILE( pINode, ppIStream );
	}
	
	return E_FAIL;
}


/*======================================================================================
METHOD:  IDMUSPRODFRAMEWORK::GETDOCROOTNODEFROMDATA
========================================================================================
@method HRESULT | IDMUSProdFramework | GetDocRootNodeFromData | Returns an <i IDMUSProdNode>
		interface pointer for the DocRoot <o Node> in <p pIDataObject>.
 
@comm
	A DocRoot Node is the top Node of a file.  For more information refer to <o Node>
	Object.
		
@rvalue S_OK | The matching DocRoot Node was returned in <p ppIDocRootNode>. 
@rvalue E_POINTER | The address in <p ppIDocRootNode> is not valid.  For example, it may be NULL.
@rvalue E_INVALIDARG | <p pIDataObject> is not valid.  For example, it may be NULL.
@rvalue E_OUTOFMEMORY | Out of memory. 
@rvalue E_FAIL | An error occurred, and a DocRoot Node could not be returned.

@ex The following example: |


@xref <i IDMUSProdFramework>, <om IDMUSProdFramework.SaveClipFormat>, <om IDMUSProdFramework.RegisterClipFormatForFile>, 
--------------------------------------------------------------------------------------*/

/////////////////////////////////////////////////////////////////////////////
// CFramework::GetDocRootNodeFromData

HRESULT CFramework::GetDocRootNodeFromData(
	IDataObject* pIDataObject,	// @parm [in] Pointer to an IDataObject interface.
	IDMUSProdNode** ppIDocRootNode	// @parm [out,retval] Address of a variable to receive
								//		the requested IDMUSProdNode interface.
								//		If an error occurs, the implementation
								//		sets <p ppIDocRootNode> to NULL.  On success, the caller
								//		is responsible for calling <om IDMUSProdNode.Release>.
)
{
	AFX_MANAGE_STATE( AfxGetAppModuleState() );

	if( ppIDocRootNode == NULL )
	{
		return E_POINTER;
	}

	*ppIDocRootNode = NULL;

	if( pIDataObject == NULL )
	{
		return E_INVALIDARG;
	}

	IStream* pIStream;

	HRESULT hr = E_FAIL;

	if( SUCCEEDED ( LoadClipFormat( pIDataObject, m_cfProducerFile, &pIStream ) ) )
	{
		CFProducerFile cfProducerFile;

		if( SUCCEEDED ( LoadCF_DMUSPROD_FILE( pIStream, &cfProducerFile ) ) )
		{
			if( !( IsEqualGUID( cfProducerFile.guidFile, GUID_AllZeros ) ) )
			{
				CFileNode* pFileNode = theApp.GetFileByGUID( cfProducerFile.guidFile );
				if( pFileNode )
				{
					if( pFileNode->m_pIChildNode )
					{
						pFileNode->m_pIChildNode->AddRef();
						*ppIDocRootNode = pFileNode->m_pIChildNode;
						hr = S_OK;
					}

					pFileNode->Release();
				}
			}
		}

		pIStream->Release();
	}

	return hr;
}


/*======================================================================================
METHOD:  IDMUSPRODFRAMEWORK::GETFIRSTPROJECT
========================================================================================
@method HRESULT | IDMUSProdFramework | GetFirstProject | Returns an <i IDMUSProdProject> interface
		pointer for the first <o Project> in the application's list of Projects.

@comm
	<p ppIFirstProject> is set to NULL if the list is empty.

@rvalue S_OK | The first Project was returned in <p ppIFirstProject>. 
@rvalue E_POINTER | The address in <p ppIFirstProject> is not valid.  For example, it may
		be NULL.
@rvalue E_FAIL | An error occurred, and the first Project could not be returned.

@ex The following example: |

@xref <i IDMUSProdFramework>, <om IDMUSProdFramework.GetNextProject>, <i IDMUSProdProject>
--------------------------------------------------------------------------------------*/

/////////////////////////////////////////////////////////////////////////////
// CFramework::GetFirstProject

HRESULT CFramework::GetFirstProject(
	IDMUSProdProject** ppIFirstProject	// @parm [out,retval] Address of a variable to receive the requested  
									//		<i IDMUSProdProject> interface.  If an error occurs, the implementation
									//		sets <p ppIFirstProject> to NULL.  On success, the
									//		caller is responsible for calling
									//		<om IDMUSProdProject.Release>.
)
{
	AFX_MANAGE_STATE( AfxGetAppModuleState() );

	return theApp.GetFirstProject( ppIFirstProject );
}


/*======================================================================================
METHOD:  IDMUSPRODFRAMEWORK::GETNEXTPROJECT
========================================================================================
@method HRESULT | IDMUSProdFramework | GetNextProject | Returns an <i IDMUSProdProject> interface
		pointer for the next <o Project> in the application's list of Projects.

@comm
	Returns the Project located after <p pIProject> in the application's list of Projects.

	<p ppINextProject> is set to NULL when the end of the list has been reached.

@rvalue S_OK | The next Project was returned in <p ppINextProject>. 
@rvalue E_POINTER | The address in <p ppINextProject> is not valid.  For example, it may
		be NULL.
@rvalue E_INVALIDARG | <p pIProject> is not valid.  For example, it may be NULL.
@rvalue E_FAIL | An error occurred, and the next Project could not be returned.

@ex The following example: |

@xref <i IDMUSProdFramework>, <om IDMUSProdFramework.GetFirstProject>, <i IDMUSProdProject>
--------------------------------------------------------------------------------------*/

/////////////////////////////////////////////////////////////////////////////
// CFramework::GetNextProject

HRESULT CFramework::GetNextProject(
	IDMUSProdProject* pIProject,		// @parm [in] A pointer to the previous Project in
										//		the application's list of Projects.
	IDMUSProdProject** ppINextProject	// @parm [out,retval] Address of a variable to receive the requested  
										//		<i IDMUSProdProject> interface.  If an error occurs, the implementation
										//		sets <p ppINextProject> to NULL.  On success, the
										//		caller is responsible for calling
										//		<om IDMUSProdProject.Release>.
)
{
	AFX_MANAGE_STATE( AfxGetAppModuleState() );

	return theApp.GetNextProject( pIProject, ppINextProject );
}


/*======================================================================================
METHOD:  IDMUSPRODFRAMEWORK::FINDPROJECT
========================================================================================
@method HRESULT | IDMUSProdFramework | FindProject | Returns an <i IDMUSProdProject> interface
		pointer for the <o Project> containing <p pINode>.

@comm

@rvalue S_OK | <p pINode>'s Project was returned in <p ppIProject>. 
@rvalue E_POINTER | The address in <p ppIProject> is not valid.  For example, it may
		be NULL.
@rvalue E_FAIL | An error occurred, and <p pINode>'s Project could not be returned.

@ex The following example: |

@xref <i IDMUSProdFramework>, <i IDMUSProdProject>
--------------------------------------------------------------------------------------*/

/////////////////////////////////////////////////////////////////////////////
// CFramework::FindProject

HRESULT CFramework::FindProject(
	IDMUSProdNode* pINode,			// @parm [in] A pointer to the node whose Project
									//		will be returned in <p ppIProject>.
	IDMUSProdProject** ppIProject	// @parm [out,retval] Address of a variable to receive the requested  
									//		<i IDMUSProdProject> interface.  If an error occurs, the implementation
									//		sets <p ppIProject> to NULL.  On success, the
									//		caller is responsible for calling
									//		<om IDMUSProdProject.Release>.
)
{
	AFX_MANAGE_STATE( AfxGetAppModuleState() );

	if( ppIProject == NULL )
	{
		return E_POINTER;
	}

	*ppIProject = NULL;

	if( pINode == NULL )
	{
		return E_INVALIDARG;
	}

	CTreeCtrl* pTreeCtrl = theApp.GetProjectTreeCtrl();
	if( pTreeCtrl == NULL )
	{
		return E_FAIL;
	}

	IDMUSProdNode* pITreeNode;
	GUID guidTreeNodeId;

	HTREEITEM hItem = FindTreeItem( pINode );

	while( hItem )
	{
		CJzNode* pJzNode = (CJzNode *)pTreeCtrl->GetItemData( hItem );
		if( pJzNode )
		{
			pITreeNode = pJzNode->m_pINode;
			ASSERT( pITreeNode != NULL );

			if( pITreeNode )
			{
				if( SUCCEEDED ( pITreeNode->GetNodeId( &guidTreeNodeId ) ) )
				{
					if( IsEqualGUID( guidTreeNodeId, GUID_ProjectFolderNode ) )
					{
						if( FAILED ( pITreeNode->QueryInterface( IID_IDMUSProdProject, (void **)ppIProject ) ) )
						{
							*ppIProject = NULL;
						}
						break;
					}
				}
			}
		}

		hItem = pTreeCtrl->GetNextItem( hItem, TVGN_PARENT );
	}

	if( *ppIProject )
	{
		return S_OK;
	}

	return E_FAIL;
}


/*======================================================================================
METHOD:  IDMUSPRODFRAMEWORK::ISPROJECTEQUAL
========================================================================================
@method HRESULT | IDMUSProdFramework | IsProjectEqual | Determines whether <p pIDocRootNode1>
		and <p pIDocRootNode2> are in the same <o Project>. 

@comm
	<p pIDocRootNode1> and <p pIDocRootNode2> must point to DocRoot <o Node>s.

	A DocRoot node is the top node of a document, or file.  For example, the Style node of
	a Style file would be considered the DocRoot node of the Style.  The Band node of a Band
	file would be considered the DocRoot node of the Band file.

@rvalue S_OK | <p pIDocRootNode1> and <p pIDocRootNode2> are in the same Project.
@rvalue S_FALSE | <p pIDocRootNode1> and <p pIDocRootNode2> are not in the same Project.
@rvalue E_INVALIDARG | The value of either <p pIDocRootNode1> or <p pIDocRootNode2> is
		not valid.  For example, it may not point to a DocRoot node.
@rvalue E_FAIL | An error occurred.  Cannot determine whether the specified DocRoot nodes
		are in the same Project.

@ex The following example makes sure that a referenced file exists in the same Project as the
	file it references.  m_pIStyleRefNode contains an IDMUSProdNode interface pointer to the node
	used to display a referenced Style file:|

	IDMUSProdReferenceNode* pIReferenceNode;

	if( SUCCEEDED ( m_pIStyleRefNode->QueryInterface( IID_IDMUSProdReferenceNode, (void **)&pIReferenceNode ) ) )
	{
		IDMUSProdNode* pIStyleDocRootNode;

		if( SUCCEEDED ( pIReferenceNode->GetReferencedFile( &pIStyleDocRootNode ) ) )
		{
			if( pIFramework->IsProjectEqual( this, pIStyleDocRootNode ) == S_FALSE )
			{
				IDMUSProdNode* pINewDocRootNode;

				if( SUCCEEDED ( pIFramework->CopyFile( pIStyleDocRootNode, this, &pINewDocRootNode ) ) )
				{
					pIReferenceNode->SetReferencedFile( pINewDocRootNode );
					pINewDocRootNode->Release();
				}
			}

			pIStyleDocRootNode->Release();
		}

		pIReferenceNode->Release();
	}

@xref <i IDMUSProdFramework>, <om IDMUSProdFramework.CopyFile>
--------------------------------------------------------------------------------------*/

/////////////////////////////////////////////////////////////////////////////
// CFramework::IsProjectEqual

HRESULT CFramework::IsProjectEqual(
	IDMUSProdNode* pIDocRootNode1,		// @parm [in] Pointer to the <i IDMUSProdNode> interface of
									//		a DocRoot node.
	IDMUSProdNode* pIDocRootNode2		// @parm [in] Pointer to the <i IDMUSProdNode> interface of
									//		a DocRoot node.
)
{
	AFX_MANAGE_STATE( AfxGetAppModuleState() );

	if( pIDocRootNode1 == NULL
	||  pIDocRootNode2 == NULL )
	{
		return E_INVALIDARG;
	}

	// Make sure pIDocRootNode1 really is a DocRootNode
	IDMUSProdNode* pINode;

	if( FAILED ( pIDocRootNode1->GetDocRootNode( &pINode ) ) )
	{
		return E_FAIL;
	}
	ASSERT( pIDocRootNode1 == pINode );
	if( pINode == NULL )
	{
		return E_FAIL;
	}
	if( pIDocRootNode1 != pINode )
	{
		pINode->Release();
		return E_INVALIDARG;
	}
	pINode->Release();

	// Make sure pIDocRootNode2 really is a DocRootNode
	if( FAILED ( pIDocRootNode2->GetDocRootNode( &pINode ) ) )
	{
		return E_FAIL;
	}
	ASSERT( pIDocRootNode2 == pINode );
	if( pINode == NULL )
	{
		return E_FAIL;
	}
	if( pIDocRootNode2 != pINode )
	{
		pINode->Release();
		return E_INVALIDARG;
	}
	pINode->Release();

	HRESULT hr = E_FAIL;
	
	// See if DocRootNodes are in the same Project
	IDMUSProdProject* pIProject1;
	IDMUSProdProject* pIProject2;

	if( SUCCEEDED ( FindProject( pIDocRootNode1, &pIProject1 ) ) )
	{
		if( SUCCEEDED ( FindProject( pIDocRootNode2, &pIProject2 ) ) )
		{
			if( pIProject1 == pIProject2 )
			{
				hr = S_OK;
			}
			else
			{
				hr = S_FALSE;
			}

			pIProject2->Release();
		}

		pIProject1->Release();
	}

	return hr;
}


/*======================================================================================
METHOD:  IDMUSPRODFRAMEWORK::ADDNODEIMAGELIST
========================================================================================
@method HRESULT | IDMUSProdFramework | AddNodeImageList | Adds images to the Project Tree's
		image list. 

@comm
	If a Component inserts nodes into the Project Tree, its <om IDMUSProdComponent.Initialize>
	method must call <om IDMUSProdFramework.AddNodeImageList> so that the Component can add
	its images to the Project Tree's image list.

	Project Tree images must be 16 X 16 and contain 256 colors.

	The Project Tree maintains a list of images used when drawing nodes.  As nodes are
	inserted into the Project Tree, the Framework calls <om IDMUSProdNode.GetNodeImageIndex>
	so that it can associate a pair of consecutive images in its list with the node
	being inserted.  The index returned by <om IDMUSProdNode.GetNodeImageIndex> is based
	<p pnNbrfirstImage>.  Images must always be added in pairs.  The
	<om IDMUSProdNode.UseOpenCloseImages> method determines whether the consecutive images
	pertain to non-selected/selected states or closed/opened states (folders).  

@rvalue S_OK | The image list was added successfully and the index to the first image in
		the list was returned in <p pnNbrFirstImage>. 
@rvalue E_POINTER | The address in <p pnNbrFirstImage> is not valid.  For example, it may
		be NULL.
@rvalue E_FAIL | The images were not added to the Project Tree's image list.

@ex The following example adds images to the Project Tree's image list: |

HRESULT CMotifComponent::AddNodeImageLists( void )
{
	CImageList lstImages;
	HICON hIcon;

	lstImages.Create( 16, 16, ILC_COLOR16, 2, 0 );
	lstImages.SetBkColor( GetSysColor(COLOR_WINDOW) );

	hIcon = ::LoadIcon( theApp.m_hInstance, MAKEINTRESOURCE(IDR_MOTIF_DOCTYPE) );
	lstImages.Add( hIcon );
	::DestroyIcon( hIcon );
	hIcon = ::LoadIcon( theApp.m_hInstance, MAKEINTRESOURCE(IDI_MOTIF_DOCTYPE_SEL) );
	lstImages.Add( hIcon );
	::DestroyIcon( hIcon );

	if( FAILED (m_pIFramework->AddNodeImageList( lstImages.Detach(), &m_nFirstMotifImage ) ) )
	{
		return E_FAIL;
	}
	
	lstImages.Create( 16, 16, ILC_COLOR16, 2, 0 );
	lstImages.SetBkColor( GetSysColor(COLOR_WINDOW) );

	hIcon = ::LoadIcon( theApp.m_hInstance, MAKEINTRESOURCE(IDI_FOLDER) );
	lstImages.Add( hIcon );
	::DestroyIcon( hIcon );
	hIcon = ::LoadIcon( theApp.m_hInstance, MAKEINTRESOURCE(IDI_FOLDER_SEL) );
	lstImages.Add( hIcon );
	::DestroyIcon( hIcon );

	if( FAILED (m_pIFramework->AddNodeImageList( lstImages.Detach(), &m_nFirstFolderImage ) ) )
	{
		return E_FAIL;
	}
	
	return S_OK;
}
	
@xref <om IDMUSProdComponent.Initialize>, <i IDMUSProdFramework>, <i IDMUSProdNode>, <om IDMUSProdNode.GetNodeImageIndex>
--------------------------------------------------------------------------------------*/

/////////////////////////////////////////////////////////////////////////////
// CFramework::AddNodeImageList

HRESULT CFramework::AddNodeImageList(
	HANDLE hNodeImageList,		// @parm [in] Handle to image list to be added.
	short* pnNbrFirstImage		// @parm [out,retval] Pointer to corresponding index into
								//		Project Tree's image list.
								//		<om IDMUSProdNode.GetNodeImageIndex> returns an index
								//		based on <p pnNbrFirstImage>.
)
{
	AFX_MANAGE_STATE( AfxGetAppModuleState() );

	CTreeCtrl* pTreeCtrl;
    CImageList lstNodeImages;
    CImageList* plstTreeImages;
    int nNbrNewImages;
    int nNbrTreeImages;
	int i;

	ASSERT( hNodeImageList != NULL );

	if( pnNbrFirstImage == NULL )
	{
		return E_POINTER;
	}

	pTreeCtrl = theApp.GetProjectTreeCtrl();
	if( pTreeCtrl == NULL )
	{
		return E_FAIL;
	}

	lstNodeImages.Attach( (HIMAGELIST)hNodeImageList );
    nNbrNewImages = lstNodeImages.GetImageCount();

    plstTreeImages = pTreeCtrl->GetImageList( TVSIL_NORMAL );

    if( plstTreeImages == NULL )
    {
        pTreeCtrl->SetImageList( &lstNodeImages, TVSIL_NORMAL );
		*pnNbrFirstImage = 0;
    }
    else
    {
		CImageList lstNewTreeImages;

	    nNbrTreeImages = plstTreeImages->GetImageCount();
		*pnNbrFirstImage = nNbrTreeImages;

		lstNewTreeImages.Create( 16, 16, ILC_COLOR16, nNbrTreeImages + nNbrNewImages, 0 );

		for( i = 0 ; i < nNbrTreeImages ; ++i )
		{
			HICON hIcon = plstTreeImages->ExtractIcon( i );
			lstNewTreeImages.Add( hIcon );
			::DestroyIcon( hIcon );
		}

		for( i = 0 ; i < nNbrNewImages ; ++i )
		{
			HICON hIcon = lstNodeImages.ExtractIcon( i );
			lstNewTreeImages.Add( hIcon );
			::DestroyIcon( hIcon );
		}


		CImageList* pImageList = pTreeCtrl->SetImageList( &lstNewTreeImages, TVSIL_NORMAL );
		if( pImageList )
		{
			pImageList->DeleteImageList();
		}

		plstTreeImages->Detach();
	    lstNewTreeImages.Detach();
    }

    lstNodeImages.Detach();

	return S_OK;
}


/*======================================================================================
METHOD:  IDMUSPRODFRAMEWORK::GETNODEFILENAME
========================================================================================
@method HRESULT | IDMUSProdFramework | GetNodeFileName | Returns the path/filename of the
		file associated with <p pINode>. 

@rvalue S_OK | The filename was returned in <p pbstrFileName>.
@rvalue E_POINTER | The address in <p pbstrFileName> is not valid.  For example, it may be NULL.
@rvalue E_INVALIDARG | The address in <p pINode> is not valid.  For example, it may be NULL.
@rvalue E_FAIL | An error occurred and the filename was not returned.

@ex The following example retrieves the filename of the file which contains <p pINode>: |

	IDMUSProdFramework pIFramework;
	CString strFileName;
	BSTR bstrFileName;

	if( SUCCEEDED ( pIFramework->GetNodeFileName((IDMUSProdNode *)this, &bstrFileName) ) )
	{
		strFileName = bstrFileName;
		::SysFreeString( bstrFileName );
	}
	
@xref <i IDMUSProdFramework>, <om IDMUSProdFramework.SaveNode>, <om IDMUSProdFramework.SaveNodeAsNewFile>, <i IDMUSProdNode>
--------------------------------------------------------------------------------------*/

/////////////////////////////////////////////////////////////////////////////
// CFramework::GetNodeFileName

HRESULT CFramework::GetNodeFileName(
	IDMUSProdNode* pINode,		// @parm [in] Pointer to any <i IDMUSProdNode> in the file.
	BSTR* pbstrFileName		// @parm [out,retval] Pointer to the caller-allocated variable
							// that receives the copy of the filename.  The caller must
							// free <p pbstrFileName> with SysFreeString when it is no longer
							// needed.
)
{
	AFX_MANAGE_STATE( AfxGetAppModuleState() );

	if( pbstrFileName == NULL )
	{
		return E_POINTER;
	}

	*pbstrFileName = NULL;

	if( pINode == NULL )
	{
		return E_INVALIDARG;
	}

	CString strFileName;

	GUID guidNodeId;
	if( SUCCEEDED ( pINode->GetNodeId ( &guidNodeId ) ) )
	{
		// Handle Project Folder Nodes
		if( IsEqualGUID( guidNodeId, GUID_ProjectFolderNode ) )
		{
			CProject* pProject = (CProject *)pINode;

			// Get file extension used for Projects
			CString strFilterExt;

			ASSERT( pProject->m_pProjectDoc != NULL );
			CJazzDocTemplate* pDocTemplate = (CJazzDocTemplate *)pProject->m_pProjectDoc->GetDocTemplate();
			ASSERT( pDocTemplate != NULL );

			pDocTemplate->GetDocString( strFilterExt, CDocTemplate::filterExt );
			strFileName = pProject->m_strProjectDir + pProject->m_strName + strFilterExt; 
			*pbstrFileName = strFileName.AllocSysString();
			return S_OK;
		}

		// Handle FileNodes
		else if( IsEqualGUID( guidNodeId, GUID_FileNode ) )
		{
			CFileNode* pFileNode = (CFileNode *)pINode;

			pFileNode->ConstructFileName( strFileName );
			*pbstrFileName = strFileName.AllocSysString();
			return S_OK;
		}
	}

	// Handle other Nodes
	CComponentDoc* pComponentDoc = theApp.FindComponentDocument( pINode );
	if( pComponentDoc )
	{
		strFileName = pComponentDoc->GetPathName();
		*pbstrFileName = strFileName.AllocSysString();
		return S_OK;
	}

	return E_FAIL;
}


/*======================================================================================
METHOD:  IDMUSPRODFRAMEWORK::GETNODEFILEGUID
========================================================================================
@method HRESULT | IDMUSProdFramework | GetNodeFileGuid | Returns the Producer generated
		GUID assigned to the file associated with <p pINode>. 

@comm	Producer assigns a GUID to every file in the Project Tree.  This GUID can be obtained
		via the <om IDMUSProdFramework::GetNodeFileGuid> method.  <p pguidFile> refers to this 
		GUID. 

		The <i IDMUSProdProject> interface provides methods to enumerate all files in a given
		Project.  The <i IDMUSProdNode> interface pointer returned by the 
		<om IDMUSProdProject::GetFirstFileByDocType> and  <om IDMUSProdProject::GetNextFileByDocType>
		methods can be passed to <om IDMUSProdFramework::GetNodeFileGuid> and used in
		conjunction with <om IDMUSProdFramework::FindDocRootNodeByFileGUID> to retrieve
		the DocRoot node for a specific file.

@rvalue S_OK | The file's GUID was placed in <p pguidFile>.
@rvalue E_POINTER | The address in <p pguidFile> is not valid.  For example, it may be NULL.
@rvalue E_INVALIDARG | The address in <p pINode> is not valid.  For example, it may be NULL.
@rvalue E_FAIL | An error occurred and the file's GUID was not returned.

@ex The following example retrieves the Producer generated GUID identifying the file which
	contains <p pINode>: |

	IDMUSProdFramework pIFramework;
	IDMUSProdNode* pIThisDocRootNode;
	IDMUSProdNode* pIDocRootNode;
	GUID guidFile;

	if( SUCCEEDED ( pIFramework->GetNodeFileGUID(pIThisDocRootNode, &guidFile) ) )
	{
		if( SUCCEEDED ( pIFramework->FindDocRootNodeByFileGUID(guidFile, &pIDocRootNode) ) )
		{
			ASSERT( pIDocRootNode == pIThisDocRootNode );	
		}
    }
	
@xref <i IDMUSProdFramework>, <i IDMUSProdProject>, <i IDMUSProdNode>, <om IDMUSProdFramework.FindDocRootNodeByFileGUID>
--------------------------------------------------------------------------------------*/

/////////////////////////////////////////////////////////////////////////////
// CFramework::GetNodeFileGUID

HRESULT CFramework::GetNodeFileGUID(
	IDMUSProdNode* pINode,	// @parm [in] Pointer to any <i IDMUSProdNode> in the file.
	GUID* pguidFile			// @parm [out,retval] Pointer to the caller-allocated variable
							//		that receives a copy of the file's GUID.
)
{
	AFX_MANAGE_STATE( AfxGetAppModuleState() );

	if( pguidFile == NULL )
	{
		return E_POINTER;
	}

	memset( pguidFile, 0, sizeof( GUID ) );

	if( pINode == NULL )
	{
		return E_INVALIDARG;
	}

	GUID guidNodeId;
	if( SUCCEEDED ( pINode->GetNodeId ( &guidNodeId ) ) )
	{
		// Handle Project Folder Nodes
		if( IsEqualGUID( guidNodeId, GUID_ProjectFolderNode ) )
		{
			return E_FAIL;
		}

		// Handle Directory Nodes
		if( IsEqualGUID( guidNodeId, GUID_DirectoryNode ) )
		{
			return E_FAIL;
		}

		// Handle FileNodes
		else if( IsEqualGUID( guidNodeId, GUID_FileNode ) )
		{
			CFileNode* pFileNode = (CFileNode *)pINode;

			*pguidFile = pFileNode->m_guid;
			return S_OK;
		}
	}

	// Handle other Nodes
	CComponentDoc* pComponentDoc = theApp.FindComponentDocument( pINode );
	if( pComponentDoc )
	{
		if( pComponentDoc->m_pFileNode )
		{
			*pguidFile = pComponentDoc->m_pFileNode->m_guid;
			return S_OK;
		}
	}

	return E_FAIL;
}


/*======================================================================================
METHOD:  IDMUSPRODFRAMEWORK::REVERTFILETOSAVED
========================================================================================
@method HRESULT | IDMUSProdFramework | RevertFileToSaved | Reverts the document associated with
	<p pINode> to its last saved state.

@comm
	This method provides the means for a Component to undo changes by reloading a file.  For
	example, the right-click context menu associated with a node can contain a 'Revert to Saved'
	menu item.

    The Framework obtains the DocRoot node for the document by using <p pINode> to call
	<om IDMUSProdNode.GetDocRootNode>.

@rvalue S_OK | The file associated with <p pINode> was successfully reverted to it last saved
		state.
@rvalue E_INVALIDARG | The address in <p pINode> is not valid.  For example, it may be NULL.
@rvalue E_FAIL | An error occurred and the file was not reverted.

@ex The following example reverts the document containing <p pINode> to its last saved state: |

HRESULT CMotif::OnRightClickMenuSelect( long lCommandId )
{
	ASSERT( m_pComponent != NULL );
	ASSERT( m_pComponent->m_pIFramework != NULL );

	HRESULT hr = E_FAIL;

	switch( lCommandId )
	{
		case IDM_REVERT:
			if( SUCCEEDED ( m_pComponent->m_pIFramework->RevertFileToSaved((IDMUSProdNode *)this) ) )
			{
				hr = S_OK;
			}
			break;
	}

	return hr;
}
	
@xref <i IDMUSProdFramework>, <om IDMUSProdFramework.GetNodeFileName>, <om IDMUSProdFramework.SaveNodeAsNewFile>, <i IDMUSProdNode>, <om IDMUSProdNode.GetDocRootNode>
--------------------------------------------------------------------------------------*/

/////////////////////////////////////////////////////////////////////////////
// CFramework::RevertFileToSaved

HRESULT CFramework::RevertFileToSaved(
	IDMUSProdNode* pINode		// @parm [in] Pointer to any <i IDMUSProdNode> in the file.
)
{
	AFX_MANAGE_STATE( AfxGetAppModuleState() );

	if( pINode == NULL )
	{
		return E_INVALIDARG;
	}

	CComponentDoc* pComponentDoc = theApp.FindComponentDocument( pINode );
	if( pComponentDoc )
	{
		pComponentDoc->m_bAction = DOC_ACTION_REVERT;
		if( pComponentDoc->RevertDocument() )
		{
			return S_OK;
		}
		pComponentDoc->m_bAction = DOC_ACTION_NONE;
	}

	return E_FAIL;
}


/*======================================================================================
METHOD:  IDMUSPRODFRAMEWORK::SAVENODE
========================================================================================
@method HRESULT | IDMUSProdFramework | SaveNode | Invokes the Framework's File Save command
		for the document associated with the DocRoot node of <p pINode>.

@comm
	This method provides the means for a Component to initiate a File Save command.  For
	example, it allows the right-click context menu associated with a file's DocRoot node
	to contain a menu item for saving itself.

    The Framework obtains the DocRoot node for the document by using <p pINode> to call
	<om IDMUSProdNode.GetDocRootNode>.

@rvalue S_OK | The file associated with <p pINode> was saved successfully.
@rvalue E_INVALIDARG | The address in <p pINode> is not valid.  For example, it may be NULL.
@rvalue E_FAIL | An error occurred and the file was not saved.

@ex The following example saves the document which contains <p pINode>: |

HRESULT CMotif::OnRightClickMenuSelect( long lCommandId )
{
	ASSERT( m_pComponent != NULL );
	ASSERT( m_pComponent->m_pIFramework != NULL );

	HRESULT hr = E_FAIL;

	IDMUSProdNode* pIDocRootNode;

	switch( lCommandId )
	{
		case IDM_SAVE:
			if( SUCCEEDED ( GetDocRootNode(&pIDocRootNode) ) )
			{
				if( SUCCEEDED ( m_pComponent->m_pIFramework->SaveNode(pIDocRootNode) ) )
				{
					hr = S_OK;
				}
				pIDocRootNode->Release();
			}
			break;
	}

	return hr;
}
	
@xref <i IDMUSProdFramework>, <om IDMUSProdFramework.GetNodeFileName>, <om IDMUSProdFramework.SaveNodeAsNewFile>, <i IDMUSProdNode>, <om IDMUSProdNode.GetDocRootNode>
--------------------------------------------------------------------------------------*/

/////////////////////////////////////////////////////////////////////////////
// CFramework::SaveNode

HRESULT CFramework::SaveNode(
	IDMUSProdNode* pINode		// @parm [in] Pointer to any <i IDMUSProdNode> in the file.
)
{
	AFX_MANAGE_STATE( AfxGetAppModuleState() );

	if( pINode == NULL )
	{
		return E_INVALIDARG;
	}

	CComponentDoc* pComponentDoc = theApp.FindComponentDocument( pINode );
	if( pComponentDoc )
	{
		if( pComponentDoc->DoFileSave() )
		{
			return S_OK;
		}
	}

	return E_FAIL;
}


/*======================================================================================
METHOD:  IDMUSPRODFRAMEWORK::SAVENODEASNEWFILE
========================================================================================
@method HRESULT | IDMUSProdFramework | SaveNodeAsNewFile | Invokes the <o Framework>'s File
	Save As command to create a new file for the <o Node> specified in <p pINode>. 

@comm
	This method provides the means for a Component to initiate a File Save As command.
	For example, it allows the right-click context menu associated with a Project Tree
	node to contain a menu item for saving itself as a new file.

	???? Need to explain how to get a Style's Band node into a Band file node.

@rvalue S_OK | <p pINode> was saved successfully as a new file.
@rvalue E_INVALIDARG | The address in <p pINode> is not valid.  For example, it may be NULL.
@rvalue E_FAIL | An error occurred and a new file was not saved.

@ex The following example saves the document containing <p pINode> as a new file: |

HRESULT CMotif::OnRightClickMenuSelect( long lCommandId )
{
	ASSERT( m_pComponent != NULL );
	ASSERT( m_pComponent->m_pIFramework != NULL );

	HRESULT hr = E_FAIL;

	IDMUSProdNode* pIDocRootNode;

	switch( lCommandId )
	{
		case IDM_SAVEAS:
			if( SUCCEEDED ( GetDocRootNode(&pIDocRootNode) ) )
			{
				if( SUCCEEDED ( m_pComponent->m_pIFramework->SaveNodeAsNewFile(pIDocRootNode) ) )
				{
					hr = S_OK;
				}
				pIDocRootNode->Release();
			}
			break;
	}

	return hr;
}
	
@xref <i IDMUSProdFramework>, <om IDMUSProdFramework.GetNodeFileName>, <om IDMUSProdFramework.SaveNode>, <i IDMUSProdNode>, <om IDMUSProdNode.GetDocRootNode>
--------------------------------------------------------------------------------------*/

/////////////////////////////////////////////////////////////////////////////
// CFramework::SaveNodeAsNewFile

HRESULT CFramework::SaveNodeAsNewFile(
	IDMUSProdNode* pINode		// @parm [in] Pointer to any <i IDMUSProdNode> in the file.
)
{
	AFX_MANAGE_STATE( AfxGetAppModuleState() );

	if( pINode == NULL )
	{
		return E_INVALIDARG;
	}

	// Handle DocRoot nodes
	if( IsDocRootNode( pINode ) )
	{
		CComponentDoc* pComponentDoc = theApp.FindComponentDocument( pINode );

		if( pComponentDoc )
		{
			if( pComponentDoc->DoSave(NULL) )
			{
				return S_OK;
			}
		}

		return E_FAIL;
	}

	HRESULT hr = E_FAIL;

	// Handle other node (i.e. Style Band nodes)
	IDataObject* pIDataObject;

	if( SUCCEEDED ( pINode->CreateDataObject( &pIDataObject ) ) )
	{
		hr = CreateFileFromDataObject( pIDataObject );

		pIDataObject->Release();
	}

	return hr;
}


/*======================================================================================
METHOD:  IDMUSPRODFRAMEWORK::ADDNODE
========================================================================================
@method HRESULT | IDMUSProdFramework | AddNode | Inserts <p pITopNode>, along with its
		children, underneath <p pIParentNode> in the Framework's Project Tree.

@comm
	If <p pIParentNode> is NULL, <p pITopNode> is inserted into the selected folder of
	the Project Tree.

	The Framework uses <om IDMUSProdNode.GetFirstChild> and <om IDMUSProdNode.GetNextChild>
	when inserting child nodes. 

@rvalue S_OK | <p pITopNode>, along with its children, was inserted successfully. 
@rvalue E_INVALIDARG | The address in <p pITopNode> is not valid.  For example, it may be NULL.
@rvalue E_FAIL | An error occurred and <p pITopNode> was not inserted into the Project Tree.

@ex The following example inserts a Style file into the active folder of the Project Tree: |

HRESULT CStyleDocType::InsertChildNode( IDMUSProdNode* pIChildNode )
{
	ASSERT( pIChildNode != NULL );
	ASSERT( m_pComponent != NULL );
	ASSERT( m_pComponent->m_pIFramework != NULL );

	// Add Style to Style component list 
	pIChildNode->AddRef();
	m_pComponent->m_lstStyles.AddTail( (CStyle *)pIChildNode );

	// Set DocRoot and parent node of ALL children
	theApp.SetNodePointers( pIChildNode, pIChildNode, (IDMUSProdNode *)this );

	// Add node to Project Tree
	if( FAILED ( m_pComponent->m_pIFramework->AddNode(pIChildNode, NULL) ) )
	{
		DeleteChildNode( pIChildNode );
		return E_FAIL;
	}

	return S_OK;
}
	
@xref <i IDMUSProdFramework>, <om IDMUSProdFramework.RemoveNode>, <i IDMUSProdNode>
--------------------------------------------------------------------------------------*/

/////////////////////////////////////////////////////////////////////////////
// CFramework::AddNode

HRESULT CFramework::AddNode(
	IDMUSProdNode* pITopNode,		// @parm [in] Pointer to the <i IDMUSProdNode> interface to be inserted.
	IDMUSProdNode* pIParentNode		// @parm [in] Pointer to the parent <i IDMUSProdNode> interface.
)
{
	AFX_MANAGE_STATE( AfxGetAppModuleState() );

	if( pITopNode == NULL )
	{
		return E_INVALIDARG;
	}

	HTREEITEM hTheParent = NULL;

	if( pIParentNode == NULL )
	{
		GUID guidNodeId;

		if( SUCCEEDED ( pITopNode->GetNodeId( &guidNodeId ) ) )
		{
			if( IsEqualGUID( guidNodeId, GUID_ProjectFolderNode ) )
			{
				hTheParent = TVI_ROOT;
			}
		}
	}
	else
	{
		hTheParent = FindTreeItem( pIParentNode );
	}

	// Don't worry about DocRoot nodes
	// DocRoot nodes are inserted during OnNewDocument() or OnOpenDocument()
	if( hTheParent == NULL )
	{
		IDMUSProdNode* pIDocRootNode;

		if( FAILED ( pITopNode->GetDocRootNode( &pIDocRootNode ) ) )
		{
			return E_FAIL;
		}
		if( pIDocRootNode )
		{
			if( pITopNode == pIDocRootNode )
			{
				pIDocRootNode->Release();
				return S_OK;
			}
			pIDocRootNode->Release();
		}
	}

	if( hTheParent )
	{
		if( AddNodes(pITopNode, hTheParent) )
		{
			CMainFrame* pMainFrame = (CMainFrame *)theApp.m_pMainWnd;
			ASSERT( pMainFrame != NULL );
			pMainFrame->m_wndTreeBar.SortChildren( hTheParent );

			if( theApp.m_fInPasteFromData )
			{
				ShowTreeNode( pITopNode );
				return S_OK;
			}

			if( pIParentNode )
			{
				GUID guidNodeId;

				if( SUCCEEDED ( pIParentNode->GetNodeId( &guidNodeId ) ) )
				{
					if( !(IsEqualGUID( guidNodeId, GUID_ProjectFolderNode ))
					&&  !(IsEqualGUID( guidNodeId, GUID_DirectoryNode ))
					&&  !(IsEqualGUID( guidNodeId, GUID_FileNode )) )
					{
						ShowTreeNode( pITopNode );
						return S_OK;
					}
				}
			}

			theApp.DrawProjectTree();
			return S_OK;
		}
	}

	return E_FAIL;
}


/*======================================================================================
METHOD:  IDMUSPRODFRAMEWORK::REMOVENODE
========================================================================================
@method HRESULT | IDMUSProdFramework | RemoveNode | Removes <p pITopNode>, along with its 
		children, from the Project Tree.

@rvalue S_OK | <p pITopNode>, along with its children, was removed successfully. 
@rvalue S_FALSE | User cancelled the delete.
@rvalue E_INVALIDARG | The address in <p pITopNode> is not valid.  For example, it may be NULL.
@rvalue E_FAIL | An error occurred and <p pITopNode> was not removed from the Project Tree.

@ex The following example removes a Style file from the Project Tree: |

HRESULT CStyleDocType::DeleteChildNode( IDMUSProdNode* pIChildNode )
{
	ASSERT( pIChildNode != NULL );
	ASSERT( m_pComponent != NULL );
	ASSERT( m_pComponent->m_pIFramework != NULL );

	// Remove from Project Tree
	if( m_pComponent->m_pIFramework->RemoveNode( pIChildNode, FALSE ) == S_FALSE )
	{
		return E_FAIL;
	}

	// Remove from Component Style list
	POSITION pos = m_pComponent->m_lstStyles.Find( (CStyle *)pIChildNode );
	if( pos )
	{
		m_pComponent->m_lstStyles.RemoveAt( pos );
		pIChildNode->Release();
	}

	return S_OK;
}
	
@xref <i IDMUSProdFramework>, <om IDMUSProdFramework.AddNode>, <i IDMUSProdNode>
--------------------------------------------------------------------------------------*/

/////////////////////////////////////////////////////////////////////////////
// CFramework::RemoveNode

HRESULT CFramework::RemoveNode(
	IDMUSProdNode* pITopNode,		// @parm [in] Pointer to the <i IDMUSProdNode> interface to be removed.
	BOOL fPromptUser				// @parm [in] Determines whether delete prompt is displayed.
)
{
	AFX_MANAGE_STATE( AfxGetAppModuleState() );

	if( pITopNode == NULL )
	{
		return E_INVALIDARG;
	}

	CTreeCtrl* pTreeCtrl = theApp.GetProjectTreeCtrl();
	HTREEITEM hTopItem = FindTreeItem( pITopNode );

	// If item is not in the Project Tree return S_OK
	if( hTopItem == NULL )
	{
		return S_OK;
	}

	// If node represents document, we want to delete its FileNode
	CComponentDoc* pComponentDoc = theApp.FindComponentDocument( pITopNode );
	if( pComponentDoc )
	{
		if( pComponentDoc->m_pIDocRootNode == pITopNode )
		{
			if( pComponentDoc->m_pFileNode )
			{
				if( fPromptUser )
				{
					if( AreYouSure( pComponentDoc->m_pFileNode ) == FALSE ) 
					{
						return S_FALSE;
					}
				}

				HRESULT hr = E_FAIL;

				// Store filename
				CString strFileName;
				pComponentDoc->m_pFileNode->ConstructFileName( strFileName );

				// Delete node
				theApp.m_fInDocRootDelete = TRUE;
				theApp.m_fDeleteFromTree = TRUE;
				if( SUCCEEDED ( pComponentDoc->m_pFileNode->DeleteNode( FALSE ) ) )
				{
					// Delete file from hard drive
					hr = theApp.DeleteFileToRecycleBin( strFileName );
					if( FAILED ( hr ) )
					{
						// Put file back in the Project Tree
						BSTR bstrFileName = strFileName.AllocSysString();
						ShowFile( bstrFileName );
					}
				}
				theApp.m_fInDocRootDelete = FALSE;
				theApp.m_fDeleteFromTree = FALSE;
				return hr;
			}
		}
	}

	if( fPromptUser )
	{
		if( AreYouSure( pITopNode ) == FALSE ) 
		{
			return S_FALSE;
		}
	}

	if( pTreeCtrl )
	{
		// See if the node we are deleting was selected
		if( pTreeCtrl->GetSelectedItem() == hTopItem )
		{
			// Highlight a sibling if at all possible
			HTREEITEM hNextItem = pTreeCtrl->GetNextItem( hTopItem, TVGN_NEXT );
			if( hNextItem == NULL )
			{
				HTREEITEM hParentItem = pTreeCtrl->GetParentItem( hTopItem );
				if( hParentItem )
				{
					hNextItem = pTreeCtrl->GetNextItem( hParentItem, TVGN_CHILD );
					if( hNextItem == hTopItem )
					{
						hNextItem = NULL;
					}
				}
			}
			if( hNextItem )
			{
				pTreeCtrl->SelectItem( hNextItem );
			}
		}
	}

	// Remove the node
	if( RemoveNodes(pITopNode) )
	{
		return S_OK;
	}

	return E_FAIL;
}


/*======================================================================================
METHOD:  IDMUSPRODFRAMEWORK::FINDDOCROOTNODE
========================================================================================
@method HRESULT | IDMUSProdFramework | FindDocRootNode | Returns an <i IDMUSProdNode> interface
		pointer for the matching DocRoot <o Node>.

@comm
	A DocRoot Node is the top Node of a file.  For more information refer to <o Node>
	Object.

	The search is confined to the <o Project> specified in <p guidProject>.

	A DocRoot Node is considered to be a match if its <o DocType> matches <p pIDocType>, 
	and its <om IDMUSProdNode::GetNodeListInfo> method returns a name and descriptor equal
	to <p bstrNodeName> and <p bstrNodeDescriptor>.

    The DocRoot Node for first file matching the criteria will be returned in <p ppIDocRootNode>.
	<om IDMUSProdFramework::GetNodeFileGuid> should be used in conjunction with
	<om IDMUSProdFramework::FindDocRootNodeByFileGUID> when it is necessary to obtain the
	DocRoot Node of a specific file.

    <p bstrNodeName> is required.  <p bstrNodeDescriptor> may be NULL.
		
@rvalue S_OK | The matching DocRoot Node was returned in <p ppIDocRootNode>. 
@rvalue E_POINTER | The address in <p ppIDocRootNode> is not valid.  For example, it may be NULL.
@rvalue E_INVALIDARG | Either <p pIDocType> or <p bstrNodeName> is not valid.  For example, they may be NULL.
@rvalue E_FAIL | An error occurred, and a DocRoot Node could not be returned.

@ex The following example: |

@xref <i IDMUSProdFramework>, <om IDMUSProdFramework.GetBestGuessDocRootNode>, <om IDMUSProdFramework::FindDocRootNodeByFileGUID>, <i IDMUSProdNode>
--------------------------------------------------------------------------------------*/

/////////////////////////////////////////////////////////////////////////////
// CFramework::FindDocRootNode

HRESULT CFramework::FindDocRootNode(
	GUID guidProject,			// @parm [in] Project GUID.
	IDMUSProdDocType* pIDocType,	// @parm [in] <o DocType> object.
	BSTR bstrNodeName,			// @parm [in] Node name.  This method frees
								//		<p bstrNodeName> with SysFreeString when it is no
								//		longer needed.
	BSTR bstrNodeDescriptor,	// @parm [in] Node descriptor.  This method frees
								//		<p bstrNodeDescriptor> with SysFreeString when it is
								//		no longer needed.
	IDMUSProdNode** ppIDocRootNode	// @parm [out,retval] Address of a variable to receive the requested  
								//		IDMUSProdNode interface.  If an error occurs, the implementation
								//		sets <p ppIDocRootNode> to NULL.  On success, the caller
								//		is responsible for calling <om IDMUSProdNode.Release>.
)
{
	AFX_MANAGE_STATE( AfxGetAppModuleState() );
	
	HRESULT hr = E_FAIL;

	CString strNodeName;
	CString strNodeDescriptor;

	if( ppIDocRootNode == NULL )
	{
		return E_POINTER;
	}

	*ppIDocRootNode = NULL;

	if( pIDocType == NULL )
	{
		return E_INVALIDARG;
	}

	// bstrNodeDescriptor is optional
	if( bstrNodeDescriptor )
	{
		strNodeDescriptor = bstrNodeDescriptor;
		::SysFreeString( bstrNodeDescriptor );
	}

	// bstrNodeName is required
	if( bstrNodeName )
	{
		strNodeName = bstrNodeName;
		::SysFreeString( bstrNodeName );
	}
	else
	{
		return E_INVALIDARG;
	}

	CFileNode* pFileNode = NULL;

	// Get Project node
	CProject* pProject = theApp.GetProjectByGUID( guidProject );
	if( pProject )
	{
		pFileNode = pProject->GetFileByText( pIDocType, strNodeName, strNodeDescriptor );

		pProject->Release();
	}

	if( pFileNode )
	{
		if( pFileNode->m_pIChildNode == NULL )
		{
			CString strFileName;
			pFileNode->ConstructFileName( strFileName );
			
			// Open the file
			theApp.m_nShowNodeInTree++;
			theApp.OpenTheFile( strFileName, TGT_FILENODE );
			theApp.m_nShowNodeInTree--;
		}

		if( pFileNode->m_pIChildNode )
		{
			pFileNode->m_pIChildNode->AddRef();
			*ppIDocRootNode = pFileNode->m_pIChildNode;
			hr = S_OK;
		}

		pFileNode->Release();
	}

	return hr;
}


/*======================================================================================
METHOD:  IDMUSPRODFRAMEWORK::FINDDOCROOTNODEBYFILEGUID
========================================================================================
@method HRESULT | IDMUSProdFramework | FindDocRootNodeByFileGUID | Returns an <i IDMUSProdNode> interface
		pointer for the matching DocRoot <o Node>.

@comm
	A DocRoot Node is the top Node of a file.  For more information refer to <o Node>
	Object.

	Producer assigns a GUID to every file in the Project Tree.  This GUID can be obtained
	via the <om IDMUSProdFramework::GetNodeFileGuid> method.  <p guidFile> refers to this 
	GUID.

	The <i IDMUSProdProject> interface provides methods to enumerate all files in a given
	Project.  The <i IDMUSProdNode> interface pointer returned by the 
	<om IDMUSProdProject::GetFirstFileByDocType> and  <om IDMUSProdProject::GetNextFileByDocType>
	methods can be passed to <om IDMUSProdFramework::GetNodeFileGuid> and used in
	conjunction with <om IDMUSProdFramework::FindDocRootNodeByFileGUID> to retrieve
	the DocRoot node for a specific file.
		
@rvalue S_OK | The matching DocRoot Node was returned in <p ppIDocRootNode>. 
@rvalue E_POINTER | The address in <p ppIDocRootNode> is not valid.  For example, it may be NULL.
@rvalue E_FAIL | An error occurred, and a DocRoot Node could not be returned.

@ex The following example retrieves the DocRoot node for the GUID returned by
	<om IDMUSProdFramework::GetNodeFileGuid>: |

	IDMUSProdFramework pIFramework;
	IDMUSProdNode* pIThisDocRootNode;
	IDMUSProdNode* pIDocRootNode;
	GUID guidFile;

	if( SUCCEEDED ( pIFramework->GetNodeFileGUID(pIThisDocRootNode, &guidFile) ) )
	{
		if( SUCCEEDED ( pIFramework->FindDocRootNodeByFileGUID(guidFile, &pIDocRootNode) ) )
		{
			ASSERT( pIDocRootNode == pIThisDocRootNode );	
		}
    }
	
@xref <i IDMUSProdFramework>, <i IDMUSProdNode>, <om IDMUSProdFramework.GetNodeFileGUID>
--------------------------------------------------------------------------------------*/

/////////////////////////////////////////////////////////////////////////////
// CFramework::FindDocRootNodeByFileGUID

HRESULT CFramework::FindDocRootNodeByFileGUID(
	GUID guidFile,				// @parm [in] File's GUID.
	IDMUSProdNode** ppIDocRootNode	// @parm [out,retval] Address of a variable to receive the requested  
								//		IDMUSProdNode interface.  If an error occurs, the implementation
								//		sets <p ppIDocRootNode> to NULL.  On success, the caller
								//		is responsible for calling <om IDMUSProdNode.Release>.
)
{
	AFX_MANAGE_STATE( AfxGetAppModuleState() );
	
	HRESULT hr = E_FAIL;

	if( ppIDocRootNode == NULL )
	{
		return E_POINTER;
	}

	*ppIDocRootNode = NULL;

	CFileNode* pFileNode = theApp.GetFileByGUID( guidFile ) ;

	if( pFileNode )
	{
		if( pFileNode->m_pIChildNode == NULL )
		{
			CString strFileName;
			pFileNode->ConstructFileName( strFileName );
			
			// Open the file
			theApp.m_nShowNodeInTree++;
			theApp.OpenTheFile( strFileName, TGT_FILENODE );
			theApp.m_nShowNodeInTree--;
		}

		if( pFileNode->m_pIChildNode )
		{
			pFileNode->m_pIChildNode->AddRef();
			*ppIDocRootNode = pFileNode->m_pIChildNode;
			hr = S_OK;
		}

		pFileNode->Release();
	}

	return hr;
}


/*======================================================================================
METHOD:  IDMUSPRODFRAMEWORK::GETBESTGUESSDOCROOTNODE
========================================================================================
@method HRESULT | IDMUSProdFramework | GetBestGuessDocRootNode | Returns an <i IDMUSProdNode>
	interface pointer for the closest matching DocRoot <o Node>.

@comm
	A DocRoot Node is the top Node of a file.  For more information refer to <o Node>
	Object.

	The search is confined to the <o Project> containing <p pITreePositionNode>.

	A DocRoot Node is considered to be a candidate for match if its <o DocType> matches
	<p pIDocType>, and its <om IDMUSProdNode::GetNodeListInfo> method returns a name equal
	to <p bstrNodeName>.

	If a matching DocRoot node cannot be located in the same directory as <p pITreePositionNode>,
	<om IDMUSProdFramework.GetBestGuessDocRootNode> searches through the entire <o Project> 
	containing <p pITreePositionNode>.  Other Projects are not searched.

	This method sets <p ppIDocRootNode> to NULL and returns S_OK when the Project Tree
	does not contain a matching node.

@rvalue S_OK | A matching DocRoot node was returned in <p ppIDocRootNode>.
@rvalue E_POINTER | The address in <p ppIDocRootNode> is not valid.  For example, it may be NULL.
@rvalue E_INVALIDARG | The address in either <p pIDocType>, <p bstrNodeName> or
		<p pITreePositionNode> is not valid.  For example, it may be NULL.
@rvalue E_PENDING | A matching DocRoot node is in the process of loading and could not be returned.
@rvalue E_FAIL | An error occurred, and a matching node could not be returned.

@ex The following example:|

@xref <i IDMUSProdFramework>, <om IDMUSProdFramework.FindDocRootNode>, <i IDMUSProdNode>
--------------------------------------------------------------------------------------*/

/////////////////////////////////////////////////////////////////////////////
// CFramework::GetBestGuessDocRootNode

HRESULT CFramework::GetBestGuessDocRootNode(
	IDMUSProdDocType* pIDocType,	// @parm [in] Pointer to the <i IDMUSProdDocType> interface
									//		associated with the desired type of DocRoot node.
									//		Used by search algorithm.
	BSTR bstrNodeName,				// @parm [in] Name of desired DocRoot node.  Used by search
									//		algorithm.  This method frees <p bstrNodeName> with
									//		SysFreeString when it is no longer needed.
	IDMUSProdNode* pITreePositionNode,	// @parm [in] Specifies position in Project Tree.  Used by search
									//		algorithm.
	IDMUSProdNode** ppIDocRootNode	// @parm [out,retval] Address of a variable to receive the requested  
									//		<i IDMUSProdNode> interface.  If an error occurs, the implementation
									//		sets <p ppIDocRootNode> to NULL.  On success, the caller
									//		is responsible for calling <om IDMUSProdNode.Release> when
									//		this pointer is no longer needed.
)
{
	AFX_MANAGE_STATE( AfxGetAppModuleState() );

	CString strNodeName;

	// Validate ppIDocRootNode
	ASSERT( ppIDocRootNode != NULL );
	if( ppIDocRootNode == NULL )
	{
		return E_POINTER;
	}

	*ppIDocRootNode = NULL;

	// Validate bstrNodeName
	if( bstrNodeName == NULL )
	{
		return E_INVALIDARG;
	}
	else
	{
		strNodeName = bstrNodeName;
		::SysFreeString( bstrNodeName );
	}

	// Validate pIDocType and pITreePositionNode
	if( pIDocType == NULL
	||  pITreePositionNode == NULL )
	{
		return E_INVALIDARG;
	}

	HRESULT hr = E_FAIL;

	// Does DocRoot exist in a container that is just now being unpacked?
	IDMUSProdComponent* pIComponent;
	if( SUCCEEDED ( FindComponent( CLSID_ContainerComponent,  &pIComponent ) ) )
	{
		IDMUSProdUnpackingFiles* pIUnpackingFiles;
		if( SUCCEEDED ( pIComponent->QueryInterface( IID_IDMUSProdUnpackingFiles, (void **)&pIUnpackingFiles ) ) )
		{
			BSTR bstrName = strNodeName.AllocSysString();

			IUnknown* pIUnknown;
			hr = pIUnpackingFiles->GetDocRootOfEmbeddedFile( pIDocType, bstrName, &pIUnknown );
			if( SUCCEEDED ( hr ) )
			{
				if( FAILED ( pIUnknown->QueryInterface( IID_IDMUSProdNode, (void **)ppIDocRootNode ) ) )
				{
					hr = E_FAIL;
				}
				
				pIUnknown->Release();
			}

			pIUnpackingFiles->Release();
		}

		pIComponent->Release();
	}
	if( SUCCEEDED(hr)
	||  hr == E_PENDING )
	{
		// The file is in a Container that is being unpacked, exit now
		return hr;
	}

	// Does DocRoot exist in a Song that is just now being unpacked?
	/*
	if( SUCCEEDED ( FindComponent( CLSID_SongComponent,  &pIComponent ) ) )
	{
		IDMUSProdUnpackingFiles* pIUnpackingFiles;
		if( SUCCEEDED ( pIComponent->QueryInterface( IID_IDMUSProdUnpackingFiles, (void **)&pIUnpackingFiles ) ) )
		{
			BSTR bstrName = strNodeName.AllocSysString();

			IUnknown* pIUnknown;
			hr = pIUnpackingFiles->GetDocRootOfEmbeddedFile( pIDocType, bstrName, &pIUnknown );
			if( SUCCEEDED ( hr ) )
			{
				if( FAILED ( pIUnknown->QueryInterface( IID_IDMUSProdNode, (void **)ppIDocRootNode ) ) )
				{
					hr = E_FAIL;
				}
				
				pIUnknown->Release();
			}

			pIUnpackingFiles->Release();
		}

		pIComponent->Release();
	}
	if( SUCCEEDED(hr)
	||  hr == E_PENDING )
	{
		// The file is in a Song that is being unpacked, exit now
		return hr;
	}
	*/

	// Does DocRoot exist in list if files waiting to be opened?
	POSITION pos = theApp.m_lstFileNamesToOpen.GetHeadPosition();
	while( pos )
	{
		CJzFileName* pJzFileName = theApp.m_lstFileNamesToOpen.GetNext( pos );

		if( pJzFileName->m_fBeingLoaded == true )
		{
			// Must handle this case further down (via it's existing CFileNode)
			continue;
		}

		IDMUSProdDocType* pIDocTypeList = theApp.GetDocType( pJzFileName->m_strFileName );
		if( pIDocTypeList )
		{
			if( pIDocTypeList == pIDocType )
			{
				if( strNodeName.Compare(pJzFileName->m_strObjectName) == 0 )
				{
					// Open the file
					theApp.m_nShowNodeInTree++;
					pJzFileName->m_fBeingLoaded = true;
					theApp.OpenDocumentFile( pJzFileName->m_strFileName );
					theApp.m_nShowNodeInTree--;

					// Find the DocRoot
					CFileNode* pFileNode = theApp.FindFileNode( pJzFileName->m_strFileName );
					if( pFileNode )
					{
						if( pFileNode->m_pIChildNode )
						{
							pFileNode->m_pIChildNode->AddRef();
							*ppIDocRootNode = pFileNode->m_pIChildNode;
							hr = S_OK;
						}

						pFileNode->Release();
					}

					pIDocTypeList->Release();
					break;
				}
			}

			pIDocTypeList->Release();
		}
	}
	if( SUCCEEDED(hr) )
	{
		// The file is in the list of files waiting to be opened
		return hr;
	}

	// The file is not in a Container, a Song or the list of file waiting to be opened
	hr = S_OK;

	// Get the Project
	IDMUSProdProject* pIProject;
	if( SUCCEEDED ( theApp.m_pFramework->FindProject( pITreePositionNode, &pIProject ) ) )
	{
		CProject* pProject = (CProject *)pIProject;

		CFileNode* pFileNode = NULL;

		// Look for an appropriate FileNode
		pFileNode = pProject->GetBestGuessDocRootNode( pIDocType, strNodeName, pITreePositionNode );

		if( pFileNode )
		{
			// Make sure the FileNode's file is loaded
			if( pFileNode->m_pIChildNode == NULL )
			{
				if( pFileNode->m_fInOnOpenDocument )
				{
					hr = E_PENDING;
				}
				else
				{
					CString strFileName;
					pFileNode->ConstructFileName( strFileName );
					
					// Open the file
					theApp.m_nShowNodeInTree++;
					theApp.OpenTheFile( strFileName, TGT_FILENODE );
					theApp.m_nShowNodeInTree--;
				}
			}

			if( pFileNode->m_pIChildNode )
			{
				pFileNode->m_pIChildNode->AddRef();
				*ppIDocRootNode = pFileNode->m_pIChildNode;
			}

			pFileNode->Release();
		}

		pIProject->Release();
	}

	return hr;
}


/*======================================================================================
METHOD:  IDMUSPRODFRAMEWORK::GETSELECTEDNODE
========================================================================================
@method HRESULT | IDMUSProdFramework | GetSelectedNode | Returns the Project Tree's currently
	selected <o Node>.

@comm
	<om IDMUSProdFramework.GetSelectedNode> sets <p ppINode> to NULL and returns S_OK when 
	either the Project Tree is empty or none of its nodes are selected.

@rvalue S_OK | The Project Tree's selected node was returned in <p ppINode>.
@rvalue E_POINTER | The address in <p ppINode> is not valid.  For example, it may be NULL.
@rvalue E_FAIL | An error occurred, and the selected node could not be returned.

@ex The following example obtains the active node of the Project Tree:|

	IDMUSProdNode* pINode;

	if( SUCCEEDED ( pIFramework->GetSelectedNode( &pINode ) ) )
	{
		if( pINode )
		{
			...
			...
			...
			pINode->Release();
		}
	}

@xref <i IDMUSProdFramework>
--------------------------------------------------------------------------------------*/

/////////////////////////////////////////////////////////////////////////////
// CFramework::GetSelectedNode

HRESULT CFramework::GetSelectedNode(
	IDMUSProdNode** ppINode	// @parm [out,retval] Address of a variable to receive the requested  
							//		<i IDMUSProdNode> interface.  If an error occurs, the implementation
							//		sets <p ppINode> to NULL.  On success, the caller
							//		is responsible for calling <om IDMUSProdNode.Release>
							//		when this pointer is no longer needed.
)
{
	AFX_MANAGE_STATE( AfxGetAppModuleState() );

	if( ppINode == NULL )
	{
		return E_POINTER;
	}

	*ppINode = NULL;

	CTreeCtrl* pTreeCtrl = theApp.GetProjectTreeCtrl();
	if( pTreeCtrl )
	{
		HTREEITEM hItem = pTreeCtrl->GetSelectedItem();
		if( hItem )
		{
			CJzNode* pJzNode = (CJzNode *)pTreeCtrl->GetItemData( hItem );
			if( pJzNode )
			{
				pJzNode->m_pINode->AddRef();
				*ppINode = pJzNode->m_pINode;
			}
		}

		return S_OK;
	}

	return E_FAIL;
}


/////////////////////////////////////////////////////////////////////////////
// CFramework::SyncEditorTitles

void CFramework::SyncEditorTitles( IDMUSProdNode* pINode )
{
	HWND hWndEditor;
	CWnd* pWndEditor;

	ASSERT( pINode != NULL );

	CComponentDoc * pComponentDoc = (CComponentDoc *)theApp.FindDocument( pINode );
	if( pComponentDoc )
	{
		ASSERT_VALID( pComponentDoc );

		if( pComponentDoc->IsKindOf( RUNTIME_CLASS(CComponentDoc) ) )
		{
			POSITION pos = pComponentDoc->GetFirstViewPosition();
			while( pos )
			{
				CComponentView * pComponentView = (CComponentView *)pComponentDoc->GetNextView( pos );
				ASSERT_VALID( pComponentView );

				if( pComponentView->m_pINode )
				{
					if( SUCCEEDED ( pComponentView->m_pINode->GetEditorWindow(&hWndEditor) ) )
					{
						if( hWndEditor )
						{
							pWndEditor = CWnd::FromHandlePermanent( hWndEditor );
							if( pWndEditor )
							{
								BSTR bstrTitle;

								pComponentView->m_pINode->GetEditorTitle( &bstrTitle );
								pWndEditor->SetWindowText(  CString(bstrTitle) );
								::SysFreeString( bstrTitle );
							}
						}
					}
				}
			}
		}
	}
}


/////////////////////////////////////////////////////////////////////////////
// CFramework::SyncNodeName

HRESULT CFramework::SyncNodeName( IDMUSProdNode* pINode, BOOL fRedraw )
{
	ASSERT( pINode != NULL );
	if( pINode == NULL )
	{
		return E_INVALIDARG;
	}

	BSTR bstrNodeName;
	CString strNodeName;

	if( SUCCEEDED ( pINode->GetNodeName(&bstrNodeName) ) )
	{
		strNodeName = bstrNodeName;
		::SysFreeString( bstrNodeName );
	}

	// Update Project Tree
	HTREEITEM hItem = FindTreeItem( pINode );
	if( hItem )
	{
		CTreeCtrl* pTreeCtrl = theApp.GetProjectTreeCtrl();
		if( pTreeCtrl )
		{
			// Update label in the Project Tree
			pTreeCtrl->SetItemText( hItem, strNodeName );
			if( fRedraw )
			{
				pTreeCtrl->UpdateWindow();
			}
		}
	}

	// Set Document Title
	CCommonDoc* pCommonDoc = theApp.FindDocument( pINode );
	if( pCommonDoc
	&&  pCommonDoc->m_pIDocRootNode == pINode )
	{
		CString strPathName = pCommonDoc->GetPathName();
		if( strPathName.IsEmpty() )
		{
			pCommonDoc->SetTitle( strNodeName );
		}
	}

	// Set Window Titles
	SyncEditorTitles( pINode );

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CFramework::SyncNodeIcon

HRESULT CFramework::SyncNodeIcon( IDMUSProdNode* pINode, BOOL fRedraw )
{
	ASSERT( pINode != NULL );
	if( pINode == NULL )
	{
		return E_INVALIDARG;
	}

	short nImage;
    if( SUCCEEDED ( pINode->GetNodeImageIndex( &nImage ) ) )
	{
		// Find node in Project Tree
		HTREEITEM hItem = FindTreeItem( pINode );
		if( hItem )
		{
			CTreeCtrl* pTreeCtrl = theApp.GetProjectTreeCtrl();
			if( pTreeCtrl )
			{
				BOOL fUseOpenCloseImages = FALSE;

				// Update icon in the Project Tree
				pINode->UseOpenCloseImages( &fUseOpenCloseImages );
				if( fUseOpenCloseImages == TRUE )
				{
					pTreeCtrl->SetItemImage( hItem, nImage, nImage );
				}
				else
				{
					pTreeCtrl->SetItemImage( hItem, nImage, nImage + 1 );
				}

				if( fRedraw )
				{
					pTreeCtrl->UpdateWindow();
				}
			}
		}
	}

	return S_OK;
}


/*======================================================================================
METHOD:  IDMUSPRODFRAMEWORK::SETSELECTEDNODE
========================================================================================
@method HRESULT | IDMUSProdFramework | SetSelectedNode | Highlights the Project Tree node
		associated with <p pINode>.

@comm
	The Project Tree does not scroll to make sure that the selected item is visible.

	<om IDMUSProdNode.OnNodeSelChanged> gets invoked after calling this method.

@rvalue S_OK | <p pINode> was highlighted successfully. 
@rvalue E_INVALIDARG | The address in <p pINode> is not valid.  For example, it may be NULL.
@rvalue E_FAIL | An error occurred and <p pINode> could not be highlighted.

@xref <i IDMUSProdFramework>, <i IDMUSProdNode>
--------------------------------------------------------------------------------------*/

/////////////////////////////////////////////////////////////////////////////
// CFramework::SetSelectedNode

HRESULT CFramework::SetSelectedNode(
	IDMUSProdNode* pINode		// @parm [in] Pointer to an <i IDMUSProdNode> interface.
)
{
	AFX_MANAGE_STATE( AfxGetAppModuleState() );

	if( pINode == NULL )
	{
		return E_INVALIDARG;
	}

	if( ShowTreeNode( pINode ) )
	{
		return S_OK;
	}

	return E_FAIL;
}


/*======================================================================================
METHOD:  IDMUSPRODFRAMEWORK::REFRESHNODE
========================================================================================
@method HRESULT | IDMUSProdFramework | RefreshNode | Refreshes and redraws the Project Tree
	node associated with <p pINode>.

@comm
	This method calls <om IDMUSProdNode.GetNodeName> before updating the Project Tree with
	new label text for <p pINode>.

	This method calls <om IDMUSProdNode.GetNodeImageIndex> before updating the Project Tree
	with a new icon for <p pINode>.

@rvalue S_OK | <p pINode> was refreshed successfully. 
@rvalue E_INVALIDARG | The address in <p pINode> is not valid.  For example, it may be NULL.
@rvalue E_FAIL | An error occurred and <p pINode> could not be refreshed.

@xref <i IDMUSProdFramework>, <i IDMUSProdNode>
--------------------------------------------------------------------------------------*/

/////////////////////////////////////////////////////////////////////////////
// CFramework::RefreshNode

HRESULT CFramework::RefreshNode(
	IDMUSProdNode* pINode		// @parm [in] Pointer to an <i IDMUSProdNode> interface.
)
{
	AFX_MANAGE_STATE( AfxGetAppModuleState() );

	if( pINode == NULL )
	{
		return E_INVALIDARG;
	}

	SyncNodeName( pINode, FALSE );
	SyncNodeIcon( pINode, TRUE );

	return S_OK;
}


/*======================================================================================
METHOD:  IDMUSPRODFRAMEWORK::SORTCHILDNODES
========================================================================================
@method HRESULT | IDMUSProdFramework | SortChildNodes | Sorts the Project Tree child
		<o Node>s associated with <p pINode>.


@rvalue S_OK | The child nodes of <p pINode> were sorted successfully. 
@rvalue E_INVALIDARG | The address in <p pINode> is not valid.  For example, it may be NULL.
@rvalue E_FAIL | An error occurred and the Project Tree could not be sorted.

@xref <i IDMUSProdFramework>, <i IDMUSProdNode>
--------------------------------------------------------------------------------------*/

/////////////////////////////////////////////////////////////////////////////
// CFramework::SortChildNodes

HRESULT CFramework::SortChildNodes(
	IDMUSProdNode* pINode		// @parm [in] Pointer to an <i IDMUSProdNode> interface.
)
{
	AFX_MANAGE_STATE( AfxGetAppModuleState() );

	if( pINode == NULL )
	{
		return E_INVALIDARG;
	}

	HTREEITEM hItem = FindTreeItem( pINode );
	if( hItem )
	{
		CMainFrame* pMainFrame = (CMainFrame *)theApp.m_pMainWnd;
		ASSERT( pMainFrame != NULL );
		pMainFrame->m_wndTreeBar.SortChildren( hItem );
		return S_OK;
	}

	return E_FAIL;
}


/*======================================================================================
METHOD:  IDMUSPRODFRAMEWORK::EDITNODELABEL
========================================================================================
@method HRESULT | IDMUSProdFramework | EditNodeLabel | Begins in-place editing of the label
		associated with <p pINode>.

@comm
	This method provides the means for a Component to initiate in-place editing of the
	node names in the Project Tree.  For example, it allows the right-click context menu
	associated with a node to contain a menu item for renaming itself.

@rvalue S_OK | In-place editing of the node's label began successfully. 
@rvalue E_INVALIDARG | The address in <p pINode> is not valid.  For example, it may be NULL.
@rvalue E_FAIL | In-place editing of the node's label could not begin.

@ex The following example initiates in-place editing of a node's label: |

HRESULT CMotif::OnRightClickMenuSelect( long lCommandId )
{
	ASSERT( m_pComponent != NULL );
	ASSERT( m_pComponent->m_pIFramework != NULL );

	HRESULT hr = E_FAIL;

	switch( lCommandId )
	{
		case IDM_RENAME:
			if( SUCCEEDED ( m_pComponent->m_pIFramework->EditNodeLabel((IDMUSProdNode *)this) ) )
			{
				hr = S_OK;
			}
			break;
	}

	return hr;
}
	
@xref <i IDMUSProdFramework>, <i IDMUSProdNode>, <om IDMUSProdNode.GetNodeNameMaxLength>, <om IDMUSProdNode.ValidateNodeName>, <om IDMUSProdNode.SetNodeName>
--------------------------------------------------------------------------------------*/

/////////////////////////////////////////////////////////////////////////////
// CFramework::EditNodeLabel

HRESULT CFramework::EditNodeLabel(
	IDMUSProdNode* pINode		// @parm [in] Pointer to the <i IDMUSProdNode> interface.
)
{
	AFX_MANAGE_STATE( AfxGetAppModuleState() );

	if( pINode == NULL )
	{
		return E_INVALIDARG;
	}

	HTREEITEM hItem = FindTreeItem( pINode );

	if( hItem )
	{
		CTreeCtrl* pTreeCtrl = theApp.GetProjectTreeCtrl();
		if( pTreeCtrl )
		{
			pTreeCtrl->EnsureVisible( hItem );
			pTreeCtrl->SelectItem( hItem );
			if( pTreeCtrl->EditLabel(hItem) )
			{
				return S_OK;
			}
		}
	}

	return E_FAIL;
}


/*======================================================================================
METHOD:  IDMUSPRODFRAMEWORK::OPENEDITOR
========================================================================================
@method HRESULT | IDMUSProdFramework | OpenEditor | Opens an editor for the node specified
		in <p pINode>.

@comm
	This method provides the means for a Component to initiate in-place editing for a
	node in the Project Tree.  

@rvalue S_OK | An editor was successfully opened for <p pINode>. 
@rvalue E_INVALIDARG | The address in <p pINode> is not valid.  For example, it may be NULL.
@rvalue E_FAIL | An error occurred, and the editor could not be opened.

@ex The following example opens an editor for <p pINode>: |

@xref <o Editor> Object, <i IDMUSProdFramework>, <om IDMUSProdFramework.CloseEditor>, <i IDMUSProdNode>, <i IDMUSProdEditor>
--------------------------------------------------------------------------------------*/

/////////////////////////////////////////////////////////////////////////////
// CFramework::OpenEditor

HRESULT CFramework::OpenEditor(
	IDMUSProdNode* pINode		// @parm [in] Pointer to the <i IDMUSProdNode> interface.
)
{
	AFX_MANAGE_STATE( AfxGetAppModuleState() );

	if( pINode == NULL )
	{
		return E_INVALIDARG;
	}

	HRESULT hr = E_FAIL;

	// If reference node, use document of referenced file
	IDMUSProdReferenceNode* pIReferenceNode;
	if( SUCCEEDED ( pINode->QueryInterface( IID_IDMUSProdReferenceNode, (void **)&pIReferenceNode ) ) )
	{
		IDMUSProdNode* pIDocRootNode;
		if( SUCCEEDED ( pIReferenceNode->GetReferencedFile( &pIDocRootNode ) ) )
		{
			if( pIDocRootNode )
			{
				CComponentDoc* pComponentDoc = theApp.FindComponentDocument( pIDocRootNode );
				if( pComponentDoc )
				{
					pComponentDoc->OpenEditorWindow( pIDocRootNode );
					hr = S_OK;
				}

				pIDocRootNode->Release();
			}
		}

		pIReferenceNode->Release();
	}
	else
	{
		CComponentDoc* pComponentDoc = theApp.FindComponentDocument( pINode );
		if( pComponentDoc )
		{
			pComponentDoc->OpenEditorWindow( pINode );
			hr = S_OK;
		}
	}

	return hr;
}


/*======================================================================================
METHOD:  IDMUSPRODFRAMEWORK::CLOSEEDITOR
========================================================================================
@method HRESULT | IDMUSProdFramework | CloseEditor | Closes the editor for the node
		specified in <p pINode>.

@comm
	This method provides the means for a Component to close an editor opened by 
	the <om IDMUSProdFramework.OpenEditor> method.

@rvalue S_OK | <p pINode>'s editor was closed successfully. 
@rvalue E_INVALIDARG | The address in <p pINode> is not valid.  For example, it may be NULL.
@rvalue E_FAIL | An error occurred, and the editor could not be closed.

@ex The following example closes the editor for <p pINode>: |

@xref <o Editor> Object, <i IDMUSProdFramework>, <om IDMUSProdFramework.OpenEditor>, <i IDMUSProdNode>, <i IDMUSProdEditor>
--------------------------------------------------------------------------------------*/

/////////////////////////////////////////////////////////////////////////////
// CFramework::CloseEditor

HRESULT CFramework::CloseEditor(
	IDMUSProdNode* pINode		// @parm [in] Pointer to the <i IDMUSProdNode> interface.
)
{
	AFX_MANAGE_STATE( AfxGetAppModuleState() );

	if( pINode == NULL )
	{
		return E_INVALIDARG;
	}

	CDocTemplate* pTemplate;
	CComponentDoc* pDocument;

	// no doc manager - no templates
	if( theApp.m_pDocManager )
	{
		// walk all templates in the application
		POSITION pos = theApp.m_pDocManager->GetFirstDocTemplatePosition();
		while( pos )
		{
			pTemplate = theApp.m_pDocManager->GetNextDocTemplate( pos );
			ASSERT_VALID( pTemplate );
			ASSERT_KINDOF( CDocTemplate, pTemplate );

			// walk all documents in the template
			POSITION pos2 = pTemplate->GetFirstDocPosition();
			while( pos2 )
			{
				pDocument = (CComponentDoc *)pTemplate->GetNextDoc( pos2 );
				ASSERT_VALID( pDocument );

				if( pDocument->IsKindOf( RUNTIME_CLASS(CComponentDoc) ) )
				{
					if( pDocument->CloseViewsByNode( pINode ) )
					{
						pos = NULL;
						pos2 = NULL;
					}
				}
			}
		}
	}

	return S_OK;
}


/*======================================================================================
METHOD:  IDMUSPRODFRAMEWORK::ADDMENUITEM
========================================================================================
@method HRESULT | IDMUSProdFramework | AddMenuItem | Adds the <o Menu> object defined by
		<p pIMenu> to the Framework's 'Add-Ins' menu. 

@comm
	<om IDMUSProdFramework.AddMenuItem> provides a way for a Component, that otherwise
	has no UI, to hook into the Framework.  For example, a Component may want to place a
	menu item in the Framework's 'Add-Ins' menu to provide a dialog that can be used to setup
	various options.

	A Component's <om IDMUSProdComponent.Initialize> method should call
	<om IDMUSProdFramework.AddMenuItem> if it wants to add menu item(s) to the Framework's
	'Add-Ins' menu.  <om IDMUSProdFramework.RemoveMenuItem> should be called from within
	<om IDMUSProdComponent.CleanUp>.

@rvalue S_OK | <p pIMenu> was successfully added to the Framework's 'Add-Ins' menu. 
@rvalue E_INVALIDARG | <p pIMenu> is not valid.  For example, it may be NULL.
@rvalue E_FAIL | <p pIMenu> was not added to the 'Add-Ins' menu. 
@rvalue E_OUTOFMEMORY | Out of memory. 

@ex The following excerpt from an <om IDMUSProdComponent.Initialize> method adds an
	item to the Framework's 'Add-Ins' menu: |

	if( FAILED ( m_pIFramework->AddMenuItem( (IDMUSProdMenu *)this ) ) )
	{
		CleanUp();
		::LoadString( theApp.m_hInstance, IDS_ERR_ADD_MENUITEM, achErrMsg, MID_BUFFER );
		strErrMsg = achErrMsg;
		*pbstrErrMsg = strErrMsg.AllocSysString();
		return E_FAIL;
	}
	else
	{
		m_fMenuWasAdded = TRUE;
	}
	
@xref <o Menu> Object, <i IDMUSProdFramework>, <om IDMUSProdFramework.RemoveMenuItem>, <i IDMUSProdMenu>
--------------------------------------------------------------------------------------*/

/////////////////////////////////////////////////////////////////////////////
// CFramework::AddMenuItem

HRESULT CFramework::AddMenuItem(
	IDMUSProdMenu* pIMenu		// @parm [in] Pointer to the <i IDMUSProdMenu> interface to be added.
)
{
	AFX_MANAGE_STATE( AfxGetAppModuleState() );

	if( pIMenu == NULL )
	{
		return E_INVALIDARG;
	}

	CMenu* pAddInsMenu = theApp.FindMenuByName( IDS_ADDINS_MENU_TEXT );
	if( pAddInsMenu == NULL )
	{
		return E_FAIL;
	}
	
	CJzMenu* pJzMenu = new CJzMenu( pIMenu, ++m_nNextMenuID ); 
	if( pJzMenu == NULL )
	{
		return E_OUTOFMEMORY;
	}

	CString strMenuText;
	BSTR bstrMenuText;

	pJzMenu->m_pIMenu->GetMenuText( &bstrMenuText );
	strMenuText = bstrMenuText;
	::SysFreeString( bstrMenuText );

	pAddInsMenu->InsertMenu( 0, MF_BYPOSITION | MF_STRING, pJzMenu->m_nCommandID, strMenuText ); 

	m_lstMenus.AddTail( pJzMenu );

	return S_OK;
}


/*======================================================================================
METHOD:  IDMUSPRODFRAMEWORK::REMOVEMENUITEM
========================================================================================
@method HRESULT | IDMUSProdFramework | RemoveMenuItem | Removes the menu item defined
		by <p pIMenu> from the Framework's 'Add-Ins' menu. 

@comm
	A Component's <om IDMUSProdComponent.Initialize> method should call
	<om IDMUSProdFramework.AddMenuItem> if it wants to add menu item(s) to the Framework's
	'Add-Ins' menu.  <om IDMUSProdFramework.RemoveMenuItem> should be called from within
	<om IDMUSProdComponent.CleanUp>.

@rvalue S_OK | <p pIMenu> was successfully removed from the Framework's 'Add-Ins' menu. 
@rvalue E_INVALIDARG | <p pIMenu> is not valid.  For example, it may be NULL.
@rvalue E_FAIL | <p pIMenu> was not removed from the 'Add-Ins' menu. 

@ex The following excerpt from an <om IDMUSProdComponent.Cleanup> method removes an
	item from the Framework's 'Add-Ins' menu: |

	if( m_fMenuWasAdded )
	{
		m_pIFramework->RemoveMenuItem( (IDMUSProdMenu *)this ); 
		m_fMenuWasAdded = FALSE;
	}
	
@xref <i IDMUSProdFramework>, <om IDMUSProdFramework.AddMenuItem>, <i IDMUSProdMenu>
--------------------------------------------------------------------------------------*/

/////////////////////////////////////////////////////////////////////////////
// CFramework::RemoveMenuItem

HRESULT CFramework::RemoveMenuItem(
	IDMUSProdMenu* pIMenu		// @parm [in] Pointer to the <i IDMUSProdMenu> interface to be removed.

)
{
	CJzMenu* pJzMenu;

	AFX_MANAGE_STATE( AfxGetAppModuleState() );

	if( pIMenu == NULL )
	{
		return E_INVALIDARG;
	}

	POSITION pos = m_lstMenus.GetHeadPosition();

    while( pos != NULL )
    {
        pJzMenu = static_cast<CJzMenu*>( m_lstMenus.GetNext(pos) );
		if( pJzMenu )
		{
			if( pJzMenu->m_pIMenu == pIMenu )
			{
				pos = m_lstMenus.Find( pJzMenu );
				if( pos )
				{
					m_lstMenus.RemoveAt( pos );
				}

				CMenu* pAddInsMenu = theApp.FindMenuByName( IDS_ADDINS_MENU_TEXT );
				if( pAddInsMenu )
				{
					pAddInsMenu->RemoveMenu( pJzMenu->m_nCommandID, MF_BYCOMMAND );
				}

				delete pJzMenu;
				return S_OK;
			}
		}
    }

	return E_FAIL;
}


/*======================================================================================
METHOD:  IDMUSPRODFRAMEWORK::ADDTOOLBAR
========================================================================================
@method HRESULT | IDMUSProdFramework | AddToolBar| Adds the <o ToolBar> object defined by
		<p pIToolBar> to the Framework.

@comm
	<om IDMUSProdFramework.AddToolBar> provides a way for a <o Component> to place a toolbar in
	the Framework so that it can be accessed by other Components.  For example, a Component
	may want to provide transport controls for other DirectMusic Producer Components. 

	A Component's <om IDMUSProdComponent.Initialize> method should call
	<om IDMUSProdFramework.AddToolBar> if it wants to add toolbar(s) to the Framework.
	<om IDMUSProdFramework.RemoveToolBar> should be called from within
	<om IDMUSProdComponent.CleanUp>.

@rvalue S_OK | <p pIToolBar> was successfully added to the Framework. 
@rvalue E_INVALIDARG | <p pIToolBar> is not valid.  For example, it may be NULL.
@rvalue E_FAIL | <p pIToolBar> was not added to the Framework. 
@rvalue E_OUTOFMEMORY | Out of memory. 

@ex The following excerpt from an <om IDMUSProdComponent.Initialize> method adds a toolbar
	to the Framework: |

	CWnd* pWndParent = new CWnd;
	if( pWndParent )
	{
		if( pWndParent->CreateEx(0, AfxRegisterWndClass(0), NULL, WS_OVERLAPPED, 0, 0, 0, 0, NULL, NULL) )
		{
			CToolbarMsgHandler* pBarMsgHandler = new CToolbarMsgHandler;
			if( pBarMsgHandler )
			{
				CRect rect( 0, 0, 0, 0 );
				if( (pBarMsgHandler->Create(AfxRegisterWndClass(0), NULL, WS_CHILD, rect, pWndParent, -1))
				&&  (SUCCEEDED(pIFramework->AddToolBar(pBarMsgHandler))) )
				{
					m_pBarMsgHandler = pBarMsgHandler;
				}
				else
				{
					if( pBarMsgHandler->GetSafeHwnd() )
					{
						pBarMsgHandler->DestroyWindow();
					}
					delete pBarMsgHandler;
				}
			}
		}

		//  IDMUSProdFramework::AddToolBar reassigns parent so it is ok to destroy pWndParent
		if( pWndParent->GetSafeHwnd() )
		{
			pWndParent->DestroyWindow();
			delete pWndParent;
		}
	}
	
@xref <o ToolBar> Object, <i IDMUSProdFramework>, <om IDMUSProdFramework.RemoveToolBar>, <i IDMUSProdToolBar>
--------------------------------------------------------------------------------------*/

/////////////////////////////////////////////////////////////////////////////
// CFramework::AddToolBar

HRESULT CFramework::AddToolBar(
	IDMUSProdToolBar* pIToolBar		// @parm [in] Pointer to the <i IDMUSProdToolBar> interface to be added.
)
{
	AFX_MANAGE_STATE( AfxGetAppModuleState() );

	if( pIToolBar == NULL )
	{
		return E_INVALIDARG;
	}

	CJzToolBar* pJzToolBar = new CJzToolBar; 
	if( pJzToolBar == NULL )
	{
		return E_OUTOFMEMORY;
	}

	pJzToolBar->m_pClientToolBar = new CClientToolBar( pIToolBar ); 
	if( pJzToolBar->m_pClientToolBar == NULL )
	{
		delete pJzToolBar;
		return E_OUTOFMEMORY;
	}

	HRESULT hr = E_FAIL;

	HWND hWndOwner;
	HINSTANCE hInstance;
	UINT nResourceId = -1;
	BSTR bstrTitle = NULL;
	CString strTitle;
	
	if( SUCCEEDED ( pIToolBar->GetInfo( &hWndOwner, &hInstance, &nResourceId, &bstrTitle ) ) )
	{
		ASSERT( hInstance != NULL );
		ASSERT( hWndOwner != NULL );
		ASSERT( GetWindowLong(hWndOwner, GWL_STYLE) & WS_CHILD );

		if( (hInstance != NULL)
		&&  (hWndOwner != NULL)
		&&  (GetWindowLong(hWndOwner, GWL_STYLE) & WS_CHILD) )
		{
			HINSTANCE hInstanceOld; 

			CMainFrame* pMainFrame = (CMainFrame *)theApp.m_pMainWnd;
			ASSERT( pMainFrame != NULL );

			if( bstrTitle )
			{
				strTitle = bstrTitle;
				::SysFreeString( bstrTitle );
			}

			pJzToolBar->m_pClientToolBar->m_hInstance = hInstance;
			pJzToolBar->m_nControlID = m_nNextToolBarID++;

			hInstanceOld = AfxGetResourceHandle();
			AfxSetResourceHandle( pJzToolBar->m_pClientToolBar->m_hInstance );

			if( pJzToolBar->m_pClientToolBar->Create(pMainFrame, WS_CHILD | WS_VISIBLE | CBRS_TOP, pJzToolBar->m_nControlID) )
			{
				if( nResourceId != -1 )
				{
					pJzToolBar->m_pClientToolBar->LoadToolBar( nResourceId );
				}
				pJzToolBar->m_pClientToolBar->ModifyStyle( 0, (WS_CLIPCHILDREN | TBSTYLE_FLAT), 0 );
				pJzToolBar->m_pClientToolBar->SetBarStyle( pJzToolBar->m_pClientToolBar->GetBarStyle() |
														   CBRS_TOOLTIPS | CBRS_FLYBY | CBRS_SIZE_DYNAMIC );
//														   CBRS_TOOLTIPS | CBRS_FLYBY | CBRS_SIZE_FIXED );
				pJzToolBar->m_pClientToolBar->SetWindowText( strTitle );

				pIToolBar->Initialize( pJzToolBar->m_pClientToolBar->GetSafeHwnd() );

				::SetParent( hWndOwner, pMainFrame->GetSafeHwnd() );

				pJzToolBar->m_pClientToolBar->SendMessage( TB_SETPARENT, (WPARAM)hWndOwner, 0 );
				pJzToolBar->m_pClientToolBar->m_hWndOwner = hWndOwner;

				pJzToolBar->m_pClientToolBar->EnableDocking( CBRS_ALIGN_TOP | CBRS_ALIGN_BOTTOM );
				pMainFrame->DockControlBar( pJzToolBar->m_pClientToolBar );

				InsertViewMenuItem( pJzToolBar ); 
				m_lstToolBars.AddTail( pJzToolBar );

				hr = S_OK;
			}

			AfxSetResourceHandle( hInstanceOld );
		}
	}

	if( FAILED(hr) )
	{
		delete pJzToolBar;
	}

	return hr;
}


/*======================================================================================
METHOD:  IDMUSPRODFRAMEWORK::REMOVETOOLBAR
========================================================================================
@method HRESULT | IDMUSProdFramework | RemoveToolBar | Removes the <o ToolBar> defined by
		<p pIToolBar> from the Framework.

@comm
	A Component's <om IDMUSProdComponent.Initialize> method should call
	<om IDMUSProdFramework.AddToolBar> if it wants to add toolbar(s) to the Framework.
	<om IDMUSProdFramework.RemoveToolBar> should be called from within
	<om IDMUSProdComponent.CleanUp>.

@rvalue S_OK | <p pIToolBar> was successfully removed from the Framework.
@rvalue E_INVALIDARG | <p pIToolBar> is not valid.  For example, it may be NULL.
@rvalue E_FAIL | <p pIToolBar> was not removed from the Framework. 

@ex The following excerpt from an <om IDMUSProdComponent.Cleanup> method removes a toolbar
	from the Framework: |

	if( m_pBarMsgHandler )
	{
		m_pIFramework->RemoveToolBar( m_pBarMsgHandler );
		if( m_pBarMsgHandler->GetSafeHwnd() )
		{
			m_pBarMsgHandler->DestroyWindow();
		}
		delete m_pBarMsgHandler;
		m_pBarMsgHandler = NULL;
	}
	
@xref <i IDMUSProdFramework>, <om IDMUSProdFramework.AddToolBar>, <i IDMUSProdToolBar>
--------------------------------------------------------------------------------------*/

/////////////////////////////////////////////////////////////////////////////
// CFramework::RemoveToolBar

HRESULT CFramework::RemoveToolBar(
	IDMUSProdToolBar* pIToolBar		// @parm [in] Pointer to the <i IDMUSProdToolBar> interface to be removed.

)
{
	AFX_MANAGE_STATE( AfxGetAppModuleState() );

	CJzToolBar* pJzToolBar;

	if( pIToolBar == NULL )
	{
		return E_INVALIDARG;
	}

	POSITION pos = m_lstToolBars.GetHeadPosition();

    while( pos != NULL )
    {
        pJzToolBar = static_cast<CJzToolBar*>( m_lstToolBars.GetNext(pos) );
		if( pJzToolBar )
		{
			if( pJzToolBar->m_pClientToolBar->m_pIToolBar == pIToolBar )
			{
				pos = m_lstToolBars.Find( pJzToolBar );
				if( pos )
				{
					m_lstToolBars.RemoveAt( pos );
				}

				// Remove toolbar from Framework
				RemoveViewMenuItem( pJzToolBar ); 
				delete pJzToolBar;

				return S_OK;
			}
		}
    }

	return E_FAIL;
}


/*======================================================================================
METHOD:  IDMUSPRODFRAMEWORK::SETNBRSTATUSBARPANES
========================================================================================
@method HRESULT | IDMUSProdFramework | SetNbrStatusBarPanes | Creates panes in the
		<o Framework>'s status bar. 

@comm
	Creates <p nCount> panes on the right-hand side of the Framework's status bar.  The
	Framework continues to use the left side of the status bar for its progress bar and
	to display help text.

    Panes created by other calls to <om IDMUSProdFramework.SetNbrStatusBarPanes> may
	exist simultaneously in the status bar.  <p nLifeSpan> helps determine the position
	of newly created panes in relationship to the other panes currently displaying in the
	status bar.  Panes with higher <p nLifeSpan> values are displayed to the left of panes
	with lower <p nLifeSpan> values.  In other words, the more "permanent" panes are
	positioned to the right-hand side of the application window.
	
    The following values are valid for use in <p nLifeSpan>:

	SBLS_APPLICATION: <tab>The status bar panes will exist the entire time the application is running.
	
	SBLS_EDITOR: <tab><tab>The status bar panes will only exist when a specific editor is active.    

	SBLS_CONTROL: <tab><tab>The status bar panes will only exist when a specific control has the focus.

	SBLS_MOUSEDOWNUP: <tab>The status bar panes will only exist while the mouse button is down.

	For even more control over positioning, <p nLifeSpan> may equal one of the defined values
	plus or minus an offset; i.e. SBLS_CONTROL + 1. 
	  
	The caller of <om IDMUSProdFramework.SetNbrStatusBarPanes> is responsible for removing the panes
	at the appropriate time.  For example, when <p nLifeSpan> is set to SBLS_EDITOR it is expected
	that the status bar panes will exist only when their associated editor is active.  In this case,
	<om IDMUSProdFramework::SetNbrStatusBarPanes> should be called during in-place activation when
	the editor's in-place toolbar is being displayed and <om IDMUSProdFramework::RestoreStatusBar>
	should be called the same time the in-place toolbar is removed.

@rvalue S_OK | <p nCount> status bar panes were created successfully. 
@rvalue E_INVALIDARG | Either <p nCount> or <p phKey> is not valid.  <p nCount> must be greater than zero
		and less than 16. <p phKey> must not be NULL.
@rvalue E_ACCESSDENIED | There is no more free space in the status bar.
@rvalue E_FAIL | An error occurred and the panes were not created. 

@ex The following example creates and initializes several panes in the Framework's status
	bar: |

	IDMUSProdFramework* pIFramework;
	HANDLE hKey;

	pIFramework->SetNbrStatusBarPanes( 2, SBLS_EDITOR, &hKey );

    BSTR bstrName = m_pStyle->m_strCategoryName.AllocSysString();
	pIFramework->SetStatusBarPaneInfo( hKey, 0, SBS_NOBORDERS, 16 );
	pIFramework->SetStatusBarPaneText( hKey, 0, bstrName, TRUE );

    bstrName = m_pStyle->m_strName.AllocSysString();
	pIFramework->SetStatusBarPaneInfo( hKey, 1, SBS_SUNKEN, 16 );
	pIFramework->SetStatusBarPaneText( hKey, 1, bstrName, TRUE );
	
@xref <i IDMUSProdFramework>, <om IDMUSProdFramework.SetStatusBarPaneInfo>, <om IDMUSProdFramework.SetStatusBarPaneText>, <om IDMUSProdFramework.RestoreStatusBar>
--------------------------------------------------------------------------------------*/


/////////////////////////////////////////////////////////////////////////////
// CFramework::SetNbrStatusBarPanes

HRESULT CFramework::SetNbrStatusBarPanes(
	int nCount,		// @parm [in] Number of panes to be created.  Must be greater than zero
					//		and less than 16.
	short nLifeSpan,// @parm [in] Length of time the status bar panes are needed.
	HANDLE* phKey	// @parm [out,retval] Pointer to the caller-allocated variable
					//		that receives the HANDLE which allows access to the
					//		Framework's status bar. 
)
{
	AFX_MANAGE_STATE( AfxGetAppModuleState() );

	if( phKey == NULL )
	{
		return E_INVALIDARG;
	}
	*phKey = NULL;

	CMainFrame* pMainFrame = (CMainFrame *)theApp.m_pMainWnd;
	ASSERT( pMainFrame != NULL );
	
	int nTotalPanes = pMainFrame->m_lstStatusBarPanes.GetCount() + nCount;
	if( (nCount <= 0)
	||  (nTotalPanes > MAX_PANES) )
	{
		return E_INVALIDARG;
	}

	// Generate hKey
	HANDLE hKey = (HANDLE)rand();

	HRESULT hr = S_OK;
	
	// Create the pane list
	for( int i = 0 ;  i < nCount ;  i++ )
	{
		// Create item for m_lstStatusBarPanes 
		CJzStatusBarPane* pJzStatusBarPane = new CJzStatusBarPane( hKey, nLifeSpan, i );
		if( pJzStatusBarPane == NULL )
		{
			hr = E_OUTOFMEMORY;
			break;
		}

		// Insert item into m_lstStatusBarPanes 
		pMainFrame->InsertStatusBarPane( pJzStatusBarPane );
	}

	// Sync the UI
	if( SUCCEEDED ( hr ) )
	{
		hr = pMainFrame->SyncStatusBarPanes();
		if( SUCCEEDED ( hr ) )
		{
			*phKey = hKey;
		}
	}
	else
	{
		RestoreStatusBar( hKey );
	}

	CString strText;
	strText.LoadString( AFX_IDS_IDLEMESSAGE );
	pMainFrame->m_wndStatusBar.SetWindowText( strText );

	return hr;
}


/*======================================================================================
METHOD:  IDMUSPRODFRAMEWORK::SETSTATUSBARPANEINFO
========================================================================================
@method HRESULT | IDMUSProdFramework | SetStatusBarPaneInfo | Sets the specified status bar
		pane to a new style and width. 

@comm
	<om IDMUSProdFramework::SetNbrStatusBarPanes> creates one or more panes on the right-hand
	side of the Framework's status bar.  The Framework continues to use the left side of
	the status bar for its progress bar and to display help text.

	The <om IDMUSProdFramework::SetStatusBarPaneInfo>
	and <om IDMUSProdFramework::SetStatusBarPaneText> methods set the style, width and text of each
	pane.

	The following styles are valid for use in <p sbStyle>:
	
	SBS_NOBORDERS		No 3-D border around the pane.

	SBS_RAISED		Reverse border so that text "pops out".

	SBS_SUNKEN		Border is sunken.
	
	<p nMaxChars> is used to set the width of the pane.  The Framework sets the width of the
	pane equal to <p nMaxChars> * tm.tmAveCharWidth, where tm.tmAveCharWidth is the average
	character width of the status bar font.

@rvalue S_OK | Status bar pane <p nIndex> was updated successfully. 
@rvalue E_INVALIDARG | Either <p hKey>, <p nIndex>, <p sbStyle>, or <p nMaxChars> is not
		valid.  For example, <p hKey> may be NULL. 
@rvalue E_ACCESSDENIED | <p hKey> does not match a HANDLE returned by a previous call
		to <om IDMUSProdFramework.SetNbrStatusBarPanes>. 
@rvalue E_FAIL | An error occurred and the pane was not modified. 

@ex The following example creates and initializes several panes in the Framework's status
	bar: |

	IDMUSProdFramework* pIFramework;
	HANDLE hKey;

	pIFramework->SetNbrStatusBarPanes( 2, SBLS_EDITOR, &hKey );

    BSTR bstrName = m_pStyle->m_strCategoryName.AllocSysString();
	pIFramework->SetStatusBarPaneInfo( hKey, 0, SBS_NOBORDERS, 16 );
	pIFramework->SetStatusBarPaneText( hKey, 0, bstrName, TRUE );

    bstrName = m_pStyle->m_strName.AllocSysString();
	pIFramework->SetStatusBarPaneInfo( hKey, 1, SBS_SUNKEN, 16 );
	pIFramework->SetStatusBarPaneText( hKey, 1, bstrName, TRUE );
	
@xref <i IDMUSProdFramework>, <om IDMUSProdFramework.SetNbrStatusBarPanes>, <om IDMUSProdFramework.SetStatusBarPaneText>, <om IDMUSProdFramework.RestoreStatusBar>
--------------------------------------------------------------------------------------*/

#define MAX_PANE_CHARS	48

/////////////////////////////////////////////////////////////////////////////
// CFramework::SetStatusBarPaneInfo

HRESULT CFramework::SetStatusBarPaneInfo(
	HANDLE hKey,			// @parm [in] HANDLE returned by <om IDMUSProdFramework.SetNbrStatusBarPanes>.
	int nIndex,				// @parm [in] Zero based index of the pane whose
							//		information is to be set.  <p nIndex> must be
							//		greater than or equal to zero, and less than
							//		the number of panes created by
							//		<om IDMUSProdFramework::SetNbrStatusBarPanes>.
	StatusBarStyle sbStyle,	// @parm [in] New style for the pane.  <p sbStyle>
							//		must be SBS_NOBORDERS, SBS_RAISED, or SBS_SUNKEN.
	int nMaxChars			// @parm [in] Maximum number of characters in pane text.
							//		<p nMaxChars> must be greater than zero, and less
							//		than or equal to 48.
)
{
	AFX_MANAGE_STATE( AfxGetAppModuleState() );

	CMainFrame* pMainFrame = (CMainFrame *)theApp.m_pMainWnd;
	ASSERT( pMainFrame != NULL );

	CJzStatusBarPane* pJzStatusBarPane;
		
	HRESULT hr = pMainFrame->GetStatusBarPane( hKey, nIndex, &pJzStatusBarPane );
	if( FAILED ( hr ) )
	{
		return hr;
	}

	switch( sbStyle )
	{
		case SBS_NOBORDERS:
			pJzStatusBarPane->m_nStyle = SBPS_NOBORDERS;
			break;

		case SBS_RAISED:
			pJzStatusBarPane->m_nStyle = SBPS_POPOUT;
			break;

		case SBS_SUNKEN:
			pJzStatusBarPane->m_nStyle = SBPS_NORMAL;
			break;

		default:
			return E_INVALIDARG;
	}

	CDC* pDC = pMainFrame->m_wndStatusBar.GetDC();
	if( pDC )
	{
		TEXTMETRIC tm;

		pDC->GetTextMetrics( &tm );
		pJzStatusBarPane->m_nWidth = (short)(nMaxChars * tm.tmAveCharWidth);
		pMainFrame->m_wndStatusBar.ReleaseDC( pDC );
	}
	else
	{
		return E_FAIL;
	}

	pMainFrame->m_wndStatusBar.SetPaneInfo( pJzStatusBarPane->m_nStatusBarIndex + NBR_FRAMEWORK_PANES,
											ID_SEPARATOR,
											pJzStatusBarPane->m_nStyle,
											pJzStatusBarPane->m_nWidth );

	return S_OK;
}


/*======================================================================================
METHOD:  IDMUSPRODFRAMEWORK::SETSTATUSBARPANETEXT
========================================================================================
@method HRESULT | IDMUSProdFramework | SetStatusBarPaneText | Sets the text of the specified
		status bar pane. 

@comm
	<om IDMUSProdFramework::SetNbrStatusBarPanes> creates one or more panes on the right-hand
	side of the Framework's status bar.  The Framework continues to use the left side of
	the status bar for its progress bar and to display help text.

	The <om IDMUSProdFramework::SetStatusBarPaneInfo> and
	<om IDMUSProdFramework::SetStatusBarPaneText> methods set the style, width and text of each
	pane.

@rvalue S_OK | Status bar pane text was updated successfully. 
@rvalue E_INVALIDARG | Either <p hKey> or <p nIndex> is not valid. For example,
		<p hKey> may be NULL.
@rvalue E_ACCESSDENIED | <p hKey> does not match a HANDLE returned by a previous call
		to <om IDMUSProdFramework.SetNbrStatusBarPanes>. 
@rvalue E_FAIL | An error occurred and the pane text was not modified. 

@ex The following example creates and initializes several panes in the Framework's status
	bar: |

	IDMUSProdFramework* pIFramework;
	HANDLE hKey;

	pIFramework->SetNbrStatusBarPanes( 2, SBLS_EDITOR, &hKey );

    BSTR bstrName = m_pStyle->m_strCategoryName.AllocSysString();
	pIFramework->SetStatusBarPaneInfo( hKey, 0, SBS_NOBORDERS, 16 );
	pIFramework->SetStatusBarPaneText( hKey, 0, bstrName, TRUE );

    bstrName = m_pStyle->m_strName.AllocSysString();
	pIFramework->SetStatusBarPaneInfo( hKey, 1, SBS_SUNKEN, 16 );
	pIFramework->SetStatusBarPaneText( hKey, 1, bstrName, TRUE );
	
@xref <i IDMUSProdFramework>, <om IDMUSProdFramework.SetNbrStatusBarPanes>, <om IDMUSProdFramework.SetStatusBarPaneInfo>, <om IDMUSProdFramework.RestoreStatusBar>
--------------------------------------------------------------------------------------*/

/////////////////////////////////////////////////////////////////////////////
// CFramework::SetStatusBarPaneText

HRESULT CFramework::SetStatusBarPaneText(
	HANDLE hKey,	// @parm [in] HANDLE returned by <om IDMUSProdFramework.SetNbrStatusBarPanes>.
	int nIndex,		// @parm [in] Zero based index of the pane whose
					//		information is to be set.  <p nIndex> must be
					//		greater than or equal to zero, and less than
					//		the number of panes created by
					//		<om IDMUSProdFramework::SetNbrStatusBarPanes>.
	BSTR bstrText,	// @parm [in] New text.  This method must free <p bstrText> with
					//		SysFreeString when it is no longer needed.
	BOOL bUpdate	// @parm [in] If TRUE, the pane is invalidated after the text update.
)
{
	AFX_MANAGE_STATE( AfxGetAppModuleState() );

	if( bstrText == NULL )
	{
		return E_INVALIDARG;
	}

	CMainFrame* pMainFrame = (CMainFrame *)theApp.m_pMainWnd;
	ASSERT( pMainFrame != NULL );

	CJzStatusBarPane* pJzStatusBarPane;
		
	HRESULT hr = pMainFrame->GetStatusBarPane( hKey, nIndex, &pJzStatusBarPane );
	if( FAILED ( hr ) )
	{
		::SysFreeString( bstrText );
		return hr;
	}

	pJzStatusBarPane->m_strText = bstrText;
	::SysFreeString( bstrText );

	pMainFrame->m_wndStatusBar.SetPaneText( pJzStatusBarPane->m_nStatusBarIndex + NBR_FRAMEWORK_PANES,
											pJzStatusBarPane->m_strText,
											bUpdate );

	return S_OK;
}


/*======================================================================================
METHOD:  IDMUSPRODFRAMEWORK::RESTORESTATUSBAR
========================================================================================
@method HRESULT | IDMUSProdFramework | RestoreStatusBar | Removes panes from the
		<o Framework>'s status bar. 

@comm
	<om IDMUSProdFramework::SetNbrStatusBarPanes> creates one or more panes on the right-hand
	side of the Framework's status bar.  The Framework continues to use the left side of
	the status bar for its progress bar and to display help text.

@rvalue S_OK | The status bar panes were removed successfully. 
@rvalue E_INVALIDARG | The value of <p hKey> is not valid.  For example, it may be NULL.
@rvalue E_ACCESSDENIED | <p hKey> does not match a HANDLE returned by a previous call
		to <om IDMUSProdFramework.SetNbrStatusBarPanes>. 
	
@xref <i IDMUSProdFramework>, <om IDMUSProdFramework.SetNbrStatusBarPanes>, <om IDMUSProdFramework.SetStatusBarPaneInfo>, <om IDMUSProdFramework.SetStatusBarPaneText>
--------------------------------------------------------------------------------------*/

/////////////////////////////////////////////////////////////////////////////
// CFramework::RestoreStatusBar

HRESULT CFramework::RestoreStatusBar(
	HANDLE hKey		// @parm [in] HANDLE returned by <om IDMUSProdFramework.SetNbrStatusBarPanes>.
)
{
	AFX_MANAGE_STATE( AfxGetAppModuleState() );

	CMainFrame* pMainFrame = (CMainFrame *)theApp.m_pMainWnd;
	ASSERT( pMainFrame != NULL );

	if( hKey == NULL )
	{
		return E_INVALIDARG;
	}

	HRESULT hr = E_ACCESSDENIED;

	CJzStatusBarPane* pJzStatusBarPane;
	POSITION pos2;

    POSITION pos = pMainFrame->m_lstStatusBarPanes.GetHeadPosition();
    while( pos )
    {
        pos2 = pos;
		pJzStatusBarPane = pMainFrame->m_lstStatusBarPanes.GetNext( pos );

		if( pJzStatusBarPane->m_hKey == hKey )
		{
			// Key is valid
			hr = S_OK;

			pMainFrame->m_lstStatusBarPanes.RemoveAt( pos2 );
			delete pJzStatusBarPane; 
		}
    }

	// Sync the UI
	if( SUCCEEDED ( hr ) )
	{
		hr = pMainFrame->SyncStatusBarPanes();
	}

	CString strText;
	strText.LoadString( AFX_IDS_IDLEMESSAGE );
	pMainFrame->m_wndStatusBar.SetWindowText( strText );

	return hr;
}



/*======================================================================================
METHOD:  IDMUSPRODFRAMEWORK::STARTPROGRESSBAR
========================================================================================
@method HRESULT | IDMUSProdFramework | StartProgressBar | Creates a progress bar control
		in the <o Framework>'s status bar. 

@comm The <o Framework>'s "progress bar" can be used by DirectMusic Producer <o Component>s
	to indicate the progress of a lengthy operation.  The progress bar control has a range
	and a current position.  The range represents the length of the entire operation, and
	the current position represents the progress the application has made toward completing
	the operation.

@rvalue S_OK | The progress bar was created successfully. 
@rvalue E_OUTOFMEMORY | Out of memory.
@rvalue E_INVALIDARG | The value of <p phKey> is not valid.  For example, it may be NULL.
@rvalue E_ACCESSDENIED | The progress bar is already being used to track another operation.
@rvalue E_FAIL | An error occurred and the progress bar was not created.

@ex The following example creates a progress bar control in the Framework's status bar: |

	IDMUSProdFramework* pIFramework;
	HANDLE hKey;
	  
	CString strPrompt = _T( "Preparing information" );
	BSTR bstrPrompt = strPrompt.AllocSysString();

	pIFramework->StartProgressBar( 0, 50, bstrPrompt, &hKey );
	for( int i = 0 ;  i < 50 ;  i++ )
	{
		Sleep( 50 );
		pIFramework->SetProgressBarPos( hKey, i );
	}
	pIFramework->EndProgressBar( hKey );
	
@xref <i IDMUSProdFramework>, <om IDMUSProdFramework.SetProgressBarPos>, <om IDMUSProdFramework.SetProgressBarStep>, <om IDMUSProdFramework.StepProgressBar>, <om IDMUSProdFramework.EndProgressBar>
--------------------------------------------------------------------------------------*/

#define PROGRESS_BAR_WIDTH	146

/////////////////////////////////////////////////////////////////////////////
// CFramework::StartProgressBar

HRESULT CFramework::StartProgressBar(
	int nLower,			// @parm [in] Specifies lower limit of the progress bar range.
	int nUpper,			// @parm [in] Specifies upper limit of the progress bar range.
	BSTR bstrPrompt,	// @parm [in] Text for the progress bar prompt.  This
						//		method must free <p bstrPrompt> with SysFreeString
						//		when it is no longer needed.
	HANDLE* phKey		// @parm [out,retval] Pointer to the caller-allocated variable
						//		that receives the HANDLE which allows access to the
						//		Framework's progress bar. 
)
{
	AFX_MANAGE_STATE( AfxGetAppModuleState() );

	if( bstrPrompt == NULL )
	{
		return E_INVALIDARG;
	}
	CString strPrompt = bstrPrompt;
	::SysFreeString( bstrPrompt );

	if( phKey == NULL )
	{
		return E_INVALIDARG;
	}
	*phKey = NULL;

	CMainFrame* pMainFrame = (CMainFrame *)theApp.m_pMainWnd;
	ASSERT( pMainFrame != NULL );

	if( pMainFrame->m_pProgressCtrl )
	{
		return E_ACCESSDENIED;
	}

	pMainFrame->m_pProgressCtrl = new CProgressCtrl;
	if( pMainFrame->m_pProgressCtrl == NULL )
	{
		return E_OUTOFMEMORY;
	}

	pMainFrame->m_wndStatusBar.SetWindowText( strPrompt );
	pMainFrame->m_wndStatusBar.UpdateWindow();

	RECT rect;
	CSize sizeText;
	CDC* pDC;

	pDC = pMainFrame->m_wndStatusBar.GetDC();
	sizeText = pDC->GetTextExtent( strPrompt );
	pMainFrame->m_wndStatusBar.ReleaseDC( pDC );

	pMainFrame->m_wndStatusBar.GetItemRect( 0, &rect );
	rect.left += sizeText.cx;
	if( rect.left > (rect.right - PROGRESS_BAR_WIDTH) )
	{
		rect.left = (rect.right - PROGRESS_BAR_WIDTH);
	}
	rect.right = rect.left + PROGRESS_BAR_WIDTH;

	VERIFY( pMainFrame->m_pProgressCtrl->Create((WS_CHILD | WS_VISIBLE),
			rect, &pMainFrame->m_wndStatusBar, 1) );
	pMainFrame->m_pProgressCtrl->SetRange( nLower, nUpper );

	pMainFrame->m_hProgressCtrl = (HANDLE)rand();
	if( pMainFrame->m_hProgressCtrl == NULL )
	{
		pMainFrame->m_hProgressCtrl = (HANDLE)0x71954;
	}
	*phKey = pMainFrame->m_hProgressCtrl;

	return S_OK;
}


/*======================================================================================
METHOD:  IDMUSPRODFRAMEWORK::SETPROGRESSBARPOS
========================================================================================
@method HRESULT | IDMUSProdFramework | SetProgressBarPos | Sets the current position of the
		<o Framework>'s progress bar control. 

@comm The <o Framework>'s "progress bar" can be used by DirectMusic Producer <o Component>s
	to indicate the progress of a lengthy operation.  The progress bar control has a range
	and a current position.  The range represents the length of the entire operation, and
	the current position represents the progress the application has made toward completing
	the operation.

@rvalue S_OK | The position of the progress bar control was set successfully. 
@rvalue E_INVALIDARG | The value of <p hKey> is not valid.  For example, it may be NULL.
@rvalue E_ACCESSDENIED | <p hKey> does not match the HANDLE returned by the previous call
		to <om IDMUSProdFramework.StartProgressBar>. 

@ex The following example creates a progress bar control in the Framework's status bar: |

	IDMUSProdFramework* pIFramework;
	HANDLE hKey;
	  
	CString strPrompt = _T( "Preparing information" );
	BSTR bstrPrompt = strPrompt.AllocSysString();

	pIFramework->StartProgressBar( 0, 50, bstrPrompt, &hKey );
	for( int i = 0 ;  i < 50 ;  i++ )
	{
		Sleep( 50 );
		pIFramework->SetProgressBarPos( hKey, i );
	}
	pIFramework->EndProgressBar( hKey );
	
@xref <i IDMUSProdFramework>, <om IDMUSProdFramework.StartProgressBar>, <om IDMUSProdFramework.SetProgressBarStep>, <om IDMUSProdFramework.StepProgressBar>, <om IDMUSProdFramework.EndProgressBar>
--------------------------------------------------------------------------------------*/

/////////////////////////////////////////////////////////////////////////////
// CFramework::SetProgressBarPos

HRESULT CFramework::SetProgressBarPos(
	HANDLE hKey,	// @parm [in] HANDLE returned by <om IDMUSProdFramework.StartProgressBar>.
	int nPos		// @parm [in] New position of the progress bar control.
)
{
	AFX_MANAGE_STATE( AfxGetAppModuleState() );

	if( hKey == NULL )
	{
		return E_INVALIDARG;
	}

	CMainFrame* pMainFrame = (CMainFrame *)theApp.m_pMainWnd;
	ASSERT( pMainFrame != NULL );

	if( hKey !=  pMainFrame->m_hProgressCtrl )
	{
		return E_ACCESSDENIED;
	}

	if( pMainFrame->m_pProgressCtrl )
	{
		pMainFrame->m_pProgressCtrl->SetPos( nPos );
	}

	return S_OK;
}


/*======================================================================================
METHOD:  IDMUSPRODFRAMEWORK::SETPROGRESSBARSTEP
========================================================================================
@method HRESULT | IDMUSProdFramework | SetProgressBarStep | Specifies the step increment for
		the <o Framework>'s progress bar control. 

@comm The <o Framework>'s "progress bar" can be used by DirectMusic Producer <o Component>s
	to indicate the progress of a lengthy operation.  The progress bar control has a range
	and a current position.  The range represents the length of the entire operation, and
	the current position represents the progress the application has made toward completing
	the operation.

	The step increment is the amount by which a call to <om IDMUSProdFramework.StepProgressBar>
	increases the progress bar's current position.

@rvalue S_OK | The step increment of the progress bar control was set successfully. 
@rvalue E_INVALIDARG | The value of <p hKey> is not valid.  For example, it may be NULL.
@rvalue E_ACCESSDENIED | <p hKey> does not match the HANDLE returned by the previous call
		to <om IDMUSProdFramework.StartProgressBar>. 


@ex The following example creates a progress bar control in the Framework's status bar: |

	IDMUSProdFramework* pIFramework;
	HANDLE hKey;
	  
	CString strPrompt = _T( "Preparing information" );
	BSTR bstrPrompt = strPrompt.AllocSysString();

	pIFramework->StartProgressBar( 0, 50, bstrPrompt, &hKey );
	pIFramework->SetProgressBarPos( hKey, 0 );
	pIFramework->SetProgressBarStep( hKey, 5 );

	for( int i = 0 ;  i < 10 ;  i++ )
	{
		Sleep( 50 );
		pIFramework->StepProgressBar( hKey );
	}

	pIFramework->EndProgressBar( hKey );
	
@xref <i IDMUSProdFramework>, <om IDMUSProdFramework.StartProgressBar>, <om IDMUSProdFramework.SetProgressBarPos>, <om IDMUSProdFramework.StepProgressBar>, <om IDMUSProdFramework.EndProgressBar>
--------------------------------------------------------------------------------------*/

/////////////////////////////////////////////////////////////////////////////
// CFramework::SetProgressBarStep

HRESULT CFramework::SetProgressBarStep(
	HANDLE hKey,	// @parm [in] HANDLE returned by <om IDMUSProdFramework.StartProgressBar>.
	UINT nValue		// @parm [in] New step increment for the progress bar control.
)
{
	AFX_MANAGE_STATE( AfxGetAppModuleState() );

	if( hKey == NULL )
	{
		return E_INVALIDARG;
	}

	CMainFrame* pMainFrame = (CMainFrame *)theApp.m_pMainWnd;
	ASSERT( pMainFrame != NULL );

	if( hKey !=  pMainFrame->m_hProgressCtrl )
	{
		return E_ACCESSDENIED;
	}

	if( pMainFrame->m_pProgressCtrl )
	{
		pMainFrame->m_pProgressCtrl->SetStep( nValue );
	}

	return S_OK;
}


/*======================================================================================
METHOD:  IDMUSPRODFRAMEWORK::STEPPROGRESSBAR
========================================================================================
@method HRESULT | IDMUSProdFramework | StepProgressBar | Advances current position of the
	<o Framework>'s progress bar control by the step increment. 

@comm The <o Framework>'s "progress bar" can be used by DirectMusic Producer <o Component>s
	to indicate the progress of a lengthy operation.  The progress bar control has a range
	and a current position.  The range represents the length of the entire operation, and
	the current position represents the progress the application has made toward completing
	the operation.

	<om IDMUSProdFramework.SetProgressBarStep> sets the step increment for the progress bar control.

@rvalue S_OK | The current position of the progress bar control was advanced successfully. 
@rvalue E_INVALIDARG | The value of <p hKey> is not valid.  For example, it may be NULL.
@rvalue E_ACCESSDENIED | <p hKey> does not match the HANDLE returned by the previous call
		to <om IDMUSProdFramework.StartProgressBar>. 

@ex The following example creates a progress bar control in the Framework's status bar: |

	IDMUSProdFramework* pIFramework;
	HANDLE hKey;
	  
	CString strPrompt = _T( "Preparing information" );
	BSTR bstrPrompt = strPrompt.AllocSysString();

	pIFramework->StartProgressBar( 0, 50, bstrPrompt, &hKey );
	pIFramework->SetProgressBarPos( hKey, 0 );
	pIFramework->SetProgressBarStep( hKey, 5 );

	for( int i = 0 ;  i < 10 ;  i++ )
	{
		Sleep( 50 );
		pIFramework->StepProgressBar( hKey );
	}

	pIFramework->EndProgressBar( hKey );
	
@xref <i IDMUSProdFramework>, <om IDMUSProdFramework.StartProgressBar>, <om IDMUSProdFramework.SetProgressBarPos>, <om IDMUSProdFramework.SetProgressBarStep>, <om IDMUSProdFramework.EndProgressBar>
--------------------------------------------------------------------------------------*/

/////////////////////////////////////////////////////////////////////////////
// CFramework::StepProgressBar

HRESULT CFramework::StepProgressBar(
	HANDLE hKey		// @parm [in] HANDLE returned by <om IDMUSProdFramework.StartProgressBar>.
)
{
	AFX_MANAGE_STATE( AfxGetAppModuleState() );

	if( hKey == NULL )
	{
		return E_INVALIDARG;
	}

	CMainFrame* pMainFrame = (CMainFrame *)theApp.m_pMainWnd;
	ASSERT( pMainFrame != NULL );

	if( hKey !=  pMainFrame->m_hProgressCtrl )
	{
		return E_ACCESSDENIED;
	}

	if( pMainFrame->m_pProgressCtrl )
	{
		pMainFrame->m_pProgressCtrl->StepIt();
	}

	return S_OK;
}


/*======================================================================================
METHOD:  IDMUSPRODFRAMEWORK::ENDPROGRESSBAR
========================================================================================
@method HRESULT | IDMUSProdFramework | EndProgressBar | Removes the progress bar control
		from the <o Framework>'s status bar. 

@comm The <o Framework>'s "progress bar" can be used by DirectMusic Producer <o Component>s
	to indicate the progress of a lengthy operation.  The progress bar control has a range
	and a current position.  The range represents the length of the entire operation, and
	the current position represents the progress the application has made toward completing
	the operation.

@rvalue S_OK | The progress bar control was removed successfully. 
@rvalue E_INVALIDARG | The value of <p hKey> is not valid.  For example, it may be NULL.
@rvalue E_ACCESSDENIED | <p hKey> does not match the HANDLE returned by the previous call
		to <om IDMUSProdFramework.StartProgressBar>. 

@ex The following example creates a progress bar control in the Framework's status bar: |

	IDMUSProdFramework* pIFramework;
	HANDLE hKey;
	  
	CString strPrompt = _T( "Preparing information" );
	BSTR bstrPrompt = strPrompt.AllocSysString();

	pIFramework->StartProgressBar( 0, 50, bstrPrompt, &hKey );
	for( int i = 0 ;  i < 50 ;  i++ )
	{
		Sleep( 50 );
		pIFramework->SetProgressBarPos( hKey, i );
	}
	pIFramework->EndProgressBar( hKey );
	
@xref <i IDMUSProdFramework>, <om IDMUSProdFramework.StartProgressBar>, <om IDMUSProdFramework.SetProgressBarPos>, <om IDMUSProdFramework.SetProgressBarStep>, <om IDMUSProdFramework.StepProgressBar>
--------------------------------------------------------------------------------------*/

/////////////////////////////////////////////////////////////////////////////
// CFramework::EndProgressBar

HRESULT CFramework::EndProgressBar(
	HANDLE hKey		// @parm [in] HANDLE returned by <om IDMUSProdFramework.StartProgressBar>.
)
{
	AFX_MANAGE_STATE( AfxGetAppModuleState() );

	if( hKey == NULL )
	{
		return E_INVALIDARG;
	}

	CMainFrame* pMainFrame = (CMainFrame *)theApp.m_pMainWnd;
	ASSERT( pMainFrame != NULL );

	if( hKey !=  pMainFrame->m_hProgressCtrl )
	{
		return E_ACCESSDENIED;
	}

	if( pMainFrame->m_pProgressCtrl )
	{
		delete pMainFrame->m_pProgressCtrl;
		pMainFrame->m_pProgressCtrl = NULL;
		pMainFrame->m_hProgressCtrl = NULL;
	}

	CString strText;
	
	strText.LoadString( AFX_IDS_IDLEMESSAGE );
	pMainFrame->m_wndStatusBar.SetWindowText( strText );

	return S_OK;
}


/*======================================================================================
METHOD:  IDMUSPRODFRAMEWORK::GETSHAREDOBJECT
========================================================================================
@method HRESULT | IDMUSProdFramework | GetSharedObject | Allows one or more DirectMusic
	Producer <o Component>s to share the same COM object.

@comm
	This method calls CoCreateInstance to create objects of type <p rclsid>.  The
	<o Framework> holds a reference to the created object so that subsequent calls to
	<om IDMUSProdFramework.GetSharedObject> can simply return an additional reference
	to a previously created object whose CLSID matches <p rclsid>.

@rvalue S_OK | The interface specified in <p riid> was returned successfully.
@rvalue E_POINTER | The address in <p ppvObject> is not valid.  For example, it may be NULL.
@rvalue E_FAIL | An error occurred, and the interface specified in <p riid> could not be returned.

@ex The following example obtains an interface to a shared DirectMusic Composer object: |

IDirectMusicComposer* pIComposer;
HRESULT hr;

hr = pIFramework->GetSharedObject( CLSID_DMCompos, IID_IDirectMusicComposer, (void**)&pIComposer )

if( SUCCEEDED ( hr ) )  
{
		.....
		.....

		pIComposer->Release();
}

@xref <i IDMUSProdFramework>
--------------------------------------------------------------------------------------*/

HRESULT CFramework::GetSharedObject(
	REFCLSID rclsid,				// @parm [in] CLSID of the requested object.
	REFIID riid,					// @parm [in] Identifier of the requested interface.
	void** ppvObject				// @parm [out,retval] Address of a variable to receive
									//		the requested object. On success, the caller is
									//		responsible for calling IUnknown::Release.
)
{
	AFX_MANAGE_STATE( AfxGetAppModuleState() );

	if( ppvObject == NULL )
	{
		return E_POINTER;
	}

	*ppvObject = NULL;

	// See if the object was created by a previous call to GetSharedObject
	CJzSharedObject* pJzSharedObject;
	
	POSITION pos = m_lstSharedObjects.GetHeadPosition();
    while( pos )
    {
        pJzSharedObject = static_cast<CJzSharedObject*>( m_lstSharedObjects.GetNext(pos) );

		if( ::IsEqualCLSID( pJzSharedObject->m_clsid, rclsid ) )
		{
			return pJzSharedObject->m_pIUnknown->QueryInterface( riid, ppvObject );
		}
    }

	// Attempt to create the object
	IUnknown* pIUnknown;

	if( FAILED ( ::CoCreateInstance( rclsid, NULL, CLSCTX_INPROC, IID_IUnknown, (void **)&pIUnknown ) ) )
	{
		return E_FAIL;
	}

	// Store IUnknown* in our SharedObjects list
	pJzSharedObject = new CJzSharedObject( rclsid, pIUnknown );
	if( pJzSharedObject == NULL )
	{
		pIUnknown->Release();
		return E_OUTOFMEMORY;
	}

	m_lstSharedObjects.AddTail( pJzSharedObject );
	pIUnknown->Release();

	// Return the requested interface
	return pJzSharedObject->m_pIUnknown->QueryInterface( riid, ppvObject );
}


/*======================================================================================
METHOD:  IDMUSPRODFRAMEWORK::ADDTONOTIFYLIST
========================================================================================
@method HRESULT | IDMUSProdFramework | AddToNotifyList | Adds <p pINotifyThisNode> to the list
		of <o Node>s notified when the state of <p pIDocRootNode> changes. 

@comm 
	<p pIDocRootNode> must point to a DocRoot <o Node>.  A DocRoot node is the top node of
	a document, or file.  For example, the Style node of a Style file would be considered
	the DocRoot node of the Style.  The Band node of a Band file would be considered the
	DocRoot node of the Band file.

	<p pINotifyThisNode> must also implement <i IDMUSProdNotifySink>.  The IDMUSProdNotifySink
	interface is used to notify <p pINotifyThisNode> when the state of <p pIDocRootNode>
	changes.

@rvalue S_OK | <p pINotifyThisNode> was added to the list of nodes to be notified when
		the state of <p pIDocRootNode> changes.
@rvalue E_INVALIDARG | Either <p pIDocRootNode> or <p pINotifyThisNode> is not valid.
		For example, they may be NULL.
@rvalue E_FAIL | An error occurred, and <p pINotifyThisNode> could not be added to the
		notify list attached to <p pIDocRootNode>.

@ex The following example displays a File Open dialog for the purpose of selecting a Segment's Style: |

	IDMUSProdReferenceNode* pIReferenceNode;
	IDMUSProdDocType* pIDocType;

    if( SUCCEEDED( pSegment->m_pIStyleRefNode->QueryInterface( IID_IDMUSProdReferenceNode, (void**)&pIReferenceNode ) ) )
	{
		if( SUCCEEDED ( pIFramework->FindDocTypeByNodeId( GUID_StyleNode, &pIDocType ) ) ) 
		{
			if( pIFramework->OpenFile( pIDocType, NULL, pSegment, &pIStyleDocRootNode ) == S_OK ) 
			{
				if( SUCCEEDED( pIReferenceNode->SetReferencedFile( pIStyleDocRootNode ) ) )
				{
					pIFramework->AddToNotifyList( pIStyleDocRootNode, pSegment );
				}
				pIStyleDocRootNode->Release();
			}
			pIDocType->Release();
		}
		pIReferenceNode->Release();
	}

@xref <i IDMUSProdFramework>, <om IDMUSProdFramework.RemoveFromNotifyList>, <om IDMUSProdFramework.NotifyNodes>, <i IDMUSProdNotifySink>
--------------------------------------------------------------------------------------*/

/////////////////////////////////////////////////////////////////////////////
// CFramework::AddToNotifyList

HRESULT CFramework::AddToNotifyList(
	IDMUSProdNode* pIDocRootNode,		// @parm [in] Pointer to an <i IDMUSProdNode> interface.
	IDMUSProdNode* pINotifyThisNode		// @parm [in] Pointer to the <i IDMUSProdNode> requesting a
									//		callback when <p pIDocRootNode> changes.
)
{
	AFX_MANAGE_STATE( AfxGetAppModuleState() );

	if( pIDocRootNode == NULL
	||  pINotifyThisNode == NULL )
	{
		return E_INVALIDARG;
	}

	// Make sure pIDocRootNode is really a DocRoot node already in the Project Tree
	if( IsDocRootNode( pIDocRootNode ) == FALSE )
	{
		return E_INVALIDARG;
	}

	// Make sure pINotifyThisNode has implemented IDMUSProdNotifySink
	IDMUSProdNotifySink* pINotifySink;

	if( FAILED ( pINotifyThisNode->QueryInterface( IID_IDMUSProdNotifySink, (void **)&pINotifySink ) ) )
	{
		return E_INVALIDARG;
	}
	pINotifySink->Release();

	// Get the CFileNode associated with pIDocRootNode
	CFileNode* pFileNode = NULL;
	
	CComponentDoc* pComponentDoc = theApp.FindComponentDocument( pIDocRootNode );
	if( pComponentDoc )
	{
		pFileNode = pComponentDoc->m_pFileNode;
	}
	if( pFileNode == NULL )
	{
		return E_FAIL;
	}

	// Insert pINotifyThisNode into CFileNode's notify list
	pFileNode->AddToNotifyList( pINotifyThisNode );

	return S_OK;
}


/*======================================================================================
METHOD:  IDMUSPRODFRAMEWORK::REMOVEFROMNOTIFYLIST
========================================================================================
@method HRESULT | IDMUSProdFramework | RemoveFromNotifyList | Removes <p pINotifyThisNode> from
		the list of <o Node>s notified when the state of <p pIDocRootNode> changes. 

@comm 
	<p pIDocRootNode> must point to a DocRoot <o Node>.  A DocRoot node is the top node of
	a document, or file.  For example, the Style node of a Style file would be considered
	the DocRoot node of the Style.  The Band node of a Band file would be considered the
	DocRoot node of the Band file.

    <om IDMUSProdFramework.RemoveFromNotifyList> advises the Framework that <p pINotifyThisNode>
	no longer references <p pIDocRootNode>.  This method should not be called as part of normal
	shutdown procedure.

@rvalue S_OK | <p pINotifyThisNode> was removed from the list of nodes to be notified when
		the state of <p pIDocRootNode> changes.
@rvalue E_INVALIDARG | Either <p pIDocRootNode> or <p pINotifyThisNode> is not valid.
		For example, they may be NULL.
@rvalue E_FAIL | An error occurred, and <p pINotifyThisNode> could not be removed from
		the notify list attached to <p pIDocRootNode>.
	
@xref <i IDMUSProdFramework>, <om IDMUSProdFramework.AddToNotifyList>, <om IDMUSProdFramework.NotifyNodes>, <i IDMUSProdNotifySink>
--------------------------------------------------------------------------------------*/

/////////////////////////////////////////////////////////////////////////////
// CFramework::RemoveFromNotifyList

HRESULT CFramework::RemoveFromNotifyList(
	IDMUSProdNode* pIDocRootNode,		// @parm [in] Pointer to an <i IDMUSProdNode> interface.
	IDMUSProdNode* pINotifyThisNode		// @parm [in] Pointer to the <i IDMUSProdNode> requesting a
									//		callback when <p pIDocRootNode> changes.
)
{
	AFX_MANAGE_STATE( AfxGetAppModuleState() );

	if( pIDocRootNode == NULL
	||  pINotifyThisNode == NULL )
	{
		return E_INVALIDARG;
	}

	// Get the CFileNode associated with pIDocRootNode
	CFileNode* pFileNode = NULL;
	
	CComponentDoc* pComponentDoc = theApp.FindComponentDocument( pIDocRootNode );
	if( pComponentDoc )
	{
		pFileNode = pComponentDoc->m_pFileNode;
	}
	if( pFileNode == NULL )
	{
		return E_FAIL;
	}

	// Remove matching pINotifyThisNode from CFileNode's notify list
	pFileNode->RemoveFromNotifyList( pINotifyThisNode );

	return S_OK;
}


/*======================================================================================
METHOD:  IDMUSPRODFRAMEWORK::NOTIFYNODES
========================================================================================
@method HRESULT | IDMUSProdFramework | NotifyNodes | Notifies all <o Node>s linked to
		<p pIChangedDocRootNode> via calls to <om IDMUSProdFramework.AddToNotifyList> that
		the state of <p pIChangedDocRootNode> has changed. 

@comm 
	<p pIChangedDocRootNode> must point to a DocRoot <o Node>.  A DocRoot node is the top
	node of a document, or file.  For example, the Style node of a Style file would be
	considered the DocRoot node of the Style.  The Band node of a Band file would be
	considered the DocRoot node of the Band file.

	<p pData> may be NULL.
	
	Valid <p guidUpdateType> and <p pData> values must be defined and documented in the .h
	and .lib files distributed by the Component supporting nodes of type <p pIDocRootNode>.
	For example, the Style Component's StyleDesigner.h and StyleDesignerGuid.lib files
	must contain and document the various <p guidUpdateType> and <p pData> values it
	uses to communicate Style file changes. 

	The following list contains notifications provided by the Framework:

	<tab><p guidUpdateType> <tab><tab><tab><p pData> <tab><tab><p Description>

	<tab>FRAMEWORK_FileDeleted <tab><tab>NULL <tab><tab> File deleted by user and is no longer in the Project Tree.

	<tab>FRAMEWORK_FileReplaced <tab><tab>NULL <tab><tab> Linked file being replaced by another version of the file.

	<tab>FRAMEWORK_FileClosed <tab><tab>NULL <tab><tab> File closed normally and is no longer in the Project Tree.

	<tab>FRAMEWORK_FileNameChange <tab><tab>NULL <tab><tab> File renamed by user.

@rvalue S_OK | Nodes linked to <p pIDocRootNode> were notified successfully.
@rvalue E_INVALIDARG | <p pIChangedDocRootNode> is not valid.  For example, it may be NULL.
@rvalue E_FAIL | An error occurred, and the nodes linked to <p pIDocRootNode> could not be
		notified.

@ex The following example notifies interested nodes that the name of a Style has changed: |

HRESULT CStyle::SetNodeName( BSTR bstrName )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( m_pComponent != NULL );
	ASSERT( m_pComponent->m_pIFramework != NULL );

	CString strName = bstrName;
	::SysFreeString( bstrName );

	m_strName = strName;

	IDMUSProdPropSheet* pIPropSheet;
	if( SUCCEEDED ( m_pComponent->m_pIFramework->QueryInterface( IID_IDMUSProdPropSheet, (void**)&pIPropSheet ) ) )
	{
		pIPropSheet->RefreshTitleByObject( this );
		pIPropSheet->Release();
	}
	
	SetModified( TRUE );

	// Notify connected nodes that the Style name has changed
	m_pComponent->m_pIFramework->NotifyNodes( this, STYLE_NameChange, NULL );

	return S_OK;
}
	
@xref <i IDMUSProdFramework>, <om IDMUSProdFramework.AddToNotifyList>, <om IDMUSProdFramework.RemoveFromNotifyList>, <i IDMUSProdNotifySink>
--------------------------------------------------------------------------------------*/

/////////////////////////////////////////////////////////////////////////////
// CFramework::NotifyNodes

HRESULT CFramework::NotifyNodes(
	IDMUSProdNode* pIChangedDocRootNode, // @parm [in] Pointer to the changed DocRoot's <i IDMUSProdNode>
									 //		interface.
	GUID guidUpdateType,			 // @parm [in] Identifies type of change.
	void* pData						 // @parm [in] Pointer to additional data associated
									 //		with the change.
)
{
	AFX_MANAGE_STATE( AfxGetAppModuleState() );

	if( pIChangedDocRootNode == NULL )
	{
		return E_INVALIDARG;
	}

	// Get the CFileNode associated with pIChangedDocRootNode
	CFileNode* pFileNode = theApp.GetFileByDocRootNode( pIChangedDocRootNode );
	if( pFileNode == NULL )
	{
		return E_FAIL;
	}

	CJzNotifyNode* pJzNotifyNode;
	IDMUSProdNotifySink* pINotifySink;

	// Send notification to all nodes in the CFileNode's notify list
	POSITION pos = pFileNode->m_lstNotifyNodes.GetHeadPosition();
    while( pos != NULL )
    {
        pJzNotifyNode = static_cast<CJzNotifyNode*>( pFileNode->m_lstNotifyNodes.GetNext(pos) );
		if( pJzNotifyNode->m_pINotifyThisNode )
		{
			if( SUCCEEDED ( pJzNotifyNode->m_pINotifyThisNode->QueryInterface( IID_IDMUSProdNotifySink, (void **)&pINotifySink ) ) )
			{
				pINotifySink->OnUpdate( pIChangedDocRootNode, guidUpdateType, pData );
				pINotifySink->Release();
			}
		}
    }

	pFileNode->Release();

	return S_OK;
}


/*======================================================================================
METHOD:  IDMUSPRODFRAMEWORK::ALLOCFILESTREAM
========================================================================================
@method HRESULT | IDMUSProdFramework | AllocFileStream | Returns an IStream interface pointer
		for the file specified in <p bstrFileName>. 

@comm 
	Streams created through either <om IDMUSProdFramework.AllocFileStream> or
	<om IDMUSProdFramework.AllocMemoryStream> implement <i IDMUSProdPersistInfo> for the purpose
	of making available additional information about the stream.  In particular, these methods
	associate a file type and data format with every stream they create.  In addition,
	<om IDMUSProdFramework.AllocFileStream> associates a target directory node with each stream
	having a <p dwDesiredAccess> of GENERIC_READ.
	
	An object can obtain a pointer to a stream's <i IDMUSProdPersistInfo> interface via a call to
	<om IStream::QueryInterface>.  <om IDMUSProdPersistInfo.GetStreamInfo> returns the <p ftFileType>,
	<p guidDataFormat>, and <p pITargetDirectoryNode> associated with a stream.  <p pITargetDirectory>
	will always be NULL for streams created via <om IDMUSProdFramework.AllocMemoryStream>.

	The following file types are valid for use in <p ftFileType>:

	FT_DESIGN: <tab>Design-time saves may include chunks of UI related information only used
	during editing.
	
	FT_RUNTIME: <tab>Runtime saves are invoked to create files for distribution.  Data should
	be saved in its most compact form.    

	FT_UNKNOWN: <tab>FT_UNKNOWN is only valid when <om IDMUSProdFramework::AllocFileStream>
	is called to open a file.
	
	<p guidDataFormat> indicates the specific format to be used when writing data into the
	stream.  Objects may create additional GUIDs to communicate specific data formats they need
	when persisting data.  The <o Framework> supplies the following GUIDs for general use:
	
	GUID_CurrentVersion: <tab><tab>Current version of the file format.

	GUID_CurrentVersion_OnlyUI: <tab>Current version of the file format (UI state information only).

	GUID_DirectMusicObject: <tab><tab>Stream being prepared to persist into a DirectMusic object.

	GUID_Bookmark: <tab><tab><tab>Framework uses this GUID when creating streams to include in bookmarks.

	GUID_AllZeros: <tab><tab><tab>GUID_AllZeros is only valid when <om IDMUSProdFramework::AllocFileStream>
	is called to open a file.

@rvalue S_OK | The IStream interface pointer was returned in <p ppIStream>.
@rvalue E_INVALIDARG | Either <p dwDesiredAccess> or <p ftFileType> is not valid.
		For example, <p dwDesiredAccess> must be GENERIC_READ or GENERIC_WRITE.
@rvalue E_OUTOFMEMORY | Out of memory.
@rvalue E_FAIL | An error occurred, and the file could not be opened.
	
@xref <i IDMUSProdFramework>, <om IDMUSProdFramework.AllocMemoryStream>, <i IDMUSProdPersistInfo>
--------------------------------------------------------------------------------------*/

//////////////////////////////////////////////////////////////////////////////
// CFramework::AllocFileStream

HRESULT CFramework::AllocFileStream(
	BSTR bstrFileName,		// @parm [in] Name of file.  This method frees <p bstrFileName>
							//		with SysFreeString when it is no longer needed.
	DWORD dwDesiredAccess,	// @parm [in] GENERIC_READ or GENERIC_WRITE.
	FileType ftFileType,	// @parm [in] Type of file. FT_DESIGN, FT_RUNTIME, or FT_UNKNOWN.
	GUID guidDataFormat,	// @parm [in] GUID identifying data format of stream.
	IDMUSProdNode* pITargetDirectoryNode,	// @parm [in] <i IDMUSProdNode> interface pointer
							//		to the Project Tree Directory <o Node> that will contain
							//		this file. 
	IStream **ppIStream		// @parm [out,retval] Address of a variable to receive the requested
							//		<i IStream> interface.
							//		If an error occurs, the implementation sets <p ppIStream>
							//		to NULL.  On success, the caller is responsible for calling
							//		<om IStream.Release>.
)
{
	AFX_MANAGE_STATE( AfxGetAppModuleState() );

	CString strFileName = bstrFileName;
	::SysFreeString( bstrFileName );

    return ::AllocFileStream( strFileName, dwDesiredAccess,
							  ftFileType, guidDataFormat, pITargetDirectoryNode, ppIStream );
}


/*======================================================================================
METHOD:  IDMUSPRODFRAMEWORK::ALLOCMEMORYSTREAM
========================================================================================
@method HRESULT | IDMUSProdFramework | AllocMemoryStream | Returns an IStream interface pointer
		for a newly created memory stream. 

@comm 
	Streams created through either <om IDMUSProdFramework.AllocFileStream> or
	<om IDMUSProdFramework.AllocMemoryStream> implement <i IDMUSProdPersistInfo> for the purpose
	of making available additional information about the stream.  In particular, these methods
	associate a file type and data format with every stream they create.  In addition,
	<om IDMUSProdFramework.AllocFileStream> associates a target directory node with each stream
	having a <p dwDesiredAccess> of GENERIC_READ.
	
	An object can obtain a pointer to a stream's <i IDMUSProdPersistInfo> interface via a call to
	<om IStream::QueryInterface>.  <om IDMUSProdPersistInfo.GetStreamInfo> returns the <p ftFileType>,
	<p guidDataFormat>, and <p pITargetDirectoryNode> associated with a stream.  <p pITargetDirectory>
	will always be NULL for streams created via <om IDMUSProdFramework.AllocMemoryStream>.

	The following file types are valid for use in <p ftFileType>:

	FT_DESIGN: <tab>Design-time saves may include chunks of UI related information only used
	during editing.
	
	FT_RUNTIME: <tab>Runtime saves are invoked to create files for distribution.  Data should
	be saved in its most compact form.    
	
	<p guidDataFormat> indicates the specific format to be used when writing data into the
	memory stream.  Objects may create additional GUIDs to communicate specific data formats
	they need when persisting data.  The <o Framework> supplies the following GUIDs for general use:
	
	GUID_CurrentVersion: <tab><tab>Current version of the file format.

	GUID_CurrentVersion_OnlyUI: <tab>Current version of the file format (UI state information only).

	GUID_DirectMusicObject: <tab><tab>Stream being prepared to persist into a DirectMusic object.

	GUID_Bookmark: <tab><tab><tab>Framework uses this GUID when creating streams to include in bookmarks.

@rvalue S_OK | The IStream interface pointer was returned in <p ppIStream>.
@rvalue E_INVALIDARG | <p ftFileType> is not valid.  For example, <p ftFileType> must be
		FT_DESIGN or FT_RUNTIME.
@rvalue E_OUTOFMEMORY | Out of memory.
@rvalue E_FAIL | An error occurred, and the stream could not be created.
	
@xref <i IDMUSProdFramework>, <om IDMUSProdFramework.AllocFileStream>, <i IDMUSProdPersistInfo>
--------------------------------------------------------------------------------------*/

//////////////////////////////////////////////////////////////////////////////
// CFramework::AllocMemoryStream

HRESULT CFramework::AllocMemoryStream(
	FileType ftFileType,	// @parm [in] Type of file. FT_DESIGN or FT_RUNTIME.
	GUID guidDataFormat,	// @parm [in] GUID identifying data format of stream.
	IStream **ppIStream		// @parm [out,retval] Address of a variable to receive the requested
							//		<i IStream> interface.
							//		If an error occurs, the implementation sets <p ppIStream>
							//		to NULL.  On success, the caller is responsible for calling
							//		<om IStream.Release>.
)
{
	AFX_MANAGE_STATE( AfxGetAppModuleState() );

    return ::AllocMemoryStream( ftFileType, guidDataFormat, ppIStream );
}


/*======================================================================================
METHOD:  IDMUSPRODFRAMEWORK8::GETNODERUNTIMEFILENAME
========================================================================================
*/
/////////////////////////////////////////////////////////////////////////////
// CFramework::GetNodeRuntimeFileName

HRESULT CFramework::GetNodeRuntimeFileName(
	IDMUSProdNode* pINode,	
	BSTR* pbstrRuntimeFileName		
)
{
	AFX_MANAGE_STATE( AfxGetAppModuleState() );

	if( pbstrRuntimeFileName == NULL )
	{
		return E_POINTER;
	}

	*pbstrRuntimeFileName = NULL;

	if( pINode == NULL )
	{
		return E_INVALIDARG;
	}

	GUID guidNodeId;
	if( SUCCEEDED ( pINode->GetNodeId ( &guidNodeId ) ) )
	{
		// Handle Project Folder and Directory Nodes
		if( IsEqualGUID( guidNodeId, GUID_ProjectFolderNode ) 
		||  IsEqualGUID( guidNodeId, GUID_DirectoryNode ) )
		{
			return E_UNEXPECTED;
		}

		// Handle FileNodes
		else if( IsEqualGUID( guidNodeId, GUID_FileNode ) )
		{
			CFileNode* pFileNode = (CFileNode *)pINode;

			*pbstrRuntimeFileName = pFileNode->m_strRuntimeFile.AllocSysString();
			return S_OK;
		}
	}

	// Handle other Nodes
	CComponentDoc* pComponentDoc = theApp.FindComponentDocument( pINode );
	if( pComponentDoc
	&&  pComponentDoc->m_pFileNode )
	{
		*pbstrRuntimeFileName = pComponentDoc->m_pFileNode->m_strRuntimeFile.AllocSysString();
		return S_OK;
	}

	return E_FAIL;
}


/*======================================================================================
METHOD:  IDMUSPRODFRAMEWORK::RESOLVEBESTGUESSWHENLOADFINISHED
========================================================================================
@method HRESULT | IDMUSProdFramework | ResolveBestGuessWhenLoadFinished | Adds <p pINotifySink>
	to a list which will receive FRAMEWORK_FileLoadFinished notifications, and returns a
	Producer generated GUID assigned to the referenced file.

@comm
	The search is confined to the <o Project> containing <p pITreePositionNode>.

    Call this method when <om IDMUSProdFramework.GetBestGuessDocRootNode> returns E_PENDING and
	you wish to be notified when the matching file has finished loading.

	<p pIDocType>, <p bstrNodeName>, and <p pITreePositionNode>  must equal the arguments
	passed to <om IDMUSProdFramework.GetBestGuessDocRootNode> when E_PENDING was returned.

@rvalue S_OK | A Producer generated GUID was returned in <p pguidFile>.
@rvalue E_POINTER | The address in <p pguidFile> is not valid.  For example, it may be NULL.
@rvalue E_INVALIDARG | The address in either <p pINotifySink>, <p bstrNodeName>, <p pIDocType>,
	or <p pITreePositionNode> is not valid.  For example, it may be NULL.
@rvalue E_FAIL | An error occurred, and the GUID could not be returned.

@ex The following example:|

@xref <i IDMUSProdFramework>, <om IDMUSProdFramework.GetBestGuessDocRootNode>, <i IDMUSProdNode>
--------------------------------------------------------------------------------------*/

/////////////////////////////////////////////////////////////////////////////
// CFramework::ResolveBestGuessWhenLoadFinished

HRESULT CFramework::ResolveBestGuessWhenLoadFinished(
	IDMUSProdDocType* pIDocType,		// @parm [in] Pointer to the <i IDMUSProdDocType> interface
										//		associated with the desired type of DocRoot node.
	BSTR bstrNodeName,					// @parm [in] Name of desired DocRoot node.  This method
										//		frees <p bstrNodeName> with SysFreeString when it
										//		is no longer needed.
	IDMUSProdNode* pITreePositionNode,	// @parm [in] Specifies position in Project Tree.  Used by search
										//		algorithm.
	IDMUSProdNotifySink* pINotifySink,	// @parm [in] Pointer to IDMUSProdNotifySink interface
										//		which will be sent a FRAMEWORK_FileLoadFinished notification.
	GUID* pguidFile						// @parm [out,retval] Address of a variable to receive the requested  
										//		GUID.  If an error occurs, the implementation sets
										//		<p pguidFile> to NULL. 
)
{
	AFX_MANAGE_STATE( AfxGetAppModuleState() );

	if( pguidFile )
	{
		*pguidFile = GUID_AllZeros;
	}

	// Validate bstrNodeName
	CString strNodeName;
	if( bstrNodeName == NULL )
	{
		return E_INVALIDARG;
	}
	else
	{
		strNodeName = bstrNodeName;
		::SysFreeString( bstrNodeName );
	}

	// Validate pguidFile
	if( pguidFile == NULL )
	{
		return E_POINTER;
	}

	// Validate pITreePositionNode, pINotifySink, and pIDocType
	if( pIDocType == NULL 
	||  pITreePositionNode == NULL 
	||  pINotifySink == NULL )
	{
		return E_INVALIDARG;
	}

	HRESULT hr = E_FAIL;

	// Does DocRoot exist in a Container that is just now being unpacked?
	IDMUSProdComponent* pIComponent;
	if( SUCCEEDED ( FindComponent( CLSID_ContainerComponent,  &pIComponent ) ) )
	{
		IDMUSProdUnpackingFiles* pIUnpackingFiles;
		if( SUCCEEDED ( pIComponent->QueryInterface( IID_IDMUSProdUnpackingFiles, (void **)&pIUnpackingFiles ) ) )
		{
			IUnknown* pIUnknown;
			BSTR bstrName = strNodeName.AllocSysString();
			hr = pIUnpackingFiles->GetDocRootOfEmbeddedFile( pIDocType, bstrName, &pIUnknown );
			if( SUCCEEDED ( hr ) )
			{
				pIUnknown->Release();
			}
			else if( hr == E_PENDING )
			{
				// File is being loaded so add to pINotifySink to file's notification list
				BSTR bstrName = strNodeName.AllocSysString();
				pIUnpackingFiles->AddToNotifyWhenLoadFinished( pIDocType, bstrName, pINotifySink, pguidFile );
			}

			pIUnpackingFiles->Release();
		}

		pIComponent->Release();
	}
	if( SUCCEEDED(hr) )
	{
		// File is already loaded
		return E_FAIL;
	}
	else if( hr == E_PENDING )
	{
		// File is in process of being loaded
		return S_OK;
	}

	// Does DocRoot exist in a Sibg that is just now being unpacked?
	/*
	if( SUCCEEDED ( FindComponent( CLSID_SongComponent,  &pIComponent ) ) )
	{
		IDMUSProdUnpackingFiles* pIUnpackingFiles;
		if( SUCCEEDED ( pIComponent->QueryInterface( IID_IDMUSProdUnpackingFiles, (void **)&pIUnpackingFiles ) ) )
		{
			IUnknown* pIUnknown;
			BSTR bstrName = strNodeName.AllocSysString();
			hr = pIUnpackingFiles->GetDocRootOfEmbeddedFile( pIDocType, bstrName, &pIUnknown );
			if( SUCCEEDED ( hr ) )
			{
				pIUnknown->Release();
			}
			else if( hr == E_PENDING )
			{
				// File is being loaded so add to pINotifySink to file's notification list
				BSTR bstrName = strNodeName.AllocSysString();
				pIUnpackingFiles->AddToNotifyWhenLoadFinished( pIDocType, bstrName, pINotifySink, pguidFile );
			}

			pIUnpackingFiles->Release();
		}

		pIComponent->Release();
	}
	if( SUCCEEDED(hr) )
	{
		// File is already loaded
		return E_FAIL;
	}
	else if( hr == E_PENDING )
	{
		// File is in process of being loaded
		return S_OK;
	}
	*/

	// The file is not in a Container or Song that is being unpacked
	hr = E_FAIL;

	// Get the Project
	IDMUSProdProject* pIProject;
	if( SUCCEEDED ( theApp.m_pFramework->FindProject( pITreePositionNode, &pIProject ) ) )
	{
		CProject* pProject = (CProject *)pIProject;

		// Look for an appropriate FileNode
		CFileNode* pFileNode = pProject->GetBestGuessDocRootNode( pIDocType, strNodeName, pITreePositionNode );
		if( pFileNode )
		{
			// Make sure file is in process of being loaded
			if( pFileNode->m_pIChildNode == NULL 
			&&  pFileNode->m_fInOnOpenDocument )
			{
				// File is being loaded so add to pINotifySink to file's notification list
				pFileNode->AddToNotifyWhenLoadFinished( pINotifySink );
				*pguidFile = pFileNode->m_guid;
				hr = S_OK;
			}

			pFileNode->Release();
		}

		pIProject->Release();
	}

	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CFramework::StartWaitCursor

HRESULT CFramework::StartWaitCursor( void )
{
	AFX_MANAGE_STATE( AfxGetAppModuleState() );

	CMainFrame* pMainFrame = (CMainFrame *)theApp.m_pMainWnd;
	ASSERT( pMainFrame != NULL );

	if( pMainFrame->m_pWaitCursor == NULL )
	{
		pMainFrame->m_pWaitCursor = new CJzWaitCursor( pMainFrame, &pMainFrame->m_wndStatusBar );
		if( pMainFrame->m_pWaitCursor == NULL )
		{
			return E_OUTOFMEMORY;
		}
	}

	pMainFrame->m_pWaitCursor->StartWait();

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CFramework::EndWaitCursor

HRESULT CFramework::EndWaitCursor( void )
{
	AFX_MANAGE_STATE( AfxGetAppModuleState() );

	CMainFrame* pMainFrame = (CMainFrame *)theApp.m_pMainWnd;
	ASSERT( pMainFrame != NULL );

	if( pMainFrame->m_pWaitCursor )
	{
		if( pMainFrame->m_pWaitCursor->EndWait() == 0 )	// CJzWaitCursor was deleted
		{
			pMainFrame->m_pWaitCursor = NULL;
		}
	}

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CFramework::ReadTheRefChunk

HRESULT CFramework::ReadTheRefChunk( IDMUSProdRIFFStream* pIRiffStream, MMCKINFO* pckMain, IDMUSProdNode** ppIDocRootNode )
{
	AFX_MANAGE_STATE( AfxGetAppModuleState() );

    IStream* pIStream;
    HRESULT hr;
	DWORD dwByteCount;
	DWORD dwSize;
	CFileNode* pFileNode;
	ioFileRef iFileRef;

    pIStream = pIRiffStream->GetStream();
	ASSERT( pIStream != NULL );

	if( ppIDocRootNode == NULL )
	{
		hr = E_POINTER;
		goto ON_ERROR;
	}

	*ppIDocRootNode = NULL;

	if( pIRiffStream == NULL
	||  pckMain == NULL )
	{
		hr = E_INVALIDARG;
		goto ON_ERROR;
	}

	// Initialize ioFileRef structure
	memset( &iFileRef, 0, sizeof(ioFileRef) );

    dwSize = min( pckMain->cksize, sizeof( ioFileRef ) );

	// Read the FileRef chunk data
    hr = pIStream->Read( &iFileRef, dwSize, &dwByteCount );
    if( FAILED( hr )
	||  dwByteCount != dwSize )
	{
		goto ON_ERROR;
	}

	hr = E_FAIL;
	pFileNode = NULL;

	// Get the referenced file's FileNode
	pFileNode = theApp.GetFileByGUID( iFileRef.guidFile );

	// We found the referenced file's FileNode
	if( pFileNode )
	{
		// Make sure the FileNode's file is loaded
		if( pFileNode->m_pIChildNode == NULL )
		{
			if( pFileNode->m_fInOnOpenDocument )
			{
				hr = E_PENDING;
			}
			else
			{
				CString strFileName;
				pFileNode->ConstructFileName( strFileName );
				
				// Open the file
				theApp.m_nShowNodeInTree++;
				theApp.OpenTheFile( strFileName, TGT_FILENODE );
				theApp.m_nShowNodeInTree--;
			}
		}

		if( pFileNode->m_pIChildNode )
		{
			pFileNode->m_pIChildNode->AddRef();
			*ppIDocRootNode = pFileNode->m_pIChildNode;
			hr = S_OK;
		}

		pFileNode->Release();
	}

ON_ERROR:
    pIStream->Release();

    return hr;
}


/*======================================================================================
METHOD:  IDMUSPRODFILEREFCHUNK::LOADREFCHUNK
========================================================================================
@method HRESULT | IDMUSProdFileRefChunk | LoadRefChunk | Reads a DirectMusic Producer file
		reference RIFF chunk, loads the referenced file, and returns a pointer to the
		referenced file's DocRoot node in <p ppIDocRootNode>. 

@comm
	A DirectMusic Producer <o Component> can call <om IDMUSProdFramework::QueryInterface>
	to obtain a pointer to the <o Framework>'s <i IDMUSProdFileRefChunk> interface.

	Call <om IDMUSProdFileRefChunk.SaveRefChunk> to create the DirectMusic Producer file
	reference RIFF chunk loaded by <om IDMUSProdFileRefChunk.LoadRefChunk>.

@rvalue S_OK | The top node of the referenced file was returned in <p ppIDocRootNode>.
@rvalue E_POINTER | The address in <p ppIDocRootNode> is not valid.  For example, it may be NULL.
@rvalue E_INVALIDARG | The value of <p pIStream> is not valid.  For example, it may be NULL.
@rvalue E_PENDING | The referenced file is in the process of loading and its top node could not
	be returned.
@rvalue E_FAIL | An error occurred, and the top node of the refrenced file could not be returned.

@ex The following example reads a DirectMusic Producer file reference chunk and creates a
	reference <o Node>: |

	const GUID GUID_StyleRefNode = {0x408FBB21,0xB009,0x11D0,{0x89,0xAD,0x00,0xA0,0xC9,0x05,0x41,0x29}}; 
	const GUID GUID_StyleNode = {0xFAE21E45,0xA51A,0x11D0,{0x89,0xAD,0x00,0xA0,0xC9,0x05,0x41,0x29}}; 
	const CLSID CLSID_StyleComponent = {0x44207721,0x487B,0x11d0,{0x89,0xAC,0x00,0xA0,0xC9,0x05,0x41,0x29}}; 

	IDMUSProdNode* m_pIStyleRefNode;	// member variable storing pointer to reference Node

    IDMUSProdFramework* pIFramework;
	IDMUSProdFileRefChunk* pIFileRefChunk;
	IStream* pIStream;
	IDMUSProdNode* pINode;

	IDMUSProdNode* pIDocRootNode = NULL;

	// Get an IDMUSProdNode* pointer to the top node of the referenced file
    if( SUCCEEDED ( pIFramework->QueryInterface( IID_IDMUSProdFileRefChunk, (void **)&pIFileRefChunk ) ) )
	{
		if( FAILED ( pIFileRefChunk->LoadRefChunk( pIStream, &pIDocRootNode ) ) )
		{
			if( AfxMessageBox( IDS_BROWSE_FOR_FILE, MB_YESNO ) == IDYES )
			{
				IDMUSProdDocType* pIDocType;

				if( SUCCEEDED ( pIFramework->FindDocTypeByNodeId( GUID_StyleNode, &pIDocType ) ) )
				{
					pIFramework->OpenFile( pIDocType, NULL, pINode, &pIDocRootNode );
					pIDocType->Release();
				}
			}
		}

		pIFileRefChunk->Release();
	}

	// Create a reference node for the referenced file
    if( pIDocRootNode )
	{
		IDMUSProdComponent* pIComponent;

		if( SUCCEEDED ( pIFramework->FindComponent( CLSID_StyleComponent, &pIComponent ) ) )
		{
			if( SUCCEEDED ( pIComponent->AllocReferenceNode( GUID_StyleRefNode, &m_pIStyleRefNode ) ) )
			{
				IDMUSProdReferenceNode* pIReferenceNode;

				if( SUCCEEDED ( m_pIStyleRefNode->QueryInterface( IID_IDMUSProdReferenceNode, (void **)&pIReferenceNode ) ) )
				{
					pIReferenceNode->SetReferencedFile( pIDocRootNode );
					pIReferenceNode->Release();
				}
			}
			pIComponent->Release();
		}
	}

  
@xref <o Node> Object, <i IDMUSProdFileRefChunk>, <om IDMUSProdFileRefChunk.SaveRefChunk>, <om IDMUSProdFileRefChunk.GetChunkSize>, <om IDMUSProdFramework.OpenFile>, <i IDMUSProdReferenceNode>
--------------------------------------------------------------------------------------*/

/////////////////////////////////////////////////////////////////////////////
// CFramework::LoadRefChunk

HRESULT CFramework::LoadRefChunk(
	IStream* pIStream,				// @parm [in] Pointer to IStream interface.
	IDMUSProdNode** ppIDocRootNode	// @parm [out,retval] Address of a variable to receive the requested  
									//		<i IDMUSProdNode> interface.  If an error occurs, the implementation
									//		sets <p ppIDocRootNode> to NULL.  On success, the caller
									//		is responsible for calling <om IDMUSProdNode.Release> when
									//		this pointer is no longer needed.
)
{
	AFX_MANAGE_STATE( AfxGetAppModuleState() );

    IDMUSProdRIFFStream* pIRiffStream;
    MMCKINFO ckMain;

	if( ppIDocRootNode == NULL )
	{
		return E_POINTER;
	}

	*ppIDocRootNode = NULL;

	if( pIStream == NULL )
	{
		return E_INVALIDARG;
	}

	HRESULT hr = E_FAIL;

    if( SUCCEEDED( AllocRIFFStream( pIStream, &pIRiffStream ) ) )
    {
        ckMain.ckid = FOURCC_DMUSPROD_FILEREF;

        if( pIRiffStream->Descend( &ckMain, NULL, MMIO_FINDCHUNK ) == 0 )
        {
            hr = ReadTheRefChunk( pIRiffStream, &ckMain, ppIDocRootNode );
        }

        pIRiffStream->Release();
    }

    return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CFramework::WriteTheRefChunk

HRESULT CFramework::WriteTheRefChunk( IDMUSProdRIFFStream* pIRiffStream, CFileNode* pFileNode )
{
    IStream* pIStream;
    HRESULT hr;
    MMCKINFO ck;
	DWORD dwBytesWritten;
	CString strRelativePath;
	ioFileRef oFileRef;

    pIStream = pIRiffStream->GetStream();
	ASSERT( pIStream != NULL );

	if( pIRiffStream == NULL
	||  pFileNode == NULL )
	{
		hr = E_INVALIDARG;
		goto ON_ERROR;
	}

	// Get the referenced file's relative path
	if( pFileNode->ConstructRelativePath( strRelativePath ) )
	{
		strRelativePath = _T("..\\") + strRelativePath;
	}
	if( strRelativePath.IsEmpty() )
	{
		hr = E_FAIL;
		goto ON_ERROR;
	}

	// Append the referenced file's name to the relative path
	BSTR bstrFileName;

	hr = pFileNode->GetNodeName( &bstrFileName );
	if( FAILED ( hr ) )
	{
		goto ON_ERROR;
	}
	if( strRelativePath.Right(1) != _T("\\") )
	{
		strRelativePath += _T("\\");
	}
	strRelativePath += CString(bstrFileName);
	::SysFreeString( bstrFileName );

	// Make sure the FileNode has a DocRoot Node
	if( pFileNode->m_pIChildNode == NULL )
	{
		hr = E_FAIL;
		goto ON_ERROR;
	}

	// Get the DocRoot's Node ID
	GUID guidDocRootNodeId;

	if( FAILED ( pFileNode->m_pIChildNode->GetNodeId ( &guidDocRootNodeId ) ) )
	{
		hr = E_FAIL;
		goto ON_ERROR;
	}

	// Write FileRef chunk header
	ck.ckid = FOURCC_DMUSPROD_FILEREF;
	if( pIRiffStream->CreateChunk( &ck, 0 ) != 0 )
	{
		hr = E_FAIL;
		goto ON_ERROR;
	}

	// Prepare ioFileRef structure
	memset( &oFileRef, 0, sizeof(ioFileRef) );
	memcpy( &oFileRef.guidFile, &pFileNode->m_guid, sizeof( oFileRef.guidFile ) );
	memcpy( &oFileRef.guidDocRootNodeId, &guidDocRootNodeId, sizeof( oFileRef.guidDocRootNodeId ) );

	// Use file GUID from new Project if in the middle of 'Duplicate Project'
	if( theApp.m_fInDuplicateProject )
	{
		GUID guidNewFile;

		if( theApp.GetNewGUIDForDuplicateFile( pFileNode->m_guid, &guidNewFile ) )
		{
			memcpy( &oFileRef.guidFile, &guidNewFile, sizeof( oFileRef.guidFile ) );
		}
	}

	// Write FileRef chunk data 
	hr = pIStream->Write( &oFileRef, sizeof(ioFileRef), &dwBytesWritten);
	if( FAILED( hr )
	||  dwBytesWritten != sizeof(ioFileRef) )
	{
        hr = E_FAIL;
        goto ON_ERROR;
	}

	if( pIRiffStream->Ascend( &ck, 0 ) != 0 )
	{
 		hr = E_FAIL;
		goto ON_ERROR;
	}

ON_ERROR:
    pIStream->Release();

    return hr;
}


/*======================================================================================
METHOD:  IDMUSPRODFILEREFCHUNK::SAVEREFCHUNK
========================================================================================
@method HRESULT | IDMUSProdFileRefChunk| SaveRefChunk | Saves a DirectMusic Producer file
		reference RIFF chunk. 

@comm
	A DirectMusic Producer <o Component> can call <om IDMUSProdFramework::QueryInterface>
	to obtain a pointer to the <o Framework>'s <i IDMUSProdFileRefChunk> interface.

	Call <om IDMUSProdFileRefChunk.LoadRefChunk> to load the DirectMusic Producer file
	reference RIFF chunk created by <om IDMUSProdFileRefChunk.SaveRefChunk>.

@rvalue S_OK | The DirectMusic Producer file reference RIFF chunk was saved successfully.
@rvalue E_INVALIDARG | Either <p pIStream> or <p pIDocRootNode> is not valid.  For example,
		they may be NULL.
@rvalue E_FAIL | An error occurred, and the file reference chunk could not be saved.

@ex The following code excerpt handles creation of file reference chunks correctly.  Reference
	chunks are saved differently when persisting directly into a DirectMusic object because Producer's
	implementation of IDirectMusicLoader will be called upon to resolve the reference.  When saving to
	a file, the file type (FT_RUNTIME, FT_DESIGN) returned by <om IDMUSProdPersistInfo.GetStreamInfo> 
	determines whether or not it is necessary to save the Producer specific file reference chunk: |


	// Write Reference chunk
	if( pIStyleDocRootNode )
	{
		if( ::IsEqualGUID( guidDataFormat, GUID_DirectMusicObject ) )
		{
			SaveDMRef( pIRiffStream, pIStyleDocRootNode, WL_PRODUCER );
		}
		else if( ::IsEqualGUID( guidDataFormat, GUID_CurrentVersion ) )
		{
			SaveDMRef( pIRiffStream, pIStyleDocRootNode, WL_DIRECTMUSIC );
			if( ftFileType == FT_DESIGN )
			{
				SaveProducerRef( pIRiffStream, pIStyleDocRootNode );
			}
		}
	}


HRESULT CStyleRefMgr::SaveProducerRef( IDMUSProdRIFFStream* pIRiffStream, IDMUSProdNode* pIDocRootNode )
{
	IDMUSProdFileRefChunk* pIFileRefChunk;

	ASSERT( m_pIFramework != NULL );
	if( m_pIFramework == NULL )
	{
		return E_FAIL;
	}

    IStream* pIStream = pIRiffStream->GetStream();
	ASSERT( pIStream != NULL );

	if ( SUCCEEDED ( m_pIFramework->QueryInterface( IID_IDMUSProdFileRefChunk, (void**)&pIFileRefChunk ) ) )
	{
		pIFileRefChunk->SaveRefChunk( pIStream, pIDocRootNode );
		pIFileRefChunk->Release();
	}

	pIStream->Release();
	return S_OK;
}


HRESULT CStyleRefMgr::SaveDMRef( IDMUSProdRIFFStream* pIRiffStream,
								 IDMUSProdNode* pIDocRootNode, WhichLoader whichLoader )
{
	IDMUSProdLoaderRefChunk* pIRefChunkLoader;

	ASSERT( m_pIFramework != NULL );
	if( m_pIFramework == NULL )
	{
		return E_FAIL;
	}

	HRESULT hr = E_FAIL;

    IStream* pIStream = pIRiffStream->GetStream();
	ASSERT( pIStream != NULL );

	if( SUCCEEDED( m_pIFramework->QueryInterface( IID_IDMUSProdLoaderRefChunk, (void**)&pIRefChunkLoader ) ) )
	{
		if( pIRefChunkLoader )
		{
			switch( whichLoader )
			{
				case WL_DIRECTMUSIC:
				case WL_PRODUCER:
					hr = pIRefChunkLoader->SaveRefChunkForLoader( pIStream,
																  pIDocRootNode,
																  CLSID_DirectMusicStyle,
																  NULL,
																  whichLoader );
					break;
			}

			pIRefChunkLoader->Release();
		}
	}

	pIStream->Release();
	return hr;
}
	
@xref <i IDMUSProdLoaderRefChunk>, <i IDMUSProdFileRefChunk>, <om IDMUSProdFileRefChunk.LoadRefChunk>, <om IDMUSProdFileRefChunk.GetChunkSize>, <om IDMUSProdFramework.OpenFile>, <i IDMUSProdReferenceNode>
--------------------------------------------------------------------------------------*/

/////////////////////////////////////////////////////////////////////////////
// CFramework::SaveRefChunk

HRESULT CFramework::SaveRefChunk(
	IStream* pIStream,				// @parm [in] Pointer to IStream interface.
	IDMUSProdNode* pIDocRootNode	// @parm [in] Pointer to an <i IDMUSProdNode> interface for the DocRoot
									//		<o Node> of the referenced file.
)
{
	AFX_MANAGE_STATE( AfxGetAppModuleState() );

	if( pIStream == NULL
	||  pIDocRootNode == NULL )
	{
		return E_INVALIDARG;
	}

	HRESULT hr;

	CFileNode* pFileNode = NULL;
    IDMUSProdRIFFStream* pIRiffStream = NULL;
	CComponentDoc* pComponentDoc;

	// Get the DocRoot's FileNode
	pComponentDoc = theApp.FindComponentDocument( pIDocRootNode );
	if( pComponentDoc )
	{
		if( pComponentDoc->m_pIDocRootNode == pIDocRootNode )
		{
			pComponentDoc->m_pFileNode->AddRef();
			pFileNode = pComponentDoc->m_pFileNode;
		}
	}
	if( pFileNode == NULL )
	{
		hr = E_FAIL;
		goto ON_ERROR;
	}
	
	// Create a RIFFStream
    hr = AllocRIFFStream( pIStream, &pIRiffStream );
	if( FAILED ( hr ) )
	{
		goto ON_ERROR;
	}

	// Save the DirectMusic Producer Reference Chunk
    hr = WriteTheRefChunk( pIRiffStream, pFileNode );

ON_ERROR:
	if( pIRiffStream )
	{
		pIRiffStream->Release();
	}

	if( pFileNode )
	{
		pFileNode->Release();
	}

	return hr;
}


/*======================================================================================
METHOD:  IDMUSPRODFILEREFCHUNK::GETCHUNKSIZE
========================================================================================
@method HRESULT | IDMUSProdFileRefChunk| GetChunkSize | Returns the size of a DirectMusic
	Producer file reference RIFF chunk.

@rvalue S_OK | The chunk size was returned in <p pdwSize>.
@rvalue E_POINTER | <p pdwSize> is not valid.  For example, it may be NULL.
	
@xref <i IDMUSProdFileRefChunk>, <i IDMUSProdReferenceNode>
--------------------------------------------------------------------------------------*/

/////////////////////////////////////////////////////////////////////////////
// CFramework::GetChunkSize

HRESULT CFramework::GetChunkSize(
	DWORD* pdwSize		// @parm [out,retval] Pointer to size of stream needed to save the
						//		chunk.
)
{
	AFX_MANAGE_STATE( AfxGetAppModuleState() );

	if( pdwSize == NULL )
	{
		return E_POINTER;
	}

	*pdwSize = 8 + sizeof( ioFileRef );

	return S_OK;
}


/*======================================================================================
METHOD:  IDMUSPRODFILEREFCHUNK::RESOLVEWHENLOADFINISHED
========================================================================================
@method HRESULT | IDMUSProdFileRefChunk | ResolveWhenLoadFinished | Adds <p pINotifySink>
	to a list which will receive FRAMEWORK_FileLoadFinished notifications, reads a DirectMusic
	Producer file reference RIFF chunk, and returns the Producer generated GUID assigned
	to the referenced file. 

@comm
	A DirectMusic Producer <o Component> can call <om IDMUSProdFramework::QueryInterface>
	to obtain a pointer to the <o Framework>'s <i IDMUSProdFileRefChunk> interface.

	Call <om IDMUSProdFileRefChunk.SaveRefChunk> to create the DirectMusic Producer file
	reference RIFF chunk loaded by <om IDMUSProdFileRefChunk.LoadRefChunk>.

@rvalue S_OK | The Producer generated GUID was returned in <p pguidFile>.
@rvalue E_POINTER | The address in <p pguidFile> is not valid.  For example, it may be NULL.
@rvalue E_INVALIDARG | The value of <p pIStream> is not valid.  For example, it may be NULL.
@rvalue E_FAIL | An error occurred, and the GUID could not be returned.
  
@xref <o Node> Object, <i IDMUSProdFileRefChunk>, <om IDMUSProdFileRefChunk.SaveRefChunk>, <om IDMUSProdFileRefChunk.GetChunkSize>, <om IDMUSProdFramework.OpenFile>, <i IDMUSProdReferenceNode>
--------------------------------------------------------------------------------------*/

/////////////////////////////////////////////////////////////////////////////
// CFramework::ResolveWhenLoadFinished

HRESULT CFramework::ResolveWhenLoadFinished(
	IStream* pIStream,					// @parm [in] Pointer to IStream interface.
	IDMUSProdNotifySink* pINotifySink,	// @parm [in] Pointer to IDMUSProdNotifySink interface
										//		which will be sent a FRAMEWORK_FileLoadFinished notification.
	GUID* pguidFile						// @parm [out,retval] Address of a variable to receive the requested  
										//		GUID.  If an error occurs, the implementation sets
										//		<p pguidFile> to NULL. 
)
{
	AFX_MANAGE_STATE( AfxGetAppModuleState() );

    IDMUSProdRIFFStream* pIRiffStream;
    MMCKINFO ckMain;

	if( pguidFile == NULL )
	{
		return E_POINTER;
	}

	*pguidFile = GUID_AllZeros;

	if( pIStream == NULL 
	||  pINotifySink == NULL )
	{
		return E_INVALIDARG;
	}

	HRESULT hr = E_FAIL;

    if( SUCCEEDED( AllocRIFFStream( pIStream, &pIRiffStream ) ) )
    {
        ckMain.ckid = FOURCC_DMUSPROD_FILEREF;

        if( pIRiffStream->Descend( &ckMain, NULL, MMIO_FINDCHUNK ) == 0 )
        {
			DWORD dwByteCount;
			ioFileRef iFileRef;

			DWORD dwSize = min( ckMain.cksize, sizeof( ioFileRef ) );

			// Read the FileRef chunk data
			if( SUCCEEDED ( pIStream->Read( &iFileRef, dwSize, &dwByteCount ) ) )
			{
				if( dwByteCount == dwSize )
				{
					// Get the referenced file's FileNode
					CFileNode* pFileNode = theApp.GetFileByGUID( iFileRef.guidFile );
					if( pFileNode )
					{
						pFileNode->AddToNotifyWhenLoadFinished( pINotifySink );
						*pguidFile = iFileRef.guidFile;
						hr = S_OK;

						pFileNode->Release();
					}
				}
			}
        }

        pIRiffStream->Release();
    }

    return hr;
}


/*======================================================================================
METHOD:  IDMUSPRODFILEREFCHUNK::GETFILEREFINFO
========================================================================================
@method HRESULT | IDMUSProdFileRefChunk | GetFileRefInfo | Reads a DirectMusic Producer
	file reference RIFF chunk, and fills a <t DMUSProdFileRefInfo> structure with information
	about the reference. 

@comm
	A DirectMusic Producer <o Component> can call <om IDMUSProdFramework::QueryInterface>
	to obtain a pointer to the <o Framework>'s <i IDMUSProdFileRefChunk> interface.

	Call <om IDMUSProdFileRefChunk.SaveRefChunk> to create the DirectMusic Producer file
	reference RIFF chunk loaded by <om IDMUSProdFileRefChunk.LoadRefChunk>.

@rvalue S_OK | Information about the reference was returned in the <t DMUSProdFileRefInfo> structure.
@rvalue E_POINTER | The address in <p pFileRefInfo> is not valid.  For example, it may be NULL.
@rvalue E_INVALIDARG | The value of <p pIStream> is not valid.  For example, it may be NULL.
@rvalue E_FAIL | An error occurred, and the <t DMUSProdFileRefInfo> structure could not be populated.
  
@xref <o Node> Object, <i IDMUSProdFileRefChunk>, <om IDMUSProdFileRefChunk.SaveRefChunk>, <om IDMUSProdFileRefChunk.GetChunkSize>, <om IDMUSProdFramework.OpenFile>, <i IDMUSProdReferenceNode>
--------------------------------------------------------------------------------------*/

/////////////////////////////////////////////////////////////////////////////
// CFramework::GetFileRefInfo

HRESULT CFramework::GetFileRefInfo(
	IStream* pIStream,					// @parm [in] Pointer to IStream interface.
	DMUSProdFileRefInfo* pFileRefInfo	// @parm [in] [in] Pointer to a DMUSProdFileRefInfo
										//		structure.
)
{
	AFX_MANAGE_STATE( AfxGetAppModuleState() );

    IDMUSProdRIFFStream* pIRiffStream;
    MMCKINFO ckMain;

	if( pFileRefInfo == NULL )
	{
		return E_POINTER;
	}

	if( pIStream == NULL
	||  pFileRefInfo->wSize == 0 )
	{
		return E_INVALIDARG;
	}

	pFileRefInfo->guidFile = GUID_AllZeros;
	pFileRefInfo->guidDocRootNodeId = GUID_AllZeros;

	HRESULT hr = E_FAIL;

    if( SUCCEEDED( AllocRIFFStream( pIStream, &pIRiffStream ) ) )
    {
        ckMain.ckid = FOURCC_DMUSPROD_FILEREF;

        if( pIRiffStream->Descend( &ckMain, NULL, MMIO_FINDCHUNK ) == 0 )
        {
			DWORD dwByteCount;
			ioFileRef iFileRef;

			DWORD dwSize = min( ckMain.cksize, sizeof( ioFileRef ) );

			// Read the FileRef chunk data
			if( SUCCEEDED ( pIStream->Read( &iFileRef, dwSize, &dwByteCount ) ) )
			{
				if( dwByteCount == dwSize )
				{
					pFileRefInfo->guidFile = iFileRef.guidFile;
					pFileRefInfo->guidDocRootNodeId = iFileRef.guidDocRootNodeId;
					hr = S_OK;
				}
			}
        }

        pIRiffStream->Release();
    }

    return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CFramework::WriteTheRefChunkForLoader

HRESULT CFramework::WriteTheRefChunkForLoader( IDMUSProdRIFFStream* pIRiffStream, LPDMUS_OBJECTDESC pObjectDesc )
{
    IStream* pIStream;
    HRESULT hr;
    MMCKINFO ckMain;
    MMCKINFO ck;
	DWORD dwBytesWritten;
	DWORD dwLength;

    pIStream = pIRiffStream->GetStream();
	ASSERT( pIStream != NULL );

	if( pIRiffStream == NULL
	||  pObjectDesc == NULL )
	{
		hr = E_INVALIDARG;
		goto ON_ERROR;
	}

	// Write REF LIST header
	ckMain.fccType = DMUS_FOURCC_REF_LIST;
	if( pIRiffStream->CreateChunk(&ckMain, MMIO_CREATELIST) != 0 )
	{
		hr = E_FAIL;
		goto ON_ERROR;
	}

	// Write REF chunk
	{
		DMUS_IO_REFERENCE dmusReference;

		ck.ckid = DMUS_FOURCC_REF_CHUNK;
		if( pIRiffStream->CreateChunk( &ck, 0 ) != 0 )
		{
			hr = E_FAIL;
			goto ON_ERROR;
		}

		// Prepare DMUS_IO_REFERENCE structure
		memset( &dmusReference, 0, sizeof(DMUS_IO_REFERENCE) );
		memcpy( &dmusReference.guidClassID, &pObjectDesc->guidClass, sizeof(GUID) );
		dmusReference.dwValidData = pObjectDesc->dwValidData;

		// Write REF chunk data 
		hr = pIStream->Write( &dmusReference, sizeof(DMUS_IO_REFERENCE), &dwBytesWritten);
		if( FAILED( hr )
		||  dwBytesWritten != sizeof(DMUS_IO_REFERENCE) )
		{
			hr = E_FAIL;
			goto ON_ERROR;
		}

		if( pIRiffStream->Ascend(&ck, 0) != 0 )
		{
			hr = E_FAIL;
			goto ON_ERROR;
		}
	}

	// Write GUID chunk
	if( pObjectDesc->dwValidData & DMUS_OBJ_OBJECT )
	{
		ck.ckid = DMUS_FOURCC_GUID_CHUNK;
		if( pIRiffStream->CreateChunk( &ck, 0 ) != 0 )
		{
			hr = E_FAIL;
			goto ON_ERROR;
		}

		hr = pIStream->Write( &pObjectDesc->guidObject, sizeof(GUID), &dwBytesWritten);
		if( FAILED( hr )
		||  dwBytesWritten != sizeof(GUID) )
		{
			hr = E_FAIL;
			goto ON_ERROR;
		}

		if( pIRiffStream->Ascend(&ck, 0) != 0 )
		{
			hr = E_FAIL;
			goto ON_ERROR;
		}
	}

	// Write Date chunk
	if( pObjectDesc->dwValidData & DMUS_OBJ_DATE )
	{
		ck.ckid = DMUS_FOURCC_DATE_CHUNK;
		if( pIRiffStream->CreateChunk( &ck, 0 ) != 0 )
		{
			hr = E_FAIL;
			goto ON_ERROR;
		}

		hr = pIStream->Write( &pObjectDesc->ftDate, sizeof(FILETIME), &dwBytesWritten);
		if( FAILED( hr )
		||  dwBytesWritten != sizeof(FILETIME) )
		{
			hr = E_FAIL;
			goto ON_ERROR;
		}

		if( pIRiffStream->Ascend(&ck, 0) != 0 )
		{
			hr = E_FAIL;
			goto ON_ERROR;
		}
	}

	// Write Name chunk
	if( pObjectDesc->dwValidData & DMUS_OBJ_NAME )
	{
		ck.ckid = DMUS_FOURCC_NAME_CHUNK;
		if( pIRiffStream->CreateChunk( &ck, 0 ) != 0 )
		{
			hr = E_FAIL;
			goto ON_ERROR;
		}

		dwLength = wcslen( pObjectDesc->wszName ) + 1; 
		dwLength *= sizeof( wchar_t );
		hr = pIStream->Write( &pObjectDesc->wszName, dwLength, &dwBytesWritten);
		if( FAILED( hr )
		||  dwBytesWritten != dwLength )
		{
			hr = E_FAIL;
			goto ON_ERROR;
		}

		if( pIRiffStream->Ascend(&ck, 0) != 0 )
		{
			hr = E_FAIL;
			goto ON_ERROR;
		}
	}

	// Write File chunk
	if( pObjectDesc->dwValidData & DMUS_OBJ_FILENAME )
	{
		ck.ckid = DMUS_FOURCC_FILE_CHUNK;
		if( pIRiffStream->CreateChunk( &ck, 0 ) != 0 )
		{
			hr = E_FAIL;
			goto ON_ERROR;
		}

		dwLength = wcslen( pObjectDesc->wszFileName ) + 1; 
		dwLength *= sizeof( wchar_t );
		hr = pIStream->Write( &pObjectDesc->wszFileName, dwLength, &dwBytesWritten);
		if( FAILED( hr )
		||  dwBytesWritten != dwLength )
		{
			hr = E_FAIL;
			goto ON_ERROR;
		}

		if( pIRiffStream->Ascend(&ck, 0) != 0 )
		{
			hr = E_FAIL;
			goto ON_ERROR;
		}
	}

	// Write Category chunk
	if( pObjectDesc->dwValidData & DMUS_OBJ_CATEGORY )
	{
		ck.ckid = DMUS_FOURCC_CATEGORY_CHUNK;
		if( pIRiffStream->CreateChunk( &ck, 0 ) != 0 )
		{
			hr = E_FAIL;
			goto ON_ERROR;
		}

		dwLength = wcslen( pObjectDesc->wszCategory ) + 1;
		dwLength *= sizeof( wchar_t );
		hr = pIStream->Write( &pObjectDesc->wszCategory, dwLength, &dwBytesWritten);
		if( FAILED( hr )
		||  dwBytesWritten != dwLength )
		{
			hr = E_FAIL;
			goto ON_ERROR;
		}

		if( pIRiffStream->Ascend(&ck, 0) != 0 )
		{
			hr = E_FAIL;
			goto ON_ERROR;
		}
	}

	// Write Version chunk
	if( pObjectDesc->dwValidData & DMUS_OBJ_VERSION )
	{
		DMUS_IO_VERSION dmusVersion;

		ck.ckid = DMUS_FOURCC_VERSION_CHUNK;
		if( pIRiffStream->CreateChunk( &ck, 0 ) != 0 )
		{
			hr = E_FAIL;
			goto ON_ERROR;
		}

		// Prepare DMUS_IO_VERSION structure
		memset( &dmusVersion, 0, sizeof(DMUS_IO_VERSION) );

		dmusVersion.dwVersionMS = pObjectDesc->vVersion.dwVersionMS ;
		dmusVersion.dwVersionLS = pObjectDesc->vVersion.dwVersionLS;

		// Write Version chunk data
		hr = pIStream->Write( &dmusVersion, sizeof(DMUS_IO_VERSION), &dwBytesWritten);
		if( FAILED( hr )
		||  dwBytesWritten != sizeof(DMUS_IO_VERSION) )
		{
			hr = E_FAIL;
			goto ON_ERROR;
		}

		if( pIRiffStream->Ascend(&ck, 0) != 0 )
		{
			hr = E_FAIL;
			goto ON_ERROR;
		}
	}

	if( pIRiffStream->Ascend(&ckMain, 0) != 0 )
	{
		hr = E_FAIL;
		goto ON_ERROR;
	}

ON_ERROR:
    pIStream->Release();

    return hr;
}


/*======================================================================================
METHOD:  IDMUSPRODLOADERREFCHUNK::SAVEREFCHUNKFORLOADER
========================================================================================
@method HRESULT | IDMUSProdLoaderRefChunk| SaveRefChunkForLoader | Embeds a RIFF chunk
		into <p pIStream> that enables an implementation of IDirectMusicLoader to
		resolve file references.

@comm
	A DirectMusic Producer Component can call <om IDMUSProdFramework::QueryInterface> to
	obtain a pointer to the <o Framework>'s <i IDMUSProdLoaderRefChunk> interface.	

	<p pObjectDesc> is required when <p pIDocRootNode's> IDMUSProdNode::GetObject method 
	fails to return an IDirectMusicObject interface pointer.  
	
	The following values are valid for use in <p wlWhichLoader>:

	WL_DIRECTMUSIC: <tab>The Framework creates a file reference chunk with information
	that the DirectMusic Loader object can use to resolve the file reference.  Use this
	value when saving runtime files to disk.

	WL_PRODUCER: <tab>The Framework creates a file reference chunk with information
	that the Producer implementation of IDirectMusicLoader can use to resolve the file
	reference.  Use this value when persisting into DirectMusic objects during the course
	of a DirectMusic Producer work session.

@rvalue S_OK | The file reference chunk was saved successfully.
@rvalue E_INVALIDARG | Either <p pIStream> or <p pIDocRootNode> is not valid.  For example,
		they may be NULL.
@rvalue E_FAIL | An error occurred, and the file reference chunk could not be saved.

@ex The following code excerpt handles creation of file reference chunks correctly.  Reference
	chunks are saved differently when persisting directly into a DirectMusic object because Producer's
	implementation of IDirectMusicLoader will be called upon to resolve the reference.  When saving to
	a file, the file type (FT_RUNTIME, FT_DESIGN) returned by <om IDMUSProdPersistInfo.GetStreamInfo> 
	determines whether or not it is necessary to save the Producer specific file reference chunk: |


	// Write Reference chunk
	if( pIStyleDocRootNode )
	{
		if( ::IsEqualGUID( guidDataFormat, GUID_DirectMusicObject ) )
		{
			SaveDMRef( pIRiffStream, pIStyleDocRootNode, WL_PRODUCER );
		}
		else if( ::IsEqualGUID( guidDataFormat, GUID_CurrentVersion ) )
		{
			SaveDMRef( pIRiffStream, pIStyleDocRootNode, WL_DIRECTMUSIC );
			if( ftFileType == FT_DESIGN )
			{
				SaveProducerRef( pIRiffStream, pIStyleDocRootNode );
			}
		}
	}


HRESULT CStyleRefMgr::SaveProducerRef( IDMUSProdRIFFStream* pIRiffStream, IDMUSProdNode* pIDocRootNode )
{
	IDMUSProdFileRefChunk* pIFileRefChunk;

	ASSERT( m_pIFramework != NULL );
	if( m_pIFramework == NULL )
	{
		return E_FAIL;
	}

    IStream* pIStream = pIRiffStream->GetStream();
	ASSERT( pIStream != NULL );

	if ( SUCCEEDED ( m_pIFramework->QueryInterface( IID_IDMUSProdFileRefChunk, (void**)&pIFileRefChunk ) ) )
	{
		pIFileRefChunk->SaveRefChunk( pIStream, pIDocRootNode );
		pIFileRefChunk->Release();
	}

	pIStream->Release();
	return S_OK;
}


HRESULT CStyleRefMgr::SaveDMRef( IDMUSProdRIFFStream* pIRiffStream,
								 IDMUSProdNode* pIDocRootNode, WhichLoader whichLoader )
{
	IDMUSProdLoaderRefChunk* pIRefChunkLoader;

	ASSERT( m_pIFramework != NULL );
	if( m_pIFramework == NULL )
	{
		return E_FAIL;
	}

	HRESULT hr = E_FAIL;

    IStream* pIStream = pIRiffStream->GetStream();
	ASSERT( pIStream != NULL );

	if( SUCCEEDED( m_pIFramework->QueryInterface( IID_IDMUSProdLoaderRefChunk, (void**)&pIRefChunkLoader ) ) )
	{
		if( pIRefChunkLoader )
		{
			switch( whichLoader )
			{
				case WL_DIRECTMUSIC:
				case WL_PRODUCER:
					hr = pIRefChunkLoader->SaveRefChunkForLoader( pIStream,
																  pIDocRootNode,
																  CLSID_DirectMusicStyle,
																  NULL,
																  whichLoader );
					break;
			}

			pIRefChunkLoader->Release();
		}
	}

	pIStream->Release();
	return hr;
}
	
@xref <i IDMUSProdFileRefChunk>, <i IDMUSProdLoaderRefChunk>
--------------------------------------------------------------------------------------*/

/////////////////////////////////////////////////////////////////////////////
// CFramework::SaveRefChunkForLoader

HRESULT CFramework::SaveRefChunkForLoader(
	IStream* pIStream,				// @parm [in] Pointer to an IStream interface.
	IDMUSProdNode* pIDocRootNode,	// @parm [in] Pointer to an <i IDMUSProdNode> interface for the DocRoot
									//		<o Node> of the referenced file.
	REFCLSID rclsid,				// @parm [in] CLSID of the DirectMusic object. 
	void*  pObjectDesc,				// @parm [in] Pointer to a DirectMusic DMUS_OBJECTDESC structure. May
									//		be NULL when <p pIDocRootNode's> IDMUSProdNode::GetObject method 
									//		returns an IDirectMusicObject interface pointer.  
	WhichLoader wlWhichLoader		// @parm [in] Specifies the target IDirectMusicLoader implementation
)
{
	AFX_MANAGE_STATE( AfxGetAppModuleState() );

	if( pIStream == NULL
	||  pIDocRootNode == NULL )
	{
		return E_INVALIDARG;
	}

	HRESULT hr;

	DMUSProdStreamInfo StreamInfo;
	StreamInfo.ftFileType = FT_RUNTIME;
	StreamInfo.guidDataFormat = GUID_CurrentVersion;
	StreamInfo.pITargetDirectoryNode = NULL;

	// Get additional stream information
	IDMUSProdPersistInfo* pPersistInfo;
	if( SUCCEEDED ( pIStream->QueryInterface( IID_IDMUSProdPersistInfo, (void **)&pPersistInfo ) ) )
	{
		pPersistInfo->GetStreamInfo( &StreamInfo );
		pPersistInfo->Release();
		pPersistInfo = NULL;
	}

	CFileNode* pFileNode = NULL;
    IDMUSProdRIFFStream* pIRiffStream = NULL;
	CComponentDoc* pComponentDoc;

	// Get the DocRoot's FileNode
	pComponentDoc = theApp.FindComponentDocument( pIDocRootNode );
	if( pComponentDoc )
	{
		if( pComponentDoc->m_pIDocRootNode == pIDocRootNode )
		{
			pComponentDoc->m_pFileNode->AddRef();
			pFileNode = pComponentDoc->m_pFileNode;
		}
	}
	if( pFileNode == NULL )
	{
		hr = E_FAIL;
		goto ON_ERROR;
	}

	// Prepare the DMUS_OBJECTDESC structure
	DMUS_OBJECTDESC dmusObjectDesc;

	memset( &dmusObjectDesc, 0, sizeof(DMUS_OBJECTDESC) );
	dmusObjectDesc.dwSize = sizeof(DMUS_OBJECTDESC);

	switch( wlWhichLoader )
	{
		case WL_DIRECTMUSIC:
		{
			IDirectMusicObject* pIDMObject;

			if( pObjectDesc )
			{
				// Use the supplied object descriptor
				LPDMUS_OBJECTDESC pDMObjectDesc = (DMUS_OBJECTDESC *)pObjectDesc;

				DWORD dwSize = min( dmusObjectDesc.dwSize, pDMObjectDesc->dwSize );  
				memcpy( &dmusObjectDesc, pDMObjectDesc, dwSize );
			}
			else
			{
				hr = pIDocRootNode->GetObject( rclsid, IID_IDirectMusicObject, (void**)&pIDMObject );
				if( SUCCEEDED ( hr ) )
				{
					pIDMObject->GetDescriptor( &dmusObjectDesc );
					pIDMObject->Release();
					pIDMObject = NULL;

					dmusObjectDesc.dwValidData &= 0x000000FF;
				}
				else
				{
					// Should have supplied pObjectDesc!!
					ASSERT( 0 );
					hr = E_INVALIDARG;
					goto ON_ERROR;
				}
			}

			// Add the filename
			CString strFileName;
			if( StreamInfo.ftFileType == FT_RUNTIME )
			{
				if( pFileNode->m_strRuntimeFile.IsEmpty() == FALSE )
				{
					// Make sure file exists on hard drive
					DWORD dwAttributes = ::GetFileAttributes( pFileNode->m_strRuntimeFile );
					if( dwAttributes != 0xFFFFFFFF )
					{
						// File exists
						theApp.SplitOutFileName( pFileNode->m_strRuntimeFile, TRUE, strFileName );
					}
				}
				if( strFileName.IsEmpty() )
				{
					if( pFileNode->m_strRuntimeFileName.IsEmpty() == FALSE )
					{
						theApp.SplitOutFileName( pFileNode->m_strRuntimeFileName, TRUE, strFileName );
					}
					else
					{
						theApp.AdjustFileName( FT_RUNTIME, pFileNode->m_strName, strFileName );
					}
				}
			}
			else
			{
				strFileName = pFileNode->m_strName;
			}
			dmusObjectDesc.dwValidData |= DMUS_OBJ_FILENAME;
			MultiByteToWideChar( CP_ACP, 0, strFileName, -1, &dmusObjectDesc.wszFileName[0], DMUS_MAX_FILENAME );

			// Add the file modified date
			if( StreamInfo.ftFileType != FT_RUNTIME )
			{
				// Skipping FT_RUNTIME because I need to figure out a way to get the full
				// path of the runtime file
				pFileNode->ConstructFileName( strFileName );
				HANDLE hFile = ::CreateFile( strFileName, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING,
	 										 FILE_ATTRIBUTE_NORMAL, NULL );
				if( hFile != INVALID_HANDLE_VALUE )
				{
					FILETIME ftModified;

					if( ::GetFileTime(hFile, NULL, NULL, &ftModified) )
					{
						dmusObjectDesc.dwValidData |= DMUS_OBJ_DATE;
						dmusObjectDesc.ftDate = ftModified;
					}

					CloseHandle( hFile );
				}
			}
			break;
		}

		case WL_PRODUCER:
			dmusObjectDesc.dwValidData = (DMUS_OBJ_OBJECT | DMUS_OBJ_CLASS); 
			memcpy( &dmusObjectDesc.guidObject, &pFileNode->m_guid, sizeof( dmusObjectDesc.guidObject ) );
			memcpy( &dmusObjectDesc.guidClass, &rclsid, sizeof( dmusObjectDesc.guidClass ) );
			break;
	}
	
	// Create a RIFFStream
    hr = AllocRIFFStream( pIStream, &pIRiffStream );
	if( FAILED ( hr ) )
	{
		goto ON_ERROR;
	}

	// Save the DirectMusic file Reference Chunk
    hr = WriteTheRefChunkForLoader( pIRiffStream, &dmusObjectDesc );

ON_ERROR:
	if( pIRiffStream )
	{
		pIRiffStream->Release();
	}

	if( pFileNode )
	{
		pFileNode->Release();
	}

	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CFramework::IsDocRootNode

BOOL CFramework::IsDocRootNode( IDMUSProdNode* pIDocRootNode )
{
	ASSERT( pIDocRootNode != NULL );

	BOOL fDocRootNode = FALSE;

	CFileNode* pFileNode = theApp.GetFileByDocRootNode( pIDocRootNode );
	if( pFileNode )
	{
		fDocRootNode = TRUE;

		pFileNode->Release();
	}

	return fDocRootNode;
}


/////////////////////////////////////////////////////////////////////////////
// CFramework::FindFileClipFormat

UINT CFramework::FindFileClipFormat( IDataObject* pIDataObject )
{
	UINT uClipFormat = 0;

	if( pIDataObject == NULL )
	{
		return 0;
	}

	// Create a new CDllJazzDataObject and see if it can read the data object's format.
	CAppJazzDataObject* pDataObject = new CAppJazzDataObject();
	if( pDataObject == NULL )
	{
		return 0;
	}

    POSITION pos = m_lstClipFormats.GetHeadPosition();
    while( pos )
    {
        CJzClipFormat* pJzClipFormat = m_lstClipFormats.GetNext( pos );

		if( SUCCEEDED (	pDataObject->IsClipFormatAvailable( pIDataObject, pJzClipFormat->m_uClipFormat ) ) )
		{
			uClipFormat = pJzClipFormat->m_uClipFormat;
			break;
		}
	}

	pDataObject->Release();

	return uClipFormat;
}


/////////////////////////////////////////////////////////////////////////////
// CFramework::FindDocTypeByClipFormat

HRESULT CFramework::FindDocTypeByClipFormat( UINT uClipFormat, IDMUSProdDocType** ppIDocType )
{
	if( ppIDocType == NULL )
	{
		return E_POINTER;
	}

	*ppIDocType = NULL;

	if( uClipFormat == 0 )
	{
		return E_INVALIDARG;
	}

    POSITION pos = m_lstClipFormats.GetHeadPosition();
    while( pos )
    {
        CJzClipFormat* pJzClipFormat = m_lstClipFormats.GetNext( pos );

		if( pJzClipFormat->m_uClipFormat == uClipFormat )
		{
			IDMUSProdDocType* pIDocType;

			BSTR bstrExt = pJzClipFormat->m_strExt.AllocSysString();

			if( SUCCEEDED ( FindDocTypeByExtension( bstrExt, &pIDocType ) ) )
			{
				*ppIDocType = pIDocType;
				return S_OK;
			}
			break;
		}
	}

	return E_FAIL;
}


/////////////////////////////////////////////////////////////////////////////
// CFramework::FindExtensionByClipFormat

HRESULT CFramework::FindExtensionByClipFormat( UINT uClipFormat, CString& strExt )
{
    POSITION pos = m_lstClipFormats.GetHeadPosition();
    while( pos )
    {
        CJzClipFormat* pJzClipFormat = m_lstClipFormats.GetNext( pos );

		if( pJzClipFormat->m_uClipFormat == uClipFormat )
		{
			strExt = pJzClipFormat->m_strExt;
			return S_OK;
		}
	}

	return E_FAIL;
}


/////////////////////////////////////////////////////////////////////////////
// CFramework WriteTheFileFromDataObject

HRESULT CFramework::WriteTheFileFromDataObject( CFProducerFile* pcfProducerFile, IStream* pIMemStream, IDMUSProdDocType* pIDocType )
{
	HRESULT hr;

	if( pcfProducerFile == NULL
	||  pIMemStream == NULL
	||  pIDocType == NULL )
	{
		return E_INVALIDARG;
	}

	// Get the DocTemplate
	CJazzDocTemplate* pDocTemplate = theApp.FindDocTemplate( pIDocType ); 
	if( pDocTemplate == NULL )
	{
		return E_FAIL;
	}

	// Get file's name
	CString strFileName = pcfProducerFile->strFileName;
	
	if( theApp.DoPromptFileSave( pDocTemplate, strFileName ) == FALSE )
	{
		return E_FAIL;
	}

	// Paste the file
	STATSTG			statstg;
	ULARGE_INTEGER	uliSizeOut, uliSizeRead, uliSizeWritten;

	// Get pIMemStream's size
	hr = pIMemStream->Stat( &statstg, STATFLAG_NONAME );
	if( FAILED( hr ) )
	{
		return E_FAIL;
	}
	uliSizeOut = statstg.cbSize;

	// Get an IStream pointer to the file we are creating for the paste
	IStream* pIStream;

	BSTR bstrFileName = strFileName.AllocSysString();

	if( SUCCEEDED ( theApp.m_pFramework->AllocFileStream(bstrFileName, GENERIC_WRITE, FT_DESIGN,
														 GUID_CurrentVersion, NULL, &pIStream) ) )
	{
		// Copy pIMemStream into pIStream
		hr = pIMemStream->CopyTo( pIStream, uliSizeOut, &uliSizeRead, &uliSizeWritten );
		pIStream->Release();

		if( FAILED( hr )
		||  uliSizeRead.QuadPart != uliSizeOut.QuadPart
		||  uliSizeWritten.QuadPart != uliSizeOut.QuadPart )
		{

			// If the storage ran out of space, return STG_E_MEDIUMFULL, otherwise just return E_FAIL
			if( hr == STG_E_MEDIUMFULL )
			{
				return hr;
			}
			return E_FAIL;
		}
	}
	
	// See if the file is in any of the opened Projects
	CProject* pProject = theApp.GetProjectByFileName( strFileName );
	if( pProject )
	{
		// Display the newly created file in the Project Tree
		theApp.OpenTheFile( strFileName, TGT_FILENODE_SAVEAS );
		pProject->Release();
	}

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CFramework CreateFileFromDataObject

HRESULT CFramework::CreateFileFromDataObject( IDataObject* pIDataObject )
{
	if( pIDataObject == NULL )
	{
		return E_INVALIDARG;
	}

	IStream* pIStream = NULL;

	// Read CF_DMUSPROD_FILE information
	BOOL fCF_DMUSPROD_FILE = FALSE;
	CFProducerFile cfProducerFile;

	if( SUCCEEDED ( theApp.m_pFramework->LoadClipFormat( pIDataObject, theApp.m_pFramework->m_cfProducerFile, &pIStream ) ) )
	{
		if( SUCCEEDED ( theApp.m_pFramework->LoadCF_DMUSPROD_FILE( pIStream, &cfProducerFile ) ) )
		{
			fCF_DMUSPROD_FILE = TRUE;
		}

		pIStream->Release();
		pIStream = NULL;
	}

	if( fCF_DMUSPROD_FILE == FALSE )
	{
		return E_FAIL;
	}

	HRESULT hr = E_FAIL;

	// Get stream of file data
	UINT uClipFormat = theApp.m_pFramework->FindFileClipFormat( pIDataObject );
	if( uClipFormat )
	{
		if( SUCCEEDED ( theApp.m_pFramework->LoadClipFormat( pIDataObject, uClipFormat, &pIStream ) ) )
		{
			IDMUSProdDocType* pIDocType;

			if( SUCCEEDED ( theApp.m_pFramework->FindDocTypeByClipFormat( uClipFormat, &pIDocType ) ) )
			{
				// Adjust filename
				CString strExt;

				if( SUCCEEDED ( theApp.m_pFramework->FindExtensionByClipFormat( uClipFormat, strExt ) ) )
				{
					int nFindPos = cfProducerFile.strFileName.ReverseFind( (TCHAR)'.' );
					if( nFindPos != -1 )
					{
						cfProducerFile.strFileName = cfProducerFile.strFileName.Left( nFindPos );
					}
					cfProducerFile.strFileName += strExt;
				}

				// Write the file
				hr = WriteTheFileFromDataObject( &cfProducerFile, pIStream, pIDocType );

				pIDocType->Release();
			}

			pIStream->Release();
		}
	}

	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CFramework::AreYouSure

BOOL CFramework::AreYouSure( IDMUSProdNode* pINode )
{
	AFX_MANAGE_STATE( AfxGetAppModuleState() );
	ASSERT( pINode != NULL );

	CTreeCtrl* pTreeCtrl = theApp.GetProjectTreeCtrl();
	ASSERT( pTreeCtrl != NULL );

	// If node represents document, we want to delete its FileNode
	CComponentDoc* pComponentDoc = theApp.FindComponentDocument( pINode );
	if( pComponentDoc )
	{
		if( pComponentDoc->m_pIDocRootNode == pINode )
		{
			pINode = pComponentDoc->m_pFileNode;
			ASSERT( pINode != NULL );
		}
	}

	if( pINode->CanDelete() != S_OK )
	{
		return FALSE;
	}

	GUID guidNodeId;
	if( FAILED ( pINode->GetNodeId( &guidNodeId ) ) )
	{
		return FALSE;
	}

	// Projects and  Directories handled elsewhere
	if( ::IsEqualGUID ( guidNodeId, GUID_ProjectFolderNode )
	||  ::IsEqualGUID ( guidNodeId, GUID_DirectoryNode ) )
	{
		// Should not get here!
		ASSERT( 0 );
		return TRUE;
	}

	// Handle File nodes
	else if( ::IsEqualGUID ( guidNodeId, GUID_FileNode ) )
	{
		CFileNode* pFileNode = (CFileNode *)pINode;