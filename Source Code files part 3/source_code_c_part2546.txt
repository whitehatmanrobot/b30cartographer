eqDataFlagSC((void *)pDecMemBlk))
			   copyCBuf2LBuf(pvciCodecIOBlk->pVoxBuffer, 
							 &(pvciCodecIOBlk->wVoxBufferReadByteOffset),
							 &(pvciCodecIOBlk->chVoxBufferReadBitOffset), 
							 pvciCodecIOBlk->wVoxBufferSize, 
							 TOTAL_BITS_SC3,
							 pDecMemBlk->pbSaveVoxBuffer);

			 /*---------------------------------------------------------
			   Unpack and unquantize SC3 data.
			 ---------------------------------------------------------*/
			 VoxUnPackSC3(QuanSC3Index,
						  pDecMemBlk->pbSaveVoxBuffer,
						  &sByteOffset,
						  &cBitOffset,
						  (TOTAL_BYTES_SC3+ADDITIONAL_BYTES_SC6),
						  &sLongerFrameFlag);

			 VoxUnQuantSC3(STACK_S QuanSC3Index, (void *)pDecMemBlk, &ParamMblk);

			 /*---------------------------------------------------------
			   if sLongerFrameFlag==END_OF_FRAME then decode using
				 SC_RATE_3K, otherwise continue unpacking.
			 ---------------------------------------------------------*/
			 if (sLongerFrameFlag==END_OF_FRAME)
			 {
				if(voxSetDecodeSC((void *)pDecMemBlk, SC_RATE_3K)) /* set decoder rate to SC3 */
				   return VCI_CODEC_NOT_SUPPORTED;
			 } else {
				if(voxSetDecodeSC((void *)pDecMemBlk, SC_RATE_6K)) /* set decoder rate to SC6 */
				   return VCI_CODEC_NOT_SUPPORTED;

				/*---------------------------------------------------------
				  Copy the additional SC6 bits from the circular buffer 
					to the linear buffer.  

				  NOTE: We had to unpack the SC3 bits before we could find 
					out if there are additional SC6 bits.
				---------------------------------------------------------*/
				if (voxGetDecReqDataFlagSC((void *)pDecMemBlk))
				   copyCBuf2LBuf(pvciCodecIOBlk->pVoxBuffer, 
								 &(pvciCodecIOBlk->wVoxBufferReadByteOffset),
								 &(pvciCodecIOBlk->chVoxBufferReadBitOffset), 
								 pvciCodecIOBlk->wVoxBufferSize, ADDITIONAL_BITS_SC6,
								 &(pDecMemBlk->pbSaveVoxBuffer[(TOTAL_BITS_SC3)>>3]));

				/*---------------------------------------------------------
				  Unpack and unquantize SC6 data.
				---------------------------------------------------------*/
				VoxUnPackSC6(QuanSC6Index,
							 pDecMemBlk->pbSaveVoxBuffer,
							 &sByteOffset,
							 &cBitOffset,
							 (TOTAL_BYTES_SC3+ADDITIONAL_BYTES_SC6),
							 &sLongerFrameFlag);

			   VoxUnQuantSC6(QuanSC6Index, &ParamMblk);
			 }
		   }
   }
   else
   {
	   VCI_SIL_IO_BLK_PARAM_CHECK_DEC(pvciCodecIOBlk);
   }

   
   /*---------------------------------------------------------
     Call the fade routine to modify parameters if there
       has benn a fade.
   ---------------------------------------------------------*/
   VoxFadeSC(pDecMemBlk->pFadeIOMemBlk, &ParamMblk);

   /*---------------------------------------------------------
     If the Fade state is SILENCE then set the decoder to
       SC3 because the fade routine does not generate
       measured phase parameters.
   ---------------------------------------------------------*/
   if (GetCurrentFrameStateSC(pDecMemBlk->pFadeIOMemBlk) == SILENCE)
     {
       if(voxSetDecodeSC((void *)pDecMemBlk, SC_RATE_3K))
          return VCI_CODEC_NOT_SUPPORTED;
     }

   /*---------------------------------------------------------
     Decode the parameters.
   ---------------------------------------------------------*/
   VoxDecodeSC(STACK_S (void *)pDecMemBlk, &ParamMblk, pvciCodecIOBlk->pPCMBuffer, 
               &(pvciCodecIOBlk->wSamplesInPCMBuffer) );

   /*---------------------------------------------------------
     Update the fade block for the case when the decoder
       is not yet finished with the current frame.
   ---------------------------------------------------------*/
   cDecReqDataFlagSC = voxGetDecReqDataFlagSC((void *)pDecMemBlk);
   UpdateFadeStateSC( pDecMemBlk->pFadeIOMemBlk, cDecReqDataFlagSC );

   return(VCI_NO_ERROR);
}
/*===========================================================================*/


#ifndef DECODE_ONLY
/******************************************************************************
*
* Function:  vciInitEncodeSC6()
*
* Action:    To allocate memory for a Codec Memory Block and to initialize
*            it as an encoder.  
*
* Input:    hEncodeMemBlk -- the pointer to the encoder structure
*
* Output:   hEncodeMemBlk -- memory allocated and initialized encoder structure
*
* Globals:   none
*
* Return:    VCI error code
*******************************************************************************
*
* Implementation/Detailed Description:
*
* References:
*******************************************************************************
*
* Modifications:
*
* Comments:  
*
* Concerns/TBD:
******************************************************************************/

VCI_RETCODE vciInitEncodeSC6(void **hEncodeMemBlk)
{
   VCI_CODEC_BLOCK *vciCodecMblk=NULL;
   STACK_DECLARE

   if(!hEncodeMemBlk)
      return VCI_NULL_ARG;

   if(VOX_MEM_INIT(vciCodecMblk=*hEncodeMemBlk,1,sizeof(VCI_CODEC_BLOCK))) 
     return VCI_FAILED_MEM_ALLOC;

   vciCodecMblk->chEncOrDec = ENCODE_ID;
   vciCodecMblk->dwVciChunkID = SANITY_CHECK;

   if(STACK_SET(vciCodecMblk->pScratchBlk,20480)) {
      vciFreeEncodeSC6(hEncodeMemBlk);
      return VCI_FAILED_MEM_ALLOC;
   }

   if(!(vciCodecMblk->pvemMemBlk=vemInit())) {
#if VEM_DEFINED == 1
      vciFreeEncodeSC6(hEncodeMemBlk);
      return VCI_FAILED_MEM_ALLOC; 
#endif
   } else {
      vemRegisterConstShort(GET_VEM_MEMORY_HANDLE(vciCodecMblk), (short)FRAME_LENGTH_SC, "frame length");
      vemRegisterConstShort(GET_VEM_MEMORY_HANDLE(vciCodecMblk), (short)RATE8K, "rate");
   }

   if(VoxInitEncodeSC3(&vciCodecMblk->hCodecMblk,vciCodecMblk->pvemMemBlk)) {
      vciFreeEncodeSC6(hEncodeMemBlk);
      return VCI_FAILED_MEM_ALLOC;
   }
 
   if(VoxInitEncodeSC6(&vciCodecMblk->hCodecMblk)) {
      vciFreeEncodeSC6(hEncodeMemBlk);
      return VCI_FAILED_MEM_ALLOC;
   } 
 
   if(initMethodStruct(&vciCodecMblk->pVciMethodStruct))
      return VCI_FAILED_MEM_ALLOC;
 
   return VCI_NO_ERROR;
}
/*===========================================================================*/
#endif

/******************************************************************************
*
* Function:  vciInitDecodeSC6()
*
* Action:    To allocate memory for a Codec Memory Block and to initialize
*            it as a decoder.
*
* Input:    hDecodeMemBlk -- the pointer to the decoder structure
*
* Output:   hDecodeMemBlk -- allocated  and initilized structure
*
* Globals:   none
*
* Return:    VCI error code
*******************************************************************************
*
* Implementation/Detailed Description:
*
* References:
*******************************************************************************
*
* Modifications:
*
* Comments:  
*
* Concerns/TBD:
******************************************************************************/

VCI_RETCODE vciInitDecodeSC6(void **hDecodeMemBlk)
{
   VCI_CODEC_BLOCK *vciCodecMblk=NULL;
   DEC_MEM_BLK *pDecMemBlk;   

   STACK_DECLARE

   if(!hDecodeMemBlk)
      return VCI_NULL_ARG;

   if(VOX_MEM_INIT(vciCodecMblk=*hDecodeMemBlk,1,sizeof(VCI_CODEC_BLOCK))) 
      return VCI_FAILED_MEM_ALLOC;

   vciCodecMblk->chEncOrDec = DECODE_ID;
   vciCodecMblk->dwVciChunkID = SANITY_CHECK;

   if(STACK_SET(vciCodecMblk->pScratchBlk,20240)) {
      vciFreeDecodeSC6(hDecodeMemBlk);
      return VCI_FAILED_MEM_ALLOC;
   } 

   if(!(vciCodecMblk->pvemMemBlk=vemInit())) {
#if VEM_DEFINED == 1
      vciFreeDecodeSC6(hDecodeMemBlk);
      return VCI_FAILED_MEM_ALLOC;
#endif
   }

   if(VoxInitDecodeSC3(&vciCodecMblk->hCodecMblk)) {
      vciFreeDecodeSC6(hDecodeMemBlk);
      return VCI_FAILED_MEM_ALLOC;
   } 
 
   if(VoxInitDecodeSC6(&vciCodecMblk->hCodecMblk)) {
      vciFreeDecodeSC6(hDecodeMemBlk);
      return VCI_FAILED_MEM_ALLOC;
   } 
   
   pDecMemBlk = (DEC_MEM_BLK *)(vciCodecMblk->hCodecMblk);

   if(VoxinitFadeSC(&pDecMemBlk->pFadeIOMemBlk)) {
      vciFreeDecodeSC6(hDecodeMemBlk);
      return VCI_FAILED_MEM_ALLOC;
   }
   
   if (VOX_MEM_INIT(pDecMemBlk->pbSaveVoxBuffer, 
                    TOTAL_BYTES_SC3+ADDITIONAL_BYTES_SC6,
                    sizeof(unsigned char *)))
     return VCI_FAILED_MEM_ALLOC;

   if(initMethodStruct(&vciCodecMblk->pVciMethodStruct))
      return VCI_FAILED_MEM_ALLOC;

   return VCI_NO_ERROR;
}
/*===========================================================================*/


#ifndef DECODE_ONLY
/******************************************************************************
*
* Function:  vciFreeEncodeSC6()
*
* Action:    Frees memory assigned to the encoder.
*
* Input:    hEncodeMemBlk -- the pointer to the encoder structure
*
* Output:   hEncodeMemBlk -- freed memory 
*
* Globals:   none
*
* Return:    VCI error code
*******************************************************************************
*
* Implementation/Detailed Description:
*
* References:
*******************************************************************************
*
* Modifications:
*
* Comments:  
*
* Concerns/TBD:
******************************************************************************/

VCI_RETCODE vciFreeEncodeSC6(void **hEncodeMemBlk)
{  
   VCI_CODEC_BLOCK *vciCodecMblk = NULL;

   if(!hEncodeMemBlk)
      return VCI_NULL_ARG;

   /* First make sure that the handle passed is the correct one. */
   if(!VCI_BLOCK_CHECK(*hEncodeMemBlk))
      return VCI_NOT_VCI_HANDLE;

   if(!VCI_IS_ENCODE(*hEncodeMemBlk))
      return VCI_NOT_ENC_HANDLE;
   
   vciCodecMblk = (VCI_CODEC_BLOCK *)*hEncodeMemBlk;

   vciCodecMblk->dwVciChunkID=0;

   /*--------------------------------------------
     Must free SC6 before the free for SC3.
       (The free for SC3 assumes that SC6 was already freed)
   --------------------------------------------*/
   VoxFreeEncodeSC6(&vciCodecMblk->hCodecMblk);
   VoxFreeEncodeSC3(&vciCodecMblk->hCodecMblk);

   vemFree(vciCodecMblk->pvemMemBlk);

   freeMethodStruct(&vciCodecMblk->pVciMethodStruct);

   STACK_UNSET(vciCodecMblk->pScratchBlk)

   VOX_MEM_FREE(vciCodecMblk);
      
   return VCI_NO_ERROR;
}
/*===========================================================================*/
#endif

/******************************************************************************
*
* Function:  vciFreeDecodeSC6()
*
* Action:    Frees memory assigned to the decoder.
*
* Input:    hDecodeMemBlk -- the pointer to the decoder structure
*
* Output:   hDecodeMemBlk -- freed memory 
*
* Globals:   none
*
* Return:    VCI error code
*******************************************************************************
*
* Implementation/Detailed Description:
*
* References:
*******************************************************************************
*
* Modifications:
*
* Comments:  
*
* Concerns/TBD:
******************************************************************************/

VCI_RETCODE vciFreeDecodeSC6(void **hDecodeMemBlk)
{
   VCI_CODEC_BLOCK *vciCodecMblk = NULL;
   DEC_MEM_BLK *pDecMemBlk;

   if(!hDecodeMemBlk)
      return VCI_NULL_ARG;

   /* First make sure that the handle passed is the correct one. */
   if(!VCI_BLOCK_CHECK(*hDecodeMemBlk))
      return VCI_NOT_VCI_HANDLE;

   if(!VCI_IS_DECODE(*hDecodeMemBlk))
      return VCI_NOT_DEC_HANDLE;

   vciCodecMblk = (VCI_CODEC_BLOCK *)*hDecodeMemBlk;

   vciCodecMblk->dwVciChunkID=0;

   pDecMemBlk = (DEC_MEM_BLK *)(vciCodecMblk->hCodecMblk);

   VoxfreeFadeSC(&pDecMemBlk->pFadeIOMemBlk);

   VOX_MEM_FREE(pDecMemBlk->pbSaveVoxBuffer);

   /*--------------------------------------------
     Must free SC6 before the free for SC3.
       (The free for SC3 assumes that SC6 was already freed)
   --------------------------------------------*/
   VoxFreeDecodeSC6(&vciCodecMblk->hCodecMblk);
   VoxFreeDecodeSC3(&vciCodecMblk->hCodecMblk);

   vemFree(vciCodecMblk->pvemMemBlk);

   freeMethodStruct(&vciCodecMblk->pVciMethodStruct);

   STACK_UNSET(vciCodecMblk->pScratchBlk)

   VOX_MEM_FREE(vciCodecMblk);

  return VCI_NO_ERROR;
}

/*===========================================================================*/


/******************************************************************************
*
* Function:  vciGetExtCompatibilitySC6()  
*
* Action:    Returns compatibility function 
*
* Input:    pCompatFunc -- the function pointer to the compatibility function
*
* Output:   pCompatFunc -- the compatibility function
*
* Globals:   none
*
* Return:    VCI return error
*******************************************************************************
*
* Implementation/Detailed Description:
*
* References:
*******************************************************************************
*
* Modifications:
*
* Comments:  
*
* Concerns/TBD:
******************************************************************************/

VCI_RETCODE vciGetExtCompatibilitySC6(void **pCompatFunc)
{
   *((COMPATIBILITY_FUNCTION **)pCompatFunc)=&SC6CompatibilityFunc;

   return VCI_NO_ERROR;
}


/******************************************************************************
*
* Function:  SC6CompatibilityFunc()
*
* Action:    Get the compatiliby ID
*
* Input:    VemPlugin -- the VEM-plug-in-ID
*           pVemCodID -- the pointer to the current codec ID
*
* Output:   pVemCodID -- the current codec ID
*
* Globals:   none
*
* Return:    vem-compatibility-ID 
*******************************************************************************
*
* Implementation/Detailed Description:
*
* References:
*******************************************************************************
*
* Modifications:
*
* Comments:  
*
* Concerns/TBD:
******************************************************************************/

unsigned  short SC6CompatibilityFunc(unsigned short VemPlugin, 
                                     unsigned long *pVemCodID) 
{
   unsigned short vem_compatibility_ID;
   *pVemCodID=(unsigned long)VOXWARE_CODEC_SC_8K_6;
   
   switch(VemPlugin) {
      case COMPATIBILITY_VFONT:
        vem_compatibility_ID = (unsigned short)VEM_COMPATIBILITY_VFONT;
        break;

      case COMPATIBILITY_VAD_AGC:
        vem_compatibility_ID = (unsigned short)VEM_COMPATIBILITY_VAD_AGC;
        break;

      case COMPATIBILITY_PLUS: 
        vem_compatibility_ID = (unsigned short)VEM_COMPATIBILITY_PLUS;
        break;

      default:
        vem_compatibility_ID = (unsigned short)VEM_COMPATIBILITY_DEFAULT;
   }

   return vem_compatibility_ID;
}



/******************************************************************************
*
* Function:  initMethodStruct()
*
* Action:    initialization of the VCI method structure
*
* Input:    hVciMethodStruct -- the pointer to the VCI method structure
*
* Output:   hVciMethodStruct -- the memory allocated and initialized 
*                               VCI method structure
*
* Globals:   none
*
* Return:    0: no error , 1: memory allocation error
*******************************************************************************
*
* Implementation/Detailed Description:
*
* References:
*******************************************************************************
*
* Modifications:
*
* Comments:  
*
* Concerns/TBD:
******************************************************************************/

static unsigned short initMethodStruct(VCI_METHOD_STRUCT **hVciMethodStruct)
{
   if(VOX_MEM_INIT(*hVciMethodStruct,1,sizeof(VCI_METHOD_STRUCT)))
      return 1;

   (*hVciMethodStruct)->pfVciGetInfo=vciGetInfoSC6;

#ifndef DECODE_ONLY
   (*hVciMethodStruct)->pfVciEncode=vciEncodeSC6;
   (*hVciMethodStruct)->pfVciInitEncode=vciInitEncodeSC6;
   (*hVciMethodStruct)->pfVciFreeEncode=vciFreeEncodeSC6;
#endif

   (*hVciMethodStruct)->pfVciDecode=vciDecodeSC6;
   (*hVciMethodStruct)->pfVciInitDecode=vciInitDecodeSC6; 
   (*hVciMethodStruct)->pfVciFreeDecode=vciFreeDecodeSC6;

   return 0;
}


/******************************************************************************
*
* Function:  freeMethodStruct()
*
* Action:    free the memory for the VCI method structure
*
* Input:    hVciMethodStruct -- the pointer to the VCI method structure
*
* Output:   hVciMethodStruct -- memory freed structure
*
* Globals:   none
*
* Return:    0: no error
*******************************************************************************
*
* Implementation/Detailed Description:
*
* References:
*******************************************************************************
*
* Modifications:
*
* Comments:  
*
* Concerns/TBD:
******************************************************************************/

static unsigned short freeMethodStruct(VCI_METHOD_STRUCT **hVciMethodStruct)
{
   if(hVciMethodStruct)
      VOX_MEM_FREE(*hVciMethodStruct);

   return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\voxware\vcirt28.h ===
/******************************************************************************
 *                                                                            *
 *		                  Voxware Proprietary Material                          *
 *		                  Copyright 1996, Voxware, Inc.                         *
 *		                       All Rights Resrved                               *
 *                                                                            *
 *		                 DISTRIBUTION PROHIBITED without                        *
 *		               written authorization from Voxware                       *
 *                                                                            *
 ******************************************************************************/

/******************************************************************************
 *                                                                            *
 * FILENAME:  vciRT29.h                                                       *
 * PURPOSE:   Defines the interface functions and defines for vciRT29.c.      *
 *                                                                            *
 *****************************************************************************/

/******************************************************************************
 *                                                                            *
 *                          DETAILED REVISION HISTORY                         *
 *                                                                            *
 * (Sept 25, '96)                                                             *
 *    Created                                                                 *
 *                                                                            *
 *****************************************************************************/


#ifndef VCIRT28_H
#define VCIRT28_H
 
#ifdef __cplusplus
extern "C"
{
#endif
                                                         
VCI_RETCODE vciGetInfoRT28(VCI_CODEC_INFO_BLOCK *pvciCodecInfoBlk);

VCI_RETCODE vciDecodeRT28(void *hCodecMemBlk, 
                          VCI_CODEC_IO_BLOCK *hvciDecodeIOBlk);
VCI_RETCODE vciEncodeRT28(void *hCodecMemBlk, 
                          VCI_CODEC_IO_BLOCK *hvciEncodeIOBlk);

VCI_RETCODE vciInitEncodeRT28(void **hCodecMemBlk);
VCI_RETCODE vciInitDecodeRT28(void **hCodecMemBlk); 
                                                      
VCI_RETCODE vciFreeEncodeRT28(void **hCodecMemBlk);                                                       
VCI_RETCODE vciFreeDecodeRT28(void **hCodecMemBlk);  

VCI_RETCODE vciGetExtCompatibilityRT28(void **ppvExtCompat);

#ifdef __cplusplus
}
#endif /* __cplusplus */

#endif /* VCIRT29_H */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\voxware\vcisc3.h ===
/******************************************************************************
*                        Voxware Proprietary Material
*                        Copyright 1996, Voxware, Inc
*                            All Rights Reserved
*
*                       DISTRIBUTION PROHIBITED without
*                      written authorization from Voxware
******************************************************************************/

/******************************************************************************
* Filename:        vciSC3.h
*
* Purpose:         Defines the interface functions for the Voxware SC Quality codec
*
* Functions:   vciGetInfoSC3, vciEncodeSC3, vciDecodeSC3, 
*              vciInitEncodeSC3, vciInitDecodeSC3, vciFreeEncodeSC3,
*              vciFreeDecodeSC3, vciGetExtCompatibilitySC3
*
* Author/Date:     Ilan Berci, Epiphany Vera 97/05/19
*******************************************************************************
*
* Modifications:
*
* Comments:
*
* Concerns:
*
* $Header:   /export/phobos/pvcs/r_and_d/archives/scaleable/vci/vciSC3.h_v   1.2   16 Mar 1998 17:26:40   weiwang  $
******************************************************************************/
#ifndef _VCISC3
#define _VCISC3

#ifdef __cplusplus
extern "C"
{
#endif

#ifndef _VCI_RETCODE_
#define _VCI_RETCODE_
typedef unsigned short VCI_RETCODE; /* Voxware Core Interface error type.    */
                                    /* This variable is also defined in vci.h*/
#endif  /* _VCI_RETCODE_ */

/******************************************************************************
*
* Function:  vciGetInfoSC3()        
*
* Action:    Fill up information block for SC3
*
* Input:    pvciCodecInfoBlk -- pointer to the info. block
*
* Output:   pvciCodecInfoBlk -- filled up info. block
*
* Globals:   none
*
* Return:    VCI error code
*******************************************************************************/

VCI_RETCODE vciGetInfoSC3(VCI_CODEC_INFO_BLOCK *pvciCodecInfoBlk);

/******************************************************************************
*
* Function:  vciEncodeSC3()     
*
* Action:    Encodes one frame of speech using SC3.
*
* Input:    pEncodeMemBlk -- encoder structure
*           pvciCodecIOBlk -- codec I/O structure
*
* Output:   pEncodeMemBlk -- updated strcture
*           pvciCodecIOBlk -- updated strcture
*
* Globals:   none
*
* Return:    VCI error code
*******************************************************************************/

VCI_RETCODE vciEncodeSC3(void *pEncodeMemBlk, 
                         VCI_CODEC_IO_BLOCK *pvciCodecIOBlk);

/******************************************************************************
*
* Function:  vciDecodeSC3()
*
* Action:    Decodes one frame of speech using SC3.
*
* Input:    pDecodeMemBlk -- decoder structure
*           pvciCodecIOBlk -- codec I/O structure
*
* Output:   pDecodeMemBlk -- updated strcture
*           pvciCodecIOBlk -- updated strcture
*
* Globals:   none
*
* Return:    VCI error code
*******************************************************************************/

VCI_RETCODE vciDecodeSC3(void *pDecodeMemBlk, 
                         VCI_CODEC_IO_BLOCK *pvciCodecIOBlk);

/******************************************************************************
*
* Function:  vciInitEncodeSC3()
*
* Action:    To allocate memory for a Codec Memory Block and to initialize
*            it as an encoder.  
*
* Input:    hEncodeMemBlk -- the pointer to the encoder structure
*
* Output:   hEncodeMemBlk -- memory allocated and initialized encoder structure
*
* Globals:   none
*
* Return:    VCI error code
*******************************************************************************/

VCI_RETCODE vciInitEncodeSC3(void **hEncodeMemBlk);

/******************************************************************************
*
* Function:  vciInitDecodeSC3()
*
* Action:    To allocate memory for a Codec Memory Block and to initialize
*            it as a decoder.
*
* Input:    hDecodeMemBlk -- the pointer to the decoder structure
*
* Output:   hDecodeMemBlk -- allocated  and initilized structure
*
* Globals:   none
*
* Return:    VCI error code
*******************************************************************************/

VCI_RETCODE vciInitDecodeSC3(void **hDecodeMemBlk);

/******************************************************************************
*
* Function:  vciFreeEncodeSC3()
*
* Action:    Frees memory assigned to the encoder.
*
* Input:    hEncodeMemBlk -- the pointer to the encoder structure
*
* Output:   hEncodeMemBlk -- freed memory 
*
* Globals:   none
*
* Return:    VCI error code
*******************************************************************************/

VCI_RETCODE vciFreeEncodeSC3(void **hEncodeMemBlk);


/******************************************************************************
*
* Function:  vciFreeDecodeSC3()
*
* Action:    Frees memory assigned to the decoder.
*
* Input:    hDecodeMemBlk -- the pointer to the decoder structure
*
* Output:   hDecodeMemBlk -- freed memory 
*
* Globals:   none
*
* Return:    VCI error code
*******************************************************************************/

VCI_RETCODE vciFreeDecodeSC3(void **hDecodeMemBlk);

/******************************************************************************
*
* Function:  vciGetExtCompatibilitySC3()  
*
* Action:    Returns compatibility function 
*
* Input:    pCompatFunc -- the function pointer to the compatibility function
*
* Output:   pCompatFunc -- the compatibility function
*
* Globals:   none
*
* Return:    VCI return error
*******************************************************************************/

VCI_RETCODE vciGetExtCompatibilitySC3(void **pCompatFunc);

#define END_OF_FRAME     0
#define LONGER_FRAME     1

#ifdef __cplusplus
}
#endif

#endif /* _VCISC3 */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\voxware\vcivr12.h ===
/******************************************************************************
 *                                                                            *
 *		                  Voxware Proprietary Material                        *
 *		                  Copyright 1996, Voxware, Inc.                       *
 *		                       All Rights Resrved                             *
 *                                                                            *
 *		                 DISTRIBUTION PROHIBITED without                      *
 *		               written authorization from Voxware                     *
 *                                                                            *
 ******************************************************************************/

/******************************************************************************
 *                                                                            *
 * FILENAME:  vciVR12.h                                                       *
 * PURPOSE:   Defines the interface functions and defines for vciRT29.c.      *
 *                                                                            *
 *****************************************************************************/

/******************************************************************************
 *                                                                            *
 *                          DETAILED REVISION HISTORY                         *
 *                                                                            *
 * (Sept 25, '96)                                                             *
 *    Created                                                                 *
 *                                                                            *
 *****************************************************************************/


#ifndef VCIVR12_H
#define VCIVR12_H
 
#ifdef __cplusplus
extern "C"
{
#endif
                                                         
VCI_RETCODE vciGetInfoVR12(VCI_CODEC_INFO_BLOCK *pvciCodecInfoBlk);

VCI_RETCODE vciDecodeVR12(void *hCodecMemBlk, 
                          VCI_CODEC_IO_BLOCK *hvciDecodeIOBlk);
VCI_RETCODE vciEncodeVR12(void *hCodecMemBlk, 
                          VCI_CODEC_IO_BLOCK *hvciEncodeIOBlk);

VCI_RETCODE vciInitEncodeVR12(void **hCodecMemBlk);
VCI_RETCODE vciInitDecodeVR12(void **hCodecMemBlk); 
                                                      
VCI_RETCODE vciFreeEncodeVR12(void **hCodecMemBlk);                                                       
VCI_RETCODE vciFreeDecodeVR12(void **hCodecMemBlk);  

VCI_RETCODE vciGetExtCompatibilityVR12(void **ppvExtCompat);

#ifdef __cplusplus
}
#endif /* __cplusplus */

#endif /* VCIRT29_H */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\voxware\vcivr15.h ===
/******************************************************************************
 *                                                                            *
 *		                  Voxware Proprietary Material                          *
 *		                  Copyright 1996, Voxware, Inc.                         *
 *		                       All Rights Resrved                               *
 *                                                                            *
 *		                 DISTRIBUTION PROHIBITED without                        *
 *		               written authorization from Voxware                       *
 *                                                                            *
 ******************************************************************************/

/******************************************************************************
 *                                                                            *
 * FILENAME:  vciVR15.h                                                       *
 * PURPOSE:   Defines the interface functions and defines for vciRT29.c.      *
 *                                                                            *
 *****************************************************************************/

/******************************************************************************
 *                                                                            *
 *                          DETAILED REVISION HISTORY                         *
 *                                                                            *
 * (Sept 25, '96)                                                             *
 *    Created                                                                 *
 *                                                                            *
 *****************************************************************************/


#ifndef VCIVR15_H
#define VCIVR15_H
 
#ifdef __cplusplus
extern "C"
{
#endif
                                                         
VCI_RETCODE vciGetInfoVR15(VCI_CODEC_INFO_BLOCK *pvciCodecInfoBlk);

VCI_RETCODE vciDecodeVR15(void *hCodecMemBlk, VCI_CODEC_IO_BLOCK *hvciDecodeIOBlk);
VCI_RETCODE vciEncodeVR15(void *hCodecMemBlk, VCI_CODEC_IO_BLOCK *hvciEncodeIOBlk);

VCI_RETCODE vciInitEncodeVR15(void **hCodecMemBlk);
VCI_RETCODE vciInitDecodeVR15(void **hCodecMemBlk); 
                                                      
VCI_RETCODE vciFreeEncodeVR15(void **hCodecMemBlk);                                                       
VCI_RETCODE vciFreeDecodeVR15(void **hCodecMemBlk);  

VCI_RETCODE vciGetExtCompatibilityVR15(void **ppvExtCompat);

#ifdef __cplusplus
}
#endif /* __cplusplus */

#endif /* VCIVR15_H */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\voxware\vem2.h ===
/******************************************************************************
*                        Voxware Proprietary Material
*                        Copyright 1996, Voxware, Inc
*                            All Rights Reserved
*
*                       DISTRIBUTION PROHIBITED without
*                      written authorization from Voxware
******************************************************************************/

/******************************************************************************
* Filename:        vem2.h
*
* Purpose:     Main VEM functions
*
* Functions:  vemUnregisterState, ...
*
* Author/Date:     Ilan Berci
*******************************************************************************
*
* Modifications:
*
* Comments:
*
* Concerns:
*
* $Header:   /export/phobos/pvcs/r_and_d/archives/common/vem/vem2.h_v   1.6   15 Apr 1998 16:53:22   weiwang  $
******************************************************************************/

#ifndef __VEM2
#define __VEM2

/***************************************************
* usefull defines to get the handles 
***************************************************/
#define GET_VEM_MEMORY_HANDLE(a) (((VEM_MAIN_STRUCT *)VCI_GET_VEM_HANDLE(a))->pMemoryHandler )
#define GET_VEM_METHOD_HANDLE(a) (((VEM_MAIN_STRUCT *)VCI_GET_VEM_HANDLE(a))->pVemMethodStruct)

/* switch for DSP's */
#define VEM_DEFINED 1

/* switch to turn on diagnostics */
#define VEM_TRACE 0

#include <stdlib.h>

/***************************************************
* VEM_KEY :
****************************************************/
#ifndef __VEM_KEY
#define __VEM_KEY
typedef void * VEM_KEY;
#endif /*  __VEM_KEY */

typedef unsigned short (VEM_FUNC)(void *, VEM_KEY);


/***************************************************
* public structure: PARAMETER_TYPE
****************************************************/  
#ifndef __VEM_PARAMETER_TYPE
#define __VEM_PARAMETER_TYPE
typedef enum tagPARAMETER_TYPE {
   VEM_VOID,
   VEM_CHAR,
   VEM_U_CHAR,
   VEM_SHORT,
   VEM_U_SHORT,
   VEM_INT,
   VEM_U_INT,
   VEM_LONG,
   VEM_U_LONG,
   VEM_FLOAT,
   VEM_DOUBLE
} PARAMETER_TYPE;
#endif /* __VEM_PARAMETER_TYPE */

/***************************************************
* public structure: VEM_METHOD_STRUCT
****************************************************/
typedef struct tagVEM_METHOD_STRUCT {
   /******* States *******/
   VEM_KEY (*lpfnVemUnregisterState)(const void *hVemMemHandle, VEM_KEY stateKey);
   VEM_KEY (*lpfnVemRegisterState)(const void *hVemMemHandle, const char *pszKey);
   unsigned short (*lpfnVemServiceState)(VEM_KEY stateKey);
   unsigned short (*lpfnVemDisableState)(VEM_KEY stateKey);
   unsigned short (*lpfnVemEnableState)(VEM_KEY  stateKey);
   VEM_KEY (*lpfnVemGetState)(const void *hVemMemHandle, const char *pszKey);

   void (*lpfnVemShowStates)(const void *hVemMemHandle);

   /******* Extensions *******/
   VEM_KEY (*lpfnVemUnregisterExtension)(const void *hVemMemHandle, VEM_KEY extensionKey);
   VEM_KEY (*lpfnVemRegisterExtension)(const void *hVemMemHandle, const char *pszKey, 
      VEM_FUNC *pVemFunc, VEM_FUNC *pVemFuncFree, void *pVemFuncMem);
   VEM_KEY (*lpfnVemGetExtension)(const void *hVemMemHandle, const char *pszKey);
   unsigned short (*lpfnVemDisableExtension)(VEM_KEY extensionKey);
   unsigned short (*lpfnVemEnableExtension)(VEM_KEY extensionKey);
   unsigned short (*lpfnVemAttachExtension)(VEM_KEY stateKey, VEM_KEY extensionKey, 
      unsigned short priority);
   unsigned short (*lpfnVemDetachExtension)(VEM_KEY stateKey, VEM_KEY extensionKey);
   VEM_FUNC *(*lpfnVemGetExtensionFunc)(const VEM_KEY extensionKey);
   unsigned short (*lpfnVemSetExtensionFunc)(VEM_KEY extensionKey, VEM_FUNC *vemFunc);
   void *(*lpfnVemGetExtensionData)(const VEM_KEY extensionKey);
   unsigned short (*lpfnVemSetExtensionData)(VEM_KEY extensionKey, void *vemFuncMem);
   void (*lpfnVemShowExtensions)(const void *hVemMemHandle);

   /******* Parameters *******/
   VEM_KEY (*lpfnVemUnregisterParameter)(void *hVemMemHandle, VEM_KEY pvVemParam);
   VEM_KEY (*lpfnVemRegisterArray)(void *hVemMemHandle, void *pData, PARAMETER_TYPE dataType, 
                            size_t dataSize, const char *pszKey);
   VEM_KEY (*lpfnVemRegisterTable)(void *hVemMemHandle, void *pData, PARAMETER_TYPE dataType, 
                            size_t dataSize, const char *pszKey);
   VEM_KEY (*lpfnVemRegisterVariable)(void *hVemMemHandle, void *pData, 
                               PARAMETER_TYPE paramType, const char *pszKey);
   VEM_KEY (*lpfnVemRegisterStruct)(void *hVemMemHandle, void *pData, size_t dataSize, 
                             const char *pszKey);
   VEM_KEY (*lpfnVemRegisterConstFloat)(void *pvMemMain, float val, const char *pszKey);
   VEM_KEY (*lpfnVemRegisterConstShort)(void *pvMemMain, short val, const char *pszKey);
   VEM_KEY (*lpfnVemGetParameter)(void *hVemMemHandle, const char *pszKey);
   unsigned short (*lpfnVemGetParameterData)(VEM_KEY pvVemParameter, void *pDataPtr);
   unsigned short (*lpfnVemSetParameterData)(VEM_KEY pvVemParameter, void *pDataPtr);
   void (*lpfnVemShowParameters)(const void *hVemMemHandle);
} VEM_METHOD_STRUCT;


/***************************************************
* public structure: VEM2
****************************************************/
typedef struct tagVEM2 {
   void *pVemStates;
   void *pVemExtensions;
   void *pVemParameters;
   void *pFunctions;
} VEM2;


/***************************************************
* public structure: VEM_MAIN_STRUCT
****************************************************/
typedef struct tagVEM_MAIN_STRUCT {
   VEM2              *pMemoryHandler;
   VEM_METHOD_STRUCT *pVemMethodStruct;
} VEM_MAIN_STRUCT;

#if(VEM_DEFINED==1)

/******* States *******/

/******************************************************************************
*
* Function:  vemUnregisterState
*
* Action:    Erase the existence of the state from the Vem memory handle
*
* Input:    hVemMemHandle -- main Vem memory handle
*           stateKey -- key to locate state
*
* Output:   stateKey -- updated state key
*
* Globals:  none
*
* Return:   NULL key
*******************************************************************************/
VEM_KEY vemUnregisterState(const void *hVemMemHandle, VEM_KEY stateKey);

/******************************************************************************
*
* Function:  vemRegisterState
*
* Action:    Register a state and should be called at a non critical time such
*            as in the initialization sequence
*
* Input:    hVemMemHandle -- main Vem memory handle
*           pszKey -- unique state identifier string
*
* Output:   none
*
* Globals:  none
*
* Return:   the key (or pointer) to quickly locate state
*******************************************************************************/
VEM_KEY vemRegisterState(const void *hVemMemHandle, const char *pszKey);

/******************************************************************************
*
* Function:  vemServiceState()
*
* Action:    This function services all states that were previously registered 
*            and enabled.
*
* Input:    stateKey -- key to locate state
*
* Output:   stateKey -- updated state key
*
* Globals:  none
*
* Return:   0: succeed
*           1: failed
*******************************************************************************/
unsigned short vemServiceState(VEM_KEY stateKey);

/******************************************************************************
*
* Function:  vemDisableState()
*
* Action:    This function will temporarily disable a state. All extensions 
*            attached to this state will still keep their relationship.
*
* Input:    stateKey -- key to locate state
*
* Output:   stateKey -- key with state disabled
*
* Globals:  none
*
* Return:   0: succeed
*           1: failed
*******************************************************************************/
unsigned short vemDisableState(VEM_KEY stateKey);

/******************************************************************************
*
* Function:  vemEnableState()
*
* Action:    This function will enable a state.
*
* Input:    stateKey -- key to locate state
*
* Output:   stateKey -- Key with state enabled
*
* Globals:  none
*
* Return:   0: succeed
*           1: failed
*******************************************************************************/
unsigned short vemEnableState(VEM_KEY  stateKey);

/******************************************************************************
*
* Function:  vemGetState()
*
* Action:    Get the key for a previously registered state
*
* Input:    hVemMemHandle -- main Vem memory handle
*           pszKey -- state's string identifer
*
* Output:   none
*
* Globals:  none
*
* Return:   key to locate state
*******************************************************************************/
VEM_KEY vemGetState(const void *hVemMemHandle, const char *pszKey);


/******************************************************************************
*
* Function:  vemShowStates()
*
* Action:    Print out a list of all states currently registered under the current
*            Vem memory handle. Every state that has one or more extensions attached
*            will also be listed.  If VEM_TRACE == 0, this is a NULL function.
*
* Input:    hVemMemHandle -- main Vem memory handle
*
* Output:   print the messages on stdout
*
* Globals:  none
*
* Return:   none
*******************************************************************************/
void vemShowStates(const void *hVemMemHandle);

/******* Extensions *******/

/******************************************************************************
*
* Function:  vemUnregisterExtension()
*
* Action:    This function can permanently removes an extension from the main Vem 
*            memory handle. 
*
* Input:    hVemMemHandle -- main Vem memory handle
*           extensionKey -- key to locate extension          
*
* Output:   extensionKey -- updated extension key
*
* Globals:  none
*
* Return:   a NULL key
*******************************************************************************/
VEM_KEY vemUnregisterExtension(const void *hVemMemHandle, VEM_KEY extensionKey);

/******************************************************************************
*
* Function:  vemRegisterExtension()
*
* Action:    Register the extension with the main Vem memory handle. It's enabled
*            by default and the key that is returned is need in order to attach
*            it to a state.
*
* Input:    hVemMemHandle -- main Vem memory handle
*           pszKey -- state's string identifier
*           pVemFunc -- extension's function
*           pVemFuncFree -- extension's free function
*           pVemFuncMem -- void pointer to extension's memory block
*           
* Output:   none
*
* Globals:  none
*
* Return:   key to locate extension
*******************************************************************************/
VEM_KEY vemRegisterExtension(const void *hVemMemHandle, const char *pszKey, 
                             VEM_FUNC *pVemFunc, VEM_FUNC *pVemFuncFree, 
                             void *pVemFuncMem);


/******************************************************************************
*
* Function:  vemGetExtension()
*
* Action:    If the extensions is not known, then this function can be called 
*            to retrieve it.
*
* Input:    hVemMemHandle -- main Vem memory handle
*           pszKey -- state's string identifier
*           
* Output:   none
*
* Globals:  none
*
* Return:   key to locate extension
*******************************************************************************/
VEM_KEY vemGetExtension(const void *hVemMemHandle, const char *pszKey);

/******************************************************************************
*
* Function:  vemDisableExtension()
*
* Action:   This function will temporarily disable the extension. It will still
*           be registered with the Vem memory handle.
*
* Input:    extensionKey -- key to locate extension
*           
* Output:   extensionKey -- key with the enable flag turned off
*
* Globals:  none
*
* Return:   0: succeed
*           1: failed
*******************************************************************************/
unsigned short vemDisableExtension(VEM_KEY extensionKey);

/******************************************************************************
*
* Function:  vemEnalbeExtension()
*
* Action:   If the extension was disabled, the extension can be enable again by
*           calling this function
*
* Input:    extensionKey -- key to locate extension
*           
* Output:   extensionKey -- Key with the enable flag turned on
*
* Globals:  none
*
* Return:   0: succeed
*           1: failed
*******************************************************************************/
unsigned short vemEnableExtension(VEM_KEY extensionKey);

/******************************************************************************
*
* Function:  vemAttachExtension()
*
* Action:    Attach the state with the extension
*
* Input:    stateKey -- key to locate state
*           extensionKey -- key to locate extension
*           priority -- priority level of attachment
*
* Output:   stateKey -- updated state key
*           extensionKey -- updated extension Key
*
* Globals:  none
*
* Return:   0: succeed
*           1: failed
*******************************************************************************/
unsigned short vemAttachExtension(VEM_KEY stateKey, VEM_KEY extensionKey, 
                                  const unsigned short priority);

/******************************************************************************
*
* Function:  vemDetachExtension()
*
* Action:    Detach the state from the extension
*
* Input:    stateKey -- key to locate state
*           extensionKey -- key to locate extension
*
* Output:   stateKey -- updated state key
*           extensionKey -- updated extension key
*
* Globals:  none
*
* Return:   0: succeed
*           1: failed
*******************************************************************************/
unsigned short vemDetachExtension(VEM_KEY stateKey, VEM_KEY extensionKey);

/******************************************************************************
*
* Function:  vemGetExtensionFunc()
*
* Action:   Retrieve the extension function
*
* Input:    extensionKey -- key to locate eaxtension
*           
* Output:   none
*
* Globals:  none
*
* Return:   pointer to extension's callback function
*******************************************************************************/
VEM_FUNC *vemGetExtensionFunc(const VEM_KEY extensionKey);


/******************************************************************************
*
* Function:  vemSetExtensionFunc()
*
* Action:   Set the extension's callback function
*
* Input:    extensionKey -- key to locate extension
*           vemFunc -- pointer to extension's callback function
*           
* Output:   extensionKey -- updated extension key
*
* Globals:  none
*
* Return:   0: succeed
*           1: failed
*******************************************************************************/
unsigned short vemSetExtensionFunc(VEM_KEY extensionKey, VEM_FUNC *vemFunc);

/******************************************************************************
*
* Function:  vemGetExtensionData()
*
* Action:   Return the extension's memory
*
* Input:    extensionKey -- key to locate eaxtension
*           
* Output:   none
*
* Globals:  none
*
* Return:   pointer to extension's memory block
*******************************************************************************/
void *vemGetExtensionData(const VEM_KEY extensionKey);

/******************************************************************************
*
* Function:  vemSetExtensionData()
*
* Action:   Set the extension's memory
*
* Input:    extensionKey -- key to locate extension
*           vemFuncMem -- pointer to extension's memory block
*           
* Output:   extensionKey -- updated extension key
*
* Globals:  none
*
* Return:   0: succeed 
*           1: failed
*******************************************************************************/
unsigned short vemSetExtensionData(VEM_KEY extensionKey, void *vemFuncMem);


/******************************************************************************
*
* Function:  vemShowExtensions()
*
* Action:   If VEM_TRACE is 1, then show all extensions and every extension's 
*           states attachment. Otherwise, it's a null function.
*
* Input:    hVemMemHandle -- main Vem memory handle
*
* Output:   print the messages on stdout
*
* Globals:  none
*
* Return:   none
*******************************************************************************/
void vemShowExtensions(const void *hVemMemHandle);

/* main create and destroy routines */

/******************************************************************************
*
* Function:  vemFree()
*
* Action:    Destroys the current instance of Vem.
*
* Input:    hVemMainHandle -- Vem handler
*
* Output:   hVemMainHandle -- NULL pointer
*
* Globals:   none
*
* Return:    NULL pointer
*******************************************************************************/
void *vemFree(void *hVemMainHandle);


/******************************************************************************
*
* Function:  vemInit()
*
* Action:    Initilaize Vem memory and extensions. It passes back it's memory
*            handle back to the user which should be checked for a NULL value
*            in case of insufficient memory.
*
* Input:    none
*
* Output:   none
*
* Globals:   none
*
* Return:    Vem memory handler
*******************************************************************************/
void *vemInit(void);

#else /* VEM_DEFINED */

/******* States *******/
#define vemUnregisterState(hVemMemHandle, stateKey)     ((VEM_KEY)NULL)
#define vemRegisterState(hVemMemHandle, pszKey)         ((VEM_KEY)NULL)
#define vemServiceState(stateKey)                       ((VEM_KEY)NULL)
#define vemDisableState(stateKey)                       ((VEM_KEY)NULL)
#define vemEnableState(stateKey)                        ((VEM_KEY)NULL)
#define vemGetState(hVemMemHandle, pszKey)              ((VEM_KEY)NULL)

#define vemShowStates(hVemMemHandle)                    ((VEM_KEY)NULL)

/******* Extensions *******/
#define vemUnregisterExtension(hVemMemHandle, extensionKey) ((VEM_KEY)NULL)
#define vemRegisterExtension(hVemMemHandle, pszKey, pVemFunc, \
   pVemFuncFree, pVemFuncMem)                           ((VEM_KEY)NULL)
#define vemGetExtension(hVemMemHandle, pszKey)          ((VEM_KEY)NULL)
#define vemDisableExtension(extensionKey)               ((VEM_KEY)NULL)
#define vemEnableExtension(extensionKey)                ((VEM_KEY)NULL)
#define vemAttachExtension(stateKey, extensionKey, priority) ((VEM_KEY)NULL)
#define vemDetachExtension(stateKey, extensionKey)      ((VEM_KEY)NULL)

#define vemGetExtensionFunc(extensionKey)               ((VEM_KEY)NULL)
#define vemSetExtensionFunc(extensionKey, vemFunc)      ((VEM_KEY)NULL)
#define vemGetExtensionData(extensionKey)               ((VEM_KEY)NULL)
#define vemSetExtensionData(extensionKey, vemFuncMem)   ((VEM_KEY)NULL)

#define vemShowExtensions(hVemMemHandle)                ((VEM_KEY)NULL)

/* main create and destroy routines */
#define vemFree(hVemMainHandle)                         ((VEM_KEY)NULL)
#define vemInit()                                       ((VEM_KEY)NULL)

#endif /* VEM_DEFINED */

#endif /* __VEM2 */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\voxware\vcivr12.c ===
/******************************************************************************
 *                                                                            *
 *                      Voxware Proprietary Material                          *
 *                      Copyright 1996, Voxware, Inc.                         *
 *                           All Rights Resrved                               *
 *                                                                            *
 *                     DISTRIBUTION PROHIBITED without                        *
 *                   written authorization from Voxware                       *
 *                                                                            *
 ******************************************************************************/

/******************************************************************************
 *                                                                            *
 * FILENAME:  vciVR12.c                                                       *
 * PURPOSE:   Defines the interface functions for Voxware's variable rate cdc *                                             *
 * AUTHOR:    Ilan Berci, Epiphany Vera   97/05/27                            *
 *                                                                            *
 *****************************************************************************/

/** ************************************************************************ **/
/**                              Standard headers                            **/
/** ************************************************************************ **/
#include <stdlib.h>
#include <string.h>
#include <math.h>
#include <assert.h>


/** ************************************************************************ **/
/**                               Codec Headers                              **/
/** ************************************************************************ **/
#include "VoxMem.h"
#include "model.h"
#include "quanvr12.h"
#include "vem2.h"

#include "Pack12.h"
#include "Quan12.h"
#include "EncodeRT.h"
#include "DecodeRT.h"
#include "FadeIO.h"
#include "QTable12.h" /* For Quantization types */
#include "vCodecID.h"

/** ************************************************************************ **/
/**                     Voxware Core Interface Headers                       **/
/** ************************************************************************ **/
#include "vciError.h"   /* VCI Specific errors.                               */
#include "vci.h"
#include "vciPriv.h"    /* Voxware Core Interface (VCI) private definations   */
#include "vciPlus.h"

#include "vemFrm12.h"
#include "vciVR12.h"

#include "xvocver.h"

/** ************************************************************************ **/
/**                     Voxware Core Interface Static Functions              **/
/** ************************************************************************ **/
static short DropFrames(float InWarp, float *OutWarp, short *DropLeft);
static unsigned short initMethodStruct(VCI_METHOD_STRUCT **hVciMethodStruct);
static unsigned short freeMethodStruct(VCI_METHOD_STRUCT **hVciMethodStruct);

/** ************************************************************************ **/
/**                     Voxware Core Interface PreDefines                    **/
/** ************************************************************************ **/
#define ON          1
#define OFF         0
#define STRETCH_IT  1
#define DROP_IT     0
/*============================================================================*/

#define PRIME_FLUSH_SAMP   90    /* delay: dec: 90 + end: 180 ==> 360-180-90 = 90 */
#define PRIME_FLUSH_FRAME  2     /* 360 samples total delay if we count prime flush samples*/
#define PACKET_BITS_VR12   64    /* The number of bits in a bit-stream packet  */
#define PACKET_BYTE_VR12   8     /* The minimum bytes required to store one    */
                                 /* bit-stream packet.                         */
                                 
/** ************************************************************************ **/
/**                            Private Prototypes                            **/
/** ************************************************************************ **/ 
                                
unsigned  short VR12CompatibilityFunc(unsigned short VemPlugin, 
                                      unsigned long * pVemCodID);
                                                                       
/* ************************************************************************** */
/*                                                                            */
/* FUNCTION: vciGetInfoVR12()                                                 */
/* PURPOSE : Encodes one frame of speech.                                     */
/*                                                                            */
/* ************************************************************************** */
VCI_RETCODE vciGetInfoVR12(VCI_CODEC_INFO_BLOCK *pvciCodecInfoBlk)
{
   float avebits;

   if(!pvciCodecInfoBlk)
      return VCI_NULL_ARG;

   pvciCodecInfoBlk->wVCIVersion               = (unsigned short) VCI_VERSION;
   
   /* Variables for codec identification.     */
   strcpy(pvciCodecInfoBlk->sCodecVersion,     "RT.03.01.00");         
   pvciCodecInfoBlk->dwCodecClassID            = (unsigned long)  VOXWARE_CODEC_RT_8K_VR12;      
   pvciCodecInfoBlk->dwCodecID                 = (unsigned long)  VOXWARE_CODEC_ID_RT_8K_VR12;
   
   /* PCM Data formats.                       */
   pvciCodecInfoBlk->wSamplingRate             = (unsigned short) RATE8K;   
   pvciCodecInfoBlk->wNumBitsPerSample         = 16; 
   pvciCodecInfoBlk->wNumSamplesPerFrame       = (unsigned short) FRAME_LEN;
   
   /* Multi-channel support.                  */
   pvciCodecInfoBlk->wNumChannels              = 1;
   pvciCodecInfoBlk->wInterleaveBlockSize      = 1;

   /* Bitstream information.                  */
   avebits =  (TOTAL_BITS_VR12_SILENCE*RATE_S + TOTAL_BITS_VR12_UNVOICED*RATE_UV 
             + TOTAL_BITS_VR12_VOICED*RATE_V + TOTAL_BITS_VR12_MIXED*RATE_MIX);
   pvciCodecInfoBlk->dwBitRate                  = (unsigned long) (avebits*RATE8K/((float)FRAME_LEN));
   pvciCodecInfoBlk->dwMinPacketBits            = (unsigned long) TOTAL_BITS_VR12_SILENCE;
   pvciCodecInfoBlk->dwAvgPacketBits            = (unsigned long) avebits;
   pvciCodecInfoBlk->dwMaxPacketBits            = (unsigned long) TOTAL_BITS_VR12_MIXED;

   /* Prime Flush Information	*/
   pvciCodecInfoBlk->wNumPrimeFlushFrames      = (unsigned short) PRIME_FLUSH_FRAME;
   pvciCodecInfoBlk->wNumPrimeFlushSamples     = (unsigned short) PRIME_FLUSH_SAMP;    
   return(VCI_NO_ERROR);
}
/*============================================================================*/



/* ************************************************************************** */
/*                                                                            */
/* FUNCTION: vciEncodeVR12()                                                  */
/* PURPOSE : Encodes one frame of speech.                                     */
/*                                                                            */
/* ************************************************************************** */
VCI_RETCODE vciEncodeVR12(void *hCodecMemBlk, VCI_CODEC_IO_BLOCK 
                          *hvciEncodeIOBlk)
{
   VCI_CODEC_BLOCK *vciCodecMblk = NULL;
   STACK_DECLARE
   
   /* First make sure that the handle passed is the correct one. */
   if(!VCI_BLOCK_CHECK(hCodecMemBlk))
      return VCI_NOT_VCI_HANDLE;

   if(!VCI_IS_ENCODE(hCodecMemBlk))
      return VCI_NOT_ENC_HANDLE;

   VCI_IO_BLK_PARAM_CHECK(hvciEncodeIOBlk);

   vciCodecMblk = (VCI_CODEC_BLOCK *)hCodecMemBlk;
   STACK_ASSIGN(vciCodecMblk->pScratchBlk)
   
   vciCodecMblk->pVciCodecIOBlock=hvciEncodeIOBlk;

   VoxEncodeRT(STACK_S hvciEncodeIOBlk->pPCMBuffer,vciCodecMblk->hCodecMblk);
   
   VoxQuanVR12(vciCodecMblk->pQuanMemBlk, 
             ((ENC_MEM_BLK *)(vciCodecMblk->hCodecMblk))->Param_mblk);

   VoxPackVR12(vciCodecMblk->pQuanMemBlk, hvciEncodeIOBlk->pVoxBuffer, 
      &(hvciEncodeIOBlk->wVoxBufferWriteByteOffset),
      &(hvciEncodeIOBlk->chVoxBufferWriteBitOffset), 
      hvciEncodeIOBlk->wVoxBufferSize);

   return(VCI_NO_ERROR);
}
/*============================================================================*/



/* ************************************************************************** */
/*                                                                            */
/* FUNCTION: vciDecodeVR12()                                                  */
/* PURPOSE : Decodes one frame of speech.                                     */
/*                                                                            */
/* ************************************************************************** */
VCI_RETCODE vciDecodeVR12(void *hCodecMemBlk, VCI_CODEC_IO_BLOCK 
                          *hvciDecodeIOBlk)
{
   VCI_CODEC_BLOCK *vciCodecMblk = NULL;
   DEC_MEM_BLK     *DecMemBlk    = NULL;
   STACK_DECLARE
   FadeIOstruct    *pFadeBlk     = NULL;
   unsigned short  TempFrames;

   /* First make sure that the handle passed is the correct one. */
   if(!VCI_BLOCK_CHECK(hCodecMemBlk))
      return VCI_NOT_VCI_HANDLE;

   if(!VCI_IS_DECODE(hCodecMemBlk))
      return VCI_NOT_DEC_HANDLE;
   
   VCI_IO_BLK_PARAM_CHECK(hvciDecodeIOBlk);

   vciCodecMblk = (VCI_CODEC_BLOCK *)hCodecMemBlk;
   DecMemBlk= ((DEC_MEM_BLK*)(vciCodecMblk->hCodecMblk));

   pFadeBlk = (FadeIOstruct *)(DecMemBlk->pFadeIOMemBlk);

   STACK_ASSIGN(vciCodecMblk->pScratchBlk)
   vciCodecMblk->pVciCodecIOBlock=hvciDecodeIOBlk;

  if((DecMemBlk->unpackFLAG==ON)&&(pFadeBlk->CurrentFrameState))
  {
      framesInBufferVR12(hvciDecodeIOBlk, &TempFrames);
      if (TempFrames == 0)
         return VCI_INSUFFICIENT_VOX_DATA;

       VoxUnPackVR12(vciCodecMblk->pQuanMemBlk, hvciDecodeIOBlk->pVoxBuffer, 
          &(hvciDecodeIOBlk->wVoxBufferReadByteOffset), 
          &(hvciDecodeIOBlk->chVoxBufferReadBitOffset), 
          hvciDecodeIOBlk->wVoxBufferSize);
  }

  if (!DropFrames(DecMemBlk->fWarpedLengthFactor,&DecMemBlk->Warp,&DecMemBlk->dropLeft)) {
     VoxUnQuanVR12(vciCodecMblk->pQuanMemBlk, DecMemBlk->Param_mblk);

     VoxFadeIO(pFadeBlk, DecMemBlk->Param_mblk);

     VoxDecodeRT(STACK_S hvciDecodeIOBlk->pPCMBuffer,DecMemBlk);

     if (!DecMemBlk->unpackFLAG) {
       if (pFadeBlk->LastFrameState == SILENCE)
	 pFadeBlk->CurrentFrameState = SILENCE;
     }

     if(DecMemBlk->writeFLAG) 
        hvciDecodeIOBlk->wSamplesInPCMBuffer = FRAME_LEN;
     else  
        hvciDecodeIOBlk->wSamplesInPCMBuffer = 0;
      
  } else {
     DecMemBlk->writeFLAG=0;
     hvciDecodeIOBlk->wSamplesInPCMBuffer = 0;
  } 

  return(VCI_NO_ERROR);
}
/*============================================================================*/



/* ************************************************************************** */
/*                                                                            */
/* FUNCTION: vciInitEncodeVR12()                                              */
/* PURPOSE : To allocate memory for a Codec Memory Block and to initialize it */
/*           as an encoder.                                                   */
/*                                                                            */
/* ************************************************************************** */
VCI_RETCODE vciInitEncodeVR12(void **hCodecMemBlk)
{
   VCI_CODEC_BLOCK *vciCodecMblk;
   STACK_DECLARE

   if(!hCodecMemBlk)
      return VCI_NULL_ARG;

   if(VOX_MEM_INIT(vciCodecMblk=*hCodecMemBlk,1,sizeof(VCI_CODEC_BLOCK))) 
     return VCI_FAILED_MEM_ALLOC;

   vciCodecMblk->chEncOrDec = ENCODE_ID;
   vciCodecMblk->dwVciChunkID = SANITY_CHECK;
   vciCodecMblk->dwCodecClassID = VOXWARE_CODEC_RT_8K_VR12;  
   vciCodecMblk->dwCodecID = VOXWARE_CODEC_ID_RT_8K_VR12; 

   if(!(vciCodecMblk->pvemMemBlk=vemInit())) {
#if VEM_DEFINED == 1
      return VCI_FAILED_MEM_ALLOC;
#endif
   }

   if(VoxInitEncodeRT(&vciCodecMblk->hCodecMblk,vciCodecMblk->pvemMemBlk)) {
      vciFreeEncodeVR12(hCodecMemBlk);
      return VCI_FAILED_MEM_ALLOC;
   }

   if(VoxInitQuanVR12(&vciCodecMblk->pQuanMemBlk, vciCodecMblk->pvemMemBlk)) {
      vciFreeEncodeVR12(hCodecMemBlk);
      return VCI_FAILED_MEM_ALLOC;
   }

   if(STACK_SET(vciCodecMblk->pScratchBlk,10240)) {
      vciFreeEncodeVR12(hCodecMemBlk);
      return VCI_FAILED_MEM_ALLOC;
   }

   if(initMethodStruct(&vciCodecMblk->pVciMethodStruct))
      return VCI_FAILED_MEM_ALLOC;

   return VCI_NO_ERROR;
}
/*============================================================================*/



/* ************************************************************************** */
/*                                                                            */
/* FUNCTION: vciInitDecodeVR12()                                              */
/* PURPOSE : To allocate memory for a Codec Memory Block and to initialize it */
/*           as a decoder.                                                    */
/*                                                                            */
/* ************************************************************************** */
VCI_RETCODE vciInitDecodeVR12(void **hCodecMemBlk)
{
   VCI_CODEC_BLOCK *vciCodecMblk;
   DEC_MEM_BLK     *DecMemBlk = NULL;

   STACK_DECLARE

   if(!hCodecMemBlk)
      return VCI_NULL_ARG;

   if(VOX_MEM_INIT(vciCodecMblk=*hCodecMemBlk,1,sizeof(VCI_CODEC_BLOCK))) 
      return VCI_FAILED_MEM_ALLOC;

   vciCodecMblk->chEncOrDec = DECODE_ID;
   vciCodecMblk->dwVciChunkID = SANITY_CHECK;
   vciCodecMblk->dwCodecClassID = VOXWARE_CODEC_RT_8K_VR12;  
   vciCodecMblk->dwCodecID = VOXWARE_CODEC_ID_RT_8K_VR12; 

   if(!(vciCodecMblk->pvemMemBlk=vemInit())) {
#if VEM_DEFINED == 1
      return VCI_FAILED_MEM_ALLOC;
#endif
   }

   if(VoxInitDecodeRT(&vciCodecMblk->hCodecMblk,vciCodecMblk->pvemMemBlk)) {
      vciFreeDecodeVR12(hCodecMemBlk);
      return VCI_FAILED_MEM_ALLOC;
   } 

   if(VoxInitQuanVR12(&vciCodecMblk->pQuanMemBlk, vciCodecMblk->pvemMemBlk)) {     
      vciFreeDecodeVR12(hCodecMemBlk);
      return VCI_FAILED_MEM_ALLOC;
   } 

   DecMemBlk = (DEC_MEM_BLK *)vciCodecMblk->hCodecMblk;
   if (VoxinitFadeIO(&DecMemBlk->pFadeIOMemBlk)) {
      vciFreeDecodeVR12(hCodecMemBlk);
      return VCI_FAILED_MEM_ALLOC;
   }

   if(STACK_SET(vciCodecMblk->pScratchBlk,4096)) {
      vciFreeDecodeVR12(hCodecMemBlk);
      return VCI_FAILED_MEM_ALLOC;
   } 

   if(initMethodStruct(&vciCodecMblk->pVciMethodStruct))
      return VCI_FAILED_MEM_ALLOC;

   ((DEC_MEM_BLK*)vciCodecMblk->hCodecMblk)->fWarpedLengthFactor=1.0F;
   ((DEC_MEM_BLK*)vciCodecMblk->hCodecMblk)->Warp=1.0F;
   ((DEC_MEM_BLK*)vciCodecMblk->hCodecMblk)->dropRate=1;
   ((DEC_MEM_BLK*)vciCodecMblk->hCodecMblk)->writeFLAG=1;
   ((DEC_MEM_BLK*)vciCodecMblk->hCodecMblk)->unpackFLAG=1;
   ((DEC_MEM_BLK*)vciCodecMblk->hCodecMblk)->dropLeft=0;

   return VCI_NO_ERROR;
}
/*============================================================================*/




/* ************************************************************************** */
/*                                                                            */
/* FUNCTION: vciFreeEncodeVR12()                                              */
/* PURPOSE : Frees memory assigned to the encoder.                            */
/*                                                                            */
/* ************************************************************************** */
VCI_RETCODE vciFreeEncodeVR12(void **hCodecMemBlk)
{  
   VCI_CODEC_BLOCK *vciCodecMblk   = NULL;

   if(!hCodecMemBlk)
      return VCI_NULL_ARG;

   /* First make sure that the handle passed is the correct one. */
   if(!VCI_BLOCK_CHECK(*hCodecMemBlk))
      return VCI_NOT_VCI_HANDLE;

   if(!VCI_IS_ENCODE(*hCodecMemBlk))
      return VCI_NOT_ENC_HANDLE;
   
   vciCodecMblk = (VCI_CODEC_BLOCK *)*hCodecMemBlk;
   STACK_UNSET(vciCodecMblk->pScratchBlk)

   vciCodecMblk->dwVciChunkID=0;

   vemFree(vciCodecMblk->pvemMemBlk);

   if(vciCodecMblk->hCodecMblk) {
      VoxFreeEncodeRT(&vciCodecMblk->hCodecMblk);
      VoxFreeQuanVR12(&vciCodecMblk->pQuanMemBlk);
   }

   VOX_MEM_FREE(vciCodecMblk->hCodecMblk);

   freeMethodStruct(&vciCodecMblk->pVciMethodStruct);

   VOX_MEM_FREE(*hCodecMemBlk);

   return VCI_NO_ERROR;
}
/*============================================================================*/




/* ************************************************************************** */
/*                                                                            */
/* FUNCTION: vciFreeDecodeVR12()                                              */
/* PURPOSE : Frees memory assigned to the decoder.                            */
/*                                                                            */
/* ************************************************************************** */
VCI_RETCODE vciFreeDecodeVR12(void **hCodecMemBlk)
{
   VCI_CODEC_BLOCK *vciCodecMblk = NULL;
   DEC_MEM_BLK *DecMemBlk;

   if(!hCodecMemBlk)
      return VCI_NULL_ARG;

   /* First make sure that the handle passed is the correct one. */
   if(!VCI_BLOCK_CHECK(*hCodecMemBlk))
      return VCI_NOT_VCI_HANDLE;

   if(!VCI_IS_DECODE(*hCodecMemBlk))
      return VCI_NOT_DEC_HANDLE;
   
   vciCodecMblk = (VCI_CODEC_BLOCK *)*hCodecMemBlk;
   STACK_UNSET(vciCodecMblk->pScratchBlk)

   vciCodecMblk->dwVciChunkID=0;

   vemFree(vciCodecMblk->pvemMemBlk);

   if(vciCodecMblk->hCodecMblk) {
      DecMemBlk = (DEC_MEM_BLK *)vciCodecMblk->hCodecMblk;
      VoxfreeFadeIO(&DecMemBlk->pFadeIOMemBlk);
      VoxFreeDecodeRT(&vciCodecMblk->hCodecMblk);
      VoxFreeQuanVR12(&vciCodecMblk->pQuanMemBlk);
   }

   freeMethodStruct(&vciCodecMblk->pVciMethodStruct);

   VOX_MEM_FREE(*hCodecMemBlk);

  return VCI_NO_ERROR;
}

/*============================================================================*/

/* ************************************************************************** */
/*                                                                            */
/* FUNCTION: DropFrames()                                                     */
/* PURPOSE : Decides on whether to drop a frame                               */
/*                                                                            */
/* ************************************************************************** */
short DropFrames(float InWarp, float *OutWarp, short *DropLeft)
{
   short dropit;

   if (*DropLeft==0) {
      dropit = 0;
      if (InWarp >=1.0)
         *DropLeft = 0;
      else 
         *DropLeft = ((short)floor(1.0/InWarp))-1;

     *OutWarp = InWarp*((*DropLeft)+1);
   } else  {
      dropit=1;
     (*DropLeft)--;
   }

   return(dropit);
}

/* ************************************************************************** */
/*                                                                            */
/* FUNCTION: vciGetExtCompatibilityVR12()                                     */
/* PURPOSE : Returns function pointer to the function vemIsCompatible         */
/*                                                                            */
/* ************************************************************************** */
unsigned  short VR12CompatibilityFunc(unsigned short VemPlugin, 
                                      unsigned long * pVemCodID) 
{
   *pVemCodID=(unsigned long)VOXWARE_CODEC_RT_8K_VR12;
   
   switch(VemPlugin) {
      case COMPATIBILITY_VFONT:
         return (unsigned short)20;

      case COMPATIBILITY_VAD_AGC:
         return (unsigned short)20;

      case COMPATIBILITY_PLUS: 
         return (unsigned short)20;
   }
   return 0;
}

VCI_RETCODE vciGetExtCompatibilityVR12(void **pCompatFunc)
{
   if(!pCompatFunc)
      return VCI_NULL_ARG;

   *((COMPATIBILITY_FUNCTION **)pCompatFunc)=&VR12CompatibilityFunc;

   return VCI_NO_ERROR;
}

static unsigned short initMethodStruct(VCI_METHOD_STRUCT **hVciMethodStruct)
{
   if(VOX_MEM_INIT(*hVciMethodStruct,1,sizeof(VCI_METHOD_STRUCT)))
      return 1;

   (*hVciMethodStruct)->pfVciGetInfo=vciGetInfoVR12;

   (*hVciMethodStruct)->pfVciEncode=vciEncodeVR12;
   (*hVciMethodStruct)->pfVciDecode=vciDecodeVR12;

   (*hVciMethodStruct)->pfVciInitEncode=vciInitEncodeVR12;
   (*hVciMethodStruct)->pfVciInitDecode=vciInitDecodeVR12; 
                                                      
   (*hVciMethodStruct)->pfVciFreeEncode=vciFreeEncodeVR12;                                                       
   (*hVciMethodStruct)->pfVciFreeDecode=vciFreeDecodeVR12;  

   return 0;
}

static unsigned short freeMethodStruct(VCI_METHOD_STRUCT **hVciMethodStruct)
{
   if(hVciMethodStruct)
      VOX_MEM_FREE(*hVciMethodStruct);

   return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\voxware\vem2.c ===
/******************************************************************************
*                        Voxware Proprietary Material
*                        Copyright 1996, Voxware, Inc
*                            All Rights Reserved
*
*                       DISTRIBUTION PROHIBITED without
*                      written authorization from Voxware
******************************************************************************/

/******************************************************************************
* Filename:        vem2.c
*
* Purpose:     Main VEM functions
*
* Functions:  vemUnregisterState, ...
*
* Author/Date:     Ilan Berci
*******************************************************************************
*
* Modifications:
*
* Comments:
*
* Concerns:
*
* $Header:   /export/phobos/pvcs/r_and_d/archives/common/vem/vem2.c_v   1.5   25 Mar 1998 14:23:12   weiwang  $
******************************************************************************/

#include <stdlib.h>
#include <string.h>
#include <assert.h>

#include "VoxMem.h"

#include "vector.h"
#include "vem2Prm.h"

#include "vem2.h"

#include "xvocver.h"


#if VEM_DEFINED == 1
/*--------------------------------------------------
  private definitions: DISABLED and ENABLES
  --------------------------------------------------*/
typedef enum tagVEM_ENABLE{DISABLED, ENABLED} VEM_ENABLE;


/*--------------------------------------------------
  private structure: VEM_EXTENSION
  --------------------------------------------------*/
typedef struct tagVEM_EXTENSION {
   char        *pszKey;
   VEM_FUNC    *vemFunc;
   VEM_FUNC    *vemFuncFree;
   void        *vemFuncMem;
   void        *pAttachVec;
   VEM_ENABLE  enable; 
} VEM_EXTENSION;

/*--------------------------------------------------
  private structure: VEM_STATE
  --------------------------------------------------*/
typedef struct tagVEM_STATE {
   char        *pszKey;
   void        *pAttachVec;
   VEM_ENABLE  enable;
} VEM_STATE;

/*--------------------------------------------------
  private structure: VEM_ATTACH
  --------------------------------------------------*/
typedef struct tagVEM_ATTACH {
   unsigned short priority;
   VEM_EXTENSION *pVemExtension;
   VEM_STATE *pVemState;
} VEM_ATTACH;


/******************************************************************************
*
* Function:  vemUnregisterState
*
* Action:    Erase the existence of the state from the Vem memory handle
*
* Input:    hVemMemHandle -- main Vem memory handle
*           stateKey -- key to locate state
*
* Output:   stateKey -- updated state key
*
* Globals:  none
*
* Return:   NULL key
*******************************************************************************
*
* Implementation/Detailed Description:
*
* References:
*******************************************************************************
*
* Modifications:
*
* Comments:  Since all states are automatically unregistered at cleanup, this 
*            function need not be called unless the user intenses to do so. All 
*            extensions that are associated with this state will have their ties
*            removed. Please note that any state can be temporarily disabled
*            with vemDisableState().
*
* Concerns/TBD:
******************************************************************************/
VEM_KEY vemUnregisterState(const void *hVemMemHandle, VEM_KEY stateKey)
{
   VEM_ATTACH        *pVemAttach       = NULL;
   VEM_KEY            extensionKey     = NULL;
   void              *pElement;
   VEM2              *pVemMemHandler   = (VEM2 *)hVemMemHandle;

   VEM_STATE         *pVemState        = (VEM_STATE *)vecGetData((void *)stateKey);
 
   if(pVemState) {
      if(pVemState->pAttachVec) {

         while(0 != (pElement=vecGetFirstElement(pVemState->pAttachVec))) {
            pVemAttach=(VEM_ATTACH *)vecGetData(pElement);
            extensionKey=(VEM_KEY)vecFindElement(pVemMemHandler->pVemExtensions, 
               pVemAttach->pVemExtension, FORWARDS);

            vemDetachExtension(stateKey, extensionKey);
         }

         vecFree(pVemState->pAttachVec);
         pVemState->pAttachVec=NULL;
      }
      vecDelElement(pVemMemHandler->pVemStates, stateKey);
      VOX_MEM_FREE(pVemState->pszKey);
      VOX_MEM_FREE(pVemState);
   }

   return NULL;
}


/******************************************************************************
*
* Function:  vemRegisterState
*
* Action:    Register a state and should be called at a non critical time such
*            as in the initialization sequence
*
* Input:    hVemMemHandle -- main Vem memory handle
*           pszKey -- unique state identifier string
*
* Output:   none
*
* Globals:  none
*
* Return:   the key (or pointer) to quickly locate state
*******************************************************************************
*
* Implementation/Detailed Description:
*
* References:
*******************************************************************************
*
* Modifications:
*
* Comments:  
*
* Concerns/TBD:
******************************************************************************/
VEM_KEY vemRegisterState(const void *hVemMemHandle, const char *pszKey)
{
   VEM_STATE         *pVemState        = NULL;
   VEM_KEY           *pKey             = NULL;
   VEM2              *pVemMemHandler   = (VEM2 *)hVemMemHandle;

   /* initialize main vem state memory */
   if(VOX_MEM_INIT(pVemState,1,sizeof(VEM_STATE)))
       return NULL;
   else {
      pVemState->pszKey=NULL;
      pVemState->pAttachVec=NULL;
      pVemState->enable=ENABLED;
   }
      

   /* initialize and store the vector key */
   if(!(pKey=(VEM_KEY)vecAddElement(pVemMemHandler->pVemStates, pVemState, FORWARDS))) {
      VOX_MEM_FREE(pVemState);
      return NULL;
   }

   /* initialize the string key */
   if(VOX_MEM_INIT(pVemState->pszKey,strlen(pszKey)+1,sizeof(char))) 
      return(vemUnregisterState(hVemMemHandle, pKey));
   else
      strcpy(pVemState->pszKey,pszKey);

   /* initialize the state's extension vector */
   if(!(pVemState->pAttachVec=vecInit())) 
      return(vemUnregisterState(hVemMemHandle, pKey));

   return(pKey);
}


/******************************************************************************
*
* Function:  vemServiceState()
*
* Action:    This function services all states that were previously registered 
*            and enabled.
*
* Input:    stateKey -- key to locate state
*
* Output:   stateKey -- updated state key
*
* Globals:  none
*
* Return:   0: succeed
*           1: failed
*******************************************************************************
*
* Implementation/Detailed Description:
*
* References:
*******************************************************************************
*
* Modifications:
*
* Comments:
*
* Concerns/TBD:
******************************************************************************/

unsigned short vemServiceState(VEM_KEY stateKey)
{
   VEM_STATE         *pVemState        = NULL;
   VEM_EXTENSION     *pVemExtension    = NULL;
   void              *pElement         = NULL;

   if(!(pVemState=(VEM_STATE *)vecGetData((void *)stateKey)))
      return 1;

   if(pVemState->enable==DISABLED)
      return 1;

   pElement = vecGetFirstElement(pVemState->pAttachVec);

   while(pElement) {
      pVemExtension=((VEM_ATTACH*)vecGetData(pElement))->pVemExtension;
      if(pVemExtension->enable==ENABLED)
         (pVemExtension->vemFunc)(pVemExtension->vemFuncMem, stateKey);

      pElement=vecGetNextElement(pElement, FORWARDS);
   }
   return 0;
}

/******************************************************************************
*
* Function:  vemDisableState()
*
* Action:    This function will temporarily disable a state. All extensions 
*            attached to this state will still keep their relationship.
*
* Input:    stateKey -- key to locate state
*
* Output:   stateKey -- key with state disabled
*
* Globals:  none
*
* Return:   0: succeed
*           1: failed
*******************************************************************************
*
* Implementation/Detailed Description:
*
* References:
*******************************************************************************
*
* Modifications:
*
* Comments:
*
* Concerns/TBD:
******************************************************************************/

unsigned short vemDisableState(VEM_KEY stateKey)
{
   VEM_STATE *pVemState=vecGetData((void *)stateKey);

   if(!pVemState)
      return 1;
   else
      pVemState->enable=DISABLED;
   return 0;
}


/******************************************************************************
*
* Function:  vemEnableState()
*
* Action:    This function will enable a state.
*
* Input:    stateKey -- key to locate state
*
* Output:   stateKey -- Key with state enabled
*
* Globals:  none
*
* Return:   0: succeed
*           1: failed
*******************************************************************************
*
* Implementation/Detailed Description:
*
* References:
*******************************************************************************
*
* Modifications:
*
* Comments:
*
* Concerns/TBD:
******************************************************************************/

unsigned short vemEnableState(VEM_KEY stateKey)
{
   VEM_STATE *pVemState=vecGetData((void *)stateKey);

   if(!pVemState)
      return 1;
   else
      pVemState->enable=ENABLED;
   return 0;
}

/******************************************************************************
*
* Function:  vemGetState()
*
* Action:    Get the key for a previously registered state
*
* Input:    hVemMemHandle -- main Vem memory handle
*           pszKey -- state's string identifer
*
* Output:   none
*
* Globals:  none
*
* Return:   key to locate state
*******************************************************************************
*
* Implementation/Detailed Description:
*
* References:
*******************************************************************************
*
* Modifications:
*
* Comments:  This function should only be used when absolutely necessary as it
*            is CPU intensive.
*
* Concerns/TBD:
******************************************************************************/

VEM_KEY vemGetState(const void *hVemMemHandle, const char *pszKey)
{
   void              *pVemElement      = NULL;
   VEM2              *pVemMemHandler   = (VEM2 *)hVemMemHandle;

   pVemElement = vecGetFirstElement(pVemMemHandler->pVemStates);
   while(pVemElement) {
      if(!strcmp(pszKey, ((VEM_STATE *)vecGetData(pVemElement))->pszKey))
         break; /* match! */
      pVemElement=vecGetNextElement(pVemElement, FORWARDS);
   }
   return ((VEM_KEY)pVemElement); /* could be null if it wasn't found */
}



/******************************************************************************
*
* Function:  vemUnregisterExtension()
*
* Action:    This function can permanently removes an extension from the main Vem 
*            memory handle. 
*
* Input:    hVemMemHandle -- main Vem memory handle
*           extensionKey -- key to locate extension          
*
* Output:   extensionKey -- updated extension key
*
* Globals:  none
*
* Return:   a NULL key
*******************************************************************************
*
* Implementation/Detailed Description:
*
* References:
*******************************************************************************
*
* Modifications:
*
* Comments:  If user intends to re-invoke the extension, then it whould be 
*            preferable to just temporarily disable it with vemDisableExtension().
*
* Concerns/TBD:
******************************************************************************/
void *vemUnregisterExtension(const void *hVemMemHandle, VEM_KEY extensionKey)
{
   VEM_EXTENSION     *pVemExtension    = NULL;
   VEM_ATTACH        *pVemAttach       = NULL;
   VEM_KEY            stateKey         = NULL;
   void              *pElement         = NULL;
   VEM2              *pVemMemHandler   = (VEM2 *)hVemMemHandle;
   
   if(!extensionKey)
      return NULL;

   pVemExtension=(VEM_EXTENSION *)vecGetData((void *)extensionKey);

   if(pVemExtension) {
      if(pVemExtension->pAttachVec) {

         while(0 != (pElement=vecGetFirstElement(pVemExtension->pAttachVec))) {
            pVemAttach=(VEM_ATTACH *)vecGetData(pElement);
            stateKey=(VEM_KEY)vecFindElement(pVemMemHandler->pVemStates, 
               pVemAttach->pVemState, FORWARDS);

            vemDetachExtension(stateKey, extensionKey);
         }

         vecFree(pVemExtension->pAttachVec);
         pVemExtension->pAttachVec=NULL;
      }
      /* call the extension's termination routine */
      if(pVemExtension->vemFuncFree)
         (pVemExtension->vemFuncFree)(pVemExtension->vemFuncMem, extensionKey);

      vecDelElement(pVemMemHandler->pVemExtensions, extensionKey);
      VOX_MEM_FREE(pVemExtension->pszKey);
      VOX_MEM_FREE(pVemExtension);
   }
   return NULL;
}


/******************************************************************************
*
* Function:  vemRegisterExtension()
*
* Action:    Register the extension with the main Vem memory handle. It's enabled
*            by default and the key that is returned is need in order to attach
*            it to a state.
*
* Input:    hVemMemHandle -- main Vem memory handle
*           pszKey -- state's string identifier
*           pVemFunc -- extension's function
*           pVemFuncFree -- extension's free function
*           pVemFuncMem -- void pointer to extension's memory block
*           
* Output:   none
*
* Globals:  none
*
* Return:   key to locate extension
*******************************************************************************
*
* Implementation/Detailed Description:
*
* References:
*******************************************************************************
*
* Modifications:
*
* Comments:  
*
* Concerns/TBD:
******************************************************************************/
VEM_KEY vemRegisterExtension(const void *hVemMemHandle, const char *pszKey, 
                             VEM_FUNC *pVemFunc, VEM_FUNC *pVemFuncFree, 
                             void *pVemFuncMem)
{
   VEM_EXTENSION     *pVemExtension    = NULL;
   VEM_KEY           *pKey             = NULL;
   VEM2              *pVemMemHandler   = (VEM2 *)hVemMemHandle;

   if(VOX_MEM_INIT(pVemExtension,1,sizeof(VEM_EXTENSION)))
       return NULL;
   else {
      pVemExtension->pszKey=NULL;
      pVemExtension->vemFunc=pVemFunc;
      pVemExtension->vemFuncFree=pVemFuncFree;
      pVemExtension->vemFuncMem=pVemFuncMem;
      pVemExtension->pAttachVec=NULL;
      pVemExtension->enable=ENABLED;
   }

   if(!(pKey=vecAddElement(pVemMemHandler->pVemExtensions, pVemExtension, FORWARDS))) {
      VOX_MEM_FREE(pVemExtension);
      return NULL;
   }

   /* initialize the string key */
   if(VOX_MEM_INIT(pVemExtension->pszKey,strlen(pszKey)+1,sizeof(char))) 
      return(vemUnregisterExtension(hVemMemHandle, pKey));
   else
      strcpy(pVemExtension->pszKey,pszKey);

   /* initialize the extension's state vector */
   if(!(pVemExtension->pAttachVec=vecInit())) 
      return(vemUnregisterExtension(hVemMemHandle, pKey));

   /* initialize and store the vector key */
   return(pKey);
}


/******************************************************************************
*
* Function:  vemDisableExtension()
*
* Action:   This function will temporarily disable the extension. It will still
*           be registered with the Vem memory handle.
*
* Input:    extensionKey -- key to locate extension
*           
* Output:   extensionKey -- key with the enable flag turned off
*
* Globals:  none
*
* Return:   0: succeed
*           1: failed
*******************************************************************************
*
* Implementation/Detailed Description:
*
* References:
*******************************************************************************
*
* Modifications:
*
* Comments:  
*
* Concerns/TBD:
******************************************************************************/

unsigned short vemDisableExtension(VEM_KEY extensionKey)
{
   VEM_EXTENSION *pVemExtension=(VEM_EXTENSION *)vecGetData((void *)extensionKey);

   if(!pVemExtension)
      return 1;
   else
      pVemExtension->enable=DISABLED;

   return 0;
}

/******************************************************************************
*
* Function:  vemEnalbeExtension()
*
* Action:   If the extension was disabled, the extension can be enable again by
*           calling this function
*
* Input:    extensionKey -- key to locate extension
*           
* Output:   extensionKey -- Key with the enable flag turned on
*
* Globals:  none
*
* Return:   0: succeed
*           1: failed
*******************************************************************************
*
* Implementation/Detailed Description:
*
* References:
*******************************************************************************
*
* Modifications:
*
* Comments:  
*
* Concerns/TBD:
******************************************************************************/

unsigned short vemEnableExtension(VEM_KEY extensionKey)
{
   VEM_EXTENSION *pVemExtension=(VEM_EXTENSION *)vecGetData((void *)extensionKey);

   if(!pVemExtension)
      return 1;
   else
      pVemExtension->enable=ENABLED;

   return 0;
}

/******************************************************************************
*
* Function:  vemGetExtension()
*
* Action:    If the extensions is not known, then this function can be called 
*            to retrieve it.
*
* Input:    hVemMemHandle -- main Vem memory handle
*           pszKey -- state's string identifier
*           
* Output:   none
*
* Globals:  none
*
* Return:   key to locate extension
*******************************************************************************
*
* Implementation/Detailed Description:
*
* References:
*******************************************************************************
*
* Modifications:
*
* Comments:  This function is costly and should only be called when absolutely
*            neccesary, preferably during a non-time critical segment of the 
*            program.
*
* Concerns/TBD:
******************************************************************************/
VEM_KEY vemGetExtension(const void *hVemMemHandle, const char *pszKey)
{
   void              *pVemElement      = NULL;
   VEM2              *pVemMemHandler   = (VEM2 *)hVemMemHandle;

   assert(hVemMemHandle != NULL);

   pVemElement = vecGetFirstElement(pVemMemHandler->pVemExtensions);
   while(pVemElement) {
      if(!strcmp(pszKey, ((VEM_EXTENSION *)vecGetData(pVemElement))->pszKey))
         break; /* match! */
      pVemElement=vecGetNextElement(pVemElement, FORWARDS);
   }
   return pVemElement; /* could be null if it wasn't found */
}


/******************************************************************************
*
* Function:  vemAttachExtension()
*
* Action:    Attach the state with the extension
*
* Input:    stateKey -- key to locate state
*           extensionKey -- key to locate extension
*           priority -- priority level of attachment
*
* Output:   stateKey -- updated state key
*           extensionKey -- updated extension Key
*
* Globals:  none
*
* Return:   0: succeed
*           1: failed
*******************************************************************************
*
* Implementation/Detailed Description:
*
* References:
*******************************************************************************
*
* Modifications:
*
* Comments: 
*
* Concerns/TBD:
******************************************************************************/
unsigned short vemAttachExtension(VEM_KEY stateKey, VEM_KEY extensionKey,
                                  const unsigned short priority)
{
   VEM_STATE         *pVemState        = NULL;
   VEM_EXTENSION     *pVemExtension    = NULL;
   VEM_ATTACH        *pVemAttach       = NULL;
   VEM_ATTACH        *pVemAttachSeek   = NULL;

   pVemState=(VEM_STATE *)vecGetData((void*)stateKey);
   pVemExtension=(VEM_EXTENSION *)vecGetData((void*)extensionKey);

   if(VOX_MEM_INIT(pVemAttach,1,sizeof(VEM_ATTACH)))
      return 1;
   else {
      pVemAttach->priority=priority;
      pVemAttach->pVemExtension=pVemExtension;
      pVemAttach->pVemState=pVemState;
   }

   /* adding the state to the extension's list */
   pVemAttachSeek=vecGetFirstElement(pVemExtension->pAttachVec);
      
   while(pVemAttachSeek) {
      if(((VEM_ATTACH *)vecGetData(pVemAttachSeek))->priority<priority) {
         pVemAttachSeek=vecAddElementAt(pVemExtension->pAttachVec, pVemAttachSeek, 
            pVemAttach, BACKWARDS);
         break;
      }
      pVemAttachSeek=vecGetNextElement(pVemAttachSeek, FORWARDS);
   }
   if(!pVemAttachSeek)
      if(!vecAddElement(pVemExtension->pAttachVec, pVemAttach, FORWARDS))
         return 1;

   /* adding the extension to the state's list */
   pVemAttachSeek=vecGetFirstElement(pVemState->pAttachVec);
      
   while(pVemAttachSeek) {
      if(((VEM_ATTACH *)vecGetData(pVemAttachSeek))->priority<priority) {
         pVemAttachSeek=vecAddElementAt(pVemState->pAttachVec, pVemAttachSeek, 
            pVemAttach, BACKWARDS);
         break;
      }
      pVemAttachSeek=vecGetNextElement(pVemAttachSeek, FORWARDS);
   }

   /* either the list was empty or the priorities were too high.. insert at end */
   if(!pVemAttachSeek)
      if(!vecAddElement(pVemState->pAttachVec, pVemAttach, FORWARDS))
         return 1;

      return 0;
}


/******************************************************************************
*
* Function:  vemDetachExtension()
*
* Action:    Detach the state from the extension
*
* Input:    stateKey -- key to locate state
*           extensionKey -- key to locate extension
*
* Output:   stateKey -- updated state key
*           extensionKey -- updated extension key
*
* Globals:  none
*
* Return:   0: succeed
*           1: failed
*******************************************************************************
*
* Implementation/Detailed Description:
*
* References:
*******************************************************************************
*
* Modifications:
*
* Comments: 
*
* Concerns/TBD:
******************************************************************************/
unsigned short vemDetachExtension(VEM_KEY stateKey, VEM_KEY extensionKey)
{
   VEM_STATE         *pVemState        = NULL;
   VEM_EXTENSION     *pVemExtension    = NULL;
   VEM_ATTACH        *pVemAttach       = NULL;
   void              *pElement         = NULL;

   pVemState=(VEM_STATE *)vecGetData((void*)stateKey);
   pVemExtension=(VEM_EXTENSION *)vecGetData((void*)extensionKey);

   /* detaching state from extension */
   pElement=vecGetFirstElement(pVemExtension->pAttachVec);
   while(pElement) {
      pVemAttach=(VEM_ATTACH *)vecGetData(pElement);
      if(pVemAttach->pVemState==pVemState) {
         vecDelElement(pVemExtension->pAttachVec, pElement);
         if(0 != (pElement=vecFindElement(pVemState->pAttachVec, pVemAttach, FORWARDS)))
            vecDelElement(pVemState->pAttachVec,pElement);
         break;
      }
      pElement=vecGetNextElement(pElement, FORWARDS);
   }

   if(!pElement)
      return 1; /* couldn't find it */

   VOX_MEM_FREE(pVemAttach);
   
   return 0;
}


/******************************************************************************
*
* Function:  vemGetExtensionFunc()
*
* Action:   Retrieve the extension function
*
* Input:    extensionKey -- key to locate eaxtension
*           
* Output:   none
*
* Globals:  none
*
* Return:   pointer to extension's callback function
*******************************************************************************
*
* Implementation/Detailed Description:
*
* References:
*******************************************************************************
*
* Modifications:
*
* Comments:  
*
* Concerns/TBD:
******************************************************************************/

VEM_FUNC *vemGetExtensionFunc(const VEM_KEY extensionKey)
{
   VEM_EXTENSION *pVemExtension=(VEM_EXTENSION *)vecGetData((void *)extensionKey);

   return((pVemExtension)?pVemExtension->vemFunc:NULL);
}


/******************************************************************************
*
* Function:  vemSetExtensionFunc()
*
* Action:   Set the extension's callback function
*
* Input:    extensionKey -- key to locate extension
*           vemFunc -- pointer to extension's callback function
*           
* Output:   extensionKey -- updated extension key
*
* Globals:  none
*
* Return:   0: succeed
*           1: failed
*******************************************************************************
*
* Implementation/Detailed Description:
*
* References:
*******************************************************************************
*
* Modifications:
*
* Comments:  
*
* Concerns/TBD:
******************************************************************************/
unsigned short vemSetExtensionFunc(VEM_KEY extensionKey,
                                   VEM_FUNC *vemFunc) 
{
   VEM_EXTENSION *pVemExtension=(VEM_EXTENSION *)vecGetData((void *)extensionKey);

   if(pVemExtension) {
      pVemExtension->vemFunc=vemFunc;
      return 0;
   } else
      return 1;
}

/******************************************************************************
*
* Function:  vemGetExtensionData()
*
* Action:   Return the extension's memory
*
* Input:    extensionKey -- key to locate eaxtension
*           
* Output:   none
*
* Globals:  none
*
* Return:   pointer to extension's memory block
*******************************************************************************
*
* Implementation/Detailed Description:
*
* References:
*******************************************************************************
*
* Modifications:
*
* Comments:  
*
* Concerns/TBD:
******************************************************************************/
void *vemGetExtensionData(const VEM_KEY extensionKey)
{
   VEM_EXTENSION *pVemExtension=(VEM_EXTENSION *)vecGetData((void *)extensionKey);

   return((pVemExtension)?pVemExtension->vemFuncMem:NULL);
}


/******************************************************************************
*
* Function:  vemSetExtensionData()
*
* Action:   Set the extension's memory
*
* Input:    extensionKey -- key to locate extension
*           vemFuncMem -- pointer to extension's memory block
*           
* Output:   extensionKey -- updated extension key
*
* Globals:  none
*
* Return:   0: succeed 
*           1: failed
*******************************************************************************
*
* Implementation/Detailed Description:
*
* References:
*******************************************************************************
*
* Modifications:
*
* Comments:  
*
* Concerns/TBD:
******************************************************************************/
unsigned short vemSetExtensionData(VEM_KEY extensionKey, void *vemFuncMem) 
{
   VEM_EXTENSION *pVemExtension=(VEM_EXTENSION *)vecGetData((void *)extensionKey);

   if(pVemExtension) {
      pVemExtension->vemFuncMem=vemFuncMem;
      return 0;
   } else
      return 1;
}


/******************************************************************************
*
* Function:  vemFree()
*
* Action:    Destroys the current instance of Vem.
*
* Input:    hVemMainHandle -- Vem handler
*
* Output:   hVemMainHandle -- NULL pointer
*
* Globals:   none
*
* Return:    NULL pointer
*******************************************************************************
*
* Implementation/Detailed Description:
*
* References:
*******************************************************************************
*
* Modifications:
*
* Comments:  
*
* Concerns/TBD:
******************************************************************************/
void *vemFree(void *hVemMainHandle)
{
   VEM_KEY            pElement         = NULL;
   VEM_MAIN_STRUCT   *pVemMainStruct   = NULL;
   VEM2              *pVemMemHandler   = NULL;

   if(hVemMainHandle)
      pVemMainStruct   = (VEM_MAIN_STRUCT *)hVemMainHandle;
   pVemMemHandler = pVemMainStruct->pMemoryHandler;

   if(0 != (pVemMemHandler=pVemMainStruct->pMemoryHandler)) {
      if(pVemMemHandler->pVemStates) {
         while(0 != (pElement=(VEM_KEY)vecGetFirstElement(pVemMemHandler->pVemStates))) 
            vemUnregisterState(pVemMemHandler, pElement);
         vecFree(pVemMemHandler->pVemStates);
         pVemMemHandler->pVemStates=NULL;
      }
      if(pVemMemHandler->pVemExtensions) {
         while(0 != (pElement=vecGetFirstElement(pVemMemHandler->pVemExtensions))) 
            vemUnregisterExtension(pVemMemHandler, pElement);
         vecFree(pVemMemHandler->pVemExtensions);
         pVemMemHandler->pVemExtensions=NULL;
      }
      if(pVemMemHandler->pVemParameters) {
         while(0 != (pElement=vecGetFirstElement(pVemMemHandler->pVemParameters)))
            vemUnregisterParameter(pVemMemHandler, pElement);
         vecFree(pVemMemHandler->pVemParameters);
         pVemMemHandler->pVemParameters=NULL;
      }
      if(pVemMemHandler->pFunctions)
         vecFree(pVemMemHandler->pFunctions);
      pVemMemHandler->pFunctions=NULL;

      VOX_MEM_FREE(pVemMainStruct->pMemoryHandler);
   }

   VOX_MEM_FREE(pVemMainStruct->pVemMethodStruct);

   VOX_MEM_FREE(hVemMainHandle);

   return hVemMainHandle;
}


/******************************************************************************
*
* Function:  vemInit()
*
* Action:    Initilaize Vem memory and extensions. It passes back it's memory
*            handle back to the user which should be checked for a NULL value
*            in case of insufficient memory.
*
* Input:    none
*
* Output:   none
*
* Globals:   none
*
* Return:    Vem memory handler
*******************************************************************************
*
* Implementation/Detailed Description:
*
* References:
*******************************************************************************
*
* Modifications:
*
* Comments:  
*
* Concerns/TBD:
******************************************************************************/

void *vemInit()
{
   VEM_MAIN_STRUCT   *pVemMainStruct   = NULL;
   VEM2              *pMemoryHandler   = NULL;
   VEM_METHOD_STRUCT *pVemMethodStruct = NULL;

   if(VOX_MEM_INIT(pVemMainStruct,1,sizeof(VEM_MAIN_STRUCT)))
      return(vemFree(pVemMainStruct));

   if(VOX_MEM_INIT(pMemoryHandler = pVemMainStruct->pMemoryHandler,1,sizeof(VEM2)))
      return(vemFree(pVemMainStruct));
   else {
      if(!(pMemoryHandler->pVemStates=vecInit())) 
         return(vemFree(pVemMainStruct));

      if(!(pMemoryHandler->pVemExtensions=vecInit())) 
         return(vemFree(pVemMainStruct));

      if(!(pMemoryHandler->pVemParameters=vecInit())) 
         return(vemFree(pVemMainStruct));

      if(!(pMemoryHandler->pFunctions=vecInit())) 
         return(vemFree(pVemMainStruct));
   }
      

   if(VOX_MEM_INIT(pVemMethodStruct = pVemMainStruct->pVemMethodStruct,1,
      sizeof(VEM_METHOD_STRUCT))) 
      return(vemFree(pVemMainStruct));

   /* Put in the callbacks for the extrinsic interface */

   /******* Extensions *******/
   pVemMethodStruct->lpfnVemUnregisterState     = vemUnregisterState;
   pVemMethodStruct->lpfnVemRegisterState       = vemRegisterState;
   pVemMethodStruct->lpfnVemServiceState        = vemServiceState;
   pVemMethodStruct->lpfnVemDisableState        = vemDisableState;
   pVemMethodStruct->lpfnVemEnableState         = vemEnableState;
   pVemMethodStruct->lpfnVemGetState            = vemGetState;

   pVemMethodStruct->lpfnVemShowStates          = vemShowStates;

   /******* Extensions *******/
   pVemMethodStruct->lpfnVemUnregisterExtension = vemUnregisterExtension;
   pVemMethodStruct->lpfnVemRegisterExtension   = vemRegisterExtension;
   pVemMethodStruct->lpfnVemGetExtension        = vemGetExtension;
   pVemMethodStruct->lpfnVemDisableExtension    = vemDisableExtension;
   pVemMethodStruct->lpfnVemEnableExtension     = vemEnableExtension;
   pVemMethodStruct->lpfnVemAttachExtension     = vemAttachExtension;
   pVemMethodStruct->lpfnVemDetachExtension     = vemDetachExtension;
   pVemMethodStruct->lpfnVemGetExtensionFunc    = vemGetExtensionFunc;
   pVemMethodStruct->lpfnVemSetExtensionFunc    = vemSetExtensionFunc;
   pVemMethodStruct->lpfnVemGetExtensionData    = vemGetExtensionData;
   pVemMethodStruct->lpfnVemSetExtensionData    = vemSetExtensionData;
   pVemMethodStruct->lpfnVemShowExtensions      = vemShowExtensions;

   /******* Parameters *******/
   pVemMethodStruct->lpfnVemUnregisterParameter = vemUnregisterParameter;
   pVemMethodStruct->lpfnVemRegisterArray       = vemRegisterArray;
   pVemMethodStruct->lpfnVemRegisterTable       = vemRegisterTable;
   pVemMethodStruct->lpfnVemRegisterVariable    = vemRegisterVariable;
   pVemMethodStruct->lpfnVemRegisterStruct      = vemRegisterStruct;
   pVemMethodStruct->lpfnVemRegisterConstFloat  = vemRegisterConstFloat;
   pVemMethodStruct->lpfnVemRegisterConstShort  = vemRegisterConstShort;
   pVemMethodStruct->lpfnVemGetParameter        = vemGetParameter;
   pVemMethodStruct->lpfnVemGetParameterData    = vemGetParameterData;
   pVemMethodStruct->lpfnVemSetParameterData    = vemSetParameterData;
   pVemMethodStruct->lpfnVemShowParameters      = vemShowParameters;
      
   return((void *)pVemMainStruct);
}

/**************
** Diagnostics
**************/
#if VEM_TRACE==1

#include <stdio.h>

/******************************************************************************
*
* Function:  vemShowStates()
*
* Action:    Print out a list of all states currently registered under the current
*            Vem memory handle. Every state that has one or more extensions attached
*            will also be listed.
*
* Input:    hVemMemHandle -- main Vem memory handle
*
* Output:   print the messages on stdout
*
* Globals:  none
*
* Return:   none
*******************************************************************************
*
* Implementation/Detailed Description:
*
* References:
*******************************************************************************
*
* Modifications:
*
* Comments:  
*
* Concerns/TBD:
******************************************************************************/

void vemShowStates(const void *hVemMemHandle) 
{
   VEM_STATE         *pVemState        = NULL;
   VEM_ATTACH        *pVemAttach       = NULL;
   void              *pVemElement      = NULL, *pVemElement2 = NULL;
   VEM2              *pVemMemHandler   = (VEM2 *)hVemMemHandle;

   pVemElement = vecGetFirstElement(pVemMemHandler->pVemStates);
   if(pVemElement)
      printf("\n\nStates registered: ");
   else
      printf("\nNo states registered ");
   while(pVemElement) {
      pVemState=(VEM_STATE *)vecGetData(pVemElement);
      printf("\n   \"%s\"", pVemState->pszKey);
      printf("\n      Status: %s", (pVemState->enable)?"enabled":"disabled");
      printf("\n      Attached Extensions: ");
      pVemElement2=vecGetFirstElement(pVemState->pAttachVec);
      while(pVemElement2) {
         pVemAttach=(VEM_ATTACH *)vecGetData(pVemElement2);
         printf("\n         \"%s\"", (pVemAttach->pVemExtension)->pszKey);
         pVemElement2=vecGetNextElement(pVemElement2, FORWARDS);
      }
      pVemElement=vecGetNextElement(pVemElement, FORWARDS);
   }
   return;
} 


/******************************************************************************
*
* Function:  vemShowExtensions()
*
* Action:    Show all extensions and every extension's states attachment
*
* Input:    hVemMemHandle -- main Vem memory handle
*
* Output:   print the messages on stdout
*
* Globals:  none
*
* Return:   none
*******************************************************************************
*
* Implementation/Detailed Description:
*
* References:
*******************************************************************************
*
* Modifications:
*
* Comments:  
*
* Concerns/TBD:
******************************************************************************/

void vemShowExtensions(const void *hVemMemHandle) 
{
   VEM_EXTENSION     *pVemExtension    = NULL;
   VEM_ATTACH        *pVemAttach       = NULL;
   void              *pVemElement      = NULL, *pVemElement2 = NULL;
   VEM2              *pVemMemHandler   = (VEM2 *)hVemMemHandle;

   pVemElement = vecGetFirstElement(pVemMemHandler->pVemExtensions);
   if(pVemElement)
      printf("\n\nExtensions registered: ");
   else
      printf("\nNo extensions registered ");
   while(pVemElement) {
      pVemExtension=(VEM_EXTENSION *)vecGetData(pVemElement);
      printf("\n   \"%s\"", pVemExtension->pszKey);
      printf("\n      Status:          %s", (pVemExtension->enable)?"enabled":"disabled");
      printf("\n      Function:        0x%X",
             (unsigned int) pVemExtension->vemFunc);
      printf("\n      Function memory: 0x%X",
             (unsigned int) pVemExtension->vemFuncMem);
      printf("\n      Attached states: ");
      pVemElement2=vecGetFirstElement(pVemExtension->pAttachVec);
      while(pVemElement2) {
         pVemAttach=(VEM_ATTACH *)vecGetData(pVemElement2);
         printf("\n         \"%s\"", (pVemAttach->pVemState)->pszKey);
         pVemElement2=vecGetNextElement(pVemElement2, FORWARDS);
      }
      pVemElement=vecGetNextElement(pVemElement, FORWARDS);
   }
   return;   
}

#else /* VEM_TRACE */

/* if VEM_TRACE is off, there will be warnings for unreferenced paramenters. 
   Please ignore them */
void vemShowStates(const void *hVemMemHandle) {return;}
void vemShowExtensions(const void *hVemMemHandle) {return;}

#endif /* VEM_TRACE */

#endif /* VEM_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\voxware\vector.h ===
/******************************************************************************
*                        Voxware Proprietary Material
*                        Copyright 1996, Voxware, Inc
*                            All Rights Reserved
*
*                       DISTRIBUTION PROHIBITED without
*                      written authorization from Voxware
******************************************************************************/

/******************************************************************************
* Filename:        vector.h
*
* Purpose:  Vector is meant to be an abstract approach to doubly linked list..
*           In it's raw form it may not have many applications due to the fact
*           that it doesn't support indexing.. But the user can easily extend on
*           this base to accomplish the indexing that they require. 
*
* Functions:   
*
* Author/Date:     Ilan Berci
*******************************************************************************
*
* Modifications:
*
* Comments:
*
* Concerns:
*
* $Header:   G:/r_and_d/archives/common/utils/vector.h_v   1.2   11 Mar 1998 13:53:08   weiwang  $
******************************************************************************/

#ifndef __VECTOR
#define __VECTOR

typedef enum tagDIRECTION {BACKWARDS, FORWARDS} DIRECTION;

/* functions for initiating and freeing the vector */
/******************************************************************************
*
* Function:  vecInit()
*
* Action:    Initialize a vector structure
*
* Input:    none
*
* Output:   none
*
* Globals:  none
*
* Return:   pointer to the Vectore structure
*******************************************************************************/
void *vecInit(void);

/******************************************************************************
*
* Function:  vecFree()
*
* Action:    Free the memory of a Vector structure
*
* Input:    pvVector -- pointer to vector structure
*
* Output:   pvVector -- NULL pointer
*
* Globals:  none
*
* Return:   none
*******************************************************************************/
void vecFree(void *pvVector);


/* functions for inserting and removing elements */

/******************************************************************************
*
* Function:  vecAddElementAt()
*
* Action:    connect a new element to an existing element
*
* Input:    pvVector -- pointer to vector structure
*           pvElement -- pointer to element
*           pMem -- memory for insertion
*           direction -- FORWARDS or BACKWARDS
*
* Output:   none
*
* Globals:  none
*
* Return:   pointer for insertion
*******************************************************************************/
void *vecAddElementAt(void *pvVector, void *pvElement, void *pMem, DIRECTION direction);
/******************************************************************************
*
* Function:  vecAddElement()
*
* Action:    Add a new element at either the tail or the head of a Vector
*
* Input:    pvVector -- pointer to vector structure
*           pMem -- memory for insertion
*           direction -- FORWARDS or BACKWARDS
*
* Output:   none
*
* Globals:  none
*
* Return:   pointer for insertion
*******************************************************************************/
void *vecAddElement(void *pvVector, void *pMem, DIRECTION direction);

/******************************************************************************
*
* Function:  vecDelElement()
*
* Action:    remove a element from vector link
*
* Input:    pvVector -- pointer to vector structure
*           pvElement -- pointer to vector element
*
* Output:   pvVector -- updated link
*           pvElement -- NULL pointer
*
* Globals:  none
*
* Return:   none
*******************************************************************************/
void vecDelElement(void *pvVector, void *pvElement); 
/******************************************************************************
*
* Function:  vecRemoveAllElements()
*
* Action:    remove all elements from vector link
*
* Input:    pvVector -- pointer to vector structure
*
* Output:   pvVector -- updated link with no element
*
* Globals:  none
*
* Return:   none
*******************************************************************************
*
* Implementation/Detailed Description:
*
* References:
*******************************************************************************/
void vecRemoveAllElements(void *pvVector);




/* functions for finding elements */
/******************************************************************************
*
* Function:  vecFindElementFrom()
*
* Action:    find the element with the same content as user provided
*
* Input:    pvElement -- pointer to vector element
*           pMem -- pointer to the memory user wants to compare with 
*           director -- BACKWARDS or FORWARDS for searching
*
* Output:   none
*
* Globals:  none
*
* Return:   pointer to vector element with match the content user provided
*******************************************************************************/
void *vecFindElementFrom(void *pvElement, void *pMem, DIRECTION direction);

/******************************************************************************
*
* Function:  vecFindElement()
*
* Action:   search an element from vector link
*
* Input:    pvVector -- pointer to vector 
*           pMem -- pointer to the memory user wants to compare with 
*           director -- BACKWARDS or FORWARDS for searching
*
* Output:   none
*
* Globals:  none
*
* Return:   pointer to vector element with match the content user provided
*******************************************************************************/
void *vecFindElement(void *pvVector, void *pMem, DIRECTION direction);

/******************************************************************************
*
* Function:  vecGetNextElement()
*

* Action:   Get the next element 
*
* Input:    pvElement -- pointer to vector element
*           director -- BACKWARDS or FORWARDS for searching
*
* Output:   none
*
* Globals:  none
*
* Return:   pointer to the next vector element 
*******************************************************************************/
void *vecGetNextElement(void *pvElement, DIRECTION direction);

/******************************************************************************
*
* Function:  vecGetFirstElement()
*
* Action:   Get the first vector element from the vector link
*
* Input:    pvVector -- pointer to a vector structure
*
* Output:   none
*
* Globals:  none
*
* Return:   pointer to the first vector element
*******************************************************************************/
void *vecGetFirstElement(void *pvVector);

/******************************************************************************
*
* Function:  vecGetLastElement()
*
* Action:   Get the last vector element from the vector link
*
* Input:    pvVector -- pointer to a vector structure
*
* Output:   none
*
* Globals:  none
*
* Return:   pointer to the last vector element
*******************************************************************************/
void *vecGetLastElement(void *pvVector);



/* functions for modifying element data */

/******************************************************************************
*
* Function:  vecGetData()
*
* Action:   Get the data contents from an element
*
* Input:    pvElement -- pointer to vector element
*
* Output:   none
*
* Globals:  none
*
* Return:   pointer to the data content
*******************************************************************************/
void *vecGetData(void *pvElement);

/******************************************************************************
*
* Function:  vecSetData()
*
* Action:   Set the data contents to a vector element
*
* Input:    pvElement -- pointer to vector element
*           pMem -- data contents
*
* Output:   none
*
* Globals:  none
*
* Return:   pointer to the updated vector element
*******************************************************************************/
void vecSetData(void *pvElement, void *pMem);


#endif /* __VECTOR */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\voxware\vcodecid.h ===
/*******************************************************************************
*                        Voxware Proprietary Material                          *
*                        Copyright 1998, Voxware, Inc                          *
*                            All Rights Reserved                               *
*                                                                              *
*                       DISTRIBUTION PROHIBITED without                        *
*                      written authorization from Voxware                      *
*******************************************************************************/

/*******************************************************************************
* Filename:       vCodecID.h      (Voxware codec IDs)                                                        
*                                 
* Dependencies:                                          
* 
* $Header:   P:/r_and_d/archives/common/vci/vCodecID.h_v   1.8   17 Nov 1998 09:35:56   epiphanyv  $
*
*******************************************************************************/

#ifndef _VCODECID_H_
#define _VCODECID_H_


/***************************/
/**    Codec Class IDs    **/
/************************************************/
/*  Each codec class must have a unique ID      */
/*  number which is communicated to the VCT     */
/*  and used to identify a particular bitstream */
/*  If the bitstream changes, the "new" codec   */
/*  must get a new class ID.  The old codec     */
/*  will not change.                            */
/************************************************/
/* !!!! CODEC CLASS ID'S CAN NEVER CHANGE !!!!  */
/************************************************/


/* Low Memory Embedded Codecs */
#define VOXWARE_CODEC_LME_16               0x07000001L  /* LME16            16khz */
#define VOXWARE_CODEC_LME_24               0x07000002L  /* LME24            16khz */
#define VOXWARE_CODEC_LME_32               0x07000004L  /* LME32            16khz */


/* Wideband Codecs */
/* HF64 */
#define VOXWARE_CODEC_HF_64                 0x06000001L  /* HF64            16khz */

/* Low Complexity Codecs */
/* LC34 */
#define VOXWARE_CODEC_LC_34                 0x05000001L  /* LC34             8khz */

#define VOXWARE_CODEC_LC_16                 0x05000002L  /* LC16             8khz */
#define VOXWARE_CODEC_LC_24                 0x05000004L  /* LC24            11khz */
#define VOXWARE_CODEC_LC_32                 0x05000008L  /* LC32            16khz */

/* RT24 */
#define VOXWARE_CODEC_RT_8K                 0x01000001L  /* RT24     2,400       8khz */

/* RT29 Bitstream Compatible */
#define VOXWARE_CODEC_RT_8K_HQ29            0x01000010L  /* RT29     2,977       8khz */

/* RT28   (was RT29 Plus) */
#define VOXWARE_CODEC_RT_8K_28              0x01000011L  /* RT28     2.8kbps     8khz    VoxChat */

/* RT24 HQ */
#define VOXWARE_CODEC_RT_8K_HQ24            0x01000004L  /* RT24HQ   not released with VDK */

/* RT - Variable Rate codecs */
#define VOXWARE_CODEC_RT_8K_VR12            0x01000012L  /* VR12     not released with VDK */
#define VOXWARE_CODEC_RT_8K_VR15            0x01000013L  /* VR15     not released with VDK */

/* ULC15 -- Variable Rate codecs */
#define VOXWARE_CODEC_RT_8K_ULC15           0x01000014L  /* ULC15    not released with VDK */


/* RT24 UQ */
#define VOXWARE_CODEC_RT_8K_UQ              0x0100000CL  /* RT24UQ   not released with VDK */

/* Audio Codecs v1.0  (shipped with VDK v1.1.8) */
#define VOXWARE_CODEC_AC_8K                 0x08000001L  /* AC8       8,000 bps  8kHz v1.0 bitstream */
#define VOXWARE_CODEC_AC_11K                0x08000002L  /* AC8       8,000 bps  8kHz v1.0 bitstream */
#define VOXWARE_CODEC_AC_16K                0x08000003L  /* AC8       8,000 bps  8kHz v1.0 bitstream */
#define VOXWARE_CODEC_AC_22K                0x08000004L  /* AC8       8,000 bps  8kHz v1.0 bitstream */

/* Audio Codecs v2.0 (shipped with VCT v1.5.0) */
#define VOXWARE_CODEC_AC_8K_V2              0x02000001L  /* AC8       8,000 bps  8kHz  v2.0 bitstream */
#define VOXWARE_CODEC_AC_11K_V2             0x02000002L  /* AC11     10,000 bps  11kHz v2.0 bitstream */
#define VOXWARE_CODEC_AC_16K_V2             0x02000003L  /* AC16     16,000 bps  16kHz v2.0 bitstream */
#define VOXWARE_CODEC_AC_22K_V2             0x02000004L  /* AC22     24,000 bps  22kHz v2.0 bitstream */
#define VOXWARE_CODEC_AC_32K_V2             0x02000005L  /* AC22     24,000 bps  22kHz v2.0 bitstream */
#define VOXWARE_CODEC_AC_40K_V2             0x02000006L  /* AC22     24,000 bps  22kHz v2.0 bitstream */
#define VOXWARE_CODEC_AC_48K_V2             0x02000007L  /* AC22     24,000 bps  22kHz v2.0 bitstream */

/* Audio Codecs Stereo (shipped with VCT v1.5.0) */
#define VOXWARE_CODEC_AC_8K_STEREO          0x04000001L  /* AC8       8,000 bps  8kHz    Stereo */
#define VOXWARE_CODEC_AC_11K_STEREO         0x04000002L  /* AC11     10,000 bps  11kHz   Stereo */
#define VOXWARE_CODEC_AC_16K_STEREO         0x04000003L  /* AC16     16,000 bps  16kHz   Stereo */
#define VOXWARE_CODEC_AC_22K_STEREO         0x04000004L  /* AC22     24,000 bps  22kHz   Stereo */
#define VOXWARE_CODEC_AC_64K_STEREO         0x04000005L  /* AC22     24,000 bps  22kHz   Stereo */
#define VOXWARE_CODEC_AC_80K_STEREO         0x04000006L  /* AC22     24,000 bps  22kHz   Stereo */
#define VOXWARE_CODEC_AC_96K_STEREO         0x04000007L  /* AC22     24,000 bps  22kHz   Stereo */


/* Scaleable Codecs */
#define VOXWARE_CODEC_SC_8K_3               0x03000003L  /* SC3       3200 bps   8kHz */
#define VOXWARE_CODEC_SC_8K_6               0x03000006L  /* SC6       6400 bps   8kHz */
#define VOXWARE_CODEC_SC_16K_10             0x03000010L  /* SC10      Not Yet Designed  16 kHz */


/*****************************/
/**    Unique Codec ID's    **/
/***************************************************/
/*  Each codec must have a unique codec ID.        */
/*  Codec ID's are different from codec class ID's */
/*  If for example you have two RT24 codecs, one   */
/*  regular and one that's MMX enhanced then       */
/*  both codecs have the same 'codec class id',    */
/*  but they must both have unique codec id's.     */
/***************************************************/
/*      !!!! CODEC ID'S CAN NEVER CHANGE !!!!      */
/***************************************************/


/* Low Memory Embedded Codecs */
#define VOXWARE_CODEC_ID_LME_16              0x07000001L  /* LME16            16khz */
#define VOXWARE_CODEC_ID_LME_24              0x07000002L  /* LME24            16khz */
#define VOXWARE_CODEC_ID_LME_32              0x07000004L  /* LME32            16khz */


/* Wideband Codecs */
/* HF64 */
#define VOXWARE_CODEC_ID_HF_64              0x06000001L  /* HF64            16khz */

/* Low Complexity Codecs */
/* LC34 */
#define VOXWARE_CODEC_ID_LC_34              0x05000002L  /* LC34            8khz */

#define VOXWARE_CODEC_ID_LC_16              0x05000004L  /* LC16            16khz */
#define VOXWARE_CODEC_ID_LC_24              0x05000008L  /* LC24            11khz */
#define VOXWARE_CODEC_ID_LC_32              0x05000010L  /* LC32             8khz */

/* RT29 HQ Bitstream Compatible */
#define VOXWARE_CODEC_ID_RT_8K_HQ29         0x01000001L  /* class = VOXWARE_CODEC_RT_8K_HQ29 */
/* RT29 HQ Bitstream Compatible Low Delay */
#define VOXWARE_CODEC_ID_RT_8K_HQ29_LD      0x01000005L  /* class = VOXWARE_CODEC_RT_8K_HQ29 */


/* RT24 */
#define VOXWARE_CODEC_ID_RT_8K_24           0x01000002L  /* class = VOXWARE_CODEC_RT_8K */
/* RT24 Low Delay */
#define VOXWARE_CODEC_ID_RT_8K_24_LD        0x01000007L  /* class = VOXWARE_CODEC_RT_8K */


/* RT28 (was RT29 Plus) */
#define VOXWARE_CODEC_ID_RT_8K_28           0x01000003L  /* class = VOXWARE_CODEC_RT_8K_28 */
/* RT28 Low Delay */
#define VOXWARE_CODEC_ID_RT_8K_28_LD        0x01000006L  /* class = VOXWARE_CODEC_RT_8K_28 */

/* VR12 */
#define VOXWARE_CODEC_ID_RT_8K_VR12         0x01000020L  /* VR12     not released with VDK */

/* VR15 */
#define VOXWARE_CODEC_ID_RT_8K_VR15         0x01000021L  /* VR15     not released with VDK */

/* ULC15 */
#define VOXWARE_CODEC_ID_RT_8K_ULC15        0x01000022L  /* ULC15    not released with VDK */


/* Audio Codecs v1.0 */
#define VOXWARE_CODEC_ID_AC_8K              0x01000008L  /* class = VOXWARE_CODEC_AC_8K  */
#define VOXWARE_CODEC_ID_AC_11K             0x01000009L  /* class = VOXWARE_CODEC_AC_11K */
#define VOXWARE_CODEC_ID_AC_16K             0x0100000AL  /* class = VOXWARE_CODEC_AC_16K */
#define VOXWARE_CODEC_ID_AC_22K             0x0100000BL  /* class = VOXWARE_CODEC_AC_22K */


/* Audio Codecs v2.0 */
#define VOXWARE_CODEC_ID_AC_8K_V2           0x02000001L  /* class = VOXWARE_CODEC_AC_8K_V2  */
#define VOXWARE_CODEC_ID_AC_11K_V2          0x02000002L  /* class = VOXWARE_CODEC_AC_11K_V2 */
#define VOXWARE_CODEC_ID_AC_16K_V2          0x02000003L  /* class = VOXWARE_CODEC_AC_16K_V2 */
#define VOXWARE_CODEC_ID_AC_22K_V2          0x02000004L  /* class = VOXWARE_CODEC_AC_22K_V2 */
#define VOXWARE_CODEC_ID_AC_32K_V2          0x02000005L  /* class = VOXWARE_CODEC_AC_22K_V2 */
#define VOXWARE_CODEC_ID_AC_40K_V2          0x02000006L  /* class = VOXWARE_CODEC_AC_22K_V2 */
#define VOXWARE_CODEC_ID_AC_48K_V2          0x02000007L  /* class = VOXWARE_CODEC_AC_22K_V2 */


/* Audio Codecs Stereo */
#define VOXWARE_CODEC_ID_AC_8K_STEREO       0x04000001L  /* class = VOXWARE_CODEC_AC_8K_STEREO  */
#define VOXWARE_CODEC_ID_AC_11K_STEREO      0x04000002L  /* class = VOXWARE_CODEC_AC_11K_STEREO */
#define VOXWARE_CODEC_ID_AC_16K_STEREO      0x04000003L  /* class = VOXWARE_CODEC_AC_16K_STEREO */
#define VOXWARE_CODEC_ID_AC_22K_STEREO      0x04000004L  /* class = VOXWARE_CODEC_AC_22K_STEREO */
#define VOXWARE_CODEC_ID_AC_64K_STEREO      0x04000005L  /* class = VOXWARE_CODEC_AC_22K_STEREO */
#define VOXWARE_CODEC_ID_AC_80K_STEREO      0x04000006L  /* class = VOXWARE_CODEC_AC_22K_STEREO */
#define VOXWARE_CODEC_ID_AC_96K_STEREO      0x04000007L  /* class = VOXWARE_CODEC_AC_22K_STEREO */

/* Scaleable Codecs */
#define VOXWARE_CODEC_ID_SC_8K_3_GENERIC    0x03010003L  /* class = VOXWARE_CODEC_SC_8K_3 */
#define VOXWARE_CODEC_ID_SC_8K_6_GENERIC    0x03010006L  /* class = VOXWARE_CODEC_SC_8K_6 */
#define VOXWARE_CODEC_ID_SC_16K_10_GENERIC  0x03010010L  /* class = VOXWARE_CODEC_SC_16K_10 */


#endif /* _VCODECID_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\voxware\vector.c ===
/******************************************************************************
*                        Voxware Proprietary Material
*                        Copyright 1996, Voxware, Inc
*                            All Rights Reserved
*
*                       DISTRIBUTION PROHIBITED without
*                      written authorization from Voxware
******************************************************************************/

/******************************************************************************
* Filename:        vector.c
*
* Purpose:  Vector is meant to be an abstract approach to doubly linked list..
*           In it's raw form it may not have many applications due to the fact
*           that it doesn't support indexing.. But the user can easily extend on
*           this base to accomplish the indexing that they require. 
*
* Functions:   
*
* Author/Date:     Ilan Berci
*******************************************************************************
*
* Modifications:
*
* Comments:
*
* Concerns:
*
* $Header:   G:/r_and_d/archives/common/utils/vector.c_v   1.3   11 Mar 1998 13:53:52   weiwang  $
******************************************************************************/
#include <stdlib.h>
#include <assert.h>

#include "VoxMem.h"

#include "vector.h"

#include "xvocver.h"

/*--------------------------------------------------
  private structure: VECTOR_ELEMENT
  --------------------------------------------------*/
typedef struct tagVECTOR_ELEMENT {
   void   *pMem;
   struct tagVECTOR_ELEMENT *pNext;
   struct tagVECTOR_ELEMENT *pLast;
} VECTOR_ELEMENT; 


/*--------------------------------------------------
  private structure: VECTOR
  --------------------------------------------------*/
typedef struct tagVECTOR {
   VECTOR_ELEMENT *pHead;
   VECTOR_ELEMENT *pTail;
} VECTOR;



/******************************************************************************
*
* Function:  vecInit()
*
* Action:    Initialize a vector structure
*
* Input:    none
*
* Output:   none
*
* Globals:  none
*
* Return:   pointer to the Vectore structure
*******************************************************************************/
void *vecInit(void)
{
   VECTOR *pVector=NULL;
   if(VOX_MEM_INIT(pVector,1,sizeof(VECTOR)))
     return NULL;
   else 
   {
      pVector->pHead=NULL;
      pVector->pTail=NULL;
      return pVector;
   } 
}

/******************************************************************************
*
* Function:  vecFree()
*
* Action:    Free the memory of a Vector structure
*
* Input:    pvVector -- pointer to vector structure
*
* Output:   pvVector -- NULL pointer
*
* Globals:  none
*
* Return:   none
*******************************************************************************/
void vecFree(void *pvVector)
{
   VOX_MEM_FREE(pvVector)
}


/******************************************************************************
*
* Function:  vecAddElementAt()
*
* Action:    connect a new element to an existing element
*
* Input:    pvVector -- pointer to vector structure
*           pvElement -- pointer to element
*           pMem -- memory for insertion
*           direction -- FORWARDS or BACKWARDS
*
* Output:   none
*
* Globals:  none
*
* Return:   pointer for insertion
*******************************************************************************
*
* Implementation/Detailed Description:
*
* References:
*******************************************************************************
*
* Modifications:
*
* Comments:
*
* Concerns/TBD:
******************************************************************************/
void *vecAddElementAt(void *pvVector, void *pvElement, void *pMem, DIRECTION direction)
{
   VECTOR *pVector=(VECTOR *)pvVector;
   VECTOR_ELEMENT *pVectorElement=(VECTOR_ELEMENT *)pvElement;
   VECTOR_ELEMENT *pPrevious=NULL, *pInsert=NULL;

   pPrevious=(direction==FORWARDS)?pVectorElement->pNext:pVectorElement->pLast;

   if(VOX_MEM_INIT(pInsert, 1,sizeof(VECTOR_ELEMENT)))
     return NULL;
   else {
      if(direction==FORWARDS) {
         pInsert->pNext=pPrevious;
         pInsert->pLast=pVectorElement;
         pVectorElement->pNext=pInsert;
      } else {
         pInsert->pNext=pVectorElement;
         pInsert->pLast=pPrevious;
         pVectorElement->pLast=pInsert;
      }

      pInsert->pMem=pMem;

      if(!(pInsert->pNext))
         pVector->pTail=pInsert;
      if(!(pInsert->pLast))
         pVector->pHead=pInsert;

      return pInsert; /* user should check for NULL; */
   }
}


/******************************************************************************
*
* Function:  vecAddElement()
*
* Action:    Add a new element at either the tail or the head of a Vector
*
* Input:    pvVector -- pointer to vector structure
*           pMem -- memory for insertion
*           direction -- FORWARDS or BACKWARDS
*
* Output:   none
*
* Globals:  none
*
* Return:   pointer for insertion
*******************************************************************************
*
* Implementation/Detailed Description:
*
* References:
*******************************************************************************
*
* Modifications:
*
* Comments:
*
* Concerns/TBD:
******************************************************************************/

void *vecAddElement(void *pvVector, void *pMem, DIRECTION direction)
{
   VECTOR *pVector=(VECTOR *)pvVector;
   VECTOR_ELEMENT *pVectorElement=NULL;

   if(!(pVector->pTail)) { 
      if(VOX_MEM_INIT(pVectorElement=pVector->pTail=pVector->pHead, 1,
         sizeof(VECTOR_ELEMENT))) 
         return NULL;
      else {
         pVectorElement->pLast=NULL;
         pVectorElement->pNext=NULL;
         pVectorElement->pMem=pMem;
      
         return (pVectorElement);
        }
   } else
      return(vecAddElementAt(pVector, (direction==FORWARDS)?pVector->pTail:pVector->pHead,
         pMem, direction));
}

/******************************************************************************
*
* Function:  vecDelElement()
*
* Action:    remove a element from vector link
*
* Input:    pvVector -- pointer to vector structure
*           pvElement -- pointer to vector element
*
* Output:   pvVector -- updated link
*           pvElement -- NULL pointer
*
* Globals:  none
*
* Return:   none
*******************************************************************************
*
* Implementation/Detailed Description:
*
* References:
*******************************************************************************
*
* Modifications:
*
* Comments:
*
* Concerns/TBD:
******************************************************************************/
void vecDelElement(void *pvVector, void *pvElement)
{
   VECTOR *pVector=(VECTOR *)pvVector;
   VECTOR_ELEMENT *pVectorElement=(VECTOR_ELEMENT *)pvElement;

   if(pVectorElement->pLast) 
      (pVectorElement->pLast)->pNext=pVectorElement->pNext;
   else
      pVector->pHead=pVectorElement->pNext;

   if(pVectorElement->pNext)
      (pVectorElement->pNext)->pLast=pVectorElement->pLast;
   else
      pVector->pTail=pVectorElement->pLast;

   pVectorElement->pMem=NULL;

   VOX_MEM_FREE(pVectorElement);

   return;
}


/******************************************************************************
*
* Function:  vecRemoveAllElements()
*
* Action:    remove all elements from vector link
*
* Input:    pvVector -- pointer to vector structure
*
* Output:   pvVector -- updated link with no element
*
* Globals:  none
*
* Return:   none
*******************************************************************************
*
* Implementation/Detailed Description:
*
* References:
*******************************************************************************
*
* Modifications:
*
* Comments:
*
* Concerns/TBD:
******************************************************************************/
void vecRemoveAllElements(void *pvVector)
{
   VECTOR *pVector=(VECTOR *)pvVector;
   VECTOR_ELEMENT *pVectorElement=pVector->pHead, *pLastElement=NULL;

   if(pVectorElement) 
      do {
         pVectorElement->pMem=NULL;;
         pLastElement=pVectorElement;
         pVectorElement=pVectorElement->pNext;
         VOX_MEM_FREE(pLastElement);
      } while(pVectorElement);

   return;
}
 

/******************************************************************************
*
* Function:  vecFindElementFrom()
*
* Action:    find the element with the same content as user provided
*
* Input:    pvElement -- pointer to vector element
*           pMem -- pointer to the memory user wants to compare with 
*           director -- BACKWARDS or FORWARDS for searching
*
* Output:   none
*
* Globals:  none
*
* Return:   pointer to vector element with match the content user provided
*******************************************************************************
*
* Implementation/Detailed Description:
*
* References:
*******************************************************************************
*
* Modifications:
*
* Comments:
*
* Concerns/TBD:
******************************************************************************/
void *vecFindElementFrom(void *pvElement, void *pMem, DIRECTION direction)
{
   VECTOR_ELEMENT *pVectorElement=(VECTOR_ELEMENT *)pvElement;
   
   while(pVectorElement->pMem!=pMem&&pVectorElement) 
      pVectorElement=(direction==FORWARDS)?pVectorElement->pNext:pVectorElement->pLast;

   return pVectorElement;
}


/******************************************************************************
*
* Function:  vecFindElement()
*
* Action:   search an element from vector link
*
* Input:    pvVector -- pointer to vector 
*           pMem -- pointer to the memory user wants to compare with 
*           director -- BACKWARDS or FORWARDS for searching
*
* Output:   none
*
* Globals:  none
*
* Return:   pointer to vector element with match the content user provided
*******************************************************************************
*
* Implementation/Detailed Description:
*
* References:
*******************************************************************************
*
* Modifications:
*
* Comments:
*
* Concerns/TBD:
******************************************************************************/
void *vecFindElement(void *pvVector, void *pMem, DIRECTION direction)
{
   return(vecFindElementFrom((direction==FORWARDS)?
      ((VECTOR *)pvVector)->pHead:((VECTOR *)pvVector)->pTail, pMem, direction));
}
 
/******************************************************************************
*
* Function:  vecGetNextElement()
*
* Action:   Get the next element 
*
* Input:    pvElement -- pointer to vector element
*           director -- BACKWARDS or FORWARDS for searching
*
* Output:   none
*
* Globals:  none
*
* Return:   pointer to the next vector element 
*******************************************************************************
*
* Implementation/Detailed Description:
*
* References:
*******************************************************************************
*
* Modifications:
*
* Comments:
*
* Concerns/TBD:
******************************************************************************/
void *vecGetNextElement(void *pvElement, DIRECTION direction)
{
   return((direction==FORWARDS)?((VECTOR_ELEMENT *)pvElement)->pNext:
      ((VECTOR_ELEMENT *)pvElement)->pLast);
}


/******************************************************************************
*
* Function:  vecGetData()
*
* Action:   Get the data contents from an element
*
* Input:    pvElement -- pointer to vector element
*
* Output:   none
*
* Globals:  none
*
* Return:   pointer to the data content
*******************************************************************************
*
* Implementation/Detailed Description:
*
* References:
*******************************************************************************
*
* Modifications:
*
* Comments:
*
* Concerns/TBD:
******************************************************************************/
void *vecGetData(void *pvElement)
{
   return(((VECTOR_ELEMENT *)pvElement)->pMem);
}


/******************************************************************************
*
* Function:  vecSetData()
*
* Action:   Set the data contents to a vector element
*
* Input:    pvElement -- pointer to vector element
*           pMem -- data contents
*
* Output:   none
*
* Globals:  none
*
* Return:   pointer to the updated vector element
*******************************************************************************
*
* Implementation/Detailed Description:
*
* References:
*******************************************************************************
*
* Modifications:
*
* Comments:
*
* Concerns/TBD:
******************************************************************************/
void vecSetData(void *pvElement, void *pMem)
{
   ((VECTOR_ELEMENT *)pvElement)->pMem=pMem;
   return;
}


/******************************************************************************
*
* Function:  vecGetFirstElement()
*
* Action:   Get the first vector element from the vector link
*
* Input:    pvVector -- pointer to a vector structure
*
* Output:   none
*
* Globals:  none
*
* Return:   pointer to the first vector element
*******************************************************************************
*
* Implementation/Detailed Description:
*
* References:
*******************************************************************************
*
* Modifications:
*
* Comments:
*
* Concerns/TBD:
******************************************************************************/
void *vecGetFirstElement(void *pvVector)
{
   return(((VECTOR *)pvVector)->pHead);
}


/******************************************************************************
*
* Function:  vecGetLastElement()
*
* Action:   Get the last vector element from the vector link
*
* Input:    pvVector -- pointer to a vector structure
*
* Output:   none
*
* Globals:  none
*
* Return:   pointer to the last vector element
*******************************************************************************
*
* Implementation/Detailed Description:
*
* References:
*******************************************************************************
*
* Modifications:
*
* Comments:
*
* Concerns/TBD:
******************************************************************************/
void *vecGetLastElement(void *pvVector)
{
   return(((VECTOR *)pvVector)->pTail);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\voxware\vemfrm12.h ===
/******************************************************************************
 *                                                                            *
 *		                  Voxware Proprietary Material                          *
 *		                  Copyright 1996, Voxware, Inc.                         *
 *		                       All Rights Resrved                               *
 *                                                                            *
 *		                 DISTRIBUTION PROHIBITED without                        *
 *		               written authorization from Voxware                       *
 *                                                                            *
 ******************************************************************************/

/******************************************************************************
 *                                                                            *
 * FILENAME:  vemFram12.h                                                      *
 * PURPOSE:   Defines the interface functions for vmFrames.c                  *
 * AURTHOR:   Epiphany Vera                                                   *
 *                                                                            *
 *****************************************************************************/

/******************************************************************************
 *                                                                            *
 *                          DETAILED REVISION HISTORY                         *
 *                                                                            *
 * (March 24, '97)                                                            *
 *    Created                                                                 *
 *                                                                            *
 *****************************************************************************/

void framesInBufferVR12(const VCI_CODEC_IO_BLOCK  *hvciCodecIOBlk,
                         unsigned short      *pwNumFrames);
void seekForwardVR12(unsigned short ReadByteOffset,
                      unsigned char  ReadBitOffset,
                      unsigned short BufferSize,
                      unsigned char  *pBuffer,
                      unsigned short wNumFrames,
                      unsigned short *pwByteOffset,
                      unsigned char  *pchBitOffset,
                      unsigned short *BitsInFrames);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\voxware\vemfrm12.c ===
/******************************************************************************
 *                                                                            *
 *                        Voxware Proprietary Material                        *
 *                        Copyright 1996, Voxware, Inc.                       *
 *                             All Rights Resrved                             *
 *                                                                            *
 *                       DISTRIBUTION PROHIBITED without                      *
 *                     written authorization from Voxware                     *
 *                                                                            *
 ******************************************************************************/

/******************************************************************************
 *                                                                            *
 * FILENAME:  vmFrames.c                                                      *
 * PURPOSE:   Functions for doing frame traversal on circular vox buffers.    *
 * AURTHOR:   Epiphany Vera                                                   *
 *                                                                            *
 * $Header:   /export/phobos/pvcs/r_and_d/archives/realtime/vem/vemFrm12.c_v   1.3   08 Jun 1998 15:37:30   bobd  $
 *****************************************************************************/

/******************************************************************************
 *                                                                            *
 *                          DETAILED REVISION HISTORY                         *
 *                                                                            *
 * (March 24, '97)                                                            *
 *    Created                                                                 *
 * (June 8, '98)                                                              *
 *    Converted ReadByteOffset to type (unsigned long) in seek routine.       *
 *      With a buffer size close to the maximum (unsigned short) the          *
 *      arithmetic could cause an incorrect wrap around in the circular       *
 *      Buffer. (Bob Dunn)                                                    *
 *                                                                            *
 *****************************************************************************/



#include "vci.h" /* Needed for the VCI_CODEC_IO_BLOCK.                        */
#include "quanvr12.h"
#include "vLibPack.h" /* BitUnpackCBuffer() */

#include "vemFrm12.h"

#include "xvocver.h"
/* ************************************************************************** */
/*                                                                            */
/* FUNCTION: framesInBufferVR12()                                             */
/* PURPOSE : Counts the number of frames in the Vox buffer of the given codec */
/*           I/O block. This function is for VR12 only.                       */
/*                                                                            */
/* ************************************************************************** */
void framesInBufferVR12(const VCI_CODEC_IO_BLOCK  *hvciCodecIOBlk,
                        unsigned short            *pwNumFrames)
{
   unsigned short  ReadByteOffset,WriteByteOffset;
   unsigned char   ReadBitOffset, WriteBitOffset;
   unsigned short  BufferSize;
   unsigned long   BitsInBuffer;
   unsigned long   BitsRead;
   unsigned short  NumBits;
   unsigned char   *pBuffer;

   ReadByteOffset  = hvciCodecIOBlk->wVoxBufferReadByteOffset;
   WriteByteOffset = hvciCodecIOBlk->wVoxBufferWriteByteOffset;
   ReadBitOffset   = hvciCodecIOBlk->chVoxBufferReadBitOffset;
   WriteBitOffset  = hvciCodecIOBlk->chVoxBufferWriteBitOffset;
   BufferSize      = hvciCodecIOBlk->wVoxBufferSize;
   pBuffer         = hvciCodecIOBlk->pVoxBuffer;
   BitsRead        = 0;
  *pwNumFrames     = 0;

   /* First we calculate the number of bits in the buffer. We split this      */
   /* into two cases. Case 1 is without wrap-around of the circular buffer    */
   /* Case 2 is with wrap-around of the circular buffer.                      */
   if(WriteByteOffset>=ReadByteOffset) /* This means we have not wraped       */
                                       /* around in the buffer.               */
   {
      BitsInBuffer = (WriteByteOffset-ReadByteOffset+1)*8;
      BitsInBuffer = BitsInBuffer-ReadBitOffset-(8-WriteBitOffset);
   }
   else /* This is the case whereby the buffer has wrapped around.            */
   {
      BitsInBuffer = (WriteByteOffset+(BufferSize-ReadByteOffset)+1)*8;
      BitsInBuffer = BitsInBuffer-ReadBitOffset-(8-WriteBitOffset);
   }

  /* Now read until we exhaust the number of bits we have in the buffer */
   while(BitsRead < BitsInBuffer)
   {
     (*pwNumFrames)++;
      seekForwardVR12(ReadByteOffset, ReadBitOffset, BufferSize, pBuffer, 1,
                      &ReadByteOffset, &ReadBitOffset, &NumBits);
      BitsRead += NumBits;
   }
   if(BitsRead>BitsInBuffer)
      (*pwNumFrames)--;
}


/* ************************************************************************** */
/*                                                                            */
/* FUNCTION: seekForwardVR12()                                                */
/* PURPOSE : Seeks to a given frame offset.                                   */
/*                                                                            */
/* ************************************************************************** */
void seekForwardVR12(unsigned short ReadByteOffset,
                      unsigned char  ReadBitOffset,
                      unsigned short BufferSize,
                      unsigned char  *pBuffer,
                      unsigned short wNumFrames,
                      unsigned short *pwByteOffset,
                      unsigned char  *pchBitOffset,
                      unsigned short *BitsInFrames)
{
   C_BUFFER_TYPE   CBuffer; 
   unsigned short  CurrentFrames;
   unsigned char   DummyRead[BYTESPERFRAME_VR]; /* the maximum bytes/frame */ 
   unsigned short  Class, wBitsInClass=0;
   unsigned long   ulReadByteOffset;

   CurrentFrames       = 0;
   *BitsInFrames       = 0;
   CBuffer.wBufferSize           = BufferSize;
   CBuffer.pBufferReadByteOffset = &ReadByteOffset;
   CBuffer.pBufferReadBitOffset  = &ReadBitOffset;
   CBuffer.pBuffer               = pBuffer;   

   while (CurrentFrames < wNumFrames)
   {
      BitUnpackCBuffer(&CBuffer, DummyRead, CLASS_BITS_VR12);
      Class = (unsigned short) DummyRead[0];
      *BitsInFrames += CLASS_BITS_VR12;

      if (Class == UV_FRAME)
         wBitsInClass=TOTAL_BITS_VR12_UNVOICED-CLASS_BITS_VR12;
      else if (Class == V_FRAME)  
         wBitsInClass=TOTAL_BITS_VR12_VOICED-CLASS_BITS_VR12;
      else if (Class == MIX_FRAME)
         wBitsInClass=TOTAL_BITS_VR12_MIXED-CLASS_BITS_VR12;
      else
         wBitsInClass=0;

      (*CBuffer.pBufferReadBitOffset)+=wBitsInClass;
      *BitsInFrames += wBitsInClass;  
      
      /*-------------------------------------------------------------
        We have to be careful here since the sum
          ulReadByteOffset + (ReadBitOffset/8) could be greater
          than the maximum (unsigned short).  We use an
          (unsigned long) to do the computation and testing.
      -------------------------------------------------------------*/
      ulReadByteOffset  = (unsigned long) (*CBuffer.pBufferReadByteOffset);
      ulReadByteOffset += (unsigned long) (ReadBitOffset/8);

      if ( ulReadByteOffset >= (unsigned long)(CBuffer.wBufferSize) )
         ulReadByteOffset -= (unsigned long) (CBuffer.wBufferSize);

      /*-------------------------------------------------------------
        After the above test we can guarantee that ulReadByteOffset
          can be represented as an (unsigned short).
      -------------------------------------------------------------*/
      (*CBuffer.pBufferReadByteOffset) = (unsigned short) ulReadByteOffset;

      (*CBuffer.pBufferReadBitOffset)%=8;

      CurrentFrames++;
   }
   *pwByteOffset = ReadByteOffset;
   *pchBitOffset = ReadBitOffset;

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\voxware\vem2prm.h ===
/******************************************************************************
*                        Voxware Proprietary Material
*                        Copyright 1996, Voxware, Inc
*                            All Rights Reserved
*
*                       DISTRIBUTION PROHIBITED without
*                      written authorization from Voxware
******************************************************************************/

/******************************************************************************
* Filename:        vem2Prm.h
*
* Purpose:  main vem file needed to locate codec parameters
*
* Functions:   vemUnRegisterParameter, ...
*
* Author/Date:     Ilan Berci
*******************************************************************************
*
* Modifications:
*
* Comments:
*
* Concerns:
*
* $Header:   /export/phobos/pvcs/r_and_d/archives/common/vem/vem2Prm.h_v   1.3   25 Mar 1998 14:23:16   weiwang  $
******************************************************************************/

#ifndef __VEM2PRM
#define __VEM2PRM

/* switch for DSP's */
#define VEM_DEFINED 1

#ifndef __VEM_KEY
#define __VEM_KEY
typedef void * VEM_KEY;
#endif /* __VEM_KEY */

#ifndef __VEM_PARAMETER_TYPE
#define __VEM_PARAMETER_TYPE
typedef enum tagPARAMETER_TYPE {
   VEM_VOID,
   VEM_CHAR,
   VEM_U_CHAR,
   VEM_SHORT,
   VEM_U_SHORT,
   VEM_INT,
   VEM_U_INT,
   VEM_LONG,
   VEM_U_LONG,
   VEM_FLOAT,
   VEM_DOUBLE
} PARAMETER_TYPE;
#endif /* __VEM_PARAMETER_TYPE */

#if(VEM_DEFINED==1)

/******************************************************************************
*
* Function:  vemUnRegisterParameter()
*
* Action:   Remove a parameter from the Vem main memory handle.
*
* Input:    hVemMemHandle -- main Vem memory handle
*           paramKey -- key to locate paramter
*
* Output:   hVemMemHandle -- updated Vem memory handle
*
* Globals:  none
*
* Return:   NULL key
*******************************************************************************/
VEM_KEY vemUnregisterParameter(void *hVemMemHandle, VEM_KEY pvVemParam);

/******************************************************************************
*
* Function:  vemRegisterArray()
*
* Action:   register arrays. Note: no constant arrays can be registered with 
*           this function.
*
* Input:    hVemMemHandle -- main Vem memory handle
*           pData -- pointer to array element
*           dataType -- parameter type
*           dataSize -- size of array
*           pszKey -- unique parameter identifier string
*
* Output:   none
*
* Globals:  none
*
* Return:   key to locate parameter
*******************************************************************************/
VEM_KEY vemRegisterArray(void *hVemMemHandle, void *pData, PARAMETER_TYPE dataType, 
                         size_t dataSize, const char *pszKey);

/******************************************************************************
*
* Function:  vemRegisterTable()
*
* Action:   register tables.
*
* Input:    hVemMemHandle -- main Vem memory handle
*           pData -- pointer to table element
*           dataType -- parameter type
*           dataSize -- size of table
*           pszKey -- unique parameter identifier string
*
* Output:   none
*
* Globals:  none
*
* Return:   key to locate parameter
*******************************************************************************/
VEM_KEY vemRegisterTable(void *hVemMemHandle, void *pData, PARAMETER_TYPE dataType, 
                         size_t dataSize, const char *pszKey);

/******************************************************************************
*
* Function:  vemRegisterVariable()
*
* Action:   register variables
*
* Input:    hVemMemHandle -- main Vem memory handle
*           pData -- pointer to variable element
*           dataType -- parameter type
*           pszKey -- unique parameter identifier string
*
* Output:   none
*
* Globals:  none
*
* Return:   key to locate parameter
*******************************************************************************/
VEM_KEY vemRegisterVariable(void *hVemMemHandle, void *pData, 
                            PARAMETER_TYPE paramType, const char *pszKey);

/******************************************************************************
*
* Function:  vemRegisterStruct()
*
* Action:   register structure
*
* Input:    hVemMemHandle -- main Vem memory handle
*           pData -- pointer to structure
*           dataSize -- structure size
*           pszKey -- unique parameter identifier string
*
* Output:   none
*
* Globals:  none
*
* Return:   key to locate parameter
*******************************************************************************/
VEM_KEY vemRegisterStruct(void *hVemMemHandle, void *pData, size_t dataSize, 
                          const char *pszKey);

/******************************************************************************
*
* Function:  vemRegisterConstFloat()
*
* Action:   register constants
*
* Input:    pvMemMain -- main Vem memory handle
*           val -- constant float value
*           pszKey -- unique parameter identifier string
*
* Output:   none
*
* Globals:  none
*
* Return:   key to locate parameter
*******************************************************************************/
VEM_KEY vemRegisterConstFloat(void *pvMemMain, float val, const char *pszKey);


/******************************************************************************
*
* Function:  vemRegisterConstShort()
*
* Action:   register constants
*
* Input:    pvMemMain -- main Vem memory handle
*           val -- constant short value
*           pszKey -- unique parameter identifier string
*
* Output:   none
*
* Globals:  none
*
* Return:   key to locate parameter
*******************************************************************************/
VEM_KEY vemRegisterConstShort(void *pvMemMain, short val, const char *pszKey);


/******************************************************************************
*
* Function:  vemGetParameter()
*
* Action:   This function returns VEM_KEY that the function was registered with.
*
* Input:    hVemMemHandle -- main Vem memory handle
*           pszKey -- unique parameter identifier string
*
* Output:   none
*
* Globals:  none
*
* Return:   key to locate parameter
*******************************************************************************/
VEM_KEY vemGetParameter(void *hVemMemHandle, const char *pszKey);

/******************************************************************************
*
* Function:  vemGetParameterData()
*
* Action:   This function returns a COPY of the data.
*
* Input:    pvVemParameter -- key to locate paramter
*           pData -- address to location to return copy of data
*
* Output:   none
*
* Globals:  none
*
* Return:   0: succeed, 1: failed
*******************************************************************************/
unsigned short vemGetParameterData(VEM_KEY pvVemParameter, void *pDataPtr);

/******************************************************************************
*
* Function:  vemSetParameterData()
*
* Action:   This function copies user provided contents to the Vem 
*
* Input:    pvVemParamter -- key to locate paramter
*           pData -- address of location where data is copied from
*
* Output:   none
*
* Globals:  none
*
* Return:   0: succeed, 1: failed
*******************************************************************************/
unsigned short vemSetParameterData(VEM_KEY pvVemParameter, void *pDataPtr);



/******************************************************************************
*
* Function:  vemShowParameters()
*
* Action:   This diagnostic utility will give a complete list of all parameters 
*           that are registered under the main Vem memory handle.
*
* Input:    hVemMemHandle -- main Vem memory handle
*
* Output:   diagnostic messages on Stdout.
*
* Globals:  none
*
* Return:   none
*******************************************************************************/
void vemShowParameters(const void *hVemMemHandle);

#else /* VEM_DEFINED */
#define vemUnregisterParameter(hVemMemHandle, pvVemParam)      ((VEM_KEY)NULL)

#define vemRegisterArray(hVemMemHandle, pData, dataType, \
                         dataSize, pszKey)                     ((VEM_KEY)NULL)

#define vemRegisterTable(hVemMemHandle, pData, dataType,  \
                         dataSize, pszKey)                     ((VEM_KEY)NULL)

#define vemRegisterVariable(hVemMemHandle, pData, \
                            paramType, pszKey)                 ((VEM_KEY)NULL)

#define vemRegisterStruct(hVemMemHandle, pData, dataSize, pszKey) ((VEM_KEY)NULL)

#define vemRegisterConstFloat(pvMemMain, val, pszKey)         ((VEM_KEY)NULL)

#define vemRegisterConstShort(pvMemMain, val, pszKey)         ((VEM_KEY)NULL)


#define vemGetParameter(hVemMemHandle, pszKey)                ((VEM_KEY)NULL)
#define vemGetParameterData(pvVemParameter, pDataPtr)         ((VEM_KEY)NULL)
#define vemSetParameterData(pvVemParameter, pDataPtr)         ((VEM_KEY)NULL)
#define vemShowParameters(hVemMemHandle)                      ((VEM_KEY)NULL)
#endif /* VEM_DEFINED */

#endif /* __VEM2PRM */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\voxware\vlibfilt.h ===
/*******************************************************************************
*                        Voxware Proprietary Material                          *
*                        Copyright 1997, Voxware, Inc                          *
*                            All Rights Reserved                               *
*                                                                              *
*                       DISTRIBUTION PROHIBITED without                        *
*                      written authorization from Voxware                      *
*                                                                              *
*******************************************************************************/
 
/*******************************************************************************
*
* File:          vLibFilt.h
*
* Purpose:
*
* Functions:
*
* Author/Date:
*******************************************************************************
* Modifications:
*
* Comments:
*
* Concerns:
*
* $Header:   /export/phobos/pvcs/pvcsproj/voxlib.prj/vlibfilt.h_v   1.23   26 Feb 1998 15:30:50   weiwang  $
******************************************************************************/
 
#ifndef _VLIB_FILT
#define _VLIB_FILT

#ifdef __cplusplus
extern "C" {
#endif


/* PolyIntp.c */
/* The definitions need for application:  */
/*****************************************************************************
*  PP_NUM_SAMPLES: number of samples for polyphase FIR filter.
*  PP_DELAY      : delay in samples caused by polyphase FIR filter
******************************************************************************/
#define PP_NUM_SAMPLES                    4
#define PP_DELAY                          ((PP_NUM_SAMPLES>>1)-1)

/******************************************************************************
*
* Function:  PolyCycleIntp()
*
* Action:    Poly-Phase Cycle Interpolation.
*
* Input:    pfOut       - address to the resampling signal.
*           iOutLength  - the length of the resampling signal.
*           pfCycle     - input proto-type signal, usually refer to a single
*                         pitch epoch with 0 phase.
*           iLog2CycleLength 
*                       - log2 of the input signal length. 
*           fResampRate - the resampling ratio of the input cycle with
*                         the output cycle (calculated by input cycle length 
*                         over the pitch period).
*           fNormPhase  - the starting phase of the output signal 
*                         (calculated by starting time over the pitch period).
*
* Output:   pfOut       - the output data
*
* Globals:  none
*
* Return:   fNormPhase  - the ending phase of the resampled signal. If use 
*                         it as input for next PolyCycleIntp() call, the phases
*                         can be guaranteed to be continous.
*
*******************************************************************************
*
* Implementation/Detailed Description:
*
* References:  
*
*******************************************************************************
*
* Modifications:
*
* Comments:  
*     (1) In order to use fix point technique to speech up the function, the 
*       cycle length has to be in the order of 2 (2^iLog2CycleLength).
*     (2) To use LONG operation (32 bits), iOutLength, iCycleLength and fIndex
*       can not exceed 2^15.
*     (3) In order to speech up FIR operation, the real length of pfCycle has 
*       to be (2^iLog2CycleLength + PP_NUM_SAMPLES). The input pfCycle has 
*       already been shifted by PP_DELAY so that the address of 
*       pfCycle[-PP_DELAY] is valid.
*
* Concerns/TBD:
******************************************************************************/
float PolyCycleIntp( float       *pfOut,
                     int         iOutLength,
                     float       *pfCycle,
                     int         iLog2CycleLength,  
                     float       fResampRate,
                     float       fNormPhase
                   );

/* PreProc.c */
/******************************************************************************
*
* Function:  VoxPreProcess()
*
* Action:    First-order high-pass filter to remove DC.
*
* Input:     piIn -- the input speech signal (16-bit PCM)
*            pfOut -- the point for the output speech
*            N -- number of samples for both input and output signal
*            hPreProc_mblk  -- internal memory for the processing
*
* Output:    pfOut -- the output speech after the preprocessing.
*
* Globals:   none
*
* Return:    void
*******************************************************************************/
void VoxPreProcess(const short *psIn, float *pfOut, int N, void *hPreProcMblk);

/******************************************************************************
*
* Function:  VoxInitPreProc()
*
* Action:    initialize the preprocessing structure.
*
* Input:     hPreProcMblk -- pointer to the preprocess structure (NULL pointer).
*            PP_Coef -- filter coefficient
*
* Output:    hPreProcMblk -- memory allocated preprocess structure.
*
* Globals:   none
*
* Return:    0 : succeed
*            1 : fail
*******************************************************************************/
unsigned short VoxInitPreProc(void **hPreProcMblk, const float PP_Coef);

/******************************************************************************
*
* Function:  VoxFreePreProc()
*
* Action:    free the preprocessing structure.
*
* Input:     hPreProcMblk -- the pointer of the preprocess structure 
*
* Output:    hPreProcMblk -- NULL preprocess structure
*
* Globals:   none
*
* Return:    none
*******************************************************************************/
void VoxFreePreProc(void **hPreProcMblk);

#ifdef __cplusplus
}
#endif

#endif /* _VLIB_FILT */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\voxware\vlibdef.h ===
/*******************************************************************************
*                        Voxware Proprietary Material
*                        Copyright 1996, Voxware, Inc
*                            All Rights Reserved
*
*                       DISTRIBUTION PROHIBITED without
*                      written authorization from Voxware
*******************************************************************************/
 
/*******************************************************************************
*
* Filename:       vLibDef.h
*
* Purpose:        Machine in-dependent definitions for Research Library
*
* Author/Date:    Wei Wang, 2/23/98
*
********************************************************************************
*
* Modifications:
*
* Comments: 
*
* Concerns:
*
* $Header:   /export/phobos/pvcs/pvcsproj/voxlib.prj/vLibDef.h_v   1.3   03 Mar 1998 14:37:06   bobd  $
*******************************************************************************/
#ifndef _VLIBDEF_H_
#define _VLIBDEF_H_

#ifdef PI
#undef PI
#endif
#define PI                3.141592653589793F

#ifdef DB_PI
#undef DB_PI
#endif
#define DB_PI             6.283185307179586F

#ifdef PI_2
#undef PI_2
#endif
#define PI_2              1.570796326794897F

#ifdef VERY_LARGE_FLOAT
#undef VERY_LARGE_FLOAT
#endif
#define VERY_LARGE_FLOAT  1.0e38F

#ifdef VERY_SMALL_FLOAT
#undef VERY_SMALL_FLOAT
#endif
#define VERY_SMALL_FLOAT  1.0e-37F

#ifdef MAX_LPC_ORDER
#undef MAX_LPC_ORDER
#endif
#define MAX_LPC_ORDER          18

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\voxware\vemfrm15.h ===
/******************************************************************************
 *                                                                            *
 *		                  Voxware Proprietary Material                          *
 *		                  Copyright 1996, Voxware, Inc.                         *
 *		                       All Rights Resrved                               *
 *                                                                            *
 *		                 DISTRIBUTION PROHIBITED without                        *
 *		               written authorization from Voxware                       *
 *                                                                            *
 ******************************************************************************/

/******************************************************************************
 *                                                                            *
 * FILENAME:  vemFrm15.h                                                      *
 * PURPOSE:   Defines the interface functions for vmFrames.c                  *
 * AURTHOR:   Epiphany Vera                                                   *
 *                                                                            *
 *****************************************************************************/

/******************************************************************************
 *                                                                            *
 *                          DETAILED REVISION HISTORY                         *
 *                                                                            *
 * (March 24, '97)                                                            *
 *    Created                                                                 *
 *                                                                            *
 *****************************************************************************/



void framesInBufferVR15(const VCI_CODEC_IO_BLOCK  *hvciCodecIOBlk,
                         unsigned short      *pwNumFrames);
void seekForwardVR15(unsigned short ReadByteOffset,
                      unsigned char  ReadBitOffset,
                      unsigned short BufferSize,
                      unsigned char  *pBuffer,
                      unsigned short wNumFrames,
                      unsigned short *pwByteOffset,
                      unsigned char  *pchBitOffset,
                      unsigned short *BitsInFrames);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\voxware\vlibmacr.h ===
/*******************************************************************************
*                        Voxware Proprietary Material                          *
*                        Copyright 1997, Voxware, Inc                          *
*                            All Rights Reserved                               *
*                                                                              *
*                       DISTRIBUTION PROHIBITED without                        *
*                      written authorization from Voxware                      *
*                                                                              *
*******************************************************************************/
 
/*******************************************************************************
*
* File: vLibMacr.h
*
* Purpose:   provide macros for Voxware Research library
*
* Functions:  SafeFree()
*
* Author/Date: Wei Wang, 3/6/98
*******************************************************************************
* Modifications:
*
* Comments:
*
* Concerns:
*
* $Header:   /export/phobos/pvcs/pvcsproj/voxlib.prj/vLibMacr.h_v   1.0   06 Mar 1998 16:56:40   weiwang  $
******************************************************************************/

#ifndef _VLIBMACR_H_
#define _VLIBMACR_H_

#define SafeFree(ptr)  if(ptr) {free((void *)ptr); ptr=NULL;}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\voxware\vem2prm.c ===
/******************************************************************************
*                        Voxware Proprietary Material
*                        Copyright 1996, Voxware, Inc
*                            All Rights Reserved
*
*                       DISTRIBUTION PROHIBITED without
*                      written authorization from Voxware
******************************************************************************/

/******************************************************************************
* Filename:        vem2Prm.c
*
* Purpose:  main vem file needed to locate codec parameters
*
* Functions:   vemUnRegisterParameter, ...
*
* Author/Date:     Ilan Berci
*******************************************************************************
*
* Modifications:
*
* Comments:
*
* Concerns:
*
* $Header:   /export/phobos/pvcs/r_and_d/archives/common/vem/vem2Prm.c_v   1.4   25 Mar 1998 14:23:16   weiwang  $
******************************************************************************/

#include <stdlib.h>
#include <string.h>
#include <assert.h>

#include "VoxMem.h"
#include "vector.h"
#include "vem2.h"

#include "vem2Prm.h"

#include "xvocver.h"

#if VEM_DEFINED == 1
/*--------------------------------------------------
  Defines the private structure: ELEMENT_TYPE
  --------------------------------------------------*/
typedef enum tagELEMENT_TYPE {
   VEM_VARIABLE,
   VEM_FLOAT_CONST,
   VEM_SHORT_CONST,
   VEM_ARRAY,
   VEM_TABLE,
   VEM_STRUCT
} ELEMENT_TYPE;


/*--------------------------------------------------
  Defines the private structure: VEM_PARAMETER
  --------------------------------------------------*/
typedef struct tagVEM_PARAMETER {
   char           *pszKey;
   union tagDataContainer {
      void        *pData;
      float       floatData;
      short       shortData;
   } DataContainer;
   size_t         dataSize;
   PARAMETER_TYPE dataType;
   ELEMENT_TYPE   elementType;
} VEM_PARAMETER;


/*------------------------------------------------------------
  prototypes of private functions.
  ------------------------------------------------------------*/
static unsigned short copyParameter(void *pVector, const void *pVector2, 
                         PARAMETER_TYPE paramType, size_t count);

static VEM_KEY registerParameter(void *hVemMemHandle, VEM_PARAMETER **hVemParameter, const char *pszKey);






/******************************************************************************
*
* Function:  vemUnRegisterParameter()
*
* Action:   Remove a parameter from the Vem main memory handle.
*
* Input:    hVemMemHandle -- main Vem memory handle
*           paramKey -- key to locate paramter
*
* Output:   hVemMemHandle -- updated Vem memory handle
*
* Globals:  none
*
* Return:   NULL key
*******************************************************************************
*
* Implementation/Detailed Description:
*
* References:
*******************************************************************************
*
* Modifications:
*
* Comments:  Parameters cann't be disabled in the same fashion as states and 
*            externsions, so this is the only way to deny access to other
*            code segments.
*
* Concerns/TBD:
******************************************************************************/

VEM_KEY vemUnregisterParameter(void *hVemMemHandle, VEM_KEY paramKey)
{
   VEM2              *pVemMemHandler   = (VEM2 *)hVemMemHandle;

   VEM_PARAMETER     *pVemParameter    = (VEM_PARAMETER *)vecGetData((void*)paramKey);

   if(pVemParameter) {
      vecDelElement(pVemMemHandler->pVemParameters, paramKey);
      VOX_MEM_FREE(pVemParameter->pszKey);
      VOX_MEM_FREE(pVemParameter);
   }
   return ((VEM_KEY)NULL);
}


/******************************************************************************
*
* Function:  vemRegisterArray()
*
* Action:   register arrays. Note: no constant arrays can be registered with 
*           this function.
*
* Input:    hVemMemHandle -- main Vem memory handle
*           pData -- pointer to array element
*           dataType -- parameter type
*           dataSize -- size of array
*           pszKey -- unique parameter identifier string
*
* Output:   none
*
* Globals:  none
*
* Return:   key to locate parameter
*******************************************************************************
*
* Implementation/Detailed Description:
*
* References:
*******************************************************************************
*
* Modifications:
*
* Comments: 
*
* Concerns/TBD:
******************************************************************************/

VEM_KEY vemRegisterArray(void *hVemMemHandle, void *pData, PARAMETER_TYPE dataType, 
                         size_t dataSize, const char *pszKey)
{
   VEM_KEY paramKey=NULL;
   VEM_PARAMETER *pVemParameter=NULL;

   if(!(paramKey=registerParameter(hVemMemHandle,&pVemParameter, pszKey)))
      return ((VEM_KEY)NULL);

   pVemParameter->DataContainer.pData=pData;
   pVemParameter->dataSize=dataSize;
   pVemParameter->dataType=dataType;
   pVemParameter->elementType=VEM_ARRAY;

   return(paramKey);
}

/******************************************************************************
*
* Function:  vemRegisterTable()
*
* Action:   register tables.
*
* Input:    hVemMemHandle -- main Vem memory handle
*           pData -- pointer to table element
*           dataType -- parameter type
*           dataSize -- size of table
*           pszKey -- unique parameter identifier string
*
* Output:   none
*
* Globals:  none
*
* Return:   key to locate parameter
*******************************************************************************
*
* Implementation/Detailed Description:
*
* References:
*******************************************************************************
*
* Modifications:
*
* Comments: 
*
* Concerns/TBD:
******************************************************************************/

VEM_KEY vemRegisterTable(void *hVemMemHandle, void *pData, PARAMETER_TYPE dataType, 
                         size_t dataSize, const char *pszKey)
{
   VEM_KEY            paramKey         = NULL;
   VEM_PARAMETER     *pVemParameter    = NULL;

   if(!(paramKey=registerParameter(hVemMemHandle,&pVemParameter, pszKey)))
      return ((VEM_KEY)NULL);

   pVemParameter->DataContainer.pData=pData;
   pVemParameter->dataSize=dataSize;
   pVemParameter->dataType=dataType;
   pVemParameter->elementType=VEM_TABLE;

   return(paramKey);
}


/******************************************************************************
*
* Function:  vemRegisterVariable()
*
* Action:   register variables
*
* Input:    hVemMemHandle -- main Vem memory handle
*           pData -- pointer to variable element
*           dataType -- parameter type
*           pszKey -- unique parameter identifier string
*
* Output:   none
*
* Globals:  none
*
* Return:   key to locate parameter
*******************************************************************************
*
* Implementation/Detailed Description:
*
* References:
*******************************************************************************
*
* Modifications:
*
* Comments: 
*
* Concerns/TBD:
******************************************************************************/

VEM_KEY vemRegisterVariable(void *hVemMemHandle, void *pData, 
                            PARAMETER_TYPE dataType, const char *pszKey)
{
   VEM_KEY            paramKey         = NULL;
   VEM_PARAMETER     *pVemParameter    = NULL;

   if(!(paramKey=registerParameter(hVemMemHandle,&pVemParameter, pszKey)))
      return ((VEM_KEY)NULL);

   pVemParameter->DataContainer.pData=pData;
   pVemParameter->dataSize=0;
   pVemParameter->dataType=dataType;
   pVemParameter->elementType=VEM_VARIABLE;

   return(paramKey);
}


/******************************************************************************
*
* Function:  vemRegisterStruct()
*
* Action:   register structure
*
* Input:    hVemMemHandle -- main Vem memory handle
*           pData -- pointer to structure
*           dataSize -- structure size
*           pszKey -- unique parameter identifier string
*
* Output:   none
*
* Globals:  none
*
* Return:   key to locate parameter
*******************************************************************************
*
* Implementation/Detailed Description:
*
* References:
*******************************************************************************
*
* Modifications:
*
* Comments: 
*
* Concerns/TBD:
******************************************************************************/

VEM_KEY vemRegisterStruct(void *hVemMemHandle, void *pData, size_t dataSize, 
                          const char *pszKey)
{
   VEM_KEY            paramKey         = NULL;
   VEM_PARAMETER     *pVemParameter    = NULL;

   if(!(paramKey=registerParameter(hVemMemHandle,&pVemParameter, pszKey)))
      return ((VEM_KEY)NULL);

   pVemParameter->DataContainer.pData=pData;
   pVemParameter->dataSize=dataSize;
   pVemParameter->dataType=VEM_VOID; /* type doesn't matter */
   pVemParameter->elementType=VEM_STRUCT;

   return(paramKey);
}


/******************************************************************************
*
* Function:  vemRegisterConstFloat()
*
* Action:   register constants
*
* Input:    pvMemMain -- main Vem memory handle
*           val -- constant float value
*           pszKey -- unique parameter identifier string
*
* Output:   none
*
* Globals:  none
*
* Return:   key to locate parameter
*******************************************************************************
*
* Implementation/Detailed Description:
*
* References:
*******************************************************************************
*
* Modifications:
*
* Comments: 
*
* Concerns/TBD:
******************************************************************************/

VEM_KEY vemRegisterConstFloat(void *pvMemMain, float val, const char *pszKey) {
   VEM_KEY            paramKey         = NULL;
   VEM_PARAMETER     *pVemParameter    = NULL;

   if(!(paramKey=registerParameter(pvMemMain,&pVemParameter, pszKey)))
      return ((VEM_KEY)NULL);

   pVemParameter->DataContainer.floatData=val;
   pVemParameter->dataSize=0;
   pVemParameter->dataType=VEM_FLOAT;
   pVemParameter->elementType=VEM_FLOAT_CONST;

   return(paramKey);
}

/******************************************************************************
*
* Function:  vemRegisterConstShort()
*
* Action:   register constants
*
* Input:    pvMemMain -- main Vem memory handle
*           val -- constant short value
*           pszKey -- unique parameter identifier string
*
* Output:   none
*
* Globals:  none
*
* Return:   key to locate parameter
*******************************************************************************
*
* Implementation/Detailed Description:
*
* References:
*******************************************************************************
*
* Modifications:
*
* Comments: 
*
* Concerns/TBD:
******************************************************************************/

VEM_KEY vemRegisterConstShort(void *pvMemMain, short val, const char *pszKey)
{
   VEM_KEY            paramKey         = NULL;
   VEM_PARAMETER     *pVemParameter    = NULL;

   if(!(paramKey=registerParameter(pvMemMain,&pVemParameter, pszKey)))
      return ((VEM_KEY)NULL);

   pVemParameter->DataContainer.shortData=val;
   pVemParameter->dataSize=0;
   pVemParameter->dataType=VEM_SHORT;
   pVemParameter->elementType=VEM_SHORT_CONST;

   return(paramKey);
}


/******************************************************************************
*
* Function:  vemGetParameter()
*
* Action:   This function returns VEM_KEY that the function was registered with.
*
* Input:    hVemMemHandle -- main Vem memory handle
*           pszKey -- unique parameter identifier string
*
* Output:   none
*
* Globals:  none
*
* Return:   key to locate parameter
*******************************************************************************
*
* Implementation/Detailed Description:
*
* References:
*******************************************************************************
*
* Modifications:
*
* Comments: 
*
* Concerns/TBD:
******************************************************************************/

VEM_KEY vemGetParameter(void *hVemMemHandle, const char *pszKey)
{
   VEM2              *pVemMemHandler   = (VEM2 *)hVemMemHandle;

   void              *pElement         = vecGetFirstElement(pVemMemHandler->pVemParameters);

   while(pElement) {
      if(!strcmp(((VEM_PARAMETER *)vecGetData(pElement))->pszKey,pszKey))
         break;
      pElement=vecGetNextElement(pElement, FORWARDS);
   }
   return((VEM_KEY)pElement); /* could be NULL */
}

/******************************************************************************
*
* Function:  vemGetParameterData()
*
* Action:   This function returns a COPY of the data.
*
* Input:    pvVemParameter -- key to locate paramter
*           pData -- address to location to return copy of data
*
* Output:   none
*
* Globals:  none
*
* Return:   0: succeed, 1: failed
*******************************************************************************
*
* Implementation/Detailed Description:
*
* References:
*******************************************************************************
*
* Modifications:
*
* Comments:
*
* Concerns/TBD:
******************************************************************************/

unsigned short vemGetParameterData(VEM_KEY pvVemParameter, void *pData)
{
   VEM_PARAMETER *pVemParameter=(VEM_PARAMETER *)vecGetData((void *)pvVemParameter);

   if(pVemParameter) {
      switch(pVemParameter->elementType) {
         case VEM_ARRAY:
         case VEM_TABLE:
            return(copyParameter(pData,pVemParameter->DataContainer.pData,pVemParameter->dataType,
                   pVemParameter->dataSize));
         case VEM_VARIABLE:
            return(copyParameter(pData,pVemParameter->DataContainer.pData,pVemParameter->dataType,1));
         case VEM_FLOAT_CONST:
            *(float *)pData=pVemParameter->DataContainer.floatData;
            return 0;
         case VEM_SHORT_CONST:
            *(short *)pData=pVemParameter->DataContainer.shortData;
            return 0;
         case VEM_STRUCT:
            return((unsigned short)((memcpy(pData,pVemParameter->DataContainer.pData,
               pVemParameter->dataSize))?(unsigned short)0:(unsigned short)1));
         default:
            assert(0);
      }
   } else
      return 1;
      
   return 0;   
}


/******************************************************************************
*
* Function:  vemSetParameterData()
*
* Action:   This function copies user provided contents to the Vem 
*
* Input:    pvVemParamter -- key to locate paramter
*           pData -- address of location where data is copied from
*
* Output:   none
*
* Globals:  none
*
* Return:   0: succeed, 1: failed
*******************************************************************************
*
* Implementation/Detailed Description:
*
* References:
*******************************************************************************
*
* Modifications:
*
* Comments: 
*
* Concerns/TBD:
******************************************************************************/

unsigned short vemSetParameterData(VEM_KEY pvVemParameter, void *pData)
{
   VEM_PARAMETER *pVemParameter=(VEM_PARAMETER *)vecGetData((void *)pvVemParameter);

   if(pVemParameter) {
      switch(pVemParameter->elementType) {
         case VEM_ARRAY:
            return(copyParameter(pVemParameter->DataContainer.pData,pData,pVemParameter->dataType,
                   pVemParameter->dataSize));
         case VEM_VARIABLE:
            return(copyParameter(pVemParameter->DataContainer.pData,pData,pVemParameter->dataType,1));
         case VEM_TABLE:
         case VEM_FLOAT_CONST:
         case VEM_SHORT_CONST:
            return 1;
         case VEM_STRUCT:
            return((unsigned short)((memcpy(pVemParameter->DataContainer.pData,pData,
                   pVemParameter->dataSize))?0:1));
         default:
            assert(0);
      }
   } else
      return 1;
      
   return 0;   
}




/******************************************************************************
*
* Function:  registerParameter()
*
* Action:   parameter registration
*
* Input:    hVemMemHandle -- main Vem memory handle
*           hVemParameter -- pointer to Vem parameter
*           pszKey -- unique parameter identifier string
*
* Output:   none
*
* Globals:  none
*
* Return:   key to locate parameter
*******************************************************************************
*
* Implementation/Detailed Description:
*
* References:
*******************************************************************************
*
* Modifications:
*
* Comments:  local function
*
* Concerns/TBD:
******************************************************************************/
static VEM_KEY registerParameter(void *hVemMemHandle, VEM_PARAMETER **hVemParameter, 
                                 const char *pszKey)
{
   VEM2              *pVemMemHandler   = (VEM2 *)hVemMemHandle;
   VEM_PARAMETER     *pVemParameter    = NULL;
   VEM_KEY            paramKey         = NULL;

   if(VOX_MEM_INIT(pVemParameter=*hVemParameter, 1, sizeof(VEM_PARAMETER)))
      return NULL;
   else
      pVemParameter->pszKey=NULL;

   if(!(paramKey=vecAddElement(pVemMemHandler->pVemParameters, pVemParameter, FORWARDS))) {
      VOX_MEM_FREE(pVemParameter);
      return NULL;
   }

   if(VOX_MEM_INIT(pVemParameter->pszKey,strlen(pszKey)+1,sizeof(char)))
      return vemUnregisterParameter(hVemMemHandle, paramKey);
   else
      strcpy(pVemParameter->pszKey,pszKey);

   return paramKey;
}



/******************************************************************************
*
* Function:  copyParameter()
*
* Action:   copy parameter
*
* Input:    pVector -- array where parameters copy to
*           pVector2 -- array where parameter copy from
*           paramType -- the parameter type
*           count -- size of the parameters
*
* Output:   pVector -- array with new parameters
*
* Globals:  none
*
* Return:   0: succeed, 1: failed
*******************************************************************************
*
* Implementation/Detailed Description:
*
* References:
*******************************************************************************
*
* Modifications:
*
* Comments:  local function
*
* Concerns/TBD:
******************************************************************************/

static unsigned short copyParameter(void *pVector, const void *pVector2, 
                         PARAMETER_TYPE paramType, size_t count) 
{
   size_t i;

   unsigned char  *pUChar=NULL,    *pUChar2=NULL;
   unsigned short *pUShort=NULL,   *pUShort2=NULL;
   unsigned int   *pUInt=NULL,     *pUInt2=NULL;
   unsigned long  *pULong=NULL,    *pULong2=NULL;
   float          *pFloat=NULL,    *pFloat2=NULL;
   double         *pDouble=NULL,   *pDouble2=NULL;

   switch(paramType) {
      case VEM_CHAR: 
      case VEM_U_CHAR:
         pUChar=(unsigned char *)pVector;
         pUChar2=(unsigned char *)pVector2;
         for(i=0;i<count;i++)
            pUChar[i]=pUChar2[i];
         break;
      case VEM_SHORT:
      case VEM_U_SHORT:
         pUShort=(unsigned short *)pVector;
         pUShort2=(unsigned short *)pVector2;
         for(i=0;i<count;i++)
            pUShort[i]=pUShort2[i];
         break;
      case  VEM_INT:
      case  VEM_U_INT:
         pUInt=(unsigned int *)pVector;
         pUInt2=(unsigned int *)pVector2;
         for(i=0;i<count;i++)
            pUInt[i]=pUInt2[i];
         break;
      case VEM_LONG:
      case VEM_U_LONG:
         pULong=(unsigned long *)pVector;
         pULong2=(unsigned long *)pVector2;
         for(i=0;i<count;i++)
            pULong[i]=pULong2[i];
         break;
      case VEM_FLOAT:
         pFloat=(float *)pVector;
         pFloat2=(float *)pVector2;
         for(i=0;i<count;i++)
            pFloat[i]=pFloat2[i];
         break;
      case VEM_DOUBLE:
         pDouble=(double *)pVector;
         pDouble2=(double *)pVector2;
         for(i=0;i<count;i++)
            pDouble[i]=pDouble2[i];
         break;
      default:
         return 1;
   }
   return 0;
}

#if VEM_TRACE==1

#include <stdio.h>



/******************************************************************************
*
* Function:  vemShowParameters()
*
* Action:   This diagnostic utility will give a complete list of all parameters 
*           that are registered under the main Vem memory handle.
*
* Input:    hVemMemHandle -- main Vem memory handle
*
* Output:   diagnostic messages on Stdout.
*
* Globals:  none
*
* Return:   none
*******************************************************************************
*
* Implementation/Detailed Description:
*
* References:
*******************************************************************************
*
* Modifications:
*
* Comments: 
*
* Concerns/TBD:
******************************************************************************/

void vemShowParameters(const void *hVemMemHandle)
{
   VEM_PARAMETER     *pVemParameter    = NULL;
   void              *pVemElement      = NULL, *pVemElement2 = NULL;
   VEM2              *pVemMemHandler   = (VEM2 *)hVemMemHandle;

   pVemElement = vecGetFirstElement(pVemMemHandler->pVemParameters);
   if(pVemElement)
      printf("\n\nParameters registered: ");
   else
      printf("\nNo parameters registered ");
   while(pVemElement) {
      pVemParameter=(VEM_PARAMETER *)vecGetData(pVemElement);
      printf("\n   \"%10s\" : ", pVemParameter->pszKey);
      switch(pVemParameter->elementType) {
         case VEM_FLOAT_CONST:
         case VEM_SHORT_CONST:
            printf("const ");
            break;
         case VEM_ARRAY:
            printf("array[%d] of ", pVemParameter->dataSize);
            break;
         case VEM_TABLE:
            printf("const array[%d] of ", pVemParameter->dataSize);
            break;
         case VEM_VARIABLE:
            break;
      }
      switch(pVemParameter->dataType) {
         case VEM_CHAR:
            printf("char");
            break;
         case VEM_U_CHAR:
            printf("unsigned char");
            break;
         case VEM_SHORT:
            printf("short");
            break;
         case VEM_U_SHORT:
            printf("unsigned short");
            break;
         case VEM_INT:
            printf("int");
            break;
         case VEM_U_INT:
            printf("unsigned int");
            break;
         case VEM_LONG:
            printf("long");
            break;
         case VEM_U_LONG:
            printf("unsigned long");
            break;
         case VEM_FLOAT:
            printf("float");
            break;
         case VEM_DOUBLE:
            printf("double");
            break;
      }
      pVemElement=vecGetNextElement(pVemElement, FORWARDS);
   }
   return;   
}

#else /* VEM_TRACE */
/* if VEM_TRACE is off, there will be warnings for unreferenced paramenters. 
   Please ignore them */
void vemShowParameters(const void *hVemMemHandle) {return;}
#endif /* VEM_TRACE */
#endif  /* VEM_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\voxware\vlibnum.h ===
/*******************************************************************************
*                        Voxware Proprietary Material                          *
*                        Copyright 1997, Voxware, Inc                          *
*                            All Rights Reserved                               *
*                                                                              *
*                       DISTRIBUTION PROHIBITED without                        *
*                      written authorization from Voxware                      *
*                                                                              *
*******************************************************************************/
 
/*******************************************************************************
*
* File:         vLibNum.h
*
* Purpose:
*
* Functions:
*
* Author/Date:
*******************************************************************************
* Modifications:
*
* Comments:
*
* Concerns:
*
* $Header:   /export/phobos/pvcs/pvcsproj/voxlib.prj/vlibnum.h_v   1.4   15 Jan 1998 15:20:12   bobd  $
******************************************************************************/
 
#ifndef __VLIBNUM
#define __VLIBNUM

#ifdef __cplusplus
extern "C" {
#endif



#ifdef __cplusplus
}
#endif

#endif /* __VLIBNUM */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\voxware\vlibmath.h ===
/*******************************************************************************
*                        Voxware Proprietary Material                          *
*                        Copyright 1997, Voxware, Inc                          *
*                            All Rights Reserved                               *
*                                                                              *
*                       DISTRIBUTION PROHIBITED without                        *
*                      written authorization from Voxware                      *
*                                                                              *
*******************************************************************************/
 
/*******************************************************************************
*
* File:          vLibMath.h
*
* Purpose:
*
* Functions:
*
* Author/Date:
*******************************************************************************
* Modifications:
*
* Comments:
*
* Concerns:
*
* $Header:   /export/phobos/pvcs/pvcsproj/voxlib.prj/vlibmath.h_v   1.24   22 Apr 1998 10:27:26   weiwang  $
******************************************************************************/
 
#ifndef __VLIBMATH
#define __VLIBMATH

#ifdef __cplusplus
extern "C" {
#endif

#ifdef _WIN64
#undef WIN32
#endif

#include <math.h>


/* Log2.h */
/******************************************************************************
*
* function:  float fLog2 (float fx) 
*
* Action:    approximation to log_base_2
*
* Input:     fx -- input number 
*
* Output:    same as return
*
* Globals:   none
*
* Return:    approximation to log_base_2 value
*
******************************************************************************
*
* Concern:   Need choose either 'IEEE' pre-definition or not. If both float and 
*            long are 32 bits and the platform support IEEE floating point
*            format, then choose 'IEEE' to speed up the code.
*          
******************************************************************************/
float fLog2 (float fx);

/******************************************************************************
*
* Function:  float fInvLog2 (float fLogB2) 
*
* Action:    approximation to 2**log_b2
*
* Input:     fLogB2 -- input number 
*
* Output:    same as return
*
* Globals:   none
*
* Return:    inverse log2 value of fx
*
******************************************************************************
*
* Concern:   Need choose either 'IEEE' pre-definition or not. If both float and 
*            long are 32 bits and the platform support IEEE floating point
*            format, then choose 'IEEE' to speed up the code.
*          
******************************************************************************/

float fInvLog2 (float fLogB2);
 
/* nurand.h */

/** 1/(2**31-1): to normalize the random number at U[0,1] **/
#define NURAND_SCALE  4.656612875e-10F 

/******************************************************************************
*
* Function:  long NuRand(long *plSeed)
*
* Action:    Generate a long random number (31-bit unsigned long) from lSeed.
*
* Input:     plSeed -- address to the input seed for random number generator.
*
* Output:    plSeed -- address to the updated seed.
*
* Globals:   none
*
* Return:    New random number in unsigned long (31 bit)
*
*******************************************************************************
*
* Modifications:
*
* Comments:    
*
* Concerns/TBD:  The initial seed must be larger than 0 
*******************************************************************************/
long NuRand(long *plSeed);

/* VoxQR.h */
/******************************************************************************
*
* function:  float fQuadRoot(float fXval)
*
* Action:    approximation fourth root.
*
* Input:     fXvale -- input number 
*
* Output:    same as return
*
* Globals:   none
*
* Return:    approximation to fourth root of fXval
*
*******************************************************************************
*
* Comments:
*
*     WARNING: This code assumes that the input is between 0 and 1.
*              The output is meaningless for inputs greater than 1.
*              If the input is negative an infinite loop results.
*
********************************************************************************/
float fQuadRoot(float fXval);


/* Macros.h */

/*******************************************************************************
*
* Macros for the Pentium
*
*******************************************************************************/
#ifdef WIN32
/*----------------------------------------------------
   VoxROUND2pos() rounds a positive float.  This is 
      assembly code for the Pentium. XF
----------------------------------------------------*/
#define VoxROUND2pos(floatIn, IntegerOut)    \
                     _asm fld floatIn        \
                     _asm fistp IntegerOut   

/*----------------------------------------------------
   VoxROUND2posLong() return long -- same as 
   VoxROUND2pos()
----------------------------------------------------*/
#define VoxROUND2posLong(floatIn, IntegerOut) \
                    VoxROUND2pos(floatIn, IntegerOut) 


/*----------------------------------------------------
   VoxROUND2() rounds a float.  This is 
      assembly code for the Pentium. XF
----------------------------------------------------*/
#define VoxROUND2(floatIn, IntegerOut)    \
                  _asm fld floatIn        \
                  _asm fistp IntegerOut   


/*----------------------------------------------------
   VoxROUNDlong() return long -- same as 
   VoxROUND()
----------------------------------------------------*/
#define VoxROUND2long(floatIn, IntegerOut) \
                   VoxROUND2(floatIn, IntegerOut)

/*----------------------------------------------------
   VoxFLOOR() truncates a float towards minus infinity.  
      This is a compiler dependent macro.  It works with
      cc and gcc on the SUN and on the Pentium.
----------------------------------------------------*/
#define VoxFLOORpos(A) ((int) (A))

#define VoxFLOOR(A)   ((int)((A>=0.0F) ?  A : A-1.0F))

/*----------------------------------------------------
   VoxFLOORlong() -- return long
----------------------------------------------------*/
#define VoxFLOORlong(A)   ((long)((A>=0.0F)? A : A-1.0F)) 

#define VoxFLOORposLong(A) ((long) (A))


#endif /* ifdef WIN32 */

/*******************************************************************************
*
* Macros for the SparcStation
*
*******************************************************************************/
#if (defined(SPARCSTATION) == 1) || (defined(WIN16) == 1) || (defined(FAST_ROUND)==1)

/*----------------------------------------------------
   VoxROUND2pos() rounds a positive float.  This is 
      a compiler dependent macro.  It works with
      cc and gcc on the SUN. BD
----------------------------------------------------*/
#define VoxROUND2pos(A,B) B = ((int) ((A)+0.5F))


/*----------------------------------------------------
   VoxROUND2posLong() return long 
----------------------------------------------------*/
#define VoxROUND2posLong(A, B)  B = ((long) ((A)+0.5F))

/*----------------------------------------------------
   VoxROUND2() rounds a float.  This is 
      a compiler dependent macro.  It works with
      cc and gcc on the SUN. BD
----------------------------------------------------*/
#define VoxROUND2(A,B)  B = (((A)>0.0F) ? (int) ((A)+0.5F) : (int) ((A)-0.5F))

/*----------------------------------------------------
   VoxROUND2long() return long 
----------------------------------------------------*/
#define VoxROUND2long(A, B) \
            B = (((A)>0.0F) ? (long) ((A)+0.5F) : (long) ((A)-0.5F))

/*----------------------------------------------------
   VoxFLOOR() truncates a float towards minus infinity.  
      This is a compiler dependent macro.  It works with
      cc and gcc on the SUN and on the Pentium.
----------------------------------------------------*/
#define VoxFLOORpos(A) ((int) (A))

#define VoxFLOOR(A)   ((int)((A>=0.0F) ? A : A-1.0F))


/*----------------------------------------------------
   VoxFLOORlong() return long 
----------------------------------------------------*/
#define VoxFLOORlong(A)   ((long)((A>=0.0F) ? A : A-1.0F))

#define VoxFLOORposLong(A) ((long) (A))

#endif /* ifndef WIN32 */

/*******************************************************************************
*
* Machine independent macros
*
*******************************************************************************/
#if  (defined(WIN32) == 0) && (defined(SPARCSTATION) == 0) && (defined(WIN16) == 0) \
   && (defined(FAST_ROUND) == 0)

/*----------------------------------------------------
   VoxROUND2pos() rounds a positive float.  This is 
      a machine independent macro.  
----------------------------------------------------*/
#define VoxROUND2pos(A,B) B = ((int) floor((double) ((A)+0.5F)))

/*----------------------------------------------------
   VoxROUND2posLong() returns long
----------------------------------------------------*/
#define VoxROUND2posLong(A,B) B = ((long) floor((double) ((A)+0.5F)))

/*----------------------------------------------------
   VoxROUND2() rounds a float.  This is 
      a machine independent macro.  
----------------------------------------------------*/
#define VoxROUND2(A,B)  B = ( ((A)>0.0F) ?                         \
                              ((int) floor((double) ((A)+0.5F))) : \
                              ((int) ceil((double)  ((A)-0.5F))) )

/*----------------------------------------------------
   VoxROUND2long() returns long
----------------------------------------------------*/
#define VoxROUND2long(A,B)  B = ( ((A)>0.0F) ?                     \
                              ((long) floor((double) ((A)+0.5F))) : \
                              ((long) ceil((double)  ((A)-0.5F))) )


/*----------------------------------------------------
   VoxFLOOR() truncates a float towards minus infinity.  
      This is a machine independent macro.  
----------------------------------------------------*/
#define VoxFLOORpos(A) ((int) (floor( (double) (A))))

#define VoxFLOOR(A) ((int) (floor( (double) (A))))

/*----------------------------------------------------
   VoxFLOORlong() returns long
----------------------------------------------------*/
#define VoxFLOORlong(A) ((long) (floor( (double) (A))))

#define VoxFLOORposLong(A) ((long) (floor( (double) (A))))

#endif

/*----------------------------------------------------
   VoxABS() generates the absolute value of a float.
      This is many times faster than fabs() as it 
      doesn't do type conversions and it is a macro
      instead of a function.
----------------------------------------------------*/
#define VoxABS(A)  (((A)>0.0F) ? (A) : -(A))
#define VoxIABS(A)  (((A)>0) ? (A) : -(A))


#define VoxINTERP(A,B,FACTOR) ((A)+(FACTOR)*((B)-(A)))

#define VoxMAX(A,B) ( ((A)>(B)) ? (A) : (B) )

#define VoxMIN(A,B) ( ((A)>(B)) ? (B) : (A) )       

/*-----------------------------------------------------
  VoxATAN2():
 -----------------------------------------------------*/
#ifdef WIN16
#define VoxATAN2(x, y)    ((x==0.0F) ? (0.0F) : ((float)atan2(x,y)))
#else
#define VoxATAN2(x, y)    ((float)atan2(x,y))
#endif

#ifdef _WIN64
#define WIN32
#endif

#ifdef __cplusplus
}
#endif

#endif /* __VLIBMATH */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\voxware\vlibpatr.h ===
/*******************************************************************************
*                        Voxware Proprietary Material                          *
*                        Copyright 1997, Voxware, Inc                          *
*                            All Rights Reserved                               *
*                                                                              *
*                       DISTRIBUTION PROHIBITED without                        *
*                      written authorization from Voxware                      *
*                                                                              *
*******************************************************************************/
 
/*******************************************************************************
*
* File:         vLibPatR.h
*
* Purpose:
*
* Functions:
*
* Author/Date:
*******************************************************************************
* Modifications:
*
* Comments:
*
* Concerns:
*
* $Header:   /export/phobos/pvcs/pvcsproj/voxlib.prj/vlibpatr.h_v   1.4   15 Jan 1998 15:20:22   bobd  $
******************************************************************************/
 
#ifndef __VLIBPATR
#define __VLIBPATR

#ifdef __cplusplus
extern "C" {
#endif



#ifdef __cplusplus
}
#endif

#endif /* __VLIBPATR */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\voxware\vlibmatr.h ===
/*******************************************************************************
*                        Voxware Proprietary Material                          *
*                        Copyright 1997, Voxware, Inc                          *
*                            All Rights Reserved                               *
*                                                                              *
*                       DISTRIBUTION PROHIBITED without                        *
*                      written authorization from Voxware                      *
*                                                                              *
*******************************************************************************/
 
/*******************************************************************************
*
* File:         vLibMatr.h
*
* Purpose:
*
* Functions:
*
* Author/Date:
*******************************************************************************
* Modifications:
*
* Comments:
*
* Concerns:
*
* $Header:   /export/phobos/pvcs/pvcsproj/voxlib.prj/vlibmatr.h_v   1.3   15 Jan 1998 15:20:02   bobd  $
******************************************************************************/
 
#ifndef __VLIBMAT
#define __VLIBMAT

#ifdef __cplusplus
extern "C" {
#endif



#ifdef __cplusplus
}
#endif

#endif /* __VLIBMAT */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\voxware\vlibpack.h ===
/*******************************************************************************
*                        Voxware Proprietary Material                          *
*                        Copyright 1997, Voxware, Inc                          *
*                            All Rights Reserved                               *
*                                                                              *
*                       DISTRIBUTION PROHIBITED without                        *
*                      written authorization from Voxware                      *
*                                                                              *
*******************************************************************************/
 
/*******************************************************************************
*
* File:          vLibPack.h
*
* Purpose:
*
* Functions:
*
* Author/Date:
*******************************************************************************
* Modifications:
*
* Comments:
*
* Concerns:
*
* $Header:   /export/phobos/pvcs/pvcsproj/voxlib.prj/vLibPack.h_v   1.1   07 Apr 1998 18:02:36   weiwang  $
******************************************************************************/
 
#ifndef _VLIB_PACK
#define _VLIB_PACK

#ifdef __cplusplus
extern "C" {
#endif

/*
   The definition of structure:
   Note : The word Byte in below variables should really be char to reflect that 
   on some platforms a char is not necessarily 1 byte. However, for
   historical reasons, the variables will keep there names.
*/


typedef struct
{
  unsigned char  *pBuffer;       /* The circular buffer */
                                 
  unsigned short wBufferSize;     /* Size of VoxBuffer in char               */  

  unsigned short *pBufferReadByteOffset; /* The offset in chars (from the beginning 
                                            of the buffer) of the first char to    
                                            start reading from. */


  unsigned char *pBufferReadBitOffset;  /* The offset in bits (from the most sign-
                                           ificant bit) to start reading from. */

  unsigned short *pBufferWriteByteOffset;/* The offset in chars (from the beginning
                                            of the buffer) of the first char to 
                                            start writing to.*/

  unsigned char *pBufferWriteBitOffset; /* The offset in bits (from the most sign-
                                           ificant bit) to start writing to.*/
} C_BUFFER_TYPE;


#define PACK_BITS_PER_CHAR   8    /* Defines the number of bits to be writt- */
                                  /* en into each char. This should always   */
                                  /* be 8 on platfroms that define char as 8 */
                                  /* On some DSP platforms, sizeof(char) is  */
                                  /* > than 8. The routine still works but   */
                                  /* there are wasted bytes. If desired this */
                                  /* constant can be changed to sizeof(char) */
                                  /* to avoid the waste.                     */

/******************************************************************************
*
* Function:  BitPackCBuffer
*
* Action:    Packs a bitstream into a circular bitstream buffer.
*
* Input:     CBuffer -- The circular buffer into which data is to be packed. 
*                       The data struct is defined in BitPackC.h. This routine
*                       only writes to the buffer, thus the read offsets are 
*                       not needed. 
*            cElement -- The char containing the data
*            cDataWidth -- The number of bits to be written into the buffer.
*
* Output:    CBuffer -- The circular buffer, the write-byte-offset and write-
*                       bit-offset are updated.
*
* Globals:   none
*
* Return:    void
*******************************************************************************/

void BitPackCBuffer(C_BUFFER_TYPE *CBuffer, unsigned char cElement,  
                    short cDataWidth);


/******************************************************************************
*
* Function:  BitUnPackCBuffer
*
* Action:    Unpacks a bitstream from a circular bitstream buffer.
*
* Input:     CBuffer -- The circular buffer into which data is to be packed. 
*                       The data struct is defined in BitPackC.h. This routine
*                       only reads to the buffer, thus the write offsets are 
*                       not needed. 
*            cElement -- The char containing the data
*            cDataWidth -- The number of bits to be read from the buffer.
*
* Output:    CBuffer -- The read-byte-offset and read-bit-offset are updated.
*
* Globals:   none
*
* Return:    void
*******************************************************************************/

void BitUnpackCBuffer(C_BUFFER_TYPE *CBuffer, unsigned char *cElement, 
                      short cDataWidth);

/******************************************************************************
*
* Function:  copyCBuf2LBuf
*
* Action:    copy circular buffer to linear buffer
*
* Input:     CBuffer -- The circular buffer into which data is to be packed. 
*            ByteOffset -- byte offset 
*            BitOffset -- bit offset
*            BufferSize -- circular buffer size
*            bitsToCopy  -- how many bits need to copy to linear buffer
*            LBuffer -- linear buffer to copy to 
*
* Output:    ByteOffset -- updated byte offset
*            BitOffset -- updated bit offset
*            LBuffer  -- updated linear buffer
*
* Globals:   none
*
* Return:    void
******************************************************************************/
void copyCBuf2LBuf(unsigned char *CBuffer,    unsigned short *ByteOffset,  
                   unsigned char *BitOffset,  unsigned short  BufferSize,
                   unsigned long  bitsToCopy, unsigned char  *LBuffer);

#ifdef __cplusplus
}
#endif

#endif /* _VLIB_PACK */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\voxware\vlibsgpr.h ===
/*******************************************************************************
*                        Voxware Proprietary Material                          *
*                        Copyright 1997, Voxware, Inc                          *
*                            All Rights Reserved                               *
*                                                                              *
*                       DISTRIBUTION PROHIBITED without                        *
*                      written authorization from Voxware                      *
*                                                                              *
*******************************************************************************/
 
/*******************************************************************************
*
* File:         vLibSqPr.h
*
* Purpose:
*
* Functions:
*
* Author/Date:
*******************************************************************************
* Modifications:
*
* Comments:
*
* Concerns:
*
* $Header:   /export/phobos/pvcs/pvcsproj/voxlib.prj/vlibsgpr.h_v   1.14   02 Mar 1998 18:23:54   bobd  $
******************************************************************************/
 
#ifndef __VLIBSGPR
#define __VLIBSGPR

#ifdef __cplusplus
extern "C" {
#endif

/* SpecInt.h */
/*******************************************************************************
* Function: SpecIntLn()
*
* Action: Interpolate the harmonic spectrum from one pitch to another using
*         linear interpolation.
*
* Input:  fPitch          - the original pitch lag (time-domain)
*         fPitchInt       - the pitch lag to interpolate the spectrum to.
*         iIntHarms       - the number of harmonics corresponding to fPitchInt
*         pfAmp           - pointer to the original harmonics
*         pfAmpInt        - pointer to a vector to put the interpolated spectrum
*         iMaxHarm        - maximum number of harmonics in fpAmpInt
*
* Output: pfAmpInt        - the interpolated harmonics
*
* Return:  None.
*
* Modifications:
*
* Comments: The pfAmp vector is zero padded up to iMaxHarm for unused
*             harmonics.
*
*******************************************************************************/
void SpecIntLn( float           fPitch,    float           fPitchInt,  
                int             iIntHarms, const float     *pfAmp,  
                float           *pfAmpInt,  unsigned int    iMaxHarm);


/* HWin.h */
/******************************************************************************
*
* Function:   HammingWindowNormSC()
*
* Action:     Window a signal with a Hamming window.  This window was suppose
*              to have unit area, but the area is really 1.08.  The function
*              is kept around because SC36 codebooks are currently trained
*              on it.
*
* Input:      float *pfX      the input signal
*             int   iLength   the length of the input signal
*
* Output:     float *pfX      the output signal
*
* Globals:    none
*
* Return:     none
******************************************************************************/
void HammingWindowNormSC( float *pfX, int iLength );

/******************************************************************************
*
* Function:   HammingWindowNorm()
*
* Action:     Window a signal with a Hamming window that has unit area.
*
* Input:      float *pfX      the input signal
*             int   iLength   the length of the input signal
*
* Output:     float *pfX      the output signal
*
* Globals:    none
*
* Return:     none
******************************************************************************/
void HammingWindowNorm( float *pfX, int iLength );

/******************************************************************************
*
* Function:   HanningWindowNorm()
*
* Action:     Window a signal with a Hanning window that has unit area.
*
* Input:      float *pfX      the input signal
*             int   iLength   the length of the input signal
*
* Output:     float *pfX      the output signal
*
* Globals:    none
*
* Return:     none
******************************************************************************
*
* Concerns:   The first and the last samples are zeros
*
******************************************************************************/
void HanningWindowNorm( float *pfX, int iLength ); 



/******************************************************************************
*
* Function:   WindowKernel()
*
* Action:     Window a signal (Hamming or Hanning)
*
* Input:      float *x        input signal
*             int   length    length of signal
*             float a         window constant A
*             float b         window constant B
*
* Output:     float *x        output windowed signal
*
* Globals:    none
*
* Return:     none
******************************************************************************/
void WindowKernel(float *x, int length, float a, float b);


/******************************************************************************
*
* Function:  KaiserWindow()
*
* Action:    Compute the Kaiser window coefficients. Only return left side
*            of window.
*
* Input:     fWindow -- pointer for Kaiser window
*            iWindowSize -- the length of full size window
*            fBeta -- the beta factor for Kaiser window.
*
* Output:    fWindow -- the left half side of Kaiser window.
*
* Globals:   none.
*
* Return:    none.
*
*******************************************************************************
*
* Modifications:
*
* Comments: All the normalization should call another function : 
*           NormSymWindowByPower() or NormSymWindowByArea().
*
* Concerns/TBD:
******************************************************************************/ 
void KaiserWindow(float *fWindow, int iWindowSize, float fBeta);

/******************************************************************************
*
* Function:  InitKaiserWindow()
*
* Action:    Allocate memory and compute the Kaiser window coefficients.
*            !!! The array *pfWindow only has the half of the window length.
*
* Input:     pfWindow -- pointer to Kaiser window buffer.
*            iWindowSize -- the length of full size window
*            fBeta -- the beta factor for Kaiser window.
*
* Output:    pfWindow -- the return address of the left side of Kaiser window.
*
* Globals:   none.
*
* Return:    1 : fail to allocate the memory.
*            0:  succeed.
*
*******************************************************************************
* Modifications:
*
* Comments: All the normalization should call another function : 
*           NormSymWindowByPower() or NormSymWindowByArea().
*
* Concerns/TBD:
******************************************************************************/
unsigned short InitKaiserWindow(float **pfWindow, int iWindowSize, float fBeta);

/******************************************************************************
*
* Function:  FreeKaiserWindow()
*
* Action:    Free the Kaiser window memory.
*
* Input:     pfWindow -- pointer to Kaiser window buffer.
*
* Output:    
*
* Globals:   none.
*
* Return:    none
*******************************************************************************/
void FreeKaiserWindow(float **pfWindow);

/* SymWinSp.h */
/*******************************************************************************
* 
* Function: SymWindowSignal()
*
* Action: considering the symmetricity of window, the signal is windowed by 
*         only the half size of window coefficients.
*
* Input:  pIn:    input signal.
*         pWin:   window data (only left half size == ((length+1)>>1)).
*         length: data length.
*
* Output: pOut:   output signal.
*
* Return: None.
*******************************************************************************
* Modifications:
*
* Comments: In-place operation is supported.
*
* Concerns/TBD:
******************************************************************************/
void SymWindowSignal(const float *pIn, const float *pWin, float *pOut,
                      int length);


/* NormWin.h */
/*******************************************************************************
* 
* Function: NormSymWindowByPower()
*
* Action: Normalize the symmetric window by power
*
* Input:  pfWindow: non-normalized window data (either left half or whole size).
*         iWindowSize : the length of window.
*
* Output: pfWindow: normalized window data.
*
* return: None.
*
******************************************************************************/
void NormSymWindowByPower(float *pfWindow, int iWindowSize);

/*******************************************************************************
* 
* Function: NormSymWindowByArea()
*
* Action: Normalize the symmetric window by area function.
*
* Input:  pfWindow: non-normalized window data (either left half or whole size).
*         iWindowSize : the length of window.
*
* Output: pfWindow: normalized window data.
*
* return: None.
*******************************************************************************/
void NormSymWindowByArea(float *pfWindow, int iWindowSize);


#ifdef __cplusplus
}
#endif

#endif /* __VLIBSGPR */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\voxware\vlibsnd.h ===
/*******************************************************************************
*                        Voxware Proprietary Material                          *
*                        Copyright 1997, Voxware, Inc                          *
*                            All Rights Reserved                               *
*                                                                              *
*                       DISTRIBUTION PROHIBITED without                        *
*                      written authorization from Voxware                      *
*                                                                              *
*******************************************************************************/
 
/*******************************************************************************
*
* File:         vLibSnd.h
*
* Purpose:
*
* Functions:
*
* Author/Date:
*******************************************************************************
* Modifications:
*
* Comments:
*
* Concerns:
*
* $Header:   /export/phobos/pvcs/pvcsproj/voxlib.prj/vlibsnd.h_v   1.11   02 Mar 1998 17:41:12   weiwang  $
******************************************************************************/
 
#ifndef __VLIBSND
#define __VLIBSND

#ifdef __cplusplus
extern "C" {
#endif

/* SpCBM.h */
/*******************************************************************************
* 
* Function: InitSpCBM()
*
* Action: initialize a structure containing circular buffer,its total 
*         length & index.
*
* Input:  pvCircMblk  - A structure containing circular buffer,its total 
*                       length & index.
*         iLength  - Length of the structur
*
* Output: pvCircMblk  - The initialised structure 
*
* return: 0: succeed, 1: failed
*
******************************************************************************/
unsigned short InitSpCBM(int iLength, void **pvCircMblk);


/*******************************************************************************
* 
* Function: FreeSpCBM()
*
* Action: free speech circular buffer structure
*
* Input:  pvCircMblk  --  circular buffer structure
*
* Output: pvCircMblk  -- NULL pointer
*
* return: none
*
******************************************************************************/
void FreeSpCBM(void **pvCircMblk);

/*******************************************************************************
* 
* Function: PutFrameSpCBM()
*
* Action: put a frame of speech to a circular buffer 
*
* Input:  pvCircMblk  --  A structure containing circular buffer,its total 
*                         length & index.
*         iOffset     --  the relative distance from the start position for 
*                         putting speech to the circular buffer index.
*                         (in most case just set it to 0)
*         iInLength   -- Number of input data
*         pfInBuff    -- Input data
*
* Output: pvCircMblk  -- update structure pointer
*
* return: none
*
******************************************************************************/
void PutFrameSpCBM( void  *pvCircMblk,  int iOffset,
                    int   iInLength,    const float *pfInBuff );

/*******************************************************************************
* 
* Function: GetFrameSpCBM()
*
* Action: extract speech from a circular buffer 
*
* Input:  pvCircMblk  --  a structure containing circular buffer,its total 
*                         length & index.
*         iDelay      --  the relative distance from the middle position of the
*                         extracting speech to the current circular buffer 
*                         index.
*         iOutLength  --  number of output data
*         pfOutBuff   --  pointer to the output speech
*
* Output: pfOutBuff -- output speech
*
* return: none
*
******************************************************************************/
void GetFrameSpCBM( void *pvCircMblk, int iDelay, int  iOutLength,
                    float *pfOutBuff);

#ifdef __cplusplus
}
#endif

#endif /* __VLIBSND */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\voxware\vlibquan.h ===
/*******************************************************************************
*                        Voxware Proprietary Material                          *
*                        Copyright 1997, Voxware, Inc                          *
*                            All Rights Reserved                               *
*                                                                              *
*                       DISTRIBUTION PROHIBITED without                        *
*                      written authorization from Voxware                      *
*                                                                              *
*******************************************************************************/
 
/*******************************************************************************
*
* File:         vLibQuan.h
*
* Purpose:
*
* Functions:
*
* Author/Date:
*******************************************************************************
* Modifications:
*
* Comments:
*
* Concerns:
*
* $Header:   /export/phobos/pvcs/pvcsproj/voxlib.prj/vlibquan.h_v   1.16   08 Apr 1998 17:44:52   weiwang  $
******************************************************************************/
 
#ifndef __VLIBQUAN
#define __VLIBQUAN

#ifdef __cplusplus
extern "C" {
#endif

/* SQ.h */
/*******************************************************************************
* Function:  ScalarQuant()
*
* Action:    Find index into codebook of the value closest to the
*              input variable.
*
* Input:     fValue:------- Input variable
*            pfCodeBook:--- Codebook valiables
*            iLength:------ Number of valiable in the codebook
*
* Output:    none
*
* Return:    index--------- Index to codebook
********************************************************************************
*
* Modifications:
*
* Comments:
*
* Concerns/TBD:
*******************************************************************************/
int ScalarQuant( float fValue, const float *pfCodeBook, int iLength );

/*******************************************************************************
* Function:  ScalarLUT
*
* Action:    Dequantisation.  Return the peoper valiable according to the
*              index of the codebook
*
* Input:     pfCodeBook:------ Codebook valiables
*            iLength:--------- Number of valiable in the codebook
*            index------------ Index to codebook
*
* Output:    none
*
* Return:    pfCodeBook[index]----chosen variable in the codebook
*******************************************************************************/
float ScalarLUT( const float *pfCodeBook, int iLength, int iIndex);



/* VQ.h */
/*******************************************************************************
* FUNCTION    : VectorQuant()
*
* PURPOSE     : Quantize a vector using trained codebook
*
* INPUT
*    pfVector:    Input vector
*    pfCodeBook:  Codebook vectors
*    iRows:       Dimension of the vector
*    iCBEntries:  Number of entries in the codebook
*
* OUTPUT        None
* RETURN        entry---- Chosen index of the codebook
*******************************************************************************/
int VectorQuant( const float *pfVector, int iRows, const float *pfCodeBook,
                 int iCBEntries );


/*******************************************************************************
* FUNCTION    : VectorLUT()
*
* PURPOSE     : Dequantize a vector from index of the codebook,
*
* INPUT
*    uiIndex:     Chosen index of the codebook
*    pfCodeBook:  Codebook vectors
*                   Codebook vectors are stored in a format of (row * column)
*                   i.e. dimention of component * entries of the codebook
*    iRows:       Dimension of each vector
*    iCBEntries:  Number of bits for the codebook
*
* OUTPUT
*    pfVector:    Chosen vector according to the index
*******************************************************************************/
void VectorLUT( unsigned int uiIndex, const float *pfCodeBook, int iCBEntries,
                int iRows, float *pfVector );
 

/* VQWeight.h */
/*******************************************************************************
* FUNCTION    : WeightedVectorQuant()
*
* PURPOSE     : Weighted vector quantization using a trained codebook
*
* INPUT
*    pfWeights:   Vector of weights
*    pfVector:    Input vector
*    pfCodeBook:  Codebook vectors
*    iRows:       Dimension of the vector
*    iCBEntries:  Number of entries in the codebook
*
* OUTPUT        None
* RETURN        entry---- Chosen index of the codebook
*******************************************************************************/
int WeightedVectorQuant( const float *pfWeights, const float *pfVector,
                         int iRows, const float *pfCodeBook, int iCBEntries );


/* VQ2.h */
/*******************************************************************************
* Function:  Dim2VectorQuantize()
*
* Action:    Encode a 2-dimensional input vector using a 2-D vector quantizer
*            with the straightforward mean squared error (MSE) criterion
*
* INPUT:     pfVector:   --- 2-dimensional input vector
*            pfCodeBook: --- one-dimensional codebook array containing
*                             (2 * iEntries) elements. Codebook vectors
*                             are stored in a format of (row * column)
*                             i.e. dimention of component * entries of
*                             the codebook
*            iEntries:   --- codebook size (number of 2-D codevectors)
*
* OUTPUT:    None
*
* RETURN:    Chosen index of the codebook
*******************************************************************************/
int Dim2VectorQuantize( const float *pfVector, const float *pfCodeBook,
                        int iEntries );

/*******************************************************************************
* Function:  Dim2VectorLUT()
*
* Action:    Decode the codebook index of a 2-dimensional vector quantizer
*
* Input:     iIndex:     --- the index of the selected codevector
*            pfCodeBook: --- one-dimensional codebook array containing
*                             (2 * iEntries) elements
*            iEntries:   --- number of entries in the codebook
*
* Output:    pfVector:   --- decoded 2-dimensional VQ output vector
*
* Author/Date:  Juin-Hwey (Raymond) Chen, June 9, 1997
*
* NOTE: the function VQ2dec() works only for the case of 2-dimensional VQ
*******************************************************************************/
void Dim2VectorLUT( unsigned int iIndex, const float *pfCodeBook,
                    int iEntries, float *pfVector );


#ifdef __cplusplus
}
#endif

#endif /* __VLIBQUAN */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\voxware\vlibtype.h ===
/*******************************************************************************
*                        Voxware Proprietary Material                          *
*                        Copyright 1997, Voxware, Inc                          *
*                            All Rights Reserved                               *
*                                                                              *
*                       DISTRIBUTION PROHIBITED without                        *
*                      written authorization from Voxware                      *
*                                                                              *
*******************************************************************************/
 
/*******************************************************************************
*
* File:          vLibType.h
*
* Purpose:   define variable types
*
* Functions:
*
* Author/Date:
*******************************************************************************
* Modifications:
*
* Comments:
*
* Concerns:
*
* $Header:   /export/phobos/pvcs/pvcsproj/voxlib.prj/vLibType.h_v   1.0   07 Apr 1998 17:58:38   weiwang  $
******************************************************************************/
 
#ifndef __VLIBTYPE
#define __VLIBTYPE

#ifdef __cplusplus
extern "C" {
#endif



#if (defined(WIN32) == 1 || defined(SPARCSTATION) == 1 || defined(IEEE) == 1)
typedef long Uint32;
#else
typedef float Uint32;   /* the trick to undo long to float */
#endif

/* union to do quicker comparison among floating numbers */
typedef union {
  float  f;
  Uint32 l;
} UnionFltLng;


#ifdef _cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\voxware\vlibvec.h ===
/*******************************************************************************
*                        Voxware Proprietary Material                          *
*                        Copyright 1997, Voxware, Inc                          *
*                            All Rights Reserved                               *
*                                                                              *
*                       DISTRIBUTION PROHIBITED without                        *
*                      written authorization from Voxware                      *
*                                                                              *
*******************************************************************************/
 
/*******************************************************************************
*
* File:         vLibVec.h
*
* Purpose:
*
* Functions:
*
* Author/Date:
*******************************************************************************
* Modifications:
*
* Comments:
*
* Concerns:
*
* $Header:   /export/phobos/pvcs/pvcsproj/voxlib.prj/vlibvec.h_v   1.29   07 Apr 1998 18:02:18   weiwang  $
******************************************************************************/
 
#ifndef __VLIBVEC
#define __VLIBVEC

#ifdef __cplusplus
extern "C" {
#endif

/* AutoCor.h */
/*******************************************************************************
*
* Function:  AutoCor()
*
* Action:    Compute autocorrelation sequence.
*
* Input:     int          iOrder   -> number of autocorrelation samples to
*                                       compute
*            const float *pcfVecIn -> input sequence
*            int          iLength  -> length of input sequence
*
* Output:    float *pfVecOut       -> the scaled vector
*
* Globals:   none
*
* Return:    void
*******************************************************************************/
void AutoCor( int iOrder, const float *pcfVecIn, int iLength, float *pfVecOut);

/* DotProd.h" */
/******************************************************************************
*
* Function:  DotProd()
*
* Action:    Calculate the inner product of two vector
*
* Input:     const float *pfVecA  -> 1st input vector
*            const float *pfVecA  -> 2nd input vector
*            int iLength          -> the length of input vectors
*
* Globals:   none
*
* Return:    float fDotProduct    -> the inner product
*******************************************************************************/
float DotProd(const float *pcfVecA, const float *pcfVecB, int iLength);

/* FindMax.h */
/*******************************************************************************
*
* Function:  FindMaxValueFlt()
*
* Action:    Finds the maximum value (and its location) of a floating 
*              point vector.
*
* Input:     *pfX  -> the vector to be scaled
*            iLength -> the length of the vector
*
* Output:    *piMaxIndex -> index of maximum value
*            *pfXmax     -> maximum value
*
* Globals:   none
*
* Return:    void
********************************************************************************
* Modifications: Version 2.0, Originated from Intel NSP Lib
*                Modified by Xiangdong Fu 12/11/96
*
*
* Concerns:    This version is an optimized version on Pentium or IEEE 
*              floating point format machine. It assumes interger
*              comparision is faster than floating point comparision. 
*              This version is 3 times faster than version  1.0 on Pentium.
*              It is proved to work on Sun as well, but not faster(or slower)
*
*              Only float point and long are 32 bits, choose 'IEEE' pre-
*              definition.
*          
* Comments:    Input vector length >= 1
*
*******************************************************************************/
void FindMaxValueFlt( const float *pfX, int         iLength, 
                      int  *piMaxIndex, float       *pfXmax);


/* L2Scale.h */
/******************************************************************************
*
* Function:  L2Scale()
*
* Action:    Perform an L2 scaling of a vector.
*
* Input:     float *pfX       -> the vector to be scaled
*            int iLength      -> the length of the vector
*            float fEnergySqr -> the desired output energy of the vector
*
* Output:    float *pfX       -> the scaled vector
*
* Globals:   none
*
* Return:    void
******************************************************************************/
void L2Scale(float *pfX, int iLength, float fEnergySqr);

/* MagSq.h */
/*******************************************************************************
*
* Function: MagSq()
*
* Action:   Compute magnitude squared of a complex vector
*
* Input:    const float *pcfRe    -> real part of complex vector
*           const float *pcfIm    -> imaginary part of complex vector
*           int    iLength        -> length of vector
*
* Output:   float *pfMagSq        -> magnitude squared of the vector
*
* Globals:  none
*
* Return:   void
*******************************************************************************/
void MagSq(const float *pcfRe, const float *pcfIm, int iLength, float *pfMagSq);


/******************************************************************************
*
* Function: MagSqIL()
*
* Action:   Compute magnitude squared of a inter-leave formatted complex vector
*
* Input:    const float *pcfVec    -> inter-leave complex vector
*           int    iLength        -> length of vector
*
* Output:   float *pfMagSq        -> magnitude squared of the vector
*
* Globals:  none
*
* Return:   void
******************************************************************************/
void MagSqIL(const float *pcfVec, int iLength, float *pfMagSq);


/* oladd.h */
/*******************************************************************************
*
* Function:  OlAdd()
*
* Action:    a generalized trapezoidal overlap-add routine.
*
* Input:     const float *pfFadeOutBuf -> fade-out input buffer
*            const float *pfFadeInBuf  -> fade-in input buffer
*            int    iOverlapLen  -> length of overlap
*            int    iFrameLen    -> length of frame
*
* Output:    float       *pfOutBuf     -> output buffer
*
* Globals:   none
*
* Return:    void
*******************************************************************************
*
*           iFrameLen
* /-------------------------------------\
*               iOverlapLen
*           /-----------------\
*
* ----------\__             __/
*              \__       __/
*                 \__ __/
*                  __X__
*               __/     \__
*            __/           \__
*           /                 \----------
*
*   pfFadeOutBuf
* |---------------------------|
*
*             pfFadeInBuf
*           |---------------------------|
*
********************************************************************************
*
* Modifications: Removed some variables and changed type (short) in call
*                to type (int). Bod Dunn 7/24/97.
*
* Comments: IMPORTANT: this routine ACCUMULATES into the output buffer.  If
*                      needed, the output buffer should be set to zero before
*                      calling this routine.
*
* Concerns/TBD:
*******************************************************************************/
void OlAdd ( const float *pfFadeOutBuf, const float *pfFadeInBuf,
             int iOverlapLen, int iFrameLen, float *pfOutBuf );

/* ScaleVec.c */
/******************************************************************************
*
* Function:  ScaleVector()
*
* Action:    Multiply a vector by a scalar.
*
* Input:     float *pfIn      -> the vector to be scaled
*            int    iLength   -> the length of the vector
*            float  fScalar   -> the desired scale factor
*
* Output:    float *pfOut     -> the scaled vector
*
* Globals:   none
*
* Return:    void
*******************************************************************************
*
* Modifications:
*
* Comments:  In place and out of place operation are supported.
*
* Concerns/TBD:
******************************************************************************/
void ScaleVector( float *pfIn, int iLength, float fScalar, float *pfOut );


#ifdef __cplusplus
}
#endif

#endif /* __VLIBVEC */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\voxware\vocint29.h ===
unsigned char VoxVocInt4kVecRT29(float *F0in,float *Ain,long Hin,float *F0out,float *Aout,long Hout);

float VoxL1Spectrum4kVecRT29(float *F0in,float *Ain,long Hin,float *Gain);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\voxware\vlibtran.h ===
/*******************************************************************************
*                        Voxware Proprietary Material                          *
*                        Copyright 1997, Voxware, Inc                          *
*                            All Rights Reserved                               *
*                                                                              *
*                       DISTRIBUTION PROHIBITED without                        *
*                      written authorization from Voxware                      *
*******************************************************************************/
 
/*******************************************************************************
*
* File:          vLibTran.h
*
* Purpose:
*
* Functions:
*
* Author/Date:
*******************************************************************************
* Modifications:
*
* Comments:
*
* Concerns:
*
* $Header:   /export/phobos/pvcs/pvcsproj/voxlib.prj/vlibtran.h_v   1.36   21 Apr 1998 13:10:22   bobd  $
******************************************************************************/
 
#ifndef __VLIBTRAN
#define __VLIBTRAN

#ifdef __cplusplus
extern "C" {
#endif


/* as2lspe.c */
/*******************************************************************************
* Function:  VoxAsToLspEven()
*
* Action:    Compute LSPs from predictor coefficients for an even ordered
*              all-pole model.
*
* Input:     float *pfAs          --> predictor coefficients
*            int    iOrder        --> all-pole model order
*            float  fScaleFactor  --> scale factor to apply to LSPs (if the
*                                       factor is 1.0, the LSPs range from
*                                       0 to 0.5).
*
* Output:    float *pfLSP         --> LSPs
*
* Globals:   none
*
* Return:    int        (0/1) (success/fail)
********************************************************************************
* Modifications:
*
* Comments:    The inverse filter is defined as:
*
*                      A(Z) = 1 + SUM(i=1...p) A_i Z^(-i)
*
*              The LSPs are normalized in frequency and range
*                from 0 to 0.5.  Since many codecs require LSPs in
*                Hertz, fScaleFactor is included to allow the conversion
*                to Hertz.  If fScaleFactor is the sampling rate, the
*                LPSs will be in Hertz.  If fScaleFactor is 1.0 the LPSs
*                will range from 0 to 0.5.
*
* Concerns/TBD:
*******************************************************************************/
int VoxAsToLspEven( float *pfAs, int iOrder, float fScaleFactor, float *pfLSP );

/* lsp2ase.h */
/*******************************************************************************
* Function:       void VoxLspToAsEven()
*
* Action:         Compute order predictor coefficients from LSPs for
*                   even ordered all-pole models.
*
* Input:          const float *pfLSP        -> LSPs
*                 int          iOrder       -> all-pole model order
*                 float        fScaleFactor -> scale factor to apply to LSPs
*                                               (when multiplied by fScaleFactor
*                                               the LSPs should range from
*                                               0 to 0.5).
*
* Output:         float       *pfAs         -> 10th order predictor coefficients
*                                                where pfAs[0] = A_0 = 1.0
*
* Globals:        none
*
* Return:         void
********************************************************************************
* Modifications:
*
* Comments:    The inverse filter is defined as:
*
*                      A(Z) = 1 + SUM(1...p) A_p Z^(-p)
*
*              The LSPs are normalized in frequency and should range
*                from 0 to 0.5.  Since many codecs require LSPs in
*                Hertz, fScaleFactor is included to allow the conversion
*                from Hertz to normalized frequency.  If the input LSPs are
*                in Hertz, fScaleFactor should be set to one over the
*                sampling rate.  If the LSPs are normalized in frequency
*                (ranging from 0 to 0.5) fScaleFactor should be set to 1.0.
*
* Concerns/TBD:
*******************************************************************************/
void VoxLspToAsEven( const float *pfLSP, int iOrder,
                     float fScaleFactor, float *pfAs );

/* AsToCs.h */
/******************************************************************************
*
* Function:  asToCs()
*
* Action:    Convert the prediction coefficients to cepstrum coefficients
*
* Input:     fGain       -- residual energy in the log domain
*            pfAs        -- prediction coefficients in the format [1 a1 a2 ...]
*            iOrder_As   -- the order of prediction coefficients
*                             (or the length of pfAs plus 1).
*            pfCs        -- the pointer to the cepstrum coefficients.
*            iLength_Cs  -- the length of pfCs (or the order of cepstrum
*                             coefficients plus 1).
*
* Output:    pfCs     -- the output cepstrum coefficients
*
* Globals:   none
*
* Return:    void
*******************************************************************************
*
* Comments:     The format for pfAs[] is:
*                  A(z) = 1 + SUM(1...p) a_p z^(-p) where pfAs[0]=1.
*
******************************************************************************/
void VoxAsToCs( const float fGain, const float *pfAs, const int iOrder_As,
                float *pfCs, const int iLength_Cs);

/* AsToKs.c */
/******************************************************************************
*
* Function:  AsToKs()
*
* Action:    Convert the prediction coefficients (LPC) to
*              reflection coefficients.
*
* Input:     pfAS[] -> predictor coefficients
*            iOrder -> all pole model order
*
* Output:    pfKS[] -> reflection coefficients
*
* Globals:   none
*
* Return:    iClipFlag (1 for clipped pfKS[], 0 otherwise)
*******************************************************************************
*
* Comments:     This recursion for computing the reflection coefficients
*                 can become unstable in single precision floating point
*                 when the magnitude of a reflection coefficient gets close
*                 to 1.  If this happens, the magnitude of one or more
*                 reflection coefficients will be set to
*                 KS_OVERFLOW_THRESHOLD and iClipFlag will be set to 1.
*
*               The format for pfAs[] is:
*                  A(z) = 1 + SUM(1...p) a_p z^(-p) where pfAs[0]=1.
*
* Concerns/TBD: (1) Need scratch memory at least 2*MAX_LPC_ORDER-1
******************************************************************************/
int AsToKs( const float *pfAS, float *pfKS, int iOrder);

/* CsToEnv.h */
/******************************************************************************
*
* Function:  VoxCsToEnv()
*
* Action:    Compute the cepstral log-amplitude and phase envelopes (using
*            interleave-formated FFT)
*
* Input:     float *pfCs           --> Cepstral coefficients
*            int iOrderCepstral    --> number of Cepstral coefficients
*            int loglfft           --> Log (base 2) of FFT length
*
* Output:    float *pfSW           --> interleaved output array. The real part
*                                          (odd indices) is the Log (base 2)
*                                          magnitude of spectrum (0 to lfft/2)
*                                          The imaginary part (even indices)
*                                          is the unwrapped phase (in radians)
*                                          of spectrum (0 to lfft/2). The length
*                                          of *pfSW must be (1<<loglfft)+2).
*
* Globals:   none
*
* Return:    void
*******************************************************************************/
void VoxCsToEnv( const float *pfCs,  int    iOrderCepstral, 
                 int    loglfft,     float       *pfSW);


/* DeMltplx.h */
/*******************************************************************************
*
* Function:  VoxDeMultiplex()
*
* Action:    Demultiplex the real and imaginary part of the spectrum
*
* Input:     const float *pfSW    --> interleaved spectrum
*            int          iLength --> length of output arrays
*
* Output:    float *pfRE          --> real part of spectrum
*            float *pfIM          --> imaginary part of spectrum
*
* Globals:   none
*
* Return:    void
*******************************************************************************/
void VoxDemultiplex( const float *pfSW, float *pfRE, float *pfIM, int iLength);

/* fft_cent.h */
/******************************************************************************
*
* Function:  VoxFftCenter()
*
* Action:    Compute the FFT of a REAL signal with the signal centered at
*              FFT sample 0.  Calculate the real FFT using inter-leaved
*              formated FFT.
*
* Input:     pfSig     -- input signal buffer
*            iLength   -- the length of the input signal
*            pfSW      -- pointer to the output spectrum (need length N+2)
*            iFFTorder -- the order of FFT
*
* Output:    pfSW      -- output spectrum (inter-leaved)
*
* Globals:   none
*
* Return:    void
*******************************************************************************
*
* Concerns: If pfSig and pfSW share the same buffer, their lengths must
*           satisfy the condition:  iNfft - iLength >= (iLength>>1)
******************************************************************************/
void VoxFftCenter( const float *pfSig, int          iLength,
                   float *       pfSW, int           iFFTorder);

/* FHTkrnl.h */
/******************************************************************************
*
* Function:  VoxFHTkrnl()
*
* Action:    A fast harmonic sum of sinusoids algorithm (the fastest 
*            known to mankind as of 10/22/96 :-) ).
*            Returns a single pitch cycle of speech
*
* Input:     pfAmps       - array of harmonic amplitudes
*            piPhaseIndex - array of harmonic phase indexes (indexes into
*                             pfSinTbl[] and pfCosTbl[])
*            iHarm        - number of harmonics for synthesis
*            pfSig        - pointer to buffer for speech accumulation
*            iFFTorder    - the FFT order for FHT
*            pfFHTWeights - table of FHT weights
*            pfSinTbl     - pointer to sine table
*            pfCosTbl     - pointer to cosine table
*
* Output:    pfSig        - single pitch cycle of speech.
*
* Globals:   none
*
* Return:    void
*******************************************************************************
*
* Modifications: remove scaling factor at end
*
* Comments:
*
* Concerns/TBD: For speed, this routine currently uses table 
*               lookup for the sine and cosine of the phase.
*               The table size is variable and the phase indexes
*               are assumed to be within the table's limits.
*
*               For inter-leaved formatted inverse FFT, the size for pfSig has 
*               to be (1<<iFFTorder)+2.
*
******************************************************************************/

void VoxFHTkrnl( const float *pfAmps, 
                 const int   *piPhaseIndex, 
                 int   iHarm,    
                 float   *pfSig, 
                 int   iFFTorder, 
                 const float *pfFHTWeights,
                 const float *pfSinTbl,
                 const float *pfCosTbl);

/* K2ASK.h */
/******************************************************************************
*
* Function:  K2ASK()
*
* Action:    Convert reflection coefficients to Arcsin reflection coefficients.
*
* Input:     iLPCorder -- the order or the length of the coefficients.
*            pfk       -- reflection coefficients.
*            pfASK     -- the pointer for the output Arcsin reflection 
*                           coefficients.
*
* Output:    pfASK     -- Arcsin reflection coefficients 
*
* Globals:   none
*
* Return:    void
*******************************************************************************/
void K2ASK (int iLPCorder, const float *pfk, float *pfASK);


/******************************************************************************
*
* Function:  ASK2K()
*
* Action:    Convert Arcsin reflection coefficients to reflection coefficients.
*
* Input:     iLPCorder -- the order or the length of the coefficients.
*            pfASK     -- Arcsin reflection coefficients.
*            pfk       -- the pointer for the output reflection coefficients.
*
* Output:    pfk       -- reflection coefficients 
*
* Globals:   none
*
* Return:    void
*******************************************************************************/
void ASK2K (int iLPCorder, const float *pfASK, float *pfk);


/* KsToAs.h */
/******************************************************************************
*
* Function:  VoxKsToAs()
*
* Action:    Convert the reflection coefficients to prediction
*              coefficients (LPC).
*
* Input:     pfKS        -- the input reflection coefficients.
*            pfAS        -- the pointer for the output LPC coefficients.
*            iOrder      -- the order of both reflection coefficients and LPCs.
*
* Output:    pfAS     -- the output prediction coefficients.
*
* Globals:   none
*
* Return:    void
*******************************************************************************
*
* Comments:     The format for pfAs[] is:
*                  A(z) = 1 + SUM(1...p) a_p z^(-p) where pfAs[0]=1.
*
* Concerns/TBD: (1) Need scratch memory at least MAX_LPC_ORDER+1 (19).
*
******************************************************************************/
void VoxKsToAs( const float *pfKS, float *pfAS, int iOrder);

/* RealFFT.h */

#ifndef WIN32

/******************************************************************************
*
* Function:  RealFft()
*
* Action:    Fast-conversion of real signal to conjugate-symmetric spectrum.
*            The output is inter-leaved.
*
*            float *pfInOut        --> pfInOut real signal/output complex signal
*            int    log2N          --> the order for FFT
*
* Globals:   none
*
* Return:    void
*******************************************************************************
*
* Modifications:
*
**          - This is the umbrella function. It calls out the other functions
**          that do the actual work.
**          - Frequency domain signal is interleaved, and has 2 extra locations.
**          See data format discussion above for more info.
**          - "Packing" algorithm, based on manipulating the output of
**          a complex FFT of half the size of the real FFT.
**          Not the most efficient algorithm, but good by most standards.
* Comments:  pfInOut length N and output length N+2.
*
* Concerns/TBD: 
******************************************************************************/
void RealFft(float *pfInOut, int log2N);

/******************************************************************************
*
* Function:  RealInverseFft()
*
* Action:    Fast-conversion of conjugate-symmetric spectrum to real signal.
*            The pfInOut is inter-leaved.
*
*            float *pfInOut        --> pfInOut conjugate-symmetric spectrum
*                                      output real time signal
*            int    log2N          --> the order for FFT
*            int    iFlags         --> controls special functions
*
* Globals:   none
*
* Return:    void
*******************************************************************************
*
* Modifications:
*
**          - This is the umbrella function. It calls out the other functions
**          that do the actual work.
**          - Frequency domain signal is interleaved, and has 2 extra locations.
**          See data format discussion above for more info.
**          - "Packing" algorithm, based on manipulating the output of
**          a complex FFT of half the size of the real FFT.
**          Not the most efficient algorithm, but good by most standards.
*
* Comments:  pfInOut length N+2 and output length N.
*
* Concerns/TBD: 
******************************************************************************/
void RealInverseFft(float *pfInOut, int log2N, int iFlags);
#endif

#ifdef WIN32
typedef struct _SCplx 
{
    float        re;
    float        im;
} SCplx;

#define NSP_Forw         1
#define NSP_Inv          2
#define NSP_Init         4
#define NSP_NoScale      8
#define NSP_NoBitRev    16
#define NSP_InBitRev    32
#define NSP_OutBitRev   64
#define NSP_OutRCPack  128
#define NSP_OutRCPerm  256
#define NSP_InRCPack   512
#define NSP_InRCPerm  1024
#define NSP_RADIX     4096

#define  FFT_OrderSplit          11       /* max order for split algorithm  */

void vox_nspsRealFft(float *samps,int order, int flags);
void vox_nspsCcsFft(float *samps,int order, int flags);
void vox_nspcFft( SCplx *samps, int order,int flags);

void nspFreeFftResources();

#define P5_OPT    0
#endif

/***********************************************************************
*
* Macros to combine the RealFft(), RealInverseFft and NSP FFTs 
*
***********************************************************************/
#ifdef WIN32
#define VoxRealFft(pfInOut, log2N)   vox_nspsRealFft(pfInOut, log2N, NSP_Forw)
#define VoxRealInverseFft(pfInOut, log2N, flags)  \
                                     vox_nspsCcsFft(pfInOut, log2N, flags)
#define IFFT_NO_SCALE_FLAG            NSP_NoScale  /* 8 */
#define IFFT_SCALE_FLAG               NSP_Inv      /* 2 */

#else
#define VoxRealFft(pfInOut, log2N)   RealFft(pfInOut, log2N)
#define VoxRealInverseFft(pfInOut, log2N, flags)   \
                                     RealInverseFft(pfInOut, log2N, flags)
#define IFFT_NO_SCALE_FLAG            8      /* consistent with NSP library */
#define IFFT_SCALE_FLAG               2      /* consistent with NSP library */
#endif

#ifdef __cplusplus
}
#endif

#endif /* __VLIBTRAN */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\voxware\vmframes.h ===
/******************************************************************************
 *                                                                            *
 *		                  Voxware Proprietary Material                          *
 *		                  Copyright 1996, Voxware, Inc.                         *
 *		                       All Rights Resrved                               *
 *                                                                            *
 *		                 DISTRIBUTION PROHIBITED without                        *
 *		               written authorization from Voxware                       *
 *                                                                            *
 ******************************************************************************/

/******************************************************************************
 *                                                                            *
 * FILENAME:  vmFrames.h                                                      *
 * PURPOSE:   Defines the interface functions for vmFrames.c                  *
 * AURTHOR:   Epiphany Vera                                                   *
 *                                                                            *
 *****************************************************************************/

/******************************************************************************
 *                                                                            *
 *                          DETAILED REVISION HISTORY                         *
 *                                                                            *
 * (March 24, '97)                                                            *
 *    Created                                                                 *
 *                                                                            *
 *****************************************************************************/

void framesInBufferFixed(const VCI_CODEC_IO_BLOCK  *hvciCodecIOBlk,
                         short               PacketBits,
                         unsigned short      *pwNumFrames);
void seekForwardFixed(unsigned short ReadByteOffset,
                      unsigned char  ReadBitOffset,
                      unsigned short BufferSize,   unsigned short PacketBits,
                      unsigned short wNumFrames,   unsigned short *pwByteOffset,
                      unsigned char  *pchBitOffset);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\voxware\vlibspch.h ===
/*******************************************************************************
*                        Voxware Proprietary Material                          *
*                        Copyright 1997, Voxware, Inc                          *
*                            All Rights Reserved                               *
*                                                                              *
*                       DISTRIBUTION PROHIBITED without                        *
*                      written authorization from Voxware                      *
*                                                                              *
*******************************************************************************/
 
/*******************************************************************************
*
* File:         vLibSpch.h
*
* Purpose:
*
* Functions:
*
* Author/Date:
*******************************************************************************
* Modifications:
*
* Comments:
*
* Concerns:
*
* $Header:   /export/phobos/pvcs/pvcsproj/voxlib.prj/vlibspch.h_v   1.32   02 Mar 1998 17:41:14   weiwang  $
******************************************************************************/
 
#ifndef _VLIB_VLIBSPCH
#define _VLIB_VLIBSPCH

#ifdef __cplusplus
extern "C" {
#endif

/* BandExpd.h */
/*******************************************************************************
*
* Function: BandExpand()
*
* Input:  pIn:            pointer of the input LPC coefficients.
*         iLPCOrder:      order of the LPC coefficients.
*         fExpandCoeff:   expandion coefficient.
*
* Output: pOut:           pointer of the output LPC coefficients.
*
* We define A(z) as:
*
*               A(z) = 1 + SUM(k=1...p) a_k * z^(-k)
* output is, 1, a[1], a[2]....
*******************************************************************************/
void BandExpand( const float *pIn, float *pOut, int iLPCOrder,
                 float fExpandCoeff );


/* VoxDurb.h */
/*****************************************************************************
 * Function: VoxCalcDurbin()
 *
 * Input:  pAutoCorr:     auto-correlation buffer.
 *         iLpcOrder:      LPC order.
 *
 * Output: pLPCoef:       LPC coefficients.
 *         pfPARCOR:      Partial Correlation (reflection) coefficients.
 *         pResidueEng:   residue energy.
 * Return:  None.
 * We define A(z) as:
 *
 *               A(z) = 1 + SUM(k=1...p) a_k * z^(-k)
 * output is, 1, a[1], a[2]....
 ****************************************************************************/
void VoxDurbin( const float *pAutoCorr, int iLpcOrder, float *pfLPCoef,
                float *pfPARCOR, float *pfResidEnrg );

 
/* PeakPick.h */
/*******************************************************************************
* FUNCTION    : PeakPick()
*
* PURPOSE     : Pick peaks from a segment of an array of floats
*
* INPUT
*      pfMag      - segment of an array of floating point magintudes
*      iStart     - starting index of the segment
*      iStop      - ending index of the segment
*      iMaxPeaks  - maximum number of peaks to be picked
*
* OUTPUT
*      piPeakFreq - indices of peaks
*      piNPeaks   - number of peaks
*
* RETURN          None
*******************************************************************************/
void PeakPick( const float *pfMag, int iStart, int iStop, int iMaxPeaks,
               int *piPeakFreq, int *piNPeaks );


/* quadPeak.h */
/******************************************************************************
*
* Function:  QuadraticPeak()
*
* Action:    Compute the interpolated peak value using quandratic interpolation.
*
* Input:     fY_1, fY0, fY1 -- the output of three continuous indices 
*            pfYpeak -- the pointer to the output peak value
*
* Output:    pfYpeak -- output of the interpolated peak
*
* Globals:   none
*
* Return:    the index for the interpolated peak which is between -1 to 1.
*******************************************************************************
*
* Modifications:
*
* Comments:     (1) Need fY0 >= fY_1 and fY0 >= fY1 to get meaningful value.
*               (2) The output fXpeak is relative value to X0.
*
* Concerns/TBD: 
*
******************************************************************************/
float QuadraticPeak(float  fY_1, float fY0, float fY1, float *pfYpeak);
#ifdef __cplusplus
}
#endif

#endif /* _VLIB_VLIBSPCH */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\voxware\vmenglev.h ===
/******************************************************************************
 *                                                                            *
 *		                  Voxware Proprietary Material                        *
 *		                  Copyright 1996, Voxware, Inc.                       *
 *		                       All Rights Resrved                             *
 *                                                                            *
 *		                 DISTRIBUTION PROHIBITED without                      *
 *		               written authorization from Voxware                     *
 *                                                                            *
 ******************************************************************************/

/******************************************************************************
 *                                                                            *
 * FILENAME:  vmEngLev.h                                                       *
 * PURPOSE:   Calculates the energy in the last frame compressed                *
 * AUTHOR:    Ilan Berci 03/97                                                   *
 *                                                                            *
 *****************************************************************************/

#ifndef VMENGLEV_H
#define VMENGLEV_H

#ifndef _VCI_RETCODE_
#define _VCI_RETCODE_
typedef unsigned short VCI_RETCODE; /* Voxware Core Interface error type.     */
                                    /* This variable is also defined in       */
                                    /* vciError.h.                            */
#endif  /** #ifndef _VCI_RETCODE_ **/



float EnergyToLevel(float Energy);
float LevelToEnergy(float Level);

#endif /* VMENGLEV_H */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\voxware\voicdeci.c ===
/*******************************************************************************
*                        Voxware Proprietary Material                          *
*                        Copyright 1996, Voxware, Inc                          *
*                            All Rights Reserved                               *
*                                                                              *
*                       DISTRIBUTION PROHIBITED without                        *
*                      written authorization from Voxware                      *
*******************************************************************************/

/*******************************************************************************
* Filename:       VoicDeci.c                                                              
*                                                                              
* Purpose:        voice probability calculation                                                                     
*                                                                              
* Functions:      VOXErr VoxVocDecision(const int LL, const float Prr, 
*                                       void *Voicing_mblk, float *pPv);                                                             
*                                                                              
* Author/Date:                                                                 
********************************************************************************
* Modifications:Ilan Berci/ 10/96 Removed global dependencies
*                                 Modularized code segments (Encapsulation)
*                                 Removed scope changes
*                                 Changed error code procedure
*                                 Removed useless code segments
*                                 General optimization                                                                 
*                                                                              
* Comments:                                                                    
* 
* Concerns:
*
* $Header:   /export/phobos/pvcs/r_and_d/archives/realtime/encode/VoicDeci.c_v   1.4   01 Dec 1998 12:07:14   zopf  $
*******************************************************************************/
#include <stdio.h>


#include <math.h>
#include <assert.h>
#include <stdlib.h>

#include "VoxMem.h"
#include "model.h"
#include "research.h"
#include "GetnHarm.h"

#include "VoicDeci.h"

#include "xvocver.h"

/** PDA structure **/
typedef struct
{
  /**** for pitch refinement and voicing *****/
  /***** static memories ******/
  short *prev_vuv;          /** previous voice/unvoice decision -- 60 (in voice decision) **/
  float Zmax;             /** maximum energy of long term (Zmax) **/
  void *myVAD_mblk;
  float P_v;               /** previous Pv **/
} Voicing;


#define MINCON         1.0e-6F    /* minimum constant */

/*******************************************************************************
* Function:      VOXErr VoxVocDecision(const int LL, const float Prr, 
*                                       void *Voicing_mblk, float *pPv);
*
* Action:         voice probability calculation
*
* Input:
*
* Output:
*
* Globals:        none
*
* Return:		  VOXErr : Voxware return code
********************************************************************************
* Implementation/Detailed Description:
*
* References:
********************************************************************************
* Modifications:
*
* Comments:
*
* Concerns/TBD:
*******************************************************************************/
unsigned short VoxVocDecision(const float fPitch, void *Voicing_mblk, float *pPv, 
                      float *pPower, float *pBandErr, unsigned int uiWinLen, short *Class)
{
  Voicing *pVoicing_mblk = (Voicing *)Voicing_mblk;
  float fNormScale;
  int i;
  float fLowBandEng, fHighBandEng, fTotalEng;
  float Pv;
  float fMaxEng = pVoicing_mblk->Zmax;
  float fBiasEng, fBiasL2H, fBiasP0, fBiasAll;
  float fThrdDelta;
  float fThreshold;
  short *iPrevVUV = pVoicing_mblk->prev_vuv;
  float fPrevPv = pVoicing_mblk->P_v;
  int iVHarm;
  unsigned short iClass=*Class;
  float Z02Zmax, Zlf2Zhf, M;
  int NHarm;

  /*************************************************************
    get number of harmonics 
    ************************************************************/
  NHarm = getnHarm(fPitch);

  /*************************************************************
    calculate energy 
    ************************************************************/
  fNormScale = 1.0F / ((float)NFFT_2 * (float)uiWinLen);

  fLowBandEng = MINCON;
  for (i = 0; i < NFFT_4; i++)  fLowBandEng += *pPower++;
  fLowBandEng *= fNormScale;

  fHighBandEng = MINCON;
  for (; i < NFFT_2; i++)   fHighBandEng += *pPower++;
  fHighBandEng *= fNormScale;

  fTotalEng = fLowBandEng + fHighBandEng;   /* leave for VAD */
  
  if (fTotalEng < MINCON) 
    Pv = 0.0F;
  else {
    /*************************************************************
      calculate the bias for voicing threshold 
      ************************************************************/
    /* Ratio related to maximum energy. For a low energy, voicing decision
       tends to unvoice. But this parameter seems have very little influence 
       to voicing calculation. */
    if (fTotalEng > fMaxEng)
      fMaxEng = 0.5F*(fTotalEng+fMaxEng);
    else
      fMaxEng = fMaxEng+0.01F*(fTotalEng-fMaxEng);

    if (fMaxEng > 40000.0F)          /* this energy is too small */
      fMaxEng = 40000.0F;

    fBiasEng = (0.005F*fMaxEng + fTotalEng)/(0.01F*fMaxEng+fTotalEng);

    /* ratio related to low band energy to high band energy. If high band
       energy is too high compare to low band energy, the speech is noise-like.
       However, this condition can never be over-used, because it also depends 
       on the channel condition. */
    fBiasL2H = (float)sqrt(fLowBandEng / (5.0F*fHighBandEng));
    if (fBiasL2H > 1.0F) fBiasL2H = 1.0F;
    

    /* ratio related to pitch value. When pitch is too large, the spectrum is 
       too smeared. It's due to bandwidth of harmonics is smaller than the window 
       bandwidth. For Kaiser window with beta = 6.0, the window bandwidth is 
       around 8. So I simplified the condition to: */
    fBiasP0 = 65.0F/fPitch;
    if (fBiasP0 > 1.0F) fBiasP0 = 1.0F;

    fBiasAll = fBiasP0 * fBiasL2H * fBiasEng;

    /* now we can make the decision based on the each harmonics */
    /* still use Suat's decision in this release until I find out
       more sophisticate classifier and threshold */
    fThrdDelta = fBiasAll * (float)CONSTANT4PV / fPitch;
    iVHarm = 0;
    for (i = 0; i < NHarm; i++) {
      fThreshold = fBiasAll - fThrdDelta * (float)i;
      /* make the threshold adaptive to previous decision */
      if(fPrevPv >= 0.85F) fThreshold *= 0.95F;
      else if (iPrevVUV[i]==1&&fPrevPv>=0.65F) fThreshold *= 0.9F;
      else if (iPrevVUV[i]==1&&fPrevPv>=0.5F)  fThreshold *= 0.85F;
      else if (iPrevVUV[i]==1)  fThreshold *= 0.75F;
      else     fThreshold *= 0.65F;

      /* make the decision by comparing the threshold and band error */
      if ( pBandErr[i] < fThreshold) {
	iPrevVUV[i] = 1;
	iVHarm ++;
      }
      else {
	iPrevVUV[i] = 0;
      }
    }

    for (; i < MAXHARM; i++)
      iPrevVUV[i] = 0;

    assert(NHarm > 0);
    

    Pv = getPv((short)iVHarm, (short)NHarm);   /* Pv=(float)((int)(iVHarm*NFFT/fPitch+0.5F))/(0.93F*NFFT_2); */

    /*************************************************************
      use Suat's decision
      ************************************************************/
    Z02Zmax = fTotalEng/fMaxEng;
    Zlf2Zhf = fLowBandEng/fHighBandEng;
    M = fBiasL2H * fBiasEng;
    if((Z02Zmax<0.0001F) ||
       (Z02Zmax<0.0005F && Zlf2Zhf<150.0F) ||
       (Z02Zmax<0.0012F && Zlf2Zhf<20.0F) ||
       (Z02Zmax<0.021F  && Zlf2Zhf<1.27F && M<0.35F && fPrevPv==0.0F) ||
       (Z02Zmax<0.02F   && Zlf2Zhf<1.13F && M<0.22F && fPrevPv==0.0F) ||
       (Z02Zmax<0.02F   && Zlf2Zhf<1.13F && M<0.28F && fPrevPv<0.12F) ||
       (Z02Zmax<0.023F  && Zlf2Zhf<1.0F  && M<0.19F && fPrevPv<0.12F) ||
       (Z02Zmax<0.041F  && Zlf2Zhf<0.3F  && M<0.15F && fPrevPv==0.0F) ||
       (Z02Zmax<0.115F  && Zlf2Zhf<0.62F && M<0.34F && fPrevPv==0.0F && fPitch>100.0F) ||
       (Z02Zmax<0.043F  && Zlf2Zhf<2.1F  && M<0.58F && fPrevPv==0.0F && fPitch>110.0F))
      {
	Pv=0.0F;
      }

    /*************************************************************
      use voicing activity classifier to find silence frames
      ************************************************************/
    if (iClass == 0) 
    {
      Pv = 0.0F;
    }
  }


  /*************************************************************
    save all the condition.
    ************************************************************/
  if (Pv == 0.0) {
    for (i = 0; i < MAXHARM; i++)
      iPrevVUV[i] = 0;
  }

  pVoicing_mblk->P_v = Pv;

  *pPv = Pv;

  pVoicing_mblk->Zmax = fMaxEng;

  pVoicing_mblk->P_v = Pv;

  return 0;
}

/*******************************************************************************
* Function:       VOXErr VoxInitVoicing(Voicing *myVoicing_mblk)
*
* Action:         initializes Voicing structure
*
* Input:
*
* Output:
*
* Globals:        none
*
* Return:	  VOXErr : Voxware return code
********************************************************************************
* Implementation/Detailed Description:
*
* References:
********************************************************************************
* Modifications:
*
* Comments:
*
* Concerns/TBD:
*******************************************************************************/
unsigned short VoxInitVoicing(void **Voicing_mblk)
{
  Voicing *myVoicing_mblk;
  /***** temporary memories *****/
  if(VOX_MEM_INIT(myVoicing_mblk=*Voicing_mblk,1,sizeof(Voicing))) 
      return 1;

  if(VOX_MEM_INIT(myVoicing_mblk->prev_vuv,MAXHARM,sizeof(short))) {
     VOX_MEM_FREE(myVoicing_mblk);
     return 1;
  }

  myVoicing_mblk->Zmax = 1000000.0F;    /*  was 20000.0 */
  myVoicing_mblk->P_v = 0.0F;

  return 0;

} /* initPDA() */

/*******************************************************************************
* Function:       VOXErr VoxFreeVoicing(Voicing *myVoicing_mblk)
*
* Action:         free's Voicing structure
*
* Input:
*
* Output:
*
* Globals:        none
*
* Return:         VOXErr : Voxware return code
********************************************************************************
* Implementation/Detailed Description:
*
* References:
********************************************************************************
* Modifications:
*
* Comments:
*
* Concerns/TBD:
*******************************************************************************/
unsigned short VoxFreeVoicing(void **hVoicing_mblk)
{
  Voicing *myVoicing_mblk=(Voicing*)*hVoicing_mblk;

  if (*hVoicing_mblk) {
    VOX_MEM_FREE(myVoicing_mblk->myVAD_mblk);

    VOX_MEM_FREE(myVoicing_mblk->prev_vuv);

    VOX_MEM_FREE(*hVoicing_mblk);
  }
  return 0;

} /* freeVoicing() */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\voxware\voicing.c ===
/*******************************************************************************
*                        Voxware Proprietary Material                          *
*                        Copyright 1996, Voxware, Inc                          *
*                            All Rights Reserved                               *
*                                                                              *
*                       DISTRIBUTION PROHIBITED without                        *
*                      written authorization from Voxware                      *
*******************************************************************************/

/*******************************************************************************
* Filename:       Voicing.c
*                                                                              
* Purpose:        Single-band voicing probability calculation
*                 using the peaks out of the square-law nonlinearity 
*                                                                              
* Functions:      VoxSTCVoicing()
*                 ModifyPv()
*
* Author/Date:    Bob McAulay, 11/10/96                     
********************************************************************************
* Modifications:Ilan Berci/ 10/96 
*                 ModifyPv() added by Wei Wang
*                                                                              
* Comments:                                                                    
* 
* Concerns:
*
* $Header:   /export/phobos/pvcs/r_and_d/archives/scaleable/pea/Voicing.c_v   1.5   07 Jul 1998 18:10:12   bobd  $
*******************************************************************************/
#include <stdlib.h>
#include <math.h>
#include <assert.h>
#include <limits.h>
#include <string.h>

#include "vLibMath.h"
#include "vLibVec.h"

#include "VoxMem.h"
#include "codec.h"
#include "Voicing.h"
#include "Compress.h"
#include "Seevoc.h"
#include "RefineC0.h"
#include "SqLawPks.h"

#include "xvocver.h"


#define PV_BANDEDGE     (int)(1350.0*HZ2DFT)   /***** cut off at 1350 Hz ******/
#define MIN_PV_HARM     5                      /***** will be change to 4 *****/
#define MIN_QPV         0.071428572F           /***** 0.5/7               *****/

/*------------------------------------------------------
  The cutoff is 2500 Hz.  Be careful when changing this
    value.  The value of fCutOffBand sets an upper bound 
    on the value of fBaseBand, and in the code below
    we assume that round(fBaseBand)+1 is less than or
    equal to NFFT.
------------------------------------------------------*/
static const float fCutOffBand = (float) ((NFFT*5)>>4);

static float ComputePv( float fdBmin,
                        float fdBmax,
                        float fRho
                      );

/******************************************************************************
*
* Function:
*
* Action: 
*
* Input: 
*
* Output:
*
* Globals:
*
* Return: 
*******************************************************************************
*
* Implementation/Detailed Description:
*
* References:
*******************************************************************************
*
* Modifications:
*
* Comments:
*
* Concerns/TBD:
******************************************************************************/
void VoxSTCVoicing( STACK_R 
                    float *pfPv_km1, 
                    float *pfSeevocEnv, 
                    float *pfPitchPeriod, 
                    float *pfPv, 
                    float *pfPeakPwr, 
                    float *pfPeakFrq, 
                    int    iPeakCount
                  )
{
  int j, k, iIndex;
  int iBaseBand, iBasePeakCount, NuPeaks;

  float fCoarsePitchDFT, ratio;
  float LoBandEdge, fBaseBand, NuEnergy;
  float fRhoRefined, fRefinedPitchPeriod, fCoarsePitchPeriod;
  float fTemp,fdBmin, PvLastTime, PvFinal;
  float fMaxMagSq;

   /*-----------------------------------------------------------------
     Compute the band edges in DFT points 
   -----------------------------------------------------------------*/
   fCoarsePitchPeriod = *pfPitchPeriod;
   fCoarsePitchDFT = (float)NFFT/ fCoarsePitchPeriod;

   iBasePeakCount = VoxFLOOR((PV_BANDEDGE/(float)NFFT)*fCoarsePitchPeriod);
   if(iBasePeakCount < MIN_PV_HARM)
      iBasePeakCount = MIN_PV_HARM;


   fBaseBand = (iBasePeakCount + 0.125F)*fCoarsePitchDFT;  /** was 0.5F **/
   if (fBaseBand > fCutOffBand)                /***** extend to 2500.0Hz *****/
     fBaseBand = fCutOffBand;

  
   VoxROUND2pos(fBaseBand, iBaseBand);

   /*-----------------------------------------------------------------
     Here we add 1 to iBaseBand.  The peaks to be used are
       0 through round(fBaseBand), including 0 and round(fBaseBand).
       Since we include both endpoints, the value of iBaseBand should 
       be round(fBaseBand)+1.
   -----------------------------------------------------------------*/
   iBaseBand++;
   assert( iBaseBand <= NFFT );

   /*-----------------------------------------------------------------
     Compute the number of baseband peaks 
   -----------------------------------------------------------------*/
   for (k = 0; k < iPeakCount; k++)
   {
      if (pfPeakFrq[k] > fBaseBand)
            break;
   }
   iBasePeakCount = k;

   if (iBasePeakCount>0)
   {
      /*-----------------------------------------------------------------
        Find the maximum magnitude of the baseband peaks and 
          the baseband region of pfSeevocEnv[].
      -----------------------------------------------------------------*/
      FindMaxValueFlt( pfPeakPwr, iBasePeakCount, &k, &fMaxMagSq );
      FindMaxValueFlt( pfSeevocEnv, iBaseBand, &k, &fTemp );
      fMaxMagSq = VoxMAX( fMaxMagSq, fTemp );
   
      /*-----------------------------------------------------------------
        Compress the baseband STFT peaks in place.
      -----------------------------------------------------------------*/
      ScaleAndCompress( pfPeakPwr, iBasePeakCount, fMaxMagSq, pfPeakPwr);
   
      {
         /*-----------------------------------------------------------------
           The length of fFltSee[] only need cover the baseband harmonics.
             We should figure out how to make this array smaller.
         -----------------------------------------------------------------*/
         STACK_INIT
           float  fFltSee[NFFT_2];         /** flattend Seevoc envelope      **/
         STACK_INIT_END
           STACK_ATTACH(float *, fFltSee)
         STACK_START
    
   
         /*-----------------------------------------------------------------
           Compress the baseband magnitude-squared seevoc flattop envelope.
             This operation is done out of place since the seevoc envelope
             will be needed later.
         -----------------------------------------------------------------*/
         ScaleAndCompress( pfSeevocEnv, iBaseBand, fMaxMagSq, fFltSee);
   
         /*-----------------------------------------------------------------
           Suppress the peaks below the compressed flattop envelope
         -----------------------------------------------------------------*/
         for (j = 0; j < iBasePeakCount; j++)
         {
            fTemp = pfPeakFrq[j];
            VoxROUND2pos(fTemp, iIndex);
   
            if(pfPeakPwr[j] < fFltSee[iIndex])
            {
               ratio = pfPeakPwr[j]/fFltSee[iIndex];
               fTemp = ratio*ratio;
               pfPeakPwr[j] *= (fTemp*fTemp);
            }
         }
   
         STACK_END
      }
   
      {
         STACK_INIT
           float  fNuAmp[MAXHARM];
           float  fNuFrq[MAXHARM];
         STACK_INIT_END
           STACK_ATTACH(float *, fNuAmp)
           STACK_ATTACH(float *, fNuFrq)
         STACK_START
   
         /*-----------------------------------------------------------------
           Compute the sine-wave representation of the square-law output 
         -----------------------------------------------------------------*/
         LoBandEdge = SQVOC_LO_EDGE*HZ2DFT;  /** ~850Hz **/
   
         VoxSquareLawPeaks( pfPeakPwr, pfPeakFrq, iBasePeakCount, 
                            LoBandEdge, fNuAmp, fNuFrq, &NuPeaks ); 
   
         /*-----------------------------------------------------------------
           Refine the pitch about the previously estimated value
         -----------------------------------------------------------------*/
         VoxRefineC0(STACK_S fCoarsePitchPeriod, fNuAmp, fNuFrq, NuPeaks, 
                     &NuEnergy, &fRefinedPitchPeriod, &fRhoRefined); 
   
         STACK_END
      }
   } else { /* if (iBasePeakCount>0) */
      /*------------------------------------------------------------
        There are no peaks in the baseband!
      ------------------------------------------------------------*/
      fRefinedPitchPeriod = fCoarsePitchPeriod;
      fRhoRefined         = 0.0;
   } /* end of else for condition: (iBasePeakCount>0) */


   /*-----------------------------------------------------------------
     Compute the coarse pitch voicing probability
   -----------------------------------------------------------------*/
   PvLastTime = *pfPv_km1;
   fdBmin     = DBMID + (DBMIN - DBMID)*PvLastTime;
   PvFinal    = ComputePv (fdBmin, DBMAX, fRhoRefined);
   *pfPv_km1  = PvFinal;

   /*-----------------------------------------------------------------
     Use the refined pitch and voicing 
   -----------------------------------------------------------------*/
   *pfPitchPeriod = fRefinedPitchPeriod;
   *pfPv          = PvFinal;

} /*VoxVoicing()*/

/******************************************************************************
*
* Function:   ComputePv()
*
* Action:     Subroutine to compute the voicing probability
*               according to TFQ's linear-log rule with RJM's added pitch
*               correlation weighting which increases the voicing probablity
*               with an increasing number of pitch correlations
*
* Input: 
*
* Output:
*
* Globals:    none
*
* Return:     none
*******************************************************************************
*
* Implementation/Detailed Description:
*
* References:
*******************************************************************************
*
* Modifications:
*
* Comments:
*
* Concerns/TBD:
******************************************************************************/

static float ComputePv( float fdBmin, 
                        float fdBmax, 
                        float fRho
                      ) 
{
   float fSNRdB;
   float fPv;

   /*-----------------------------------------------------------------
     Check for numerical instabilities
   -----------------------------------------------------------------*/
   if (fRho <= 0.0F)
            fRho = 0.000001F;
   if (fRho >= 1.0F)
            fRho = 0.999999F;
 
   /*-----------------------------------------------------------------
     Convert fRho to dB
   -----------------------------------------------------------------*/
   fSNRdB = -10.0F*(float)log10(1.0F - fRho);          /* SNR in dB */

   /*-----------------------------------------------------------------
     Voicing probability is linear in dB SNR
   -----------------------------------------------------------------*/
   if (fSNRdB < fdBmin)
      fPv = 0.0F;      /* fully unvoiced */

   else if (fSNRdB > fdBmax)
      fPv = 1.0F;      /* fully voiced */

   else 
      /*------------------------------------------------
        if (fSNRdB >= fdBmin && fSNRdB <= fdBmax) 
             (partial voicing)
      ------------------------------------------------*/
      fPv = (fSNRdB - fdBmin)/(fdBmax - fdBmin);

   return( fPv );
} /* ComputePv() */


/******************************************************************************
*
* Function:  ModifyPv()
*
* Action:    Compute a modified voicing probability based on correlation
*              coefficients, current and previous pitch values, and 
*              current and previous voicing probabilities.
*
* Input:     float fCorrCost  --> correlation coefficient
*            float fPv        --> current voicing probability
*            float fPv_1      --> previous voicing probability
*            float fPitch     --> current pitch period
*            float fPitch_1   --> previous pitch period
*
* Output:    none
*
* Globals:   none
*
* Return:    float fPv (the modified voicing probability)
*******************************************************************************
*
* Implementation/Detailed Description:
*
* References:
*******************************************************************************
*
* Modifications:
*
* Comments:
*
* Concerns/TBD:
******************************************************************************/
float ModifyPv( float fCorrCost, 
                float fPv, 
                float fPv_1, 
                float fPitch,
                float fPitch_1
              )
{     
  float fEstPv;

  /*-----------------------------------------------------------------
    If fCorrCost is negative, fPv should be 0.
  -----------------------------------------------------------------*/
  if (fCorrCost <= 0.01F)   /* unvoiced speech */
    fPv = 0.0F;

  /*-----------------------------------------------------------------
    If fCorrCost is large enough and fPv is too small, we have to
      reset fPv to a larger number.
  -----------------------------------------------------------------*/
  if (fCorrCost >= 0.45F)   /* voiced speech */
  {
    fEstPv = fCorrCost - 0.45F;

    if ((fEstPv * (fPitch * 0.5F)) < 1.0F)    /* at least one harmonic */
      fEstPv += MIN_QPV;

    if (fEstPv > fPv)
      fPv = fEstPv;
  }

  /*-----------------------------------------------------------------
    Now smooth the fPv
  -----------------------------------------------------------------*/
  if (fPv_1 > fPv && fPv_1 >= MIN_QPV) 
  {
    if ((fPitch < 1.25F * fPitch_1)&&(fPitch > 0.8F * fPitch_1))
      fPv = 0.7F*fPv + 0.3F*fPv_1;
    
    if (fPv < MIN_QPV)
      fPv += MIN_QPV;
  }
  
  return fPv;

} /* ModifyPv() */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\voxware\voicdeci.h ===
/*******************************************************************************
*                        Voxware Proprietary Material                          *
*                        Copyright 1996, Voxware, Inc                          *
*                            All Rights Reserved                               *
*                                                                              *
*                       DISTRIBUTION PROHIBITED without                        *
*                      written authorization from Voxware                      *
*******************************************************************************/

/*******************************************************************************
* Filename:       VoicDeci.h                                                            
*                                                                              
* Purpose:        voice probability calculation                                                             
*                                                                              
* Author/Date:    Original developped by Suat Yeldener
*                 Integrated by Rob Zopf Sept. 12/95.                                           
********************************************************************************
* $Header:   /export/phobos/pvcs/r_and_d/archives/realtime/encode/VoicDeci.h_v   1.0   26 Jan 1998 10:55:02   johnp  $                                                                     
*******************************************************************************/
#ifndef VOICDECI_H
#define VOICDECI_H

#define CONSTANT4PV           (0.3096F*D_PI)

unsigned short VoxVocDecision(const float fPitch, void *PDA_mblk, float *pPv, 
                      float *pPower, float *pBandErr, unsigned int uiWinLen, short *Class);

unsigned short VoxInitVoicing(void **Voicing_mblk);
unsigned short VoxFreeVoicing(void **hVoicing_mblk);

#endif /* VOICEDECI_H */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\voxware\voicing.h ===
/*******************************************************************************
*                        Voxware Proprietary Material                          *
*                        Copyright 1996, Voxware, Inc                          *
*                            All Rights Reserved                               *
*                                                                              *
*                       DISTRIBUTION PROHIBITED without                        *
*                      written authorization from Voxware                      *
*******************************************************************************/
 
/*******************************************************************************
* Filename:       Voicing.h
*
* Purpose:        Single-band voicing probability calculation
*                 using the peaks out of the square-law nonlinearity
*
* Functions:      VoxSTCVoicing()
*                 ModifyPv()
*
* Author/Date:    Bob McAulay, 11/10/96
********************************************************************************
* Modifications:Ilan Berci/ 10/96
*                 ModifyPv() added by Wei Wang
*
* Comments:
*
* Concerns:
*
* $Header:   /export/phobos/pvcs/r_and_d/archives/scaleable/pea/Voicing.h_v   1.1   11 Apr 1998 15:17:56   bobd  $
*******************************************************************************/

#ifndef _VOICING_H
#define _VOICING_H

#define DBMIN   4.0F             /* unvoiced if SNR < DBMIN...was 4.0 */
#define DBMID   4.5F             /* variable threshold...was 4.5 */
#define DBMAX   13.0F            /*   voiced if SNR > DBMAX */

/* maximum spread for differential frequencies...was 850. */
#define SQVOC_LO_EDGE   850.0F   

void VoxSTCVoicing( STACK_R 
                    float *Pv_km1, 
                    float *pfLogSeeEnv,
                    float *pfPitchPeriod, 
                    float *Pv,
                    float *PeakPwr, 
                    float *PeakFrq, 
                    int    iPeakCount
                  );

float ModifyPv( float fCorrCost, 
                float fPv, 
                float fPv_1, 
                float fPitch,
                float fPitch_1
              );

#endif  /* _VOICING_H*/
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\voxware\voicld.h ===
/*******************************************************************************
*                        Voxware Proprietary Material                          *
*                        Copyright 1997, Voxware, Inc                          *
*                            All Rights Reserved                               *
*                                                                              *
*                       DISTRIBUTION PROHIBITED without                        *
*                      written authorization from Voxware                      *
******************************************************************************/

/*******************************************************************************
* Filename:       VoicLD.h
*                                                                              
* Purpose:        voicing calculation for LDPDA.
*                                                                              
* Functions:     VoicingLD(), FindBand4VoicLD()
*
* Author/Date:    Wei Wang, 12/97
*
********************************************************************************
* Modifications: Reduce the length of refining window spectrum from 2048 to 112.
*                Use fix point indices to speech up code.
*                                                                              
* Comments:                                                                    
* 
* Concerns:
*
* $Header:   /export/phobos/pvcs/r_and_d/archives/scaleable/pea/VoicLD.h_v   1.1   02 Apr 1998 14:47:04   weiwang  $
******************************************************************************/
#ifndef _VOICLD_H_
#define _VOICLD_H_

/******************************************************************************
* Function:  VoicingLD()
*
* Action:    Estimate voicing probability and use it for final pitch seletion
*
* Input:     fPitch     -- pitch period
*            pfSW       -- complex spectrum
*            iNBand     -- length of spectrum for voicing probability 
*                          calculation
*
* Output:    none
*
* Globals:   none
*
* Return:    estimated voicing probability
*******************************************************************************
*
* Implementation/Detailed Description:
*
*******************************************************************************
*
* Modifications:
*
* Comments:  
*
* Concerns/TBD:
*
******************************************************************************/
float VoicingLD( float        fPitch,
                 const float  *pfSW, 
                 int          iNBand
               );



/******************************************************************************
* Function:  FindBand4VoicLD()
*
* Action:    Find out spectrum band for voicing calculation
*
* Input:     iBaseBand   -- band for pitch estimation
*            fMinPitch   -- minimum pitch period for voicing calculation
*
* Output:    none
*
* Globals:   none
*
* Return:    band for voicing calculation
*******************************************************************************
*
* Implementation/Detailed Description:
*
*******************************************************************************
*
* Modifications:
*
* Comments:  
*
* Concerns/TBD:
*
******************************************************************************/
int FindBand4VoicLD ( int   iBaseBand, 
                      float fMinPitch
                    );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\voxware\voxdurb.c ===
/*****************************************************************************
*                        Voxware Proprietary Material                       *
*                        Copyright 1996, Voxware Inc.                       *
*                        All Rights Reserved                                *
*                                                                           *
*                        DISTRIBUTION PROHIBITED without                    *
*                        written authorization from Voxware.                *
*****************************************************************************/
/*****************************************************************************
* 
* Filename: VoxDurb.c
*
* Purpose: calculate LPC coefficients using Durbin-Levinson algorithm.
*
* Reference: Optimal signal processing by S. J. Orfanidis
*
* Author:    Wei Wang
*
* Date:      Oct. 07, 1996.
* 
* Modification:  Xiaoqin Sun   Nov. 21, 1997
*
*$Header:   /export/phobos/pvcs/pvcsproj/voxlib.prj/VoxDurb.c_v   1.7   03 Mar 1998 14:38:08   bobd  $
*******************************************************************************/
#include <stdlib.h>
#include <assert.h>
#include <string.h>

#include "vLibDef.h"
#include "vLibSpch.h"

#include "xvocver.h"

static const float fOverflowThreshold = 0.9999F;

/*****************************************************************************
 * Function: VoxCalcDurbin()
 *
 * Input:  pAutoCorr:     auto-correlation buffer.
 *         iLpcOrder:      LPC order.
 *
 * Output: pLPCoef:       LPC coefficients.
 *         pfPARCOR:      Partial Correlation (reflection) coefficients.
 *         pResidueEng:   residue energy.
 * Return:  None.
 * We define A(z) as: 
 *
 *               A(z) = 1 + SUM(k=1...p) a_k * z^(-k)
 * output is, 1, a[1], a[2]....
 ****************************************************************************/
void VoxDurbin( const float *pAutoCorr, 
                int         iLpcOrder, 
                float       *pfLPCoef,
                float       *pfPARCOR, 
                float       *pfResidEnrg
              )
{
   int             i, j, p;
   float           *pfA;
   float           *pfA_1;
   float          *pfSwap;
   float           fTmp[MAX_LPC_ORDER+1];
   float           fDelta;
   float           fGamma;
   float           fResidEnrg;
   
   assert(iLpcOrder <= MAX_LPC_ORDER);
   assert(pAutoCorr != NULL && pfLPCoef != NULL);
   assert(pfPARCOR != NULL && pfResidEnrg != NULL);

   /*--------------------------------------------------
    check the frame energy first. If frame is almost
    silence, put a small number for the energy.
   --------------------------------------------------*/
   fResidEnrg = pAutoCorr[0];
   if (fResidEnrg == 0.0F)
      fResidEnrg = VERY_SMALL_FLOAT;
   
   /*--------------------------------------------------
    do Leveinson-Durbin iteration.
   --------------------------------------------------*/
   if(iLpcOrder&1)           /* an odd number of iterations */
   {
      pfA    = fTmp;
      pfA_1  = pfLPCoef;
   }
   else                    /* an even number of iterations */
   {  
      pfA   = pfLPCoef;
      pfA_1 = fTmp;
   }

   pfA[0] = pfA_1[0] = 1.0F;
   for (p=0; p<iLpcOrder; p++) 
   {
      fDelta = 0.0F;
      for( i=0; i<=p; i++) 
         fDelta += pfA[i] * pAutoCorr[p+1-i];
   
      /*--------------------------------------------------
         calculate reflection coefficients (Equation 5.3.11
         page 205). Then convergence checking is applied.
      --------------------------------------------------*/
      fGamma =  fDelta / fResidEnrg;

      if ( fGamma > fOverflowThreshold ) 
         fGamma = fOverflowThreshold;
      if ( fGamma < (-fOverflowThreshold) ) 
         fGamma = (-fOverflowThreshold);      

      *pfPARCOR++ = fGamma;
     
      /*------------------------------------------------------
        Move pfA[] to pfA_1[] by swapping pointers
      ------------------------------------------------------*/
      pfSwap = pfA;   /* swap pfA with pfA_1 */
      pfA    = pfA_1;
      pfA_1  = pfSwap;

      /*------------------------------------------------------
        Compute (i+1)th order predictor coefficients
      ------------------------------------------------------*/
      pfA[p+1] = -fGamma;
      for (j=1, i=p; j<=p; j++, i--)
         pfA[j] = pfA_1[j] - fGamma*pfA_1[i];
   
      /*--------------------------------------------------
        iteratively calculate residue energy.
      --------------------------------------------------*/
      fResidEnrg *= 1.0F-fGamma*fGamma;
   }
   *pfResidEnrg = fResidEnrg;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\voxware\voxcodec.cpp ===
/***************************************************************************
 *
 *  Copyright (C) 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       voxcodec.cpp
 *  Content:    Voxware CODEC XMO
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  11/08/00    dereks  Created.
 *
 ****************************************************************************/

#include "dsoundi.h"
#include "vci.h"
#include "vcisc3.h"
#include "vcisc6.h"
#include "vcivr12.h"
#include "vcierror.h"

#include "xvocver.h"

DEFINELPCTYPE(BYTE);
DEFINELPTYPE(SHORT);

#define VOXWARE_SC03_MAXBITSPERSEC		3200
#define VOXWARE_SC03_MAXBYTESPERSEC		(VOXWARE_SC03_MAXBITSPERSEC / 8)
#define VOXWARE_SC03_TRAILFRAMES		1
#define VOXWARE_SC03_TIMEOUT			20
#define VOXWARE_SC03_FRAMELENGTH		((VOXWARE_SC03_TIMEOUT * VOXWARE_SC03_MAXBYTESPERSEC) / 1000)

#define VOXWARE_SC06_MAXBITSPERSEC		6400
#define VOXWARE_SC06_MAXBYTESPERSEC		(VOXWARE_SC06_MAXBITSPERSEC / 8)
#define VOXWARE_SC06_TRAILFRAMES		1
#define VOXWARE_SC06_TIMEOUT			20
#define VOXWARE_SC06_FRAMELENGTH		((VOXWARE_SC06_TIMEOUT * VOXWARE_SC06_MAXBYTESPERSEC) / 1000)

#define VOXWARE_VR12_MAXBITSPERSEC		1822
#define VOXWARE_VR12_TRAILFRAMES		1
#define VOXWARE_VR12_TIMEOUT			90
#define VOXWARE_VR12_FRAMELENGTH		21


//
// Voxware function pointers
//

typedef VCI_RETCODE (*LPFNVCIGETINFO)(VCI_CODEC_INFO_BLOCK *pvciCodecInfoBlk);
typedef VCI_RETCODE (*LPFNVCIPROCESS)(LPVOID pEncodeMemBlk, VCI_CODEC_IO_BLOCK *pvciCodecIOBlk);
typedef VCI_RETCODE (*LPFNVCIINIT)(LPVOID *hEncodeMemBlk); 
typedef VCI_RETCODE (*LPFNVCIFREE)(LPVOID *hEncodeMemBlk);

//
// Voxware CODEC XMO
//

class CVoxMediaObject
    : public XMediaObject
{
protected:
    BOOL                    m_fEncoder;                     // TRUE if we're an encoder
    ULONG                   m_ulRefCount;                   // Object reference count
    VCI_CODEC_INFO_BLOCK    m_vciCodecInfo;                 // CODEC info
    WORD                    m_wEncodeFrameSize;             // Encoded frame size

private:
    LPFNVCIGETINFO          m_pfnVciGetInfo;
    LPFNVCIPROCESS          m_pfnVciProcess;
    LPFNVCIINIT             m_pfnVciInit;
    LPFNVCIFREE             m_pfnVciFree;
    LPVOID                  m_pvMemBlock;

public:
    CVoxMediaObject(void);
    virtual ~CVoxMediaObject(void);

public:
    // Initialization
    void STDMETHODCALLTYPE Initialize(WORD wEncodeFormatTag, BOOL fCreateEncoder, LPVOICECODECWAVEFORMAT pwfxEncoded, LPWAVEFORMATEX pwfxDecoded);
    
    // IUnknown methods
    virtual ULONG STDMETHODCALLTYPE AddRef(void);
    virtual ULONG STDMETHODCALLTYPE Release(void);

    // XMediaObject methods
    virtual HRESULT STDMETHODCALLTYPE GetInfo(LPXMEDIAINFO pInfo);
    virtual HRESULT STDMETHODCALLTYPE GetStatus(LPDWORD pdwStatus);
    virtual HRESULT STDMETHODCALLTYPE Process(LPCXMEDIAPACKET pxmbInput, LPCXMEDIAPACKET pxmbOutput);
    virtual HRESULT STDMETHODCALLTYPE Discontinuity(void);
    virtual HRESULT STDMETHODCALLTYPE Flush(void);

protected:
    DWORD STDMETHODCALLTYPE GetEncodeAlignment(void);
    DWORD STDMETHODCALLTYPE GetDecodeAlignment(void);
    
    DWORD STDMETHODCALLTYPE GetInputAlignment(void);
    DWORD STDMETHODCALLTYPE GetOutputAlignment(void);
};

__inline HRESULT CVoxMediaObject::GetStatus(LPDWORD pdwStatus)
{
    *pdwStatus = XMO_STATUSF_ACCEPT_INPUT_DATA | XMO_STATUSF_ACCEPT_OUTPUT_DATA;
    return DS_OK;
}

__inline HRESULT CVoxMediaObject::Discontinuity(void)
{
    return DS_OK;
}

__inline HRESULT CVoxMediaObject::Flush(void)
{
    return DS_OK;
}

__inline DWORD CVoxMediaObject::GetEncodeAlignment(void)
{
    return m_wEncodeFrameSize;
}

__inline DWORD CVoxMediaObject::GetDecodeAlignment(void)
{
    return m_vciCodecInfo.wNumSamplesPerFrame << 1;
}

__inline DWORD CVoxMediaObject::GetInputAlignment(void)
{
    return m_fEncoder ? GetDecodeAlignment() : GetEncodeAlignment();
}

__inline DWORD CVoxMediaObject::GetOutputAlignment(void)
{
    return m_fEncoder ? GetEncodeAlignment() : GetDecodeAlignment();
}


/****************************************************************************
 *
 *  VoxwareCreateConverter
 *
 *  Description:
 *      Creates a Voxware CODEC object.
 *
 *  Arguments:
 *      WORD [in]: encoded format tag.
 *      BOOL [in]: TRUE to initialize the object as an encoder.
 *      LPVOICECODECWAVEFORMAT [out]: encoded format.
 *      LPWAVEFORMATEX [out]: decoded format.
 *      XMediaObject ** [out]: CODEC object.  The caller is responsible for
 *                             freeing this object with Release.
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "VoxwareCreateConverter"

HRESULT
VoxwareCreateConverter
(
    WORD                    wEncodeFormatTag, 
    BOOL                    fCreateEncoder, 
    LPVOICECODECWAVEFORMAT  pwfxEncoded, 
    LPWAVEFORMATEX          pwfxDecoded, 
    LPXMEDIAOBJECT *        ppMediaObject
)
{
    CVoxMediaObject *       pMediaObject;
    HRESULT                 hr;

    DPF_ENTER();

    hr = HRFROMP(pMediaObject = NEW(CVoxMediaObject));

    if(SUCCEEDED(hr))
    {
        pMediaObject->Initialize(wEncodeFormatTag, fCreateEncoder, pwfxEncoded, pwfxDecoded);
    }

    if(SUCCEEDED(hr))
    {
        *ppMediaObject = ADDREF(pMediaObject);
    }

    RELEASE(pMediaObject);

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/****************************************************************************
 *
 *  CVoxMediaObject
 *
 *  Description:
 *      Object constructor.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CVoxMediaObject::CVoxMediaObject"

CVoxMediaObject::CVoxMediaObject
(
    void
)
{
    DPF_ENTER();

    //
    // Initialize defaults
    //

    m_ulRefCount = 1;

    DPF_LEAVE_VOID();
}


/****************************************************************************
 *
 *  ~CVoxMediaObject
 *
 *  Description:
 *      Object destructor.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CVoxMediaObject::~CVoxMediaObject"

CVoxMediaObject::~CVoxMediaObject
(
    void
)
{
    DPF_ENTER();

    //
    // Free working memory
    //

    if(m_pvMemBlock)
    {
        ASSERT(m_pfnVciFree);
        m_pfnVciFree(&m_pvMemBlock);
    }

    DPF_LEAVE_VOID();
}


/****************************************************************************
 *
 *  Initialize
 *
 *  Description:
 *      Initializes the object.
 *
 *  Arguments:
 *      WORD [in]: encoded format tag.
 *      WORD [in]: channel count.
 *      BOOL [in]: TRUE to initialize the object as an encoder.
 *      LPVOICECODECWAVEFORMAT [out]: encoded format.
 *      LPWAVEFORMATEX [out]: decoded format.
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CVoxMediaObject::Initialize"

void
CVoxMediaObject::Initialize
(
    WORD                    wEncodeFormatTag, 
    BOOL                    fCreateEncoder, 
    LPVOICECODECWAVEFORMAT  pwfxEncoded, 
    LPWAVEFORMATEX          pwfxDecoded
)
{
    DPF_ENTER();

    //
    // Save data members
    //

    m_fEncoder = fCreateEncoder;

    //
    // Set up the function table and save CODEC-specific values
    //

    switch(wEncodeFormatTag) 
    {
        case WAVE_FORMAT_VOXWARE_SC03:
            m_pfnVciGetInfo = vciGetInfoSC3;

            if(m_fEncoder)
            {
                m_pfnVciProcess = vciEncodeSC3;
                m_pfnVciInit = vciInitEncodeSC3;
                m_pfnVciFree = vciFreeEncodeSC3;
            }
            else
            {
                m_pfnVciProcess = vciDecodeSC3;
                m_pfnVciInit = vciInitDecodeSC3;
                m_pfnVciFree = vciFreeDecodeSC3;
            }

            m_wEncodeFrameSize = VOXWARE_SC03_FRAMELENGTH;

            break;

        case WAVE_FORMAT_VOXWARE_SC06:
            m_pfnVciGetInfo = vciGetInfoSC6;

            if(m_fEncoder)
            {
                m_pfnVciProcess = vciEncodeSC6;
                m_pfnVciInit = vciInitEncodeSC6;
                m_pfnVciFree = vciFreeEncodeSC6;
            }
            else
            {
                m_pfnVciProcess = vciDecodeSC6;
                m_pfnVciInit = vciInitDecodeSC6;
                m_pfnVciFree = vciFreeDecodeSC6;
            }

            m_wEncodeFrameSize = VOXWARE_SC06_FRAMELENGTH;

            break;

        case WAVE_FORMAT_VOXWARE_VR12:
            m_pfnVciGetInfo = vciGetInfoVR12;

            if(m_fEncoder)
            {
                m_pfnVciProcess = vciEncodeVR12;
                m_pfnVciInit = vciInitEncodeVR12;
                m_pfnVciFree = vciFreeEncodeVR12;
            }
            else
            {
                m_pfnVciProcess = vciDecodeVR12;
                m_pfnVciInit = vciInitDecodeVR12;
                m_pfnVciFree = vciFreeDecodeVR12;
            }

            m_wEncodeFrameSize = VOXWARE_VR12_FRAMELENGTH;

            break;

        default:
            ASSERTMSG("Invalid encode format tag");
            break;
    }

    //
    // Initialize the Voxware library
    //

    m_pfnVciInit(&m_pvMemBlock);
    m_pfnVciGetInfo(&m_vciCodecInfo);

    //
    // Build an encoded format for the caller
    //

    if(pwfxEncoded)
    {
        pwfxEncoded->wfx.wFormatTag = wEncodeFormatTag;
        pwfxEncoded->wfx.nChannels = m_vciCodecInfo.wNumChannels;
        pwfxEncoded->wfx.nSamplesPerSec = m_vciCodecInfo.wSamplingRate;
        pwfxEncoded->wfx.wBitsPerSample = m_vciCodecInfo.wNumBitsPerSample;
        pwfxEncoded->wfx.nBlockAlign = (WORD)GetEncodeAlignment();
        pwfxEncoded->wfx.cbSize = sizeof(*pwfxEncoded) - sizeof(pwfxEncoded->wfx);
        
        switch(wEncodeFormatTag) 
        {
            case WAVE_FORMAT_VOXWARE_SC03:
                pwfxEncoded->wfx.nAvgBytesPerSec = VOXWARE_SC03_MAXBITSPERSEC;
                
                pwfxEncoded->dwMilliSecPerFrame = VOXWARE_SC03_TIMEOUT;
                pwfxEncoded->dwTrailFrames = VOXWARE_SC03_TRAILFRAMES;

                break;

            case WAVE_FORMAT_VOXWARE_SC06:
                pwfxEncoded->wfx.nAvgBytesPerSec = VOXWARE_SC06_MAXBITSPERSEC;
                
                pwfxEncoded->dwMilliSecPerFrame = VOXWARE_SC06_TIMEOUT;
                pwfxEncoded->dwTrailFrames = VOXWARE_SC06_TRAILFRAMES;

                break;

            case WAVE_FORMAT_VOXWARE_VR12:
                pwfxEncoded->wfx.nAvgBytesPerSec = VOXWARE_VR12_MAXBITSPERSEC;
                
                pwfxEncoded->dwMilliSecPerFrame = VOXWARE_VR12_TIMEOUT;
                pwfxEncoded->dwTrailFrames = VOXWARE_VR12_TRAILFRAMES;

                break;

            default:
                ASSERTMSG("Invalid encode format tag");
                break;
        }
    }

    //
    // Build a decoded format for the caller
    //

    if(pwfxDecoded)
    {
        pwfxDecoded->wFormatTag = WAVE_FORMAT_PCM;
        pwfxDecoded->nChannels = m_vciCodecInfo.wNumChannels;
        pwfxDecoded->nSamplesPerSec = m_vciCodecInfo.wSamplingRate;
        pwfxDecoded->wBitsPerSample = m_vciCodecInfo.wNumBitsPerSample;
        pwfxDecoded->nBlockAlign = pwfxDecoded->nChannels * pwfxDecoded->wBitsPerSample >> 3;
        pwfxDecoded->nAvgBytesPerSec = pwfxDecoded->nBlockAlign * pwfxDecoded->nSamplesPerSec;
        pwfxDecoded->cbSize = 0;
    }

    DPF_LEAVE_VOID();
}


/****************************************************************************
 *
 *  AddRef
 *
 *  Description:
 *      Increments the object reference count.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      ULONG: reference count.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundSecondaryBuffer::AddRef"

ULONG
CVoxMediaObject::AddRef
(
    void
)
{
    ULONG                   ulRefCount;

    DPF_ENTER();

    ASSERT(m_ulRefCount);
    
    ulRefCount = ++m_ulRefCount;

    DPF_LEAVE(ulRefCount);

    return ulRefCount;
}


/****************************************************************************
 *
 *  Release
 *
 *  Description:
 *      Decrements the object reference count.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      ULONG: reference count.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundSecondaryBuffer::Release"

ULONG
CVoxMediaObject::Release
(
    void
)
{
    ULONG                   ulRefCount;

    DPF_ENTER();

    ASSERT(m_ulRefCount);
    
    if(!(ulRefCount = --m_ulRefCount))
    {
        delete this;
    }

    DPF_LEAVE(ulRefCount);

    return ulRefCount;
}


/****************************************************************************
 *
 *  GetInfo
 *
 *  Description:
 *      Gets information about the data the object supports.
 *
 *  Arguments:
 *      LPXMEDIAINFO [in/out]: info structure.
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CVoxMediaObject::GetInfo"

HRESULT
CVoxMediaObject::GetInfo
(
    LPXMEDIAINFO            pInfo
)
{
    DPF_ENTER();

    pInfo->dwFlags = XMO_STREAMF_FIXED_SAMPLE_SIZE;
    pInfo->dwInputSize = GetInputAlignment();
    pInfo->dwOutputSize = GetOutputAlignment();
    pInfo->dwMaxLookahead = 0;

    DPF_LEAVE_HRESULT(DS_OK);

    return DS_OK;
}


/****************************************************************************
 *
 *  Process
 *
 *  Description:
 *      Submits buffers to the stream.
 *
 *  Arguments:
 *      LPCXMEDIAPACKET  [in]: input buffer.
 *      LPCXMEDIAPACKET  [in]: output buffer.
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CVoxMediaObject::Process"

HRESULT
CVoxMediaObject::Process
(
    LPCXMEDIAPACKET         pxmbSource, 
    LPCXMEDIAPACKET         pxmbDest 
)
{
    HRESULT                 hr                  = DS_OK;
    LPCXMEDIAPACKET         pxmbDecode;
    LPCXMEDIAPACKET         pxmbEncode;
    DWORD                   dwEncodeAlignment;
    DWORD                   dwDecodeAlignment;
    DWORD                   dwFrames;
    VCI_CODEC_IO_BLOCK      vciBlock;
    VCI_RETCODE             vciResult;
    DWORD                   i;
    
    DPF_ENTER();

    ASSERT(pxmbSource && pxmbDest);

    if(m_fEncoder)
    {
        pxmbDecode = pxmbSource;
        pxmbEncode = pxmbDest;
    }
    else
    {
        pxmbDecode = pxmbDest;
        pxmbEncode = pxmbSource;
    }

    // 
    // Initialize output members of the packet descriptors
    //
    
    XMOAcceptPacket(pxmbSource);
    XMOAcceptPacket(pxmbDest);

    //
    // Set up the processing block
    //

    dwEncodeAlignment = GetEncodeAlignment();
    dwDecodeAlignment = GetDecodeAlignment();

    ZeroMemory(&vciBlock, sizeof(vciBlock));
    
    vciBlock.pPCMBuffer = (short *)pxmbDecode->pvBuffer;
    vciBlock.pVoxBuffer = (LPBYTE)pxmbEncode->pvBuffer;
    vciBlock.wVoxBufferSize = (WORD)pxmbEncode->dwMaxSize;

    dwFrames = pxmbDecode->dwMaxSize / dwDecodeAlignment;

    if(!m_fEncoder)
    {
        vciBlock.wVoxBufferWriteByteOffset = vciBlock.wVoxBufferSize;
        vciBlock.wVoxBufferSize += 1;
    }

    //
    // Enter the main loop
    //

    for(i = 0; i < dwFrames; i++)
    {
        if(VCI_NO_ERROR != (vciResult = m_pfnVciProcess(m_pvMemBlock, &vciBlock)))
        {
            DPF_ERROR("Encode failed with error %lu", vciResult);
            hr = DSERR_GENERIC;

            break;
        }

        vciBlock.pPCMBuffer += m_vciCodecInfo.wNumSamplesPerFrame;
        
        if(m_fEncoder)
        {
            vciBlock.wSamplesInPCMBuffer = 0;
        }
    }

    //
    // Complete the packets
    //

    XMOCompletePacketSync(pxmbEncode, i * dwEncodeAlignment, SUCCEEDED(hr) ? XMEDIAPACKET_STATUS_SUCCESS : XMEDIAPACKET_STATUS_FAILURE);
    XMOCompletePacketSync(pxmbDecode, i * dwDecodeAlignment, SUCCEEDED(hr) ? XMEDIAPACKET_STATUS_SUCCESS : XMEDIAPACKET_STATUS_FAILURE);

    DPF_LEAVE_HRESULT(hr);

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\voxware\voicld.c ===
/*******************************************************************************
*                        Voxware Proprietary Material                          *
*                        Copyright 1997, Voxware, Inc                          *
*                            All Rights Reserved                               *
*                                                                              *
*                       DISTRIBUTION PROHIBITED without                        *
*                      written authorization from Voxware                      *
******************************************************************************/

/*******************************************************************************
* Filename:       VoicLD.c
*                                                                              
* Purpose:        voicing calculation for LDPDA.
*                                                                              
* Functions:     VoicingLD(), FindBand4VoicLD()
*
* Author/Date:    Wei Wang, 12/97
*
********************************************************************************
* Modifications: Reduce the length of refining window spectrum from 2048 to 112.
*                Use fix point indices to speech up code.
*                                                                              
* Comments:                                                                    
* 
* Concerns:
*
* $Header:   /export/phobos/pvcs/r_and_d/archives/scaleable/pea/VoicLD.c_v   1.6   14 Apr 1998 10:14:20   weiwang  $
******************************************************************************/

/**** system include files ****/
#include <stdlib.h>
#include <assert.h>
#include <math.h>

/**** codec related include files ****/
#include "codec.h"
#include "vLibMath.h"
#include "VoicLD.h"

#include "xvocver.h"

/**** table for real part of Kaiser window spectrum:
  fft( Kaiser(291,6),2^14 ). ****/
const static float tfWinSpec[] = {
#include "FD291SC.h"          
};

/**** local definitions ****/
#define REFINE_SPEC_SIZE  112 /* ((sizeof(tfWinSpec)/sizeof(float))>>1) */

#define REFINE_SPEC_BITS   5
#define REFINE_SPEC_SCALE  (1<<REFINE_SPEC_BITS)
#define F0_SHIFT_BIT  10
#define F0_SHIFT_SCALE  (float)(1<<F0_SHIFT_BIT)  
#define F0_SCALED_05  (1<<(F0_SHIFT_BIT-1))   

#define REF_F0_SHIFT_BITS  (F0_SHIFT_BIT+REFINE_SPEC_BITS) 
#define REF_F0_SHIFT_SCALE  (float)((long)1<<REF_F0_SHIFT_BITS)
#define REF_SCALED_05  ((long)1<<(REF_F0_SHIFT_BITS-1))

#define CONST_EXTEND_BAND  3.9F


/******************************************************************************
* Function:  VoicingLD()
*
* Action:    Estimate voicing probability and use it for final pitch seletion
*
* Input:     fPitch     -- pitch period
*            pfSW       -- complex spectrum
*            iNBand     -- length of spectrum for voicing probability 
*                          calculation
*
* Output:    none
*
* Globals:   none
*
* Return:    estimated voicing probability
*******************************************************************************
*
* Implementation/Detailed Description:
*
*******************************************************************************
*
* Modifications:
*
* Comments:  
*
* Concerns/TBD:
*
******************************************************************************/
float VoicingLD( float        fPitch,
                 const float  *pfSW, 
                 int          iNBand
               )
{
   const float *pfFWinCt = &(tfWinSpec[REFINE_SPEC_SIZE]); /* shift to center */
   float fF0;
   int iNHarm;
   long lF0, lBandWdth;
   int iLeftBound, iRightBound;
   long lHarmF0;
   int i, j;
   int iHF0;
   float ftmp;
   float fHarmMagReal, fHarmMagImag;
   float fErr1, fErr2;
   float fTotalError, fTotalPower;
   float *ptmpSW;
   int iWinIndex;
   float fVoicing = 0.0F;

   assert(pfSW != NULL);

   /*** initializing fF0 -- F0 in DFT domain ***/
   fF0 = (float)NFFT/fPitch;

   /*** initializing iNHarm -- number of harmonics within [0 iNBand] ***/
   iNHarm = (int)VoxFLOORpos((float)iNBand / fF0);

   /*** shift fF0 by REF_F0_SHIFT_BITS to get fix-point lF0 ***/
   ftmp = REF_F0_SHIFT_SCALE * fF0;
   VoxROUND2pos(ftmp, lF0);

   /*** initialize fix point bandwidth ***/
   lBandWdth = lF0 >> 1;

   /*** right boundary for each harmonics: round((i+0.5)*F0): i refers to 
     i'th harmonic ***/
   iRightBound = (int)((lBandWdth+REF_SCALED_05)>>REF_F0_SHIFT_BITS);

   /** compute reconstructed spectrum and compare it with original spectrum. **/
   lHarmF0 = 0L;
   for (j=1; j<=iNHarm; j++) {

     /*** update the left boundary and right boundary ***/
     lHarmF0 += lF0;
     iLeftBound = iRightBound;
     iRightBound = (int)((lBandWdth+lHarmF0+REF_SCALED_05)
                                >>REF_F0_SHIFT_BITS);

     /*** Get the magnitude of j'th harmonic ***/
     iHF0 = (int)((lHarmF0+REF_SCALED_05)>>REF_F0_SHIFT_BITS);

     ptmpSW = (float *)(&(pfSW[iHF0 << 1]));
     fHarmMagReal = ptmpSW[0];
     fHarmMagImag = ptmpSW[1];

     /**** reconstruct spectrum ****/
     fTotalPower = EPS;
     
     /*** initialize window index from j'th harmonic ***/
     iWinIndex = (int)(-((lHarmF0+F0_SCALED_05)>>F0_SHIFT_BIT)
                       +((long)iLeftBound<<REFINE_SPEC_BITS));

     /*** Since the indices for pfFWinCt[] is between [-REFINE_SPEC_SIZE
          REFINE_SPEC_SIZE]. Outside that range assume window spectra are 0 */
     /*** Deal with left side outliers: band error equals to band power ***/
     i = iLeftBound;
     ptmpSW = (float *)(&(pfSW[i<<1]));
     while (iWinIndex <= (-REFINE_SPEC_SIZE))
       {
         fErr1 = ptmpSW[0]*ptmpSW[0]+ptmpSW[1]*ptmpSW[1];

	 fTotalPower += fErr1;
	 iWinIndex += REFINE_SPEC_SCALE;
	 i++;
	 ptmpSW += 2;
       }
     fTotalError = fTotalPower;

     /*** Compute band errors and band power for the center part ***/
     while ((iWinIndex < REFINE_SPEC_SIZE) && (i < iRightBound))
       {
	 fTotalPower += ptmpSW[0]*ptmpSW[0] + ptmpSW[1]*ptmpSW[1];

	 fErr1 = ptmpSW[0] - fHarmMagReal * pfFWinCt[iWinIndex];
	 fErr2 = ptmpSW[1] - fHarmMagImag * pfFWinCt[iWinIndex];

	 fTotalError += fErr1 * fErr1 + fErr2 * fErr2;
	 iWinIndex += REFINE_SPEC_SCALE;
	 i++;
	 ptmpSW += 2;
       }
     
     /*** Deal with right side outliers: band errors equals to band power ***/
     while(i < iRightBound) 
       {
	 fErr1 = ptmpSW[0]*ptmpSW[0]+ptmpSW[1]*ptmpSW[1]; 
	 fTotalPower += fErr1;
	 fTotalError += fErr1;
	 i++;
	 ptmpSW += 2;
       }

     /**** voicing estimation of each band ****/
     fVoicing += fTotalError / fTotalPower; 
   }

   return  (1.0F - fVoicing/(float)iNHarm);
} /* VoicingLD() */


/******************************************************************************
* Function:  FindBand4VoicLD()
*
* Action:    Find out spectrum band for voicing calculation
*
* Input:     iBaseBand   -- band for pitch estimation
*            fMinPitch   -- minimum pitch period for voicing calculation
*
* Output:    none
*
* Globals:   none
*
* Return:    band for voicing calculation
*******************************************************************************
*
* Implementation/Detailed Description:
*
*******************************************************************************
*
* Modifications:
*
* Comments:  
*
* Concerns/TBD:
*
******************************************************************************/
int FindBand4VoicLD ( int   iBaseBand, 
                      float fMinPitch
                    )
{
  int iNewBand;
  float fBand;

  fBand = (float)NFFT/(float)fMinPitch;
  fBand *= CONST_EXTEND_BAND;

  VoxROUND2pos(fBand, iNewBand);

  if (iNewBand > iBaseBand)
    iNewBand = iBaseBand;

  return iNewBand;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\voxware\voxlpc.c ===
/***********************************************************************
 *
 * Filename:  calcLPC.c
 *
 * Purpose:   calculate the LPC coefficients using autocorrelation method.
 *
 * Reference: any digital speech processing text book.
 *
 * Author:    Wei Wang
 *
 * Date:      Oct. 07, 1996.
 *
 * $Header:   G:/r_and_d/archives/realtime/encode/LPC.c_v   1.5   11 Mar 1998 13:33:46   weiwang  $
 ***********************************************************************/
#include <stdlib.h>
#include <assert.h>

#include "model.h"
#include "VoxMem.h"

#include "vLibSpch.h" /* BandExpand(), VoxDurbin() */
#include "vLibVec.h"  /* AutoCor(), ScaleVector()  */

#include "LPC.h"

#include "xvocver.h"

/***************************************************
 * Function: calcLPC()
 *
 * Input:  pIn:  input data pointer.
 *         length: input data length.
 *         pLPCoef: LPC coefficients pointer (output).
 *         pResidueEng:  residue energy (output).
 *         pWinFrameEng: windowed signal energy (output).
 *         lpcOrder: LPC order.
 *         expandCoef: expansion coefficients.
 *         myLPC_mblk: pointer of the LPC structure.
 *
 * Output:  None.
 ***************************************************/

void VoxCalcLPC( STACK_R 
                 float *pIn, 
					  int   length,
                 float *pLPCoef, 
                 float *pResidueEng, 
                 float  expandCoef, 
                 float *autocorr_buf
                )
{
  STACK_INIT
  float fPARCOR[LPC_ORDER];
  STACK_INIT_END
  STACK_ATTACH(float *, fPARCOR)

  float invLength = 1.0F/(float)length;

  STACK_START

  /*--------------------------------------------------
    calcualte auto-correlation.
  --------------------------------------------------*/
  AutoCor(LPC_ORDER+1, pIn, length, autocorr_buf);

  
  /*--------------------------------------------------
    calculate LPC coefficients by using Levinson-Durbin
    algorithm.
  --------------------------------------------------*/
  VoxDurbin(autocorr_buf, LPC_ORDER, pLPCoef, fPARCOR, pResidueEng);

  *pResidueEng *= invLength;
  ScaleVector( autocorr_buf, LPC_ORDER+1, invLength, autocorr_buf );


  /*--------------------------------------------------
    expand the LPC pole. pLPCoef is overwritten.
  --------------------------------------------------*/
  BandExpand(pLPCoef, pLPCoef, LPC_ORDER, expandCoef);

  STACK_END
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\voxware\voxround.h ===
#ifndef _VOXROUND_H_
#define _VOXROUND_H_

long VoxPosRound(float x);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\voxware\voxround.c ===
#include <math.h>
#include "VoxRound.h"

#include "xvocver.h"

long VoxPosRound(float x)
{
  return (long)(floor(x+0.5F));
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\voxware\voxmem.h ===
/*******************************************************************************
*                        Voxware Proprietary Material                          *
*                        Copyright 1996, Voxware, Inc                          *
*                            All Rights Reserved                               *
*                                                                              *
*                       DISTRIBUTION PROHIBITED without                        *
*                      written authorization from Voxware                      *
*******************************************************************************/

/*******************************************************************************
* Filename:       VoxMem.h (more comonly known as "Ilan's MACROS from hell file!")                                                                    
*                                                                              
* Purpose:        Controls all dynamic memory allocation in codec                                                             
*                                                                              
* Author/Date:    Ilan Berci 96/11/20                                                                
********************************************************************************
* $Header:   G:/r_and_d/archives/common/utils/VoxMem.h_v   1.3   21 Apr 1998 17:33:46   epiphanyv  $
*******************************************************************************/

#ifndef VOXMEM_H
#define VOXMEM_H

#ifdef WIN16
#define SCRATCH_DEFINE 0
#else
#define SCRATCH_DEFINE 0        /* Main Scratch Memory switch */
#endif

#define SCRATCH_DIAGNOSTICS 0   /* Diagnostic utility that requires printf */

#define ALIGNMENT_WORD_SIZE 8   /* The number of bytes to align stack by */
#define ALIGN_SHIFT 3           /* 2 to the power of ALIGN_SHIFT = ALIGNMENT_WORD_SIZE */

#define SCRATCH_PAD_DWORD 0xFACE   /* 32 bit word to use in padding */

#ifndef Vsize_t
#define Vsize_t unsigned int   /* Voxware size_t */
#endif /* Vsize_t */

/* Replacement for callocs for DSP implementation */
#if(SCRATCH_DIAGNOSTICS==0)
#define VOX_MEM_INIT(ptr,num,size) (!(ptr=calloc(num,size)))
#else
unsigned int voxHeapCount(int num, Vsize_t size); /* returns 1 on success */
unsigned int voxGetHeapCount();
#define VOX_MEM_INIT(ptr,num,size) (!((ptr=calloc(num,size))&&voxHeapCount(num,size)))
#endif

#define VOX_MEM_FREE(ptr) if(ptr) { free(ptr); ptr=NULL; }

#define VOX_MEM_FREE_CONST(ptr) if(ptr) { free((void *)ptr); ptr=NULL; }

#if SCRATCH_DIAGNOSTICS==1
#if SCRATCH_DEFINE==0
#error In order to use Scratch Diagnostics, Scratch Define must be turned on
#endif
#endif

/* Replacement for stack for DSP implementation */
#if SCRATCH_DEFINE==1

#ifndef NDEBUG
#ifndef assert
#error "assert.h"  must be included in this file if you are intendending to use "VoxMem.h"
#endif /* assert */
#endif /* NDEBUG */

#if SCRATCH_DIAGNOSTICS==1
typedef struct tagFILE_SCRATCH_FILE {
   char                     *pFile;
   unsigned int             wAmount;
   struct tagFILE_SCRATCH_FILE* pLast;
} FILE_SCRATCH_BLK;
#endif /* SCRATCH_DIAGNOSTICS */

/* Pre-defines for initializing and freeing at the upermost level */
typedef struct _tagScratchStruct {
   unsigned char *bStartScratch;
   unsigned char *bCurrentScratch;
   unsigned char *bEndScratch;
   unsigned char *bMaximumScratch;
#if SCRATCH_DIAGNOSTICS==1
   struct tagFILE_SCRATCH_FILE*  pFileScratchStruct;
#endif /* SCRATCH_DIAGNOSTICS */
} SCRATCH_STRUCT;

#define STACK_DECLARE SCRATCH_STRUCT *pScratchStruct;

#define STACK_ASSIGN(ptr) pScratchStruct=(SCRATCH_STRUCT *)(ptr);

#define STACK_SET(ptr,size) voxStackSet(&ptr, size, &pScratchStruct, __FILE__) 

#define STACK_UNSET(ptr) voxStackUnSet(((SCRATCH_STRUCT **)(&ptr)));

#define STACK_VALIDATE() voxStackValidate(&pScratchStruct);

#define STACK_S pScratchStruct,

#define STACK_S_ pScratchStruct

#define STACK_R SCRATCH_STRUCT *pScratchStruct,  

#define STACK_R_ SCRATCH_STRUCT *pScratchStruct

#if SCRATCH_DIAGNOSTICS==1 
#define STACK_SHOW() voxStackShow(pScratchStruct);
#else 
#define STACK_SHOW()
#endif

/* Pre-defines for implementing the stack at lower levels */

#define STACK_INIT unsigned char *dwScratchInitial=pScratchStruct->bCurrentScratch; \
   typedef struct tagScratch { unsigned long padDWordStart; 
   /* body of stack fits in here between these 2 defines */

#define STACK_INIT_END unsigned long padDWordEnd; } SCRATCH_BLK; \
   SCRATCH_BLK *pScratch= ((SCRATCH_BLK *)(pScratchStruct->bCurrentScratch));

#define STACK_START pScratch->padDWordStart=pScratch->padDWordEnd=(unsigned long)SCRATCH_PAD_DWORD; \
   voxStackStart(pScratchStruct, sizeof(SCRATCH_BLK), __FILE__); 

#define STACK_END  assert(pScratch->padDWordStart==(unsigned long)SCRATCH_PAD_DWORD); \
   assert(pScratch->padDWordEnd==(unsigned long)SCRATCH_PAD_DWORD); \
   voxStackEnd(pScratchStruct, sizeof(SCRATCH_BLK)); \
   assert(pScratchStruct->bCurrentScratch==dwScratchInitial);

#define STACK_ATTACH(type, id) type id= pScratch->id;

#define STACK_ACCESS pScratch->

unsigned short voxStackSet(void **hvScratchStruct, unsigned int size, SCRATCH_STRUCT **hScratchStruct, char *pFile);
unsigned short voxStackUnSet(SCRATCH_STRUCT **hScratchStruct);
unsigned short voxStackValidate(SCRATCH_STRUCT **hScratchStruct);
unsigned short voxStackShow(const SCRATCH_STRUCT *pScratchStruct);
unsigned short voxStackStart(SCRATCH_STRUCT *pScratchStruct, Vsize_t sizeScratch, const char *pszFile);
unsigned short voxStackEnd(SCRATCH_STRUCT *pScratchStruct, Vsize_t sizeScratch);

#else

#define STACK_DECLARE
#define STACK_ASSIGN(ptr)
#define STACK_SET(ptr,size) 0
#define STACK_UNSET(ptr)
#define STACK_VALIDATE()
#define STACK_SHOW()
#define STACK_S
#define STACK_R
#define STACK_INIT
#define STACK_INIT_END
#define STACK_START
#define STACK_END
#define STACK_ATTACH(type, id)
#define STACK_ACCESS 

#endif /* SCRATCH_DEFINE */

unsigned char voxIsPreEmptive();
unsigned short voxSetNonPreEmptive();

#endif /* VOXMEM_H */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\voxware\vq2.c ===
/*******************************************************************************
*                        Voxware Proprietary Material
*                        Copyright 1996, Voxware, Inc
*                            All Rights Reserved
*
*                       DISTRIBUTION PROHIBITED without
*                      written authorization from Voxware
*******************************************************************************/
/*******************************************************************************
* File:         VQ2.c
*
* Description:  Encode a 2-dimensional input vector using a 2-D vector 
*                 quantizer with the straightforward mean squared error 
*                 (MSE) criterion 
*
* Author/date:  Original VQ.c code written by:    Wei Wang, July 22, 1994
*               Special Optimized version for 2-dimensional VQ written by: 
*                                   Juin-Hwey (Raymond) Chen, May 21, 1997
* $Header:   /export/phobos/pvcs/pvcsproj/voxlib.prj/VQ2.c_v   1.9   25 Mar 1998 14:04:44   weiwang  $ 
*******************************************************************************/
#include <stdlib.h>
#include <assert.h>

#include "vLibDef.h"
#include "vLibQuan.h"

#include "xvocver.h"

/*******************************************************************************
* Function:  Dim2VectorQuantize()
*
* Action:    Encode a 2-dimensional input vector using a 2-D vector quantizer 
*            with the straightforward mean squared error (MSE) criterion 
*
* INPUT:     pfVector:   --- 2-dimensional input vector
*            pfCodeBook: --- one-dimensional codebook array containing
*                             (2 * iEntries) elements. Codebook vectors
*                             are stored in a format of (row * column)
*                             i.e. dimention of component * entries of
*                             the codebook
*            iEntries:   --- codebook size (number of 2-D codevectors)
*
* OUTPUT:    None
*    
* RETURN:    Chosen index of the codebook
********************************************************************************
*
* Implementation:  There are 2 versions of the code.  The WIN32/IEEE version
*                    uses a float/int union to speed up comparisons.
*
*******************************************************************************/

#if ( defined(WIN32) || defined(IEEE) )

/*---------------------------------------------------------------------------
  WIN32/IEEE VERSION: The float/int union speeds up comparisons.
---------------------------------------------------------------------------*/
int Dim2VectorQuantize( const float *pfVector, 
                        const float *pfCodeBook, 
                        int          iEntries
                      )
{
   int   i;
   int   iIndex;
   float fTmp;
   union dt {
      float f;
      long   l;
   } uMinError, uError;

   assert( pfVector != NULL);
   assert( pfCodeBook != NULL);
   iIndex = 0;
   uMinError.f = VERY_LARGE_FLOAT;
  
   for (i = 0; i < iEntries; i++) 
   {
      fTmp = *pfCodeBook++ - pfVector[0];
      uError.f = fTmp * fTmp;
      fTmp = *pfCodeBook++ - pfVector[1];
      uError.f += fTmp * fTmp;

      if (uError.l < uMinError.l) 
      {
         uMinError.l = uError.l;
         iIndex = i;
      }
   }

   return( iIndex );
}

#else /* else not WIN32 */

/*---------------------------------------------------------------------------
  GENERAL PURPOSE VERSION: No float/int union.
---------------------------------------------------------------------------*/
int Dim2VectorQuantize( const float *pfVector,
                        const float *pfCodeBook,
                        int          iEntries
                      )
{
   int   i;
   int   iEntry;
   float fTmp;
   float fError;
   float fMinError;

   assert( pfVector != NULL );
   assert( pfCodeBook != NULL);

   iEntry = 0;
   fMinError = VERY_LARGE_FLOAT;
 
   for (i = 0; i < iEntries; i++)
   {
      fTmp    = *pfCodeBook++ - pfVector[0];
      fError  = fTmp*fTmp;
      fTmp    = *pfCodeBook++ - pfVector[1];
      fError += fTmp*fTmp;

      if (fError < fMinError) 
      {
         fMinError = fError;
         iEntry = i;
      }
   }

   return( iEntry );
}

#endif

/*******************************************************************************
* Function:  Dim2VectorLUT()
*
* Action:    Decode the codebook index of a 2-dimensional vector quantizer
*
* Input:     iIndex:     --- the index of the selected codevector
*            pfCodeBook: --- one-dimensional codebook array containing
*                             (2 * iEntries) elements
*            iEntries:   --- number of entries in the codebook
*
* Output:    pfVector:   --- decoded 2-dimensional VQ output vector
*
* Author/Date:  Juin-Hwey (Raymond) Chen, June 9, 1997
*
* NOTE: the function VQ2dec() works only for the case of 2-dimensional VQ
*******************************************************************************/
 
void Dim2VectorLUT( unsigned int  iIndex, 
                    const float  *pfCodeBook, 
                    int           iEntries,
                    float        *pfVector
                  )
{
   assert( pfCodeBook != NULL);
   assert( pfVector != NULL);
   assert( iIndex < (unsigned int) iEntries );

   if (iIndex >= (unsigned int) iEntries)
      iIndex = 0;

   pfCodeBook += (iIndex<<1);    /* increment pointer by 2*iIndex */
   *pfVector++ = *pfCodeBook++;
   *pfVector   = *pfCodeBook;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\voxware\vqresi.h ===
/******************************************************************************
*                        Voxware Proprietary Material
*                        Copyright 1996, Voxware, Inc
*                            All Rights Reserved
*
*                       DISTRIBUTION PROHIBITED without
*                      written authorization from Voxware
******************************************************************************/
 
/******************************************************************************
* Filename:        VqResi.h
*
* Purpose:         quantize residual ASKs
*
* Functions:       VoxASKResiEnc and VoxASKResiDec
*
* Author/Date:     Bob Dunn 9/11/97
*******************************************************************************
*
* Modifications: Cleaned up the code by Wei Wang, 2/9/98
*
* Comments: 
*
* Concerns: The numbers are hard wired for 12th order. 
*
* $Header:   /export/phobos/pvcs/r_and_d/archives/scaleable/quan/VqResi.h_v   1.0   06 Feb 1998 10:11:42   johnp  $
*
******************************************************************************/
#ifndef VQRESI_H
#define VQRESI_H

/******************************************************************************
*
* Function:  VoxASKResiEnc
*
* Action:   quantize the residual for last two pairs of ASKs
*
* Input:  pfASKq -- quantized ASKs input vector
*         pfASKorig -- unquantized ASKs
*         piIndex -- the pointer to the output indices
*
* Output: piIndex -- output quantization indices
*
* Globals:   none
*
* Return:    none
*******************************************************************************
*
* Implementation/Detailed Description: 
*
* References:
*******************************************************************************
*
* Modifications:
*
* Comments:  
*
* Concerns/TBD:
******************************************************************************/

void VoxASKResiEnc(const float *pfASKq, const float *pfASKorig, int *piIndex);

/******************************************************************************
*
* Function:  VoxASKResiDec
*
* Action:   unquantize the residual for last two pairs of ASKs
*
* Input:  pfASKq -- quantized ASKs input vector
*         piIndex -- the quantization indices
*
* Output: pfASKq -- quantized ASKs (input vector + residual)
*
* Globals:   none
*
* Return:    none
*******************************************************************************
*
* Implementation/Detailed Description: 
*
* References:
*******************************************************************************
*
* Modifications:
*
* Comments:  
*
* Concerns/TBD:
******************************************************************************/

void VoxASKResiDec(float *pfASKq, const int *piIndex);

#endif /* VQRESI_H */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\voxware\voxqr.c ===
/******************************************************************************
*                        Voxware Proprietary Material
*                        Copyright 1996, Voxware, Inc
*                            All Rights Reserved
*
*                       DISTRIBUTION PROHIBITED without
*                      written authorization from Voxware
******************************************************************************/
 
/******************************************************************************
*
* Filename:        VoxQR.c
*
* Purpose:         Approximate fourth root.
*
* Functions:
*
* Author/Date:     Bob Dunn 1/9/87
*
*******************************************************************************
*
* Modifications:
*
* Comments:
*
*     WARNING: This code assumes that the input is between 0 and 1.
*              The output is meaningless for inputs greater than 1.
*              If the input is negative an infinite loop results.
*
* Concerns:
*
* $Header:   /export/phobos/pvcs/pvcsproj/voxlib.prj/VoxQR.c_v   1.4   02 Mar 1998 16:25:38   weiwang  $
******************************************************************************/
#include <assert.h>
 
#include "vLibMath.h"

#include "xvocver.h"

/*----------------------------------------------------
  Constants to approximate 4th root function in
    the region (0.1 <= x <= 1.0):

    y = x^(1/4) = (approx) (QRA*x*x + QRB*x + QRC)
----------------------------------------------------*/
#define QRA      -0.48015624485737840033F
#define QRB       1.00009717769371908602F
#define QRC       0.46449154220907556967F

/*----------------------------------------------------
  A constant to use for scaling:

   INV_QR10 = 1.0/(10.0^(1/4))
----------------------------------------------------*/
#define SCALE_INIT    1.0F
#define CONST_SCALE   10.0F
#define INV_SCALE     0.1F
#define INV_QR_SCALE  0.56234132519034907283F

/*----------------------------------------------------
  The LIMITING_FACTOR is used to control the maximum
    number of iterations in the while loop that scales
    an input which is less than 0.1 (but greater than
    0.0).  If N is the maximum number of iterations
    then LIMITING_FACTOR should be set to:

    LIMITING_FACTOR = 1.0x10.0^(-(N+1))
  
    This effectively limits the dynamic range of the 
    input to N+1 orders of magnitude.
----------------------------------------------------*/
#define LIMITING_FACTOR  1.0e-7F    /* N=6 for 7 orders of magnitude */

/******************************************************************************
*
* function:  float fQuadRoot(float fXval)
*
* Action:    approximation fourth root.
*
* Input:     fXvale -- input number 
*
* Output:    same as return
*
* Globals:   none
*
* Return:    approximation to fourth root of fXval
*
*******************************************************************************
*
* Implementation/Detailed Description: 
*
* References:
*******************************************************************************
*
* Modifications:
*
* Comments:    
*
* Concerns/TBD: fXvale must be smaller than 1.
******************************************************************************/

float fQuadRoot(float fXval)
{
  float fScale;
  float fout;

  /*---------------------------------------------
    Assert for input between 0.0 and 1.0
  ---------------------------------------------*/
  assert( fXval >= 0.0F );
  assert( fXval <= 1.0F );

  /*---------------------------------------------
    Scale fXval so that it is between 0.1 and 1.0.
  ---------------------------------------------*/
  fScale = SCALE_INIT;
  fXval += LIMITING_FACTOR; /* limit number of iterations in the while loop */
  while (fXval < INV_SCALE)
    {
      fXval  *= CONST_SCALE;
      fScale *= INV_QR_SCALE;
    }

  /*---------------------------------------------
    Quadratic approximation to 4th root
  ---------------------------------------------*/
  fout  = QRA*fXval+QRB;
  fout  = fXval*fout + QRC;
  fout *= fScale;

  return fout;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\voxware\vr12test.c ===
#include <stdlib.h>

extern int RTmain(int,char**);

int main(int argc, char** argv)
{
	/************************/
	/*** Real Time Codecs ***/

	/* assign shared arguments */
	argc = 5;
	argv[2] = "-isample_m.raw";
	argv[3] = "-vsample_m.vox";

	/*** VR12 ***/
	argv[1] = "-cVR12";
	argv[4] = "-osample_m_c_VR12.raw";
	RTmain(argc,argv);


	return(0);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\voxware\vqresi.c ===
/******************************************************************************
*                        Voxware Proprietary Material
*                        Copyright 1996, Voxware, Inc
*                            All Rights Reserved
*
*                       DISTRIBUTION PROHIBITED without
*                      written authorization from Voxware
******************************************************************************/
 
/******************************************************************************
* Filename:        VqResi.c
*
* Purpose:         quantize residual ASKs
*
* Functions:       VoxASKResiEnc and VoxASKResiDec
*
* Author/Date:     Bob Dunn 9/11/97
*******************************************************************************
*
* Modifications: Cleaned up the code by Wei Wang, 2/9/98
*
* Comments: 
*
* Concerns: The numbers are hard wired for 12th order. 
*
* $Header:   /export/phobos/pvcs/r_and_d/archives/scaleable/quan/VqResi.c_v   1.4   08 Apr 1998 11:03:08   weiwang  $
*
******************************************************************************/
#include <stdlib.h>
#include <assert.h>

#include "vLibQuan.h"

#include "codec.h"
#include "quansc36.h"
#include "VqResi.h"

#include "xvocver.h"

#define RES_ASKS_8_9_SIZE    (1<<RESIDUAL_BITS_ASKS_8_9_SC6)
static const float tabCB_8_9[RES_ASKS_8_9_SIZE*2] = {
 0.003142F,  0.002211F,
-0.052339F, -0.000010F,
-0.024635F, -0.048779F,
-0.015182F, -0.011979F,
 0.042617F,  0.002844F,
-0.020211F,  0.031112F,
 0.021640F,  0.042246F,
 0.020281F, -0.032090F
};

#define RES_ASKS_10_11_SIZE    (1<<RESIDUAL_BITS_ASKS_10_11_SC6)
static const float tabCB_10_11[RES_ASKS_10_11_SIZE*2] = {
-0.003104F, -0.002303F,
 0.016099F,  0.051439F,
 0.057398F,  0.008813F,
 0.017065F,  0.011489F,
 0.026144F, -0.028814F,
-0.044614F, -0.007490F,
-0.014048F, -0.042063F,
-0.022506F,  0.028976F
};


#ifndef DECODE_ONLY
/******************************************************************************
*
* Function:  VoxASKResiEnc
*
* Action:   quantize the residual for last two pairs of ASKs
*
* Input:  pfASKq -- quantized ASKs input vector
*         pfASKorig -- unquantized ASKs
*         piIndex -- the pointer to the output indices
*
* Output: piIndex -- output quantization indices
*
* Globals:   none
*
* Return:    none
*******************************************************************************
*
* Implementation/Detailed Description: 
*
* References:
*******************************************************************************
*
* Modifications:
*
* Comments:  
*
* Concerns/TBD:
******************************************************************************/

void VoxASKResiEnc(const float *pfASKq, const float *pfASKorig, int *piIndex)
{
   float fResi[2];

   assert((pfASKq != NULL) && (pfASKorig != NULL) && (piIndex != NULL));

   /* quantize the residual of ASK[8] and ASK[9] */
   fResi[0] = pfASKorig[8] - pfASKq[8];
   fResi[1] = pfASKorig[9] - pfASKq[9];
   piIndex[0] = Dim2VectorQuantize(fResi, tabCB_8_9, RES_ASKS_8_9_SIZE);

   /* quantize the residual of ASK[10] and ASK[11] */
   fResi[0] = pfASKorig[10] - pfASKq[10];
   fResi[1] = pfASKorig[11] - pfASKq[11];
   piIndex[1] = Dim2VectorQuantize( fResi, tabCB_10_11, RES_ASKS_10_11_SIZE);
}

#endif

/******************************************************************************
*
* Function:  VoxASKResiDec
*
* Action:   unquantize the residual for last two pairs of ASKs
*
* Input:  pfASKq -- quantized ASKs input vector
*         piIndex -- the quantization indices
*
* Output: pfASKq -- quantized ASKs (input vector + residual)
*
* Globals:   none
*
* Return:    none
*******************************************************************************
*
* Implementation/Detailed Description: 
*
* References:
*******************************************************************************
*
* Modifications:
*
* Comments:  
*
* Concerns/TBD:
******************************************************************************/

void VoxASKResiDec(float *pfASKq, const int *piIndex)
{
  float pfVector[2];

  assert((pfASKq != NULL) && (piIndex != NULL));

  Dim2VectorLUT(piIndex[0], tabCB_8_9, RES_ASKS_8_9_SIZE, pfVector);
  pfASKq[8] += pfVector[0];
  pfASKq[9] += pfVector[1];


  Dim2VectorLUT(piIndex[1], tabCB_10_11, RES_ASKS_10_11_SIZE, pfVector);
  pfASKq[10] += pfVector[0];
  pfASKq[11] += pfVector[1];
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\voxware\w576rt29.h ===
1.0000000e+00F,
9.9987633e-01F,
9.9950538e-01F,
9.9888739e-01F,
9.9802274e-01F,
9.9691198e-01F,
9.9555580e-01F,
9.9395503e-01F,
9.9211068e-01F,
9.9002390e-01F,
9.8769598e-01F,
9.8512837e-01F,
9.8232266e-01F,
9.7928060e-01F,
9.7600406e-01F,
9.7249509e-01F,
9.6875583e-01F,
9.6478862e-01F,
9.6059588e-01F,
9.5618020e-01F,
9.5154429e-01F,
9.4669101e-01F,
9.4162331e-01F,
9.3634429e-01F,
9.3085718e-01F,
9.2516532e-01F,
9.1927216e-01F,
9.1318127e-01F,
9.0689634e-01F,
9.0042114e-01F,
8.9375959e-01F,
8.8691566e-01F,
8.7989346e-01F,
8.7269716e-01F,
8.6533105e-01F,
8.5779949e-01F,
8.5010692e-01F,
8.4225788e-01F,
8.3425696e-01F,
8.2610883e-01F,
8.1781824e-01F,
8.0938999e-01F,
8.0082895e-01F,
7.9214003e-01F,
7.8332821e-01F,
7.7439850e-01F,
7.6535597e-01F,
7.5620572e-01F,
7.4695287e-01F,
7.3760261e-01F,
7.2816012e-01F,
7.1863061e-01F,
7.0901933e-01F,
6.9933151e-01F,
6.8957241e-01F,
6.7974730e-01F,
6.6986143e-01F,
6.5992008e-01F,
6.4992848e-01F,
6.3989189e-01F,
6.2981552e-01F,
6.1970460e-01F,
6.0956429e-01F,
5.9939977e-01F,
5.8921615e-01F,
5.7901853e-01F,
5.6881196e-01F,
5.5860145e-01F,
5.4839196e-01F,
5.3818842e-01F,
5.2799569e-01F,
5.1781856e-01F,
5.0766179e-01F,
4.9753005e-01F,
4.8742798e-01F,
4.7736010e-01F,
4.6733090e-01F,
4.5734477e-01F,
4.4740604e-01F,
4.3751895e-01F,
4.2768765e-01F,
4.1791620e-01F,
4.0820860e-01F,
3.9856872e-01F,
3.8900038e-01F,
3.7950726e-01F,
3.7009297e-01F,
3.6076101e-01F,
3.5151478e-01F,
3.4235759e-01F,
3.3329263e-01F,
3.2432298e-01F,
3.1545163e-01F,
3.0668145e-01F,
2.9801519e-01F,
2.8945552e-01F,
2.8100496e-01F,
2.7266594e-01F,
2.6444078e-01F,
2.5633168e-01F,
2.4834071e-01F,
2.4046986e-01F,
2.3272096e-01F,
2.2509576e-01F,
2.1759589e-01F,
2.1022284e-01F,
2.0297803e-01F,
1.9586272e-01F,
1.8887807e-01F,
1.8202515e-01F,
1.7530489e-01F,
1.6871811e-01F,
1.6226553e-01F,
1.5594775e-01F,
1.4976527e-01F,
1.4371847e-01F,
1.3780764e-01F,
1.3203294e-01F,
1.2639445e-01F,
1.2089213e-01F,
1.1552584e-01F,
1.1029536e-01F,
1.0520034e-01F,
1.0024037e-01F,
9.5414907e-02F,
9.0723345e-02F,
8.6164977e-02F,
8.1739009e-02F,
7.7444561e-02F,
7.3280667e-02F,
6.9246282e-02F,
6.5340282e-02F,
6.1561464e-02F,
5.7908551e-02F,
5.4380195e-02F,
5.0974977e-02F,
4.7691411e-02F,
4.4527949e-02F,
4.1482977e-02F,
3.8554824e-02F,
3.5741763e-02F,
3.3042011e-02F,
3.0453735e-02F,
2.7975052e-02F,
2.5604036e-02F,
2.3338714e-02F,
2.1177074e-02F,
1.9117067e-02F,
1.7156608e-02F,
1.5293580e-02F,
1.3525835e-02F,
1.1851201e-02F,
1.0267478e-02F,
8.7724469e-03F,
7.3638684e-03F,
6.0394871e-03F,
4.7970339e-03F,
3.6342283e-03F,
2.5487811e-03F,
1.5383971e-03F,
6.0077700e-04F,
2.6637948e-04F,
1.0653717e-03F,
1.7984954e-03F,
2.4680409e-03F,
3.0762901e-03F,
3.6255149e-03F,
4.1179749e-03F,
4.5559149e-03F,
4.9415635e-03F,
5.2771304e-03F,
5.5648051e-03F,
5.8067545e-03F,
6.0051215e-03F,
6.1620227e-03F,
6.2795474e-03F,
6.3597554e-03F,
6.4046755e-03F,
6.4163044e-03F,
6.3966048e-03F,
6.3475041e-03F,
6.2708933e-03F,
6.1686258e-03F,
6.0425158e-03F,
5.8943377e-03F,
5.7258247e-03F,
5.5386682e-03F,
5.3345164e-03F,
5.1149742e-03F,
4.8816017e-03F,
4.6359140e-03F,
4.3793804e-03F,
4.1134241e-03F,
3.8394212e-03F,
3.5587010e-03F,
3.2725449e-03F,
2.9821869e-03F,
2.6888129e-03F,
2.3935605e-03F,
2.0975193e-03F,
1.8017307e-03F,
1.5071879e-03F,
1.2148361e-03F,
9.2557250e-04F,
6.4024682e-04F,
3.5966136e-04F,
8.4571437e-05F,
1.8431424e-04F,
4.4633311e-04F,
7.0086826e-04F,
9.4734787e-04F,
1.1852446e-03F,
1.4140750e-03F,
1.6333987e-03F,
1.8428177e-03F,
2.0419759e-03F,
2.2305576e-03F,
2.4082873e-03F,
2.5749286e-03F,
2.7302830e-03F,
2.8741896e-03F,
3.0065231e-03F,
3.1271940e-03F,
3.2361463e-03F,
3.3333576e-03F,
3.4188370e-03F,
3.4926249e-03F,
3.5547910e-03F,
3.6054338e-03F,
3.6446793e-03F,
3.6726794e-03F,
3.6896115e-03F,
3.6956764e-03F,
3.6910978e-03F,
3.6761209e-03F,
3.6510110e-03F,
3.6160525e-03F,
3.5715476e-03F,
3.5178150e-03F,
3.4551890e-03F,
3.3840180e-03F,
3.3046634e-03F,
3.2174985e-03F,
3.1229071e-03F,
3.0212827e-03F,
2.9130270e-03F,
2.7985490e-03F,
2.6782638e-03F,
2.5525915e-03F,
2.4219561e-03F,
2.2867845e-03F,
2.1475056e-03F,
2.0045488e-03F,
1.8583437e-03F,
1.7093185e-03F,
1.5578996e-03F,
1.4045102e-03F,
1.2495699e-03F,
1.0934933e-03F,
9.3668996e-04F,
7.7956268e-04F,
6.2250745e-04F,
4.6591242e-04F,
3.1015727e-04F,
1.5561253e-04F,
2.6389715e-06F,
1.4841299e-04F,
2.9720388e-04F,
4.4340565e-04F,
5.8670219e-04F,
7.2678980e-04F,
8.6337758e-04F,
9.9618785e-04F,
1.1249565e-03F,
1.2494332e-03F,
1.3693819e-03F,
1.4845808e-03F,
1.5948230e-03F,
1.6999160e-03F,
1.7996826e-03F,
1.8939604e-03F,
1.9826024e-03F,
2.0654765e-03F,
2.1424659e-03F,
2.2134692e-03F,
2.2783999e-03F,
2.3371867e-03F,
2.3897730e-03F,
2.4361175e-03F,
2.4761932e-03F,
2.5099877e-03F,
2.5375029e-03F,
2.5587548e-03F,
2.5737730e-03F,
2.5826007e-03F,
2.5852944e-03F,
2.5819231e-03F,
2.5725687e-03F,
2.5573250e-03F,
2.5362976e-03F,
2.5096035e-03F,
2.4773705e-03F,
2.4397370e-03F,
2.3968515e-03F,
2.3488718e-03F,
2.2959650e-03F,
2.2383067e-03F,
2.1760809e-03F,
2.1094788e-03F,
2.0386989e-03F,
1.9639463e-03F,
1.8854321e-03F,
1.8033729e-03F,
1.7179904e-03F,
1.6295107e-03F,
1.5381637e-03F,
1.4441828e-03F,
1.3478043e-03F,
1.2492667e-03F,
1.1488105e-03F,
1.0466772e-03F,
9.4310914e-04F,
8.3834897e-04F,
7.3263900e-04F,
6.2622075e-04F,
5.1933447e-04F,
4.1221868e-04F,
3.0510965e-04F,
1.9824096e-04F,
9.1843053e-05F,
1.3857216e-05F,
1.1863699e-04F,
2.2227785e-04F,
3.2456616e-04F,
4.2529352e-04F,
5.2425708e-04F,
6.2125991e-04F,
7.1611135e-04F,
8.0862730e-04F,
8.9863055e-04F,
9.8595106e-04F,
1.0704262e-03F,
1.1519010e-03F,
1.2302285e-03F,
1.3052698e-03F,
1.3768943e-03F,
1.4449798e-03F,
1.5094130e-03F,
1.5700891e-03F,
1.6269125e-03F,
1.6797963e-03F,
1.7286628e-03F,
1.7734436e-03F,
1.8140793e-03F,
1.8505197e-03F,
1.8827239e-03F,
1.9106601e-03F,
1.9343058e-03F,
1.9536476e-03F,
1.9686809e-03F,
1.9794105e-03F,
1.9858497e-03F,
1.9880206e-03F,
1.9859542e-03F,
1.9796897e-03F,
1.9692746e-03F,
1.9547647e-03F,
1.9362235e-03F,
1.9137225e-03F,
1.8873404e-03F,
1.8571635e-03F,
1.8232849e-03F,
1.7858045e-03F,
1.7448288e-03F,
1.7004705e-03F,
1.6528483e-03F,
1.6020863e-03F,
1.5483144e-03F,
1.4916671e-03F,
1.4322839e-03F,
1.3703087e-03F,
1.3058892e-03F,
1.2391771e-03F,
1.1703275e-03F,
1.0994985e-03F,
1.0268509e-03F,
9.5254779e-04F,
8.7675451e-04F,
7.9963790e-04F,
7.2136619e-04F,
6.4210860e-04F,
5.6203495e-04F,
4.8131539e-04F,
4.0012001e-04F,
3.1861850e-04F,
2.3697985e-04F,
1.5537198e-04F,
7.3961448e-05F,
7.0868900e-06F,
8.7610184e-05F,
1.6744790e-04F,
2.4644212e-04F,
3.2443783e-04F,
4.0128320e-04F,
4.7682988e-04F,
5.5093324e-04F,
6.2345262e-04F,
6.9425162e-04F,
7.6319829e-04F,
8.3016538e-04F,
8.9503054e-04F,
9.5767654e-04F,
1.0179914e-03F,
1.0758688e-03F,
1.1312078e-03F,
1.1839134e-03F,
1.2338966e-03F,
1.2810744e-03F,
1.3253700e-03F,
1.3667128e-03F,
1.4050389e-03F,
1.4402904e-03F,
1.4724164e-03F,
1.5013722e-03F,
1.5271199e-03F,
1.5496282e-03F,
1.5688725e-03F,
1.5848348e-03F,
1.5975038e-03F,
1.6068747e-03F,
1.6129494e-03F,
1.6157363e-03F,
1.6152502e-03F,
1.6115123e-03F,
1.6045501e-03F,
1.5943973e-03F,
1.5810937e-03F,
1.5646851e-03F,
1.5452230e-03F,
1.5227648e-03F,
1.4973734e-03F,
1.4691168e-03F,
1.4380685e-03F,
1.4043070e-03F,
1.3679155e-03F,
1.3289821e-03F,
1.2875990e-03F,
1.2438629e-03F,
1.1978745e-03F,
1.1497381e-03F,
1.0995618e-03F,
1.0474568e-03F,
9.9353765e-04F,
9.3792152e-04F,
8.8072831e-04F,
8.2208022e-04F,
7.6210159e-04F,
7.0091858e-04F,
6.3865892e-04F,
5.7545171e-04F,
5.1142708e-04F,
4.4671601e-04F,
3.8145000e-04F,
3.1576086e-04F,
2.4978043e-04F,
1.8364033e-04F,
1.1747173e-04F,
5.1405033e-05F,
1.4430287e-05F,
7.9905993e-05F,
1.4489530e-04F,
2.0927311e-04F,
2.7291624e-04F,
3.3570369e-04F,
3.9751679e-04F,
4.5823948e-04F,
5.1775846e-04F,
5.7596347e-04F,
6.3274739e-04F,
6.8800652e-04F,
7.4164067e-04F,
7.9355341e-04F,
8.4365219e-04F,
8.9184850e-04F,
9.3805802e-04F,
9.8220077e-04F,
1.0242012e-03F,
1.0639884e-03F,
1.1014961e-03F,
1.1366627e-03F,
1.1694318e-03F,
1.1997515e-03F,
1.2275754e-03F,
1.2528618e-03F,
1.2755744e-03F,
1.2956820e-03F,
1.3131585e-03F,
1.3279831e-03F,
1.3401404e-03F,
1.3496199e-03F,
1.3564167e-03F,
1.3605308e-03F,
1.3619676e-03F,
1.3607375e-03F,
1.3568560e-03F,
1.3503438e-03F,
1.3412264e-03F,
1.3295342e-03F,
1.3153025e-03F,
1.2985711e-03F,
1.2793848e-03F,
1.2577925e-03F,
1.2338476e-03F,
1.2076080e-03F,
1.1791353e-03F,
1.1484954e-03F,
1.1157579e-03F,
1.0809962e-03F,
1.0442871e-03F,
1.0057107e-03F,
9.6535047e-04F,
9.2329277e-04F,
8.7962681e-04F,
8.3444444e-04F,
7.8783999e-04F,
7.3991002e-04F,
6.9075318e-04F,
6.4046997e-04F,
5.8916256e-04F,
5.3693460e-04F,
4.8389098e-04F,
4.3013763e-04F,
3.7578137e-04F,
3.2092961e-04F,
2.6569022e-04F,
2.1017127e-04F,
1.5448087e-04F,
9.8726921e-05F,
4.3016943e-05F,
1.2542149e-05F,
6.7844231e-05F,
1.2278418e-04F,
1.7725804e-04F,
2.3116328e-04F,
2.8439888e-04F,
3.3686562e-04F,
3.8846619e-04F,
4.3910538e-04F,
4.8869027e-04F,
5.3713039e-04F,
5.8433785e-04F,
6.3022754e-04F,
6.7471723e-04F,
7.1772775e-04F,
7.5918311e-04F,
7.9901063e-04F,
8.3714106e-04F,
8.7350871e-04F,
9.0805151e-04F,
9.4071119e-04F,
9.7143329e-04F,
1.0001673e-03F,
1.0268667e-03F,
1.0514891e-03F,
1.0739962e-03F,
1.0943539e-03F,
1.1125323e-03F,
1.1285059e-03F,
1.1422533e-03F,
1.1537577e-03F,
1.1630063e-03F,
1.1699910e-03F,
1.1747078e-03F,
1.1771570e-03F,
1.1773433e-03F,
1.1752756e-03F,
1.1709673e-03F,
1.1644356e-03F,
1.1557020e-03F,
1.1447923e-03F,
1.1317359e-03F,
1.1165665e-03F,
1.0993215e-03F,
1.0800421e-03F,
1.0587732e-03F,
1.0355633e-03F,
1.0104642e-03F,
9.8353120e-04F,
9.5482294e-04F,
9.2440101e-04F,
8.9233004e-04F,
8.5867751e-04F,
8.2351360e-04F,
7.8691108e-04F,
7.4894512e-04F,
7.0969316e-04F,
6.6923476e-04F,
6.2765142e-04F,
5.8502646e-04F,
5.4144478e-04F,
4.9699279e-04F,
4.5175815e-04F,
4.0582968e-04F,
3.5929711e-04F,
3.1225098e-04F,
2.6478242e-04F,
2.1698300e-04F,
1.6894452e-04F,
1.2075889e-04F,
7.2517918e-05F,
2.4313159e-05F,
2.3764275e-05F,
7.1623869e-05F,
1.1917588e-04F,
1.6633150e-04F,
2.1300301e-04F,
2.5910395e-04F,
3.0454930e-04F,
3.4925557e-04F,
3.9314102e-04F,
4.3612574e-04F,
4.7813187e-04F,
5.1908366e-04F,
5.5890764e-04F,
5.9753278e-04F,
6.3489054e-04F,
6.7091505e-04F,
7.0554319e-04F,
7.3871471e-04F,
7.7037235e-04F,
8.0046188e-04F,
8.2893225e-04F,
8.5573563e-04F,
8.8082753e-04F,
9.0416681e-04F,
9.2571581e-04F,
9.4544035e-04F,
9.6330982e-04F,
9.7929720e-04F,
9.9337912e-04F,
1.0055358e-03F,
1.0157514e-03F,
1.0240133e-03F,
1.0303132e-03F,
1.0346459e-03F,
1.0370105e-03F,
1.0374092e-03F,
1.0358485e-03F,
1.0323379e-03F,
1.0268912e-03F,
1.0195251e-03F,
1.0102604e-03F,
9.9912113e-04F,
9.8613469e-04F,
9.7133194e-04F,
9.5474704e-04F,
9.3641731e-04F,
9.1638325e-04F,
8.9468837e-04F,
8.7137916e-04F,
8.4650496e-04F,
8.2011786e-04F,
7.9227258e-04F,
7.6302640e-04F,
7.3243900e-04F,
7.0057238e-04F,
6.6749069e-04F,
6.3326013e-04F,
5.9794882e-04F,
5.6162667e-04F,
5.2436523e-04F,
4.8623753e-04F,
4.4731801e-04F,
4.0768229e-04F,
3.6740708e-04F,
3.2657003e-04F,
2.8524955e-04F,
2.4352469e-04F,
2.0147499e-04F,
1.5918031e-04F,
1.1672069e-04F,
7.4176215e-05F,
3.1626851e-05F,
1.0847706e-05F,
5.3168170e-05F,
9.5255814e-05F,
1.3703261e-04F,
1.7842138e-04F,
2.1934593e-04F,
2.5973119e-04F,
2.9950335e-04F,
3.3859000e-04F,
3.7692023e-04F,
4.1442481e-04F,
4.5103625e-04F,
4.8668898e-04F,
5.2131942e-04F,
5.5486611e-04F,
5.8726982e-04F,
6.1847364e-04F,
6.4842309e-04F,
6.7706620e-04F,
7.0435363e-04F,
7.3023869e-04F,
7.5467748e-04F,
7.7762895e-04F,
7.9905491e-04F,
8.1892019e-04F,
8.3719260e-04F,
8.5384305e-04F,
8.6884554e-04F,
8.8217723e-04F,
8.9381846e-04F,
9.0375281e-04F,
9.1196704e-04F,
9.1845119e-04F,
9.2319854e-04F,
9.2620562e-04F,
9.2747220e-04F,
9.2700130e-04F,
9.2479917e-04F,
9.2087525e-04F,
9.1524213e-04F,
9.0791557e-04F,
8.9891442e-04F,
8.8826057e-04F,
8.7597892e-04F,
8.6209732e-04F,
8.4664650e-04F,
8.2966002e-04F,
8.1117417e-04F,
7.9122792e-04F,
7.6986285e-04F,
7.4712300e-04F,
7.2305487e-04F,
6.9770727e-04F,
6.7113121e-04F,
6.4337985e-04F,
6.1450837e-04F,
5.8457383e-04F,
5.5363511e-04F,
5.2175278e-04F,
4.8898894e-04F,
4.5540717e-04F,
4.2107236e-04F,
3.8605060e-04F,
3.5040903e-04F,
3.1421578e-04F,
2.7753977e-04F,
2.4045059e-04F,
2.0301841e-04F,
1.6531382e-04F,
1.2740770e-04F,
8.9371071e-05F,
5.1275012e-05F,
1.3190480e-05F,
2.4811799e-05F,
6.2661463e-05F,
1.0028864e-04F,
1.3762409e-04F,
1.7459931e-04F,
2.1114667e-04F,
2.4719954e-04F,
2.8269239e-04F,
3.1756094e-04F,
3.5174225e-04F,
3.8517482e-04F,
4.1779875e-04F,
4.4955579e-04F,
4.8038948e-04F,
5.1024523e-04F,
5.3907041e-04F,
5.6681448e-04F,
5.9342901e-04F,
6.1886783e-04F,
6.4308708e-04F,
6.6604527e-04F,
6.8770337e-04F,
7.0802487e-04F,
7.2697584e-04F,
7.4452499e-04F,
7.6064369e-04F,
7.7530606e-04F,
7.8848898e-04F,
8.0017213e-04F,
8.1033803e-04F,
8.1897205e-04F,
8.2606244e-04F,
8.3160032e-04F,
8.3557973e-04F,
8.3799758e-04F,
8.3885371e-04F,
8.3815081e-04F,
8.3589447e-04F,
8.3209313e-04F,
8.2675805e-04F,
8.1990331e-04F,
8.1154573e-04F,
8.0170490e-04F,
7.9040305e-04F,
7.7766509e-04F,
7.6351847e-04F,
7.4799321e-04F,
7.3112175e-04F,
7.1293896e-04F,
6.9348201e-04F,
6.7279033e-04F,
6.5090553e-04F,
6.2787129e-04F,
6.0373329e-04F,
5.7853915e-04F,
5.5233828e-04F,
5.2518182e-04F,
4.9712254e-04F,
4.6821472e-04F,
4.3851406e-04F,
4.0807759e-04F,
3.7696352e-04F,
3.4523115e-04F,
3.1294077e-04F,
2.8015354e-04F,
2.4693136e-04F,
2.1333677e-04F,
1.7943283e-04F,
1.4528299e-04F,
1.1095100e-04F,
7.6500754e-05F,
4.1996207e-05F,
7.5012377e-06F,
2.6920463e-05F,
6.1205510e-05F,
9.5290939e-05F,
1.2911432e-04F,
1.6261388e-04F,
1.9572859e-04F,
2.2839832e-04F,
2.6056388e-04F,
2.9216721e-04F,
3.2315140e-04F,
3.5346086e-04F,
3.8304137e-04F,
4.1184020e-04F,
4.3980621e-04F,
4.6688992e-04F,
4.9304360e-04F,
5.1822136e-04F,
5.4237923e-04F,
5.6547524e-04F,
5.8746947e-04F,
6.0832413e-04F,
6.2800365e-04F,
6.4647469e-04F,
6.6370624e-04F,
6.7966964e-04F,
6.9433864e-04F,
7.0768944e-04F,
7.1970074e-04F,
7.3035374e-04F,
7.3963220e-04F,
7.4752245e-04F,
7.5401341e-04F,
7.5909659e-04F,
7.6276613e-04F,
7.6501879e-04F,
7.6585391e-04F,
7.6527348e-04F,
7.6328207e-04F,
7.5988683e-04F,
7.5509747e-04F,
7.4892627e-04F,
7.4138798e-04F,
7.3249985e-04F,
7.2228157e-04F,
7.1075521e-04F,
6.9794521e-04F,
6.8387829e-04F,
6.6858343e-04F,
6.5209179e-04F,
6.3443664e-04F,
6.1565332e-04F,
5.9577915e-04F,
5.7485336e-04F,
5.5291703e-04F,
5.3001297e-04F,
5.0618569e-04F,
4.8148126e-04F,
4.5594726e-04F,
4.2963269e-04F,
4.0258784e-04F,
3.7486424e-04F,
3.4651452e-04F,
3.1759234e-04F,
2.8815228e-04F,
2.5824974e-04F,
2.2794083e-04F,
1.9728228e-04F,
1.6633131e-04F,
1.3514554e-04F,
1.0378290e-04F,
7.2301466e-05F,
4.0759430e-05F,
9.2149344e-06F,
2.2274009e-05F,
5.3649632e-05F,
8.4854513e-05F,
1.1583168e-04F,
1.4652472e-04F,
1.7687787e-04F,
2.0683614e-04F,
2.3634538e-04F,
2.6535239e-04F,
2.9380504e-04F,
3.2165232e-04F,
3.4884447e-04F,
3.7533304e-04F,
4.0107098e-04F,
4.2601274e-04F,
4.5011434e-04F,
4.7333344e-04F,
4.9562942e-04F,
5.1696344e-04F,
5.3729854e-04F,
5.5659965e-04F,
5.7483369e-04F,
5.9196963e-04F,
6.0797850e-04F,
6.2283349e-04F,
6.3650996e-04F,
6.4898547e-04F,
6.6023986e-04F,
6.7025524e-04F,
6.7901604e-04F,
6.8650903e-04F,
6.9272333e-04F,
6.9765042e-04F,
7.0128418e-04F,
7.0362086e-04F,
7.0465909e-04F,
7.0439990e-04F,
7.0284668e-04F,
7.0000521e-04F,
6.9588358e-04F,
6.9049224e-04F,
6.8384391e-04F,
6.7595362e-04F,
6.6683862e-04F,
6.5651837e-04F,
6.4501449e-04F,
6.3235072e-04F,
6.1855287e-04F,
6.0364878e-04F,
5.8766824e-04F,
5.7064295e-04F,
5.5260644e-04F,
5.3359405e-04F,
5.1364279e-04F,
4.9279132e-04F,
4.7107986e-04F,
4.4855013e-04F,
4.2524523e-04F,
4.0120959e-04F,
3.7648889e-04F,
3.5112996e-04F,
3.2518068e-04F,
2.9868991e-04F,
2.7170741e-04F,
2.4428369e-04F,
2.1647000e-04F,
1.8831816e-04F,
1.5988051e-04F,
1.3120979e-04F,
1.0235904e-04F,
7.3381532e-05F,
4.4330643e-05F,
1.5259766e-05F,
1.3777787e-05F,
4.2728881e-05F,
7.1540655e-05F,
1.0016062e-04F,
1.2853676e-04F,
1.5661760e-04F,
1.8435234e-04F,
2.1169090e-04F,
2.3858407e-04F,
2.6498352e-04F,
2.9084196e-04F,
3.1611318e-04F,
3.4075214e-04F,
3.6471505e-04F,
3.8795948e-04F,
4.1044438e-04F,
4.3213018e-04F,
4.5297885e-04F,
4.7295401e-04F,
4.9202090e-04F,
5.1014655e-04F,
5.2729974e-04F,
5.4345112e-04F,
5.5857322e-04F,
5.7264051e-04F,
5.8562947e-04F,
5.9751857e-04F,
6.0828834e-04F,
6.1792142e-04F,
6.2640254e-04F,
6.3371859e-04F,
6.3985859e-04F,
6.4481375e-04F,
6.4857748e-04F,
6.5114535e-04F,
6.5251514e-04F,
6.5268682e-04F,
6.5166256e-04F,
6.4944670e-04F,
6.4604576e-04F,
6.4146839e-04F,
6.3572539e-04F,
6.2882967e-04F,
6.2079620e-04F,
6.1164201e-04F,
6.0138615e-04F,
5.9004962e-04F,
5.7765538e-04F,
5.6422824e-04F,
0.0F,
0.0F,
0.0F,
0.0F,
0.0F,
0.0F,
0.0F,
0.0F,
0.0F,
0.0F,
0.0F,
0.0F
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\voxware\warp.c ===
/******************************************************************************
*                        Voxware Proprietary Material
*                        Copyright 1996, Voxware, Inc
*                            All Rights Reserved
*
*                       DISTRIBUTION PROHIBITED without
*                      written authorization from Voxware
******************************************************************************/
 
/******************************************************************************
* Filename:        warp.c
* Purpose:         Spectral warping
* Functions:
* Author/Date:     Bob Dunn 10/7/97
*******************************************************************************
*
* Modifications:
*
* Comments:
*           This code applies the warping function corresponding 
*             to the parameter values:
*
*             #define FC_LINEAR   1200.0F
*             #define BW_LINEAR     95.0F
*             #define BW_MAX       200.0F
*             #define FREQ_DC        0.0F
*             #define FREQ_LPC    4000.0F
*
*             The floating point and fixed point computation of indices
*             are both matlab approximations of the tabular version.
*             The approximation assumes PI=256 DFT samples.
*             For the fixed point code, the approximation is linear 
*             below 87 DFT samples and quadratic at and above 87 DFT 
*             samples.   For the floating point code the cutoff is
*             at 97.  It may appear inconsistent that these cutoffs
*             are different, but the curve is still pretty linear
*             betweern 87 and 97 DFT samples.
*
*             The fixed point version of the approximation will work on
*             16 bit platforms.  The indices generated by the fixed point 
*             version vary by +/- 1 from the floating point version.
*             Also, for the UnWarp function, the indices generated by 
*             the fixed point version are not monotonically increasing.
*
*             The code can only warp and unwarp 256 point envelopes.
*             The code allows for warping in place (i.e. the
*             input and output arrays can be the same).
*
*
* Concerns:
*
* $Header:   /export/phobos/pvcs/r_and_d/archives/scaleable/utils/warp.c_v   1.7   10 Apr 1998 15:29:36   bobd  $
*
******************************************************************************/
#include <math.h>
#include <assert.h>

#include "vLibMath.h"
#include "VoxMem.h"
#include "codec.h"

#include "warp.h"

#include "xvocver.h"

/*---------------------------------------------------------------------
  The coefficients below are for the linear and quadratic 
    approximations to the warping curve.  The coefficients are
    divisible by 2^8 or 2^17 to facilitate writing a fixed point
    version of the code.  

  IMPORTANT NOTE:  The quadratic curve is guaranteed to stay below
    256.0 if the input frequency is less than 256.0.  This is very
    important in SetAmps.c because the returned frequency(/index)
    will be out of bounds if this condition does not hold.
---------------------------------------------------------------------*/
#define QUAD_C    1.78906250F       /* (2^8)*QUAD_C is an integer    */
#define QUAD_B    1.40234375F       /* (2^8)*QUAD_B is an integer    */
#define QUAD_A   -0.00160217285156F /* (2^17)*QUAD_A is an integer   */
#define LINEAR_A  1.26953125F       /* (2^8)*LINEAR_A is an integer  */

/*******************************************************************************
*
* Function:  VoxWarpSC36()
*
* Action:    Perceptually warp a spectral magnitude or phase envelope. The 
*              warping function streatches low frequency regions and
*              compresses high frequency regions.  The warping function
*              is linear in the low end an quadratic in the high end.
*
* Input:     float *pfIn  --> 256 point envelope (magintude or phase)
*                               on a linear scale.
*            
* Output:    float *pfOut --> 256 point envelope (magintude or phase)
*                               on a non-linear perceptually warped scale.
*
* Globals:   none
*
* Return:    void
********************************************************************************
*
* Modifications:
*
* Comments:  1) The warping may be done in place (i.e. pfIn=pfOut).
*            2) The fixed point index computation is valid for 16 bit
*                 as well as 32 bit word lengths.  This was written in
*                 fixed point for speed.
*            3) If speed is more important that memory size, this code
*                 should be implemented with a look-up table using
*                 256 words of ROM.
*
* Concerns/TBD:
*******************************************************************************/

void VoxWarpSC36( float *pfIn, float *pfOut)
{
   unsigned int i;
   unsigned long i0;
   unsigned long lIndex;
   unsigned int iIndex;

   /*--------------------------------------------------------
     Skip to the end of the pfOut array.  By starting at the 
       end of the array where the envelope is compressed, 
       the warping may be done in place.
   --------------------------------------------------------*/
   pfOut += 255;

   /*--------------------------------------------------------
     Set the initial value for i0 in the quadratic region.  
       This is: i0 = 162*255+128 = 41600
   --------------------------------------------------------*/
   i0 = 41600L;

   /*--------------------------------------------------------
     Compute warping indices with a quadratic curve in the
       region (86 < i < 256)
   --------------------------------------------------------*/
   for (i=255; i>86; i--)
   {
      i0 -= 162L;
      lIndex = i0 >> 8;
      lIndex += 65;
      lIndex *= i;
      lIndex += 209;
      iIndex = (int)(lIndex >> 8);
      iIndex += 29;
      *pfOut-- = pfIn[iIndex];
   }
 
   /*--------------------------------------------------------
     Set the initial value for i0 in the linear region.  
        This is: i0 = 203*87+128 = 17789
   --------------------------------------------------------*/
    i0 = 17789L;

   /*--------------------------------------------------------
     Compute warping indices with a linear curve in the
       region (0 < i < 87)
   --------------------------------------------------------*/
   for (i=87; i; i--)
   {
     i0 -= 203L;
     iIndex = (int)(i0>>8);
     *pfOut-- = pfIn[iIndex];
   }
}
 
/*******************************************************************************
*
* Function:  CaldWarpedFreq()
*
* Action:    Given a frequency in DFT samples on a linear scale, compute
*              the corresponding warped frequency.
*
* Input:     float --> frequency in DFT samples on a linear scale
*
* Output:    float --> frequency in DFT samples on the warped scale
*
* Globals:   none
*
* Return:    void
********************************************************************************
*
* Modifications:
*
* Comments:
*
* Concerns/TBD:
*******************************************************************************/

float CalcWarpedFreq( float fLinFreq )
{
   float fWarpedFreq;

   if (fLinFreq>97.0F)
   {
      /*-----------------------------------------------------
        Approximate the warping function with a quadratic
          for frequencies above 97 DFT samples.
      -----------------------------------------------------*/
      fWarpedFreq = QUAD_C + fLinFreq*(QUAD_B+QUAD_A*fLinFreq);
   } else {
      /*-----------------------------------------------------
        Approximate the warping function with a straight line
          for frequencies below 97 DFT samples.
      -----------------------------------------------------*/
      fWarpedFreq = LINEAR_A*fLinFreq;
   }

   return( fWarpedFreq );
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\voxware\vr12sc36test.c ===
#include <stdlib.h>

#define VR12	1
#define SCX		1

extern int RTmain(int,char**);
extern int STCmain(int,char**);

int main(int argc, char** argv)
{
	/************************/
	/*** Real Time Codecs ***/

	/* assign shared arguments */
	argc = 5;
	argv[2] = "-isample_m.raw";
	argv[3] = "-vsample_m.vox";

	/*** VR12 ***/
	#if (VR12 == 1)
		argv[1] = "-cVR12";
		argv[4] = "-osample_m_c_VR12.raw";
		RTmain(argc,argv);
	#endif

	
	/**********************/
	/*** Scalable Codes ***/

	/* assign shared arguments */
	argc = 4;

	/*** SCX ***/
	#if (SCX == 1)
		argv[1] = "-iSCX";
		argv[2] = "sample_m.raw";		/* need to reassign both input and output files for scalable codecs */
		argv[3] = "sample_m_c_SCX.raw";
		STCmain(argc,argv);
	#endif

	return(0);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\voxware\inc\vci.h ===
/******************************************************************************
*                        Voxware Proprietary Material
*                        Copyright 1996, Voxware, Inc
*                            All Rights Reserved
*
*                       DISTRIBUTION PROHIBITED without
*                      written authorization from Voxware
******************************************************************************/

/******************************************************************************
* Filename:        vci.h
*
* Purpose:   Defines the interface data structures needed for the Voxware
*            Core Interface (VCI).
*
* Structure: VCI_CODEC_IO_BLOCK, VCI_CODEC_INFO_BLOCK
*
* Author/Date:     Ilan Berci, Epiphany Vera
*******************************************************************************
*
* Modifications:
*
* Comments:
*
* Concerns:
*
* $Header:   /export/phobos/pvcs/r_and_d/archives/realtime/vci/vci.h_v   1.1   13 Feb 1998 10:42:36   weiwang  $
******************************************************************************/

#ifndef _VCI_H_
#define _VCI_H_

/* Donavan's VCI switch */
#define VCI_SEGMENTED_MODEL_SWITCH 0

#ifdef __cplusplus
extern "C"
{
#endif

#ifndef _VCI_RETCODE_
#define _VCI_RETCODE_
typedef unsigned short VCI_RETCODE; /* Voxware Core Interface error type.    */
                                    /* This variable is also defined in      */
                                    /* vciError.h.                           */
#endif  /** #ifndef _VCI_RETCODE_ **/


/* ************************************************************************* */
/*                                 VCI Defines                               */
/* ************************************************************************* */
#define VCI_VERSION 4

/* ************************************************************************* */
/*                                                                           */
/* STRUCTURE: VCI_CODEC_CONTROL_BLOCK                                        */
/* PURPOSE :  Used for I/O between the codec and the calling program.        */
/*                                                                           */
/*                                                                           */
/* ************************************************************************* */
typedef struct 
{
  /* PCM Data buffer variables                                               */
                                  /* Buffer of signed 16 bit PCM samples.    */
  signed short   *pPCMBuffer;               
                                  /* Number of samples in PCMBuffer          */
  unsigned short wSamplesInPCMBuffer;

  /* Compressed bit-stream buffer variables                                  */
                                  /* Buffer of compressed bit-stream data    */
  unsigned char  *pVoxBuffer;     
                                  /* Size of VoxBuffer in bytes              */
  unsigned short wVoxBufferSize;
                                  /* Diagram of the VoxBuffer. The "D" repr- */
                                  /* esents byte with at least 1 bit of data */
                                  /* _______________________________________
                                    |                  DDDDDDDDDDDDDD       |
                                    |__________________^____________^_______|
                                    ^                  ^            ^       ^
                                    |<-ReadByteOffset->|            |       |
                                    |                               |       |
                                    |<------WriteByteOffset-------->|       |
                                    |                               |       |
                                    |<-------------BufferSize-------------->|
                                    |
                                    |<---Begining of buffer (i.e. pVoxBuffer)
                                                                             */
                                  /* The offset in bytes, from the beginning */
                                  /* of the buffer, of the first byte to     */
                                  /* start reading from.                     */
  unsigned short wVoxBufferReadByteOffset;
                                  /* The offset in bits, from the most sign- */
                                  /* ificant bit, to start reading from.     */
  unsigned char  chVoxBufferReadBitOffset;
                                  /* The offset in bytes, from the beginning */
                                  /* of the buffer, of the first byte to     */
                                  /* start writing to.                       */
  unsigned short wVoxBufferWriteByteOffset;
                                  /* The offset in bits, from the most sign- */
                                  /* ificant bit, to start writing to.       */
  unsigned char  chVoxBufferWriteBitOffset;
   
} VCI_CODEC_IO_BLOCK;



/* ************************************************************************* */
/*                                                                           */
/* STRUCTURE: VCI_CODEC_INFO_BLOCK                                           */
/* PURPOSE :  Used for getting information about the codec.                  */
/*                                                                           */
/*                                                                           */
/* ************************************************************************* */
 typedef struct
 {
   /* VCI Codec API information.              */
   unsigned short wVCIVersion;
   
   /* Variables for codec identification.     */
   char           sCodecVersion[32];  
   unsigned long  dwCodecClassID;      
   unsigned long  dwCodecID;
   
   /* PCM Data formats.                       */
   unsigned short wSamplingRate;   
   unsigned short wNumBitsPerSample;
   unsigned short wNumSamplesPerFrame;
   
   /* Multi-channel support.                  */
   unsigned short wNumChannels;
   unsigned short wInterleaveBlockSize;
   
   /* Bitstream information.                  */
   unsigned long dwBitRate;
   unsigned long dwMinPacketBits;
   unsigned long dwAvgPacketBits;
   unsigned long dwMaxPacketBits;
      
   /* Prime Flush Information   */
   unsigned short wNumPrimeFlushFrames;
   unsigned short wNumPrimeFlushSamples;
 } VCI_CODEC_INFO_BLOCK;

#ifdef __cplusplus
}
#endif /* __cplusplus */

#endif /** #ifndef _VCI_H_ **/
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\voxware\inc\vcierror.h ===
/******************************************************************************
*                        Voxware Proprietary Material
*                        Copyright 1996, Voxware, Inc
*                            All Rights Reserved
*
*                       DISTRIBUTION PROHIBITED without
*                      written authorization from Voxware
******************************************************************************/

/******************************************************************************
* Filename:        vciError.h
*
* Purpose:     Defines the Voxware Core Interface (VCI) error values
*
* Author/Date: Ilan Berci, Sept. 25, 1996
*******************************************************************************
*
* Modifications:
*
* Comments:
*
* Concerns:
*
* $Header:   P:/r_and_d/archives/common/vci/vciError.h_v   1.4   28 Aug 1998 10:36:10   johnp  $
******************************************************************************/

#ifndef _VCI_ERROR_H_
#define _VCI_ERROR_H_

#ifndef _VCI_RETCODE_
#define _VCI_RETCODE_
typedef unsigned short VCI_RETCODE; /* Voxware Core Interface error type.     */
                                    /* This variable is also defined in vci.h */
#endif  /** #ifndef _VCI_RETCODE_ **/

#define VCI_NO_ERROR                      0
#define VCI_FAILED_MEM_ALLOC           6000
#define VCI_NOT_VCI_HANDLE             6100
#define VCI_INCOMPATIBLE_HANDLE        6105
#define VCI_NOT_ENC_HANDLE             6110
#define VCI_NOT_DEC_HANDLE             6115
#define VCI_NULL_IO_BLOCK              6120
#define VCI_NULL_PCM_BUFFER            6125
#define VCI_NULL_VOX_BUFFER            6130
#define VCI_INVALID_R_BIT_OFFSET       6135
#define VCI_INVALID_W_BIT_OFFSET       6140
#define VCI_INVALID_R_BYTE_OFFSET      6145
#define VCI_INVALID_W_BYTE_OFFSET      6150
#define VCI_INSUFFICIENT_VOX_DATA      6155
#define VCI_NULL_INFO_BLOCK            6160
#define VCI_ARG_OUT_OF_RANGE           6165
#define VCI_NULL_ARG                   6170
#define VCI_NO_EXTENSION_SUPPORT       6175
#define VCI_WRONG_PITCH_MODE           6180
#define VCI_CODEC_NOT_SUPPORTED        6500 
#define VCI_CODEC_OUT_OF_DATE          6501 
#define VCI_EXT_OUT_OF_DATE            6502
#define VCI_EXTENSION_NOT_ENABLED      6503 
#define VCI_BITSTREAM_CORRUPTED        6185
#define VCI_BITSTREAM_NOT_SUPPORTED    6186
#define VCI_BITSTREAM_INSUFFICIENT     6187
#define VCI_BITSTREAM_FULL             6189
#define VCI_RATE_SET_TO_MAX            6190
#define VCI_RATE_INVALID               6191
#define VCI_DYNAMIC_ARG_NOT_FOUND      6200
#define VCI_PLUS_NOT_INITIALIZED       6210

#define VCI_IO_BLK_PARAM_CHECK(a) \
   if(!a) \
      return VCI_NULL_ARG; \
   if(!a->pVoxBuffer) \
      return VCI_NULL_VOX_BUFFER; \
   if(!(a->pPCMBuffer)) \
      return VCI_NULL_PCM_BUFFER; \
   if(a->wVoxBufferReadByteOffset>=a->wVoxBufferSize) \
      return VCI_INVALID_R_BYTE_OFFSET; \
   if(a->wVoxBufferWriteByteOffset>=a->wVoxBufferSize) \
      return VCI_INVALID_W_BYTE_OFFSET; \
   if(a->chVoxBufferReadBitOffset>7) \
      return VCI_INVALID_R_BIT_OFFSET; \
   if(a->chVoxBufferWriteBitOffset>7) \
      return VCI_INVALID_W_BIT_OFFSET; 

#define VCI_EXTRACT_IO_BLK_PARAM_CHECK(a) \
   if(!a) \
      return VCI_NULL_ARG; \
   if(!a->pVoxBuffer) \
      return VCI_NULL_VOX_BUFFER; \
   if(a->wVoxBufferReadByteOffset>=a->wVoxBufferSize) \
      return VCI_INVALID_R_BYTE_OFFSET; \
   if(a->wVoxBufferWriteByteOffset>=a->wVoxBufferSize) \
      return VCI_INVALID_W_BYTE_OFFSET; \
   if(a->chVoxBufferReadBitOffset>7) \
      return VCI_INVALID_R_BIT_OFFSET; \
   if(a->chVoxBufferWriteBitOffset>7) \
      return VCI_INVALID_W_BIT_OFFSET; 

#define VCI_IO_BLK_PARAM_CHECK_ENC(a) \
   if(!a) \
      return VCI_NULL_ARG; \
   if(!a->pPCMBuffer) \
      return VCI_NULL_PCM_BUFFER; \
   if(!a->pVoxBuffer) \
      return VCI_NULL_VOX_BUFFER; \
   if(a->wVoxBufferWriteByteOffset>=a->wVoxBufferSize) \
      return VCI_INVALID_W_BYTE_OFFSET; \
   if(a->chVoxBufferWriteBitOffset>7) \
      return VCI_INVALID_W_BIT_OFFSET; 

#define VCI_IO_BLK_PARAM_CHECK_DEC(a) \
   if(!a) \
      return VCI_NULL_ARG; \
   if(!a->pPCMBuffer) \
      return VCI_NULL_PCM_BUFFER; \
   if(!a->pVoxBuffer) \
      return VCI_NULL_VOX_BUFFER; \
   if(a->wVoxBufferReadByteOffset>=a->wVoxBufferSize) \
      return VCI_INVALID_R_BYTE_OFFSET; \
   if(a->chVoxBufferReadBitOffset>7) \
      return VCI_INVALID_R_BIT_OFFSET;

#define VCI_SIL_IO_BLK_PARAM_CHECK_DEC(a) \
   if(!a) \
      return VCI_NULL_ARG; \
   if(!a->pPCMBuffer) \
      return VCI_NULL_PCM_BUFFER;

#endif /** #ifndef _VCI_ERROR_H_ **/
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\voxware\inc\vcisc3.h ===
/******************************************************************************
*                        Voxware Proprietary Material
*                        Copyright 1996, Voxware, Inc
*                            All Rights Reserved
*
*                       DISTRIBUTION PROHIBITED without
*                      written authorization from Voxware
******************************************************************************/

/******************************************************************************
* Filename:        vciSC3.h
*
* Purpose:         Defines the interface functions for the Voxware SC Quality codec
*
* Functions:   vciGetInfoSC3, vciEncodeSC3, vciDecodeSC3, 
*              vciInitEncodeSC3, vciInitDecodeSC3, vciFreeEncodeSC3,
*              vciFreeDecodeSC3, vciGetExtCompatibilitySC3
*
* Author/Date:     Ilan Berci, Epiphany Vera 97/05/19
*******************************************************************************
*
* Modifications:
*
* Comments:
*
* Concerns:
*
* $Header:   /export/phobos/pvcs/r_and_d/archives/scaleable/vci/vciSC3.h_v   1.2   16 Mar 1998 17:26:40   weiwang  $
******************************************************************************/
#ifndef _VCISC3
#define _VCISC3

#ifdef __cplusplus
extern "C"
{
#endif

#ifndef _VCI_RETCODE_
#define _VCI_RETCODE_
typedef unsigned short VCI_RETCODE; /* Voxware Core Interface error type.    */
                                    /* This variable is also defined in vci.h*/
#endif  /* _VCI_RETCODE_ */

/******************************************************************************
*
* Function:  vciGetInfoSC3()        
*
* Action:    Fill up information block for SC3
*
* Input:    pvciCodecInfoBlk -- pointer to the info. block
*
* Output:   pvciCodecInfoBlk -- filled up info. block
*
* Globals:   none
*
* Return:    VCI error code
*******************************************************************************/

VCI_RETCODE vciGetInfoSC3(VCI_CODEC_INFO_BLOCK *pvciCodecInfoBlk);

/******************************************************************************
*
* Function:  vciEncodeSC3()     
*
* Action:    Encodes one frame of speech using SC3.
*
* Input:    pEncodeMemBlk -- encoder structure
*           pvciCodecIOBlk -- codec I/O structure
*
* Output:   pEncodeMemBlk -- updated strcture
*           pvciCodecIOBlk -- updated strcture
*
* Globals:   none
*
* Return:    VCI error code
*******************************************************************************/

VCI_RETCODE vciEncodeSC3(void *pEncodeMemBlk, 
                         VCI_CODEC_IO_BLOCK *pvciCodecIOBlk);

/******************************************************************************
*
* Function:  vciDecodeSC3()
*
* Action:    Decodes one frame of speech using SC3.
*
* Input:    pDecodeMemBlk -- decoder structure
*           pvciCodecIOBlk -- codec I/O structure
*
* Output:   pDecodeMemBlk -- updated strcture
*           pvciCodecIOBlk -- updated strcture
*
* Globals:   none
*
* Return:    VCI error code
*******************************************************************************/

VCI_RETCODE vciDecodeSC3(void *pDecodeMemBlk, 
                         VCI_CODEC_IO_BLOCK *pvciCodecIOBlk);

/******************************************************************************
*
* Function:  vciInitEncodeSC3()
*
* Action:    To allocate memory for a Codec Memory Block and to initialize
*            it as an encoder.  
*
* Input:    hEncodeMemBlk -- the pointer to the encoder structure
*
* Output:   hEncodeMemBlk -- memory allocated and initialized encoder structure
*
* Globals:   none
*
* Return:    VCI error code
*******************************************************************************/

VCI_RETCODE vciInitEncodeSC3(void **hEncodeMemBlk);

/******************************************************************************
*
* Function:  vciInitDecodeSC3()
*
* Action:    To allocate memory for a Codec Memory Block and to initialize
*            it as a decoder.
*
* Input:    hDecodeMemBlk -- the pointer to the decoder structure
*
* Output:   hDecodeMemBlk -- allocated  and initilized structure
*
* Globals:   none
*
* Return:    VCI error code
*******************************************************************************/

VCI_RETCODE vciInitDecodeSC3(void **hDecodeMemBlk);

/******************************************************************************
*
* Function:  vciFreeEncodeSC3()
*
* Action:    Frees memory assigned to the encoder.
*
* Input:    hEncodeMemBlk -- the pointer to the encoder structure
*
* Output:   hEncodeMemBlk -- freed memory 
*
* Globals:   none
*
* Return:    VCI error code
*******************************************************************************/

VCI_RETCODE vciFreeEncodeSC3(void **hEncodeMemBlk);


/******************************************************************************
*
* Function:  vciFreeDecodeSC3()
*
* Action:    Frees memory assigned to the decoder.
*
* Input:    hDecodeMemBlk -- the pointer to the decoder structure
*
* Output:   hDecodeMemBlk -- freed memory 
*
* Globals:   none
*
* Return:    VCI error code
*******************************************************************************/

VCI_RETCODE vciFreeDecodeSC3(void **hDecodeMemBlk);

/******************************************************************************
*
* Function:  vciGetExtCompatibilitySC3()  
*
* Action:    Returns compatibility function 
*
* Input:    pCompatFunc -- the function pointer to the compatibility function
*
* Output:   pCompatFunc -- the compatibility function
*
* Globals:   none
*
* Return:    VCI return error
*******************************************************************************/

VCI_RETCODE vciGetExtCompatibilitySC3(void **pCompatFunc);

#define END_OF_FRAME     0
#define LONGER_FRAME     1

#ifdef __cplusplus
}
#endif

#endif /* _VCISC3 */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\voxware\inc\vcisc6.h ===
/******************************************************************************
*                        Voxware Proprietary Material
*                        Copyright 1996, Voxware, Inc
*                            All Rights Reserved
*
*                       DISTRIBUTION PROHIBITED without
*                      written authorization from Voxware
******************************************************************************/

/******************************************************************************
* Filename:        vciSC6.h
*
* Purpose:         Defines the interface functions for the Voxware SC Quality codec
*
* Functions:   vciGetInfoSC6, vciEncodeSC6, vciDecodeSC6, 
*              vciInitEncodeSC6, vciInitDecodeSC3, vciFreeEncodeSC6,
*              vciFreeDecodeSC6, vciGetExtCompatibilitySC6
*
* Author/Date:     Ilan Berci, Epiphany Vera 97/05/19
*******************************************************************************
*
* Modifications:
*
* Comments:
*
* Concerns:
*
* $Header:   /export/phobos/pvcs/r_and_d/archives/scaleable/vci/vciSC6.h_v   1.2   16 Mar 1998 17:26:42   weiwang  $
******************************************************************************/
#ifndef _VCISC6
#define _VCISC6

#ifdef __cplusplus
extern "C"
{
#endif

#ifndef _VCI_RETCODE_
#define _VCI_RETCODE_
typedef unsigned short VCI_RETCODE; /* Voxware Core Interface error type.     */
                                    /* This variable is also defined in vci.h */
#endif  /* _VCI_RETCODE_ */

/******************************************************************************
*
* Function:  vciGetInfoSC6() 
*
* Action:    Fill up information block for SC6
*
* Input:    pvciCodecInfoBlk -- pointer to the info. block
*
* Output:   pvciCodecInfoBlk -- filled up info. block
*
* Globals:   none
*
* Return:    VCI error code
*******************************************************************************/

VCI_RETCODE vciGetInfoSC6(VCI_CODEC_INFO_BLOCK *pvciCodecInfoBlk);

/******************************************************************************
*
* Function:  vciEncodeSC6()     
*
* Action:    Encodes one frame of speech using SC6
*
* Input:    pEncodeMemBlk -- encoder structure
*           pvciCodecIOBlk -- codec I/O structure
*
* Output:   pEncodeMemBlk -- updated strcture
*           pvciCodecIOBlk -- updated strcture
*
* Globals:   none
*
* Return:    VCI error code
*******************************************************************************/

VCI_RETCODE vciEncodeSC6(void *pEncodeMemBlk, 
                         VCI_CODEC_IO_BLOCK *pvciCodecIOBlk);


/******************************************************************************
*
* Function:  vciDecodeSC6()
*
* Action:    Decodes one frame of speech using SC6
*
* Input:    pDecodeMemBlk -- decoder structure
*           pvciCodecIOBlk -- codec I/O structure
*
* Output:   pDecodeMemBlk -- updated strcture
*           pvciCodecIOBlk -- updated strcture
*
* Globals:   none
*
* Return:    VCI error code
*******************************************************************************/

VCI_RETCODE vciDecodeSC6(void *pDecodeMemBlk, 
                         VCI_CODEC_IO_BLOCK *pvciCodecIOBlk);


/******************************************************************************
*
* Function:  vciInitEncodeSC6()
*
* Action:    To allocate memory for a Codec Memory Block and to initialize
*            it as an encoder.  
*
* Input:    hEncodeMemBlk -- the pointer to the encoder structure
*
* Output:   hEncodeMemBlk -- memory allocated and initialized encoder structure
*
* Globals:   none
*
* Return:    VCI error code
*******************************************************************************/

VCI_RETCODE vciInitEncodeSC6(void **hEncodeMemBlk);

                                     
/******************************************************************************
*
* Function:  vciInitDecodeSC6()
*
* Action:    To allocate memory for a Codec Memory Block and to initialize
*            it as a decoder.
*
* Input:    hDecodeMemBlk -- the pointer to the decoder structure
*
* Output:   hDecodeMemBlk -- allocated  and initilized structure
*
* Globals:   none
*
* Return:    VCI error code
*******************************************************************************/

VCI_RETCODE vciInitDecodeSC6(void **hDecodeMemBlk);

/******************************************************************************
*
* Function:  vciFreeEncodeSC6()
*
* Action:    Frees memory assigned to the encoder.
*
* Input:    hEncodeMemBlk -- the pointer to the encoder structure
*
* Output:   hEncodeMemBlk -- freed memory 
*
* Globals:   none
*
* Return:    VCI error code
*******************************************************************************/

VCI_RETCODE vciFreeEncodeSC6(void **hEncodeMemBlk);

/******************************************************************************
*
* Function:  vciFreeDecodeSC6()
*
* Action:    Frees memory assigned to the decoder.
*
* Input:    hDecodeMemBlk -- the pointer to the decoder structure
*
* Output:   hDecodeMemBlk -- freed memory 
*
* Globals:   none
*
* Return:    VCI error code
*******************************************************************************/

VCI_RETCODE vciFreeDecodeSC6(void **hDecodeMemBlk);

/******************************************************************************
*
* Function:  vciGetExtCompatibilitySC6()  
*
* Action:    Returns compatibility function 
*
* Input:    pCompatFunc -- the function pointer to the compatibility function
*
* Output:   pCompatFunc -- the compatibility function
*
* Globals:   none
*
* Return:    VCI return error
*******************************************************************************/
VCI_RETCODE vciGetExtCompatibilitySC6(void **pCompatFunc);

#ifdef __cplusplus
}
#endif


#endif /* _VCISC6 */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\voxware\inc\vcivr12.h ===
/******************************************************************************
 *                                                                            *
 *		                  Voxware Proprietary Material                        *
 *		                  Copyright 1996, Voxware, Inc.                       *
 *		                       All Rights Resrved                             *
 *                                                                            *
 *		                 DISTRIBUTION PROHIBITED without                      *
 *		               written authorization from Voxware                     *
 *                                                                            *
 ******************************************************************************/

/******************************************************************************
 *                                                                            *
 * FILENAME:  vciVR12.h                                                       *
 * PURPOSE:   Defines the interface functions and defines for vciRT29.c.      *
 *                                                                            *
 *****************************************************************************/

/******************************************************************************
 *                                                                            *
 *                          DETAILED REVISION HISTORY                         *
 *                                                                            *
 * (Sept 25, '96)                                                             *
 *    Created                                                                 *
 *                                                                            *
 *****************************************************************************/


#ifndef VCIVR12_H
#define VCIVR12_H
 
#ifdef __cplusplus
extern "C"
{
#endif
                                                         
VCI_RETCODE vciGetInfoVR12(VCI_CODEC_INFO_BLOCK *pvciCodecInfoBlk);

VCI_RETCODE vciDecodeVR12(void *hCodecMemBlk, 
                          VCI_CODEC_IO_BLOCK *hvciDecodeIOBlk);
VCI_RETCODE vciEncodeVR12(void *hCodecMemBlk, 
                          VCI_CODEC_IO_BLOCK *hvciEncodeIOBlk);

VCI_RETCODE vciInitEncodeVR12(void **hCodecMemBlk);
VCI_RETCODE vciInitDecodeVR12(void **hCodecMemBlk); 
                                                      
VCI_RETCODE vciFreeEncodeVR12(void **hCodecMemBlk);                                                       
VCI_RETCODE vciFreeDecodeVR12(void **hCodecMemBlk);  

VCI_RETCODE vciGetExtCompatibilityVR12(void **ppvExtCompat);

#ifdef __cplusplus
}
#endif /* __cplusplus */

#endif /* VCIRT29_H */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\voxware\winscale.h ===
/*******************************************************************************
*                         Voxware Proprietary Material                         *
*                         Copyright 1997, Voxware, Inc                         *
*                             All Rights Reserved                              *
*                                                                              *
*                        DISTRIBUTION PROHIBITED without                       *
*                       written authorization from Voxware                     *
*******************************************************************************/
 
/*******************************************************************************
* Filename:       winscale.h
*
* Purpose:        window scale factors for different pitch values
*
* Functions:      
*
* Author/Date:    Original developed by Bob McAulay and Bob Dunn 1/97
********************************************************************************
* Modifications:  change to fLog2(winscale) by Wei Wang, 4/98
*
* Comments:
*
* Concerns:  If not use linear-approximation fLog2, the table should be 
*            recalculated.
*
* $Header:   /export/phobos/pvcs/r_and_d/archives/scaleable/tables/winscale.h_v   1.2   10 Apr 1998 11:52:28   weiwang  $
*******************************************************************************/
#ifndef WINSCALE_H
#define WINSCALE_H
3.7298565F,   /* fLog2(1.3838853e+001F), */
3.6622577F,   /* fLog2(1.3298062e+001F), */
3.5917907F,   /* fLog2(1.2734326e+001F), */
3.5180564F,   /* fLog2(1.2144450e+001F), */
3.4405527F,   /* fLog2(1.1524421e+001F), */
3.3586349F    /* fLog2(1.0869080e+001F) */
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\voxware\zargs.h ===
/******************************************************************************
*
*                        Voxware Proprietary Material
*
*                        Copyright 1996, Voxware, Inc
*
*                            All Rights Reserved
*
*
*
*                       DISTRIBUTION PROHIBITED without
*
*                      written authorization from Voxware
*
******************************************************************************/
 
/******************************************************************************
*
* Filename:      zargs.h
*
* Purpose:
*
* Functions:
*
* Author/Date:
*
* $Header:   /export/phobos/pvcs/r_and_d/archives/scaleable/testcode/zargs.h_v   1.1   20 Jan 1999 15:30:18   weiwang  $
*******************************************************************************
*
* Modifications:
*
* Comments:
*
* Concerns:
*
******************************************************************************/
#ifndef _ZARGS_H
#define _ZARGS_H

#define INT       0
#define FLOAT     1
#define BOOLEAN   2
#define FLAG      BOOLEAN
#define CHAR      3
#define STRING    4
#define PROC      5
#define DOUBLE    6

typedef struct
{
   char       *arg;        /* command line switch */
   unsigned   type;        /* variable type */
   int        *variable;   /* pointer to variable */
   char       *errmsg;     /* pointer to error message */
}
ARG;

void   zargs_prusage(ARG *tabp, int tabsize, FILE *fp);
int    zargs(int argc, char **argv, ARG *tabp, int tabsize);


#endif /* _ZARGS_H */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\voxware\window.c ===
/*******************************************************************************
*                        Voxware Proprietary Material                          *
*                        Copyright 1996, Voxware, Inc                          *
*                            All Rights Reserved                               *
*                                                                              *
*                       DISTRIBUTION PROHIBITED without                        *
*                      written authorization from Voxware                      *
*******************************************************************************/
 
/******************************************************************************
*
* Filename:      Window.c
*
* Purpose:       Use the current pitch estimate to select the pitch-adaptive
*                window.	
*
* Functions:
*
* Author/Date:   Bob McAulay/1/25/97
*
*******************************************************************************
*
* Modifications:
*                
*
* Comments:
*
* Concerns:
*
*******************************************************************************
* $Header:   /export/phobos/pvcs/r_and_d/archives/scaleable/encode/Window.c_v   1.1   10 Feb 1998 13:39:22   weiwang  $
*******************************************************************************
*
*   This software is owned by Voxware, Inc. or its suppliers.
*   Title, ownership rights, and intellectual property rights in
*   and to the software shall remain in Voxware, Inc. and/or its
*   suppliers.  The software in source code form remains a
*   confidential trade secret of Voxware, Inc. and/or its suppliers.
*
******************************************************************************/
#include <stdlib.h>
#include <assert.h>
#include <math.h>

#include "vLibMath.h"
#include "Window.h"
#include "codec.h"

#include "xvocver.h"

int VoxAdaptiveWindow ( float CoarsePitchPeriod)
{

  int iWindowLength;


  if (CoarsePitchPeriod > 96)       /* 261 (32.5ms) window */
  {
    iWindowLength = PDA_FRAME_SIZE1;
  }
  else if (CoarsePitchPeriod > 88)       /* 241 (30.0ms) window */
  {
    iWindowLength = PDA_FRAME_SIZE2;
  }
  else if (CoarsePitchPeriod > 80)       /* 221 (27.5ms) window */
  {
    iWindowLength = PDA_FRAME_SIZE3;
  }
  else if (CoarsePitchPeriod > 72)       /* 201 (25.0ms) window */
  {
    iWindowLength = PDA_FRAME_SIZE4;
  }
  else if (CoarsePitchPeriod > 64)       /* 181 (22.5ms) window */
  {
    iWindowLength = PDA_FRAME_SIZE5;
  }
  else if (CoarsePitchPeriod > 56)       /* 161 (20.0ms) window */
  {
    iWindowLength = PDA_FRAME_SIZE6;
  }
  else if (CoarsePitchPeriod > 48)       /* 141 (17.5ms) window */
  {
    iWindowLength = PDA_FRAME_SIZE7;
  }
  else if (CoarsePitchPeriod > 40)       /* 121 (15.0ms) window */
  {
    iWindowLength = PDA_FRAME_SIZE8;
  }
  else if (CoarsePitchPeriod > 32)       /* 101 (12.5ms) window */
  {
    iWindowLength = PDA_FRAME_SIZE9;
  }
  else                                   /* 81 (10.0ms) window */
  {
    iWindowLength = PDA_FRAME_SIZE10;
  }

/*:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
 
 
return iWindowLength;
 
} /*VoxAdaptiveWindow()*/
 

/********************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\voxware\warp.h ===
/******************************************************************************
*                        Voxware Proprietary Material
*                        Copyright 1996, Voxware, Inc
*                            All Rights Reserved
*
*                       DISTRIBUTION PROHIBITED without
*                      written authorization from Voxware
******************************************************************************/
 
/******************************************************************************
* Filename:        warp.h
*
* Purpose:         Spectral warping
*
* Functions:       VoxWarpSC36(), CalcWarpedFreq()
*
* Author/Date:     Bob Dunn 10/7/97
*******************************************************************************
*
* Modifications:
*
* Comments:
*
* Concerns:
*
* $Header:   /export/phobos/pvcs/r_and_d/archives/scaleable/utils/warp.h_v   1.2   10 Apr 1998 13:57:48   weiwang  $
*
******************************************************************************/
 
#ifndef WARP_H
#define WARP_H

/*******************************************************************************
*
* Function:  VoxWarpSC36()
*
* Action:    Perceptually warp a spectral magnitude or phase envelope. The
*              warping function streatches low frequency regions and
*              compresses high frequency regions.  The warping function
*              is linear in the low end an quadratic in the high end.
*
* Input:     float *pfIn  --> 256 point envelope (magintude or phase)
*                               on a linear scale.
*
* Output:    float *pfOut --> 256 point envelope (magintude or phase)
*                               on a non-linear perceptually warped scale.
*
* Globals:   none
*
* Return:    void
********************************************************************************
*
* Modifications:
*
* Comments:  1) The warping may be done in place (i.e. pfIn=pfOut).
*            2) The fixed point index computation is valid for 16 bit
*                 as well as 32 bit word lengths.  This was written in
*                 fixed point for speed.
*            3) If speed is more important that memory size, this code
*                 should be implemented with a look-up table using
*                 256 words of ROM.
*
* Concerns/TBD:
*******************************************************************************/

void VoxWarpSC36( float *pfIn, float *pfOut);

/*******************************************************************************
*
* Function:  CalcWarpedFreq()
*
* Action:    Given a frequency in DFT samples on a linear scale, compute
*              the corresponding warped frequency.
*
* Input:     float --> frequency in DFT samples on a linear scale
*
* Output:    float --> frequency in DFT samples on the warped scale
*
* Globals:   none
*
* Return:    void
********************************************************************************
*
* Modifications:
*
* Comments:
*
* Concerns/TBD:
*******************************************************************************/

float CalcWarpedFreq( float fLinFreq );


#endif /* WARP_H */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\voxware\zargs.c ===
/******************************************************************************
*
*                        Voxware Proprietary Material
*
*                        Copyright 1996, Voxware, Inc
*
*                            All Rights Reserved
*
*
*
*                       DISTRIBUTION PROHIBITED without
*
*                      written authorization from Voxware
*
******************************************************************************/
 
/******************************************************************************
*
* Filename:        zargs.c
*
* Purpose:         command line argument parsing
*
* Functions:
*
* Author/Date:
*
* $Header:   /export/phobos/pvcs/r_and_d/archives/scaleable/testcode/zargs.c_v   1.2   20 Jan 1999 15:30:18   weiwang  $
*******************************************************************************
*
* Modifications:
*
* Comments:
*
* Concerns:
*
******************************************************************************/
 
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include "zargs.h"

#include "xvocver.h"

typedef int (*PFI)(char *value);
double atof();


static char *setarg(ARG *argp, char *value);
static ARG   *findarg(char *name, ARG *tabp, int tabsize);
static int  stoi(char *str);

/*----------------------------------------------------------------------
 setarg - Set an argument
   argp points at the argument table entry to bet set.
   value points at the desired value
--------------------------------------------------------------------------*/
static char *setarg(ARG *argp, char *value)
{
   switch(argp->type)
      {
      case INT:
         *(argp->variable) = stoi(value);
         break;
      case FLOAT:
         *((float *)(argp->variable)) = (float)atof(value);
         break;
      case DOUBLE:
         *((double *)(argp->variable)) = atof(value);
         break;
      case FLAG:
         *(argp->variable) = 1;
         break;
      case CHAR:
         *(argp->variable) = value[0];
         break;
      case STRING:
         *((char **)(argp->variable)) = value;
         break;
      case PROC:
         (*(PFI)(argp->variable)) (value); /* I cannot fix this warning !! (W.W.) */
         break;
      default:
         fprintf(stderr, "zargs: Bad Argument Type\n");
#ifdef EXITBUG
         exit(0);
#else
         exit(1);
#endif
   }
   return 0;
}


/*------------------------------------------------------------
 findarg - find argument
   Return pointer to argument table entry corresponting to 
   name (or NULL if name isn't in talble)
-----------------------------------------------------------*/
static    ARG   *findarg(char *name, ARG *tabp, int tabsize)
{
   for (; --tabsize >= 0; tabp++)
      if (strcmp(tabp->arg,name) == 0)
         return tabp;
   return (NULL);
}


/*-----------------------------------------------------------------
 zargs_prusage - print the argument table for user
   Prints in form -arg <type>   error_message (value: *variable)
----------------------------------------------------------------*/
void zargs_prusage(ARG *tabp, int tabsize, FILE *fp)
{
   for(;   --tabsize >= 0; tabp++)
   {
      switch(tabp->type)
      {
         case INT:
            fprintf(fp,"-%-12s <int>    %-40s (value: ",
               tabp->arg,tabp->errmsg);
            fprintf(fp,"%-5d)\n", *(tabp->variable));
            break;
         case FLOAT:
            fprintf(fp,"-%-12s <float>  %-40s (value: ",
               tabp->arg,tabp->errmsg);
            fprintf(fp,"%-5g)\n", 
               *(float *)(tabp->variable));
            break;
         case DOUBLE:
            fprintf(fp,"-%-12s <double> %-40s (value: ",
               tabp->arg,tabp->errmsg);
            fprintf(fp,"%-5g)\n", 
               *(double *)(tabp->variable));
            break;
         case FLAG:
            fprintf(fp,"-%-12s          %-40s (value: ",
               tabp->arg,tabp->errmsg);
            fprintf(fp,"%-5s)\n", 
               *(tabp->variable) ? "TRUE":"FALSE");
            break;
         case CHAR:
            fprintf(fp,"-%-12s <char>   %-40s (value: ",
               tabp->arg,tabp->errmsg);
            fprintf(fp,"%c)\n", *(tabp->variable) );
            break;
         case STRING:
            fprintf(fp,"-%-12s <str>    %-40s (value: ",
               tabp->arg,tabp->errmsg);
            fprintf(fp,"\"%s\")\n", 
               *(char **)tabp->variable );
            break;
         case PROC:
            fprintf(fp,"-%-12s <proc>   %-40s\n",
               tabp->arg,tabp->errmsg);
            break;
      }
   }
}

/*------------------------------------------------------------------------
 stoi - convert ascii string to integer ( enhances atoi)
   If string starts with 0x it is interpreted as hex, else
   if it starts with 0 it is octal, else it is decimal.
   Conversion stops on first character not a digit in the indicated radix.
--------------------------------------------------------------------------*/
#define islower(c) ('a'<= (c) && (c) <= 'z')
#define toupper(c) ( islower(c) ? (c) - ('a' - 'A') : (c) )

static int stoi(char *str)
{
   register int   num=0;
   int            sign=1;

   while(*str == ' ' || *str == '\t' || *str == '\n')
      str++;

   if (*str == '-')
   {
      sign = -1;
      str++;
   }
   if (*str == '0')
   {
      ++str;
      if (*str == 'x' || *str == 'X')
      {
         str++;
         while( ('0' <= *str && *str <= '9') ||
               ('a' <= *str && *str <= 'f') ||
               ('A' <= *str && *str <= 'F')   )
         {
            num *= 16;
            num += ('0' <= *str && *str <= '9') ?
                         *str - '0': toupper(*str) - 'A' + 10;
            str++;
         }
      }
      else
      {
         while ('0' <= *str && *str <= '7')
         {
            num *= 8;
            num += *str++ - '0';
         }
      }
   }
   else
   {
      while ('0' <= *str && *str <= '9')
      {
         num *= 10;
         num += *str++ - '0';
      }
   }
   return (num*sign);
}

/*----------------------------------------------------------------------
 zargs - process command line arguments
   Strips all command line switches out of argv. Return new argc.
   If an error is found exit(1) is called and a usage message is printed
   showing all arguments in the table 
--------------------------------------------------------------------------*/
/* Changed by MAZ as follows:
 *
 *    (1) command line switches must begin with a '-', but can be arbitrarily
 *      long.  
 *
 *   (2) the command line consists of the function name followed by
 *      (a) pairs of non-boolean switches and values
 *      (b) boolean switches   
 *      (c) other strings which get passed back to the calling program
 *      
 */
int   zargs(int argc, char **argv, ARG *tabp, int tabsize)
{
    register int   nargc;
    register char  **nargv;
    register ARG   *argp;
    char           *switch_name;
    char           *switch_val;

    nargc = 1;
    for (nargv = ++argv; --argc > 0; argv++) 
    {
       if ( **argv != '-' ) 
       {
          *nargv++ = *argv;
          nargc++;
       }
       else if (strcmp(*argv, "--") == 0) 
       {
          /* this is a way for the user to print the possible args */
          fprintf(stderr, "Possible arguments are:\n");
          zargs_prusage (tabp, tabsize, stderr);
          exit(0);
       }
       else 
       {
          switch_name=(*argv)+1; /* move past the minus */
          argp = findarg(switch_name, tabp, tabsize);
          if (argp == NULL) 
          {
             fprintf(stderr, 
                     "zargs: bad flag \"-%s\".\nAllowable flags are:\n", 
                     switch_name);
             zargs_prusage (tabp, tabsize, stderr);
#ifdef EXITBUG
             exit(0);
#else
             exit(1);
#endif
          }
          else if (argp->type == BOOLEAN) 
          {
             setarg(argp, NULL);
          }
          else 
          {
             --argc;
             if (argc <= 0) 
             {
                fprintf(stderr, 
                        "zargs: flag \"%s\" must have an argument\n",
                        switch_name);
             }
             else 
             {
                ++argv;
                switch_val = *argv;
                setarg(argp, switch_val);
             }
          }
       }
    }
    return nargc;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\voxware\window.h ===
/*******************************************************************************
*                        Voxware Proprietary Material                          *
*                        Copyright 1996, Voxware, Inc                          *
*                            All Rights Reserved                               *
*                                                                              *
*                       DISTRIBUTION PROHIBITED without                        *
*                      written authorization from Voxware                      *
*******************************************************************************/
 
/*******************************************************************************
* $Header:   /export/phobos/pvcs/r_and_d/archives/scaleable/encode/Window.h_v   1.0   06 Feb 1998 10:06:56   johnp  $
*******************************************************************************/
#ifndef WINDOW_H
#define WINDOW_H

int VoxAdaptiveWindow ( float CoarsePitchPeriod );

#endif /* WINDOW_H */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\wmalib\asfparse_s\wmaerr.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows Media
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       wmaerr.h
//
//--------------------------------------------------------------------------

#ifndef WMAERR_H
#define WMAERR_H

#ifndef _WMAERR_DEFINED
#define _WMAERR_DEFINED
typedef int WMAERR;
#endif /* _WMAERR_DEFINED */

#define WMAERR_OK               0
#define WMAERR_FAIL             1
#define WMAERR_INVALIDARG       2
#define WMAERR_BUFFERTOOSMALL   3
#define WMAERR_INVALIDHEADER    4
#define WMAERR_OUTOFMEMORY      5
#define WMAERR_CORRUPTDATA      6
#define WMAERR_NOTDONE          7 /* need more data to finish the work */
#define WMAERR_INVALIDSTATE     8

#endif // WMAERR_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\wmalib\asfparse_s\loadstuff.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows Media
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       loadStuff.h
//
//--------------------------------------------------------------------------

#ifndef LOADSTUFF_H
#define LOADSTUFF_H

#ifdef _MSC_VER
#define LITTLE_ENDIAN
#endif

#ifdef LITTLE_ENDIAN

#define GetUnalignedWord( pb, w )   (w) = *(UNALIGNED WORD*)(pb); 

#define GetUnalignedDword( pb, dw ) (dw) = *(UNALIGNED DWORD*)(pb);

#define GetUnalignedQword( pb, qw ) (qw) = *(UNALIGNED QWORD*)(pb);

#define GetUnalignedDouble( pb, d ) (d) = *(UNALIGNED double*)(pb);

#else

#define GetUnalignedWord( pb, w ) \
            (w) = ((WORD) *(pb + 1) << 8) + *pb;

#define GetUnalignedDword( pb, dw ) \
            (dw) = ((DWORD) *(pb + 3) << 24) + \
                   ((DWORD) *(pb + 2) << 16) + \
                   ((DWORD) *(pb + 1) << 8) + *pb;

#define GetUnalignedQword( pb, qw ) \
            GetUnalignedDword( pb, (qw).dwLo ); \
            GetUnalignedDword( (pb + 4), (qw).dwHi );

#define GetUnalignedDouble( pb, d ) (d) = *(UNALIGNED double*)(pb);

#endif

#define GetUnalignedWordEx( pb, w )     GetUnalignedWord( pb, w ); (pb) += sizeof(WORD);
#define GetUnalignedDwordEx( pb, dw )   GetUnalignedDword( pb, dw ); (pb) += sizeof(DWORD);
#define GetUnalignedQwordEx( pb, qw )   GetUnalignedQword( pb, qw ); (pb) += sizeof(QWORD);
#define GetUnalignedDoubleEx( pb, d )   GetUnalignedDouble( pb, d ); (pb) += sizeof(double);

#define LoadBYTE( b, p )    b = *(BYTE *)(p);  (p) += sizeof( BYTE )

#define LoadWORD( w, p )    GetUnalignedWordEx( p, w )
#define LoadDWORD( dw, p )  GetUnalignedDwordEx( p, dw )
#define LoadQWORD( qw, p )  GetUnalignedQwordEx( p, qw )

#define LoadGUID( g, p ) \
        { \
            LoadDWORD( (g).Data1, p ); \
            LoadWORD( (g).Data2, p ); \
            LoadWORD( (g).Data3, p ); \
            LoadBYTE( (g).Data4[0], p ); \
            LoadBYTE( (g).Data4[1], p ); \
            LoadBYTE( (g).Data4[2], p ); \
            LoadBYTE( (g).Data4[3], p ); \
            LoadBYTE( (g).Data4[4], p ); \
            LoadBYTE( (g).Data4[5], p ); \
            LoadBYTE( (g).Data4[6], p ); \
            LoadBYTE( (g).Data4[7], p ); \
        }

#endif  // LOADSTUFF_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\wmalib\asfparse_s\wmaguids.h ===
/*
 * wmaguids.h:
 * Copyright (C) ARM Limited 1999. All Rights Reserved.
 */

//+-------------------------------------------------------------------------
//
//  Microsoft Windows Media
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       wmaguids.h
//
//--------------------------------------------------------------------------

#ifndef WMAGUIDS_H
#define WMAGUIDS_H

//#include <string.h>


/***************************************************************************/
#ifndef EXTERN_C
# ifdef __cplusplus
#  define EXTERN_C extern "C"
# else
#  define EXTERN_C extern
# endif
#endif


/***************************************************************************/
#ifndef INITGUID
#define WMA_DEFINE_GUID(name, l, w1, w2, b1, b2, b3, b4, b5, b6, b7, b8) \
    EXTERN_C const GUID name
#else

#define WMA_DEFINE_GUID(name, l, w1, w2, b1, b2, b3, b4, b5, b6, b7, b8) \
        EXTERN_C const GUID name; \
        EXTERN_C const GUID name \
                = { l, w1, w2, { b1, b2,  b3,  b4,  b5,  b6,  b7,  b8 } }
#endif // INITGUID

#define WMA_IsEqualGUID(rguid1, rguid2) (!memcmp((void *)rguid1, (void *)rguid2, sizeof(GUID)))


/***************************************************************************/
WMA_DEFINE_GUID(CLSID_CAsfHeaderObjectV0,
    0x75b22630,0x668e,0x11cf,0xa6,0xd9,0x00,0xaa,0x00,0x62,0xce,0x6c);

WMA_DEFINE_GUID(CLSID_CAsfPropertiesObjectV2, 
    0x8cabdca1, 0xa947, 0x11cf, 0x8e, 0xe4, 0x0, 0xc0, 0xc, 0x20, 0x53, 0x65);

WMA_DEFINE_GUID(CLSID_CAsfStreamPropertiesObjectV1, 
    0xb7dc0791, 0xa9b7, 0x11cf, 0x8e, 0xe6, 0x0, 0xc0, 0xc, 0x20, 0x53, 0x65);

WMA_DEFINE_GUID(CLSID_CAsfContentDescriptionObjectV0,
    0x75b22633,0x668e,0x11cf,0xa6,0xd9,0x00,0xaa,0x00,0x62,0xce,0x6c);

WMA_DEFINE_GUID(CLSID_CAsfDataObjectV0,
    0x75b22636,0x668e,0x11cf,0xa6,0xd9,0x00,0xaa,0x00,0x62,0xce,0x6c);

WMA_DEFINE_GUID(CLSID_AsfXNullErrorMaskingStrategy,
    0x20fb5700,0x5b55,0x11cf,0xa8,0xfd,0x00,0x80,0x5f,0x5c,0x44,0x2b);

WMA_DEFINE_GUID(CLSID_AsfXAcmAudioErrorMaskingStrategy,
    0xbfc3cd50,0x618f,0x11cf,0x8b,0xb2,0x00,0xaa,0x00,0xb4,0xe2,0x20);

WMA_DEFINE_GUID(CLSID_AsfXSignatureAudioErrorMaskingStrategy, 
    0x49f1a440, 0x4ece, 0x11d0, 0xa3, 0xac, 0x0, 0xa0, 0xc9, 0x3, 0x48, 0xf6);

WMA_DEFINE_GUID(CLSID_AsfXStreamTypeAcmAudio,
    0xf8699e40,0x5b4d,0x11cf,0xa8,0xfd,0x00,0x80,0x5f,0x5c,0x44,0x2b);

WMA_DEFINE_GUID(CLSID_CAsfContentEncryptionObject, 
    0x2211b3fb, 0xbd23, 0x11d2, 0xb4, 0xb7, 0x0, 0xa0, 0xc9, 0x55, 0xfc, 0x6e);

WMA_DEFINE_GUID( CLSID_CAsfExtendedContentDescObject,
    0xd2d0a440, 0xe307, 0x11d2, 0x97, 0xf0, 0x0, 0xa0, 0xc9, 0x5e, 0xa8, 0x50);

WMA_DEFINE_GUID(CLSID_CAsfMarkerObjectV0, 
    0xf487cd01, 0xa951, 0x11cf, 0x8e, 0xe6, 0x0, 0xc0, 0xc, 0x20, 0x53, 0x65);

WMA_DEFINE_GUID( CLSID_CAsfLicenseStoreObject, 
    0x8fa7857b, 0xddc0, 0x11d3, 0xb6, 0xbd, 0x0, 0xc0, 0x4f, 0x61, 0xd, 0x62);

WMA_DEFINE_GUID( CLSID_CAsfStreamPropertiesObjectV2, 
    0x818d0d47, 0x43, 0x4451, 0x92, 0x37, 0xda, 0xef, 0xbc, 0x48, 0x4f, 0x50);

WMA_DEFINE_GUID( CLSID_AsfXStreamTypeDRMAuxData, 
    0xd5c82c81, 0x8264, 0x4abd, 0xa7, 0x14, 0xcd, 0x4f, 0x85, 0x54, 0xc7, 0x2e);

#endif  // WMAGUIDS_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\wmalib\asfparse_s\wmatypes.h ===
/*
 * wmatypes.h:
 * Copyright (C) ARM Limited 1999. All Rights Reserved.
 */

//+-------------------------------------------------------------------------
//
//  Microsoft Windows Media
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       wmatypes.h
//
//--------------------------------------------------------------------------

#ifndef WMATYPES_H
#define WMATYPES_H

#ifdef UNDER_CE
#define PACKED
#else

#ifdef _MSC_VER
#define USE_PACK_HEADERS
#define PACKED
#elif defined( WMA_TARGET_MACOS )
#define USE_PACK_HEADERS
#else
#define PACKED  __packed
#endif

#ifdef _Embedded_x86
#define PACKED
#endif

#ifdef USE_PACK_HEADERS
#pragma warning( push )
#pragma warning( disable : 4103 )
#include <pshpack1.h>
#pragma warning( pop )
#endif
#endif

/****************************************************************************/
#ifndef NULL
#ifdef  __cplusplus
#define NULL    0
#else  /* __cplusplus */
#define NULL    ((void *)0)
#endif /* __cplusplus */
#endif /* NULL */

#if defined(_M_MRX000) || defined(_M_ALPHA) || defined(_M_PPC)
#define UNALIGNED __unaligned
#elif defined(_WIN32_WCE) && !defined(_M_IX86)
// WinCE inc\winnt.h defined this
#ifndef UNALIGNED
#define UNALIGNED __unaligned
#endif
#else
#define UNALIGNED
#endif

#ifdef _Embedded_x86
#define FALSE 0
#define TRUE  1
#endif


/****************************************************************************/
#ifndef _BOOL_DEFINED
#define _BOOL_DEFINED
typedef long BOOL;
#endif /* _BOOL_DEFINED */

#ifndef _BYTE_DEFINED
#define _BYTE_DEFINED
typedef unsigned char   BYTE;
#endif /* _BYTE_DEFINED */

#ifndef _WORD_DEFINED
#define _WORD_DEFINED
typedef unsigned short  WORD;
#endif /* _WORD_DEFINED */

#ifndef _DWORD_DEFINED
#define _DWORD_DEFINED
typedef unsigned long    DWORD;	/* actually long, but this should be okay */
#endif /* _DWORD_DEFINED */

#if defined (_Embedded_x86) || defined (_MIPS_) || defined (UNDER_CE)
#pragma pack (1)
#endif

#ifndef _QWORD_DEFINED
#define _QWORD_DEFINED
typedef PACKED struct tQWORD
{
    DWORD   dwLo;
    DWORD   dwHi;

}   QWORD;
#endif /* _QWORD_DEFINED */


/****************************************************************************/
#ifndef GUID_DEFINED
#define GUID_DEFINED

typedef PACKED struct tGUID
{
    DWORD   Data1;
    WORD    Data2;
    WORD    Data3;
    BYTE    Data4[ 8 ];

}	GUID;

#endif


/****************************************************************************/
#ifndef _WAVEFORMATEX_
#define _WAVEFORMATEX_
typedef PACKED struct tWAVEFORMATEX
{
    WORD    wFormatTag;         /* format type */
    WORD    nChannels;          /* number of channels (i.e. mono, stereo...) */
    DWORD   nSamplesPerSec;     /* sample rate */
    DWORD   nAvgBytesPerSec;    /* for buffer estimation */
    WORD    nBlockAlign;        /* block size of data */
    WORD    wBitsPerSample;     /* number of bits per sample of mono data */
    WORD    cbSize;             /* the count in bytes of the size of */

}   WAVEFORMATEX;
typedef const WAVEFORMATEX *LPCWAVEFORMATEX;

#endif

#define WAVE_FORMAT_MSAUDIO1  0x0160
typedef PACKED struct tMSAUDIO1WAVEFORMAT
{
    WAVEFORMATEX wfx;
    WORD         wSamplesPerBlock;
    WORD         wEncodeOptions;

}   MSAUDIO1WAVEFORMAT;

#define WAVE_FORMAT_WMAUDIO2  0x0161
typedef PACKED struct tWMAUDIO2WAVEFORMAT
{
    WAVEFORMATEX wfx;
    DWORD        dwSamplesPerBlock;
    WORD         wEncodeOptions;
    DWORD        dwSuperBlockAlign;

}   WMAUDIO2WAVEFORMAT;


/****************************************************************************/
typedef PACKED struct tAsfXAcmAudioErrorMaskingData
{
    BYTE    span;
    WORD    virtualPacketLen;
    WORD    virtualChunkLen;
    WORD    silenceLen;
    BYTE    silence[1];

}   AsfXAcmAudioErrorMaskingData;


/****************************************************************************/
typedef PACKED struct tAsfXSignatureAudioErrorMaskingData
{
    DWORD maxObjectSize;
    WORD  chunkLen;
    WORD  signatureLen;
    BYTE  signature[1];

}   AsfXSignatureAudioErrorMaskingData;

#if defined (_Embedded_x86) || defined (_MIPS_)  || defined (UNDER_CE)
#pragma pack ()
#endif

/****************************************************************************/
typedef struct tPACKET_PARSE_INFO_EX
{
    BOOL fParityPacket;
    DWORD cbParseOffset;

    BOOL fEccPresent;
    BYTE bECLen;

    BYTE bPacketLenType;
    DWORD cbPacketLenTypeOffset;

    BYTE bPadLenType;
    BYTE bSequenceLenType;

    BOOL fMultiPayloads;

    BYTE bOffsetBytes;

    BYTE bOffsetLenType;

    DWORD cbPacketLenOffset;

    DWORD cbExplicitPacketLength; 

    DWORD cbSequenceOffset;
    
    DWORD dwSequenceNum; 

    DWORD cbPadLenOffset;
    DWORD cbPadding;

    DWORD dwSCR;
    WORD wDuration;

    BYTE bPayLenType;
    BYTE bPayBytes;
    DWORD cbPayLenTypeOffset;

    DWORD cPayloads;

}   PACKET_PARSE_INFO_EX;


/****************************************************************************/
typedef struct tPAYLOAD_MAP_ENTRY_EX
{
    WORD cbPacketOffset;
    WORD cbTotalSize;

    BYTE bStreamId;
    BYTE bObjectId;

    DWORD cbObjectOffset;
    DWORD cbObjectSize;
    DWORD msObjectPres;

    BYTE cbRepData;
    BYTE bJunk;
    WORD cbPayloadSize;
 // Added by Amit
    
//    BYTE bIsKeyFrame;
//    BYTE bFrameRate;
    WORD wBytesRead;
    WORD wTotalDataBytes;
    BYTE bSubPayloadState;
    BYTE bIsCompressedPayload;
    BYTE bNextSubPayloadSize;
    WORD wSubpayloadLeft;

}   PAYLOAD_MAP_ENTRY_EX;


#ifdef USE_PACK_HEADERS
#pragma warning( push )
#pragma warning( disable : 4103 )
#include <poppack.h>
#pragma warning( pop )
#endif

#endif  /* WMATYPES_H */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\wmalib\asfparse_s\wmaudio_type.h ===
/*
 * Windows Media Audio (WMA) Decoder API (implementation)
 *
 * Copyright (c) Microsoft Corporation 1999.  All Rights Reserved.
 */

#ifndef _WMAUDIO_IMPL_H_
#define _WMAUDIO_IMPL_H_

#include "wmaerr.h"
#include "wmatypes.h"
#ifndef WMAAPI_NO_DRM
#include "drmpd.h"
#endif /* WMAAPI_NO_DRM */
#include "..\decoder\wmadecS_api.h"
#ifdef USE_WOW_FILTER
#include "wow_interface.h"
#endif
#define MIN_OBJECT_SIZE     24
#define DATA_OBJECT_SIZE    50


/* parser state  */
typedef enum
{
    csWMA_NotValid = 0,

    csWMA_HeaderStart,
    csWMA_HeaderError,

    csWMA_NewAsfPacket,

    /* packet parsing states */

    csWMA_DecodePayloadStart,
    csWMA_DecodePayload,
    csWMA_DecodePayloadHeader,
    csWMA_DecodeLoopStart,
    csWMA_DecodePayloadEnd,
    csWMA_DecodeCompressedPayload,

    csWMA_End_

} tWMAParseState;


/* internal structure for the ASF header parsing */
typedef struct tagWMAFileHdrStateInternal
{
    DWORD currPacketOffset;     /* not just for packets */
    DWORD nextPacketOffset;

    /* ASF header */

    DWORD   cbHeader;
    DWORD   cbPacketSize;
    DWORD   cbAudioSize;
    DWORD   cPackets;
    DWORD   msDuration;
    DWORD   msPreroll;
    DWORD   cbFirstPacketOffset;
    DWORD   cbLastPacketOffset;

    /* audio prop */

    WORD    nVersion;
    DWORD   nSamplesPerSec;
    DWORD   nAvgBytesPerSec;
    DWORD   nBlockAlign;
    WORD    nChannels;
    DWORD   nSamplesPerBlock;
    WORD    nEncodeOpt;

    /* DRM */

    BYTE    pbSecretData[32];
    DWORD   cbSecretData;
    BYTE    pbType[16];
    BYTE    pbKeyID[32];

    /* Content Description */

    DWORD   cbCDOffset;
    WORD    cbCDTitle;
    WORD    cbCDAuthor;
    WORD    cbCDCopyright;
    WORD    cbCDDescription;
    WORD    cbCDRating;

    /* Extended Content Description */

    tWMAExtendedContentDesc *m_pECDesc;

    /* Marker */
    DWORD   m_dwMarkerNum;
    MarkerEntry *m_pMarker;

    /* License Store */
    DWORD   m_dwLicenseLen;
    BYTE   *m_pLicData;

#ifndef WMAAPI_NO_DRM_STREAM
    BYTE    bAudioStreamNum;
    BYTE    bDRMAuxStreamNum;
#endif
// Members added by Amit 
    WORD	wAudioStreamId;

    /* user callback context */
    PVOID pCallbackContext;
    

} tWMAFileHdrStateInternal;

//typedef void * WMADecHANDLE;

/* internal structure for the WMAudio library state */
typedef struct tagWMAFileStateInternal
{
    tWMAFileHdrStateInternal hdr_parse;

    /* user callback context */
    PVOID pCallbackContext;

    /* parse_state */
    
    tWMAParseState parse_state;

    /* payload parsing */

    DWORD cbPayloadOffset;
    DWORD cbPayloadLeft;

    BOOL  bBlockStart;
    DWORD cbBlockLeft;

    /* packet parsing */

    PACKET_PARSE_INFO_EX ppex;

    PAYLOAD_MAP_ENTRY_EX payload;
    DWORD iPayload;
    WORD wPayStart;

    /* other states */

    BOOL    bHasDRM;

    DWORD   nSampleCount;

    /* objects */

//    tWMAState wma_state;
//    WMADHANDLE hWMA;
    WMARawDecHandle hWMA;

#ifndef WMAAPI_NO_DRM
    CDrmPD* pDRM_state;
#endif /* WMAAPI_NO_DRM */

#ifndef WMAAPI_NO_DRM_STREAM
    BYTE cbNextPayloadEndValid;
    BYTE rgbNextPayloadEnd[15];
#endif

	
#ifdef USE_WOW_FILTER
    WowChannel sWowChannel;
#endif
	BYTE bDecInWaitState;
	BYTE bAllFramesDone;
	BYTE bFirst;

} tWMAFileStateInternal;


/* ASF parsing functions */

#ifdef __cplusplus
extern "C"
{
#endif /* __cplusplus */


/* use (only) for reading possibly large chunk */
DWORD WMA_GetBuffer(tWMAFileStateInternal *pInt,
                    DWORD cbOffset, DWORD cbWanted, BYTE *pBuffer);

WMAERR WMA_LoadObjectHeader(tWMAFileHdrStateInternal *pInt, GUID *pObjectId, QWORD *pqwSize);
WMAERR WMA_LoadHeaderObject(tWMAFileHdrStateInternal *pInt, int isFull);
WMAERR WMA_LoadPropertiesObject(tWMAFileHdrStateInternal *pInt, DWORD cbSize, int isFull);
WMAERR WMA_LoadAudioObject(tWMAFileHdrStateInternal *pInt, DWORD cbSize, int isFull);
WMAERR WMA_LoadEncryptionObject(tWMAFileHdrStateInternal *pInt, DWORD cbSize);
WMAERR WMA_LoadContentDescriptionObject(tWMAFileHdrStateInternal *pInt, DWORD cbSize);
WMAERR WMA_LoadExtendedContentDescObject(tWMAFileHdrStateInternal *pInt, DWORD cbSize);

WMAERR WMA_ParseAsfHeader(tWMAFileHdrStateInternal *pInt, int isFull);
WMAERR WMA_ParsePacketHeader(tWMAFileStateInternal *pInt);
WMAERR WMA_ParsePayloadHeader(tWMAFileStateInternal *pInt);

WMAERR WMA_GetMarkerObject(tWMAFileHdrStateInternal *pInt, int k);

#ifdef __cplusplus
}
#endif /* __cplusplus */

#endif /* _WMAUDIO_IMPL_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\wmalib\asfparse_s\wmaudio.h ===
/*
 * Windows Media Audio (WMA) Decoder API
 *
 * Copyright (c) Microsoft Corporation 1999.  All Rights Reserved.
 */

#ifndef _WMAUDIO_API_H_
#define _WMAUDIO_API_H_

#define PACKED
/*
#ifdef _MSC_VER
#define USE_PACK_HEADERS
#define PACKED
#else
#undef USE_PACK_HEADERS
#define PACKED  __packed
#endif

#ifdef USE_PACK_HEADERS
#include <pshpack1.h>
#endif
*/

/* ...........................................................................
 *
 * Types and Constants
 * ===================
 */

#define CHECK_NONSDMI_LIC	1
#define CHECK_SDMI_LIC		2
#define CHECK_ALL_LICENSE	3

#define WMA_MAX_DATA_REQUESTED  128

enum {
    ECD_STRING = 0,
    ECD_BINARY = 1,
    ECD_BOOL = 2,
    ECD_DWORD = 3,
    ECD_QWORD = 4,
    ECD_WORD = 5
};

#if defined(_Embedded_x86)
#pragma pack (1)
#endif

/* 8-bit signed type  */
#ifndef _WMAU8_DEFINED
#define _WMAU8_DEFINED
typedef unsigned char tWMA_U8;
#endif /* _WMAU8_DEFINED */

/* 16-bit signed type  */
#ifndef _WMAI16_DEFINED
#define _WMAI16_DEFINED
typedef short tWMA_I16;
#endif /* _WMAI16_DEFINED */

/* 16-bit unsigned type  */
#ifndef _WMAU16_DEFINED
#define _WMAU16_DEFINED
typedef short tWMA_U16;
#endif /* _WMAU16_DEFINED */

/* 32-bit unsigned type  */
#ifndef _WMAU32_DEFINED
#define _WMAU32_DEFINED
typedef unsigned long tWMA_U32;
#endif /* _WMAU32_DEFINED */

/* Bool */
#ifndef _WMABool_DEFINED
#define _WMABool_DEFINED
typedef long tWMA_Bool;
#endif /* _WMABool_DEFINED */

/* 64-bit unsigned type  */
#ifndef _WMAU64_DEFINED
#define _WMAU64_DEFINED
#if defined(macintosh) || defined(_Embedded_x86)
typedef unsigned __int64  tWMA_U64;
#else
typedef unsigned __int64    tWMA_U64;
#endif
#endif /* _WMAU64_DEFINED */

#ifndef _QWORD_DEFINED
#define _QWORD_DEFINED
typedef PACKED struct tQWORD
{
    tWMA_U32   dwLo;
    tWMA_U32   dwHi;

}   QWORD;
#endif /* _QWORD_DEFINED */

#define DESC_NAME_MAX_LENGTH   64
typedef struct _MarkerEntry {
    QWORD   m_qOffset;
    QWORD   m_qtime;
    tWMA_U16    m_wEntryLen;
    tWMA_U32   m_dwSendTime;
    tWMA_U32   m_dwFlags;
    tWMA_U32   m_dwDescLen;
    tWMA_U16   m_pwDescName[DESC_NAME_MAX_LENGTH];
} MarkerEntry;

typedef struct _ECD_DESCRIPTOR {
    tWMA_U16         cbName;
    tWMA_U16     *pwszName;
    tWMA_U16         data_type;
    tWMA_U16         cbValue;
    union {
        tWMA_U16 *pwszString;
        tWMA_U8 *pbBinary;
        tWMA_Bool *pfBool;
        tWMA_U32 *pdwDword;
        tWMA_U64 *pqwQword;
        tWMA_U16  *pwWord;
    } uValue;
} ECD_DESCRIPTOR;

typedef struct tagWMAExtendedContentDescription
{
    tWMA_U16 cDescriptors;             // number of descriptors
    ECD_DESCRIPTOR *pDescriptors;  // pointer to all the descriptors
} tWMAExtendedContentDesc;

/* status */
#ifndef _WMAFILESTATUS_DEFINED
#define _WMAFILESTATUS_DEFINED
typedef enum tagWMAFileStatus
{
    cWMA_NoErr,                 /* -> always first entry */
                                /* remaining entry order is not guaranteed */
    cWMA_Failed,
    cWMA_BadArgument,
    cWMA_BadAsfHeader,
    cWMA_BadPacketHeader,
    cWMA_BrokenFrame,
    cWMA_NoMoreFrames,
    cWMA_BadSamplingRate,
    cWMA_BadNumberOfChannels,
    cWMA_BadVersionNumber,
    cWMA_BadWeightingMode,
    cWMA_BadPacketization,

    cWMA_BadDRMType,
    cWMA_DRMFailed,
    cWMA_DRMUnsupported,

    cWMA_DemoExpired,

    cWMA_BadState,
    cWMA_Internal,               /* really bad */
	cWMA_NoMoreDataThisTime
} tWMAFileStatus;
#endif /* _WMAFILESTATUS_DEFINED */

/* versions */
#ifndef _WMAFILEVERSION_DEFINED
#define _WMAFILEVERSION_DEFINED
typedef enum tagWMAFileVersion
{
    cWMA_V1 = 1,
    cWMA_V2 = 2

} tWMAFileVersion;
#endif /* _WMAFILEVERSION_DEFINED */

/* sample rates */
#ifndef _WMAFILESAMPLERATE_DEFINED
#define _WMAFILESAMPLERATE_DEFINED
typedef enum tagWMAFileSampleRate
{
    cWMA_SR_48kHz,
    cWMA_SR_44_1kHz,
    cWMA_SR_32kHz,
    cWMA_SR_22_05kHz,
    cWMA_SR_16kHz,
    cWMA_SR_11_025kHz,
    cWMA_SR_08kHz
} tWMAFileSampleRate;
#endif /* _WMAFILESAMPLERATE_DEFINED */

/* channels */
#ifndef _WMAFILECHANNELS_DEFINED
#define _WMAFILECHANNELS_DEFINED
typedef enum tagWMAFileChannels
{
    cWMA_C_Mono = 1,
    cWMA_C_Stereo = 2

} tWMAFileChannels;
#endif /* _WMAFILECHANNELS_DEFINED */


/* ...........................................................................
 *
 * Structures
 * ==========
 */

/* header */
#ifndef _WMAFILEHEADER_DEFINED
#define _WMAFILEHEADER_DEFINED
typedef PACKED struct tagWMAFileHeader
{
    tWMAFileVersion version;         /* version of the codec */
    tWMAFileSampleRate sample_rate;  /* sampling rate */
    tWMAFileChannels num_channels;   /* number of audio channels */
    tWMA_U32 duration;               /* of the file in milliseconds */
    tWMA_U32 packet_size;            /* size of an ASF packet */
    tWMA_U32 first_packet_offset;    /* byte offset to the first ASF packet */
    tWMA_U32 last_packet_offset;     /* byte offset to the last ASF packet */

    tWMA_U32 has_DRM;                /* does it have DRM encryption? */
 
    tWMA_U32 LicenseLength;          /* License Length in the header */

    tWMA_U32 bitrate;                /* bit-rate of the WMA bitstream */

    /* HongCho: what else? */

} tWMAFileHeader;
#endif /* _WMAFILEHEADER_DEFINED */


/* content description */
#ifndef _WMAFILECONTDESC_DEFINED
#define _WMAFILECONTDESC_DEFINED
typedef PACKED struct tagWMAFileContDesc
{
    /* *_len: as [in], they specify how large the corresponding
     *        buffers below are.
     *        as [out], they specify how large the returned
     *        buffers actually are.
     */

    tWMA_U16 title_len;
    tWMA_U16 author_len;
    tWMA_U16 copyright_len;
    tWMA_U16 description_len;   /* rarely used */
    tWMA_U16 rating_len;        /* rarely used */

    /* these are two-byte strings
     *   for ASCII-type character set, to convert these
     *   into a single-byte characters, simply skip
     *   over every other bytes.
     */

    unsigned char *pTitle;
    unsigned char *pAuthor;
    unsigned char *pCopyright;
    unsigned char *pDescription;
    unsigned char *pRating;

} tWMAFileContDesc;
#endif /* _WMAFILECONTDESC_DEFINED */

/* license params */
#ifndef _WMAFILELICPARAMS_DEFINED
#define _WMAFILELICPARAMS_DEFINED
typedef PACKED struct tagWMAFileLicParams
{
    unsigned char *pPMID;       /* portable media id */
    tWMA_U32 cbPMID;            /* length of the pPMID buffer */

} tWMAFileLicParams;
#endif /* _WMAFILELICPARAMS_DEFINED */


typedef void * tHWMAFileState;

/* another internal state */
#ifndef _WMAFILEHDRSTATE_DEFINED
#define _WMAFILEHDRSTATE_DEFINED
typedef PACKED struct tagWMAFileHdrState
{
    unsigned char internal[192];
//    unsigned char internal[188];

} tWMAFileHdrState;
#endif /* _WMAFILEHDRSTATE_DEFINED */

#ifdef _Embedded_x86
#pragma pack ()
#endif

/* ........................................................................... 
 *
 * Functions
 * =========
 */

#ifdef __cplusplus
extern "C"
{
#endif /* __cplusplus */


/*
 *        WMAFileIsWMA
 *        ============
 *
 * Description
 * -----------
 * Checks to see if the file is decodable.  Uses WMAFileCBGetData(),
 * but the first argument to it is not really of type tHWMAFileState,
 * but tWMAFileIdState.
 *
 * To decode the file, the app should call WMAFileDecodeInit()
 * instead.
 *
 * This function was added in case the app wants to determine the
 * type of the file without fully allocating tHWMAFileState.
 *
 * Syntax
 * ------
 *   tWMAFileStatus WMAFileIsWMA(tWMAFileHdrState *state);
 *
 * where:
 *
 *   state          pointer to the smaller structure that contains
 *                  state of the checking function
 *
 * Return Value
 * ------------
 *   cWMA_NoErr                yes, it's a WMA file
 *   cWMA_BadArgument          bad argument passed in
 *   cWMA_BadAsfHeader         bad ASF header
 *
 */
tWMAFileStatus WMAFileIsWMA (tWMAFileHdrState *state);


/*
 *        WMAGetNumberOfMarkers
 *        ============
 *
 * Description
 * -----------
 * Return the total number of Markers in the asf file
 *
 * Syntax
 * ------
 *  int WMAGetNumberOfMarkers(tWMAFileHdrState *state);  
 *
 * where:
 *
 *   state          pointer to the smaller structure that contains
 *                  state of the checking function
 *
 * Return Value
 * ------------
 *   total number of Markers in the asf file
 *
 */

int WMAGetNumberOfMarkers(tWMAFileHdrState *state);  



/*
 *        WMAGetMarker
 *        ============
 *
 * Description
 * -----------
 * WMAGetMarker(...) is designed to return the Marker specified by an index integer iIndex
 * If the total number of Markers returned by WMAGetNumberOfMarkers is total_num_of_markers, 
 * all the Markers are indexed from 0 to total_num_of_markers - 1.  
 * When a Marker structure MarkerEntry is allocated by the application
 * and the pointer to that Marker structure is passed in WMAGetMarker(...) with pEntry,
 * succesful calling of WMAGetMarker(...) will fill up the Marker structure *pEntry
 * with the Marker identified by the index iIndex.
 *
 * Syntax
 * ------
 *   tWMAFileStatus WMAGetMarker(tWMAFileHdrState *state, int iIndex, MarkerEntry *pEntry); 
 *
 * where:
 *
 *   state          pointer to the smaller structure that contains
 *                  state of the checking function
 *   pEntry         pointer to the Marker structure MarkerEntryEx 
 *                  allocated by the application  
 *   iIndex         index to specify which Marker to return
 *
 * Return Value
 * ------------
 * return cWMA_NoErr
 *      if WMAGetMarker(...) succeed in returning the Marker specified by iIndex.            
 * return cWMA_Failed 
 *      if WMAGetMarker(...) failed in returning the Marker specified by iIndex.  
 */

tWMAFileStatus WMAGetMarker(tWMAFileHdrState *state, int iIndex, MarkerEntry *pEntry); 



/*
 *        WMAGetLicenseStore
 *        ============
 *
 * Description
 * -----------
 * Get the marker list so the main program can seek the file freely.
 *
 * Syntax
 * ------
 * BYTE * WMAGetLicenseStore(tWMAFileHdrState *pstate,tWMA_U32 *pLen)
 *
 * where:
 *
 *   state          pointer to the smaller structure that contains
 *                  state of the checking function
 *   pLen           Address of the poitner to store the size of license.
 *
 * Return Value
 * ------------
 * Pointer of data chunck
 *
 */
unsigned char * WMAGetLicenseStore(tWMAFileHdrState *pstate,tWMA_U32 *pLen);

/*
 *        WMAFileCBGetData
 *        ================
 *
 * Description
 * -----------
 * Supplies more data to the WMAudio decoder.  Not implemented by
 * the WMAudio decoder library.
 *
 * It is a callback function implemented by the application.  When
 * the WMAudio library needs more data to process (both to parse
 * informatio and to decode the actual data bitstream), the library
 * will call this function.
 *
 * Called by WMAFileDecodeInit(), WMAFileContentDesc() and
 * WMAFileDecodeData().
 *
 * Syntax
 * ------
 *   tWMA_U32 WMAFileCBGetData(tHWMAFileState hstate,
 *                             tWMA_U32 offset,
 *                             tWMA_U32 num_bytes,
 *                             unsigned char **ppData);
 *
 * where:
 *
 *   state          pointer to the structure that holds the internal
 *                  state of the WMAudio decoder
 *   offset         offset into the WMA file to get the data from
 *   num_bytes      how many bytes to get
 *   ppData         pointer to contain the returned buffer with more
 *                  data
 *                  The WMA library may over-write this buffer
 *
 * Return Value
 * ------------
 *   tWMA_U32       how many actually returned
 *                  should be same as num_bytes except for at the
 *                  very end of the file
 *
 */
extern tWMA_U32 WMAFileCBGetData (
    tHWMAFileState hstate,
    void * pContext,
    tWMA_U32 offset,
    tWMA_U32 num_bytes,
    unsigned char **ppData);


/*
 *        WMAFileCBGetLicenseData
 *        =======================
 *
 * Description
 * -----------
 * Supplies more data to the WMAudio DRM decryption function.  Not
 * implemented by the WMAudio decoder library.
 *
 * It is a callback function implemented by the application.  When
 * the WMAudio's DRM decryption library needs more data to process
 * the library will call this function.
 *
 * Called by WMAFileLicenseInit().
 *
 * Syntax
 * ------
 *   tWMA_U32 WMAFileCBGetLicenseData(tHWMAFileState *state,
 *                                    tWMA_U32 offset,
 *                                    tWMA_U32 num_bytes,
 *                                    unsigned char **ppData);
 *
 * where:
 *
 *   state          pointer to the structure that holds the internal
 *                  state of the WMAudio decoder
 *   offset         offset into the license file to get the data from
 *   num_bytes      how many bytes to get
 *   ppData         pointer to contain the returned buffer with more
 *                  data
 *
 * Return Value
 * ------------
 *   tWMA_U32       how many actually returned
 *                  should be same as num_bytes except for at the
 *                  very end of the file
 *
 */
extern tWMA_U32 WMAFileCBGetLicenseData (
    tHWMAFileState *pstate,
    tWMA_U32 offset,
    tWMA_U32 num_bytes,
    unsigned char **ppData);


/*
 *        WMAFileDecodeCreate
 *        ===================
 *
 * Description
 * -----------
 * Create the WMAudio decoder.
 *
 * Must be called before starting to decode a WMA file.
 *
 * Syntax
 * ------
 *   tWMAFileStatus WMAFileDecodeCreate(tHWMAFileState *state);
 *
 * where:
 *
 *   phstate        pointer to the handle that holds the internal
 *                  state of the WMAudio decoder
 *                  This memory should be cleared before the first call
 *                  to WMAFileDecodeCreate
 *
 * Return Value
 * ------------
 *   cWMA_NoErr                decoder initialised
 *   cWMA_BadArgument          bad argument passed in
 *   cWMA_BadAsfHeader         bad ASF header
 *   cWMA_BadSamplingRate      invalid or unsupported sampling rate
 *   cWMA_BadNumberOfChannels  invalid or unsupported number of channels
 *   cWMA_BadVersionNumber     invalid or unsupported version number
 *   cWMA_BadWeightingMode     invalid or unsupported weighting mode
 *   cWMA_BadPacketisation     invalid or unsupported packetisation
 *   cWMA_BadDRMType           unknown encryption type
 *   cWMA_DRMFailed            DRM failed
 *   cWMA_DRMUnsupported       DRM is not supported for this version
 *
 */
tWMAFileStatus WMAFileDecodeCreate (tHWMAFileState* phstate, void * pCallbackContext);

/*
 *        WMAFileDecodeInit
 *        =================
 *
 * Description
 * -----------
 * Initializes the WMAudio decoder.
 *
 * Must be called before starting to decode a WMA file.
 *
 * Syntax
 * ------
 *   tWMAFileStatus WMAFileDecodeInit(tHWMAFileState state);
 *
 * where:
 *
 *   phstate        pointer to the handle that holds the internal
 *                  state of the WMAudio decoder
 *                  This memory should be cleared before the first call
 *                  to WMAFileDecodeInit
 *
 * Return Value
 * ------------
 *   cWMA_NoErr                decoder initialised
 *   cWMA_BadArgument          bad argument passed in
 *   cWMA_BadAsfHeader         bad ASF header
 *   cWMA_BadSamplingRate      invalid or unsupported sampling rate
 *   cWMA_BadNumberOfChannels  invalid or unsupported number of channels
 *   cWMA_BadVersionNumber     invalid or unsupported version number
 *   cWMA_BadWeightingMode     invalid or unsupported weighting mode
 *   cWMA_BadPacketisation     invalid or unsupported packetisation
 *   cWMA_BadDRMType           unknown encryption type
 *   cWMA_DRMFailed            DRM failed
 *   cWMA_DRMUnsupported       DRM is not supported for this version
 *
 */
tWMAFileStatus WMAFileDecodeInit (tHWMAFileState phstate);

tWMAFileStatus WMAFileDecodeClose (tHWMAFileState* phstate);

/*
 *       WMAFileDecodeInfo
 *       =================
 *
 * Description
 * -----------
 * Retrieves the header information for the WMA file.
 *
 * Syntax
 * ------
 *   tWMAFileStatus WMAFileDecodeInfo(tHWMAFileState hstate,
 *                                    tWMAFileHeader *hdr);
 *
 * where:
 *
 *   state          pointer to the structure that holds the internal
 *                  state of the WMAudio decoder
 *   hdr            pointer to the structure that holds the WMA file
 *                  header info
 *
 * Return Value
 * ------------
 *   cWMA_NoErr                header retrieved ok
 *   cWMA_BadArgument          bad argument(s)
 *
 */

tWMAFileStatus WMAFileDecodeInfo (tHWMAFileState hstate, tWMAFileHeader *hdr);


/*
 *       WMAFileContentDesc
 *       ==================
 *
 * Description
 * -----------
 * Retrieves the content description for the WMA file.  Content
 * descriptions are such as the song title, the author, the
 * copyright info, the song description, and the rating info.
 * All these are part of the standard ASF description.
 *
 * Not all songs have content descriptions.
 *
 * Syntax
 * ------
 *   tWMAFileStatus WMAFileContentDesc(tHWMAFileState hstate,
 *                                     tWMAFileContDesc *desc);
 *
 * where:
 *
 *   state          pointer to the structure that holds the internal
 *                  state of the WMAudio decoder
 *   desc           pointer to the structure that holds the WMA file
 *                  content description info
 *                  as [in], must provide the buffer(s) and the size(s)
 *
 * Return Value
 * ------------
 *   cWMA_NoErr                description retrieved ok
 *   cWMA_BadArgument          bad argument(s)
 *   cWMA_BadAsfHeader         bad ASF header
 *
 */
tWMAFileStatus WMAFileContentDesc (tHWMAFileState hstate, tWMAFileContDesc *desc);

/* WMAFileExtendedContentDesc
 *
 * Description
 * -----------
 * Retrieves the extended content descriptions for the ASF file.
 * Not all ASF files have extended content descriptions.
 *
 * Syntax
 * ------
 * tWMAFileStatus WMAFileExtendedContentDesc (tHWMAFileState hstate, const tWMAExtendedContentDesc **pECDesc);
 *
 * where:
 *
 *   hstate                     Pointer to the structure that holds the internal
 *                              state of the WMAudio decoder
 *   pECDesc                    pointer of pointer to the Extended Content Desc
 *                              structure that holds in the ASF file.
 *
 * Return Value
 * ------------
 *   cWMA_NoErr                  description retrieved ok
 *   cWMA_BadArgument            bad argument(s)
 *   pECDesc is the pointer of pointer to the ASF extended content desc object.
 ***** DO NOT RELEASE THIS POINTER *************
 */

tWMAFileStatus WMAFileExtendedContentDesc (tHWMAFileState hstate, const tWMAExtendedContentDesc **pECDesc);

/*
 *       WMAFileLicenseInit
 *       ==================
 *
 * Description
 * -----------
 * Reads the DRM license file and check the license for the file.
 *
 * Uses WMAFileCBGetLicenseData to retrieve the license file.
 *
 * Syntax
 * ------
 *   tWMAFileStatus WMAFileLicenseInit(tHWMAFileState hstate,
 *                                     tWMAFileLicParams *lic_params);
 *
 * where:
 *
 *   state          pointer to the structure that holds the internal
 *                  state of the WMAudio decoder
 *   lic_params     pointer to the structure that passes in the
 *                  parameters for the license initialization.
 *
 * Return Value
 * ------------
 *   cWMA_NoErr                license checked ok
 *   cWMA_BadArgument          bad argument
 *   cWMA_DRMFailed            no license
 *   cWMA_DRMUnsupported       DRM is not supported for this version
 *
 */
tWMAFileStatus WMAFileLicenseInit (tHWMAFileState hstate, tWMAFileLicParams *lic_params, tWMA_U16 CheckLicTypes);


/*
 *       WMAFileDecodeData
 *       =================
 *
 * Description
 * -----------
 * Decodes WMAudio bitstream.
 *
 * Syntax
 * ------
 *   tWMAFileStatus WMAFileDecodeData(tHWMAFileState hstate);
 *
 * where:
 *
 *   state          pointer to the structure that holds the internal
 *                  state of the WMAudio decoder
 *
 * Return Value
 * ------------
 *   cWMA_NoErr                frame decoded ok
 *   cWMA_BadArgument          bad argument
 *   cWMA_BrokenFrame          data is inconsistent
 *   cWMA_NoMoreFrames         no more data to decode
 *
 */
tWMAFileStatus WMAFileDecodeData (tHWMAFileState hstate);


/*
 *       WMAFileGetPCM
 *       =============
 *
 * Description
 * -----------
 * Write PCM samples from the WMAudio bitstream previously decoded by
 * WMAFileDecodeData().
 *
 * WMAFileGetPCM() may have to be called more than once to obtain all
 * of the samples for the frame. The frame is complete when the number
 * of samples written is less than the number of samples requested.
 *
 * Syntax
 * ------
 *   tWMA_U32 WMAFileGetPCM(tHWMAFileState hstate,
 *                          tWMA_I16 *left, tWMA_I16 *right,
 *                          tWMA_U32 max_nsamples);
 *
 * where:
 *
 *   state          pointer to the structure that holds the internal
 *                  state of the WMAudio decoder
 *   pi16Channel0   pointer to output buffer for left-channel PCM, or the entire PCM output if it is inter-leaved form
 *   pi16Channel1   pointer to output buffer for right-channel PCM, NULL if the output PCM is in parallel form
 *   max_nsamples   maximum number of samples to write per channel
 *
 * Return Value
 * ------------
 *   tWMA_U32       number of samples written
 *                  < max_nsamples when frame complete
 *
 */
tWMA_U32 WMAFileGetPCM (
    tHWMAFileState hstate,
    tWMA_I16 *pi16Channel0, tWMA_I16 *pi16Channel1,
    tWMA_U32 max_nsamples);


/*
 *       WMAFileSeek
 *       ===========
 *
 * Description
 * -----------
 * Seek to a time into the WMA file.  It seeks to the nearest seek
 * point.
 *
 * Syntax
 * ------
 *   tWMA_32 WMAFileSeek(tHWMAFileState hstate,
 *                       tWMA_U32 msSeek);
 *
 * where:
 *
 *   state          pointer to the structure that holds the internal
 *                  state of the WMAudio decoder
 *   msSeek         time position to seek from the beginning of the
 *                  clip, in milliseconds
 *
 * Return Value
 * ------------
 *   tWMA_32        actual time position from the beginning of the
 *                  clip, in milliseconds
 *
 */
tWMA_U32 WMAFileSeek (tHWMAFileState hstate, tWMA_U32 msSeek);


/*
 *       WMADebugMessage
 *       ===============
 *
 * Description
 * -----------
 * Display a debugging message. This function needs to be implemented by the app that calls WMEPAK.
 * These messages are meant for the device/application developer, not the end user.
 * Display the message using fprintf, messagebox, or whatever method is suitable to your platform.
 * See the sample code for an example implementation.
 * Make it a empty-body function if the intent is to skip this operation.
 *
 * Syntax
 * ------
 *		WMADebugMessage(const char* pszFmt,
 *						...);
 *
 * where:
 *
 *   pszFmt		    pointer to a null terminated printf like format string
 *   ...			variable number of arguments referenced by the format string
 *
 * Return Value
 * ------------
 *   none
 *
 */
extern void WMADebugMessage (const char*pszFmt, ...);



#ifdef __cplusplus
}
#endif /* __cplusplus */

/*
#ifdef USE_PACK_HEADERS
#include <poppack.h>
#endif
*/

#endif /* _WMAUDIO_API_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\wmalib\common\constants.h ===
/*************************************************************************

Copyright (C) Microsoft Corporation, 1996 - 1999

Module Name:

    Constants.h

Abstract:

    Contants and macros used in MsAudio.

Author:

    Wei-ge Chen (wchen) 12-March-1998

Revision History:


*************************************************************************/

#ifndef __CONSTANTS_H_
#define __CONSTANTS_H_

#ifdef  PI
#undef  PI
#endif
#define PI  3.1415926535897932384626433832795
// value prior to 10/5/99 as a float: #define PI  3.14159265359F

#define FLOAT_SHRT_MAX  32767.0F - 10.0F
#define FLOAT_SHRT_MIN -32768.0F + 10.0F
#define FLOAT_INT_MAX  2147483647.0F - 10.0F
#define FLOAT_INT_MIN -2147483648.0F + 10.0F

#ifdef	BITS_PER_BYTE
#undef	BITS_PER_BYTE
#endif
#define BITS_PER_BYTE 8

#ifdef	BITS_PER_DWORD
#undef	BITS_PER_DWORD
#endif
#define BITS_PER_DWORD      32

#ifdef	BITS_PER_QWORD
#undef	BITS_PER_QWORD
#endif
#define BITS_PER_QWORD      64

#ifdef	NBITS_PACKET_CNT
#undef	NBITS_PACKET_CNT
#endif
#define NBITS_PACKET_CNT    4

#ifdef	NBITS_FRM_CNT
#undef	NBITS_FRM_CNT
#endif
#define NBITS_FRM_CNT       4


#ifdef  NUM_MILSEC_PER_FRAME
#undef  NUM_MILSEC_PER_FRAME
#endif
#define NUM_MILSEC_PER_FRAME 32

#ifdef  NUM_BARK_BAND
#undef  NUM_BARK_BAND
#endif
#define NUM_BARK_BAND 25

#ifdef  MAX_WIDTH_BARKBAND
#undef  MAX_WIDTH_BARKBAND
#endif
#define MAX_WIDTH_BARKBAND 450

#ifdef  MIN_BITRATE
#undef  MIN_BITRATE
#endif
#define MIN_BITRATE 2000    //2.0kbps, TBD

#ifdef  MAX_BITRATE
#undef  MAX_BITRATE
#endif
#define MAX_BITRATE 640000  //64kbps, TBD

#ifdef  LOW_CUTOFF_V1
#undef  LOW_CUTOFF_V1
#endif
#define LOW_CUTOFF_V1 3        //TBD

#ifdef  LOW_CUTOFF
#undef  LOW_CUTOFF
#endif
#define LOW_CUTOFF 0        //wchen: no more due to bug#19144

#ifdef  ABS_THRESHOLD_IN_DB     // in dB, how much to bring down Fletcher-Munson curves;
#undef  ABS_THRESHOLD_IN_DB
#endif
#define ABS_THRESHOLD_IN_DB -30

// power reduction factor in dB for masking @ same frequency
#ifdef INTEGER_ENCODER
#define MIN_THRESHOLD_IN_DB_V1  ((I32)(25 / PWRTODB_STEP ))
#else   // INTEGER_ENCODER
#define MIN_THRESHOLD_IN_DB_V1  25
#endif  // INTEGER_ENCODER

#ifdef  MIN_MASKQ_IN_DB_V1
#undef  MIN_MASKQ_IN_DB_V1
#endif
#define MIN_MASKQ_IN_DB_V1 (Int) (MIN_THRESHOLD_IN_DB_V1 / MASK_QUANT)

#ifdef  MAX_MASKQ_IN_DB_V1
#undef  MAX_MASKQ_IN_DB_V1
#endif                                      
#define MAX_MASKQ_IN_DB_V1 MIN_MASKQ_IN_DB_V1 + (1 << NBITS_FIRST_MASKQUANT) - 1

#ifdef  MASK_QUANT      // in db
#undef  MASK_QUANT      
#endif
#define MASK_QUANT 2.5

#ifdef  NBITS_FIRST_MASKQUANT      
#undef  NBITS_FIRST_MASKQUANT      
#endif
#define NBITS_FIRST_MASKQUANT 5   

#ifdef  FIRST_V2_MASKQUANT
#undef  FIRST_V2_MASKQUANT
#endif
#define FIRST_V2_MASKQUANT 36

#ifdef  MAX_MASKQUANT_DIFF      
#undef  MAX_MASKQUANT_DIFF      
#endif
#define MAX_MASKQUANT_DIFF 60  // limited by the huffman table

#ifdef  NUM_BITS_QUANTIZER
#undef  NUM_BITS_QUANTIZER
#endif
#define NUM_BITS_QUANTIZER 7

// both as the escape code and the range...
#ifdef  MSA_MAX_QUANT_ESC
#undef  MSA_MAX_QUANT_ESC
#endif
#define MSA_MAX_QUANT_ESC ((1<<NUM_BITS_QUANTIZER) - 1)

#ifdef  MAX_QUANT
#undef  MAX_QUANT
#endif
#define MAX_QUANT 129	/* 138 has been seen by decoder */

#ifdef  MIN_QUANT
#undef  MIN_QUANT
#endif
#define MIN_QUANT 1		/*	was once 10; 22 is lowest value seen by decoder */

#define MAX_RUNLEVEL_44SM_QB 60
#define MAX_RUNLEVEL_44SS_QB 40
#define MAX_RUNLEVEL_44SM_HB 110
#define MAX_RUNLEVEL_44SS_HB 70
#define MAX_RUNLEVEL_44SM_OB 340
#define MAX_RUNLEVEL_44SS_OB 180
#define MAX_RUNLEVEL_16SM_OB 70
#define MAX_RUNLEVEL_16SS_OB 40

//lpc constants;need clean up
#define LPCORDER 10
#define FOURTYFOURS_QB 1
#define FOURTYFOURS_OB 2
#define SIXTEENS_OB 3

#define MIN_AUDIBLE 0   // should be fixed...

#define MSA_STEREO_WEIGHT 1.6

#define MIN_EQ -35
#define MAX_EQ 15
#define MIN_RATE BITS_PER_BYTE

#define NUM_PREV_POWER 8
#define NUM_TRANS_FILTER 3

// We're lucky in that everywhere where MIN_FRAME_SIZE is used, pau->m_fHalfTransform
// is available. If this changes, the compiler will let you know.
#define MIN_FRAME_SIZE  HALF(pau->m_fHalfTransform, 128)

// Constants
#define QUANTSTEP_DENOMINATOR 20
#define QUANTSTEP_FRACT_BITS 28

#define TRANSFORM_FRACT_BITS    5

#define MAX_CSUBBAND 2048

// The following should only be used when compiling the integer encoder
#ifdef INTEGER_ENCODER
#define INVWEIGHTFACTOR_FRACTBITS   27
#define INVQUANTSTEP_FRACTBITS      27
#define WEIGHTINPUT_FRACTBITS   14  // prvWeightInput
#define WEIGHT_FRACTBITS        4   // prvGetMaskingThresholdMono and others in masking.c

// Discard bits to allow power value to stay within U32 range. We only need to discard
// 3 bits but discard 1 extra so sqrt(2^TRANSIENT_BITDISCARD) is power of 2
#define TRANSIENT_THRFRACTBITS  4       // Allows 1/16 precision (see threshold init)
#define TRANSIENT_BITDISCARD    (3 + 1 + TRANSIENT_THRFRACTBITS)
#endif  // INTEGER_ENCODER


// fix-point binary points conversion factors
// convert float or double to BP1 integer ( -1.0 <= x < +1.0 )
#define NF2BP1 0x7FFFFFFF
// convert float or double to BP2 integer ( -2.0 <= x < +2.0 )
#define NF2BP2 0x3FFFFFFF

//wchen: added for new buffer model 

#define NOT_DETECTED_YET -2
#define NO_TRANSIENT     -1

#if defined (SMOOTH_NMR)
// Used by noise detection/suppression
#define NOISE_DETECTION_HALFBLOCK 128
#endif // SMOOTH_NMR

#endif //__CONSTANTS_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\wmalib\common\DecTables.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows Media
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       tables_rc.h
//
//--------------------------------------------------------------------------

#ifndef _DECTABLES_H_
#define _DECTABLES_H_

#ifdef __cplusplus
extern "C" {  // only need to export C interface if
              // used by C++ source code
#endif

#include "macros.h"
#include "constants.h"

#ifdef USE_SIN_COS_TABLES
extern const Int g_SinTableForReconstruction[(2048+1024+512+256+128+64)];
#endif

//for high rates only
extern const U16    g_rgiBarkFreq	[];

extern const U16    g_rgiHuffDecTblMsk[];

extern const U16    g_rgiHuffDecTbl16smOb[];
extern const U16    gRun16smOb[];   //can be a byte
extern const U16    gLevel16smOb[]; //can be a byte

extern const U16    g_rgiHuffDecTbl16ssOb[];
extern const U16    gRun16ssOb[];   //can be a byte
extern const U16    gLevel16ssOb[]; //can be a byte

//For FFT & adaptToSubFrameConfig
typedef struct {
    BP1Type sin_PIby4cSB;		// sin( pi/(4*cSB) ) * nF2BP1 for DCT and inverseTransform
    BP1Type cos_PIby4cSB;		// cos( pi/(4*cSB) ) * nF2BP1 for DCT and inverseTransform
	BP1Type sin_3PIby4cSB;		// sin( 3*pi/(4*cSB) ) * nF2BP1 for DCT
	BP1Type cos_3PIby4cSB;		// cos( 3*pi/(4*cSB) ) * nF2BP1 for DCT
	BP1Type sin_PIbycSB;		// sin( pi/cSB ) * nF2BP1 for DCT
	BP1Type cos_PIbycSB;		// cos( pi/cSB ) * nF2BP1 for DCT
	BP1Type sin_2PIbycSB;		// sin( pi/(cSB/2) ) * nF2BP1 for FFT
	BP1Type cos_2PIbycSB;		// cos( pi/(cSB/2) ) * nF2BP1 for FFT
	BP1Type sin_PIby2cSB;		// sin( pi/(2*cSB) ) * nF2BP1 for inverseTransform
	BP1Type cos_PIby2cSB;		// cos( pi/(2*cSB) ) * nF2BP1 for inverseTransform
	BP1Type two_sin_PIbycSB;	// 2 * sin( pi/cSB ) * nF2BP1 for DCT
#ifdef ENABLE_LPC
    BP2Type sin_4PIbycSB;       // sin( 4*pi/cSB ) * nF2BP2 for LPC
    BP2Type cos_4PIbycSB;       // sin( 4*pi/cSB ) * nF2BP2 for LPC
#endif
}SinCosTable;

#define SINCOSTABLE_ENTRIES 17
extern const SinCosTable * const rgSinCosTables[SINCOSTABLE_ENTRIES];

#if defined(BUILD_INTEGER) || defined(INTEGER_ENCODER)
	typedef I32 MaskPowerType;
#	define MASK_POWER_FRAC_BITS 28
#	define MASK_POWER_SCALE (1<<MASK_POWER_FRAC_BITS)
#	define MASK_POWER_FROM_FLOAT(flt) ((MaskPowerType)((flt)*MASK_POWER_SCALE))
#	define FLOAT_FROM_MASK_POWER(typ) ((typ)/((Float)MASK_POWER_SCALE))

	typedef I32 DBPowerType;
#	define DBPOWER_FRAC_BITS QUANTSTEP_FRACT_BITS
#	define DBPOWER_FROM_FLOAT(flt) ((DBPowerType)((flt)*(1<<DBPOWER_FRAC_BITS)))
#	define FLOAT_FROM_DBPOWER(typ) ((typ)*(((Float)1.0)/(1<<DBPOWER_FRAC_BITS)))
#else
	typedef Float MaskPowerType;
#	define MASK_POWER_FRAC_BITS 0
#	define MASK_POWER_SCALE 1
#	define MASK_POWER_FROM_FLOAT(flt) ((MaskPowerType)(flt))
#	define FLOAT_FROM_MASK_POWER(typ) ((Float)(typ))

	typedef Float DBPowerType;
#	define DBPOWER_FROM_FLOAT(flt) ((DBPowerType)(flt))
#	define FLOAT_FROM_DBPower(typ) ((Float)(typ))
#endif

#if defined(SKIMP_ON_ROM)
#	define MASK_MINUS_POWER_TABLE_SIZE 40
#else
#	define MASK_MINUS_POWER_TABLE_SIZE 72
#endif
extern const MaskPowerType rgiMaskMinusPower10[MASK_MINUS_POWER_TABLE_SIZE];
#define MASK_PLUS_POWER_TABLE_SIZE 50
extern const MaskPowerType rgiMaskPlusPower10[MASK_PLUS_POWER_TABLE_SIZE];


#define DBPOWER_TABLE_SIZE 128
#define DBPOWER_TABLE_OFFSET 18
extern const DBPowerType rgDBPower10[DBPOWER_TABLE_SIZE];
#ifdef BUILD_INT_FLOAT
extern const Float rgfltDBPowerExponentScale[((DBPOWER_TABLE_OFFSET+DBPOWER_TABLE_SIZE)>>3)+1];
#endif

#ifdef ENABLE_ALL_ENCOPT
//for all other rates
extern const U16    g_rgiHuffDecTbl44smOb[];
extern const U16    gRun44smOb[];   //can be a byte
extern const U16    gLevel44smOb[];

extern const U16    g_rgiHuffDecTbl44ssOb[];
extern const U16    gRun44ssOb[];
extern const U16    gLevel44ssOb[]; //can be a byte

extern const U16    g_rgiHuffDecTbl44smQb[];
extern const U16    gRun44smQb[];
extern const U16    gLevel44smQb[];  //can be a byte

extern const U16    g_rgiHuffDecTbl44ssQb[];
extern const U16    gRun44ssQb[];
extern const U16    gLevel44ssQb[];  //can be a byte

extern const U16    g_rgiHuffDecTblNoisePower[];

extern const float  g_rgfltLsfReconLevel [LPCORDER] [16];

#if defined(BUILD_INTEGER) || defined(INTEGER_ENCODER)

#   define INVQUADROOT_FRACTION_TABLE_LOG2_SIZE 8
#   define INVQUADROOT_FRACTION_TABLE_SIZE (1<<INVQUADROOT_FRACTION_TABLE_LOG2_SIZE)

    extern const UInt g_InvQuadRootFraction[1+INVQUADROOT_FRACTION_TABLE_SIZE];
    extern const UInt g_InvQuadRootExponent[BITS_LP_SPEC_POWER+1];

#   define INVERSE_FRACTION_TABLE_LOG2_SIZE 8
#   define INVERSE_FRACTION_TABLE_SIZE (1<<INVERSE_FRACTION_TABLE_LOG2_SIZE)
    extern const UInt g_InverseFraction[1+INVERSE_FRACTION_TABLE_SIZE];

#   define SQRT_FRACTION_TABLE_LOG2_SIZE 8
#   define SQRT_FRACTION_TABLE_SIZE (1<<SQRT_FRACTION_TABLE_LOG2_SIZE)
    extern const UInt g_SqrtFraction[1+SQRT_FRACTION_TABLE_SIZE];

#endif

#endif // ENABLE_ALL_ENCOPT

#define PWRTORMS_ZEROPT     60
#define PWRTORMS_SIZE       (PWRTORMS_ZEROPT*2 + 1)
extern const UInt           g_rgfiPwrToRMS[];

#ifdef __cplusplus
}
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\wmalib\common\macros.h ===
/*************************************************************************

Copyright (C) Microsoft Corporation, 1996 - 1999

Module Name:

    Macros.h

Abstract:

    Processor-specific macros, defines, and data types.

Author:

    Raymond Cheng (raych)       Jul 29, 1999

Revision History:


*************************************************************************/

#ifndef __COMMON_MACROS_H
#define __COMMON_MACROS_H

#ifndef DISABLE_ASSERTS
#define DISABLE_ASSERTS
#endif // DISABLE_ASSERTS

// If BUILD_INTEGER or BUILD_INT_FLOAT is not defined by project set default state

#ifdef SDE_WANTS_ASSERTS
// This should be defined only when an SDE is watching and never when checking in or for builds.
// a compiler warning message is on wmaos.c
#   ifdef DISABLE_ASSERTS
#       undef DISABLE_ASSERTS
#   endif
#elif !defined(DISABLE_ASSERTS)
// DISABLE ASSERTS because of a known issue. V4-encoded streams can contain garbage
// at the end which we will detect as an invalid bitstream.
#   define DISABLE_ASSERTS
#endif

#ifdef BUILD_INT_FLOAT
    // build Floating version of integer tree (otherwise, build integer version)
#   if defined(BUILD_INTEGER)
#       undef BUILD_INTEGER
#   endif
#elif !defined(BUILD_INTEGER)
    // This is default for decoder if neither is defined
#   define BUILD_INTEGER
#endif  

#ifdef ENCODER
// not integer build if encoder
#undef BUILD_INTEGER
#if !defined(INTEGER_ENCODER) && !defined(BUILD_INT_FLOAT)
// except for integer encoder, assume float for the encoder
#define BUILD_INT_FLOAT
#endif  // INTEGER_ENCODER
#endif  // ENCODER

#include "constants.h"

#ifdef UNDER_CE
#include <windef.h>
#include <kfuncs.h>
#include <dbgapi.h>
#define assert ASSERT
#else
// The following are ANSI C includes, and so should be safe for all platforms
#include <assert.h>     // If this doesn't exist, you must write an "assert" macro
#endif
#include <string.h>
#include <stdlib.h>

#ifdef DISABLE_ASSERTS
#undef assert
#define assert(a)
#endif  // DISABLE_ASSERTS


// **************************************************************************
// Platform-Specific #ifdefs
// **************************************************************************
#ifdef __QNX__
#undef _M_IX86
#endif
#if defined(_M_IX86) && !defined(INTEGER_ENCODER)
//#ifdef __QNX__
//#define WMA_TARGET_QNX_X86
//#else
#define WMA_TARGET_X86
//#endif
#endif

#ifdef _MIPS_
#define WMA_TARGET_MIPS
#endif

#if defined(_SH3_) && !defined(_SH4_)
#define WMA_TARGET_SH3
#endif

#ifdef _SH4_
#define WMA_TARGET_SH4
#endif

#ifdef _Embedded_x86
#define WMA_TARGET_Embedded_x86
#endif


#ifdef S_SUNOS5
#define WMA_TARGET_S_SUNOS5
#endif

#ifdef _ARM_
#define WMA_TARGET_ARM
#endif

// It's often nice to be able to compare the output between optimized versions
// and the ANSI version, to verify that the optimizations are in sync. Alas,
// some optimizations sacrifice reproducibility for speed. The following #define allows
// us to disable those optimizations to verify the main algorithms.
//#define WMA_ANSI_COMPATIBILITY_MODE


// ======================================================
// Intel x86 Platform
// ======================================================
#if defined(WMA_TARGET_X86)

#if !defined(UNDER_CE) 
#define USE_SIN_COS_TABLES
#endif

// Override the ROUNDF/ROUNDD macros below
#ifndef LITTLE_ENDIAN
#define LITTLE_ENDIAN
#endif  //LITTLE_ENDIAN
#define PLATFORM_SPECIFIC_ROUND
#define PLATFORM_SPECIFIC_BITCOPY
#define PLATFORM_SPECIFIC_FNPTR //mmx, katmai

#ifdef WMA_ANSI_COMPATIBILITY_MODE
#undef PLATFORM_SPECIFIC_ROUND
#endif // WMA_ANSI_COMPATIBILITY_MODE

// Do the fundamental typedefs: {U|I}{8|16|32|64}
typedef unsigned __int64 U64;
typedef __int64 I64;
// Default all other typedefs to standard definitions (see below)
                                                               
// Do compiler directives
#define PLATFORM_SPECIFIC_INLINE
#if _MSC_VER >= 1200            /* VC6.0 == 1200, VC5.0 == 1100 */
#define INLINE __forceinline
#else  /* _MSC_VER */
#define INLINE __inline
#endif /* _MSC_VER */
// ======================================================
// QNX in X86 Platform
// ======================================================
#elif defined(WMA_TARGET_QNX_X86)

// Override the ROUNDF/ROUNDD macros below
#define LITTLE_ENDIAN
#define PLATFORM_SPECIFIC_ROUND
#define PLATFORM_SPECIFIC_BITCOPY

#ifdef WMA_ANSI_COMPATIBILITY_MODE
#undef PLATFORM_SPECIFIC_ROUND
#endif // WMA_ANSI_COMPATIBILITY_MODE

// Do the fundamental typedefs: {U|I}{8|16|32|64}
#ifdef __QNX__
#include "../qnx/qnx.h"
#else
typedef __int64 U64;
typedef __int64 I64;
#endif
// Default all other typedefs to standard definitions (see below)

// Do compiler directives
#define PLATFORM_SPECIFIC_INLINE                       
#define INLINE __inline

// ======================================================
// MIPS (Casio) Platform
// ======================================================
#elif defined(WMA_TARGET_MIPS)

#define LITTLE_ENDIAN

// Do the fundamental typedefs: {U|I}{8|16|32|64}
typedef unsigned __int64 U64;
typedef __int64 I64;
// Default all other typedefs to standard definitions (see below)

// Do compiler directives
#define PLATFORM_SPECIFIC_INLINE
#define INLINE __forceinline


// ======================================================
//SH3 (HP WinCE and Hitachi) Platform
// ======================================================
#elif defined(WMA_TARGET_SH3)

#define LITTLE_ENDIAN

// Do the fundamental typedefs: {U|I}{8|16|32|64}
#ifdef NOINT64 
#include "int64.h"
typedef UINT64 U64;
typedef  INT64 I64;
#else
typedef unsigned __int64 U64;
typedef __int64 I64;
#endif
// Default all other typedefs to standard definitions (see below)

// Do compiler directives
#define PLATFORM_SPECIFIC_INLINE
#ifdef HITACHI
#pragma inline(quickRand, RandStateClear, LOG2, NormUInt, Align2FracBits, ROUNDF, ROUNDD, bitCpy)
#define INLINE static
#else
#define INLINE __forceinline
#endif
// ======================================================
//SH4 (HP WinCE and Hitachi) Platform
// ======================================================
#elif defined(WMA_TARGET_SH4)

#define LITTLE_ENDIAN

// Do the fundamental typedefs: {U|I}{8|16|32|64}
#ifdef NOINT64 
#include "int64.h"
typedef UINT64 U64;
typedef  INT64 I64;
#else
typedef __int64 U64;
typedef __int64 I64;
#endif
// Default all other typedefs to standard definitions (see below)

// Do compiler directives
#define PLATFORM_SPECIFIC_INLINE
#ifdef HITACHI
#pragma inline(quickRand, RandStateClear, LOG2, NormUInt, Align2FracBits, ROUNDF, ROUNDD, bitCpy)
#define INLINE static
#else
#define INLINE __forceinline
#endif
// ======================================================
//ARM Platform
// ======================================================
#elif defined(WMA_TARGET_ARM)

#define LITTLE_ENDIAN

// Do the fundamental typedefs: {U|I}{8|16|32|64}
typedef unsigned __int64 U64;
typedef __int64 I64;
// Default all other typedefs to standard definitions (see below)

// Do compiler directives
#define PLATFORM_SPECIFIC_INLINE
#define INLINE __forceinline

// ======================================================
//Linux in X86 Platform
// ======================================================
#elif defined(WMA_TARGET_Embedded_x86)
#undef BIG_ENDIAN
#undef  LITTLE_ENDIAN
#define LITTLE_ENDIAN

// Do the fundamental typedefs: {U|I}{8|16|32|64}
typedef  unsigned long long U64;
typedef  long long  I64;
// Default all other typedefs to standard definitions (see below)
// 
// Do compiler directives
#define PLATFORM_SPECIFIC_INLINE
#define INLINE inline  

// ======================================================
//Sun Solaris
// ======================================================
#elif defined(WMA_TARGET_S_SUNOS5)

#undef  LITTLE_ENDIAN
#undef  BIG_ENDIAN
#define BIG_ENDIAN

// Do the fundamental typedefs: {U|I}{8|16|32|64}
typedef  unsigned long long int  U64 ;
typedef  long long int  I64 ;

#define  PLATFORM_SPECIFIC_I32
typedef unsigned int U32;
typedef int I32;
// Default all other typedefs to standard definitions (see below)
// 
// Do compiler directives
#define PLATFORM_SPECIFIC_INLINE
#define INLINE inline  


// ======================================================
//MacOS Platform
// ======================================================
#elif defined(WMA_TARGET_MACOS)

#undef  LITTLE_ENDIAN
#undef  BIG_ENDIAN
#define BIG_ENDIAN

// Do the fundamental typedefs: {U|I}{8|16|32|64}
typedef  unsigned long long     U64;
typedef  long long              I64;

// Default all other typedefs to standard definitions (see below)
// 


// ======================================================
// ANSI-C version (no platform-specific details
// ======================================================
#else

#define WMA_TARGET_ANSI

// Default endian
#if !defined(LITTLE_ENDIAN) && !defined(BIG_ENDIAN)
#define LITTLE_ENDIAN
#endif

// Do the fundamental typedefs: {U|I}{8|16|32|64}
#ifdef NOINT64 
#include "int64.h"
typedef UINT64 U64;
#else
#ifdef __QNX__
typedef unsigned long long int U64;
typedef long long int I64;
#else
#ifdef macintosh
typedef unsigned long long U64;
typedef long long I64;
#else
typedef unsigned __int64 U64;
typedef __int64 I64;
#endif
#endif
#endif //NOINT64
// Default all other typedefs to standard definitions (see below)

#endif // Platform-specific #ifdefs



// **************************************************************************
// Default Fundamental Typedefs
// **************************************************************************
#ifndef PLATFORM_SPECIFIC_I32
#ifdef HITACHI
typedef unsigned long U32;
typedef long I32;
#else
typedef unsigned long int U32;
typedef long int I32;
#endif
#endif

#ifndef PLATFORM_SPECIFIC_I16
typedef unsigned short U16;
typedef short I16;
#endif

#ifndef PLATFORM_SPECIFIC_I8
typedef unsigned char U8;
typedef signed char I8;
#endif



// **************************************************************************
// Common Typedefs (not expected to change by platform)
// **************************************************************************
#ifndef _WMARESULT_DEFINED
#define _WMARESULT_DEFINED
typedef I32 WMARESULT;

// SUCCESS codes
static const WMARESULT WMA_OK               = 0x00000000;
static const WMARESULT WMA_S_FALSE          = 0x00000001;
static const WMARESULT WMA_S_BUFUNDERFLOW   = 0x00000002;
static const WMARESULT WMA_S_NEWPACKET      = 0x00000003;
static const WMARESULT WMA_S_NO_MORE_FRAME  = 0x00000004;
static const WMARESULT WMA_S_DEFAULT        = 0x00000005;
static const WMARESULT WMA_S_SWITCHCHMODE   = 0x00000006; // Internal error, corrected internally

// ERROR codes
static const WMARESULT WMA_E_FAIL           = 0x80004005;
static const WMARESULT WMA_E_OUTOFMEMORY    = 0x8007000E;
static const WMARESULT WMA_E_INVALIDARG     = 0x80070057;
static const WMARESULT WMA_E_NOTSUPPORTED   = 0x80040000;
static const WMARESULT WMA_E_LOSTPACKET     = 0x80040001;
static const WMARESULT WMA_E_BROKEN_FRAME   = 0x80040002;
static const WMARESULT WMA_E_BUFFEROVERFLOW = 0x80040003;
static const WMARESULT WMA_E_ONHOLD         = 0x80040004; 
//ON_HOLD: the decoder can't continue operating because of sth, most
//       likely no more data for flushing, getbits or peekbits. all functions
//       stop *immediately*.

static const WMARESULT WMA_E_BUFFERUNDERFLOW =0x80040005;
static const WMARESULT WMA_E_INVALIDRECHDR  = 0x80040006;
static const WMARESULT WMA_E_SYNCERROR      = 0x80040007;
static const WMARESULT WMA_E_NOTIMPL        = 0x80040008;
static const WMARESULT WMA_E_FLUSHOVERFLOW  = 0x80040009; // Too much input data provided to flush


#endif // _WMARESULT_DEFINED

#define WMAB_TRUE 1
#define WMAB_FALSE 0

#define own // used as "reserved word" to indicate ownership or transfer to distinguish from const

typedef double Double;
typedef float Float;
typedef void Void;
typedef U32 UInt;
typedef I32 Int;
typedef I32 Bool; // In Win32, BOOL is an "int" == 4 bytes. Keep it this way to reduce problems.


// **************************************************************************
// Overridable Compiler Directives
// **************************************************************************
#ifndef PLATFORM_SPECIFIC_INLINE
// This should hopefully work for most compilers. It works for VC
#define INLINE __inline
#endif  // PLATFORM_SPECIFIC_INLINE

#ifndef PLATFORM_SPECIFIC_COMPILER_MESSAGE
#define COMPILER_MESSAGE(x)         message(x)
#endif

#ifndef PLATFORM_SPECIFIC_COMPILER_PACKALIGN
#define COMPILER_PACKALIGN(x)       pack(x)
#endif

#ifndef PLATFORM_SPECIFIC_COMPILER_PACKALIGN_DEFAULT
#define COMPILER_PACKALIGN_DEFAULT  pack()
#endif

#ifdef _MSC_VER
#define MSVC_DISABLE_WARNING(x)     warning(disable:x)
#define MSVC_RESTORE_WARNING(x)     warning(default:x)
#define MSVC_CDECL                  __cdecl
#else   // _MSC_VER
// I'm hoping that compilers can take an empty #pragma (VC can)
#define MSVC_DISABLE_WARNING(x)
#define MSVC_RESTORE_WARNING(x)
#define MSVC_CDECL
#endif  // _MSC_VER


// **************************************************************************
// Macros Common to All Platforms
// **************************************************************************
// If you need to override the following for just one platform, #define a
// switch to override as in the case for ROUNDF/ROUNDD above in the
// platform-specific #ifdefs so that it is plain to see.

#define MULT_HI(a,b) (MULT_HI_DWORD(a,b)<<1)
#ifndef BUILD_INTEGER
    // these macros are not used by integer decoder. 
    // Where/when needed, provide cpu depended optimized versions as well as these generic ones.
#   define UMASR(a,b,c) (U32)((((U64)a)*((U64)b))>>c)
#   define MASR(a,b,c) (I32)((((I64)a)*((I64)b))>>(c))
#   define DASR(a,b,c) (I32)((((I64)a)*((I64)b))>>(c))
#   define DASL(a,b,c) (I32)((((I64)a)*((I64)b))<<(c))

    // The following macro has no perf-enhanced equivalents, although one can
    // easily be written a la x86 MULT_HI_DWORD:
    // I32HI,LOW = a*b; if (I32LOW & 0x80000000) I32HI += 1; return I32HI;
    // NOTE that it only rounds UP, and does not consider negative numbers.
#   define MULT_HI_DWORD_ROUND(a,b)    (I32)((((I64)(a))*((I64)(b)) + ((I64)1 << 31))>>32)
#endif

#define max(a,b) (((a) > (b)) ? (a) : (b))
#define min(a, b)  (((a) < (b)) ? (a) : (b))
#define checkRange(x, a, b) (((x) < (a)) ? (a) : (((x) > (b)) ? (b) : (x)))
#define DELETE_ARRAY(ptr) if (ptr!=NULL) auFree (ptr); ptr = NULL;
#define DELETE_PTR(ptr) if (ptr!=NULL) auFree (ptr); ptr = NULL;
#define ARRAY_SIZE(ar) (sizeof(ar)/sizeof((ar)[0]))

#  ifdef DEBUG_ONLY
// WCE already has this macro defined in the same way, avoid warning messages
#  undef DEBUG_ONLY
#  endif
#ifdef _DEBUG
#define DEBUG_ONLY(x)   x
#else   // _DEBUG
#define DEBUG_ONLY(x)
#endif  // _DEBUG

#if defined(LITTLE_ENDIAN)
#define DEFAULTENDIAN_TO_BIGENDIAN(i)   ByteSwap(i)
#define BIGENDIAN_TO_DEFAULTENDIAN(i)   ByteSwap(i)
#elif defined(BIG_ENDIAN)
#define DEFAULTENDIAN_TO_BIGENDIAN(i)   (i)
#define BIGENDIAN_TO_DEFAULTENDIAN(i)   (i)
#else
#error Must define the endian of the target platform
#endif // ENDIAN

#define SWAP_WORD( w )      (w) = ((w) << 8) | ((w) >> 8)

#define SWAP_DWORD( dw )    (dw) = ((dw) << 24) | ( ((dw) & 0xFF00) << 8 ) | ( ((dw) & 0xFF0000) >> 8 ) | ( ((dw) & 0xFF000000) >> 24);

// WMARESULT macros (stolen from winerror.h)
#define WMA_SUCCEEDED(Status) ((WMARESULT)(Status) >= 0)
#define WMA_FAILED(Status) ((WMARESULT)(Status)<0)


// Create types which are change implementation between BUILD_INTEGER and BUILD_INT_FLOAT
// Some platforms, like the X86 and the SH4, can implement either build efficently.
// Other platforms, with only emulated floating point support, are typically only build with BUILD_INTEGER
//  
// Each type defined below is either a float (BUILD_INT_FLOAT) and an I32 with some number of fractional bits (BUILD_INTEGER)
// Use float or and I32 with five fractional bits
// And create a type for trig functions (Float or I32 with 30 fractional bits)
#if defined(BUILD_INTEGER) || defined(INTEGER_ENCODER)

// Coefficents type (output of inverse quantization, transformed by DCT and overlapped/added)
// Range is +/- 2^26 with five fractional bits
    typedef I32 CoefType;
#   define COEF_FRAC_BITS 5
#   define COEF_FRAC_SCALE (1<<COEF_FRAC_BITS)
#   define COEF_FROM_FLOAT(flt) ((CoefType)(flt*COEF_FRAC_SCALE))
#   define FLOAT_FROM_COEF(coef) (coef/((Float)COEF_FRAC_SCALE))
#   define COEF_FROM_INT(i) ((i)<<COEF_FRAC_BITS)
#   define INT_FROM_COEF(cf) ((cf)>>COEF_FRAC_BITS)

// Fractional Type with range -2.0 <= x < 2.0 used by FFT Trig Recurrsion 
    typedef I32 BP2Type;
#   define BP2_FRAC_BITS 30
#   define BP2_FRAC_SCALE NF2BP2
#   define BP2_FROM_FLOAT(flt) ((BP2Type)(flt*BP2_FRAC_SCALE))
#   define FLOAT_FROM_BP2(bp2) (bp2/((Float)BP2_FRAC_SCALE))
#   define BP2_FROM_BP1(bp1) ((bp1)>>1)
#   define MULT_BP2(a,b) MULT_HI_DWORD_DOWN((a),(b))

// Fractional type with range -1.0 <= x < 1.0 used by DCT Trig Recurrsion
    typedef I32 BP1Type;
#   define BP1_FRAC_BITS 31
#   define BP1_FRAC_SCALE NF2BP1
#   define BP1_FROM_FLOAT(flt) ((BP2Type)(flt*BP1_FRAC_SCALE))
#   define FLOAT_FROM_BP1(bp1) (bp1/((Float)BP1_FRAC_SCALE))
#   define MULT_BP1(a,b) MULT_HI((a),(b))

// Fraction is stored at 2^32 (BP0)
#define UBP0_FROM_FLOAT(x) ((U32)(x*4294967296.0F))

    typedef I32 FracBitsType;
    typedef struct {
    //I8 exponent;  Old exponent was shift from binary point at 24th position
        FracBitsType iFracBits;
        I32 iFraction;
    } FastFloat;

// Type for holding quantization magnitide returned by prvWeightedQuantization
    typedef FastFloat QuantFloat;

//****************************************************************************
//         Types, constants related to LPC.
//         Lot of these could be moved to constants.h or lpcConst.h for cleanliness
//****************************************************************************

//  LSP (aka LSF), used for inverse quantized LSF.
    typedef Int LspType;
#   define FRACT_BITS_LSP 30
#   define LSP_SCALE (1<<FRACT_BITS_LSP)
#   define LSP_FROM_FLOAT(a) ((LpType)((a)*LSP_SCALE))
#   define MULT_LSP(a,b) (I32)((((I64)(a))*((I64)(b)))>>FRACT_BITS_LSP)
// MULT_LSP may be redefined by processor specific code in macros_cpu.h

//  LP, used for P, Q, and LPC values
    typedef Int LpType;
#   ifndef MATCH_ARM_WAY
#       define FRACT_BITS_LP 27
#   else
#       define FRACT_BITS_LP 26
#   endif
#   define LP_SCALE (1<<FRACT_BITS_LP)
#   define FLOAT_FROM_LP(a) ((Float)((a)*(1.0f/LP_SCALE)))
#   define LP_FROM_FLOAT(a) ((LpType)((a)*LP_SCALE))

//  LP Spectrum: used during FFT of LPC values
//  LP Spectrum power: sum-squares of FFT output
    typedef Int LpSpecType;
#if defined (LPCPOWER32)
//               Uses 32-bit intermediates
//               LPC scale is 2^21.  Making it any larger causes overflows in the square(x) function 
//               in LPC_TO_SPECTRUM. But would like more frac bits, because the small values of the 
//               spectrum yield larger WeightFactors. And float version on the same sound uses 
//               IQR(1.575e-7) = 75.5795. Largest IQR of 1/LPC_SCALE is 38 or the result for values 
//               less than that which is 1/(2*LPC_SCALE) => 45.25.
#   define FRACT_BITS_LP_SPEC 21
    typedef UInt LpSpecPowerType;
#   define BITS_LP_SPEC_POWER 32
#   define FRACT_BITS_LP_SPEC_POWER 21
#   define QR_FRACTION_FRAC_BITS 27
#   define QR_EXPONENT_FRAC_BITS 25

#else // !LPCPOWER32
//                Uses 64-bit intermediates
#   ifndef MATCH_ARM_WAY
#       define FRACT_BITS_LP_SPEC 25
#   else
        //  ARM's use of 26 instead of 25 produces BIG relative errors compared to LPC_COMPARE
        //  at least when using the old version of the Lpc code.
//#       define FRACT_BITS_LP_SPEC 26
#       define FRACT_BITS_LP_SPEC 25
#   endif
    typedef U64 LpSpecPowerType;
#   define BITS_LP_SPEC_POWER 64
#   define FRACT_BITS_LP_SPEC_POWER 30 
#   define QR_FRACTION_FRAC_BITS 24
#   define QR_EXPONENT_FRAC_BITS 29
#endif // LPCPOWER32

#   define LP_SPEC_SCALE (1<<FRACT_BITS_LP_SPEC)
#   define LP_SPEC_POWER_SCALE ((float)(1L<<FRACT_BITS_LP_SPEC_POWER))
#   define LP_SPEC_FROM_FLOAT(a) ((LpSpecType)((a)*LP_SPEC_SCALE))
#   define LP_SPEC_POWER_FROM_FLOAT(a) ((LpSpecType)((a)*LP_SPEC_POWER_SCALE))
#   define FLOAT_FROM_LP_SPEC(a) ((Float)((a)*(1.0f/LP_SPEC_SCALE)))
#   define LP_SPEC_FROM_LP(a) ((LpSpecType)((a)>>(FRACT_BITS_LP-FRACT_BITS_LP_SPEC)))

//  Weights, computed from LPC (and Bark?).
    typedef UInt WeightType;
//               We see weight factor values upto 64.53440857: 7 bits enough to cover integer part, 
//               leaving upto 25 bits for fraction. However, only 21 bits of fraction are generated 
//               upstream, making other 4 bits zero, even if used.
#if defined (LPCPOWER32)
#   define WEIGHTFACTOR_FRACT_BITS     20
#else
#   ifndef MATCH_ARM_WAY
#       define WEIGHTFACTOR_FRACT_BITS     21
#   else
#       define WEIGHTFACTOR_FRACT_BITS     25
#   endif
#endif 
#   define WEIGHT_FROM_FLOAT(a) ((WeightType)((a)*(1<<WEIGHTFACTOR_FRACT_BITS)))
#   define FLOAT_FROM_WEIGHT(a) ((Float)((a)*(1.0f/(1<<WEIGHTFACTOR_FRACT_BITS))))

//****************************************************************************
//         End of types, constants related to LPC.
//****************************************************************************

    // Some utility functions with obvious meaning
#   define DIV2(a) ((a)>>1)
#   define MUL2(a) ((a)<<1)
#   define DIV4(a) ((a)>>2)
#   define MUL4(a) ((a)<<2)
#   define MUL8(a) ((a)<<3)

#   define INTEGER_ONLY(a) a
#   define INTEGER_OR_INT_FLOAT(a,b) a

#else // ************ so must be BUILD_INT_FLOAT *****************

// Coefficents type (output of inverse quantization, transformed by DCT and overlapped/added)
    typedef Float CoefType;
#   define COEF_FRAC_BITS 0
#   define COEF_FRAC_SCALE 1
#   define COEF_FROM_FLOAT(flt) ((CoefType)(flt))
#   define FLOAT_FROM_COEF(coef) ((Float)(coef))
#   define COEF_FROM_INT(i) (i)
#   define INT_FROM_COEF(cf) (cf)

// Fractional Type used by FFT Trig Recurrsion 
    typedef Float BP2Type;
#   define BP2_FRAC_BITS 0
#   define BP2_FRAC_SCALE 1
#   define BP2_FROM_FLOAT(flt) ((BP2Type)(flt))
#   define FLOAT_FROM_BP2(bp2) ((Float)(bp2))
#   define BP2_FROM_BP1(bp1) (bp1)
#   define MULT_BP2(a,b) ((a)*(b))

// Fractional type used by DCT Trig Recurrsion
    typedef Float BP1Type;
#   define BP1_FRAC_BITS 0
#   define BP1_FRAC_SCALE 1
#   define BP1_FROM_FLOAT(flt) ((BP1Type)(flt))
#   define FLOAT_FROM_BP1(bp1) ((Float)(bp1))
#   define MULT_BP1(a,b) ((a)*(b))

// Another form of floating point 
    typedef Float FastFloat;

// Type for holding quantization magnitide returned by prvWeightedQuantization
    typedef Float QuantFloat;

//****************************************************************************
//         Types, constants related to LPC.
//****************************************************************************

//  LSP (aka LSF), used for inverse quantized LSF.
    typedef Float LspType;
#   define LSP_FROM_FLOAT(a) ((LspType)(a))
#   define MULT_LSP(x,y) ((x)*(y))

// LP, used for P, Q, and LPC values
    typedef Float LpType;
#   define LP_FROM_FLOAT(a) ((LpType)(a))
#   define FLOAT_FROM_LP(a) ((Float)(a))

// LP Spectrum: used during FFT of LPC values
// LP Spectrum power: sum-squares of FFT output
    typedef Float LpSpecType;
    typedef Float LpSpecPowerType;
#   define LP_SPEC_FROM_FLOAT(a) ((LpSpecType)(a))
#   define FLOAT_FROM_LP_SPEC(a) ((Float)(a))
#   define LP_SPEC_FROM_LP(a)    ((LpSpecType)(a))

//  Weights, computed from LPC   (and Bark?).
    typedef Float WeightType;
#   define WEIGHT_FROM_FLOAT(a) ((WeightType)(a))
#   define FLOAT_FROM_WEIGHT(a) ((Float)(a))

//****************************************************************************
//         End of types, constants related to LPC.
//****************************************************************************

// Some utility functions with obvious meaning
#   define DIV2(a) ((a)*0.5f)
#   define MUL2(a) ((a)*2.0f)
#   define DIV4(a) ((a)*0.25f)
#   define MUL4(a) ((a)*4.0f)
#   define MUL8(a) ((a)*8.0f)

#   define INTEGER_ONLY(a)
#   define INTEGER_OR_INT_FLOAT(a,b) b

#endif  // either BUILD_INTEGER or BUILD_INT_FLOAT

// some utility macros that are type specific to avoid the compiler's type conversion rules.
#define COEF_ABS(a) (((a)<0) ? -(a) : (a))
#define BPX_ABS(a) (((a)<0) ? -(a) : (a))


#if defined(ENCODER) || defined(INTEGER_ENCODER) || !(defined(REFERENCE_RAND_24) || defined(REFERENCE_RAND_16))
    //****************************************************************************
    // quick and dirty rand generator, assuming low word multiply, only works for 
    // 32-bit machines see Numerical Recipes p.284.  
    // Note this is the referenced generator but the 24-bit or 16-bit versions can
    // be used for compliance comparisions with 24-bit or 16-bit implementations.
    //****************************************************************************

    typedef struct tagRandState {
        I32 iPrior;         // prior value
        U32 uiRand;         // current value
    } tRandState;

    INLINE I32 quickRand(tRandState* ptRandState)
    {
        const U32 a = 1664525;
        const U32 c = 1013904223;
        I32 iTemp, iTemp1;
        //a*x + c has to be done with unsigned 32 bit
        ptRandState->uiRand =  a * ptRandState->uiRand + c;

        // uiRand values starting from a 0 seed are: 0x3c6ef35f, 0x47502932, 0xd1ccf6e9, 0xaaf95334, 0x6252e503, 0x9f2ec686, 0x57fe6c2d, ...

        // do not change the above - this reference generator has been extensively tested and has excellent randomness properties
        // a truism in the world of random number generator theory and practice is:
        // "any change, no matter how small, can and will change the properties of the generator and must be fully tested"
        // In case you don't know, it can easily take a person-month to fully test a generator.
    
        // Notwithstanding the above, it is fair to take a function of a random number to shape its range or distribution.
        // This we do below to give it a triangular distrbution between -2.5 and 2.5 to roughly approximate a Guassian distribution.

        // cast and shift to make the range (-1, 1) with Binary Point 3.
        iTemp = ((I32)(ptRandState->uiRand)) >> 2; 

        // *1.25 to make the range (-1.25, 1.25) 
        iTemp += (iTemp>>2);
    
        // Difference of two random numbers gives a triangle distribution and a range of (-2.5, 2.5)
        // it also gives a serial correlation of -0.5 at lag 1.  But all the other lags have normally small correlations.
        iTemp1 = iTemp - ptRandState->iPrior;

        // Save first term of this difference for next time.
        ptRandState->iPrior = iTemp;

        //return -2.5 to 2.5 with Binary Point = 3 with a triangle distribution
        return iTemp1;
    }

    INLINE void RandStateClear(tRandState* ptRandState) {
        ptRandState->iPrior = 0;
        ptRandState->uiRand = 0;
    }

	// protect encoder from having these defined by mistake
#	ifdef REFERENCE_RAND_24
#		undef REFERENCE_RAND_24
#	endif
#	ifdef REFERENCE_RAND_16
#		undef REFERENCE_RAND_16
#	endif

#elif defined(REFERENCE_RAND_24)
    //****************************************************************************
    // Quick and dirty 24-bit rand generator.
    // Simulates 24-bits on a 32-bit reference machine.
    // Note this is the 24-bit referenced generator which can be used for compliance 
    // comparisions with 24-bit implementations by defining REFERENCE_RAN_24
    //****************************************************************************
    typedef struct tagRandState {
        I32 iPrior;         // prior value   (only top 24-bits used)
        U32 uiRand;         // current value (only top 24-bits used)
    } tRandState;

    INLINE I32 quickRand(tRandState* ptRandState)
    {
        // OK to 512 lags, then ChiSquare is suspect at 1024 and rejects at 2048 (length 1024000)
        const U32 uLCa = 69857;         // 0x000110E1
        const U32 uLCc = 3546581;       // 0x00361DD5

        I32 iTemp, iTemp1;
        //a*x + c has to be done with unsigned 32 bit - but we similate a 24x24
        ptRandState->uiRand =  (uLCa * ((ptRandState->uiRand)>>8) + uLCc)<<8;

        // uiRand values starting from a 0 seed are: 0x361dd500, 0x78a60a00, 0xaaac9f00, 0xa0c59400, 0x7104e900, 0xc2fe9e00, 0x1fc6b300

        // do not change the above - see comment in 32-bit generator

        // cast and shift to make the range (-1, 1) with Binary Point 3.
        iTemp = (((I32)(ptRandState->uiRand)) >> 2) & 0xFFFFFF00; 

        // *1.25 to make the range (-1.25, 1.25) 
        iTemp += ((iTemp>>2) & 0xFFFFFF00);
    
        // Difference of two random numbers gives a triangle distribution and a range of (-2.5, 2.5)
        // it also gives a serial correlation of -0.5 at lag 1.  But all the other lags have normally small correlations.
        iTemp1 = iTemp - ptRandState->iPrior;

        // Save first term of this difference for next time.
        ptRandState->iPrior = iTemp;

        //return -2.5 to 2.5 with Binary Point = 3 with a triangle distribution
        return iTemp1;
    }

    INLINE void RandStateClear(tRandState* ptRandState) {
        ptRandState->iPrior = 0;
        ptRandState->uiRand = 0;
    }


#elif defined(REFERENCE_RAND_16)
    //****************************************************************************
    // Quick and dirty 16-bit rand generator.
    // Simulates 16-bits on a 32-bit reference machine.
    // Note this is the 16-bit referenced generator for compliance comparisions 
    // with 16-bit implementations by defining REFERENCE_RAN_16.
    // The function actually returns 21 random bits at the top of the 32 
    // so is not a pure 16-bit generator, but does limit itself to a 16x16=>32 multiply
    //****************************************************************************

    // Background
    // A pure 16-bit Linear Congruent generator has limited sequence length.  
    // Use 13 A's and 3 C's choosen from good values in the middle of the range.
    // Tested OK up to lag 1024 (length 32768) and pretty good at 2048 and 2049.
    // Sequence length quite long.

    // these two arrays are defined once in dectables.c
#   define LCA_SET 13
#   define LCC_SET 3
    extern const unsigned int g_uWMALCA[LCA_SET];   // {1637,1033,1825,1621, 1657,1861,1229,1549, 2017,941,1409,1777, 1153};
    extern const unsigned int g_uWMALCC[LCC_SET];   // {13849,13841,13859};

    typedef struct tagRandState {
        I32 iPrior;         // prior value
        U16 uiRand;         // current value
        char bIdxLCA;       // index for uLCA
        char bIdxLCC;       // index for uLCC
    } tRandState;

    INLINE I32 quickRand(tRandState* ptRandState)
    {
        // This 16-bit implementation returns a 32-bit result with the top 21 bits random.
        // But it base implementation is 16x16=>32, e.g. it requires only a single precision 16-bit multiply.

        I32 iTemp, iTemp1;
        U32 uTemp;

        //a*x + c is with unsigned 32 bit - but we similate a 16x16+16 =32
        uTemp =  (g_uWMALCA[ptRandState->bIdxLCA++] * (ptRandState->uiRand)) + g_uWMALCC[ptRandState->bIdxLCC++];

        // save bottom 16 bits
        ptRandState->uiRand  = (unsigned short)uTemp;

        // uiRand values starting from a 0 seed are: 0x3623, 0x259c, 0x5add, 0x5698, 0xb511, 0x78ae, 0x6af9, 0x09f2, 0xc49b, 0x4f3e, 0x4377, 0x1108

        // wrap indexes
        if (ptRandState->bIdxLCA>=LCA_SET) 
            ptRandState->bIdxLCA = 0;
        if (ptRandState->bIdxLCC>=LCC_SET)
            ptRandState->bIdxLCC = 0;

        // get best 19 bits into top
        uTemp <<= 13;           

        // do not change the above - see comment in 32-bit generator

        // cast and shift to make the range (-1, 1) with Binary Point 3.
        iTemp = (((I32)(uTemp)) >> 2); 

        // *1.25 to make the range (-1.25, 1.25) 
        iTemp += (iTemp>>2);
    
        // Difference of two random numbers gives a triangle distribution and a range of (-2.5, 2.5)
        // it also gives a serial correlation of -0.5 at lag 1.  But all the other lags have normally small correlations.
        iTemp1 = iTemp - ptRandState->iPrior;

        // Save first term of this difference for next time.
        ptRandState->iPrior = iTemp;

        //return -2.5 to 2.5 with Binary Point = 3 with a triangle distribution
        return iTemp1;
    }

    INLINE void RandStateClear(tRandState* ptRandState) {
        ptRandState->iPrior = 0;
        ptRandState->uiRand = 0;
        ptRandState->bIdxLCA = 1;
        ptRandState->bIdxLCC = 2;
    }

#endif

//****************************************************************************
// log base 2 of a number which is a power of 2 
//****************************************************************************
INLINE I32 LOG2(U32 i)
{   // returns n where n = log2(2^n) = log2(2^(n+1)-1)
    U32 iLog2 = 0;
    assert (i != 0);
    while ((i >> iLog2) > 1)
        iLog2++;

    return iLog2;
}

#ifndef macintosh
#define log2 LOG2
#endif

//****************************************************************************
// Normalize a dynamically scaled unsigned int 
//****************************************************************************
INLINE void NormUInt( UInt* puiValue, Int* pcFracBits, const UInt uiTarget ){
    const UInt uiTarget2 = uiTarget>>1;
    register UInt uiV = *puiValue;
    register Int cFB = *pcFracBits;
    assert( uiV > 0 );    
    if (uiV == 0) return; // useful if asserts are disabled

    while ( uiV < uiTarget2 )
    {
        uiV <<= 2;        
        cFB += 2;
    }
    if ( uiV < uiTarget )
    {
        uiV <<= 1;        
        cFB += 1;
    }
    *puiValue = uiV;
    *pcFracBits = cFB;
}

//****************************************************************************
// Align a dynamically scaled int to a particular binary point position
//****************************************************************************
INLINE Int Align2FracBits( const Int iValue, const Int cFracBits, const Int cAlignFracBits )
{
    const Int iShift = cFracBits-cAlignFracBits;

    if (iShift < 0) {
        return (iValue << -iShift);
    } else if (iShift < 32) { 
        return (iValue >> iShift);
    } else {
        return 0;
    }
}


// V4 Compatibility Mode: This mode allows us to compare V5 encoder with V4 encoder
#ifdef V4V5_COMPARE_MODE
#define V4V5COMPARE_SNAPTOZERO(x)   if (fabs(x) <= 1.0e-15) {(x) = 0;}
#define ROUNDF_V4V5COMPARE(x)  ROUNDD(x)
typedef double V4V5COMPARE;
#else   // V4V5_COMPARE_MODE
#define V4V5COMPARE_SNAPTOZERO(x)
#define ROUNDF_V4V5COMPARE(x)  ROUNDF(x)
typedef float  V4V5COMPARE;
#endif  // V4V5_COMPARE_MODE

#ifdef INTEGER_ENCODER
typedef I32     FLOATORI32;
typedef U32     FLOATORU32;
typedef U16     FLOATORU16;
#define FLOATORU32_CONST(flop,fb)           ((U32)((flop)*(1 << (fb))))
#define FLOATORINT_TOFLOAT(x,fb)            ((Float)(x)/(Float)(1 << (fb)))
#define FLOATORINT_SELECTTOFLOAT(f,i,fb)    ((Float)(i)/(Float)(1 << (fb)))
#define FLOATORINT_ASSERT(x)                assert(x)
#define FLOATORINT_AB(a,b)                  (a)

// The following is used to allow non-integerized code to convert a FLOP
// result to a bit-discarded integer result
#define FLOATORU32_DISCARDBITSFROMFLT(x,fb) ((U32)((x)/(float)(1 << (fb))))
#define FLOATORU32_DISCARDBITSFROMU32(x,fb) ((U32)(x) >> (fb))
#define FLOATORU32_DISCARDBITSFROMI64(x,fb) ((I64)(x) >> (fb))
#define FLOATORU32_ADDFRACTBITS(i,fb)       ((i) << (fb))
#define FLOATORI32_DISCARDBITSFROMI32(x,fb) ((I32)(x) >> (fb))

#else   // INTEGER_ENCODER

typedef Float   FLOATORI32;
typedef Float   FLOATORU32;
typedef Float   FLOATORU16;
#define FLOATORU32_CONST(flop,fb)           (flop)
#define FLOATORINT_TOFLOAT(x,fb)            (x)
#define FLOATORINT_SELECTTOFLOAT(f,i,fb)    (f)
#define FLOATORINT_ASSERT(x)
#define FLOATORINT_AB(a,b)                  (b)

#define FLOATORU32_DISCARDBITSFROMFLT(x,fb) (x) // FLOP-to-FLOP, no conversion required
#define FLOATORU32_DISCARDBITSFROMU32(x,fb) ((Float)x)
#define FLOATORU32_DISCARDBITSFROMI64(x,fb) (x)
#define FLOATORU32_ADDFRACTBITS(i,fb)       (i) // FLOP, no fract bits required
#define FLOATORI32_DISCARDBITSFROMI32(x,fb) (x)
#endif  // INTEGER_ENCODER


// **************************************************************************
// Bring in platform-specific macros
// **************************************************************************
// Include them here because some of them use the global macros above
#include "wmaOS.h"
#if defined(WMA_TARGET_X86) || defined(WMA_TARGET_QNX_X86)

// Output target
#ifdef COMMONMACROS_OUTPUT_TARGET
#pragma COMPILER_MESSAGE("-----MACROS.H: Compiling for Intel x86 Target")
#endif  // COMMONMACROS_OUTPUT_TARGET

//#ifdef __QNX__
#include "../x86/macros.h"
//#else
//#include "..\x86\macros.h"
//#endif

//---------------------------------------------------------------------------
#elif defined(WMA_TARGET_MIPS)

// Output target
#ifdef BUILD_INTEGER
#ifdef COMMONMACROS_OUTPUT_TARGET
#pragma COMPILER_MESSAGE("-----MACROS.H: Compiling for MIPS integer Target")
#endif // COMMONMACROS_OUTPUT_TARGET
#else
#ifdef COMMONMACROS_OUTPUT_TARGET
#pragma COMPILER_MESSAGE("-----MACROS.H: Compiling for MIPS floating point  Target")
#endif // COMMONMACROS_OUTPUT_TARGET

#endif

#include "..\mips\macros_mips.h"

#elif defined(WMA_TARGET_SH3)

// Output target
#ifdef COMMONMACROS_OUTPUT_TARGET
#pragma COMPILER_MESSAGE("-----MACROS.H: Compiling for SH3 (Hitachi & HP WinCE) Target")
#endif // COMMONMACROS_OUTPUT_TARGET

#include "..\sh3\macros_sh3.h"

#elif defined(WMA_TARGET_SH4)

// Output target
#ifdef COMMONMACROS_OUTPUT_TARGET
#pragma COMPILER_MESSAGE("-----MACROS.H: Compiling for SH4 (Hitachi WinCE) Target")
#endif // COMMONMACROS_OUTPUT_TARGET

#ifndef HITACHI
static 
#endif
INLINE U32 ByteSwap(U32 i){ 
    U8 *p = (U8 *)&i;
    return (p[0]<<24)|(p[1]<<16)|(p[2]<<8)|p[3];
}

#include "..\sh4\macros_SH4.h"

//---------------------------------------------------------------------------
#else

// Output target
#ifdef COMMONMACROS_OUTPUT_TARGET
#pragma COMPILER_MESSAGE("-----MACROS.H: Compiling for ANSI-C Target")
#endif // COMMONMACROS_OUTPUT_TARGET

// Bring in platform-independent macros
#define MULT_HI_DWORD_DOWN(a,b) (I32)((((I64)(a))*((I64)(b)))>>30)
#define MULT_HI_DWORD(a,b) (I32)((((I64)(a))*((I64)(b)))>>32)

// Unsigned version of multiply
#define MULT_HI_UDWORD(a,b) (U32)((((U64)(a))*((U64)(b)))>>32)

static INLINE U32 ByteSwap(U32 i){ 
    U8 *p = (U8 *)&i;
    return (p[0]<<24)|(p[1]<<16)|(p[2]<<8)|p[3];
}

#endif // Platform-specific #ifdefs


// **************************************************************************
// Overridable Macros (optimized for some platforms, but not all)
// **************************************************************************
// The following can be overridden within a particular platform macro file
#ifndef PLATFORM_SPECIFIC_ROUND
#ifdef HITACHI
static I32 ROUNDF(float f) {
#else
static INLINE I32 ROUNDF(float f) {
#endif
    if (f < 0.0f)
        return (I32) (f - 0.5f);
    else
        return (I32) (f + 0.5f);
}

//---------------------------------------------------------------------------
#ifdef HITACHI
static I32 ROUNDD(double f) {
#else
static INLINE I32 ROUNDD(double f) {
#endif
    if (f < 0)
        return (I32) (f - 0.5);
    else
        return (I32) (f + 0.5);
}
#endif // PLATFORM_SPECIFIC_ROUND

//---------------------------------------------------------------------------
#ifndef PLATFORM_SPECIFIC_BITCOPY
//assuming bsrc is zeroed out
#ifdef HITACHI
static void bitCpy (const U8* pbSrc, Int iBitStartSrc, Int cBits, U8* pbDst)
#else
static INLINE void bitCpy (const U8* pbSrc, Int iBitStartSrc, Int cBits, U8* pbDst)
#endif
{
    const U8* pbSrcEnd;
    Int iShiftDown;
    U8 b2, b1;

    assert (pbSrc != NULL && pbDst != NULL);
    assert (iBitStartSrc < BITS_PER_DWORD && iBitStartSrc >= 0);
    assert (cBits >= 0);

    // Caller assumes we're copying DWORDs at a time (hangover from Intel)
    // Normalize pointers 
    pbSrc += iBitStartSrc / BITS_PER_BYTE;
    iBitStartSrc %= BITS_PER_BYTE;

    pbSrcEnd = pbSrc + (iBitStartSrc > 0) + 
                            (((cBits - iBitStartSrc) + 7) & ~7) / 8; //open
    iShiftDown = (BITS_PER_BYTE - iBitStartSrc);
    b1 = *pbSrc;
    while (pbSrc < pbSrcEnd) {
        pbSrc++;
        b2 = *pbSrc;
        *pbDst = (b1 << iBitStartSrc) | (b2 >> iShiftDown);
        b1 = b2;
        pbDst++;
    }
}
#endif // PLATFORM_SPECIFIC_BITCOPY

#ifndef PLATFORM_SPECIFIC_FNPTR
#define PLATFORM_SPECIFIC_FNPTR     //nothing for non-x86
#endif // PLATFORM_SPECIFIC_FNPTR


//**********************************************************************
// Support for FastFloat
//**********************************************************************

#if defined(BUILD_INTEGER) || defined(INTEGER_ENCODER)
    // FastFloat
    // FastFloat is a quick way of handling values that exceed I32 range without incurring
    // the expense of floating point emulation on integer only platforms.
    // real value = iFraction * pow( 2, -iFracBits )
    // In debugger, iFraction*1.0F/(1<<iFracBits) works if 0<=iFracBits<31

    // Normalize a FastFloat
#ifdef HITACHI  
#   pragma inline(Norm4FastFloat)
#else   
    INLINE
#endif
static void Norm4FastFloat( FastFloat* pfflt )
    {   // use the faster Norm4FastFloatU when you know the value is positive
        register UInt uiF = abs(pfflt->iFraction);
        register Int iFB = 0;
        if ( uiF == 0 )
        {
            pfflt->iFracBits = 0;
            return;
        }
        while ( uiF < 0x1FFFFFFF )
        {
            uiF <<= 2;
            iFB +=  2;
        }
        if ( uiF < 0x3FFFFFFF )
        {
            iFB +=  1;
        }
        pfflt->iFraction <<= iFB;
        pfflt->iFracBits += iFB;
    }


#ifdef HITACHI
#   pragma inline(Norm4FastFloatU)
#else   
    INLINE
#endif
static void Norm4FastFloatU( FastFloat* pfflt )
    {   // same as above when we know value is positive (which we often do)
        register UInt uiF = pfflt->iFraction;
        register Int iFB = 0;
        assert( uiF > 0 );
        while ( uiF < 0x1FFFFFFF )
        {
            uiF  <<= 2;
            iFB +=  2;
        }
        if ( uiF < 0x3FFFFFFF )
        {
            uiF  <<= 1;
            iFB +=  1;
        }
        pfflt->iFraction = uiF;
        pfflt->iFracBits += iFB;
    }


#ifdef HITACHI
    #pragma inline(ffltMultiply)
#else   
    INLINE
#endif  
static FastFloat ffltMultiply( FastFloat ffltA, FastFloat ffltB )
    {
        FastFloat ffltP;
        ffltP.iFraction = MULT_HI( ffltA.iFraction, ffltB.iFraction );
        ffltP.iFracBits = (ffltA.iFracBits + ffltB.iFracBits - 31);
        Norm4FastFloat( &ffltP );
        return ffltP;
    }
#   define FASTFLOAT_MULT(a,b) ffltMultiply((a),(b))


#ifdef HITACHI
    #pragma inline(FastFloatFromFloat)
#else   
    INLINE
#endif  
static FastFloat FastFloatFromFloat(Float flt) {
        FastFloat fflt;
        Float fltScale = (Float)(1<<(31-24));
        fflt.iFracBits = 24;
        while( flt < -fltScale || fltScale < flt )
        {
            flt /= 2;
            fflt.iFracBits -= 1;
            fltScale *= 2;
        }
        fflt.iFraction = (I32)(flt*(1<<fflt.iFracBits));
        Norm4FastFloat( &fflt );
        return fflt;
    }   


#ifdef HITACHI  
    #pragma inline(FloatFromFastFloat)
#else   
    INLINE
#endif
static Float FloatFromFastFloat( FastFloat fflt )
    {
        assert( 0<= fflt.iFracBits && fflt.iFracBits <= 50 );
        if ( fflt.iFracBits > 30 )
            return fflt.iFraction/(1048576.0F*(1<<(fflt.iFracBits-20)));
        else
            return fflt.iFraction/((Float)(1<<fflt.iFracBits));

    }
#   define FASTFLOAT_FROM_FLOAT(flt) FastFloatFromFloat(flt)
#   define FLOAT_FROM_FASTFLOAT(fflt) FloatFromFastFloat(fflt)
#   define DOUBLE_FROM_FASTFLOAT(fflt) ((double)fflt.iFraction/(1<<fflt.iFracBits))


#ifdef HITACHI
    #pragma inline(FastFloatFromU64)
#else   
    INLINE
#endif  
static FastFloat FastFloatFromU64(U64 u64, Int cExp) 
    {
        FastFloat fflt;
        U32 uiMSF = (U32)(u64>>32);
        Int iExp = 0;
        if ( uiMSF==0 ) {
            iExp = 32;
            uiMSF = (U32)u64;
        }
        if (uiMSF==0) {
            fflt.iFracBits = 0;
            fflt.iFraction = 0;
            return fflt;
        }
        // normalize the most significant fractional part
        while( (uiMSF & 0xF0000000)==0 ) {
            iExp += 3;
            uiMSF <<= 3;
        }
        while( (uiMSF & 0xC0000000)==0 ) {
            iExp++;
            uiMSF <<= 1;
        }
        // number of fractional bits
        fflt.iFracBits = iExp+cExp-32;
#if defined(PLATFORM_OPTIMIZE_MINIMIZE_BRANCHING)
        fflt.iFraction = (U32)((u64<<iExp)>>32);
#else
        fflt.iFraction = (iExp>32) ? (U32)(u64<<(iExp-32)) : (U32)(u64>>(32-iExp));
#endif
        return fflt;
    }   
#define FASTFLOAT_FROM_U64(u64,exp) FastFloatFromU64(u64,exp)


    typedef FastFloat QuantStepType;
#define DOUBLE_FROM_QUANTSTEPTYPE(qst) DOUBLE_FROM_FASTFLOAT(qst)
#define  FLOAT_FROM_QUANTSTEPTYPE(qst) FLOAT_FROM_FASTFLOAT(qst)
#define FASTFLOAT_FROM_QUANTSTEPTYPE(qst) (qst)

#else   // must be BUILD_INT_FLOAT

#   define FASTFLOAT_FROM_FLOAT(flt) (flt)
#   define FLOAT_FROM_FASTFLOAT(fflt) (fflt)
#   define FASTFLOAT_MULT(a,b) ((a)*(b))
#   define DOUBLE_FROM_FASTFLOAT(fflt) ((double)fflt)

#   define FASTFLOAT_FROM_U64(u64,exp) (((Float)(u64))/(((U64)1)<<exp))

    typedef Float QuantStepType;
#define DOUBLE_FROM_QUANTSTEPTYPE(qst) ((Double)(qst))
#define  FLOAT_FROM_QUANTSTEPTYPE(qst) (qst)
#define FASTFLOAT_FROM_QUANTSTEPTYPE(qst) ((FastFloat)(qst))


#endif


// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
// Define Macros to switch auReconMono and auSaveHistoryMono between Integer and Float

#if defined(BUILD_INTEGER) || defined(INTEGER_ENCODER)

#define ROUND_SATURATE_STORE(piDst,cf,mn,mx,iTmp)      \
    *piDst = (I16) checkRange (cf, mn, mx);            \
    iTmp = cf;

#else  // BUILD_INT_FLOAT

#ifdef PLATFORM_SPECIFIC_ROUND
// Combined Round and Saturate is faster in floating point
// But if the platform has special Round function, we must use it.
#define ROUND_AND_CHECK_RANGE(it,flt,mn,mx)            \
    it = (I32)ROUNDF_V4V5COMPARE(flt);                 \
    it = checkRange(it,mn,mx);
#else
// Combined Round and Saturate is faster in floating point
#define ROUND_AND_CHECK_RANGE(it,flt,mn,mx)            \
    if ( flt < (V4V5COMPARE)0.0 ) {                    \
        it = (I32)( flt - ((V4V5COMPARE)0.05) );       \
        if ( it < mn ) it = mn;                        \
    } else {                                           \
        it = (I32)( flt + ((V4V5COMPARE)0.05) );       \
        if ( it > mx ) it = mx;                        \
    }
#endif

#define ROUND_SATURATE_STORE(piDst,cf,mn,mx,iTmp)      \
    ROUND_AND_CHECK_RANGE( iTmp, cf, mn, mx );         \
    *piDst = (I16)iTmp;
        
#endif // Both BUILD_INTEGER and BUILD_INT_FLOAT

#if defined (SMOOTH_NMR) && !defined (PEAQ_MASK)
// We must always use PEAQ_MASK for SMOOTH_NMR to function. However, PEAQ_MASK can be used with older rate control as well.
#define PEAQ_MASK
#endif

#ifdef _XBOX
#define XFILE void
#define STDOUT (void *)
extern XFILE * _XFOPEN(char *filename, char *mode);
extern int  _XFSEEK(XFILE *strmnum, long offset, int origin);
extern int  _XFWRITE(const void *buffer, int size, int count, XFILE *strmnum);
extern long  _XFTELL(XFILE *strmnum);
extern int  _XFCLOSE(XFILE *strmnum);
extern int  _XFFLUSH();
extern int  _XFPRINTF(XFILE *strmnum, const char *format, ...);
#define FOPEN _XFOPEN
#define FSEEK _XFSEEK
#define FTELL _XFTELL
#define FCLOSE _XFCLOSE
#define FWRITE _XFWRITE
#define FFLUSH _XFFLUSH
#define FPRINTF _XFPRINTF
#else
#define XFILE FILE
#define STDOUT stdout
#define FOPEN fopen
#define FSEEK fseek
#define FTELL ftell
#define FCLOSE fclose
#define FWRITE fwrite
#define FFLUSH fflush
#define FPRINTF fprintf
#endif
#endif  // __COMMON_MACROS_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\wmalib\common\msaudio.h ===
/*************************************************************************

Copyright (C) Microsoft Corporation, 1996 - 1999

Module Name:

    MsAudio.h

Abstract:

    Implementation of public member functions for CAudioObject.

Author:

    Wei-ge Chen (wchen) 11-March-1998

Revision History:


*************************************************************************/


// Compile Time Flags normally defined in project seetings
// these vary from specific project to project
// BUILD_INTEGER - build integer version
// BUILD_INT_FLOAT - build float version of integer tree = !BUILD_INTEGER
// ENCODER - build encoder
// DECODER - build decoder = !ENCODER
// ENABLE_ALL_ENCOPT - build support for all encoder options (otherwise just HighRate)
// ENABLE_LPC - build LPC spectrogram weighting for LowRate configurations (only defined if ENABLE_ALL_ENCOPT)
// ENABLE_EQUALIZER - build support for equalizer
// Known Useful Combinations
//   ENCODER && !BUILD_INTEGER &&  ENABLE_ALL_ENCOPT &&  ENABLE_LPC	= Normal Encoder
//   ENCODER && INTEGER_ENCODER&&  ENABLE_ALL_ENCOPT &&  ENABLE_LPC	= Partially Integerized Encoder
//   DECODER &&  BUILD_INTEGER &&  ENABLE_ALL_ENCOPT &&  ENABLE_LPC	= Normal Integer Do-It-All Decoder
//   DECODER &&  BUILD_INTEGER &&  ENABLE_ALL_ENCOPT && !ENABLE_LPC	= Normal Integer HighRate & MidRate Decoder
//   DECODER &&  BUILD_INTEGER && !ENABLE_ALL_ENCOPT && !ENABLE_LPC	= Normal Integer HighRate Only Decoder
//   DECODER && !BUILD_INTEGER &&  ENABLE_ALL_ENCOPT &&  ENABLE_LPC	= IntFloat Do-It-All Decoder
//   DECODER && !BUILD_INTEGER &&  ENABLE_ALL_ENCOPT && !ENABLE_LPC	= IntFloat HighRate & MidRate Decoder
//   DECODER && !BUILD_INTEGER && !ENABLE_ALL_ENCOPT && !ENABLE_LPC	= IntFloat HighRate Only Decoder
#ifndef __MSAUDIO_H_
#define __MSAUDIO_H_

#define  MaxSamplesPerPacket MaxSamplesPerPacket_XDS
#define  msaudioGetSamplePerFrame msaudioGetSamplePerFrame_XDS
#define  auNew auNew_XDS
#define  auDelete auDelete_XDS
#define  auInit auInit_XDS
#define  auPreGetPCM auPreGetPCM_XDS
#define  auGetPCM auGetPCM_XDS
#define  auReconstruct auReconstruct_XDS
#define  auAdaptToSubFrameConfig auAdaptToSubFrameConfig_XDS
#define  prvAdaptTrigToSubframeConfig prvAdaptTrigToSubframeConfig_XDS
#define  prvAdaptTrigToSubframeConfig_INT prvAdaptTrigToSubframeConfig_INT_XDS
#define  auPowerToRMS auPowerToRMS_XDS
#define  auUpdateMaxEsc auUpdateMaxEsc_XDS
#define  auDctIV auDctIV_XDS
#define  auResampleWeightFactorLPC auResampleWeightFactorLPC_XDS
#define  auLsp2lpc auLsp2lpc_XDS
#define  auResampleWeightFactorBark auResampleWeightFactorBark_XDS
#define  prvAllocate prvAllocate_XDS
#define  prvSetBarkIndex prvSetBarkIndex_XDS
#define  prvInverseQuantizeHighRate prvInverseQuantizeHighRate_XDS
#define  prvInverseTransformMonoauReconMono prvInverseTransformMonoauReconMono_XDS
#define  auDctIV_KNIprvFFT4DCT_INTEL auDctIV_KNIprvFFT4DCT_INTEL_XDS
#define  auInitIntelFFT auInitIntelFFT_XDS
#define  auFreeIntelFFT auFreeIntelFFT_XDS
#define  prvInvFftComplexConjugate_INTEL prvInvFftComplexConjugate_INTEL_XDS
#define  auReconstruct_X86 auReconstruct_X86_XDS
#define  auReconMono_X86 auReconMono_X86_XDS
#define  auReconStereo_MMX auReconStereo_MMX_XDS
#define  auReconStereo_SIMDFP auReconStereo_SIMDFP_XDS
#define  auReconstruct_MMX auReconstruct_MMX_XDS
#define  auReconMono_MMX auReconMono_MMX_XDS
#define  prvInverseTransformMono_MMX prvInverseTransformMono_MMX_XDS
#define  prvFFT_Int prvFFT_Int_XDS
#define  prvFFT4DCT prvFFT4DCT_XDS
#define  prvInvFftComplexConjugate prvInvFftComplexConjugate_XDS
#define  prvInitNoiseSub prvInitNoiseSub_XDS
#define  prvInverseQuantizeMidRate prvInverseQuantizeMidRate_XDS
#define  prvInverseQuantizeLowRate prvInverseQuantizeLowRate_XDS
#define  prvInverseQuantizeMidRateSkipNoise prvInverseQuantizeMidRateSkipNoise_XDS
#define  prvInverseQuantizeTRANSCODE prvInverseQuantizeTRANSCODE_XDS
#define  prvLpcToSpectrumprvInitInverseQuadRootTable prvLpcToSpectrumprvInitInverseQuadRootTable_XDS
#define  prvInterpolateInit prvInterpolateInit_XDS
#define  auLowPass auLowPass_XDS
#define  prvInterpolate prvInterpolate_XDS
#define  qstCalcQuantStep qstCalcQuantStep_XDS
#define  prvWeightedQuantization prvWeightedQuantization_XDS
#define  SetActualPower SetActualPower_XDS
#define  SetActualPowerHighRate SetActualPowerHighRate_XDS
#define  prvWmaShowFrames prvWmaShowFrames_XDS
#define  HeapDebugCheck HeapDebugCheck_XDS
#define  mallocAligned mallocAligned_XDS
#define  freeAligned freeAligned_XDS
#define  auMallocGetCount auMallocGetCount_XDS
#define  auMallocSetState auMallocSetState_XDS
#define  auMalloc auMalloc_XDS
#define  auFree auFree_XDS
#define  auReconMono auReconMono_XDS
#define  auReconCoefficentsHighRate auReconCoefficentsHighRate_XDS
#define  prvInitDiscardSilence prvInitDiscardSilence_XDS
#define  prvDiscardSilence prvDiscardSilence_XDS
#define  g_SupportMMX g_SupportMMX_XDS
#define  g_SupportKNI g_SupportKNI_XDS
#define  g_SupportSIMD_FP g_SupportSIMD_FP_XDS
#define  g_SupportCMOV g_SupportCMOV_XDS
#define  auSaveHistoryMono auSaveHistoryMono_XDS
#define  prvGetBandWeightMidRate prvGetBandWeightMidRate_XDS
#define  cfltInverseRand2Float cfltInverseRand2Float_XDS
#define  prvPq2lpc prvPq2lpc_XDS
#define  prvConvolve_odd prvConvolve_odd_XDS
#define  prvConvolve prvConvolve_XDS
#define  prvLsp2pq prvLsp2pq_XDS
#define  prvInitInverseQuadRootTable prvInitInverseQuadRootTable_XDS
#define  prvDoLpc4 prvDoLpc4_XDS
#define  prvLpcJLoopBottom prvLpcJLoopBottom_XDS
#define  prvLpcToSpectrum prvLpcToSpectrum_XDS
#define  g_rgiLsfReconLevel g_rgiLsfReconLevel_XDS
#define  lpc_trig2048 lpc_trig2048_XDS
#define  CLSID_CAsfHeaderObjectV0 CLSID_CAsfHeaderObjectV0_XDS
#define  CLSID_AsfXAcmAudioErrorMaskingStrategy CLSID_AsfXAcmAudioErrorMaskingStrategy_XDS
#define  CLSID_AsfXSignatureAudioErrorMaskingStrategy CLSID_AsfXSignatureAudioErrorMaskingStrategy_XDS
#define  CLSID_AsfXStreamTypeAcmAudio CLSID_AsfXStreamTypeAcmAudio_XDS
#define  CLSID_CAsfMarkerObjectV0 CLSID_CAsfMarkerObjectV0_XDS
#define  CLSID_CAsfLicenseStoreObject CLSID_CAsfLicenseStoreObject_XDS
#define  CLSID_CAsfExtendedContentDescObject CLSID_CAsfExtendedContentDescObject_XDS
#define  CLSID_CAsfContentDescriptionObjectV0 CLSID_CAsfContentDescriptionObjectV0_XDS
#define  CLSID_CAsfContentEncryptionObject CLSID_CAsfContentEncryptionObject_XDS
#define  CLSID_CAsfStreamPropertiesObjectV2 CLSID_CAsfStreamPropertiesObjectV2_XDS
#define  CLSID_CAsfStreamPropertiesObjectV1 CLSID_CAsfStreamPropertiesObjectV1_XDS
#define  CLSID_CAsfPropertiesObjectV2 CLSID_CAsfPropertiesObjectV2_XDS
#define  CLSID_CAsfDataObjectV0 CLSID_CAsfDataObjectV0_XDS
#define  CLSID_AsfXNullErrorMaskingStrategy CLSID_AsfXNullErrorMaskingStrategy_XDS


#ifdef __cplusplus
extern "C" {  // only need to export C interface if
              // used by C++ source code
#endif

#include <stdlib.h>

#include "macros.h"
#include "DecTables.h"


#define MAX_SUBFRAMES       16

// Forward data type decl
typedef struct _CoefStream CoefStream;

#ifdef TRANSCODER
#define OLD_QUANT_LOOP
#define TRANSCODER_ONLY(x)  (x)
#define TRANSCODER_AB(x,y)  (x)
#else   // TRANSCODER
#define TRANSCODER_ONLY(x)
#define TRANSCODER_AB(x,y)  (y)
#endif  // TRANSCODER

typedef enum {TT_NONE = 0, TT_SIMPLE} TRANSCODETYPE;
typedef enum {STEREO_LEFTRIGHT = 0, STEREO_SUMDIFF} StereoMode;
typedef enum {CODEC_NULL, CODEC_STEADY, CODEC_DONE, CODEC_BEGIN, CODEC_LAST, CODEC_ONHOLD} Status;
typedef enum {FMU_DONE = 0, FMU_QUANTIZE, FMU_PROCESS} FMU_STATUS;
typedef struct PerChannelInfo 
{
//whenever the memory gest moved to buckets, update is needed
    // Decoder and Global Members
    I16*           m_rgiCoefQ;						//quantized coef
    Int*           m_rgiMaskQ;                      //quantized maskq ((could be I16))
    U8*            m_rgbBandNotCoded;               //band not coded
	FastFloat*	   m_rgffltSqrtBWRatio;				//MidRate/LowRate for Bands not coded
	Int*		   m_rgiNoisePower;
    const U16*     m_rgiHuffDecTbl;                 //decoder only
    const U16*     m_rgiRunEntry;                   //decoder only        
    const U16*     m_rgiLevelEntry;                 //decoder only
    Int            m_cSubbandActual;
    Int            m_iPower;                        //channel power
    Int            m_iActualPower;                  // Power as suggested by CoefQ/CoefRecon
    UInt*          m_rguiWeightFactor;				//weighting factor
    Int*           m_rgiCoefRecon;                  //reconstructed coef
	Int			   m_iMaxMaskQ;	

#ifdef TRANSCODER
    // Transcoder members
    CoefStream    *m_pcstrmCoefSaved;
    CoefStream    *m_pcstrmPower;
    CoefStream    *m_pcstrmMaskQ;
    Int            m_rgiLastMaskQUpdate[NUM_BARK_BAND];
    Int            m_iLastMaskQUpdBarkBands;
    I32            m_rgiThinningRands[2048];
    I32            m_rgiRands[2048];
#endif  // TRANSCODER

#define CURRGETPCM_INVALID  0x7FFF
    I16            m_iCurrGetPCM_SubFrame;          // reconstruction index
    Int*           m_rgiCoefReconCurr;  //current position in m_rgiCoefRecon
    I16*           m_piPrevOutput;      //prev history per channel
    I16*           m_piPrevOutputSign;  //sign of m_piPrevOutput
    I16*           m_piPrevOutputCurr;  //current position in m_piPrevOutput

	// These next five must be kept in this order for SH4 optimizations
    Int            m_iSin;    //floating value = (float)iSin/0x3FFFFFFF
    Int            m_iCos;    //floating value = (float)iCos/0x3FFFFFFF
	Int            m_iSin1;	 //previous sin value for recurrsion
	Int            m_iCos1;	 //previous cos value for recurrsion
	Int            m_iStep;	 // 2*sin(step increment)

    // Float-only members
#ifndef BUILD_INTEGER
#endif
    // The following is NOT YET INTEGERIZED but after it is,
    // it should be moved into the #ifndef BUILD_INTEGER above
    Float*         m_rgfltCoefRecon;                //reconstructed coef soon to be removed
    Float*         m_rgfltBandWeight;    

#ifdef BUILD_INTEGER
#else
#endif
    // The following are NOT YET INTEGERIZED but after they are,
    // they should be moved into the #ifndef BUILD_INTEGER above
    Float*         m_rgfltWeightFactor;
    WeightType     m_wtMaxWeight;
  

#ifdef ENCODER
#if !defined (DISABLE_PREPROCESSING)
    // For pre-processing
    I16*             m_rgnPPBuffer;            // Temporary buffer   
#endif 
    
    Float*           m_rgfltMask;
#if defined (PEAQ_MASK)
    // The excitation values for mask computation etc.
    Float*           m_rgfltBarkNmrWts;        // somewhat based on the excitation pattern
    Float*           m_rgfltBarkExc;           // enough for all subframes
    Bool*            m_rgfNoisyBark;           // barks with any kind of noise substition
    Float*           m_rgfltBarkNmr;           // NMR measured, per bark basis
    Float*           m_rgfltBarkExcPrev;       // just pointer for v8
    Float*           m_rgfltBarkExcCurr;       // just pointer for v8
    Float*           m_rgfltBarkExcRef;        // just pointer for v8
    
    Float*           m_rgfltBarkExcRecon;      // enough for all subframes
    Float*           m_rgfltBarkExcReconPrev;  // just pointer for v8
    Float*           m_rgfltBarkExcReconCurr;  // just pointer for v8
    
    Float*           m_rgfltTargetSpectrum;    // for generating excitation=>mask=>lpc parameters.

#endif // PEAQ_MASK
	
#if defined (SMOOTH_NMR)     
    // Noise detection, suppression etc
    Float*           m_rgfltBandEnergy;        // to determine stationarity
    Float*           m_rgfltNoiseSpectrum;     // to perform noise filtering
    Float*           m_rgfltSpectrumCurr;      // to perform noise filtering
    
    Bool*            m_rgfMaskNeededForBark;   // for header squeezing
    Float*           m_rgfltBarkEnergyOrig;    // in computing nrmr
#endif // SMOOTH_NMR

    // Encoder-only members
    FLOATORI32*     m_pfltInputW;                    //weighted data: encoder only

    Float*          m_rgfltCoefOrig;                 // original coef: encoder only
    Float*          m_rgfltCoef;                     //original coef: encoder only, weighted
    
#if defined (PEAQ_MASK)
    Float*          m_rgfltCoefLR;                   // original coef, straight through (without stereo matrixing)
    Float*          m_rgfltCoefReconLR;              // reconstructed coef, straight through (without stereo matrixing)
#endif // PEAQ_MASK
    
    I32*            m_rgiCoef;                       // Integer version of m_rgfltCoef, not really used by anybody now
    U32             m_iCoefMagnitude;                // Magnitude (OR) of all coefs in m_rgiCoef; integer encoder
    Float*          m_rgfltWeightFactorPerBark;
    U8*             m_rgbLsfQ;                       //quantized lsf; encoder only
    I16*            m_rgiCoefQRLC;                   //Run length coded quantized coef
    I16*            m_rgiCoefQRLC_DIFF;              //Previous QRLC to be used for requant purposes
    U8*             m_rgbIsTone;                     //encoder only
    const U32*      m_rgiHffmanTblRunLevel;          //could be different for each stereo channel
    const I16*      m_rgiRunLevelVLCAtLevel;
    Int             m_iMaxLevelInRunLevelVLC;
    Int             m_cBitsUsed;                     //encoder only   
    Bool            m_fAnyNonZeroCoefQ;              //is coefQ all zero?
    Int             m_iFramePowerPrev;
    Int             m_iFramePower;
    WMARESULT       m_hr;                            // return code for multi-threaded operations
    FMU_STATUS      m_fNeedFullMaskUpdate;  // Scrunch bug #32: v4 decoder can resample
                                            // uninitialized weight factors
    float           m_fltLastFreq[LPCORDER];

    // transient detection (encoder only)
    I16           *m_piInputCurr;   //other preprocessing as well
    I16           *m_piInputNext;   //other preprocessing as well

    I16           *m_rgiTransient;
    FLOATORU32    *m_rgfltTransientStrength;
    FLOATORU32    *m_rgfltSlicePower;
    FLOATORU32    m_fltPowerPrevL;
    FLOATORU32    m_fltPowerPrevM;
    FLOATORU32    m_fltPowerPrevH;

    I16           *m_rgiTransientSrcLow;
    Int           m_iTransientSrcLowCurr;
    FLOATORI32    *m_rgfltTransientDstLow;
    Int           m_iTransientDstLowCurr;

    I16           *m_rgiTransientSrcMed;
    Int           m_iTransientSrcMedCurr;
    FLOATORI32    *m_rgfltTransientDstMed;
    Int           m_iTransientDstMedCurr;

    I16           *m_rgiTransientSrcHi;
    Int           m_iTransientSrcHiCurr;
    FLOATORI32    *m_rgfltTransientDstHi;
    Int           m_iTransientDstHiCurr;

#if defined (SMOOTH_NMR) && !defined(INTEGER_ENCODER) && !defined(BUILD_INTEGER)
    Float        *m_rgfltDitherNoise;
    Float         m_fltAchievedNmr;
#endif  // defined (SMOOTH_NMR) && !defined(INTEGER_ENCODER) && !defined(BUILD_INTEGER)
    
#endif // ENCODER

} PerChannelInfo;

typedef struct SubFrameConfigInfo
{ 
    Int m_cSubFrame;
    Int m_rgiSubFrameSize [MAX_SUBFRAMES];
    Int m_rgiSubFrameStart [MAX_SUBFRAMES];
    Int m_iFirstTransientSubFrm;        //for enc only
    Int m_iLastTransientSubFrm;         //for enc only
    Int m_cMaskUpdate;                  //for enc only
    Int m_rgfMaskUpdate [MAX_SUBFRAMES];
} SubFrameConfigInfo;


typedef enum {LPC_MODE=0,BARK_MODE} WeightMode;

typedef struct CAudioObject
{
    //Step Size
    QuantStepType  m_qstQuantStep;
#if 0
	// no longer needed
    UInt    m_rgiQuantStepFract[QUANTSTEP_DENOMINATOR - 1]; // Exclude numerator of 0
#endif

    // packetization (has nothing to do with the rest)
    Int m_iPacketCurr;
    Int m_cBitPackedFrameSize;
    Int m_cBitPacketHeader;
    Int m_cdwPacketHeader;
    Int m_cBitPacketHeaderFractionDw;
    Int m_cBitPacketLength;

    //utility vars for entropy decoding for high rate only
    Int m_cRunOfZeros;
    I16 m_iLevel; 
    Int m_iSign;
    Int m_iHighCutOffCurr;
    Int m_iNextBarkIndex;

    Bool  m_fNoiseSub; 
    Float m_fltBitsPerSample;
    Float m_fltWeightedBitsPerSample;

    Int m_iMaxEscSize;          // in bits
    Int m_iMaxEscLevel;         // (1<<m_iMaxEscSize)

    
    Int     m_iVersion;
    Status	m_codecStatus;          //current status of the codec
    Bool    m_fSeekAdjustment;
    Bool    m_fPacketLossAdj;       //skip some samples when packetloss
    Int		m_iSamplingRate;        //audio sampling rate in Hz
    U16		m_cChannel;
    U32     m_nBytePerSample;
#ifdef WMA_V9
    U16     m_nValidBitsPerSample;
    U32     m_nChannelMask;
#endif 
    Int		m_cSubband;				//no. of subbands in the MLT transform

    Bool    m_fAllowSuperFrame;
    Bool    m_fAllowSubFrame;
    Bool    m_fV5Lpc;
//!! reset
    Int     m_iCurrSubFrame;        //which subframe we are doing
    I16     m_iCurrReconCoef;       //which coef we are doing
    Bool    m_fHeaderReset;
//!! dupe? needed for inv-quantization
    Int     m_iSubFrameSizeWithUpdate;
    Int     m_iMaxSubFrameDiv;      //maximum no. division into subwindows
    Int     m_cMinSubFrameSample;   //min size of subframes in current frame; many change from frame to frame
    Int     m_cMinSubFrameSampleHalf;   //min size of subframes in current frame; many change from frame to frame
    Int     m_cMinSubFrameSampleQuad;   //min size of subframes in current frame; many change from frame to frame
    Int     m_cPossibleWinSize; 
    Int     m_iIncr;                //log2(longest winsize / curr winsize)
    Int     m_cSubFrameSample;      //for long win, same as m_cFrameSample
    Int     m_cSubFrameSampleHalf;
    Int     m_cSubFrameSampleQuad;
//!! yes!
    SubFrameConfigInfo  m_subfrmconfigPrev;
    SubFrameConfigInfo  m_subfrmconfigCurr;
    SubFrameConfigInfo  m_subfrmconfigNext;

    //should be reset every subfrm in next version
    Int		m_cBitsSubbandMax;	    //no. of bits for m_cSubband; 
    Int		m_cFrameSample;         //no. of input/output samples = 2 * cSubband
    Int		m_cFrameSampleHalf;     //no. of input/output samples = cSubband
    Int		m_cFrameSampleQuad;     //no. of input/output samples = cSubband / 2

    Int		m_cLowCutOff;           //How many coeffs to zero at the low end of spectrum
    Int		m_cHighCutOff;			//How many coeffs to zero at the high end of spectrum
    Int		m_cLowCutOffLong;
    Int		m_cHighCutOffLong;		

    Int		m_iWeightingMode;
//!! yes!
    StereoMode  m_stereoMode;       // left-right or sum-difference coding 
    Int     m_iEntropyMode;         //entropy coding mode
    Float	m_fltDitherLevel;	    //=.12; Relative intensity of Roberts' pseudo-random noise quantization
    Int		m_iQuantStepSize;
    Float	m_fltFlatenFactor;	    //Excess spectral noise power factor. Typical values are
    							    //in the range 0.4 -- 0.9; best choice is 0.5
    Float   m_fltDctScale;
    Int		m_cValidBarkBand;       //valid bark band in range; some are out of range in the subband decompositio
    const Int*	m_rgiBarkIndex;     //corresponding coef index for each valid bark


#if defined(BUILD_INTEGER) || defined(INTEGER_ENCODER)
	I32     m_iSinRampUpStart;
	I32     m_iCosRampUpStart;
	I32     m_iSinRampUpPrior;
	I32     m_iCosRampUpPrior;
	I32     m_iSinRampUpStep;
	I32     m_iSinRampDownStart;
	I32     m_iCosRampDownStart;
	I32     m_iSinRampDownPrior;
	I32     m_iCosRampDownPrior;
	I32     m_iSinRampDownStep;
	I32     m_iSinInit[4];			// still need these for encoder (MsAudioEnc) until its recurrsion is fixed
	I32     m_iCosInit[4];			// still need these for encoder (MsAudioEnc) until its recurrsion is fixed
#endif

#if !defined(BUILD_INTEGER) || defined(INTEGER_ENCODER)
	V4V5COMPARE    m_fltSinRampUpStart;
	V4V5COMPARE    m_fltCosRampUpStart;
	V4V5COMPARE    m_fltSinRampUpPrior;
	V4V5COMPARE    m_fltCosRampUpPrior;
	V4V5COMPARE    m_fltSinRampUpStep;
	// These next five must be kept in this order for SH4 optimizations
	V4V5COMPARE    m_fltSinRampDownStart;
	V4V5COMPARE    m_fltCosRampDownStart;
	V4V5COMPARE    m_fltSinRampDownPrior;
	V4V5COMPARE    m_fltCosRampDownPrior;
	V4V5COMPARE    m_fltSinRampDownStep;
#endif

    Int     m_iSizePrev;
    Int     m_iSizeCurr;
    Int     m_iSizeNext;

    Int     m_iCoefRecurQ1;
    Int     m_iCoefRecurQ2;
    Int     m_iCoefRecurQ3;
    Int     m_iCoefRecurQ4;

    I16*	m_rgiCoefQ;             // just a pointer

    //random accessed memory
    //overall
    own PerChannelInfo* m_rgpcinfo;
    //transform
	own Int*	m_rgiCoefReconOrig;
    //weighting
//!!yes? invQ needs it
    own Int*	m_rgiMaskQ;
    own Int*	m_rgcValidBarkBand;
    own Int*	m_rgiBarkIndexOrig;  

    //output
//!!yes? invQ needs it
    own I16*	m_piPrevOutput;        // previous encoded output; bottom half += top half of Curr; then gone
//!!yes? invQ needs it
    I32         m_iDiscardSilence;

#ifdef TRANSCODER
    // Transcoder member variables
    TRANSCODETYPE   m_ttTranscodeType;
    CoefStream     *m_pcstrmSubFrameSizes;
    CoefStream     *m_pcstrmStereoMode;
    CoefStream     *m_pcstrmMaskUpdate;
    CoefStream     *m_pcstrmBitAllocs;
    CoefStream     *m_pcstrmQSteps;
    CoefStream     *m_pcstrmSubFrmConfig;
    CoefStream     *m_pcstrmFrameBitAlloc;
    Int             m_rgfOrigMaskUpdate[MAX_SUBFRAMES];
#endif  // TRANSCODER

#ifdef ENABLE_ALL_ENCOPT
    Float   m_fltFirstNoiseFreq;
    Int		m_iFirstNoiseBand;
    Int     m_iFirstNoiseIndex;
    Int     m_iNoisePeakIgnoreBand; // Num of coefficients to ignore when detecting peaks during noise substitution

    //only used for NoiseSub mode
    own Int*        m_rgiFirstNoiseBand;
//!!yes
    own U8*         m_rgbBandNotCoded;
	own FastFloat*	m_rgffltSqrtBWRatio;
//!!yes
    own Int*        m_rgiNoisePower;
//!!for invQ
    own Float*      m_rgfltBandWeight;

#if defined(_DEBUG) && defined(LPC_COMPARE)
    Float* m_rgfltLpsSpecCos [LPCORDER];
    Float* m_rgfltLpsSpecSin [LPCORDER];
#endif  // _DEBUG
#else   // ENABLE_ALL_ENCOPT
#endif  // ENABLE_ALL_ENCOPT

    Float*  m_rgfltWeightFactor; 
    UInt*	m_rguiWeightFactor;   //share with m_rgiMaskQ when bark

    U32 m_iFrameNumber; // frame counter to the common code

#if defined(INTERPOLATED_DOWNSAMPLE)
    Bool    m_fLowPass;             // Specify independently of downsampling
    Bool    m_fDownsample;          // Eg, Downsample 32kHz output to 22kHz for some devices
    Int     m_iInterpolSrcBlkSize;  // Size of 1 indivisible source block
    Int     m_iInterpolDstBlkSize;  // Size of 1 indivisible destination block
    Int     m_iInterpolIncr;        // Pointer increment
    Int     m_iInterpolCarry;       // Pointer increment "carry", +1 from time to time
    I32     m_iInterpolWeightIncr;  // FixedPt increment to interpolation weight
    Int     m_iInterpolAddInterval; // Add an extra sample at this interval of output samples
    Int     m_iInterpolNextAdd;     // Countdown to extra sample
#endif  // defined(INTERPOLATED_DOWNSAMPLE)

#if defined(HALF_TRANSFORM) || defined(PAD2X_TRANSFORM)
    Bool    m_fHalfTransform;
    Bool    m_fUpsample;
    Bool    m_fPad2XTransform;
	I16		m_iPriorSample[2];		// warning: maximum number of channels is currently 2

    // the following values are adjusted to reflect HalfTransform or PAd2XTransform
    // They are used for the DCT and for Reconstruction.
    Int		m_cSubbandAdjusted;
    Int     m_cFrameSampleAdjusted; 
    Int     m_cFrameSampleHalfAdjusted;
    Int     m_cSubFrameSampleAdjusted;
    Int     m_cSubFrameSampleHalfAdjusted;
    Int     m_cSubFrameSampleQuadAdjusted;
    Int		m_cHighCutOffAdjusted;
    // m_iCoefRecurQ1..4 and Trig values only exist in their adjusted states
#else   // defined(HALF_TRANSFORM) || defined(PAD2X_TRANSFORM)
    // Without these features, no need for adjusted values, 
    // so make the code use the regular values
#   define  m_cSubbandAdjusted            m_cSubband
#   define  m_cFrameSampleAdjusted        m_cFrameSample
#   define  m_cFrameSampleHalfAdjusted    m_cFrameSampleHalf
#   define  m_cSubFrameSampleAdjusted     m_cSubFrameSample
#   define  m_cSubFrameSampleHalfAdjusted m_cSubFrameSampleHalf
#   define  m_cSubFrameSampleQuadAdjusted m_cSubFrameSampleQuad
#   define	m_cHighCutOffAdjusted         m_cHighCutOff
#endif  // defined(HALF_TRANSFORM) || defined(PAD2X_TRANSFORM)


    // Function Pointers
    WMARESULT (*aupfnInverseQuantize) (struct CAudioObject* pau,
        PerChannelInfo* ppcinfo, Int* rgiWeightFactor);
    WMARESULT (*prvpfnInverseTransformMono) (struct CAudioObject* pau,
        PerChannelInfo* ppcinfo, I16* piOutput, I16* piPrevOutput,
        I16* piPrevOutputSign, Bool fForceTransformAll);
    WMARESULT (*aupfnGetNextRun) (Void* paudec, PerChannelInfo* ppcinfo, Int *piBitCnt);

    WMARESULT (*aupfnReconstruct) (struct CAudioObject* pau, I16* piOutput, I16* pcSampleGet, Bool fForceTransformAll);

    WMARESULT (*aupfnDctIV) (struct CAudioObject* pau, CoefType* rgiCoef, Float fltAfterScaleFactor, U32 *piMagnitude);
    void (*aupfnFFT) (CoefType data[], Int nLog2np);

#if !defined(BUILD_INTEGER) && !defined(UNDER_CE) && defined(WMA_TARGET_X86)
    Bool    m_fIntelFFT;    // Intel FFT needs setup/takedown, so we need to know this
#endif  // !defined(BUILD_INTEGER) && !defined(UNDER_CE) && defined(WMA_TARGET_X86)

	tRandState m_tRandState;

#ifdef USE_SIN_COS_TABLES
    //Tables for reconstruction sin values
    BP2Type *m_piSinForRecon2048;
    BP2Type *m_piSinForRecon1024;
    BP2Type *m_piSinForRecon512;
    BP2Type *m_piSinForRecon256;
    BP2Type *m_piSinForRecon128;
    BP2Type *m_piSinForRecon64;
    BP2Type *m_piSinForRecon;

    BP2Type *m_piSinForSaveHistory;
#endif

} CAudioObject;


//public and protected
#ifdef __cplusplus
extern "C" {  // only need to export C interface if
              // used by C++ source code
#endif


#if defined(HALF_TRANSFORM)
#   define HALFTRANSFORM_ONLY(x)   (x)
#   define UPSAMPLE_ONLY(x)        (x)
#   define HALF(fHalfTransform, x)  ((fHalfTransform) ? ((x)/2) : (x))
#else   // defined(HALF_TRANSFORM)
#   define HALFTRANSFORM_ONLY(x)
#   define UPSAMPLE_ONLY(x)
#   define HALF(fUpsample, x)  (x)
#endif  // defined(HALF_TRANSFORM)

#if defined(PAD2X_TRANSFORM)
#   define PAD2XTRANSFORM_ONLY(x)	(x)
#   define DOUBLE(fPad2X, x)  ((fPad2X) ? ((x)*2) : (x))
#else   // defined(PAD2X_TRANSFORM)
#   define PAD2XTRANSFORM_ONLY(x)
#   define DOUBLE(fUpsample, x)    (x)
#endif  // defined(PAD2X_TRANSFORM)

//#if defined(HALF_TRANSFORM) || defined(PAD2X_TRANSFORM)
//#   define HALF_OR_DOUBLE(fHalfTransform, fPad2X, x)  ((fHalfTransform) ? ((x)/2) : ((fPad2X) ? ((x)*2) : (x)))
//#else   // defined(HALF_TRANSFORM) || defined(PAD2X_TRANSFORM)
//#   define HALF_OR_DOUBLE(fUpsample, fPad2X, x)      (x)
//#endif  // defined(HALF_TRANSFORM) || defined(PAD2X_TRANSFORM)


U32 MaxSamplesPerPacket(U32 ulVersion, U32 ulSamplingRate, U32 ulChannels, U32 ulBitrate);
I32 msaudioGetSamplePerFrame (Int   cSamplePerSec, 
                              U32   dwBitPerSec, 
                              Int   cChannel,
                              Int   iVersion);

CAudioObject* auNew ();
Void    auDelete (CAudioObject* pau);        //destructor
WMARESULT auInit (CAudioObject* pau, Int iVersionNumber, Int cSubband, 
                  Int iSamplingRate, U16 cChannel, 
#ifdef WMA_V9
                  U32 nBlockAlign,
                  U16   nValidBitsPerSample,
                  U32   nChannelMask,
#endif // WMA_V9
                  Int cBytePerSec, Int cbPacketLength,
                  U16 iEncodeOpt, U16 iPlayerOpt);

Void    auPreGetPCM (CAudioObject* pau, U16* pcSampleDecoded);
WMARESULT auGetPCM (CAudioObject* pau, U16* pcSample, U8* pbDst, U32 cbDstLength);
WMARESULT auReconstruct (CAudioObject* pau, I16* piOutput, I16* pcSampleGet, Bool fForceTransformAll);
WMARESULT auSaveHistoryMono (CAudioObject* pau, PerChannelInfo* ppcinfo, 
                            Bool fForceTransformAll);

WMARESULT auAdaptToSubFrameConfig (CAudioObject* pau);
WMARESULT prvAdaptTrigToSubframeConfig(CAudioObject *pau);
WMARESULT prvAdaptTrigToSubframeConfig_INT(CAudioObject *pau);


Int     auPowerToRMS(CAudioObject* pau, Int iCurrMaskQ, Int iPrevMaskQ, Int iPrevResult);
Void    auUpdateMaxEsc(CAudioObject* pau, Int iQuantStepSize);

WMARESULT auDctIV(CAudioObject* pau, CoefType* rgiCoef, 
				   Float fltAfterScaleFactor, U32 *piMagnitude);  // DCT type 4

// LPC functions
#ifdef ENABLE_ALL_ENCOPT
Void    auResampleWeightFactorLPC (CAudioObject* pau, PerChannelInfo* ppcinfo);
Void    auLsp2lpc(CAudioObject* pau, U8 *lsfQ, LpType *lpc, Int order);
#endif //ENABLE_ALL_ENCOPT

Void    auResampleWeightFactorBark (CAudioObject* pau, PerChannelInfo* ppcinfo);

WMARESULT prvAllocate (CAudioObject* pau);

#ifdef __cplusplus
}
#endif

//private:

// *** TEMPORARY: prvAllocate moved from here to extern "C" block above ***

Void    prvSetBarkIndex (CAudioObject* pau);
WMARESULT prvInverseQuantizeHighRate (CAudioObject* pau, PerChannelInfo* ppcinfo, Int* rgiWeightFactor);
WMARESULT auReconCoefficentsHighRate (CAudioObject* pau, Void* pcaller, PerChannelInfo* ppcinfo, Int* piBitCnt);

WMARESULT prvInverseTransformMono (CAudioObject* pau, PerChannelInfo* ppcinfo, I16* piOutput,
                                 I16* piPrevOutput, I16* piPrevOutputSign,
                                 Bool fForceTransformAll);

WMARESULT auReconMono ( CAudioObject* pau,PerChannelInfo* ppcinfo,I16* piOutput,I16* pcSampleGet,Bool fForceTransformAll);


#if defined(WMA_TARGET_MIPS) && defined(BUILD_INTEGER)
//This function initalizes the function pointers for mips transforms
WMARESULT auInitMIPS(CAudioObject* pau);
#endif


#if defined(WMA_TARGET_X86)
WMARESULT auDctIV_KNI(CAudioObject* pau, CoefType* rgiCoef, Float fltAfterScaleFactor, U32 *piMagnitude);
WMARESULT auDctIV_INTEL(CAudioObject* pau, CoefType* rgiCoef, Float fltAfterScaleFactor, U32 *piMagnitude);

#if !defined(BUILD_INTEGER) && !defined(UNDER_CE)
typedef enum {INTELFFT_INIT_PROCESS, INTELFFT_INIT_THREAD,
    INTELFFT_FREE_THREAD, INTELFFT_FREE_PROCESS} INTELFFT_INITCODE;

void prvFFT4DCT_INTEL(CoefType data[], Int nLog2np);
WMARESULT auInitIntelFFT(const CAudioObject *pau, const INTELFFT_INITCODE iCode);
WMARESULT auFreeIntelFFT(CAudioObject *pau, const INTELFFT_INITCODE iCode);

#if defined (PEAQ_MASK) && defined (ENCODER)
Void prvInvFftComplexConjugate_INTEL(Float rgfltData[], Int nLog2np);
#endif // PEAQ_MASK && ENCODER
#endif  // !defined(BUILD_INTEGER) && !defined(UNDER_CE)


#ifdef USE_SIN_COS_TABLES
#ifndef BUILD_INTEGER
WMARESULT auReconstruct_X86 (CAudioObject* pau, I16* piOutput, I16* pcSampleGet, Bool fForceTransformAll);
WMARESULT auReconMono_X86 ( CAudioObject* pau,PerChannelInfo* ppcinfo,I16* piOutput,I16* pcSampleGet,Bool fForceTransformAll);
WMARESULT auReconStereo_MMX (CAudioObject* pau, I16* piOutput, I16* pcSampleGet, Bool fForceTransformAll);
WMARESULT auReconStereo_SIMDFP (CAudioObject* pau, I16* piOutput, I16* pcSampleGet, Bool fForceTransformAll);
#else
WMARESULT auReconstruct_MMX (CAudioObject* pau, I16* piOutput, I16* pcSampleGet, Bool fForceTransformAll);
WMARESULT auReconMono_MMX ( CAudioObject* pau,PerChannelInfo* ppcinfo,I16* piOutput,I16* pcSampleGet,Bool fForceTransformAll);
#endif //#ifndef BUILD_INTEGER
#endif //#ifdef USE_SIN_COS_TABLES
WMARESULT prvInverseTransformMono_MMX (CAudioObject* pau, Float* rgfltCoefRecon,
                                     I32* piCurrOutput, Bool fForceTransformAll);
#endif // defined(WMA_TARGET_X86)

#if !(defined(WMA_TARGET_MIPS)&&defined(BUILD_INTEGER))
Void    prvFFT_Int(Int data[], Int np);
Void    prvFFT4DCT(CoefType data[], Int nLog2np);

#if defined (PEAQ_MASK) && defined (ENCODER)
// Implemented in x86.c, fft.c
Void prvInvFftComplexConjugate(Float *rgfltData, Int nOrder);
#endif // PEAQ_MASK && ENCODER
#endif // !WMA_TARGET_MIPS

#ifdef ENABLE_ALL_ENCOPT
//for noise sub and low rates only
WMARESULT prvInitNoiseSub (CAudioObject* pau);
WMARESULT prvInverseQuantizeMidRate (CAudioObject* pau, PerChannelInfo* ppcinfo, Int* rgiWeightFactor);
WMARESULT prvInverseQuantizeLowRate (CAudioObject* pau, PerChannelInfo* ppcinfo, Int* rgiWeightFactor);

#if defined(ENCODER) && defined (SMOOTH_NMR) && !defined(INTEGER_ENCODER) && !defined(BUILD_INTEGER)
WMARESULT prvInverseQuantizeMidRateSkipNoise (CAudioObject* pau, PerChannelInfo* ppcinfo,
                                              Int* rgiWeightFactor, Bool fSkipNoise);
#endif // defined(ENCODER) && defined (SMOOTH_NMR) && !defined(INTEGER_ENCODER) && !defined(BUILD_INTEGER)

#ifdef TRANSCODER
WMARESULT prvInverseQuantizeTRANSCODE (CAudioObject* pau, PerChannelInfo* ppcinfo, Int* rgiWeightFactor);
#endif  // TRANSCODER

//private lpc functions
WMARESULT prvLpcToSpectrum (CAudioObject* pau, const LpType* rgfltLpcCoef, PerChannelInfo* ppcinfo);
Void prvInitInverseQuadRootTable (CAudioObject* pau);
#endif //ENABLE_ALL_ENCOPT

#ifdef __cplusplus
}
#endif

#ifndef PREVOUTPUT_16BITS
// **************************************************************************
// Signbit Macros
// I've put them here because they're used in both msaudio.c and float.c
// **************************************************************************
#define I17_MIN ((signed) 0xFFFF0000)
#define I17_MAX ((signed) 0x0000FFFF)
#define CALC_SIGN_OFFSETS(piSrcBase, piSrc, piSrcSignBase, piSrcSign,           \
                           uiSignbitData, uiSignbitCount, cChan)                \
    {                                                                           \
    const int c_iOffset = (piSrc - piSrcBase)>>(cChan-1);                       \
    const int c_iSignOffset = (c_iOffset+((BITS_PER_BYTE * sizeof(I16))-1))		\
							/ (BITS_PER_BYTE * sizeof(I16));					\
    piSrcSign = piSrcSignBase + c_iSignOffset;                                  \
    uiSignbitCount = 16 - (c_iOffset % (BITS_PER_BYTE * sizeof(I16)));          \
	if (uiSignbitCount == 16)													\
		uiSignbitData = *piSrcSign++;                                           \
	else																		\
		uiSignbitData = *(piSrcSign-1);											\
    }

#define RECORD_SIGNBIT(iResult, piDstSign, uiSignbitData, uiSignbitCount, incr) \
    uiSignbitData <<= 1;                                                        \
    uiSignbitData |= ((iResult >> 31) & 0x00000001);                            \
    uiSignbitCount += 1;                                                        \
    if (uiSignbitCount >= 16)                                                   \
    {   /* Signbit register is full! Write it out */                            \
        *piDstSign = (I16) uiSignbitData;                                       \
        piDstSign += incr;                                                      \
        DEBUG_ONLY( uiSignbitData = 0 );                                        \
        uiSignbitCount = 0;                                                     \
    }

#define COMBINE_SIGNBIT(iResult, iSrc, piSrcSign, uiSignbitData, uiSignbitCount) \
    if (0 == uiSignbitCount)                                                     \
    {   /* Signbit register is empty! Read new one in */                         \
        uiSignbitData = *piSrcSign;                                              \
        piSrcSign += 1;                                                          \
        uiSignbitCount = 16;                                                     \
    }                                                                            \
    if (uiSignbitData & 0x00008000)                                              \
        iResult = (-1) & 0xFFFF0000;                                             \
    else                                                                         \
        iResult = 0;                                                             \
    iResult |= (iSrc & 0x0000FFFF);                                              \
    uiSignbitData <<= 1;                                                         \
    uiSignbitCount -= 1;

#define SAVE_SIGNBIT_STATE(piSrcSign,uiSignbitData)								 \
	if (0 != uiSignbitCount)													 \
		*(piSrcSign-1) = (I16)uiSignbitData;	/* must save partial shift */

#define ASSERT_SIGNBIT_POINTER(piSrcOrDstSign)								     \
	assert( piSrcOrDstSign != NULL );

#else   // PREVOUTPUT_16BITS

// Use I16 min/max in place of I17
#define I17_MIN SHRT_MIN
#define I17_MAX SHRT_MAX

#define CALC_SIGN_OFFSETS(piSrcBase, piSrc, piSrcSignBase, piSrcSign,            \
                           uiSignData, uiSignCount, cChan)                             
#define RECORD_SIGNBIT(iResult, piDstSign, uiSignbitData, uiSignbitCount, incr)
#define COMBINE_SIGNBIT(iResult, iSrc, piSrcSign, uiSignbitData, uiSignbitCount) \
    iResult = iSrc
#define SAVE_SIGNBIT_STATE(piSrcSign,uiSignData)
#define ASSERT_SIGNBIT_POINTER(piSrcOrDstSign)

#endif  // PREVOUTPUT_16BITS


#if defined(INTERPOLATED_DOWNSAMPLE)

#define INTERPOL_FRACTBITS  30

void prvInterpolateInit(CAudioObject *pau, Int iSrcSampleRate,
                        Int iDstSampleRate, Int iAddInterval);

#ifdef BUILD_INTEGER
void auLowPass(CAudioObject *pau, Int *rgiCoef, Int iNumCoefs);
#else
void auLowPass(CAudioObject *pau, Float *rgfltCoef, Int iNumCoefs);
#endif  // BUILD_INTEGER
#endif  // defined(INTERPOLATED_DOWNSAMPLE)

#ifdef INTERPOLATED_DOWNSAMPLE
#define DOWNSAMPLE_ONLY(x)  (x)
void prvInterpolate(CAudioObject *pau, I16 *piSourceBuffer, Int iNumSrcSamples, Int iChannels,
                    I16 *piDestBuffer, Int *piNumDstSamples, U16* pcSamples);
#else   // INTERPOLATED_DOWNSAMPLE
#define DOWNSAMPLE_ONLY(x)
#endif  // INTERPOLATED_DOWNSAMPLE

#ifndef BUILD_INTEGER
// do not scale WeightFactor when using float
#undef WEIGHTFACTOR_FRACT_BITS
#define WEIGHTFACTOR_FRACT_BITS 0
#endif

//Void auCalcQuantStep(Int iQuantStepSize, U32 *piQuantStep, U32 *piFractBits);
QuantStepType qstCalcQuantStep(Int iQuantStepSize);
QuantFloat prvWeightedQuantization(CAudioObject *pau, PerChannelInfo *ppcinfo, Int iBark);


void SetActualPower(const I16 *piCoefQ, const int iCount,
                    PerChannelInfo *ppcinfo, const Status codecStatus);
void SetActualPowerHighRate(const I32 *piCoefRecon, const int iCount,
                    PerChannelInfo *ppcinfo, const Status codecStatus);


// **************** Monitor Range of Values for Debugging ******************************
// Place MONITOR_RANGE(name,variable) in the code where you want to monitor a variable,
// and use DUMP_MONITOR_RANGES(0) in the exit code where you want to print out the results
// If you want to dump on a frame-by-frame basis, use REINIT_MONITOR_RANGE after the dump
// Finally, add an appropriate DECL_MONITOR_RANGE(name) in wmaOS.c 
// and add DUMP_MONITOR_RANGE(name) to the DumpMonitorRanges() function there.
// **************************************************************************************
#if defined(_DEBUG) && defined(WMA_MONITOR)
// some MONITOR_RANGE variations can be defined.
// First variation is to print the variable to stdout
//#	define WMA_MONITOR_PRINT "gMR_rgfltWeightFactor"
// Second variation allows you to break when the fabs(variable) exceeds a threshold
//#	define WMA_MONITOR_BREAK "gMR_rgfltWeightFactor"
//#	define WMA_MONITOR_BREAK_THRESHOLD 50
// both of these variations are slow because strcmp is done at runtime instead of compile time - but this is debug code.
#	ifdef WMA_MONITOR_PRINT
#		define MONITOR_RANGE(a,x) { extern double a[]; extern long lc##a; if ((double)(x)<a[0]) a[0]=(double)(x); if ((double)(x)>a[1]) a[1]=(double)(x); a[2] += (x); a[3] += (x)*(x); lc##a++; \
									if (strcmp(#a,WMA_MONITOR_PRINT)==0) printf("%14.6g\n",(double)(x));  }
#	elif defined(WMA_MONITOR_BREAK)
#		define MONITOR_RANGE(a,x) { extern double a[]; extern long lc##a; if ((double)(x)<a[0]) a[0]=(double)(x); if ((double)(x)>a[1]) a[1]=(double)(x); a[2] += (x); a[3] += (x)*(x); lc##a++; \
									if (strcmp(#a,WMA_MONITOR_BREAK)==0 && fabs(x)>WMA_MONITOR_BREAK_THRESHOLD) DEBUG_BREAK();  }
#	else
#		define MONITOR_RANGE(a,x) { extern double a[]; extern long lc##a; if ((double)(x)<a[0]) a[0]=(double)(x); if ((double)(x)>a[1]) a[1]=(double)(x); a[2] += (x); a[3] += (x)*(x); lc##a++; }
#	endif
#	define MONITOR_RANGE_CONDITIONAL(cond,a,x) if (cond) { extern double a[]; extern long lc##a; if ((double)(x)<a[0]) a[0]=(double)(x); if ((double)(x)>a[1]) a[1]=(double)(x); a[2] += (x); a[3] += (x)*(x); lc##a++; }
#	define MONITOR_COUNT(a,c) { extern long lc##a; lc##a+=c; }
#	define MONITOR_COUNT_CONDITIONAL(cond,a,c) if (cond) { extern long lc##a; lc##a+=c; }
#	define DUMP_MONITOR_RANGES(fAppend) { void DumpMonitorRanges(int f); DumpMonitorRanges(fAppend); }
#	define REINIT_MONITOR_RANGE(a) { extern double a[]; extern long lc##a; a[1] = -( a[0] = 1.0e30 );  a[2] = a[3] = 0; lc##a = 0; }
#	define DUMP_MONITOR_RANGE(a) { extern double a[]; extern long lc##a; if ( a[0] == 1.0e30 && a[3]==0 ) { a[0] = a[1] = 0; } if (lc##a>0) printf("%14.6g %14.6g %14.6g %14.6g %8ld " #a "\n", a[0], a[1], a[2]/lc##a, sqrt((lc##a*a[3]-a[2]*a[2])/((double)(lc##a)*(lc##a-1))), lc##a ); }
#else // not (defined(_DEBUG) && defined(WMA_MONITOR))
#	define MONITOR_RANGE(a,x)
#	define MONITOR_RANGE_CONDITIONAL(cond,a,x)
#	define MONITOR_COUNT(a,c)
#	define MONITOR_COUNT_CONDITIONAL(cond,a,c)
#	define DUMP_MONITOR_RANGES(fAppend)
#	define REINIT_MONITOR_RANGE(a)
#	define DUMP_MONITOR_RANGE(a) 
#endif

#if defined(WMA_SHOW_FRAMES) && defined(_DEBUG)
    void prvWmaShowFrames(CAudioObject* pau, const char* pszID, const char* pszFmt, ...);
#endif

#if defined(HEAP_DEBUG_TEST) && defined(_DEBUG)
void HeapDebugCheck();
#define HEAP_DEBUG_CHECK HeapDebugCheck()
#else
#define HEAP_DEBUG_CHECK
#endif

// **************************************************************************
// Encoding Options
// **************************************************************************
#define ENCOPT_BARK             0x0001
#define ENCOPT_V5LPC            0x0020
#define ENCOPT_SUPERFRAME       0x0002
#define ENCOPT_SUBFRAME         0x0004

#define ENCOPT_SUBFRAMEDIVMASK  0x0018
#define ENCOPT_SUBFRAMEDIVSHR   3

#define ENCOPT_TRANSCODE        0x0040


// **************************************************************************
// Player Options
// **************************************************************************
#define PLAYOPT_DOWNSAMPLE32TO22 0x0001
#define PLAYOPT_HALFTRANSFORM    0x0002
#define PLAYOPT_UPSAMPLE         0x0004
#define PLAYOPT_PAD2XTRANSFORM   0x0008


//mallocAligned allocates a buffer of size (+iAlignToBytes for allignment padding) bytes 
//which is alligned on an iAllignToBytes byte boundary
//the buffer must be deallocated using freeAligned
//and it is only safe to use size bytes as the padding could be at the begining or ending
void *mallocAligned(size_t size,Int iAlignToBytes);
void freeAligned(void *ptr);

// ----- Memory Allocation Functions -----
typedef enum {MAS_ALLOCATE, MAS_LOCKED, MAS_DELETE} MEMALLOCSTATE;

I32 auMallocGetCount(void);
void auMallocSetState(const MEMALLOCSTATE maState, void *pBuf, const I32 iBufSize);
void *auMalloc(const size_t iSize);
void auFree(void *pFree);


#endif //__MSAUDIO_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\wmalib\common\wavfileio.h ===
/* -------------------------------------------------------------------------
 *
 *  Microsoft Windows Media
 *
 *  Copyright (C) Microsoft Corporation, 1999 - 1999
 *
 *  File:       wavfileio.h
 *
 * ---------------------------------------------------------------------- */

#ifndef _WAV_FILE_IO_H_
#define _WAV_FILE_IO_H_

/* use this to turn off the use of mmio* calls */
#define WFIO_NO_WIN32 1

/* use this to control the endian-ness */
#define WFIO_LITTLE_ENDIAN 1

#if WFIO_NO_WIN32

#include <stdio.h>
#include "macros.h"
#include <xtl.h> 

#ifndef _WAVEFORMATEX_
#define _WAVEFORMATEX_
#ifndef _Embedded_x86
#pragma COMPILER_PACKALIGN(1)
#endif
#ifndef _Embedded_x86
#pragma COMPILER_PACKALIGN_DEFAULT
#endif
#endif /* _WAVEFORMATEX_ */

#define MMSYSERR_NOERROR     0
#define MMSYSERR_ERROR       1
#define MMSYSERR_NOMEM       7
#define MMSYSERR_READERROR   16
#define MMSYSERR_WRITEERROR  17

#else  /* WFIO_NO_WIN32 */

#include <mmsystem.h>
#include <mmreg.h>

#endif /* WFIO_NO_WIN32 */

#ifdef __cplusplus
extern "C" {
#endif  /* __cplusplus */

/* flag for WavFileIO */
enum
{
    wfioModeRead = 0,
    wfioModeWrite
};

/* ===========================================================================
 * WavFileIO struct
 */
typedef struct WavFileIO_tag
{
    I32      m_mode;

#if WFIO_NO_WIN32
    FILE    *m_fpWav;

    size_t   m_posRiffLength;
    size_t   m_posDataLength;
#else  /* WFIO_NO_WIN32 */
    HMMIO    m_hmmio;
    MMIOINFO m_mmioinfo;

    MMCKINFO m_ckWave;
    MMCKINFO m_ck;
#endif /* WFIO_NO_WIN32 */

    WAVEFORMATEX *m_pFormat;      /* but allocated using BYTEs...  */
    U32   m_sizeFormat;

    U32   m_sizeData;
    U32   m_posDataStart;

} WavFileIO;


/* ---------------------------------------------------------------------------
 * member functions
 */

WavFileIO * wfioNew();
void wfioDelete(WavFileIO *pwfio);

/* pFormat and cbFormat are only for writing... */
I32 wfioOpen(WavFileIO *pwfio, const char *szFile, WAVEFORMATEX *pFormat, U32 cbFormat, I32 mode);
void wfioClose(WavFileIO *pwfio);

/* origin can be SEEK_SET, SEEK_CUR, or SEEK_END */
I32 wfioSeek(WavFileIO *pwfio, I32 position, I32 origin);

I32 wfioRead(WavFileIO *pwfio, U8 *pBuf, I32 cbBuf);
I32 wfioWrite(WavFileIO *pwfio, U8 *pBuf, I32 cbBuf);

WAVEFORMATEX * wfioGetFormat(WavFileIO *pwfio);
U32 wfioGetFormatLength(WavFileIO *pwfio);

U32 wfioGetSampleSize(WavFileIO *pwfio);
U32 wfioGetDataLength(WavFileIO *pwfio);

I32 wfioGetMode(WavFileIO *pwfio);
I32 wfioIsOpened(WavFileIO *pwfio);

/* utility functions */
U16 adjustByteOrder16(U16 val);
U32 adjustByteOrder32(U32 val);

#ifdef __cplusplus
}
#endif  /* __cplusplus */


#endif /* _WAV_FILE_IO_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\wmalib\decoder\strmdec_wma.h ===
/*************************************************************************

Copyright (C) 1996-1999  Microsoft Corporation

Module Name:

	strmdec_wma.h

Abstract:

	Decoder BitStream

Author:

	Craig Dowell (craigdo@microsoft.com) 10-December-1996
	Ming-Chieh Lee (mingcl@microsoft.com) 10-December-1996
	Bruce Lin (blin@microsoft.com) 10-December-1996

Revision History:
	Bruce Lin (blin@microsoft.com) 02-May-1997
	Add getMaxBits()
    Wei-ge Chen (wchen@microsoft.com) 20-July-1999
    Make it in C.

*************************************************************************/

#ifndef __STRMDEC_WMA_H_
#define __STRMDEC_WMA_H_

#define VALID				0
#define END_OF_FILE			1
#define ILLEGAL_PATTERN		3
#ifndef EOF
#define EOF                 (-1)
#endif

#define NONSUPER_WRAPAROUND 1024

#ifdef __cplusplus
extern "C" {  // only need to export C interface if
              // used by C++ source code
#endif

extern const UInt getMask [33];

#if defined(_DEBUG) || defined(BITRATE_REPORT)
extern Int g_cBitGet;
#endif  // _DEBUG || BITRATE_REPORT

typedef WMARESULT (*PFNGETMOREDATA)(U8 **ppBuffer, U32 *pcbBuffer, U32 user_data, U8* pBufferExtra);

typedef struct CWMAInputBitStream {

//wchen: add for streaming mode
    PFNGETMOREDATA  m_pfnGetMoreData;
    U32             m_dwUser;
    U32             m_dwOwner;

    U32     m_dwHeaderBuf;      // hold the packet header data
    U8	    *m_pBufferBegin;    // begining of packet for reset
    U32	    m_cbBuflenBegin;    // used in association of m_pBufferBegin	

    U8		*m_pBuffer;
    Int		m_cbBuflen;
    UInt	m_dwDot;
    UInt	m_dwBitsLeft;
    Int     m_iPrevPacketNum;
    Bool    m_fAllowPackets;
    Bool    m_fSuppressPacketLoss;
	U8		m_pBufferExtra [256];

    WMARESULT (*ibstrmpfnPeekBits) (struct CWMAInputBitStream *pibstrm, register UInt dwNumBits,
                                    U32 *piNumBits);

} CWMAInputBitStream;

Void        ibstrmInit (CWMAInputBitStream* pibstrm, Bool fAllowPackets);
Void        ibstrmAttach(CWMAInputBitStream *pibstrm, U32 dwDot, U32 dwBitsLeft, U8* pbSrc, I32 cbSrc);
Void ibstrmReset(CWMAInputBitStream *pibstrm);
INLINE UInt ibstrmBitsLeft (const CWMAInputBitStream* pibstrm) {return pibstrm->m_dwBitsLeft;}
INLINE U32  ibstrmDwBuf (const CWMAInputBitStream* pibstrm) {return pibstrm->m_dwDot;}
INLINE U8*  ibstrmBuf (const CWMAInputBitStream* pibstrm) {return pibstrm->m_pBuffer;}
INLINE Int  ibstrmBufLen (const CWMAInputBitStream* pibstrm) {return pibstrm->m_cbBuflen;}

INLINE Void ibstrmSetGetMoreData(CWMAInputBitStream *pibs, PFNGETMOREDATA pfnGetMoreData)
                        { pibs->m_pfnGetMoreData = pfnGetMoreData; }
INLINE Void ibstrmSetUserData(CWMAInputBitStream *pibs, U32 dwUser) 
                        { pibs->m_dwUser = dwUser; }
INLINE Void ibstrmSetOwner(CWMAInputBitStream *pibs, U32 dwOwner) 
                        { pibs->m_dwOwner = dwOwner; }
INLINE U32  ibstrmGetPacketHeader(CWMAInputBitStream *pibs) 
                        { return pibs->m_dwHeaderBuf; }
INLINE Void ibstrmSetPacketHeader(CWMAInputBitStream *pibs, U32 iVal) 
                        { pibs->m_dwHeaderBuf = iVal; }
Void        ibstrmResetPacket(CWMAInputBitStream *pibstrm); // reset to the beginning of packet
WMARESULT   ibstrmGetMoreData(CWMAInputBitStream *pibstrm, U32 *piBufLen);
WMARESULT   ibstrmPeekBitsNonStop (CWMAInputBitStream *pibstrm, register UInt dwNumBits,
                                   U32 *piNumBits);
WMARESULT   ibstrmPeekBits (CWMAInputBitStream *pibstrm, register UInt dwNumBits,
                            U32 *piNumBits);
WMARESULT   ibstrmLookForBits (CWMAInputBitStream *pibstrm, UInt dwNumBits);
WMARESULT   ibstrmFlushBits (CWMAInputBitStream *pibstrm, register UInt dwNumBits);
INLINE Void ibstrmFlush (CWMAInputBitStream* pibstrm) 
                        { pibstrm->m_dwBitsLeft -= (pibstrm->m_dwBitsLeft % 8); } 

//private
WMARESULT prvFinalLoad(CWMAInputBitStream* pibstrm,
                       UInt             dwRetval,
                       UInt             dwBitsToAdd,
                       U32             *piResult);

/*INLINE*/ WMARESULT ibstrmGetBits (CWMAInputBitStream* pibstrm, register UInt dwNumBits,
                                    U32 *piResult);

/*
{
    register UInt dwRetval;
    register UInt dwShift;

#ifdef _DEBUG
    g_cBitGet += dwNumBits;
#endif  // _DEBUG


    if (pibstrm->m_dwBitsLeft <= 24 && pibstrm->m_cbBuflen <= 0)
        ibstrmGetMoreData (pibstrm);
    assert (dwNumBits <= 24);
    //wchen: since the dwDot is always 24bits or more 
    //the following code can be greatly simplified. Do it later.

    //
    // This is a little unwieldly, but make sure the end-of-file test falls
    // through in the usual (not end-of-file) case to avoid CPU pipeline stalls
    // due to a branch (or mispredictions on more sophisticated processors).
    //
    if (pibstrm->m_fStreamStaus == VALID && 
        ((UInt) (pibstrm->m_cbBuflen << 3) >= dwNumBits || 
        pibstrm->m_dwBitsLeft + (pibstrm->m_cbBuflen << 3) >= dwNumBits)) {
        //
        // Do the most common case first.  If this doesn't play, we have one branch
        // to get to the next most common case (usually 1/32 of the time in the case
        // of the codec doing a huffman decode).  Note that we use a mask array to
        // avoid a special case branch when the bitcount is 32 (even though this is
        // relatively unlikely) since a left shift operation where the shift count
        // is equal to or greater than the number of bits in the destination is
        // undefined.
        //
        if (dwNumBits <= pibstrm->m_dwBitsLeft) {
            pibstrm->m_dwBitsLeft -= dwNumBits;
			return (pibstrm->m_dwDot >> pibstrm->m_dwBitsLeft) & getMask[dwNumBits];
        }
        //
        // The next most common case is when we have lots of data left in the buffer.
        // and we can fully load (i.e., all 32-bits) our accumulator.  This is
        // hard-wired to allow an optimizer to go crazy with all of the constants.
        // Note that the data is byte-swapped on the way in.
        //
        dwRetval = pibstrm->m_dwDot & getMask[pibstrm->m_dwBitsLeft];
        dwShift = dwNumBits - pibstrm->m_dwBitsLeft;

        if (pibstrm->m_cbBuflen >= 4) {
            register UInt     dwAcc;

            dwAcc = (UInt)pibstrm->m_pBuffer[3];
            dwAcc |= (UInt)(pibstrm->m_pBuffer[2]) << 8;
            dwAcc |= (UInt)(pibstrm->m_pBuffer[1]) << 16;
            dwAcc |= (UInt)(pibstrm->m_pBuffer[0]) << 24;
            pibstrm->m_dwDot = dwAcc;
            pibstrm->m_pBuffer += 4;
            pibstrm->m_cbBuflen -= 4;
            dwRetval <<= dwShift;
            dwRetval |= (dwAcc >> (32 - dwShift));// & getMask[dwShift];
            pibstrm->m_dwBitsLeft = 32 - dwShift;
            return dwRetval;
        }
        //
        // The final, and least likely case, is when we're at the end of the buffer.
        // Since there's really no point in having this inlined since it'll only
        // happen once, I'll call a function to make it happen and save the space
        // in the inline instances of getBits().
        //
		return prvFinalLoad(pibstrm, dwRetval, dwShift);
    }
	else {
        pibstrm->m_fStreamStaus = END_OF_FILE;
        return 0;
    }
}
*/
#ifdef __cplusplus
}
#endif

#endif // __STRMDEC_WMA_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\wmalib\decoder\huffdec.h ===
/*************************************************************************

Copyright (C) Microsoft Corporation, 1996 - 1999

Module Name:

    HuffDec.h

Abstract:

    Huffman decoder. Simplified from Sanjeevm's huffman.hpp

Author:

    Wei-ge Chen (wchen) 19-July-1999

Revision History:


*************************************************************************/

#ifndef _HUFFDEC_H
#define _HUFFDEC_H

#ifdef __cplusplus
extern "C" {  // only need to export C interface if
              // used by C++ source code
#endif

#include "macros.h"
#include "strmdec_wma.h"

#define BITSTREAM_READ 1

WMARESULT huffDecGet(const U16 *pDecodeTable, CWMAInputBitStream *bs,
                     U32* puBitCnt, U32 *puResult, U32* puSign);

#ifdef __cplusplus
}
#endif
#endif //_HUFFDEC_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\wmalib\common\wmaOS.h ===
//depot/xbox/private/windows/directx/dsound/codecs/wmalib/common/wmaOS.h#1 - add change 1740 (text)
/*************************************************************************

Copyright (C) Microsoft Corporation, 1996 - 1999

Module Name:

    WmaOS.h

Abstract:

    OS-specific data types and defines.

Author:

    Raymond Cheng (raych)       Aug 25, 1999

Revision History:


*************************************************************************/


#ifndef _WMA_OS_H_
#define _WMA_OS_H_


// Specify the OS target here


#if  defined(_Embedded_x86)
#define WMA_OSTARGET_LINUX
#elif defined(S_SUNOS5)
#define WMA_OSTARGET_SUNOS5
#elif defined(__QNX__)
#define WMA_OSTARGET_QNX
#elif defined(_WIN32) 
#ifndef macintosh
#define WMA_OSTARGET_WIN32
#endif 
#endif





// **************************************************************************
// OS-Specific #ifdefs
// **************************************************************************

// ======================================================
// Win32 OS
// ======================================================
#if defined(WMA_OSTARGET_WIN32)

#ifdef COMMONMACROS_OUTPUT_TARGET
#pragma COMPILER_MESSAGE("-----WMAOS.H: Compiling for Win32 OS")
#endif // COMMONMACROS_OUTPUT_TARGET

#define _SCRUNCH_INLINE_ASM
#define PLATFORM_SPECIFIC_OUTPUTDEBUGSTRING
#define PLATFORM_SPECIFIC_PERFTIMER
#define PLATFORM_SPECIFIC_DEBUGINFRASTRUCTURE

#ifndef DISABLE_ASSERTS
#define PLATFORM_SPECIFIC_DEBUGBREAK

/* CE x86em platform does not have DebugBreak */
#ifdef _WIN32_WCE
#undef PLATFORM_SPECIFIC_DEBUGBREAK
#endif  // _WIN32_WCE
#endif  // DISABLE_ASSERTS

#ifdef UNDER_CE
// avoid threading on WinCE 
// TODO: verify if it can be used and how it effects performance)
#define WMA_SERIALIZE 
#endif

#include "..\win32\win32.h"


// ======================================================
// Generic OS
// ======================================================
#else

#ifdef COMMONMACROS_OUTPUT_TARGET
#pragma COMPILER_MESSAGE("-----WMAOS.H: Compiling for GENERIC OS")
#endif // COMMONMACROS_OUTPUT_TARGET

#define WMA_SERIALIZE // No threading services are available

#endif // WMA_OSTARGET_WIN32



// **************************************************************************
// Common to All OS's
// **************************************************************************

#ifdef ENCODER
#ifndef WMA_SERIALIZE
// Thread-Handling API (implement these fns for a particular OS to turn on threading)
void osInitThreadInfo(THREADINFO *pInfo);
WMARESULT osInitThreads(CAudioObjectEncoder *pauenc);
void osCloseThreads(THREADINFO *pInfo);
void osThreadPrcAll(THREADINFO *pInfo);
void osThreadEncAll(THREADINFO *pInfo);
void osThreadSendAll(THREADINFO *pInfo);
void osThreadDetectAll(THREADINFO *pInfo);
#endif  // !WMA_SERIALIZE
#endif  // ENCODER


// ----- Performance Timer Functions -----
#ifdef __cplusplus
extern "C" {
#endif  // __cplusplus
typedef struct tagPERFTIMERINFO PERFTIMERINFO;

PERFTIMERINFO *PerfTimerNew(long lSamplesPerSecOutput);
void PerfTimerStart(PERFTIMERINFO *pInfo);
void PerfTimerStop(PERFTIMERINFO *pInfo, long lSamplesDecoded);
void PerfTimerStopElapsed(PERFTIMERINFO *pInfo);
void PerfTimerReport(PERFTIMERINFO *pInfo);
float fltPerfTimerDecodeTime(PERFTIMERINFO *pInfo);
void PerfTimerFree(PERFTIMERINFO *pInfo);
#ifdef __cplusplus
}
#endif  // __cplusplus

// ----- Debug Infrastructure Functions and Macros -----
void TraceInfo(const char *pszFmt, ...);

#ifdef _DEBUG
#ifdef __cplusplus
extern "C" {
#endif  // __cplusplus
void TraceInfoHelper(const char *pszFile, int iLine, const char *pszFmt, ...);
WMARESULT MyOutputDbgStr(WMARESULT wmaReturn, const char *pszFmt, ...);

#ifdef __cplusplus
}
#endif  // __cplusplus

// raych: The __FILE__ and __LINE__ might cause cross-platform compiler problems. Fix later...
#define TraceInfo0(text)            TraceInfoHelper(__FILE__, __LINE__, text)
#define TraceInfo1(text,one)        TraceInfoHelper(__FILE__, __LINE__, text, one)
#define TraceInfo2(text,one,two)    TraceInfoHelper(__FILE__, __LINE__, text, one, two)
#define TraceInfo3(text,one,two,three)                                      \
    TraceInfoHelper(__FILE__, __LINE__, text, one, two, three)

#define TraceInfo4(text,one,two,three,four)                                 \
    TraceInfoHelper(__FILE__, __LINE__, text, one, two, three, four)

#define TraceInfo5(text,one,two,three,four,five)                            \
    TraceInfoHelper(__FILE__, __LINE__, text, one, two, three, four, five)

#ifdef WANT_TRACE_ONHOLD
// Tracing ONHOLD for decapp produces too many benign error messages.  But Wei-ge assures us that
// for wmadec_s, it can be useful.  If you want it, define the symbol above.
#define TraceResult(code)   MyOutputDbgStr((code), "%s(%d) : *** TRACE *** code = 0x%x!\n", \
                                    __FILE__, __LINE__, (code))
#else   // WANT_TRACE_ONHOLD
#define TraceResult(code)   ( ((code)==WMA_E_ONHOLD || (code)==WMA_OK) ?  (code) :              \
                                MyOutputDbgStr((code), "%s(%d) : *** TRACE *** code = 0x%x!\n", \
                                    __FILE__, __LINE__, (code)) )
#endif  // WANT_TRACE_ONHOLD

#define TraceError(code)    {   /* wmaFOOFOO to avoid naming collisions */                      \
                                WMARESULT wmaFOOFOO = (code);                                   \
                                if (WMA_FAILED(wmaFOOFOO))                                      \
                                    TraceResult(wmaFOOFOO);                                     \
                            }

#else   // _DEBUG
#define TraceInfo0(text)
#define TraceInfo1(text,one)
#define TraceInfo2(text,one,two)
#define TraceResult(code)   (code)
#define TraceError(code)
#endif  // _DEBUG

#define TRACEWMA_EXIT(wmaResult, action) \
                            (wmaResult) = (action);                                             \
                            if (WMA_FAILED(wmaResult))                                          \
                            {                                                                   \
                                TraceResult(wmaResult);                                         \
                                goto exit;                                                      \
                            } else {}
    
#define ASSERTWMA_EXIT(wmaResult, action) \
                            (wmaResult) = (action);                                             \
                            if (WMA_FAILED(wmaResult))                                          \
                            {                                                                   \
                                DEBUG_ONLY(DEBUG_BREAK()); /* assert(WMAB_FALSE); */            \
                                TraceResult(wmaResult);                                         \
                                goto exit;                                                      \
                            } else {}

#define CHECKWMA_EXIT(wmaResult) \
                            if (WMA_FAILED(wmaResult))                                          \
                            {                                                                   \
                                TraceResult(wmaResult);                                         \
                                goto exit;                                                      \
                            } else {}

#define TRACEWMA_RET(wmaResult, action) \
                            (wmaResult) = (action);                                             \
                            if (WMA_FAILED(wmaResult))                                          \
                            {                                                                   \
                                return TraceResult(wmaResult);                                  \
                            } else {}


// **************************************************************************
// Overridable Macros (optimized for some platforms, but not all)
// **************************************************************************
// The following can be overridden within a particular platform OS file

//---------------------------------------------------------------------------
#ifndef PLATFORM_SPECIFIC_OUTPUTDEBUGSTRING
#define OUTPUT_DEBUG_STRING(sz) printf(sz)
#endif  // PLATFORM_SPECIFIC_OUTPUTDEBUGSTRING

//---------------------------------------------------------------------------
#if defined(_DEBUG) && !defined(DISABLE_ASSERTS)
#ifndef PLATFORM_SPECIFIC_DEBUGBREAK
#define DEBUG_BREAK()   *((U32 *)0) = 55    // Brute-force debug break
#endif // PLATFORM_SPECIFIC_DEBUGBREAK
#else   // defined(_DEBUG) && !defined(DISABLE_ASSERTS)
#undef DEBUG_BREAK
#define DEBUG_BREAK()
#endif  // defined(_DEBUG) && !defined(DISABLE_ASSERTS)

#endif // _WMA_OS_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\wmalib\decoder\msaudiodec.h ===
/*************************************************************************

Copyright (C) Microsoft Corporation, 1996 - 1999

Module Name:

    MsAudioDec.h

Abstract:

    Header file for CAudioObjectDecoder.

Author:

    Wei-ge Chen (wchen) 14-July-1998

Revision History:


*************************************************************************/

#ifndef __MSAUDIODEC_H_
#define __MSAUDIODEC_H_


#define audecNew audecNew_XDS
#define audecDelete audecDelete_XDS
#define audecInit audecInit_XDS
#define audecReset audecReset_XDS
#define audecFlush audecFlush_XDS
#define audecOutputBufferSize audecOutputBufferSize_XDS
#define audecDecodeInfo audecDecodeInfo_XDS
#define audecDecodeData audecDecodeData_XDS
#define audecGetPCM audecGetPCM_XDS
#define prvWMAGetMoreData prvWMAGetMoreData_XDS
#define audecDecode audecDecode_XDS
#define audecSetEqualizer audecSetEqualizer_XDS
#define audecResetEqualizer audecResetEqualizer_XDS
#define audecStartComputeBandPower audecStartComputeBandPower_XDS
#define audecStopComputeBandPower audecStopComputeBandPower_XDS
#define audecGetBandPower audecGetBandPower_XDS
#define prvDecodePacket prvDecodePacket_XDS
#define prvDecodeFrame prvDecodeFrame_XDS
#define prvDecodeSubFrameTRANSCODE prvDecodeSubFrameTRANSCODE_XDS
#define prvDecodeSubFrame prvDecodeSubFrame_XDS
#define prvDecodeSubFrameHighRate prvDecodeSubFrameHighRate_XDS
#define prvDecodeFrameHeader prvDecodeFrameHeader_XDS
#define prvSetDetTable prvSetDetTable_XDS
#define prvDecodeFrameHeaderLpc prvDecodeFrameHeaderLpc_XDS
#define prvDecodeFrameHeaderNoiseSub prvDecodeFrameHeaderNoiseSub_XDS
#define prvGetNextRunDEC prvGetNextRunDEC_XDS
#define prvGetBandWeightLowRate prvGetBandWeightLowRate_XDS
#define prvUpdateSubFrameConfig prvUpdateSubFrameConfig_XDS
#define prvDecodeCoefficientMono prvDecodeCoefficientMono_XDS
#define prvDecodeCoefficientStereo prvDecodeCoefficientStereo_XDS
#define prvDecodeRunLevel prvDecodeRunLevel_XDS
#define prvAdaptEqToSubFrame prvAdaptEqToSubFrame_XDS
#define prvEqualize prvEqualize_XDS
#define prvComputeBandPower prvComputeBandPower_XDS




#include <math.h>
#include <limits.h>
#include "stdio.h"

#include "msaudio.h"
#include "strmdec_wma.h"

typedef enum {BEGIN_PACKET, BEGIN_FRAME, BEGIN_SUBFRAME, DECODE_SUBFRAME, END_SUBFRAME1, END_SUBFRAME2} DecodeStatus;
typedef enum {SUBFRM_HDR, SUBFRM_COEF, SUBFRM_DONE} SubFrmDecodeStatus;
typedef enum {HDR_SIZE, HDR_QUANT, HDR_NOISE1, HDR_NOISE2, HDR_MSKUPD, HDR_BARK, HDR_DONE} HdrDecodeStatus; //and a lot more
typedef enum {VLC, FRAME_END, NORMAL, ESCAPE} RunLevelStatus;

typedef struct CAudioObjectDecoder 
{
    CAudioObject* pau;
    //packetization stuff
    Bool  m_fPacketLoss;
    I16   m_cFrmInPacket;
    U8*   m_pbSrcCurr;  //ptr to src of curr packet, only for non-strm mode
    U16   m_cbSrcCurrLength; //only for non-strm mode
    DecodeStatus       m_decsts;
    SubFrmDecodeStatus m_subfrmdecsts;
    HdrDecodeStatus    m_hdrdecsts;
    RunLevelStatus     m_rlsts;
    I16                m_iChannel;  //current channel we are doing
    I16                m_iBand;     //current band we are doing
    Bool  m_fNoMoreData;

    Bool        m_fLastSubFrame;
    CWMAInputBitStream	m_ibstrm;

    //I don't think we need any of these now
    I16*        m_rgiRunEntry44ssQb;
    I16*        m_rgiLevelEntry44ssQb;
    I16*        m_rgiRunEntry44smQb;
    I16*        m_rgiLevelEntry44smQb;
    I16*        m_rgiRunEntry44ssOb;
    I16*        m_rgiLevelEntry44ssOb;
    I16*        m_rgiRunEntry44smOb;
    I16*        m_rgiLevelEntry44smOb;

    I16*        m_rgiRunEntry16ssOb;
    I16*        m_rgiLevelEntry16ssOb;
    I16*        m_rgiRunEntry16smOb;
    I16*        m_rgiLevelEntry16smOb;

#if 0
    UInt        m_rgiQuantStepFract[QUANTSTEP_DENOMINATOR - 1]; // Exclude numerator of 0
#endif	// !defined(SILSMOD)

#if defined(UNDER_CE) && defined(_ARM_)
    U32         lPrivate1;  // Used by ARMStub to keep track of ARM structures
    U32         lPrivate2;  // Used by ARMStub to keep track of current buffer pos
#endif

#ifdef ENABLE_EQUALIZER
#define MAX_NO_EQBAND 10
    Float       m_rgfltEqBandWeight[MAX_NO_EQBAND];
    U16         m_rgwEqBandBoundary[MAX_NO_EQBAND + 1];
    I8          m_cEqBand;
    Bool        m_fNoEq; 
    I8          m_rgbBandPower[MAX_NO_EQBAND];
    Bool        m_fComputeBandPower;
    Int         m_iEqFrameSize;
#endif // ENABLE_EQUALIZER

    WMARESULT (*m_pfnDecodeSubFrame) (struct CAudioObjectDecoder* paudec, Int* piBitCnt);
    WMARESULT (*m_pfnDecodeCoefficient) (struct CAudioObjectDecoder* paudec, PerChannelInfo* ppcinfo, Int* piBitCnt);	

} CAudioObjectDecoder;

#ifdef __cplusplus
extern "C" {  // only need to export C interface if
              // used by C++ source code
#endif
//public:
CAudioObjectDecoder* audecNew(void *pMemBuf, const I32 iMemBufSize);
Void audecDelete (CAudioObjectDecoder* paudec);

WMARESULT audecInit (
    CAudioObjectDecoder* paudec, 
    Int iVersionNumber,
    Int cSubband, 
    Int iSamplingRate, 
    U16 cChannel, 
    Int cBytePerSec, 
    Int cbPacketLength,
    U16 wEncodeOpt,
    U16 wPlayerOpt,
    PFNGETMOREDATA pfnGetMoreData,
    U32 dwUserData,
    I32 *piMemBufUsed);
WMARESULT audecReset (CAudioObjectDecoder* paudec);
WMARESULT audecFlush (
    CAudioObjectDecoder* paudec, 
    U8   *pbDst, 
    Int   cbDstLength,
    Int*  pcbDstUsed,
    U8*   pbEqu,
    Int   cbEquLength,
    Int*  pcbEquUsed,
    U32*  pcSamplesFromBefore);

U32 audecOutputBufferSize(Int iVersion, Int iSamplingRate, Int cChannels, Int cBytePerSec, U16 wEncodeOpt);

//streaming decoding interface
WMARESULT audecDecodeInfo (CAudioObjectDecoder* paudec);
WMARESULT audecDecodeData (CAudioObjectDecoder* paudec, U16* pcSampleReady);
WMARESULT audecGetPCM (CAudioObjectDecoder* paudec, U16* pcSampleReady, U8* pbDst, U32 cbDstLength);

// This function is optionally implemented by the user, but if the user opts for
// non-streaming mode, we supply a standard implementation. Streaming-mode callers
// MUST supply their own version of this function.
WMARESULT prvWMAGetMoreData(U8 **ppBuffer, U32 *pcbBuffer,
                            U32 dwUserData, U8* pDummy);

//alternative decoding interface
WMARESULT audecDecode (CAudioObjectDecoder* paudec, 
                     const U8*   pbSrc,
                     Int         cbSrcLength,
                     Int*        pcbSrcUsed,
                     U8*         pbDst,
                     Int         cbDstLength,
                     Int*        pcbDstUsed,
                     U8*         pbEqu,
                     Int         cbEqu,
                     Int*        pcbEquUsed,
                     I32*        pcSamplesFromBefore);

#ifdef ENABLE_EQUALIZER        	
WMARESULT audecSetEqualizer (CAudioObjectDecoder* paudec, Int iBand, Int iGainIndB);
WMARESULT audecResetEqualizer (CAudioObjectDecoder* paudec);  
Void    audecStartComputeBandPower (CAudioObjectDecoder* paudec);
Void    audecStopComputeBandPower (CAudioObjectDecoder* paudec);
WMARESULT audecGetBandPower (CAudioObjectDecoder* paudec, I8* rgbBandPower);
#endif //ENABLE_EQUALIZER
#ifdef __cplusplus
}
#endif

//private:
WMARESULT prvDecodePacket (CAudioObjectDecoder* paudec,
                           const U8*    pbSrc,
                           Int          cbSrcLength,
                           Int*         pcbSrcUsed,
                           U8*          pbDst,
                           Int          cbDstLength,
                           Int*         pcbDstUsed,
                           U8*          pbEqu,
                           Int          cbEquLength,
                           Int*         pcbEquUsed,
                           I32*         pcSamplesPrevPacket);
WMARESULT prvDecodeFrame (CAudioObjectDecoder* paudec,
                        const U8*   pbSrc, 
                        Int         cbSrcLength, 
                        Int*        pcbSrcUsed, 
                        I16*        piDst, 
                        Int         cbDstLength,
                        Int*        pcbDstUsed,
                        U8*         pbEqu,
                        Int         cbEquLength,
                        Int*        pcbEquUsed);

#ifdef TRANSCODER
WMARESULT prvDecodeSubFrameTRANSCODE(CAudioObjectDecoder *paudec, Int *piBitsUsed);
#endif  // TRANSCODER

WMARESULT prvDecodeSubFrame (CAudioObjectDecoder* paudec, Int* piBitCnt);
WMARESULT prvDecodeSubFrameHighRate (CAudioObjectDecoder* paudec, Int* piBitCnt);

WMARESULT prvDecodeFrameHeader (CAudioObjectDecoder* paudec, Int* piBitCnt);
Void    prvSetDetTable  (CAudioObjectDecoder* paudec,  PerChannelInfo* ppcinfo);
WMARESULT prvDecodeFrameHeaderLpc (CAudioObjectDecoder* paudec, Int* piBitCnt);
WMARESULT prvDecodeFrameHeaderNoiseSub (CAudioObjectDecoder* paudec, Int* piBitCnt);
WMARESULT prvGetNextRunDEC (Void* pvoid, PerChannelInfo* ppcinfo, Int *piBitCnt);

// Void    prvGetBandWeightMidRate (CAudioObjectDecoder* paudec);
Void    prvGetBandWeightLowRate (CAudioObjectDecoder* paudec);
WMARESULT prvUpdateSubFrameConfig (CAudioObjectDecoder* paudec, Int iSizeNext, Int iSizePrev, Int iSizeCurr);

WMARESULT prvDecodeCoefficientMono	
                (CAudioObjectDecoder* paudec, PerChannelInfo* ppcinfo, Int* piBitCnt);
WMARESULT prvDecodeCoefficientStereo 
                (CAudioObjectDecoder* paudec, PerChannelInfo* ppcinfo, Int* piBitCnt);
WMARESULT prvDecodeRunLevel  (CAudioObjectDecoder* paudec, PerChannelInfo* ppcinfo,
						      Int iCoefFirst, 
						      Int iCoefLim, 
                              Int* piBitCnt);

//equalize
Void    prvAdaptEqToSubFrame(CAudioObjectDecoder* paudec);
WMARESULT prvEqualize (CAudioObjectDecoder* paudec, PerChannelInfo* ppcinfo);
Void    prvComputeBandPower (CAudioObjectDecoder* paudec);

INLINE Int WMA_get_fNoMoreData(U32 hWMA)
{
    return ((CAudioObjectDecoder *)hWMA)->m_fNoMoreData;
}

INLINE Void WMA_set_fNoMoreData(U32 hWMA, Int iVal)
{
    ((CAudioObjectDecoder *)hWMA)->m_fNoMoreData = iVal;
}

INLINE U8 WMA_get_nHdrBits(U32 hWMA)
{
    const CAudioObject *pau = ((CAudioObjectDecoder *)hWMA)->pau;

    if (pau->m_fAllowSuperFrame)
        return (U8)(pau->m_cBitPackedFrameSize + NBITS_FRM_CNT + NBITS_PACKET_CNT + 3);
    else
        return 0;
}

#endif  //__MSAUDIODEC_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\wmalib\include\assert_wma.h ===
#ifdef UNDER_CE
// find this in windows CE include files
#ifdef _SH4_
#include <windef.h>
#include <kfuncs.h>
#include <dbgapi.h>
#endif

#ifdef assert
#undef assert
#endif
#define assert ASSERT

#else	// so not UNDER_CE

#include <assert.h>

#endif

#ifdef DISABLE_ASSERTS
#undef assert
#define assert(a)
#endif  // DISABLE_ASSERTS
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\wmalib\decoder\wmadec_api.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows Media
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       wmadec_api.h
//
//--------------------------------------------------------------------------


#ifndef _WMADEC_API_H_
#define _WMADEC_API_H_


typedef enum {
    WMADECERR_NOERROR = 0,     // no error, success

    WMADECERR_FAIL,            // (un-reasoned, generic) failure
    WMADECERR_OUTOFMEMORY,     // out of memory
    WMADECERR_INVALIDHANDLE,   // invalid handle
    WMADECERR_INVALIDPOINTER,  // invalid memory pointer

    WMADECERR_EOF,             // end of file
    WMADECERR_FILEREAD,        // failed in a file read operation

    WMADECERR_BUFTOOSMALL,     // buffer is too small for the operation
    WMADECERR_BUFTOOLARGE,     // buffer is too large for the operation

    WMADECERR_MAX              // guarding max barrier (not a valid error code)
} WMADECERROR;

// handle to be used for moving an instance
typedef void * WMADECHANDLE;

#ifdef __cplusplus
extern "C" {
#endif  // __cplusplus


/***************   Begin: NORMAL, NON-STREAMING MODE  *******************************/
// ===========================================================================
// WMADECCreate()
//
// Creates a Microsoft Audio decoder object and returns it.
//
// Input: nVersion         : version of the WMA
//        nSamplesPerSec   : sampling rate in Hz
//        nChannels        : number of channels (1 for mono and 2 for stereo)
//        nBytesPerSec     : bits per second times 8
//        nSamplesPerBlock : decoded samples per block (powers of 2)
//        nFrameLength     : encoded frame length in bytes
//        nEncodeOpt       : encoding mode option (0 or 1)
//        nPlayerOpt       : decoding mode, see defines below.
//
// Returns NULL if not successful.

WMADECHANDLE
WMADECCreate (long nVersion,
           long nSamplesPerSec,
           long nChannels,
           long nBytesPerSec,
           long nSamplesPerBlock,
           long nFrameLength,
           long nEncodeOpt,
           long nPlayerOpt);

// ===========================================================================
// Important notes on Player Options 
// These options change the sampling rate of the PCM data relative to the input bit stream sampling rate.
// 1. Downsample 32kHz to 22kHz only works if the bit stream sampling rate is 32kHz.
//    The PCM data returned will be at 22kHz.
// 2. Half Transform cuts the sampling rate in half so the PCM data will be at half the bit stream rate.
//    Normally use this to lower CPU requirements when playing in the background.
// 3. Upsample doubles the sampling rate and is used in conjunction with Downsample 32kHz to 22kHz
//    so DOWNSAMPLE32_22 | UPSAMPLE will result in the PCM data being at 44kHz.
//    Remember that your PCM buffer should be longer with this option.
// 4. Pad2x Transform doubles the sampling rate.  So a 22kHz bit stream will return PCM data at 44kHz.
//    Remember that your PCM buffer should be twice as long with this option.

#define PLAYOPT_DOWNSAMPLE32TO22 0x0001
#define PLAYOPT_HALFTRANSFORM    0x0002
#define PLAYOPT_UPSAMPLE         0x0004
#define PLAYOPT_PAD2XTRANSFORM   0x0008


// ===========================================================================
// WMADECDestroy()
//
// Destroys the given Microsoft Audio decoder handle.

WMADECERROR
WMADECDestroy(WMADECHANDLE hDecoder);


// ===========================================================================
// WMADECDecode()
//
// Decodes the memory block with the previous created handle.
//
// Input: pSrc      : pointer to the source buffer
//        nSrcLen   : size of the source buffer in bytes
//        pnSrcUsed : pointer to receive the actual number of source bytes
//                    used
//        pDst      : pointer to the destination buffer
//        nDstLen   : size of the destination buffer in bytes
//        pnDstUsed : pointer to receive the actual number of destination
//                    bytes used
//        pnSamplesFromBefore: number of samples used before the current packet

WMADECERROR WMADECDecode (
    WMADECHANDLE hDecoder,
    unsigned char *pSrc,
    unsigned long nSrcLen,
    unsigned long *pnSrcUsed,
    unsigned char *pDst,
    unsigned long nDstLen,
    unsigned long *pnDstUsed,
    unsigned long *pnSamplesFromBefore
);


// ===========================================================================
// WMADECFlush()
//
// Flushes out the internally buffered data, if any.
//
// Input: pDst      : pointer to the destination buffer
//        nDstLen   : size of the destination buffer in bytes
//        pnDstUsed : pointer to receive the actual number of destination
//                    bytes used

WMADECERROR
WMADECFlush(WMADECHANDLE hDecoder,
          unsigned char *pDst,
          unsigned long nDstLen,
          unsigned long *pnDstUsed);


// ===========================================================================
// WMADECOutputBufferSize()
//
// Returns the minimum Output Buffer Size for WMADECDecode.
//
// Input: nVersion         : version of the WMA
//        nSamplesPerSec   : sampling rate in Hz
//        nChannels        : number of channels (1 for mono and 2 for stereo)
//        nBytesPerSec     : bits per second times 8
//        nEncodeOpt       : encoding mode option (0 or 1)
//                    bytes used

unsigned long WMADECOutputBufferSize(long nVersion, 
                                     long nSamplingRate, 
                                     long nChannels, 
                                     long nBytesPerSec, 
                                     long nEncodeOpt);


/***************   End: NORMAL, NON-STREAMING MODE  *******************************/

#ifdef __cplusplus
}
#endif  // __cplusplus

#endif  // _MSAD_API_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\wmalib\decoder\wmadecS_api.h ===
#ifndef _WMADECRAW_API_H_
#define _WMADECRAW_API_H_


#ifndef _WMARESULT_DEFINED
#define _WMARESULT_DEFINED

typedef int WMARESULT;

// SUCCESS codes
static const WMARESULT WMA_OK               = 0x00000000;
static const WMARESULT WMA_S_FALSE          = 0x00000001;
static const WMARESULT WMA_S_BUFUNDERFLOW   = 0x00000002;
static const WMARESULT WMA_S_NEWPACKET      = 0x00000003;
static const WMARESULT WMA_S_NO_MORE_FRAME  = 0x00000004;
static const WMARESULT WMA_S_NO_MORE_SRCDATA= 0x00000005;

// ERROR codes
static const WMARESULT WMA_E_FAIL           = 0x80004005;
static const WMARESULT WMA_E_OUTOFMEMORY    = 0x8007000E;
static const WMARESULT WMA_E_INVALIDARG     = 0x80070057;
static const WMARESULT WMA_E_NOTSUPPORTED   = 0x80040000;
static const WMARESULT WMA_E_LOSTPACKET     = 0x80040001;
static const WMARESULT WMA_E_BROKEN_FRAME   = 0x80040002;
static const WMARESULT WMA_E_BUFFEROVERFLOW = 0x80040003;
static const WMARESULT WMA_E_ONHOLD         = 0x80040004; 

#define WMARAW_SUCCEEDED(Status) ((WMARESULT)(Status) >= 0)
#define WMARAW_FAILED(Status) ((WMARESULT)(Status)<0)

#endif // _WMARESULT_DEFINED


// define basic types
typedef unsigned long U32_WMARawDec;
typedef long I32_WMARawDec;
typedef unsigned short U16_WMARawDec;
typedef short I16_WMARawDec;
typedef unsigned char U8_WMARawDec;


typedef void* WMARawDecHandle;

#ifdef __cplusplus
extern "C" {
#endif  // __cplusplus


WMARESULT WMARawDecInit (
    WMARawDecHandle* phWMARawDec,
    U32_WMARawDec dwUserData,
    void * pfnGetMoreData,
    U16_WMARawDec iVersionNumber,
    U16_WMARawDec cSamplesPerBlock, 
    U16_WMARawDec cSamplesPerSecond, 
    U16_WMARawDec cChannel, 
    U16_WMARawDec cBytePerSec, 
    U16_WMARawDec cPacketLength,
    U16_WMARawDec cEncodeOpt,
    U16_WMARawDec cPlayerOpt
);

// **************************************************************************
// Player Options
// **************************************************************************
#define PLAYOPT_DOWNSAMPLE32TO22 0x0001
#define PLAYOPT_HALFTRANSFORM    0x0002
#define PLAYOPT_UPSAMPLE         0x0004
#define PLAYOPT_PAD2XTRANSFORM   0x0008

    
WMARESULT WMARawDecClose (WMARawDecHandle* phWMARawDec);
WMARESULT WMARawDecReset (WMARawDecHandle hWMARawDec);
WMARESULT WMARawDecStatus (WMARawDecHandle hWMARawDec);
WMARESULT WMARawDecDecodeData (WMARawDecHandle hWMARawDec);
WMARESULT WMARawDecGetPCM (WMARawDecHandle hWMARawDec, U16_WMARawDec* pcSampleReady, U8_WMARawDec* pbDst, U32_WMARawDec cbDstBufferLength);

extern WMARESULT WMARawDecCBGetData (U8_WMARawDec **ppBuffer, U32_WMARawDec* pcbBuffer, U32_WMARawDec dwUserData, U8_WMARawDec* pBufferExtra);
#ifdef __cplusplus
}
#endif  // __cplusplus


#endif // _WMADECRAW_API_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\wmalib\include\AutoProfile.h ===
#if !defined(_AUTO_PROFILE_INCLUDED_)
#define _AUTO_PROFILE_INCLUDED_

#if defined(PROFILE) 

#define WIN32_LEAN_AND_MEAN

#pragma warning( disable : 4103 4142 )
#include <windows.h>   
#pragma warning( default : 4103 4142 )
#include <stdlib.h>
#include <string.h>

#ifdef __cplusplus
extern "C" {
#endif

#define MAX_FUNCTIONS_TO_PROFILE 100

typedef struct  
{
    int id;
    TCHAR name[80];
}ProfileFunctionDeffinitionType;

extern ProfileFunctionDeffinitionType functionDefintions[MAX_FUNCTIONS_TO_PROFILE];
extern int Profiler_functionCountCalls[];


#define FFT_PROFILE 1
#define INVERSE_QUAN_HIGH_RATE_PROFILE 2
#define INVERSE_TRANSFORM_AND_RECON_PROFILE 3
#define INVERSE_OUANTIZE_SPECTRUM_PROFILE 4
#define DCTIV_PROFILE 5
#define POWER_TO_RMS_PROFILE 6 
#define ADAPT_TO_SUB_FRAME_CONFIG_PROFILE 7
#define INVERSE_TRANSFORM_MONO_PROFILE 8
#define DECODE_FRAME_HEADER_PROFILE 9
#define DECODE_COEFFICENT_MONO_PROFILE 10
#define DECODE_COEFFICENT_STEREO_PROFILE 11
#define DECODE_RUN_LEVEL_PROFILE 12
#define SET_DET_TABLE_PROFILE 13
#define DECODE_SUB_FRAME_PROFILE 14
#define UPDATE_SUB_FRAME_CONFIG_PROFILE 15
#define CALC_QUANT_STEP_PROFILE 16
#define DECODE_FRAME_PROFILE 17
#define DECODE_PACKET_PROFILE 18 
#define DECODE_PROFILE 19
#define CONVERT_SD_TO_LR_PROFILE 20
#define HUFF_DEC_GET_PROFILE 21
#define MSAC_DECODE_PROFILE 22
#define INVERSE_QUAN_HIGH_SDTOLR_PROFILE 23
#define SAVE_HISTORY_MONO_PROFILE 24

#define FRAME_HEADER_LPC_PROFILE 25
#define FRAME_HEADER_NOISE_SUB_PROFILE 26
#define GET_BAND_WEIGHTS_PROFILE 27
#define INVERSE_QUAN_LOW_RATE_PROFILE 28
#define INVERSE_QUAN_MID_RATE_PROFILE 29

#define WMA_FILE_DECODE_DATA_PROFILE 30
#define AU_GET_PCM_PROFILE 31
#define RECON_MONO_PROFILE 32
#define AUDEC_DECODE_DATA_PROFILE 33
#define WMA_FILE_GET_PCM_PROFILE 34
#define DECODE_COEFFICENTS_HIGH_RATE_PROFILE 35
#define DECODE_SUB_FRAME_HIGH_RATE_PROFILE 36
#define LPC_TO_SPECTRUM_PROFILE 37
#define FFT32_PROFILE 38

#if 1
#define Profiler_getTimer(ptime64) QueryPerformanceCounter((LARGE_INTEGER*)ptime64)
#else
__inline __int64 Profiler_getTimer(__int64 *time64)
{
    __int64 time;
    QueryPerformanceCounter((LARGE_INTEGER*)&time);
    *time64 = time;
    return time;
}
#endif
 
extern void Profiler_init(TCHAR* szFileName);
extern void Profiler_initEX(TCHAR* szFileName,int fAppend);
extern void Profiler_close();
extern void Profiler_closeEX(unsigned int Duration, DWORD TotalTime, TCHAR* szMsg);
extern void Profiler_print(TCHAR* szMsg);

typedef struct 
{
    __int64 StartTime;
    int functionIndex;
    void *parent;
}FunctionProfile;

extern __int64 Profiler_functionTimings[MAX_FUNCTIONS_TO_PROFILE];
extern __int64 Profiler_functionPlusChildTimings[MAX_FUNCTIONS_TO_PROFILE];
extern __int64 Profiler_totalTime;
extern __int64 profileStartTime;
extern HANDLE hProfile;
extern FunctionProfile *Profiler_lastFunctionProfiler;



void Profile_print(TCHAR* fmt);


__inline void FunctionProfileStart(FunctionProfile *fp, int FunctionID) 
{
    Profiler_getTimer(&fp->StartTime);
    fp->functionIndex = FunctionID;
    fp->parent = Profiler_lastFunctionProfiler;
    Profiler_lastFunctionProfiler = fp;
	Profiler_functionCountCalls[FunctionID]++;
};

__inline void FunctionProfileStop(FunctionProfile *fp){
    __int64 endTime;
    __int64 time;
    Profiler_getTimer(&endTime);
    time = (int)(endTime-fp->StartTime);
    
    Profiler_functionTimings[fp->functionIndex] += time;

    if (fp->parent != NULL) {
        Profiler_functionTimings[((FunctionProfile*)(fp->parent))->functionIndex] -= time;
    } else {
        Profiler_totalTime+=time; 
    }

    Profiler_functionPlusChildTimings[fp->functionIndex] += time;
    Profiler_lastFunctionProfiler = ((FunctionProfile*)(fp->parent));
}

#define FUNCTION_PROFILE(fp) FunctionProfile fp;
#define FUNCTION_PROFILE_START(fp,id) FunctionProfileStart(fp,id)
#define FUNCTION_PROFILE_STOP(fp) FunctionProfileStop(fp)

#ifdef __cplusplus
}
#endif

#else	// !PROFILE

#define FUNCTION_PROFILE(fp)
#define FUNCTION_PROFILE_START(fp,id)
#define FUNCTION_PROFILE_STOP(fp)

#endif	// !PROFILE

#endif  // !defined(_AUTO_PROFILE_INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\wmalib\include\cpudetect.h ===
/*************************************************************************

Copyright (C) 1996 -- 1998  Microsoft Corporation

Module Name:

	CPUDetect.h

Abstract:

	Several CPU detection utilities. For non-X86, false is always returned.

Author:

    Raych, Wchen

Revision History:

*************************************************************************/

#ifndef __CPUDETECT_H_
#define __CPUDETECT_H_

#ifndef macintosh
Bool g_SupportMMX(void);
#endif
Bool g_SupportKNI(void);
Bool g_SupportSIMD_FP(void);
Bool g_SupportCMOV(void);

#endif // __CPUDETECT_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\wmalib\include\config.h ===
#ifndef __CONFIG_H__
#define __CONFIG_H__

#ifndef EXTERN_C
#ifdef __cplusplus
#define EXTERN_C extern "C"
#else 
#define EXTERN_C extern 
#endif
#endif

// The XxxGetXxxXxx funstions below are used to enumerate supported parameter
// combinations.  ulIndex is a 0-based index, the funtions return FALSE if it
// is out of range.
//
// The XxxCheckXxxXxx functions return TRUE if the parameter combination is
// supported, FALSE otherwise.

typedef struct _WMAFormatInfo {
    // base WAVEFORMATEX
    U32 nSamplesPerSec;
    U32 nChannels;
    U32 nAvgBytesPerSec;
    U32 nBlockAlign;
#if defined (WMA_V9)
    U32 nBytePerSample;
    U16 nValidBitsPerSample;    /* bits of precision */
    U32 nChannelMask;         /* which channels are present in stream */
#endif // WMA_V9
    // extended WAVEFORMATES
    U32 nSamplesPerBlock;
    U32 dwSuperBlockAlign;
    U16 wEncodeOptions;

    // miscellaneous
    U32 nFramesPerPacket;
    U32 nSamplesPerFrame;
    U32 nMaxSamplesPerPacket;
    U32 nLookaheadSamples;
    U32 nSuperFrameSamples; // useless ?
    U32 ulOfficialBitrate;
} WMAFormatInfo;

#ifdef __cplusplus
extern "C" {
#endif

   // Checks if the codec can encode this PCM at all (at at least some bitrate)
Bool CheckPCMParams(U32 ulSamplingRate, U32 ulChannels);
// Enumerate all of the channels / sampling combinations supported at any bitrate
Bool GetPCMParamsByIndex(U32 ulIndex, U32 *pulSamplingRate, U32 *pulChannels);


//
// For the GetXxxXxx functions, the entire WMAFormatInfo is an output parameter.
// For CheckFormat, the WAVEFORMATEX stuff is input and the miscellaneous fields
// at the end are output.
//

// Enumerates all of the output formats, regardless if input.  Normal formats
// are enumerated first, followed by the special ASF AV Interleave versions of
// formats that cannot be interleaved in their normal form.
Bool GetFormatByIndex(U32 ulIndex, Bool fIncludeASFAVInterleaveSpecial, WMAFormatInfo* pFormat);
// Total number of formants enumerated by GetFormatByIndex
U32 TotalFormatCount(Bool fIncludeASFAVInterleaveSpecial);

// This is for when you know the input sampling rate and the number of channels
// and want to enumerate all possible output formats.  Normal formats are
// enumerated first, followed by the special ASF AV Interleave versions.
Bool GetFormatByPCMParamsAndIndex(U32 ulIndex, U32 ulSamplingRate, U32 ulChannels, Bool fIncludeASFAVInterleaveSpecial, WMAFormatInfo* pFormat);

// If you know the sampling rate / channels AND the approximate bitrate you
// want, call this to get the corresponding WMAFormatInfo parameters.
EXTERN_C Bool GetFormatByPCMParamsAndBitrate(U32 ulSamplingRate, 
                                             U32 ulChannels, 
#if defined (WMA_V9)
                                             U32 nBytePerSample,
                                             U16 nValidBitsPerSample,
                                             U32 nChannelMask,
#endif // WMA_V9
                                             U32 ulBitrate, Bool fASFAVInterleave, WMAFormatInfo* pFormat);

// Only the following members of pSrcFormat are used:
// nSamplesPerSec, nChannels, nAvgBytesPerSec, nBlockAlign,
// nSamplesPerBlock, dwSuperBlockAlign, wEncodeOptions
Bool GetTranscodeDstFormatByIndex(const WMAFormatInfo* pSrcFormat,
                                  const U32 ulIndex,
                                  WMAFormatInfo* pDstFormat);


#ifdef __cplusplus
}
#endif


#endif //__CONFIG_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\wmalib\include\msaudiofmt.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       msaudiofmt.h
//
//--------------------------------------------------------------------------

/* msaudiofmt.h */

#ifndef _MSAUDIO_FMT_H
#define _MSAUDIO_FMT_H

//NQF+, 120199
#ifndef macintosh
#include "../common/macros.h"
#else
#include "macros.h"
#endif
//NQF-

#ifndef RC_INVOKED              // from mmreg.h
#pragma COMPILER_PACKALIGN(1)	// Assume byte packing throughout
#endif  // RC_INVOKED

// ======================================================================
// Windows Media Audio (common)


#define MM_MSFT_ACM_WMAUDIO  39

#define WMAUDIO_BITS_PER_SAMPLE    16 // just an uncompressed size...
#define WMAUDIO_MAX_CHANNELS       2


// ======================================================================
// Windows Media Audio V1 (a.k.a. "MSAudio")

#define WAVE_FORMAT_MSAUDIO1  0x0160
#define MM_MSFT_ACM_MSAUDIO1  39

typedef struct msaudio1waveformat_tag {
    WAVEFORMATEX wfx;
    U16          wSamplesPerBlock; // only counting "new" samples "= half of what will be used due to overlapping
    U16          wEncodeOptions;
} MSAUDIO1WAVEFORMAT;

typedef MSAUDIO1WAVEFORMAT *LPMSAUDIO1WAVEFORMAT;

#define MSAUDIO1_BITS_PER_SAMPLE    WMAUDIO_BITS_PER_SAMPLE
#define MSAUDIO1_MAX_CHANNELS       WMAUDIO_MAX_CHANNELS
#define MSAUDIO1_WFX_EXTRA_BYTES    (sizeof(MSAUDIO1WAVEFORMAT) - sizeof(WAVEFORMATEX))


// ======================================================================
// Windows Media Audio V2

#define WAVE_FORMAT_WMAUDIO2  0x0161
#define MM_MSFT_ACM_WMAUDIO2  101

typedef struct wmaudio2waveformat_tag {
    WAVEFORMATEX wfx;
    U32          dwSamplesPerBlock; // only counting "new" samples "= half of what will be used due to overlapping
    U16          wEncodeOptions;
    U32          dwSuperBlockAlign; // the big size...  should be multiples of wfx.nBlockAlign.
} WMAUDIO2WAVEFORMAT;

typedef WMAUDIO2WAVEFORMAT *LPWMAUDIO2WAVEFORMAT;

#define WMAUDIO2_BITS_PER_SAMPLE    WMAUDIO_BITS_PER_SAMPLE
#define WMAUDIO2_MAX_CHANNELS       WMAUDIO_MAX_CHANNELS
#define WMAUDIO2_WFX_EXTRA_BYTES    (sizeof(WMAUDIO2WAVEFORMAT) - sizeof(WAVEFORMATEX))

#ifndef RC_INVOKED              // from mmreg.h
#pragma COMPILER_PACKALIGN_DEFAULT	// Revert to default packing
#endif  // RC_INVOKED

#endif /* !_MSAUDIO_FMT_H */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\wmalib\win32\win32.h ===
/*************************************************************************

Copyright (C) Microsoft Corporation, 1996 - 1999

Module Name:

    Win32.h

Abstract:

    Win32-specific data structures.

Author:

    Raymond Cheng (raych)       Aug 25, 1999

Revision History:


*************************************************************************/


#ifndef _WMA_OS_WIN32_H_
#define _WMA_OS_WIN32_H_

// Verify that our target is a WIN32 machine
#ifndef WMA_OSTARGET_WIN32
#error This header file does not match the currently select OS target
#endif

#include <xtl.h>

// **************************************************************************
// COMMON FUNCTIONS
// **************************************************************************
#include "macros.h"



// **************************************************************************
// ENCODER FUNCTIONS
// **************************************************************************

#ifdef ENCODER

// Following functions are for non-serialized code only
#ifndef WMA_SERIALIZE
typedef void *HANDLE; // Stolen from WinNT.h

// Type declaration
typedef struct CAudioObjectEncoder CAudioObjectEncoder;

typedef struct THREADINFO
{
    HANDLE m_hEncEvent0, m_hEncDone0;
    HANDLE m_hEncEvent1, m_hEncDone1;
    HANDLE m_hThreadEnc0, m_hThreadEnc1;
    Bool   m_bShutdownThreads;
    Bool   m_fMultiProc;
    CAudioObjectEncoder *m_pauenc;
} THREADINFO;
#endif  // !WMA_SERIALZE
#endif  // ENCODER


// **************************************************************************
// WinCE FUNCTIONS
// **************************************************************************
// time and clock are not available in WinCE.  Provide them.

#ifdef UNDER_CE
#	ifndef _TIME_T_DEFINED
		typedef long time_t;        /* time value */
#		define _TIME_T_DEFINED     /* avoid multiple def's of time_t */
#	endif
#	ifndef _CLOCK_T_DEFINED
		typedef long clock_t;
#		define _CLOCK_T_DEFINED
#	endif
#	ifndef CLOCKS_PER_SEC
#		define CLOCKS_PER_SEC  1000
#	endif

#ifdef __cplusplus
extern "C"
#endif  // __cplusplus
	clock_t __cdecl clock(void);

#ifdef __cplusplus
extern "C"
#endif  // __cplusplus
	time_t __cdecl time(time_t * pt);

#endif

// **************************************************************************
// MACROS
// **************************************************************************

//-------------------------------------------------------
#ifdef PLATFORM_SPECIFIC_DEBUGBREAK
// Normally we do NOT provide function prototypes here, because win32 fns are
// usually confined to individual files such as win32.c. In such a case, we include
// windows.h or ansiwin.h in that file only, and save ourselves a LOT of compilation time.
// DebugBreak is widespread and therefore we break the rule and prototype it here.

#ifdef __cplusplus
extern "C"
#endif  // __cplusplus
__declspec(dllimport) void __stdcall DebugBreak(void); // From winbase.h

#define DEBUG_BREAK()   DebugBreak()
#endif  // PLATFORM_SPECIFIC_DEBUGBREAK


#endif  // _WMA_OS_WIN32_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\wmalib\include\int64.h ===
#ifndef _PRVINT64_
#define _PRVINT64_

typedef struct _INT64 { 
    unsigned long val[2];
} INT64;

typedef struct _UINT64 {   
    unsigned long val[2];
} UINT64;
#else
typedef struct _INT64 { 
    unsigned char val[8];
} INT64;

typedef struct _UINT64 {   
    unsigned char val[8];
} UINT64;
           
extern INT64 I64Add(const INT64 a, const INT64 b);
extern INT64 I64Sub(const INT64 a, const INT64 b);
extern INT64 I64Mul(const INT64 a, const INT64 b);
extern INT64 I64DIV(const INT64 a, const INT64 b);
extern INT64 I64MOD(const INT64 a, const INT64 b);
extern INT64 I64AND(const INT64 a, const INT64 b);
extern INT64 I64SHR(const INT64 a, const int unsigned b);
extern INT64 I64SHL(const INT64 a, const int unsigned b);
extern int   I64EQL(const INT64 a, const INT64 b);
extern int   I64LES(const INT64 a, const INT64 b);
extern INT64 I64(const long int b);
extern INT64 I64Asgn(const long int a, const long int b);
extern INT64 UI2I64(const UINT64 b);
extern unsigned long int I64toUI32(const INT64 b);

extern UINT64 UI64Add(const UINT64 a, const UINT64 b);
extern UINT64 UI64Sub(const UINT64 a, const UINT64 b);
extern UINT64 UI64Mul(const UINT64 a, const UINT64 b);
extern UINT64 UI64DIV(const UINT64 a, const UINT64 b);
extern UINT64 UI64MOD(const UINT64 a, const UINT64 b);
extern UINT64 UI64AND(const UINT64 a, const UINT64 b);
extern UINT64 UI64SHR(const UINT64 a, const unsigned int b);
extern UINT64 UI64SHL(const UINT64 a, const unsigned int b);
extern int    UI64EQL(const UINT64 a, const UINT64 b);
extern int    UI64LES(const UINT64 a, const UINT64 b);
extern UINT64 UI64(const unsigned long int b);
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\wmalib\wmadec_s\dectables.c ===
#pragma code_seg("WMADEC")
#pragma data_seg("WMADEC_RW")
#pragma const_seg("WMADEC_RD")

#include "DecTables.h"
#include "huffDTbl.c"
#include "macros.h"  //for FastFloat && NF2BP1
#include "..\..\..\dsound\dsndver.h"
                   
#define F2BP1 NF2BP1

#ifdef USE_SIN_COS_TABLES

/*
g_SinTableForReconstruction can be built with the following code. 

#ifdef BUILD_INTEGER
#   define SHUFFLE_BITS(x) ((((x)>>16)&0xFFFF) | (((x)<<15)&0xFFFF0000))
#else 
#   define SHUFFLE_BITS(x) x
#endif

    for (i = 0; i < 1024; i++) pau->m_piSinForRecon2048[i] = SHUFFLE_BITS( BP2_FROM_FLOAT( -(sin ((0.5+i) * PI / 2048 / 2))));
    for (     ; i < 2048; i++) pau->m_piSinForRecon2048[i] = SHUFFLE_BITS( BP2_FROM_FLOAT(  (sin ((0.5+i) * PI / 2048 / 2))));
    for (i = 0; i < 512 ; i++) pau->m_piSinForRecon1024[i] = SHUFFLE_BITS( BP2_FROM_FLOAT( -(sin ((0.5+i) * PI / 1024 / 2))));
    for (     ; i < 1024; i++) pau->m_piSinForRecon1024[i] = SHUFFLE_BITS( BP2_FROM_FLOAT(  (sin ((0.5+i) * PI / 1024 / 2))));
    for (i = 0; i < 256 ; i++) pau->m_piSinForRecon512 [i] = SHUFFLE_BITS( BP2_FROM_FLOAT( -(sin ((0.5+i) * PI / 512  / 2))));
    for (     ; i < 512 ; i++) pau->m_piSinForRecon512 [i] = SHUFFLE_BITS( BP2_FROM_FLOAT(  (sin ((0.5+i) * PI / 512  / 2))));
    for (i = 0; i < 128 ; i++) pau->m_piSinForRecon256 [i] = SHUFFLE_BITS( BP2_FROM_FLOAT( -(sin ((0.5+i) * PI / 256  / 2))));
    for (     ; i < 256 ; i++) pau->m_piSinForRecon256 [i] = SHUFFLE_BITS( BP2_FROM_FLOAT(  (sin ((0.5+i) * PI / 256  / 2))));
    for (i = 0; i < 64  ; i++) pau->m_piSinForRecon128 [i] = SHUFFLE_BITS( BP2_FROM_FLOAT( -(sin ((0.5+i) * PI / 128  / 2))));
    for (     ; i < 128 ; i++) pau->m_piSinForRecon128 [i] = SHUFFLE_BITS( BP2_FROM_FLOAT(  (sin ((0.5+i) * PI / 128  / 2))));
    for (i = 0; i < 32  ; i++) pau->m_piSinForRecon64  [i] = SHUFFLE_BITS( BP2_FROM_FLOAT( -(sin ((0.5+i) * PI / 64   / 2))));
    for (     ; i < 64  ; i++) pau->m_piSinForRecon64  [i] = SHUFFLE_BITS( BP2_FROM_FLOAT(  (sin ((0.5+i) * PI / 64   / 2))));
*/
     
#ifdef BUILD_INT_FLOAT  
//Note: These numbers are float numbers represented in there hex format. These numbers
//      should be aligned on a 32byte boundary when the compiler supports it. When this
//      is done the appropriate mouvps in auReconStereo_SIMDFP is changed to movaps.
const Int g_SinTableForReconstruction[(2048+1024+512+256+128+64)] = {
0xB9C90FDA,0xBA96CBE2,0xBAFB53C7,0xBB2FEDD1,0xBB6231B9,0xBB8A3ACB,0xBBA35CB5,0xBBBC7E99,
0xBBD5A075,0xBBEEC249,0xBC03F20A,0xBC1082EA,0xBC1D13C5,0xBC29A49A,0xBC363568,0xBC42C62F,
0xBC4F56EF,0xBC5BE7A6,0xBC687856,0xBC7508FC,0xBC80CCCC,0xBC871516,0xBC8D5D5A,0xBC93A599,
0xBC99EDD2,0xBCA03605,0xBCA67E32,0xBCACC658,0xBCB30E78,0xBCB95691,0xBCBF9EA3,0xBCC5E6AD,
0xBCCC2EB0,0xBCD276AB,0xBCD8BE9E,0xBCDF0688,0xBCE54E6A,0xBCEB9643,0xBCF1DE13,0xBCF825DA,
0xBCFE6D97,0xBD025AA5,0xBD057E7A,0xBD08A249,0xBD0BC613,0xBD0EE9D8,0xBD120D97,0xBD153151,
0xBD185505,0xBD1B78B3,0xBD1E9C5B,0xBD21BFFD,0xBD24E399,0xBD28072E,0xBD2B2ABD,0xBD2E4E45,
0xBD3171C6,0xBD349541,0xBD37B8B5,0xBD3ADC22,0xBD3DFF87,0xBD4122E5,0xBD44463C,0xBD47698B,
0xBD4A8CD2,0xBD4DB012,0xBD50D34A,0xBD53F679,0xBD5719A1,0xBD5A3CC0,0xBD5D5FD7,0xBD6082E5,
0xBD63A5EA,0xBD66C8E7,0xBD69EBDB,0xBD6D0EC6,0xBD7031A8,0xBD735480,0xBD76774F,0xBD799A15,
0xBD7CBCD1,0xBD7FDF83,0xBD818116,0xBD831265,0xBD84A3AF,0xBD8634F4,0xBD87C634,0xBD89576E,
0xBD8AE8A4,0xBD8C79D4,0xBD8E0AFE,0xBD8F9C23,0xBD912D43,0xBD92BE5D,0xBD944F71,0xBD95E07F,
0xBD977188,0xBD99028B,0xBD9A9388,0xBD9C247F,0xBD9DB570,0xBD9F465B,0xBDA0D740,0xBDA2681F,
0xBDA3F8F7,0xBDA589C9,0xBDA71A95,0xBDA8AB5A,0xBDAA3C19,0xBDABCCD1,0xBDAD5D83,0xBDAEEE2D,
0xBDB07ED2,0xBDB20F6F,0xBDB3A005,0xBDB53095,0xBDB6C11D,0xBDB8519F,0xBDB9E219,0xBDBB728C,
0xBDBD02F8,0xBDBE935D,0xBDC023BA,0xBDC1B410,0xBDC3445F,0xBDC4D4A6,0xBDC664E5,0xBDC7F51D,
0xBDC9854D,0xBDCB1575,0xBDCCA596,0xBDCE35AE,0xBDCFC5BF,0xBDD155C7,0xBDD2E5C8,0xBDD475C0,
0xBDD605B0,0xBDD79598,0xBDD92578,0xBDDAB54F,0xBDDC451E,0xBDDDD4E4,0xBDDF64A2,0xBDE0F457,
0xBDE28403,0xBDE413A7,0xBDE5A342,0xBDE732D4,0xBDE8C25D,0xBDEA51DE,0xBDEBE155,0xBDED70C3,
0xBDEF0028,0xBDF08F83,0xBDF21ED6,0xBDF3AE1F,0xBDF53D5F,0xBDF6CC95,0xBDF85BC2,0xBDF9EAE5,
0xBDFB79FE,0xBDFD090E,0xBDFE9814,0xBE001388,0xBE00DB01,0xBE01A276,0xBE0269E5,0xBE03314F,
0xBE03F8B4,0xBE04C014,0xBE05876F,0xBE064EC5,0xBE071616,0xBE07DD61,0xBE08A4A7,0xBE096BE8,
0xBE0A3324,0xBE0AFA5A,0xBE0BC18B,0xBE0C88B6,0xBE0D4FDC,0xBE0E16FD,0xBE0EDE18,0xBE0FA52E,
0xBE106C3E,0xBE113349,0xBE11FA4E,0xBE12C14D,0xBE138847,0xBE144F3B,0xBE151629,0xBE15DD11,
0xBE16A3F4,0xBE176AD1,0xBE1831A8,0xBE18F879,0xBE19BF45,0xBE1A860A,0xBE1B4CCA,0xBE1C1383,
0xBE1CDA36,0xBE1DA0E4,0xBE1E678B,0xBE1F2E2C,0xBE1FF4C8,0xBE20BB5C,0xBE2181EB,0xBE224874,
0xBE230EF6,0xBE23D572,0xBE249BE7,0xBE256257,0xBE2628C0,0xBE26EF22,0xBE27B57E,0xBE287BD4,
0xBE294223,0xBE2A086B,0xBE2ACEAE,0xBE2B94E9,0xBE2C5B1E,0xBE2D214C,0xBE2DE773,0xBE2EAD94,
0xBE2F73AE,0xBE3039C2,0xBE30FFCE,0xBE31C5D4,0xBE328BD3,0xBE3351CB,0xBE3417BC,0xBE34DDA6,
0xBE35A389,0xBE366965,0xBE372F3A,0xBE37F508,0xBE38BACF,0xBE39808F,0xBE3A4647,0xBE3B0BF9,
0xBE3BD1A3,0xBE3C9746,0xBE3D5CE2,0xBE3E2276,0xBE3EE804,0xBE3FAD89,0xBE407308,0xBE41387F,
0xBE41FDEE,0xBE42C356,0xBE4388B7,0xBE444E10,0xBE451361,0xBE45D8AB,0xBE469DED,0xBE476328,
0xBE48285A,0xBE48ED85,0xBE49B2A9,0xBE4A77C4,0xBE4B3CD8,0xBE4C01E4,0xBE4CC6E8,0xBE4D8BE4,
0xBE4E50D9,0xBE4F15C5,0xBE4FDAA9,0xBE509F86,0xBE51645A,0xBE522926,0xBE52EDEA,0xBE53B2A6,
0xBE54775A,0xBE553C06,0xBE5600A9,0xBE56C544,0xBE5789D7,0xBE584E62,0xBE5912E4,0xBE59D75E,
0xBE5A9BCF,0xBE5B6038,0xBE5C2499,0xBE5CE8F1,0xBE5DAD40,0xBE5E7187,0xBE5F35C6,0xBE5FF9FC,
0xBE60BE29,0xBE61824D,0xBE624669,0xBE630A7C,0xBE63CE87,0xBE649288,0xBE655681,0xBE661A71,
0xBE66DE58,0xBE67A236,0xBE68660B,0xBE6929D8,0xBE69ED9B,0xBE6AB155,0xBE6B7506,0xBE6C38AF,
0xBE6CFC4E,0xBE6DBFE3,0xBE6E8370,0xBE6F46F4,0xBE700A6E,0xBE70CDDF,0xBE719147,0xBE7254A5,
0xBE7317FA,0xBE73DB46,0xBE749E88,0xBE7561C1,0xBE7624F1,0xBE76E817,0xBE77AB33,0xBE786E46,
0xBE79314F,0xBE79F44F,0xBE7AB745,0xBE7B7A31,0xBE7C3D14,0xBE7CFFED,0xBE7DC2BC,0xBE7E8582,
0xBE7F483D,0xBE800578,0xBE8066CC,0xBE80C81B,0xBE812965,0xBE818AAA,0xBE81EBEA,0xBE824D25,
0xBE82AE5B,0xBE830F8C,0xBE8370B8,0xBE83D1DF,0xBE843300,0xBE84941D,0xBE84F535,0xBE855647,
0xBE85B755,0xBE86185D,0xBE867960,0xBE86DA5D,0xBE873B56,0xBE879C49,0xBE87FD38,0xBE885E21,
0xBE88BF04,0xBE891FE3,0xBE8980BC,0xBE89E190,0xBE8A425E,0xBE8AA327,0xBE8B03EB,0xBE8B64AA,
0xBE8BC563,0xBE8C2616,0xBE8C86C5,0xBE8CE76D,0xBE8D4811,0xBE8DA8AF,0xBE8E0947,0xBE8E69DB,
0xBE8ECA68,0xBE8F2AF0,0xBE8F8B73,0xBE8FEBF0,0xBE904C67,0xBE90ACD9,0xBE910D45,0xBE916DAC,
0xBE91CE0D,0xBE922E69,0xBE928EBF,0xBE92EF0F,0xBE934F59,0xBE93AF9E,0xBE940FDD,0xBE947017,
0xBE94D04B,0xBE953079,0xBE9590A1,0xBE95F0C3,0xBE9650E0,0xBE96B0F7,0xBE971108,0xBE977113,
0xBE97D119,0xBE983118,0xBE989112,0xBE98F106,0xBE9950F4,0xBE99B0DC,0xBE9A10BE,0xBE9A709A,
0xBE9AD070,0xBE9B3041,0xBE9B900B,0xBE9BEFCF,0xBE9C4F8D,0xBE9CAF46,0xBE9D0EF8,0xBE9D6EA4,
0xBE9DCE4A,0xBE9E2DEA,0xBE9E8D84,0xBE9EED18,0xBE9F4CA5,0xBE9FAC2D,0xBEA00BAE,0xBEA06B29,
0xBEA0CA9E,0xBEA12A0D,0xBEA18976,0xBEA1E8D8,0xBEA24834,0xBEA2A78A,0xBEA306DA,0xBEA36623,
0xBEA3C566,0xBEA424A3,0xBEA483D9,0xBEA4E309,0xBEA54233,0xBEA5A156,0xBEA60073,0xBEA65F89,
0xBEA6BE99,0xBEA71DA3,0xBEA77CA6,0xBEA7DBA3,0xBEA83A99,0xBEA89989,0xBEA8F872,0xBEA95755,
0xBEA9B631,0xBEAA1507,0xBEAA73D6,0xBEAAD29F,0xBEAB3161,0xBEAB901C,0xBEABEED1,0xBEAC4D7F,
0xBEACAC27,0xBEAD0AC7,0xBEAD6962,0xBEADC7F5,0xBEAE2682,0xBEAE8508,0xBEAEE387,0xBEAF4200,
0xBEAFA072,0xBEAFFEDD,0xBEB05D41,0xBEB0BB9F,0xBEB119F5,0xBEB17845,0xBEB1D68E,0xBEB234D0,
0xBEB2930C,0xBEB2F140,0xBEB34F6E,0xBEB3AD94,0xBEB40BB4,0xBEB469CD,0xBEB4C7DE,0xBEB525E9,
0xBEB583ED,0xBEB5E1EA,0xBEB63FE0,0xBEB69DCE,0xBEB6FBB6,0xBEB75997,0xBEB7B770,0xBEB81543,
0xBEB8730E,0xBEB8D0D3,0xBEB92E90,0xBEB98C46,0xBEB9E9F5,0xBEBA479D,0xBEBAA53D,0xBEBB02D6,
0xBEBB6069,0xBEBBBDF4,0xBEBC1B77,0xBEBC78F4,0xBEBCD669,0xBEBD33D7,0xBEBD913D,0xBEBDEE9D,
0xBEBE4BF5,0xBEBEA945,0xBEBF068F,0xBEBF63D0,0xBEBFC10B,0xBEC01E3E,0xBEC07B6A,0xBEC0D88E,
0xBEC135AB,0xBEC192C0,0xBEC1EFCE,0xBEC24CD5,0xBEC2A9D4,0xBEC306CB,0xBEC363BB,0xBEC3C0A4,
0xBEC41D85,0xBEC47A5E,0xBEC4D730,0xBEC533FA,0xBEC590BD,0xBEC5ED77,0xBEC64A2B,0xBEC6A6D6,
0xBEC7037B,0xBEC76017,0xBEC7BCAC,0xBEC81938,0xBEC875BE,0xBEC8D23B,0xBEC92EB1,0xBEC98B1F,
0xBEC9E785,0xBECA43E4,0xBECAA03A,0xBECAFC89,0xBECB58D0,0xBECBB50F,0xBECC1147,0xBECC6D76,
0xBECCC99E,0xBECD25BE,0xBECD81D5,0xBECDDDE5,0xBECE39ED,0xBECE95ED,0xBECEF1E5,0xBECF4DD5,
0xBECFA9BD,0xBED0059D,0xBED06175,0xBED0BD45,0xBED1190D,0xBED174CD,0xBED1D085,0xBED22C34,
0xBED287DC,0xBED2E37C,0xBED33F13,0xBED39AA2,0xBED3F629,0xBED451A8,0xBED4AD1F,0xBED5088D,
0xBED563F3,0xBED5BF52,0xBED61AA7,0xBED675F5,0xBED6D13A,0xBED72C77,0xBED787AC,0xBED7E2D8,
0xBED83DFC,0xBED89918,0xBED8F42C,0xBED94F37,0xBED9AA39,0xBEDA0533,0xBEDA6025,0xBEDABB0F,
0xBEDB15F0,0xBEDB70C8,0xBEDBCB98,0xBEDC2660,0xBEDC811F,0xBEDCDBD6,0xBEDD3684,0xBEDD912A,
0xBEDDEBC7,0xBEDE465B,0xBEDEA0E7,0xBEDEFB6A,0xBEDF55E5,0xBEDFB057,0xBEE00AC1,0xBEE06522,
0xBEE0BF7A,0xBEE119C9,0xBEE17410,0xBEE1CE4E,0xBEE22884,0xBEE282B1,0xBEE2DCD5,0xBEE336F0,
0xBEE39102,0xBEE3EB0C,0xBEE4450D,0xBEE49F05,0xBEE4F8F5,0xBEE552DB,0xBEE5ACB9,0xBEE6068E,
0xBEE6605A,0xBEE6BA1D,0xBEE713D7,0xBEE76D88,0xBEE7C731,0xBEE820D0,0xBEE87A66,0xBEE8D3F4,
0xBEE92D78,0xBEE986F4,0xBEE9E066,0xBEEA39D0,0xBEEA9330,0xBEEAEC88,0xBEEB45D6,0xBEEB9F1C,
0xBEEBF858,0xBEEC518B,0xBEECAAB5,0xBEED03D6,0xBEED5CEE,0xBEEDB5FC,0xBEEE0F02,0xBEEE67FE,
0xBEEEC0F1,0xBEEF19DB,0xBEEF72BC,0xBEEFCB93,0xBEF02461,0xBEF07D26,0xBEF0D5E2,0xBEF12E94,
0xBEF1873D,0xBEF1DFDD,0xBEF23873,0xBEF29100,0xBEF2E984,0xBEF341FE,0xBEF39A6F,0xBEF3F2D7,
0xBEF44B35,0xBEF4A38A,0xBEF4FBD5,0xBEF55417,0xBEF5AC50,0xBEF6047F,0xBEF65CA4,0xBEF6B4C0,
0xBEF70CD3,0xBEF764DC,0xBEF7BCDB,0xBEF814D1,0xBEF86CBD,0xBEF8C4A0,0xBEF91C79,0xBEF97449,
0xBEF9CC0E,0xBEFA23CB,0xBEFA7B7D,0xBEFAD326,0xBEFB2AC6,0xBEFB825B,0xBEFBD9E7,0xBEFC3169,
0xBEFC88E2,0xBEFCE051,0xBEFD37B6,0xBEFD8F11,0xBEFDE662,0xBEFE3DAA,0xBEFE94E8,0xBEFEEC1C,
0xBEFF4346,0xBEFF9A67,0xBEFFF17D,0xBF002445,0xBF004FC6,0xBF007B43,0xBF00A6BA,0xBF00D22D,
0xBF00FD9A,0xBF012903,0xBF015467,0xBF017FC5,0xBF01AB1F,0xBF01D674,0xBF0201C3,0xBF022D0E,
0xBF025853,0xBF028394,0xBF02AED0,0xBF02DA06,0xBF030537,0xBF033064,0xBF035B8B,0xBF0386AE,
0xBF03B1CB,0xBF03DCE3,0xBF0407F6,0xBF043304,0xBF045E0D,0xBF048911,0xBF04B40F,0xBF04DF09,
0xBF0509FD,0xBF0534EC,0xBF055FD7,0xBF058ABC,0xBF05B59C,0xBF05E076,0xBF060B4C,0xBF06361C,
0xBF0660E7,0xBF068BAD,0xBF06B66E,0xBF06E12A,0xBF070BE0,0xBF073692,0xBF07613E,0xBF078BE4,
0xBF07B686,0xBF07E122,0xBF080BB9,0xBF08364B,0xBF0860D8,0xBF088B5F,0xBF08B5E1,0xBF08E05E,
0xBF090AD6,0xBF093548,0xBF095FB5,0xBF098A1D,0xBF09B47F,0xBF09DEDC,0xBF0A0934,0xBF0A3386,
0xBF0A5DD3,0xBF0A881B,0xBF0AB25E,0xBF0ADC9B,0xBF0B06D2,0xBF0B3105,0xBF0B5B32,0xBF0B8559,
0xBF0BAF7C,0xBF0BD998,0xBF0C03B0,0xBF0C2DC2,0xBF0C57CF,0xBF0C81D6,0xBF0CABD8,0xBF0CD5D4,
0xBF0CFFCB,0xBF0D29BD,0xBF0D53A9,0xBF0D7D8F,0xBF0DA771,0xBF0DD14C,0xBF0DFB23,0xBF0E24F3,
0xBF0E4EBF,0xBF0E7885,0xBF0EA245,0xBF0ECC00,0xBF0EF5B5,0xBF0F1F65,0xBF0F490F,0xBF0F72B4,
0xBF0F9C53,0xBF0FC5ED,0xBF0FEF81,0xBF101910,0xBF104299,0xBF106C1C,0xBF10959A,0xBF10BF13,
0xBF10E885,0xBF1111F3,0xBF113B5A,0xBF1164BC,0xBF118E19,0xBF11B76F,0xBF11E0C1,0xBF120A0C,
0xBF123352,0xBF125C92,0xBF1285CD,0xBF12AF02,0xBF12D831,0xBF13015B,0xBF132A7F,0xBF13539D,
0xBF137CB6,0xBF13A5C9,0xBF13CED6,0xBF13F7DE,0xBF1420E0,0xBF1449DC,0xBF1472D2,0xBF149BC3,
0xBF14C4AE,0xBF14ED93,0xBF151673,0xBF153F4D,0xBF156821,0xBF1590EF,0xBF15B9B7,0xBF15E27A,
0xBF160B37,0xBF1633EE,0xBF165C9F,0xBF16854B,0xBF16ADF1,0xBF16D691,0xBF16FF2B,0xBF1727BF,
0xBF17504E,0xBF1778D6,0xBF17A159,0xBF17C9D6,0xBF17F24D,0xBF181ABE,0xBF18432A,0xBF186B8F,
0xBF1893EF,0xBF18BC49,0xBF18E49D,0xBF190CEB,0xBF193533,0xBF195D75,0xBF1985B1,0xBF19ADE7,
0xBF19D618,0xBF19FE42,0xBF1A2667,0xBF1A4E86,0xBF1A769E,0xBF1A9EB1,0xBF1AC6BE,0xBF1AEEC4,
0xBF1B16C5,0xBF1B3EC0,0xBF1B66B5,0xBF1B8EA4,0xBF1BB68D,0xBF1BDE6F,0xBF1C064C,0xBF1C2E23,
0xBF1C55F4,0xBF1C7DBF,0xBF1CA583,0xBF1CCD42,0xBF1CF4FB,0xBF1D1CAD,0xBF1D445A,0xBF1D6C00,
0xBF1D93A1,0xBF1DBB3B,0xBF1DE2CF,0xBF1E0A5D,0xBF1E31E6,0xBF1E5968,0xBF1E80E3,0xBF1EA859,
0xBF1ECFC9,0xBF1EF732,0xBF1F1E96,0xBF1F45F3,0xBF1F6D4A,0xBF1F949B,0xBF1FBBE6,0xBF1FE32B,
0xBF200A69,0xBF2031A1,0xBF2058D4,0xBF208000,0xBF20A725,0xBF20CE45,0xBF20F55E,0xBF211C71,
0xBF21437E,0xBF216A85,0xBF219186,0xBF21B880,0xBF21DF74,0xBF220662,0xBF222D4A,0xBF22542B,
0xBF227B06,0xBF22A1DB,0xBF22C8A9,0xBF22EF72,0xBF231633,0xBF233CEF,0xBF2363A5,0xBF238A54,
0xBF23B0FC,0xBF23D79F,0xBF23FE3B,0xBF2424D1,0xBF244B60,0xBF2471EA,0xBF24986D,0xBF24BEE9,
0xBF24E55F,0xBF250BCF,0xBF253238,0xBF25589B,0xBF257EF8,0xBF25A54E,0xBF25CB9E,0xBF25F1E8,
0xBF26182B,0xBF263E68,0xBF26649E,0xBF268ACE,0xBF26B0F7,0xBF26D71A,0xBF26FD37,0xBF27234D,
0xBF27495D,0xBF276F66,0xBF279569,0xBF27BB65,0xBF27E15B,0xBF28074B,0xBF282D34,0xBF285316,
0xBF2878F2,0xBF289EC8,0xBF28C497,0xBF28EA5F,0xBF291021,0xBF2935DD,0xBF295B91,0xBF298140,
0xBF29A6E8,0xBF29CC89,0xBF29F224,0xBF2A17B8,0xBF2A3D46,0xBF2A62CD,0xBF2A884D,0xBF2AADC7,
0xBF2AD33B,0xBF2AF8A7,0xBF2B1E0E,0xBF2B436D,0xBF2B68C6,0xBF2B8E19,0xBF2BB364,0xBF2BD8AA,
0xBF2BFDE8,0xBF2C2320,0xBF2C4851,0xBF2C6D7C,0xBF2C92A0,0xBF2CB7BD,0xBF2CDCD4,0xBF2D01E4,
0xBF2D26ED,0xBF2D4BF0,0xBF2D70EC,0xBF2D95E1,0xBF2DBAD0,0xBF2DDFB8,0xBF2E0499,0xBF2E2973,
0xBF2E4E47,0xBF2E7314,0xBF2E97DA,0xBF2EBC9A,0xBF2EE153,0xBF2F0605,0xBF2F2AB0,0xBF2F4F55,
0xBF2F73F3,0xBF2F988A,0xBF2FBD1A,0xBF2FE1A4,0xBF300626,0xBF302AA2,0xBF304F18,0xBF307386,
0xBF3097EE,0xBF30BC4E,0xBF30E0A8,0xBF3104FB,0xBF312948,0xBF314D8D,0xBF3171CC,0xBF319604,
0xBF31BA35,0xBF31DE5F,0xBF320282,0xBF32269E,0xBF324AB4,0xBF326EC3,0xBF3292CA,0xBF32B6CB,
0xBF32DAC5,0xBF32FEB8,0xBF3322A5,0xBF33468A,0xBF336A68,0xBF338E40,0xBF33B210,0xBF33D5DA,
0xBF33F99D,0xBF341D58,0xBF34410D,0xBF3464BB,0xBF348862,0xBF34AC02,0xBF34CF9B,0xBF34F32D,
0x3F3516B8,0x3F353A3C,0x3F355DB9,0x3F35812F,0x3F35A49E,0x3F35C806,0x3F35EB67,0x3F360EC1,
0x3F363214,0x3F365560,0x3F3678A5,0x3F369BE3,0x3F36BF1A,0x3F36E24A,0x3F370573,0x3F372894,
0x3F374BAF,0x3F376EC3,0x3F3791CF,0x3F37B4D5,0x3F37D7D3,0x3F37FACA,0x3F381DBB,0x3F3840A4,
0x3F386386,0x3F388661,0x3F38A934,0x3F38CC01,0x3F38EEC7,0x3F391185,0x3F39343C,0x3F3956EC,
0x3F397995,0x3F399C37,0x3F39BED2,0x3F39E165,0x3F3A03F2,0x3F3A2677,0x3F3A48F5,0x3F3A6B6C,
0x3F3A8DDB,0x3F3AB044,0x3F3AD2A5,0x3F3AF4FF,0x3F3B1752,0x3F3B399E,0x3F3B5BE2,0x3F3B7E1F,
0x3F3BA055,0x3F3BC284,0x3F3BE4AB,0x3F3C06CB,0x3F3C28E4,0x3F3C4AF6,0x3F3C6D01,0x3F3C8F04,
0x3F3CB100,0x3F3CD2F4,0x3F3CF4E2,0x3F3D16C8,0x3F3D38A7,0x3F3D5A7E,0x3F3D7C4E,0x3F3D9E17,
0x3F3DBFD9,0x3F3DE193,0x3F3E0346,0x3F3E24F2,0x3F3E4696,0x3F3E6833,0x3F3E89C9,0x3F3EAB57,
0x3F3ECCDE,0x3F3EEE5E,0x3F3F0FD6,0x3F3F3147,0x3F3F52B0,0x3F3F7412,0x3F3F956D,0x3F3FB6C0,
0x3F3FD80C,0x3F3FF951,0x3F401A8E,0x3F403BC4,0x3F405CF2,0x3F407E19,0x3F409F38,0x3F40C050,
0x3F40E161,0x3F41026A,0x3F41236C,0x3F414466,0x3F416559,0x3F418645,0x3F41A728,0x3F41C805,
0x3F41E8DA,0x3F4209A7,0x3F422A6E,0x3F424B2C,0x3F426BE3,0x3F428C93,0x3F42AD3B,0x3F42CDDB,
0x3F42EE74,0x3F430F06,0x3F432F90,0x3F435012,0x3F43708D,0x3F439101,0x3F43B16D,0x3F43D1D1,
0x3F43F22E,0x3F441283,0x3F4432D1,0x3F445317,0x3F447356,0x3F44938D,0x3F44B3BC,0x3F44D3E4,
0x3F44F404,0x3F45141D,0x3F45342E,0x3F455437,0x3F457439,0x3F459433,0x3F45B426,0x3F45D411,
0x3F45F3F4,0x3F4613D0,0x3F4633A4,0x3F465370,0x3F467335,0x3F4692F2,0x3F46B2A8,0x3F46D256,
0x3F46F1FC,0x3F47119A,0x3F473131,0x3F4750C0,0x3F477048,0x3F478FC7,0x3F47AF3F,0x3F47CEB0,
0x3F47EE18,0x3F480D79,0x3F482CD3,0x3F484C24,0x3F486B6E,0x3F488AB0,0x3F48A9EA,0x3F48C91D,
0x3F48E848,0x3F49076B,0x3F492686,0x3F49459A,0x3F4964A6,0x3F4983AA,0x3F49A2A6,0x3F49C19B,
0x3F49E088,0x3F49FF6D,0x3F4A1E4A,0x3F4A3D1F,0x3F4A5BED,0x3F4A7AB3,0x3F4A9971,0x3F4AB827,
0x3F4AD6D5,0x3F4AF57C,0x3F4B141B,0x3F4B32B2,0x3F4B5141,0x3F4B6FC8,0x3F4B8E47,0x3F4BACBF,
0x3F4BCB2F,0x3F4BE996,0x3F4C07F6,0x3F4C264E,0x3F4C449F,0x3F4C62E7,0x3F4C8128,0x3F4C9F60,
0x3F4CBD91,0x3F4CDBBA,0x3F4CF9DB,0x3F4D17F4,0x3F4D3605,0x3F4D540E,0x3F4D720F,0x3F4D9009,
0x3F4DADFA,0x3F4DCBE3,0x3F4DE9C5,0x3F4E079F,0x3F4E2570,0x3F4E433A,0x3F4E60FC,0x3F4E7EB6,
0x3F4E9C68,0x3F4EBA12,0x3F4ED7B3,0x3F4EF54D,0x3F4F12DF,0x3F4F3069,0x3F4F4DEB,0x3F4F6B65,
0x3F4F88D7,0x3F4FA642,0x3F4FC3A4,0x3F4FE0FE,0x3F4FFE50,0x3F501B9A,0x3F5038DB,0x3F505615,
0x3F507347,0x3F509071,0x3F50AD93,0x3F50CAAD,0x3F50E7BE,0x3F5104C8,0x3F5121CA,0x3F513EC3,
0x3F515BB5,0x3F51789E,0x3F51957F,0x3F51B259,0x3F51CF2A,0x3F51EBF3,0x3F5208B4,0x3F52256D,
0x3F52421E,0x3F525EC6,0x3F527B67,0x3F5297FF,0x3F52B490,0x3F52D118,0x3F52ED98,0x3F530A10,
0x3F532680,0x3F5342E7,0x3F535F47,0x3F537B9E,0x3F5397EE,0x3F53B435,0x3F53D074,0x3F53ECAA,
0x3F5408D9,0x3F5424FF,0x3F54411D,0x3F545D33,0x3F547941,0x3F549547,0x3F54B144,0x3F54CD3A,
0x3F54E927,0x3F55050C,0x3F5520E8,0x3F553CBD,0x3F555889,0x3F55744D,0x3F559009,0x3F55ABBC,
0x3F55C767,0x3F55E30A,0x3F55FEA5,0x3F561A38,0x3F5635C2,0x3F565144,0x3F566CBE,0x3F56882F,
0x3F56A399,0x3F56BEF9,0x3F56DA52,0x3F56F5A3,0x3F5710EB,0x3F572C2A,0x3F574762,0x3F576291,
0x3F577DB8,0x3F5798D7,0x3F57B3ED,0x3F57CEFB,0x3F57EA01,0x3F5804FE,0x3F581FF3,0x3F583AE0,
0x3F5855C4,0x3F5870A0,0x3F588B74,0x3F58A63F,0x3F58C102,0x3F58DBBC,0x3F58F66F,0x3F591118,
0x3F592BBA,0x3F594653,0x3F5960E4,0x3F597B6C,0x3F5995EC,0x3F59B064,0x3F59CAD3,0x3F59E53A,
0x3F59FF98,0x3F5A19EE,0x3F5A343C,0x3F5A4E81,0x3F5A68BE,0x3F5A82F2,0x3F5A9D1E,0x3F5AB741,
0x3F5AD15C,0x3F5AEB6F,0x3F5B0579,0x3F5B1F7B,0x3F5B3974,0x3F5B5365,0x3F5B6D4D,0x3F5B872D,
0x3F5BA105,0x3F5BBAD4,0x3F5BD49A,0x3F5BEE58,0x3F5C080E,0x3F5C21BB,0x3F5C3B60,0x3F5C54FC,
0x3F5C6E8F,0x3F5C881A,0x3F5CA19D,0x3F5CBB17,0x3F5CD489,0x3F5CEDF2,0x3F5D0752,0x3F5D20AA,
0x3F5D39FA,0x3F5D5341,0x3F5D6C7F,0x3F5D85B5,0x3F5D9EE3,0x3F5DB807,0x3F5DD124,0x3F5DEA37,
0x3F5E0343,0x3F5E1C45,0x3F5E353F,0x3F5E4E31,0x3F5E671A,0x3F5E7FFA,0x3F5E98D2,0x3F5EB1A1,
0x3F5ECA68,0x3F5EE326,0x3F5EFBDB,0x3F5F1488,0x3F5F2D2C,0x3F5F45C8,0x3F5F5E5B,0x3F5F76E5,
0x3F5F8F67,0x3F5FA7E0,0x3F5FC051,0x3F5FD8B8,0x3F5FF118,0x3F60096E,0x3F6021BC,0x3F603A02,
0x3F60523E,0x3F606A73,0x3F60829E,0x3F609AC1,0x3F60B2DB,0x3F60CAEC,0x3F60E2F5,0x3F60FAF5,
0x3F6112ED,0x3F612ADB,0x3F6142C1,0x3F615A9F,0x3F617274,0x3F618A40,0x3F61A203,0x3F61B9BE,
0x3F61D16F,0x3F61E919,0x3F6200B9,0x3F621851,0x3F622FE0,0x3F624766,0x3F625EE4,0x3F627659,
0x3F628DC5,0x3F62A528,0x3F62BC83,0x3F62D3D5,0x3F62EB1E,0x3F63025F,0x3F631996,0x3F6330C5,
0x3F6347EC,0x3F635F09,0x3F63761E,0x3F638D2A,0x3F63A42D,0x3F63BB27,0x3F63D219,0x3F63E901,
0x3F63FFE1,0x3F6416B9,0x3F642D87,0x3F64444D,0x3F645B0A,0x3F6471BE,0x3F648869,0x3F649F0B,
0x3F64B5A5,0x3F64CC35,0x3F64E2BD,0x3F64F93D,0x3F650FB3,0x3F652620,0x3F653C85,0x3F6552E1,
0x3F656934,0x3F657F7E,0x3F6595BF,0x3F65ABF7,0x3F65C227,0x3F65D84E,0x3F65EE6C,0x3F660480,
0x3F661A8D,0x3F663090,0x3F66468A,0x3F665C7C,0x3F667264,0x3F668844,0x3F669E1B,0x3F66B3E9,
0x3F66C9AE,0x3F66DF6A,0x3F66F51D,0x3F670AC7,0x3F672069,0x3F673601,0x3F674B91,0x3F676118,
0x3F677695,0x3F678C0A,0x3F67A176,0x3F67B6D9,0x3F67CC33,0x3F67E184,0x3F67F6CC,0x3F680C0C,
0x3F682142,0x3F68366F,0x3F684B94,0x3F6860AF,0x3F6875C2,0x3F688ACB,0x3F689FCC,0x3F68B4C3,
0x3F68C9B2,0x3F68DE97,0x3F68F374,0x3F690848,0x3F691D12,0x3F6931D4,0x3F69468D,0x3F695B3D,
0x3F696FE3,0x3F698481,0x3F699916,0x3F69ADA1,0x3F69C224,0x3F69D69E,0x3F69EB0E,0x3F69FF76,
0x3F6A13D5,0x3F6A282A,0x3F6A3C77,0x3F6A50BA,0x3F6A64F5,0x3F6A7926,0x3F6A8D4F,0x3F6AA16E,
0x3F6AB585,0x3F6AC992,0x3F6ADD96,0x3F6AF191,0x3F6B0584,0x3F6B196D,0x3F6B2D4D,0x3F6B4124,
0x3F6B54F1,0x3F6B68B6,0x3F6B7C72,0x3F6B9025,0x3F6BA3CE,0x3F6BB76F,0x3F6BCB06,0x3F6BDE94,
0x3F6BF21A,0x3F6C0596,0x3F6C1909,0x3F6C2C73,0x3F6C3FD3,0x3F6C532B,0x3F6C667A,0x3F6C79BF,
0x3F6C8CFC,0x3F6CA02F,0x3F6CB359,0x3F6CC67A,0x3F6CD992,0x3F6CECA0,0x3F6CFFA6,0x3F6D12A2,
0x3F6D2596,0x3F6D3880,0x3F6D4B61,0x3F6D5E39,0x3F6D7108,0x3F6D83CD,0x3F6D968A,0x3F6DA93D,
0x3F6DBBE7,0x3F6DCE88,0x3F6DE120,0x3F6DF3AE,0x3F6E0634,0x3F6E18B0,0x3F6E2B23,0x3F6E3D8D,
0x3F6E4FEE,0x3F6E6245,0x3F6E7493,0x3F6E86D8,0x3F6E9914,0x3F6EAB47,0x3F6EBD71,0x3F6ECF91,
0x3F6EE1A8,0x3F6EF3B6,0x3F6F05BB,0x3F6F17B6,0x3F6F29A8,0x3F6F3B92,0x3F6F4D71,0x3F6F5F48,
0x3F6F7115,0x3F6F82D9,0x3F6F9494,0x3F6FA646,0x3F6FB7EE,0x3F6FC98E,0x3F6FDB24,0x3F6FECB0,
0x3F6FFE34,0x3F700FAE,0x3F70211F,0x3F703286,0x3F7043E5,0x3F70553A,0x3F706686,0x3F7077C8,
0x3F708902,0x3F709A32,0x3F70AB59,0x3F70BC76,0x3F70CD8A,0x3F70DE95,0x3F70EF97,0x3F71008F,
0x3F71117F,0x3F712264,0x3F713341,0x3F714414,0x3F7154DE,0x3F71659F,0x3F717656,0x3F718704,
0x3F7197A8,0x3F71A844,0x3F71B8D6,0x3F71C95F,0x3F71D9DE,0x3F71EA54,0x3F71FAC1,0x3F720B24,
0x3F721B7E,0x3F722BCF,0x3F723C16,0x3F724C54,0x3F725C89,0x3F726CB5,0x3F727CD7,0x3F728CEF,
0x3F729CFF,0x3F72AD05,0x3F72BD01,0x3F72CCF5,0x3F72DCDE,0x3F72ECBF,0x3F72FC96,0x3F730C64,
0x3F731C28,0x3F732BE4,0x3F733B95,0x3F734B3E,0x3F735ADC,0x3F736A72,0x3F7379FE,0x3F738981,
0x3F7398FA,0x3F73A86A,0x3F73B7D1,0x3F73C72E,0x3F73D682,0x3F73E5CC,0x3F73F50D,0x3F740445,
0x3F741373,0x3F742298,0x3F7431B3,0x3F7440C5,0x3F744FCE,0x3F745ECD,0x3F746DC3,0x3F747CAF,
0x3F748B92,0x3F749A6B,0x3F74A93B,0x3F74B802,0x3F74C6BF,0x3F74D573,0x3F74E41D,0x3F74F2BE,
0x3F750155,0x3F750FE3,0x3F751E68,0x3F752CE3,0x3F753B54,0x3F7549BC,0x3F75581B,0x3F756670,
0x3F7574BC,0x3F7582FE,0x3F759137,0x3F759F66,0x3F75AD8C,0x3F75BBA9,0x3F75C9BC,0x3F75D7C5,
0x3F75E5C5,0x3F75F3BC,0x3F7601A9,0x3F760F8C,0x3F761D66,0x3F762B37,0x3F7638FE,0x3F7646BB,
0x3F76546F,0x3F76621A,0x3F766FBB,0x3F767D53,0x3F768AE1,0x3F769865,0x3F76A5E0,0x3F76B352,
0x3F76C0BA,0x3F76CE19,0x3F76DB6E,0x3F76E8B9,0x3F76F5FB,0x3F770334,0x3F771063,0x3F771D88,
0x3F772AA4,0x3F7737B6,0x3F7744BF,0x3F7751BE,0x3F775EB4,0x3F776BA0,0x3F777883,0x3F77855C,
0x3F77922C,0x3F779EF2,0x3F77ABAE,0x3F77B861,0x3F77C50B,0x3F77D1AB,0x3F77DE41,0x3F77EACE,
0x3F77F751,0x3F7803CA,0x3F78103A,0x3F781CA1,0x3F7828FE,0x3F783551,0x3F78419B,0x3F784DDB,
0x3F785A12,0x3F78663F,0x3F787263,0x3F787E7D,0x3F788A8D,0x3F789694,0x3F78A291,0x3F78AE84,
0x3F78BA6E,0x3F78C64F,0x3F78D226,0x3F78DDF3,0x3F78E9B7,0x3F78F571,0x3F790121,0x3F790CC8,
0x3F791865,0x3F7923F9,0x3F792F83,0x3F793B03,0x3F79467A,0x3F7951E7,0x3F795D4B,0x3F7968A5,
0x3F7973F5,0x3F797F3C,0x3F798A79,0x3F7995AD,0x3F79A0D7,0x3F79ABF7,0x3F79B70D,0x3F79C21A,
0x3F79CD1E,0x3F79D818,0x3F79E308,0x3F79EDEE,0x3F79F8CB,0x3F7A039E,0x3F7A0E68,0x3F7A1928,
0x3F7A23DE,0x3F7A2E8B,0x3F7A392E,0x3F7A43C7,0x3F7A4E57,0x3F7A58DD,0x3F7A6359,0x3F7A6DCC,
0x3F7A7835,0x3F7A8295,0x3F7A8CEA,0x3F7A9737,0x3F7AA179,0x3F7AABB2,0x3F7AB5E1,0x3F7AC006,
0x3F7ACA22,0x3F7AD434,0x3F7ADE3D,0x3F7AE83C,0x3F7AF231,0x3F7AFC1C,0x3F7B05FE,0x3F7B0FD6,
0x3F7B19A4,0x3F7B2369,0x3F7B2D24,0x3F7B36D6,0x3F7B407D,0x3F7B4A1B,0x3F7B53B0,0x3F7B5D3A,
0x3F7B66BB,0x3F7B7032,0x3F7B79A0,0x3F7B8304,0x3F7B8C5E,0x3F7B95AE,0x3F7B9EF5,0x3F7BA832,
0x3F7BB166,0x3F7BBA8F,0x3F7BC3AF,0x3F7BCCC5,0x3F7BD5D2,0x3F7BDED5,0x3F7BE7CE,0x3F7BF0BD,
0x3F7BF9A3,0x3F7C027F,0x3F7C0B51,0x3F7C141A,0x3F7C1CD9,0x3F7C258E,0x3F7C2E39,0x3F7C36DB,
0x3F7C3F73,0x3F7C4801,0x3F7C5085,0x3F7C5900,0x3F7C6171,0x3F7C69D8,0x3F7C7236,0x3F7C7A8A,
0x3F7C82D4,0x3F7C8B14,0x3F7C934B,0x3F7C9B78,0x3F7CA39B,0x3F7CABB4,0x3F7CB3C4,0x3F7CBBCA,
0x3F7CC3C6,0x3F7CCBB8,0x3F7CD3A1,0x3F7CDB80,0x3F7CE355,0x3F7CEB21,0x3F7CF2E2,0x3F7CFA9A,
0x3F7D0249,0x3F7D09ED,0x3F7D1188,0x3F7D1919,0x3F7D20A0,0x3F7D281D,0x3F7D2F91,0x3F7D36FB,
0x3F7D3E5B,0x3F7D45B1,0x3F7D4CFE,0x3F7D5441,0x3F7D5B7A,0x3F7D62A9,0x3F7D69CE,0x3F7D70EA,
0x3F7D77FC,0x3F7D7F04,0x3F7D8603,0x3F7D8CF8,0x3F7D93E2,0x3F7D9AC4,0x3F7DA19B,0x3F7DA868,
0x3F7DAF2C,0x3F7DB5E6,0x3F7DBC96,0x3F7DC33D,0x3F7DC9DA,0x3F7DD06C,0x3F7DD6F5,0x3F7DDD75,
0x3F7DE3EA,0x3F7DEA56,0x3F7DF0B8,0x3F7DF710,0x3F7DFD5E,0x3F7E03A3,0x3F7E09DE,0x3F7E100F,
0x3F7E1636,0x3F7E1C53,0x3F7E2267,0x3F7E2871,0x3F7E2E71,0x3F7E3467,0x3F7E3A53,0x3F7E4036,
0x3F7E460F,0x3F7E4BDE,0x3F7E51A3,0x3F7E575E,0x3F7E5D10,0x3F7E62B7,0x3F7E6855,0x3F7E6DEA,
0x3F7E7374,0x3F7E78F4,0x3F7E7E6B,0x3F7E83D8,0x3F7E893B,0x3F7E8E94,0x3F7E93E4,0x3F7E9929,
0x3F7E9E65,0x3F7EA397,0x3F7EA8C0,0x3F7EADDE,0x3F7EB2F2,0x3F7EB7FD,0x3F7EBCFE,0x3F7EC1F5,
0x3F7EC6E3,0x3F7ECBC6,0x3F7ED0A0,0x3F7ED56F,0x3F7EDA35,0x3F7EDEF2,0x3F7EE3A4,0x3F7EE84C,
0x3F7EECEB,0x3F7EF180,0x3F7EF60B,0x3F7EFA8C,0x3F7EFF04,0x3F7F0371,0x3F7F07D5,0x3F7F0C2F,
0x3F7F107F,0x3F7F14C5,0x3F7F1901,0x3F7F1D34,0x3F7F215C,0x3F7F257B,0x3F7F2990,0x3F7F2D9C,
0x3F7F319D,0x3F7F3594,0x3F7F3982,0x3F7F3D66,0x3F7F4140,0x3F7F4510,0x3F7F48D6,0x3F7F4C93,
0x3F7F5045,0x3F7F53EE,0x3F7F578D,0x3F7F5B22,0x3F7F5EAE,0x3F7F622F,0x3F7F65A7,0x3F7F6914,
0x3F7F6C78,0x3F7F6FD2,0x3F7F7322,0x3F7F7669,0x3F7F79A5,0x3F7F7CD8,0x3F7F8000,0x3F7F831F,
0x3F7F8634,0x3F7F8940,0x3F7F8C41,0x3F7F8F39,0x3F7F9226,0x3F7F950A,0x3F7F97E4,0x3F7F9AB4,
0x3F7F9D7A,0x3F7FA037,0x3F7FA2E9,0x3F7FA592,0x3F7FA831,0x3F7FAAC6,0x3F7FAD51,0x3F7FAFD2,
0x3F7FB24A,0x3F7FB4B7,0x3F7FB71B,0x3F7FB975,0x3F7FBBC5,0x3F7FBE0B,0x3F7FC047,0x3F7FC279,
0x3F7FC4A2,0x3F7FC6C1,0x3F7FC8D5,0x3F7FCAE0,0x3F7FCCE1,0x3F7FCED9,0x3F7FD0C6,0x3F7FD2A9,
0x3F7FD483,0x3F7FD653,0x3F7FD819,0x3F7FD9D5,0x3F7FDB87,0x3F7FDD2F,0x3F7FDECE,0x3F7FE062,
0x3F7FE1ED,0x3F7FE36E,0x3F7FE4E5,0x3F7FE652,0x3F7FE7B5,0x3F7FE90F,0x3F7FEA5E,0x3F7FEBA4,
0x3F7FECE0,0x3F7FEE12,0x3F7FEF3A,0x3F7FF058,0x3F7FF16C,0x3F7FF277,0x3F7FF377,0x3F7FF46E,
0x3F7FF55B,0x3F7FF63E,0x3F7FF717,0x3F7FF7E6,0x3F7FF8AC,0x3F7FF967,0x3F7FFA19,0x3F7FFAC1,
0x3F7FFB5E,0x3F7FFBF2,0x3F7FFC7D,0x3F7FFCFD,0x3F7FFD73,0x3F7FFDE0,0x3F7FFE43,0x3F7FFE9B,
0x3F7FFEEA,0x3F7FFF30,0x3F7FFF6B,0x3F7FFF9C,0x3F7FFFC4,0x3F7FFFE1,0x3F7FFFF5,0x3F7FFFFF,
0xBA490FD9,0xBB16CBDB,0xBB7B53A9,0xBBAFEDA8,0xBBE23160,0xBC0A3A7B,0xBC235C30,0xBC3C7DCC,
0xBC559F4C,0xBC6EC0AA,0xBC83F0F2,0xBC90817A,0xBC9D11EC,0xBCA9A246,0xBCB63286,0xBCC2C2A9,
0xBCCF52AF,0xBCDBE294,0xBCE87258,0xBCF501F8,0xBD00C8B9,0xBD071062,0xBD0D57F6,0xBD139F75,
0xBD19E6DD,0xBD202E2D,0xBD267564,0xBD2CBC82,0xBD330385,0xBD394A6C,0xBD3F9137,0xBD45D7E4,
0xBD4C1E73,0xBD5264E2,0xBD58AB31,0xBD5EF15F,0xBD65376A,0xBD6B7D51,0xBD71C315,0xBD7808B3,
0xBD7E4E2B,0xBD8249BE,0xBD856C52,0xBD888ED2,0xBD8BB13C,0xBD8ED391,0xBD91F5D0,0xBD9517F9,
0xBD983A0A,0xBD9B5C05,0xBD9E7DE7,0xBDA19FB0,0xBDA4C161,0xBDA7E2F8,0xBDAB0476,0xBDAE25D9,
0xBDB14721,0xBDB4684E,0xBDB7895F,0xBDBAAA54,0xBDBDCB2C,0xBDC0EBE6,0xBDC40C83,0xBDC72D02,
0xBDCA4D62,0xBDCD6DA3,0xBDD08DC4,0xBDD3ADC5,0xBDD6CDA5,0xBDD9ED64,0xBDDD0D02,0xBDE02C7D,
0xBDE34BD6,0xBDE66B0C,0xBDE98A1F,0xBDECA90D,0xBDEFC7D7,0xBDF2E67C,0xBDF604FB,0xBDF92354,
0xBDFC4187,0xBDFF5F94,0xBE013EBC,0xBE02CD9B,0xBE045C65,0xBE05EB1B,0xBE0779BC,0xBE090848,
0xBE0A96BF,0xBE0C2521,0xBE0DB36D,0xBE0F41A4,0xBE10CFC4,0xBE125DCE,0xBE13EBC1,0xBE15799E,
0xBE170763,0xBE189511,0xBE1A22A8,0xBE1BB027,0xBE1D3D8E,0xBE1ECADD,0xBE205813,0xBE21E530,
0xBE237235,0xBE24FF20,0xBE268BF2,0xBE2818AA,0xBE29A548,0xBE2B31CC,0xBE2CBE36,0xBE2E4A85,
0xBE2FD6B9,0xBE3162D2,0xBE32EECF,0xBE347AB2,0xBE360678,0xBE379222,0xBE391DB0,0xBE3AA921,
0xBE3C3476,0xBE3DBFAD,0xBE3F4AC7,0xBE40D5C4,0xBE4260A3,0xBE43EB64,0xBE457607,0xBE47008B,
0xBE488AF1,0xBE4A1538,0xBE4B9F5F,0xBE4D2967,0xBE4EB350,0xBE503D19,0xBE51C6C1,0xBE535049,
0xBE54D9B1,0xBE5662F8,0xBE57EC1D,0xBE597522,0xBE5AFE05,0xBE5C86C6,0xBE5E0F65,0xBE5F97E2,
0xBE61203C,0xBE62A874,0xBE643089,0xBE65B87A,0xBE674048,0xBE68C7F3,0xBE6A4F79,0xBE6BD6DC,
0xBE6D5E1A,0xBE6EE533,0xBE706C28,0xBE71F2F7,0xBE7379A1,0xBE750026,0xBE768685,0xBE780CBE,
0xBE7992D0,0xBE7B18BC,0xBE7C9E82,0xBE7E2420,0xBE7FA998,0xBE809774,0xBE815A08,0xBE821C88,
0xBE82DEF4,0xBE83A14C,0xBE84638F,0xBE8525BF,0xBE85E7D9,0xBE86A9DF,0xBE876BD0,0xBE882DAD,
0xBE88EF74,0xBE89B126,0xBE8A72C3,0xBE8B344B,0xBE8BF5BD,0xBE8CB71A,0xBE8D7861,0xBE8E3992,
0xBE8EFAAD,0xBE8FBBB2,0xBE907CA1,0xBE913D79,0xBE91FE3C,0xBE92BEE7,0xBE937F7D,0xBE943FFB,
0xBE950062,0xBE95C0B3,0xBE9680EC,0xBE97410E,0xBE980119,0xBE98C10D,0xBE9980E9,0xBE9A40AD,
0xBE9B0059,0xBE9BBFEE,0xBE9C7F6A,0xBE9D3ECF,0xBE9DFE1B,0xBE9EBD4F,0xBE9F7C6A,0xBEA03B6D,
0xBEA0FA57,0xBEA1B928,0xBEA277E0,0xBEA3367F,0xBEA3F505,0xBEA4B372,0xBEA571C5,0xBEA62FFF,
0xBEA6EE1F,0xBEA7AC25,0xBEA86A12,0xBEA927E5,0xBEA9E59D,0xBEAAA33B,0xBEAB60BF,0xBEAC1E29,
0xBEACDB78,0xBEAD98AC,0xBEAE55C6,0xBEAF12C5,0xBEAFCFA8,0xBEB08C71,0xBEB1491E,0xBEB205B0,
0xBEB2C227,0xBEB37E82,0xBEB43AC1,0xBEB4F6E5,0xBEB5B2EC,0xBEB66ED8,0xBEB72AA7,0xBEB7E65B,
0xBEB8A1F1,0xBEB95D6C,0xBEBA18CA,0xBEBAD40B,0xBEBB8F2F,0xBEBC4A36,0xBEBD0521,0xBEBDBFEE,
0xBEBE7A9E,0xBEBF3530,0xBEBFEFA5,0xBEC0A9FD,0xBEC16437,0xBEC21E53,0xBEC2D851,0xBEC39231,
0xBEC44BF2,0xBEC50596,0xBEC5BF1B,0xBEC67882,0xBEC731CA,0xBEC7EAF3,0xBEC8A3FD,0xBEC95CE9,
0xBECA15B5,0xBECACE63,0xBECB86F1,0xBECC3F60,0xBECCF7AF,0xBECDAFDE,0xBECE67EE,0xBECF1FDE,
0xBECFD7AE,0xBED08F5E,0xBED146EE,0xBED1FE5E,0xBED2B5AD,0xBED36CDB,0xBED423EA,0xBED4DAD7,
0xBED591A4,0xBED6484F,0xBED6FEDA,0xBED7B543,0xBED86B8B,0xBED921B2,0xBED9D7B7,0xBEDA8D9B,
0xBEDB435D,0xBEDBF8FD,0xBEDCAE7C,0xBEDD63D8,0xBEDE1912,0xBEDECE2A,0xBEDF831F,0xBEE037F2,
0xBEE0ECA3,0xBEE1A130,0xBEE2559B,0xBEE309E3,0xBEE3BE08,0xBEE4720A,0xBEE525E9,0xBEE5D9A4,
0xBEE68D3C,0xBEE740B1,0xBEE7F401,0xBEE8A72E,0xBEE95A37,0xBEEA0D1C,0xBEEABFDD,0xBEEB727A,
0xBEEC24F3,0xBEECD747,0xBEED8976,0xBEEE3B81,0xBEEEED67,0xBEEF9F28,0xBEF050C5,0xBEF1023C,
0xBEF1B38E,0xBEF264BB,0xBEF315C2,0xBEF3C6A4,0xBEF47761,0xBEF527F8,0xBEF5D868,0xBEF688B3,
0xBEF738D8,0xBEF7E8D7,0xBEF898B0,0xBEF94862,0xBEF9F7EE,0xBEFAA753,0xBEFB5692,0xBEFC05AA,
0xBEFCB49B,0xBEFD6365,0xBEFE1207,0xBEFEC083,0xBEFF6ED8,0xBF000E82,0xBF006585,0xBF00BC74,
0xBF01134F,0xBF016A17,0xBF01C0CA,0xBF021769,0xBF026DF4,0xBF02C46B,0xBF031ACE,0xBF03711D,
0xBF03C757,0xBF041D7E,0xBF04738F,0xBF04C98D,0xBF051F75,0xBF05754A,0xBF05CB0A,0xBF0620B5,
0xBF06764B,0xBF06CBCD,0xBF07213A,0xBF077692,0xBF07CBD5,0xBF082103,0xBF08761C,0xBF08CB20,
0xBF092010,0xBF0974E9,0xBF09C9AE,0xBF0A1E5E,0xBF0A72F8,0xBF0AC77D,0xBF0B1BEC,0xBF0B7046,
0xBF0BC48B,0xBF0C18BA,0xBF0C6CD3,0xBF0CC0D7,0xBF0D14C5,0xBF0D689D,0xBF0DBC5F,0xBF0E100C,
0xBF0E63A2,0xBF0EB723,0xBF0F0A8E,0xBF0F5DE2,0xBF0FB121,0xBF100449,0xBF10575B,0xBF10AA57,
0xBF10FD3D,0xBF11500C,0xBF11A2C5,0xBF11F567,0xBF1247F3,0xBF129A68,0xBF12ECC7,0xBF133F0F,
0xBF139140,0xBF13E35B,0xBF14355E,0xBF14874B,0xBF14D921,0xBF152AE0,0xBF157C88,0xBF15CE19,
0xBF161F93,0xBF1670F6,0xBF16C241,0xBF171376,0xBF176493,0xBF17B598,0xBF180687,0xBF18575D,
0xBF18A81D,0xBF18F8C4,0xBF194955,0xBF1999CD,0xBF19EA2E,0xBF1A3A77,0xBF1A8AA8,0xBF1ADAC2,
0xBF1B2AC3,0xBF1B7AAD,0xBF1BCA7F,0xBF1C1A38,0xBF1C69DA,0xBF1CB963,0xBF1D08D5,0xBF1D582E,
0xBF1DA76F,0xBF1DF697,0xBF1E45A7,0xBF1E949F,0xBF1EE37E,0xBF1F3245,0xBF1F80F3,0xBF1FCF89,
0xBF201E06,0xBF206C6A,0xBF20BAB6,0xBF2108E9,0xBF215703,0xBF21A504,0xBF21F2EC,0xBF2240BB,
0xBF228E71,0xBF22DC0E,0xBF232992,0xBF2376FD,0xBF23C44F,0xBF241187,0xBF245EA6,0xBF24ABAC,
0xBF24F898,0xBF25456B,0xBF259224,0xBF25DEC4,0xBF262B4A,0xBF2677B7,0xBF26C40A,0xBF271043,
0xBF275C62,0xBF27A868,0xBF27F454,0xBF284026,0xBF288BDE,0xBF28D77C,0xBF292300,0xBF296E69,
0xBF29B9B9,0xBF2A04EF,0xBF2A500A,0xBF2A9B0B,0xBF2AE5F2,0xBF2B30BE,0xBF2B7B70,0xBF2BC608,
0xBF2C1085,0xBF2C5AE7,0xBF2CA52F,0xBF2CEF5D,0xBF2D396F,0xBF2D8367,0xBF2DCD44,0xBF2E1707,
0xBF2E60AE,0xBF2EAA3B,0xBF2EF3AD,0xBF2F3D03,0xBF2F863F,0xBF2FCF60,0xBF301865,0xBF306150,
0xBF30AA1F,0xBF30F2D3,0xBF313B6B,0xBF3183E9,0xBF31CC4B,0xBF321491,0xBF325CBC,0xBF32A4CC,
0xBF32ECC0,0xBF333498,0xBF337C55,0xBF33C3F6,0xBF340B7B,0xBF3452E5,0xBF349A33,0xBF34E165,
0x3F35287B,0x3F356F75,0x3F35B653,0x3F35FD15,0x3F3643BB,0x3F368A45,0x3F36D0B3,0x3F371704,
0x3F375D3A,0x3F37A353,0x3F37E950,0x3F382F30,0x3F3874F4,0x3F38BA9C,0x3F390027,0x3F394595,
0x3F398AE7,0x3F39D01D,0x3F3A1535,0x3F3A5A31,0x3F3A9F10,0x3F3AE3D3,0x3F3B2879,0x3F3B6D01,
0x3F3BB16D,0x3F3BF5BC,0x3F3C39EE,0x3F3C7E03,0x3F3CC1FB,0x3F3D05D6,0x3F3D4993,0x3F3D8D34,
0x3F3DD0B7,0x3F3E141D,0x3F3E5766,0x3F3E9A91,0x3F3EDD9F,0x3F3F208F,0x3F3F6362,0x3F3FA617,
0x3F3FE8AF,0x3F402B2A,0x3F406D86,0x3F40AFC5,0x3F40F1E7,0x3F4133EA,0x3F4175D0,0x3F41B798,
0x3F41F942,0x3F423ACE,0x3F427C3C,0x3F42BD8C,0x3F42FEBE,0x3F433FD2,0x3F4380C8,0x3F43C1A0,
0x3F44025A,0x3F4442F5,0x3F448372,0x3F44C3D1,0x3F450411,0x3F454433,0x3F458437,0x3F45C41C,
0x3F4603E3,0x3F46438B,0x3F468315,0x3F46C280,0x3F4701CC,0x3F4740FA,0x3F478008,0x3F47BEF9,
0x3F47FDCA,0x3F483C7C,0x3F487B10,0x3F48B985,0x3F48F7DA,0x3F493611,0x3F497429,0x3F49B222,
0x3F49EFFB,0x3F4A2DB6,0x3F4A6B51,0x3F4AA8CD,0x3F4AE62A,0x3F4B2367,0x3F4B6085,0x3F4B9D84,
0x3F4BDA63,0x3F4C1723,0x3F4C53C4,0x3F4C9045,0x3F4CCCA6,0x3F4D08E8,0x3F4D450A,0x3F4D810D,
0x3F4DBCF0,0x3F4DF8B3,0x3F4E3456,0x3F4E6FDA,0x3F4EAB3E,0x3F4EE681,0x3F4F21A5,0x3F4F5CA9,
0x3F4F978D,0x3F4FD252,0x3F500CF6,0x3F504779,0x3F5081DD,0x3F50BC21,0x3F50F644,0x3F513047,
0x3F516A2A,0x3F51A3ED,0x3F51DD8F,0x3F521711,0x3F525073,0x3F5289B4,0x3F52C2D5,0x3F52FBD5,
0x3F5334B5,0x3F536D74,0x3F53A612,0x3F53DE90,0x3F5416ED,0x3F544F2A,0x3F548745,0x3F54BF40,
0x3F54F71A,0x3F552ED4,0x3F55666C,0x3F559DE3,0x3F55D53A,0x3F560C70,0x3F564384,0x3F567A78,
0x3F56B14A,0x3F56E7FB,0x3F571E8C,0x3F5754FB,0x3F578B48,0x3F57C175,0x3F57F780,0x3F582D6A,
0x3F586333,0x3F5898DA,0x3F58CE60,0x3F5903C5,0x3F593908,0x3F596E29,0x3F59A329,0x3F59D807,
0x3F5A0CC4,0x3F5A415F,0x3F5A75D9,0x3F5AAA31,0x3F5ADE67,0x3F5B127B,0x3F5B466E,0x3F5B7A3E,
0x3F5BADED,0x3F5BE17A,0x3F5C14E6,0x3F5C482F,0x3F5C7B56,0x3F5CAE5B,0x3F5CE13E,0x3F5D13FF,
0x3F5D469E,0x3F5D791B,0x3F5DAB76,0x3F5DDDAF,0x3F5E0FC5,0x3F5E41B9,0x3F5E738B,0x3F5EA53A,
0x3F5ED6C8,0x3F5F0833,0x3F5F397B,0x3F5F6AA1,0x3F5F9BA5,0x3F5FCC86,0x3F5FFD44,0x3F602DE0,
0x3F605E5A,0x3F608EB0,0x3F60BEE5,0x3F60EEF6,0x3F611EE5,0x3F614EB1,0x3F617E5B,0x3F61ADE1,
0x3F61DD45,0x3F620C86,0x3F623BA4,0x3F626AA0,0x3F629978,0x3F62C82D,0x3F62F6C0,0x3F63252F,
0x3F63537B,0x3F6381A5,0x3F63AFAB,0x3F63DD8E,0x3F640B4E,0x3F6438EB,0x3F646665,0x3F6493BB,
0x3F64C0EE,0x3F64EDFE,0x3F651AEB,0x3F6547B4,0x3F65745A,0x3F65A0DC,0x3F65CD3B,0x3F65F977,
0x3F66258F,0x3F665184,0x3F667D55,0x3F66A903,0x3F66D48D,0x3F66FFF3,0x3F672B36,0x3F675655,
0x3F678151,0x3F67AC29,0x3F67D6DD,0x3F68016D,0x3F682BDA,0x3F685623,0x3F688047,0x3F68AA49,
0x3F68D426,0x3F68FDDF,0x3F692774,0x3F6950E6,0x3F697A33,0x3F69A35D,0x3F69CC62,0x3F69F543,
0x3F6A1E01,0x3F6A469A,0x3F6A6F0F,0x3F6A9760,0x3F6ABF8C,0x3F6AE795,0x3F6B0F79,0x3F6B3739,
0x3F6B5ED5,0x3F6B864C,0x3F6BADA0,0x3F6BD4CE,0x3F6BFBD9,0x3F6C22BF,0x3F6C4980,0x3F6C701E,
0x3F6C9696,0x3F6CBCEA,0x3F6CE31A,0x3F6D0925,0x3F6D2F0C,0x3F6D54CE,0x3F6D7A6C,0x3F6D9FE4,
0x3F6DC539,0x3F6DEA68,0x3F6E0F73,0x3F6E3459,0x3F6E591A,0x3F6E7DB7,0x3F6EA22F,0x3F6EC682,
0x3F6EEAB0,0x3F6F0EBA,0x3F6F329E,0x3F6F565E,0x3F6F79F8,0x3F6F9D6E,0x3F6FC0BF,0x3F6FE3EB,
0x3F7006F2,0x3F7029D4,0x3F704C91,0x3F706F28,0x3F70919B,0x3F70B3E9,0x3F70D611,0x3F70F814,
0x3F7119F3,0x3F713BAC,0x3F715D3F,0x3F717EAE,0x3F719FF7,0x3F71C11B,0x3F71E21A,0x3F7202F4,
0x3F7223A8,0x3F724437,0x3F7264A0,0x3F7284E4,0x3F72A503,0x3F72C4FC,0x3F72E4D0,0x3F73047E,
0x3F732407,0x3F73436B,0x3F7362A8,0x3F7381C1,0x3F73A0B4,0x3F73BF81,0x3F73DE28,0x3F73FCAA,
0x3F741B07,0x3F74393E,0x3F74574F,0x3F74753A,0x3F749300,0x3F74B0A0,0x3F74CE1A,0x3F74EB6F,
0x3F75089D,0x3F7525A6,0x3F754289,0x3F755F47,0x3F757BDE,0x3F759850,0x3F75B49C,0x3F75D0C2,
0x3F75ECC2,0x3F76089C,0x3F762450,0x3F763FDE,0x3F765B46,0x3F767688,0x3F7691A4,0x3F76AC9A,
0x3F76C76B,0x3F76E215,0x3F76FC99,0x3F7716F6,0x3F77312E,0x3F774B40,0x3F77652B,0x3F777EF1,
0x3F779890,0x3F77B209,0x3F77CB5C,0x3F77E488,0x3F77FD8F,0x3F78166F,0x3F782F29,0x3F7847BC,
0x3F78602A,0x3F787871,0x3F789091,0x3F78A88C,0x3F78C060,0x3F78D80E,0x3F78EF95,0x3F7906F6,
0x3F791E30,0x3F793544,0x3F794C32,0x3F7962F9,0x3F79799A,0x3F799014,0x3F79A668,0x3F79BC95,
0x3F79D29C,0x3F79E87C,0x3F79FE36,0x3F7A13C9,0x3F7A2936,0x3F7A3E7C,0x3F7A539B,0x3F7A6894,
0x3F7A7D66,0x3F7A9212,0x3F7AA697,0x3F7ABAF5,0x3F7ACF2D,0x3F7AE33D,0x3F7AF728,0x3F7B0AEB,
0x3F7B1E88,0x3F7B31FE,0x3F7B454E,0x3F7B5876,0x3F7B6B78,0x3F7B7E53,0x3F7B9107,0x3F7BA395,
0x3F7BB5FC,0x3F7BC83B,0x3F7BDA55,0x3F7BEC47,0x3F7BFE12,0x3F7C0FB7,0x3F7C2134,0x3F7C328B,
0x3F7C43BB,0x3F7C54C4,0x3F7C65A6,0x3F7C7661,0x3F7C86F5,0x3F7C9762,0x3F7CA7A9,0x3F7CB7C8,
0x3F7CC7C0,0x3F7CD792,0x3F7CE73C,0x3F7CF6C0,0x3F7D061C,0x3F7D1551,0x3F7D2460,0x3F7D3347,
0x3F7D4207,0x3F7D50A0,0x3F7D5F13,0x3F7D6D5E,0x3F7D7B82,0x3F7D897E,0x3F7D9754,0x3F7DA503,
0x3F7DB28A,0x3F7DBFEB,0x3F7DCD24,0x3F7DDA36,0x3F7DE721,0x3F7DF3E5,0x3F7E0082,0x3F7E0CF7,
0x3F7E1946,0x3F7E256D,0x3F7E316D,0x3F7E3D46,0x3F7E48F7,0x3F7E5482,0x3F7E5FE5,0x3F7E6B21,
0x3F7E7635,0x3F7E8123,0x3F7E8BE9,0x3F7E9688,0x3F7EA100,0x3F7EAB50,0x3F7EB579,0x3F7EBF7B,
0x3F7EC955,0x3F7ED309,0x3F7EDC95,0x3F7EE5F9,0x3F7EEF37,0x3F7EF84D,0x3F7F013C,0x3F7F0A03,
0x3F7F12A3,0x3F7F1B1C,0x3F7F236D,0x3F7F2B97,0x3F7F339A,0x3F7F3B75,0x3F7F4329,0x3F7F4AB6,
0x3F7F521B,0x3F7F5959,0x3F7F606F,0x3F7F675F,0x3F7F6E26,0x3F7F74C7,0x3F7F7B40,0x3F7F8191,
0x3F7F87BB,0x3F7F8DBE,0x3F7F9399,0x3F7F994D,0x3F7F9EDA,0x3F7FA43F,0x3F7FA97D,0x3F7FAE93,
0x3F7FB382,0x3F7FB849,0x3F7FBCE9,0x3F7FC161,0x3F7FC5B2,0x3F7FC9DC,0x3F7FCDDE,0x3F7FD1B9,
0x3F7FD56C,0x3F7FD8F8,0x3F7FDC5C,0x3F7FDF99,0x3F7FE2AF,0x3F7FE59D,0x3F7FE863,0x3F7FEB02,
0x3F7FED7A,0x3F7FEFCA,0x3F7FF1F3,0x3F7FF3F4,0x3F7FF5CE,0x3F7FF780,0x3F7FF90B,0x3F7FFA6E,
0x3F7FFBAA,0x3F7FFCBE,0x3F7FFDAB,0x3F7FFE70,0x3F7FFF0E,0x3F7FFF85,0x3F7FFFD4,0x3F7FFFFB,
0xBAC90FD5,0xBB96CBC1,0xBBFB5330,0xBC2FED02,0xBC622FFF,0xBC8A3938,0xBCA35A1C,0xBCBC7A9B,
0xBCD59AA6,0xBCEEBA2C,0xBD03EC90,0xBD107BB8,0xBD1D0A88,0xBD2998F6,0xBD3626FC,0xBD42B491,
0xBD4F41AF,0xBD5BCE4C,0xBD685A62,0xBD74E5E9,0xBD80B86C,0xBD86FD94,0xBD8D426A,0xBD9386E7,
0xBD99CB0A,0xBDA00ECF,0xBDA65230,0xBDAC952B,0xBDB2D7BB,0xBDB919DD,0xBDBF5B8D,0xBDC59CC6,
0xBDCBDD86,0xBDD21DC8,0xBDD85D89,0xBDDE9CC4,0xBDE4DB76,0xBDEB199A,0xBDF1572E,0xBDF7942C,
0xBDFDD092,0xBE02062E,0xBE0523C2,0xBE084105,0xBE0B5DF3,0xBE0E7A8B,0xBE1196CC,0xBE14B2B2,
0xBE17CE3D,0xBE1AE96B,0xBE1E0438,0xBE211EA5,0xBE2438AD,0xBE275251,0xBE2A6B8D,0xBE2D8461,
0xBE309CC9,0xBE33B4C4,0xBE36CC50,0xBE39E36C,0xBE3CFA15,0xBE401049,0xBE432607,0xBE463B4D,
0xBE495018,0xBE4C6467,0xBE4F7838,0xBE528B89,0xBE559E58,0xBE58B0A4,0xBE5BC26A,0xBE5ED3A8,
0xBE61E45C,0xBE64F486,0xBE680422,0xBE6B132F,0xBE6E21AB,0xBE712F94,0xBE743CE8,0xBE7749A6,
0xBE7A55CB,0xBE7D6156,0xBE803622,0xBE81BB4A,0xBE834022,0xBE84C4AA,0xBE8648DF,0xBE87CCC1,
0xBE895050,0xBE8AD38A,0xBE8C566E,0xBE8DD8FC,0xBE8F5B32,0xBE90DD10,0xBE925E94,0xBE93DFBF,
0xBE95608D,0xBE96E100,0xBE986116,0xBE99E0CE,0xBE9B6027,0xBE9CDF20,0xBE9E5DB8,0xBE9FDBEE,
0xBEA159C2,0xBEA2D733,0xBEA4543F,0xBEA5D0E5,0xBEA74D25,0xBEA8C8FE,0xBEAA446F,0xBEABBF77,
0xBEAD3A15,0xBEAEB449,0xBEB02E10,0xBEB1A76B,0xBEB32058,0xBEB498D6,0xBEB610E6,0xBEB78884,
0xBEB8FFB2,0xBEBA766E,0xBEBBECB6,0xBEBD628B,0xBEBED7EB,0xBEC04CD5,0xBEC1C148,0xBEC33544,
0xBEC4A8C8,0xBEC61BD2,0xBEC78E62,0xBEC90077,0xBECA7210,0xBECBE32C,0xBECD53CA,0xBECEC3EA,
0xBED0338A,0xBED1A2AA,0xBED31148,0xBED47F64,0xBED5ECFD,0xBED75A13,0xBED8C6A3,0xBEDA32AD,
0xBEDB9E31,0xBEDD092E,0xBEDE73A2,0xBEDFDD8D,0xBEE146EE,0xBEE2AFC4,0xBEE4180E,0xBEE57FCB,
0xBEE6E6FB,0xBEE84D9C,0xBEE9B3AE,0xBEEB1930,0xBEEC7E21,0xBEEDE280,0xBEEF464C,0xBEF0A985,
0xBEF20C29,0xBEF36E38,0xBEF4CFB1,0xBEF63093,0xBEF790DC,0xBEF8F08E,0xBEFA4FA5,0xBEFBAE22,
0xBEFD0C04,0xBEFE694A,0xBEFFC5F3,0xBF0090FF,0xBF013EB5,0xBF01EC1C,0xBF029932,0xBF0345F8,
0xBF03F26D,0xBF049E91,0xBF054A62,0xBF05F5E2,0xBF06A10E,0xBF074BE8,0xBF07F66F,0xBF08A0A1,
0xBF094A7F,0xBF09F409,0xBF0A9D3D,0xBF0B461C,0xBF0BEEA5,0xBF0C96D7,0xBF0D3EB3,0xBF0DE638,
0xBF0E8D65,0xBF0F343B,0xBF0FDAB8,0xBF1080DC,0xBF1126A7,0xBF11CC19,0xBF127130,0xBF1315EE,
0xBF13BA50,0xBF145E58,0xBF150204,0xBF15A554,0xBF164847,0xBF16EADE,0xBF178D18,0xBF182EF5,
0xBF18D073,0xBF197194,0xBF1A1255,0xBF1AB2B8,0xBF1B52BB,0xBF1BF25F,0xBF1C91A2,0xBF1D3084,
0xBF1DCF06,0xBF1E6D26,0xBF1F0AE5,0xBF1FA841,0xBF20453B,0xBF20E1D2,0xBF217E06,0xBF2219D7,
0xBF22B543,0xBF23504B,0xBF23EAEE,0xBF24852C,0xBF251F04,0xBF25B877,0xBF265184,0xBF26EA2A,
0xBF278268,0xBF281A40,0xBF28B1B0,0xBF2948B8,0xBF29DF57,0xBF2A758E,0xBF2B0B5B,0xBF2BA0BF,
0xBF2C35B9,0xBF2CCA49,0xBF2D5E6F,0xBF2DF229,0xBF2E8578,0xBF2F185B,0xBF2FAAD3,0xBF303CDE,
0xBF30CE7C,0xBF315FAD,0xBF31F071,0xBF3280C7,0xBF3310AF,0xBF33A029,0xBF342F34,0xBF34BDCF,
0x3F354BFB,0x3F35D9B8,0x3F366704,0x3F36F3DF,0x3F37804A,0x3F380C43,0x3F3897CB,0x3F3922E1,
0x3F39AD85,0x3F3A37B7,0x3F3AC175,0x3F3B4AC1,0x3F3BD398,0x3F3C5BFC,0x3F3CE3EC,0x3F3D6B67,
0x3F3DF26E,0x3F3E78FF,0x3F3EFF1B,0x3F3F84C0,0x3F4009F0,0x3F408EA9,0x3F4112EC,0x3F4196B7,
0x3F421A0B,0x3F429CE8,0x3F431F4C,0x3F43A138,0x3F4422AB,0x3F44A3A5,0x3F452426,0x3F45A42D,
0x3F4623BB,0x3F46A2CE,0x3F472167,0x3F479F84,0x3F481D27,0x3F489A4E,0x3F4916FA,0x3F499329,
0x3F4A0EDC,0x3F4A8A13,0x3F4B04CC,0x3F4B7F09,0x3F4BF8C7,0x3F4C7208,0x3F4CEACB,0x3F4D6310,
0x3F4DDAD5,0x3F4E521C,0x3F4EC8E4,0x3F4F3F2B,0x3F4FB4F4,0x3F502A3B,0x3F509F03,0x3F51134A,
0x3F518710,0x3F51FA54,0x3F526D18,0x3F52DF59,0x3F535118,0x3F53C255,0x3F54330F,0x3F54A347,
0x3F5512FB,0x3F55822C,0x3F55F0D9,0x3F565F02,0x3F56CCA7,0x3F5739C7,0x3F57A663,0x3F581279,
0x3F587E0B,0x3F58E916,0x3F59539C,0x3F59BD9C,0x3F5A2716,0x3F5A9009,0x3F5AF875,0x3F5B605A,
0x3F5BC7B8,0x3F5C2E8E,0x3F5C94DD,0x3F5CFAA3,0x3F5D5FE1,0x3F5DC497,0x3F5E28C3,0x3F5E8C67,
0x3F5EEF81,0x3F5F5212,0x3F5FB419,0x3F601596,0x3F607689,0x3F60D6F2,0x3F6136D0,0x3F619622,
0x3F61F4EA,0x3F625326,0x3F62B0D7,0x3F630DFC,0x3F636A95,0x3F63C6A1,0x3F642221,0x3F647D14,
0x3F64D77B,0x3F653154,0x3F658AA0,0x3F65E35E,0x3F663B8E,0x3F669330,0x3F66EA45,0x3F6740CA,
0x3F6796C1,0x3F67EC29,0x3F684103,0x3F68954C,0x3F68E907,0x3F693C32,0x3F698ECC,0x3F69E0D7,
0x3F6A3252,0x3F6A833C,0x3F6AD395,0x3F6B235E,0x3F6B7295,0x3F6BC13B,0x3F6C0F50,0x3F6C5CD4,
0x3F6CA9C5,0x3F6CF624,0x3F6D41F2,0x3F6D8D2D,0x3F6DD7D5,0x3F6E21EB,0x3F6E6B6D,0x3F6EB45D,
0x3F6EFCBA,0x3F6F4483,0x3F6F8BB8,0x3F6FD25A,0x3F701867,0x3F705DE1,0x3F70A2C6,0x3F70E717,
0x3F712AD4,0x3F716DFB,0x3F71B08E,0x3F71F28C,0x3F7233F4,0x3F7274C7,0x3F72B504,0x3F72F4AC,
0x3F7333BE,0x3F737239,0x3F73B01F,0x3F73ED6E,0x3F742A27,0x3F746649,0x3F74A1D5,0x3F74DCC9,
0x3F751727,0x3F7550ED,0x3F758A1C,0x3F75C2B3,0x3F75FAB3,0x3F76321B,0x3F7668EC,0x3F769F24,
0x3F76D4C4,0x3F7709CC,0x3F773E3C,0x3F777213,0x3F77A551,0x3F77D7F7,0x3F780A04,0x3F783B77,
0x3F786C52,0x3F789C93,0x3F78CC3B,0x3F78FB4A,0x3F7929BF,0x3F79579A,0x3F7984DC,0x3F79B183,
0x3F79DD91,0x3F7A0904,0x3F7A33DD,0x3F7A5E1C,0x3F7A87C1,0x3F7AB0CB,0x3F7AD93A,0x3F7B010E,
0x3F7B2848,0x3F7B4EE7,0x3F7B74EA,0x3F7B9A53,0x3F7BBF20,0x3F7BE353,0x3F7C06E9,0x3F7C29E5,
0x3F7C4C44,0x3F7C6E08,0x3F7C8F31,0x3F7CAFBD,0x3F7CCFAE,0x3F7CEF03,0x3F7D0DBC,0x3F7D2BD8,
0x3F7D4959,0x3F7D663D,0x3F7D8285,0x3F7D9E30,0x3F7DB940,0x3F7DD3B2,0x3F7DED88,0x3F7E06C2,
0x3F7E1F5E,0x3F7E375E,0x3F7E4EC1,0x3F7E6588,0x3F7E7BB1,0x3F7E913D,0x3F7EA62D,0x3F7EBA7F,
0x3F7ECE34,0x3F7EE14C,0x3F7EF3C7,0x3F7F05A4,0x3F7F16E4,0x3F7F2787,0x3F7F378C,0x3F7F46F4,
0x3F7F55BF,0x3F7F63EC,0x3F7F717B,0x3F7F7E6D,0x3F7F8AC2,0x3F7F9678,0x3F7FA191,0x3F7FAC0D,
0x3F7FB5EA,0x3F7FBF2A,0x3F7FC7CC,0x3F7FCFD1,0x3F7FD737,0x3F7FDE00,0x3F7FE42B,0x3F7FE9B8,
0x3F7FEEA7,0x3F7FF2F8,0x3F7FF6AC,0x3F7FF9C1,0x3F7FFC39,0x3F7FFE13,0x3F7FFF4E,0x3F7FFFEC,
0xBB490FC6,0xBC16CB58,0xBC7B514B,0xBCAFEA69,0xBCE22A7A,0xBD0A342F,0xBD2351CB,0xBD3C6DD5,
0xBD55880E,0xBD6EA038,0xBD83DB0A,0xBD9064B4,0xBD9CECF9,0xBDA973BA,0xBDB5F8DA,0xBDC27C39,
0xBDCEFDB7,0xBDDB7D37,0xBDE7FA9A,0xBDF475C0,0xBE007745,0xBE06B26E,0xBE0CEC4A,0xBE1324CA,
0xBE195BE0,0xBE1F917B,0xBE25C58C,0xBE2BF804,0xBE3228D4,0xBE3857EC,0xBE3E853E,0xBE44B0B9,
0xBE4ADA4F,0xBE5101F1,0xBE57278F,0xBE5D4B1A,0xBE636C83,0xBE698BBA,0xBE6FA8B2,0xBE75C35A,
0xBE7BDBA4,0xBE80F8C0,0xBE840270,0xBE870ADA,0xBE8A11F7,0xBE8D17C0,0xBE901C2C,0xBE931F35,
0xBE9620D2,0xBE9920FE,0xBE9C1FAF,0xBE9F1CDF,0xBEA21887,0xBEA5129F,0xBEA80B1F,0xBEAB0201,
0xBEADF73C,0xBEB0EACB,0xBEB3DCA5,0xBEB6CCC3,0xBEB9BB1E,0xBEBCA7AF,0xBEBF926F,0xBEC27B55,
0xBEC5625C,0xBEC8477C,0xBECB2AAE,0xBECE0BEA,0xBED0EB2A,0xBED3C867,0xBED6A399,0xBED97CB9,
0xBEDC53C1,0xBEDF28A9,0xBEE1FB6A,0xBEE4CBFE,0xBEE79A5D,0xBEEA6681,0xBEED3063,0xBEEFF7FB,
0xBEF2BD43,0xBEF58035,0xBEF840C8,0xBEFAFEF7,0xBEFDBABB,0xBF003A06,0xBF019573,0xBF02EF9F,
0xBF044889,0xBF05A02C,0xBF06F686,0xBF084B92,0xBF099F4E,0xBF0AF1B7,0xBF0C42C9,0xBF0D9281,
0xBF0EE0DB,0xBF102DD5,0xBF11796B,0xBF12C39A,0xBF140C5F,0xBF1553B7,0xBF16999F,0xBF17DE12,
0xBF19210F,0xBF1A6293,0xBF1BA299,0xBF1CE11F,0xBF1E1E22,0xBF1F599F,0xBF209393,0xBF21CBFB,
0xBF2302D3,0xBF24381A,0xBF256BCB,0xBF269DE3,0xBF27CE61,0xBF28FD41,0xBF2A2A80,0xBF2B561B,
0xBF2C800F,0xBF2DA859,0xBF2ECEF7,0xBF2FF3E6,0xBF311722,0xBF3238AA,0xBF33587A,0xBF34768F,
0x3F3592E7,0x3F36AD7F,0x3F37C655,0x3F38DD65,0x3F39F2AC,0x3F3B0629,0x3F3C17D9,0x3F3D27B8,
0x3F3E35C5,0x3F3F41FC,0x3F404C5C,0x3F4154E1,0x3F425B89,0x3F436051,0x3F446337,0x3F456439,
0x3F466354,0x3F476085,0x3F485BCA,0x3F495521,0x3F4A4C87,0x3F4B41FA,0x3F4C3578,0x3F4D26FD,
0x3F4E1689,0x3F4F0417,0x3F4FEFA8,0x3F50D937,0x3F51C0C2,0x3F52A649,0x3F5389C7,0x3F546B3B,
0x3F554AA4,0x3F5627FE,0x3F570348,0x3F57DC7F,0x3F58B3A1,0x3F5988AD,0x3F5A5BA0,0x3F5B2C79,
0x3F5BFB34,0x3F5CC7D1,0x3F5D924D,0x3F5E5AA6,0x3F5F20DB,0x3F5FE4E9,0x3F60A6CF,0x3F61668A,
0x3F62241A,0x3F62DF7B,0x3F6398AC,0x3F644FAC,0x3F650479,0x3F65B710,0x3F666771,0x3F671599,
0x3F67C187,0x3F686B39,0x3F6912AE,0x3F69B7E4,0x3F6A5AD9,0x3F6AFB8C,0x3F6B99FB,0x3F6C3624,
0x3F6CD007,0x3F6D67A1,0x3F6DFCF2,0x3F6E8FF8,0x3F6F20B0,0x3F6FAF1B,0x3F703B37,0x3F70C501,
0x3F714C7A,0x3F71D19F,0x3F725470,0x3F72D4EB,0x3F73530E,0x3F73CED9,0x3F74484B,0x3F74BF62,
0x3F75341D,0x3F75A67B,0x3F76167A,0x3F76841B,0x3F76EF5B,0x3F77583A,0x3F77BEB7,0x3F7822D1,
0x3F788486,0x3F78E3D6,0x3F7940C0,0x3F799B43,0x3F79F35E,0x3F7A4910,0x3F7A9C59,0x3F7AED37,
0x3F7B3BAB,0x3F7B87B2,0x3F7BD14D,0x3F7C187A,0x3F7C5D3A,0x3F7C9F8A,0x3F7CDF6C,0x3F7D1CDD,
0x3F7D57DE,0x3F7D906E,0x3F7DC68C,0x3F7DFA38,0x3F7E2B72,0x3F7E5A38,0x3F7E868B,0x3F7EB069,
0x3F7ED7D4,0x3F7EFCC9,0x3F7F1F49,0x3F7F3F54,0x3F7F5CE9,0x3F7F7808,0x3F7F90B1,0x3F7FA6E3,
0x3F7FBA9E,0x3F7FCBE2,0x3F7FDAAF,0x3F7FE705,0x3F7FF0E3,0x3F7FF84A,0x3F7FFD39,0x3F7FFFB1,
0xBBC90F88,0xBC96C9B6,0xBCFB49BA,0xBD2FE007,0xBD621469,0xBD8A200A,0xBDA3308C,0xBDBC3AC3,
0xBDD53DB9,0xBDEE3876,0xBE039502,0xBE1008B7,0xBE1C76DE,0xBE28DEFC,0xBE354098,0xBE419B37,
0xBE4DEE60,0xBE5A3997,0xBE667C66,0xBE72B651,0xBE7EE6E1,0xBE8586CE,0xBE8B9507,0xBE919DDD,
0xBE97A117,0xBE9D9E78,0xBEA395C5,0xBEA986C4,0xBEAF713A,0xBEB554EC,0xBEBB31A0,0xBEC1071E,
0xBEC6D529,0xBECC9B8B,0xBED25A09,0xBED8106B,0xBEDDBE79,0xBEE363FA,0xBEE900B7,0xBEEE9479,
0xBEF41F07,0xBEF9A02D,0xBEFF17B2,0xBF0242B1,0xBF04F484,0xBF07A136,0xBF0A48AD,0xBF0CEAD0,
0xBF0F8784,0xBF121EB0,0xBF14B039,0xBF173C07,0xBF19C200,0xBF1C420C,0xBF1EBC12,0xBF212FF9,
0xBF239DA9,0xBF26050A,0xBF286605,0xBF2AC082,0xBF2D1469,0xBF2F61A5,0xBF31A81D,0xBF33E7BC,
0x3F36206C,0x3F385216,0x3F3A7CA4,0x3F3CA003,0x3F3EBC1B,0x3F40D0DA,0x3F42DE29,0x3F44E3F5,
0x3F46E22A,0x3F48D8B3,0x3F4AC77F,0x3F4CAE79,0x3F4E8D90,0x3F5064AF,0x3F5233C6,0x3F53FAC3,
0x3F55B993,0x3F577026,0x3F591E6A,0x3F5AC450,0x3F5C61C7,0x3F5DF6BE,0x3F5F8327,0x3F6106F2,
0x3F628210,0x3F63F473,0x3F655E0B,0x3F66BECC,0x3F6816A8,0x3F696591,0x3F6AAB7B,0x3F6BE858,
0x3F6D1C1D,0x3F6E46BE,0x3F6F6830,0x3F708066,0x3F718F57,0x3F7294F8,0x3F73913F,0x3F748422,
0x3F756D97,0x3F764D97,0x3F772417,0x3F77F110,0x3F78B47B,0x3F796E4E,0x3F7A1E84,0x3F7AC516,
0x3F7B61FC,0x3F7BF531,0x3F7C7EB0,0x3F7CFE73,0x3F7D7474,0x3F7DE0B1,0x3F7E4323,0x3F7E9BC9,
0x3F7EEA9D,0x3F7F2F9D,0x3F7F6AC7,0x3F7F9C18,0x3F7FC38F,0x3F7FE129,0x3F7FF4E6,0x3F7FFEC4,
0xBC490E90,0xBD16C32C,0xBD7B2B74,0xBDAFB680,0xBDE1BC2E,0xBE09CF86,0xBE22ABB6,0xBE3B6ECF,
0xBE541501,0xBE6C9A7F,0xBE827DC0,0xBE8E9A22,0xBE9AA086,0xBEA68F12,0xBEB263EF,0xBEBE1D4A,
0xBEC9B953,0xBED53641,0xBEE0924F,0xBEEBCBBB,0xBEF6E0CB,0xBF00E7E4,0xBF064B82,0xBF0B9A6B,
0xBF10D3CD,0xBF15F6D9,0xBF1B02C6,0xBF1FF6CB,0xBF24D225,0xBF299415,0xBF2E3BDE,0xBF32C8C9,
0x3F373A23,0x3F3B8F3B,0x3F3FC767,0x3F43E200,0x3F47DE65,0x3F4BBBF8,0x3F4F7A1F,0x3F531849,
0x3F5695E5,0x3F59F26A,0x3F5D2D53,0x3F604621,0x3F633C5A,0x3F660F88,0x3F68BF3C,0x3F6B4B0C,
0x3F6DB293,0x3F6FF573,0x3F721352,0x3F740BDD,0x3F75DEC6,0x3F778BC5,0x3F791298,0x3F7A7302,
0x3F7BACCD,0x3F7CBFC9,0x3F7DABCC,0x3F7E70B0,0x3F7F0E58,0x3F7F84AB,0x3F7FD397,0x3F7FFB11};
#endif //BUILD_INT_FLOAT

#ifdef BUILD_INTEGER
const Int g_SinTableForReconstruction[(2048+1024+512+256+128+64)] = {
0xDBC1FFF9,0x9342FFED,0x4AC4FFE0,0x246FFD4 ,0xB9C9FFC7,0x714DFFBA,0x28D3FFAE,0xE05AFFA1,
0x97E3FF95,0x4F6EFF88,0x6FBFF7C ,0xBE8BFF6F,0x761DFF62,0x2DB3FF56,0xE54CFF49,0x9CE8FF3D,
0x5489FF30,0xC2DFF24 ,0xC3D5FF17,0x7B82FF0A,0x3334FEFE,0xEAEAFEF1,0xA2A6FEE5,0x5A67FED8,
0x122EFECC,0xC9FBFEBF,0x81CEFEB3,0x39A8FEA6,0xF188FE99,0xA96FFE8D,0x615DFE80,0x1953FE74,
0xD150FE67,0x8955FE5B,0x4162FE4E,0xF978FE41,0xB196FE35,0x69BDFE28,0x21EDFE1C,0xDA26FE0F,
0x9269FE03,0x4AB6FDF6,0x30DFDEA ,0xBB6EFDDD,0x73D9FDD0,0x2C50FDC4,0xE4D1FDB7,0x9D5EFDAB,
0x55F6FD9E,0xE9AFD92 ,0xC74AFD85,0x8006FD79,0x38CFFD6C,0xF1A4FD5F,0xAA87FD53,0x6376FD46,
0x1C73FD3A,0xD57EFD2D,0x8E96FD21,0x47BDFD14,0xF2FD08  ,0xBA36FCFB,0x7389FCEE,0x2CEAFCE2,
0xE65BFCD5,0x9FDCFCC9,0x596DFCBC,0x130EFCB0,0xCCBFFCA3,0x8680FC97,0x4053FC8A,0xFA37FC7D,
0xB42BFC71,0x6E32FC64,0x284AFC58,0xE274FC4B,0x9CB1FC3F,0x5700FC32,0x1162FC26,0xCBD7FC19,
0x865FFC0D,0x40FAFC00,0xFBAAFBF3,0xB66DFBE7,0x7145FBDA,0x2C30FBCE,0xE731FBC1,0xA247FBB5,
0x5D71FBA8,0x18B2FB9C,0xD408FB8F,0x8F73FB83,0x4AF5FB76,0x68DFB6A ,0xC23CFB5D,0x7E02FB50,
0x39DFFB44,0xF5D3FB37,0xB1DFFB2B,0x6E03FB1E,0x2A3FFB12,0xE693FB05,0xA2FFFAF9,0x5F85FAEC,
0x1C23FAE0,0xD8DBFAD3,0x95ACFAC7,0x5297FABA,0xF9DFAAE ,0xCCBCFAA1,0x89F6FA95,0x474AFA88,
0x4BAFA7C ,0xC245FA6F,0x7FEBFA62,0x3DADFA56,0xFB8BFA49,0xB985FA3D,0x779BFA30,0x35CEFA24,
0xF41EFA17,0xB28CFA0B,0x7116F9FE,0x2FBEF9F2,0xEE84F9E5,0xAD69F9D9,0x6C6BF9CC,0x2B8CF9C0,
0xEACCF9B3,0xAA2BF9A7,0x69AAF99A,0x2948F98E,0xE906F981,0xA8E3F975,0x68E1F968,0x2900F95C,
0xE93FF94F,0xA9A0F943,0x6A21F936,0x2AC4F92A,0xEB89F91D,0xAC70F911,0x6D79F904,0x2EA4F8F8,
0xEFF3F8EB,0xB164F8DF,0x72F8F8D2,0x34AFF8C6,0xF68BF8B9,0xB88AF8AD,0x7AADF8A0,0x3CF5F894,
0xFF61F887,0xC1F3F87B,0x84A9F86F,0x4784F862,0xA86F856 ,0xCDADF849,0x90FAF83D,0x546DF830,
0x1807F824,0xDBC8F817,0x9FAFF80B,0x63BEF7FE,0x27F5F7F2,0xEC53F7E5,0xB0D9F7D9,0x7588F7CC,
0x3A5FF7C0,0xFF5EF7B3,0xC487F7A7,0x89D9F79B,0x4F54F78E,0x14F8F782,0xDAC7F775,0xA0C0F769,
0x66E3F75C,0x2D31F750,0xF3AAF743,0xBA4EF737,0x811DF72B,0x4818F71E,0xF3EF712 ,0xD691F705,
0x9E10F6F9,0x65BBF6EC,0x2D94F6E0,0xF599F6D3,0xBDCCF6C7,0x862CF6BB,0x4EB9F6AE,0x1775F6A2,
0xE05FF695,0xA978F689,0x72BFF67C,0x3C35F670,0x5DAF664 ,0xCFAFF657,0x99B3F64B,0x63E8F63E,
0x2E4CF632,0xF8E1F625,0xC3A6F619,0x8E9DF60D,0x59C4F600,0x251DF5F4,0xF0A7F5E7,0xBC63F5DB,
0x8851F5CF,0x5472F5C2,0x20C5F5B6,0xED4AF5A9,0xBA03F59D,0x86EFF591,0x540EF584,0x2162F578,
0xEEE9F56B,0xBCA4F55F,0x8A94F553,0x58B8F546,0x2712F53A,0xF5A0F52D,0xC464F521,0x935EF515,
0x628DF508,0x31F3F4FC,0x18FF4F0 ,0xD161F4E3,0xA16BF4D7,0x71ABF4CA,0x4223F4BE,0x12D2F4B2,
0xE3B9F4A5,0xB4D8F499,0x8630F48D,0x57C0F480,0x2988F474,0xFB8AF467,0xCDC5F45B,0xA039F44F,
0x72E7F442,0x45CFF436,0x18F1F42A,0xEC4DF41D,0xBFE4F411,0x93B6F405,0x67C3F3F8,0x3C0BF3EC,
0x108FF3E0,0xE54FF3D3,0xBA4BF3C7,0x8F83F3BB,0x64F8F3AE,0x3AAAF3A2,0x1098F396,0xE6C4F389,
0xBD2DF37D,0x93D4F371,0x6AB9F364,0x41DDF358,0x193EF34C,0xF0DFF33F,0xC8BEF333,0xA0DCF327,
0x793AF31A,0x51D8F30E,0x2AB5F302,0x3D2F2F6 ,0xDD30F2E9,0xB6CFF2DD,0x90AEF2D1,0x6ACEF2C4,
0x4530F2B8,0x1FD3F2AC,0xFAB8F29F,0xD5DEF293,0xB147F287,0x8CF3F27B,0x68E1F26E,0x4513F262,
0x2187F256,0xFE3FF249,0xDB3AF23D,0xB87AF231,0x95FDF225,0x73C5F218,0x51D2F20C,0x3023F200,
0xEB9F1F4 ,0xED95F1E7,0xCCB6F1DB,0xAC1DF1CF,0x8BCBF1C3,0x6BBEF1B6,0x4BF8F1AA,0x2C78F19E,
0xD40F192 ,0xEE4FF185,0xCFA5F179,0xB143F16D,0x9329F161,0x7557F154,0x57CDF148,0x3A8CF13C,
0x1D94F130,0xE5F124  ,0xE47FF117,0xC863F10B,0xAC90F0FF,0x9108F0F3,0x75CAF0E6,0x5AD6F0DA,
0x402EF0CE,0x25D0F0C2,0xBBDF0B6 ,0xF1F6F0A9,0xD87AF09D,0xBF4BF091,0xA667F085,0x8DD0F079,
0x7586F06C,0x5D88F060,0x45D8F054,0x2E74F048,0x175FF03C,0x97F030  ,0xEA1DF023,0xD3F2F017,
0xBE15F00B,0xA886EFFF,0x9347EFF3,0x7E57EFE6,0x69B6EFDA,0x5565EFCE,0x4164EFC2,0x2DB3EFB6,
0x1A53EFAA,0x743EF9E ,0xF484EF91,0xE216EF85,0xCFF9EF79,0xBE2EEF6D,0xACB4EF61,0x9B8DEF55,
0x8AB8EF49,0x7A35EF3C,0x6A05EF30,0x5A28EF24,0x4A9FEF18,0x3B68EF0C,0x2C86EF00,0x1DF7EEF4,
0xFBCEEE8 ,0x1D6EEDC ,0xF444EECF,0xE707EEC3,0xDA1FEEB7,0xCD8CEEAB,0xC14FEE9F,0xB568EE93,
0xA9D6EE87,0x9E9BEE7B,0x93B7EE6F,0x8929EE63,0x7EF2EE56,0x7512EE4A,0x6B89EE3E,0x6258EE32,
0x597FEE26,0x50FEEE1A,0x48D5EE0E,0x4105EE02,0x398EEDF6,0x326FEDEA,0x2BAAEDDE,0x253EEDD2,
0x1F2DEDC6,0x1974EDBA,0x1417EDAE,0xF13EDA2 ,0xA6AED96 ,0x61CED8A ,0x22AED7E ,0xFE92ED71,
0xFB56ED65,0xF876ED59,0xF5F2ED4D,0xF3CAED41,0xF1FFED35,0xF090ED29,0xEF7EED1D,0xEECAED11,
0xEE73ED05,0xEE79ECF9,0xEEDEECED,0xEFA0ECE1,0xF0C1ECD5,0xF241ECC9,0xF41FECBD,0xF65CECB1,
0xF8F9ECA5,0xFBF5EC99,0xFF51EC8D,0x30DEC82 ,0x729EC76 ,0xBA5EC6A ,0x1082EC5E,0x15C0EC52,
0x1B5FEC46,0x215FEC3A,0x27C1EC2E,0x2E85EC22,0x35ABEC16,0x3D33EC0A,0x451DEBFE,0x4D6AEBF2,
0x561BEBE6,0x5F2EEBDA,0x68A5EBCE,0x727FEBC2,0x7CBEEBB6,0x8760EBAB,0x9267EB9F,0x9DD2EB93,
0xA9A2EB87,0xB5D7EB7B,0xC272EB6F,0xCF72EB63,0xDCD7EB57,0xEAA3EB4B,0xF8D4EB3F,0x76CEB34,
0x166BEB28,0x25D1EB1C,0x359DEB10,0x45D1EB04,0x566DEAF8,0x6770EAEC,0x78DBEAE0,0x8AAFEAD5,
0x9CEBEAC9,0xAF90EABD,0xC29DEAB1,0xD614EAA5,0xE9F4EA99,0xFE3EEA8D,0x12F1EA82,0x280FEA76,
0x3D97EA6A,0x5389EA5E,0x69E6EA52,0x80AEEA47,0x97E1EA3B,0xAF80EA2F,0xC78AEA23,0xE001EA17,
0xF8E3EA0B,0x1232EA00,0x2BEDE9F4,0x4615E9E8,0x60AAE9DC,0x7BACE9D0,0x971CE9C5,0xB2FAE9B9,
0xCF45E9AD,0xEBFFE9A1,0x926E996 ,0x26BDE98A,0x44C2E97E,0x6337E972,0x821BE967,0xA16EE95B,
0xC131E94F,0xE164E943,0x207E938 ,0x231AE92C,0x449FE920,0x6694E914,0x88FAE909,0xABD1E8FD,
0xCF1AE8F1,0xF2D5E8E5,0x1702E8DA,0x3BA1E8CE,0x60B3E8C2,0x8637E8B7,0xAC2EE8AB,0xD298E89F,
0xF976E893,0x20C7E888,0x488CE87C,0x70C5E870,0x9972E865,0xC294E859,0xEC2BE84D,0x1636E842,
0x40B7E836,0x6BADE82A,0x9718E81F,0xC2FAE813,0xEF51E807,0x1C1FE7FC,0x4963E7F0,0x771EE7E4,
0xA550E7D9,0xD3F9E7CD,0x31AE7C2 ,0x32B2E7B6,0x62C2E7AA,0x934AE79F,0xC44AE793,0xF5C3E787,
0x27B5E77C,0x5A1FE770,0x8D03E765,0xC061E759,0xF437E74D,0x2888E742,0x5D53E736,0x9298E72B,
0xC858E71F,0xFE92E713,0x3548E708,0x6C79E6FC,0xA425E6F1,0xDC4CE6E5,0x14F0E6DA,0x4E10E6CE,
0x87ACE6C3,0xC1C5E6B7,0xFC5AE6AB,0x376CE6A0,0x72FCE694,0xAF09E689,0xEB93E67D,0x289CE672,
0x6623E666,0xA428E65B,0xE2ABE64F,0x21ADE644,0x612FE638,0xA12FE62D,0xE1AFE621,0x22AFE616,
0x642EE60A,0xA62EE5FF,0xE8ADE5F3,0x2BAEE5E8,0x6F2FE5DC,0xB331E5D1,0xF7B5E5C5,0x3CB9E5BA,
0x8240E5AF,0xC848E5A3,0xED2E598 ,0x55DFE58C,0x9D6EE581,0xE580E575,0x2E15E56A,0x772DE55E,
0xC0C9E553,0xAE8E548 ,0x558BE53C,0xA0B2E531,0xEC5DE525,0x388DE51A,0x8542E50F,0xD27BE503,
0x203AE4F8,0x6E7EE4EC,0xBD48E4E1,0xC97E4D6 ,0x5C6DE4CA,0xACC9E4BF,0xFDABE4B3,0x4F14E4A8,
0xA104E49D,0xF37BE491,0x467AE486,0x9A00E47B,0xEE0EE46F,0x42A4E464,0x97C2E459,0xED68E44D,
0x4397E442,0x9A50E437,0xF191E42B,0x495BE420,0xA1AFE415,0xFA8DE409,0x53F5E3FE,0xADE7E3F3,
0x864E3E8 ,0x636BE3DC,0xBEFDE3D1,0x1B1AE3C6,0x77C2E3BA,0xD4F6E3AF,0x32B6E3A4,0x9101E399,
0xEFD9E38D,0x4F3DE382,0xAF2DE377,0xFABE36C ,0x70B5E360,0xD24DE355,0x3472E34A,0x9725E33F,
0xFA66E333,0x5E35E328,0xC292E31D,0x277DE312,0x8CF8E307,0xF301E2FB,0x599AE2F0,0xC0C2E2E5,
0x287AE2DA,0x90C1E2CF,0xF999E2C3,0x6300E2B8,0xCCF9E2AD,0x3782E2A2,0xA29BE297,0xE46E28C,
0x7A83E280,0xE751E275,0x54B0E26A,0xC2A2E25F,0x3126E254,0xA03CE249,0xFE5E23E ,0x8021E233,
0xF0F0E227,0x6252E21C,0xD447E211,0x46D1E206,0xB9EEE1FB,0x2D9FE1F0,0xA1E5E1E5,0x16BFE1DA,
0x8C2EE1CF,0x232E1C4 ,0x78CCE1B8,0xEFFAE1AD,0x67BEE1A2,0xE019E197,0x5909E18C,0xD28FE181,
0x4CACE176,0xC760E16B,0x42AAE160,0xBE8CE155,0x3B05E14A,0xB815E13F,0x35BDE134,0xB3FEE129,
0x32D6E11E,0xB247E113,0x3250E108,0xB2F2E0FD,0x342EE0F2,0xB602E0E7,0x3870E0DC,0xBB78E0D1,
0x3F19E0C6,0xC355E0BB,0x482BE0B0,0xCD9BE0A5,0x53A6E09A,0xDA4CE08F,0x618DE084,0xE96AE079,
0x71E2E06E,0xFAF6E063,0x84A5E059,0xEF2E04E ,0x99DAE043,0x255FE038,0xB181E02D,0x3E40E022,
0xCB9CE017,0x5996E00C,0xE82DE001,0x7762DFF6,0x735DFEC ,0x97A7DFE1,0x28B7DFD6,0xBA66DFCB,
0x4CB4DFC0,0xDFA1DFB5,0x732DDFAA,0x759DFA0 ,0x9C24DF95,0x3190DF8A,0xC79BDF7F,0x5E47DF74,
0xF594DF69,0x8D81DF5F,0x2610DF54,0xBF40DF49,0x5911DF3E,0xF384DF33,0x8E98DF29,0x2A4FDF1E,
0xC6A8DF13,0x63A3DF08,0x141DEFE ,0x9F82DEF3,0x3E67DEE8,0xDDEEDEDD,0x7E19DED2,0x1EE7DEC8,
0xC05ADEBD,0x6271DEB2,0x52CDEA8 ,0xA88BDE9D,0x4C8FDE92,0xF139DE87,0x9687DE7D,0x3C7BDE72,
0xE314DE67,0x8A53DE5D,0x3239DE52,0xDAC4DE47,0x83F6DE3D,0x2DCEDE32,0xD84DDE27,0x8373DE1D,
0x2F41DE12,0xDBB6DE07,0x88D2DDFD,0x3696DDF2,0xE503DDE7,0x9417DDDD,0x43D4DDD2,0xF43ADDC7,
0xA549DDBD,0x5700DDB2,0x961DDA8 ,0xBC6CDD9D,0x7020DD92,0x247EDD88,0xD986DD7D,0x8F38DD73,
0x4595DD68,0xFC9CDD5D,0xB44FDD53,0x6CACDD48,0x25B5DD3E,0xDF6ADD33,0x99CADD29,0x54D6DD1E,
0x108EDD14,0xCCF3DD09,0x8A04DCFF,0x47C1DCF4,0x62CDCEA ,0xC544DCDF,0x8509DCD5,0x457CDCCA,
0x69CDCC0 ,0xC86BDCB5,0x8AE7DCAB,0x4E12DCA0,0x11ECDC96,0xD674DC8B,0x9BABDC81,0x6192DC76,
0x2827DC6C,0xEF6DDC61,0xB762DC57,0x8007DC4D,0x495CDC42,0x1362DC38,0xDE18DC2D,0xA97FDC23,
0x7597DC18,0x4260DC0E,0xFDADC04 ,0xDE06DBF9,0xACE4DBEF,0x7C74DBE4,0x4CB6DBDA,0x1DAADBD0,
0xEF51DBC5,0xC1ABDBBB,0x94B7DBB1,0x6877DBA6,0x3CEADB9C,0x1211DB92,0xE7EBDB87,0xBE7ADB7D,
0x95BDDB73,0x6DB4DB68,0x465FDB5E,0x1FC0DB54,0xF9D5DB49,0xD49FDB3F,0xB01FDB35,0x8C55DB2B,
0x6940DB20,0x46E1DB16,0x2538DB0C,0x446DB02 ,0xE40ADAF7,0xC485DAED,0xA5B7DAE3,0x87A0DAD9,
0x6A40DACE,0x4D98DAC4,0x31A7DABA,0x166FDAB0,0xFBEFDAA5,0xE227DA9B,0xC917DA91,0xB0C0DA87,
0x9923DA7D,0x823EDA73,0x6C12DA68,0x56A0DA5E,0x41E8DA54,0x2DEADA4A,0x1AA5DA40,0x81BDA36,
0xF64CDA2B,0xE537DA21,0xD4DDDA17,0xC53EDA0D,0xB65BDA03,0xA832D9F9,0x9AC6D9EF,0x8E15D9E5,
0x8221D9DB,0x76E8D9D0,0x6C6CD9C6,0x62ADD9BC,0x59AAD9B2,0x5165D9A8,0x49DDD99E,0x4312D994,
0x3D04D98A,0x37B5D980,0x3323D976,0x2F50D96C,0x2C3BD962,0x29E4D958,0x284DD94E,0x2774D944,
0x275AD93A,0x2800D930,0x2965D926,0x2B8AD91C,0x2E6FD912,0x3214D908,0x367AD8FE,0x3B9FD8F4,
0x4186D8EA,0x482DD8E0,0x4F95D8D6,0x57BFD8CC,0x60AAD8C2,0x6A57D8B8,0x74C5D8AE,0x7FF6D8A4,
0x8BE9D89B,0x989ED891,0xA616D887,0xB450D87D,0xC34ED873,0xD30FD869,0xE393D85F,0xF4DAD855,
0x6E6D84C ,0x19B5D842,0x2D48D838,0x41A0D82E,0x56BCD824,0x6C9DD81A,0x8343D811,0x9AAED807,
0xB2DED7FD,0xCBD3D7F3,0xE58ED7E9,0xFD7E0   ,0x1B56D7D6,0x3763D7CC,0x5437D7C2,0x71D1D7B8,
0x9032D7AF,0xAF5AD7A5,0xCF49D79B,0xEFFFD791,0x117DD788,0x33C3D77E,0x56D0D774,0x7AA5D76A,
0x9F43D761,0xC4A9D757,0xEAD8D74D,0x11D0D744,0x3991D73A,0x621BD730,0x8B6ED727,0xB58BD71D,
0xE071D713,0xC22D70A ,0x389DD700,0x65E2D6F6,0x93F1D6ED,0xC2CBD6E3,0xF270D6D9,0x22E0D6D0,
0x541CD6C6,0x8623D6BD,0xB8F5D6B3,0xEC93D6A9,0x20FED6A0,0x5634D696,0x8C37D68D,0xC306D683,
0xFAA2D679,0x330BD670,0x6C41D666,0xA644D65D,0xE115D653,0x1CB3D64A,0x5920D640,0x965AD637,
0xD462D62D,0x1339D624,0x52DFD61A,0x9353D611,0xD496D607,0x16A8D5FE,0x598AD5F4,0x9D3BD5EB,
0xE1BBD5E1,0x270CD5D8,0x6D2CD5CE,0xB41DD5C5,0xFBDED5BB,0x4470D5B2,0x8DD2D5A9,0xD806D59F,
0x230AD596,0x6EE0D58C,0xBB87D583,0x900D57A ,0x574BD570,0xA668D567,0xF657D55D,0x4718D554,
0x98ACD54B,0xEB13D541,0x3E4CD538,0x9259D52F,0xE739D525,0x3CEDD51C,0x9374D513,0xEACFD509,
0x42FED500,0x9C01D4F7,0xF5D8D4ED,0x5085D4E4,0xAC05D4DB,0x85BD4D2 ,0x6586D4C8,0xC386D4BF,
0x225BD4B6,0x8207D4AD,0xE287D4A3,0x43DED49A,0xA60BD491,0x90FD488 ,0x6CE9D47E,0xD199D475,
0x3721D46C,0x9D7FD463,0x4B5D45A ,0x6CC2D450,0xD5A6D447,0x3F63D43E,0xA9F7D435,0x1564D42C,
0x81A8D423,0xEEC5D419,0x5CBBD410,0xCB8AD407,0x3B31D3FE,0xABB2D3F5,0x1D0CD3EC,0x8F40D3E3,
0x24DD3DA ,0x7634D3D0,0xEAF5D3C7,0x6091D3BE,0xD707D3B5,0x4E57D3AC,0xC682D3A3,0x3F88D39A,
0xB969D391,0x3426D388,0xAFBDD37F,0x2C31D376,0xA980D36D,0x27ABD364,0xA6B2D35B,0x2696D352,
0xA756D349,0x28F3D340,0xAB6CD337,0x2EC3D32E,0xB2F7D325,0x3808D31C,0xBDF6D313,0x44C2D30A,
0xCC6DD301,0x54F5D2F8,0xDE5BD2EF,0x68A0D2E6,0xF3C3D2DD,0x7FC5D2D4,0xCA6D2CC ,0x9A66D2C3,
0xD6FA2D45,0x477B2D4E,0xB71D2D57,0x25DF2D60,0x93C12D69,0xC32D72  ,0x6CE52D7A,0xD8262D83,
0x42872D8C,0xAC072D95,0x14A62D9E,0x7C642DA6,0xE3412DAF,0x493C2DB8,0xAE552DC1,0x128D2DCA,
0x75E32DD2,0xD8562DDB,0x39E82DE4,0x9A962DED,0xFA632DF5,0x594C2DFE,0xB7532E07,0x14762E10,
0x70B62E18,0xCC122E21,0x268B2E2A,0x80202E33,0xD8D12E3B,0x309E2E44,0x87872E4D,0xDD8B2E55,
0x32AA2E5E,0x86E52E67,0xDA3A2E6F,0x2CAB2E78,0x7E362E80,0xCEDC2E89,0x1E9C2E92,0x6D762E9A,
0xBB6A2EA3,0x8782EAC ,0x54A02EB4,0x9FE12EBD,0xEA3C2EC5,0x33B02ECE,0x7C3C2ED6,0xC3E22EDF,
0xAA02EE8 ,0x50772EF0,0x95672EF9,0xD96E2F01,0x1C8D2F0A,0x5EC52F12,0xA0142F1B,0xE07A2F23,
0x1FF82F2C,0x5E8D2F34,0x9C3A2F3D,0xD8FD2F45,0x14D72F4E,0x4FC72F56,0x89CE2F5F,0xC2EB2F67,
0xFB1E2F6F,0x32672F78,0x68C62F80,0x9E3A2F89,0xD2C42F91,0x6632F9A ,0x39172FA2,0x6AE02FAA,
0x9BBD2FB3,0xCBB02FBB,0xFAB72FC3,0x28D22FCC,0x56012FD4,0x82442FDD,0xAD9B2FE5,0xD8062FED,
0x1842FF6 ,0x2A152FFE,0x51BA3006,0x7872300E,0x9E3C3017,0xC319301F,0xE7093027,0xA0B3030,
0x2C1F3038,0x4D453040,0x6D7E3048,0x8CC83051,0xAB233059,0xC8903061,0xE50E3069,0x9D3072,
0x1B3D307A,0x34EE3082,0x4DB0308A,0x65823092,0x7C64309A,0x925630A3,0xA75930AB,0xBB6B30B3,
0xCE8D30BB,0xE0BE30C3,0xF1FF30CB,0x24F30D4 ,0x11AE30DC,0x201C30E4,0x2D9930EC,0x3A2430F4,
0x45BD30FC,0x50653104,0x5A1B310C,0x62DF3114,0x6AB1311C,0x71903124,0x777D312C,0x7C773134,
0x807F313D,0x83933145,0x85B4314D,0x86E23155,0x871D315D,0x86643165,0x84B7316D,0x82163175,
0x7E81317C,0x79F83184,0x747B318C,0x6E093194,0x66A2319C,0x5E4731A4,0x54F631AC,0x4AB131B4,
0x3F7631BC,0x334631C4,0x262031CC,0x180431D4,0x8F331DC ,0xF8EB31E3,0xE7EE31EB,0xD5FA31F3,
0xC30F31FB,0xAF2E3203,0x9A56320B,0x84873213,0x6DC0321A,0x56033222,0x3D4E322A,0x23A23232,
0x8FE323A ,0xED623241,0xD0CE3249,0xB3423251,0x94BE3259,0x75413260,0x54CB3268,0x335D3270,
0x10F63278,0xED96327F,0xC93C3287,0xA3EA328F,0x7D9D3296,0x5658329E,0x2E1832A6,0x4DE32AE,
0xDAAB32B5,0xAF7D32BD,0x835432C5,0x563132CC,0x281432D4,0xF8FB32DB,0xC8E832E3,0x97D932EB,
0x65D032F2,0x32CA32FA,0xFECA3301,0xC9CD3309,0x93D53311,0x5CE03318,0x24F03320,0xEC033327,
0xB21A332F,0x77343336,0x3B51333E,0xFE723345,0xC095334D,0x81BC3355,0x41E5335C,0x1103364,
0xBF3E336B,0x7C6F3372,0x38A1337A,0xF3D53381,0xAE0B3389,0x67433390,0x1F7C3398,0xD6B7339F,
0x8CF333A7,0x423033AE,0xF66E33B5,0xA9AD33BD,0x5BED33C4,0xD2D33CC ,0xBD6D33D3,0x6CAE33DA,
0x1AEF33E2,0xC82F33E9,0x747033F0,0x1FB033F8,0xC9F033FF,0x732F3406,0x1B6E340E,0xC2AB3415,
0x68E8341C,0xE233424 ,0xB25D342B,0x55963432,0xF7CD3439,0x99033441,0x39363448,0xD867344F,
0x76973456,0x13C4345E,0xAFEE3465,0x4B16346C,0xE53C3473,0x7E5E347A,0x167E3482,0xAD9A3489,
0x43B33490,0xD8C93497,0x6CDB349E,0xFFEA34A5,0x91F534AD,0x22FB34B4,0xB2FE34BB,0x41FC34C2,
0xCFF734C9,0x5CEC34D0,0xE8DD34D7,0x73C934DE,0xFDB134E5,0x869334ED,0xE7034F4 ,0x954834FB,
0x1B1A3502,0x9FE73509,0x23AE3510,0xA66F3517,0x282A351E,0xA8DF3525,0x288E352C,0xA7363533,
0x24D8353A,0xA1733541,0x1D083548,0x9795354F,0x111C3556,0x899B355D,0x1133564 ,0x7783356A,
0xECEC3571,0x614D3578,0xD4A6357F,0x46F73586,0xB840358D,0x28803594,0x97B9359B,0x5E935A2,
0x731035A8,0xDF2E35AF,0x4A4335B6,0xB45035BD,0x1D5335C4,0x854D35CB,0xEC3D35D1,0x522435D8,
0xB70135DF,0x1AD435E6,0x7D9D35EC,0xDF5C35F3,0x401135FA,0x9FBB3601,0xFE5B3607,0x5BF1360E,
0xB87B3615,0x13FB361C,0x6E6F3622,0xC7D93629,0x20373630,0x778A3636,0xCDD1363D,0x230D3644,
0x773C364A,0xCA603651,0x1C783658,0x6D84365E,0xBD833665,0xC76366C ,0x5A5C3672,0xA7363679,
0xF303367F,0x3DC33686,0x8776368D,0xD01B3693,0x17B3369A,0x5E3E36A0,0xA3BB36A7,0xE82B36AD,
0x2B8D36B4,0x6DE136BA,0xAF2636C1,0xEF5E36C7,0x2E8736CE,0x6CA236D4,0xA9AE36DB,0xE5AB36E1,
0x209A36E8,0x5A7936EE,0x934A36F5,0xCB0B36FB,0x1BD3702 ,0x37603708,0x6BF3370E,0x9F763715,
0xD1E9371B,0x34D3722 ,0x33A03728,0x62E3372E,0x91163735,0xBE39373B,0xEA4B3741,0x154C3748,
0x3F3C374E,0x681C3754,0x8FEA375B,0xB6A83761,0xDC543767,0xEE376E  ,0x24773774,0x46EF377A,
0x68543780,0x88A83787,0xA7EA378D,0xC6193793,0xE3363799,0xFF41379F,0x1A3A37A6,0x342037AC,
0x4CF337B2,0x64B337B8,0x7B6037BE,0x90FA37C5,0xA58137CB,0xB8F537D1,0xCB5537D7,0xDCA137DD,
0xECDA37E3,0xFBFF37E9,0xA1137F0 ,0x170E37F6,0x22F737FC,0x2DCB3802,0x378C3808,0x4037380E,
0x47CE3814,0x4E51381A,0x53BE3820,0x58173826,0x5B5A382C,0x5D893832,0x5EA23838,0x5EA5383E,
0x5D933844,0x5B6B384A,0x582E3850,0x53DA3856,0x4E71385C,0x47F13862,0x405B3868,0x37AF386E,
0x2DEC3874,0x2313387A,0x17233880,0xA1C3886 ,0xFBFF388B,0xECCA3891,0xDC7E3897,0xCB1B389D,
0xB8A038A3,0xA50E38A9,0x906438AF,0x7AA338B4,0x63C938BA,0x4BD838C0,0x32CF38C6,0x18AD38CC,
0xFD7438D1,0xE12238D7,0xC3B738DD,0xA53438E3,0x859838E9,0x64E338EE,0x431538F4,0x202E38FA,
0xFC2E38FF,0xD7153905,0xB0E2390B,0x89963911,0x61303916,0x37B0391C,0xD173922 ,0xE1643927,
0xB496392D,0x86AF3933,0x57AD3938,0x2791393E,0xF65A3943,0xC4093949,0x909D394F,0x5C163954,
0x2674395A,0xEFB8395F,0xB7E03965,0x7EED396A,0x44DE3970,0x9B53976 ,0xCD6F397B,0x900E3981,
0x51913986,0x11F8398C,0xD1443991,0x8F733997,0x4C86399C,0x87C39A2 ,0xC35739A7,0x7D1439AC,
0x35B639B2,0xED3A39B7,0xA3A239BD,0x58EC39C2,0xD1A39C8 ,0xC02A39CD,0x721E39D2,0x22F339D8,
0xD2AC39DD,0x814739E3,0x2EC439E8,0xDB2339ED,0x866539F3,0x308939F8,0xD98E39FD,0x81753A03,
0x283E3A08,0xCDE93A0D,0x72753A12,0x15E33A18,0xB8323A1D,0x59623A22,0xF9733A27,0x98663A2D,
0x36393A32,0xD2ED3A37,0x6E823A3C,0x8F73A42 ,0xA24D3A47,0x3A833A4C,0xD19A3A51,0x67903A56,
0xFC673A5B,0x901E3A61,0x22B53A66,0xB42C3A6B,0x44823A70,0xD3B83A75,0x61CD3A7A,0xEEC23A7F,
0x7A963A84,0x54A3A8A ,0x8EDC3A8F,0x174E3A94,0x9E9E3A99,0x24CE3A9E,0xA9DC3AA3,0x2DC83AA8,
0xB0933AAD,0x323D3AB2,0xB2C53AB7,0x322B3ABC,0xB0703AC1,0x2D923AC6,0xA9923ACB,0x24713AD0,
0x9E2D3AD5,0x16C63ADA,0x8E3D3ADF,0x4923AE4 ,0x79C43AE8,0xEDD43AED,0x60C03AF2,0xD28A3AF7,
0x43313AFC,0xB2B43B01,0x21153B06,0x8E523B0B,0xFA6C3B0F,0x65623B14,0xCF353B19,0x37E43B1E,
0x9F6F3B23,0x5D73B28 ,0x6B1B3B2C,0xCF3A3B31,0x32363B36,0x940D3B3B,0xF4C03B3F,0x544F3B44,
0xB2B93B49,0xFFF3B4E ,0x6C1F3B52,0xC71C3B57,0x20F33B5C,0x79A53B60,0xD1333B65,0x279B3B6A,
0x7CDE3B6E,0xD0FC3B73,0x23F43B78,0x75C73B7C,0xC6753B81,0x15FC3B86,0x645E3B8A,0xB19A3B8F,
0xFDB13B93,0x48A13B98,0x926B3B9D,0xDB0F3BA1,0x228D3BA6,0x68E43BAA,0xAE153BAF,0xF21F3BB3,
0x35033BB8,0x76C03BBC,0xB7563BC1,0xF6C53BC5,0x350E3BCA,0x722F3BCE,0xAE293BD3,0xE8FC3BD7,
0x22A83BDC,0x5B2C3BE0,0x92893BE5,0xC8BE3BE9,0xFDCB3BED,0x31B13BF2,0x646F3BF6,0x96053BFB,
0xC6733BFF,0xF5B93C03,0x23D73C08,0x50CD3C0C,0x7C9A3C10,0xA73F3C15,0xD0BB3C19,0xF90F3C1D,
0x203A3C22,0x463C3C26,0x6B153C2A,0x8EC63C2F,0xB14E3C33,0xD2AC3C37,0xF2E13C3B,0x11ED3C40,
0x2FD03C44,0x4C8A3C48,0x68193C4C,0x82803C51,0x9BBC3C55,0xB3CF3C59,0xCAB83C5D,0xE0783C61,
0xF50D3C65,0x8783C6A ,0x1AB93C6E,0x2BD03C72,0x3BBC3C76,0x4A7F3C7A,0x58163C7E,0x64843C82,
0x6FC63C86,0x79DE3C8A,0x82CB3C8F,0x8A8D3C93,0x91253C97,0x96913C9B,0x9AD23C9F,0x9DE93CA3,
0x9FD43CA7,0xA0933CAB,0xA0273CAF,0x9E903CB3,0x9BCD3CB7,0x97DF3CBB,0x92C53CBF,0x8C7F3CC3,
0x850D3CC7,0x7C6F3CCA,0x72A63CCE,0x67B03CD2,0x5B8E3CD6,0x4E403CDA,0x3FC53CDE,0x301F3CE2,
0x1F4B3CE6,0xD4B3CEA ,0xFA1F3CED,0xE5C63CF1,0xD0403CF5,0xB98E3CF9,0xA1AE3CFD,0x88A13D01,
0x6E683D04,0x53013D08,0x366D3D0C,0x18AC3D10,0xF9BE3D13,0xD9A23D17,0xB8593D1B,0x95E23D1F,
0x723D3D22,0x4D6B3D26,0x276B3D2A,0x3D3D2E  ,0xD7E13D31,0xAE583D35,0x83A03D39,0x57BA3D3C,
0x2AA63D40,0xFC643D43,0xCCF33D47,0x9C543D4B,0x6A863D4E,0x378A3D52,0x3603D56 ,0xCE063D59,
0x977E3D5D,0x5FC73D60,0x26E13D64,0xECCC3D67,0xB1893D6B,0x75163D6E,0x37743D72,0xF8A23D75,
0xB8A23D79,0x77723D7C,0x35123D80,0xF1833D83,0xACC53D87,0x66D73D8A,0x1FB93D8E,0xD76B3D91,
0x8DEE3D95,0x43413D98,0xF7643D9B,0xAA563D9F,0x5C193DA2,0xCAB3DA6 ,0xBC0E3DA9,0x6A403DAC,
0x17413DB0,0xC3123DB3,0x6DB33DB6,0x17233DBA,0xBF633DBD,0x66723DC0,0xC503DC4 ,0xB0FD3DC7,
0x54793DCA,0xF6C53DCD,0x97E03DD1,0x37C93DD4,0xD6813DD7,0x74093DDA,0x105E3DDE,0xAB833DE1,
0x45763DE4,0xDE383DE7,0x75C93DEA,0xC273DEE ,0xA1553DF1,0x35503DF4,0xC81A3DF7,0x59B23DFA,
0xEA183DFD,0x794C3E00,0x74E3E04 ,0x941F3E07,0x1FBD3E0A,0xAA293E0D,0x33623E10,0xBB6A3E13,
0x423F3E16,0xC7E23E19,0x4C523E1C,0xCF903E1F,0x519B3E22,0xD2733E25,0x52193E28,0xD08C3E2B,
0x4DCD3E2E,0xC9DA3E31,0x44B53E34,0xBE5C3E37,0x36D13E3A,0xAE133E3D,0x24213E40,0x98FC3E43,
0xCA43E46 ,0x7F193E48,0xF05A3E4B,0x60683E4E,0xCF423E51,0x3CE93E54,0xA95C3E57,0x149C3E5A,
0x7EA83E5C,0xE7803E5F,0x4F243E62,0xB5943E65,0x1AD13E68,0x7EDA3E6A,0xE1AE3E6D,0x434F3E70,
0xA3BB3E73,0x2F33E76 ,0x60F73E78,0xBDC73E7B,0x19623E7E,0x73C93E80,0xCCFC3E83,0x24FA3E86,
0x7BC33E88,0xD1583E8B,0x25B83E8E,0x78E43E90,0xCADB3E93,0x1B9C3E96,0x6B2A3E98,0xB9823E9B,
0x6A53E9E ,0x52933EA0,0x9D4C3EA3,0xE6D13EA5,0x2F203EA8,0x76393EAA,0xBC1E3EAD,0xCD3EB0,
0x44473EB2,0x868B3EB5,0xC79A3EB7,0x7743EBA ,0x46183EBC,0x83863EBF,0xBFBF3EC1,0xFAC23EC3,
0x348F3EC6,0x6D263EC8,0xA4883ECB,0xDAB43ECD,0xFAA3ED0 ,0x436A3ED2,0x75F43ED4,0xA7473ED7,
0xD7653ED9,0x64D3EDC ,0x33FE3EDE,0x60793EE0,0x8BBE3EE3,0xB5CC3EE5,0xDEA53EE7,0x6463EEA,
0x2CB13EEC,0x51E63EEE,0x75E43EF0,0x98AC3EF3,0xBA3D3EF5,0xDA973EF7,0xF9BA3EF9,0x17A73EFC,
0x345D3EFE,0x4FDC3F00,0x6A243F02,0x83353F05,0x9B0F3F07,0xB1B33F09,0xC71F3F0B,0xDB543F0D,
0xEE513F0F,0x183F12  ,0x10A73F14,0x20003F16,0x2E203F18,0x3B0A3F1A,0x46BC3F1C,0x51363F1E,
0x5A793F20,0x62853F22,0x69593F24,0x6EF53F26,0x735A3F28,0x76873F2A,0x787C3F2C,0x793A3F2E,
0x78C03F30,0x770E3F32,0x74243F34,0x70023F36,0x6AA83F38,0x64163F3A,0x5C4D3F3C,0x534B3F3E,
0x49113F40,0x3D9F3F42,0x30F43F44,0x23123F46,0x13F73F48,0x3A43F4A ,0xF2193F4B,0xDF553F4D,
0xCB593F4F,0xB6243F51,0x9FB73F53,0x88123F55,0x6F343F56,0x551D3F58,0x39CE3F5A,0x1D463F5C,
0xFF863F5D,0xE08D3F5F,0xC05B3F61,0x9EF03F63,0x7C4D3F64,0x58703F66,0x335B3F68,0xD0D3F6A,
0xE5863F6B,0xBCC63F6D,0x92CD3F6F,0x679B3F70,0x3B303F72,0xD8B3F74 ,0xDEAE3F75,0xAE983F77,
0x7D483F78,0x4ABF3F7A,0x16FD3F7C,0xE2013F7D,0xABCC3F7F,0x745E3F80,0x3BB73F82,0x1D63F84,
0xC6BC3F85,0x8A683F87,0x4CDA3F88,0xE143F8A ,0xCE133F8B,0x8CD93F8D,0x4A653F8E,0x6B83F90,
0xC1D13F91,0x7BB13F92,0x34563F94,0xEBC23F95,0xA1F43F97,0x56ED3F98,0xAAB3F9A ,0xBD303F9B,
0x6E7B3F9C,0x1E8B3F9E,0xCD623F9F,0x7AFF3FA0,0x27623FA2,0xD28B3FA3,0x7C7A3FA4,0x252F3FA6,
0xCCA93FA7,0x72EA3FA8,0x17F03FAA,0xBBBC3FAB,0x5E4E3FAC,0xFFA63FAD,0x9FC43FAF,0x3EA73FB0,
0xDC503FB1,0x78BF3FB2,0x13F33FB4,0xADED3FB5,0x46AD3FB6,0xDE323FB7,0x747C3FB8,0x98D3FBA,
0x9D633FBB,0x2FFE3FBC,0xC15F3FBD,0x51853FBE,0xE0703FBF,0x6E223FC0,0xFA983FC1,0x85D43FC3,
0xFD53FC4 ,0x989B3FC5,0x20273FC6,0xA6783FC7,0x2B8F3FC8,0xAF6A3FC9,0x320B3FCA,0xB3713FCB,
0x339C3FCC,0xB28D3FCD,0x30423FCE,0xACBD3FCF,0x27FD3FD0,0xA2023FD1,0x1ACC3FD2,0x925B3FD3,
0x8AF3FD4 ,0x7DC83FD4,0xF1A63FD5,0x64493FD6,0xD5B13FD7,0x45DE3FD8,0xB4D03FD9,0x22863FDA,
0x8F023FDB,0xFA433FDB,0x64483FDC,0xCD133FDD,0x34A23FDE,0x9AF63FDF,0xE3FE0   ,0x63EC3FE0,
0xC68E3FE1,0x27F53FE2,0x88213FE3,0xE7123FE3,0x44C73FE4,0xA1413FE5,0xFC803FE5,0x56833FE6,
0xAF4B3FE7,0x6D83FE8 ,0x5D293FE8,0xB23F3FE9,0x61A3FEA ,0x58B93FEA,0xAA1C3FEB,0xFA453FEB,
0x49313FEC,0x96E33FED,0xE3593FED,0x2E933FEE,0x78923FEE,0xC1563FEF,0x8DE3FF0 ,0x4F2A3FF0,
0x943B3FF1,0xD8103FF1,0x1AAA3FF2,0x5C083FF2,0x9C2B3FF3,0xDB123FF3,0x18BE3FF4,0x552D3FF4,
0x90623FF5,0xCA5A3FF5,0x3173FF6 ,0x3A993FF6,0x70DF3FF6,0xA5E93FF7,0xD9B73FF7,0xC4A3FF8,
0x3DA13FF8,0x6DBC3FF8,0x9C9C3FF9,0xCA403FF9,0xF6A93FF9,0x21D53FFA,0x4BC63FFA,0x747B3FFA,
0x9BF53FFB,0xC2333FFB,0xE7343FFB,0xAFB3FFC ,0x2D853FFC,0x4ED43FFC,0x6EE73FFC,0x8DBE3FFD,
0xAB5A3FFD,0xC7B93FFD,0xE2DD3FFD,0xFCC53FFD,0x15713FFE,0x2CE23FFE,0x43173FFE,0x58103FFE,
0x6BCD3FFE,0x7E4E3FFE,0x8F933FFF,0x9F9D3FFF,0xAE6B3FFF,0xBBFD3FFF,0xC8533FFF,0xD36E3FFF,
0xDD4C3FFF,0xE5EF3FFF,0xED563FFF,0xF3813FFF,0xF8713FFF,0xFC243FFF,0xFE9C3FFF,0xFFD83FFF,
0xB781FFF3,0x2685FFDA,0x958BFFC1,0x496FFA8 ,0x73A8FF8E,0xE2C3FF75,0x51E8FF5C,0xC11AFF43,
0x305AFF2A,0x9FABFF11,0xF0EFEF8 ,0x7E86FEDE,0xEE14FEC5,0x5DBAFEAC,0xCD7BFE93,0x3D57FE7A,
0xAD51FE61,0x1D6CFE48,0x8DA8FE2F,0xFE08FE15,0x6E8EFDFC,0xDF3CFDE3,0x5013FDCA,0xC116FDB1,
0x3247FD98,0xA3A7FD7F,0x1538FD66,0x86FDFD4D,0xF8F7FD33,0x6B28FD1A,0xDD92FD01,0x5037FCE8,
0xC31AFCCF,0x363BFCB6,0xA99EFC9D,0x1D43FC84,0x912CFC6B,0x55DFC52 ,0x79D6FC38,0xEE9AFC1F,
0x63AAFC06,0xD909FBED,0x4EB8FBD4,0xC4B9FBBB,0x3B0FFBA2,0xB1BBFB89,0x28BEFB70,0xA01CFB57,
0x17D6FB3E,0x8FEEFB25,0x866FB0C ,0x813FFAF3,0xFA7CFAD9,0x741FFAC0,0xEE29FAA7,0x689DFA8E,
0xE37CFA75,0x5EC8FA5C,0xDA84FA43,0x56B1FA2A,0xD351FA11,0x5067F9F8,0xCDF3F9DF,0x4BF8F9C6,
0xCA78F9AD,0x4975F994,0xC8F0F97B,0x48EDF962,0xC96BF949,0x4A6FF930,0xCBF8F917,0x4E0AF8FE,
0xD0A7F8E5,0x53CFF8CC,0xD786F8B3,0x5BCDF89A,0xE0A5F881,0x6612F868,0xEC14F84F,0x72AFF836,
0xF9E3F81D,0x81B2F805,0xA1FF7EC ,0x932CF7D3,0x1CD9F7BA,0xA72AF7A1,0x3221F788,0xBDBEF76F,
0x4A05F756,0xD6F6F73D,0x6495F724,0xF2E2F70B,0x81E0F6F3,0x1191F6DA,0xA1F6F6C1,0x3312F6A8,
0xC4E6F68F,0x5774F676,0xEABFF65D,0x7EC8F644,0x1390F62C,0xA91BF613,0x3F6AF5FA,0xD67FF5E1,
0x6E5BF5C8,0x701F5B0 ,0xA073F597,0x3AB2F57E,0xD5C0F565,0x71A0F54C,0xE52F534 ,0xABDAF51B,
0x4A39F502,0xE971F4E9,0x8984F4D1,0x2A74F4B8,0xCC42F49F,0x6EF1F486,0x1282F46E,0xB6F7F455,
0x5C53F43C,0x297F424 ,0xA9C6F40B,0x51E0F3F2,0xFAE8F3D9,0xA4E0F3C1,0x4FC9F3A8,0xFBA6F38F,
0xA879F377,0x5643F35E,0x507F346 ,0xB4C5F32D,0x6581F314,0x173CF2FC,0xC9F7F2E3,0x7DB6F2CA,
0x3279F2B2,0xE843F299,0x9F15F281,0x56F2F268,0xFDAF250 ,0xC9D1F237,0x84D9F21F,0x40F2F206,
0xFE1FF1ED,0xBC61F1D5,0x7BBBF1BC,0x3C2FF1A4,0xFDBEF18B,0xC06BF173,0x8437F15B,0x4923F142,
0xF33F12A ,0xD668F111,0x9EC3F0F9,0x6847F0E0,0x32F5F0C8,0xFED0F0AF,0xCBD9F097,0x9A12F07F,
0x697DF066,0x3A1CF04E,0xBF1F036 ,0xDEFEF01D,0xB344F005,0x88C5EFED,0x5F84EFD4,0x3782EFBC,
0x10C1EFA4,0xEB43EF8B,0xC709EF73,0xA416EF5B,0x826CEF43,0x620CEF2A,0x42F9EF12,0x2534EEFA,
0x8BEEEE2 ,0xED9BEEC9,0xD3CBEEB1,0xBB51EE99,0xA42EEE81,0x8E65EE69,0x79F7EE50,0x66E6EE38,
0x5533EE20,0x44E2EE08,0x35F3EDF0,0x2869EDD8,0x1C45EDC0,0x118AEDA8,0x838ED90 ,0x52ED78,
0xF9DBED5F,0xF4D2ED47,0xF13CED2F,0xEF19ED17,0xEE6AECFF,0xEF33ECE7,0xF175ECCF,0xF532ECB7,
0xFA6BEC9F,0x123EC88 ,0x95BEC70 ,0x1315EC58,0x1E53EC40,0x2B17EC28,0x3962EC10,0x4937EBF8,
0x5A98EBE0,0x6D86EBC8,0x8202EBB1,0x9810EB99,0xAFB0EB81,0xC8E5EB69,0xE3B0EB51,0x14EB3A,
0x1E11EB22,0x3DAAEB0A,0x5EE1EAF2,0x81B8EADB,0xA630EAC3,0xCC4BEAAB,0xF40CEA93,0x1D73EA7C,
0x4882EA64,0x753DEA4C,0xA3A3EA35,0xD3B8EA1D,0x57DEA06 ,0x38F3E9EE,0x6E1EE9D6,0xA4FDE9BF,
0xDD94E9A7,0x17E4E990,0x53EFE978,0x91B6E961,0xD13CE949,0x1283E932,0x558BE91A,0x9A57E903,
0xE0EAE8EB,0x2943E8D4,0x7366E8BC,0xBF55E8A5,0xD10E88E ,0x5C9AE876,0xADF5E85F,0x122E848,
0x5623E830,0xACFAE819,0x5A9E802 ,0x6032E7EA,0xBC96E7D3,0x1AD7E7BC,0x7AF7E7A4,0xDCF8E78D,
0x40DBE776,0xA6A3E75F,0xE51E748 ,0x77E6E730,0xE366E719,0x50D1E702,0xC029E6EB,0x3170E6D4,
0xA4A9E6BD,0x19D3E6A6,0x90F3E68F,0xA08E678 ,0x8515E661,0x21CE64A ,0x811FE633,0x21FE61C,
0x851EE605,0xA1EE5EE ,0x9120E5D7,0x1A27E5C0,0xA534E5A9,0x3248E592,0xC167E57B,0x5291E564,
0xE5C8E54D,0x7B0EE536,0x1265E520,0xABCEE509,0x474BE4F2,0xE4DFE4DB,0x848AE4C5,0x264FE4AE,
0xCA2FE497,0x702CE480,0x1848E46A,0xC284E453,0x6EE2E43C,0x1D65E426,0xCE0DE40F,0x80DDE3F9,
0x35D6E3E2,0xECFAE3CB,0xA64BE3B5,0x61CAE39E,0x1F79E388,0xDF5BE371,0xA170E35B,0x65BAE344,
0x2C3BE32E,0xF4F6E317,0xBFEBE301,0x8D1CE2EB,0x5C8BE2D4,0x2E3AE2BE,0x22BE2A8 ,0xD85FE291,
0xB0D8E27B,0x8B97E265,0x689FE24E,0x47F1E238,0x298EE222,0xD7AE20C ,0xF3B4E1F5,0xDC40E1DF,
0xC71EE1C9,0xB450E1B3,0xA3D9E19D,0x95B9E187,0x89F3E171,0x8088E15B,0x797AE144,0x74CAE12E,
0x727BE118,0x728EE102,0x7505E0EC,0x79E1E0D6,0x8124E0C1,0x8ACFE0AB,0x96E6E095,0xA568E07F,
0xB658E069,0xC9B8E053,0xDF89E03D,0xF7CDE027,0x1285E012,0x2FB4DFFC,0x4F5ADFE6,0x717BDFD0,
0x9616DFBB,0xBD2FDFA5,0xE6C6DF8F,0x12DDDF7A,0x4177DF64,0x7294DF4E,0xA636DF39,0xDC5FDF23,
0x1511DF0E,0x504EDEF8,0x8E16DEE3,0xCE6CDECD,0x1151DEB8,0x56C7DEA2,0x9ECFDE8D,0xE96CDE77,
0x369FDE62,0x8669DE4D,0xD8CDDE37,0x2DCBDE22,0x8566DE0D,0xDF9FDDF7,0x3C78DDE2,0x9BF2DDCD,
0xFE0FDDB7,0x62D1DDA2,0xCA39DD8D,0x3449DD78,0xA103DD63,0x1068DD4E,0x827ADD39,0xF73ADD23,
0x6EABDD0E,0xE8CDDCF9,0x65A2DCE4,0xE52DDCCF,0x676EDCBA,0xEC67DCA5,0x741ADC90,0xFE89DC7B,
0x8BB4DC67,0x1B9EDC52,0xAE49DC3D,0x43B5DC28,0xDBE5DC13,0x76DADBFE,0x1496DBEA,0xB51ADBD5,
0x5867DBC0,0xFE81DBAB,0xA767DB97,0x531CDB82,0x1A2DB6E ,0xB2F9DB59,0x6723DB44,0x1E23DB30,
0xD7FADB1B,0x94A8DB07,0x5431DAF2,0x1694DADE,0xDBD5DAC9,0xA3F4DAB5,0x6EF4DAA0,0x3CD5DA8C,
0xD99DA78 ,0xE142DA63,0xB7D2DA4F,0x9149DA3B,0x6DAADA26,0x4CF6DA12,0x2F2FD9FE,0x1456D9EA,
0xFC6DD9D5,0xE775D9C1,0xD570D9AD,0xC65FD999,0xBA45D985,0xB122D971,0xAAF8D95D,0xA7C8D949,
0xA795D935,0xAA60D921,0xB02AD90D,0xB8F4D8F9,0xC4C1D8E5,0xD392D8D1,0xE568D8BD,0xFA46D8A9,
0x122BD896,0x2D1BD882,0x4B16D86E,0x6C1ED85A,0x9035D847,0xB75CD833,0xE194D81F,0xEE0D80C,
0x3F40D7F8,0x72B6D7E4,0xA944D7D1,0xE2EBD7BD,0x1FADD7AA,0x5F8BD796,0xA287D783,0xE8A2D76F,
0x31DDD75C,0x7E3BD748,0xCDBCD735,0x2063D722,0x7630D70E,0xCF26D6FB,0x2B45D6E8,0x8A8FD6D5,
0xED06D6C1,0x52ABD6AE,0xBB7FD69B,0x2785D688,0x96BDD675,0x929D662 ,0x7ECBD64E,0xF7A3D63B,
0x73B4D628,0xF2FFD615,0x7585D602,0xFB48D5EF,0x844AD5DD,0x108BD5CA,0xA00DD5B7,0x32D2D5A4,
0xC8DBD591,0x6229D57E,0xFEBFD56B,0x9E9DD559,0x41C5D546,0xE838D533,0x91F8D521,0x3F07D50E,
0xEF65D4FB,0xA314D4E9,0x5A16D4D6,0x146BD4C4,0xD216D4B1,0x9318D49F,0x5772D48C,0x1F26D47A,
0xEA35D467,0xB8A0D455,0x8A6AD443,0x5F92D430,0x381CD41E,0x1407D40C,0xF357D3F9,0xD60BD3E7,
0xBC25D3D5,0xA5A8D3C3,0x9293D3B1,0x82EAD39F,0x76ACD38C,0x6DDCD37A,0x687AD368,0x6689D356,
0x6809D344,0x6CFCD332,0x7563D320,0x8141D30F,0x9095D2FD,0xA362D2EB,0xB9A8D2D9,0xD36AD2C7,
0xF572D4A ,0xEE9A2D5B,0xCA5E2D6D,0xA2A22D7F,0x77632D90,0x48A12DA2,0x165A2DB4,0xE08D2DC5,
0xA7392DD7,0x6A5B2DE8,0x29F42DFA,0xE6012E0B,0x9E802E1D,0x53722E2E,0x4D42E40 ,0xB2A52E51,
0x5CE42E62,0x38F2E74 ,0xA6A62E85,0x46262E96,0xE20E2EA7,0x7A5D2EB8,0xF132ECA ,0xA02C2EDB,
0x2DA92EEC,0xB7872EFD,0x3DC62F0E,0xC0642F1F,0x3F602F30,0xBAB82F41,0x326C2F52,0xA6792F63,
0x16E02F74,0x839D2F85,0xECB02F95,0x52182FA6,0xB3D42FB7,0x11E22FC8,0x6C402FD8,0xC2EE2FE9,
0x15EA2FFA,0x6533300A,0xB0C8301B,0xF8A8302B,0x3CD0303C,0x7D40304C,0xB9F7305D,0xF2F3306D,
0x2834307E,0x59B7308E,0x877B309F,0xB18030AF,0xD7C430BF,0xFA4530CF,0x190330E0,0x33FC30F0,
0x4B303100,0x5E9C3110,0x6E3F3120,0x7A193130,0x82273141,0x866A3151,0x86DF3161,0x83853171,
0x7C5B3180,0x71603190,0x629331A0,0x4FF231B0,0x397D31C0,0x1F3131D0,0x10E31E0 ,0xDF1231EF,
0xB93D31FF,0x8F8D320F,0x6201321E,0x3097322E,0xFB4F323D,0xC227324D,0x851E325D,0x4433326C,
0xFF65327B,0xB6B2328B,0x6A1A329A,0x199A32AA,0xC53332B9,0x6CE232C8,0x10A732D8,0xB08032E7,
0x4C6C32F6,0xE46B3305,0x787A3314,0x8993324 ,0x94C63333,0x1D013342,0xA1483351,0x219A3360,
0x9DF6336F,0x165B337E,0x8AC7338D,0xFB3A339B,0x67B233AA,0xD02E33B9,0x34AD33C8,0x952D33D7,
0xF1AF33E5,0x4A3033F4,0x9EB03403,0xEF2D3411,0x3BA63420,0x841A342F,0xC888343D,0x8EF344C,
0x454E345A,0x7DA33468,0xB1ED3477,0xE22C3485,0xE5F3494 ,0x368334A2,0x5A9834B0,0x7A9E34BE,
0x969234CD,0xAE7434DB,0xC24334E9,0xD1FD34F7,0xDDA13505,0xE52F3513,0xE8A63521,0xE803352F,
0xE347353D,0xDA6F354B,0xCD7C3559,0xBC6C3567,0xA73D3575,0x8DEF3583,0x70813590,0x4EF2359E,
0x294035AC,0xFF6B35B9,0xD17135C7,0x9F5135D5,0x690B35E2,0x2E9E35F0,0xF00735FD,0xAD47360B,
0x665C3618,0x1B463626,0xCC023633,0x78903640,0x20F0364E,0xC520365B,0x651E3668,0xEB3676,
0x98843683,0x2BEA3690,0xBB1B369D,0x461536AA,0xCCD836B7,0x4F6436C4,0xCDB636D1,0x47CE36DE,
0xBDAB36EB,0x2F4C36F8,0x9CB03705,0x5D63712 ,0x6ABD371E,0xCB64372B,0x27CA3738,0x7FED3744,
0xD3CE3751,0x236B375E,0x6EC3376A,0xB5D53777,0xF8A03783,0x37243790,0x715E379C,0xA74F37A9,
0xD8F537B5,0x65037C2 ,0x2F5D37CE,0x541E37DA,0x748F37E6,0x90B237F3,0xA88437FF,0xBC04380B,
0xCB323817,0xD60D3823,0xDC94382F,0xDEC6383B,0xDCA23847,0xD6273853,0xCB54385F,0xBC28386B,
0xA8A33877,0x90C33883,0x7487388E,0x53EF389A,0x2EFA38A6,0x5A638B2 ,0xD7F438BD,0xA5E138C9,
0x6F6E38D4,0x349838E0,0xF56038EB,0xB1C538F7,0x69C53902,0x1D5F390E,0xCC933919,0x77613924,
0x1DC63930,0xBFC2393B,0x5D553946,0xF67D3951,0x8B39395D,0x1B8A3968,0xA76D3973,0x2EE2397E,
0xB1E83989,0x307F3994,0xAAA5399F,0x205939AA,0x919B39B5,0xFE6B39BF,0x66C639CA,0xCAAC39D5,
0x2A1D39E0,0x851739EB,0xDB9A39F5,0x2DA63A00,0x7B383A0A,0xC4503A15,0x8EE3A20 ,0x49113A2A,
0x84B73A35,0xBBE03A3F,0xEE8C3A49,0x1CB93A54,0x46673A5E,0x6B943A68,0x8C413A73,0xA86C3A7D,
0xC0143A87,0xD3393A91,0xE1DA3A9B,0xEBF63AA5,0xF18C3AAF,0xF29C3AB9,0xEF253AC3,0xE7263ACD,
0xDA9E3AD7,0xC98C3AE1,0xB3F03AEB,0x99CA3AF5,0x7B173AFE,0x57D83B08,0x300B3B12,0x3B13B1C,
0xD2C83B25,0x9D4F3B2F,0x63463B38,0x24AC3B42,0xE1803B4B,0x99C23B55,0x4D713B5E,0xFC8C3B67,
0xA7123B71,0x4D023B7A,0xEE5D3B83,0x8B213B8D,0x234E3B96,0xB6E23B9F,0x45DD3BA8,0xD03F3BB1,
0x56063BBA,0xD7333BC3,0x53C33BCC,0xCBB83BD5,0x3F0F3BDE,0xADC83BE7,0x17E33BF0,0x7D5F3BF8,
0xDE3B3C01,0x3A773C0A,0x92113C13,0xE50A3C1B,0x33603C24,0x7D133C2C,0xC2223C35,0x28D3C3E,
0x3E523C46,0x75723C4E,0xA7EB3C57,0xD5BD3C5F,0xFEE83C67,0x236A3C70,0x43433C78,0x5E723C80,
0x74F73C88,0x86D23C91,0x94003C99,0x9C833CA1,0xA0593CA9,0x9F813CB1,0x99FB3CB9,0x8FC73CC1,
0x80E43CC9,0x6D503CD0,0x550C3CD8,0x38173CE0,0x16713CE8,0xF0183CEF,0xC50C3CF7,0x954D3CFF,
0x60DA3D06,0x27B23D0E,0xE9D63D15,0xA7433D1D,0x5FFA3D24,0x13FA3D2C,0xC3423D33,0x6DD33D3A,
0x13AB3D42,0xB4C93D49,0x512E3D50,0xE8D93D57,0x7BC83D5E,0x9FD3D66 ,0x93753D6D,0x18313D74,
0x98303D7B,0x13713D82,0x89F43D89,0xFBB83D8F,0x68BD3D96,0xD1033D9D,0x34883DA4,0x934D3DAB,
0xED503DB1,0x42913DB8,0x93103DBF,0xDECC3DC5,0x25C53DCC,0x67FA3DD2,0xA56B3DD9,0xDE173DDF,
0x11FD3DE6,0x411E3DEC,0x6B783DF2,0x910C3DF9,0xB1D83DFF,0xCDDD3E05,0xE5193E0B,0xF78C3E11,
0x5373E18 ,0xE173E1E ,0x122D3E24,0x11793E2A,0xBFA3E30 ,0x1AF3E36 ,0xF2983E3B,0xDEB53E41,
0xC6053E47,0xA8873E4D,0x863C3E53,0x5F223E58,0x333A3E5E,0x2833E64 ,0xCCFC3E69,0x92A53E6F,
0x537E3E74,0xF863E7A ,0xC6BC3E7F,0x79213E84,0x26B43E8A,0xCF753E8F,0x73623E94,0x127C3E9A,
0xACC33E9F,0x42353EA4,0xD2D33EA9,0x5E9C3EAE,0xE5903EB3,0x67AE3EB8,0xE4F53EBD,0x5D673EC2,
0xD1013EC7,0x3FC53ECC,0xA9B03ED1,0xEC43ED6 ,0x6F003EDA,0xCA623EDF,0x20EC3EE4,0x729C3EE8,
0xBF733EED,0x76F3EF2 ,0x4A913EF6,0x88D83EFB,0xC2433EFF,0xF6D43F03,0x26883F08,0x51603F0C,
0x775C3F10,0x987A3F15,0xB4BC3F19,0xCC203F1D,0xDEA63F21,0xEC4E3F25,0xF5173F29,0xF9023F2D,
0xF80E3F31,0xF23A3F35,0xE7863F39,0xD7F33F3D,0xC37F3F41,0xAA2A3F45,0x8BF53F49,0x68DE3F4C,
0x40E63F50,0x140C3F54,0xE2503F57,0xABB13F5B,0x70303F5E,0x2FCD3F62,0xEA863F65,0xA05B3F69,
0x514D3F6C,0xFD5B3F6F,0xA4853F73,0x46CA3F76,0xE42B3F79,0x7CA63F7C,0x103D3F80,0x9EEE3F83,
0x28B93F86,0xAD9E3F89,0x2D9D3F8C,0xA8B63F8F,0x1EE83F92,0x90343F95,0xFC983F97,0x64153F9A,
0xC6AA3F9D,0x24583FA0,0x7D1E3FA2,0xD0FB3FA5,0x1FF13FA8,0x69FE3FAA,0xAF223FAD,0xEF5D3FAF,
0x2AAF3FB2,0x61173FB4,0x92963FB7,0xBF2C3FB9,0xE6D73FBB,0x9993FBE ,0x27703FC0,0x405D3FC2,
0x54603FC4,0x63773FC6,0x6DA43FC8,0x72E63FCA,0x733C3FCC,0x6EA73FCE,0x65273FD0,0x56BA3FD2,
0x43633FD4,0x2B1F3FD6,0xDEF3FD8 ,0xEBD23FD9,0xC4CA3FDB,0x98D53FDD,0x67F33FDE,0x32253FE0,
0xF7693FE1,0xB7C13FE3,0x732C3FE4,0x29A93FE6,0xDB393FE7,0x87DB3FE9,0x2F913FEA,0xD2583FEB,
0x70323FEC,0x91D3FEE ,0x9D1B3FEF,0x2C2B3FF0,0xB64D3FF1,0x3B813FF2,0xBBC63FF3,0x371D3FF4,
0xAD853FF5,0x1F003FF6,0x8B8B3FF7,0xF3283FF7,0x55D63FF8,0xB3963FF9,0xC663FFA ,0x60483FFA,
0xAF3B3FFB,0xF93F3FFB,0x3E543FFC,0x7E7A3FFC,0xB9B13FFD,0xEFF93FFD,0x21513FFE,0x4DBB3FFE,
0x75353FFE,0x97C03FFF,0xB55C3FFF,0xCE083FFF,0xE1C53FFF,0xF0933FFF,0xFA723FFF,0xFF613FFF,
0x6F03FFE6,0x4D10FFB4,0x2B34FF82,0x97FFF50 ,0xE800FF1D,0xC6C8FEEB,0xA5E4FEB9,0x8565FE87,
0x655AFE54,0x45D4FE22,0x26E0FDF0,0x88FFDBE ,0xEAF1FD8B,0xCE14FD59,0xB208FD27,0x96DDFCF5,
0x7CA3FCC2,0x6368FC90,0x4B3CFC5E,0x342FFC2C,0x1E50FBFA,0x9AEFBC8 ,0xF65AFB95,0xE462FB63,
0xD3D6FB31,0xC4C6FAFF,0xB741FACD,0xAB56FA9B,0xA114FA69,0x988CFA37,0x91CDFA05,0x8CE6F9D3,
0x89E7F9A1,0x88DEF96F,0x89DCF93D,0x8CF0F90B,0x9229F8D9,0x9997F8A7,0xA349F875,0xAF4EF843,
0xBDB7F811,0xCE91F7DF,0xE1EDF7AD,0xF7DBF77B,0x1068F74A,0x2BA5F718,0x49A2F6E6,0x6A6DF6B4,
0x8E15F683,0xB4ABF651,0xDE3EF61F,0xADCF5EE ,0x3A95F5BC,0x6D78F58A,0xA395F559,0xDCFCF527,
0x19BAF4F6,0x59E0F4C4,0x9D7DF493,0xE4A0F461,0x2F58F430,0x7DB5F3FE,0xCFC6F3CD,0x2599F39C,
0x7F3FF36A,0xDCC6F339,0x3E3EF308,0xA3B6F2D7,0xD3DF2A6 ,0x7AE2F274,0xECB4F243,0x62C3F212,
0xDD1DF1E1,0x5BD2F1B0,0xDEF1F17F,0x6689F14E,0xF2A9F11D,0x8360F0ED,0x18BDF0BC,0xB2CFF08B,
0x51A6F05A,0xF550F029,0x9DDDEFF9,0x4B5BEFC8,0xFDD9EF97,0xB567EF67,0x7213EF36,0x33ECEF06,
0xFB02EED5,0xC763EEA5,0x991EEE75,0x7042EE44,0x4CDEEE14,0x2F02EDE4,0x16BAEDB4,0x418ED84,
0xF729ED53,0xEFFCED23,0xEEA0ECF3,0xF324ECC3,0xFD97EC93,0xE07EC64 ,0x2484EC34,0x411CEC04,
0x63DDEBD4,0x8CD7EBA5,0xBC18EB75,0xF1AFEB45,0x2DAAEB16,0x7019EAE6,0xB909EAB7,0x88AEA88,
0x5EAAEA58,0xBB78EA29,0x1F02E9FA,0x8957E9CB,0xFA85E99B,0x729BE96C,0xF1A7E93D,0x77B9E90E,
0x4DDE8E0 ,0x9924E8B1,0x349BE882,0xD751E853,0x8154E825,0x32B2E7F6,0xEB7AE7C7,0xABBBE799,
0x7382E76A,0x42DEE73C,0x19DEE70E,0xF88FE6DF,0xDF00E6B1,0xCD3EE683,0xC35AE655,0xC15FE627,
0xC75EE5F9,0xD563E5CB,0xEB7DE59D,0x9BAE570 ,0x3029E542,0x5ED7E514,0x95D2E4E7,0xD529E4B9,
0x1CEAE48C,0x6D22E45E,0xC5DFE431,0x2730E404,0x9123E3D7,0x3C4E3AA ,0x7F24E37C,0x34EE350,
0x9051E323,0x263CE2F6,0xC51BE2C9,0x6CFCE29C,0x1DEEE270,0xD7FEE243,0x9B3AE217,0x67B0E1EA,
0x3D6CE1BE,0x1C7EE192,0x4F2E166 ,0xF6D6E139,0xF238E10D,0xF726E0E1,0x5ACE0B6 ,0x1DD9E08A,
0x3FBAE05E,0x6B5CE032,0xA0CEE007,0xE01BDFDB,0x2953DFB0,0x7C81DF84,0xD9B5DF59,0x40FADF2E,
0xB25EDF03,0x2DEFDED8,0xB3BADEAD,0x43CBDE82,0xDE31DE57,0x82F9DE2D,0x322FDE02,0xEBE1DDD7,
0xB01BDDAD,0x7EECDD82,0x5860DD58,0x3C84DD2E,0x2B65DD04,0x2511DCDA,0x2993DCB0,0x38FADC86,
0x5351DC5C,0x78A7DC32,0xA907DC09,0xE47EDBDF,0x2B1ADBB6,0x7CE8DB8C,0xD9F3DB63,0x4249DB3A,
0xB5F6DB11,0x3507DAE8,0xBF89DABF,0x5588DA96,0xF711DA6D,0xA430DA45,0x5CF3DA1C,0x2165D9F4,
0xF193D9CB,0xCD89D9A3,0xB554D97B,0xA901D953,0xA89BD92B,0xB42FD903,0xCBC9D8DB,0xEF76D8B3,
0x1F42D88C,0x5B38D864,0xA366D83D,0xF7D7D815,0x5898D7EE,0xC5B4D7C7,0x3F38D7A0,0xC530D779,
0x57A8D752,0xF6ABD72B,0xA246D705,0x5A84D6DE,0x1F72D6B8,0xF11CD691,0xCF8CD66B,0xBAD0D645,
0xB2F2D61F,0xB7FFD5F9,0xCA02D5D3,0xE907D5AD,0x1519D588,0x4E45D562,0x9495D53D,0xE816D517,
0x48D2D4F2,0xB6D6D4CD,0x322CD4A8,0xBAE1D483,0x50FFD45E,0xF492D439,0xA5A5D415,0x6444D3F0,
0x307AD3CC,0xA51D3A8 ,0xF1D6D383,0xE713D35F,0xEA14D33B,0xFAE3D317,0x198CD2F4,0x461AD2D0,
0x7F682D52,0x36F02D76,0xE0732D99,0x7BE52DBC,0x93B2DE0 ,0x886C2E03,0xF96B2E25,0x5C2F2E48,
0xB0AC2E6B,0xF6D82E8D,0x2EA92EB0,0x58132ED2,0x730C2EF4,0x7F892F16,0x7D812F38,0x6CE82F5A,
0x4DB32F7C,0x1FDA2F9E,0xE3512FBF,0x980D2FE1,0x3E053002,0xD52F3023,0x5D7F3044,0xD6ED3065,
0x416D3086,0x9CF630A7,0xE97D30C7,0x26F830E8,0x555F3108,0x74A53128,0x84C23149,0x85AC3169,
0x77583188,0x59BD31A8,0x2CD231C8,0xF08B31E7,0xA4E13207,0x49C83226,0xDF373245,0x65253264,
0xDB883283,0x425732A2,0x998832C1,0xE11132DF,0x18E932FE,0x4108331C,0x5962333A,0x61F03358,
0x5AA73376,0x43803394,0x1C6F33B2,0xE56D33CF,0x9E7033ED,0x476F340A,0xE0613427,0x693C3444,
0xE1F93461,0x4A8E347E,0xA2F3349B,0xEB1D34B7,0x230534D4,0x4AA234F0,0x61EB350C,0x68D73528,
0x5F5E3544,0x45783560,0x1B1A357C,0xE03E3597,0x94DA35B3,0x38E635CE,0xCC5A35E9,0x4F2D3604,
0xC156361F,0x22CF363A,0x738E3654,0xB38B366F,0xE2BE3689,0x11F36A4 ,0xEA536BE ,0xB4936D8,
0xF70336F1,0xD1CB370B,0x9B983725,0x5464373E,0xFC253757,0x92D53771,0x186B378A,0x8CE037A3,
0xF02C37BB,0x424737D4,0x832B37ED,0xB2CE3805,0xD12A381D,0xDE383835,0xD9EF384D,0xC4493865,
0x9D3E387D,0x64C73894,0x1ADC38AC,0xBF7738C3,0x528F38DA,0xD41F38F1,0x441F3908,0xA287391F,
0xEF513935,0x2A76394C,0x53EF3962,0x6BB53978,0x71C2398E,0x660D39A4,0x489139BA,0x194839D0,
0xD82939E5,0x852F39FB,0x20533A10,0xA98F3A25,0x20DB3A3A,0x86323A4F,0xD98E3A63,0x1AE73A78,
0x4A373A8C,0x67793AA0,0x72A53AB4,0x6BB63AC8,0x52A63ADC,0x276E3AF0,0xEA093B03,0x9A703B17,
0x389D3B2A,0xC48B3B3D,0x3E343B50,0xA5913B63,0xFA9D3B75,0x3D523B88,0x6DAB3B9A,0x8BA13BAD,
0x97303BBF,0x90513BD1,0x76FF3BE2,0x4B353BF4,0xCED3C06 ,0xBC223C17,0x58CE3C28,0xE2EC3C39,
0x5A773C4A,0xBF693C5B,0x11BE3C6C,0x51703C7C,0x7E7A3C8C,0x98D73C9D,0xA0833CAD,0x95773CBD,
0x77B03CCC,0x47283CDC,0x3DB3CEC ,0xADC33CFB,0x44DD3D0A,0xC9233D19,0x3A913D28,0x99223D37,
0xE4D13D45,0x1D9B3D54,0x437A3D62,0x566B3D70,0x56683D7E,0x436E3D8C,0x1D783D9A,0xE4833DA7,
0x98893DB5,0x39873DC2,0xC7783DCF,0x425A3DDC,0xAA273DE9,0xFEDB3DF5,0x40733E02,0x6EEC3E0E,
0x8A403E1B,0x926D3E27,0x876E3E33,0x69403E3E,0x37E03E4A,0xF3493E55,0x9B783E61,0x306A3E6C,
0xB21C3E77,0x20893E82,0x7BAF3E8C,0xC38A3E97,0xF8173EA1,0x19523EAC,0x27393EB6,0x21C93EC0,
0x8FE3ECA ,0xDCD53ED3,0x9D4C3EDD,0x4A5F3EE6,0xE40C3EEF,0x6A503EF8,0xDD273F01,0x3C903F0A,
0x88873F13,0xC10A3F1B,0xE6163F23,0xF7A93F2B,0xF5C03F33,0xE0583F3B,0xB7703F43,0x7B053F4A,
0x2B153F52,0xC79D3F59,0x509B3F60,0xC60D3F67,0x27F13F6E,0x76443F74,0xB1053F7B,0xD8323F81,
0xEBC83F87,0xEBC63F8D,0xD82B3F93,0xB0F33F99,0x761E3F9E,0x27AA3FA4,0xC5943FA9,0x4FDC3FAE,
0xC6803FB3,0x297E3FB8,0x78D63FBC,0xB4843FC1,0xDC893FC5,0xF0E23FC9,0xF18F3FCD,0xDE8E3FD1,
0xB7DE3FD5,0x7D7E3FD8,0x2F6D3FDC,0xCDA93FDF,0x58333FE2,0xCF083FE5,0x32283FE8,0x81923FEB,
0xBD453FED,0xE5413FEF,0xF9853FF1,0xFA0F3FF3,0xE6E03FF5,0xBFF73FF7,0x85543FF9,0x36F53FFA,
0xD4DB3FFB,0x5F053FFC,0xD5733FFD,0x38243FFE,0x87183FFF,0xC2503FFF,0xE9CA3FFF,0xFD873FFF,
0xDE07FFCD,0x9A54FF69,0x575AFF04,0x1597FEA0,0xD586FE3B,0x97A2FDD7,0x5C69FD72,0x2456FD0E,
0xEFE4FCA9,0xBF90FC45,0x93D6FBE1,0x6D31FB7C,0x4C1EFB18,0x3117FAB4,0x1C98FA50,0xF1EF9EC,
0x923F988 ,0xB23F924 ,0x1599F8C0,0x2900F85C,0x45D5F7F8,0x6C91F794,0x9DB0F731,0xD9ADF6CD,
0x2102F66A,0x742AF606,0xD3A0F5A3,0x3FDFF540,0xB95FF4DD,0x409DF47A,0xD611F417,0x7A36F3B4,
0x2D86F352,0xF079F2EF,0xC38BF28D,0xA733F22B,0x9BEBF1C9,0xA22DF167,0xBA70F105,0xE52FF0A3,
0x22E0F042,0x73FDEFE0,0xD8FDEF7F,0x5259EF1E,0xE088EEBD,0x8402EE5D,0x3D3EEDFC,0xCB3ED9C,
0xF2D9ED3B,0xF025ECDB,0x50EEC7C ,0x320BEC1C,0x7792EBBC,0xD618EB5D,0x4E12EAFE,0xDFF7EA9F,
0x8C3AEA41,0x5352E9E2,0x35B2E984,0x33CEE926,0x4E1CE8C8,0x850DE86B,0xD916E80D,0x4AABE7B0,
0xDA3DE753,0x883FE6F7,0x5524E69A,0x415EE63E,0x4D5EE5E2,0x7996E586,0xC677E52B,0x3471E4D0,
0xC3F6E475,0x7574E41A,0x495DE3C0,0x401EE366,0x5A29E30C,0x97EAE2B3,0xF9D2E259,0x804DE201,
0x2BCAE1A8,0xFCB5E14F,0xF37DE0F7,0x108DE0A0,0x5452E048,0xBF38DFF1,0x51AADF9A,0xC14DF44,
0xEEE0DEED,0xFA79DE97,0x2F48DE42,0x8DB7DDED,0x1630DD98,0xC91BDD43,0xA6E1DCEF,0xAFE9DC9B,
0xE49BDC47,0x455FDBF4,0xD29ADBA1,0x8CB4DB4F,0x7411DAFC,0x8918DAAB,0xCC2DDA59,0x3DB5DA08,
0xDE14D9B7,0xADAED967,0xACE5D917,0xDC1CD8C7,0x3BB7D878,0xCC16D829,0x8D9AD7DB,0x80A5D78D,
0xA597D73F,0xFCD0D6F1,0x86AFD6A5,0x4393D658,0x33DBD60C,0x57E3D5C0,0xB00BD575,0x3CAFD52A,
0xFE2AD4DF,0xF4DAD495,0x2119D44C,0x8342D403,0x1BB0D3BA,0xEABDD371,0xF0C1D329,0x2E16D2E2,
0x5CEC2D64,0xAFEE2DAB,0xCA992DF1,0xAC952E37,0x558D2E7C,0xC52B2EC1,0xFB1B2F05,0xF7072F49,
0xB89C2F8D,0x3F872FD0,0x8B753013,0x9C133055,0x71113096,0xA1D30D8 ,0x66E63118,0x871E3159,
0x6A743198,0x109A31D8,0x79423216,0xA41F3255,0x90E33293,0x3F4232D0,0xAEF0330D,0xDFA33349,
0xD1103385,0x82ED33C1,0xF4F033FB,0x26D23436,0x18493470,0xC91034A9,0x38DE34E2,0x676D351A,
0x54793552,0xFFBC3589,0x68F235C0,0x8FD835F7,0x7429362C,0x15A53662,0x74093696,0x8F1436CB,
0x668636FE,0xFA1F3731,0x49A03764,0x54CA3796,0x1B6037C8,0x9D2537F9,0xD9DB3829,0xD1483859,
0x83303889,0xEF5938B7,0x158938E6,0xF5863913,0x8F193941,0xE209396D,0xEE203999,0xB32739C5,
0x30E839F0,0x672E3A1A,0x55C63A44,0xFC7B3A6D,0x5B1A3A96,0x71723ABE,0x3F503AE6,0xC4833B0D,
0xDD3B34  ,0xF42C3B59,0x9E433B7F,0xFEF33BA3,0x160E3BC8,0xE36A3BEB,0x66D83C0E,0xA02F3C31,
0x8F433C53,0x33EB3C74,0x8DFF3C95,0x9D543CB5,0x61C43CD4,0xDB293CF3,0x95B3D12 ,0xEC353D2F,
0x83933D4D,0xCF503D69,0xCF4A3D85,0x835E3DA1,0xEB693DBB,0x74B3DD6 ,0xD6E43DEF,0x5A143E08,
0x90BC3E21,0x7ABD3E38,0x17FB3E50,0x68593E66,0x6BBB3E7C,0x22063E92,0x8B1F3EA7,0xA6EC3EBB,
0x75563ECE,0xF6423EE1,0x299B3EF4,0xF493F06, 0xA7373F17,0xF14F3F27,0xED7C3F37,0x9BAB3F47,
0xFBCA3F55,0xDC63F64 ,0xD18C3F71,0x470E3F7E,0x6E3A3F8A,0x47033F96,0xD1583FA1,0xD2D3FAC,
0xFA743FB5,0x99223FBF,0xE92B3FC7,0xEA843FCF,0x9D243FD7,0x1023FDE ,0x16143FE4,0xDC543FE9,
0x53BA3FEE,0x7C413FF2,0x55E33FF6,0xE09C3FF9,0x1C673FFC,0x9433FFE ,0xA72C3FFF,0xF6203FFF,
0xBC1EFF9B,0x364AFED2,0xB646FE09,0x3FF3FD40,0xD72FFC77,0x7FD9FBAE,0x3DD1FAE6,0x14F3FA1E,
0x91CF956 ,0x1E27F88E,0x57EEF7C6,0xBA4BF6FF,0x4914F638,0x81FF572 ,0xFB3FF4AB,0x2646F3E6,
0x8D03F321,0x3344F25C,0x1CD3F198,0x4D79F0D4,0xC8F9F011,0x9318EF4F,0xAF94EE8D,0x222AEDCC,
0xEE93ED0B,0x1883EC4C,0xA3ADEB8D,0x93C0EACF,0xEC64EA11,0xB141E955,0xE5F9E899,0x8E28E7DF,
0xAD69E725,0x4750E66C,0x5F6CE5B4,0xF94AE4FD,0x186FE448,0xC05BE393,0xF48CE2DF,0xB876E22D,
0xF8BE17C ,0xFD35E0CB,0x84DAE01D,0xA9DADF6F,0x6F8CDEC2,0xD945DE17,0xEA51DD6D,0xA5F6DCC5,
0xF75DC1E ,0x2A05DB78,0xF8D9DAD3,0x7F1CDA30,0xBFF3D98F,0xBE7AD8EF,0x7DC8D850,0xE9D7B4,
0x4AE5D718,0x5EBAD67E,0x3F61D5E6,0xEFC8D54F,0x72D6D4BA,0xCB6BD427,0xFC5DD395,0x87CD306,
0xD732D88 ,0x42B22E14,0x948D2E9F,0x562F28  ,0x836C2FAF,0x1B333034,0xC51A30B7,0x7E993138,
0x453231B8,0x166F3236,0xEFE432B1,0xCF2E332B,0xB1F533A3,0x95EA3419,0x78C7348C,0x585234FE,
0x3258356E,0x4B335DC ,0xCD463647,0x89FE36B1,0x38D23718,0xD7C4377D,0x64E037E0,0xDE3F3841,
0x420038A0,0x8E5138FD,0xC1693957,0xD98939AF,0xD4FE3A05,0xB2203A59,0x6F523AAA,0xB023AFA,
0x83A83B47,0xD7CA3B91,0x5F73BDA ,0xCC93C20 ,0xEAE73C63,0x9F033CA5,0x27DA3CE4,0x84353D21,
0xB2E83D5B,0xB2D33D93,0x82E13DC9,0x220B3DFC,0x8F533E2D,0xC9C83E5B,0xD0853E87,0xA2B03EB1,
0x3F7D3ED8,0xA6293EFD,0xD5FF3F1F,0xCE553F3F,0x8E8D3F5D,0x16173F78,0x646C3F90,0x79133FA6,
0x539F3FBA,0xF3AE3FCB,0x58EC3FDA,0x830F3FE7,0x71DA3FF0,0x251D3FF8,0x9CB33FFD,0xD8853FFF,
0x78B8FF36,0x79A9FDA4,0xA918FC13,0x25FFFA82,0xF47F8F2 ,0x83CCF763,0xA254F5D5,0x8989F449,
0x57F7F2BE,0x2C07F136,0x23F9EFB0,0x5DE0EE2C,0xF79FECAB,0xEDFEB2E ,0xC112E9B3,0x2B68E83C,
0x6ACEE6C8,0x9BEAE559,0xDB14E3ED,0x4452E286,0xF357E123,0x379DFC6 ,0x8FB3DE6D,0xB29CDD19,
0x8667DBCB,0x24DADA82,0xA74FD93F,0x26ADD802,0xBB65D6CB,0x7D6ED59A,0x8442D471,0xE6DAD34D,
0x44542DCE,0xE75E2EE3,0xECE22FF1,0x400F30F8,0xCCA331F7,0x7EF432EE,0x43EE33DE,0x91A34C6,
0xBC9D35A5,0x4D3E367C,0xAA66374B,0xC4263811,0x8B3438CF,0xF0F33983,0xE7733A2F,0x61733AD2,
0x52613B6C,0xAE613BFD,0x6A4A3C84,0x7BAA3D02,0xD8C83D77,0x78A33DE2,0x52F63E44,0x603A3E9C,
0x99A33EEB,0xF9243F2F,0x79713F6A,0x15FC3F9C,0xCAFC3FC3,0x95653FE1,0x72EF3FF4,0x62163FFE};
#endif //BUILD_INTEGER
#endif //USE_SIN_COS_TABLES

// create these preload tables with cossin project & cut & paste
// g_sct64 added by Raymond was one bit different than what cossin.exe produces so use cossin's for consistency

const SinCosTable g_sct64 = {
        BP1_FROM_FLOAT(0.012271538285720),       // 0x01921d1f sin( pi/(4*64) ) * nF2BP1 for DCT & inverseTransform
        BP1_FROM_FLOAT(0.999924701839145),       // 0x7ffd8859 cos( pi/(4*64) ) * nF2BP1 for DCT & inverseTransform
        BP1_FROM_FLOAT(0.036807222941359),       // 0x04b6195d sin( 3*pi/(4*64) ) * nF2BP1 for DCT
        BP1_FROM_FLOAT(0.999322384588350),       // 0x7fe9cbbe cos( 3*pi/(4*64) ) * nF2BP1 for DCT
        BP1_FROM_FLOAT(0.049067674327418),       // 0x0647d97c sin( pi/64 ) * nF2BP1 for DCT
        BP1_FROM_FLOAT(0.998795456205172),       // 0x7fd8878c cos( pi/64 ) * nF2BP1 for DCT
        BP1_FROM_FLOAT(0.098017140329561),       // 0x0c8bd35d sin( pi/(64/2) ) * nF2BP1 for FFT
        BP1_FROM_FLOAT(0.995184726672197),       // 0x7f62368e cos( pi/(64/2) ) * nF2BP1 for FFT
        BP1_FROM_FLOAT(0.024541228522912),       // 0x03242abe sin( pi/(2*64) ) * nF2BP1 for FFT & inverseTransform
        BP1_FROM_FLOAT(0.999698818696204),       // 0x7ff62181 cos( pi/(2*64) ) * nF2BP1 for FFT & inverseTransform
        BP1_FROM_FLOAT(0.098135348654836)        // 0x0c8fb2f8 2*sin( pi/64 ) * nF2BP1 for DCT
#   ifdef ENABLE_LPC
       ,BP2_FROM_FLOAT(0.195090322016128)        // sin( 4*pi/cSB ) * nF2BP2 for LPC
       ,BP2_FROM_FLOAT(0.980785280403230)        // sin( 4*pi/cSB ) * nF2BP2 for LPC
#   endif
                };
const SinCosTable g_sct128 = {
        BP1_FROM_FLOAT(0.006135884649154),       // 0x00c90f87 sin( pi/(4*128) ) * nF2BP1 for DCT & inverseTransform
        BP1_FROM_FLOAT(0.999981175282601),       // 0x7fff6215 cos( pi/(4*128) ) * nF2BP1 for DCT & inverseTransform
        BP1_FROM_FLOAT(0.018406729905805),       // 0x025b26d7 sin( 3*pi/(4*128) ) * nF2BP1 for DCT
        BP1_FROM_FLOAT(0.999830581795823),       // 0x7ffa72d0 cos( 3*pi/(4*128) ) * nF2BP1 for DCT
        BP1_FROM_FLOAT(0.024541228522912),       // 0x03242abe sin( pi/128 ) * nF2BP1 for DCT
        BP1_FROM_FLOAT(0.999698818696204),       // 0x7ff62181 cos( pi/128 ) * nF2BP1 for DCT
        BP1_FROM_FLOAT(0.049067674327418),       // 0x0647d97c sin( pi/(128/2) ) * nF2BP1 for FFT
        BP1_FROM_FLOAT(0.998795456205172),       // 0x7fd8878c cos( pi/(128/2) ) * nF2BP1 for FFT
        BP1_FROM_FLOAT(0.012271538285720),       // 0x01921d1f sin( pi/(2*128) ) * nF2BP1 for FFT & inverseTransform
        BP1_FROM_FLOAT(0.999924701839145),       // 0x7ffd8859 cos( pi/(2*128) ) * nF2BP1 for FFT & inverseTransform
        BP1_FROM_FLOAT(0.049082457045825)        // 0x0648557d 2*sin( pi/128 ) * nF2BP1 for DCT
#   ifdef ENABLE_LPC
       ,BP2_FROM_FLOAT(0.098017140329560)        // sin( 4*pi/cSB ) * nF2BP2 for LPC
       ,BP2_FROM_FLOAT(0.995184726672196)        // sin( 4*pi/cSB ) * nF2BP2 for LPC
#   endif
                };
const SinCosTable g_sct256 = {
        BP1_FROM_FLOAT(0.003067956762966),       // 0x006487e2 sin( pi/(4*256) ) * nF2BP1 for DCT & inverseTransform
        BP1_FROM_FLOAT(0.999995293809576),       // 0x7fffd884 cos( pi/(4*256) ) * nF2BP1 for DCT & inverseTransform
        BP1_FROM_FLOAT(0.009203754782060),       // 0x012d96b0 sin( 3*pi/(4*256) ) * nF2BP1 for DCT
        BP1_FROM_FLOAT(0.999957644551964),       // 0x7ffe9cb1 cos( 3*pi/(4*256) ) * nF2BP1 for DCT
        BP1_FROM_FLOAT(0.012271538285720),       // 0x01921d1f sin( pi/256 ) * nF2BP1 for DCT
        BP1_FROM_FLOAT(0.999924701839145),       // 0x7ffd8859 cos( pi/256 ) * nF2BP1 for DCT
        BP1_FROM_FLOAT(0.024541228522912),       // 0x03242abe sin( pi/(256/2) ) * nF2BP1 for FFT
        BP1_FROM_FLOAT(0.999698818696204),       // 0x7ff62181 cos( pi/(256/2) ) * nF2BP1 for FFT
        BP1_FROM_FLOAT(0.006135884649154),       // 0x00c90f87 sin( pi/(2*256) ) * nF2BP1 for FFT & inverseTransform
        BP1_FROM_FLOAT(0.999981175282601),       // 0x7fff6215 cos( pi/(2*256) ) * nF2BP1 for FFT & inverseTransform
        BP1_FROM_FLOAT(0.024543076571440)        // 0x03243a3f 2*sin( pi/256 ) * nF2BP1 for DCT
#   ifdef ENABLE_LPC
       ,BP2_FROM_FLOAT(0.049067674327418)        // sin( 4*pi/cSB ) * nF2BP2 for LPC
       ,BP2_FROM_FLOAT(0.998795456205172)        // sin( 4*pi/cSB ) * nF2BP2 for LPC
#   endif
                };
const SinCosTable g_sct512 = {
        BP1_FROM_FLOAT(0.001533980186285),       // 0x003243f5 sin( pi/(4*512) ) * nF2BP1 for DCT & inverseTransform
        BP1_FROM_FLOAT(0.999998823451702),       // 0x7ffff620 cos( pi/(4*512) ) * nF2BP1 for DCT & inverseTransform
        BP1_FROM_FLOAT(0.004601926120449),       // 0x0096cbc1 sin( 3*pi/(4*512) ) * nF2BP1 for DCT
        BP1_FROM_FLOAT(0.999989411081928),       // 0x7fffa72b cos( 3*pi/(4*512) ) * nF2BP1 for DCT
        BP1_FROM_FLOAT(0.006135884649154),       // 0x00c90f87 sin( pi/512 ) * nF2BP1 for DCT
        BP1_FROM_FLOAT(0.999981175282601),       // 0x7fff6215 cos( pi/512 ) * nF2BP1 for DCT
        BP1_FROM_FLOAT(0.012271538285720),       // 0x01921d1f sin( pi/(512/2) ) * nF2BP1 for FFT
        BP1_FROM_FLOAT(0.999924701839145),       // 0x7ffd8859 cos( pi/(512/2) ) * nF2BP1 for FFT
        BP1_FROM_FLOAT(0.003067956762966),       // 0x006487e2 sin( pi/(2*512) ) * nF2BP1 for FFT & inverseTransform
        BP1_FROM_FLOAT(0.999995293809576),       // 0x7fffd884 cos( pi/(2*512) ) * nF2BP1 for FFT & inverseTransform
        BP1_FROM_FLOAT(0.012271769298309)        // 0x01921f0f 2*sin( pi/512 ) * nF2BP1 for DCT
#   ifdef ENABLE_LPC
       ,BP2_FROM_FLOAT(0.024541228522912)        // sin( 4*pi/cSB ) * nF2BP2 for LPC
       ,BP2_FROM_FLOAT(0.999698818696204)        // sin( 4*pi/cSB ) * nF2BP2 for LPC
#   endif
                };
const SinCosTable g_sct1024 = {
        BP1_FROM_FLOAT(0.000766990318743),       // 0x001921fb sin( pi/(4*1024) ) * nF2BP1 for DCT & inverseTransform
        BP1_FROM_FLOAT(0.999999705862882),       // 0x7ffffd87 cos( pi/(4*1024) ) * nF2BP1 for DCT & inverseTransform
        BP1_FROM_FLOAT(0.002300969151426),       // 0x004b65ed sin( 3*pi/(4*1024) ) * nF2BP1 for DCT
        BP1_FROM_FLOAT(0.999997352766978),       // 0x7fffe9ca cos( 3*pi/(4*1024) ) * nF2BP1 for DCT
        BP1_FROM_FLOAT(0.003067956762966),       // 0x006487e2 sin( pi/1024 ) * nF2BP1 for DCT
        BP1_FROM_FLOAT(0.999995293809576),       // 0x7fffd884 cos( pi/1024 ) * nF2BP1 for DCT
        BP1_FROM_FLOAT(0.006135884649154),       // 0x00c90f87 sin( pi/(1024/2) ) * nF2BP1 for FFT
        BP1_FROM_FLOAT(0.999981175282601),       // 0x7fff6215 cos( pi/(1024/2) ) * nF2BP1 for FFT
        BP1_FROM_FLOAT(0.001533980186285),       // 0x003243f5 sin( pi/(2*1024) ) * nF2BP1 for FFT & inverseTransform
        BP1_FROM_FLOAT(0.999998823451702),       // 0x7ffff620 cos( pi/(2*1024) ) * nF2BP1 for FFT & inverseTransform
        BP1_FROM_FLOAT(0.006135913525932)        // 0x00c90fc5 2*sin( pi/1024 ) * nF2BP1 for DCT
#   ifdef ENABLE_LPC
       ,BP2_FROM_FLOAT(0.012271538285719)        // sin( 4*pi/cSB ) * nF2BP2 for LPC
       ,BP2_FROM_FLOAT(0.999924701839144)        // sin( 4*pi/cSB ) * nF2BP2 for LPC
#   endif
                };
const SinCosTable g_sct2048 = {
        BP1_FROM_FLOAT(0.000383495187571),       // 0x000c90fd sin( pi/(4*2048) ) * nF2BP1 for DCT & inverseTransform
        BP1_FROM_FLOAT(0.999999926465718),       // 0x7fffff61 cos( pi/(4*2048) ) * nF2BP1 for DCT & inverseTransform
        BP1_FROM_FLOAT(0.001150485337114),       // 0x0025b2f8 sin( 3*pi/(4*2048) ) * nF2BP1 for DCT
        BP1_FROM_FLOAT(0.999999338191526),       // 0x7ffffa71 cos( 3*pi/(4*2048) ) * nF2BP1 for DCT
        BP1_FROM_FLOAT(0.001533980186285),       // 0x003243f5 sin( pi/2048 ) * nF2BP1 for DCT
        BP1_FROM_FLOAT(0.999998823451702),       // 0x7ffff620 cos( pi/2048 ) * nF2BP1 for DCT
        BP1_FROM_FLOAT(0.003067956762966),       // 0x006487e2 sin( pi/(2048/2) ) * nF2BP1 for FFT
        BP1_FROM_FLOAT(0.999995293809576),       // 0x7fffd884 cos( pi/(2048/2) ) * nF2BP1 for FFT
        BP1_FROM_FLOAT(0.000766990318743),       // 0x001921fb sin( pi/(2*2048) ) * nF2BP1 for FFT & inverseTransform
        BP1_FROM_FLOAT(0.999999705862882),       // 0x7ffffd87 cos( pi/(2*2048) ) * nF2BP1 for FFT & inverseTransform
        BP1_FROM_FLOAT(0.003067960372570)        // 0x006487ea 2*sin( pi/2048 ) * nF2BP1 for DCT
#   ifdef ENABLE_LPC
       ,BP2_FROM_FLOAT(0.006135884649154)        // sin( 4*pi/cSB ) * nF2BP2 for LPC
       ,BP2_FROM_FLOAT(0.999981175282601)        // sin( 4*pi/cSB ) * nF2BP2 for LPC
#   endif
                };/***
const SinCosTable g_sct128  = {0x006487c4,0x3fffb10a,0x3fffb109,0xff9b780d,0x00013bd2,0x00c90e90,0xfcdc1341,0x3FEC43C6};
const SinCosTable g_sct256  = {0x003243f1,0x3fffec41,0x3fffec41,0xffcdbbe0,0x00004ef4,0x006487c4,0xfe6deaa0,0x3ffb10c0};
const SinCosTable g_sct512  = {0x001921fa,0x3ffffb0f,0x3ffffb0f,0xffe6ddd7,0x000013bd,0x003243f1,0xff36f170,0x3ffec42c};
const SinCosTable g_sct1024 = {0x000c90fd,0x3ffffec3,0x3ffffec3,0xfff36ed4,0x000004ef,0x001921fa,0xff9b783c,0x3fffb10a};
const SinCosTable g_sct2048 = {0x0006487e,0x3fffffb0,0x3fffffb0,0xfff9b753,0x0000013b,0x000c90fd,0xffcdbc0f,0x3fffec41};
*///


const SinCosTable * const rgSinCosTables[SINCOSTABLE_ENTRIES] = {&g_sct64,&g_sct128,&g_sct256,
    NULL, &g_sct512,NULL, NULL, NULL, &g_sct1024, NULL, NULL, NULL, NULL, NULL,
    NULL, NULL, &g_sct2048};

// HighRate and MidRate InverseQuantize require one
// to caluclate 10^( (MaskQ-MaxMaskQ)&2.4*0.5/20 ) = (10^(1/16)) ^ (MaskQ-MaxMaskQ) 
// equals rgMaskPower10[ MaxMaskQ-MaskQ ] * (1<<((MaxMaskQ-MaskQ)/4) / ((float)(1<<28))
// The values for this table are from WMAConcepts.xls!WeightedQuantization
const MaskPowerType rgiMaskMinusPower10[MASK_MINUS_POWER_TABLE_SIZE] = {
    MASK_POWER_FROM_FLOAT(1.000000000000),    // *(2^-0) for [0]
    MASK_POWER_FROM_FLOAT(0.865964323282),    // *(2^-0) for [1]
    MASK_POWER_FROM_FLOAT(0.749894209206),    // *(2^-0) for [2]
    MASK_POWER_FROM_FLOAT(0.649381630123),    // *(2^-0) for [3]
    MASK_POWER_FROM_FLOAT(1.124682649970),    // *(2^-1) for [4]
    MASK_POWER_FROM_FLOAT(0.973935049027),    // *(2^-1) for [5]
    MASK_POWER_FROM_FLOAT(0.843393005431),    // *(2^-1) for [6]
    MASK_POWER_FROM_FLOAT(0.730348251760),    // *(2^-1) for [7]
    MASK_POWER_FROM_FLOAT(1.264911063015),    // *(2^-2) for [8]
    MASK_POWER_FROM_FLOAT(1.095367852598),    // *(2^-2) for [9]
    MASK_POWER_FROM_FLOAT(0.948549479246),    // *(2^-2) for [10]
    MASK_POWER_FROM_FLOAT(0.821410007775),    // *(2^-2) for [11]
    MASK_POWER_FROM_FLOAT(1.422623526305),    // *(2^-3) for [12]
    MASK_POWER_FROM_FLOAT(1.231941219419),    // *(2^-3) for [13]
    MASK_POWER_FROM_FLOAT(1.066817142069),    // *(2^-3) for [14]
    MASK_POWER_FROM_FLOAT(0.923825584352),    // *(2^-3) for [15]
    MASK_POWER_FROM_FLOAT(1.599999997765),    // *(2^-4) for [16]
    MASK_POWER_FROM_FLOAT(1.385542914271),    // *(2^-4) for [17]
    MASK_POWER_FROM_FLOAT(1.199830733240),    // *(2^-4) for [18]
    MASK_POWER_FROM_FLOAT(1.039010610431),    // *(2^-4) for [19]
    MASK_POWER_FROM_FLOAT(1.799492239952),    // *(2^-5) for [20]
    MASK_POWER_FROM_FLOAT(1.558296076953),    // *(2^-5) for [21]
    MASK_POWER_FROM_FLOAT(1.349428810179),    // *(2^-5) for [22]
    MASK_POWER_FROM_FLOAT(1.168557204306),    // *(2^-5) for [23]
    MASK_POWER_FROM_FLOAT(2.023857701570),    // *(2^-6) for [24]
    MASK_POWER_FROM_FLOAT(1.752588562667),    // *(2^-6) for [25]
    MASK_POWER_FROM_FLOAT(1.517679169774),    // *(2^-6) for [26]
    MASK_POWER_FROM_FLOAT(1.314256016165),    // *(2^-6) for [27]
    MASK_POWER_FROM_FLOAT(2.276197642088),    // *(2^-7) for [28]
    MASK_POWER_FROM_FLOAT(1.971105951816),    // *(2^-7) for [29]
    MASK_POWER_FROM_FLOAT(1.706907432526),    // *(2^-7) for [30]
    MASK_POWER_FROM_FLOAT(1.478120937943),    // *(2^-7) for [31]
    MASK_POWER_FROM_FLOAT(2.559999998659),    // *(2^-8) for [32]
    MASK_POWER_FROM_FLOAT(2.216868665069),    // *(2^-8) for [33]
    MASK_POWER_FROM_FLOAT(1.919729173183),    // *(2^-8) for [34]
    MASK_POWER_FROM_FLOAT(1.662416975945),    // *(2^-8) for [35]
    MASK_POWER_FROM_FLOAT(2.879187583923),    // *(2^-9) for [36]
    MASK_POWER_FROM_FLOAT(2.493273727596),    // *(2^-9) for [37]
    MASK_POWER_FROM_FLOAT(2.159086097032),    // *(2^-9) for [38]
    MASK_POWER_FROM_FLOAT(1.869691528380)     // *(2^-9) for [39]
#if defined(SKIMP_ON_ROM)
	);
#else	// so !defined(SKIMP_ON_ROM)
	,
    MASK_POWER_FROM_FLOAT(3.238172322512),    // *(2^-10) for [40]
    MASK_POWER_FROM_FLOAT(2.804141703993),    // *(2^-10) for [41]
    MASK_POWER_FROM_FLOAT(2.428286671638),    // *(2^-10) for [42]
    MASK_POWER_FROM_FLOAT(2.102809626609),    // *(2^-10) for [43]
    MASK_POWER_FROM_FLOAT(3.641916230321),    // *(2^-11) for [44]
    MASK_POWER_FROM_FLOAT(3.153769522905),    // *(2^-11) for [45]
    MASK_POWER_FROM_FLOAT(2.731051892042),    // *(2^-11) for [46]
    MASK_POWER_FROM_FLOAT(2.364993501455),    // *(2^-11) for [47]
    MASK_POWER_FROM_FLOAT(4.095999997109),    // *(2^-12) for [48]
    MASK_POWER_FROM_FLOAT(3.546989865601),    // *(2^-12) for [49]
    MASK_POWER_FROM_FLOAT(3.071566678584),    // *(2^-12) for [50]
    MASK_POWER_FROM_FLOAT(2.659867160022),    // *(2^-12) for [51]
    MASK_POWER_FROM_FLOAT(4.606700133532),    // *(2^-13) for [52]
    MASK_POWER_FROM_FLOAT(3.989237964153),    // *(2^-13) for [53]
    MASK_POWER_FROM_FLOAT(3.454537753016),    // *(2^-13) for [54]
    MASK_POWER_FROM_FLOAT(2.991506449878),    // *(2^-13) for [55]
    MASK_POWER_FROM_FLOAT(5.181075718254),    // *(2^-14) for [56]
    MASK_POWER_FROM_FLOAT(4.486626725644),    // *(2^-14) for [57]
    MASK_POWER_FROM_FLOAT(3.885258678347),    // *(2^-14) for [58]
    MASK_POWER_FROM_FLOAT(3.364495400339),    // *(2^-14) for [59]
    MASK_POWER_FROM_FLOAT(5.827065970749),    // *(2^-15) for [60]
    MASK_POWER_FROM_FLOAT(5.046031240374),    // *(2^-15) for [61]
    MASK_POWER_FROM_FLOAT(4.369683027267),    // *(2^-15) for [62]
    MASK_POWER_FROM_FLOAT(3.783989604563),    // *(2^-15) for [63]
	MASK_POWER_FROM_FLOAT(6.553599998355),    // *(2^-16) for [64]
    MASK_POWER_FROM_FLOAT(5.675183787942),    // *(2^-16) for [65]
    MASK_POWER_FROM_FLOAT(4.914506688714),    // *(2^-16) for [66]
    MASK_POWER_FROM_FLOAT(4.255787458271),    // *(2^-16) for [67]
    MASK_POWER_FROM_FLOAT(7.370720215142),    // *(2^-17) for [68]
    MASK_POWER_FROM_FLOAT(6.382780745625),    // *(2^-17) for [69]
    MASK_POWER_FROM_FLOAT(5.527260407805),    // *(2^-17) for [70]
    MASK_POWER_FROM_FLOAT(4.786410320550)     // *(2^-17) for [71]
	};
#endif	// of both defined(SKIMP_ON_ROM) and !defined(SKIMP_ON_ROM)


const MaskPowerType rgiMaskPlusPower10[MASK_PLUS_POWER_TABLE_SIZE] = {
    MASK_POWER_FROM_FLOAT(1.154781982303),    // *(2^0) for [-1]
    MASK_POWER_FROM_FLOAT(1.333521429449),    // *(2^0) for [-2]
    MASK_POWER_FROM_FLOAT(1.539926525205),    // *(2^0) for [-3]
    MASK_POWER_FROM_FLOAT(0.889139704406),    // *(2^1) for [-4]
    MASK_POWER_FROM_FLOAT(1.026762511581),    // *(2^1) for [-5]
    MASK_POWER_FROM_FLOAT(1.185686852783),    // *(2^1) for [-6]
    MASK_POWER_FROM_FLOAT(1.369209814817),    // *(2^1) for [-7]
    MASK_POWER_FROM_FLOAT(0.790569413453),    // *(2^2) for [-8]
    MASK_POWER_FROM_FLOAT(0.912935316563),    // *(2^2) for [-9]
    MASK_POWER_FROM_FLOAT(1.054241254926),    // *(2^2) for [-10]
    MASK_POWER_FROM_FLOAT(1.217418812215),    // *(2^2) for [-11]
    MASK_POWER_FROM_FLOAT(0.702926654369),    // *(2^3) for [-12]
    MASK_POWER_FROM_FLOAT(0.811727035791),    // *(2^3) for [-13]
    MASK_POWER_FROM_FLOAT(0.937367759645),    // *(2^3) for [-14]
    MASK_POWER_FROM_FLOAT(1.082455404103),    // *(2^3) for [-15]
    MASK_POWER_FROM_FLOAT(0.625000000000),    // *(2^4) for [-16]
    MASK_POWER_FROM_FLOAT(0.721738737077),    // *(2^4) for [-17]
    MASK_POWER_FROM_FLOAT(0.833450894803),    // *(2^4) for [-18]
    MASK_POWER_FROM_FLOAT(0.962454076856),    // *(2^4) for [-19]
    MASK_POWER_FROM_FLOAT(0.555712312460),    // *(2^5) for [-20]
    MASK_POWER_FROM_FLOAT(0.641726568341),    // *(2^5) for [-21]
    MASK_POWER_FROM_FLOAT(0.741054281592),    // *(2^5) for [-22]
    MASK_POWER_FROM_FLOAT(0.855756133795),    // *(2^5) for [-23]
    MASK_POWER_FROM_FLOAT(0.494105882943),    // *(2^6) for [-24]
    MASK_POWER_FROM_FLOAT(0.570584572852),    // *(2^6) for [-25]
    MASK_POWER_FROM_FLOAT(0.658900786191),    // *(2^6) for [-26]
    MASK_POWER_FROM_FLOAT(0.760886754841),    // *(2^6) for [-27]
    MASK_POWER_FROM_FLOAT(0.439329158515),    // *(2^7) for [-28]
    MASK_POWER_FROM_FLOAT(0.507329396904),    // *(2^7) for [-29]
    MASK_POWER_FROM_FLOAT(0.585854850709),    // *(2^7) for [-30]
    MASK_POWER_FROM_FLOAT(0.676534626633),    // *(2^7) for [-31]
    MASK_POWER_FROM_FLOAT(0.390625000000),    // *(2^8) for [-32]
    MASK_POWER_FROM_FLOAT(0.451086711138),    // *(2^8) for [-33]
    MASK_POWER_FROM_FLOAT(0.520906805992),    // *(2^8) for [-34]
    MASK_POWER_FROM_FLOAT(0.601533796638),    // *(2^8) for [-35]
    MASK_POWER_FROM_FLOAT(0.347320195287),    // *(2^9) for [-36]
    MASK_POWER_FROM_FLOAT(0.401079103351),    // *(2^9) for [-37]
    MASK_POWER_FROM_FLOAT(0.463158924133),    // *(2^9) for [-38]
    MASK_POWER_FROM_FLOAT(0.534847583622),    // *(2^9) for [-39]
    MASK_POWER_FROM_FLOAT(0.308816175908),    // *(2^10) for [-40]
    MASK_POWER_FROM_FLOAT(0.356615357101),    // *(2^10) for [-41]
    MASK_POWER_FROM_FLOAT(0.411812990904),    // *(2^10) for [-42]
    MASK_POWER_FROM_FLOAT(0.475554220378),    // *(2^10) for [-43]
    MASK_POWER_FROM_FLOAT(0.274580724537),    // *(2^11) for [-44]
    MASK_POWER_FROM_FLOAT(0.317080873996),    // *(2^11) for [-45]
    MASK_POWER_FROM_FLOAT(0.366159278899),    // *(2^11) for [-46]
    MASK_POWER_FROM_FLOAT(0.422834139317),    // *(2^11) for [-47]
    MASK_POWER_FROM_FLOAT(0.244140625000),    // *(2^12) for [-48]
    MASK_POWER_FROM_FLOAT(0.281929194927),    // *(2^12) for [-49]
    MASK_POWER_FROM_FLOAT(0.325566753745),    // *(2^12) for [-50]
};

// lookup table for calculating QuantStepSize to QuantSep
// = 10^( (idx-18)/20 ) * (1<<((idx/8)+4)) for idx = 18..145
// note the range 22 to 138 is as large as was observed in many configurations of Tough and All1
// So one could skimp on its size if you really needed to.
// The values for this tables can be found in WMAConcepts.xls!QuantStep
const DBPowerType rgDBPower10[DBPOWER_TABLE_SIZE] = {
    DBPOWER_FROM_FLOAT(0.124113783240),    // *(2^6) for [18]
    DBPOWER_FROM_FLOAT(0.139257956296),    // *(2^6) for [19]
    DBPOWER_FROM_FLOAT(0.156250000000),    // *(2^6) for [20]
    DBPOWER_FROM_FLOAT(0.175315380096),    // *(2^6) for [21]
    DBPOWER_FROM_FLOAT(0.196707092226),    // *(2^6) for [22]
    DBPOWER_FROM_FLOAT(0.220708988607),    // *(2^6) for [23]
    DBPOWER_FROM_FLOAT(0.123819779605),    // *(2^7) for [24]
    DBPOWER_FROM_FLOAT(0.138928078115),    // *(2^7) for [25]
    DBPOWER_FROM_FLOAT(0.155879866332),    // *(2^7) for [26]
    DBPOWER_FROM_FLOAT(0.174900088459),    // *(2^7) for [27]
    DBPOWER_FROM_FLOAT(0.196241125464),    // *(2^7) for [28]
    DBPOWER_FROM_FLOAT(0.220186166465),    // *(2^7) for [29]
    DBPOWER_FROM_FLOAT(0.247052941471),    // *(2^7) for [30]
    DBPOWER_FROM_FLOAT(0.277197957039),    // *(2^7) for [31]
    DBPOWER_FROM_FLOAT(0.155510611832),    // *(2^8) for [32]
    DBPOWER_FROM_FLOAT(0.174485776573),    // *(2^8) for [33]
    DBPOWER_FROM_FLOAT(0.195776261389),    // *(2^8) for [34]
    DBPOWER_FROM_FLOAT(0.219664577395),    // *(2^8) for [35]
    DBPOWER_FROM_FLOAT(0.246467709541),    // *(2^8) for [36]
    DBPOWER_FROM_FLOAT(0.276541318744),    // *(2^8) for [37]
    DBPOWER_FROM_FLOAT(0.310284465551),    // *(2^8) for [38]
    DBPOWER_FROM_FLOAT(0.348144896328),    // *(2^8) for [39]
    DBPOWER_FROM_FLOAT(0.195312500000),    // *(2^9) for [40]
    DBPOWER_FROM_FLOAT(0.219144228846),    // *(2^9) for [41]
    DBPOWER_FROM_FLOAT(0.245883867145),    // *(2^9) for [42]
    DBPOWER_FROM_FLOAT(0.275886237621),    // *(2^9) for [43]
    DBPOWER_FROM_FLOAT(0.309549450874),    // *(2^9) for [44]
    DBPOWER_FROM_FLOAT(0.347320195287),    // *(2^9) for [45]
    DBPOWER_FROM_FLOAT(0.389699667692),    // *(2^9) for [46]
    DBPOWER_FROM_FLOAT(0.437250219285),    // *(2^9) for [47]
    DBPOWER_FROM_FLOAT(0.245301406831),    // *(2^10) for [48]
    DBPOWER_FROM_FLOAT(0.275232706219),    // *(2^10) for [49]
    DBPOWER_FROM_FLOAT(0.308816175908),    // *(2^10) for [50]
    DBPOWER_FROM_FLOAT(0.346497450024),    // *(2^10) for [51]
    DBPOWER_FROM_FLOAT(0.388776533306),    // *(2^10) for [52]
    DBPOWER_FROM_FLOAT(0.436214443296),    // *(2^10) for [53]
    DBPOWER_FROM_FLOAT(0.489440657198),    // *(2^10) for [54]
    DBPOWER_FROM_FLOAT(0.549161449075),    // *(2^10) for [55]
    DBPOWER_FROM_FLOAT(0.308084640652),    // *(2^11) for [56]
    DBPOWER_FROM_FLOAT(0.345676649362),    // *(2^11) for [57]
    DBPOWER_FROM_FLOAT(0.387855581939),    // *(2^11) for [58]
    DBPOWER_FROM_FLOAT(0.435181118548),    // *(2^11) for [59]
    DBPOWER_FROM_FLOAT(0.488281250000),    // *(2^11) for [60]
    DBPOWER_FROM_FLOAT(0.547860570252),    // *(2^11) for [61]
    DBPOWER_FROM_FLOAT(0.614709671587),    // *(2^11) for [62]
    DBPOWER_FROM_FLOAT(0.689715597779),    // *(2^11) for [63]
    DBPOWER_FROM_FLOAT(0.386936813593),    // *(2^12) for [64]
    DBPOWER_FROM_FLOAT(0.434150245041),    // *(2^12) for [65]
    DBPOWER_FROM_FLOAT(0.487124588341),    // *(2^12) for [66]
    DBPOWER_FROM_FLOAT(0.546562775970),    // *(2^12) for [67]
    DBPOWER_FROM_FLOAT(0.613253522664),    // *(2^12) for [68]
    DBPOWER_FROM_FLOAT(0.688081767410),    // *(2^12) for [69]
    DBPOWER_FROM_FLOAT(0.772040441632),    // *(2^12) for [70]
    DBPOWER_FROM_FLOAT(0.866243623197),    // *(2^12) for [71]
    DBPOWER_FROM_FLOAT(0.485970664769),    // *(2^13) for [72]
    DBPOWER_FROM_FLOAT(0.545268055052),    // *(2^13) for [73]
    DBPOWER_FROM_FLOAT(0.611800819635),    // *(2^13) for [74]
    DBPOWER_FROM_FLOAT(0.686451811343),    // *(2^13) for [75]
    DBPOWER_FROM_FLOAT(0.770211599767),    // *(2^13) for [76]
    DBPOWER_FROM_FLOAT(0.864191628993),    // *(2^13) for [77]
    DBPOWER_FROM_FLOAT(0.969638954848),    // *(2^13) for [78]
    DBPOWER_FROM_FLOAT(1.087952803820),    // *(2^13) for [79]
    DBPOWER_FROM_FLOAT(0.610351562500),    // *(2^14) for [80]
    DBPOWER_FROM_FLOAT(0.684825714678),    // *(2^14) for [81]
    DBPOWER_FROM_FLOAT(0.768387090415),    // *(2^14) for [82]
    DBPOWER_FROM_FLOAT(0.862144496292),    // *(2^14) for [83]
    DBPOWER_FROM_FLOAT(0.967342033982),    // *(2^14) for [84]
    DBPOWER_FROM_FLOAT(1.085375614464),    // *(2^14) for [85]
    DBPOWER_FROM_FLOAT(1.217811468989),    // *(2^14) for [86]
    DBPOWER_FROM_FLOAT(1.366406943649),    // *(2^14) for [87]
    DBPOWER_FROM_FLOAT(0.766566902399),    // *(2^15) for [88]
    DBPOWER_FROM_FLOAT(0.860102210194),    // *(2^15) for [89]
    DBPOWER_FROM_FLOAT(0.965050552040),    // *(2^15) for [90]
    DBPOWER_FROM_FLOAT(1.082804530859),    // *(2^15) for [91]
    DBPOWER_FROM_FLOAT(1.214926667511),    // *(2^15) for [92]
    DBPOWER_FROM_FLOAT(1.363170139492),    // *(2^15) for [93]
    DBPOWER_FROM_FLOAT(1.529502052814),    // *(2^15) for [94]
    DBPOWER_FROM_FLOAT(1.716129530221),    // *(2^15) for [95]
    DBPOWER_FROM_FLOAT(0.962764501572),    // *(2^16) for [96]
    DBPOWER_FROM_FLOAT(1.080239538103),    // *(2^16) for [97]
    DBPOWER_FROM_FLOAT(1.212048694491),    // *(2^16) for [98]
    DBPOWER_FROM_FLOAT(1.359941005707),    // *(2^16) for [99]
    DBPOWER_FROM_FLOAT(1.525878906250),    // *(2^16) for [100]
    DBPOWER_FROM_FLOAT(1.712064288557),    // *(2^16) for [101]
    DBPOWER_FROM_FLOAT(1.920967727900),    // *(2^16) for [102]
    DBPOWER_FROM_FLOAT(2.155361242592),    // *(2^16) for [103]
    DBPOWER_FROM_FLOAT(1.209177542478),    // *(2^17) for [104]
    DBPOWER_FROM_FLOAT(1.356719519943),    // *(2^17) for [105]
    DBPOWER_FROM_FLOAT(1.522264339030),    // *(2^17) for [106]
    DBPOWER_FROM_FLOAT(1.708008680493),    // *(2^17) for [107]
    DBPOWER_FROM_FLOAT(1.916417259723),    // *(2^17) for [108]
    DBPOWER_FROM_FLOAT(2.150255531073),    // *(2^17) for [109]
    DBPOWER_FROM_FLOAT(2.412626385689),    // *(2^17) for [110]
    DBPOWER_FROM_FLOAT(2.707011330873),    // *(2^17) for [111]
    DBPOWER_FROM_FLOAT(1.518658332527),    // *(2^18) for [112]
    DBPOWER_FROM_FLOAT(1.703962676227),    // *(2^18) for [113]
    DBPOWER_FROM_FLOAT(1.911877568811),    // *(2^18) for [114]
    DBPOWER_FROM_FLOAT(2.145161911845),    // *(2^18) for [115]
    DBPOWER_FROM_FLOAT(2.406911253929),    // *(2^18) for [116]
    DBPOWER_FROM_FLOAT(2.700598847121),    // *(2^18) for [117]
    DBPOWER_FROM_FLOAT(3.030121743679),    // *(2^18) for [118]
    DBPOWER_FROM_FLOAT(3.399852514267),    // *(2^18) for [119]
    DBPOWER_FROM_FLOAT(1.907348632813),    // *(2^19) for [120]
    DBPOWER_FROM_FLOAT(2.140080362558),    // *(2^19) for [121]
    DBPOWER_FROM_FLOAT(2.401209659874),    // *(2^19) for [122]
    DBPOWER_FROM_FLOAT(2.694201551378),    // *(2^19) for [123]
    DBPOWER_FROM_FLOAT(3.022943861783),    // *(2^19) for [124]
    DBPOWER_FROM_FLOAT(3.391798797995),    // *(2^19) for [125]
    DBPOWER_FROM_FLOAT(3.805660847574),    // *(2^19) for [126]
    DBPOWER_FROM_FLOAT(4.270021699369),    // *(2^19) for [127]
    DBPOWER_FROM_FLOAT(2.395521573722),    // *(2^20) for [128]
    DBPOWER_FROM_FLOAT(2.687819413841),    // *(2^20) for [129]
    DBPOWER_FROM_FLOAT(3.015782985836),    // *(2^20) for [130]
    DBPOWER_FROM_FLOAT(3.383764162660),    // *(2^20) for [131]
    DBPOWER_FROM_FLOAT(3.796645835042),    // *(2^20) for [132]
    DBPOWER_FROM_FLOAT(4.259906690568),    // *(2^20) for [133]
    DBPOWER_FROM_FLOAT(4.779693923891),    // *(2^20) for [134]
    DBPOWER_FROM_FLOAT(5.362904787064),    // *(2^20) for [135]
    DBPOWER_FROM_FLOAT(3.008639067411),    // *(2^21) for [136]
    DBPOWER_FROM_FLOAT(3.375748559833),    // *(2^21) for [137]
    DBPOWER_FROM_FLOAT(3.787652179599),    // *(2^21) for [138]
    DBPOWER_FROM_FLOAT(4.249815642834),    // *(2^21) for [139]
    DBPOWER_FROM_FLOAT(4.768371582031),    // *(2^21) for [140]
    DBPOWER_FROM_FLOAT(5.350200910121),    // *(2^21) for [141]
    DBPOWER_FROM_FLOAT(6.003024157137),    // *(2^21) for [142]
    DBPOWER_FROM_FLOAT(6.735503885895),    // *(2^21) for [143]
    DBPOWER_FROM_FLOAT(3.778679829091),    // *(2^22) for [144]
    DBPOWER_FROM_FLOAT(4.239748500288)     // *(2^22) for [145]
};

#if defined(REFERENCE_RAND_16)
	// constants used by 16-bit quickRand
	const unsigned int g_uWMALCA[LCA_SET] = {1637,1033,1825,1621, 1657,1861,1229,1549, 2017,941,1409,1777, 1153};
	const unsigned int g_uWMALCC[LCC_SET] = {13849,13841,13859};
#endif

#ifdef BUILD_INT_FLOAT
// Lookup factor (float)pow(2,4+(iQSS>>3)) associated with the above table
// index with [iQSS>>3]
const Float rgfltDBPowerExponentScale[((DBPOWER_TABLE_OFFSET+DBPOWER_TABLE_SIZE)>>3)+1] = {
	   16.0f,     32.0f,     64.0f,    128.0f,     256.0f,     512.0f,  
	 1024.0f,   2048.0f,   4096.0f,   8192.0f,   16384.0f,   32768.0f,
	65536.0f, 131072.0f, 262144.0f, 524288.0f, 1048576.0f, 2097152.0f, 4194304.0f
 };
#endif

const U16 g_rgiBarkFreq	[] = 
                                    {  100,    200,    300,    400,    510, 
                                       630,    770,    920,   1080,   1270,
                                      1480,   1720,   2000,   2320,   2700,
                                      3150,   3700,   4400,   5300,   6400,
                                      7700,   9500,  12000,  15500,  24500 };

// pow (10, iCurrMaskQ*MASK_QUANT/20*m_fltFlatenFactor) * (1 << 10) for 10 fract bits
// MASK_QUANT = 2.5, m_fltFlatenFactor = 0.5
const U32 g_rgfiPwrToRMS[] =
{
    0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 4, 4, 5, 6, 7,
    8, 9, 10, 12, 14, 16, 18, 21, 24, 28, 32, 37, 43, 50, 58, 66, 77, 89, 102, 118,
    137, 158, 182, 210, 243, 280, 324, 374, 432, 499, 576, 665, 768, 887, 1024,
    1182, 1366, 1577, 1821, 2103, 2428, 2804, 3238, 3739, 4318, 4987, 5758, 6650,
    7679, 8867, 10240, 11825, 13655, 15769, 18210, 21028, 24283, 28041, 32382, 37394,
    43182, 49865, 57584, 66497, 76789, 88675, 102400, 118250, 136553, 157688, 182096,
    210281, 242829, 280414, 323817, 373938, 431817, 498655, 575838, 664967, 767892,
    886747, 1024000, 1182497, 1365526, 1576885, 1820958, 2102810, 2428287, 2804142,
    3238172, 3739383, 4318172, 4986547, 5758375
};




const U16 gRun16smOb[] =	{
    0,     1,     2,     3,     4,     5,     6,     7,     8,     9,    10,    11,    12,    13,    14,    15,    16,    17,    18,    19, 
   20,    21,    22,    23,    24,    25,    26,    27,    28,    29,    30,    31,    32,    33,    34,    35,    36,    37,    38,    39, 
   40,    41,    42,    43,    44,    45,    46,    47,    48,    49,    50,    51,    52,    53,    54,    55,    56,    57,    58,    59, 
   60,    61,    62,    63,    64,    65,    66,    67,    68,    69,    70,    71,    72,    73,    74,    75,    76,    77,    78,    79, 
   80,    81,    82,    83,    84,    85,    86,    87,    88,    89,    90,    91,    92,    93,    94,    95,    96,    97,    98,    99, 
  100,   101,   102,   103,   104,   105,   106,   107,   108,   109,   110,   111,   112,     0,     1,     2,     3,     4,     5,     6, 
    7,     8,     9,    10,    11,    12,    13,    14,    15,    16,    17,    18,    19,    20,    21,    22,    23,    24,    25,    26, 
   27,    28,    29,    30,    31,    32,    33,    34,    35,    36,    37,    38,    39,    40,    41,    42,    43,    44,    45,    46, 
   47,    48,    49,    50,    51,    52,    53,    54,    55,    56,    57,    58,    59,    60,    61,    62,    63,    64,    65,    66, 
   67,     0,     1,     2,     3,     4,     5,     6,     7,     8,     9,    10,    11,    12,    13,    14,    15,    16,    17,    18, 
   19,    20,    21,    22,    23,    24,    25,    26,    27,    28,    29,    30,    31,    32,    33,    34,    35,    36,    37,    38, 
   39,    40,    41,    42,    43,    44,    45,    46,    47,    48,     0,     1,     2,     3,     4,     5,     6,     7,     8,     9, 
   10,    11,    12,    13,    14,    15,    16,    17,    18,    19,    20,    21,    22,    23,    24,    25,    26,    27,    28,    29, 
   30,    31,    32,    33,    34,    35,    36,    37,    38,    39,    40,    41,     0,     1,     2,     3,     4,     5,     6,     7, 
    8,     9,    10,    11,    12,    13,    14,    15,    16,    17,    18,    19,    20,    21,    22,    23,    24,    25,    26,    27, 
   28,    29,    30,    31,    32,    33,    34,    35,    36,    37,    38,    39,     0,     1,     2,     3,     4,     5,     6,     7, 
    8,     9,    10,    11,    12,    13,    14,    15,    16,    17,    18,    19,    20,    21,    22,    23,    24,    25,    26,    27, 
   28,    29,    30,    31,     0,     1,     2,     3,     4,     5,     6,     7,     8,     9,    10,    11,    12,    13,    14,    15, 
   16,    17,    18,    19,    20,    21,    22,    23,    24,    25,    26,     0,     1,     2,     3,     4,     5,     6,     7,     8, 
    9,    10,    11,    12,    13,    14,     0,     1,     2,     3,     4,     5,     6,     7,     8,     9,     0,     1,     2,     3, 
    4,     0,     1,     2,     0,     1,     2,     0,     1,     2,     0,     1,     2,     0,     1,     0,     1,     0,     1,     0, 
    1,     0,     1,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0, 
    0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0, 
    0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0};

const U16 gLevel16smOb[] =	{
    1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1, 
    1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1, 
    1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1, 
    1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1, 
    1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1, 
    1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     2,     2,     2,     2,     2,     2,     2, 
    2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2, 
    2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2, 
    2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2, 
    2,     3,     3,     3,     3,     3,     3,     3,     3,     3,     3,     3,     3,     3,     3,     3,     3,     3,     3,     3, 
    3,     3,     3,     3,     3,     3,     3,     3,     3,     3,     3,     3,     3,     3,     3,     3,     3,     3,     3,     3, 
    3,     3,     3,     3,     3,     3,     3,     3,     3,     3,     4,     4,     4,     4,     4,     4,     4,     4,     4,     4, 
    4,     4,     4,     4,     4,     4,     4,     4,     4,     4,     4,     4,     4,     4,     4,     4,     4,     4,     4,     4, 
    4,     4,     4,     4,     4,     4,     4,     4,     4,     4,     4,     4,     5,     5,     5,     5,     5,     5,     5,     5, 
    5,     5,     5,     5,     5,     5,     5,     5,     5,     5,     5,     5,     5,     5,     5,     5,     5,     5,     5,     5, 
    5,     5,     5,     5,     5,     5,     5,     5,     5,     5,     5,     5,     6,     6,     6,     6,     6,     6,     6,     6, 
    6,     6,     6,     6,     6,     6,     6,     6,     6,     6,     6,     6,     6,     6,     6,     6,     6,     6,     6,     6, 
    6,     6,     6,     6,     7,     7,     7,     7,     7,     7,     7,     7,     7,     7,     7,     7,     7,     7,     7,     7, 
    7,     7,     7,     7,     7,     7,     7,     7,     7,     7,     7,     8,     8,     8,     8,     8,     8,     8,     8,     8, 
    8,     8,     8,     8,     8,     8,     9,     9,     9,     9,     9,     9,     9,     9,     9,     9,    10,    10,    10,    10, 
   10,    11,    11,    11,    12,    12,    12,    13,    13,    13,    14,    14,    14,    15,    15,    16,    16,    17,    17,    18, 
   18,    19,    19,    20,    21,    22,    23,    24,    25,    26,    27,    28,    29,    30,    31,    32,    33,    34,    35,    36, 
   37,    38,    39,    40,    41,    42,    43,    44,    45,    46,    47,    48,    49,    50,    51,    52,    53,    54,    55,    56, 
   57,    58,    59,    60,    61,    62,    63,    64,    65,    66,    67,    68,    69,    70};


const U16 gRun16ssOb[] =	{
    0,     1,     2,     3,     4,     5,     6,     7,     8,     9,    10,    11,    12,    13,    14,    15,    16,    17,    18,    19, 
   20,    21,    22,    23,    24,    25,    26,    27,    28,    29,    30,    31,    32,    33,    34,    35,    36,    37,    38,    39, 
   40,    41,    42,    43,    44,    45,    46,    47,    48,    49,    50,    51,    52,    53,    54,    55,    56,    57,    58,    59, 
   60,    61,    62,    63,    64,    65,    66,    67,    68,    69,    70,    71,    72,    73,    74,    75,    76,    77,    78,    79, 
   80,    81,    82,    83,    84,    85,    86,    87,    88,    89,    90,    91,    92,    93,    94,    95,    96,    97,    98,    99, 
  100,   101,   102,   103,   104,   105,   106,   107,   108,   109,   110,   111,   112,   113,   114,   115,   116,   117,   118,   119, 
  120,   121,   122,   123,   124,   125,   126,   127,   128,   129,   130,   131,   132,   133,   134,   135,   136,   137,   138,   139, 
  140,   141,   142,   143,   144,   145,   146,   147,   148,   149,   150,   151,   152,   153,   154,   155,   156,   157,   158,   159, 
  160,   161,   162,   163,   164,   165,   166,   167,   168,   169,   170,   171,   172,   173,   174,   175,   176,   177,   178,   179, 
  180,   181,   182,   183,   184,   185,   186,   187,   188,   189,   190,   191,   192,   193,   194,   195,   196,   197,   198,   199, 
  200,   201,   202,   203,   204,   205,   206,   207,   208,   209,   210,   211,   212,   213,     0,     1,     2,     3,     4,     5, 
    6,     7,     8,     9,    10,    11,    12,    13,    14,    15,    16,    17,    18,    19,    20,    21,    22,    23,    24,    25, 
   26,    27,    28,    29,    30,    31,    32,    33,    34,    35,    36,    37,    38,    39,    40,    41,    42,    43,    44,    45, 
   46,    47,    48,    49,    50,    51,    52,    53,    54,    55,    56,    57,    58,    59,    60,    61,    62,    63,    64,    65, 
   66,    67,    68,    69,    70,    71,     0,     1,     2,     3,     4,     5,     6,     7,     8,     9,    10,    11,    12,    13, 
   14,    15,    16,    17,    18,    19,    20,    21,    22,    23,    24,    25,    26,    27,    28,    29,    30,    31,    32,    33, 
   34,    35,    36,    37,    38,    39,    40,    41,     0,     1,     2,     3,     4,     5,     6,     7,     8,     9,    10,    11, 
   12,    13,    14,    15,    16,    17,    18,    19,    20,    21,    22,    23,    24,    25,    26,    27,    28,    29,    30,    31, 
   32,    33,    34,    35,    36,    37,    38,    39,     0,     1,     2,     3,     4,     5,     6,     7,     8,     9,    10,    11, 
   12,    13,    14,    15,    16,    17,     0,     1,     2,     3,     0,     1,     2,     3,     0,     1,     0,     1,     0,     1, 
    0,     1,     0,     1,     0,     0,     0,     1,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0, 
    0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0};

const U16 gLevel16ssOb[] =	{
    1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1, 
    1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1, 
    1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1, 
    1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1, 
    1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1, 
    1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1, 
    1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1, 
    1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1, 
    1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1, 
    1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1, 
    1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     2,     2,     2,     2,     2,     2, 
    2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2, 
    2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2, 
    2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2, 
    2,     2,     2,     2,     2,     2,     3,     3,     3,     3,     3,     3,     3,     3,     3,     3,     3,     3,     3,     3, 
    3,     3,     3,     3,     3,     3,     3,     3,     3,     3,     3,     3,     3,     3,     3,     3,     3,     3,     3,     3, 
    3,     3,     3,     3,     3,     3,     3,     3,     4,     4,     4,     4,     4,     4,     4,     4,     4,     4,     4,     4, 
    4,     4,     4,     4,     4,     4,     4,     4,     4,     4,     4,     4,     4,     4,     4,     4,     4,     4,     4,     4, 
    4,     4,     4,     4,     4,     4,     4,     4,     5,     5,     5,     5,     5,     5,     5,     5,     5,     5,     5,     5, 
    5,     5,     5,     5,     5,     5,     6,     6,     6,     6,     7,     7,     7,     7,     8,     8,     9,     9,    10,    10, 
   11,    11,    12,    12,    13,    14,    15,    15,    16,    17,    18,    19,    20,    21,    22,    23,    24,    25,    26,    27, 
   28,    29,    30,    31,    32,    33,    34,    35,    36,    37,    38,    39,    40};

#ifdef ENABLE_ALL_ENCOPT

const U16 gRun44smOb[] =	{
    0,     1,     2,     3,     4,     5,     6,     7,     8,     9,    10,    11,    12,    13,    14,    15,    16,    17,    18,    19, 
   20,    21,    22,    23,    24,    25,    26,    27,    28,    29,    30,    31,    32,    33,    34,    35,    36,    37,    38,    39, 
   40,    41,    42,    43,    44,    45,    46,    47,    48,    49,    50,    51,    52,    53,    54,    55,    56,    57,    58,    59, 
   60,    61,    62,    63,    64,    65,    66,    67,    68,    69,    70,    71,    72,    73,    74,    75,    76,    77,    78,    79, 
   80,    81,    82,    83,    84,    85,    86,    87,    88,    89,    90,    91,    92,    93,    94,    95,    96,    97,    98,    99, 
  100,   101,   102,   103,   104,   105,   106,   107,   108,   109,   110,   111,   112,   113,   114,   115,   116,   117,   118,   119, 
  120,   121,   122,   123,   124,   125,   126,   127,   128,   129,   130,   131,   132,   133,   134,   135,   136,   137,   138,   139, 
  140,   141,   142,   143,   144,   145,   146,   147,   148,   149,   150,   151,   152,   153,   154,   155,   156,   157,   158,   159, 
  160,   161,   162,   163,   164,   165,   166,   167,   168,   169,   170,   171,   172,   173,   174,   175,   176,   177,   178,   179, 
  180,     0,     1,     2,     3,     4,     5,     6,     7,     8,     9,    10,    11,    12,    13,    14,    15,    16,    17,    18, 
   19,    20,    21,    22,    23,    24,    25,    26,    27,    28,    29,    30,    31,    32,    33,    34,    35,    36,    37,    38, 
   39,    40,    41,    42,    43,    44,    45,    46,    47,    48,    49,    50,    51,    52,    53,    54,    55,    56,    57,    58, 
   59,    60,    61,    62,    63,    64,    65,    66,    67,    68,    69,    70,    71,    72,    73,    74,    75,    76,    77,    78, 
   79,    80,    81,    82,    83,    84,    85,    86,    87,    88,    89,    90,    91,    92,    93,    94,    95,    96,    97,    98, 
   99,   100,   101,   102,   103,   104,   105,   106,   107,   108,   109,     0,     1,     2,     3,     4,     5,     6,     7,     8, 
    9,    10,    11,    12,    13,    14,    15,    16,    17,    18,    19,    20,    21,    22,    23,    24,    25,    26,    27,    28, 
   29,    30,    31,    32,    33,    34,    35,    36,    37,    38,    39,    40,    41,    42,    43,    44,    45,    46,    47,    48, 
   49,    50,    51,    52,    53,    54,    55,    56,    57,    58,    59,    60,    61,    62,    63,    64,    65,    66,    67,    68, 
   69,    70,    71,    72,    73,    74,    75,    76,    77,     0,     1,     2,     3,     4,     5,     6,     7,     8,     9,    10, 
   11,    12,    13,    14,    15,    16,    17,    18,    19,    20,    21,    22,    23,    24,    25,    26,    27,    28,    29,    30, 
   31,    32,    33,    34,    35,    36,    37,    38,    39,    40,    41,    42,    43,    44,    45,    46,    47,    48,    49,    50, 
   51,    52,    53,    54,    55,    56,    57,    58,    59,    60,    61,    62,     0,     1,     2,     3,     4,     5,     6,     7, 
    8,     9,    10,    11,    12,    13,    14,    15,    16,    17,    18,    19,    20,    21,    22,    23,    24,    25,    26,    27, 
   28,    29,    30,    31,    32,    33,    34,    35,    36,    37,    38,    39,    40,    41,    42,    43,    44,    45,    46,    47, 
   48,    49,    50,    51,    52,    53,    54,    55,    56,    57,    58,    59,    60,     0,     1,     2,     3,     4,     5,     6, 
    7,     8,     9,    10,    11,    12,    13,    14,    15,    16,    17,    18,    19,    20,    21,    22,    23,    24,    25,    26, 
   27,    28,    29,    30,    31,    32,    33,    34,    35,    36,    37,    38,    39,    40,    41,    42,    43,    44,    45,    46, 
   47,    48,    49,    50,    51,    52,    53,    54,    55,    56,    57,    58,    59,    60,    61,     0,     1,     2,     3,     4, 
    5,     6,     7,     8,     9,    10,    11,    12,    13,    14,    15,    16,    17,    18,    19,    20,    21,    22,    23,    24, 
   25,    26,    27,    28,    29,    30,    31,    32,    33,    34,    35,    36,    37,    38,    39,    40,    41,    42,    43,    44, 
   45,    46,    47,    48,    49,    50,    51,    52,    53,    54,    55,    56,    57,    58,    59,     0,     1,     2,     3,     4, 
    5,     6,     7,     8,     9,    10,    11,    12,    13,    14,    15,    16,    17,    18,    19,    20,    21,    22,    23,    24, 
   25,    26,    27,    28,    29,    30,    31,    32,    33,    34,    35,    36,    37,    38,    39,    40,    41,    42,    43,    44, 
   45,    46,    47,    48,    49,    50,    51,    52,    53,    54,    55,    56,    57,    58,    59,    60,     0,     1,     2,     3, 
    4,     5,     6,     7,     8,     9,    10,    11,    12,    13,    14,    15,    16,    17,    18,    19,    20,    21,    22,    23, 
   24,    25,    26,    27,    28,    29,    30,    31,    32,     0,     1,     2,     3,     4,     5,     6,     7,     8,     9,    10, 
   11,    12,    13,    14,    15,    16,    17,    18,    19,    20,    21,    22,    23,    24,    25,    26,    27,    28,    29,    30, 
   31,    32,    33,    34,    35,    36,    37,    38,    39,    40,     0,     1,     2,     3,     4,     5,     6,     7,     8,     9, 
   10,    11,    12,    13,    14,    15,    16,    17,    18,    19,    20,    21,    22,    23,    24,    25,    26,    27,    28,    29, 
   30,    31,    32,    33,    34,    35,    36,    37,    38,    39,    40,     0,     1,     2,     3,     4,     5,     6,     7,     8, 
    9,    10,    11,    12,    13,    14,    15,    16,    17,    18,     0,     1,     2,     3,     4,     5,     6,     7,     8,     9, 
   10,    11,    12,    13,    14,    15,    16,     0,     1,     2,     3,     4,     5,     6,     7,     8,     9,    10,    11,    12, 
   13,    14,    15,    16,    17,    18,     0,     1,     2,     3,     4,     5,     6,     7,     8,     9,    10,    11,     0,     1, 
    2,     3,     4,     5,     6,     7,     8,     9,    10,     0,     1,     2,     3,     4,     5,     6,     7,     8,     0,     1, 
    2,     3,     4,     5,     6,     7,     8,     9,    10,     0,     1,     2,     3,     4,     5,     6,     7,     8,     9,     0, 
    1,     2,     3,     4,     5,     0,     1,     2,     3,     4,     5,     6,     7,     0,     1,     2,     3,     4,     5,     6, 
    0,     1,     2,     3,     4,     5,     0,     1,     2,     3,     0,     1,     2,     3,     4,     0,     1,     2,     3,     4, 
    0,     1,     2,     3,     0,     1,     2,     3,     0,     1,     2,     0,     1,     2,     3,     0,     1,     2,     0,     1, 
    2,     3,     4,     0,     1,     2,     0,     1,     2,     3,     0,     1,     2,     0,     1,     2,     0,     1,     2,     0, 
    1,     2,     0,     1,     2,     0,     1,     2,     0,     1,     0,     1,     0,     1,     2,     3,     0,     1,     0,     1, 
    2,     0,     1,     0,     1,     2,     0,     1,     2,     0,     1,     0,     1,     0,     1,     0,     1,     0,     1,     0, 
    1,     0,     1,     0,     1,     0,     1,     2,     0,     1,     0,     1,     0,     1,     0,     1,     0,     1,     0,     1, 
    0,     1,     0,     1,     0,     1,     0,     1,     0,     0,     1,     0,     0,     1,     0,     1,     0,     1,     0,     1, 
    0,     0,     1,     0,     0,     0,     0,     1,     0,     1,     0,     0,     1,     0,     0,     1,     0,     1,     0,     1, 
    0,     1,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0, 
    0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0, 
    0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0, 
    0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0, 
    0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0, 
    0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0, 
    0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0, 
    0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0, 
    0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0, 
    0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0, 
    0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0, 
    0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0, 
    0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0};

const U16 gLevel44smOb[] =	{
    1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1, 
    1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1, 
    1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1, 
    1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1, 
    1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1, 
    1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1, 
    1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1, 
    1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1, 
    1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1, 
    1,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2, 
    2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2, 
    2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2, 
    2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2, 
    2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2, 
    2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     3,     3,     3,     3,     3,     3,     3,     3,     3, 
    3,     3,     3,     3,     3,     3,     3,     3,     3,     3,     3,     3,     3,     3,     3,     3,     3,     3,     3,     3, 
    3,     3,     3,     3,     3,     3,     3,     3,     3,     3,     3,     3,     3,     3,     3,     3,     3,     3,     3,     3, 
    3,     3,     3,     3,     3,     3,     3,     3,     3,     3,     3,     3,     3,     3,     3,     3,     3,     3,     3,     3, 
    3,     3,     3,     3,     3,     3,     3,     3,     3,     4,     4,     4,     4,     4,     4,     4,     4,     4,     4,     4, 
    4,     4,     4,     4,     4,     4,     4,     4,     4,     4,     4,     4,     4,     4,     4,     4,     4,     4,     4,     4, 
    4,     4,     4,     4,     4,     4,     4,     4,     4,     4,     4,     4,     4,     4,     4,     4,     4,     4,     4,     4, 
    4,     4,     4,     4,     4,     4,     4,     4,     4,     4,     4,     4,     5,     5,     5,     5,     5,     5,     5,     5, 
    5,     5,     5,     5,     5,     5,     5,     5,     5,     5,     5,     5,     5,     5,     5,     5,     5,     5,     5,     5, 
    5,     5,     5,     5,     5,     5,     5,     5,     5,     5,     5,     5,     5,     5,     5,     5,     5,     5,     5,     5, 
    5,     5,     5,     5,     5,     5,     5,     5,     5,     5,     5,     5,     5,     6,     6,     6,     6,     6,     6,     6, 
    6,     6,     6,     6,     6,     6,     6,     6,     6,     6,     6,     6,     6,     6,     6,     6,     6,     6,     6,     6, 
    6,     6,     6,     6,     6,     6,     6,     6,     6,     6,     6,     6,     6,     6,     6,     6,     6,     6,     6,     6, 
    6,     6,     6,     6,     6,     6,     6,     6,     6,     6,     6,     6,     6,     6,     6,     7,     7,     7,     7,     7, 
    7,     7,     7,     7,     7,     7,     7,     7,     7,     7,     7,     7,     7,     7,     7,     7,     7,     7,     7,     7, 
    7,     7,     7,     7,     7,     7,     7,     7,     7,     7,     7,     7,     7,     7,     7,     7,     7,     7,     7,     7, 
    7,     7,     7,     7,     7,     7,     7,     7,     7,     7,     7,     7,     7,     7,     7,     8,     8,     8,     8,     8, 
    8,     8,     8,     8,     8,     8,     8,     8,     8,     8,     8,     8,     8,     8,     8,     8,     8,     8,     8,     8, 
    8,     8,     8,     8,     8,     8,     8,     8,     8,     8,     8,     8,     8,     8,     8,     8,     8,     8,     8,     8, 
    8,     8,     8,     8,     8,     8,     8,     8,     8,     8,     8,     8,     8,     8,     8,     8,     9,     9,     9,     9, 
    9,     9,     9,     9,     9,     9,     9,     9,     9,     9,     9,     9,     9,     9,     9,     9,     9,     9,     9,     9, 
    9,     9,     9,     9,     9,     9,     9,     9,     9,    10,    10,    10,    10,    10,    10,    10,    10,    10,    10,    10, 
   10,    10,    10,    10,    10,    10,    10,    10,    10,    10,    10,    10,    10,    10,    10,    10,    10,    10,    10,    10, 
   10,    10,    10,    10,    10,    10,    10,    10,    10,    10,    11,    11,    11,    11,    11,    11,    11,    11,    11,    11, 
   11,    11,    11,    11,    11,    11,    11,    11,    11,    11,    11,    11,    11,    11,    11,    11,    11,    11,    11,    11, 
   11,    11,    11,    11,    11,    11,    11,    11,    11,    11,    11,    12,    12,    12,    12,    12,    12,    12,    12,    12, 
   12,    12,    12,    12,    12,    12,    12,    12,    12,    12,    13,    13,    13,    13,    13,    13,    13,    13,    13,    13, 
   13,    13,    13,    13,    13,    13,    13,    14,    14,    14,    14,    14,    14,    14,    14,    14,    14,    14,    14,    14, 
   14,    14,    14,    14,    14,    14,    15,    15,    15,    15,    15,    15,    15,    15,    15,    15,    15,    15,    16,    16, 
   16,    16,    16,    16,    16,    16,    16,    16,    16,    17,    17,    17,    17,    17,    17,    17,    17,    17,    18,    18, 
   18,    18,    18,    18,    18,    18,    18,    18,    18,    19,    19,    19,    19,    19,    19,    19,    19,    19,    19,    20, 
   20,    20,    20,    20,    20,    21,    21,    21,    21,    21,    21,    21,    21,    22,    22,    22,    22,    22,    22,    22, 
   23,    23,    23,    23,    23,    23,    24,    24,    24,    24,    25,    25,    25,    25,    25,    26,    26,    26,    26,    26, 
   27,    27,    27,    27,    28,    28,    28,    28,    29,    29,    29,    30,    30,    30,    30,    31,    31,    31,    32,    32, 
   32,    32,    32,    33,    33,    33,    34,    34,    34,    34,    35,    35,    35,    36,    36,    36,    37,    37,    37,    38, 
   38,    38,    39,    39,    39,    40,    40,    40,    41,    41,    42,    42,    43,    43,    43,    43,    44,    44,    45,    45, 
   45,    46,    46,    47,    47,    47,    48,    48,    48,    49,    49,    50,    50,    51,    51,    52,    52,    53,    53,    54, 
   54,    55,    55,    56,    56,    57,    57,    57,    58,    58,    59,    59,    60,    60,    61,    61,    62,    62,    63,    63, 
   64,    64,    65,    65,    66,    66,    67,    67,    68,    69,    69,    70,    71,    71,    72,    72,    73,    73,    74,    74, 
   75,    76,    76,    77,    78,    79,    80,    80,    81,    81,    82,    83,    83,    84,    85,    85,    86,    86,    87,    87, 
   88,    88,    89,    90,    91,    92,    93,    94,    95,    96,    97,    98,    99,   100,   101,   102,   103,   104,   105,   106, 
  107,   108,   109,   110,   111,   112,   113,   114,   115,   116,   117,   118,   119,   120,   121,   122,   123,   124,   125,   126, 
  127,   128,   129,   130,   131,   132,   133,   134,   135,   136,   137,   138,   139,   140,   141,   142,   143,   144,   145,   146, 
  147,   148,   149,   150,   151,   152,   153,   154,   155,   156,   157,   158,   159,   160,   161,   162,   163,   164,   165,   166, 
  167,   168,   169,   170,   171,   172,   173,   174,   175,   176,   177,   178,   179,   180,   181,   182,   183,   184,   185,   186, 
  187,   188,   189,   190,   191,   192,   193,   194,   195,   196,   197,   198,   199,   200,   201,   202,   203,   204,   205,   206, 
  207,   208,   209,   210,   211,   212,   213,   214,   215,   216,   217,   218,   219,   220,   221,   222,   223,   224,   225,   226, 
  227,   228,   229,   230,   231,   232,   233,   234,   235,   236,   237,   238,   239,   240,   241,   242,   243,   244,   245,   246, 
  247,   248,   249,   250,   251,   252,   253,   254,   255,   256,   257,   258,   259,   260,   261,   262,   263,   264,   265,   266, 
  267,   268,   269,   270,   271,   272,   273,   274,   275,   276,   277,   278,   279,   280,   281,   282,   283,   284,   285,   286, 
  287,   288,   289,   290,   291,   292,   293,   294,   295,   296,   297,   298,   299,   300,   301,   302,   303,   304,   305,   306, 
  307,   308,   309,   310,   311,   312,   313,   314,   315,   316,   317,   318,   319,   320,   321,   322,   323,   324,   325,   326, 
  327,   328,   329,   330,   331,   332,   333,   334,   335,   336,   337,   338,   339};


const U16 gRun44ssOb[] =	{
    0,     1,     2,     3,     4,     5,     6,     7,     8,     9,    10,    11,    12,    13,    14,    15,    16,    17,    18,    19, 
   20,    21,    22,    23,    24,    25,    26,    27,    28,    29,    30,    31,    32,    33,    34,    35,    36,    37,    38,    39, 
   40,    41,    42,    43,    44,    45,    46,    47,    48,    49,    50,    51,    52,    53,    54,    55,    56,    57,    58,    59, 
   60,    61,    62,    63,    64,    65,    66,    67,    68,    69,    70,    71,    72,    73,    74,    75,    76,    77,    78,    79, 
   80,    81,    82,    83,    84,    85,    86,    87,    88,    89,    90,    91,    92,    93,    94,    95,    96,    97,    98,    99, 
  100,   101,   102,   103,   104,   105,   106,   107,   108,   109,   110,   111,   112,   113,   114,   115,   116,   117,   118,   119, 
  120,   121,   122,   123,   124,   125,   126,   127,   128,   129,   130,   131,   132,   133,   134,   135,   136,   137,   138,   139, 
  140,   141,   142,   143,   144,   145,   146,   147,   148,   149,   150,   151,   152,   153,   154,   155,   156,   157,   158,   159, 
  160,   161,   162,   163,   164,   165,   166,   167,   168,   169,   170,   171,   172,   173,   174,   175,   176,   177,   178,   179, 
  180,   181,   182,   183,   184,   185,   186,   187,   188,   189,   190,   191,   192,   193,   194,   195,   196,   197,   198,   199, 
  200,   201,   202,   203,   204,   205,   206,   207,   208,   209,   210,   211,   212,   213,   214,   215,   216,   217,   218,   219, 
  220,   221,   222,   223,   224,   225,   226,   227,   228,   229,   230,   231,   232,   233,   234,   235,   236,   237,   238,   239, 
  240,   241,   242,   243,   244,   245,   246,   247,   248,   249,   250,   251,   252,   253,   254,   255,   256,   257,   258,   259, 
  260,   261,   262,   263,   264,   265,   266,   267,   268,   269,   270,   271,   272,   273,   274,   275,   276,   277,   278,   279, 
  280,   281,   282,   283,   284,   285,   286,   287,   288,   289,   290,   291,   292,   293,   294,   295,   296,   297,   298,   299, 
  300,   301,   302,   303,   304,   305,   306,   307,   308,   309,   310,   311,   312,   313,   314,   315,   316,   317,   318,   319, 
  320,   321,   322,   323,   324,   325,   326,   327,   328,   329,   330,   331,   332,   333,   334,   335,   336,   337,   338,   339, 
  340,   341,   342,   343,   344,   345,   346,   347,   348,   349,   350,     0,     1,     2,     3,     4,     5,     6,     7,     8, 
    9,    10,    11,    12,    13,    14,    15,    16,    17,    18,    19,    20,    21,    22,    23,    24,    25,    26,    27,    28, 
   29,    30,    31,    32,    33,    34,    35,    36,    37,    38,    39,    40,    41,    42,    43,    44,    45,    46,    47,    48, 
   49,    50,    51,    52,    53,    54,    55,    56,    57,    58,    59,    60,    61,    62,    63,    64,    65,    66,    67,    68, 
   69,    70,    71,    72,    73,    74,    75,    76,    77,    78,    79,    80,    81,    82,    83,    84,    85,    86,    87,    88, 
   89,    90,    91,    92,    93,    94,    95,    96,    97,    98,    99,   100,   101,   102,   103,   104,   105,   106,   107,   108, 
  109,   110,   111,   112,   113,   114,   115,   116,   117,   118,   119,   120,   121,     0,     1,     2,     3,     4,     5,     6, 
    7,     8,     9,    10,    11,    12,    13,    14,    15,    16,    17,    18,    19,    20,    21,    22,    23,    24,    25,    26, 
   27,    28,    29,    30,    31,    32,    33,    34,    35,    36,    37,    38,    39,    40,    41,    42,    43,    44,    45,    46, 
   47,    48,    49,    50,    51,    52,    53,    54,    55,    56,    57,    58,    59,    60,    61,    62,    63,    64,    65,    66, 
   67,    68,    69,    70,    71,    72,    73,    74,    75,     0,     1,     2,     3,     4,     5,     6,     7,     8,     9,    10, 
   11,    12,    13,    14,    15,    16,    17,    18,    19,    20,    21,    22,    23,    24,    25,    26,    27,    28,    29,    30, 
   31,    32,    33,    34,    35,    36,    37,    38,    39,    40,    41,    42,    43,    44,    45,    46,    47,    48,    49,    50, 
   51,    52,    53,    54,    55,    56,    57,    58,    59,    60,     0,     1,     2,     3,     4,     5,     6,     7,     8,     9, 
   10,    11,    12,    13,    14,    15,    16,    17,    18,    19,    20,    21,    22,    23,    24,    25,    26,    27,    28,    29, 
   30,    31,    32,    33,    34,    35,    36,    37,    38,    39,    40,     0,     1,     2,     3,     4,     5,     6,     7,     8, 
    9,    10,    11,    12,    13,    14,    15,    16,    17,    18,    19,    20,    21,    22,    23,    24,    25,    26,    27,    28, 
   29,    30,    31,    32,    33,    34,    35,    36,    37,    38,    39,    40,    41,     0,     1,     2,     3,     4,     5,     6, 
    7,     8,     9,    10,    11,    12,    13,    14,    15,    16,    17,    18,    19,    20,    21,    22,    23,     0,     1,     2, 
    3,     4,     5,     6,     7,     8,     9,    10,    11,    12,    13,    14,    15,    16,    17,    18,    19,    20,    21,    22, 
   23,    24,    25,    26,    27,    28,    29,     0,     1,     2,     3,     4,     5,     6,     7,     8,     9,    10,    11,    12, 
   13,    14,    15,    16,    17,    18,    19,    20,    21,     0,     1,     2,     3,     4,     5,     6,     7,     8,     9,    10, 
   11,    12,    13,    14,    15,    16,    17,    18,     0,     1,     2,     3,     4,     5,     6,     7,     8,     9,    10,     0, 
    1,     2,     3,     4,     5,     6,     7,     8,     0,     1,     2,     3,     4,     5,     6,     7,     8,     9,     0,     1, 
    2,     3,     4,     5,     6,     7,     0,     1,     2,     3,     4,     0,     1,     2,     3,     4,     0,     1,     2,     3, 
    0,     1,     2,     3,     4,     0,     1,     2,     3,     4,     0,     1,     2,     0,     1,     2,     0,     1,     2,     0, 
    1,     2,     0,     1,     2,     0,     1,     2,     0,     1,     2,     0,     1,     0,     1,     0,     1,     2,     0,     1, 
    0,     1,     0,     1,     0,     1,     2,     0,     1,     2,     0,     1,     0,     1,     0,     1,     0,     1,     2,     0, 
    1,     0,     1,     0,     1,     0,     1,     0,     1,     0,     1,     0,     1,     0,     1,     0,     1,     0,     1,     0, 
    1,     0,     1,     0,     1,     0,     1,     0,     1,     0,     1,     0,     0,     0,     1,     0,     1,     0,     0,     1, 
    0,     0,     1,     0,     1,     0,     1,     0,     1,     0,     1,     0,     1,     0,     0,     1,     0,     0,     0,     0, 
    0,     0,     0,     0,     0,     0,     0,     1,     0,     1,     0,     0,     1,     0,     0,     0,     0,     0,     0,     0, 
    0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0, 
    0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0, 
    0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0, 
    0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0, 
    0,     0,     0,     0,     0,     0,     0,     0,     0};

const U16 gLevel44ssOb[] =	{
    1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1, 
    1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1, 
    1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1, 
    1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1, 
    1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1, 
    1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1, 
    1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1, 
    1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1, 
    1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1, 
    1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1, 
    1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1, 
    1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1, 
    1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1, 
    1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1, 
    1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1, 
    1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1, 
    1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1, 
    1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     2,     2,     2,     2,     2,     2,     2,     2,     2, 
    2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2, 
    2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2, 
    2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2, 
    2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2, 
    2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2, 
    2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     3,     3,     3,     3,     3,     3,     3, 
    3,     3,     3,     3,     3,     3,     3,     3,     3,     3,     3,     3,     3,     3,     3,     3,     3,     3,     3,     3, 
    3,     3,     3,     3,     3,     3,     3,     3,     3,     3,     3,     3,     3,     3,     3,     3,     3,     3,     3,     3, 
    3,     3,     3,     3,     3,     3,     3,     3,     3,     3,     3,     3,     3,     3,     3,     3,     3,     3,     3,     3, 
    3,     3,     3,     3,     3,     3,     3,     3,     3,     4,     4,     4,     4,     4,     4,     4,     4,     4,     4,     4, 
    4,     4,     4,     4,     4,     4,     4,     4,     4,     4,     4,     4,     4,     4,     4,     4,     4,     4,     4,     4, 
    4,     4,     4,     4,     4,     4,     4,     4,     4,     4,     4,     4,     4,     4,     4,     4,     4,     4,     4,     4, 
    4,     4,     4,     4,     4,     4,     4,     4,     4,     4,     5,     5,     5,     5,     5,     5,     5,     5,     5,     5, 
    5,     5,     5,     5,     5,     5,     5,     5,     5,     5,     5,     5,     5,     5,     5,     5,     5,     5,     5,     5, 
    5,     5,     5,     5,     5,     5,     5,     5,     5,     5,     5,     6,     6,     6,     6,     6,     6,     6,     6,     6, 
    6,     6,     6,     6,     6,     6,     6,     6,     6,     6,     6,     6,     6,     6,     6,     6,     6,     6,     6,     6, 
    6,     6,     6,     6,     6,     6,     6,     6,     6,     6,     6,     6,     6,     7,     7,     7,     7,     7,     7,     7, 
    7,     7,     7,     7,     7,     7,     7,     7,     7,     7,     7,     7,     7,     7,     7,     7,     7,     8,     8,     8, 
    8,     8,     8,     8,     8,     8,     8,     8,     8,     8,     8,     8,     8,     8,     8,     8,     8,     8,     8,     8, 
    8,     8,     8,     8,     8,     8,     8,     9,     9,     9,     9,     9,     9,     9,     9,     9,     9,     9,     9,     9, 
    9,     9,     9,     9,     9,     9,     9,     9,     9,    10,    10,    10,    10,    10,    10,    10,    10,    10,    10,    10, 
   10,    10,    10,    10,    10,    10,    10,    10,    11,    11,    11,    11,    11,    11,    11,    11,    11,    11,    11,    12, 
   12,    12,    12,    12,    12,    12,    12,    12,    13,    13,    13,    13,    13,    13,    13,    13,    13,    13,    14,    14, 
   14,    14,    14,    14,    14,    14,    15,    15,    15,    15,    15,    16,    16,    16,    16,    16,    17,    17,    17,    17, 
   18,    18,    18,    18,    18,    19,    19,    19,    19,    19,    20,    20,    20,    21,    21,    21,    22,    22,    22,    23, 
   23,    23,    24,    24,    24,    25,    25,    25,    26,    26,    26,    27,    27,    28,    28,    29,    29,    29,    30,    30, 
   31,    31,    32,    32,    33,    33,    33,    34,    34,    34,    35,    35,    36,    36,    37,    37,    38,    38,    38,    39, 
   39,    40,    40,    41,    41,    42,    42,    43,    43,    44,    44,    45,    45,    46,    46,    47,    47,    48,    48,    49, 
   49,    50,    50,    51,    51,    52,    52,    53,    53,    54,    54,    55,    56,    57,    57,    58,    58,    59,    60,    60, 
   61,    62,    62,    63,    63,    64,    64,    65,    65,    66,    66,    67,    67,    68,    69,    69,    70,    71,    72,    73, 
   74,    75,    76,    77,    78,    79,    80,    80,    81,    81,    82,    83,    83,    84,    85,    86,    87,    88,    89,    90, 
   91,    92,    93,    94,    95,    96,    97,    98,    99,   100,   101,   102,   103,   104,   105,   106,   107,   108,   109,   110, 
  111,   112,   113,   114,   115,   116,   117,   118,   119,   120,   121,   122,   123,   124,   125,   126,   127,   128,   129,   130, 
  131,   132,   133,   134,   135,   136,   137,   138,   139,   140,   141,   142,   143,   144,   145,   146,   147,   148,   149,   150, 
  151,   152,   153,   154,   155,   156,   157,   158,   159,   160,   161,   162,   163,   164,   165,   166,   167,   168,   169,   170, 
  171,   172,   173,   174,   175,   176,   177,   178,   179};


const U16 gRun44smQb[] =	{
    0,     1,     2,     3,     4,     5,     6,     7,     8,     9,    10,    11,    12,    13,    14,    15,    16,    17,    18,    19, 
   20,    21,    22,    23,    24,    25,    26,    27,    28,    29,    30,    31,    32,    33,    34,    35,    36,    37,    38,    39, 
   40,    41,    42,    43,    44,    45,    46,    47,    48,    49,    50,    51,    52,    53,    54,    55,    56,    57,    58,    59, 
   60,    61,    62,    63,    64,    65,    66,    67,    68,    69,    70,    71,    72,    73,    74,    75,    76,    77,    78,    79, 
   80,    81,    82,    83,    84,    85,    86,    87,    88,    89,    90,    91,    92,    93,    94,    95,    96,    97,    98,    99, 
  100,   101,   102,   103,   104,   105,   106,   107,   108,   109,   110,   111,   112,   113,   114,   115,   116,   117,   118,   119, 
  120,   121,   122,   123,   124,   125,   126,   127,   128,   129,   130,   131,   132,   133,   134,   135,   136,   137,   138,   139, 
  140,   141,   142,   143,   144,   145,   146,   147,   148,   149,   150,   151,   152,   153,   154,   155,   156,   157,   158,   159, 
  160,   161,   162,   163,   164,   165,   166,   167,   168,   169,   170,   171,   172,   173,   174,   175,   176,   177,   178,   179, 
  180,   181,   182,   183,   184,   185,   186,   187,   188,   189,   190,   191,   192,   193,   194,   195,   196,   197,   198,   199, 
  200,   201,   202,   203,   204,   205,   206,   207,   208,   209,   210,   211,   212,   213,   214,   215,   216,   217,   218,   219, 
  220,   221,   222,   223,   224,   225,   226,   227,   228,   229,   230,   231,   232,   233,   234,   235,   236,   237,   238,   239, 
  240,   241,   242,   243,   244,   245,   246,   247,   248,   249,   250,   251,   252,   253,   254,   255,   256,   257,   258,   259, 
  260,   261,   262,   263,   264,   265,   266,   267,   268,   269,   270,   271,   272,   273,   274,   275,   276,   277,   278,   279, 
  280,   281,   282,   283,   284,   285,   286,   287,   288,   289,   290,   291,   292,   293,   294,   295,   296,   297,   298,   299, 
  300,   301,   302,   303,   304,   305,   306,   307,   308,   309,   310,   311,   312,   313,   314,   315,   316,     0,     1,     2, 
    3,     4,     5,     6,     7,     8,     9,    10,    11,    12,    13,    14,    15,    16,    17,    18,    19,    20,    21,    22, 
   23,    24,    25,    26,    27,    28,    29,    30,    31,    32,    33,    34,    35,    36,    37,    38,    39,    40,    41,    42, 
   43,    44,    45,    46,    47,    48,    49,    50,    51,    52,    53,    54,    55,    56,    57,    58,    59,    60,    61,    62, 
   63,    64,    65,    66,    67,    68,    69,    70,    71,    72,    73,    74,    75,    76,    77,    78,    79,    80,    81,    82, 
   83,    84,    85,    86,    87,    88,    89,    90,    91,     0,     1,     2,     3,     4,     5,     6,     7,     8,     9,    10, 
   11,    12,    13,    14,    15,    16,    17,    18,    19,    20,    21,    22,    23,    24,    25,    26,    27,    28,    29,    30, 
   31,    32,    33,    34,    35,    36,    37,    38,    39,    40,    41,    42,    43,    44,    45,    46,    47,    48,    49,    50, 
   51,    52,    53,    54,    55,    56,    57,    58,    59,    60,    61,     0,     1,     2,     3,     4,     5,     6,     7,     8, 
    9,    10,    11,    12,    13,    14,    15,    16,    17,    18,    19,    20,    21,    22,    23,    24,    25,    26,    27,    28, 
   29,    30,    31,    32,    33,    34,    35,    36,    37,    38,    39,    40,    41,    42,    43,    44,    45,    46,    47,    48, 
   49,    50,    51,    52,    53,    54,    55,    56,    57,    58,    59,     0,     1,     2,     3,     4,     5,     6,     7,     8, 
    9,    10,    11,    12,    13,    14,    15,    16,    17,    18,     0,     1,     2,     3,     4,     5,     6,     7,     8,     9, 
   10,    11,    12,    13,    14,    15,    16,     0,     1,     2,     3,     4,     5,     6,     7,     8,     9,     0,     1,     2, 
    3,     4,     5,     6,     0,     1,     2,     3,     4,     5,     0,     1,     2,     3,     4,     0,     1,     2,     3,     4, 
    0,     1,     2,     0,     1,     2,     0,     1,     2,     0,     1,     0,     1,     0,     1,     0,     1,     0,     1,     0, 
    1,     0,     1,     0,     0,     1,     0,     1,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0, 
    0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0, 
    0,     0,     0,     0};

const U16 gLevel44smQb[] =	{
    1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1, 
    1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1, 
    1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1, 
    1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1, 
    1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1, 
    1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1, 
    1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1, 
    1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1, 
    1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1, 
    1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1, 
    1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1, 
    1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1, 
    1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1, 
    1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1, 
    1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1, 
    1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     2,     2,     2, 
    2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2, 
    2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2, 
    2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2, 
    2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2, 
    2,     2,     2,     2,     2,     2,     2,     2,     2,     3,     3,     3,     3,     3,     3,     3,     3,     3,     3,     3, 
    3,     3,     3,     3,     3,     3,     3,     3,     3,     3,     3,     3,     3,     3,     3,     3,     3,     3,     3,     3, 
    3,     3,     3,     3,     3,     3,     3,     3,     3,     3,     3,     3,     3,     3,     3,     3,     3,     3,     3,     3, 
    3,     3,     3,     3,     3,     3,     3,     3,     3,     3,     3,     4,     4,     4,     4,     4,     4,     4,     4,     4, 
    4,     4,     4,     4,     4,     4,     4,     4,     4,     4,     4,     4,     4,     4,     4,     4,     4,     4,     4,     4, 
    4,     4,     4,     4,     4,     4,     4,     4,     4,     4,     4,     4,     4,     4,     4,     4,     4,     4,     4,     4, 
    4,     4,     4,     4,     4,     4,     4,     4,     4,     4,     4,     5,     5,     5,     5,     5,     5,     5,     5,     5, 
    5,     5,     5,     5,     5,     5,     5,     5,     5,     5,     6,     6,     6,     6,     6,     6,     6,     6,     6,     6, 
    6,     6,     6,     6,     6,     6,     6,     7,     7,     7,     7,     7,     7,     7,     7,     7,     7,     8,     8,     8, 
    8,     8,     8,     8,     9,     9,     9,     9,     9,     9,    10,    10,    10,    10,    10,    11,    11,    11,    11,    11, 
   12,    12,    12,    13,    13,    13,    14,    14,    14,    15,    15,    16,    16,    17,    17,    18,    18,    19,    19,    20, 
   20,    21,    21,    22,    23,    23,    24,    24,    25,    26,    27,    28,    29,    30,    31,    32,    33,    34,    35,    36, 
   37,    38,    39,    40,    41,    42,    43,    44,    45,    46,    47,    48,    49,    50,    51,    52,    53,    54,    55,    56, 
   57,    58,    59,    60};


const U16 gRun44ssQb[] =	{
    0,     1,     2,     3,     4,     5,     6,     7,     8,     9,    10,    11,    12,    13,    14,    15,    16,    17,    18,    19, 
   20,    21,    22,    23,    24,    25,    26,    27,    28,    29,    30,    31,    32,    33,    34,    35,    36,    37,    38,    39, 
   40,    41,    42,    43,    44,    45,    46,    47,    48,    49,    50,    51,    52,    53,    54,    55,    56,    57,    58,    59, 
   60,    61,    62,    63,    64,    65,    66,    67,    68,    69,    70,    71,    72,    73,    74,    75,    76,    77,    78,    79, 
   80,    81,    82,    83,    84,    85,    86,    87,    88,    89,    90,    91,    92,    93,    94,    95,    96,    97,    98,    99, 
  100,   101,   102,   103,   104,   105,   106,   107,   108,   109,   110,   111,   112,   113,   114,   115,   116,   117,   118,   119, 
  120,   121,   122,   123,   124,   125,   126,   127,   128,   129,   130,   131,   132,   133,   134,   135,   136,   137,   138,   139, 
  140,   141,   142,   143,   144,   145,   146,   147,   148,   149,   150,   151,   152,   153,   154,   155,   156,   157,   158,   159, 
  160,   161,   162,   163,   164,   165,   166,   167,   168,   169,   170,   171,   172,   173,   174,   175,   176,   177,   178,   179, 
  180,   181,   182,   183,   184,   185,   186,   187,   188,   189,   190,   191,   192,   193,   194,   195,   196,   197,   198,   199, 
  200,   201,   202,   203,   204,   205,   206,   207,   208,   209,   210,   211,   212,   213,   214,   215,   216,   217,   218,   219, 
  220,   221,   222,   223,   224,   225,   226,   227,   228,   229,   230,   231,   232,   233,   234,   235,   236,   237,   238,   239, 
  240,   241,   242,   243,   244,   245,   246,   247,   248,   249,   250,   251,   252,   253,   254,   255,   256,   257,   258,   259, 
  260,   261,   262,   263,   264,   265,   266,   267,   268,   269,   270,   271,   272,   273,   274,   275,   276,   277,   278,   279, 
  280,   281,   282,   283,   284,   285,   286,   287,   288,   289,   290,   291,   292,   293,   294,   295,   296,   297,   298,   299, 
  300,   301,   302,   303,   304,   305,   306,   307,   308,   309,   310,     0,     1,     2,     3,     4,     5,     6,     7,     8, 
    9,    10,    11,    12,    13,    14,    15,    16,    17,    18,    19,    20,    21,    22,    23,    24,    25,    26,    27,    28, 
   29,    30,    31,    32,    33,    34,    35,    36,    37,    38,    39,    40,    41,    42,    43,    44,    45,    46,    47,    48, 
   49,    50,    51,    52,    53,    54,    55,    56,    57,    58,    59,    60,    61,    62,    63,    64,    65,    66,    67,    68, 
   69,    70,    71,    72,    73,    74,    75,    76,    77,    78,    79,    80,    81,    82,    83,    84,    85,    86,    87,    88, 
   89,    90,     0,     1,     2,     3,     4,     5,     6,     7,     8,     9,    10,    11,    12,    13,    14,    15,    16,    17, 
   18,    19,    20,    21,    22,    23,    24,    25,    26,    27,    28,    29,    30,    31,    32,    33,    34,    35,    36,    37, 
   38,    39,    40,    41,    42,    43,    44,    45,    46,    47,    48,    49,    50,    51,    52,    53,    54,    55,    56,    57, 
   58,    59,    60,     0,     1,     2,     3,     4,     5,     6,     7,     8,     9,    10,    11,    12,    13,    14,    15,    16, 
   17,    18,    19,    20,    21,    22,    23,    24,    25,    26,    27,     0,     1,     2,     3,     4,     5,     6,     7,     8, 
    9,     0,     1,     2,     3,     4,     5,     0,     1,     2,     3,     4,     0,     1,     0,     1,     0,     1,     0,     1, 
    0,     1,     0,     1,     0,     1,     0,     1,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0, 
    0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0};

const U16 gLevel44ssQb[] =	{
    1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1, 
    1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1, 
    1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1, 
    1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1, 
    1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1, 
    1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1, 
    1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1, 
    1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1, 
    1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1, 
    1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1, 
    1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1, 
    1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1, 
    1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1, 
    1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1, 
    1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1, 
    1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     2,     2,     2,     2,     2,     2,     2,     2,     2, 
    2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2, 
    2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2, 
    2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2, 
    2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,     2, 
    2,     2,     3,     3,     3,     3,     3,     3,     3,     3,     3,     3,     3,     3,     3,     3,     3,     3,     3,     3, 
    3,     3,     3,     3,     3,     3,     3,     3,     3,     3,     3,     3,     3,     3,     3,     3,     3,     3,     3,     3, 
    3,     3,     3,     3,     3,     3,     3,     3,     3,     3,     3,     3,     3,     3,     3,     3,     3,     3,     3,     3, 
    3,     3,     3,     4,     4,     4,     4,     4,     4,     4,     4,     4,     4,     4,     4,     4,     4,     4,     4,     4, 
    4,     4,     4,     4,     4,     4,     4,     4,     4,     4,     4,     5,     5,     5,     5,     5,     5,     5,     5,     5, 
    5,     6,     6,     6,     6,     6,     6,     7,     7,     7,     7,     7,     8,     8,     9,     9,    10,    10,    11,    11, 
   12,    12,    13,    13,    14,    14,    15,    15,    16,    17,    18,    19,    20,    21,    22,    23,    24,    25,    26,    27, 
   28,    29,    30,    31,    32,    33,    34,    35,    36,    37,    38,    39,    40};


const float g_rgfltLsfReconLevel [LPCORDER] [16] = {
	{1.7925000e-002F,2.2837500e-002F,2.6762500e-002F,3.0825000e-002F,3.5525000e-002F,4.1200000e-002F,4.8675000e-002F,5.9487500e-002F},
	{2.6375000e-002F,3.1550000e-002F,3.5725000e-002F,3.9712500e-002F,4.3675000e-002F,4.7900000e-002F,5.2462500e-002F,5.7362500e-002F,6.2937500e-002F,6.9262500e-002F,7.6012500e-002F,8.3237500e-002F,9.1412500e-002F,1.0113750e-001F,1.1402500e-001F,1.3408750e-001F},
	{5.0262500e-002F,5.8850000e-002F,6.5262500e-002F,7.1475000e-002F,7.7675000e-002F,8.3950000e-002F,9.0537500e-002F,9.7350000e-002F,1.0438750e-001F,1.1285000e-001F,1.2243750e-001F,1.3320000e-001F,1.4338750e-001F,1.5515000e-001F,1.6963750e-001F,1.8963750e-001F},
	{7.7175000e-002F,9.1537500e-002F,1.0248750e-001F,1.1067500e-001F,1.1803750e-001F,1.2523750e-001F,1.3260000e-001F,1.4015000e-001F,1.4827500e-001F,1.5753750e-001F,1.6775000e-001F,1.7816250e-001F,1.8936250e-001F,2.0170000e-001F,2.1537500e-001F,2.3567500e-001F},
	{1.2272500e-001F,1.3523750e-001F,1.4651250e-001F,1.5676250e-001F,1.6615000e-001F,1.7541250e-001F,1.8412500e-001F,1.9248750e-001F,2.0115000e-001F,2.0993750e-001F,2.1916250e-001F,2.2836250e-001F,2.3852500e-001F,2.4982500e-001F,2.6332500e-001F,2.7956250e-001F},
	{1.6676250e-001F,1.8085000e-001F,1.9245000e-001F,2.0325000e-001F,2.1220000e-001F,2.2041250e-001F,2.2858750e-001F,2.3632500e-001F,2.4426250e-001F,2.5243750e-001F,3.7345000e-001F,2.7005000e-001F,2.7978750e-001F,2.9110000e-001F,3.0258750e-001F,3.1576250e-001F},
	{2.2883750e-001F,2.4497500e-001F,2.5706250e-001F,2.6682500e-001F,2.7482500e-001F,2.8178750e-001F,2.8793750e-001F,2.9365000e-001F,2.9970000e-001F,3.0601250e-001F,3.1253750e-001F,3.2001250e-001F,3.2903750e-001F,3.3938750e-001F,3.5292500e-001F,3.7077500e-001F},
	{2.9346250e-001F,3.1012500e-001F,3.2288750e-001F,3.3436250e-001F,3.4593750e-001F,3.5932500e-001F,3.7570000e-001F,4.0031250e-001F,3.4283750e-001F,3.4897500e-001F,3.5576250e-001F,3.6305000e-001F,3.7082500e-001F,3.8123750e-001F,3.9447500e-001F,4.0711250e-001F},
	{2.8091250e-001F,2.9517500e-001F,3.0435000e-001F,3.1206250e-001F,3.1885000e-001F,3.2506250e-001F,3.3096250e-001F,3.3675000e-001F},
	{3.9257500e-001F,4.0575000e-001F,4.1585000e-001F,4.2440000e-001F,4.3235000e-001F,4.4057500e-001F,4.5018750e-001F,4.6370000e-001F}};

#if defined(BUILD_INTEGER) || defined(INTEGER_ENCODER)

// This table is cut and pasted from WMAConcepts.xls!InvQuadRoot2
// Since the binary point is fixed at 32, this table should only change if INVQUADROOT_FRACTION_TABLE_SIZE==256 changes.
// Numerical results seem the same as previous method which used a 4096 table without interpolation

const UInt g_InvQuadRootFraction[1+INVQUADROOT_FRACTION_TABLE_SIZE] = {
    0xFFFFFFFF,                            //  UBP0_FROM_FLOAT(1),    //0
    UBP0_FROM_FLOAT(0.999025814722967),    //1
    UBP0_FROM_FLOAT(0.998056356216173),    //2
    UBP0_FROM_FLOAT(0.997091583357276),    //3
    UBP0_FROM_FLOAT(0.996131455538709),    //4
    UBP0_FROM_FLOAT(0.995175932659284),    //5
    UBP0_FROM_FLOAT(0.994224975115967),    //6
    UBP0_FROM_FLOAT(0.993278543795814),    //7
    UBP0_FROM_FLOAT(0.992336600068073),    //8
    UBP0_FROM_FLOAT(0.991399105776439),    //9
    UBP0_FROM_FLOAT(0.990466023231461),    //10
    UBP0_FROM_FLOAT(0.989537315203104),    //11
    UBP0_FROM_FLOAT(0.988612944913449),    //12
    UBP0_FROM_FLOAT(0.987692876029542),    //13
    UBP0_FROM_FLOAT(0.98677707265638),    //14
    UBP0_FROM_FLOAT(0.985865499330035),    //15
    UBP0_FROM_FLOAT(0.984958121010905),    //16
    UBP0_FROM_FLOAT(0.984054903077102),    //17
    UBP0_FROM_FLOAT(0.983155811317963),    //18
    UBP0_FROM_FLOAT(0.982260811927689),    //19
    UBP0_FROM_FLOAT(0.981369871499097),    //20
    UBP0_FROM_FLOAT(0.980482957017497),    //21
    UBP0_FROM_FLOAT(0.979600035854689),    //22
    UBP0_FROM_FLOAT(0.978721075763059),    //23
    UBP0_FROM_FLOAT(0.977846044869802),    //24
    UBP0_FROM_FLOAT(0.976974911671241),    //25
    UBP0_FROM_FLOAT(0.976107645027259),    //26
    UBP0_FROM_FLOAT(0.97524421415583),    //27
    UBP0_FROM_FLOAT(0.974384588627654),    //28
    UBP0_FROM_FLOAT(0.973528738360891),    //29
    UBP0_FROM_FLOAT(0.972676633615989),    //30
    UBP0_FROM_FLOAT(0.97182824499061),    //31
    UBP0_FROM_FLOAT(0.970983543414647),    //32
    UBP0_FROM_FLOAT(0.970142500145332),    //33
    UBP0_FROM_FLOAT(0.969305086762432),    //34
    UBP0_FROM_FLOAT(0.968471275163532),    //35
    UBP0_FROM_FLOAT(0.967641037559406),    //36
    UBP0_FROM_FLOAT(0.966814346469464),    //37
    UBP0_FROM_FLOAT(0.965991174717289),    //38
    UBP0_FROM_FLOAT(0.965171495426243),    //39
    UBP0_FROM_FLOAT(0.964355282015168),    //40
    UBP0_FROM_FLOAT(0.96354250819414),    //41
    UBP0_FROM_FLOAT(0.96273314796032),    //42
    UBP0_FROM_FLOAT(0.961927175593862),    //43
    UBP0_FROM_FLOAT(0.961124565653902),    //44
    UBP0_FROM_FLOAT(0.960325292974613),    //45
    UBP0_FROM_FLOAT(0.95952933266133),    //46
    UBP0_FROM_FLOAT(0.958736660086742),    //47
    UBP0_FROM_FLOAT(0.957947250887149),    //48
    UBP0_FROM_FLOAT(0.957161080958785),    //49
    UBP0_FROM_FLOAT(0.956378126454201),    //50
    UBP0_FROM_FLOAT(0.955598363778716),    //51
    UBP0_FROM_FLOAT(0.954821769586923),    //52
    UBP0_FROM_FLOAT(0.954048320779256),    //53
    UBP0_FROM_FLOAT(0.953277994498616),    //54
    UBP0_FROM_FLOAT(0.952510768127053),    //55
    UBP0_FROM_FLOAT(0.951746619282504),    //56
    UBP0_FROM_FLOAT(0.95098552581559),    //57
    UBP0_FROM_FLOAT(0.950227465806457),    //58
    UBP0_FROM_FLOAT(0.949472417561678),    //59
    UBP0_FROM_FLOAT(0.948720359611208),    //60
    UBP0_FROM_FLOAT(0.947971270705378),    //61
    UBP0_FROM_FLOAT(0.947225129811953),    //62
    UBP0_FROM_FLOAT(0.946481916113228),    //63
    UBP0_FROM_FLOAT(0.945741609003176),    //64
    UBP0_FROM_FLOAT(0.945004188084643),    //65
    UBP0_FROM_FLOAT(0.944269633166589),    //66
    UBP0_FROM_FLOAT(0.943537924261368),    //67
    UBP0_FROM_FLOAT(0.942809041582063),    //68
    UBP0_FROM_FLOAT(0.942082965539854),    //69
    UBP0_FROM_FLOAT(0.941359676741435),    //70
    UBP0_FROM_FLOAT(0.940639155986465),    //71
    UBP0_FROM_FLOAT(0.939921384265074),    //72
    UBP0_FROM_FLOAT(0.939206342755389),    //73
    UBP0_FROM_FLOAT(0.93849401282112),    //74
    UBP0_FROM_FLOAT(0.937784376009166),    //75
    UBP0_FROM_FLOAT(0.937077414047272),    //76
    UBP0_FROM_FLOAT(0.936373108841719),    //77
    UBP0_FROM_FLOAT(0.935671442475046),    //78
    UBP0_FROM_FLOAT(0.934972397203813),    //79
    UBP0_FROM_FLOAT(0.9342759554564),    //80
    UBP0_FROM_FLOAT(0.933582099830834),    //81
    UBP0_FROM_FLOAT(0.932890813092654),    //82
    UBP0_FROM_FLOAT(0.932202078172812),    //83
    UBP0_FROM_FLOAT(0.931515878165598),    //84
    UBP0_FROM_FLOAT(0.930832196326605),    //85
    UBP0_FROM_FLOAT(0.930151016070724),    //86
    UBP0_FROM_FLOAT(0.929472320970163),    //87
    UBP0_FROM_FLOAT(0.928796094752507),    //88
    UBP0_FROM_FLOAT(0.928122321298796),    //89
    UBP0_FROM_FLOAT(0.927450984641643),    //90
    UBP0_FROM_FLOAT(0.926782068963373),    //91
    UBP0_FROM_FLOAT(0.926115558594194),    //92
    UBP0_FROM_FLOAT(0.925451438010392),    //93
    UBP0_FROM_FLOAT(0.924789691832558),    //94
    UBP0_FROM_FLOAT(0.924130304823837),    //95
    UBP0_FROM_FLOAT(0.923473261888205),    //96
    UBP0_FROM_FLOAT(0.922818548068774),    //97
    UBP0_FROM_FLOAT(0.922166148546114),    //98
    UBP0_FROM_FLOAT(0.921516048636615),    //99
    UBP0_FROM_FLOAT(0.920868233790855),    //100
    UBP0_FROM_FLOAT(0.920222689592004),    //101
    UBP0_FROM_FLOAT(0.91957940175425),    //102
    UBP0_FROM_FLOAT(0.918938356121245),    //103
    UBP0_FROM_FLOAT(0.918299538664573),    //104
    UBP0_FROM_FLOAT(0.917662935482247),    //105
    UBP0_FROM_FLOAT(0.917028532797218),    //106
    UBP0_FROM_FLOAT(0.916396316955915),    //107
    UBP0_FROM_FLOAT(0.915766274426796),    //108
    UBP0_FROM_FLOAT(0.915138391798935),    //109
    UBP0_FROM_FLOAT(0.914512655780611),    //110
    UBP0_FROM_FLOAT(0.91388905319793),    //111
    UBP0_FROM_FLOAT(0.913267570993463),    //112
    UBP0_FROM_FLOAT(0.912648196224901),    //113
    UBP0_FROM_FLOAT(0.912030916063736),    //114
    UBP0_FROM_FLOAT(0.911415717793952),    //115
    UBP0_FROM_FLOAT(0.910802588810737),    //116
    UBP0_FROM_FLOAT(0.91019151661922),    //117
    UBP0_FROM_FLOAT(0.909582488833218),    //118
    UBP0_FROM_FLOAT(0.908975493174),    //119
    UBP0_FROM_FLOAT(0.908370517469075),    //120
    UBP0_FROM_FLOAT(0.907767549650993),    //121
    UBP0_FROM_FLOAT(0.90716657775616),    //122
    UBP0_FROM_FLOAT(0.906567589923676),    //123
    UBP0_FROM_FLOAT(0.905970574394182),    //124
    UBP0_FROM_FLOAT(0.905375519508726),    //125
    UBP0_FROM_FLOAT(0.90478241370765),    //126
    UBP0_FROM_FLOAT(0.904191245529481),    //127
    UBP0_FROM_FLOAT(0.903602003609845),    //128
    UBP0_FROM_FLOAT(0.903014676680396),    //129
    UBP0_FROM_FLOAT(0.902429253567758),    //130
    UBP0_FROM_FLOAT(0.901845723192475),    //131
    UBP0_FROM_FLOAT(0.90126407456799),    //132
    UBP0_FROM_FLOAT(0.900684296799622),    //133
    UBP0_FROM_FLOAT(0.900106379083569),    //134
    UBP0_FROM_FLOAT(0.899530310705914),    //135
    UBP0_FROM_FLOAT(0.898956081041654),    //136
    UBP0_FROM_FLOAT(0.898383679553736),    //137
    UBP0_FROM_FLOAT(0.897813095792106),    //138
    UBP0_FROM_FLOAT(0.897244319392775),    //139
    UBP0_FROM_FLOAT(0.896677340076892),    //140
    UBP0_FROM_FLOAT(0.896112147649831),    //141
    UBP0_FROM_FLOAT(0.895548732000295),    //142
    UBP0_FROM_FLOAT(0.894987083099423),    //143
    UBP0_FROM_FLOAT(0.894427190999916),    //144
    UBP0_FROM_FLOAT(0.893869045835169),    //145
    UBP0_FROM_FLOAT(0.893312637818422),    //146
    UBP0_FROM_FLOAT(0.89275795724191),    //147
    UBP0_FROM_FLOAT(0.89220499447604),    //148
    UBP0_FROM_FLOAT(0.891653739968563),    //149
    UBP0_FROM_FLOAT(0.891104184243764),    //150
    UBP0_FROM_FLOAT(0.890556317901667),    //151
    UBP0_FROM_FLOAT(0.890010131617242),    //152
    UBP0_FROM_FLOAT(0.889465616139622),    //153
    UBP0_FROM_FLOAT(0.888922762291343),    //154
    UBP0_FROM_FLOAT(0.888381560967574),    //155
    UBP0_FROM_FLOAT(0.887842003135375),    //156
    UBP0_FROM_FLOAT(0.887304079832949),    //157
    UBP0_FROM_FLOAT(0.88676778216892),    //158
    UBP0_FROM_FLOAT(0.886233101321602),    //159
    UBP0_FROM_FLOAT(0.885700028538295),    //160
    UBP0_FROM_FLOAT(0.885168555134573),    //161
    UBP0_FROM_FLOAT(0.884638672493595),    //162
    UBP0_FROM_FLOAT(0.884110372065417),    //163
    UBP0_FROM_FLOAT(0.883583645366315),    //164
    UBP0_FROM_FLOAT(0.883058483978115),    //165
    UBP0_FROM_FLOAT(0.882534879547532),    //166
    UBP0_FROM_FLOAT(0.882012823785518),    //167
    UBP0_FROM_FLOAT(0.88149230846662),    //168
    UBP0_FROM_FLOAT(0.880973325428339),    //169
    UBP0_FROM_FLOAT(0.880455866570503),    //170
    UBP0_FROM_FLOAT(0.879939923854648),    //171
    UBP0_FROM_FLOAT(0.879425489303404),    //172
    UBP0_FROM_FLOAT(0.878912554999886),    //173
    UBP0_FROM_FLOAT(0.878401113087102),    //174
    UBP0_FROM_FLOAT(0.877891155767354),    //175
    UBP0_FROM_FLOAT(0.877382675301662),    //176
    UBP0_FROM_FLOAT(0.87687566400918),    //177
    UBP0_FROM_FLOAT(0.876370114266633),    //178
    UBP0_FROM_FLOAT(0.875866018507748),    //179
    UBP0_FROM_FLOAT(0.875363369222702),    //180
    UBP0_FROM_FLOAT(0.874862158957572),    //181
    UBP0_FROM_FLOAT(0.874362380313789),    //182
    UBP0_FROM_FLOAT(0.873864025947605),    //183
    UBP0_FROM_FLOAT(0.873367088569562),    //184
    UBP0_FROM_FLOAT(0.87287156094397),    //185
    UBP0_FROM_FLOAT(0.872377435888383),    //186
    UBP0_FROM_FLOAT(0.871884706273099),    //187
    UBP0_FROM_FLOAT(0.871393365020643),    //188
    UBP0_FROM_FLOAT(0.870903405105276),    //189
    UBP0_FROM_FLOAT(0.870414819552497),    //190
    UBP0_FROM_FLOAT(0.869927601438559),    //191
    UBP0_FROM_FLOAT(0.869441743889983),    //192
    UBP0_FROM_FLOAT(0.868957240083086),    //193
    UBP0_FROM_FLOAT(0.868474083243507),    //194
    UBP0_FROM_FLOAT(0.867992266645745),    //195
    UBP0_FROM_FLOAT(0.867511783612694),    //196
    UBP0_FROM_FLOAT(0.867032627515195),    //197
    UBP0_FROM_FLOAT(0.866554791771583),    //198
    UBP0_FROM_FLOAT(0.866078269847242),    //199
    UBP0_FROM_FLOAT(0.865603055254171),    //200
    UBP0_FROM_FLOAT(0.865129141550544),    //201
    UBP0_FROM_FLOAT(0.864656522340285),    //202
    UBP0_FROM_FLOAT(0.864185191272645),    //203
    UBP0_FROM_FLOAT(0.863715142041779),    //204
    UBP0_FROM_FLOAT(0.863246368386335),    //205
    UBP0_FROM_FLOAT(0.862778864089041),    //206
    UBP0_FROM_FLOAT(0.862312622976306),    //207
    UBP0_FROM_FLOAT(0.861847638917812),    //208
    UBP0_FROM_FLOAT(0.861383905826124),    //209
    UBP0_FROM_FLOAT(0.860921417656296),    //210
    UBP0_FROM_FLOAT(0.860460168405485),    //211
    UBP0_FROM_FLOAT(0.860000152112567),    //212
    UBP0_FROM_FLOAT(0.85954136285776),    //213
    UBP0_FROM_FLOAT(0.85908379476225),    //214
    UBP0_FROM_FLOAT(0.858627441987819),    //215
    UBP0_FROM_FLOAT(0.858172298736482),    //216
    UBP0_FROM_FLOAT(0.857718359250124),    //217
    UBP0_FROM_FLOAT(0.85726561781014),    //218
    UBP0_FROM_FLOAT(0.856814068737085),    //219
    UBP0_FROM_FLOAT(0.856363706390322),    //220
    UBP0_FROM_FLOAT(0.855914525167676),    //221
    UBP0_FROM_FLOAT(0.855466519505093),    //222
    UBP0_FROM_FLOAT(0.855019683876299),    //223
    UBP0_FROM_FLOAT(0.854574012792468),    //224
    UBP0_FROM_FLOAT(0.85412950080189),    //225
    UBP0_FROM_FLOAT(0.853686142489641),    //226
    UBP0_FROM_FLOAT(0.853243932477263),    //227
    UBP0_FROM_FLOAT(0.852802865422442),    //228
    UBP0_FROM_FLOAT(0.852362936018689),    //229
    UBP0_FROM_FLOAT(0.85192413899503),    //230
    UBP0_FROM_FLOAT(0.851486469115693),    //231
    UBP0_FROM_FLOAT(0.851049921179803),    //232
    UBP0_FROM_FLOAT(0.850614490021076),    //233
    UBP0_FROM_FLOAT(0.850180170507523),    //234
    UBP0_FROM_FLOAT(0.849746957541149),    //235
    UBP0_FROM_FLOAT(0.84931484605766),    //236
    UBP0_FROM_FLOAT(0.848883831026173),    //237
    UBP0_FROM_FLOAT(0.848453907448929),    //238
    UBP0_FROM_FLOAT(0.848025070361007),    //239
    UBP0_FROM_FLOAT(0.847597314830043),    //240
    UBP0_FROM_FLOAT(0.847170635955951),    //241
    UBP0_FROM_FLOAT(0.846745028870647),    //242
    UBP0_FROM_FLOAT(0.846320488737779),    //243
    UBP0_FROM_FLOAT(0.845897010752451),    //244
    UBP0_FROM_FLOAT(0.845474590140965),    //245
    UBP0_FROM_FLOAT(0.845053222160547),    //246
    UBP0_FROM_FLOAT(0.844632902099093),    //247
    UBP0_FROM_FLOAT(0.844213625274905),    //248
    UBP0_FROM_FLOAT(0.84379538703644),    //249
    UBP0_FROM_FLOAT(0.843378182762051),    //250
    UBP0_FROM_FLOAT(0.84296200785974),    //251
    UBP0_FROM_FLOAT(0.842546857766908),    //252
    UBP0_FROM_FLOAT(0.842132727950112),    //253
    UBP0_FROM_FLOAT(0.841719613904818),    //254
    UBP0_FROM_FLOAT(0.841307511155163),    //255
    UBP0_FROM_FLOAT(0.840896415253715),    //256
};

// 2^((18+16-idx)/4.0)
// ARM uses 18.  Our fractional bits require 18+16 == 34.  
// Anyone who works out the formula should write it down.
// The values in this table is cut and pasted from WmaudioConcepts.xls!InvQuadRoot2.  
// Chnages to any of the LPc fractional bits should require a change in this table.

const UInt g_InvQuadRootExponent[BITS_LP_SPEC_POWER+1] = {
    WEIGHT_FROM_FLOAT(0.00276213586400995),    //0
    WEIGHT_FROM_FLOAT(0.00328475162208482),    //1
    WEIGHT_FROM_FLOAT(0.00390625),    //2
    WEIGHT_FROM_FLOAT(0.00464534029297938),    //3
    WEIGHT_FROM_FLOAT(0.0055242717280199),    //4
    WEIGHT_FROM_FLOAT(0.00656950324416965),    //5
    WEIGHT_FROM_FLOAT(0.0078125),    //6
    WEIGHT_FROM_FLOAT(0.00929068058595876),    //7
    WEIGHT_FROM_FLOAT(0.0110485434560398),    //8
    WEIGHT_FROM_FLOAT(0.0131390064883393),    //9
    WEIGHT_FROM_FLOAT(0.015625),    //10
    WEIGHT_FROM_FLOAT(0.0185813611719175),    //11
    WEIGHT_FROM_FLOAT(0.0220970869120796),    //12
    WEIGHT_FROM_FLOAT(0.0262780129766786),    //13
    WEIGHT_FROM_FLOAT(0.03125),    //14
    WEIGHT_FROM_FLOAT(0.037162722343835),    //15
    WEIGHT_FROM_FLOAT(0.0441941738241592),    //16
    WEIGHT_FROM_FLOAT(0.0525560259533572),    //17
    WEIGHT_FROM_FLOAT(0.0625),    //18
    WEIGHT_FROM_FLOAT(0.0743254446876701),    //19
    WEIGHT_FROM_FLOAT(0.0883883476483184),    //20
    WEIGHT_FROM_FLOAT(0.105112051906714),    //21
    WEIGHT_FROM_FLOAT(0.125),    //22
    WEIGHT_FROM_FLOAT(0.14865088937534),    //23
    WEIGHT_FROM_FLOAT(0.176776695296637),    //24
    WEIGHT_FROM_FLOAT(0.210224103813429),    //25
    WEIGHT_FROM_FLOAT(0.25),    //26
    WEIGHT_FROM_FLOAT(0.29730177875068),    //27
    WEIGHT_FROM_FLOAT(0.353553390593274),    //28
    WEIGHT_FROM_FLOAT(0.420448207626857),    //29
    WEIGHT_FROM_FLOAT(0.5),    //30
    WEIGHT_FROM_FLOAT(0.594603557501361),    //31
    WEIGHT_FROM_FLOAT(0.707106781186547)     //32

#if BITS_LP_SPEC_POWER>32
    ,
    WEIGHT_FROM_FLOAT(0.840896415253715),    //33
    WEIGHT_FROM_FLOAT(1),    //34
    WEIGHT_FROM_FLOAT(1.18920711500272),    //35
    WEIGHT_FROM_FLOAT(1.4142135623731),    //36
    WEIGHT_FROM_FLOAT(1.68179283050743),    //37
    WEIGHT_FROM_FLOAT(2),    //38
    WEIGHT_FROM_FLOAT(2.37841423000544),    //39
    WEIGHT_FROM_FLOAT(2.82842712474619),    //40
    WEIGHT_FROM_FLOAT(3.36358566101486),    //41
    WEIGHT_FROM_FLOAT(4),    //42
    WEIGHT_FROM_FLOAT(4.75682846001088),    //43
    WEIGHT_FROM_FLOAT(5.65685424949238),    //44
    WEIGHT_FROM_FLOAT(6.72717132202972),    //45
    WEIGHT_FROM_FLOAT(8.0),    //46
    WEIGHT_FROM_FLOAT(9.51365692002177),    //47
    WEIGHT_FROM_FLOAT(11.3137084989848),    //48
    WEIGHT_FROM_FLOAT(13.4543426440594),    //49
    WEIGHT_FROM_FLOAT(16.0),    //50
    WEIGHT_FROM_FLOAT(19.0273138400435),    //51
    WEIGHT_FROM_FLOAT(22.6274169979695),    //52
    WEIGHT_FROM_FLOAT(26.9086852881189),    //53
    WEIGHT_FROM_FLOAT(32.0),    //54
    WEIGHT_FROM_FLOAT(38.0546276800871),    //55
    WEIGHT_FROM_FLOAT(45.254833995939),    //56
    WEIGHT_FROM_FLOAT(53.8173705762377),    //57
    WEIGHT_FROM_FLOAT(64.0),    //58
    WEIGHT_FROM_FLOAT(76.1092553601742),    //59
    WEIGHT_FROM_FLOAT(90.5096679918781),    //60
    WEIGHT_FROM_FLOAT(107.634741152475),    //61
    WEIGHT_FROM_FLOAT(128.0),    //62
    WEIGHT_FROM_FLOAT(152.218510720348),    //63
    WEIGHT_FROM_FLOAT(181.019335983756)    //64
#endif  //BITS_LP_SPEC_POWER>32
};  


const UInt g_InverseFraction[1+INVERSE_FRACTION_TABLE_SIZE] = {
    UBP0_FROM_FLOAT(1),    //0
    UBP0_FROM_FLOAT(0.996108949416342),    //1
    UBP0_FROM_FLOAT(0.992248062015504),    //2
    UBP0_FROM_FLOAT(0.988416988416988),    //3
    UBP0_FROM_FLOAT(0.984615384615385),    //4
    UBP0_FROM_FLOAT(0.980842911877395),    //5
    UBP0_FROM_FLOAT(0.977099236641221),    //6
    UBP0_FROM_FLOAT(0.973384030418251),    //7
    UBP0_FROM_FLOAT(0.96969696969697),    //8
    UBP0_FROM_FLOAT(0.966037735849057),    //9
    UBP0_FROM_FLOAT(0.962406015037594),    //10
    UBP0_FROM_FLOAT(0.958801498127341),    //11
    UBP0_FROM_FLOAT(0.955223880597015),    //12
    UBP0_FROM_FLOAT(0.951672862453532),    //13
    UBP0_FROM_FLOAT(0.948148148148148),    //14
    UBP0_FROM_FLOAT(0.944649446494465),    //15
    UBP0_FROM_FLOAT(0.941176470588235),    //16
    UBP0_FROM_FLOAT(0.937728937728938),    //17
    UBP0_FROM_FLOAT(0.934306569343066),    //18
    UBP0_FROM_FLOAT(0.930909090909091),    //19
    UBP0_FROM_FLOAT(0.927536231884058),    //20
    UBP0_FROM_FLOAT(0.924187725631769),    //21
    UBP0_FROM_FLOAT(0.920863309352518),    //22
    UBP0_FROM_FLOAT(0.917562724014337),    //23
    UBP0_FROM_FLOAT(0.914285714285714),    //24
    UBP0_FROM_FLOAT(0.911032028469751),    //25
    UBP0_FROM_FLOAT(0.907801418439716),    //26
    UBP0_FROM_FLOAT(0.904593639575972),    //27
    UBP0_FROM_FLOAT(0.901408450704225),    //28
    UBP0_FROM_FLOAT(0.898245614035088),    //29
    UBP0_FROM_FLOAT(0.895104895104895),    //30
    UBP0_FROM_FLOAT(0.89198606271777),    //31
    UBP0_FROM_FLOAT(0.888888888888889),    //32
    UBP0_FROM_FLOAT(0.885813148788927),    //33
    UBP0_FROM_FLOAT(0.882758620689655),    //34
    UBP0_FROM_FLOAT(0.879725085910653),    //35
    UBP0_FROM_FLOAT(0.876712328767123),    //36
    UBP0_FROM_FLOAT(0.873720136518771),    //37
    UBP0_FROM_FLOAT(0.870748299319728),    //38
    UBP0_FROM_FLOAT(0.867796610169492),    //39
    UBP0_FROM_FLOAT(0.864864864864865),    //40
    UBP0_FROM_FLOAT(0.861952861952862),    //41
    UBP0_FROM_FLOAT(0.859060402684564),    //42
    UBP0_FROM_FLOAT(0.8561872909699),    //43
    UBP0_FROM_FLOAT(0.853333333333333),    //44
    UBP0_FROM_FLOAT(0.850498338870432),    //45
    UBP0_FROM_FLOAT(0.847682119205298),    //46
    UBP0_FROM_FLOAT(0.844884488448845),    //47
    UBP0_FROM_FLOAT(0.842105263157895),    //48
    UBP0_FROM_FLOAT(0.839344262295082),    //49
    UBP0_FROM_FLOAT(0.836601307189543),    //50
    UBP0_FROM_FLOAT(0.833876221498371),    //51
    UBP0_FROM_FLOAT(0.831168831168831),    //52
    UBP0_FROM_FLOAT(0.828478964401295),    //53
    UBP0_FROM_FLOAT(0.825806451612903),    //54
    UBP0_FROM_FLOAT(0.823151125401929),    //55
    UBP0_FROM_FLOAT(0.82051282051282),    //56
    UBP0_FROM_FLOAT(0.817891373801917),    //57
    UBP0_FROM_FLOAT(0.815286624203822),    //58
    UBP0_FROM_FLOAT(0.812698412698413),    //59
    UBP0_FROM_FLOAT(0.810126582278481),    //60
    UBP0_FROM_FLOAT(0.807570977917981),    //61
    UBP0_FROM_FLOAT(0.805031446540881),    //62
    UBP0_FROM_FLOAT(0.802507836990596),    //63
    UBP0_FROM_FLOAT(0.8),    //64
    UBP0_FROM_FLOAT(0.797507788161994),    //65
    UBP0_FROM_FLOAT(0.795031055900621),    //66
    UBP0_FROM_FLOAT(0.792569659442725),    //67
    UBP0_FROM_FLOAT(0.790123456790123),    //68
    UBP0_FROM_FLOAT(0.787692307692308),    //69
    UBP0_FROM_FLOAT(0.785276073619632),    //70
    UBP0_FROM_FLOAT(0.782874617737003),    //71
    UBP0_FROM_FLOAT(0.780487804878049),    //72
    UBP0_FROM_FLOAT(0.778115501519757),    //73
    UBP0_FROM_FLOAT(0.775757575757576),    //74
    UBP0_FROM_FLOAT(0.773413897280967),    //75
    UBP0_FROM_FLOAT(0.771084337349398),    //76
    UBP0_FROM_FLOAT(0.768768768768769),    //77
    UBP0_FROM_FLOAT(0.766467065868264),    //78
    UBP0_FROM_FLOAT(0.764179104477612),    //79
    UBP0_FROM_FLOAT(0.761904761904762),    //80
    UBP0_FROM_FLOAT(0.759643916913947),    //81
    UBP0_FROM_FLOAT(0.757396449704142),    //82
    UBP0_FROM_FLOAT(0.755162241887906),    //83
    UBP0_FROM_FLOAT(0.752941176470588),    //84
    UBP0_FROM_FLOAT(0.750733137829912),    //85
    UBP0_FROM_FLOAT(0.748538011695906),    //86
    UBP0_FROM_FLOAT(0.746355685131195),    //87
    UBP0_FROM_FLOAT(0.744186046511628),    //88
    UBP0_FROM_FLOAT(0.742028985507246),    //89
    UBP0_FROM_FLOAT(0.739884393063584),    //90
    UBP0_FROM_FLOAT(0.737752161383285),    //91
    UBP0_FROM_FLOAT(0.735632183908046),    //92
    UBP0_FROM_FLOAT(0.73352435530086),    //93
    UBP0_FROM_FLOAT(0.731428571428571),    //94
    UBP0_FROM_FLOAT(0.729344729344729),    //95
    UBP0_FROM_FLOAT(0.727272727272727),    //96
    UBP0_FROM_FLOAT(0.725212464589235),    //97
    UBP0_FROM_FLOAT(0.72316384180791),    //98
    UBP0_FROM_FLOAT(0.72112676056338),    //99
    UBP0_FROM_FLOAT(0.719101123595506),    //100
    UBP0_FROM_FLOAT(0.717086834733894),    //101
    UBP0_FROM_FLOAT(0.715083798882682),    //102
    UBP0_FROM_FLOAT(0.713091922005571),    //103
    UBP0_FROM_FLOAT(0.711111111111111),    //104
    UBP0_FROM_FLOAT(0.709141274238227),    //105
    UBP0_FROM_FLOAT(0.707182320441989),    //106
    UBP0_FROM_FLOAT(0.705234159779614),    //107
    UBP0_FROM_FLOAT(0.703296703296703),    //108
    UBP0_FROM_FLOAT(0.701369863013699),    //109
    UBP0_FROM_FLOAT(0.699453551912568),    //110
    UBP0_FROM_FLOAT(0.697547683923706),    //111
    UBP0_FROM_FLOAT(0.695652173913043),    //112
    UBP0_FROM_FLOAT(0.693766937669377),    //113
    UBP0_FROM_FLOAT(0.691891891891892),    //114
    UBP0_FROM_FLOAT(0.690026954177898),    //115
    UBP0_FROM_FLOAT(0.688172043010753),    //116
    UBP0_FROM_FLOAT(0.686327077747989),    //117
    UBP0_FROM_FLOAT(0.684491978609626),    //118
    UBP0_FROM_FLOAT(0.682666666666667),    //119
    UBP0_FROM_FLOAT(0.680851063829787),    //120
    UBP0_FROM_FLOAT(0.679045092838196),    //121
    UBP0_FROM_FLOAT(0.677248677248677),    //122
    UBP0_FROM_FLOAT(0.675461741424802),    //123
    UBP0_FROM_FLOAT(0.673684210526316),    //124
    UBP0_FROM_FLOAT(0.671916010498688),    //125
    UBP0_FROM_FLOAT(0.670157068062827),    //126
    UBP0_FROM_FLOAT(0.668407310704961),    //127
    UBP0_FROM_FLOAT(0.666666666666667),    //128
    UBP0_FROM_FLOAT(0.664935064935065),    //129
    UBP0_FROM_FLOAT(0.663212435233161),    //130
    UBP0_FROM_FLOAT(0.661498708010336),    //131
    UBP0_FROM_FLOAT(0.65979381443299),    //132
    UBP0_FROM_FLOAT(0.658097686375321),    //133
    UBP0_FROM_FLOAT(0.656410256410256),    //134
    UBP0_FROM_FLOAT(0.654731457800512),    //135
    UBP0_FROM_FLOAT(0.653061224489796),    //136
    UBP0_FROM_FLOAT(0.651399491094148),    //137
    UBP0_FROM_FLOAT(0.649746192893401),    //138
    UBP0_FROM_FLOAT(0.648101265822785),    //139
    UBP0_FROM_FLOAT(0.646464646464647),    //140
    UBP0_FROM_FLOAT(0.644836272040302),    //141
    UBP0_FROM_FLOAT(0.64321608040201),    //142
    UBP0_FROM_FLOAT(0.641604010025063),    //143
    UBP0_FROM_FLOAT(0.64),    //144
    UBP0_FROM_FLOAT(0.638403990024938),    //145
    UBP0_FROM_FLOAT(0.63681592039801),    //146
    UBP0_FROM_FLOAT(0.635235732009926),    //147
    UBP0_FROM_FLOAT(0.633663366336634),    //148
    UBP0_FROM_FLOAT(0.632098765432099),    //149
    UBP0_FROM_FLOAT(0.630541871921182),    //150
    UBP0_FROM_FLOAT(0.628992628992629),    //151
    UBP0_FROM_FLOAT(0.627450980392157),    //152
    UBP0_FROM_FLOAT(0.625916870415648),    //153
    UBP0_FROM_FLOAT(0.624390243902439),    //154
    UBP0_FROM_FLOAT(0.62287104622871),    //155
    UBP0_FROM_FLOAT(0.621359223300971),    //156
    UBP0_FROM_FLOAT(0.619854721549637),    //157
    UBP0_FROM_FLOAT(0.618357487922705),    //158
    UBP0_FROM_FLOAT(0.616867469879518),    //159
    UBP0_FROM_FLOAT(0.615384615384615),    //160
    UBP0_FROM_FLOAT(0.613908872901679),    //161
    UBP0_FROM_FLOAT(0.61244019138756),    //162
    UBP0_FROM_FLOAT(0.610978520286396),    //163
    UBP0_FROM_FLOAT(0.60952380952381),    //164
    UBP0_FROM_FLOAT(0.608076009501188),    //165
    UBP0_FROM_FLOAT(0.606635071090047),    //166
    UBP0_FROM_FLOAT(0.605200945626478),    //167
    UBP0_FROM_FLOAT(0.60377358490566),    //168
    UBP0_FROM_FLOAT(0.602352941176471),    //169
    UBP0_FROM_FLOAT(0.60093896713615),    //170
    UBP0_FROM_FLOAT(0.599531615925059),    //171
    UBP0_FROM_FLOAT(0.598130841121495),    //172
    UBP0_FROM_FLOAT(0.596736596736597),    //173
    UBP0_FROM_FLOAT(0.595348837209302),    //174
    UBP0_FROM_FLOAT(0.593967517401392),    //175
    UBP0_FROM_FLOAT(0.592592592592593),    //176
    UBP0_FROM_FLOAT(0.591224018475751),    //177
    UBP0_FROM_FLOAT(0.589861751152074),    //178
    UBP0_FROM_FLOAT(0.588505747126437),    //179
    UBP0_FROM_FLOAT(0.587155963302752),    //180
    UBP0_FROM_FLOAT(0.585812356979405),    //181
    UBP0_FROM_FLOAT(0.584474885844749),    //182
    UBP0_FROM_FLOAT(0.583143507972665),    //183
    UBP0_FROM_FLOAT(0.581818181818182),    //184
    UBP0_FROM_FLOAT(0.580498866213152),    //185
    UBP0_FROM_FLOAT(0.579185520361991),    //186
    UBP0_FROM_FLOAT(0.577878103837472),    //187
    UBP0_FROM_FLOAT(0.576576576576577),    //188
    UBP0_FROM_FLOAT(0.575280898876405),    //189
    UBP0_FROM_FLOAT(0.573991031390135),    //190
    UBP0_FROM_FLOAT(0.572706935123042),    //191
    UBP0_FROM_FLOAT(0.571428571428571),    //192
    UBP0_FROM_FLOAT(0.570155902004454),    //193
    UBP0_FROM_FLOAT(0.568888888888889),    //194
    UBP0_FROM_FLOAT(0.567627494456763),    //195
    UBP0_FROM_FLOAT(0.566371681415929),    //196
    UBP0_FROM_FLOAT(0.565121412803532),    //197
    UBP0_FROM_FLOAT(0.563876651982379),    //198
    UBP0_FROM_FLOAT(0.562637362637363),    //199
    UBP0_FROM_FLOAT(0.56140350877193),    //200
    UBP0_FROM_FLOAT(0.560175054704595),    //201
    UBP0_FROM_FLOAT(0.558951965065502),    //202
    UBP0_FROM_FLOAT(0.557734204793028),    //203
    UBP0_FROM_FLOAT(0.556521739130435),    //204
    UBP0_FROM_FLOAT(0.55531453362256),    //205
    UBP0_FROM_FLOAT(0.554112554112554),    //206
    UBP0_FROM_FLOAT(0.552915766738661),    //207
    UBP0_FROM_FLOAT(0.551724137931034),    //208
    UBP0_FROM_FLOAT(0.550537634408602),    //209
    UBP0_FROM_FLOAT(0.549356223175966),    //210
    UBP0_FROM_FLOAT(0.548179871520343),    //211
    UBP0_FROM_FLOAT(0.547008547008547),    //212
    UBP0_FROM_FLOAT(0.545842217484009),    //213
    UBP0_FROM_FLOAT(0.54468085106383),    //214
    UBP0_FROM_FLOAT(0.543524416135881),    //215
    UBP0_FROM_FLOAT(0.542372881355932),    //216
    UBP0_FROM_FLOAT(0.54122621564482),    //217
    UBP0_FROM_FLOAT(0.540084388185654),    //218
    UBP0_FROM_FLOAT(0.538947368421053),    //219
    UBP0_FROM_FLOAT(0.53781512605042),    //220
    UBP0_FROM_FLOAT(0.536687631027254),    //221
    UBP0_FROM_FLOAT(0.535564853556485),    //222
    UBP0_FROM_FLOAT(0.534446764091858),    //223
    UBP0_FROM_FLOAT(0.533333333333333),    //224
    UBP0_FROM_FLOAT(0.532224532224532),    //225
    UBP0_FROM_FLOAT(0.531120331950207),    //226
    UBP0_FROM_FLOAT(0.530020703933747),    //227
    UBP0_FROM_FLOAT(0.528925619834711),    //228
    UBP0_FROM_FLOAT(0.527835051546392),    //229
    UBP0_FROM_FLOAT(0.526748971193416),    //230
    UBP0_FROM_FLOAT(0.525667351129363),    //231
    UBP0_FROM_FLOAT(0.524590163934426),    //232
    UBP0_FROM_FLOAT(0.523517382413088),    //233
    UBP0_FROM_FLOAT(0.522448979591837),    //234
    UBP0_FROM_FLOAT(0.521384928716904),    //235
    UBP0_FROM_FLOAT(0.520325203252033),    //236
    UBP0_FROM_FLOAT(0.519269776876268),    //237
    UBP0_FROM_FLOAT(0.518218623481781),    //238
    UBP0_FROM_FLOAT(0.517171717171717),    //239
    UBP0_FROM_FLOAT(0.516129032258065),    //240
    UBP0_FROM_FLOAT(0.515090543259557),    //241
    UBP0_FROM_FLOAT(0.514056224899598),    //242
    UBP0_FROM_FLOAT(0.513026052104208),    //243
    UBP0_FROM_FLOAT(0.512),    //244
    UBP0_FROM_FLOAT(0.510978043912176),    //245
    UBP0_FROM_FLOAT(0.50996015936255),    //246
    UBP0_FROM_FLOAT(0.508946322067594),    //247
    UBP0_FROM_FLOAT(0.507936507936508),    //248
    UBP0_FROM_FLOAT(0.506930693069307),    //249
    UBP0_FROM_FLOAT(0.505928853754941),    //250
    UBP0_FROM_FLOAT(0.504930966469428),    //251
    UBP0_FROM_FLOAT(0.503937007874016),    //252
    UBP0_FROM_FLOAT(0.502946954813359),    //253
    UBP0_FROM_FLOAT(0.501960784313725),    //254
    UBP0_FROM_FLOAT(0.500978473581213),    //255
    UBP0_FROM_FLOAT(0.5)     //256
};


const UInt g_SqrtFraction[1+SQRT_FRACTION_TABLE_SIZE] = {
    BP2_FROM_FLOAT(1),    //0
    BP2_FROM_FLOAT(1.00195122136759),    //1
    BP2_FROM_FLOAT(1.00389865026306),    //2
    BP2_FROM_FLOAT(1.00584230871444),    //3
    BP2_FROM_FLOAT(1.00778221853732),    //4
    BP2_FROM_FLOAT(1.00971840133772),    //5
    BP2_FROM_FLOAT(1.01165087851492),    //6
    BP2_FROM_FLOAT(1.01357967126418),    //7
    BP2_FROM_FLOAT(1.0155048005795),    //8
    BP2_FROM_FLOAT(1.01742628725623),    //9
    BP2_FROM_FLOAT(1.01934415189376),    //10
    BP2_FROM_FLOAT(1.02125841489801),    //11
    BP2_FROM_FLOAT(1.02316909648406),    //12
    BP2_FROM_FLOAT(1.02507621667855),    //13
    BP2_FROM_FLOAT(1.02697979532219),    //14
    BP2_FROM_FLOAT(1.02887985207215),    //15
    BP2_FROM_FLOAT(1.03077640640442),    //16
    BP2_FROM_FLOAT(1.03266947761614),    //17
    BP2_FROM_FLOAT(1.03455908482793),    //18
    BP2_FROM_FLOAT(1.03644524698606),    //19
    BP2_FROM_FLOAT(1.03832798286476),    //20
    BP2_FROM_FLOAT(1.04020731106833),    //21
    BP2_FROM_FLOAT(1.04208325003332),    //22
    BP2_FROM_FLOAT(1.04395581803063),    //23
    BP2_FROM_FLOAT(1.04582503316759),    //24
    BP2_FROM_FLOAT(1.04769091339001),    //25
    BP2_FROM_FLOAT(1.04955347648417),    //26
    BP2_FROM_FLOAT(1.0514127400788),    //27
    BP2_FROM_FLOAT(1.05326872164704),    //28
    BP2_FROM_FLOAT(1.05512143850838),    //29
    BP2_FROM_FLOAT(1.05697090783049),    //30
    BP2_FROM_FLOAT(1.05881714663109),    //31
    BP2_FROM_FLOAT(1.06066017177982),    //32
    BP2_FROM_FLOAT(1.0625),    //33
    BP2_FROM_FLOAT(1.0643366478704),    //34
    BP2_FROM_FLOAT(1.066170131827),    //35
    BP2_FROM_FLOAT(1.06800046816469),    //36
    BP2_FROM_FLOAT(1.06982767303898),    //37
    BP2_FROM_FLOAT(1.07165176246764),    //38
    BP2_FROM_FLOAT(1.07347275233235),    //39
    BP2_FROM_FLOAT(1.07529065838033),    //40
    BP2_FROM_FLOAT(1.07710549622588),    //41
    BP2_FROM_FLOAT(1.078917281352),    //42
    BP2_FROM_FLOAT(1.08072602911191),    //43
    BP2_FROM_FLOAT(1.08253175473055),    //44
    BP2_FROM_FLOAT(1.08433447330609),    //45
    BP2_FROM_FLOAT(1.08613419981142),    //46
    BP2_FROM_FLOAT(1.08793094909558),    //47
    BP2_FROM_FLOAT(1.08972473588517),    //48
    BP2_FROM_FLOAT(1.09151557478581),    //49
    BP2_FROM_FLOAT(1.09330348028349),    //50
    BP2_FROM_FLOAT(1.09508846674595),    //51
    BP2_FROM_FLOAT(1.09687054842402),    //52
    BP2_FROM_FLOAT(1.09864973945293),    //53
    BP2_FROM_FLOAT(1.10042605385369),    //54
    BP2_FROM_FLOAT(1.10219950553427),    //55
    BP2_FROM_FLOAT(1.10397010829098),    //56
    BP2_FROM_FLOAT(1.10573787580963),    //57
    BP2_FROM_FLOAT(1.10750282166683),    //58
    BP2_FROM_FLOAT(1.10926495933118),    //59
    BP2_FROM_FLOAT(1.11102430216445),    //60
    BP2_FROM_FLOAT(1.1127808634228),    //61
    BP2_FROM_FLOAT(1.11453465625794),    //62
    BP2_FROM_FLOAT(1.11628569371823),    //63
    BP2_FROM_FLOAT(1.11803398874989),    //64
    BP2_FROM_FLOAT(1.11977955419806),    //65
    BP2_FROM_FLOAT(1.1215224028079),    //66
    BP2_FROM_FLOAT(1.12326254722571),    //67
    BP2_FROM_FLOAT(1.125),    //68
    BP2_FROM_FLOAT(1.1267347735825),    //69
    BP2_FROM_FLOAT(1.12846688032924),    //70
    BP2_FROM_FLOAT(1.13019633250157),    //71
    BP2_FROM_FLOAT(1.13192314226718),    //72
    BP2_FROM_FLOAT(1.13364732170107),    //73
    BP2_FROM_FLOAT(1.13536888278656),    //74
    BP2_FROM_FLOAT(1.13708783741627),    //75
    BP2_FROM_FLOAT(1.13880419739304),    //76
    BP2_FROM_FLOAT(1.14051797443092),    //77
    BP2_FROM_FLOAT(1.14222918015607),    //78
    BP2_FROM_FLOAT(1.1439378261077),    //79
    BP2_FROM_FLOAT(1.14564392373896),    //80
    BP2_FROM_FLOAT(1.14734748441786),    //81
    BP2_FROM_FLOAT(1.14904851942814),    //82
    BP2_FROM_FLOAT(1.15074703997012),    //83
    BP2_FROM_FLOAT(1.15244305716161),    //84
    BP2_FROM_FLOAT(1.15413658203871),    //85
    BP2_FROM_FLOAT(1.15582762555668),    //86
    BP2_FROM_FLOAT(1.15751619859076),    //87
    BP2_FROM_FLOAT(1.15920231193696),    //88
    BP2_FROM_FLOAT(1.16088597631292),    //89
    BP2_FROM_FLOAT(1.16256720235864),    //90
    BP2_FROM_FLOAT(1.16424600063732),    //91
    BP2_FROM_FLOAT(1.1659223816361),    //92
    BP2_FROM_FLOAT(1.16759635576684),    //93
    BP2_FROM_FLOAT(1.16926793336686),    //94
    BP2_FROM_FLOAT(1.1709371246997),    //95
    BP2_FROM_FLOAT(1.17260393995586),    //96
    BP2_FROM_FLOAT(1.1742683892535),    //97
    BP2_FROM_FLOAT(1.17593048263917),    //98
    BP2_FROM_FLOAT(1.17759023008855),    //99
    BP2_FROM_FLOAT(1.17924764150708),    //100
    BP2_FROM_FLOAT(1.1809027267307),    //101
    BP2_FROM_FLOAT(1.18255549552653),    //102
    BP2_FROM_FLOAT(1.18420595759353),    //103
    BP2_FROM_FLOAT(1.18585412256314),    //104
    BP2_FROM_FLOAT(1.1875),    //105
    BP2_FROM_FLOAT(1.18914359940253),    //106
    BP2_FROM_FLOAT(1.1907849302036),    //107
    BP2_FROM_FLOAT(1.19242400177118),    //108
    BP2_FROM_FLOAT(1.19406082340892),    //109
    BP2_FROM_FLOAT(1.19569540435681),    //110
    BP2_FROM_FLOAT(1.19732775379175),    //111
    BP2_FROM_FLOAT(1.19895788082818),    //112
    BP2_FROM_FLOAT(1.20058579451866),    //113
    BP2_FROM_FLOAT(1.20221150385446),    //114
    BP2_FROM_FLOAT(1.20383501776614),    //115
    BP2_FROM_FLOAT(1.20545634512412),    //116
    BP2_FROM_FLOAT(1.20707549473925),    //117
    BP2_FROM_FLOAT(1.20869247536336),    //118
    BP2_FROM_FLOAT(1.21030729568982),    //119
    BP2_FROM_FLOAT(1.21191996435408),    //120
    BP2_FROM_FLOAT(1.21353048993422),    //121
    BP2_FROM_FLOAT(1.21513888095147),    //122
    BP2_FROM_FLOAT(1.21674514587074),    //123
    BP2_FROM_FLOAT(1.21834929310112),    //124
    BP2_FROM_FLOAT(1.21995133099645),    //125
    BP2_FROM_FLOAT(1.22155126785575),    //126
    BP2_FROM_FLOAT(1.22314911192381),    //127
    BP2_FROM_FLOAT(1.22474487139159),    //128
    BP2_FROM_FLOAT(1.22633855439679),    //129
    BP2_FROM_FLOAT(1.22793016902428),    //130
    BP2_FROM_FLOAT(1.22951972330663),    //131
    BP2_FROM_FLOAT(1.23110722522451),    //132
    BP2_FROM_FLOAT(1.23269268270725),    //133
    BP2_FROM_FLOAT(1.23427610363322),    //134
    BP2_FROM_FLOAT(1.23585749583032),    //135
    BP2_FROM_FLOAT(1.23743686707646),    //136
    BP2_FROM_FLOAT(1.23901422509994),    //137
    BP2_FROM_FLOAT(1.24058957757995),    //138
    BP2_FROM_FLOAT(1.24216293214699),    //139
    BP2_FROM_FLOAT(1.24373429638327),    //140
    BP2_FROM_FLOAT(1.2453036778232),    //141
    BP2_FROM_FLOAT(1.24687108395375),    //142
    BP2_FROM_FLOAT(1.24843652221489),    //143
    BP2_FROM_FLOAT(1.25),    //144
    BP2_FROM_FLOAT(1.2515615246563),    //145
    BP2_FROM_FLOAT(1.25312110348521),    //146
    BP2_FROM_FLOAT(1.2546787437428),    //147
    BP2_FROM_FLOAT(1.25623445264011),    //148
    BP2_FROM_FLOAT(1.25778823734363),    //149
    BP2_FROM_FLOAT(1.25934010497562),    //150
    BP2_FROM_FLOAT(1.2608900626145),    //151
    BP2_FROM_FLOAT(1.26243811729526),    //152
    BP2_FROM_FLOAT(1.26398427600979),    //153
    BP2_FROM_FLOAT(1.26552854570729),    //154
    BP2_FROM_FLOAT(1.26707093329458),    //155
    BP2_FROM_FLOAT(1.26861144563653),    //156
    BP2_FROM_FLOAT(1.27015008955635),    //157
    BP2_FROM_FLOAT(1.27168687183599),    //158
    BP2_FROM_FLOAT(1.27322179921646),    //159
    BP2_FROM_FLOAT(1.2747548783982),    //160
    BP2_FROM_FLOAT(1.27628611604138),    //161
    BP2_FROM_FLOAT(1.2778155187663),    //162
    BP2_FROM_FLOAT(1.27934309315367),    //163
    BP2_FROM_FLOAT(1.28086884574495),    //164
    BP2_FROM_FLOAT(1.2823927830427),    //165
    BP2_FROM_FLOAT(1.28391491151088),    //166
    BP2_FROM_FLOAT(1.2854352375752),    //167
    BP2_FROM_FLOAT(1.28695376762338),    //168
    BP2_FROM_FLOAT(1.28847050800552),    //169
    BP2_FROM_FLOAT(1.28998546503439),    //170
    BP2_FROM_FLOAT(1.29149864498574),    //171
    BP2_FROM_FLOAT(1.29301005409858),    //172
    BP2_FROM_FLOAT(1.2945196985755),    //173
    BP2_FROM_FLOAT(1.29602758458298),    //174
    BP2_FROM_FLOAT(1.29753371825167),    //175
    BP2_FROM_FLOAT(1.29903810567666),    //176
    BP2_FROM_FLOAT(1.3005407529178),    //177
    BP2_FROM_FLOAT(1.30204166599998),    //178
    BP2_FROM_FLOAT(1.30354085091339),    //179
    BP2_FROM_FLOAT(1.30503831361382),    //180
    BP2_FROM_FLOAT(1.30653406002293),    //181
    BP2_FROM_FLOAT(1.30802809602852),    //182
    BP2_FROM_FLOAT(1.30952042748481),    //183
    BP2_FROM_FLOAT(1.31101106021269),    //184
    BP2_FROM_FLOAT(1.3125),    //185
    BP2_FROM_FLOAT(1.31398725260179),    //186
    BP2_FROM_FLOAT(1.31547282374057),    //187
    BP2_FROM_FLOAT(1.31695671910659),    //188
    BP2_FROM_FLOAT(1.31843894435806),    //189
    BP2_FROM_FLOAT(1.31991950512143),    //190
    BP2_FROM_FLOAT(1.32139840699162),    //191
    BP2_FROM_FLOAT(1.3228756555323),    //192
    BP2_FROM_FLOAT(1.32435125627607),    //193
    BP2_FROM_FLOAT(1.32582521472478),    //194
    BP2_FROM_FLOAT(1.32729753634971),    //195
    BP2_FROM_FLOAT(1.32876822659183),    //196
    BP2_FROM_FLOAT(1.33023729086205),    //197
    BP2_FROM_FLOAT(1.33170473454141),    //198
    BP2_FROM_FLOAT(1.33317056298135),    //199
    BP2_FROM_FLOAT(1.33463478150391),    //200
    BP2_FROM_FLOAT(1.336097395402),    //201
    BP2_FROM_FLOAT(1.33755840993954),    //202
    BP2_FROM_FLOAT(1.33901783035178),    //203
    BP2_FROM_FLOAT(1.34047566184545),    //204
    BP2_FROM_FLOAT(1.34193190959899),    //205
    BP2_FROM_FLOAT(1.34338657876279),    //206
    BP2_FROM_FLOAT(1.34483967445938),    //207
    BP2_FROM_FLOAT(1.34629120178363),    //208
    BP2_FROM_FLOAT(1.34774116580299),    //209
    BP2_FROM_FLOAT(1.34918957155768),    //210
    BP2_FROM_FLOAT(1.35063642406089),    //211
    BP2_FROM_FLOAT(1.352081728299),    //212
    BP2_FROM_FLOAT(1.35352548923173),    //213
    BP2_FROM_FLOAT(1.35496771179243),    //214
    BP2_FROM_FLOAT(1.35640840088817),    //215
    BP2_FROM_FLOAT(1.35784756140003),    //216
    BP2_FROM_FLOAT(1.35928519818322),    //217
    BP2_FROM_FLOAT(1.36072131606733),    //218
    BP2_FROM_FLOAT(1.36215591985646),    //219
    BP2_FROM_FLOAT(1.36358901432946),    //220
    BP2_FROM_FLOAT(1.3650206042401),    //221
    BP2_FROM_FLOAT(1.36645069431722),    //222
    BP2_FROM_FLOAT(1.36787928926496),    //223
    BP2_FROM_FLOAT(1.36930639376292),    //224
    BP2_FROM_FLOAT(1.37073201246633),    //225
    BP2_FROM_FLOAT(1.37215615000626),    //226
    BP2_FROM_FLOAT(1.37357881098974),    //227
    BP2_FROM_FLOAT(1.375),    //228
    BP2_FROM_FLOAT(1.37641972159658),    //229
    BP2_FROM_FLOAT(1.37783798031554),    //230
    BP2_FROM_FLOAT(1.37925478066962),    //231
    BP2_FROM_FLOAT(1.38067012714841),    //232
    BP2_FROM_FLOAT(1.3820840242185),    //233
    BP2_FROM_FLOAT(1.38349647632367),    //234
    BP2_FROM_FLOAT(1.38490748788502),    //235
    BP2_FROM_FLOAT(1.38631706330118),    //236
    BP2_FROM_FLOAT(1.38772520694841),    //237
    BP2_FROM_FLOAT(1.3891319231808),    //238
    BP2_FROM_FLOAT(1.39053721633044),    //239
    BP2_FROM_FLOAT(1.39194109070751),    //240
    BP2_FROM_FLOAT(1.3933435506005),    //241
    BP2_FROM_FLOAT(1.39474460027634),    //242
    BP2_FROM_FLOAT(1.39614424398054),    //243
    BP2_FROM_FLOAT(1.39754248593737),    //244
    BP2_FROM_FLOAT(1.39893933034996),    //245
    BP2_FROM_FLOAT(1.4003347814005),    //246
    BP2_FROM_FLOAT(1.40172884325036),    //247
    BP2_FROM_FLOAT(1.40312152004023),    //248
    BP2_FROM_FLOAT(1.40451281589026),    //249
    BP2_FROM_FLOAT(1.40590273490025),    //250
    BP2_FROM_FLOAT(1.40729128114971),    //251
    BP2_FROM_FLOAT(1.40867845869808),    //252
    BP2_FROM_FLOAT(1.41006427158481),    //253
    BP2_FROM_FLOAT(1.41144872382953),    //254
    BP2_FROM_FLOAT(1.41283181943216),    //255
    BP2_FROM_FLOAT(1.4142135623731)      //256
};

#endif

#endif //ENABLE_ALL_ENCOPT
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\wmalib\wmadec_s\entropydec.c ===
/*************************************************************************

Copyright (C) Microsoft Corporation, 1996 - 1999

Module Name:

    EntropyDec.cpp

Abstract:

    Implementation of entropy decoding functions.

Author:

    Wei-ge Chen (wchen) 14-July-1998

Revision History:


*************************************************************************/

#pragma code_seg("WMADEC")
#pragma data_seg("WMADEC_RW")
#pragma const_seg("WMADEC_RD")

#include "..\decoder\msaudiodec.h"
#include "..\decoder\huffdec.h"
#include "AutoProfile.h"  
#include "..\..\..\dsound\dsndver.h"

#ifdef TRANSCODER
#include "coefStream.h"
#endif  // TRANSCODER


//*****************************************************************************************
//
// prvDecodeFrameHeader
//
//*****************************************************************************************

//#define DEBUG_DECODE_TRACE
#undef DEBUG_DECODE_TRACE
#if defined (DEBUG_DECODE_TRACE)
extern unsigned int g_ulOutputSamples;
#define DEBUG_TRACE_QUANT(a, b, c)                                              \
                printf("%d %d %d %u\n", a, b, c, g_ulOutputSamples);                                  \
                fflush (stdout);
#pragma COMPILER_MESSAGE(__FILE__ "(43) : Warning - m_iQuantStepSize Debug Code Enabled.")
#else
#define DEBUG_TRACE_QUANT(a, b, c)
#endif

#if defined (_DEBUG)
#define COUNT_BITS(a,b) a += b
#else
#define COUNT_BITS(a,b)
#endif

WMARESULT prvDecodeFrameHeader (CAudioObjectDecoder* paudec, Int* piBitCnt)
{      
    Bool fSkipAll;
    Bool* fUpdateMask;
    I16  *piChannel = &paudec->m_iChannel;
    Int iMaskQPrev;
    Int iSizePrev = 0, iSizeCurr = 0, iSizeNext = 0;
    PerChannelInfo* ppcinfo;
	CAudioObject* pau = paudec->pau;

    WMARESULT   wmaResult = WMA_OK;
    U32         iResult;

#ifdef PROFILE
    FunctionProfile fp;
    FunctionProfileStart(&fp,DECODE_FRAME_HEADER_PROFILE);
#endif

    switch (paudec->m_hdrdecsts)
    {
        case HDR_SIZE:
            if (pau->m_fAllowSubFrame) 
            {
                //peek enough bits for this "case" if not enough will be on hold
                Int cBitsNeed = LOG2 ((U32) LOG2 ((U32)pau->m_iMaxSubFrameDiv)) + 1;
                TRACEWMA_EXIT(wmaResult, ibstrmLookForBits (&paudec->m_ibstrm, 12));
                if (pau->m_fHeaderReset) 
                {
                    TRACEWMA_EXIT(wmaResult, ibstrmGetBits (&paudec->m_ibstrm, cBitsNeed, &iResult));
                    COUNT_BITS(*piBitCnt, cBitsNeed);
                    iSizePrev = pau->m_cFrameSampleHalf / (1 << iResult);

                    //current
                    TRACEWMA_EXIT(wmaResult, ibstrmGetBits (&paudec->m_ibstrm, cBitsNeed, &iResult));
                    COUNT_BITS(*piBitCnt, cBitsNeed);
                    iSizeCurr = pau->m_cFrameSampleHalf / (1 << iResult);

                    assert (iSizePrev != 0 && iSizeCurr != 0);
                    pau->m_fHeaderReset = WMAB_FALSE;
                    if (iSizePrev  < pau->m_cMinSubFrameSampleHalf || iSizePrev > pau->m_cFrameSampleHalf ||
                        iSizeCurr  < pau->m_cMinSubFrameSampleHalf || iSizeCurr > pau->m_cFrameSampleHalf)
                    {
                        assert (WMAB_FALSE);
                        return TraceResult(WMA_E_BROKEN_FRAME);
                    }
                }

                TRACEWMA_EXIT(wmaResult, ibstrmGetBits (&paudec->m_ibstrm, cBitsNeed, &iResult));
                COUNT_BITS(*piBitCnt, cBitsNeed);
                iSizeNext = pau->m_cFrameSampleHalf / (1 << iResult);
                if (iSizeNext  < pau->m_cMinSubFrameSampleHalf || iSizeNext > pau->m_cFrameSampleHalf)
                {
                    assert (WMAB_FALSE);
                    return TraceResult(WMA_E_BROKEN_FRAME);
                }
            }
            ASSERTWMA_EXIT(wmaResult, prvUpdateSubFrameConfig(paudec, iSizeNext, iSizePrev, iSizeCurr));
            ASSERTWMA_EXIT(wmaResult, auAdaptToSubFrameConfig (pau));

#ifdef ENABLE_EQUALIZER
            prvAdaptEqToSubFrame(paudec);
#endif    //ENABLE_EQUALIZER

            if (pau->m_cChannel == 1)    {
                TRACEWMA_EXIT(wmaResult, ibstrmGetBits (&paudec->m_ibstrm, 1, &iResult));
                pau->m_rgpcinfo [0].m_iPower = iResult;

                COUNT_BITS(*piBitCnt, 1);
                fSkipAll = (pau->m_rgpcinfo [0].m_iPower == 0);

#ifdef TRANSCODER
                if (TT_SIMPLE == pau->m_ttTranscodeType)
                {
                   TRACEWMA_RET(wmaResult, coefstrmRecordCoefs(pau->m_rgpcinfo[0].
                       m_pcstrmPower, &iResult, 1));
                   TRACEWMA_RET(wmaResult, coefstrmRecordDone(pau->m_rgpcinfo[0].
                       m_pcstrmPower));
                }
#endif  // TRANSCODER

            }
	        else if (pau->m_cChannel == 2)	{
                TRACEWMA_EXIT(wmaResult, ibstrmGetBits (&paudec->m_ibstrm, 1, &iResult));
		        pau->m_stereoMode = (StereoMode) iResult;

                COUNT_BITS(*piBitCnt, 1);
                TRACEWMA_EXIT(wmaResult, ibstrmGetBits (&paudec->m_ibstrm, 1, &iResult));
		        pau->m_rgpcinfo [0].m_iPower = iResult;

                COUNT_BITS(*piBitCnt, 1);
                TRACEWMA_EXIT(wmaResult, ibstrmGetBits (&paudec->m_ibstrm, 1, &iResult));
		        pau->m_rgpcinfo [1].m_iPower = iResult;

                COUNT_BITS(*piBitCnt, 1);
                fSkipAll = (pau->m_rgpcinfo [0].m_iPower == 0) & (pau->m_rgpcinfo [1].m_iPower == 0);
                prvSetDetTable  (paudec,  pau->m_rgpcinfo + 1);

#ifdef TRANSCODER
                if (TT_SIMPLE == pau->m_ttTranscodeType)
                {
                    PerChannelInfo *ppcinfo0 = &(pau->m_rgpcinfo[0]);
                    PerChannelInfo *ppcinfo1 = &(pau->m_rgpcinfo[1]);

                    TRACEWMA_RET(wmaResult, coefstrmRecordCoefs(pau->m_pcstrmStereoMode,
                        &pau->m_stereoMode, 1));

                    TRACEWMA_RET(wmaResult, coefstrmRecordCoefs(ppcinfo0->m_pcstrmPower,
                        &ppcinfo0->m_iPower, 1));

                    TRACEWMA_RET(wmaResult, coefstrmRecordCoefs(ppcinfo1->m_pcstrmPower,
                        &ppcinfo1->m_iPower, 1));

                    TRACEWMA_RET(wmaResult, coefstrmRecordDone(pau->m_pcstrmStereoMode));
                    TRACEWMA_RET(wmaResult, coefstrmRecordDone(ppcinfo0->m_pcstrmPower));
                    TRACEWMA_RET(wmaResult, coefstrmRecordDone(ppcinfo1->m_pcstrmPower));
                }
#endif  // TRANSCODER

            }
            pau->m_iQuantStepSize = MIN_QUANT; // shift it back by the minimum for decode or in case of exit
            if (fSkipAll) {
#               if defined(ENABLE_ALL_ENCOPT) && defined(ENABLE_LPC)
                    // no bits will be read
                    if (pau->m_iWeightingMode == LPC_MODE) 
                        TRACEWMA_EXIT(wmaResult, prvDecodeFrameHeaderLpc(paudec, (Int *)piBitCnt));
#               endif  // defined(ENABLE_ALL_ENCOPT) && defined(ENABLE_LPC)
                paudec->m_hdrdecsts = HDR_DONE;

#ifdef TRANSCODER
                if (TT_SIMPLE == pau->m_ttTranscodeType)
                {
                    // *** TODO: Can probably avoid saving explicitly and implicitly set
                    // after noticing fSkipAll condition on encoder side.
                    TRACEWMA_EXIT(wmaResult, coefstrmRecordCoefs(pau->m_pcstrmQSteps,
                        &pau->m_iQuantStepSize, 1));
                    TRACEWMA_EXIT(wmaResult, coefstrmRecordDone(pau->m_pcstrmQSteps));
                }
#endif  // TRANSCODER

                goto exit;
            }
            paudec->m_hdrdecsts = HDR_QUANT;

        case HDR_QUANT:
            TRACEWMA_EXIT(wmaResult, ibstrmLookForBits (&paudec->m_ibstrm, 3 * NUM_BITS_QUANTIZER));
            while(1) {
                Int iStepSize;

                TRACEWMA_EXIT(wmaResult, ibstrmGetBits (&paudec->m_ibstrm,
                    NUM_BITS_QUANTIZER, &iResult));
                iStepSize = iResult;

                COUNT_BITS(*piBitCnt, NUM_BITS_QUANTIZER);
                assert(iStepSize <= MSA_MAX_QUANT_ESC);
                DEBUG_TRACE_QUANT(pau->m_iFrameNumber, pau->m_iCurrSubFrame, iStepSize);
                if(iStepSize != MSA_MAX_QUANT_ESC) {
                    // the last one...
                    pau->m_iQuantStepSize += iStepSize;
			        MONITOR_RANGE(gMR_iQuantStepSize,pau->m_iQuantStepSize);
                    break;
                }
                // escape code, so on to the next level...
                pau->m_iQuantStepSize += MSA_MAX_QUANT_ESC;
            }
            auUpdateMaxEsc(pau, pau->m_iQuantStepSize);

#ifdef TRANSCODER
            if (TT_SIMPLE == pau->m_ttTranscodeType)
            {
                TRACEWMA_EXIT(wmaResult, coefstrmRecordCoefs(pau->m_pcstrmQSteps,
                    &pau->m_iQuantStepSize, 1));
                TRACEWMA_EXIT(wmaResult, coefstrmRecordDone(pau->m_pcstrmQSteps));
            }
#endif  // TRANSCODER
            
            *piChannel  = 0;
#ifdef ENABLE_ALL_ENCOPT
            paudec->m_iBand     = (I16) pau->m_iFirstNoiseBand;;
#endif // ENABLE_ALL_ENCOPT
            paudec->m_hdrdecsts = HDR_NOISE1;

        case HDR_NOISE1 :
        case HDR_NOISE2 :
#           ifdef ENABLE_ALL_ENCOPT
            if (pau->m_fNoiseSub == WMAB_TRUE)
            {
                TRACEWMA_EXIT(wmaResult, prvDecodeFrameHeaderNoiseSub(paudec, (Int *)piBitCnt));
            }
#           endif //ENABLE_ALL_ENCOPT
            paudec->m_hdrdecsts = HDR_MSKUPD;

        case HDR_MSKUPD :

            TRACEWMA_EXIT(wmaResult, ibstrmLookForBits (&paudec->m_ibstrm, 1));
            //Setup the pointer to the quantized coefficents. This must be done after 
            //prvDecodeFrameHeaderNoiseSub since it changes the value of m_cSubbandActual
            ppcinfo = pau->m_rgpcinfo;
            ppcinfo->m_rgiCoefQ       = ((I16*) (pau->m_rgiCoefReconOrig + DOUBLE(pau->m_fPad2XTransform,pau->m_cFrameSampleHalf)))  
                                      - DOUBLE(pau->m_fPad2XTransform,ppcinfo->m_cSubbandActual);
            memset (ppcinfo->m_rgiCoefQ, 0,  sizeof (I16) * DOUBLE(pau->m_fPad2XTransform,ppcinfo->m_cSubbandActual));
            if (pau->m_cChannel == 2)   {
                ppcinfo = pau->m_rgpcinfo + 1;
                ppcinfo->m_rgiCoefQ       = ((I16*) (pau->m_rgiCoefReconOrig + DOUBLE(pau->m_fPad2XTransform, 2 * pau->m_cFrameSampleHalf)))
                                          - DOUBLE(pau->m_fPad2XTransform,ppcinfo->m_cSubbandActual);
                memset (ppcinfo->m_rgiCoefQ, 0,  sizeof (I16) * DOUBLE(pau->m_fPad2XTransform,ppcinfo->m_cSubbandActual));
            }

            fUpdateMask = &(pau->m_subfrmconfigCurr.m_rgfMaskUpdate [pau->m_iCurrSubFrame]);
            *fUpdateMask = WMAB_TRUE;
            if (pau->m_fAllowSubFrame && pau->m_subfrmconfigCurr.m_cSubFrame > 1) {
                TRACEWMA_EXIT(wmaResult, ibstrmGetBits (&paudec->m_ibstrm, 1, &iResult));
                *fUpdateMask = iResult;
                (*piBitCnt)++;
            }
            *piChannel = 0;
            paudec->m_iBand = 0;
            paudec->m_hdrdecsts = HDR_BARK;

        case HDR_BARK :
            fUpdateMask = &(pau->m_subfrmconfigCurr.m_rgfMaskUpdate [pau->m_iCurrSubFrame]);
            if (pau->m_iWeightingMode == BARK_MODE) 
            {
                for (; *piChannel < pau->m_cChannel; (*piChannel)++)
                {
                    PerChannelInfo *ppcinfo = pau->m_rgpcinfo + *piChannel;
                    if (ppcinfo->m_iPower != 0) 
                    {
                        Int* rgiMaskQ = ppcinfo->m_rgiMaskQ;
                        if (*fUpdateMask == WMAB_TRUE)    
                        {
                            if (pau->m_iVersion == 1) {
                                TRACEWMA_EXIT(wmaResult, ibstrmGetBits (&paudec->m_ibstrm,
                                    NBITS_FIRST_MASKQUANT, &iResult));
	                            rgiMaskQ [0] = iResult + MIN_MASKQ_IN_DB_V1;

#ifdef TRANSCODER
                                if (TT_SIMPLE == pau->m_ttTranscodeType)
                                {
                                    TRACEWMA_EXIT(wmaResult,
                                        coefstrmRecordCoefs(ppcinfo->m_pcstrmMaskQ,
                                        &rgiMaskQ[0], 1));
                                }
#endif  // TRANSCODER

                                *piBitCnt += NBITS_FIRST_MASKQUANT;
                                paudec->m_iBand++;
                            }

                            for (; paudec->m_iBand < pau->m_cValidBarkBand; paudec->m_iBand++)	
                            {
				                Int iDiff;                        
                                TRACEWMA_EXIT(wmaResult, huffDecGet (g_rgiHuffDecTblMsk,
                                    &paudec->m_ibstrm, &iResult, (unsigned long *)&iDiff, (unsigned long *)0));
                                COUNT_BITS(*piBitCnt, iResult);
                                TRACEWMA_EXIT(wmaResult, ibstrmFlushBits(&paudec->m_ibstrm, iResult));   //flush bits used by huffDecGet
                                iDiff -= MAX_MASKQUANT_DIFF;
                                assert (iDiff >= -MAX_MASKQUANT_DIFF);
                                iMaskQPrev = (paudec->m_iBand == 0) ? 
                                              FIRST_V2_MASKQUANT : rgiMaskQ [paudec->m_iBand - 1];
				                rgiMaskQ [paudec->m_iBand] = iDiff + iMaskQPrev;
						        MONITOR_RANGE(gMR_rgiMaskQ, rgiMaskQ[paudec->m_iBand]);

#ifdef TRANSCODER
                                if (TT_SIMPLE == pau->m_ttTranscodeType)
                                {
                                    TRACEWMA_EXIT(wmaResult,
                                        coefstrmRecordCoefs(ppcinfo->m_pcstrmMaskQ,
                                        &rgiMaskQ[paudec->m_iBand], 1));
                                }
#endif  // TRANSCODER

                            }
                            pau->m_iSubFrameSizeWithUpdate = pau->m_subfrmconfigCurr.m_rgiSubFrameSize [pau->m_iCurrSubFrame];
                            paudec->m_iBand = 0;

#ifdef TRANSCODER
                            if (TT_SIMPLE == pau->m_ttTranscodeType)
                                TRACEWMA_EXIT(wmaResult, coefstrmRecordDone(ppcinfo->m_pcstrmMaskQ));
#endif  // TRANSCODER
                        }

                        //for IntFloat this gets done inside ReconWeightFactor()
                        //Scan For Max Weight
                        if (*fUpdateMask)
                        {
					        Int iMax = rgiMaskQ[0];
                            I16 iBand;
                            for (iBand = 1; iBand < pau->m_cValidBarkBand; iBand++)
                            {
                                if (rgiMaskQ[iBand] > iMax)
							        iMax = rgiMaskQ[iBand];
                            }
					        ppcinfo->m_iMaxMaskQ = iMax;
                        }
                    }
                    else if (*fUpdateMask == WMAB_TRUE)    
                    {	//else artifically set to constants since nothing got sent; see comments in msaudioenc.c
				        //0 db = 1.0 for weightfactor
				        memset( ppcinfo->m_rgiMaskQ, 0, pau->m_cValidBarkBand*sizeof(Int) );
                        ppcinfo->m_iMaxMaskQ = 0;
			        }
                }
            }
#if defined(ENABLE_ALL_ENCOPT) && defined(ENABLE_LPC)
            else 
            {
                TRACEWMA_EXIT(wmaResult, prvDecodeFrameHeaderLpc(paudec, (Int *)piBitCnt));
		        if (pau->m_fNoiseSub == WMAB_TRUE)	
			        prvGetBandWeightLowRate (paudec);
            }
#else   // defined(ENABLE_ALL_ENCOPT) && defined(ENABLE_LPC)
            else {
                assert(WMAB_FALSE);
            }
#endif  // defined(ENABLE_ALL_ENCOPT) && defined(ENABLE_LPC)
    }

    paudec->m_hdrdecsts = HDR_DONE;

exit:

#ifdef PROFILE
    FunctionProfileStop(&fp);
#endif

    return wmaResult;
}


//*****************************************************************************************
//
// prvDecodeCoefficientMono
//
//*****************************************************************************************
WMARESULT prvDecodeCoefficientMono	(CAudioObjectDecoder* paudec, 
                                     PerChannelInfo* ppcinfo, 
                                     Int* piBitCnt)
{
    WMARESULT   wmaResult = WMA_OK;

#ifdef PROFILE
    FunctionProfile fp;
    FunctionProfileStart(&fp,DECODE_COEFFICENT_MONO_PROFILE);
#endif

    if (ppcinfo->m_iPower == 0)
        goto exit;

    TRACEWMA_EXIT(wmaResult, prvDecodeRunLevel(paudec, ppcinfo, 0, ppcinfo->m_cSubbandActual, piBitCnt));

exit:
#ifdef PROFILE
    FunctionProfileStop(&fp);
#endif
    return wmaResult;
}


//*****************************************************************************************
//
// prvDecodeCoefficientStereo
//
//*****************************************************************************************
WMARESULT prvDecodeCoefficientStereo (CAudioObjectDecoder* paudec, 
                                    PerChannelInfo* ppcinfo, Int* piBitCnt)
{
    WMARESULT   wmaResult = WMA_OK;
    CAudioObject* pau = paudec->pau;

#ifdef PROFILE
    //FunctionProfile fp;
    //FunctionProfileStart(&fp,DECODE_COEFFICENT_STEREO_PROFILE);
#endif
	for (; paudec->m_iChannel < pau->m_cChannel; paudec->m_iChannel++)	
    {
        TRACEWMA_EXIT(wmaResult, prvDecodeCoefficientMono(paudec, ppcinfo + paudec->m_iChannel, piBitCnt));

        if(pau->m_iVersion == 1) 
        {
            *piBitCnt += ibstrmBitsLeft (&paudec->m_ibstrm) % 8;
		    ibstrmFlush(&paudec->m_ibstrm);         //no need to support pause mode (always has fraction bytes)
        }
        paudec->pau->m_iCurrReconCoef = 0;
	}

exit:
#ifdef PROFILE
    //FunctionProfileStop(&fp);
#endif
	return wmaResult;
}


//*****************************************************************************************
//
// prvGetNextRunDEC
//
//*****************************************************************************************
extern Int g_cBitPut;
WMARESULT prvGetNextRunDEC(Void*			 pobjin, 
					 PerChannelInfo* ppcinfo,
                     Int*			 piBitCnt)
{
	U32 uSign  = 0;		//1 for positive 0 for nonpositive
    I32 iSign  = 0;
	U32 iEntry = 0;		//index to the Vlc table entry
    U32 iResult;
    U16 cBitsTotal;
    WMARESULT     wmaResult = WMA_OK;
    CAudioObjectDecoder* paudec  = (CAudioObjectDecoder*) pobjin;
    CAudioObject*		 pau = paudec->pau;
    CWMAInputBitStream*  pibstrm = &(paudec->m_ibstrm);

    switch (paudec->m_rlsts)
    {
    case VLC:
        TRACEWMA_EXIT(wmaResult, huffDecGet (ppcinfo->m_rgiHuffDecTbl, &paudec->m_ibstrm,
            &iResult, &iEntry, &uSign));
        COUNT_BITS(*piBitCnt, iResult);
        TRACEWMA_EXIT(wmaResult, ibstrmFlushBits(&paudec->m_ibstrm, iResult));   //flush bits used by huffDecGet
	    if (iEntry == 0)
            goto escape;
        if (iEntry == 1)
        {
			/*
		    // [1], end of coefs for this subFrame 
            *pcRunOfZeros = ppcinfo->m_cSubbandActual - iCoef - 1;
            *piCurrLevel = 0;
            wmaResult = WMA_OK;
			*/
            pau->m_iLevel = 0;
			pau->m_iHighCutOffCurr = -1; 
			pau->m_iNextBarkIndex = -1;                                                                    
			pau->m_cRunOfZeros = ppcinfo->m_cSubbandActual - pau->m_iCurrReconCoef - 1;
        }
        else 
        {
			assert (iEntry >= 2);
            COUNT_BITS(*piBitCnt, 1);
            TRACEWMA_EXIT(wmaResult, ibstrmFlushBits(&paudec->m_ibstrm, 1));   //flush the sign bit also
			pau->m_cRunOfZeros = ppcinfo->m_rgiRunEntry [iEntry - 2] & 0x7FFFFFFF;
			assert (pau->m_cRunOfZeros >= 0);
			pau->m_iLevel = ppcinfo->m_rgiLevelEntry [iEntry - 2];
			pau->m_iSign = (I32) (uSign >> 31) - 1;
        }
        break;

    case ESCAPE:
escape:
        paudec->m_rlsts = ESCAPE;
        cBitsTotal = (U16) pau->m_iMaxEscSize + (U16) pau->m_cBitsSubbandMax + 1; //<=25=13+11+1
        assert (cBitsTotal <= 25);
        TRACEWMA_EXIT(wmaResult, ibstrmLookForBits (&paudec->m_ibstrm, cBitsTotal));

        TRACEWMA_EXIT(wmaResult, ibstrmGetBits (&paudec->m_ibstrm, cBitsTotal, &iResult));
        COUNT_BITS(*piBitCnt, cBitsTotal);

        cBitsTotal = (U16) paudec->pau->m_cBitsSubbandMax + 1;
		pau->m_iLevel = (I16) (iResult >> cBitsTotal);
        pau->m_iSign = (I32) (iResult & 0x00000001) - 1;
        //*piCurrLevel = (I16) ((*piCurrLevel ^ iSign) - iSign);

		pau->m_cRunOfZeros = (I16) (iResult & (0xFFFFFFFF >> (32 - cBitsTotal))) >> 1;
		pau->m_cRunOfZeros &= 0x7FFFFFFF;
        paudec->m_rlsts = VLC;
	}

exit:
    return wmaResult;
}

//*****************************************************************************************
//
// prvDecodeRunLevel
//
//*****************************************************************************************
//#define RL_PRINT_SRC
#if defined (RL_PRINT_SRC)
#define DBG_RUNLEVEL(a,b,c,e)     \
                    if(e) {\
	                    printf("%d %d %d\n", a, b, c);\
                        fflush (stdout);\
                    }
#else 
#define DBG_RUNLEVEL(a,b,c,e)
#endif //DBG_RUNLEVEL

WMARESULT prvDecodeRunLevel  (CAudioObjectDecoder* paudec, 
                            PerChannelInfo* ppcinfo,
						    Int iCoefFirst, 
						    Int iCoefLim, 
                            Int* piBitCnt)
{
    I16* rgiCoefQ       = ppcinfo->m_rgiCoefQ;
    const U16* rgiRunEntry    = ppcinfo->m_rgiRunEntry;    
    const U16* rgiLevelEntry  = ppcinfo->m_rgiLevelEntry;    
    CAudioObject* pau = paudec->pau;
	I16* piCoef = &pau->m_iCurrReconCoef;	
#ifdef DEBUG_DECODE_TRACE
    DEBUG_ONLY( Bool fPrint = (g_ulOutputSamples==0x4e00); )
#else
    DEBUG_ONLY( Bool fPrint = (pau->m_iFrameNumber  <= 10 && pau->m_iCurrSubFrame == 0); )
#endif
    WMARESULT   wmaResult = WMA_OK;

    // This function is too frequently called to be profiled
	//FUNCTION_PROFILE(fp);
    //FUNCTION_PROFILE_START(&fp,DECODE_RUN_LEVEL_PROFILE);
    while (*piCoef < iCoefLim) 
    {
        TRACEWMA_EXIT(wmaResult, prvGetNextRunDEC(paudec,ppcinfo,piBitCnt));
        pau->m_iLevel = (I16) ((pau->m_iLevel ^ pau->m_iSign) - pau->m_iSign);
        DBG_RUNLEVEL(g_cBitGet-21,pau->m_cRunOfZeros,pau->m_iLevel,fPrint);
        if ( (*piCoef+ pau->m_cRunOfZeros) >= iCoefLim)  {
            assert (WMAB_FALSE);
            wmaResult = TraceResult(WMA_E_BROKEN_FRAME);
            goto exit;
        }
//        memset (rgiCoefQ + *piCoef, 0, pau->m_cRunOfZeros * sizeof (I16));
    	*piCoef += (I16) pau->m_cRunOfZeros;
		rgiCoefQ [*piCoef] = pau->m_iLevel;
		MONITOR_RANGE(gMR_iCoefQ,rgiCoefQ [*piCoef]);
		MONITOR_COUNT_CONDITIONAL(pau->m_cRunOfZeros>0,gMC_0CoefQ,pau->m_cRunOfZeros);
		(*piCoef)++;
        paudec->m_rlsts = VLC;
	}
    
exit:
    //FUNCTION_PROFILE_STOP(&fp);
	return wmaResult;
}


//*****************************************************************************************
//
// prvSetDetTable
//
//*****************************************************************************************
Void prvSetDetTable  (CAudioObjectDecoder* paudec,  PerChannelInfo* ppcinfo)
{
    CAudioObject* pau = paudec->pau;
/*** less than 0.5%
#ifdef PROFILE
    //FunctionProfile fp;
    //FunctionProfileStart(&fp,SET_DET_TABLE_PROFILE);
#endif
*///
    if (pau->m_iEntropyMode == SIXTEENS_OB)   {
        if (pau->m_stereoMode == STEREO_SUMDIFF)  {
            ppcinfo->m_rgiHuffDecTbl = g_rgiHuffDecTbl16ssOb;
            ppcinfo->m_rgiRunEntry = gRun16ssOb;    
            ppcinfo->m_rgiLevelEntry = gLevel16ssOb;    
        }
        else {
            ppcinfo->m_rgiHuffDecTbl = g_rgiHuffDecTbl16smOb; 
            ppcinfo->m_rgiRunEntry = gRun16smOb;    
            ppcinfo->m_rgiLevelEntry = gLevel16smOb;    
        }
    }
#ifdef ENABLE_ALL_ENCOPT
    else if (pau->m_iEntropyMode == FOURTYFOURS_QB)   {
        if (pau->m_stereoMode == STEREO_SUMDIFF)  {
            ppcinfo->m_rgiHuffDecTbl = g_rgiHuffDecTbl44ssQb;
            ppcinfo->m_rgiRunEntry = gRun44ssQb;    
            ppcinfo->m_rgiLevelEntry = gLevel44ssQb;
        }
        else {
            ppcinfo->m_rgiHuffDecTbl = g_rgiHuffDecTbl44smQb; 
            ppcinfo->m_rgiRunEntry = gRun44smQb;    
            ppcinfo->m_rgiLevelEntry = gLevel44smQb;    
        }
    }
    else if (pau->m_iEntropyMode == FOURTYFOURS_OB)   {
        if (pau->m_stereoMode == STEREO_SUMDIFF)  {
            ppcinfo->m_rgiHuffDecTbl = g_rgiHuffDecTbl44ssOb;
            ppcinfo->m_rgiRunEntry = gRun44ssOb;
            ppcinfo->m_rgiLevelEntry = gLevel44ssOb;
        }
        else {
            ppcinfo->m_rgiHuffDecTbl = g_rgiHuffDecTbl44smOb;
            ppcinfo->m_rgiRunEntry = gRun44smOb;
            ppcinfo->m_rgiLevelEntry = gLevel44smOb;
        }
    }
#endif // ENABLE_ALL_ENCOPT
/***
#ifdef PROFILE
    //FunctionProfileStop(&fp);
#endif
*///
}


#if defined(ENABLE_ALL_ENCOPT) && defined(ENABLE_LPC)

// define to break at a particular frame
//#define LPC_WEIGHTS_BREAK_AT_FRAME 27
// define to display overview of weight factor calculations by subframe
//#define SHOW_OVERVIEW_WEIGHT_FACTOR_FIRST 0
//#define SHOW_OVERVIEW_WEIGHT_FACTOR_LAST  60
#if defined(_DEBUG) && ( defined(SHOW_OVERVIEW_WEIGHT_FACTOR_FIRST) || defined(LPC_WEIGHTS_BREAK_AT_FRAME) )
#	pragma COMPILER_MESSAGE(__FILE__ "(644) : Warning - LPC Weight Factor Debug Code Enabled.")
#endif
#if defined(_DEBUG) && defined(LPC_WEIGHTS_BREAK_AT_FRAME)
#   define DEBUG_BREAK_AT_FRAME_LPC_WEIGHTS                 \
    if ( pau->m_iFrameNumber==LPC_WEIGHTS_BREAK_AT_FRAME )  \
        { DEBUG_BREAK(); }
#else   // define(_DEBUG) && defined(SHOW_OVERVIEW_WEIGHT_FACTOR)
#   define DEBUG_BREAK_AT_FRAME_LPC_WEIGHTS
#endif  // define(_DEBUG) && defined(SHOW_OVERVIEW_WEIGHT_FACTOR)
#if defined(_DEBUG) && defined(SHOW_OVERVIEW_WEIGHT_FACTOR_FIRST)
#   if UNDER_CE
#       define SHOW_OWF(iChan,iCase)                                            \
            if (SHOW_OVERVIEW_WEIGHT_FACTOR_FIRST <= pau->m_iFrameNumber        \
                && pau->m_iFrameNumber <= SHOW_OVERVIEW_WEIGHT_FACTOR_LAST )    \
                MyOutputDbgStr(0,"%4d %2d %d %4d %d  %+16.6f %+16.6f %+16.6f %+16.6f\n", \
                    pau->m_iFrameNumber,pau->m_iCurrSubFrame, pau->m_cSubband,  \
                    iChan, iCase,                                               \
                    FLOAT_FROM_WEIGHT(ppcinfo->m_rguiWeightFactor[0]),          \
                    FLOAT_FROM_WEIGHT(ppcinfo->m_rguiWeightFactor[1]),          \
                    FLOAT_FROM_WEIGHT(ppcinfo->m_rguiWeightFactor[2]),          \
                    FLOAT_FROM_WEIGHT(ppcinfo->m_rguiWeightFactor[3]) )
#   else // UNDER_CE
#       define SHOW_OWF(iChan,iCase)                                            \
            if (SHOW_OVERVIEW_WEIGHT_FACTOR_FIRST <= pau->m_iFrameNumber        \
                && pau->m_iFrameNumber <= SHOW_OVERVIEW_WEIGHT_FACTOR_LAST )    \
                printf("%4d %2d %d %4d %d  %+16.6f %+16.6f %+16.6f %+16.6f\n",  \
                    pau->m_iFrameNumber,pau->m_iCurrSubFrame, pau->m_cSubband,  \
                    iChan, iCase,                                               \
                    FLOAT_FROM_WEIGHT(ppcinfo->m_rguiWeightFactor[0]),          \
                    FLOAT_FROM_WEIGHT(ppcinfo->m_rguiWeightFactor[1]),          \
                    FLOAT_FROM_WEIGHT(ppcinfo->m_rguiWeightFactor[2]),          \
                    FLOAT_FROM_WEIGHT(ppcinfo->m_rguiWeightFactor[3]) )
#   endif  // UNDER_CE
#else   // define(_DEBUG) && defined(SHOW_OVERVIEW_WEIGHT_FACTOR)
#   define SHOW_OWF(iChan,iCase)
#endif  // define(_DEBUG) && defined(SHOW_OVERVIEW_WEIGHT_FACTOR)

WMARESULT prvDecodeFrameHeaderLpc (CAudioObjectDecoder* paudec, Int* piBitCnt) 
{
    Bool fUpdateMask = paudec->pau->m_subfrmconfigCurr.m_rgfMaskUpdate [paudec->pau->m_iCurrSubFrame];
	CAudioObject* pau = paudec->pau;
    I16* piChannel = &paudec->m_iChannel;
    PerChannelInfo *ppcinfo;
    // U8 rgiLspFreqQ[LPCORDER];  ONHOLD will lose this, use WeightFactor instead
    I16* piFreq = &paudec->m_iBand;  // preserve this across ONHOLD
	Int cBitAlloc;
    WMARESULT   wmaResult = WMA_OK;
    LpType rgLpcCoef [LPCORDER];
    FUNCTION_PROFILE(fp);
    FUNCTION_PROFILE_START(&fp,FRAME_HEADER_LPC_PROFILE);

    DEBUG_BREAK_AT_FRAME_LPC_WEIGHTS;

    for (; *piChannel < pau->m_cChannel; (*piChannel)++)   
	{
		ppcinfo = pau->m_rgpcinfo + *piChannel;
		if (ppcinfo->m_iPower != 0 )   
		{
			if (fUpdateMask == WMAB_TRUE)
			{
                // these 10 bytes are saved in the WeightFactor array in case we go ONHOLD.  
                // WeightFactor will be set by rgiLspFreqQ
                U8* rgiLspFreqQ = (U8*)(INTEGER_OR_INT_FLOAT( ppcinfo->m_rguiWeightFactor, ppcinfo->m_rgfltWeightFactor ));
				for (; *piFreq < LPCORDER; (*piFreq)++)	
				{
					U32         iResult;
					cBitAlloc = (*piFreq == 0 || *piFreq == 8 || *piFreq == 9) ? 3 : 4;
                
					TRACEWMA_EXIT(wmaResult, ibstrmGetBits(&paudec->m_ibstrm,
						          cBitAlloc, &iResult));
					rgiLspFreqQ[*piFreq] = (U8) iResult;

					*piBitCnt += cBitAlloc;
					MONITOR_RANGE(gMR_rgiLspFreqQ, rgiLspFreqQ[*piFreq]);
				}
				auLsp2lpc(pau, rgiLspFreqQ, rgLpcCoef, LPCORDER);
				TRACEWMA_EXIT(wmaResult, prvLpcToSpectrum(pau,
					          rgLpcCoef, ppcinfo));
                SHOW_OWF(*piChannel,0);
			}
			else if (pau->m_iCurrSubFrame > 0) 
			{	
				auResampleWeightFactorLPC (pau, ppcinfo);
                SHOW_OWF(*piChannel,1);
			}
		}
		else if (fUpdateMask == WMAB_TRUE)
		{	//artifically set to constants since nothing got sent for this channel; see comments in msaudioenc.c
			WeightType* pwtWeightFactor = (WeightType*) ppcinfo->m_rguiWeightFactor;
            I16 iFreq;
			ppcinfo->m_wtMaxWeight = WEIGHT_FROM_FLOAT(1.0F);
			for (iFreq = (I16) pau->m_cSubband; iFreq > 0; iFreq-- )
				*pwtWeightFactor++ = WEIGHT_FROM_FLOAT(1.0F);
            SHOW_OWF(*piChannel,2);
		}
        else if (pau->m_iCurrSubFrame > 0) 
		{	// resample even if zero power, these weights might be used in a later subframe with non-zero power
            auResampleWeightFactorLPC (pau, ppcinfo);
            SHOW_OWF(*piChannel,3);
		}
        *piFreq = 0;
	}

exit:
    FUNCTION_PROFILE_STOP(&fp);
    return wmaResult;
}
#endif  // ENABLE_LPC

#if defined (_DEBUG)
#define COUNT_BITS(a,b) a += b
#else
#define COUNT_BITS(a,b)
#endif

#ifdef ENABLE_ALL_ENCOPT
WMARESULT prvDecodeFrameHeaderNoiseSub (CAudioObjectDecoder* paudec, Int* piBitCnt)
{
    U8*	rgbBandNotCoded;
    Int iStart, iEnd;
    Int iCode;
    U32 cBitUsed;
    I16* piChannel = &paudec->m_iChannel;
    I16* piBand = &paudec->m_iBand;
	CAudioObject* pau = paudec->pau;

    WMARESULT   wmaResult = WMA_OK;
    U32         iResult;
	FUNCTION_PROFILE(fp);
	FUNCTION_PROFILE_START(&fp,FRAME_HEADER_NOISE_SUB_PROFILE);

    switch (paudec->m_hdrdecsts)
    {
        case HDR_NOISE1:
            //noise band indicator
            for (; *piChannel < pau->m_cChannel; (*piChannel)++)   {
                PerChannelInfo* ppcinfo = pau->m_rgpcinfo + *piChannel;
                TRACEWMA_EXIT(wmaResult, ibstrmLookForBits (&paudec->m_ibstrm, 
                                pau->m_cValidBarkBand - pau->m_iFirstNoiseBand));                
                if (ppcinfo->m_iPower != 0) {
                    rgbBandNotCoded = ppcinfo->m_rgbBandNotCoded;
                    *rgbBandNotCoded = 0;
                    ppcinfo->m_cSubbandActual = pau->m_iFirstNoiseIndex - pau->m_cLowCutOff;
                    iStart = 0, iEnd = 0;
                    while (WMAB_TRUE) {
                        iStart = max (pau->m_iFirstNoiseIndex, pau->m_rgiBarkIndex [*piBand]);
                        if (iStart >= pau->m_cHighCutOff)
                            break;
                        iEnd   = min (pau->m_cHighCutOff, pau->m_rgiBarkIndex [*piBand + 1]);

                        TRACEWMA_EXIT(wmaResult, ibstrmGetBits (&paudec->m_ibstrm, 1, &iResult));
				        rgbBandNotCoded [*piBand] = (U8) iResult;

                        (*piBitCnt)++;
				        if (rgbBandNotCoded [*piBand] != 0)
					        rgbBandNotCoded [0]++;
                        else 
                            ppcinfo->m_cSubbandActual += iEnd - iStart;
                        (*piBand)++;
			        }
			        if (*piBand < pau->m_cValidBarkBand )
				        rgbBandNotCoded [*piBand] = (U8) 0;		// protect from debug verify code looking one band past end  
                }
                else 
                    ppcinfo->m_cSubbandActual = 0;
                assert (ppcinfo->m_cSubbandActual >= 0 &&
                        ppcinfo->m_cSubbandActual <= pau->m_cHighCutOff - pau->m_cLowCutOff);
                *piBand = (I16) pau->m_iFirstNoiseBand;
            }
            paudec->m_hdrdecsts = HDR_NOISE2;
            *piChannel = 0;
            //I guess
            *piBand = 0;

        case HDR_NOISE2:
            //noise power
            for (; *piChannel < pau->m_cChannel; (*piChannel)++)   {
                PerChannelInfo* ppcinfo = pau->m_rgpcinfo + *piChannel;
                if (ppcinfo->m_iPower != 0) {
			        U8*	 rgbBandNotCoded = ppcinfo->m_rgbBandNotCoded;
			        Int* rgiNoisePower   = ppcinfo->m_rgiNoisePower;
			        if (rgbBandNotCoded [0] > 0)	{
                        if (*piBand == 0)
                        {
                            TRACEWMA_EXIT(wmaResult, ibstrmGetBits (&paudec->m_ibstrm, 7, &iResult));
				            rgiNoisePower [0] = iResult - 19;
                            (*piBand)++;
                            *piBitCnt += 7;
                        }

				        for (; *piBand < rgbBandNotCoded [0]; (*piBand)++)	{
                            TRACEWMA_EXIT(wmaResult, huffDecGet (g_rgiHuffDecTblNoisePower,
                                          &paudec->m_ibstrm, &cBitUsed, (unsigned long *)&iCode, (unsigned long *)0));
                            TRACEWMA_EXIT(wmaResult, ibstrmFlushBits(&paudec->m_ibstrm, cBitUsed));     //flush bits used by huffDecGet
                            COUNT_BITS(*piBitCnt, cBitUsed);
					        rgiNoisePower [*piBand] = iCode - 18 + rgiNoisePower [*piBand - 1];

					        MONITOR_RANGE(gMR_rgiNoisePower,rgiNoisePower[*piBand]);
				        }
			        }
                }
                *piBand = 0;
            }
    }

exit:
	FUNCTION_PROFILE_STOP(&fp);
    return wmaResult;
}

//******************************************************************************************
//
//  Helper functions for prvGetBandWeightLowRate
//  These functions can be replaced by processor dependent optimized variants
//

#ifndef FFLT_AVG_SQUARE_WEIGHTS
#   if defined(BUILD_INTEGER)
#       if defined(U64SQUARE32SR)
#           define U64_SQUARE_I32(x) U64SQUARE32SR(x, 0)
#       else
#           define U64_SQUARE_I32(x) (((U64)(x)) * ((U64)(x))) 
#       endif
        INLINE FastFloat ffltAvgSquareWeights(WeightType* pwtWeightFactor, Int cN )
        {
            U64 u64Sum = 0;
            FastFloat fflt;
            Int i = cN;
	        for ( ; i > 0; i--, pwtWeightFactor++) {
                u64Sum += U64_SQUARE_I32(*pwtWeightFactor);
            }
            // convert to a fastfloat and then divide.  This avoids an int64 division which is
            // really slow on the sh 3 and quite slow on other risc/dsp machines
            // cN varies from 1 to 328 so this can lose 8.3 bits of precision.
            // but we are comparing to float implementation which has only 24 bits of mantissa.
            fflt = FASTFLOAT_FROM_U64( u64Sum, (WEIGHTFACTOR_FRACT_BITS<<1) );
            fflt.iFraction /= cN;
            Norm4FastFloatU( &fflt );
            return fflt;
        }
#   else
        INLINE Float ffltAvgSquareWeights(WeightType* pwtWeightFactor, Int cN )
        {
            Float fltSum = 0;
            Int i = cN;
	        for ( ; i > 0; i--, pwtWeightFactor++) {
                fltSum += *pwtWeightFactor * *pwtWeightFactor;
	        }
            return fltSum/cN;
        }
#   endif
#   define FFLT_AVG_SQUARE_WEIGHTS( pwtWeightFactor, cN ) ffltAvgSquareWeights( pwtWeightFactor, cN )
#endif


#ifndef FFLT_SQRT_RATIO
    INLINE FastFloat ffltSqrtRatio( FastFloat fflt1, FastFloat fflt2 )
    {
#       if defined(BUILD_INTEGER)
            U64 u64Ratio;
            FastFloat fflt;
            Int iMSF8;
            U32 uiMSF;
            U32 uiFrac1;
            Int iExp = 0;
            if ( fflt2.iFraction==0 ) {
                assert( fflt2.iFraction != 0 ); // divide by 0
                fflt.iFraction = 0x7FFFFFFF;
                fflt.iFracBits = 0;
                return fflt;
            }
            //// fflt1.iFraction*0.5F/(1<<(fflt1.iFracBits-1))
            //// fflt2.iFraction*0.5F/(1<<(fflt2.iFracBits-1))
            u64Ratio = (((U64)fflt1.iFraction)<<32)/fflt2.iFraction;
            uiMSF = (U32)(u64Ratio>>32);
            if ( uiMSF==0 ) {
                iExp = 32;
                uiMSF = (U32)u64Ratio;
            }
            assert( uiMSF != 0 ) ;
            // normalize the most significant fractional part
            while( (uiMSF & 0xF0000000)==0 ) {
                iExp += 4;
                uiMSF <<= 4;
            }
            while( (uiMSF & 0x80000000)==0 ) {
                iExp++;
                uiMSF <<= 1;
            }
            // discard the most significant one bit (it's presence is built into g_InvQuadRootFraction)
            iExp++;
            // get all 32 bits from source
#           if defined(PLATFORM_OPTIMIZE_MINIMIZE_BRANCHING)
                uiMSF = (U32)((u64Ratio<<iExp)>>32);
#           else
                uiMSF = (iExp>32) ? (U32)(u64Ratio<<(iExp-32)) : (U32)(u64Ratio>>(32-iExp));
#           endif
            // split into top SQRT_FRACTION_TABLE_LOG2_SIZE==8 bits for fractional lookup and bottom bits for interpolation
            iMSF8 = uiMSF>>(32-SQRT_FRACTION_TABLE_LOG2_SIZE);
            uiMSF <<= SQRT_FRACTION_TABLE_LOG2_SIZE;
            // lookup and interpolate
            uiFrac1  = g_SqrtFraction[iMSF8++];   // BP2
            uiFrac1 += MULT_HI_UDWORD( uiMSF,  g_SqrtFraction[iMSF8] - uiFrac1 );
            // adjust by sqrt(1/2) if expoenent is odd
            if ( (iExp+fflt1.iFracBits-fflt2.iFracBits) & 1 ) {
                // multiply by 1/sqrt(2) and adjust fracbits by 1/2
                uiFrac1 = MULT_HI_UDWORD( uiFrac1, UBP0_FROM_FLOAT(0.70710678118654752440084436210485) );
                fflt.iFracBits = ((fflt1.iFracBits-(fflt2.iFracBits+1))>>1)+(iExp-3);
            } else {
                fflt.iFracBits = ((fflt1.iFracBits-fflt2.iFracBits)>>1)+(iExp-3);
            }
            fflt.iFraction = uiFrac1>>1;    // make sure sign is positive
            //// fflt.iFraction*0.5F/(1<<(fflt.iFracBits-1))
			Norm4FastFloatU( &fflt );
#           if defined(_DEBUG) && 0
            {   // old way used float
			    Float flt = (Float)sqrt( FloatFromFastFloat(fflt1) / FloatFromFastFloat(fflt2) );
                if ( fabs( flt - FloatFromFastFloat(fflt) ) > 0.01 ) {
                    DEBUG_BREAK();
                }
            }
#           endif
            return fflt;
#       else
			return (Float)sqrt( fflt1 / fflt2 );
#       endif
    }
#   define FFLT_SQRT_RATIO(fflt1,fflt2) ffltSqrtRatio(fflt1,fflt2)
#endif


// display noise bands used only once
//#define SHOW_NOISE_BANDS
#if defined(_DEBUG) && defined(SHOW_NOISE_BANDS)
    I16 iShown[2049] = { 1, 0 };
#   define SHOW_NOISE_BANDS_ONCE                                    \
        if (iShown[0]==1)                                           \
            memset( iShown, 0, 2049*sizeof(I16) );                  \
        if ((iShown[iEnd-iStart] & paudec->pau->m_cSubband)==0)     \
        {                                                           \
            iShown[iEnd-iStart] |= paudec->pau->m_cSubband;         \
            printf("%4d  %2d  %4d  %4d  %4d  %16.12f\n",            \
                paudec->pau->m_cSubbandAdjusted, iBand,                     \
                iStart, iEnd, iEnd-iStart, 1.0f/(iEnd-iStart) );    \
        }
#else
#   define SHOW_NOISE_BANDS_ONCE
#endif


Void prvGetBandWeightLowRate (CAudioObjectDecoder* paudec)
{
    U8*	rgbBandNotCoded;
    Int iBand;
    Int iStart, iEnd;
    Int iChannel;
	U8 cNoiseBand;
#if 0
    Int i;
    Float fltWeightFactor;
    Float fltInvBandWithd;
#endif
    FUNCTION_PROFILE(fp);
    FUNCTION_PROFILE_START(&fp,GET_BAND_WEIGHTS_PROFILE);

    //calculating band weight
    for (iChannel = 0; iChannel < paudec->pau->m_cChannel; iChannel++)   {
        if (paudec->pau->m_rgpcinfo [iChannel].m_iPower != 0) {
		    FastFloat rgfltBandWeight[25];
			FastFloat* rgffltSqrtBWRatio = paudec->pau->m_rgpcinfo[iChannel].m_rgffltSqrtBWRatio;
            WeightType* rgxWeightFactor  = paudec->pau->m_rgpcinfo[iChannel].INTEGER_OR_INT_FLOAT(m_rguiWeightFactor,m_rgfltWeightFactor);
		    rgbBandNotCoded = paudec->pau->m_rgpcinfo[iChannel].m_rgbBandNotCoded;
		    cNoiseBand = 0;
            iStart = 0, iEnd = 0;
            iBand = paudec->pau->m_iFirstNoiseBand;            
            while (WMAB_TRUE)    {
                iStart = max (paudec->pau->m_iFirstNoiseIndex, paudec->pau->m_rgiBarkIndex [iBand]);
                if (iStart >= paudec->pau->m_cHighCutOff)
                    break;
                assert (iBand < paudec->pau->m_cValidBarkBand);
                iEnd   = min (paudec->pau->m_cHighCutOff, paudec->pau->m_rgiBarkIndex [iBand + 1]);
                assert (iEnd >= iStart);

			    if (rgbBandNotCoded [iBand] == 1)	{
                    // This may be slower than straight divide, but we must do this to
                    // remain consistent with prvGetNoiseLikeBandsMono
                    rgfltBandWeight [cNoiseBand] = FFLT_AVG_SQUARE_WEIGHTS( rgxWeightFactor+iStart, iEnd-iStart );
                    //// rgfltBandWeight[cNoiseBand].iFraction*1.0F/(1<<rgfltBandWeight[cNoiseBand].iFracBits)
					MONITOR_RANGE(gMR_rgfltBandWeight,FLOAT_FROM_FASTFLOAT(rgfltBandWeight[cNoiseBand]));
					MONITOR_COUNT(gMC_GBW_floats,1+(iEnd-iStart)*2 );
				    cNoiseBand++;
			    }
                SHOW_NOISE_BANDS_ONCE;
                iBand++;
		    }
		    assert (cNoiseBand < paudec->pau->m_cValidBarkBand);
		    assert (paudec->pau->m_iFirstNoiseBand > 0);
			for( iBand = 0; iBand < (cNoiseBand-1); iBand++ )
			{	
				// This calculation is not ideally suited to FastFloat, leave in float for time being
				// But note that limited range of the result probably means it can be done more quickly
                rgffltSqrtBWRatio[iBand] = FFLT_SQRT_RATIO( rgfltBandWeight[iBand], rgfltBandWeight[cNoiseBand-1] );
				//// float SqrtBWRatio = fflt.iFraction*1.0F/(1<<fflt.iFracBits)
				MONITOR_RANGE(gMR_rgffltSqrtBWRatio,FLOAT_FROM_FASTFLOAT(rgffltSqrtBWRatio[iBand]));
				MONITOR_COUNT(gMC_GBW_floats,14);		// count sqrt as 10.
			}
			if (cNoiseBand > 0)
			{	// last band has a ratio of 1.0
#if defined(BUILD_INTEGER) || defined(INTEGER_ENCODER)
				rgffltSqrtBWRatio[cNoiseBand-1].iFraction = 0x40000000;
				rgffltSqrtBWRatio[cNoiseBand-1].iFracBits = 30;
#else
				rgffltSqrtBWRatio[cNoiseBand-1] = 1.0F;
#endif
				MONITOR_RANGE(gMR_rgffltSqrtBWRatio,1.0F);
			}
		    rgbBandNotCoded [0] = cNoiseBand; //used as cNoiseBand
        }
    }
    FUNCTION_PROFILE_STOP(&fp);
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\wmalib\wmadec_s\equalizer.c ===
/*************************************************************************

Copyright (C) Microsoft Corporation, 1996 - 1999

Module Name:

    MsAudioDec.cpp

Abstract:

    Implementation of top level functions of CAudioObjectDecoder.

Author:

    Wei-ge Chen (wchen) 14-July-1998

Revision History:


*************************************************************************/
#pragma code_seg("WMADEC")
#pragma data_seg("WMADEC_RW")
#pragma const_seg("WMADEC_RD")

#include "..\..\..\dsound\dsndver.h"

#ifdef ENABLE_EQUALIZER

#include "msaudiodec.h"
#include "macros.h"

WMARESULT audecSetEqualizer (CAudioObjectDecoder* paudec, Int iBand, Int iGainIndB)
{
    if (iBand >= 0 && iBand < MAX_NO_EQBAND && iGainIndB >= MIN_EQ && iGainIndB <= MAX_EQ)  {
        paudec->m_fNoEq = WMAB_FALSE;
        if (iGainIndB != 0) {   
            paudec->m_rgfltEqBandWeight [iBand] = (Float) pow (10, iGainIndB / 20.0);
        }
        else 
            paudec->m_rgfltEqBandWeight [iBand] = 1.0F;
        return WMA_OK;
    }
    else 
        return TraceResult(WMA_E_INVALIDARG);
}

WMARESULT audecResetEqualizer (CAudioObjectDecoder* paudec)
{
    Int i;
    paudec->m_fNoEq = WMAB_TRUE; 
    for (i = 0; i < MAX_NO_EQBAND; i++)
        paudec->m_rgfltEqBandWeight [i] = 1.0F;

    return WMA_OK;
}

WMARESULT prvEqualize (CAudioObjectDecoder* paudec, PerChannelInfo* ppcinfo)
{
    Int i = 0;
    Int iCoef;
    Float fltWeightC = 1.0F;
    Float fltWeightR = 0;
    Int   iWidthR = 0;

    Float fltBandDiffL;
    Float fltBandDiffR;
    Int iWidthOfTransition;

    if (paudec->m_fNoEq)
        return WMA_OK;

    // Calculate first equalizer weighting
    do
    {
        fltWeightR += paudec->m_rgfltEqBandWeight[i];
        i += 1;
    } while (i < paudec->m_cEqBand && paudec->m_rgwEqBandBoundary[i - 1] == paudec->m_rgwEqBandBoundary[i]);
    iWidthR = i;
    fltWeightR /= iWidthR; // Average all the EQ gains

    // Apply each equalizer band's weighting to the desired coefficients
    for (i = 0; i < paudec->m_cEqBand; ) {
        Float fltWeightL;
        Float fltWeight;
        Int   iWidthC;

        // Shift weightings and widths down from right to left
        fltWeightL = fltWeightC;
        fltWeightC = fltWeightR;
        iWidthC = iWidthR;
        assert(iWidthC > 0);

        // Calculate next band's weight and width (one or more EQ bands may live
        // in one coefficient bin if frame size is small)
        if (i + iWidthC >= paudec->m_cEqBand)
        {
            fltWeightR = 1.0F;
            iWidthR = 0;
        }
        else
        {
            Int j = i + iWidthC;
            fltWeightR = 0;
            do
            {
                fltWeightR += paudec->m_rgfltEqBandWeight[j];
                j += 1;
            } while (j < paudec->m_cEqBand && paudec->m_rgwEqBandBoundary[j - 1] == paudec->m_rgwEqBandBoundary[j]);
            iWidthR = j - (i + iWidthC);
            fltWeightR /= iWidthR; // Average all the EQ gains
        }


        // EQUALIZE
        fltBandDiffL = fltWeightC - fltWeightL;
        fltBandDiffR = fltWeightC - fltWeightR;
        iWidthOfTransition = min (5, (paudec->m_rgwEqBandBoundary [i + iWidthC] -
            paudec->m_rgwEqBandBoundary [i]) / 4);

        for (iCoef = paudec->m_rgwEqBandBoundary [i];
            iCoef < paudec->m_rgwEqBandBoundary [i + iWidthC]; iCoef++)
        {
            if (iCoef - paudec->m_rgwEqBandBoundary [i] < iWidthOfTransition)
            {
                fltWeight = fltWeightC - (iWidthOfTransition - 1 - (iCoef -
                    paudec->m_rgwEqBandBoundary [i])) * fltBandDiffL / iWidthOfTransition;
            }
            else if (paudec->m_rgwEqBandBoundary [i + iWidthC] - iCoef <= iWidthOfTransition)
            {
                fltWeight = fltWeightC - (iWidthOfTransition -
                    (paudec->m_rgwEqBandBoundary [i + iWidthC] - iCoef)) *
                    fltBandDiffR / iWidthOfTransition;
            }
            else
                fltWeight = fltWeightC;

            ppcinfo->m_rgfltCoefRecon [iCoef] *= fltWeight;
        }

        // Advance indices
        i += iWidthC;

    } // for

    return WMA_OK;
}

Void    prvComputeBandPower (CAudioObjectDecoder* paudec)
{
    Int i;
    Float fltPower = 0;
    Int   iWidthC;
    Int   j;
    Int   iCoef;
    Float fltPwrOffset;

    for (i = 0; i < paudec->m_cEqBand; )
    {
        fltPower = 0;

        // Figure out width of this EQ band (more than one EQ band
        // may map to a single coefficient if frame size is small)
        j = i + 1;
        while (j < paudec->m_cEqBand && paudec->m_rgwEqBandBoundary[j - 1] == paudec->m_rgwEqBandBoundary[j])
            j++;
        iWidthC = j - i;

        // Calculate power of all coefficients within this EQ band
        for (iCoef = paudec->m_rgwEqBandBoundary [i];
            iCoef < paudec->m_rgwEqBandBoundary [i + iWidthC]; iCoef++)
        {
            fltPower += paudec->pau->m_rgpcinfo[0].m_rgfltCoefRecon[iCoef] *
                        paudec->pau->m_rgpcinfo[0].m_rgfltCoefRecon[iCoef];

            if (paudec->pau->m_cChannel > 1)
            {
                assert (paudec->pau->m_cChannel == 2);
                fltPower += paudec->pau->m_rgpcinfo[1].m_rgfltCoefRecon[iCoef] *
                            paudec->pau->m_rgpcinfo[1].m_rgfltCoefRecon[iCoef];
            }
        } // for

        // Record the power in one or more EQ bands
        assert (fltPower >= 0);

        // Fwd transform used to scale coefficients by sqrt(2/paudec->pau->m_cSubband),
        // but now does not so we must explicitly scale
        fltPwrOffset = (Float) (10 * log10(2.0F / paudec->pau->m_cSubband));
        for (j = i; j < i + iWidthC; j++)
        {
            fltPower = fltPwrOffset + (Float)(10*log10(fltPower));
            paudec->m_rgbBandPower[j] = (I8) checkRange (fltPower, SCHAR_MIN, SCHAR_MAX);
        }

        // Advance indices
        i += iWidthC;

    } // for
} // computeBandPower

WMARESULT audecGetBandPower (CAudioObjectDecoder* paudec, I8* rgbBandPower)
{
    rgbBandPower [0] = paudec->m_cEqBand;
    memcpy (rgbBandPower + 1, paudec->m_rgbBandPower, sizeof (I8) * MAX_NO_EQBAND);
    return WMA_OK;
}

Void    audecStartComputeBandPower (CAudioObjectDecoder* paudec)
{
    paudec->m_fComputeBandPower = WMAB_TRUE;
}

Void    audecStopComputeBandPower (CAudioObjectDecoder* paudec)
{
    paudec->m_fComputeBandPower = WMAB_FALSE;
}

Void    prvAdaptEqToSubFrame(CAudioObjectDecoder* paudec)
{
    Int i;
    // Set up the equalizer, if it needs it
    if (WMAB_FALSE == paudec->m_fNoEq && paudec->m_iEqFrameSize != paudec->pau->m_cSubFrameSampleAdjusted)
    {
        const static U16 rgwEqBandFreq [MAX_NO_EQBAND + 1] = {0, 50, 100, 200, 400, 800,
            1600, 3200, 6400, 12800, 24100};   //make sure the last one is beyond the end

        const Float fltSamplingPeriod = 1.0F / paudec->pau->m_iSamplingRate;

        paudec->m_iEqFrameSize = paudec->pau->m_cSubFrameSampleAdjusted;
        paudec->m_rgwEqBandBoundary [0] = 0;
        for (i = 0; i < MAX_NO_EQBAND; i++) {
            paudec->m_rgwEqBandBoundary [i + 1] = (U16) (rgwEqBandFreq [i + 1] *
                paudec->pau->m_cSubFrameSampleAdjusted * fltSamplingPeriod + 0.5f); //open end

            // Note that is is possible for consecutive elements of
            // paudec->m_rgwEqBandBoundary to have the same value, especially
            // in the case of small frames!

            if (paudec->m_rgwEqBandBoundary [i + 1] > paudec->pau->m_cSubbandAdjusted)    {
                paudec->m_rgwEqBandBoundary [i + 1] = (U16) paudec->pau->m_cSubbandAdjusted;
                paudec->m_cEqBand = i + 1;
                break;
            }
        } // for
    } // if
}
#endif //ENABLE_EQUALIZER
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\wmalib\wmadec_s\fft.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows Media
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       fft.c
//
//  The FFT used for the DctIV and DctIV
//
//--------------------------------------------------------------------------

#pragma code_seg("WMADEC")
#pragma data_seg("WMADEC_RW")
#pragma const_seg("WMADEC_RD")

#include <math.h>
//#include <assert_wma.h>
#include <stdio.h>
#include <limits.h>
#include "msaudio.h"
#include "macros.h"
#include "AutoProfile.h"
#include "..\..\..\dsound\dsndver.h"

// Define to get Split Radix FFt algorithm - which is expected to be 30% faster than Radix 2
//#define SPLIT_RADIX_FFT

#if defined(WMA_TARGET_MIPS) && defined(BUILD_INTEGER)


// Now separately build each processor
//#    include "../mips/transform_mips.c"

#elif ( defined(WMA_TARGET_SH3) || defined(WMA_TARGET_SH4) ) && defined(BUILD_INTEGER)

// Now separately build each processor
//#    include "../sh3/transform_sh3.c"

#elif defined(WMA_TARGET_SH4) && defined(BUILD_INT_FLOAT)

// Now separately build each processor
//#    include "../sh4/transform_sh4.c"

#else

// Some Algorithm Counters to match to journal article operation counts
#if defined(_DEBUG) && 0

    static int cButterfly0 = 0;         // R2 butterfly with no multiplies
    static int cButterfly1 = 0;         // R4 butterfly with no multiplies
    static int cButterfly2 = 0;         // R2 or R4 butterfly with a complex multiply
    static int cTrig  = 0;              // number of sin/cos recursions
    static int cAdditions = 0;          // number of Data additions (float or I32)
    static int cMultiplications = 0;    // number of Data mutliplications (float or I32)
    static int cIndexing = 0;           // count array indexing/incrementing
    static int cLoops = 0;              // count loops
    static int cLoopIndexing = 0;       // count extra loop indexing operations
    static int cTrigAdditions = 0;      // Additions for trig recursions
    static int cTrigMultiplications = 0; // multiplications for trig recursions

#   define DEBUG_COUNT_BTFLY0(a,m,i) cButterfly0++; cAdditions += a; cMultiplications += m; cIndexing += i;
#   define DEBUG_COUNT_BTFLY1(a,m,i) cButterfly1++; cAdditions += a; cMultiplications += m; cIndexing += i;
#   define DEBUG_COUNT_BTFLY2(a,m,i) cButterfly2++; cAdditions += a; cMultiplications += m; cIndexing += i;
#   define DEBUG_COUNT_TRIG(a,m)     cTrig++;  cTrigAdditions += a;  cTrigMultiplications += m;
#   define DEBUG_COUNT_LOOP(i)       cLoops++; cLoopIndexing += i;

#else // _DEBUG

#   define DEBUG_COUNT_BTFLY0(a,m,i)
#   define DEBUG_COUNT_BTFLY1(a,m,i)
#   define DEBUG_COUNT_BTFLY2(a,m,i)
#   define DEBUG_COUNT_TRIG(a,m)
#   define DEBUG_COUNT_LOOP(i)

#endif // _DEBUG

static const double dPI = PI;       // 3.1415926535897932384626433832795;

// the following defines do most of the computational work of the FFT, so they should be done efficently
// note need ur and ui to be defined unless assembly routines which should not need them
// note pointers will be incremented as a side effect of these macros
// define these in assembly for any processor whose compiler needs further optimization

#if !defined(SPLIT_RADIX_FFT)


#define FFTBUTTERFLY0(pxk,pxi) \
/* Butterfly at angle == 0 */ \
    ur = *pxk - *pxi;               /* ur = px[k] - px[i];      */ \
    *pxk++ += *pxi;                 /* px[k]   += px[i];        */ \
    *pxi++ = ur;                    /* px[i]   = ur;            */ \
    ui = *pxk - *pxi;               /* ui = px[k+1] - px[i+1];  */ \
    *pxk++ += *pxi;                 /* px[k+1] += px[i+1];      */ \
    *pxi++ = ui;                    /* px[i+1] = ui;            */
// leave pxi and pxk incremented by 2
// The SH-3 compiler generates very good code for fftbutterfly0

#define FFTBUTTERFLY(pxk,pxi,CR,SI)     \
/* Butterfly at a non-zero angle */     \
    ur = *pxk - *pxi;           /* ur = px[k] - px[i];    */ \
    *pxk++ += *pxi++;           /* px[k]   += px[i];      */ \
    ui = *pxk - *pxi;           /* ui = px[k+1] - px[i+1];*/ \
    *pxk++ += *pxi--;           /* px[k+1] += px[i+1];    */ \
    *pxi++ = MULT_BP2(CR,ur) - MULT_BP2(SI,ui);  /* px[i]   = cr * ur - (si) * ui; */ \
    *pxi++ = MULT_BP2(CR,ui) + MULT_BP2(SI,ur);  /* px[i+1] = cr * ui + (si) * ur; */ \
// leave pxi and pxk incremented by 2

// *************************************************************************************
// Spilt radix inverse FFT which scales by 2/N in a step-wise fashion
// *************************************************************************************

#if defined(BUILD_INTEGER) || defined(INTEGER_ENCODER)

#define FFTBUTTERFLY0_N(pxk,pxi) \
/* Butterfly at angle == 0 with inputs divided by 2*/ \
    ur = (tk = *pxk>>1) - (ti = *pxi>>1);   /* ur = px[k] - px[i];      */ \
    *pxk++ = tk + ti;                       /* px[k]   += px[i];        */ \
    *pxi++ = ur;                            /* px[i]   = ur;            */ \
    ui = (tk = *pxk>>1) - (ti = *pxi>>1);   /* ui = px[k+1] - px[i+1];  */ \
    *pxk++ = tk + ti;                       /* px[k+1] += px[i+1];      */ \
    *pxi++ = ui;                    /* px[i+1] = ui;            */
// leave pxi and pxk incremented by 2
// The SH-3 compiler generates very good code for fftbutterfly0

#define FFTBUTTERFLY_N(pxk,pxi,CR,SI)       \
/* Butterfly at a non-zero angle with inputs divided by 2*/     \
    ur = (tk = *pxk>>1) - (ti = *pxi++>>1); /* ur = px[k] - px[i];    */ \
    *pxk++ = tk + ti;                       /* px[k]   += px[i];      */ \
    ui = (tk = *pxk>>1) - (ti = *pxi-->>1); /* ui = px[k+1] - px[i+1];*/ \
    *pxk++ = tk + ti;                       /* px[k+1] += px[i+1];    */ \
    *pxi++ = MULT_BP2(CR,ur) - MULT_BP2(SI,ui);  /* px[i]   = cr * ur - (si) * ui; */ \
    *pxi++ = MULT_BP2(CR,ui) + MULT_BP2(SI,ur);  /* px[i+1] = cr * ui + (si) * ur; */ \
// leave pxi and pxk incremented by 2

#else // must be BUILD_INT_FLOAT

#define FFTBUTTERFLY0_N(pxk,pxi) FFTBUTTERFLY0(pxk,pxi)

#define FFTBUTTERFLY_N(pxk,pxi,CR,SI) FFTBUTTERFLY(pxk,pxi,CR,SI)

#endif

#ifndef _M_IX86
// the following tables save floating point conversions and trig function calls
// compiler is unwilling to evaluate a constant expression of the form cos(PI/4) as a constant
static const BP1Type icosPIbynp[16] = { 
        BP1_FROM_FLOAT(-0.999999999999996),   // cos(dPI/1)
        BP1_FROM_FLOAT(-0.000000043711390),   // cos(dPI/2)
        BP1_FROM_FLOAT(0.707106765732237),    // cos(dPI/4)
        BP1_FROM_FLOAT(0.923879528329380),    // cos(dPI/8)
        BP1_FROM_FLOAT(0.980785279337272),    // cos(dPI/16)
        BP1_FROM_FLOAT(0.995184726404418),    // cos(dPI/32)
        BP1_FROM_FLOAT(0.998795456138147),    // cos(dPI/64)
        BP1_FROM_FLOAT(0.999698818679443),    // cos(dPI/128)
        BP1_FROM_FLOAT(0.999924701834954),    // cos(dPI/256)
        BP1_FROM_FLOAT(0.999981175281554),    // cos(dPI/512)
        BP1_FROM_FLOAT(0.999995293809314),    // cos(dPI/1024)
        BP1_FROM_FLOAT(0.999998823451636),    // cos(dPI/2048)
        BP1_FROM_FLOAT(0.999999705862866),    // cos(dPI/4096)
        BP1_FROM_FLOAT(0.999999926465714),    // cos(dPI/8192)
        BP1_FROM_FLOAT(0.999999981616428),    // cos(dPI/16384)
        BP1_FROM_FLOAT(0.999999995404107) };  // cos(dPI/32768)
static const BP1Type isinPIbynp[16] = { 
        BP1_FROM_FLOAT(0.000000087422780),    // sin(-dPI/1)
        BP1_FROM_FLOAT(-0.999999999999999),   // sin(-dPI/2)
        BP1_FROM_FLOAT(-0.707106796640858),   // sin(-dPI/4)
        BP1_FROM_FLOAT(-0.382683442461104),   // sin(-dPI/8)
        BP1_FROM_FLOAT(-0.195090327375064),   // sin(-dPI/16)
        BP1_FROM_FLOAT(-0.098017143048367),   // sin(-dPI/32)
        BP1_FROM_FLOAT(-0.049067675691754),   // sin(-dPI/64)
        BP1_FROM_FLOAT(-0.024541229205697),   // sin(-dPI/128)
        BP1_FROM_FLOAT(-0.012271538627189),   // sin(-dPI/256)
        BP1_FROM_FLOAT(-0.006135884819899),   // sin(-dPI/512)
        BP1_FROM_FLOAT(-0.003067956848339),   // sin(-dPI/1024)
        BP1_FROM_FLOAT(-0.001533980228972),   // sin(-dPI/2048)
        BP1_FROM_FLOAT(-0.000766990340086),   // sin(-dPI/4096)
        BP1_FROM_FLOAT(-0.000383495198243),   // sin(-dPI/8192)
        BP1_FROM_FLOAT(-0.000191747602647),   // sin(-dPI/16384)
        BP1_FROM_FLOAT(-0.000095873801764) }; // sin(-dPI/32768)
#endif // _M_IX86


// *************************************************************************************
//  Radix 2 FFT
//  when BUILD_INTEGER, does a scale by 2/N FFT
//  when BUILD_INT_FLOAT, does a regular FFT
// *************************************************************************************

        
void prvFFT4DCT(CoefType data[], Int nLog2np)
{
    I32 np = (1<<nLog2np);
    CoefType *px = data;
    I32 i, j, k, l, m, n;
    CoefType *pxk, *pxi;
    CoefType ur, ui;
#if defined(BUILD_INTEGER) || defined(INTEGER_ENCODER)
    CoefType tk, ti;
#endif

    // defining the following COSSIN structure allows us to pass a pointer to a set of values in asm code
    // but WinCE/SH-3 compiler seems to do a particularly bad job of optimizing access to structure members!
    // struct COSSIN { I32 CR2,SI2,CR1,SI1,STEP,CR,SI;  } cs;
    BP2Type CR2,SI2,CR1,SI1,STEP,CR,SI;
    FUNCTION_PROFILE(fp);
    FUNCTION_PROFILE_START(&fp,FFT_PROFILE);

#ifdef _M_IX86
    // Pentium sin/cos are fast
    CR = BP2_FROM_FLOAT(cos(dPI/np));
    STEP = BP2_FROM_FLOAT(2*sin(-dPI/np));
#else // _M_IX86
    // other platforms' sin/cos unlikely to be that optimized, so do lookup
    {
        if ( nLog2np < 16 )
        {
            CR = BP2_FROM_BP1(icosPIbynp[nLog2np]);         // CR = (I32)(cos(PI/np) * NF2BP2)
#ifdef BUILD_INTEGER
            STEP = isinPIbynp[nLog2np];                     // STEP = (I32)(2*sin(-PI/np) * NF2BP2)
#else
            STEP = BP2_FROM_FLOAT(2*isinPIbynp[nLog2np]);   // STEP = (I32)(2*sin(-PI/np) * NF2BP2)
#endif
        }
        else
        {
            CR = BP2_FROM_FLOAT(cos(dPI/np));
            STEP = BP2_FROM_FLOAT(2*sin(-dPI/np));
        }
    }
#endif // _M_IX86
    SI = DIV2(STEP);                                    // SI = (I32)(sin(-PI/np) * NF2BP2)

    ///  comments with three /// show example indexing sequences for np=1024 and times the loop is executed [1x]

    n = 2 * np;                             /// n: 2048
    m = n;

    while (m > 4) {                         /// m: {2048, ... 16, 8} [9x]
        l = m >> 1;
        CR2 = BP2_FROM_FLOAT(1);                                // cos(0)
        SI2 = 0;                                                // sin(0)
        CR1 = BP2_FROM_FLOAT(1) - MULT_BP2(STEP,SI);    // cos(2*2*PI/m)
        SI = SI1 = MULT_BP2(STEP,CR);                   // sin(2*2*PI/m)
        CR = CR1;
        STEP = MUL2(SI1);

        // Trivial butterflies (angle = 0) 
        for (k = 0; k < n; k += m) {        /// k: {0} {0,1024} ... {0,8,16...2044} [512x]
            i = k + l;                      /// i: {1024} {1024,2048} ... {4,12,20...2040}
            pxk = &px[k];
            pxi = &px[i];
            // +1/-1 butterfly 
            FFTBUTTERFLY0_N(pxk,pxi);                   // update px[i], px[i+1] and px[k], px[k+1], leave pointers +2
             // +1/-1/W_k butterfly 
            FFTBUTTERFLY_N(pxk,pxi,CR1,SI1);    // update px[i+2], px[i+2+1] and px[k+2], px[k+2+1], leave pointers +2
            /* Butterfly at a non-zero angle */ 
            //  ur = *pxk - *pxi;           /* ur = px[k] - px[i];    */ \
            //  *pxk++ += *pxi++;           /* px[k]   += px[i];      */ \
            //  ui = *pxk - *pxi;           /* ui = px[k+1] - px[i+1];*/ \
            //  *pxk++ += *pxi--;           /* px[k+1] += px[i+1];    */ \
            //  *pxi++ = MULT_BP2(CR,ur) - MULT_BP2(SI,ui);  /* px[i]   = cr * ur - (si) * ui; */ \
            //  *pxi++ = MULT_BP2(CR,ui) + MULT_BP2(SI,ur);  /* px[i+1] = cr * ui + (si) * ur; */ \
            // leave pxi and pxk incremented by 2
            DEBUG_COUNT_BTFLY0(4,0,4);
            DEBUG_COUNT_BTFLY1(6,4,6);
        }
        // Nontrivial butterflies 
        for (j = 4; j < l; j += 4) {        /// j: {4,8...1020} {4,8,...510} ... {4} {} [~510x]

            // recurrsion to next sin and cosine values where Theta = 2*PI/m;
            // CR2 = cos(-j*Theta);  SI2 = sin(-j*Theta); CR1 = cos((-j-2)*Theta); SI1 = sin((-j-2)*Theta);
            // recursion: cos(a-2b) = cos(a) - 2*sin(b)*cos(a-b)
            // and:       sin(a-2b) = sin(a) + 2*sin(b)*sin(a-b)
            CR2 -= MULT_BP2(STEP,SI1);
            SI2 += MULT_BP2(STEP,CR1);
            CR1 -= MULT_BP2(STEP,SI2);
            SI1 += MULT_BP2(STEP,CR2);

            // do main butterflies
            for (k = j; k <= n; k += m) {   /// k: {{4}{8}...{1020}} {{4,1028}{8,1032}...{508,1020}} ... {{4,20...2044}} [2048x]
                pxk = &px[k];
                pxi = &px[k + l];
                // +1/-1/W_k butterfly 
                FFTBUTTERFLY_N(pxk,pxi,CR2,SI2);        // update px[i], px[i+1] and px[k], px[k+1], leave pointers at +2
                // +1/-1/W_k butterfly 
                FFTBUTTERFLY_N(pxk,pxi,CR1,SI1);        // update px[i+2], px[i+2+1] and px[k+2], px[k+2+1], leave pointers at +2
                /* Butterfly at a non-zero angle */     \
                //  ur = *pxk - *pxi;           /* ur = px[k] - px[i];    */ \
                //  *pxk++ += *pxi++;           /* px[k]   += px[i];      */ \
                //  ui = *pxk - *pxi;           /* ui = px[k+1] - px[i+1];*/ \
                //  *pxk++ += *pxi--;           /* px[k+1] += px[i+1];    */ \
                //  *pxi++ = MULT_BP2(CR,ur) - MULT_BP2(SI,ui);  /* px[i]   = cr * ur - (si) * ui; */ \
                //  *pxi++ = MULT_BP2(CR,ui) + MULT_BP2(SI,ur);  /* px[i+1] = cr * ui + (si) * ur; */ \
                // leave pxi and pxk incremented by 2
                DEBUG_COUNT_BTFLY1(6,4,6);
                DEBUG_COUNT_BTFLY1(6,4,6);
                DEBUG_COUNT_LOOP(2);
            }
            DEBUG_COUNT_TRIG(2,2);
            DEBUG_COUNT_TRIG(2,2);
            DEBUG_COUNT_LOOP(2);
        }
        m  = l;
        DEBUG_COUNT_TRIG(2,2);
        DEBUG_COUNT_LOOP(2);
    }
    if (m > 2) {
        // m normally exits the loop above == 4, so normally do this except when called with np = 1 or 2
        for (j = 0; j < n; j += 4) {        /// j: {0,4...2044}  [512x]
            pxi = (pxk = px+j) + 2;
            
            // +1/-1 butterfly 
            FFTBUTTERFLY0(pxk,pxi);
            DEBUG_COUNT_BTFLY0(4,0,4);
            DEBUG_COUNT_LOOP(2);
        }
    }
    if (n > 4) {
        I32 n2, n21;
        CoefType tmp;

        n2 = np / 2;                        /// n2: 512
        n21 = np + 1;                       /// n21: 1025
        j = 0;                              
        for (i = 0; i < np; i += 4) {       /// i,j: 0,0; 4,1024; 8,512; 12,1536; ... 2044,??? [255x]

            if (i < j) {
                // swap 4 pairs of values (2 complex pairs with 2 others)
                // px[i] <-> px[j]; px[i+1] <-> px[j+1]
                // px[i+1+n21] <-> px[j+1+n21];  px[i+1+n21+1] <-> px[j+1+n21+1]
                pxi = &px[i];
                pxk = &px[j];
                tmp = *pxi; 
                *pxi++ = *pxk;
                *pxk++ = tmp;
                tmp = *pxi;
                *pxi = *pxk;
                *pxk = tmp;
                pxi  += n21;
                pxk  += n21;
                tmp = *pxi;
                *pxi++ = *pxk;
                *pxk++ = tmp;
                tmp = *pxi;
                *pxi = *pxk;
                *pxk = tmp;
            }

            // swap 2 pairs of values (1 complex pair with another)
            // px[i+2] <-> px[j+np];  px[i+3] <-> px[j+np+1]
            pxi = &px[i+2];
            pxk = &px[j+np];
            tmp = *pxi; 
            *pxi++ = *pxk;
            *pxk++ = tmp;
            tmp = *pxi;
            *pxi = *pxk;
            *pxk = tmp;

            k = n2;                         
            while (k <= j) {                /// k: {1024} {1024,512} {1024} {1024,512,256} ...
                j -= k;
                k = k / 2;
            }
            j += k;                         /// j: {1024} {512} {1536} {256} ...
        }
    }
    FUNCTION_PROFILE_STOP(&fp);
}

#else // so must be SPLIT_RADIX_FFT

//****************************************************************************************************************
//
// A Split Radix FFT for the DCT -
// See WMAConcepts.xls - Sheet SRFFT32 for how this works.
// See also Sorensen & Heldeman, IEEE Trans ASSP, Vol ASSP-34, #1, 2/86, pp152-156.
// And also G. M. Blair, Electronics & Comm Engr Journal, August 1995, pp169-177.
//
//****************************************************************************************************************

#define BP2Const6(a,b,c,d,e,f) BP2_FROM_FLOAT(a),BP2_FROM_FLOAT(b),BP2_FROM_FLOAT(c), \
                               BP2_FROM_FLOAT(d),BP2_FROM_FLOAT(e),BP2_FROM_FLOAT(f)

static const BP2Type rgcbp2SrFFTTrig[] = {
//        STEP1             STEP3       
//        2sin(2pi/2^k) Cos(2pi/2^k)  Sin(2pi/2^k)  2sin(6pi/2^k)  Cos(6pi/2^k)  Sin(6pi/2^k)
BP2Const6(1.41421356237,0.70710678119,0.70710678119,1.41421356237,-0.70710678119,0.70710678119),    // K=3
BP2Const6(0.76536686473,0.92387953251,0.38268343237,1.84775906502, 0.38268343237,0.92387953251),    // K=4
BP2Const6(0.39018064403,0.98078528040,0.19509032202,1.11114046604, 0.83146961230,0.55557023302),    // K=5
BP2Const6(0.19603428066,0.99518472667,0.09801714033,0.58056935451, 0.95694033573,0.29028467725),    // K=6
BP2Const6(0.09813534865,0.99879545621,0.04906767433,0.29346094891, 0.98917650996,0.14673047446),    // k=7
BP2Const6(0.04908245705,0.99969881870,0.02454122852,0.14712912720, 0.99729045668,0.07356456360),    // k=8
BP2Const6(0.02454307657,0.99992470184,0.01227153829,0.07361444588, 0.99932238459,0.03680722294),    // k=9
BP2Const6(0.01227176930,0.99998117528,0.00613588465,0.03681345981, 0.99983058180,0.01840672991),    // k=10
BP2Const6(0.00613591353,0.99999529381,0.00306795676,0.01840750956, 0.99995764455,0.00920375478),    // k=11
BP2Const6(0.00306796037,0.99999882345,0.00153398019,0.00920385224, 0.99998941108,0.00460192612),    // k=12
BP2Const6(0.00153398064,0.99999970586,0.00076699032,0.00460193830, 0.99999735277,0.00230096915),    // k=13
BP2Const6(0.00076699038,0.99999992647,0.00038349519,0.00230097067, 0.99999933819,0.00115048534),    // k=14
BP2Const6(0.00038349519,0.99999998162,0.00019174760,0.00115048553, 0.99999983455,0.00057524276),    // k=15
BP2Const6(0.00019174760,0.99999999540,0.00009587380,0.00057524279, 0.99999995864,0.00028762139),    // k=16
0,0,0,0,0,0 };


#if defined(_DEBUG) && 0
// some code to show looping 
FILE* fileFFTDump = NULL;
Int* pFFTIndex = NULL;
#define DUMP_FFT_OPEN(msg,np)                          \
    if (fileFFTDump == NULL )                          \
        fileFFTDump = fopen("DUMP_FFT.TXT","wt");      \
    if (fileFFTDump != NULL )                          \
        fprintf( fileFFTDump, msg, np );               \
    pFFTIndex = realloc(pFFTIndex,2*np*sizeof(Int));   \
    memset( pFFTIndex,0,2*np*sizeof(Int));
#define DUMP_FFT_SET(i,v) pFFTIndex[i] = v;
#define DUMP_FFT_SHOW(msg,k,np)                         \
    {   int i;                                          \
        if (fileFFTDump != NULL ) {                     \
            fprintf( fileFFTDump, msg, k, np );         \
            for( i=0; i<2*np; i += 2 ) {                \
                fprintf( fileFFTDump, "%d,  %d,\n",     \
                    i, pFFTIndex[i] );                  \
            }                                           \
        }                                               \
        memset( pFFTIndex, 0, 2*np*sizeof(Int) );       \
    }
#else
#define DUMP_FFT_OPEN(msg,np)
#define DUMP_FFT_SET(i,v)
#define DUMP_FFT_SHOW(msg,k,np)
#endif

#ifdef BUILD_INTEGER
#   define INTDIV2(a) ((a)>>1)
#else
#   define INTDIV2(a) (a)
#endif

void prvFFT4DCT(CoefType data[], Int nLog2np)
{
    Int np = (1<<nLog2np);
    Int np2 = np<<1;
    Int np2m7 = np2-7;
    CoefType *pxk, *pxi, *px0, *px1, *px2, *px3;
    CoefType *px = data;
    I32 i, j, k, iOffset, iStride, iStridem1;
    Int n2k, n2km1, n2km2, n2kp2, idx;
    CoefType tmp, ur0, ui0, ur1, ui1;
    BP2Type bp2Step1, bp2Cos1, bp2Sin1, bp2Step3, bp2Cos3, bp2Sin3;
    BP2Type bp2Cos1p, bp2Sin1p, bp2Cos3p, bp2Sin3p;
    BP2Type bp2Cos1T, bp2Sin1T, bp2Cos3T, bp2Sin3T;
    CoefType ur2, ui2, ur3, ui3, urp, uip, urm, uim;
    const BP2Type* pbp2Trig = rgcbp2SrFFTTrig;
    INTEGER_ONLY( Int n2kp1; )

    FUNCTION_PROFILE(fp);
    FUNCTION_PROFILE_START(&fp,FFT_PROFILE);
    DUMP_FFT_OPEN("//FFT np = %d\n", np );

    // bit reverse (same code as Radix 2)
    if (np > 2) {
        I32 n2, n21;

        n2 = np / 2;                        /// n2: 512
        n21 = np + 1;                       /// n21: 1025
        j = 0;                              
        for (i = 0; i < np; i += 4) {       /// i,j: 0,0; 4,1024; 8,512; 12,1536; ... 2044,??? [255x]

            if (i < j) {
                // swap 4 pairs of values (2 complex pairs with 2 others)
                // px[i] <-> px[j]; px[i+1] <-> px[j+1]
                // px[i+1+n21] <-> px[j+1+n21];  px[i+1+n21+1] <-> px[j+1+n21+1]
                pxi = &px[i];
                pxk = &px[j];
                tmp = *pxi; 
                *pxi++ = *pxk;
                *pxk++ = tmp;
                tmp = *pxi;
                *pxi = *pxk;
                *pxk = tmp;
                pxi  += n21;
                pxk  += n21;
                tmp = *pxi;
                *pxi++ = *pxk;
                *pxk++ = tmp;
                tmp = *pxi;
                *pxi = *pxk;
                *pxk = tmp;
            }

            // swap 2 pairs of values (1 complex pair with another)
            // px[i+2] <-> px[j+np];  px[i+3] <-> px[j+np+1]
            pxi = &px[i+2];
            pxk = &px[j+np];
            tmp = *pxi; 
            *pxi++ = *pxk;
            *pxk++ = tmp;
            tmp = *pxi;
            *pxi = *pxk;
            *pxk = tmp;

            k = n2;                         
            while (k <= j) {                /// k: {1024} {1024,512} {1024} {1024,512,256} ...
                j -= k;
                k = k / 2;
            }
            j += k;                         /// j: {1024} {512} {1536} {256} ...
        }
    }
 
    // Length 2 butterflies
    for( iOffset = 0, iStride = 8; 
            iOffset < np2; 
                iOffset = (iStride<<1) - 4, iStride <<= 2 )
    {
        iStridem1 = iStride-1;
        for( idx = iOffset, px1 = (px0 = px+iOffset) + 2;
                idx < np2; 
                    idx += iStride, px0 += iStridem1, px1 += iStridem1 )
        {
            ur0 = *px0;
            ur1 = *px1; 
            *px0++ = ur0 + ur1;
            *px1++ = ur0 - ur1;
            ui0 = *px0;
            ui1 = *px1; 
            *px0 = ui0 + ui1;
            *px1 = ui0 - ui1;
            DUMP_FFT_SET(idx,2);
            DUMP_FFT_SET(idx+2,1);
            DEBUG_COUNT_BTFLY0(4,0,4);
            DEBUG_COUNT_LOOP(2);
        }
        DEBUG_COUNT_LOOP(6);
    }
    DUMP_FFT_SHOW("k = %d.\n", 1, np );

    // Radix 4 like Butterflies - either with ot without multiplies
    n2k = 2;
    for( k=2; k<=nLog2np; k++ )
    {
        n2k <<= 1;
        n2km1 = n2k>>1;
        n2km2 = n2k>>2;
        n2kp2 = n2k<<2;
#ifdef BUILD_INTEGER
        n2kp1 = n2k<<1;
        // we must scale all the px's by 2 that will not be accessed in the remainder of this main loop
        for( iOffset = n2kp1, iStride = n2k<<3; 
                iOffset < np2; 
                    iOffset = (iStride<<1) - n2kp1, iStride <<= 2 )
        {
            for( idx = iOffset; idx < np2; idx += iStride )
            {
                for( i = 0, px0 = px+idx; i < n2kp1; i++ )
                    *px0++ >>= 1;
            }
        }
#endif 
        // Trivial Butterflies - j==0 - no multiplies since Cos==1 and Sin==0
        for( iOffset = 0, iStride = n2kp2; 
                iOffset < np2; 
                    iOffset = (iStride - n2k)<<1, iStride <<= 2 )
        {
            px3 = (px2 = (px1 = (px0 = px+iOffset) + n2km1) + n2km1) + n2km1;
            iStridem1 = iStride-1;
            for( idx = iOffset; 
                    idx < np2m7; 
                        idx += iStride, px0 += iStridem1, px1 += iStridem1, px2 += iStridem1, px3 += iStridem1 )
            {
                urp = (ur0=INTDIV2(*px2++)) + (ur1=INTDIV2(*px3++));
                urm = ur0 - ur1;
                uip = (ui0=INTDIV2(*px2--)) + (ui1=INTDIV2(*px3--));
                uim = ui0 - ui1;
                *px2++  = (ur0 = INTDIV2(*px0)) - urp;
                *px0++  = ur0 + urp;
                *px3++  = (ur1 = INTDIV2(*px1)) - uim;
                *px1++  = ur1 + uim;
                *px2    = (ui0 = INTDIV2(*px0)) - uip;
                *px0    = ui0 + uip;
                *px3    = (ui1 = INTDIV2(*px1)) + urm;
                *px1    = ui1 - urm;
                DUMP_FFT_SET(idx,3);
                DUMP_FFT_SET(idx+n2km1,1);
                DUMP_FFT_SET(idx+2*n2km1,1);
                DUMP_FFT_SET(idx+3*n2km1,1);
                DEBUG_COUNT_BTFLY1(12,0,12);
                DEBUG_COUNT_LOOP(2);
            }
            DEBUG_COUNT_LOOP(9);
        }
        // Now the non-trivial butterflies
        if ( n2km2 > 1 )
        {
            if ( *pbp2Trig != 0 )
            {   // normal case with k <= 16
                bp2Step1 = *pbp2Trig++;     // 2*sin(2*pi/2^k)
                bp2Cos1  = *pbp2Trig++;     // cos(2*pi/2^k) 
                bp2Sin1  = *pbp2Trig++;     // sin(2*pi/2^k)
                bp2Step3 = *pbp2Trig++;     // 2*sin(6*pi/2^k)
                bp2Cos3  = *pbp2Trig++;     // cos(6*pi/2^k) 
                bp2Sin3  = *pbp2Trig++;     // sin(6*pi/2^k)
            }
            else
            {   // k > 16 is not normal - but cleaniness before smallness
                bp2Step1 = BP2_FROM_FLOAT( 2*sin(2*PI/n2k) );
                bp2Cos1  = BP2_FROM_FLOAT( cos(2*PI/n2k) );
                bp2Sin1  = BP2_FROM_FLOAT( sin(2*PI/n2k) );
                bp2Step3 = BP2_FROM_FLOAT( 2*sin(6*PI/n2k) );
                bp2Cos3  = BP2_FROM_FLOAT( cos(6*PI/n2k)  );
                bp2Sin3  = BP2_FROM_FLOAT( sin(6*PI/n2k) );
            }
            bp2Cos1p = bp2Cos3p = BP2_FROM_FLOAT(1.0);
            bp2Sin1p = bp2Sin3p = BP2_FROM_FLOAT(0.0);
            for( j = 1; j<n2km2;  j++ )
            {
                //assert( fabs(FLOAT_FROM_BP2(bp2Sin1) - sin((2*PI*j)/n2k)) < 0.0001 );
                //assert( fabs(FLOAT_FROM_BP2(bp2Sin3) - sin((6*PI*j)/n2k)) < 0.0001 );
                for( iOffset = j<<1, iStride = n2kp2; 
                        iOffset < np2; 
                            iOffset = (iStride - n2k + j)<<1, iStride <<= 2 )
                {
                    px3 = (px2 = (px1 = (px0 = px+iOffset) + n2km1) + n2km1) + n2km1;
                    iStridem1 = iStride-1;
                    for( idx = iOffset; 
                            idx < np2m7; 
                        idx += iStride, px0 += iStridem1, px1 += iStridem1, px2 += iStridem1, px3 += iStridem1 )
                    {
#if !defined(WMA_TARGET_SH4)
                        // The pentium prefers this way, but still does not generate wonderful code
                        ur0 = INTDIV2(*px2++);  ui0 = INTDIV2(*px2--);
                        ur2 = MULT_BP2(bp2Cos1,ur0) + MULT_BP2(bp2Sin1,ui0);
                        ui2 = MULT_BP2(bp2Cos1,ui0) - MULT_BP2(bp2Sin1,ur0);
                        ur1 = INTDIV2(*px3++);  ui1 = INTDIV2(*px3--);
                        ur3 = MULT_BP2(bp2Cos3,ur1) + MULT_BP2(bp2Sin3,ui1);
                        ui3 = MULT_BP2(bp2Cos3,ui1) - MULT_BP2(bp2Sin3,ur1);
                        urp     = ur2 + ur3;
                        *px2++  = (ur0 = INTDIV2(*px0)) - urp;
                        *px0++  = ur0 + urp;
                        uim     = ui2 - ui3;
                        *px3++  = (ur1 = INTDIV2(*px1)) - uim;
                        *px1++  = ur1 + uim;
                        uip     = ui2 + ui3;
                        *px2    = (ui0 = INTDIV2(*px0)) - uip;
                        *px0    = ui0 + uip;
                        urm     = ur2 - ur3;
                        *px3    = (ui1 = INTDIV2(*px1)) + urm;
                        *px1    = ui1 - urm;
#else
                        // some platforms might prefer this expression
                        ur0 = INTDIV2(*px2++);  ui0 = INTDIV2(*px2--);
                        ur2 = MULT_BP2(bp2Cos1,ur0) + MULT_BP2(bp2Sin1,ui0);
                        ui2 = MULT_BP2(bp2Cos1,ui0) - MULT_BP2(bp2Sin1,ur0);
                        ur1 = INTDIV2(*px3++); ui1 = INTDIV2(*px3--);
                        ur3 = MULT_BP2(bp2Cos3,ur1) + MULT_BP2(bp2Sin3,ui1);
                        ui3 = MULT_BP2(bp2Cos3,ui1) - MULT_BP2(bp2Sin3,ur1);
                        urp = ur2 + ur3;
                        urm = ur2 - ur3;
                        uip = ui2 + ui3;
                        uim = ui2 - ui3;
                        *px2++  = (ur0 = INTDIV2(*px0)) - urp;
                        *px0++  = ur0 + urp;
                        *px3++  = (ur1 = INTDIV2(*px1)) - uim;
                        *px1++  = ur1 + uim;
                        *px2    = (ui0 = INTDIV2(*px0)) - uip;
                        *px0    = ui0 + uip;
                        *px3    = (ui1 = INTDIV2(*px1)) + urm;
                        *px1    = ui1 - urm;
#endif
                        DUMP_FFT_SET(idx,4);
                        DUMP_FFT_SET(idx+n2km1,1);
                        DUMP_FFT_SET(idx+2*n2km1,1);
                        DUMP_FFT_SET(idx+3*n2km1,1);
                        DEBUG_COUNT_BTFLY2(16,8,12);
                        DEBUG_COUNT_LOOP(2);
                    }
                    DEBUG_COUNT_LOOP(10);
                }
                if ( (j+1) < n2km2 )
                {   // Trig Recurrsion for both 2*pi/2^k and 6*pi/2^k
                    // sin(a+b) = sin(a-b) + 2*sin(b)*cos(a)
                    // cos(a+b) = cos(a-b) - 2*sin(b)*sin(a)
                    // Lay these out like this as ahint to optimizer to overlap operations
                    bp2Sin1T = bp2Sin1p + MULT_BP2(bp2Step1,bp2Cos1);
                    bp2Cos1T = bp2Cos1p - MULT_BP2(bp2Step1,bp2Sin1);
                    bp2Sin3T = bp2Sin3p + MULT_BP2(bp2Step3,bp2Cos3);
                    bp2Cos3T = bp2Cos3p - MULT_BP2(bp2Step3,bp2Sin3);
                    bp2Sin1p = bp2Sin1;  bp2Sin1 = bp2Sin1T;
                    bp2Cos1p = bp2Cos1;  bp2Cos1 = bp2Cos1T;
                    bp2Sin3p = bp2Sin3;  bp2Sin3 = bp2Sin3T;
                    bp2Cos3p = bp2Cos3;  bp2Cos3 = bp2Cos3T;
                    DEBUG_COUNT_TRIG(2,2);
                    DEBUG_COUNT_TRIG(2,2);
                }
                DEBUG_COUNT_LOOP(2);
            }
        }
        DEBUG_COUNT_LOOP(7);
        DUMP_FFT_SHOW("k = %d.\n", k, np );
    }
    FUNCTION_PROFILE_STOP(&fp);
}


#endif  // both !SPLIT_RADIX_FFT and SPLIT_RADIX_FFT


#if defined(_DEBUG)
//*****************************************************************************************
//
// auDctIV
// DCT type IV transform
//
//*****************************************************************************************
//
// define DCT_SIN_PRINT to print sin values as they are used
//#define DCT_SIN_PRINT -1
// define DCT_IN_PRINT to prinf DCT input coefs (positive value to do so for just one frame)
//#define DCT_IN_PRINT 10100
// define DCT_PRE_PRINT to print DCT coefs prior to calling FFT
//#define DCT_PRE_PRINT -1
// define DCT_POST_PRINT to print DCT coefs after calling FFT
//#define DCT_POST_PRINT -1
// define DCT_OUT_PRINT to print DCT output coefs
//#define DCT_OUT_PRINT 10100
// define this to be smaller than 2048 is you only want a sample
#define DCT_MOD_COEF_TO_PRINT 128
#   if defined(DCT_IN_PRINT) || defined(DCT_PRE_PRINT)  || defined(DCT_POST_PRINT) || defined(DCT_OUT_PRINT)
#       pragma COMPILER_MESSAGE(__FILE__ "(725) : Warning - DCT Debug Code Enabled.")
        int bPrintDctAtFrame = 0;       // used by main program to control the printing
        extern int g_ulOutputSamples;   // main must create and update
		void DebugDctPrintCoefs(CAudioObject* pau, int def, int id, float fac, CoefType* pfCoef)
        {   int dcti; float fmax = 0;                                                     
            if ( ((int)pau->m_iFrameNumber==def) || (def < 0) || (bPrintDctAtFrame&(1<<id)) )          
            {   /* MyOutputDbgStr(0, "DCT %4s %4d\n",id,n); matlab does not like */  
				static char* szID[]= { "DCT in  ", "DCT pre ", "DCT post", "DCT out ", "Wgt Fact", "WF down ", "WF up  ", "WF same" };
                for( dcti = 0; dcti < pau->m_cSubbandAdjusted; dcti++ ) {    
					float f = id<4 ? FLOAT_FROM_COEF(pfCoef[dcti])/((Float)fac) :
								     FLOAT_FROM_WEIGHT(pfCoef[dcti]);
                    if ( fmax < fabs(f) )       
                        fmax = (float)fabs(f);
                    if ( dcti < DCT_MOD_COEF_TO_PRINT || (dcti%DCT_MOD_COEF_TO_PRINT)==0 ) 
#						ifdef UNDER_CE
							MyOutputDbgStr(0, 
#						else
							printf(
#						endif
						"%4d.%1d   %4d  %+15.7f\n",          
                            pau->m_iFrameNumber, pau->m_iCurrSubFrame, dcti, f );
                }
#				ifdef UNDER_CE
					MyOutputDbgStr(0, szID[id]);
					MyOutputDbgStr(0, 
#				else
					printf(szID[id]);
					printf(
#				endif
					" %4d  %+15.7f  %7d\n", pau->m_cSubbandAdjusted, fmax, g_ulOutputSamples );
#				ifndef UNDER_CE
					fflush(stdout); 
#				endif
            }
        }
#       define DCT_PRINT(def,id,fac,pfCoef)  DebugDctPrintCoefs(pau,def,id,fac,pfCoef)
#   else
#       define DCT_PRINT(def,id,fac,pfCoef)
#   endif
#   if defined(DCT_IN_PRINT)
#       define DCT_DOPRINT_IN(fac,pfCoef) DCT_PRINT(DCT_IN_PRINT,0,fac,pfCoef)
#   else
#       define DCT_DOPRINT_IN(fac,pfCoef)
#   endif
#   if defined(DCT_PRE_PRINT)
#       define DCT_DOPRINT_PRE(fac,pfCoef) DCT_PRINT(DCT_PRE_PRINT,1,n,fac,pfCoef)
#   else
#       define DCT_DOPRINT_PRE(fac,pfCoef)
#   endif
#   if defined(DCT_POST_PRINT)
#       define DCT_DOPRINT_POST(fac,pfCoef) DCT_PRINT(DCT_POST_PRINT,2,n,fac,pfCoef)
#   else
#       define DCT_DOPRINT_POST(fac,pfCoef)
#   endif
#   if defined(DCT_OUT_PRINT)
#       define DCT_DOPRINT_OUT(fac,pfCoef) DCT_PRINT(DCT_OUT_PRINT,3,n,fac,pfCoef)
#   else
#       define DCT_DOPRINT_OUT(fac,pfCoef)
#   endif
#   if defined(DCT_SIN_PRINT)
#       pragma COMPILER_MESSAGE(__FILE__ "(774) : Warning - DCT Debug Code Enabled.")
#       define DEBUG_DCT_SIN(id,i,fac,sinv)                                     \
            if ( (pau->m_iFrameNumber==DCT_SIN_PRINT) || (DCT_SIN_PRINT < 0) )  \
            {   printf("%2d  %4d  %+15.8f\n", id, i, sinv/fac );                \
                fflush(stdout);                                                 \
            }
#   else
#       define DEBUG_DCT_SIN(id,i,fac,sinv)
#   endif
#else
#       define DCT_DOPRINT_IN(fac,pfCoef)
#       define DCT_DOPRINT_PRE(fac,pfCoef)
#       define DCT_DOPRINT_POST(fac,pfCoef)
#       define DCT_DOPRINT_OUT(fac,pfCoef)
#       define DEBUG_DCT_SIN(id,i,fac,sinv)
#endif

#ifdef INTEGER_ENCODER
#define INTEGER_ENCODER_ONLY(a) a
#else
#define INTEGER_ENCODER_ONLY(a)
#endif

WMARESULT auDctIV(CAudioObject* pau, CoefType* rgiCoef, Float fltAfterScaleFactor, U32 *piMagnitude)
{
    CoefType *piCoefTop, *piCoefBottom, *piCoefBottomOut;
    CoefType iTr, iTi, iBr, iBi;
    BP1Type CR, CI, UR, UI, STEP, CR1, CI1, CR2, CI2;
    Int iFFTSize, i, cSB, nLog2SB;
    BP1Type  iFac;
    const SinCosTable* pSinCosTable;
    double fac;
    const double dPI = PI;
    const double dPI3Q = 3*PI/4;                        // PI (-1/4 + 1)
    const double dPIby4 = PI/4;
#if defined(BUILD_INTEGER) || defined(INTEGER_ENCODER)
    const double d1p0   = 1.0 * NF2BP1;
    const double d2p0   = 2.0 * NF2BP1;
    const double d1Hp0  = 0.5 * NF2BP1;
    const double d1Qp0  = 0.25* NF2BP1;
    Int nFacExponent;
    U32 iMagnitude = 0;
#else  // must be BUILD_INT_FLOAT
    const double d1p0   = 1.0;
    const double d2p0   = 2.0;
    const double d1Hp0  = 0.5;
    const double d1Qp0  = 0.25;
#endif  // BUILD_INTEGER or BUILD_INT_FLOAT
#ifdef INTEGER_ENCODER
    Int iScaleFactor;
#endif

    FUNCTION_PROFILE(fp);
    FUNCTION_PROFILE_START(&fp,DCTIV_PROFILE);

    // m_cSubbandAdjusted below deals with the need to scale transform results to compensate the fact 
    // that we're inv transforming coefficients from a transform that was twice or half our size

    cSB = pau->m_cSubbandAdjusted;
    iFFTSize = cSB/2;
    nLog2SB = LOG2( cSB );

    piCoefTop          = rgiCoef;               
    piCoefBottom       = rgiCoef + cSB - 1;
    piCoefBottomOut    = rgiCoef + cSB - 1;     // separate pointer now obsolete but still used

#if defined(WMA_SHOW_FRAMES) && defined(_DEBUG)
    prvWmaShowFrames(pau, "DCT", " %4d 0x%08x 0x%08x", cSB, piCoefTop, piCoefBottom);
#endif

    // fltAfterScaleFactor:  V2: 2/cSB == 1/iFFTSize and V1: sqrt(2/cSB)
#if defined(BUILD_INTEGER) || defined(INTEGER_ENCODER)
    fac = fltAfterScaleFactor * cSB * d1Qp0;
    for( nFacExponent = 0; fabs(fac) > d1p0; nFacExponent++ )
        fac /= 2.0f;        // SH warning CBE4717 here is ignorable
#else   // must be BUILD_INT_FLOAT
    fac = fltAfterScaleFactor;
#endif

    // initialize sin/cos recursion
    // note this style of recurrsion is more accurate than Numerical Recipies 5.5.6
    if ( 64 <= cSB && cSB <= 2048 )
    {
        pSinCosTable = rgSinCosTables[cSB>>7];
#       if defined(BUILD_INTEGER) || defined(INTEGER_ENCODER)
            iFac = (I32)ROUNDD( fac );
#       else  // must be BUILD_INT_FLOAT
            iFac = (BP1Type)fac;
#       endif // BUILD_INTEGER or BUILD_INT_FLOAT
        // initial cosine/sine values
        CR =  MULT_BP1(iFac,pSinCosTable->cos_PIby4cSB);        // CR = (I32)(fac*cos(-PI/(4*m_cSubband)) * NF2BP1)
        CI = -MULT_BP1(iFac,pSinCosTable->sin_PIby4cSB);        // CI = (I32)(fac*sin(-PI/(4*m_cSubband)) * NF2BP1)
        // prior cosine/sine values to init Pre-FFT recurrsion trig( -PI/(4*M) - (-PI/M ) = trig( 3*PI/(4*M) )
        CR1 =  MULT_BP1(iFac,pSinCosTable->cos_3PIby4cSB);  // CR = (I32)(fac*cos(+3*PI/(4*m_cSubband)) * NF2BP1)
        CI1 =  MULT_BP1(iFac,pSinCosTable->sin_3PIby4cSB);  // CI = (I32)(fac*sin(+3*PI/(4*m_cSubband)) * NF2BP1)
        // rotation step for both recurrsions
        STEP = -pSinCosTable->two_sin_PIbycSB;              // STEP = 2*sin(-PI/m_cSubband) 
        // prior cosine/sine values to init Post-FFT recurrsion
        CR2 =  pSinCosTable->cos_PIbycSB;                   // CR = (I32)(cos( PI/m_cSubband) * NF2BP1)
        CI2 =  pSinCosTable->sin_PIbycSB;                   // CI = (I32)(sin( PI/m_cSubband) * NF2BP1)
    }
    else
    {   // not normally needed in decoder, here for generality
        double dA, dSB;

        dA = -dPIby4 / (dSB=cSB);
        CR = (BP1Type)( fac * cos( dA ) );
        CI = (BP1Type)( fac * sin( dA ) );
        dA = dPI3Q / dSB;
        CR1 = (BP1Type)( fac * cos( dA ) );
        CI1 = (BP1Type)( fac * sin( dA ) );
        dA = -dPI / dSB;
        STEP = (BP1Type)( d2p0 * sin( dA ) );
        CR2  = (BP1Type)( d1p0 * cos( dA ) );
        CI2  = -STEP/2;  
    }

    // Include the next code-block to verify changes to the lookup-table
#if 0
    {
#       if defined(BUILD_INTEGER) || defined(INTEGER_ENCODER)
            const BP1Type Theshold = 1;
#       else
            const BP1Type Theshold = BP1_FROM_FLOAT(0.001F*fac);
#       endif
        assert(BPX_ABS(CR - (BP1Type)( fac * cos(-dPIby4 / cSB) )) <= Theshold);
        assert(BPX_ABS(CI - (BP1Type)( fac * sin(-dPIby4 / cSB) )) <= Theshold);
        assert(BPX_ABS(CR1 - (BP1Type)( fac * cos(dPI3Q / cSB) )) <= Theshold);
        assert(BPX_ABS(CI1 - (BP1Type)( fac * sin(dPI3Q / cSB) )) <= Theshold);
        assert(BPX_ABS(STEP - (BP1Type)( d2p0 * sin(-dPI / cSB) )) <= Theshold);
        assert(BPX_ABS(CR2  - (BP1Type)( d1p0 * cos(-dPI / cSB) )) <= Theshold);
        assert(BPX_ABS(CI2  - DIV2((-(BP1Type)( d2p0 * sin(-dPI / cSB) )))) <= Theshold);
    }
#endif

    DCT_DOPRINT_IN(1.0,rgiCoef);

    for (i = iFFTSize/2; i > 0; i--) {
        iBi = piCoefBottom[0];
        piCoefBottomOut[0] = piCoefTop[1];

        iTr = piCoefTop[0];
        piCoefTop[0] = MULT_BP1(CR,iTr) - MULT_BP1(CI,iBi);
        piCoefTop[1] = MULT_BP1(CR,iBi) + MULT_BP1(CI,iTr);

        DEBUG_DCT_SIN(0,i,fac,CI);
        MONITOR_RANGE(gMR_DCTCoefIntoFFT,FLOAT_FROM_COEF(piCoefTop[0]));
        MONITOR_RANGE(gMR_DCTCoefIntoFFT,FLOAT_FROM_COEF(piCoefTop[1]));
        // rotate angle by -b = -pi/cSubband
        // recursion: cos(a-b) = cos(a+b) - 2*sin(b)*sin(a)
        // and:       sin(a-b) = sin(a+b) + 2*sin(b)*cos(a)
        UR = CR1 - MULT_BP1(STEP,CI);
        UI = CI1 + MULT_BP1(STEP,CR);
        CR1 = CR;  CR = UR;
        CI1 = CI;  CI = UI;

        piCoefTop += 2;
        piCoefBottom -= 2;
        piCoefBottomOut -= 2;
    }

    for (i = iFFTSize/2; i > 0; i--) {
        iTr = piCoefTop[0];
        iTi = piCoefTop[1];
        piCoefTop[0] = MULT_BP1(CR,iTr) - MULT_BP1(CI,iTi);
        piCoefTop[1] = MULT_BP1(CR,iTi) + MULT_BP1(CI,iTr);

        DEBUG_DCT_SIN(1,i,fac,CI);
        MONITOR_RANGE(gMR_DCTCoefIntoFFT,FLOAT_FROM_COEF(piCoefTop[0]));
        MONITOR_RANGE(gMR_DCTCoefIntoFFT,FLOAT_FROM_COEF(piCoefTop[1]));
        // rotate angle by b = -pi/cSubband
        UR = CR1 - MULT_BP1(STEP,CI);
        UI = CI1 + MULT_BP1(STEP,CR);
        CR1 = CR;  CR = UR;
        CI1 = CI;  CI = UI;

        piCoefTop += 2;
    }

    DCT_DOPRINT_PRE((fac/d1Hp0),rgiCoef);

    //Call the integer FFT explicitly
    pau->aupfnFFT(rgiCoef, nLog2SB - 1);

    DCT_DOPRINT_POST(1.0,rgiCoef);

#ifdef INTEGER_ENCODER
    // TODO:  put this in asm for SH4, SH3 and casio
    if (nFacExponent > 0)
    {   // This scaling needed for encoding only (we think hopefully)
        const int c_iMaxScaleUp = 15;

        iScaleFactor = nFacExponent;

        // Limit pre-scale to +c_iMaxScaleUp (to avoid overflow)
        if (iScaleFactor > c_iMaxScaleUp)
        {
            nFacExponent = (iScaleFactor - c_iMaxScaleUp);
            iScaleFactor = c_iMaxScaleUp;
        }
        else
            nFacExponent = 0;

#ifdef _DEBUG
        if (iScaleFactor > 0)
        {
            I32 iIntMax = INT_MAX >> iScaleFactor;  
            piCoefTop      = rgiCoef; 
            for( i = cSB; i > 0; i--, piCoefTop++ )
            {
                assert(-iIntMax <= (I32)(*piCoefTop)  && (I32)(*piCoefTop) <= iIntMax );
            }
        }
#endif
    }

#endif

    // post FFT demodulation 
    // using R[i], I[i] as real and imaginary parts of complex point i
    // and C(i), S(i) are cos(i*pi/cSubband) and sin(i*pi/cSubband), and N = cSubband/2
    // R[0] = C(0) R[0] - S(0) I[0]
    // I[0] = -S(-(N-1)) R[N-1] - C(-(N-1)) I[N-1]
    // R[1] = C(1) R[1] - S(-1) I[N-1]
    // I[1] = -S(-(N-2)) R[N-2] - C(-(N-2)) I[N-2]
    // ...
    // R[N-2] = C(-(N-2)) R[N-2] - S(-(N-2)) I[N-2]
    // I[N-2] = -S(-1) R[1] - C(-1) I[1]
    // R[N-1] = C(-(N-1)) R[N-1] - S(-(N-1)) I[N-1]
    // R[N-1] = -S(0) R[0] - C(0) I[0]
    // and where 90 - angle trig formulas reveal:
    // C(-(N-i)) == -S(-i) and S(-(N-i)) = -C(-i)

    piCoefTop      = rgiCoef;           //reuse this pointer; start from head;
    piCoefBottom   = rgiCoef + cSB - 2; //reuse this pointer; start from tail;
    CR = BP1_FROM_FLOAT(1);             //one
    CI = 0;                             //zero

    for (i = iFFTSize/2; i > 0; i--) {
        iTr = piCoefTop[0] INTEGER_ENCODER_ONLY( <<iScaleFactor );
        iTi = piCoefTop[1] INTEGER_ENCODER_ONLY( <<iScaleFactor );
        iBr = piCoefBottom[0] INTEGER_ENCODER_ONLY( <<iScaleFactor );
        iBi = piCoefBottom[1] INTEGER_ENCODER_ONLY( <<iScaleFactor );

        piCoefTop[0] =  MULT_BP1(CR,iTr) -  MULT_BP1(CI,iTi);
        piCoefBottom[1] =  MULT_BP1(-CI,iTr) - MULT_BP1(CR,iTi);
        INTEGER_ONLY( iMagnitude |= abs(piCoefTop[0]) );
        INTEGER_ONLY( iMagnitude |= abs(piCoefBottom[1]) );

        DEBUG_DCT_SIN(2,i,d1p0,CI);
        MONITOR_RANGE(gMR_DCTCoefOut,FLOAT_FROM_COEF(piCoefTop[0]));
        MONITOR_RANGE(gMR_DCTCoefOut,FLOAT_FROM_COEF(piCoefBottom[1]));
        // rotate angle by -b = -pi/cSubband
        // recursion: cos(a-b) = cos(a+b) - 2*sin(b)*sin(a)
        // and:       sin(a-b) = sin(a+b) + 2*sin(b)*cos(a)
        UR = CR2 - MULT_BP1(STEP,CI);
        UI = CI2 + MULT_BP1(STEP,CR);
        CR2 = CR;  CR = UR;
        CI2 = CI;  CI = UI;

        // note that cos(-(cSubband/2 - i)*pi/cSubband ) = -sin( -i*pi/cSubband )
        piCoefTop[1] = MULT_BP1(CR,iBr) + MULT_BP1(CI,iBi);
        piCoefBottom[0] = MULT_BP1(-CI,iBr) +  MULT_BP1(CR,iBi);
        
        INTEGER_ONLY( iMagnitude |= abs(piCoefTop[1]) );
        INTEGER_ONLY( iMagnitude |= abs(piCoefBottom[0]) );

        MONITOR_RANGE(gMR_DCTCoefOut,FLOAT_FROM_COEF(piCoefTop[1]));
        MONITOR_RANGE(gMR_DCTCoefOut,FLOAT_FROM_COEF(piCoefBottom[0]));

        piCoefTop += 2;
        piCoefBottom -= 2;
    }
#if defined(BUILD_INTEGER) || defined(INTEGER_ENCODER)
    if ( nFacExponent > 0 )
    {   // This scaling needed in v1 bit-streams
        piCoefTop      = rgiCoef; 
        iMagnitude <<= nFacExponent;
        for( i = cSB; i > 0; i-- )
        {
            *piCoefTop++ <<= nFacExponent;
        }
    }
#endif

    if (NULL != piMagnitude)
        *piMagnitude = INTEGER_OR_INT_FLOAT( iMagnitude, 0 );

    DCT_DOPRINT_OUT(1.0,rgiCoef);
#if defined(DCT_OUT_PRINT) && defined(_DEBUG)
    if ( pau->m_iFrameNumber==DCT_OUT_PRINT)
    { DEBUG_BREAK(); }
#endif
    FUNCTION_PROFILE_STOP(&fp);

    return WMA_OK;
}



#endif // WMA_TARGET_MIPS, WMA_TARGET_SH3, WMA_TARGET_SH4 and everything else


//#define PLATFORM_LPC_LITDFT

#if defined(PLATFORM_LPC_LITDFT) 

// A Split Radix FFT for the LPC -
// Size (which is 32) must match that required by LPC
// See WMAConcepts.xls - Sheet SRFFT32 for how this works.
// See also Sorensen & Heldeman, IEEE Trans ASSP, Vol ASSP-34, #1, 2/86, pp152-156.

#define NP 32
#define LOGNP 5
#define NP2 (2*NP)
#define SWAP(a,b) tmp=(a);(a)=(b);(b)=tmp

#define BP2_CONST4(a,b,c,d) BP2_FROM_FLOAT(a),BP2_FROM_FLOAT(b),BP2_FROM_FLOAT(c),BP2_FROM_FLOAT(d)

const BP2Type rgbp2SRFFT32[] = {
//     cos(2*PI*j/2^k) sin(2*PI*j/2^k) cos(6*PI*j/2^k) sin(6*PI*j/2^k)
BP2_CONST4(0.70710678119,0.70710678119,-0.70710678119,0.70710678119),   // k=3, j=1
BP2_CONST4(0.92387953251,0.38268343237,0.38268343237,0.92387953251),    // k=4, j=1
BP2_CONST4(0.70710678119,0.70710678119,-0.70710678119,0.70710678119),   // k=4, j=2
BP2_CONST4(0.38268343237,0.92387953251,-0.92387953251,-0.38268343237),  // k=4, j=3
BP2_CONST4(0.98078528040,0.19509032202,0.83146961230,0.55557023302),    // k=5, j=1
BP2_CONST4(0.92387953251,0.38268343237,0.38268343237,0.92387953251),    // k=5, j=2
BP2_CONST4(0.83146961230,0.55557023302,-0.19509032202,0.98078528040),   // k=5, j=3
BP2_CONST4(0.70710678119,0.70710678119,-0.70710678119,0.70710678119),   // k=5, j=4
BP2_CONST4(0.55557023302,0.83146961230,-0.98078528040,0.19509032202),   // k=5, j=5
BP2_CONST4(0.38268343237,0.92387953251,-0.92387953251,-0.38268343237),  // k=5, j=6
BP2_CONST4(0.19509032202,0.98078528040,-0.55557023302,-0.83146961230)   // k=5, j=7
};

static const I8 rgi8BitReverse32[2*12] = {
    2,32,  4,16,  6,48,  10,40, 12,24, 14,56, 
    18,36, 22,52, 26,44, 30,60, 38,50, 46,58 
};


void prvFFT32(CoefType data[])
{
    CoefType *px = data;
    I32 i, j, k, iOffset, iStride;
    Int n2k, n2km1, n2km2, n2kp2, idx0, idx1, idxR0, idxR1, idxR2, idxR3;
    CoefType tmp, ur0, ui0, ur1, ui1;
    BP2Type bp2Cos1, bp2Sin1, bp2Cos3, bp2Sin3;
    const BP2Type* pbp2Trig = rgbp2SRFFT32;
    CoefType ur2, ui2, ur3, ui3, urp, uip, urm, uim;

    //FUNCTION_PROFILE(fp);
    //FUNCTION_PROFILE_START(&fp,FFT32_PROFILE);

    // bit reverse
    for( i = 0; i < (2*12); i += 2 )
    {
        SWAP( px[rgi8BitReverse32[i]], px[rgi8BitReverse32[i+1]] );
        SWAP( px[rgi8BitReverse32[i]+1], px[rgi8BitReverse32[i+1]+1] );
    }

    // Length 2 butterflies
    for( iOffset = 0, iStride = 8; 
            iOffset < NP2; 
                iOffset = (iStride<<1) - 4, iStride <<= 2 )
    {
        for( idx0 = iOffset; idx0<NP2; idx0 += iStride-1 )
        {
            ur0 = px[idx0];
            ur1 = px[idx1 = idx0+2 ]; 
            px[idx0++] = ur0 + ur1;
            px[idx1++] = ur0 - ur1;
            ui0 = px[idx0];
            ui1 = px[idx1]; 
            px[idx0] = ui0 + ui1;
            px[idx1] = ui0 - ui1;
        }
    }

    // L Shaped Butterflies
    n2k = 2;
    for( k=2; k<=LOGNP; k++ )
    {
        n2k <<= 1;
        n2km1 = n2k>>1;
        n2km2 = n2k>>2;
        n2kp2 = n2k<<2;
        // Trivial Butterflies - j==0 - no multiplies since Cos==1 and Sin==0
        for( iOffset = 0, iStride = n2kp2; 
                iOffset < NP2; 
                    iOffset = (iStride - n2k)<<1, iStride <<= 2 )
        {
            for( idxR0 = iOffset; 
                    idxR0 < (NP2-7); 
                        idxR0 += iStride )
            {
                idxR1 = idxR0 + n2km1;
                idxR2 = idxR1 + n2km1;
                idxR3 = idxR2 + n2km1;
                urp = px[idxR2]   + px[idxR3];
                urm = px[idxR2]   - px[idxR3];
                uip = px[idxR2+1] + px[idxR3+1];
                uim = px[idxR2+1] - px[idxR3+1];
                px[idxR2]    = px[idxR0] - urp;
                px[idxR0]   += urp;
                px[idxR3]    = px[idxR1] - uim;
                px[idxR1]   += uim;
                px[idxR2+1]  = px[idxR0+1] - uip;
                px[idxR0+1] += uip;
                px[idxR3+1]  = px[idxR1+1] + urm;
                px[idxR1+1] -= urm;
            }
        }
        // Now the non-trivial butterflies
        for( j = 1; j<n2km2;  j++ )
        {
            bp2Cos1 = *pbp2Trig++;      // cos(2*pi*j/n2k)
            bp2Sin1 = *pbp2Trig++;      // sin(2*pi*j/n2k)
            bp2Cos3 = *pbp2Trig++;      // cos(3*2*pi*j/n2k)
            bp2Sin3 = *pbp2Trig++;      // sin(3*2*pi*j/n2k)
            assert( fabs(FLOAT_FROM_BP2(bp2Sin1) - sin((2*PI*j)/n2k)) < 0.0001 );
            for( iOffset = j<<1, iStride = n2kp2; 
                    iOffset < NP2; 
                        iOffset = (iStride - n2k + j)<<1, iStride <<= 2 )
            {
                for( idxR0 = iOffset; 
                        idxR0 < (NP2-7); 
                            idxR0 += iStride )
                {
                    idxR1 = idxR0 + n2km1;
                    idxR2 = idxR1 + n2km1;
                    idxR3 = idxR2 + n2km1;
                    ur2 = bp2Cos1*px[idxR2]   + bp2Sin1*px[idxR2+1];
                    ui2 = bp2Cos1*px[idxR2+1] - bp2Sin1*px[idxR2];
                    ur3 = bp2Cos3*px[idxR3]   + bp2Sin3*px[idxR3+1];
                    ui3 = bp2Cos3*px[idxR3+1] - bp2Sin3*px[idxR3];
                    urp = ur2 + ur3;
                    urm = ur2 - ur3;
                    uip = ui2 + ui3;
                    uim = ui2 - ui3;
                    px[idxR2]    = px[idxR0] - urp;
                    px[idxR0]   += urp;
                    px[idxR3]    = px[idxR1] - uim;
                    px[idxR1]   += uim;
                    px[idxR2+1]  = px[idxR0+1] - uip;
                    px[idxR0+1] += uip;
                    px[idxR3+1]  = px[idxR1+1] + urm;
                    px[idxR1+1] -= urm;
                }
            }
        }
    }
    //FUNCTION_PROFILE_STOP(&fp);
}


#undef SWAP

#endif  // defined(PLATFORM_LPC_LITDFT) || 1



#if defined (PEAQ_MASK) && defined (ENCODER)

// useful in some debugging situations - routines from Numerical Recipes

#define SWAP(a,b) tempr=(a);(a)=(b);(b)=tempr

void four1(float data[], unsigned long nn, int isign)
// Replaces data[1..2*nn] by its discrete Fourier transform, if isign is input as 1; or replaces
// data[1..2*nn] by nn times its inverse discrete Fourier transform, if isign is input as - 1.
// data is a complex array of length nn or, equivalently, a real array of length 2*nn. nn MUST
// be an integer power of 2 (this is not checked for!).
{
    unsigned long n,mmax,m,j,istep,i;
    double wtemp,wr,wpr,wpi,wi,theta;           // Double precision for the trigonomet-
    float tempr,tempi;                          // ric recurrences. 
    n=nn << 1;
    j=1;
    for (i=1;i<n;i+=2) {                        // This is the bit-reversal section of the
        // routine. 
        if(j > i) {
            SWAP(data[j],data[i]);              // Exchange the two complex numbers.
            SWAP(data[j+1],data[i+1]);
        }
        m=n >> 1;
        while (m >= 2 && j > m) {
            j -=m;
            m >>= 1;
        }
        j += m;
    }
    // Here begins the Danielson-Lanczos section of the routine.
    mmax=2;
    while (n > mmax) {                          // Outer loop executed log 2 nn times.
        istep=mmax << 1;
        theta=isign*(6.28318530717959/mmax);    // Initialize the trigonometric recurrence.
        wtemp=sin(0.5*theta);
        wpr = -2.0*wtemp*wtemp;
        wpi=sin(theta);
        wr=1.0;
        wi=0.0;
        for (m=1;m<mmax;m+=2) {                 // Here are the two nested inner loops.
            for (i=m;i<=n;i+=istep) {
                j=i+mmax;                       // This is the Danielson-Lanczos for-
                tempr=(float)(wr*data[j]-wi*data[j+1]); // mula: 
                tempi=(float)(wr*data[j+1]+wi*data[j]);
                data[j]=data[i]-tempr;
                data[j+1]=data[i+1]-tempi;
                data[i] += tempr;
                data[i+1] += tempi;
            }
            wr=(wtemp=wr)*wpr-wi*wpi+wr;        // Trigonometric recurrence.
            wi=wi*wpr+wtemp*wpi+wi;
        }
        mmax=istep;
    }
}

// Input shall be in complex flot format(real followed by imag). rgfltData should have size = N + 2 floats.
// On the input, (N/2 + 1) complex numbers should be filled in. On the output, only the first N outputs 
// are valid, and all of them should be considered real values. nOrder = log2(N).
// Inputs are mirror-imaged (&conjugated) internally before ifft. Never tested
// with complex inputs.
Void prvInvFftComplexConjugate(Float *rgfltData, Int nOrder)
{
    Int N = 1 << nOrder;
    Float rgfltTmp[4 * 2048 + 1]; // Big buffer on the stack
    Int i;
    Int iSrc2, iDst2;
    
    assert(nOrder < 12);
    
    memset(rgfltTmp, 0, (4 * 2048 + 1) * sizeof(Float)); 
    // Perform shift by one operation for Numerical Recipe's fft
    memcpy (rgfltTmp + 1, rgfltData, (N + 2) * sizeof(Float));
    
    // Perform mirroring (in complex domain), for numerical recipes' normal fft.
    iSrc2 = 2 * 2;
    iDst2 = N * 2;
    for (i = 0; i < (N/2)-1; i++) {
        rgfltTmp[iDst2 - 1] =  rgfltTmp[iSrc2 - 1]; // real
        rgfltTmp[iDst2]     = -rgfltTmp[iSrc2];     // imag
        iSrc2 += 2;
        iDst2 -= 2;
    }
    
    // Call Numerical recipes four1
    four1(rgfltTmp, N, -1 /* inverse */);
    
    // Do the scaling and copy back result
    for (i = 0; i < N; i++) {
        rgfltData[i] = rgfltTmp[2 * i + 1]/N;
    }
}

#endif // PEAQ_MASK && ENCODER

#if defined(_DEBUG) && 0
//#undef SWAP(a,b)

void realft(float data[], unsigned long n, int isign)
// Calculates the Fourier transform of a set of n real-valued data points. Replaces this data (which
// is stored in array data[1..n]) by the positive frequency half of its complex Fourier transform.
// The real-valued rst and last components of the complex transform are returned as elements
// data[1] and data[2], respectively. n must be a power of 2. This routine also calculates the
// inverse transform of a complex data array if it is the transform of real data. (Result in this case
// must be multiplied by 2/n.)
{
    void four1(float data[], unsigned long nn, int isign);
    unsigned long i,i1,i2,i3,i4,np3;
    float c1=0.5,c2,h1r,h1i,h2r,h2i;
    double wr,wi,wpr,wpi,wtemp,theta;           // Double precision for the trigonometric recurrences.
    theta=3.141592653589793/(double) (n>>1);    // Initialize the recurrence.
    if (isign == 1) {
        c2 = -0.5;
        four1(data,n>>1,1);                     // The forward transform is here.
    } else {
        c2=0.5;                                 // Otherwise set up for an inverse transform. 
        theta = -theta;
    }
    wtemp = sin(0.5*theta);
    wpr   = -2.0*wtemp*wtemp;
    wpi   = sin(theta);
    wr    = 1.0+wpr;
    wi    = wpi;
    np3 = n+3;
    for (i=2; i<=(n>>2); i++ ) 
    {                                           // Case i=1 done separately below.
        i4  = 1+(i3=np3-(i2=1+(i1=i+i-1)));
        h1r =  c1*(data[i1]+data[i3]);          // The two separate transforms are sep-
        h1i =  c1*(data[i2]-data[i4]);          // arated out of data. 
        h2r = -c2*(data[i2]+data[i4]);
        h2i =  c2*(data[i1]-data[i3]);
        data[i1] = (float)( h1r + wr*h2r - wi*h2i);     // Here they are recombined to form
        data[i2] = (float)( h1i + wr*h2i + wi*h2r);     // the true transform of the origi-
        data[i3] = (float)( h1r - wr*h2r + wi*h2i);     // nal real data.
        data[i4] = (float)(-h1i + wr*h2i + wi*h2r);
        wr = (wtemp=wr)*wpr - wi*wpi + wr;      // The recurrence.
        wi = wi*wpr + wtemp*wpi + wi;
    }
    if (isign == 1) {
        data[1] = (h1r=data[1])+data[2];        // Squeeze the First and last data to-
        data[2] = h1r-data[2];                  // gether to get them all within the
                                                // original array.
        
    } else {
        data[1] = c1*((h1r=data[1])+data[2]);
        data[2] = c1*(h1r-data[2]);
        four1(data,n>>1,-1);                    // This is the inverse transform for the
                                                // case isign=-1. 
    }
}

#endif // _DEBUG && 0
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\wmalib\wmadec_s\float.c ===
/*************************************************************************

Copyright (C) Microsoft Corporation, 1996 - 1999

Module Name:

    MsAudio.cpp

Abstract:

    Floating point implementation of public member functions for CAudioObject.

Author:

    Wei-ge Chen (wchen) 11-March-1998

Revision History:


*************************************************************************/

#if !defined(_WIN32_WCE) && !defined(HITACHI)
#include <time.h>
#endif  // _WIN32_WCE

#include <math.h>
#include <limits.h>
#include <stdio.h>
#include "msaudio.h"
#include "macros.h"
#include "AutoProfile.h"
#include "..\..\..\dsound\dsndver.h"

#ifndef BUILD_INTEGER

/////////////////////////////////////////////////////////////////////////
//      Floating point versions of code that has already been integerized
//      this may eventionally be deleted
//////////////////////////////////////////////////////////////////////////

//floating version
WMARESULT prvAdaptTrigToSubframeConfig(CAudioObject *pau)
{
    WMARESULT wmaResult = WMA_OK;
    Int iSize2Use;
	Double dA;
#   if !defined(V4V5_COMPARE_MODE) && !defined(INTEGER_ENCODER)
    const SinCosTable*  pSinCosTable;
#endif

    //if the adjacent size is bigger; just keep your own shape
    //otherwise a transition window is needed.
    if (pau->m_iSizePrev >= pau->m_iSizeCurr) {
        //just forward copy curr
		iSize2Use = pau->m_iSizeCurr;
    }
    else  {
        //long start
		iSize2Use = pau->m_iSizePrev;
    }

#ifdef USE_SIN_COS_TABLES
    switch (iSize2Use){
        case 2048:
            pau->m_piSinForRecon = pau->m_piSinForRecon2048;
            break;
        case 1024:
            pau->m_piSinForRecon = pau->m_piSinForRecon1024;
            break;
        case 512 :
            pau->m_piSinForRecon = pau->m_piSinForRecon512;
            break;
        case 256 :
            pau->m_piSinForRecon = pau->m_piSinForRecon256;
            break;
        case 128 :
            pau->m_piSinForRecon = pau->m_piSinForRecon128;
            break;
        case 64  :
            pau->m_piSinForRecon = pau->m_piSinForRecon64;
            break;
        default: 
            assert(0);
            return (TraceResult (WMA_E_BROKEN_FRAME));
    }
#endif  //maby else out next section


#   if !defined(V4V5_COMPARE_MODE) && !defined(INTEGER_ENCODER)
        // Use lookup-tables if we can 
        // Saves 1% of play time of SH4 and a tiny bit on an 233MHz Pentium II
        if (iSize2Use >= 64 && iSize2Use <= 2048)
        {
            pSinCosTable = rgSinCosTables[iSize2Use>>7];
            // START: see below for detailed explaination
            pau->m_fltSinRampUpStart =   pSinCosTable->sin_PIby4cSB;    //(Int) (sin (0.5 * PI / iSizeCurr / 2) * 0x3FFFFFFF);
            pau->m_fltCosRampUpStart =   pSinCosTable->cos_PIby4cSB;    //(Int) (cos (0.5 * PI / iSizeCurr / 2) * 0x3FFFFFFF);
            // PRIOR: see below for detailed explaination
            pau->m_fltSinRampUpPrior =  -pSinCosTable->sin_PIby4cSB;
            pau->m_fltCosRampUpPrior =   pSinCosTable->cos_PIby4cSB;
            pau->m_fltSinRampUpStep  = 2*pSinCosTable->sin_PIby2cSB;   // STEP = 2 * sin (PI / 2 / iSizeCurr) * 0x3FFFFFFF;
#           ifdef _DEBUG
            {   // Include the next code-block to verify changes to the lookup-table
                dA = PI / (4*iSize2Use);
                assert(fabs(pau->m_fltSinRampUpStart - sin ( dA ) ) <= 0.0001);
                assert(fabs(pau->m_fltCosRampUpStart - cos ( dA ) ) <= 0.0001);
                assert(fabs(pau->m_fltSinRampUpPrior - sin( -dA ) ) <= 0.0001);
                assert(fabs(pau->m_fltCosRampUpPrior - cos( -dA ) ) <= 0.0001);
                assert(fabs(pau->m_fltSinRampUpStep  -  2 * sin( 2*dA ) ) <= 0.0001); 
            }
#           endif // _DEBUG
        }
        else
#   endif // !defined(V4V5_COMPARE_MODE) && !defined(INTEGER_ENCODER)    
        {
            // START:  sin ((0.5 + iSize2Use) * PI / (2*iSize2Use) )
	        //		 = sin ( PI/(4*iSize2Use) + PI/2 ) =  cos( PI/(4*iSize2Use) )
	        // AND:    cos ((0.5 + iSize2Use) * PI / (2*iSize2Use) )
	        //       = cos ( PI/(4*iSize2Use) + PI/2 ) = -sin( PI/(4*iSize2Use) )
	        dA = PI / (4*iSize2Use);
            pau->m_fltSinRampUpStart =  (V4V5COMPARE)(sin ( dA ));
            pau->m_fltCosRampUpStart =  (V4V5COMPARE)(cos ( dA ));
	        // PRIOR:  sin ((0.5 + iSize2Use) * PI / (2*iSize2Use) -PI/(2*iSize2Use) )
	        //       = sin ( PI/(4*iSize2Use) + PI/2 - PI/(2*iSize2Use) ) 
            //       = cos( -PI/(4*iSize2Use) ) = cos( PI/(4*iSize2Use) )
	        // AND:    cos ((0.5 + iSize2Use) * PI / (2*iSize2Use) -PI/(2*iSize2Use) )
	        //       = cos ( PI/(4*iSize2Use) + PI/2 - PI/(2*iSize2Use) ) 
            //       = -sin( -PI/(4*iSize2Use) ) = sin( PI/(4*iSize2Use) )
	        pau->m_fltSinRampUpPrior =  (V4V5COMPARE)(sin( -dA ));
	        pau->m_fltCosRampUpPrior =  (V4V5COMPARE)(cos( -dA ));

            // Rotate by PI/(2*iSize2Use)
	        pau->m_fltSinRampUpStep  =  (V4V5COMPARE)( 2 * sin( 2*dA ) );
        }


    if (pau->m_iSizeNext >= pau->m_iSizeCurr) {
		iSize2Use = pau->m_iSizeCurr;
    }
    else    {
        //just backward copy curr
		iSize2Use = pau->m_iSizeNext;
    }

#ifdef USE_SIN_COS_TABLES
    switch (iSize2Use){
        case 2048:
            pau->m_piSinForSaveHistory = pau->m_piSinForRecon2048+2048;
            break;
        case 1024:
            pau->m_piSinForSaveHistory = pau->m_piSinForRecon1024+1024;
            break;
        case 512 :
            pau->m_piSinForSaveHistory = pau->m_piSinForRecon512+512;
            break;
        case 256 :
            pau->m_piSinForSaveHistory = pau->m_piSinForRecon256+256;
            break;
        case 128 :
            pau->m_piSinForSaveHistory = pau->m_piSinForRecon128+128;
            break;
        case 64  :
            pau->m_piSinForSaveHistory = pau->m_piSinForRecon64+64;
            break;
        default: 
            assert (0);
            return (TraceResult (WMA_E_BROKEN_FRAME));
    }
#endif //USE_SIN_COS_TABLES

#   if !defined(V4V5_COMPARE_MODE) && !defined(INTEGER_ENCODER)
        // Use lookup-tables if we can
        if (iSize2Use >= 64 && iSize2Use <= 2048)
        {
            pSinCosTable = rgSinCosTables[iSize2Use>>7];
            // START: see below for detailed explaination
            pau->m_fltSinRampDownStart =   pSinCosTable->cos_PIby4cSB;  //(Int) sin ((0.5 + iSizeNext) * PI / iSizeNext / 2);
            pau->m_fltCosRampDownStart =  -pSinCosTable->sin_PIby4cSB;  //(Int) cos ((0.5 + iSizeNext) * PI / iSizeNext / 2);
            // PRIOR: see below for detailed explaination
            pau->m_fltSinRampDownPrior =   pSinCosTable->cos_PIby4cSB;
            pau->m_fltCosRampDownPrior =   pSinCosTable->sin_PIby4cSB;
            pau->m_fltSinRampDownStep  = 2*pSinCosTable->sin_PIby2cSB;     // STEP = 2 * sin (PI / 2 / iSizeCurr) * 0x3FFFFFFF;
#           ifdef _DEBUG
            {   // Include this code-block to verify changes to the lookup-table
	            dA = PI/(4* iSize2Use);
                assert(fabs(pau->m_fltSinRampDownStart - cos( dA )) <= 0.0001);
                assert(fabs(pau->m_fltCosRampDownStart + sin( dA )) <= 0.0001);       // + == - -
                assert(fabs(pau->m_fltSinRampDownPrior - cos( dA )) <= 0.0001);
                assert(fabs(pau->m_fltCosRampDownPrior - sin( dA )) <= 0.0001);
                assert(fabs(pau->m_fltSinRampDownStep  - 2 * sin( 2*dA )) <= 0.0001);
            }
#           endif // _DEBUG
        }
        else
#   endif // !defined(V4V5_COMPARE_MODE) && !defined(INTEGER_ENCODER)    
        { 
            // START:  sin ((0.5 + iSize2Use) * PI / (2*iSize2Use) )
	        //		 = sin ( PI/(4*iSize2Use) + PI/2 ) =  cos( PI/(4*iSize2Use) )
	        // AND:    cos ((0.5 + iSize2Use) * PI / (2*iSize2Use) )
	        //       = cos ( PI/(4*iSize2Use) + PI/2 ) = -sin( PI/(4*iSize2Use) )
	        dA = PI/(4* iSize2Use);
            pau->m_fltSinRampDownStart = (V4V5COMPARE)(cos( dA ));
            pau->m_fltCosRampDownStart = (V4V5COMPARE)(-sin( dA ));
	        // PRIOR:  sin ((0.5 + iSize2Use) * PI / (2*iSize2Use) -PI/(2*iSize2Use) )
	        //       = sin ( PI/(4*iSize2Use) + PI/2 - PI/(2*iSize2Use) ) 
            //       = cos( -PI/(4*iSize2Use) ) = cos( PI/(4*iSize2Use) )
	        // AND:    cos ((0.5 + iSize2Use) * PI / (2*iSize2Use) -PI/(2*iSize2Use) )
	        //       = cos ( PI/(4*iSize2Use) + PI/2 - PI/(2*iSize2Use) ) 
            //       = -sin( -PI/(4*iSize2Use) ) = sin( PI/(4*iSize2Use) )
	        pau->m_fltSinRampDownPrior =  (V4V5COMPARE)(cos( dA ));
	        pau->m_fltCosRampDownPrior =  (V4V5COMPARE)(sin( dA ));
	        // Rotate by PI/(2*iSize2Use)

	        pau->m_fltSinRampDownStep  =  (V4V5COMPARE)( 2 * sin( 2*dA ) );
        }

#ifdef INTEGER_ENCODER
    wmaResult = prvAdaptTrigToSubframeConfig_INT(pau);
#endif  // INTEGER_ENCODER
    return wmaResult;
}

#endif // !BUILD_INTEGER

/////////////////////////////////////////////////////////////////////////
//      Floating point versions of code that has already been integerized
//      this may eventually be deleted
//////////////////////////////////////////////////////////////////////////

// DEBUG_BREAK at a particular Frame in prvInverseQuantizeHighRate or prvInverseQuantizeLowRate 
//#define INVERSE_QUANTIZE_AT_FRAME 26
// PRINT CoefRecon for all Frames in range (define or undefine both at once)
//#define PRINT_INVERSE_QUANTIZE_AT_FRAME_FIRST 178
//#define PRINT_INVERSE_QUANTIZE_AT_FRAME_LAST  178
#if defined(_DEBUG) && ( defined(INVERSE_QUANTIZE_AT_FRAME) || defined(PRINT_INVERSE_QUANTIZE_AT_FRAME_FIRST)  )
#	pragma COMPILER_MESSAGE(__FILE__ "(235) : Warning - Float Inverse Quantize Debug Code Enabled.")
static int iInvQuantFrameCount = 0;
static int iInvQuantSubFrameCount = 0;
#endif
#if defined(_DEBUG) && defined(INVERSE_QUANTIZE_AT_FRAME)
#	define DEBUG_BREAK_AT_FRAME_INV_QUANT															\
		if ( pau->m_iCurrSubFrame == 0 && ppcinfo == pau->m_rgpcinfo )								\
		{	iInvQuantFrameCount++;	iInvQuantSubFrameCount = 0; }									\
		else if ( ppcinfo == pau->m_rgpcinfo ) iInvQuantSubFrameCount++;							\
		if ( iInvQuantFrameCount == INVERSE_QUANTIZE_AT_FRAME )										\
			DEBUG_BREAK();				
#elif defined(_DEBUG) && defined(PRINT_INVERSE_QUANTIZE_AT_FRAME_FIRST)
#	define DEBUG_BREAK_AT_FRAME_INV_QUANT															\
		if ( pau->m_iCurrSubFrame == 0 && ppcinfo == pau->m_rgpcinfo )								\
		{	iInvQuantFrameCount++;	iInvQuantSubFrameCount = 0; }									\
		else if ( ppcinfo == pau->m_rgpcinfo ) iInvQuantSubFrameCount++;
#else	// defined(_DEBUG) && defined(INVERSE_QUANTIZE_AT_FRAME)
#	define DEBUG_BREAK_AT_FRAME_INV_QUANT
#endif	// defined(_DEBUG) && defined(INVERSE_QUANTIZE_AT_FRAME)
#if defined(PRINT_INVERSE_QUANTIZE_AT_FRAME_FIRST)
#	define PRINT_INVERSE_QUANTIZE(iQ,fltW,fltN)																									\
		if ( PRINT_INVERSE_QUANTIZE_AT_FRAME_FIRST <= pau->m_iFrameNumber &&  pau->m_iFrameNumber <= PRINT_INVERSE_QUANTIZE_AT_FRAME_LAST )	\
			printf("IQ:%4d %2d %1d  %4d  %+16.6f  %+16.6f  %4d %+10.4g\n",																			\
				 pau->m_iFrameNumber, pau->m_iCurrSubFrame, ppcinfo-pau->m_rgpcinfo, iRecon, fltW,rgfltCoefRecon [iRecon], iQ, fltN );
#else
#	define PRINT_INVERSE_QUANTIZE(iQ,fltW,fltN)
#	endif

#ifndef BUILD_INTEGER
#ifdef ENABLE_ALL_ENCOPT

//*************************************************************************************************
// prvInverseQuantizeLowRate() calculates values in rgfltCoefRecon[] prior to DCT 
// Handles both MidRate (NoiseSub and Bark Spectrum) and LowRate (NoiseSub and LPC Spectrum)
//*************************************************************************************************
WMARESULT prvInverseQuantizeLowRate (CAudioObject* pau, PerChannelInfo* ppcinfo, Int* rgiWeightFactor)
{
    FUNCTION_PROFILE(fp);
    FUNCTION_PROFILE_START(&fp,INVERSE_QUAN_LOW_RATE_PROFILE);
    {
		//Double dblQuantStep = (double)pau->m_iQuantStep/(1<<pau->m_iQuantStepFractBits);
		QuantStepType qstQuantStep = qstCalcQuantStep( pau->m_iQuantStepSize );
		const Float* rgfltWeightFactor  = (Float*) rgiWeightFactor;
		Float fltInvMaxWeight = 1.0F / ppcinfo->m_wtMaxWeight;
        const I16* rgiCoefQ             = ppcinfo->m_rgiCoefQ;
        Float* rgfltCoefRecon           = ppcinfo->m_rgfltCoefRecon;
	    Int iBark = 0;
	    Int iCoefQ = 0;
	    Int iRecon = 0;
        const U8* rgbBandNotCoded       = ppcinfo->m_rgbBandNotCoded;
        const Int* rgiNoisePower		= ppcinfo->m_rgiNoisePower;
#ifdef ENCODER
        const Float* rgfltBandWeight    = ppcinfo->m_rgfltBandWeight;
#else
		const FastFloat* const rgffltSqrtBWRatio = ppcinfo->m_rgffltSqrtBWRatio;
#endif
	    //	Float* rgfltNoise = pau->m_rgfltGaussRand + (rand () % (20480 / pau->m_cSubband)) * pau->m_cSubband; //swith to diff segments
	    U8 cNoiseBand;
	    Int iNoiseBand = 0;
		QuantStepType qstQuantStepDivMaxWeight = qstQuantStep * fltInvMaxWeight;
		Float fltNoiseFactor;
		Int iTarget;

		DEBUG_BREAK_AT_FRAME_INV_QUANT;
		MONITOR_RANGE(gMR_QuantStepXInvMaxWeight,qstQuantStep*fltInvMaxWeight);		// match monitor in integer version

		if (!pau->m_fNoiseSub) {
			// Unusual case, but 8kHz Mono 8kpbs gets here
			memset (rgfltCoefRecon, 0, pau->m_cLowCutOff * sizeof (Float));
			for (iRecon = pau->m_cLowCutOff; iRecon < pau->m_cHighCutOff; iRecon++, iCoefQ++)
    			rgfltCoefRecon [iRecon] = (Float)((Float) (rgiCoefQ [iCoefQ]) * rgfltWeightFactor [iRecon] * qstQuantStepDivMaxWeight );
			memset (rgfltCoefRecon + pau->m_cHighCutOff, 0, (pau->m_cSubband - pau->m_cHighCutOff) * sizeof (Float));
            FUNCTION_PROFILE_STOP(&fp);
			return WMA_OK;
		}

		cNoiseBand = rgbBandNotCoded[0];

		fltNoiseFactor = pau->m_fltDitherLevel / (Float) 0x20000000;
		iTarget = pau->m_cLowCutOff;
		while  (iRecon < iTarget) 	
		{	// This does not happen in V2 sounds, don't bother to optimize
		    Float fltNoise = fltNoiseFactor * ((Float) quickRand (&(pau->m_tRandState)));
		    rgfltCoefRecon [iRecon] = (Float) (fltNoise * rgfltWeightFactor [pau->m_cLowCutOff] * qstQuantStepDivMaxWeight );
			MONITOR_RANGE(gMR_CoefRecon,rgfltCoefRecon[iRecon]);
			MONITOR_COUNT_CONDITIONAL(fabs(rgfltCoefRecon[iRecon])<(1.0F/(1<<TRANSFORM_FRACT_BITS)),gMC_zeroCoefRecon,1);
			MONITOR_RANGE(gMR_WeightRatio,(rgfltWeightFactor[pau->m_cLowCutOff]*fltInvMaxWeight));
			PRINT_INVERSE_QUANTIZE(0,rgfltWeightFactor[pau->m_cLowCutOff],fltNoise);
		    iRecon++;
        }

		iTarget = pau->m_iFirstNoiseIndex;
	    while  (iRecon < iTarget) {
            Float fltNoise = ((Float) quickRand (&(pau->m_tRandState))) * fltNoiseFactor;
		    if (iRecon >= pau->m_rgiBarkIndex [iBark + 1]) 
				iBark++;
            assert(iBark < NUM_BARK_BAND);
		    rgfltCoefRecon [iRecon] = (Float) ((rgiCoefQ [iCoefQ] + fltNoise) * rgfltWeightFactor [iRecon] *
                qstQuantStepDivMaxWeight );			
			MONITOR_RANGE(gMR_CoefRecon,rgfltCoefRecon[iRecon]);
			MONITOR_COUNT_CONDITIONAL(fabs(rgfltCoefRecon[iRecon])<(1.0F/(1<<TRANSFORM_FRACT_BITS)),gMC_zeroCoefRecon,1);
			MONITOR_RANGE(gMR_WeightRatio,(rgfltWeightFactor[iRecon]*fltInvMaxWeight));
			MONITOR_RANGE(gMR_weightFactor,rgfltWeightFactor[iRecon]);
			MONITOR_RANGE(gMR_QuantStepXMaxWeightXWeightFactor,rgfltWeightFactor[iRecon]*qstQuantStepDivMaxWeight);
			PRINT_INVERSE_QUANTIZE(rgiCoefQ [iCoefQ],rgfltWeightFactor [iRecon],fltNoise);
		    iRecon++;
		    iCoefQ++;
        }  
		
        while  (iRecon < pau->m_cHighCutOff) {
		    if (iRecon >= pau->m_rgiBarkIndex [iBark + 1]) 
				iBark++;
            assert(iBark < NUM_BARK_BAND);
			iTarget = min(pau->m_rgiBarkIndex [iBark + 1],pau->m_cHighCutOff);

			if (rgbBandNotCoded [iBark] == WMAB_TRUE)
            {
#ifdef ENCODER
                Float fltNoisePower0 = (Float) qstCalcQuantStep(rgiNoisePower [iNoiseBand]);
                Float fltNoisePower1 = (Float) (sqrt (rgfltBandWeight [iNoiseBand] / rgfltBandWeight [cNoiseBand - 1]));
                Float fltNoisePower = fltNoisePower0 * fltNoisePower1; // Exact match with int-float decoder only when I store in two variables! Naveen
#else
				Float fltNoisePower = (Float)( qstCalcQuantStep(rgiNoisePower [iNoiseBand]) * rgffltSqrtBWRatio[iNoiseBand] );
#endif
			    assert(iBark < NUM_BARK_BAND);
				fltNoisePower *= fltInvMaxWeight / (Float) 0x20000000;
			    while (iRecon < iTarget)
                {
				    rgfltCoefRecon [iRecon] = ((Float) quickRand (&(pau->m_tRandState))) * fltNoisePower 
											* rgfltWeightFactor [iRecon];
					MONITOR_RANGE(gMR_CoefRecon,rgfltCoefRecon[iRecon]);
					MONITOR_COUNT_CONDITIONAL(fabs(rgfltCoefRecon[iRecon])<(1.0F/(1<<TRANSFORM_FRACT_BITS)),gMC_zeroCoefRecon,1);
					MONITOR_RANGE(gMR_WeightRatio,(rgfltWeightFactor[iRecon]*fltInvMaxWeight));
					MONITOR_RANGE(gMR_weightFactor,rgfltWeightFactor[iRecon]);
					PRINT_INVERSE_QUANTIZE(0,rgfltWeightFactor [iRecon],rgfltCoefRecon [iRecon]/rgfltWeightFactor [iRecon]);
				    iRecon++;	
			    }
			    iNoiseBand++;
		    }
		    else 
			{
				if ( pau->m_cHighCutOff < iTarget )
					iTarget = pau->m_cHighCutOff;
			    while (iRecon < iTarget)
                {
					Float fltNoise = ((Float) quickRand (&(pau->m_tRandState))) * fltNoiseFactor;
					rgfltCoefRecon [iRecon] = (Float) ((rgiCoefQ [iCoefQ] + fltNoise) * rgfltWeightFactor [iRecon] *
						qstQuantStepDivMaxWeight );			
					MONITOR_RANGE(gMR_CoefRecon,rgfltCoefRecon[iRecon]);
					MONITOR_COUNT_CONDITIONAL(fabs(rgfltCoefRecon[iRecon])<(1.0F/(1<<TRANSFORM_FRACT_BITS)),gMC_zeroCoefRecon,1);
					MONITOR_RANGE(gMR_WeightRatio,(rgfltWeightFactor[iRecon]*fltInvMaxWeight));
					MONITOR_RANGE(gMR_QuantStepXMaxWeightXWeightFactor,rgfltWeightFactor[iRecon]*qstQuantStepDivMaxWeight);
					MONITOR_RANGE(gMR_weightFactor,rgfltWeightFactor[iRecon]);
					PRINT_INVERSE_QUANTIZE(rgiCoefQ [iCoefQ],rgfltWeightFactor [iRecon],fltNoise);
					iRecon++;
					iCoefQ++;
				}
		    }
	    }

		iTarget = pau->m_cSubband;
		fltNoiseFactor *= (Float)(rgfltWeightFactor [pau->m_cHighCutOff - 1] * qstQuantStepDivMaxWeight);
	    while  (iRecon < iTarget) 	{
		    rgfltCoefRecon [iRecon] = ((Float) quickRand (&(pau->m_tRandState))) * fltNoiseFactor;
			// MONITOR_RANGE(gMR_CoefRecon,rgfltCoefRecon[iRecon]);
			// if (fabs(rgfltCoefRecon[iRecon])<(1.0F/(1<<TRANSFORM_FRACT_BITS))) { MONITOR_COUNT(gMC_zeroCoefRecon,1); }
			MONITOR_RANGE(gMR_WeightRatio,(rgfltWeightFactor[pau->m_cHighCutOff-1]*fltInvMaxWeight));
			MONITOR_RANGE(gMR_QuantStepXMaxWeightXWeightFactor,rgfltWeightFactor[pau->m_cHighCutOff-1]*qstQuantStepDivMaxWeight);
			MONITOR_RANGE(gMR_weightFactor,rgfltWeightFactor[pau->m_cHighCutOff-1]);
			PRINT_INVERSE_QUANTIZE(0,rgfltWeightFactor [iRecon],rgfltCoefRecon [iRecon]/rgfltWeightFactor [pau->m_cHighCutOff - 1]);
		    iRecon++;
        }    
    }
    FUNCTION_PROFILE_STOP(&fp);
	return WMA_OK;
}
#endif // ENABLE_ALL_ENCOPT
#endif // !BUILD_INTEGER
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\wmalib\wmadec_s\autoprofile.c ===
#pragma code_seg("WMADEC")
#pragma data_seg("WMADEC_RW")
#pragma const_seg("WMADEC_RD")

#pragma warning( disable : 4103 )
#include "../include/AutoProfile.h"
#include "..\..\..\dsound\dsndver.h"

#ifdef PROFILE

#include <stdio.h>
//#include <assert.h>
#include <tchar.h>

//****************************************************************************************
//
// The Zen and the Art of Profiling 
//   by Sil after much befuddlement
//
// Profile as few things as possible to get your result.  
//
// Each profile start-stop pair costs 3.770 microsocnds on a 500MHz Pentium.
// So profiling a per-coefficent function like getNextRunLevelHighRate costs 
// 2.3 seconds of execution time for a process which otherwise only takes 1.6 seconds
//
// Unless you correct for the start-stop overhead, changing the profile configurtation
// will effect the overall results.  A spreadsheet could take this current output and
// do such a correction - given you measure the start-stop overhead of your test machines.
//
// The start-stop overhead gets distributed to the parent and the child functions.
//
// Some runs are significantly off - if the results don't make sense, repeat them.
//
// But similiar runs are pretty similar.  I have not quantified the variance.
//
//****************************************************************************************
   
ProfileFunctionDeffinitionType Profiler_functionDefintions[MAX_FUNCTIONS_TO_PROFILE] = {0,_T(""),

MSAC_DECODE_PROFILE					,_T("Decode"),
DECODE_PROFILE                      ,_T("..audecDecode"),
WMA_FILE_DECODE_DATA_PROFILE        ,_T("..WMAFileDecodeData"),
DECODE_PACKET_PROFILE               ,_T("....DecodePacket"),
DECODE_FRAME_PROFILE                ,_T("......DecodeFrame"),
AUDEC_DECODE_DATA_PROFILE           ,_T("......audecDecodeData"),
SAVE_HISTORY_MONO_PROFILE			,_T("........Save History Mono"),
DECODE_SUB_FRAME_PROFILE            ,_T("........DecodeSubFrame"),
DECODE_SUB_FRAME_HIGH_RATE_PROFILE  ,_T("........DecodeSubFrameHighRate"),
DECODE_FRAME_HEADER_PROFILE         ,_T("..........DecodeFrameHeader"),
UPDATE_SUB_FRAME_CONFIG_PROFILE     ,_T("............UpdateSubFrameConfig"),
ADAPT_TO_SUB_FRAME_CONFIG_PROFILE   ,_T("............AdaptToSubFrameConfig"),
SET_DET_TABLE_PROFILE               ,_T("............SetDetTable"),
FRAME_HEADER_NOISE_SUB_PROFILE		,_T("............DecodeFrameHeaderNoiseSub"),
FRAME_HEADER_LPC_PROFILE			,_T("............DecodeFrameHeaderLpc"),
LPC_TO_SPECTRUM_PROFILE  			,_T("..............prvLpcToSpectrum"),
FFT32_PROFILE                       ,_T("................prvFFT32"),
GET_BAND_WEIGHTS_PROFILE			,_T("............GetBandWeightXxxRate"),
INVERSE_QUAN_HIGH_RATE_PROFILE      ,_T("..........InverseQuantizeHighRate"),
DECODE_COEFFICENTS_HIGH_RATE_PROFILE,_T("..........ReconCoefficentsHighRate"),

DECODE_COEFFICENT_STEREO_PROFILE    ,_T("..........DecodeCoefficientStereo"),
DECODE_COEFFICENT_MONO_PROFILE      ,_T("............prvDecodeCoefficientMono"),
DECODE_RUN_LEVEL_PROFILE            ,_T("..............prvDecodeRunLevel"),
HUFF_DEC_GET_PROFILE                ,_T("................HuffDecGet"),
INVERSE_QUAN_HIGH_SDTOLR_PROFILE	,_T("..........InverseQuantizeHighRateSDtoLR"),
INVERSE_QUAN_LOW_RATE_PROFILE		,_T("..........prvInverseQuantizeLowRate"),
INVERSE_QUAN_MID_RATE_PROFILE		,_T("..........prvInverseQuantizeMidRate"),
DCTIV_PROFILE                       ,_T("..........DctIV"),
FFT_PROFILE                         ,_T("............FFT"),

WMA_FILE_GET_PCM_PROFILE            ,_T("..WMAFileGetPCM"),
AU_GET_PCM_PROFILE                  ,_T("....auGetPCM"),
INVERSE_TRANSFORM_AND_RECON_PROFILE ,_T("........InverseTransformAndRecon"),
INVERSE_TRANSFORM_MONO_PROFILE		,_T("..........InverseTransformMono"),
RECON_MONO_PROFILE          		,_T("..........ReconMono"),
CONVERT_SD_TO_LR_PROFILE            ,_T("Convert s/d to l/r"),
INVERSE_OUANTIZE_SPECTRUM_PROFILE	,_T("Quantize Spectrum"),
0,_T("")
}; 

int     Profiler_functionCountCalls[MAX_FUNCTIONS_TO_PROFILE];
__int64 Profiler_functionTimings[MAX_FUNCTIONS_TO_PROFILE];
__int64 Profiler_functionPlusChildTimings[MAX_FUNCTIONS_TO_PROFILE];
__int64 Profiler_totalTime;
__int64 profileStartTime;
HANDLE hProfile;
FunctionProfile *Profiler_lastFunctionProfiler;

void Profiler_init(TCHAR* wcsProfilerName )
{
	Profiler_initEX(wcsProfilerName, 0 );
}

void Profiler_initEX(TCHAR* szProfilerName, int fAppend )
{
    LONGLONG startTime;
#if defined(_UNICODE) || defined(UNICODE)
	WCHAR* wcsProfilerName = szProfilerName;
#else
    WCHAR wcsProfilerName[200];
    mbstowcs( wcsProfilerName, szProfilerName, strlen(szProfilerName)+1 );
#endif

    hProfile = CreateFileW(wcsProfilerName, 
						   GENERIC_WRITE, FILE_SHARE_WRITE, NULL, 
						   fAppend ? OPEN_ALWAYS : CREATE_ALWAYS, 
						   FILE_ATTRIBUTE_NORMAL, NULL);

	if ( fAppend && hProfile != NULL )
		SetFilePointer( hProfile, 0L, NULL, FILE_END ); 

	memset( Profiler_functionCountCalls, 0, sizeof(int)*MAX_FUNCTIONS_TO_PROFILE );
	memset( Profiler_functionTimings, 0, sizeof(__int64)*MAX_FUNCTIONS_TO_PROFILE );
	memset( Profiler_functionPlusChildTimings, 0, sizeof(__int64)*MAX_FUNCTIONS_TO_PROFILE );

    Profiler_lastFunctionProfiler = NULL;
    Profiler_totalTime = 0;
    Profiler_getTimer(&startTime);
    profileStartTime = startTime;
}

void Profiler_print(TCHAR* szMsg)
{
    DWORD dwBytesWritten;		
    if (hProfile)
    {
        WriteFile(hProfile, (void*) szMsg, sizeof(TCHAR) * _tcslen(szMsg), &dwBytesWritten, NULL);
    }		
}

void Profiler_close(void)
{
	Profiler_closeEX(0,0,NULL);
}

void Profiler_closeEX(unsigned int Duration, DWORD TotalTime, TCHAR* szMsg)
{
    LONGLONG stopTime;
    int i = 1;
    TCHAR buff[120];
	float fltTotalTime;
    Profiler_getTimer(&stopTime);
    Profiler_totalTime = stopTime-profileStartTime;
	fltTotalTime = (float)Profiler_totalTime;
	if (szMsg != NULL)
		Profiler_print(szMsg);
    _stprintf(buff,_T("Total Time %10.0f\r\n\r\n"),fltTotalTime);
    Profiler_print(buff);
	if ( Duration != 0 && TotalTime != 0 )
	{	// change duration to media play duration converted to profiling time units
		fltTotalTime = Duration * (fltTotalTime/TotalTime);
		_stprintf(buff,_T("Play Time  %10.0f ms == %10.0f profile time units.\r\n\r\n"),(float)Duration, fltTotalTime);
		Profiler_print(buff);
	}
    _stprintf(buff,_T("  Function   Function  Function  Function\r\n"));
    Profiler_print(buff);
    _stprintf(buff,_T("   + child       only  + child   only\r\n"));
    Profiler_print(buff);
    _stprintf(buff,_T("      time       time  ratio     ratio     Count  Function Name\r\n\r\n"));
    Profiler_print(buff);
    do {
        int j = Profiler_functionDefintions[i].id;
        if (Profiler_functionPlusChildTimings[j] > 0) {
            
            _stprintf(buff,_T("%10.0f %10.0f  %7.5f   %7.5f %7d  %s,\r\n"),
				(float)(Profiler_functionPlusChildTimings[j]),
				(float)(Profiler_functionTimings[j]),
				((float)Profiler_functionPlusChildTimings[j]/fltTotalTime),
				((float)Profiler_functionTimings[j]/fltTotalTime),
				Profiler_functionCountCalls[j],
				Profiler_functionDefintions[i].name);
            Profiler_print(buff);
        }
    } while (++i < MAX_FUNCTIONS_TO_PROFILE);

	CloseHandle(hProfile);
}
#endif	// PROFILE
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\wmalib\wmadec_s\huffdec.c ===
/*************************************************************************

Copyright (C) Microsoft Corporation, 1996 - 1999

Module Name:

    HuffDec.cpp

Abstract:

    Huffman decoder. Simplified from Sanjeevm's huffman.cpp

Author:

    Wei-ge Chen (wchen) 19-July-1999

Revision History:


*************************************************************************/

#pragma code_seg("WMADEC")
#pragma data_seg("WMADEC_RW")
#pragma const_seg("WMADEC_RD")

#include <stdio.h>
#include <stdlib.h>
#include "..\common\macros.h"
#include "..\decoder\huffdec.h"
#include "..\..\..\dsound\dsndver.h"

#ifdef PROFILE
#include "autoprofile.h"
#endif


WMARESULT huffDecGet(const U16 *pDecodeTable, CWMAInputBitStream *bs,
                     U32* puBitCnt, U32 *puResult, U32* puSign)
{
     const int FIRST_LOAD = 10;
     const int SECOND_LOAD = 12;

     unsigned int ret_value;
     const unsigned short* node_base = pDecodeTable;

     U32 uBits;
     U32 codeword;
     int i;

     WMARESULT  wmaResult;
#ifdef PROFILE
	 //profiling a function that gets called this often has too much overhead.
     //FunctionProfile fp;
     //FunctionProfileStart(&fp,HUFF_DEC_GET_PROFILE);
#endif

     TRACEWMA_EXIT(wmaResult, (*(bs->ibstrmpfnPeekBits))(bs, FIRST_LOAD + SECOND_LOAD + 1, &uBits));
     codeword = uBits;

     // Do first five 2-bit tables
     i = 5;
     do
     {
         node_base += ((codeword & 0xC0000000) >> 30);  // Use top 2 bits as offset
         ret_value = *node_base;
         if (ret_value & 0x8000)
             goto decode_complete;  // Found a leaf node!

         node_base += ret_value;    // No leaf node, follow the offset
         codeword <<= 2;            // Advance to next 2 bits
         i -= 1;
     } while (i > 0);

     // Do remaining three 2-bit tables
     i = 3;
     do
     {
         node_base += ((codeword & 0xC0000000) >> 30);  // Use top 2 bits as offset
         ret_value = *node_base;
         if (ret_value & 0x8000)
             goto decode_complete;  // Found a leaf node!

         node_base += ret_value;    // No leaf node, follow the offset
         codeword <<= 2;            // Advance to next 2 bits
         i -= 1;
     } while (i > 0);

     // Do six 1-bit tables
     i = 6;
     do
     {
         node_base += ((codeword & 0x80000000) >> 31);  // Use top bit as offset
         ret_value = *node_base;
         if (ret_value & 0x8000)
             goto decode_complete;  // Found a leaf node!

         node_base += ret_value;    // No leaf node, follow the offset
         codeword <<= 1;            // Advance to next bit
         i -= 1;
     } while (i > 0);


decode_complete:
     assert(ret_value & 0x8000);
     *puBitCnt = ((ret_value >> 10) & (0x0000001F));
     *puResult = ret_value & 0x000003FF;
     if (*puResult >= 0x03FC)
         *puResult = *(node_base + (*puResult & 0x0003) + 1);
     
     if (puSign != NULL)
        *puSign = uBits << *puBitCnt;

exit:
#ifdef PROFILE
    //FunctionProfileStop(&fp);
#endif
     return wmaResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\wmalib\wmadec_s\huffDTbl.c ===
#include "..\common\macros.h"
// **************************************************************************
// Huffman Decoder Tables
//
// These tables are automatically generated by HuffDec.exe. Please do not
// edit these tables by hand. Instead you should make the necessary changes
// to HuffDec.exe and re-generate table using the program.
// **************************************************************************

const U16 g_rgiHuffDecTblMsk[226] =
{
  0x843c, 0x843c, 0x00a4, 0x0001, 0x903e, 0x009d, 0x0098, 0x0001, 
  0x0092, 0x008d, 0x0084, 0x0001, 0x007e, 0x0079, 0x0074, 0x0001, 
  0x006e, 0x0069, 0x005c, 0x0001, 0x0056, 0x0051, 0x0048, 0x0001, 
  0x0042, 0x003b, 0x0002, 0x000f, 0x0034, 0x0007, 0x0002, 0x0097, 
  0x0002, 0x00a5, 0xc800, 0x00a1, 0x0004, 0x0001, 0xc801, 0xc802, 
  0xc813, 0xc803, 0x00a4, 0x000d, 0x0002, 0x0015, 0x0006, 0x0001, 
  0x0002, 0x000d, 0xcc77, 0xcc04, 0x0002, 0x0097, 0xcc0a, 0xcc05, 
  0x009c, 0x0001, 0x0002, 0x0005, 0xcc76, 0xcc06, 0xcc07, 0xcc0f, 
  0xcc08, 0xcc09, 0x0008, 0x0001, 0x0002, 0x0003, 0xcc0b, 0xcc0c, 
  0xcc0e, 0xcc0d, 0x0002, 0x0003, 0xcc10, 0xcc12, 0xcc14, 0xcc11, 
  0xc417, 0x0001, 0xc85a, 0xc815, 0xc01c, 0xc018, 0xc058, 0x0001, 
  0xc419, 0xc416, 0xc056, 0xc01d, 0xc01a, 0xc01b, 0xb854, 0xb820, 
  0x0052, 0x0001, 0xbc1e, 0xbc1e, 0xbc1f, 0xbc1f, 0xb855, 0xb821, 
  0xb824, 0xb822, 0xb453, 0xb453, 0xb825, 0xb823, 0xb050, 0xb028, 
  0x0006, 0x0001, 0xb452, 0xb452, 0xb426, 0xb426, 0xb451, 0xb451, 
  0xb427, 0xb427, 0xb02c, 0xb04f, 0xb02a, 0xb029, 0xac2d, 0xac2d, 
  0xac2b, 0xac2b, 0xa84a, 0xa82e, 0x0026, 0x0029, 0xa848, 0xa830, 
  0xa849, 0xa82f, 0xa431, 0xa431, 0xa447, 0xa447, 0xa034, 0xa045, 
  0xa033, 0x0001, 0xa446, 0xa446, 0xa432, 0xa432, 0x9c43, 0x9c43, 
  0xa035, 0xa044, 0x9c42, 0x9c42, 0x9c36, 0x9c36, 0x9838, 0x9840, 
  0x9837, 0x9841, 0x9439, 0x9439, 0x943f, 0x943f, 0x8c3b, 0x8c3b, 
  0x903d, 0x903a, 0xac4c, 0xac4c, 0xac4b, 0xac4b, 0xac4d, 0xac4d, 
  0xac4e, 0xac4e, 0xbc57, 0xbc57, 0xbc59, 0xbc59, 0x0002, 0x0007, 
  0x0002, 0x0003, 0xcc61, 0xcc5b, 0xcc5c, 0xcc5d, 0x0002, 0x0003, 
  0xcc5e, 0xcc5f, 0xcc60, 0xcc68, 0xcc62, 0xcc63, 0x0002, 0x0003, 
  0xcc64, 0xcc65, 0xcc66, 0xcc75, 0xcc67, 0xcc78, 0x000c, 0x0001, 
  0x0010, 0x0001, 0xcc6e, 0xcc69, 0x0002, 0x0003, 0xcc6a, 0xcc6b, 
  0xcc6c, 0xcc6d, 0x0002, 0x0003, 0xcc6f, 0xcc70, 0xcc71, 0xcc72, 
  0xcc73, 0xcc74
}; 

const U16 g_rgiHuffDecTblNoisePower[76] = {
    0x0004,
    0x003b,
    0x0042,
    0x0045,
    0x0004,
    0x900c,
    0x0016,
    0x9012,
    0x0004,
    0x000f,
    0x940a,
    0x940a,
    0x0004,
    0x0007,
    0xa017,
    0xa007,
    0xa819,
    0xa802,
    0xa81b,
    0xa800,
    0xa41f,
    0xa41f,
    0xa41e,
    0xa41e,
    0xa01d,
    0xa01a,
    0x9c18,
    0x9c18,
    0x9414,
    0x9414,
    0x9816,
    0x0001,
    0x9c08,
    0x9c08,
    0x0002,
    0x0015,
    0xa821,
    0x0003,
    0xa404,
    0xa404,
    0x0004,
    0x0007,
    0x000a,
    0xb001,
    0xb420,
    0xb420,
    0xb405,
    0xb405,
    0xb422,
    0xb422,
    0xb423,
    0xb423,
    0xb424,
    0xb424,
    0xb403,
    0xb403,
    0xa406,
    0xa406,
    0xa41c,
    0xa41c,
    0x9010,
    0x0003,
    0x900b,
    0x9013,
    0x9415,
    0x9415,
    0x9409,
    0x9409,
    0x8c0e,
    0x8c0e,
    0x8c0f,
    0x8c0f,
    0x8c0d,
    0x8c0d,
    0x8c11,
    0x8c11};

#if defined (INSERT_VERSION_INFO)
const U16 g_rgiHuffDecTbl16smOb[] =
#else
const U16 g_rgiHuffDecTbl16smOb[872] =
#endif // INSERT_VERSION_INFO
{
  0x8802, 0x0017, 0x001e, 0x0001, 0x002c, 0x9005, 0x0026, 0x0001, 
  0x0004, 0x003b, 0x980d, 0x0079, 0x0004, 0x006b, 0xa017, 0x0071, 
  0x0004, 0x00bb, 0x0242, 0xa824, 0xb034, 0xb000, 0xad14, 0xad14, 
  0x9073, 0x000b, 0x9004, 0x0001, 0x0018, 0x002b, 0x9801, 0x98e8, 
  0x8c03, 0x8c03, 0x002a, 0x0005, 0x9406, 0x9406, 0x0032, 0x9809, 
  0x980a, 0x000f, 0x9407, 0x9407, 0x0014, 0x980c, 0x9408, 0x9408, 
  0x003c, 0x980b, 0x0022, 0x0009, 0xa013, 0x002b, 0x9c0e, 0x9c0e, 
  0x9c0f, 0x9c0f, 0x0042, 0xa15a, 0x9c10, 0x9c10, 0x0036, 0x00f1, 
  0x9c11, 0x9c11, 0x9d3a, 0x9d3a, 0xa018, 0x0063, 0x9c12, 0x9c12, 
  0x004c, 0xa076, 0x0076, 0xa014, 0x94b7, 0x94b7, 0x9874, 0x0001, 
  0x0064, 0x0013, 0x0016, 0xa015, 0x0110, 0xa016, 0x004a, 0xa077, 
  0xa0b8, 0x0003, 0x9d12, 0x9d12, 0xa419, 0xa419, 0x002e, 0xa8ba, 
  0x0084, 0xa820, 0xa41a, 0xa41a, 0x00c4, 0xa821, 0xa41b, 0xa41b, 
  0x00a4, 0xa87c, 0xa41c, 0xa41c, 0x0004, 0x008f, 0x9c75, 0x9c75, 
  0xa8bb, 0xa993, 0xa41d, 0xa41d, 0xa823, 0xa87e, 0xa41e, 0xa41e, 
  0x0060, 0x01b7, 0xa41f, 0xa41f, 0x0078, 0x020f, 0x001e, 0xa822, 
  0xa825, 0xa996, 0x005a, 0x0051, 0x0004, 0xa175, 0x000a, 0xa078, 
  0xa826, 0x008f, 0xa58e, 0xa58e, 0x00c4, 0x01af, 0xac27, 0xac27, 
  0x0040, 0x004f, 0xa828, 0xa880, 0x0004, 0xa87b, 0x0056, 0x0019, 
  0xad3b, 0xad3b, 0xac29, 0xac29, 0xac2a, 0xac2a, 0xacbd, 0xacbd, 
  0xa584, 0xa584, 0x0026, 0x0001, 0x0070, 0x00d3, 0xac2b, 0xac2b, 
  0xa8bc, 0x0003, 0xa47a, 0xa47a, 0x00f4, 0xb116, 0xac2c, 0xac2c, 
  0xb02e, 0xb02d, 0x0182, 0x0223, 0x0004, 0x0007, 0xa4b9, 0xa4b9, 
  0x01a8, 0xb02f, 0xb0ed, 0x0069, 0xb089, 0xb030, 0xad99, 0xad99, 
  0xa4e9, 0xa4e9, 0x0002, 0xa913, 0xac81, 0xac81, 0xb0bf, 0xb031, 
  0xb032, 0xb13c, 0x003e, 0x020f, 0xb033, 0xb0c2, 0x007a, 0x017d, 
  0xb185, 0x0173, 0xb090, 0xb035, 0xb036, 0x0125, 0xacec, 0xacec, 
  0xb037, 0x01c3, 0x012a, 0x0165, 0x00e8, 0xb038, 0xacbe, 0xacbe, 
  0x00c8, 0x01b3, 0xb039, 0x01fb, 0x01b4, 0x0133, 0x003a, 0x0001, 
  0xb43a, 0xb43a, 0x01ca, 0xb848, 0x0004, 0xb088, 0x015a, 0xb1a1, 
  0xb43b, 0xb43b, 0x0096, 0x0065, 0xb0c1, 0x00ed, 0x0002, 0x012b, 
  0xb849, 0xb8d1, 0xb43c, 0xb43c, 0x0004, 0x003f, 0x008e, 0xa87d, 
  0xb08c, 0x00b3, 0xb1a3, 0x0001, 0xb9b0, 0x01a3, 0xb43d, 0xb43d, 
  0xb43e, 0xb43e, 0x0228, 0x00cf, 0xad9c, 0xad9c, 0x0002, 0xb08b, 
  0x01c0, 0xb8f4, 0xb43f, 0xb43f, 0xb440, 0xb440, 0xb4ca, 0xb4ca, 
  0x0080, 0x0003, 0xac87, 0xac87, 0xb441, 0xb441, 0xb91b, 0xb9b4, 
  0x0064, 0xb8d0, 0xb842, 0x018d, 0xb491, 0xb491, 0xb845, 0xb843, 
  0x0004, 0xb08e, 0xb08a, 0x0021, 0x0030, 0xb844, 0x0092, 0xb93f, 
  0x0004, 0x009b, 0x00fa, 0xa87f, 0xb0c3, 0x0003, 0xac83, 0xac83, 
  0xb95e, 0xb898, 0xb846, 0xb8ce, 0x0004, 0xb176, 0xb08d, 0x0005, 
  0xb847, 0xb95d, 0xb53d, 0xb53d, 0xb84a, 0x013b, 0xb4c9, 0xb4c9, 
  0xb84b, 0xb8f8, 0x017e, 0xb8f7, 0xb9af, 0xb897, 0x0012, 0xb84c, 
  0xb8d3, 0x0003, 0x01dc, 0x00fd, 0xbc4d, 0xbc4d, 0xc106, 0xc0a9, 
  0xbdb2, 0xbdb2, 0xbc4e, 0xbc4e, 0xbc4f, 0xbc4f, 0xc0fe, 0xc12f, 
  0xc0a0, 0x008b, 0xbc50, 0xbc50, 0xa479, 0xa479, 0x0002, 0xa8ea, 
  0x0004, 0x0127, 0xac84, 0xac84, 0x00fc, 0x0003, 0x0012, 0x0005, 
  0xbc51, 0xbc51, 0xbc52, 0xbc52, 0xbc53, 0xbc53, 0xbda2, 0xbda2, 
  0x0134, 0xb8f9, 0xb9b1, 0x0001, 0xbc54, 0xbc54, 0xbd5f, 0xbd5f, 
  0xbc55, 0xbc55, 0xbd21, 0xbd21, 0xc056, 0xc0aa, 0xbd60, 0xbd60, 
  0xc0da, 0xc164, 0xc057, 0xc187, 0xac82, 0xac82, 0xb115, 0x0001, 
  0xb5aa, 0xb5aa, 0x0002, 0x0163, 0x007a, 0xc122, 0xc058, 0xc105, 
  0x0018, 0x0003, 0xb8d4, 0xb986, 0xbc59, 0xbc59, 0xbdb8, 0xbdb8, 
  0xb518, 0xb518, 0x001a, 0x0001, 0xbc5a, 0xbc5a, 0xbc5c, 0xbc5c, 
  0x0036, 0x00c3, 0x0002, 0x01b5, 0xc109, 0xc108, 0xbc5b, 0xbc5b, 
  0xbc5d, 0xbc5d, 0xbcdb, 0xbcdb, 0xb4c6, 0xb4c6, 0x0002, 0x0151, 
  0xc05f, 0xc153, 0xc0a2, 0xc05e, 0xbc9f, 0xbc9f, 0xbc60, 0xbc60, 
  0xc195, 0xc110, 0xc061, 0xc127, 0x004c, 0x00af, 0x0002, 0x0151, 
  0xc139, 0xc062, 0xc156, 0xc17e, 0xb08f, 0x0003, 0xad9f, 0xad9f, 
  0xb4f2, 0xb4f2, 0x001e, 0x0001, 0x00b2, 0x0003, 0xc14a, 0xc0dc, 
  0xc46f, 0xc463, 0xc1c0, 0xc064, 0xc131, 0xc162, 0xc066, 0xc10b, 
  0xc065, 0xc1a8, 0xb4c8, 0xb4c8, 0x0002, 0x008b, 0x0012, 0x015d, 
  0x0002, 0x002d, 0xc467, 0xc5cc, 0x0002, 0x0137, 0xc955, 0xc868, 
  0x0138, 0x0003, 0x0148, 0x0133, 0x0002, 0x00cf, 0xc972, 0xc869, 
  0xc46a, 0xc58d, 0x0122, 0x0003, 0xb4cf, 0xb4cf, 0xbca3, 0xbca3, 
  0xc1ca, 0x0001, 0xc46b, 0xc5d8, 0xb594, 0xb594, 0xb978, 0x0001, 
  0xbd7a, 0xbd7a, 0x0002, 0x0131, 0xc46c, 0xc4e4, 0xc46d, 0xc50c, 
  0x0130, 0x0003, 0xc0ab, 0xc0af, 0xc5d1, 0xc46e, 0xc4e7, 0xc470, 
  0xb5a7, 0xb5a7, 0x0002, 0x00e1, 0x00de, 0x0061, 0x0002, 0x0059, 
  0xc471, 0xc5c7, 0xb8f6, 0x0003, 0xb5a9, 0xb5a9, 0xc148, 0xc0a6, 
  0xc146, 0x0001, 0xc472, 0xc56a, 0x000c, 0x008b, 0xac85, 0xac85, 
  0xac86, 0xac86, 0xb0ee, 0xb0c4, 0xb896, 0xb93e, 0xb492, 0xb492, 
  0x011e, 0xb8d6, 0xb493, 0xb493, 0xb894, 0xb977, 0xb8f3, 0x00a3, 
  0xb495, 0xb495, 0xb4cc, 0xb4cc, 0xb499, 0xb499, 0xb49a, 0xb49a, 
  0xb89b, 0x00c3, 0xb4c5, 0xb4c5, 0xb91c, 0xb89c, 0xb4f1, 0xb4f1, 
  0xbcd5, 0xbcd5, 0xc09d, 0x0035, 0xb1a5, 0x0003, 0xad5b, 0xad5b, 
  0x0022, 0x0003, 0x00c6, 0x0093, 0xc09e, 0xc1bc, 0xc188, 0xc163, 
  0xb517, 0xb517, 0xb8f5, 0x0001, 0xc0a1, 0xc0a7, 0xbdb3, 0xbdb3, 
  0xc166, 0xc0a4, 0xbd00, 0xbd00, 0xc0a5, 0xc1c5, 0xc132, 0xc0ae, 
  0xc1a6, 0xc14b, 0xc0a8, 0xc143, 0xc16b, 0xc0b1, 0xc168, 0xc0ac, 
  0xc5c4, 0xc4ad, 0xc128, 0xc0b0, 0xc111, 0xc0b6, 0xc554, 0xc4b2, 
  0x00be, 0x00c9, 0x00b6, 0x0001, 0xc4b3, 0xc5c8, 0xc4b4, 0xc5d7, 
  0x003e, 0x0001, 0xc8b5, 0xc8e1, 0xaceb, 0xaceb, 0x0012, 0xb0c0, 
  0xb58f, 0xb58f, 0xb4c7, 0xb4c7, 0x002c, 0x006f, 0xb4cb, 0xb4cb, 
  0xb8cd, 0xb997, 0x004c, 0xb9ac, 0x004e, 0xb91e, 0xb4d2, 0xb4d2, 
  0xb55c, 0xb55c, 0x0002, 0xb919, 0xbcd7, 0xbcd7, 0xbcfd, 0xbcfd, 
  0xbcd8, 0xbcd8, 0xbdb6, 0xbdb6, 0xbd04, 0xbd04, 0xbcd9, 0xbcd9, 
  0xc0dd, 0x009b, 0xbcfc, 0xbcfc, 0xbd1f, 0xbd1f, 0xbcde, 0xbcde, 
  0xb5ab, 0xb5ab, 0x0038, 0x0001, 0xbd20, 0xbd20, 0xbcdf, 0xbcdf, 
  0xbce0, 0xbce0, 0xbcff, 0xbcff, 0xc938, 0xc8e2, 0xc90d, 0xc8e3, 
  0xbd1d, 0xbd1d, 0x0002, 0xc14c, 0xc5da, 0x0001, 0xc9d4, 0xc8e5, 
  0xbd90, 0xbd90, 0x0002, 0x0081, 0xc4e6, 0xc5d5, 0xb4ef, 0xb4ef, 
  0x003a, 0xb9ad, 0xb4f0, 0xb4f0, 0x0080, 0xb91a, 0xb8fa, 0x0021, 
  0xb5ae, 0xb5ae, 0xbd9d, 0xbd9d, 0xbcfb, 0xbcfb, 0xbd01, 0xbd01, 
  0x0060, 0x005d, 0xbd02, 0xbd02, 0xbd23, 0xbd23, 0xbd03, 0xbd03, 
  0xbd25, 0xbd25, 0xbd07, 0xbd07, 0xbd44, 0xbd44, 0xc10a, 0xc198, 
  0xc14e, 0xc192, 0xc56e, 0xc50e, 0xc145, 0xc161, 0xc10f, 0xc12b, 
  0xbd24, 0xbd24, 0xbd79, 0xbd79, 0xbd47, 0xbd47, 0xbd26, 0xbd26, 
  0xc17b, 0xc129, 0xc1bf, 0xc149, 0xbd9a, 0xbd9a, 0x0028, 0x0001, 
  0xc52a, 0xc552, 0x0004, 0x0051, 0xc1c3, 0xc1a4, 0xc534, 0xc52c, 
  0xc1cd, 0xc17f, 0xc12d, 0xc1c1, 0xc191, 0xc19b, 0xbd2e, 0xbd2e, 
  0xc165, 0xc150, 0xc142, 0xc130, 0xc933, 0xc9ce, 0xc535, 0xc569, 
  0x0002, 0x0019, 0x0002, 0xc98c, 0xcd37, 0xcd36, 0xbd40, 0xbd40, 
  0xbdb5, 0xbdb5, 0xbd41, 0xbd41, 0xc167, 0xc14d, 0xc54f, 0xc559, 
  0xc5cb, 0xc551, 0xc557, 0xc5c9, 0xc58a, 0xc558, 0xc56c, 0xc56d, 
  0xc56f, 0xc581, 0xc970, 0xc971, 0xc57d, 0xc573, 0xc574, 0xc59e, 
  0x001e, 0xc57c, 0xc580, 0xc5d9, 0xc5d3, 0x0001, 0xc9d2, 0x0001, 
  0xcddb, 0x0001, 0x0008, 0xd182, 0xc583, 0xc5cf, 0xc189, 0xc1be, 
  0xbdb9, 0xbdb9, 0xd5d0, 0xd58b, 0xbdb7, 0xbdb7, 0xbda0, 0xbda0, 
  0xbdba, 0xbdba, 0xbdbb, 0xbdbb, 0xc5c2, 0xc5bd, 0xc9c6, 0xc9d6,
#if defined (INSERT_VERSION_INFO)
  // Magic string
  0x4d57, 0x5641, 0x5245, 0x4953, 0x4e4f, 
  // Length of version info (num U16's)
  0x0005, 
  // version info
  0xbadc, 0x0deb, 0xadc0, 0xdeba, 0xdc0d,
#endif // INSERT_VERSION_INFO
}; 

const U16 g_rgiHuffDecTbl44smOb[2847] = {
0x8802,
0x0003,
0x0453,
0x0687,
0x8c03,
0x8c03,
0x9004,
0x0001,
0x0004,
0x01fc,
0x0297,
0x030b,
0x9cb9,
0x9cb9,
0x0002,
0x018a,
0x0004,
0xab5c,
0x0006,
0x009f,
0xaf93,
0xaf93,
0xac16,
0xac16,
0x0004,
0xb3b9,
0x0055,
0x0058,
0xbb5d,
0x0003,
0x003d,
0x004a,
0x0004,
0x0014,
0x0024,
0x0030,
0x0002,
0x000a,
0x0002,
0x0004,
0xcefd,
0xcffc,
0x0423,
0xcffd,
0xcffd,
0x04e8,
0x04d9,
0x0002,
0x0003,
0xcde8,
0xce1b,
0xce0c,
0xcee6,
0x0002,
0x0009,
0x0002,
0x0004,
0xcffd,
0xcf35,
0x0432,
0xcffd,
0xce1c,
0x04fe,
0x0002,
0x0004,
0xce4a,
0xcffc,
0x04f5,
0xcf58,
0xcd05,
0x0002,
0x0007,
0x0002,
0x0003,
0xcd9c,
0xcc8b,
0xcc9c,
0xcd11,
0x0002,
0xc87a,
0xcd12,
0xcffc,
0x0516,
0x0002,
0x0003,
0xc87d,
0xcb61,
0xcbfd,
0xcbfd,
0x048b,
0x0488,
0x0004,
0x0008,
0x0009,
0xc35e,
0x0002,
0xc4e9,
0xcbfd,
0xc9c7,
0x04ac,
0xc54a,
0xc596,
0xc7fd,
0xc545,
0x0468,
0xc2cb,
0x0003,
0xbccb,
0xbccb,
0xc543,
0xc672,
0xb7de,
0xb7de,
0xb7e0,
0xb7e0,
0x0004,
0x0018,
0x001b,
0x0034,
0xbfff,
0xbfff,
0x0004,
0x0005,
0x042a,
0x042a,
0xc462,
0xc4ea,
0xc7fd,
0x0002,
0x0472,
0x0002,
0xc8f3,
0xcd60,
0x0001,
0x0002,
0x0003,
0xd707,
0xd521,
0xd705,
0xd791,
0xc04f,
0xc1bd,
0xbe32,
0xbe32,
0xc3ff,
0x0004,
0x000a,
0x000f,
0x0447,
0x0002,
0x0003,
0xc873,
0xca76,
0xcbfd,
0xc8f0,
0x04ae,
0x0002,
0x0003,
0xcbb0,
0xc94e,
0xc9d0,
0xcaf9,
0x0002,
0x0005,
0xcbfd,
0xcbfd,
0x04bb,
0x04ad,
0xcb7e,
0xcbf4,
0x0006,
0xc270,
0xbffd,
0xbffd,
0x042e,
0x042e,
0xc542,
0xc544,
0x0004,
0x0033,
0x007c,
0x00c9,
0x0004,
0xb92f,
0xb9f3,
0x0007,
0xbfff,
0xbfff,
0xbe6d,
0xbe6d,
0x0427,
0x0427,
0xc2ab,
0xc181,
0x0002,
0x0003,
0xc730,
0xc4ed,
0xc540,
0x0001,
0x0002,
0x0010,
0x0002,
0x0008,
0x0002,
0x0003,
0xd6bf,
0xd703,
0xd7fd,
0xd6bc,
0x051f,
0x0002,
0x0003,
0xd6a3,
0xd4b5,
0xd5ea,
0xd5eb,
0x0002,
0x0007,
0x0002,
0x0003,
0xd6e2,
0xd65c,
0xd716,
0xd570,
0x0002,
0xd261,
0xd7fd,
0xd65e,
0x0504,
0xb426,
0xb426,
0xb82f,
0x0001,
0xbd7d,
0xbd7d,
0x0002,
0x0022,
0x0002,
0x0012,
0x0002,
0x0008,
0x0002,
0x0003,
0xd337,
0xd0b4,
0xd1e9,
0xd3fc,
0x0534,
0x0002,
0x0004,
0xd3fd,
0xd11a,
0x0530,
0xd34e,
0xd3fc,
0x052f,
0x0002,
0x0007,
0x0002,
0x0003,
0xd2a4,
0xd11c,
0xd0a7,
0xd167,
0x0002,
0x0003,
0xd0a4,
0xd0a3,
0xd0a2,
0xd2e1,
0x0002,
0x000f,
0x0002,
0x0007,
0x0002,
0x0003,
0xd2dd,
0xd28b,
0xd226,
0xd379,
0x0002,
0x0003,
0xd227,
0xd21a,
0xd25d,
0xd313,
0x0002,
0x0008,
0x0002,
0x0003,
0xd2da,
0xd382,
0xd311,
0xd3fc,
0x0535,
0x0002,
0x0003,
0xd087,
0xd295,
0xd3fd,
0xd3fd,
0x050f,
0x0515,
0xb578,
0xb578,
0xbbfd,
0x0002,
0x0403,
0x0004,
0x0019,
0x0028,
0x0036,
0x0002,
0x000f,
0x0002,
0x000b,
0x0002,
0x0005,
0xd3fd,
0xd3fd,
0x0511,
0x0519,
0xd3fd,
0xd3fd,
0x04ff,
0x0528,
0xcfc2,
0xcfca,
0x0002,
0x0003,
0xcd68,
0xcf62,
0xcf63,
0xcf66,
0x0002,
0x0008,
0x0002,
0x0003,
0xce04,
0xcff2,
0xcffd,
0xccf8,
0x04d7,
0x0002,
0x0003,
0xceb8,
0xce7b,
0xcc93,
0xcffc,
0x04e9,
0x0002,
0x0007,
0x0002,
0x0003,
0xcd0f,
0xcf9f,
0xcd09,
0xcf2a,
0x0002,
0x0003,
0xce51,
0xcd07,
0xcffd,
0xcefe,
0x0500,
0x0002,
0x0007,
0x0002,
0x0003,
0xcde1,
0xcfc7,
0xce62,
0xcfb5,
0x0002,
0x0004,
0xcc9b,
0xcffc,
0x04ea,
0xcffd,
0xcca6,
0x0428,
0x0004,
0x0016,
0xb8c7,
0xb9b8,
0x0004,
0x0009,
0x000a,
0x000d,
0x0002,
0x0003,
0xcb88,
0xc959,
0xc990,
0xc958,
0xc4e0,
0xc460,
0xc7fd,
0xc7fd,
0x0467,
0x0485,
0xc673,
0xc7fc,
0x0471,
0xc04d,
0xc0d6,
0xbc3e,
0xbc3e,
0xa719,
0xa719,
0x0002,
0x0027,
0xacbe,
0xacbe,
0xb01d,
0x0001,
0x0004,
0x001a,
0xb52d,
0xb52d,
0xbc41,
0xbc41,
0x0002,
0x0010,
0xc586,
0x0001,
0xcbfd,
0x0002,
0x047f,
0xcffd,
0x0002,
0x04b4,
0xd3fd,
0x0002,
0x0510,
0xd69b,
0x0001,
0xda9c,
0xdb15,
0xc7fd,
0xc7fd,
0x047a,
0x046b,
0x0004,
0xc052,
0xbc3f,
0xbc3f,
0xc7d6,
0xc7fc,
0x0473,
0x0004,
0xb3bd,
0xaf9a,
0xaf9a,
0x0004,
0x0010,
0x002a,
0x0033,
0xc0d7,
0x0005,
0xbffd,
0xbffd,
0x042c,
0x042c,
0x0002,
0x0004,
0xcbfd,
0xc8f4,
0x0404,
0xcb43,
0xc953,
0x0004,
0x000b,
0x0012,
0x0015,
0x0002,
0x0004,
0xca12,
0xcbfc,
0x04a9,
0xcbfd,
0xca79,
0x049c,
0x0002,
0x0004,
0xcbfd,
0xc9cf,
0x04b7,
0xcbfd,
0xcb21,
0x0490,
0x0002,
0xc638,
0xcb32,
0xc9d2,
0xc4e6,
0xc7fc,
0x046d,
0xc3ff,
0xc2f4,
0x0003,
0x0005,
0x0453,
0xc587,
0xc7fc,
0x0463,
0xc5fb,
0xc5c3,
0x0005,
0xc235,
0xc3fd,
0xc182,
0x044b,
0xc637,
0xc7fc,
0x0470,
0x0004,
0xa0ba,
0xa00b,
0x006e,
0xa4bb,
0xa4bb,
0x0002,
0xab67,
0xad29,
0xad29,
0xb0c0,
0x0001,
0x0005,
0xbbfe,
0x0008,
0x002c,
0x0406,
0xbf8c,
0xbf8c,
0xc3b7,
0xc3fc,
0x044d,
0xc3ff,
0xc3ff,
0x0004,
0x0013,
0x0459,
0x044f,
0x0002,
0x0008,
0x0002,
0x0004,
0xcffd,
0xcd24,
0x04ef,
0xcde7,
0xcd62,
0x0002,
0x0003,
0xce41,
0xce4d,
0xcffd,
0xcd10,
0x0503,
0x0002,
0x0008,
0x0002,
0x0003,
0xcd6a,
0xce85,
0xcffd,
0xcea5,
0x0522,
0x0002,
0x0003,
0xceb6,
0xcc90,
0xce91,
0xced2,
0x0004,
0x0015,
0x0025,
0x002b,
0x0002,
0x0009,
0x0002,
0x0003,
0xcee5,
0xcde4,
0xcffd,
0xcffd,
0x04d0,
0x04dc,
0x0002,
0x0004,
0xcffd,
0xce5a,
0x04fd,
0xcffd,
0xcc80,
0x04d8,
0x0002,
0x000b,
0x0002,
0x0005,
0xcffd,
0xcffd,
0x04f8,
0x0425,
0xcffd,
0xcffd,
0x0419,
0x0411,
0x0002,
0xca03,
0xcffd,
0xcfd7,
0x040f,
0x0002,
0x0004,
0xcbfd,
0xcab4,
0x04a0,
0xc950,
0xc9d5,
0x0002,
0x0005,
0xcbfd,
0xcbfd,
0x0491,
0x04a7,
0xc874,
0xcb33,
0xa812,
0x0003,
0xa40e,
0xa40e,
0xb01e,
0xb2c8,
0x0002,
0xb1f1,
0x0004,
0xb831,
0x000e,
0x0011,
0x0005,
0x0007,
0x0008,
0xc3fc,
0x0452,
0xc7fd,
0xc6ae,
0x047d,
0xc541,
0xc4e2,
0xc461,
0xc597,
0xbc42,
0xbc42,
0xbd34,
0xbd34,
0x0004,
0x0005,
0x0006,
0x0008,
0xc6cf,
0xc75f,
0xc4e5,
0xc6af,
0xc465,
0xc7fc,
0x047c,
0xc7fd,
0xc7fd,
0x0475,
0x0482,
0x9d26,
0x9d26,
0xa2a6,
0x0001,
0xa401,
0xa401,
0x0002,
0x0014,
0xac17,
0xac17,
0x0002,
0xb3c0,
0xb4c3,
0xb4c3,
0x0002,
0x0008,
0x0004,
0xc0dc,
0xbeca,
0xbeca,
0xc787,
0xc7fc,
0x0474,
0xbdf6,
0xbdf6,
0xbf2e,
0xbf2e,
0x0004,
0x0007,
0x0021,
0x004a,
0xb7e2,
0xb7e2,
0xb7e6,
0xb7e6,
0x0004,
0x0009,
0xb72d,
0xb72d,
0xc32f,
0xc055,
0xbffd,
0xbffd,
0x0429,
0x0429,
0xbc3d,
0xbc3d,
0x0002,
0x0008,
0x0002,
0x0003,
0xc9d6,
0xcbfa,
0xcbfd,
0xcab1,
0x04cb,
0x0002,
0x0003,
0xca77,
0xc9ce,
0xca78,
0xcb55,
0x0004,
0x0013,
0xb97b,
0x0021,
0x0004,
0x000c,
0xbc40,
0xbc40,
0x0002,
0x0004,
0xc86b,
0xcbfc,
0x04b2,
0xcbfd,
0xcbfd,
0x04a1,
0x03fc,
0xc7fd,
0xc598,
0x046f,
0xbfff,
0xbfff,
0xc053,
0x0003,
0x0431,
0x0431,
0xc46e,
0x0001,
0xc957,
0x0001,
0x0002,
0x0003,
0xd339,
0xd0a9,
0xd328,
0xd34a,
0xbdbb,
0xbdbb,
0xbffd,
0xbffd,
0x042b,
0x042b,
0xb427,
0xb427,
0xbac9,
0x0001,
0xc369,
0x0004,
0x0005,
0xc3fc,
0x0451,
0xc466,
0xc5fd,
0xc594,
0xc6f6,
0x0004,
0x00d7,
0x9c09,
0x9c09,
0xa9f0,
0xa928,
0x0002,
0x0097,
0xafa0,
0xafa0,
0x0002,
0x000a,
0x0005,
0xbbfe,
0xb7e8,
0xb7e8,
0x040a,
0xbf94,
0xbf94,
0xbd33,
0xbd33,
0xbb68,
0xbbfe,
0x0003,
0x0040,
0x0408,
0xc056,
0xc2cc,
0x0002,
0x0022,
0x0002,
0x0010,
0x0002,
0x0007,
0x0002,
0x0003,
0xd349,
0xd0b2,
0xd30f,
0xd34b,
0x0002,
0x0004,
0xd3fd,
0xd10a,
0x052d,
0xd30a,
0xd34c,
0x0002,
0x0008,
0x0002,
0x0003,
0xd0ac,
0xd165,
0xd123,
0xd3fc,
0x0509,
0x0002,
0x0004,
0xd3fd,
0xd25f,
0x052b,
0xd228,
0xd267,
0x0002,
0x0010,
0x0002,
0x0007,
0x0002,
0x0003,
0xd246,
0xd298,
0xd259,
0xd171,
0x0002,
0x0003,
0xd1e3,
0xd2c3,
0xd29d,
0xd3fc,
0x0507,
0x0002,
0x0003,
0xce80,
0xccae,
0xcffd,
0xcffd,
0x04eb,
0x04c7,
0x0004,
0x0013,
0x0022,
0x0032,
0x0002,
0x0007,
0x0002,
0x0003,
0xceff,
0xcf8f,
0xce49,
0xcfbc,
0x0002,
0x0004,
0xcffd,
0xcc91,
0x042d,
0xcfbf,
0xcffc,
0x0506,
0x0002,
0x0008,
0x0002,
0x0004,
0xcc98,
0xcffc,
0x04e7,
0xcebb,
0xccb6,
0x0002,
0x0003,
0xcded,
0xce25,
0xce24,
0xcffc,
0x0532,
0x0002,
0x000a,
0x0002,
0x0005,
0xcffd,
0xcffd,
0x04ca,
0x04de,
0xce7d,
0xcffc,
0x050d,
0x0002,
0x0003,
0xced5,
0xccff,
0xcd69,
0xced6,
0x0002,
0x0008,
0x0002,
0x0004,
0xcfd1,
0xcffc,
0x04e1,
0xcf48,
0xcfd4,
0x0002,
0x0004,
0xcffd,
0xcd9e,
0x04f2,
0xcffd,
0xcd15,
0x051d,
0xac00,
0xac00,
0x0002,
0xb01f,
0x0004,
0x002a,
0xb5b6,
0xb5b6,
0x0004,
0x0012,
0x0018,
0x001e,
0x0002,
0x0008,
0x0002,
0x0003,
0xcd1d,
0xce8e,
0xcdec,
0xcffc,
0x04ce,
0x0003,
0xcbfc,
0x04b5,
0xcffd,
0xcf24,
0x04d3,
0x0002,
0x0003,
0xc95b,
0xc9cd,
0xc9c6,
0xcbfc,
0x04bc,
0x0002,
0x0004,
0xcbfd,
0xc87e,
0x04cd,
0xc9af,
0xc9ee,
0x0002,
0x0003,
0xca05,
0xca3f,
0xcbf8,
0xc954,
0x0004,
0x0005,
0x0007,
0xc183,
0xc46a,
0xc5fc,
0xc591,
0xc7fc,
0x0481,
0xc6f7,
0xc731,
0x0004,
0x0040,
0xa72c,
0xa72c,
0x0004,
0xb3c5,
0x0013,
0xb3c8,
0x0004,
0x000c,
0xb428,
0xb428,
0xbfff,
0xbfff,
0xc3af,
0x0003,
0x0434,
0x0434,
0xc7fd,
0xc7dc,
0x0476,
0xbccc,
0xbccc,
0xc057,
0xc1f9,
0x0004,
0x000b,
0x0012,
0xb8c8,
0xc050,
0x0005,
0xbffd,
0xbffd,
0x0430,
0x0430,
0xc741,
0xc639,
0x0006,
0xc058,
0xbffd,
0xbffd,
0x0436,
0x0436,
0xc4e7,
0xc463,
0xc138,
0xc3fe,
0x0003,
0x000a,
0x0454,
0x0002,
0x0004,
0xcbfd,
0xcafa,
0x04c5,
0xcbfd,
0xca3e,
0x0499,
0x0002,
0x0004,
0xc8f7,
0xcbfc,
0x04a8,
0xca4c,
0xc87f,
0x0004,
0xb12b,
0xae6a,
0xae6a,
0xb5f2,
0xb5f2,
0xb830,
0x0001,
0x0004,
0x000a,
0x0011,
0x0016,
0x0002,
0x0004,
0xcbfd,
0xc87c,
0x04a4,
0xcb56,
0xc9d9,
0x0002,
0x0004,
0xcbab,
0xcbfc,
0x049b,
0xcb57,
0xcbfc,
0x04b6,
0x0002,
0x0003,
0xcba6,
0xcb60,
0xc901,
0xc9ca,
0x0003,
0xc7fc,
0x0478,
0xcbee,
0xc9d3,
0x8cb7,
0x8cb7,
0x0002,
0x0005,
0x9807,
0x99b2,
0x94b8,
0x94b8,
0x0004,
0x015c,
0x9573,
0x9573,
0x0004,
0x00df,
0x9e2d,
0x9e2d,
0x0004,
0xab70,
0x0047,
0xa975,
0x0004,
0x002d,
0xac18,
0xac18,
0x0005,
0x0011,
0x0020,
0xbbfc,
0x040e,
0x0004,
0x0006,
0x0007,
0xc051,
0xc7fd,
0xc464,
0x046a,
0xc54c,
0xc469,
0xc7fd,
0xc7fd,
0x046e,
0x0477,
0x0005,
0xc3fe,
0xbccf,
0xbccf,
0x044c,
0xc588,
0x0001,
0xcbfd,
0x0002,
0x03fe,
0x0002,
0xcfda,
0xd258,
0x0001,
0xd697,
0xd717,
0xbccd,
0xbccd,
0x0002,
0x0003,
0xc71f,
0xc71e,
0xc7d3,
0xc7d9,
0xb832,
0x0003,
0xb66b,
0xb66b,
0xbc43,
0xbc43,
0xc340,
0x0001,
0x0002,
0x0008,
0x0002,
0x0003,
0xcc9f,
0xce81,
0xcf83,
0xcffc,
0x051e,
0x0002,
0x0003,
0xcfe4,
0xcc97,
0xcd14,
0xccaa,
0x0004,
0x002c,
0xb020,
0x007b,
0xb9b9,
0x0004,
0xbbfd,
0xb835,
0x040c,
0xbc45,
0xbc45,
0x0002,
0x0010,
0x0002,
0x0007,
0x0002,
0x0003,
0xcf26,
0xcc8e,
0xce52,
0xcd00,
0x0002,
0x0003,
0xce84,
0xcd5c,
0xcf59,
0xcffc,
0x0513,
0x0002,
0x0007,
0x0002,
0x0003,
0xcf6e,
0xcf64,
0xcf99,
0xcc8c,
0x0002,
0x0005,
0xcffd,
0xcffd,
0x0525,
0x0517,
0xced8,
0xcffc,
0x041f,
0x0004,
0x0030,
0x0043,
0x0048,
0x0004,
0x0014,
0x001e,
0x0023,
0x0002,
0x0008,
0x0002,
0x0004,
0xcffd,
0xce4f,
0x04da,
0xcddc,
0xcfac,
0x0002,
0x0004,
0xcffd,
0xcfb1,
0x04f7,
0xcffd,
0xce23,
0x04f0,
0x0002,
0x0007,
0x0002,
0xc877,
0xcffd,
0xcffd,
0x04fc,
0x04e0,
0xcbfd,
0xc9c9,
0x04db,
0x0002,
0x0003,
0xc9ae,
0xc885,
0xc886,
0xc882,
0x0002,
0x0003,
0xc99f,
0xc884,
0xcbfd,
0xc9cc,
0x04cf,
0x0004,
0x000a,
0x000d,
0x000f,
0x0002,
0x0004,
0xc9cb,
0xcbfc,
0x04ba,
0xc95f,
0xc956,
0x0002,
0xc7df,
0xc8f5,
0xc95a,
0xc4e8,
0xc7fc,
0x0484,
0xc53f,
0xc4e3,
0x0004,
0xc3c1,
0xbc44,
0xbc44,
0xc754,
0xc468,
0xbe33,
0xbe33,
0xbffd,
0xbffd,
0x043a,
0x043a,
0x0004,
0xb834,
0xb833,
0x0009,
0x0004,
0xc0dd,
0xc1bf,
0x0003,
0xc5ff,
0xc76a,
0xc5fe,
0xc589,
0xbf9b,
0xbf9b,
0x0002,
0x0004,
0xc7fd,
0xc6f8,
0x049e,
0xc58a,
0xc592,
0xa813,
0x0003,
0x0028,
0x003f,
0xafa4,
0xafa4,
0x0002,
0x0007,
0xbbff,
0xbbff,
0xb7ed,
0xb7ed,
0x0412,
0x0416,
0x0005,
0xb930,
0xbb71,
0xbbfc,
0x0410,
0xbfff,
0xbfff,
0xc3ff,
0x0004,
0x0438,
0x0438,
0x045d,
0x0002,
0x000c,
0x0002,
0xc95d,
0xcffd,
0x0002,
0x04ed,
0x0003,
0xd3fc,
0x052c,
0xd6e3,
0xd7fc,
0x0533,
0xcbfd,
0xcb8e,
0x04b8,
0xadb4,
0xadb4,
0xb3cc,
0x0001,
0xba6c,
0x0003,
0xb7eb,
0xb7eb,
0xbd7e,
0xbd7e,
0x0002,
0x0007,
0x0002,
0x0003,
0xc961,
0xc8fa,
0xc98e,
0xca13,
0x0003,
0xc7fc,
0x047b,
0xc9de,
0xcbfc,
0x04d2,
0xb177,
0x0003,
0x001b,
0x0030,
0x0004,
0x0009,
0xb73e,
0xb73e,
0xc3ff,
0xc3ff,
0xbeaa,
0xbeaa,
0x045a,
0x0458,
0xbc47,
0xbc47,
0x0002,
0xc1be,
0xc7fd,
0x0002,
0x048d,
0xc9a0,
0x0001,
0x0002,
0x0003,
0xd2d7,
0xd2a2,
0xd304,
0xd2e4,
0x0004,
0x000b,
0xb4c4,
0xb4c4,
0xc3ba,
0x0005,
0xbffd,
0xbffd,
0x043c,
0x043c,
0xc795,
0xc5c4,
0xbfff,
0xbfff,
0x0004,
0xc236,
0x0433,
0x0433,
0xc7fd,
0xc7fd,
0x0489,
0x0480,
0xb429,
0xb429,
0xb579,
0xb579,
0x0004,
0xa174,
0x0006,
0xa00c,
0xa5b3,
0xa5b3,
0xa40f,
0xa40f,
0x0004,
0x00bf,
0xab7b,
0x00c1,
0xb0c1,
0x0003,
0x00a8,
0xb2f1,
0xb9f4,
0x0003,
0x0042,
0x0084,
0xbd35,
0xbd35,
0x0002,
0x0021,
0x0002,
0x0010,
0x0002,
0x0007,
0x0002,
0x0003,
0xd29f,
0xd346,
0xd29a,
0xd308,
0x0002,
0x0003,
0xd30d,
0xd296,
0xd302,
0xd3fc,
0x052e,
0x0002,
0x0007,
0x0002,
0x0003,
0xd28f,
0xd27f,
0xd27c,
0xd265,
0x0002,
0x0003,
0xd253,
0xd264,
0xd3fd,
0xd117,
0x0520,
0x0002,
0x0012,
0x0002,
0x0009,
0x0002,
0x0004,
0xd3fd,
0xd0af,
0x052a,
0xd222,
0xd3fc,
0x051c,
0x0002,
0x0004,
0xd256,
0xd3fc,
0x0521,
0xd166,
0xd21f,
0x0002,
0x0006,
0x0003,
0xcffc,
0x0523,
0xd219,
0xd220,
0xcf29,
0xcede,
0x0004,
0x0014,
0x0024,
0x0032,
0x0002,
0x0008,
0x0002,
0x0003,
0xcedf,
0xcd0e,
0xcffd,
0xcdad,
0x050a,
0x0002,
0x0003,
0xcde0,
0xcec4,
0xcffd,
0xcffd,
0x04e4,
0x04d6,
0x0002,
0x0009,
0x0002,
0x0004,
0xcffd,
0xcfa7,
0x0505,
0xcffd,
0xcca0,
0x0439,
0x0002,
0x0003,
0xcf77,
0xcd72,
0xcfc3,
0xcffc,
0x0502,
0x0002,
0x0008,
0x0002,
0x0004,
0xce44,
0xcffc,
0x0501,
0xcc9d,
0xcf4d,
0x0002,
0x0003,
0xcf84,
0xccab,
0xcf98,
0xcca1,
0x0002,
0x0007,
0x0002,
0x0003,
0xceee,
0xce63,
0xce68,
0xce54,
0x0003,
0xcbfc,
0x0409,
0xcffd,
0xce90,
0x04f3,
0x0004,
0x000a,
0x0011,
0x0019,
0x0002,
0x0004,
0xcbfd,
0xcb7f,
0x04c8,
0xca4b,
0xc8fb,
0x0002,
0x0004,
0xcb74,
0xcbfc,
0x04d5,
0xcb96,
0xcbfc,
0x04dd,
0x0002,
0x0005,
0xcbfd,
0xcbfd,
0x04bf,
0x0400,
0xcbfd,
0xca02,
0x04a2,
0xc54b,
0xc7fc,
0x0496,
0x0004,
0x000d,
0xb52e,
0xb52e,
0x0006,
0x0007,
0xc3fd,
0xc3fd,
0x0455,
0x045f,
0xc595,
0xc78d,
0xc54d,
0xc7a2,
0xbcce,
0xbcce,
0xbc46,
0xbc46,
0xac19,
0xac19,
0xb021,
0xb1b5,
0xafa9,
0xafa9,
0xad76,
0xad76,
0x9125,
0x0003,
0x0346,
0x9005,
0x0004,
0x016c,
0x9406,
0x9406,
0xa2c7,
0x0003,
0x0064,
0x0154,
0xa73d,
0xa73d,
0x0002,
0xa8bd,
0x0004,
0x001c,
0x0049,
0x0057,
0x0004,
0x0009,
0xb7f0,
0xb7f0,
0xc054,
0xc3fe,
0xc3fe,
0xc147,
0x0457,
0x0462,
0x0004,
0x0006,
0x0007,
0xc139,
0xc551,
0xc7fc,
0x047e,
0xc6d0,
0xc58c,
0xc7fd,
0x0002,
0x0487,
0xc94f,
0xcbfc,
0x04aa,
0x0004,
0x0015,
0x0027,
0xb836,
0xbe6e,
0xbe6e,
0x0002,
0x0008,
0x0002,
0x0003,
0xc9a8,
0xcbbb,
0xca3d,
0xcbfc,
0x04b3,
0x0002,
0x0003,
0xc8fe,
0xc9a3,
0xc9a9,
0xcbfc,
0x04b0,
0x0004,
0x0009,
0x000d,
0x000e,
0x0002,
0x0003,
0xcb23,
0xca07,
0xcb6b,
0xca06,
0x0002,
0xc7e3,
0xcbfd,
0xc9c8,
0x04bd,
0xc467,
0xc742,
0xc7f6,
0xc63b,
0xbc4a,
0xbc4a,
0xc05a,
0xc3fc,
0x045b,
0xb8c9,
0xbbfe,
0xbbfe,
0x0003,
0x0414,
0x0418,
0xbfff,
0xbfff,
0x0004,
0xc0de,
0x043d,
0x043d,
0xc7fd,
0xc479,
0x048a,
0xb7f5,
0xb7f5,
0xb42a,
0xb42a,
0x0004,
0xa814,
0x0028,
0x00ae,
0xacbf,
0xacbf,
0x0002,
0xb3cf,
0x0004,
0x000a,
0xb97c,
0x000c,
0xc148,
0xc3fe,
0xbffe,
0xbffe,
0x0456,
0x0442,
0x0442,
0xbfa1,
0xbfa1,
0xbf3f,
0xbf3f,
0x0004,
0xc2ad,
0xbdf7,
0xbdf7,
0xc471,
0x0001,
0x0002,
0x0009,
0x0003,
0xcffc,
0x04e6,
0xd3fd,
0x0002,
0x051a,
0xd56f,
0xd666,
0xcee7,
0xcffc,
0x04e5,
0x0004,
0x0029,
0xafae,
0xafae,
0xb7f3,
0xb7f3,
0x0002,
0xb837,
0xbcd9,
0xbcd9,
0x0002,
0x0010,
0x0002,
0x0008,
0x0002,
0x0003,
0xcefc,
0xcf10,
0xcebe,
0xcffc,
0x0405,
0x0002,
0x0003,
0xce9e,
0xcfdd,
0xcf38,
0xce8a,
0x0002,
0x0008,
0x0002,
0x0004,
0xcffd,
0xce87,
0x042f,
0xce86,
0xcf5b,
0x0002,
0x0003,
0xcfcb,
0xcf65,
0xce8c,
0xcfc4,
0xb42b,
0xb42b,
0x0002,
0x003f,
0x0004,
0x0017,
0x0028,
0x0033,
0x0002,
0x000a,
0x0002,
0x0005,
0xcffd,
0xcffd,
0x0437,
0x043b,
0xce18,
0xcffc,
0x050b,
0x0002,
0x0004,
0xcc96,
0xcffc,
0x0512,
0xcffd,
0xcffd,
0x0529,
0x0526,
0x0002,
0x0009,
0x0002,
0x0005,
0xcffd,
0xcffd,
0x0514,
0x04f6,
0xcda4,
0xce47,
0x0002,
0x0004,
0xcffd,
0xcd08,
0x0524,
0xcd13,
0xcffc,
0x051b,
0x0002,
0x0008,
0x0002,
0x0004,
0xcffd,
0xcd6d,
0x04fb,
0xcddb,
0xce4e,
0xc8fc,
0xcbfc,
0x0413,
0x0002,
0x0004,
0xcbfd,
0xca7a,
0x0417,
0xc89a,
0xcbfc,
0x04b1,
0x0004,
0x0009,
0x000e,
0x0013,
0x0002,
0x0003,
0xcad9,
0xc8f9,
0xc8f6,
0xc904,
0x0002,
0x0003,
0xc9a1,
0xca0f,
0xca0d,
0xc88d,
0x0002,
0x0003,
0xc9d7,
0xcb22,
0xcb34,
0xcbb8,
0x0003,
0xc7fc,
0x048f,
0xcb44,
0xcb45,
0x0004,
0x0019,
0xb022,
0x002a,
0x0004,
0x000d,
0x0010,
0xbb7c,
0x0005,
0x0006,
0xc271,
0xc3fc,
0x045c,
0xc58f,
0xc7e1,
0xc7fd,
0xc79c,
0x0483,
0xc3be,
0xc3cd,
0xbd7f,
0xbd7f,
0xbe34,
0xbe34,
0xc184,
0xc149,
0xb4c5,
0xb4c5,
0x0002,
0x000b,
0xc185,
0x0003,
0xbcd0,
0xbcd0,
0x0003,
0xc7fc,
0x0492,
0xcbfd,
0xc955,
0x04c4,
0xc3ff,
0xc2ac,
0xbfa5,
0xbfa5,
0x045e,
0x0006,
0xbbfe,
0x000d,
0xbbfd,
0x041a,
0x041b,
0xbcd3,
0xbcd3,
0xc059,
0x0001,
0xc7fd,
0x0002,
0x0479,
0xc883,
0xca2b,
0xbcd2,
0xbcd2,
0xbc48,
0xbc48,
0x0004,
0xab85,
0xa410,
0xa410,
0xac1a,
0xac1a,
0xb3d2,
0x0001,
0xbaf2,
0x0003,
0xb7f7,
0xb7f7,
0xc05b,
0xc372,
0xc3fd,
0xc3fd,
0x0450,
0x0465,
0x0004,
0x0111,
0x9c0a,
0x9c0a,
0x0004,
0x0061,
0xa750,
0xa750,
0x0004,
0xb3d5,
0x003a,
0xb12c,
0x0004,
0xb839,
0x0023,
0x002e,
0x0004,
0x000a,
0x0011,
0x0017,
0x0002,
0x0003,
0xca10,
0xca09,
0xc889,
0xcbfc,
0x04c6,
0x0002,
0x0004,
0xcab5,
0xcbfc,
0x0402,
0xcb75,
0xcbfc,
0x040b,
0x0002,
0x0003,
0xcad3,
0xca50,
0xc902,
0xcbfc,
0x04c0,
0x0002,
0x0003,
0xcb36,
0xc895,
0xcbfd,
0xcb9d,
0x04b9,
0x0004,
0x0005,
0xc1c0,
0x0006,
0xc7f1,
0xc4ef,
0xc7fd,
0xc58d,
0x049a,
0xc472,
0xc7fc,
0x049d,
0xbc49,
0xbc49,
0xc13a,
0x0001,
0xc59a,
0xc7fc,
0x0494,
0x0004,
0x0009,
0xb7f9,
0xb7f9,
0xbfff,
0xbfff,
0xbdf8,
0xbdf8,
0x043e,
0x043e,
0x0005,
0xc13c,
0xc3fd,
0x0004,
0x0461,
0xc63a,
0xc552,
0xc7fd,
0x0002,
0x048e,
0x0002,
0x0007,
0x0002,
0x0003,
0xd293,
0xd2c1,
0xd2a0,
0xd2c2,
0x0002,
0x0003,
0xd299,
0xd260,
0xd2eb,
0xd2dc,
0xafb2,
0xafb2,
0x0002,
0x002e,
0x0004,
0x0007,
0x000c,
0xb838,
0xbd80,
0xbd80,
0xbe6f,
0xbe6f,
0xbfff,
0xbfff,
0xbef3,
0xbef3,
0x0440,
0x0440,
0xbf52,
0xbf52,
0xc353,
0x0001,
0x0002,
0x000f,
0x0002,
0x0007,
0x0002,
0x0003,
0xd2e0,
0xd118,
0xd33b,
0xd0b0,
0x0002,
0x0003,
0xd2ed,
0xd33a,
0xd11e,
0xd309,
0x0002,
0x0007,
0x0002,
0x0003,
0xd122,
0xd0b1,
0xd30b,
0xd312,
0xce8d,
0xcffc,
0x0536,
0xb83b,
0xb9ba,
0x0002,
0x0043,
0x0004,
0x0014,
0x0023,
0x0031,
0x0002,
0x000a,
0x0002,
0x0005,
0xcffd,
0xcffd,
0x0531,
0x04f1,
0xce92,
0xcffc,
0x0435,
0x0002,
0x0003,
0xce7e,
0xce45,
0xceb9,
0xce43,
0x0002,
0x0008,
0x0002,
0x0004,
0xce2c,
0xcffc,
0x04ec,
0xce29,
0xceba,
0x0002,
0x0004,
0xce94,
0xcffc,
0x050e,
0xcebd,
0xcfa8,
0x0002,
0x0007,
0x0002,
0x0003,
0xcf25,
0xcd19,
0xcc94,
0xceef,
0x0002,
0x0003,
0xcf00,
0xcdaa,
0xcf7a,
0xcffc,
0x0518,
0x0002,
0x0007,
0x0002,
0x0003,
0xcc9e,
0xce08,
0xcf6f,
0xcf5a,
0x0002,
0x0003,
0xcf4f,
0xcf3c,
0xcf2b,
0xcf92,
0x0004,
0x0011,
0x001f,
0x0029,
0x0002,
0x0007,
0x0002,
0x0003,
0xcfad,
0xcde2,
0xcee8,
0xcee9,
0x0002,
0x0003,
0xcf18,
0xcdb1,
0xcd6c,
0xcdac,
0x0002,
0x0008,
0x0002,
0x0003,
0xcdab,
0xcd1f,
0xcf06,
0xcffc,
0x0537,
0x0002,
0x0003,
0xcd16,
0xcf01,
0xcfe5,
0xcd0b,
0x0002,
0x0007,
0x0002,
0x0003,
0xcfea,
0xcf0e,
0xcd64,
0xcfef,
0xcbfd,
0xc881,
0x040d,
0x0002,
0x0004,
0xcab7,
0xcbfc,
0x04d1,
0xcbfd,
0xcbfd,
0x04d4,
0x0407,
0x0004,
0xa815,
0x004b,
0x0083,
0xad2a,
0xad2a,
0x0002,
0x003e,
0x0004,
0x0024,
0x0030,
0x0036,
0x0004,
0x000a,
0x0011,
0x0016,
0x0002,
0x0004,
0xcbfd,
0xcb47,
0x04c1,
0xcb97,
0xc90c,
0x0002,
0x0004,
0xcb76,
0xcbfc,
0x04ab,
0xc99d,
0xcbfc,
0x04a6,
0x0002,
0x0003,
0xca11,
0xcbce,
0xca42,
0xca55,
0x0002,
0x0003,
0xca88,
0xcb6d,
0xcbfd,
0xcbfd,
0x04c3,
0x04f4,
0x0004,
0x0006,
0x0007,
0x0008,
0xc7fd,
0xc58b,
0x04a5,
0xc4ec,
0xc46d,
0xc476,
0xc7ec,
0xc63c,
0xc6d1,
0x0004,
0xc05d,
0xc31d,
0xc1c1,
0xc470,
0xc7fc,
0x048c,
0xbc4c,
0xbc4c,
0xc13b,
0xc3c9,
0xb7fb,
0xb7fb,
0xbb86,
0x0001,
0xbcd1,
0xbcd1,
0xbd36,
0xbd36,
0x0004,
0x0019,
0x001c,
0xb22f,
0xba31,
0x0003,
0xb8ca,
0x000a,
0xc05e,
0x0005,
0xbffd,
0xbffd,
0x043f,
0x043f,
0xc5d1,
0xc7fc,
0x049f,
0x0004,
0x0006,
0xbc4b,
0xbc4b,
0xc7e9,
0xc7fc,
0x0493,
0xc773,
0xc600,
0xb57a,
0xb57a,
0xb42d,
0xb42d,
0xb751,
0xb751,
0x0002,
0x0008,
0xbfff,
0xbfff,
0xc3ff,
0xc3c6,
0x0445,
0x0445,
0x0460,
0xbfff,
0xbfff,
0xc37d,
0x0003,
0x0446,
0x0446,
0x0002,
0x0005,
0x0002,
0xc892,
0xcd63,
0xcd6e,
0xcbfd,
0xcbfd,
0x0415,
0x041c,
0xaea7,
0xaea7,
0xb023,
0x0001,
0x0004,
0x0007,
0x000c,
0x002a,
0xbfaa,
0xbfaa,
0xbdbc,
0xbdbc,
0xbfff,
0xbfff,
0xbcd4,
0xbcd4,
0x0448,
0x0448,
0x0004,
0x000a,
0x0011,
0x0016,
0x0002,
0x0004,
0xcbfd,
0xcba3,
0x04e2,
0xcab2,
0xcb80,
0x0002,
0x0004,
0xcbfd,
0xc906,
0x04be,
0xcbfd,
0xc8fd,
0x04c9,
0x0002,
0x0003,
0xca15,
0xca16,
0xc903,
0xc9df,
0x0002,
0x0003,
0xc9d8,
0xca14,
0xcbb4,
0xc888,
0x0004,
0x0006,
0x0007,
0x0008,
0xc7fd,
0xc720,
0x0486,
0xc601,
0xc674,
0xc4f1,
0xc7e7,
0xc46f,
0xc7fc,
0x04af,
0x0004,
0x9808,
0x003f,
0x99ef,
0xa2f0,
0x0003,
0x9e69,
0x9e69,
0xaa2e,
0xab8b,
0x0002,
0x0016,
0xac1b,
0xac1b,
0x0002,
0xb024,
0x0006,
0x000a,
0xbbfd,
0xbbfd,
0x041d,
0x0420,
0xc2f5,
0xc3fe,
0xc2cd,
0xc0e1,
0x046c,
0xbfff,
0xbfff,
0xbcdb,
0xbcdb,
0x0441,
0x0441,
0x0004,
0x0007,
0x001a,
0xb3d8,
0xb630,
0xb630,
0xb42c,
0xb42c,
0x0004,
0xb83c,
0xbb1b,
0x000d,
0x0005,
0xc3fe,
0xc05f,
0xc13e,
0x0464,
0xc5c5,
0x0001,
0xca0b,
0x0001,
0xce2a,
0xcffc,
0x0508,
0xc05c,
0xc0df,
0xbf1c,
0xbf1c,
0xb6a8,
0xb6a8,
0xb5b7,
0xb5b7,
0xa00d,
0x0003,
0x00ae,
0xa127,
0x0004,
0x0014,
0xa4bc,
0xa4bc,
0xafb6,
0xafb6,
0x0002,
0xb0c2,
0xb4c6,
0xb4c6,
0x0003,
0xbbfc,
0x0422,
0xbfff,
0xbfff,
0xbfff,
0xbfff,
0x0444,
0x0444,
0x044e,
0x044e,
0xb31a,
0x0003,
0x0015,
0x0038,
0x0004,
0xb931,
0xb932,
0xb9f5,
0x0004,
0x0005,
0xc1c2,
0xc0eb,
0xc46c,
0xc478,
0xc6b0,
0x0001,
0x0002,
0x0003,
0xcd6b,
0xceea,
0xcffd,
0xce5b,
0x050c,
0x0005,
0x000a,
0xbbfd,
0x000e,
0x0426,
0xc146,
0xc0e4,
0xbffd,
0xbffd,
0x0443,
0x0443,
0xbcd5,
0xbcd5,
0xbffd,
0xbffd,
0x0449,
0x0449,
0xc3ff,
0x0004,
0xbcda,
0xbcda,
0x0466,
0x0002,
0x0007,
0x0002,
0x0003,
0xcde5,
0xcd20,
0xce21,
0xcedb,
0x0002,
0x0003,
0xcf90,
0xce1d,
0xcd1b,
0xce1e,
0x0004,
0xb83a,
0x0025,
0x0042,
0xbd37,
0xbd37,
0x0002,
0x0011,
0x0002,
0x0008,
0x0002,
0x0003,
0xcec0,
0xccad,
0xcffd,
0xcf9e,
0x0527,
0x0002,
0x0003,
0xcf14,
0xcc99,
0xcffd,
0xcf81,
0x04fa,
0x0002,
0x0008,
0x0002,
0x0003,
0xcd0d,
0xce82,
0xcf78,
0xcffc,
0x04f9,
0x0002,
0x0003,
0xcca5,
0xcf27,
0xcca8,
0xccb3,
0x0004,
0x0009,
0x000e,
0x0015,
0x0002,
0x0003,
0xcad4,
0xc9da,
0xcac6,
0xcac5,
0x0002,
0x0003,
0xcb8a,
0xca48,
0xc88a,
0xcb89,
0x0002,
0x0004,
0xcbfd,
0xca89,
0x04c2,
0xcbfd,
0xca40,
0x04cc,
0x0002,
0x0003,
0xca0e,
0xcb6c,
0xc9dd,
0xc9e6,
0x0004,
0x0009,
0x0010,
0x0012,
0x0002,
0x0003,
0xca17,
0xc9a5,
0xc9b0,
0xc88f,
0x0002,
0x0004,
0xc9a2,
0xcbfc,
0x0421,
0xcbfd,
0xc95e,
0x04ee,
0xc7fd,
0xc59b,
0x0498,
0xc593,
0xc675,
0xa411,
0xa411,
0x0002,
0x0027,
0x0004,
0x0015,
0xac1c,
0xac1c,
0x0006,
0x000b,
0xb7fd,
0xb7fd,
0x03fd,
0x03fd,
0xbfff,
0xbfff,
0xbcd8,
0xbcd8,
0x044a,
0x044a,
0x0004,
0xc2ce,
0xbc4e,
0xbc4e,
0xc599,
0xc5a6,
0xbbff,
0x0006,
0xb7fe,
0xb7fe,
0x0424,
0x03ff,
0x03ff,
0xbfb3,
0xbfb3,
0x0002,
0x0003,
0xc4ee,
0xc4f2,
0xc475,
0xc7fc,
0x04a3,
0xb025,
0xb3db,
0x0002,
0x0029,
0x0005,
0xbbfe,
0xbaa9,
0x000c,
0x041e,
0x0004,
0x0006,
0xc1fa,
0xc13d,
0xc5a7,
0xc7fc,
0x0497,
0xc5d4,
0xc7fc,
0x0495,
0x0005,
0xc3d0,
0xc3fd,
0x000e,
0x0469,
0xc47b,
0x0001,
0x0002,
0xcafb,
0xce83,
0x0001,
0x0002,
0x0003,
0xd70c,
0xd657,
0xd6a1,
0xd6ec,
0x0002,
0x0004,
0xcbfd,
0xca0a,
0x04e3,
0xcbfd,
0xcab3,
0x04df,
0xb7ff,
0xb7ff,
0xb42e,
0xb42e,
0x0401,
0x0401,};


const U16 g_rgiHuffDecTbl16ssOb[848] =
{
  0x0018, 0x8802, 0x0012, 0x0001, 0x9004, 0x0003, 0x90d8, 0x0021, 
  0x0004, 0x980d, 0x006a, 0x980e, 0x0088, 0x0003, 0x9d4a, 0x9d4a, 
  0xa4de, 0xa4de, 0x00f2, 0xa800, 0x000c, 0x0017, 0x000e, 0x9001, 
  0x0018, 0x9003, 0x0002, 0x0021, 0x9405, 0x9405, 0x001a, 0x9809, 
  0x9406, 0x9406, 0x9920, 0x980a, 0x0030, 0x980c, 0x9407, 0x9407, 
  0x0030, 0x003f, 0x9408, 0x9408, 0x0024, 0x0043, 0x980b, 0x001d, 
  0x0004, 0x002b, 0x002e, 0x0031, 0xa01a, 0x0043, 0x9c0f, 0x9c0f, 
  0x9cd9, 0x9cd9, 0x9c10, 0x9c10, 0x0030, 0x0003, 0x0006, 0x0009, 
  0x9c11, 0x9c11, 0x007e, 0x00f1, 0x9c13, 0x9c13, 0x9c12, 0x9c12, 
  0x9c14, 0x9c14, 0x006e, 0x0071, 0x9c15, 0x9c15, 0xa172, 0x00a1, 
  0x00c0, 0xa021, 0x9c16, 0x9c16, 0xa0db, 0xa023, 0x9c17, 0x9c17, 
  0x9c18, 0x9c18, 0x0082, 0x0041, 0xa019, 0xa01e, 0x0042, 0x002d, 
  0xa01b, 0x004f, 0xa0da, 0x0025, 0x0018, 0xa01c, 0x0042, 0x0045, 
  0x003c, 0x004b, 0x9c1d, 0x9c1d, 0x0014, 0x0023, 0xa01f, 0x0015, 
  0x0054, 0xa020, 0xa022, 0x0055, 0x0094, 0xa024, 0x00ae, 0x0021, 
  0x0054, 0xa836, 0xa425, 0xa425, 0x007c, 0xa835, 0xa426, 0xa426, 
  0xa429, 0xa429, 0xa427, 0xa427, 0xa428, 0xa428, 0x0250, 0x0217, 
  0xa521, 0xa521, 0xa42a, 0xa42a, 0xa42b, 0xa42b, 0xa988, 0x006d, 
  0x0054, 0xa83b, 0xa42c, 0xa42c, 0xa42d, 0xa42d, 0x008a, 0xa8e3, 
  0xa431, 0xa431, 0xa42e, 0xa42e, 0xa42f, 0xa42f, 0xa430, 0xa430, 
  0xa832, 0x00ab, 0xa83a, 0x003d, 0xa433, 0xa433, 0x01e6, 0xa845, 
  0xa834, 0xa922, 0x0026, 0xa8df, 0x022e, 0xa837, 0x002a, 0x00b9, 
  0xa4dc, 0xa4dc, 0x004e, 0xa838, 0xa439, 0xa439, 0x021c, 0xa844, 
  0x00a8, 0xa83c, 0xa4dd, 0xa4dd, 0xa840, 0x01ed, 0xa94b, 0xa83d, 
  0x0014, 0x00c7, 0x0162, 0xa83e, 0xa83f, 0x0027, 0xa923, 0x0021, 
  0xa841, 0x0205, 0x004e, 0xa8e0, 0xac42, 0xac42, 0xb057, 0x023b, 
  0x0184, 0x00ff, 0xac43, 0xac43, 0xac46, 0xac46, 0xaceb, 0xaceb, 
  0xac47, 0xac47, 0x00a6, 0x0081, 0x00b4, 0x0077, 0xa848, 0x00b9, 
  0xac49, 0xac49, 0xb052, 0x0061, 0x00fc, 0xb051, 0xac4a, 0xac4a, 
  0xac4b, 0xac4b, 0x008e, 0xb059, 0xac4c, 0xac4c, 0x0086, 0xb0fa, 
  0xa8e2, 0x0003, 0x002a, 0x0065, 0xb0fb, 0x0147, 0xac4d, 0xac4d, 
  0xb04e, 0xb060, 0x00ae, 0xb058, 0xace6, 0xace6, 0xb0f4, 0xb04f, 
  0x0110, 0x00ab, 0xb050, 0xb053, 0xac54, 0xac54, 0x00ce, 0x0069, 
  0x0004, 0x0037, 0x0032, 0x00f1, 0xac55, 0xac55, 0xb12c, 0xb0f8, 
  0x0020, 0xa98c, 0x0002, 0x009d, 0xac56, 0xac56, 0xace8, 0xace8, 
  0x00c4, 0xb05a, 0xad73, 0xad73, 0x0088, 0xb05b, 0xb063, 0xb0f7, 
  0xb062, 0xb05c, 0x00b6, 0x01f3, 0xa8e4, 0x0003, 0x0006, 0xa8e5, 
  0x01f2, 0x009f, 0xb05d, 0xb196, 0xb05e, 0xb072, 0xad4c, 0xad4c, 
  0xb197, 0xb05f, 0xb194, 0x00e9, 0x0004, 0xa8e1, 0xa584, 0xa584, 
  0x01b2, 0x000f, 0xb0f6, 0xb061, 0xb128, 0xb071, 0xb0f9, 0xb064, 
  0x019e, 0xb065, 0xb066, 0xb12a, 0xb54e, 0xb54e, 0xb467, 0xb467, 
  0xb468, 0xb468, 0xb59a, 0xb59a, 0x006c, 0x002f, 0xb0f0, 0x0001, 
  0xb469, 0xb469, 0xb46e, 0xb46e, 0xb06a, 0x004b, 0xacf2, 0xacf2, 
  0xb06f, 0xb073, 0xb06b, 0xb070, 0xb902, 0xb99d, 0xb46c, 0xb46c, 
  0x0004, 0xb100, 0x0022, 0x01af, 0xb93c, 0xb948, 0xb46d, 0xb46d, 
  0x0004, 0x008b, 0xacea, 0xacea, 0xb474, 0xb474, 0xb99e, 0x012b, 
  0xb475, 0xb475, 0xb478, 0xb478, 0xb476, 0xb476, 0xb9a1, 0xb8a3, 
  0xb991, 0xb903, 0xb477, 0xb477, 0xb501, 0xb501, 0xb879, 0xb897, 
  0x00fe, 0xb99b, 0xb87a, 0xb976, 0xb952, 0xb887, 0xb8a8, 0xb87b, 
  0x0004, 0x015d, 0xace9, 0xace9, 0xb938, 0xb943, 0xb93b, 0xb87c, 
  0x0166, 0x0033, 0x0002, 0x0059, 0xb535, 0xb535, 0xb47d, 0xb47d, 
  0x0004, 0x004f, 0x00aa, 0x0025, 0xb47e, 0xb47e, 0xb480, 0xb480, 
  0xb48f, 0xb48f, 0xb47f, 0xb47f, 0xb894, 0xb886, 0xb481, 0xb481, 
  0xb884, 0xb882, 0xb598, 0xb598, 0x005c, 0xb883, 0xb98f, 0xb957, 
  0xad25, 0xad25, 0x0002, 0x0019, 0x0102, 0x0115, 0xb885, 0xb88d, 
  0x010e, 0x008f, 0x0002, 0x0091, 0xbc88, 0xbc88, 0xbc98, 0xbc98, 
  0xb889, 0xb947, 0xb536, 0xb536, 0xb893, 0xb986, 0xb88a, 0xb9a6, 
  0xb954, 0xb88b, 0xb4fe, 0xb4fe, 0xb88c, 0xb8ab, 0xb88e, 0x014f, 
  0x0156, 0xb890, 0xb958, 0xb909, 0xb891, 0xb8ad, 0xb8aa, 0xb9a0, 
  0xb892, 0xb906, 0xb52f, 0xb52f, 0xb531, 0xb531, 0xb895, 0x002d, 
  0x0004, 0xb910, 0xb939, 0xb90f, 0xbc96, 0xbc96, 0xbda3, 0xbda3, 
  0x008e, 0x0089, 0x00d0, 0xb899, 0xb58d, 0xb58d, 0xb953, 0x0001, 
  0xbc9a, 0xbc9a, 0xbcc9, 0xbcc9, 0x0136, 0x00f9, 0x0002, 0x00fb, 
  0xbc9b, 0xbc9b, 0xbd17, 0xbd17, 0xacf3, 0xacf3, 0x0002, 0x0085, 
  0x007a, 0x0069, 0x0002, 0x012b, 0xbcb6, 0xbcb6, 0xbc9c, 0xbc9c, 
  0xbc9d, 0xbc9d, 0xbcca, 0xbcca, 0xbd46, 0xbd46, 0xbc9e, 0xbc9e, 
  0x0008, 0x0027, 0x013a, 0x0001, 0xbc9f, 0xbc9f, 0xbd5d, 0xbd5d, 
  0x006a, 0xc17b, 0xc0cd, 0xc0a0, 0x0040, 0x0051, 0x0032, 0x0001, 
  0xbca1, 0xbca1, 0xbcae, 0xbcae, 0x009a, 0xb127, 0x0002, 0x0009, 
  0x0038, 0x0003, 0x00f8, 0x00b7, 0xbd11, 0xbd11, 0xbca2, 0xbca2, 
  0x0004, 0xb956, 0xb955, 0xb93a, 0xbca4, 0xbca4, 0xbda5, 0xbda5, 
  0xc0a5, 0xc0b9, 0xc0bb, 0xc0bf, 0x0004, 0x010b, 0x0102, 0x00fd, 
  0xbca6, 0xbca6, 0xbd04, 0xbd04, 0xb8c0, 0xb914, 0xb90e, 0xb8a7, 
  0xbca9, 0xbca9, 0xbd13, 0xbd13, 0xbcac, 0xbcac, 0xbd59, 0xbd59, 
  0xbda4, 0xbda4, 0xbcaf, 0xbcaf, 0xb4fc, 0xb4fc, 0x000e, 0x0001, 
  0xbcb0, 0xbcb0, 0xbd1e, 0xbd1e, 0xc1ab, 0xc163, 0xc0b1, 0xc119, 
  0xbcb2, 0xbcb2, 0xbd1f, 0xbd1f, 0xc0c2, 0x0003, 0xbd6c, 0xbd6c, 
  0xc4d0, 0xc4b3, 0xc0b4, 0xc179, 0xc1ad, 0xc1b2, 0xbdaf, 0xbdaf, 
  0xbcb5, 0xbcb5, 0xbcd4, 0xbcd4, 0xbcb7, 0xbcb7, 0xbd41, 0xbd41, 
  0xbcb8, 0xbcb8, 0x001e, 0xc16e, 0xc0d5, 0xc0ba, 0xbd16, 0xbd16, 
  0xc0bc, 0xc0cf, 0xc582, 0xc4bd, 0x0082, 0x00ad, 0x0002, 0x0073, 
  0xbcbe, 0xbcbe, 0xbd7e, 0xbd7e, 0xacf1, 0xacf1, 0x0002, 0xb12b, 
  0xb59c, 0xb59c, 0xb907, 0x0001, 0xbd61, 0xbd61, 0x006e, 0xc0c1, 
  0xc4c3, 0x0069, 0xc0ce, 0xc0cc, 0xc0c4, 0xc0c8, 0xacec, 0xacec, 
  0x0002, 0xb14d, 0xb574, 0xb574, 0x0002, 0xb93d, 0xbd7d, 0xbd7d, 
  0xc167, 0xc0c5, 0xace7, 0xace7, 0x0002, 0xb185, 0xb4ff, 0xb4ff, 
  0x0002, 0x004d, 0xc145, 0xc0c7, 0xc0c6, 0xc16f, 0xbd95, 0xbd95, 
  0xbccb, 0xbccb, 0xbcd1, 0xbcd1, 0xbd66, 0xbd66, 0xb533, 0xb533, 
  0x0084, 0x0001, 0xbd40, 0xbd40, 0xbcd2, 0xbcd2, 0xbd49, 0xbd49, 
  0xbcd3, 0xbcd3, 0xbcd6, 0xbcd6, 0xbcd7, 0xbcd7, 0xaced, 0xaced, 
  0xad90, 0xad90, 0xad92, 0xad92, 0xacee, 0xacee, 0xb126, 0xb0ef, 
  0xad8e, 0xad8e, 0x0034, 0xb0f5, 0xad24, 0xad24, 0xb575, 0xb575, 
  0xb4fd, 0xb4fd, 0xbd5f, 0xbd5f, 0xbd05, 0xbd05, 0xb951, 0xb942, 
  0xb90b, 0xb908, 0xb90a, 0xb90c, 0xb589, 0xb589, 0xbd7c, 0xbd7c, 
  0xbd0d, 0xbd0d, 0xbd5b, 0xbd5b, 0xbd12, 0xbd12, 0xb550, 0xb550, 
  0x003e, 0xb915, 0xbd81, 0xbd81, 0xbd18, 0xbd18, 0xc11a, 0xc1a9, 
  0xc1b0, 0xc1ae, 0xc96a, 0xc91b, 0xc570, 0xc51c, 0xbd1d, 0xbd1d, 
  0xbd99, 0xbd99, 0xb529, 0xb529, 0xb52d, 0xb52d, 0xb532, 0xb532, 
  0xb52e, 0xb52e, 0xb54f, 0xb54f, 0xb530, 0xb530, 0xb534, 0xb534, 
  0xb99f, 0xb93e, 0xb937, 0xb978, 0xb95e, 0xb98a, 0xbd5a, 0xbd5a, 
  0xbd3f, 0xbd3f, 0xbd93, 0xbd93, 0xbd44, 0xbd44, 0xbd64, 0xbd64, 
  0xbd5c, 0xbd5c, 0xc169, 0xc160, 0xbda8, 0xbda8, 0xbd68, 0xbd68, 
  0xbd62, 0xbd62, 0xbd65, 0xbd65, 0xbd83, 0xbd83, 0xbd7a, 0xbd7a, 
  0xc1aa, 0x0001, 0xc5b1, 0xc56b, 0xbda7, 0xbda7, 0xbd6d, 0xbd6d, 
  0xbd80, 0xbd80, 0xbd71, 0xbd71, 0xbd8b, 0xbd8b, 0xbd77, 0xbd77, 
  0xbdac, 0xbdac, 0xbd7f, 0xbd7f, 0xbd87, 0xbd87, 0xbda2, 0xbda2
}; 

const U16 g_rgiHuffDecTbl44ssOb[2002] = {
0x8802,
0x0003,
0x0247,
0x042c,
0x9161,
0x0003,
0x9004,
0x0109,
0x9962,
0x9a27,
0x9808,
0x0001,
0x0004,
0x003d,
0x00f2,
0xa011,
0xa565,
0xa565,
0x0002,
0x0019,
0x0004,
0xb366,
0xac2b,
0xac2b,
0x0004,
0x000b,
0x000e,
0xb863,
0x0004,
0x0005,
0xc3da,
0xc371,
0xc4ce,
0xc641,
0xc6c3,
0xc4f6,
0xc0bb,
0xc0b2,
0xc2f5,
0xc3f6,
0xc199,
0xc36e,
0xbfc4,
0xbfc4,
0xb1e2,
0x0003,
0xb039,
0x0011,
0xb668,
0xb668,
0x0002,
0x0005,
0xbc7f,
0xbc7f,
0xbc98,
0xbc98,
0x0004,
0xc0a6,
0xc367,
0xc298,
0xc67b,
0x0001,
0xcaec,
0xc945,
0xb861,
0x0003,
0xb44e,
0xb44e,
0xc1f6,
0x0003,
0xbc82,
0xbc82,
0xc72e,
0xc679,
0xa821,
0x0003,
0x0036,
0x0085,
0xb369,
0x0003,
0x0016,
0xb22b,
0x0004,
0xb86c,
0xbb42,
0x0005,
0xbe35,
0xbe35,
0xbc88,
0xbc88,
0x0004,
0x0005,
0x0006,
0x0007,
0xc5ab,
0xc4f3,
0xc4f4,
0xc6f7,
0xc505,
0xc4d0,
0xc6c8,
0xc6c2,
0x0004,
0x0011,
0xb86d,
0x0015,
0x0004,
0x0005,
0x0006,
0x0007,
0xc683,
0xc530,
0xc6db,
0xc4d7,
0xc51a,
0xc51b,
0xc7fd,
0xc7fd,
0x040f,
0x040d,
0x0004,
0xc19c,
0xc1fa,
0xc0ab,
0xc50f,
0xc643,
0xc23e,
0xc343,
0xbe38,
0xbe38,
0x0004,
0x000b,
0x0016,
0x001d,
0x0004,
0xb866,
0xbba1,
0xb9ea,
0xbfbf,
0xbfbf,
0xbdef,
0xbdef,
0xb77e,
0xb77e,
0x0002,
0x0005,
0xc0c3,
0xc0ac,
0xc0b3,
0xc0af,
0xc3e0,
0xc1f8,
0xc23d,
0xc3f3,
0x0004,
0xb9eb,
0xb44d,
0xb44d,
0xbebc,
0xbebc,
0xbf55,
0xbf55,
0xb9ec,
0xb97e,
0x0002,
0x0011,
0xbf58,
0xbf58,
0x0002,
0x0007,
0x0002,
0x0003,
0xc946,
0xc940,
0xcab6,
0xcb7b,
0x0002,
0x0003,
0xc93f,
0xcb45,
0xc9b5,
0xc949,
0x0004,
0x0009,
0x000e,
0x0013,
0x0002,
0x0003,
0xcb40,
0xc948,
0xc94d,
0xc8f9,
0x0002,
0x0003,
0xca58,
0xcb39,
0xca61,
0xc9bb,
0x0002,
0x0003,
0xc938,
0xcb29,
0xcb0d,
0xca51,
0x0002,
0x0003,
0xcb52,
0xcbbd,
0xcbc9,
0xca5f,
0xac2c,
0xac2c,
0x0002,
0x0027,
0x0004,
0x0015,
0x0020,
0xb86b,
0x0004,
0x0009,
0x000c,
0x000d,
0x0002,
0x0003,
0xcbad,
0xc9bd,
0xcaa8,
0xcbb4,
0x0002,
0xc615,
0xcbb0,
0xc9bf,
0xc510,
0xc4e7,
0xc788,
0xc647,
0x0004,
0x0005,
0x0006,
0x0007,
0xc759,
0xc4e4,
0xc796,
0xc4cd,
0xc71c,
0xc4e1,
0xc4c9,
0xc4d6,
0xc0a8,
0xc276,
0xc29f,
0xc0c0,
0xb780,
0xb780,
0xb450,
0xb450,
0xa418,
0xa418,
0xa822,
0x0001,
0xb03b,
0x0003,
0xaf54,
0xaf54,
0x0004,
0xb97d,
0xb62e,
0xb62e,
0xbc9a,
0xbc9a,
0xbfca,
0xbfca,
0x95db,
0x95db,
0x0002,
0x007a,
0x9c0c,
0x9c0c,
0x0002,
0x003d,
0x0004,
0xab3c,
0xa823,
0x0023,
0x0004,
0xb28f,
0x0012,
0x0015,
0xb864,
0x0003,
0xb575,
0xb575,
0xbfc6,
0xbfc6,
0x0002,
0xc0ba,
0xc4de,
0x0001,
0xc92a,
0x0001,
0x0002,
0xcdd6,
0xd156,
0xd15e,
0xb782,
0xb782,
0xb454,
0xb454,
0xba6b,
0x0003,
0xb451,
0xb451,
0xc3e3,
0xc277,
0xc3df,
0x0001,
0xc70b,
0xc4d2,
0xac2d,
0xac2d,
0x0002,
0xb03d,
0x0004,
0x0007,
0xb44f,
0xb44f,
0xbc92,
0xbc92,
0xbc8c,
0xbc8c,
0xbc85,
0xbc85,
0x0002,
0x0004,
0xc7fd,
0xc663,
0x0405,
0xc7fd,
0xc5ac,
0x0428,
0xa716,
0xa716,
0xa9de,
0x0001,
0x0004,
0x0007,
0x0027,
0x002a,
0xb690,
0xb690,
0xb785,
0xb785,
0x0004,
0x000f,
0x0017,
0x001a,
0x0004,
0x0005,
0x0006,
0x0007,
0xc60a,
0xc726,
0xc681,
0xc4d9,
0xc4dc,
0xc6c5,
0xc5a2,
0xc64c,
0x0004,
0x0005,
0xc0c1,
0xc1f7,
0xc4e5,
0xc4cb,
0xc6c4,
0xc7fc,
0x040e,
0xc297,
0xc3e8,
0xbef1,
0xbef1,
0xbfc1,
0xbfc1,
0xbed3,
0xbed3,
0xb97f,
0xbba3,
0xb72b,
0xb72b,
0x0004,
0xbb05,
0xb455,
0xb455,
0xbc87,
0xbc87,
0xc275,
0xc3ed,
0x0004,
0xa2cf,
0x0028,
0xa012,
0xa5dd,
0xa5dd,
0xa968,
0x0001,
0xb03c,
0xb170,
0xb36b,
0x0001,
0x0004,
0x0007,
0xbb9f,
0x0009,
0xc19d,
0xc0ae,
0xc0bd,
0xc3e2,
0xbf06,
0xbf06,
0xbc8d,
0xbc8d,
0xbc89,
0xbc89,
0xc1fd,
0x0001,
0x0002,
0x0007,
0x0002,
0x0003,
0xce8a,
0xcdc3,
0xce1c,
0xcdd1,
0x0002,
0x0003,
0xcdd7,
0xcd5b,
0xcd20,
0xcee8,
0xa419,
0xa419,
0x0002,
0x007f,
0x0004,
0x000b,
0x0028,
0x002b,
0xbba5,
0xb86a,
0x0002,
0xba92,
0xbdf3,
0xbdf3,
0xbc96,
0xbc96,
0xb789,
0xb789,
0xb86e,
0x0001,
0xbc90,
0xbc90,
0x0002,
0x000f,
0x0002,
0x0007,
0x0002,
0x0003,
0xcd5d,
0xcee4,
0xcdd9,
0xcdcc,
0x0002,
0x0003,
0xce19,
0xcd55,
0xcd54,
0xcefc,
0x0002,
0x0005,
0x0002,
0xcafe,
0xce5b,
0xcee7,
0xc93a,
0xcb4e,
0xb5e5,
0xb5e5,
0xb453,
0xb453,
0x0004,
0x001f,
0x0036,
0x0043,
0x0004,
0x0009,
0x000e,
0x0013,
0x0002,
0x0003,
0xcb20,
0xc957,
0xc9c2,
0xcb30,
0x0002,
0x0003,
0xcafb,
0xcb53,
0xcb02,
0xcb6f,
0x0002,
0x0003,
0xc93c,
0xc9b2,
0xc9d3,
0xc928,
0x0002,
0x0003,
0xcb3b,
0xcb84,
0xc92e,
0xcbb2,
0x0004,
0x0009,
0x000e,
0x0012,
0x0002,
0x0003,
0xcaae,
0xca26,
0xc924,
0xca82,
0x0002,
0x0003,
0xca87,
0xcae6,
0xca25,
0xcacc,
0x0003,
0xc7fc,
0x0411,
0xcbcb,
0xc917,
0xc7fd,
0xc649,
0x0413,
0x0004,
0x0007,
0x0008,
0x0009,
0xc7fd,
0xc7fd,
0x0424,
0x042a,
0xc4e0,
0xc611,
0xc605,
0xc4f7,
0xc78e,
0xc7a0,
0x0004,
0x0005,
0x0006,
0xc0b5,
0xc6e0,
0xc5b6,
0xc60d,
0xc513,
0xc60b,
0xc4fb,
0x0004,
0xb304,
0xade0,
0xade0,
0x0004,
0x0007,
0xba6c,
0xbba9,
0xc0b8,
0xc2f3,
0xbfc0,
0xbfc0,
0xbdf2,
0xbdf2,
0xbf2c,
0xbf2c,
0x8c03,
0x8c03,
0x0002,
0x003f,
0x9406,
0x9406,
0x0002,
0x9809,
0x9e8d,
0x9e8d,
0x0002,
0xa164,
0xa824,
0x0003,
0x001c,
0x001f,
0x0004,
0x0007,
0x0014,
0xb03e,
0xb576,
0xb576,
0xb6d1,
0xb6d1,
0xb452,
0xb452,
0x0002,
0x0007,
0xc23b,
0x0003,
0xbebe,
0xbebe,
0xc500,
0xc4ee,
0xbe6f,
0xbe6f,
0xbfd3,
0xbfd3,
0xbb4b,
0xbad2,
0xb787,
0xb787,
0xac2f,
0xac2f,
0xac2e,
0xac2e,
0xb267,
0x0003,
0xac30,
0xac30,
0x0004,
0x0007,
0x000a,
0xbba6,
0xbfc8,
0xbfc8,
0xc1f9,
0xc2d7,
0xc0a7,
0xc3eb,
0xc2f2,
0xc0cf,
0xc204,
0xc308,
0xbc8a,
0xbc8a,
0x0004,
0x00b0,
0x00bb,
0x019d,
0x0004,
0x003d,
0x9d63,
0x9d63,
0xaa8e,
0x0003,
0xa41a,
0xa41a,
0xb16f,
0xb1e3,
0x0002,
0x000f,
0x0004,
0xba31,
0xb456,
0xb456,
0xbf5e,
0xbf5e,
0x0002,
0x0004,
0xc7fd,
0xc542,
0x042c,
0xc7fd,
0xc4ea,
0x0420,
0x0004,
0x0011,
0x001a,
0x001d,
0x0004,
0x0006,
0x0008,
0x0009,
0xc512,
0xc7fc,
0x041c,
0xc7fd,
0xc5a4,
0x041f,
0xc6a1,
0xc738,
0xc4d5,
0xc78a,
0x0004,
0x0005,
0x0006,
0xc3e1,
0xc75c,
0xc4f1,
0xc64b,
0xc5a0,
0xc648,
0xc5b0,
0xc1fc,
0xc0a5,
0xc3ef,
0xc0b1,
0xbfc3,
0xbfc3,
0xbdf1,
0xbdf1,
0xa825,
0x0003,
0x0006,
0x002a,
0xaf57,
0xaf57,
0xae66,
0xae66,
0x0004,
0xb03f,
0x0012,
0xb36d,
0x0004,
0xbabb,
0x0006,
0x0009,
0xbc86,
0xbc86,
0xbfcc,
0xbfcc,
0xc31b,
0xc29a,
0xbdf4,
0xbdf4,
0xbe36,
0xbe36,
0xbe37,
0xbe37,
0x0004,
0xb871,
0x0006,
0x000a,
0xbe39,
0xbe39,
0xbe6e,
0xbe6e,
0xc2c0,
0xc1fb,
0xc194,
0xc3fc,
0x03fe,
0xc19a,
0xc0a3,
0xbc8f,
0xbc8f,
0xae2a,
0xae2a,
0xb171,
0x0001,
0xb869,
0x0003,
0x001f,
0x002f,
0x0004,
0x000a,
0x000f,
0x0014,
0x0002,
0x0003,
0xcaad,
0xcaaa,
0xcaa5,
0xcbfc,
0x042e,
0x0002,
0x0003,
0xc94f,
0xc9be,
0xcb10,
0xca53,
0x0002,
0x0003,
0xca52,
0xc9c9,
0xca88,
0xca23,
0x0002,
0x0003,
0xcb4d,
0xcad9,
0xcaf9,
0xc95c,
0x0004,
0x0009,
0x000b,
0x000c,
0x0002,
0x0003,
0xc959,
0xcadc,
0xcab1,
0xc93d,
0xc7fd,
0xc6ca,
0x0429,
0xc502,
0xc5c1,
0xc4f0,
0xc77d,
0x0004,
0x0005,
0x0006,
0x0007,
0xc642,
0xc75f,
0xc744,
0xc4fd,
0xc4ed,
0xc4e9,
0xc6a6,
0xc4fa,
0x9c0d,
0x9c0d,
0xa013,
0x0001,
0xa41b,
0xa41b,
0x0002,
0xab41,
0xaed0,
0xaed0,
0xad6b,
0xad6b,
0x0004,
0x002c,
0x00b3,
0x00dc,
0xaa29,
0x0003,
0xa721,
0xa721,
0x0004,
0xb041,
0xac31,
0xac31,
0x0004,
0x0012,
0x0017,
0x001a,
0x0004,
0x0005,
0x0007,
0x000a,
0xc5b7,
0xc607,
0xc749,
0xc7fc,
0x041b,
0xc7fd,
0xc7fd,
0x041d,
0x041a,
0xc4f5,
0xc662,
0x0004,
0xc0c2,
0xc299,
0xc201,
0xc67f,
0xc6f6,
0xc23c,
0xc36c,
0xc3e9,
0xc203,
0xc23f,
0xc31a,
0xbe70,
0xbe70,
0x0004,
0x0030,
0xa826,
0x005a,
0x0004,
0x000b,
0x0017,
0xb370,
0xbb47,
0x0003,
0xbbab,
0xb875,
0xbc8b,
0xbc8b,
0xbfcd,
0xbfcd,
0xb459,
0xb459,
0x0002,
0x0005,
0xc1fe,
0xc200,
0xc0c4,
0xc37f,
0xc2c1,
0xc0ad,
0xc3f1,
0xc3fc,
0x0404,
0x0004,
0xb984,
0xbba7,
0x0005,
0xbc9b,
0xbc9b,
0xbf07,
0xbf07,
0xbc94,
0xbc94,
0xc3f9,
0x0001,
0x0002,
0xc514,
0xc941,
0x0001,
0x0002,
0xcd58,
0xd1d0,
0xd21f,
0xb040,
0x0003,
0x0006,
0x0011,
0xb5e7,
0xb5e7,
0xb78b,
0xb78b,
0x0004,
0x0007,
0xb45b,
0xb45b,
0xbc95,
0xbc95,
0xbc97,
0xbc97,
0xbc93,
0xbc93,
0xbd8e,
0xbd8e,
0xb5e6,
0xb5e6,
0x0002,
0x0009,
0xbfd7,
0xbfd7,
0x0002,
0x0003,
0xc606,
0xc515,
0xc616,
0xc60c,
0x0004,
0x0005,
0x0006,
0x0007,
0xc532,
0xc79c,
0xc680,
0xc52c,
0xc7a4,
0xc501,
0xc60f,
0xc504,
0x0004,
0x0019,
0xb372,
0xb042,
0x0004,
0x0011,
0xb988,
0xb980,
0x0004,
0x0005,
0x0007,
0x0009,
0xc50c,
0xc67c,
0xc50d,
0xc7fc,
0x0410,
0xc7fd,
0xc5bc,
0x0423,
0xc71f,
0xc5b8,
0xc3fb,
0xc244,
0xc3f5,
0xc375,
0x0004,
0xb9ed,
0xb578,
0xb578,
0xbfc7,
0xbfc7,
0xc0bf,
0x0001,
0xc7fd,
0x0002,
0x0427,
0x0002,
0x0003,
0xcee9,
0xce89,
0xce55,
0xcd51,
0xa41c,
0xa41c,
0x0002,
0x0011,
0xaf5a,
0xaf5a,
0x0002,
0x0009,
0xb735,
0xb735,
0x0002,
0xb86f,
0xbebd,
0xbebd,
0xc278,
0xc24e,
0xb62f,
0xb62f,
0xb458,
0xb458,
0xac32,
0xac32,
0x0002,
0x000f,
0xb78f,
0xb78f,
0x0002,
0x0007,
0xc0c5,
0xc3fe,
0xc3fe,
0xc217,
0x0412,
0x0403,
0xc309,
0xc3f8,
0xc3ee,
0xc0be,
0xb78d,
0xb78d,
0xb669,
0xb669,
0xa41d,
0xa41d,
0xa566,
0xa566,
0xa014,
0xa2ed,
0x9c0e,
0x9c0e,
0x0004,
0x00cc,
0x9005,
0x0201,
0x980a,
0x0003,
0x9407,
0x9407,
0x0004,
0x00a3,
0x9ddc,
0x9ddc,
0x0004,
0x001b,
0x0082,
0x0089,
0x0004,
0x000f,
0x0012,
0xb317,
0x0004,
0xbbac,
0x0006,
0xb874,
0xbc91,
0xbc91,
0xbf3e,
0xbf3e,
0xbc9e,
0xbc9e,
0xbf61,
0xbf61,
0xb9ee,
0xb983,
0xbb18,
0xb981,
0xb579,
0xb579,
0xb870,
0xba6d,
0x0004,
0xb044,
0x0006,
0x0051,
0xb899,
0xb87a,
0xb457,
0xb457,
0x0004,
0x0023,
0x0033,
0x003f,
0x0004,
0x000d,
0x0012,
0x0017,
0x0002,
0x0007,
0x0002,
0x0003,
0xcdd4,
0xcdd8,
0xce56,
0xce1e,
0xc93b,
0xcae2,
0x0002,
0x0003,
0xc9cf,
0xc91c,
0xcadf,
0xc91f,
0x0002,
0x0003,
0xcaeb,
0xca21,
0xc9c8,
0xc94e,
0x0002,
0x0003,
0xc9cb,
0xc9c4,
0xcb14,
0xcb01,
0x0004,
0x0009,
0x000b,
0x000c,
0x0002,
0x0003,
0xc9ca,
0xc953,
0xcb32,
0xcaa7,
0xc7fd,
0xc78c,
0x0415,
0xc51e,
0xc67e,
0xc52b,
0xc650,
0x0004,
0x0005,
0x0006,
0x0008,
0xc519,
0xc521,
0xc51d,
0xc511,
0xc547,
0xc7fc,
0x0426,
0xc6da,
0xc68c,
0x0004,
0x0005,
0x0006,
0xc1ff,
0xc646,
0xc64a,
0xc6a3,
0xc4fe,
0xc72f,
0xc6b0,
0x0004,
0x0007,
0x000a,
0x000d,
0xc377,
0xc0bc,
0xc3f0,
0xc0df,
0xc273,
0xc19f,
0xbfdc,
0xbfdc,
0xbdf5,
0xbdf5,
0xbf5b,
0xbf5b,
0xbfdd,
0xbfdd,
0xbd8b,
0xbd8b,
0xb043,
0x0003,
0xb374,
0xb047,
0xb878,
0xb982,
0xbbb1,
0xb873,
0xb046,
0xb22c,
0x0002,
0x000d,
0x0004,
0x0007,
0xba93,
0xb879,
0xc0c6,
0xc0d1,
0xbfcf,
0xbfcf,
0xbd8f,
0xbd8f,
0xbed4,
0xbed4,
0xba32,
0xbbae,
0xb791,
0xb791,
0xa827,
0xa969,
0x0002,
0x001a,
0x0004,
0x0010,
0xad6c,
0xad6c,
0xb577,
0xb577,
0x0002,
0x0005,
0xc0d3,
0xc240,
0xc29e,
0xc0d4,
0xc1a9,
0xc3fe,
0xbfd1,
0xbfd1,
0x03ff,
0x0004,
0xb877,
0xb45a,
0xb45a,
0xbc9f,
0xbc9f,
0xbf64,
0xbf64,
0xaf5d,
0xaf5d,
0xac34,
0xac34,
0x0004,
0x9a64,
0x006b,
0x008c,
0x0004,
0x0048,
0x9c01,
0x9c01,
0xa665,
0xa665,
0xab46,
0x0001,
0x0004,
0x000f,
0x001a,
0x001d,
0xb45d,
0xb45d,
0x0002,
0x0005,
0xbfd4,
0xbfd4,
0xbf36,
0xbf36,
0xbfd5,
0xbfd5,
0xbd8d,
0xbd8d,
0xb73d,
0xb73d,
0xba94,
0x0001,
0xbe71,
0xbe71,
0x0002,
0x0003,
0xc613,
0xc6de,
0xc6e1,
0xc6c9,
0xb57a,
0xb57a,
0xba95,
0xb87c,
0xbbbb,
0x0003,
0x000e,
0x001a,
0x0004,
0x0005,
0x0006,
0x0007,
0xc6c6,
0xc5aa,
0xc526,
0xc5b3,
0xc5af,
0xc4e6,
0xc792,
0xc52d,
0x0004,
0x0006,
0x0007,
0x0008,
0xc4f2,
0xc7fc,
0x0421,
0xc731,
0xc507,
0xc50a,
0xc4eb,
0xc794,
0xc4ff,
0xc2d8,
0xc32d,
0xc3f4,
0xc348,
0xa41e,
0xa41e,
0xa828,
0x0001,
0x0004,
0x000b,
0xb172,
0xb049,
0x0004,
0xb989,
0xb45c,
0xb45c,
0xc1a8,
0xc0da,
0xbfd2,
0xbfd2,
0x0004,
0xbbaf,
0x0006,
0x0009,
0xbfde,
0xbfde,
0xc0ca,
0xc2a0,
0xbd90,
0xbd90,
0xbf24,
0xbf24,
0xbd97,
0xbd97,
0xbf19,
0xbf19,
0xa015,
0x0003,
0x9c0f,
0x9c0f,
0xa400,
0xa400,
0x0002,
0xa829,
0x0004,
0xb048,
0x0006,
0x0009,
0xb45f,
0xb45f,
0xb876,
0xbbb7,
0xb87b,
0xb872,
0xb462,
0xb462,
0xb691,
0xb691,
0x0002,
0x0006,
0xc29b,
0xc0cc,
0xc3f2,
0xc3fc,
0x03fd,
0xc325,
0xc386,
0xc29d,
0xc3fc,
0x0406,
0x0004,
0x0027,
0x9eb7,
0x9eb7,
0x0004,
0x001f,
0xa72a,
0xa72a,
0xac33,
0xac33,
0xb04a,
0x0001,
0x0004,
0x0007,
0x000a,
0xba33,
0xc3ec,
0xc0c7,
0xc30a,
0xc274,
0xbd95,
0xbd95,
0xbe02,
0xbe02,
0xbfd0,
0xbfd0,
0xc24f,
0x0001,
0x0002,
0x0005,
0x0002,
0xca57,
0xce60,
0xcdd2,
0xc93e,
0xca5a,
0xac35,
0xac35,
0xade1,
0xade1,
0x0004,
0x0013,
0x0016,
0xa9df,
0xad6d,
0xad6d,
0xb1e4,
0x0001,
0x0004,
0x0007,
0xb795,
0xb795,
0xbd93,
0xbd93,
0xbfd6,
0xbfd6,
0xbd91,
0xbd91,
0xbd98,
0xbd98,
0xb376,
0xb2b9,
0xaf60,
0xaf60,
0xb045,
0x0003,
0x0022,
0x0025,
0xbb50,
0x0003,
0xb45e,
0xb45e,
0x0004,
0x0009,
0x000e,
0x0013,
0x0002,
0x0003,
0xc952,
0xc950,
0xcae5,
0xc939,
0x0002,
0x0003,
0xcb12,
0xcab3,
0xcafd,
0xcab2,
0x0002,
0x0003,
0xcb13,
0xc94a,
0xc943,
0xcaea,
0x0002,
0x0003,
0xca84,
0xcaac,
0xcb0e,
0xcb3a,
0xb57b,
0xb57b,
0xb79b,
0xb79b,
0x0004,
0x0019,
0x0025,
0x0031,
0x0004,
0x0009,
0x000e,
0x0011,
0x0002,
0x0003,
0xcab5,
0xc95f,
0xcaa9,
0xcaff,
0x0002,
0x0003,
0xcab4,
0xc9ae,
0xca5e,
0xca5c,
0x0002,
0xc79a,
0xca1b,
0xca24,
0xc533,
0xc727,
0x0004,
0x0005,
0x0006,
0x0007,
0xc527,
0xc71e,
0xc535,
0xc531,
0xc522,
0xc508,
0xc7a2,
0xc7fc,
0x0422,
0x0004,
0x0005,
0x0006,
0x0008,
0xc52f,
0xc790,
0xc5ce,
0xc503,
0xc7fd,
0xc654,
0x042f,
0xc6dd,
0xc60e,
0x0004,
0x0005,
0x0006,
0x0007,
0xc4fc,
0xc516,
0xc5b9,
0xc612,
0xc54b,
0xc614,
0xc5a1,
0xc5cd,
0x0004,
0x980b,
0x006b,
0x0130,
0xa228,
0x0003,
0xa016,
0x002e,
0x0004,
0x001c,
0xa41f,
0xa41f,
0x0004,
0x0014,
0xac37,
0xac37,
0x0004,
0x000b,
0xb88e,
0xbaf0,
0x0004,
0x0005,
0xc381,
0xc3fa,
0xc70c,
0xc6af,
0xc6a4,
0xc68b,
0xc3ff,
0xc33f,
0xbebf,
0xbebf,
0x0408,
0xb66a,
0xb66a,
0xb5e8,
0xb5e8,
0x0004,
0xb173,
0xaeee,
0xaeee,
0x0004,
0xbbb3,
0xb87d,
0x0005,
0xbd8c,
0xbd8c,
0xbfd9,
0xbfd9,
0xbca0,
0xbca0,
0xc3f7,
0xc373,
0x0004,
0xab4a,
0x001a,
0xaab8,
0x0004,
0x000f,
0xac36,
0xac36,
0xba34,
0xbbbc,
0x0002,
0x0005,
0xc0f8,
0xc337,
0xbd96,
0xbd96,
0xbca1,
0xbca1,
0xbcaa,
0xbcaa,
0x0004,
0xb884,
0xb460,
0xb460,
0xbf6a,
0xbf6a,
0xbca4,
0xbca4,
0xb379,
0xb322,
0x0002,
0xb174,
0xb985,
0x0003,
0x000e,
0x0011,
0xbfe6,
0xbfe6,
0xc3fd,
0x0002,
0x040c,
0x0003,
0xc7fc,
0x0414,
0xc944,
0x0001,
0xcd5a,
0xcd60,
0xbd92,
0xbd92,
0xbca2,
0xbca2,
0xbed5,
0xbed5,
0xbcb0,
0xbcb0,
0xa303,
0x0003,
0x0074,
0x008b,
0x0004,
0x004b,
0xa420,
0xa420,
0x0004,
0x0007,
0x0013,
0x0016,
0xbbb5,
0xbb23,
0xb6ef,
0xb6ef,
0x0004,
0xbbbe,
0xb6ba,
0xb6ba,
0xbc9d,
0xbc9d,
0x0002,
0x0003,
0xc5b4,
0xc686,
0xc5c7,
0xc7fc,
0x0416,
0xb793,
0xb793,
0xb57c,
0xb57c,
0x0004,
0x0011,
0x001c,
0x0026,
0x0004,
0x0006,
0x0008,
0x0009,
0xc7fd,
0xc620,
0x0409,
0xc67d,
0xc7fc,
0x0425,
0xc71d,
0xc765,
0xc537,
0xc7a8,
0x0004,
0x0005,
0x0006,
0x0007,
0xc523,
0xc518,
0xc5da,
0xc6a2,
0xc79e,
0xc7ba,
0xc6fa,
0xc4e8,
0x0005,
0x0006,
0x0007,
0xc3fc,
0x0401,
0xc610,
0xc778,
0xc50b,
0xc609,
0xc762,
0xc6cd,
0xc245,
0xc0c8,
0xc3fd,
0xc3fd,
0x041e,
0x040b,
0x0004,
0xb04b,
0x0018,
0x001b,
0x0004,
0x0009,
0x000c,
0x000f,
0xc0e3,
0xc3fe,
0xc2f4,
0xc3fd,
0x0402,
0x0407,
0xc24d,
0xc0d8,
0xc383,
0xc0ec,
0xbfe4,
0xbfe4,
0xbfd8,
0xbfd8,
0xbc9c,
0xbc9c,
0xbe72,
0xbe72,
0xb9f0,
0xbbc5,
0xb5e9,
0xb5e9,
0xb799,
0xb799,
0xb987,
0x0001,
0xc208,
0xc106,
0xbd9e,
0xbd9e,
0x0004,
0xa82a,
0xa567,
0xa567,
0xb37c,
0xb22d,
0xb04c,
0x0001,
0x0004,
0x0007,
0x000a,
0xbbb9,
0xbe3a,
0xbe3a,
0xbfe5,
0xbfe5,
0xbcb9,
0xbcb9,
0xbed6,
0xbed6,
0xbfe7,
0xbfe7,
0xbe96,
0xbe96,
0xa734,
0xa734,
0x0002,
0x0025,
0x0004,
0x000b,
0xad6e,
0xad6e,
0xb630,
0xb630,
0xb883,
0x0001,
0xc0dd,
0xc1a6,
0xc0db,
0xc218,
0x0004,
0x000b,
0x000e,
0x0011,
0xc3ff,
0xc3ff,
0xc3ff,
0xc3ff,
0x0418,
0x03fc,
0x040a,
0x0417,
0xc3ea,
0xc27a,
0xc37a,
0xc356,
0xbcb4,
0xbcb4,
0xbca9,
0xbca9,
0xbcb6,
0xbcb6,
0xbfdb,
0xbfdb,
0xaf63,
0xaf63,
0x0002,
0x0005,
0xb881,
0xb986,
0xb797,
0xb797,
0xb87e,
0x0003,
0xb468,
0xb468,
0xbd9b,
0xbd9b,
0xbcb7,
0xbcb7,
0x9c10,
0x9c10,
0xa017,
0x0001,
0xa96a,
0x0003,
0xab4f,
0x0023,
0xac38,
0xac38,
0x0002,
0x001b,
0xbbc2,
0xb98a,
0xb880,
0x0001,
0x0004,
0x0009,
0x000e,
0x0011,
0x0002,
0x0003,
0xcaab,
0xc9c5,
0xc929,
0xcb00,
0x0002,
0x0003,
0xca1a,
0xca22,
0xcae3,
0xcb0f,
0x0002,
0xc5a3,
0xc9d5,
0xcb11,
0xc5b1,
0xc685,
0xb465,
0xb465,
0xb79d,
0xb79d,
0xac3a,
0xac3a,
0x0002,
0x001f,
0xb467,
0xb467,
0x0002,
0x000f,
0x0004,
0x0005,
0x0007,
0x0009,
0xc61d,
0xc659,
0xc7fd,
0xc768,
0x042b,
0xc7fd,
0xc509,
0x042d,
0xc6c7,
0xc536,
0x0004,
0x0005,
0x0006,
0x0007,
0xc6cb,
0xc525,
0xc7aa,
0xc715,
0xc6ce,
0xc728,
0xc54c,
0xc534,
0x0004,
0x000f,
0x0015,
0x0018,
0x0004,
0x0005,
0x0006,
0x0007,
0xc7b8,
0xc65d,
0xc5c6,
0xc5c0,
0xc733,
0xc7b6,
0xc7ce,
0xc50e,
0x0005,
0xc1ad,
0xc0ef,
0xc3fc,
0x0419,
0xc6f8,
0xc5ba,
0xc29c,
0xc1a7,
0xc0e2,
0xc1a5,
0xc34c,
0xc351,
0xc3fd,
0xc398,
0x0400,};

const U16 g_rgiHuffDecTbl44smQb[] =
{
0x8802,
0x0003,
0x0274,
0x0341,
0x0004,
0x00a3,
0x01b8,
0x913f,
0x9405,
0x9405,
0x0002,
0x0075,
0xa015,
0x0003,
0xa228,
0x0019,
0x0004,
0xa944,
0xa420,
0xa420,
0xac3f,
0xac3f,
0x0002,
0x0009,
0xb877,
0xb9a6,
0xba1a,
0x0001,
0xc0cc,
0xc176,
0xc22e,
0xc28c,
0xb465,
0xb465,
0x0002,
0xba78,
0xbd7b,
0xbd7b,
0xbdaf,
0xbdaf,
0x0004,
0x002b,
0xa542,
0xa542,
0xac00,
0xac00,
0x0002,
0x0015,
0xb466,
0xb466,
0xb87f,
0x0001,
0xbdb1,
0xbdb1,
0x0002,
0x0007,
0x0002,
0x0003,
0xca35,
0xca24,
0xc992,
0xc9cd,
0x0002,
0x0003,
0xc9f7,
0xc91d,
0xc9f3,
0xca58,
0xb46a,
0xb46a,
0xba3b,
0x0001,
0x0004,
0x0005,
0x0006,
0x0007,
0xc4e5,
0xc659,
0xc65c,
0xc64f,
0xc530,
0xc5d0,
0xc501,
0xc4f8,
0xac3d,
0xac3d,
0x0002,
0x0021,
0x0004,
0x000f,
0x0016,
0x0019,
0x0004,
0x0005,
0x0006,
0x0007,
0xc604,
0xc627,
0xc4fa,
0xc4ee,
0xc504,
0xc509,
0xc699,
0xc68e,
0x0004,
0x0005,
0xc0bf,
0xc0c3,
0xc515,
0xc638,
0xc517,
0xc632,
0xc1ee,
0xc1e7,
0xc1bf,
0xc0eb,
0xbe2d,
0xbe2d,
0xbcae,
0xbcae,
0xb884,
0x0003,
0xb5de,
0xb5de,
0xbdb6,
0xbdb6,
0xbcb3,
0xbcb3,
0x9c0d,
0x9c0d,
0x0002,
0x0011,
0x0004,
0xa82d,
0xa82e,
0x0009,
0xac3b,
0xac3b,
0xb04d,
0x0001,
0xb671,
0xb671,
0xb46e,
0xb46e,
0xb267,
0xb14e,
0xb04f,
0xb14c,
0xa421,
0xa421,
0x0002,
0xa82f,
0xac3c,
0xac3c,
0x0002,
0xb052,
0xb555,
0xb555,
0x0002,
0x0005,
0xc0c9,
0xc286,
0xbca5,
0xbca5,
0xbdb8,
0xbdb8,
0xbe7f,
0xbe7f,
0x0004,
0x9809,
0x008e,
0x00eb,
0x0004,
0x0007,
0xa016,
0x0031,
0xa643,
0xa643,
0xa423,
0xa423,
0xa422,
0xa422,
0x0002,
0x0005,
0xb050,
0xb14d,
0xae60,
0xae60,
0xad48,
0xad48,
0xb1a1,
0x0001,
0x0004,
0x0009,
0x0014,
0x0019,
0xc0e8,
0x0003,
0xbde4,
0xbde4,
0xc5cb,
0xc63f,
0x0004,
0x0005,
0x0006,
0x0007,
0xc4e6,
0xc5ff,
0xc51e,
0xc528,
0xc5fc,
0xc695,
0xc584,
0xc590,
0x0004,
0xc0d3,
0xc247,
0xc252,
0xc58c,
0xc5f2,
0xc0da,
0xc0d4,
0xc0c6,
0xc230,
0x0004,
0x001b,
0x003e,
0xa830,
0xb054,
0x0003,
0xb14f,
0x000d,
0x0004,
0x0007,
0xb963,
0xba79,
0xc1bb,
0xc288,
0xbca4,
0xbca4,
0xbcbb,
0xbcbb,
0xbdb3,
0xbdb3,
0xb880,
0x0003,
0xb559,
0xb559,
0xbdb0,
0xbdb0,
0xbd78,
0xbd78,
0x0004,
0xb051,
0xb04c,
0x0009,
0xb46c,
0xb46c,
0xb881,
0x0001,
0xbcb8,
0xbcb8,
0xbe4c,
0xbe4c,
0xb883,
0x0003,
0x000e,
0x0011,
0x0004,
0xc0c1,
0xc0cb,
0xc1fe,
0xc626,
0x0001,
0x0002,
0x0003,
0xce09,
0xcd23,
0xce0a,
0xcd21,
0xc0db,
0xc268,
0xc289,
0xc290,
0xc0f3,
0xc0c0,
0xc0cd,
0xc1d5,
0x0004,
0xb23a,
0x000a,
0x0011,
0x0004,
0xb891,
0xb88c,
0xb882,
0xbcab,
0xbcab,
0xbe3d,
0xbe3d,
0xba2b,
0x0003,
0xb64b,
0xb64b,
0xbcb9,
0xbcb9,
0xbcb1,
0xbcb1,
0xb55b,
0xb55b,
0xb47c,
0xb47c,
0x9c0e,
0x9c0e,
0xa017,
0x0001,
0xa99d,
0xa831,
0x0002,
0xaa55,
0xb1dc,
0x0003,
0x0006,
0x003b,
0xb5a4,
0xb5a4,
0xb46f,
0xb46f,
0xb9ac,
0x0003,
0x001c,
0x0027,
0x0004,
0x0009,
0x000e,
0x0013,
0x0002,
0x0003,
0xc92a,
0xc916,
0xc998,
0xc924,
0x0002,
0x0003,
0xca06,
0xca07,
0xca41,
0xc93c,
0x0002,
0x0003,
0xc989,
0xc91c,
0xc981,
0xc92e,
0x0002,
0xc514,
0xc994,
0xca11,
0x0004,
0x0005,
0x0006,
0x0007,
0xc5ce,
0xc583,
0xc4e4,
0xc505,
0xc587,
0xc520,
0xc52f,
0xc534,
0x0004,
0x0005,
0x0006,
0x0007,
0xc53b,
0xc4e9,
0xc5d3,
0xc50f,
0xc4f0,
0xc599,
0xc5d6,
0xc532,
0x0004,
0x000b,
0x000e,
0x0011,
0x0004,
0x0005,
0xc1c9,
0xc0d8,
0xc58a,
0xc698,
0xc65f,
0xc642,
0xc221,
0xc28b,
0xc0c8,
0xc0de,
0xbd79,
0xbd79,
0xbe80,
0xbe80,
0xbd77,
0xbd77,
0xbca9,
0xbca9,
0x0004,
0xa018,
0x9c0f,
0x9c0f,
0xa424,
0xa424,
0x0002,
0xa945,
0x0004,
0x000b,
0x0012,
0xb057,
0x0004,
0xb9aa,
0xb46d,
0xb46d,
0xbdb7,
0xbdb7,
0xbc9f,
0xbc9f,
0xb556,
0xb556,
0xba7a,
0x0001,
0xbdb2,
0xbdb2,
0xbca7,
0xbca7,
0xb566,
0xb566,
0x0002,
0x0005,
0xbe81,
0xbe81,
0xbd74,
0xbd74,
0xbd75,
0xbd75,
0xbcac,
0xbcac,
0x9406,
0x9406,
0x0002,
0x00ad,
0x0004,
0x0047,
0x004a,
0xa141,
0x0004,
0x0019,
0xa832,
0x0039,
0xb055,
0x0003,
0xb05c,
0x0005,
0xb9e1,
0xb96b,
0xb618,
0xb618,
0xb558,
0xb558,
0x0002,
0x0007,
0x0004,
0xc28a,
0xc0d2,
0xc0d9,
0xc640,
0xc633,
0xc0e1,
0xc0e3,
0xbe3c,
0xbe3c,
0x0004,
0x000b,
0xb151,
0x0013,
0x0004,
0xb88e,
0xb5a5,
0xb5a5,
0xbde8,
0xbde8,
0xbd72,
0xbd72,
0x0004,
0xba5b,
0xb46b,
0xb46b,
0xbdc3,
0xbdc3,
0xc21f,
0x0001,
0xc588,
0xc519,
0xb88a,
0x0003,
0x0006,
0xb9a9,
0xbcf6,
0xbcf6,
0xbca8,
0xbca8,
0xbe82,
0xbe82,
0xbe46,
0xbe46,
0xb150,
0x0003,
0xb269,
0xb056,
0xb892,
0xb9ae,
0xb567,
0xb567,
0xa425,
0xa425,
0xa426,
0xa426,
0x0004,
0x0027,
0x002a,
0x0045,
0xad9f,
0xad9f,
0x0002,
0x0011,
0xb55a,
0xb55a,
0xb9ab,
0x0001,
0x0004,
0x0005,
0x0006,
0x0007,
0xc4f1,
0xc59a,
0xc513,
0xc536,
0xc4fd,
0xc4fe,
0xc4ff,
0xc57f,
0xb5df,
0xb5df,
0x0002,
0x0009,
0x0004,
0x0005,
0xc220,
0xc0c7,
0xc670,
0xc50d,
0xc591,
0xc5fd,
0xc0cf,
0xc1be,
0xbca0,
0xbca0,
0xae63,
0xae63,
0xb059,
0xb26b,
0x0004,
0xb1a2,
0xae29,
0xae29,
0x0004,
0xb96c,
0x0006,
0x0011,
0xbcb0,
0xbcb0,
0xbd70,
0xbd70,
0xbd71,
0xbd71,
0xc0d6,
0x0001,
0xc51b,
0x0001,
0x0002,
0xc9fb,
0xce0d,
0x0001,
0xd20c,
0xd210,
0xbd73,
0xbd73,
0xbcaf,
0xbcaf,
0x0004,
0xb217,
0xb05d,
0x0009,
0xb96a,
0x0003,
0xb55c,
0xb55c,
0xbca3,
0xbca3,
0xc18b,
0xc0e7,
0x0004,
0x0007,
0xba2c,
0xba7b,
0xc28d,
0xc26c,
0xc1f6,
0xc0ea,
0xbd7a,
0xbd7a,
0xbcb7,
0xbcb7,
0x9e15,
0x9e15,
0xa019,
0x0001,
0xa429,
0xa429,
0xa64a,
0xa64a,
0x9004,
0x0003,
0x8c03,
0x8c03,
0x980a,
0x0003,
0x0054,
0x0091,
0x9c10,
0x9c10,
0x0002,
0x001b,
0xa946,
0x0003,
0xa42a,
0xa42a,
0x0004,
0xb058,
0x0006,
0xb05a,
0xb619,
0xb619,
0xb651,
0xb651,
0xb886,
0x0003,
0xb55d,
0xb55d,
0xc1c5,
0x0003,
0xbe3e,
0xbe3e,
0x0002,
0x0003,
0xc927,
0xc9d1,
0xca13,
0xc931,
0xa427,
0xa427,
0x0002,
0x0015,
0xb152,
0x0003,
0xac40,
0xac40,
0x0004,
0xb96e,
0xb889,
0x0005,
0xbcaa,
0xbcaa,
0xbcc5,
0xbcc5,
0xbcb6,
0xbcb6,
0x0002,
0x0003,
0xc50c,
0xc608,
0xc614,
0xc602,
0x0004,
0x0007,
0x0016,
0xb05b,
0xb557,
0xb557,
0xb62a,
0xb62a,
0xb470,
0xb470,
0xba5e,
0x0001,
0x0004,
0x0005,
0x0006,
0x0007,
0xc506,
0xc500,
0xc649,
0xc510,
0xc5d8,
0xc5fa,
0xc58d,
0xc518,
0xb47d,
0xb47d,
0xb47b,
0xb47b,
0x0004,
0xa01a,
0x9c11,
0x9c11,
0xa428,
0xa428,
0x0002,
0x0023,
0x0004,
0x001d,
0xaddb,
0xaddb,
0x0004,
0x000d,
0x0010,
0x0013,
0x0004,
0x0005,
0x0006,
0xc103,
0xc53e,
0xc675,
0xc673,
0xc51a,
0xc58e,
0xc597,
0xc1bc,
0xc1ca,
0xc180,
0xc26a,
0xc248,
0xc253,
0xbcb2,
0xbcb2,
0xbdb5,
0xbdb5,
0xbde5,
0xbde5,
0xba7d,
0xb9e2,
0xb96f,
0xb894,
0xad49,
0xad49,
0x0002,
0x0009,
0xb89e,
0x0003,
0xb471,
0xb471,
0xbcad,
0xbcad,
0xbcb5,
0xbcb5,
0xb887,
0x0003,
0xb8ba,
0xb89c,
0xbdc0,
0xbdc0,
0xbdc2,
0xbdc2,
0x0004,
0xa239,
0xa01b,
0x000d,
0xa543,
0xa543,
0xaa5a,
0x0001,
0xac45,
0xac45,
0xb244,
0x0001,
0xb47a,
0xb47a,
0xb893,
0xb895,
0xa833,
0x0003,
0xa834,
0x0005,
0xb1a3,
0xb062,
0xac41,
0xac41,
0x0004,
0x000f,
0xac46,
0xac46,
0x0004,
0x0007,
0xb472,
0xb472,
0xc1c6,
0xc0e2,
0xc1d4,
0xc1ef,
0xc0f9,
0xc24d,
0xc22f,
0xc223,
0x0004,
0x0007,
0xb672,
0xb672,
0xbdb9,
0xbdb9,
0xbcc2,
0xbcc2,
0xbcf5,
0xbcf5,
0xc1f0,
0x0001,
0xc5d7,
0xc637,
0x0004,
0x0099,
0x009c,
0x012d,
0x0004,
0x99d9,
0x980b,
0x0005,
0xa19c,
0xa01c,
0x9c12,
0x9c12,
0x0004,
0x005b,
0xa01d,
0x0073,
0x0004,
0x002b,
0xa835,
0x0049,
0x0004,
0x0017,
0xac43,
0xac43,
0x0004,
0x0007,
0x000a,
0x000d,
0xbcb4,
0xbcb4,
0xbdc8,
0xbdc8,
0xbcbd,
0xbcbd,
0xbdc1,
0xbdc1,
0xbe83,
0xbe83,
0xbdc4,
0xbdc4,
0xbe1d,
0xbe1d,
0xbdba,
0xbdba,
0xba7c,
0x0003,
0xb676,
0xb676,
0x0004,
0x0005,
0x0006,
0x0007,
0xc526,
0xc51f,
0xc697,
0xc600,
0xc525,
0xc52c,
0xc593,
0xc502,
0xac42,
0xac42,
0x0002,
0x0011,
0xb476,
0xb476,
0x0002,
0x0009,
0x0004,
0x0005,
0xc0d5,
0xc0f2,
0xc596,
0xc634,
0xc693,
0xc533,
0xc225,
0xc0d7,
0xc28f,
0xc231,
0x0004,
0x0007,
0xb561,
0xb561,
0xc1f1,
0xc0f7,
0xbdea,
0xbdea,
0xbe85,
0xbe85,
0xbe87,
0xbe87,
0xac47,
0xac47,
0x0002,
0x0005,
0xb474,
0xb474,
0xb96d,
0xb888,
0xb8a6,
0xb89a,
0xb560,
0xb560,
0x0004,
0xa947,
0xa42b,
0xa42b,
0xb05e,
0x0003,
0x0010,
0xb063,
0xb885,
0x0003,
0xb9e3,
0xb9ad,
0xc13d,
0x0003,
0xbd7c,
0xbd7c,
0xc535,
0x0001,
0x0002,
0xca0e,
0xce0f,
0xcdd2,
0xb8a1,
0xb88f,
0xb674,
0xb674,
0xa836,
0x0003,
0xaa16,
0xa837,
0xb1dd,
0x0003,
0xada0,
0xada0,
0xb88d,
0x0003,
0x0006,
0x0009,
0xbcf4,
0xbcf4,
0xc292,
0xc186,
0xc1cf,
0xc185,
0xc257,
0xc26e,
0xc291,
0xc294,
0xc262,
0xc203,
0x959b,
0x959b,
0x9407,
0x9407,
0x0004,
0x0057,
0x980c,
0x9940,
0x9c13,
0x9c13,
0x0002,
0x0009,
0xa5da,
0xa5da,
0x0002,
0xa838,
0xb05f,
0xb26d,
0xad4a,
0xad4a,
0x0004,
0x0023,
0x0026,
0x0039,
0x0004,
0xb154,
0x0016,
0x0019,
0x0004,
0x0007,
0xb89b,
0x0009,
0xc201,
0xc24e,
0xbe84,
0xbe84,
0xbdb4,
0xbdb4,
0xbcbc,
0xbcbc,
0xbe66,
0xbe66,
0xc1f4,
0x0001,
0x0002,
0xc5cc,
0xca05,
0xca36,
0xb479,
0xb479,
0xb677,
0xb677,
0xba45,
0xb89d,
0xb562,
0xb562,
0xac49,
0xac49,
0xac44,
0xac44,
0xac48,
0xac48,
0x0002,
0x0005,
0xb478,
0xb478,
0xb55f,
0xb55f,
0xb565,
0xb565,
0xb896,
0x0001,
0xbdc7,
0xbdc7,
0x0002,
0x0003,
0xc60b,
0xc5f8,
0xc595,
0xc57d,
0x0004,
0x0007,
0xac4a,
0xac4a,
0xb55e,
0xb55e,
0xb564,
0xb564,
0xb475,
0xb475,
0xb47e,
0xb47e,
0xa01e,
0x0003,
0x9c14,
0x9c14,
0x0004,
0xa83e,
0xa839,
0x0027,
0x0004,
0x0007,
0xad4b,
0xad4b,
0xb473,
0xb473,
0xb5a8,
0xb5a8,
0x0004,
0x000f,
0x0014,
0x0017,
0x0004,
0x0005,
0x0006,
0x0007,
0xc57e,
0xc508,
0xc53a,
0xc539,
0xc538,
0xc52b,
0xc52d,
0xc50b,
0x0004,
0xc0d0,
0xc0fb,
0xc137,
0xc522,
0xc529,
0xc0ef,
0xc212,
0xc10a,
0xc1f5,
0xbcdc,
0xbcdc,
0xbcca,
0xbcca,
0x0004,
0xb153,
0xae65,
0xae65,
0x0004,
0xb897,
0xb656,
0xb656,
0xbde6,
0xbde6,
0xbdbd,
0xbdbd,
0x0004,
0x9801,
0x9408,
0x9408,
0xa01f,
0x0003,
0x002a,
0x0051,
0x0004,
0xa83a,
0x0012,
0x001d,
0x0004,
0xb064,
0xb068,
0xb060,
0x0004,
0xba7e,
0xba1b,
0x0005,
0xbe1e,
0xbe1e,
0xbded,
0xbded,
0xbcdd,
0xbcdd,
0xbcd1,
0xbcd1,
0x0004,
0x0007,
0xac53,
0xac53,
0xba61,
0xb899,
0xb569,
0xb569,
0xb568,
0xb568,
0xb8a2,
0xb898,
0xac4e,
0xac4e,
0x0002,
0xb061,
0xb48b,
0xb48b,
0xb5a7,
0xb5a7,
0xa42c,
0xa42c,
0x0002,
0xaa5d,
0xac4b,
0xac4b,
0x0002,
0x0015,
0x0004,
0x0007,
0x000a,
0x000d,
0xc0ec,
0xc0fc,
0xc222,
0xc296,
0xc0df,
0xc18f,
0xc254,
0xc182,
0xc107,
0xc111,
0xc10e,
0xc1f9,
0xc112,
0xc0ed,
0xbde9,
0xbde9,
0x0004,
0x0007,
0xb5e0,
0xb5e0,
0xbcbe,
0xbcbe,
0xbdec,
0xbdec,
0xbcce,
0xbcce,
0xbce0,
0xbce0,
0x0004,
0xa99e,
0xa650,
0xa650,
0xb069,
0xb26f,
0xb067,
0x0001,
0xba64,
0xba1c,
0xb890,
0x0001,
0xbdeb,
0xbdeb,
0xbcc4,
0xbcc4
};


const U16 g_rgiHuffDecTbl44ssQb[] =
{
0x0004,
0x8802,
0x0108,
0x029d,
0x9003,
0x0003,
0x005a,
0x00df,
0x9401,
0x9401,
0x0002,
0x9994,
0x9d3a,
0x9d3a,
0x0002,
0x0045,
0x0004,
0xa83b,
0x001a,
0xa9d2,
0x0004,
0x0007,
0xac59,
0xac59,
0xb613,
0xb613,
0xb4f8,
0xb4f8,
0xb8dd,
0x0003,
0x0006,
0x0009,
0xc1ea,
0xc188,
0xc119,
0xc1ce,
0xbdab,
0xbdab,
0xbcfc,
0xbcfc,
0xbd0d,
0xbd0d,
0xbd03,
0xbd03,
0x0004,
0x0017,
0x001e,
0x0021,
0x0004,
0x0007,
0x000a,
0x000d,
0xbd04,
0xbd04,
0xbd82,
0xbd82,
0xbdb3,
0xbdb3,
0xbddc,
0xbddc,
0xbd1a,
0xbd1a,
0xbcff,
0xbcff,
0xbce9,
0xbce9,
0xbd35,
0xbd35,
0x0004,
0xb96a,
0xb4b8,
0xb4b8,
0xbd18,
0xbd18,
0xbd81,
0xbd81,
0xb4b7,
0xb4b7,
0xb499,
0xb499,
0xb49f,
0xb49f,
0xb49e,
0xb49e,
0xa428,
0xa428,
0x0002,
0xa839,
0xb149,
0x0003,
0xac5b,
0xac5b,
0xb488,
0xb488,
0xb976,
0xb8da,
0x9808,
0x0003,
0x002a,
0x006f,
0x0004,
0x0013,
0x9dd1,
0x9dd1,
0xa53d,
0xa53d,
0x0002,
0x0009,
0xad43,
0xad43,
0xb079,
0x0001,
0xb490,
0xb490,
0xba07,
0xb9a7,
0xac7c,
0xac7c,
0xac5e,
0xac5e,
0xa83a,
0x0003,
0x000e,
0xa941,
0x0004,
0x0007,
0xac5d,
0xac5d,
0xb8d2,
0xb9a4,
0xb968,
0xb9f3,
0xb563,
0xb563,
0xb55a,
0xb55a,
0xadee,
0xadee,
0xac58,
0xac58,
0xa018,
0x0003,
0xa019,
0xa01c,
0x0004,
0x002d,
0xaa04,
0xa840,
0x0004,
0x0011,
0xb154,
0x0013,
0xb8b1,
0x0003,
0xb49d,
0xb49d,
0xc1ba,
0x0003,
0xbe11,
0xbe11,
0x0002,
0xc590,
0xc9c2,
0x0001,
0xcdcb,
0xcdcd,
0xb615,
0xb615,
0xb603,
0xb603,
0x0004,
0x0007,
0x000a,
0x000d,
0xbd1e,
0xbd1e,
0xbdac,
0xbdac,
0xbd84,
0xbd84,
0xbd1c,
0xbd1c,
0xbd21,
0xbd21,
0xbcee,
0xbcee,
0xbd71,
0xbd71,
0xbe21,
0xbe21,
0x0004,
0x0007,
0x000a,
0x000d,
0xb8d4,
0xb9a2,
0xb9f2,
0xb8ca,
0xb9a8,
0xb8cc,
0xb8ea,
0xb9b1,
0xb560,
0xb560,
0xb5a5,
0xb5a5,
0xb55e,
0xb55e,
0xb4a7,
0xb4a7,
0x0004,
0xa017,
0x9c0d,
0x9c0d,
0x0004,
0x0007,
0xa42d,
0xa42d,
0xae0a,
0xae0a,
0xac5c,
0xac5c,
0x0004,
0xb08b,
0xad99,
0xad99,
0xb4c3,
0xb4c3,
0xb4d1,
0xb4d1,
0x9809,
0x0003,
0x9405,
0x9405,
0x0004,
0xa01d,
0x9c0e,
0x9c0e,
0xa996,
0x0003,
0xa5fd,
0xa5fd,
0x0004,
0x000f,
0xb076,
0x0011,
0x0004,
0xb8e6,
0xb9a9,
0xb972,
0xbdf5,
0xbdf5,
0x0002,
0x0003,
0xc57e,
0xc57f,
0xc5cf,
0xc5c5,
0xb55c,
0xb55c,
0xb614,
0xb614,
0xb4a0,
0xb4a0,
0xb5f0,
0xb5f0,
0x0004,
0x00e1,
0x0120,
0x9139,
0x0004,
0x0079,
0x008c,
0x980a,
0x0004,
0x004b,
0x004e,
0xa13b,
0x0004,
0x0007,
0x001e,
0x003d,
0xac68,
0xac68,
0xb071,
0xb077,
0xac5a,
0xac5a,
0xb19c,
0x0001,
0x0004,
0x0007,
0x000a,
0x000d,
0xc1c9,
0xc12d,
0xc133,
0xc124,
0xc224,
0xc1c4,
0xc228,
0xc186,
0xc1b7,
0xc18b,
0xbd1f,
0xbd1f,
0xbdc1,
0xbdc1,
0xbd8f,
0xbd8f,
0x0004,
0x0017,
0x001a,
0xb1d4,
0x0004,
0x0007,
0x000a,
0x000d,
0xbdc0,
0xbdc0,
0xbe0d,
0xbe0d,
0xbd11,
0xbd11,
0xbd2e,
0xbd2e,
0xbd0f,
0xbd0f,
0xbdf4,
0xbdf4,
0xbdb6,
0xbdb6,
0xbd0a,
0xbd0a,
0xb9ff,
0xb9af,
0xba1d,
0xb8d7,
0xb8f1,
0xb9fa,
0xb8b0,
0xba19,
0xac7d,
0xac7d,
0x0002,
0xb210,
0xb575,
0xb575,
0xb4bc,
0xb4bc,
0xa53e,
0xa53e,
0xa42f,
0xa42f,
0x0004,
0xa842,
0x0010,
0xa942,
0xac63,
0xac63,
0x0002,
0xb14d,
0xb59e,
0xb59e,
0x0002,
0xb8d5,
0xbd05,
0xbd05,
0xc18c,
0x0001,
0xc5cc,
0xc5c3,
0x0004,
0x0007,
0x000a,
0xb1d5,
0xba1b,
0xb906,
0xb8de,
0xb9fb,
0xb4cf,
0xb4cf,
0xb4aa,
0xb4aa,
0xb616,
0xb616,
0xb927,
0x0001,
0xbdbb,
0xbdbb,
0xbdbc,
0xbdbc,
0x0004,
0xa01a,
0x9c0f,
0x9c0f,
0xa430,
0xa430,
0x0002,
0xa841,
0xac67,
0xac67,
0x0002,
0x0005,
0xb564,
0xb564,
0xb4c0,
0xb4c0,
0xb617,
0xb617,
0xb4ab,
0xb4ab,
0xa021,
0xa01b,
0x0002,
0x0035,
0x0004,
0x0027,
0xa400,
0xa400,
0xb075,
0x0003,
0xb07f,
0x000d,
0xb4be,
0xb4be,
0x0002,
0x0005,
0xbd83,
0xbd83,
0xbdd0,
0xbdd0,
0xbe25,
0xbe25,
0xbde4,
0xbde4,
0x0004,
0x0007,
0x000a,
0x000d,
0xbd1b,
0xbd1b,
0xbd93,
0xbd93,
0xbd17,
0xbd17,
0xbd20,
0xbd20,
0xbcf0,
0xbcf0,
0xbd0e,
0xbd0e,
0xbdfc,
0xbdfc,
0xbdf6,
0xbdf6,
0x0004,
0xb089,
0xad44,
0xad44,
0x0004,
0xb9a6,
0xb56b,
0xb56b,
0xbd70,
0xbd70,
0xbd34,
0xbd34,
0xa42e,
0xa42e,
0x0002,
0x0005,
0xac66,
0xac66,
0xac5f,
0xac5f,
0x0004,
0x000b,
0xac62,
0xac62,
0xb4a9,
0xb4a9,
0xb96e,
0x0001,
0xbdec,
0xbdec,
0xc1bf,
0xc1ca,
0xb55d,
0xb55d,
0xb4ce,
0xb4ce,
0x0004,
0x0007,
0x9406,
0x9406,
0xa01e,
0xa01f,
0x9c10,
0x9c10,
0xa020,
0x0003,
0x0016,
0x0029,
0x0004,
0x000b,
0xa431,
0xa431,
0x0004,
0xb074,
0xb1d6,
0xb157,
0xb4d0,
0xb4d0,
0xb4b6,
0xb4b6,
0xb19d,
0x0003,
0xac61,
0xac61,
0xb4af,
0xb4af,
0xb8d8,
0xb8e3,
0x0004,
0x000b,
0xa432,
0xa432,
0xb080,
0xb14e,
0x0002,
0xb14f,
0xb566,
0xb566,
0xb56c,
0xb56c,
0xb073,
0x0003,
0xb072,
0xb081,
0xb4f9,
0xb4f9,
0xb4bd,
0xb4bd,
0xa434,
0xa434,
0xa84e,
0x0001,
0xb212,
0x0003,
0xac64,
0xac64,
0xb4c9,
0xb4c9,
0xb4ae,
0xb4ae,
0x0004,
0x0047,
0x006e,
0x980b,
0x9c11,
0x9c11,
0x0002,
0x003d,
0x0004,
0xa845,
0x0012,
0x0035,
0xb0a4,
0x0003,
0xac69,
0xac69,
0xb55f,
0xb55f,
0x0002,
0x0005,
0xc18d,
0xc1e7,
0xc1e5,
0xc1e9,
0xbdb8,
0xbdb8,
0xbcef,
0xbcef,
0x0004,
0x0017,
0x001e,
0xb152,
0x0004,
0x0007,
0x000a,
0x000d,
0xbdde,
0xbdde,
0xbddf,
0xbddf,
0xbe01,
0xbe01,
0xbe0b,
0xbe0b,
0xbcfe,
0xbcfe,
0xbd32,
0xbd32,
0xbdb5,
0xbdb5,
0xbd30,
0xbd30,
0x0004,
0xb916,
0xb8e5,
0xba0f,
0xbe2a,
0xbe2a,
0xbe27,
0xbe27,
0xb90c,
0xb8e7,
0xb4b4,
0xb4b4,
0xb0a5,
0xb155,
0xad48,
0xad48,
0xa846,
0xa847,
0xa43e,
0xa43e,
0xa1f7,
0x0003,
0x0022,
0xa02a,
0x0004,
0xa844,
0xa853,
0x000d,
0xac65,
0xac65,
0xb078,
0x0001,
0xb8e4,
0x0003,
0xb55b,
0xb55b,
0xbd26,
0xbd26,
0xbd91,
0xbd91,
0x0004,
0xb085,
0x0006,
0x0009,
0xb4c5,
0xb4c5,
0xb4f4,
0xb4f4,
0xba1c,
0xb8e8,
0xba1e,
0xb967,
0xb936,
0xb9aa,
0xb910,
0xb907,
0xa435,
0xa435,
0xa84d,
0xa84a,
0x9c13,
0x9c13,
0x9c12,
0x9c12,
0x0004,
0x9004,
0x00c6,
0x0135,
0x0004,
0x005f,
0x0086,
0x00b1,
0x0004,
0xa022,
0x0026,
0x0031,
0x0004,
0x000f,
0x001e,
0xa843,
0x0004,
0x0007,
0xac60,
0xac60,
0xb4f7,
0xb4f7,
0xb565,
0xb565,
0xb5f1,
0xb5f1,
0xb56d,
0xb56d,
0xb0a2,
0xb082,
0x0002,
0x0009,
0xb8e0,
0x0003,
0xb4ad,
0xb4ad,
0xbdbd,
0xbdbd,
0xbde1,
0xbde1,
0xb4d6,
0xb4d6,
0xb4ac,
0xb4ac,
0xb08a,
0xb09a,
0xad47,
0xad47,
0xa84b,
0x0003,
0x0006,
0xaa06,
0xb1fe,
0xb093,
0xb086,
0xb095,
0xac6d,
0xac6d,
0xadd3,
0xadd3,
0x0004,
0x0017,
0xa437,
0xa437,
0xac6a,
0xac6a,
0x0002,
0x000d,
0x0004,
0x0007,
0xb938,
0xb923,
0xbd7d,
0xbd7d,
0xbd78,
0xbd78,
0xbd7a,
0xbd7a,
0xbd2c,
0xbd2c,
0xb8ec,
0xb937,
0xb92f,
0xb913,
0x0004,
0x0007,
0x000a,
0xb0bb,
0xb900,
0xb985,
0xb912,
0xb9be,
0xb90b,
0xb902,
0xb4c2,
0xb4c2,
0xb5d9,
0xb5d9,
0xb501,
0xb501,
0x0004,
0xa026,
0xa023,
0x0009,
0xa433,
0xa433,
0xa848,
0x0001,
0xb0a6,
0xb087,
0xad45,
0xad45,
0x0004,
0x000b,
0x0012,
0x0015,
0xb083,
0x0003,
0xad46,
0xad46,
0xb5d8,
0xb5d8,
0xb4b5,
0xb4b5,
0xac6c,
0xac6c,
0x0002,
0xb161,
0xb4c7,
0xb4c7,
0xb4b2,
0xb4b2,
0xb09b,
0xb084,
0xb0f6,
0xb0ba,
0xad9a,
0xad9a,
0xac7b,
0xac7b,
0x9c15,
0x9c15,
0x0002,
0x0015,
0xa84c,
0x0003,
0xa43f,
0xa43f,
0xae0c,
0xae0c,
0x0002,
0x0009,
0x0004,
0xb8f2,
0xb8ed,
0xb96f,
0xbd2a,
0xbd2a,
0xc1e0,
0xc17b,
0xba22,
0xb8fb,
0xb9ad,
0xb9db,
0xa602,
0xa602,
0xa854,
0x0001,
0x0004,
0x0007,
0x000a,
0xb153,
0xb9ae,
0xb909,
0xba00,
0xb922,
0xb4dc,
0xb4dc,
0xb605,
0xb605,
0xb5a0,
0xb5a0,
0xb4bf,
0xb4bf,
0x0004,
0xa02b,
0x9c14,
0x9c14,
0xa849,
0x0003,
0xa855,
0x0005,
0xb08d,
0xb158,
0xad4a,
0xad4a,
0xb1ef,
0xb098,
0xad4b,
0xad4b,
0x0004,
0x0017,
0x9407,
0x9407,
0xa195,
0x0003,
0xa027,
0xa025,
0xa850,
0x0003,
0xa436,
0xa436,
0x0004,
0x0007,
0xb08f,
0xb097,
0xb4db,
0xb4db,
0xb4cd,
0xb4cd,
0xb4c4,
0xb4c4,
0xb4d3,
0xb4d3,
0xa13c,
0x0003,
0x000a,
0x0011,
0xa43d,
0xa43d,
0x0002,
0xa852,
0xb0a3,
0xb151,
0xb150,
0xb1d7,
0xa53f,
0xa53f,
0x0002,
0xa997,
0xae0e,
0xae0e,
0xadf8,
0xadf8,
0x0004,
0x002f,
0x003e,
0xa851,
0x0004,
0x0017,
0x0022,
0x0025,
0x0004,
0x0007,
0x000a,
0x000d,
0xc192,
0xc189,
0xc18a,
0xc1e8,
0xbd80,
0xbd80,
0xbdeb,
0xbdeb,
0xbde6,
0xbde6,
0xbe23,
0xbe23,
0xbe29,
0xbe29,
0xbdc8,
0xbdc8,
0x0004,
0x0007,
0xb9b0,
0xb9c7,
0xbd31,
0xbd31,
0xbd2b,
0xbd2b,
0xbd29,
0xbd29,
0xbdb4,
0xbdb4,
0xb8fa,
0xb977,
0xb91d,
0xba1f,
0xb928,
0xb97c,
0xb8eb,
0xb8e1,
0x0004,
0x0007,
0x000a,
0xb091,
0xb4cb,
0xb4cb,
0xb574,
0xb574,
0xb61a,
0xb61a,
0xb4b3,
0xb4b3,
0xb5f9,
0xb5f9,
0xb4f3,
0xb4f3,
0xac6e,
0xac6e,
0xac6b,
0xac6b,
0x0004,
0x0023,
0x0026,
0x980c,
0xa029,
0x0003,
0xa024,
0x0019,
0x0004,
0xa84f,
0xa856,
0x000d,
0x0004,
0xb08c,
0xac7e,
0xac7e,
0xb4d9,
0xb4d9,
0xb9e2,
0x0001,
0xbdb9,
0xbdb9,
0xbd8e,
0xbd8e,
0xb0b9,
0x0003,
0xb094,
0xb096,
0xb4c6,
0xb4c6,
0xb4c1,
0xb4c1,
0xa43c,
0xa43c,
0xa438,
0xa438,
0x9ded,
0x9ded,
0x9c16,
0x9c16,
0x0004,
0x002b,
0x003e,
0xa02c,
0x0004,
0x0007,
0x000a,
0x001d,
0xac6f,
0xac6f,
0xac7a,
0xac7a,
0xb159,
0xb0f5,
0xad4c,
0xad4c,
0x0004,
0x0007,
0x000a,
0x000d,
0xb8fd,
0xb914,
0xb925,
0xb987,
0xb908,
0xb8e2,
0xb915,
0xba09,
0xb9e3,
0xb9dd,
0xba26,
0xba20,
0xb573,
0xb573,
0xb618,
0xb618,
0x0004,
0xb0a8,
0xb08e,
0xb162,
0xb5da,
0xb5da,
0xb569,
0xb569,
0x0004,
0xa998,
0xa857,
0x000d,
0xb09c,
0x0003,
0xad9b,
0xad9b,
0xb4df,
0xb4df,
0xb9b2,
0x0001,
0xbd79,
0xbd79,
0xbdc6,
0xbdc6,
0xb092,
0xb0a1,
0xac70,
0xac70,
0x0004,
0xaa08,
0xa540,
0xa540,
0xad56,
0xad56,
0x0002,
0x0005,
0xb59f,
0xb59f,
0xb5a1,
0xb5a1,
0xb4c8,
0xb4c8,
0xb5a3,
0xb5a3
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\wmalib\wmadec_s\lpc.c ===
/*************************************************************************

Copyright (C) Microsoft Corporation, 1996 - 1999

Module Name:

    MsAudio.cpp

Abstract:

    Implementation of public member functions for CAudioObject.

Author:

    Wei-ge Chen (wchen) 16-November-1998

Revision History:

    Sil Sanders (sils) 8-Feb-00 - combine Integer and Float versions and simplify


*************************************************************************/
#pragma code_seg("WMADEC")
#pragma data_seg("WMADEC_RW")
#pragma const_seg("WMADEC_RD")

#if defined(ENABLE_ALL_ENCOPT) && defined(ENABLE_LPC)

#if !defined(_WIN32_WCE) && !defined(HITACHI)
#include <time.h>
#endif  // _WIN32_WCE
#include <math.h>
#include <limits.h>
#include "msaudio.h"
#include "stdio.h"
#include "AutoProfile.h"
#include "float.h"
#include "..\..\..\dsound\dsndver.h"


// *** one of these may be set by platform in macros.h ***
//// in performance figures an X86 tick = 1/1193182 seconds = 838 ns (500MHz Pentium Dell 610)
//// and a SH4 Tick = 80ns (Dreamcast SH4 200Mhz)
//// X86 tested with wmadec_s Release build w/ PROFILE and wmatest_sh4 Release Build with PROFILE

// **************** warning ***************************
// every time you change one of these PLATFORM_LPC defines below, you must rebuilt all!
// ****************************************************

// A pruned or decomposed FFT - fast (old default)
// But uses an excess amount of cache
//#define PLATFORM_LPC_PRUNED_NONREDUNDANT
//// X86 Tough_32s_22:  1,376,277               Tough_16m_16:    556,708
//// SH4 Tough_32s_22: 22,842,016               Tough_16m_16:  8,488,652

// A pruned or decomposed FFT - both fast and V4 numerically compatabible
//#define PLATFORM_LPC_PRUNED_STRAIGHT
//// X86 Tough_32s_22:  1,490,909               Tough_16m_16:    545,381
//// SH4 Tough_32s_22: 23,573,152               Tough_16m_16:  8.603.243

// PLATFORM_LPC_DIRECT using trig recurrsion
//#define PLATFORM_LPC_DIRECT
//// X86 Tough_32s_22:  5,300,299               Tough_16m_16:  1,533,753
//// SH4 Tough_32s_22: 43,303,596               Tough_16m_16: 12,927,913

// PLATFORM_LPC_LITDFT is theoretically the fastest but isnt.  
// Above methods are very clever but this does limited damage to the cache.
//#define PLATFORM_LPC_LITDFT
//// X86 Tough_32s_32:  2,868,037 = 1,281,738+1,560,625+1,186,050-1,160,376
//// SH4 Tough_32s_32: 41,381,752 

// PLATFORM_LPC_FOLDED is derived from ARM's implementation
//#define PLATFORM_LPC_FOLDED

// PLATFORM_LPC_FOLDED_PRUNED uses ARM's Folded Trick with otherwise PLATFORM_LPC_PRUNED_NONREDUNDANT
// Fast and uses little extra memory and so is the default
//#define PLATFORM_LPC_FOLDED_PRUNED

#if !(defined(PLATFORM_LPC_PRUNED_NONREDUNDANT) || defined(PLATFORM_LPC_DIRECT) \
   || defined(PLATFORM_LPC_LITDFT) || defined(PLATFORM_LPC_PRUNED_STRAIGHT)     \
   || defined(PLATFORM_LPC_FOLDED) || defined(PLATFORM_LPC_FOLDED_PRUNED) )
//  set the default if none is otherwise selected
#   define PLATFORM_LPC_FOLDED_PRUNED
#endif

#if defined(PI) != (defined(PLATFORM_LPC_PRUNED_NONREDUNDANT) +defined(PLATFORM_LPC_DIRECT) \
                  + defined(PLATFORM_LPC_LITDFT) + defined(PLATFORM_LPC_PRUNED_STRAIGHT)    \
                 +  defined(PLATFORM_LPC_FOLDED) + defined(PLATFORM_LPC_FOLDED_PRUNED))
#       pragma COMPILER_MESSAGE(__FILE__ "(84) : Warning - Multiple LPC Platforms selected.")
#endif

#if defined(PLATFORM_LPC_FOLDED_PRUNED)
// use a smaller trig table and calculate the 6 lpc constants from base sin/cos values
// so far, only implemented for PLATFORM_LPC_FOLDED_PRUNED
#   if !(defined(PLATFORM_LPC_SMALL_TRIG_TABLE) || defined(PLATFORM_LPC_NO_TRIG_TABLE))
// these two alternatives are essentially the same speed on the SH3.  NO_TRIG_TABLE saves rom/cache space.
//#     define PLATFORM_LPC_SMALL_TRIG_TABLE
#       define PLATFORM_LPC_NO_TRIG_TABLE
#   endif
#endif

// LPC in V4 has a couple of bugs 
// Define the symbol below to replicate that bug as well as V4 style computations for comparision
// Can be used with any of the methods above
//#define REPLICATE_V4_LPC

#if defined(V4V5_COMPARE_MODE) && !defined(REPLICATE_V4_LPC)
#define REPLICATE_V4_LPC
#endif

//#define REPLICATE_ARM_NON_TRUNCATED_LPC

#if defined(_DEBUG) && defined(LPC_COMPARE)
        static void prvSetupLpcSpecTrig(CAudioObject* pau);
#define SETUP_LPC_SPEC_TRIG(pau) prvSetupLpcSpecTrig(pau)
#else
#define SETUP_LPC_SPEC_TRIG(pau) 
#endif

#define MAX_LP_SPEC_SIZE 2048


#if defined(V4V5_COMPARE_MODE) && defined(BUILD_INT_FLOAT) && 0

// To be sure, use old version of lpc in lpc_float.c
// no longer exists #include        "lpc_float.c"

#else // so not V4V5_COMPARE_MODE 


#include "lpcConst.h"

//function prototype, used to eliminate Mac warnings
Void prvPq2lpc(CAudioObject* pau, LpType* p, LpType* q, LpType* lpc, Int order);
Void prvConvolve_odd(CAudioObject* pau, LpType* in1, Int l1, LpType* in2, Int l2, LpType* out, Int *lout);
Void prvConvolve(CAudioObject* pau, LpType *in1, Int l1, LpType *in2, Int l2, LpType *out, Int *lout);
Void prvLsp2pq(CAudioObject* pau, U8 *lsfQ, LpType *p, LpType *q, Int order);


// *****************************************************************************
//
// Conversion from LSF thru Parcor to LPC
//
// *****************************************************************************

// Parcor to LPC conversion
Void prvPq2lpc(CAudioObject* pau, LpType* p, LpType* q, LpType* lpc, Int order)
{
  I32 i;
  
  for(i=1; i<=order/2; i++) {
    lpc[i-1]= -DIV2(p[i]+q[i]);
    lpc[order-i]= -DIV2(p[i]-q[i]);
  }
}

/* symmetric convolution */
Void prvConvolve_odd(CAudioObject* pau, LpType* in1, Int l1, LpType* in2, Int l2, LpType* out, Int *lout)
{
  // In BUILD_INTEGER mode, in1 assumed to have FRACT_BITS_LSP and in2 to have FRACT_BITS_LP. Output will have
  // FRACT_BITS_LP.
  I32   i,j;
  LpType ret[100];
  
  for (i=0; (i<l1)&&(i<l2); i++) {
    ret[i]=0;
    for (j=0; j<=i; j++) {
      ret[i] += MULT_LSP(in1[j],in2[i-j]);
    }
  }
  
  for (i=l1; i<(l1+l2)/2; i++) {
    ret[i]=0;
    for (j=0; j<l1; j++) {
      ret[i] += MULT_LSP(in1[j],in2[i-j]);
    }
  }
  
  *lout=(l1+l2)-1;
  for (i=0; i<(*lout)/2; i++) {
    out[i]=ret[i];
    out[(*lout-1)-i]=ret[i];
  }
  out[*lout/2]=ret[*lout/2];
}

/* symmetric convolution */
Void prvConvolve(CAudioObject* pau, LpType *in1, Int l1, LpType *in2, Int l2, LpType *out, Int *lout)
{
  // In BUILD_INTEGER mode, in1 assumed to have FRACT_BITS_LSP and in2 to have FRACT_BITS_LP. Output will have
  // FRACT_BITS_LP.
  I32   i,j;
  LpType ret[100];
  
  for (i=0; (i<l1)&&(i<l2); i++) {
    ret[i]=0;
    for (j=0; j<=i; j++) {
      ret[i] += MULT_LSP(in1[j],in2[i-j]);
    }
  }
  
  for (i=l1; i<(l1+l2)/2; i++) {
    ret[i]=0;
    for (j=0; j<l1; j++) {
      ret[i] += MULT_LSP(in1[j],in2[i-j]);
    }
  }
  
  *lout=(l1+l2)-1;
  for (i=0; i<(*lout)/2; i++) {
    out[i]=ret[i];
    out[(*lout-1)-i]=ret[i];
  }
}

#if defined(REPLICATE_V4_LPC) && defined(BUILD_INT_FLOAT)
#define LSF_DECODE(i,lsfQ) -2.0F*(Float)cos(2.0*PI*(g_rgfltLsfReconLevel [i] [lsfQ[i]]) )
#define LP_DECODE(i,lsfQ)  LSF_DECODE((i),(lsfQ))
#else
#define LSF_DECODE(i,lsfQ) g_rgiLsfReconLevel[i][lsfQ[i]]
#if defined(BUILD_INTEGER)
#define LP_DECODE(i,lsfQ) (g_rgiLsfReconLevel[i][lsfQ[i]] >> (FRACT_BITS_LSP-FRACT_BITS_LP))
#else
#define LP_DECODE(i,lsfQ) LSF_DECODE((i),(lsfQ))
#endif // BUILD_INTEGER
#endif

// Only updates
#define ARRAY_RANGE_FMAX(a,b,c,d,init,i) if ((init)) d = -FLT_MAX; \
for ((i)=(b);(i)<(c);(i)++) (d) = ((d) < (a)[i]) ? (a)[i] : (d);
#define ARRAY_RANGE_FMIN(a,b,c,d,init,i) if ((init)) d = FLT_MAX; \
for ((i)=(b);(i)<(c);(i)++) (d) = ((d) > (a)[i]) ? (a)[i] : (d);

// Quantized LSF to PARCOR

Void prvLsp2pq(CAudioObject* pau, U8 *lsfQ, LpType *p, LpType *q, Int order)
{
    I32     i;
    LpType  long_seq[100];
    LspType short_seq[3];
    Int     long_length, short_length;
    
#if 0 // only to create preload for g_rgiLsfReconLevel in lpcconst.h
    static int first = 1;
    if (first)
    {
        for( i = 0; i<LPCORDER; i++ )
        {
            printf("LP_CONST16(");
            for( first = 0; first < 15; first++ )
                printf("%.10f,", g_rgfltLsfReconLevel [i] [first] != 0 ? -2.0F*(Float)cos(2.0*PI*(g_rgfltLsfReconLevel [i] [first]) ) : 0.0f );
            printf("%.10f),\n", g_rgfltLsfReconLevel [i] [first] != 0 ? -2.0F*(Float)cos(2.0*PI*(g_rgfltLsfReconLevel [i] [first]) ) : 0.0f );
        }
        first = 0;
    }
#endif
    
    short_length = 3; 
    long_length  = 2;
    
    short_seq[0] = short_seq[2] = LSP_FROM_FLOAT(1);
    long_seq[0]  = long_seq[1]  = LP_FROM_FLOAT(1);
    
    for (i = 0; i < order; i+= 2) {
        short_seq[1]= LSF_DECODE(i,lsfQ);   // -2.0F*(Float)cos(2.0*PI*lsp[i])
        prvConvolve(pau, short_seq, short_length, long_seq, long_length, 
            long_seq, &long_length);
    }
    
    for (i=1; i<=order/2; i++) {
        p[i] = long_seq[i];
    }
    
    long_length = 3;
    long_seq[0] = LP_FROM_FLOAT(1);
    long_seq[1] = LP_DECODE(1,lsfQ);             // -2.0F*(Float)cos(2.0*PI*lsp[1])
    long_seq[2] = LP_FROM_FLOAT(1);
    
    for (i = 3; i < order; i += 2) {
        short_seq[1]= LSF_DECODE(i,lsfQ);   // -2.0F*(Float)cos(2.0*PI*lsp[i])
        prvConvolve_odd(pau, short_seq, short_length, long_seq, long_length, 
            long_seq, &long_length);
    }
    
    for (i=1; i<=order/2; i++) {
        q[i]=long_seq[i]-long_seq[i-1];
    }
}

// Quantized LSF to LPC
Void    auLsp2lpc(CAudioObject* pau, U8 *lsfQ, LpType *lpc, Int order)
{
  LpType p[LPCORDER+2],q[LPCORDER+2];
  
  prvLsp2pq(pau, lsfQ,p,q,order);
  
  prvPq2lpc(pau, p,q,lpc,order);
}



// ************************************************************************************
//
// InverseQuadRoot(x) = (1/x)^(1/4) 
// where the 1/4 is one squareroot combined with the flattenfactor
//
// Do this three different ways:  Encoder, Integer Decoder, IntFloat Decoder
//
// ************************************************************************************

#ifdef BUILD_INTEGER

#ifndef LPCPOWER32
static void gLZLTableInit(void);

U8 gLZLTable[128];

static void gLZLTableInit(void)
{
   int i,j;
   U8 mask;

   for(i=0;i<128;i++)
   {
	   mask=0x80;
	   for(j=0;j<8;j++)
	   {
         if((2*i)&mask)
			 break;
		 mask>>=1;
	   }

	   
	   gLZLTable[i]=j;

       mask=0x80;
	   for(j=0;j<8;j++)
	   {
         if((2*i+1)&mask)
			 break;
		 mask>>=1;
	   }

       gLZLTable[i]|=j<<4;
   }

}
#endif

#define PRECESSION_BITS_FOR_INVQUADROOT 12
// 14 makes this marginally better but requires 50kB more RAM
// V4 used a value of 18!
// These tables should be in the text segment.

//Build tables for inverse quad root calculation encoder outputs float decoder outputs int
#ifdef ENCODER

Float g_InvQuadRootFraction[1<<(PRECESSION_BITS_FOR_INVQUADROOT)];
Float g_InvQuadRootExponent[32-PRECESSION_BITS_FOR_INVQUADROOT];

Void prvInitInverseQuadRootTable (CAudioObject* pau)
{
    Int i;
    for (i = 1; i < 1<<(PRECESSION_BITS_FOR_INVQUADROOT); i++){          
        Float f = (Float)i/LP_SPEC_SCALE;
        Float invQuadRoot = (Float)(1/sqrt(sqrt(f)));
        g_InvQuadRootFraction[i] = invQuadRoot;
    }
    g_InvQuadRootFraction[0] = (Float)(1/(sqrt(sqrt(1.0/LP_SPEC_SCALE/2))));            // 32.0

    for (i = 0; i < 32-PRECESSION_BITS_FOR_INVQUADROOT; i++){
        Float invQuadRoot = (Float)(1<<i);
                invQuadRoot = (Float)(1/sqrt(sqrt(invQuadRoot)));  
        g_InvQuadRootExponent[i] = invQuadRoot;
    }
        SETUP_LPC_SPEC_TRIG(pau);
#ifndef LPCPOWER32

	gLZLTableInit();
#endif
}

INLINE Float InverseQuadRoot(Int f){
    Float frac,exp;
    Int iFrac,iExp;
    iExp = 0;
    iFrac = f;
    while (iFrac >= (1<<(PRECESSION_BITS_FOR_INVQUADROOT))){
        iExp++;
        iFrac>>=1;
    }
    frac = g_InvQuadRootFraction[iFrac];
    exp = g_InvQuadRootExponent[iExp];
    return frac*exp;
}

#else   // so must be Integer Decoder

// INVQUADROOT_FRACTION_TABLE_SIZE defined as 256 and interpolate
//UInt g_InvQuadRootFraction[1+INVQUADROOT_FRACTION_TABLE_SIZE];

//UInt g_InvQuadRootExponent[BITS_LP_SPEC_POWER];  // was [32-PRECESSION_BITS_FOR_INVQUADROOT]

Void prvInitInverseQuadRootTable (CAudioObject* pau)
{
#if 0
    Int i;
    
    for (i = 1; i < 1<<(PRECESSION_BITS_FOR_INVQUADROOT); i++){          
        Float f = (float)i/LP_SPEC_POWER_SCALE;
        Float invQuadRoot = (Float)(1/sqrt(sqrt(f)));                                   
        //// range is 11.3137:0.0525556 or in bits +3.5:-4.25
        // When PRECESSION_BITS_FOR_INVQUADROOT = 14, LP_SPEC_POWER_SCALE = 28, range is 128.000000:11.313881 ==> QR_FRAC = 32-8
        // When PRECESSION_BITS_FOR_INVQUADROOT = 14, LP_SPEC_POWER_SCALE = 30, range is 181.019333:16.000244 ==> QR_FRAC = 32-9
        // When PRECESSION_BITS_FOR_INVQUADROOT = 14, LP_SPEC_POWER_SCALE = 31, range is 215.269482:19.027604 ==> QR_FRAC = 32-8
        g_InvQuadRootFraction[i] = (UInt)(invQuadRoot*(1<<QR_FRACTION_FRAC_BITS));
    }
    g_InvQuadRootFraction[0] = (UInt)((1/(sqrt(sqrt(1.0/LP_SPEC_SCALE/2))))*(1<<QR_FRACTION_FRAC_BITS));
    
    for (i = -PRECESSION_BITS_FOR_INVQUADROOT; i < BITS_LP_SPEC_POWER-PRECESSION_BITS_FOR_INVQUADROOT; i++){
        Float invQuadRoot = (i<0) ? (float)pow(2,i) : (float)(1<<i);
                invQuadRoot = (Float)(1/sqrt(sqrt(invQuadRoot)));                               
                // range is 45.2548:3.36364 or in bits +5.5:1.75 for 32 bit power. 
        g_InvQuadRootExponent[i+PRECESSION_BITS_FOR_INVQUADROOT] = (UInt)(invQuadRoot*(1<<QR_EXPONENT_FRAC_BITS));
    }
        // range of product is 511.999:0.176778 or +9.0:-2.5
        // When PRECESSION_BITS_FOR_INVQUADROOT = 14, BITS_LP_SPEC_POWER = 64, range is 1.000000:0.005524 ==> QR_EXP = 32-2
        // So value should work with a LP_SPEC_FRAC_BITS of 22.
#endif
    SETUP_LPC_SPEC_TRIG(pau);
#ifndef LPCPOWER32

	gLZLTableInit();
#endif
}

//Debugging aid to dealwith LPC calculations separately from InverseQuadRoot
//#define FAKE_INVERSE_QUAD_ROOT


INLINE WeightType InverseQuadRoot(LpSpecPowerType f)
{
    //// 1.0f/(1<<30)
    WeightType uiResult;
    LpSpecPowerType uFrac;
    Int iExp;// can be -ve
    UInt uiExpVal;
    UInt uiTmp;
    
    uFrac = f;
    // Get normalized fractional portion with PRECESSION_BITS_FOR_INVQUADROOT
    // bits and corresponding exponent value
    if (uFrac == 0) {
      iExp = 0;
    } else {
      // Find the most significant bit with value 1.
#if defined (LPCPOWER32)
      // 32-bit input
      iExp = 0;
      uiTmp = uFrac;
#else 
      // 64-bit input: Look at each 32-bit portion
      // We are assuming that PRECESSION_BITS_FOR_INVQUADROOT is < 32.
      if ((uFrac >> 32) == 0) {
        iExp = 32;
        uiTmp = (UInt) uFrac;
      } else {
        iExp = 0;
        uiTmp = (UInt)(uFrac >> 32);
      }
#endif
      while (!(uiTmp & 0x80000000)) { uiTmp <<= 1; iExp++;};
      
      // Perform shifts on the input so that we have 
      // PRECESSION_BITS_FOR_INVQUADROOT bits of normalized 
      // fraction, and corresponding exponent values.
      
      uFrac = f;
      iExp = BITS_LP_SPEC_POWER - iExp - PRECESSION_BITS_FOR_INVQUADROOT;
      if (iExp < 0) 
        uFrac <<= (-iExp);
      if (iExp > 0)
        uFrac >>= iExp;
    }
    
    // QR_*_FRAC_BITS: same as used in prvInitInverseQuadRootTable
    MONITOR_COUNT(gMC_ScaleInverseQuadRoot,iExp);
    uFrac = g_InvQuadRootFraction[(Int)uFrac];
    //// iFrac*1.0f/(1<<23)
    uiExpVal = g_InvQuadRootExponent[iExp+PRECESSION_BITS_FOR_INVQUADROOT];
    //// iExp*1.0f/(1<<29)
    uiResult = MULT_HI_UDWORD(((UInt)uFrac),uiExpVal);  // frac_bits = 23+29-32 = 20
    //// iResult*1.0f/(1<<20)
#if ((QR_FRACTION_FRAC_BITS+QR_EXPONENT_FRAC_BITS-32) > WEIGHTFACTOR_FRACT_BITS)
    uiResult >>= (QR_FRACTION_FRAC_BITS+QR_EXPONENT_FRAC_BITS-31) - WEIGHTFACTOR_FRACT_BITS;
#elif ((QR_FRACTION_FRAC_BITS+QR_EXPONENT_FRAC_BITS-32) < WEIGHTFACTOR_FRACT_BITS)
    uiResult <<= WEIGHTFACTOR_FRACT_BITS - (QR_FRACTION_FRAC_BITS+QR_EXPONENT_FRAC_BITS-31);
#endif //((QR_FRACTION_FRAC_BITS+QR_EXPONENT_FRAC_BITS-32) > WEIGHTFACTOR_FRACT_BITS)
    // uiResult = (2^19/QR(iFrac*2^-19)) * 2^6 * (2^19/QR(2^iExp)) * 2^7 * 2^-32 = 2^19/QR(iFrac*2^-19*2^iExp)
    // uiResult = MULT_HI_DWORD(iFrac<<(BITS_PER_DWORD-FRACT_BITS_LP_SPEC>>1),(iExp<<((BITS_PER_DWORD-FRACT_BITS_LP_SPEC>>1)+1)));
    assert( uiResult >= 0 );
    
    //fprintf(stdout, "%lf\n", (double)uiResult/(1<<WEIGHTFACTOR_FRACT_BITS));
    return uiResult;
}
#endif // Integer Encoder and Decoder variation

#else   // so must be BUILD_INT_FLOAT

#define PRECESSION_BITS_FOR_INVQUADROOT 12
//Tables for inverse quad root calculation
UInt g_InvQuadRootExponent[0x100];
UInt g_InvQuadRootMantissa[1<<(PRECESSION_BITS_FOR_INVQUADROOT)];

//Build tables for fast inverse quad root calculation
Void prvInitInverseQuadRootTable (CAudioObject* pau)
{
    //Iterate through floating point numbers with 12 bits of presition
    //The folowing loop is equivalent to 
    //for (Float i = 1.0; i < 1.999756;i+=1.000244)
    Int i;
    for (i = 0; i < 1<<(PRECESSION_BITS_FOR_INVQUADROOT); i++){          
        Int fltInt = 0x3F800000 | (i << (23-PRECESSION_BITS_FOR_INVQUADROOT));//Build floating point      
        Float f = *(Float *)&fltInt;                       //number in the form of 1.i * pow(2,0);
        Float invQuadRoot = (Float)(1/sqrt(sqrt(f)));  //Calculate inverse quad root
        fltInt = *(Int *)&invQuadRoot;          
        g_InvQuadRootMantissa[i] = fltInt;             //Store value in table
    }
    
    //Iterate through floating point exponents from pow(2,-126)...pow(2,127) by powers of 2
    for (i = 1; i < 255; i++){
        Int fltInt = (i << 23);                             //Build floating point number in the form
        Float f = *(Float *)&fltInt;            //of 1.0 * pow(2,(i-125))
        f = (Float)(1/sqrt(sqrt(f)));           //calculate inverse quad root / 2
        g_InvQuadRootExponent[i] = *(Int *)&f;  //Store in table   
    }
    SETUP_LPC_SPEC_TRIG(pau);
}

INLINE WeightType InverseQuadRootF(Float f){
    Float frac = (*(Float *)&(g_InvQuadRootMantissa[((*(Int *)&f) &   0x7FFFFF) >> (23-PRECESSION_BITS_FOR_INVQUADROOT)]));
    Float exp  = (*(Float *)&(g_InvQuadRootExponent[((*(Int *)&f) & 0x7F800000) >> 23]));
    return (frac * exp);
}

INLINE WeightType InverseQuadRootI(Int f){
    Float frac = (*(Float *)&(g_InvQuadRootMantissa[(f &   0x7FFFFF) >> (23-PRECESSION_BITS_FOR_INVQUADROOT)]));
    Float exp  = (*(Float *)&(g_InvQuadRootExponent[(f & 0x7F800000) >> 23]));
    //fprintf(stdout, "%.20lf\n", ((double)*(Float*)(&f)));
    //fprintf(stdout, "%.20lf\n", ((double)frac * (double)exp));
    return (frac * exp);
}

// there appears to be no effect of calling The I suffix or the F suffix.  
// lpc_float.c called the I suffix.
#define InverseQuadRoot(X) InverseQuadRootI(*(Int*)&X)

#endif // of BUILD_INTEGER and BUILD_INT_FLOAT variations


// *****************************************************************************
//
// Support for Integer and Float versions of LPC to Spectrum 
//
// *****************************************************************************

#if defined(BUILD_INTEGER)
 
INLINE LpSpecPowerType square(LpSpecType x) {
    /* x must be less than sqrt(2^12)*2^19 to avoid overflow */
    if ( abs(x) < 0x01000000 )
        return (LpSpecPowerType) 
        (MULT_HI_DWORD(x<<((BITS_PER_DWORD-FRACT_BITS_LP_SPEC)>>1),x<<((BITS_PER_DWORD-FRACT_BITS_LP_SPEC+1)>>1)));
    return (LpSpecPowerType) 
        (MULT_HI_DWORD(x,x) << (BITS_PER_DWORD-FRACT_BITS_LP_SPEC));
}

INLINE LpSpecPowerType square64(LpSpecType x) {
    return (LpSpecPowerType)(((U64)x * (U64)x) >> (2 * FRACT_BITS_LP_SPEC - FRACT_BITS_LP_SPEC_POWER));
}

#if defined(_DEBUG)

static LpSpecPowerType DebugSquare(LpSpecType x) {
    UInt y;
    Float f2 = (float)x/(LP_SPEC_SCALE);
    Float f3 = f2*f2;
    Float f4 = f3*LP_SPEC_SCALE;
    Float dif,rel;
    y = (UInt) square(x);

    dif = (Float)fabs(f4-y);
    rel = (Float)fabs(dif/f4);
    if ((f4 > 10.0f) && (rel > .2f)) {
        assert(WMAB_FALSE);
    }
    return y;
}


static Int MultBp2Debug(int x, int y) {
    Float fx,fy,fa,rel,dif;
    Int a;
    a = MULT_BP2(x,y);
    fx = (Float)x;
    fy = (Float)y;
    fa = fx*fy/(1<<30);
    dif = (Float)fabs(fa-a);
    rel = (Float)fabs(dif/fa);
    if ((fa > 5.0f) && (rel > .5f)) {
        assert(WMAB_FALSE);
    }
    return a;
}

#if defined (LPCPOWER32)
#   define SQUARE(x) DebugSquare(x)
#   define SUM_SQUARES(x,y) (DebugSquare(x)+DebugSquare(y))
#elif defined(U64SQUARE32SR)
#   define SQUARE(x) U64SQUARE32SR(x, (2 * FRACT_BITS_LP_SPEC - FRACT_BITS_LP_SPEC_POWER))
#ifdef U64SUM_SQUARES32SR
#   define SUM_SQUARES(x,y) U64SUM_SQUARES32SR(x,y, (2 * FRACT_BITS_LP_SPEC - FRACT_BITS_LP_SPEC_POWER))
#else
#   define SUM_SQUARES(x,y) (square64(x)+square64(y))
#endif
#else 
#   define SQUARE(x) square64(x) 
#   define SUM_SQUARES(x,y) (square64(x)+square64(y))
#endif // LPCPOWER32
#   define MULT_BP2X(x,y) MultBp2Debug(x,y)

#else // so not _DEBUG

#if defined (LPCPOWER32)
#   define SQUARE(x) square(x)
#   define SUM_SQUARES(x,y) (square(x)+square(y))
#elif defined(U64SQUARE32SR)
#   define SQUARE(x) U64SQUARE32SR(x, (2 * FRACT_BITS_LP_SPEC - FRACT_BITS_LP_SPEC_POWER))
#ifdef U64SUM_SQUARES32SR
#   define SUM_SQUARES(x,y) U64SUM_SQUARES32SR(x,y, (2 * FRACT_BITS_LP_SPEC - FRACT_BITS_LP_SPEC_POWER))
#else
#   define SUM_SQUARES(x,y) (square64(x)+square64(y))
#endif
#else
#   define SQUARE(x) square64(x) 
#   define SUM_SQUARES(x,y) (square64(x)+square64(y))
#endif // LPCPOWER32
#   define MULT_BP2X(x,y) MULT_BP2(x,y)

#endif  // end of _DEBUG and not _DEBUG variations

#else // so must be BUILD_INT_FLOAT

#   define SQUARE(x) ((x)*(x))
#   define SUM_SQUARES(x,y) ((x)*(x)+(y)*(y))
#   define MULT_BP2X(x,y) ((x)*(y))

#endif

#if defined(REPLICATE_V4_LPC)
#       define SQRT2_2  BP2_FROM_FLOAT(0.7071067811865)
#       define SQRT2    BP2_FROM_FLOAT(1.414213562373)
#else
#       define SQRT2_2  BP2_FROM_FLOAT(0.70710678118654752440084436210485)
#       define SQRT2    BP2_FROM_FLOAT(1.4142135623730950488016887242097)
#endif

// Main LpcSpectrum function only calls the following function which can be optimized on a platform-by-platform basis
#if defined(PLATFORM_SPECIFIC_INVERSEQUADROOT)
extern WeightType InverseQuadRootOfSumSquares(LpSpecType F1, LpSpecType F2 );
#else

#if defined(BUILD_INTEGER) && !defined(LPCPOWER32)
// here we have a limited (256) size lookup table and will interpolate values between them.
// note that two times we call this with pF2==NULL, for F[0] and for F[2048>>xxx]

#if 0
U8 gLZLTable[128];

static void gLZLTableInit(void)
{
   int i,j;
   U8 mask;

   for(i=0;i<128;i++)
   {
	   mask=0x80;
	   for(j=0;j<8;j++)
	   {
         if((2*i)&mask)
			 break;
		 mask>>=1;
	   }

	   
	   gLZLTable[i]=j;

       mask=0x80;
	   for(j=0;j<8;j++)
	   {
         if((2*i+1)&mask)
			 break;
		 mask>>=1;
	   }

       gLZLTable[i]|=j<<4;
   }

}

#endif


#if defined(WMA_TARGET_MIPS) && defined(BUILD_INTEGER)


#include "macros_mips_lpc.h"

#else

//INLINE
WeightType InverseQuadRootOfSumSquares(LpSpecType F1, LpSpecType F2 )
{
    // LpSpecPowerType is U64.
    LpSpecPowerType f = SUM_SQUARES( F1, F2 );
    U32 uiMSF = (U32)(f>>32);
    Int iExp = 0;
    int iMSF8;
    U32 uiFrac1;
	U8 index;
    if ( uiMSF==0 ) {
        iExp = 32;
        uiMSF = (U32)f;
    }
    if (uiMSF==0) 
        return(0xFFFFFFFF);
    // normalize the most significant fractional part
    while( (uiMSF & 0xFf000000)==0 ) {
        iExp += 8;
        uiMSF <<= 8;
    }


	index=(U8)(uiMSF>>24);
	iExp+=((gLZLTable[index>>1]>>((index&1)<<2)))&0xf;


    // discard the most significant one bit (it's presence is built into g_InvQuadRootFraction)
    iExp++;
    //MONITOR_COUNT(gMC_ScaleInverseQuadRoot,iExp);
    MONITOR_RANGE(gMC_ScaleInverseQuadRoot,iExp);
    // get all 32 bits from source
#if defined(PLATFORM_OPTIMIZE_MINIMIZE_BRANCHING)
    uiMSF = (U32)((f<<iExp)>>32);
#else
    uiMSF = (iExp>32) ? (U32)(f<<(iExp-32)) : (U32)(f>>(32-iExp));
#endif
    // split into top INVQUADROOT_FRACTION_TABLE_LOG2_SIZE==8 bits for fractional lookup and bottom bits for interpolation
    iMSF8 = uiMSF>>(32-INVQUADROOT_FRACTION_TABLE_LOG2_SIZE);
    uiMSF <<= INVQUADROOT_FRACTION_TABLE_LOG2_SIZE;
    // lookup and interpolate - tables are set up to return correct binary point for WeightType
    uiFrac1  = g_InvQuadRootFraction[iMSF8++];
    uiFrac1 -= MULT_HI_UDWORD( uiMSF, uiFrac1 - g_InvQuadRootFraction[iMSF8] );
    return MULT_HI_UDWORD( uiFrac1, g_InvQuadRootExponent[ iExp ] );
}

#endif

#else   // defined(BUILD_INTEGER) && !defined(LPCPOWER32)

INLINE WeightType InverseQuadRootOfSumSquares(LpSpecType F1, LpSpecType F2 )
{
    LpSpecPowerType f = SUM_SQUARES( F1, F2 );
    return InverseQuadRoot( f );
}

#endif  // defined(BUILD_INTEGER) && !defined(LPCPOWER32)

#endif  // PLATFORM_SPECIFIC_INVERSEQUADROOT

#if defined(_DEBUG) && defined(LPC_COMPARE)  //compare results

#   ifdef UNDER_CE
        extern void WMADebugMessage(const char* pszFmt, ... );
#       define MYPRINTF WMADebugMessage
#   else
#       define MYPRINTF printf
#   endif

void LpcCompareDebug( CAudioObject* pau, Int iFreq, Int iF, Int iT, LpSpecType* F, const LpType* rgLpcCoef )
{
    //to compare results find the line that reads
    //Float fltTemp = (iFreq + 0.5F) * PI / pau->m_cSubband;
    //and remove the + 0.5F
    static Float max = 0.001f;  //.00001f;
    static Int cnt = 0;
    static Float sum = 0;
    Float old_way, new_way;
    Float R = 1;
    Float I = 0;
    int j;
    cnt++;
    for (j = 0; j < LPCORDER; j++)  
    {
        R -= FLOAT_FROM_LP(rgLpcCoef [j]) * pau->m_rgfltLpsSpecCos [j] [iT];
        I -= FLOAT_FROM_LP(rgLpcCoef [j]) * pau->m_rgfltLpsSpecSin [j] [iT];
    }
    old_way = (Float)(1/pow((R * R + I * I),pau->m_fltFlatenFactor/2));
#   if defined(PLATFORM_LPC_FOLDED) || defined(PLATFORM_LPC_PRUNED_NONREDUNDANT) || defined( PLATFORM_LPC_FOLDED_PRUNED)
        new_way = FLOAT_FROM_WEIGHT(F[iF]);
#   else
        new_way = FLOAT_FROM_WEIGHT(InverseQuadRoot(F[iF]));
#   endif
    sum += (Float)fabs(old_way-new_way);
    if (fabs(old_way-new_way)  > max) 
    {
        max = (Float)fabs(old_way-new_way);
        MYPRINTF("max error=%f, %%=%f, Frame=%4d, iFreq=%4d, Size=%4d, ave err=%f\n", 
            max, 100*max/old_way, pau->m_iFrameNumber, iFreq, 
#           ifdef REPLICATE_V4_LPC
                pau->m_cFrameSampleHalf, 
#           else
                (pau->m_fV5Lpc) ? pau->m_cSubband : pau->m_cFrameSampleHalf, 
#           endif
            sum/cnt );
    }
}
#define LPC_COMPARE_DEBUG( pau, iFreq, iF, iT, F, rgLpcCoef ) LpcCompareDebug( pau, iFreq, iF, iT, F, rgLpcCoef )
#pragma COMPILER_MESSAGE(__FILE__ "(704) : Warning - LPC_COMPARE Mode - output to stdout!")
#else
#define LPC_COMPARE_DEBUG( pau, iFreq, iF, iT, F, rgLpcCoef )
#endif

// define LPC_SPEC_PRINT_FRAME to get a printout of particular frame
//#define LPC_SPEC_PRINT_FRAME 2
#if defined(_DEBUG) && defined(LPC_SPEC_PRINT_FRAME)
#define LPC_SPEC_PRINT(a,b,c,d,e)                               \
        if ( pau->m_iFrameNumber == LPC_SPEC_PRINT_FRAME )      \
                printf("%4d  %d  %4d  %10.6f  %10.6f\n",a,b,c,d,e);
#else
#define LPC_SPEC_PRINT(a,b,c,d,e)
#endif

// define LPC_FT_PRINT_FRAME to get a printout of particular frame
//#define LPC_FT_PRINT_FRAME 2
#if defined(_DEBUG) && defined(LPC_FT_PRINT_FRAME)
#define LPC_FT_PRINT(a,b,c,d,e,f)                               \
        if ( pau->m_iFrameNumber == LPC_FT_PRINT_FRAME )        \
                printf("%4d  %d  %4d  %10.6f  %10.6f  %10.6f\n",a,b,c,d,e,f);
#else
#define LPC_FT_PRINT(a,b,c,d,e,f)
#endif

//#define PRINT_WEIGHT_FACTOR 100000000
#	ifdef PRINT_WEIGHT_FACTOR
		// this function must be defined in fft.c
		extern void DebugDctPrintCoefs(CAudioObject* pau, int def, int id, float fac, CoefType* pfCoef);
#		define WF_PRINT(pfCoef)  DebugDctPrintCoefs(pau,PRINT_WEIGHT_FACTOR,4,1.0f*(1<<WEIGHTFACTOR_FRACT_BITS),pfCoef)
#   else
#       define WF_PRINT(pfCoef)
#   endif

#if defined(PLATFORM_LPC_FOLDED_PRUNED) && !defined(V4V5_COMPARE_MODE)

// ************************************************************************************
// ************************* This is the one we normally use **************************
// ************************************************************************************

//#pragma COMPILER_MESSAGE(__FILE__ "(735) : Warning - building PLATFORM_LPC_FOLDED_PRUNED LPC spectrum")

// ************************************************************************************
//
// LPC to Spectrum using a "Pruned" FFT and redundant calculation removal
//
// See Sorensen & Burrus, IEEE Trans Signal Processing V41 #3 March 93
// and the references sited there for a treatment of pruned and Transform-decomposited DFT
// Unclear how this particular implementation relates to those articles.
//
// Originally designed and implemented by Wei-ge and Marc.  
// Restructured by Sil to be a single routine.  
// Later restructured again to use only a small stack array (inspired by ARM's technique).
//
// The use of pointers instead of array indexes speeds up the SH4 and has no effect on the X86
//
// Cache usage: constants 14kb (note SH3 cache size is 16kb and we need 8k of WF plus constants)
//
// ************************************************************************************


#if defined(PLATFORM_LPC_NO_TRIG_TABLE) || defined(PLATFORM_LPC_SMALL_TRIG_TABLE)

#if defined(PLATFORM_SPECIFIC_DOLPC4)

extern void prvDoLpc4( const Int k, const LpSpecType* pTmp, WeightType* pWF, const Int iSizeBy2, const BP2Type S1, const BP2Type C1 );

#else // defined(PLATFORM_SPECIFIC_DOLPC4)

#if !(defined(WMA_TARGET_MIPS) && defined(BUILD_INTEGER))
void prvDoLpc4( const Int k, const LpSpecType* pTmp, WeightType* pWF, const Int iSizeBy2, const BP2Type S1, const BP2Type C1 ) 
{
    BP2Type    CmS, CpS;
    LpSpecType T2, T4, T6, T7, T8, T9, TA, TB;
    LpSpecType D, E;

    BP2Type    C2, S2, C3, S3;

//#define DOLPC4_BREAK 243
#if defined(DOLPC4_BREAK) && defined(_DEBUG)
    if ( k==DOLPC4_BREAK || (iSizeBy2-k)==DOLPC4_BREAK || (iSizeBy2+k)==DOLPC4_BREAK || ((iSizeBy2<<1)-k)==DOLPC4_BREAK )
    {
        DEBUG_BREAK();
    }
    
#endif
    CmS = C1 - S1;                              // cnst4[i*6+4];
    CpS = C1 + S1;                              // cnst4[i*6+5];
    assert( BP2_FROM_FLOAT(1.0) <= CpS && CpS < BP2_FROM_FLOAT(1.5) );
    T8 = MULT_BP2X(CmS,pTmp[2]) + MULT_BP2X(CpS,pTmp[3]);     // F[2048+j]    F[3072-j]
    T6 = MULT_BP2X(CpS,pTmp[2]) - MULT_BP2X(CmS,pTmp[3]);     // F[2048+j]    F[3072-j]

    S2 = MUL2(MULT_BP2X(C1,S1));                        // sin(2x)
    C2 = BP2_FROM_FLOAT(1.0f) - MUL2(MULT_BP2X(S1,S1)); // cos(2x)
    CmS = C2 - S2;                              // cnst4[i*6+2];
    CpS = C2 + S2;                              // cnst4[i*6+3];
    T7 = MULT_BP2X(CmS,pTmp[0]) + MULT_BP2X(CpS,pTmp[1]);     // F[1024+j]    F[2048-j]
    T4 = MULT_BP2X(CpS,pTmp[0]) - MULT_BP2X(CmS,pTmp[1]);     // F[1024+j]    F[2048-j]

    S3 = MULT_BP2X(S1,C2) + MULT_BP2X(C1,S2);   // sin(3x) = sin(x+2x)
    C3 = MULT_BP2X(C1,C2) - MULT_BP2X(S1,S2);   // cos(2x) = cos(x+2x)
    CmS = C3 - S3;                              // old cnst4[i*6];
    CpS = C3 + S3;                              // old cnst4[i*6+1];
    T9 = MULT_BP2X(CmS,pTmp[4]) + MULT_BP2X(CpS,pTmp[5]);     // F[3072+j]    F[4096-j]
    T2 = MULT_BP2X(CpS,pTmp[4]) - MULT_BP2X(CmS,pTmp[5]);     // F[3072+j]    F[4096-j]

    TA = pTmp[6] + pTmp[7];                                   // F[j]      +  F[1024-j];
    TB = pTmp[6] - pTmp[7];                                   // F[j]      -  F[1024-j];

    D  = DIV2(+ T7  + T8 + T9 + TA);
    E  = DIV2(+ T4  + T6 + T2 + TB);
    pWF[k]           = InverseQuadRootOfSumSquares(D, E);              // F[j]

    D  = DIV2(- T7  + T6 - T2 + TA);
    E  = DIV2(+ T4  + T8 - T9 - TB);
    pWF[iSizeBy2-k]  = InverseQuadRootOfSumSquares(D, E);              // F[1024-j]

    D  = DIV2(- T7  - T6 + T2 + TA);
    E  = DIV2(- T4  + T8 - T9 + TB);
    pWF[iSizeBy2+k]  = InverseQuadRootOfSumSquares(D, E);              // F[1024+j]

    D  = DIV2(- T4  + T6 + T2 - TB);
    E  = DIV2(+ T7  - T8 - T9 + TA);
    pWF[(iSizeBy2<<1)-k]  = InverseQuadRootOfSumSquares(D, E);         // F[2048-j]

    //INTEGER_ONLY( assert( F[j]>=0 && F[(1024>>iShrink)-j]>=0 && F[(1024>>iShrink)+j]>=0 && F[(2048>>iShrink)-j]>=0 ) );

    //** This block uses 36 adds and 20 mults plus either 4 more mults or 4 shifts
}
#else
void (*prvDoLpc4)( const Int k, const LpSpecType* pTmp, WeightType* pWF, const Int iSizeBy2, const BP2Type S1, const BP2Type C1 ) ;
#endif

#endif  // defined(PLATFORM_SPECIFIC_DOLPC4)
#else   // defined(PLATFORM_LPC_NO_TRIG_TABLE) || defined(PLATFORM_LPC_SMALL_TRIG_TABLE)

void prvDoLpc4( const Int k, const LpSpecType* pTmp, WeightType* pWF, const Int iSizeBy2, const Int iShrink ) 
{
    const BP2Type *pC4;
    BP2Type    CmS, CpS;
    LpSpecType T2, T4, T6, T7, T8, T9, TA, TB;
    LpSpecType D, E;


    // if we folded the constants, we could just increment rather than recalculate this pointer
    pC4 = &lpc_cnst4[k*(6<<iShrink)];

    CmS = *pC4++;   // old cnst4[i*6];
    CpS = *pC4++;   // old cnst4[i*6+1];
    T9 = MULT_BP2X(CmS,pTmp[4]) + MULT_BP2X(CpS,pTmp[5]);     // F[3072+j]    F[4096-j]
    T2 = MULT_BP2X(CpS,pTmp[4]) - MULT_BP2X(CmS,pTmp[5]);     // F[3072+j]    F[4096-j]

    CmS = *pC4++;   // cnst4[i*6+2];
    CpS = *pC4++;   // cnst4[i*6+3];
    T7 = MULT_BP2X(CmS,pTmp[0]) + MULT_BP2X(CpS,pTmp[1]);     // F[1024+j]    F[2048-j]
    T4 = MULT_BP2X(CpS,pTmp[0]) - MULT_BP2X(CmS,pTmp[1]);     // F[1024+j]    F[2048-j]

    CmS = *pC4++;   // cnst4[i*6+4];
    CpS = *pC4;     // cnst4[i*6+5];
    assert( BP2_FROM_FLOAT(1.0) <= CpS && CpS < BP2_FROM_FLOAT(1.5) );
    T8 = MULT_BP2X(CmS,pTmp[2]) + MULT_BP2X(CpS,pTmp[3]);     // F[2048+j]    F[3072-j]
    T6 = MULT_BP2X(CpS,pTmp[2]) - MULT_BP2X(CmS,pTmp[3]);     // F[2048+j]    F[3072-j]

    TA = pTmp[6] + pTmp[7];                                   // F[j]      +  F[1024-j];
    TB = pTmp[6] - pTmp[7];                                   // F[j]      -  F[1024-j];

    D  = DIV2(+ T7  + T8 + T9 + TA);
    E  = DIV2(+ T4  + T6 + T2 + TB);
    pWF[k]           = InverseQuadRootOfSumSquares(D, E);              // F[j]

    D  = DIV2(- T7  + T6 - T2 + TA);
    E  = DIV2(+ T4  + T8 - T9 - TB);
    pWF[iSizeBy2-k]  = InverseQuadRootOfSumSquares(D, E);              // F[1024-j]

    D  = DIV2(- T7  - T6 + T2 + TA);
    E  = DIV2(- T4  + T8 - T9 + TB);
    pWF[iSizeBy2+k]  = InverseQuadRootOfSumSquares(D, E);              // F[1024+j]

    D  = DIV2(- T4  + T6 + T2 - TB);
    E  = DIV2(+ T7  - T8 - T9 + TA);
    pWF[(iSizeBy2<<1)-k]  = InverseQuadRootOfSumSquares(D, E);              // F[2048-j]

    //INTEGER_ONLY( assert( F[j]>=0 && F[(1024>>iShrink)-j]>=0 && F[(1024>>iShrink)+j]>=0 && F[(2048>>iShrink)-j]>=0 ) );

    //** This block uses 36 adds and 20 mults plus either 4 more mults or 4 shifts
}
#endif
   

#if defined(PLATFORM_SPECIFIC_LPC_JLOOP_BOTTOM) && defined(PLATFORM_LPC_NO_TRIG_TABLE) 
    extern void prvLpcJLoopBottom( int j, const LpSpecType* pTmp, WeightType* pWF, const Int iSizeBy2, 
                            BP2Type *pS1, BP2Type *pC1, BP2Type *pS1p, BP2Type *pC1p, const BP2Type STEP1 ); 
#else
    // use this to generate optimized assembly to start your own asm version
    void prvLpcJLoopBottom( int j, const LpSpecType* pTmp, WeightType* pWF, const Int iSizeBy2, 
                            BP2Type *pS1, BP2Type *pC1, BP2Type *pS1p, BP2Type *pC1p, const BP2Type STEP1 ) 
    {
        BP2Type S1 = *pS1;
        BP2Type C1 = *pC1;
        BP2Type S2, C2, SLS1, SLC1, CLS1, CLC1;
        int iSizeBy8 = iSizeBy2>>2;
        const BP2Type SL8     = BP2_FROM_FLOAT(0.38268343236508977172845998403040);     // sim(pi/8)   = sin(pi*iSizeBy8*(1<<iShrink)/2048)
        const BP2Type CL8     = BP2_FROM_FLOAT(0.92387953251128675612818318939679);     // cos(pi/8)   = sin(pi*iSizeBy8*(1<<iShrink)/2048)
        const BP2Type SL4     = BP2_FROM_FLOAT(0.70710678118654752440084436210485);     // sim(pi/4)   = sin(pi*iSizeBy4*(1<<iShrink)/2048)
        const BP2Type CL4     = BP2_FROM_FLOAT(0.70710678118654752440084436210485);     // cos(pi/4)   = sin(pi*iSizeBy4*(1<<iShrink)/2048)
        DEBUG_ONLY( int iSize = iSizeBy2<<1; )
        DEBUG_ONLY( int iSizeBy4 = iSizeBy2>>1; )
        DEBUG_ONLY( int iShrink = LOG2(MAX_LP_SPEC_SIZE/iSize); )

        assert( fabs(FLOAT_FROM_BP2(S1)-sin(PI*j/iSize)) < 0.0001 
             && fabs(FLOAT_FROM_BP2(C1)-cos(PI*j/iSize)) < 0.0001 );

        prvDoLpc4( j, pTmp, pWF, iSizeBy2, S1, C1 );

        S2 = (SLC1 = MULT_BP2X(SL8,C1)) - (CLS1 = MULT_BP2X(CL8,S1));
        C2 = (CLC1 = MULT_BP2X(CL8,C1)) + (SLS1 = MULT_BP2X(SL8,S1));
        assert( fabs(FLOAT_FROM_BP2(S2)-FLOAT_FROM_BP2(TRIGTBL(iSizeBy8-j,0)))<0.0001 
             && fabs(FLOAT_FROM_BP2(C2)-FLOAT_FROM_BP2(TRIGTBL(iSizeBy8-j,1)))<0.0001 );
        prvDoLpc4( iSizeBy8 - j, pTmp+8,  pWF, iSizeBy2, S2, C2 );

        S2 = SLC1 + CLS1;
        C2 = CLC1 - SLS1;
        assert( fabs(FLOAT_FROM_BP2(S2)-FLOAT_FROM_BP2(TRIGTBL(iSizeBy8+j,0)))<0.0001 
             && fabs(FLOAT_FROM_BP2(C2)-FLOAT_FROM_BP2(TRIGTBL(iSizeBy8+j,1)))<0.0001 );
        prvDoLpc4( iSizeBy8 + j, pTmp+16, pWF, iSizeBy2, S2, C2 );

        S2 = MULT_BP2X(SL4,C1) - MULT_BP2X(CL4,S1);
        C2 = MULT_BP2X(CL4,C1) + MULT_BP2X(SL4,S1);
        assert( fabs(FLOAT_FROM_BP2(S2)-FLOAT_FROM_BP2(TRIGTBL(iSizeBy4-j,0)))<0.0001 
             && fabs(FLOAT_FROM_BP2(C2)-FLOAT_FROM_BP2(TRIGTBL(iSizeBy4-j,1)))<0.0001 );
        prvDoLpc4( (iSizeBy2>>1) - j, pTmp+24, pWF, iSizeBy2, S2, C2 );

		// rotate angle by b = pi/iSize
		// recursion: cos(a+b) = cos(a-b) + 2*sin(b)*sin(a)
		// and:       sin(a+b) = sin(a-b) - 2*sin(b)*cos(a)
		*pC1 = *pC1p - MULT_BP2X(STEP1,S1);
		*pS1 = *pS1p + MULT_BP2X(STEP1,C1);
		*pC1p = C1;
		*pS1p = S1;
    }
#   endif // defined(PLATFORM_SPECIFIC_LPC_JLOOP_BOTTOM)



WMARESULT prvLpcToSpectrum(CAudioObject* pau, const LpType* rgLpcCoef, PerChannelInfo* ppcinfo)
{
    // put often used variables near the top for easier access in platforms like the SH3 and SH4
    LpSpecType original[LPCORDER];
    LpSpecType *pFb;      
    Int i, j;
    LpSpecType t1pO7, t1mO7, tO1pO9, tO1mO9, tO0pO8, tO0mO8, tO4pO6, tO4mO6;
    LpSpecType t1pO7pO3, t1pO7mO3, tO1pO5pO9, tO0pO2pO4pO6pO8;
    LpSpecType tS2x; 
    LpSpecType tCpS1x, tCmS1x, tCpS2x, tCmS2x;
    LpSpecType CpS1, CmS1, CpS2, CmS2;
    LpSpecType D, E, F, G, H, I, J;
    
    LpSpecType* rgwtLpcSpec;
    WeightType wtLpcSpecMax, wtTemp;
    Int iFreq, iF, iLoopLimit;
    Int iShrink, iStride; 
    LpSpecType Tmp[32];
    WeightType* pWF = (WeightType*)INTEGER_OR_INT_FLOAT( (I32 *)ppcinfo->m_rguiWeightFactor, ppcinfo->m_rgfltWeightFactor ); 
    Int iSize, iSizeBy2, iSizeBy4, iSizeBy8, iSizeBy16;

#   if defined(PLATFORM_LPC_SMALL_TRIG_TABLE)
        BP2Type SLC1, CLS1, CLC1, SLS1;
        BP2Type S4, C4;
        BP2Type S1, C1;
        const BP2Type *pC4, *pC1;
        Int pCInc4, pCInc1;

        const BP2Type SL16    = BP2_FROM_FLOAT(0.19509032201612826784828486847702);     // sim(pi/16)  = sin(pi*iSizeBy16*(1<<iShrink)/2048)
        const BP2Type CL16    = BP2_FROM_FLOAT(0.98078528040323044912618223613424);     // cos(pi/16)  = sin(pi*iSizeBy16*(1<<iShrink)/2048)
        const BP2Type SL8     = BP2_FROM_FLOAT(0.38268343236508977172845998403040);     // sim(pi/8)   = sin(pi*iSizeBy8*(1<<iShrink)/2048)
        const BP2Type CL8     = BP2_FROM_FLOAT(0.92387953251128675612818318939679);     // cos(pi/8)   = sin(pi*iSizeBy8*(1<<iShrink)/2048)
        const BP2Type SL3by16 = BP2_FROM_FLOAT(0.55557023301960222474283081394853);     // sim(pi3/16) = sin(pi*3*iSizeBy16*(1<<iShrink)/2048)
        const BP2Type CL3by16 = BP2_FROM_FLOAT(0.83146961230254523707878837761791);     // cos(pi3/16) = sin(pi*3*iSizeBy16*(1<<iShrink)/2048)
        const BP2Type SL4     = BP2_FROM_FLOAT(0.70710678118654752440084436210485);     // sim(pi/4)   = sin(pi*iSizeBy4*(1<<iShrink)/2048)
        const BP2Type CL4     = BP2_FROM_FLOAT(0.70710678118654752440084436210485);     // cos(pi/4)   = sin(pi*iSizeBy4*(1<<iShrink)/2048)
#   elif defined(PLATFORM_LPC_NO_TRIG_TABLE)
#       if !defined(PLATFORM_SPECIFIC_LPC_JLOOP_BOTTOM)
            BP2Type SLC1, CLS1, CLC1, SLS1;
#       endif
        BP2Type CT, ST;
        const SinCosTable* pSinCosTable;
        BP2Type S4, C4, S4p, C4p, STEP4;
        BP2Type S1, C1, S1p, C1p, STEP1;

        const BP2Type SL16    = BP2_FROM_FLOAT(0.19509032201612826784828486847702);     // sim(pi/16)  = sin(pi*iSizeBy16*(1<<iShrink)/2048)
        const BP2Type CL16    = BP2_FROM_FLOAT(0.98078528040323044912618223613424);     // cos(pi/16)  = sin(pi*iSizeBy16*(1<<iShrink)/2048)
        const BP2Type SL8     = BP2_FROM_FLOAT(0.38268343236508977172845998403040);     // sim(pi/8)   = sin(pi*iSizeBy8*(1<<iShrink)/2048)
        const BP2Type CL8     = BP2_FROM_FLOAT(0.92387953251128675612818318939679);     // cos(pi/8)   = sin(pi*iSizeBy8*(1<<iShrink)/2048)
        const BP2Type SL3by16 = BP2_FROM_FLOAT(0.55557023301960222474283081394853);     // sim(pi3/16) = sin(pi*3*iSizeBy16*(1<<iShrink)/2048)
        const BP2Type CL3by16 = BP2_FROM_FLOAT(0.83146961230254523707878837761791);     // cos(pi3/16) = sin(pi*3*iSizeBy16*(1<<iShrink)/2048)
        const BP2Type SL4     = BP2_FROM_FLOAT(0.70710678118654752440084436210485);     // sim(pi/4)   = sin(pi*iSizeBy4*(1<<iShrink)/2048)
        const BP2Type CL4     = BP2_FROM_FLOAT(0.70710678118654752440084436210485);     // cos(pi/4)   = sin(pi*iSizeBy4*(1<<iShrink)/2048)
#   else
        Int k, jj;
        Int iMapLpcIdxOffset[4];
        LpSpecType* pTmp;
        const BP2Type* pC4;
        Int pCInc4;
#   endif
    
    FUNCTION_PROFILE(fp);
    FUNCTION_PROFILE_START(&fp,LPC_TO_SPECTRUM_PROFILE);
    
#ifdef REPLICATE_V4_LPC
    iSize = pau->m_cFrameSampleHalf;
#elif defined(REPLICATE_ARM_NON_TRUNCATED_LPC)
    iSize = pau->m_cSubband;
#else
    if (pau->m_fV5Lpc)
        iSize = pau->m_cSubband;
    else 
        iSize = pau->m_cFrameSampleHalf;
#endif
    iShrink = LOG2(MAX_LP_SPEC_SIZE/iSize);     // for smaller transforms, shrink or expand indexing
    iStride = MAX_LP_SPEC_SIZE/iSize;           // for smaller transforms, stride past unused (lpc_compare only)
    iSizeBy2 = iSize>>1;
    iSizeBy4 = iSizeBy2>>1;
    iSizeBy8 = iSizeBy4>>1;
    iSizeBy16 = iSizeBy8>>1;
    // iSize can be 2048, 1024, 512, 256, or 128.
    //      at 32000 Hz: 2048, 1024, 512 and 256
    //      at 22050 Hz: 1024, 512, 256 and 128
    //      at 16000 Hz: 512, 256, and 128
    //      at 11025 Hz: 512, 256, and 128
    //      at  8000 Hz: 512.

    
        
    // DEBUG_ONLY( if (pau->m_iFrameNumber==32) { DEBUG_BREAK(); } );
    
    assert(pau->m_fltFlatenFactor == 0.5f); //So we can use quadRoot instead of pow(x,m_fltFlatenFactor/2);
    assert( iSize <= MAX_LP_SPEC_SIZE );
    
    //for (i = 0; i < LPCORDER; i++) 
    //fprintf(stdout, "%.20lf\n", (double) FLOAT_FROM_LP(rgLpcCoef[i])); 
    
    for (i = 0; i < LPCORDER; i++) 
        original[i] = -LP_SPEC_FROM_LP(rgLpcCoef[i]); 
      
                                        // F[128]
    Tmp[14]  = (t1pO7 = LP_SPEC_FROM_FLOAT(1) + original[7]) + (tS2x = MULT_BP2X(SQRT2,original[3]));
                                        // F[256]  
    Tmp[22]  = (t1mO7 = LP_SPEC_FROM_FLOAT(1) - original[7]) + original[3];
    Tmp[30]  = t1mO7;                   // F[384]
    Tmp[31]  = t1pO7 - tS2x;            // F[640]
    Tmp[23]  = t1mO7 - original[3];     // F[768]
    Tmp[15]  = t1mO7;                   // F[896]
    
                                        // F[1152] 
    Tmp[8]  = (tO1pO9 = original[1] + original[9]) + (tS2x = MULT_BP2X(SQRT2,original[5]));
                                        // F[1280] 
    Tmp[16]  = (tO1mO9 = original[1] - original[9]) + original[5];
    Tmp[24]  = tO1mO9;                  // F[1408]
    Tmp[25]  = tO1pO9 - tS2x;           // F[1664]
    Tmp[17]  = tO1mO9 - original[5];    // F[1792]
    Tmp[9]  = tO1mO9;                   // F[1920] 
    
                                        // F[2176] 
    Tmp[10]  = (tO0pO8 = original[0] + original[8]) + (tS2x = MULT_BP2X(SQRT2,original[4]));
                                        // F[2304] 
    Tmp[18]  = (tO0mO8 = original[0] - original[8]) + original[4];
    Tmp[26]  = tO0mO8;                  // F[2432]
    Tmp[27]  = tO0pO8 - tS2x;           // F[2688]
    Tmp[19]  = tO0mO8 - original[4];    // F[2816] 
    Tmp[11]  = tO0mO8;                  // F[2944]
    
                                        // F[3200] 
    Tmp[12]  = original[2] + (tS2x = MULT_BP2X(SQRT2,original[6]));
    Tmp[20]  = original[2] + original[6]; // F[3328]
    Tmp[28]  = original[2];             // F[3456] 
    Tmp[29]  = original[2] - tS2x;      // F[3712]
    Tmp[21]  = original[2] - original[6]; // F[3840]
    Tmp[13]  = original[2];             // F[3968]
    
    tO4pO6 = original[4] + original[6];
    tO4mO6 = original[4] - original[6];
    t1pO7pO3 = t1pO7 + original[3];
    t1pO7mO3 = t1pO7 - original[3];
    tO1pO5pO9 = tO1pO9 + original[5];
    tO0pO2pO4pO6pO8 = tO0pO8 + tO4pO6 + original[2];

    D  = t1pO7pO3 + tO1pO5pO9 + tO0pO2pO4pO6pO8;    // F[0]
    E  = t1pO7mO3 + (tS2x = MULT_BP2X(SQRT2_2, tO0pO8 - tO4mO6 - original[2]));     // F[512]
    F  = t1pO7pO3 - tO1pO5pO9;                      // F[1024]
    G  = t1pO7mO3 - tS2x;                           // F[1536]
    H  = -tO1pO9 + original[5] + (tS2x = MULT_BP2X(SQRT2_2,tO0pO8 - tO4pO6 + original[2]));  // F[2560]
    I  =  tO0pO8 + tO4mO6 - original[2];            // F[3072]
    J  =  tO1pO9 - original[5] + tS2x;              // F[3584]
    
    // j==0 and i==0 below.
    pFb   =  (LpSpecType*) &pWF[0];      
    *pFb  =  InverseQuadRootOfSumSquares(D, 0);     // F[0]
    pFb  +=  iSizeBy4;   
    *pFb  =  InverseQuadRootOfSumSquares(E, J);     // F[512]    b: F[512]    a: F[3584]
    pFb  +=  iSizeBy4;    
    *pFb  =  InverseQuadRootOfSumSquares(F, I);     // F[1024]    b: F[1024]   a: F[3072]
    pFb  +=  iSizeBy4;    
    *pFb  =  InverseQuadRootOfSumSquares(G, H);     // F[1536]   b: F[1536]   a: F[2560]

    // k - example:  iSize = 0x100 = 256, j==0
    //         i:  0   1   2   3 
    //    kdx         10  20  30 
    // 80-kdx         70  60  50  
    // 80+kdx         90  a0  b0
    //100-kdx         f0  e0  d0  

#   if defined(PLATFORM_LPC_NO_TRIG_TABLE) || defined(PLATFORM_LPC_SMALL_TRIG_TABLE)

        assert( fabs(FLOAT_FROM_BP2(SL16)-FLOAT_FROM_BP2(TRIGTBL(iSizeBy16,0)))<0.0001 
             && fabs(FLOAT_FROM_BP2(CL16)-FLOAT_FROM_BP2(TRIGTBL(iSizeBy16,1)))<0.0001 );

        prvDoLpc4( iSizeBy16, Tmp+8, pWF, iSizeBy2, SL16, CL16 );

        assert( fabs(FLOAT_FROM_BP2(SL8)-FLOAT_FROM_BP2(TRIGTBL(iSizeBy8,0)))<0.0001 
             && fabs(FLOAT_FROM_BP2(CL8)-FLOAT_FROM_BP2(TRIGTBL(iSizeBy8,1)))<0.0001 );

        prvDoLpc4( iSizeBy8,  Tmp+16, pWF, iSizeBy2, SL8,  CL8 );

        assert( fabs(FLOAT_FROM_BP2(SL3by16)-FLOAT_FROM_BP2(TRIGTBL(iSizeBy8 + iSizeBy16,0)))<0.0001 
             && fabs(FLOAT_FROM_BP2(CL3by16)-FLOAT_FROM_BP2(TRIGTBL(iSizeBy8 + iSizeBy16,1)))<0.0001 );

        prvDoLpc4( iSizeBy8 + iSizeBy16, Tmp+24, pWF, iSizeBy2, SL3by16, CL3by16 );

#   else

        iMapLpcIdxOffset[0] = 0;  
        iMapLpcIdxOffset[1] = iSizeBy8;  
        iMapLpcIdxOffset[2] = iSizeBy8;  
        iMapLpcIdxOffset[3] = iSizeBy4;

        pTmp = Tmp+8;
        for( i = 1, jj = iSizeBy16; i<4; i++, pTmp += 8, jj = (i&1)*(iSizeBy16) ) 
        {
            k = iMapLpcIdxOffset[i] - jj;

            prvDoLpc4( k, pTmp, pWF, iSizeBy2, iShrink );
        }

#   endif

#   if defined(PLATFORM_LPC_SMALL_TRIG_TABLE)
        // 2 items per row, sample every fourth row.
        pC4 = &lpc_trig2048[(8<<iShrink)];
        pCInc4 = (8<<iShrink)-1;  // 1 of them gets done with ++
        // pC4 = lpc_Trigs[iShrink] + (2*4);
        // pCInc4 = 8-1;

        pC1 = &lpc_trig2048[(2<<iShrink)];
        pCInc1 = (2<<iShrink)-1;    // 1 of them gets done with ++;
        // pC1 = lpc_Trigs[iShrink] + 2;
        // pCInc1 = 1;

#   elif defined(PLATFORM_LPC_NO_TRIG_TABLE)

        assert( 64 <= iSize && iSize <= 2048 );

        pSinCosTable = rgSinCosTables[iSize>>7];
        S4  = pSinCosTable->sin_4PIbycSB;
        C4  = pSinCosTable->cos_4PIbycSB;
        S4p = 0;
        C4p = BP2_FROM_FLOAT(1.0f);
        STEP4 = MUL2(S4);

        S1  = BP2_FROM_BP1(pSinCosTable->sin_PIbycSB);
        C1  = BP2_FROM_BP1(pSinCosTable->cos_PIbycSB);
        S1p = 0;
        C1p = BP2_FROM_FLOAT(1.0f);
        STEP1 = BP2_FROM_BP1(pSinCosTable->two_sin_PIbycSB);

#   else   // so must be big lpc constants table

        pC4 = &lpc_cnst3[1*(4<<iShrink)];
        pCInc4 = (4<<iShrink)-3;  // 3 of them get done with ++

#   endif  // defined(PLATFORM_LPC_NO_TRIG_TABLE)

    for (j=1; j<iSizeBy16; j++ )
    {
#       if defined(PLATFORM_LPC_NO_TRIG_TABLE) || defined(PLATFORM_LPC_SMALL_TRIG_TABLE)
#           if !defined(PLATFORM_SPECIFIC_LPC_JLOOP_BOTTOM) || defined(PLATFORM_LPC_SMALL_TRIG_TABLE)
                BP2Type S2, C2;
#           endif
            BP2Type C8, S8;

#           if defined(PLATFORM_LPC_SMALL_TRIG_TABLE)
                S4 = *pC4++;                        // sin(x) = sin(pi*4*j/iSize)
                C4 = *pC4;                          // cos(x) = cos(pi*4*j/iSize)
                pC4 += pCInc4;
#           endif  // PLATFORM_LPC_SMALL_TRIG_TABLE

            assert( fabs(FLOAT_FROM_BP2(S4)-sin(PI*4*j/iSize)) < 0.0001 
                 && fabs(FLOAT_FROM_BP2(C4)-cos(PI*4*j/iSize)) < 0.0001 );

            CmS1 = -C4 + S4;                    // cnst3[i*(4<<iShrink)+3];
            CpS1 =  C4 + S4;                    // cnst3[i*(4<<iShinrk)+1];

            S8 = MUL2(MULT_BP2X(C4,S4));                        // sin(2x)
            C8 = BP2_FROM_FLOAT(1.0f) - MUL2(MULT_BP2X(S4,S4)); // cos(2x)
            CmS2 = -C8 + S8;                    // cnst3[i*(4<<iShrink)+2];
            CpS2 =  C8 + S8;                    // cnst3[i*(4<<iShink)];

#           if defined(PLATFORM_LPC_NO_TRIG_TABLE)
		        // rotate angle by b = 4*pi/iSize
		        // recursion: cos(a+b) = cos(a-b) + 2*sin(b)*sin(a)
		        // and:       sin(a+b) = sin(a-b) - 2*sin(b)*cos(a)
		        CT = C4p - MULT_BP2X(STEP4,S4);
		        ST = S4p + MULT_BP2X(STEP4,C4);
		        C4p = C4;  C4 = CT;
		        S4p = S4;  S4 = ST;
#           endif  // PLATFORM_LPC_NO_TRIG_TABLE

#       else    // PLATFORM_LPC_NO_TRIG_TABLE || PLATFORM_LPC_SMALL_TRIG_TABLE

            CpS2 = *pC4++;              // cnst3[i*(4<<iShink)];
            CpS1 = *pC4++;              // cnst3[i*(4<<iShinrk)+1];
            CmS2 = *pC4++;              // cnst3[i*(4<<iShrink)+2];
            CmS1 = *pC4;                // cnst3[i*(4<<iShrink)+3];
            pC4 += pCInc4;

#       endif
        assert( BP2_FROM_FLOAT(1) <= CpS2 && CpS2 <= BP2_FROM_FLOAT(1.5) );     

                                                        // F[j]
        Tmp[6]  = LP_SPEC_FROM_FLOAT(1) + (tCpS2x = MULT_BP2X(CpS2,original[7])) + (tCpS1x = MULT_BP2X(CpS1,original[3]));
                                                        // F[256-j]
        Tmp[14] = LP_SPEC_FROM_FLOAT(1) + (tCmS2x = MULT_BP2X(CmS2,original[7])) + tCpS1x;
                                                        // F[256+j]
        Tmp[22] = LP_SPEC_FROM_FLOAT(1) - tCpS2x - (tCmS1x = MULT_BP2X(CmS1,original[3]));    
        Tmp[30] = LP_SPEC_FROM_FLOAT(1) - tCmS2x + tCmS1x;  // F[512-j]
        Tmp[31] = LP_SPEC_FROM_FLOAT(1) + tCpS2x - tCpS1x;  // F[512+j]
        Tmp[23] = LP_SPEC_FROM_FLOAT(1) + tCmS2x - tCpS1x;  // F[768-j]
        Tmp[15] = LP_SPEC_FROM_FLOAT(1) - tCpS2x + tCmS1x;  // F[768+j]
        Tmp[7]  = LP_SPEC_FROM_FLOAT(1) - tCmS2x - tCmS1x;  // F[1024-j]
        
                                                        // F[1024+j]
        Tmp[0]  = original[1] + (tCpS2x = MULT_BP2X(CpS2,original[9])) + (tCpS1x = MULT_BP2X(CpS1,original[5]));
                                                        // F[1280-j]  
        Tmp[8]  = original[1] + (tCmS2x = MULT_BP2X(CmS2,original[9])) + tCpS1x;
                                                        // F[1280+j]  
        Tmp[16] = original[1] - tCpS2x - (tCmS1x = MULT_BP2X(CmS1,original[5]));
        Tmp[24] = original[1] - tCmS2x + tCmS1x;            // F[1536-j]
        Tmp[25] = original[1] + tCpS2x - tCpS1x;            // F[1536+j]
        Tmp[17] = original[1] + tCmS2x - tCpS1x;            // F[1792-j]
        Tmp[9]  = original[1] - tCpS2x + tCmS1x;            // F[1792+j]
        Tmp[1]  = original[1] - tCmS2x - tCmS1x;            // F[2048-j
        
                                                        // F[2048+j]  
        Tmp[2]  = original[0] + (tCpS2x = MULT_BP2X(CpS2,original[8])) + (tCpS1x = MULT_BP2X(CpS1,original[4]));
                                                        // F[2304-j]  
        Tmp[10] = original[0] + (tCmS2x = MULT_BP2X(CmS2,original[8])) + tCpS1x;
                                                        // F[2304+j]  
        Tmp[18] = original[0] - tCpS2x - (tCmS1x = MULT_BP2X(CmS1,original[4]));
        Tmp[26] = original[0] - tCmS2x + tCmS1x;            // F[2560-j]
        Tmp[27] = original[0] + tCpS2x - tCpS1x;            // F[2560+j]
        Tmp[19] = original[0] + tCmS2x - tCpS1x;            // F[2816-j]
        Tmp[11] = original[0] - tCpS2x + tCmS1x;            // F[2816+j]
        Tmp[3]  = original[0] - tCmS2x - tCmS1x;            // F[3072-j]
        
                                                        // F[3072+j] 
                                                        // F[3328-j]
        Tmp[4]  =  Tmp[12]  = original[2] + (tCpS1x = MULT_BP2X(CpS1,original[6]));
                                                        // F[3328+j] 
        Tmp[20] = original[2] - (tCmS1x = MULT_BP2X(CmS1,original[6]));
        Tmp[28] = original[2] + tCmS1x;                   // F[3584-j]
        Tmp[29] = original[2] - tCpS1x;                   // F[3584+j]
        Tmp[21] = original[2] - tCpS1x;                   // F[3840-j]
        Tmp[13] = original[2] + tCmS1x;                   // F[3840+j]
        Tmp[5]  = original[2] - tCmS1x;                   // F[4096-j]
        
        //** this block uses 52 adds and 14 mults??
       

        // example:  iSize = 0x100 = 256.
        //            j==1         |   j==2          |  j==3
        //       i:  0   1   2   3 |   0   1   2   3 |  0
        //    k      1  1f  21  3f |   2  1e  22  3e |  3 ...
        // 80+k     81  9f  a1  bf |  82  9e  a2  be | 83 ...
        // 80-k     7f  61  5f  41 |  7e  62  5e  42 | 7e ...
        //100-k     ff  e1  df  c1 |  fe  e2  de  c2 | fd ...


#if defined(PLATFORM_LPC_NO_TRIG_TABLE) || defined(PLATFORM_LPC_SMALL_TRIG_TABLE)

#   if defined(PLATFORM_SPECIFIC_LPC_JLOOP_BOTTOM) && defined(PLATFORM_LPC_NO_TRIG_TABLE)
        prvLpcJLoopBottom( j, Tmp, pWF, iSizeBy2, &S1, &C1, &S1p, &C1p, STEP1 );
#   else    //  defined(PLATFORM_SPECIFIC_LPC_JLOOP_BOTTOM)
#       if defined(PLATFORM_LPC_SMALL_TRIG_TABLE)
            S1 = *pC1++;                        // sin(x) = sin(pi*4*j/iSize)
            C1 = *pC1;                          // cos(x) = cos(pi*4*j/iSize)
            pC1 += pCInc1;
#       endif  // PLATFORM_LPC_SMALL_TRIG_TABLE

        assert( fabs(FLOAT_FROM_BP2(S1)-sin(PI*j/iSize)) < 0.0001 
             && fabs(FLOAT_FROM_BP2(C1)-cos(PI*j/iSize)) < 0.0001 );

        prvDoLpc4( j, Tmp, pWF, iSizeBy2, S1, C1 );

        S2 = (SLC1 = MULT_BP2X(SL8,C1)) - (CLS1 = MULT_BP2X(CL8,S1));
        C2 = (CLC1 = MULT_BP2X(CL8,C1)) + (SLS1 = MULT_BP2X(SL8,S1));
        assert( fabs(FLOAT_FROM_BP2(S2)-FLOAT_FROM_BP2(TRIGTBL(iSizeBy8-j,0)))<0.0001 
             && fabs(FLOAT_FROM_BP2(C2)-FLOAT_FROM_BP2(TRIGTBL(iSizeBy8-j,1)))<0.0001 );
        prvDoLpc4( iSizeBy8 - j, Tmp+8,  pWF, iSizeBy2, S2, C2 );

        S2 = SLC1 + CLS1;
        C2 = CLC1 - SLS1;
        assert( fabs(FLOAT_FROM_BP2(S2)-FLOAT_FROM_BP2(TRIGTBL(iSizeBy8+j,0)))<0.0001 
             && fabs(FLOAT_FROM_BP2(C2)-FLOAT_FROM_BP2(TRIGTBL(iSizeBy8+j,1)))<0.0001 );
        prvDoLpc4( iSizeBy8 + j, Tmp+16, pWF, iSizeBy2, S2, C2 );

        S2 = MULT_BP2X(SL4,C1) - MULT_BP2X(CL4,S1);
        C2 = MULT_BP2X(CL4,C1) + MULT_BP2X(SL4,S1);
        assert( fabs(FLOAT_FROM_BP2(S2)-FLOAT_FROM_BP2(TRIGTBL(iSizeBy4-j,0)))<0.0001 
             && fabs(FLOAT_FROM_BP2(C2)-FLOAT_FROM_BP2(TRIGTBL(iSizeBy4-j,1)))<0.0001 );
        prvDoLpc4( iSizeBy4 - j, Tmp+24, pWF, iSizeBy2, S2, C2 );

#       if defined(PLATFORM_LPC_NO_TRIG_TABLE)
		    // rotate angle by b = pi/iSize
		    // recursion: cos(a+b) = cos(a-b) + 2*sin(b)*sin(a)
		    // and:       sin(a+b) = sin(a-b) - 2*sin(b)*cos(a)
		    CT = C1p - MULT_BP2X(STEP1,S1);
		    ST = S1p + MULT_BP2X(STEP1,C1);
		    C1p = C1;  C1 = CT;
		    S1p = S1;  S1 = ST;
#       endif  // defined(PLATFORM_LPC_NO_TRIG_TABLE)
#   endif // defined(PLATFORM_SPECIFIC_LPC_JLOOP_BOTTOM)
#else

        pTmp = Tmp;
        for( i = 0, jj = j; i<4; i++, pTmp += 8, jj = -jj ) 
        {
            k = iMapLpcIdxOffset[i] + jj;

            prvDoLpc4( k, pTmp, pWF, iSizeBy2, iShrink );    
        }
    
#endif

    }
    //** this loop uses (512>>iShrink) * (36 adds and 24 mults)
    
    //** total to here: 
    //**   (46 adds and 14 mults) + (N/16) * (52 adds and 14 mults) + (N/4) * (36 adds and 24 mults)
    //** TA = 46 + 3.25N + 9N      = 46 + 12.250N
    //** TM = 14 + (14/16)N + 6*N  = 14 +  6.875N
    //** An FFT takes order N*log(N)
    //** so we may need to substitute an optimized FFT for this on some platforms.
    
    // The inverse quad root has already been computed. Copy to destination, find max etc remain here.
    
    rgwtLpcSpec  = INTEGER_OR_INT_FLOAT( (I32 *)ppcinfo->m_rguiWeightFactor, ppcinfo->m_rgfltWeightFactor ); 
    wtLpcSpecMax = WEIGHT_FROM_FLOAT(0.0F);
    iLoopLimit   = pau->m_cSubband;
    
    for (iFreq = 0, iF = 0; iFreq < iLoopLimit; iFreq++, iF += iStride) 
    {
        LPC_COMPARE_DEBUG( pau, iFreq, iFreq, iF, pWF, rgLpcCoef );

        wtTemp = pWF[iFreq];

        if ( wtTemp > wtLpcSpecMax )
            wtLpcSpecMax = wtTemp;
        
        INTEGER_ONLY( assert( wtTemp>= 0 ); );
        MONITOR_RANGE(gMR_rgfltWeightFactor,wtTemp);                                
        MONITOR_RANGE(gMR_fltLPC_F3,pWF[iFreq]);
    }
    
	WF_PRINT(pWF);

    if (wtLpcSpecMax == WEIGHT_FROM_FLOAT(0.0F))
    {
        FUNCTION_PROFILE_STOP(&fp);
        return TraceResult(WMA_E_FAIL);
    }
    
#if defined(INTEGER_ENCODER)
    ppcinfo->m_iMaxWeight = wtLpcSpecMax;
#endif
    ppcinfo->m_wtMaxWeight = wtLpcSpecMax;
    
    FUNCTION_PROFILE_STOP(&fp);
    return WMA_OK;
}

#else  // defined(PLATFORM_LPC_FOLDED_PRUNED) && !defined(V4V5_COMPARE_MODE)
# include "lpc_variants.c"
#endif // defined(PLATFORM_LPC_FOLDED_PRUNED) && !defined(V4V5_COMPARE_MODE)

#endif // (V4V5_COMPARE_MODE && BUILD_INT_FLOAT) and then the opposite

#ifdef REPLICATE_V4_LPC
#   pragma COMPILER_MESSAGE(__FILE__ "(1139) : Warning - Built with REPLICATE_V4_LPC!")
#endif


#if defined(_DEBUG) && defined(LPC_COMPARE)

static void prvSetupLpcSpecTrig(CAudioObject* pau) 
{
    // precompute trig functions used in the slow spectral method used for comparision
    Int iFreq, i; 
    
    for (i = 0; i < LPCORDER; i++)  {
        if ( pau->m_rgfltLpsSpecCos [i] == NULL )
            pau->m_rgfltLpsSpecCos [i] = (Float*) malloc (sizeof (Float) * MAX_LP_SPEC_SIZE);
        if ( pau->m_rgfltLpsSpecSin [i] == NULL );
            pau->m_rgfltLpsSpecSin [i] = (Float*) malloc (sizeof (Float) * MAX_LP_SPEC_SIZE);
        assert( pau->m_rgfltLpsSpecCos [i] != NULL && pau->m_rgfltLpsSpecSin [i] != NULL );
    }
    if ( pau->m_rgfltLpsSpecCos [LPCORDER-1] != NULL && pau->m_rgfltLpsSpecSin [LPCORDER-1] != NULL )
    {
        for (iFreq = 0; iFreq < MAX_LP_SPEC_SIZE; iFreq++)   
        {
#           if defined(REPLICATE_V4_LPC) || defined(V4V5_COMPARE_MODE)
                Float  Temp = (Float)((iFreq) * PI / MAX_LP_SPEC_SIZE);
#           else
                Double Temp = ((iFreq) * PI / MAX_LP_SPEC_SIZE);
#           endif
            for (i = 0; i < LPCORDER; i++)  
            {
                pau->m_rgfltLpsSpecCos [i] [iFreq] = (Float) cos ((i + 1) * Temp);
                pau->m_rgfltLpsSpecSin [i] [iFreq] = (Float) sin ((i + 1) * Temp);
            }
        }
    }
}

#endif  // _DEBUG


#endif //defined(ENABLE_ALL_ENCOPT) && defined(ENABLE_LPC)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\wmalib\wmadec_s\main.c ===
/* test.c */

#pragma code_seg("WMADEC")
#pragma data_seg("WMADEC_RW")
#pragma const_seg("WMADEC_RD")

#pragma comment(linker, "/merge:WMADEC_RW=WMADEC")
#pragma comment(linker, "/merge:WMADEC_RD=WMADEC")
#pragma comment(linker, "/section:WMADEC,ERW")

#pragma warning ( disable : 4103 )
#include <malloc.h> // for heapcheck
#include <stdarg.h>
#include <stdio.h>
#include <string.h>
#include <time.h>
#include <tchar.h>
#include "wmaudio.h"
#include "assert.h"
#include "AutoProfile.h"
#include "..\..\..\dsound\dsndver.h"

// Define MEASURE_CLOCK for top level timing
//#define MEASURE_CLOCK

// AUTOPC_STYLE has a very large buffer and calls our routines to repeatedly fill it up
//#define AUTOPC_STYLE

// Define DISCARD_OUTPUT for profiling.
#if defined(PROFILE) || defined(MEASURE_CLOCK)
// this must be commented out if you really want output
//#define DISCARD_OUTPUT
#endif

// comment out DUMP_WAV define below to output a raw .pcm file rather than a .wav file.
#define DUMP_WAV
#ifdef DUMP_WAV
#include "wavfileio.h"
#endif  /* DUMP_WAV */

// Obnoxious Tests
// un-comment out the define below to enable some modestly obnoxious tests for the interface (output should still be OK)
//#define OBNOXIOUS
// un-comment out the next define to enable interface tests which will not generate the correct output
//#define REAL_OBNOXIOUS

//#define _MARKERDEMO_
//#define TEST_SPEED

//#define TEST_MARKER

// WMA2CMP - define in project settings to produce a .cmp output file from the .wma suitable for use with decapp
#ifdef WMA2CMP
#   ifndef WMAAPI_NO_DRM
#       define WMAAPI_NO_DRM
#   endif
#   include "wmaudio_type.h"
#   include "msaudio.h"
    FILE    *pfWma2Cmp = NULL;       // file (and flag) to output .cmp file
    // typically you would rename the execuable of this WMA2CMP build as Wma2Cmp.exe when moving it into your path
#endif


// HEAP_DEBUG_CHECK is the same as the defines in msaudio.h 
// Although it is normally bad form to copy something out a .h instead of 
// including the .h, in this test program, we want to make sure we do not 
// inadvertently use anything from msaudio.h 
#if defined(HEAP_DEBUG_TEST) && defined(_DEBUG)
void HeapDebugCheck();
#define HEAP_DEBUG_CHECK HeapDebugCheck()
#else
#define HEAP_DEBUG_CHECK
#endif

//#define PRINT_FROM_SAMPLE 67966
//#define PRINT_TO_SAMPLE   68228
//#define PRINT_FROM_SAMPLE 66000
//#define PRINT_TO_SAMPLE   68228
#if defined(PRINT_FROM_SAMPLE) && defined(PRINT_TO_SAMPLE)
    // One of the DCT print defines must be defined in fft.c to get this
    extern int bPrintDctAtFrame;	// used to print coefs before and after DCT
#endif


/* global */

tWMAFileHdrState g_hdrstate;
tHWMAFileState g_state;
tWMAFileHeader g_hdr;
tWMAFileLicParams g_lic;

#ifndef TEST_SPEED
FILE *g_fp = NULL;
FILE *g_fpLic = NULL;
#endif /* TEST_SPEED */

#ifdef TEST_SPEED
unsigned char *g_pBuffer = NULL;
#else  /* TEST_SPEED */
const int MAX_BUFSIZE = WMA_MAX_DATA_REQUESTED;
unsigned char g_pBuffer[WMA_MAX_DATA_REQUESTED];
#endif /* TEST_SPEED */
tWMA_U32 g_cbBuffer = 0;

#ifdef TEST_SPEED
#else  /* TEST_SPEED */
unsigned char g_pBufLic[WMA_MAX_DATA_REQUESTED];
#endif /* TEST_SPEED */
tWMA_U32 g_cbBufLic = 0;

unsigned long g_ulStartFirstSec, g_ulEndSec;
unsigned long g_ulFullSec = 0;
unsigned long g_ulOutputSamples = 0;
unsigned int  g_SampleRate;

/* Portable Media ID
 *
 * This is different for each portable medium (PM).  Should be
 * provided by the application by reading an identification from
 * the PD
 */


unsigned char g_pmid[20] =
{
    // Jonas
//    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x4D, 0x20,
//    0x33, 0x54, 0x31, 0x30, 0x31, 0x33, 0x37, 0x32, 0x37, 0x33
// Robert
  0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x69, 0x20,
  0x32, 0x30, 0x35, 0x30, 0x30, 0x32, 0x30, 0x31, 0x32, 0x31,
//    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
//    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x01, 0x02, 0x03, 0x04,
};

/*
//train 
unsigned char g_pmid[20] =
{
    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x4d, 0x20,
    0x33, 0x54, 0x31, 0x30, 0x30, 0x35, 0x30, 0x30, 0x39, 0x35
};
*/

/*
unsigned char g_pmid[20] =
{ 
    0xef, 0xef, 0xef, 0xef, 0xef, 0xef, 0xef, 0xef, 0x55, 0xef, 
    0xee, 0xee, 0xef, 0xef, 0xef, 0xef, 0xef, 0xdf, 0xdf, 0xd9
};
*/

// This should work either with or without TEST_INTERLEAVED_DATA
//   TEST_INTERLEAVED_DATA should be more efficient for all platforms except perhaps ARM.
//   but some applications want separate right and left channel data returned.
// One should check-in with TEST_INTERLEAVED_DATA defined 
//   but run appropriate tests both with and without TEST_INTERLEAVED_DATA


#if defined(AUTOPC_STYLE)
// This style uses a large buffer and repeatedly calls our interface to fill it up
#define MAX_SAMPLES 132000
#define TEST_INTERLEAVED_DATA

#else
// This style is like our sample programs
// should work with any buffer size.  No point in it being larger than 2048.
//#define MAX_SAMPLES 256
#define MAX_SAMPLES 2048
#define TEST_INTERLEAVED_DATA

#endif

#ifdef TEST_INTERLEAVED_DATA
    short g_pLeft [MAX_SAMPLES * 2];
    short *g_pRight = NULL;
#else
    short g_pLeft [MAX_SAMPLES];
    short g_pRight [MAX_SAMPLES];
#   ifdef DUMP_WAV
        // this combo not supported below
#       undef DUMP_WAV
#   endif
#endif

#define STRING_SIZE 128
unsigned char g_szTitle[STRING_SIZE];
unsigned char g_szAuthor[STRING_SIZE];
unsigned char g_szCopyright[STRING_SIZE];
unsigned char g_szDescription[STRING_SIZE];
unsigned char g_szRating[STRING_SIZE];

#if 0
extern "C" void
SerialSendString(char *pcString)
{
    fprintf(stderr, pcString);
}

extern "C" void
SerialPrintf(const char *format, ...)
{
    va_list a;
    char s[256];
    va_start( a, format );
    vsprintf(s, format, a);
    va_end(a);
    SerialSendString(s);
}
#endif /* 0 */

/**************************************************/

void
WStrToStrN(unsigned char *pStr,
           unsigned char *pWStr,
           int n)
{
    if(pStr == NULL || pWStr == NULL)
    {
        return;
    }

    while(n-- > 0)
    {
        *pStr++ = *pWStr;
        pWStr += 2;
    }
    *pStr = 0;
}


//
// georgioc - The callback below is not used. Instead  we redefine it in codecs\wma\wmaxmo.cpp
// since the WmaXMO is the proper interface for reading wma files
//


#if 0

/* WMAFileCBGetData */

tWMA_U32 WMAFileCBGetData (
    tHWMAFileState *state,
    tWMA_U32 offset,
    tWMA_U32 num_bytes,
    unsigned char **ppData)
{
    tWMA_U32 ret;

#ifdef TEST_SPEED

    if(offset >= g_cbBuffer)
    {
        *ppData = g_pBuffer + g_cbBuffer;
        ret = 0;
    }
    else
    {
        *ppData = g_pBuffer + offset;

        if(offset + num_bytes > g_cbBuffer)
        {
            ret = g_cbBuffer - offset;
        }
        else
        {
            ret = num_bytes;
        }
    }

#else  /* TEST_SPEED */

    tWMA_U32 nWanted = num_bytes <= (tWMA_U32) MAX_BUFSIZE ? num_bytes : (tWMA_U32) MAX_BUFSIZE;
    if(num_bytes != nWanted)
    {
        fprintf(stderr, "** WMAFileCBGetData: Requested too much (%lu).\n",
                num_bytes);
    }

    fseek (g_fp, offset, SEEK_SET);
    ret = fread (g_pBuffer, 1, (size_t)nWanted, g_fp);

    g_cbBuffer = ret;

    *ppData = g_pBuffer;

#endif /* TEST_SPEED */

//    fprintf(stderr, "++ WMAFileCBGetData: %lu bytes from %lu.\n", ret, offset);

    return ret;
}

#endif // 0 disable WMAFileCBGetData


// need to provide a platform independent fprintf to stderr for wmaudio.c and wmaudio_parse.c
void WMADebugMessage(const char* pszFmt, ... )
{
    va_list vargs;
    va_start(vargs, pszFmt);
    vfprintf(stderr, pszFmt, vargs );
    va_end(vargs);
}

#if defined(AUTOPC_STYLE)

// AutoPc reads into large 132000 byte buffers using the following code (much simplified)

#define LONG long
#define BYTE unsigned char
//
// llPos   - Starting position to read.
// lLength - Number of bytes to read.
// pBuffer - Ptr to buffer to populate with data.
WMARESULT
AutoPCReadNext(
    LONG lLength,
    short* pBuffer,
    LONG* lWritten)
{

    tWMAFileStatus rc;

    // calculate sample length
    tWMA_U32 sampleLength = (tWMA_U32)lLength / (g_hdr.num_channels << 1);

    short* pLeft = (short*)pBuffer;

    short* pTempLeft = pLeft;

    tWMA_U32 num_samples = 0;

    *lWritten = 0;

    //Keep looping around until no samples are left.
    while(sampleLength)
    {
        do
        {
            num_samples = WMAFileGetPCM(g_state, pTempLeft, NULL, sampleLength);

            *lWritten += num_samples*(g_hdr.num_channels << 1);
            sampleLength -= num_samples;
            pTempLeft += (num_samples * g_hdr.num_channels);
        } while(num_samples);

        if ( sampleLength == 0 )
            break;

        rc = WMAFileDecodeData(g_state);
        if( rc == cWMA_NoMoreFrames )
        {
            return WMA_S_NO_MORE_SRCDATA;
        } else if( rc != cWMA_NoErr )
        {
            return rc;
        }
    }

    return cWMA_NoErr;
}

#endif  // defined(AUTOPC_STYLE)


//
// georgioc - We dont need main since we use this strictly as a LIB
//

#if 0

/* main */

int __cdecl main (int argc, char *argv[])
{
 
    tWMA_U32 msSeekTo;

#ifdef TEST_MARKER
    int k; 
    MarkerEntry pEntry[5];
#endif

    tWMAFileStatus rc;
    tWMA_U32 num_samples;
    int cCountDecodeData = 0;
    int cCountGetPCM = 0;
//    const char *strOut = "d:\\test\\output.pcm";
//    const char *strLic = "drmv1pm.lic";
    const char *strLic = "c:\\ti_test\\files\\drmv1pm.new";
    tWMAFileContDesc desc;
    tWMAExtendedContentDesc *pECDesc;
    unsigned char szTemp [STRING_SIZE];
    int iRV = 1;    // assume error exit return value
#ifndef DISCARD_OUTPUT
#ifdef DUMP_WAV
    WavFileIO *pwfioOut = wfioNew ();
    WAVEFORMATEX wfx;
#else   /* DUMP_WAV */
    FILE *pfOutPCM = NULL;
#endif /* DUMP_WAV */
#endif // !DISCARD_OUTPUT
#ifdef REAL_OBNOXIOUS
    unsigned long ulObnoxiousLoopCount = 0;
#endif
#ifdef MEASURE_CLOCK
    PERFTIMERINFO  *pPerfTimerInfo;
#endif  // MEASURE_CLOCK
    FUNCTION_PROFILE(fpDecode);

    if (argc < 3) {
        fprintf(stderr, "** Too few arguments.\n");
        goto lexit;
    }

    g_fp = fopen (argv [1], "rb");
    if (g_fp == NULL) {
        fprintf(stderr, "** Cannot open %s.\n", argv [1]);
        goto lexit;
    }

    /* init struct */
    memset ((void *)&g_hdrstate, 0, sizeof(g_hdrstate));
    memset ((void *)&g_state, 0, sizeof(g_state));
    memset ((void *)&g_hdr, 0, sizeof(g_hdr));

#ifdef OBNOXIOUS
    // try to close interface which is not yet open
    WMAFileDecodeClose (&g_state);
    // try to get PCM data now
    num_samples = WMAFileGetPCM (g_state, g_pLeft, g_pRight, MAX_SAMPLES);
    if ( num_samples > 0 )
    {
        fprintf( stderr, "** Obnoxious WMAFileGetPCM returns %d samples.\n", num_samples);
        assert( num_samples <= 0 );
    }
    // try to decode data
    rc = WMAFileDecodeData (g_state);
    if ( rc == cWMA_NoErr )
    {
        fprintf( stderr, "** Obnoxious WMAFileDecodeData returns NoErr.\n" );
        assert( rc != cWMA_NoErr );
    }
    // try some other stuff as well
    rc = WMAFileDecodeInfo (g_state, &g_hdr);
    if ( rc == cWMA_NoErr )
    {
        fprintf( stderr, "** Obnoxious WMAFileDecodeInfo returns NoErr.\n" );
        assert( rc != cWMA_NoErr );
    }
    rc = WMAFileContentDesc (g_state, &desc);
    if ( rc == cWMA_NoErr )
    {
        fprintf( stderr, "** Obnoxious WMAFileContentDesc returns NoErr.\n" );
        assert( rc != cWMA_NoErr );
    }
#endif

    /* test the checking API */

    rc = WMAFileIsWMA (&g_hdrstate);
    if(rc != cWMA_NoErr)
    {
        fprintf(stderr, "** The file is not a WMA file.\n");
        goto lexit;
    }

//test Marker 
#ifdef TEST_MARKER
	for ( k = 0 ; k < 5 && k < WMAGetNumberOfMarkers(&g_hdrstate); k++)
	{
		 WMAGetMarker(&g_hdrstate, k, &pEntry[k]); 
	}
#endif 

    /* init the decoder */

    rc = WMAFileDecodeCreate (&g_state);
    if(rc != cWMA_NoErr)
    {
        fprintf(stderr, "** Cannot create the WMA decoder.\n");
        goto lexit;
    }
    rc = WMAFileDecodeInit (g_state);
    if(rc != cWMA_NoErr)
    {
        fprintf(stderr, "** Cannot initialize the WMA decoder.\n");
        goto lexit;
    }

#ifdef OBNOXIOUS
    // Init twice for good measure
    rc = WMAFileDecodeCreate (&g_state);
    if(rc != cWMA_NoErr)
    {
        fprintf(stderr, "** Cannot create the WMA decoder.\n");
        goto lexit;
    }
    rc = WMAFileDecodeInit (g_state);
    if(rc != cWMA_NoErr)
    {
        fprintf(stderr, "** Cannot initialize the WMA decoder.\n");
        goto lexit;
    }
#endif
    
    /* get header information */

    rc = WMAFileDecodeInfo (g_state, &g_hdr);
    if(rc != cWMA_NoErr)
    {
        fprintf(stderr, "** Failed to retrieve information.\n");
        goto lexit;
    }

    /* set up the content description struct */

    memset((void *)&desc, 0, sizeof(desc));
    desc.title_len = STRING_SIZE;
    desc.pTitle    = (unsigned char *)g_szTitle;
    desc.author_len = STRING_SIZE;
    desc.pAuthor    = (unsigned char *)g_szAuthor;
    desc.copyright_len = STRING_SIZE;
    desc.pCopyright    = (unsigned char *)g_szCopyright;
    desc.description_len = STRING_SIZE;
    desc.pDescription    = (unsigned char *)g_szDescription;
    desc.rating_len = STRING_SIZE;
    desc.pRating    = (unsigned char *)g_szRating;

    /* get content description */

    rc = WMAFileContentDesc (g_state, &desc);
    if(rc != cWMA_NoErr)
    {
        fprintf(stderr, "** Failed to retrieve content description.\n");
        goto lexit;
    }

    /* display information */

    WStrToStrN(szTemp, desc.pTitle, desc.title_len);
    printf("++            Song title: %s\n", szTemp);
    WStrToStrN(szTemp, desc.pAuthor, desc.author_len);
    printf("++                Author: %s\n", szTemp);
    WStrToStrN(szTemp, desc.pCopyright, desc.copyright_len);
    printf("++             Copyright: %s\n", szTemp);
    WStrToStrN(szTemp, desc.pDescription, desc.description_len);
    printf("++           Description: %s\n", szTemp);
    WStrToStrN(szTemp, desc.pRating, desc.rating_len);
    printf("++                Rating: %s\n", szTemp);

    rc = WMAFileExtendedContentDesc (g_state, &pECDesc);

    if(rc != cWMA_NoErr)
    {
        fprintf(stderr, "** Failed to retrieve extended content description.\n")
;
        goto lexit;
    }

    printf("++ WMA bitstream version: %d\n", g_hdr.version);
    printf("++         sampling rate: ");
    switch(g_hdr.sample_rate)
    {
    case cWMA_SR_08kHz:
        printf("8000 Hz\n");
        g_SampleRate = 8000;
        break;
    case cWMA_SR_11_025kHz:
        printf("11025 Hz\n");
        g_SampleRate = 11025;
        break;
    case cWMA_SR_16kHz:
        printf("16000 Hz\n");
        g_SampleRate = 16000;
        break;
    case cWMA_SR_22_05kHz:
        printf("22050 Hz\n");
        g_SampleRate = 22050;
        break;
    case cWMA_SR_32kHz:
        printf("32000 Hz\n");
        g_SampleRate = 32000;
        break;
    case cWMA_SR_44_1kHz:
        printf("44100 Hz\n");
        g_SampleRate = 44100;
        break;
    case cWMA_SR_48kHz:
        printf("48000 Hz\n");
        g_SampleRate = 48000;
        break;
    default:
        printf("Unknown??? [%d]\n", g_hdr.sample_rate);
        g_SampleRate = g_hdr.sample_rate;
        break;
    }
    printf("++         # of channels: %d\n", g_hdr.num_channels);
    printf("++              bit-rate: %ld bps\n", g_hdr.bitrate);
    printf("++              duration: %ld ms\n", g_hdr.duration);
    printf("++           DRM content: %s\n", g_hdr.has_DRM ? "Yes" : "No");

    /* if DRM, init with the license file */

    if(g_hdr.has_DRM)
    {
        g_lic.pPMID = (unsigned char *)&g_pmid;
        g_lic.cbPMID = sizeof(g_pmid);

        rc = WMAFileLicenseInit (g_state, &g_lic, CHECK_ALL_LICENSE);
        if(rc != cWMA_NoErr)
        {
            fprintf(stderr, "** WMALicenseInit failed (%u).\n", rc);
            goto lexit;
        }
    }

#ifndef DISCARD_OUTPUT
#ifdef DUMP_WAV
    wfx.wFormatTag      = (USHORT)WAVE_FORMAT_PCM;
    wfx.nSamplesPerSec  = g_SampleRate;
    wfx.nChannels       = (USHORT)g_hdr.num_channels;
    wfx.wBitsPerSample  = 16;
    wfx.nBlockAlign     = ((wfx.wBitsPerSample + 7) / 8) * wfx.nChannels;
    wfx.nAvgBytesPerSec = wfx.nBlockAlign * wfx.nSamplesPerSec;
    wfx.cbSize          = 0;

    if(wfioOpen (pwfioOut, argv [2], &wfx, sizeof(wfx), wfioModeWrite) != 0) {
        fprintf(stderr, "Can't create file\n");
        exit(1);
    }
#else   /* DUMP_WAV */
    pfOutPCM = fopen (argv [2], "wb");
    if (pfOutPCM == NULL) {
        fprintf(stderr, "** Cannot open output file %s.\n", argv [2]);
        goto lexit;
    }
#endif // DUMP_WAV
#endif // !DISCARD_OUTPUT

#if defined(WMA2CMP) && defined(DUMP_WAV) && !defined(DISCARD_OUTPUT)
    if (argc > 3) 
    {
	    //setup the output bitstream file in private format
        WAVEFORMATEX  wfxCMP; 
        tWMAFileHdrStateInternal *pInt = (tWMAFileHdrStateInternal *)(&g_hdrstate);

	    if ((pfWma2Cmp = fopen (argv [3], "wb")) == NULL) {
		    fprintf (stderr, "Can't create file %s\n", argv [3]);
		    exit (1);
	    }

        wfxCMP = wfx;
        wfxCMP.nBlockAlign = (U16)(pInt->nBlockAlign);

        if (pInt->nVersion==1)         {
	        wfxCMP.cbSize = sizeof(MSAUDIO1WAVEFORMAT) - sizeof(WAVEFORMATEX);
            fwrite (&wfxCMP, sizeof (U8), sizeof (WAVEFORMATEX), pfWma2Cmp);
            {
                U16 dwStupidNumber = (U16)MaxSamplesPerPacket(1, pInt->nSamplesPerSec, pInt->nChannels, pInt->nAvgBytesPerSec*8);
                fwrite (&dwStupidNumber , sizeof (U16), 1, pfWma2Cmp);    
            }
        } else {
            // not V1 so must be V2 
	        wfxCMP.cbSize = sizeof(WMAUDIO2WAVEFORMAT) - sizeof(WAVEFORMATEX);
            fwrite (&wfxCMP, sizeof (U8), sizeof (WAVEFORMATEX), pfWma2Cmp);
            //should be this; but to be compatible with V4RTM...
            //fwrite (&dwSamplesPerFrame, sizeof (U32), 1, pfWma2Cmp);
            {
                //this is sent but only used by the decoder for some unnecessary
                //computation. We need to fudge this number so that the V4 decoder 
                //can work without any change. The following is the smallest
                //number that can safely fool the old decoder.
                U32 dwStupidNumber = MaxSamplesPerPacket(2, pInt->nSamplesPerSec, pInt->nChannels, pInt->nAvgBytesPerSec*8);
                fwrite (&dwStupidNumber , sizeof (U32), 1, pfWma2Cmp);    
            }
        }

        {
            I16 nEncodeOpt = pInt->nEncodeOpt;
            fwrite (&nEncodeOpt, sizeof (U16), 1, pfWma2Cmp);
        }
        {
            U32 nAvgBytesPerSec = pInt->nAvgBytesPerSec;
            fwrite (&nAvgBytesPerSec, sizeof (U32), 1, pfWma2Cmp);
        }
    }
#endif // WMA2CMP

#if 0
    /* testing the seek */

    {
        tWMA_U32 msSeekTo = 3000;
        tWMA_U32 msReturned = WMAFileSeek(g_state, msSeekTo);
        fprintf(stderr, "++ Seek to %d and actually gotten to %d\n",
                msSeekTo, msReturned);
    }
#endif /* 0 */

    HEAP_DEBUG_CHECK;

    //iMarkerNum = WMAGetMarkers(&g_hdrstate, &pEntry);

    /* decoding loop */
#ifdef MEASURE_CLOCK
    pPerfTimerInfo = PerfTimerNew( g_SampleRate * g_hdr.num_channels );
    if (NULL == pPerfTimerInfo)
    {
        fprintf(stderr, "Could not allocate perf timer structure\n");
        exit(1);
    }
#endif
#ifdef PROFILE
    Profiler_init(_T("profile.txt"));
#endif
#ifdef MEASURE_CLOCK
    PerfTimerStart(pPerfTimerInfo);
#endif  // MEASURE_CLOCK
#ifdef PROFILE
    FUNCTION_PROFILE_START(&fpDecode,MSAC_DECODE_PROFILE);
#endif  // PROFILE
    g_ulStartFirstSec = time(NULL); 


    msSeekTo = 0;

#if defined(AUTOPC_STYLE)
    do
    {
        rc = AutoPCReadNext( MAX_SAMPLES, g_pLeft, &num_samples );
        if ( rc == WMA_S_NO_MORE_SRCDATA )
        {
            iRV = 0;
            break;
        }        
        if ( rc != cWMA_NoErr )
        {   // an error occured 
            iRV = 2;        // error decoding data
            break;
        }
        
#ifndef DISCARD_OUTPUT

#       ifdef DUMP_WAV
            wfioWrite (pwfioOut, (U8*) g_pLeft, num_samples );
#       else   /* DUMP_WAV */
            fwrite (g_pLeft, sizeof (short), num_samples / sizeof(short), pfOutPCM);
#       endif // DUMP_WAV

#endif // !DISCARD_OUTPUT
    } while (1);

#else  // so not AUTOPC_STYLE

    do
    {
        int cGetLoopCount = 0;
#       ifdef OBNOXIOUS
            // try to get PCM data now
            num_samples = WMAFileGetPCM (g_state, g_pLeft, g_pRight, MAX_SAMPLES);
            if ( num_samples > 0 )
            {
                fprintf( stderr, "** Obnoxious WMAFileGetPCM returns %d samples.\n", num_samples);
                assert( num_samples <= 0 );
            }
#       endif

        cCountDecodeData++;
        if ( cCountDecodeData == 74 )
            cGetLoopCount = 0;  // really a place for a breakpint
        rc = WMAFileDecodeData (g_state);

#ifdef _MARKERDEMO_
        if (msSeekTo==0) 
            msSeekTo ++;
        if (msSeekTo == 1) 
        {
            tWMA_U32 msReturned;
            msSeekTo = 2;
            msSeekTo = pEntry[3].m_dwSendTime;
//            msSeekTo = pEntry[1].m_qtime.dwLo/10000;
            msReturned = WMAFileSeek(g_state, msSeekTo);
        }
#endif //_MARKERDEMO_

        if(rc != cWMA_NoErr)
        {
            g_ulEndSec = time(NULL);
            if ( rc == cWMA_NoMoreFrames || rc == cWMA_Failed )
                iRV = 0;        // normal exit
            else
                iRV = 2;        // error decoding data
            break;
        }

        do
        {
            short *pL = g_pLeft;
            short *pR = g_pRight;

#ifdef REAL_OBNOXIOUS
            if ( (++ulObnoxiousLoopCount % 101) == 0 || (ulObnoxiousLoopCount%1009)==0 )
            {
                // skip getting these PCM samples and see if interface recovers
                break;
            } 
#endif
            HEAP_DEBUG_CHECK;
            cCountGetPCM++;
            num_samples = WMAFileGetPCM (g_state, g_pLeft, g_pRight, MAX_SAMPLES);
            if (num_samples == 0)
            {
                /* no more, so on with the decoding... */
                break;
            }
            if ( cGetLoopCount > 0 )
            {
                cGetLoopCount++;  // actually a place for a breakpoint
            }
            cGetLoopCount++;

#ifndef DISCARD_OUTPUT

#   ifdef MEASURE_CLOCK
            PerfTimerStop(pPerfTimerInfo, num_samples * g_hdr.num_channels );
#   endif  // MEASURE_CLOCK
            FUNCTION_PROFILE_STOP(&fpDecode);

#   ifdef TEST_INTERLEAVED_DATA
#       ifdef DUMP_WAV
            wfioWrite (pwfioOut, (U8*) g_pLeft, num_samples * g_hdr.num_channels * sizeof (short));
#       else   /* DUMP_WAV */
            fwrite (g_pLeft, sizeof (short), num_samples * g_hdr.num_channels, pfOutPCM);
#       endif // DUMP_WAV
#   else    // TEST_INTERLEAVED_DATA
            {
                unsigned int i;
                for( i = 0; i < num_samples; i++ ) {
#                   ifdef DUMP_WAV
                        wfioWrite (pwfioOut, (U8*)(g_pLeft+i), sizeof (short));
                        if ( g_hdr.num_channels == 2 )
                            wfioWrite (pwfioOut, (U8*)(g_pRight+i), sizeof (short));
#                   else   /* DUMP_WAV */
                        fwrite (g_pLeft+i, sizeof (short), 1, pfOutPCM);
                        if ( g_hdr.num_channels == 2 )
                            fwrite (g_pRight+i, sizeof (short), 1, pfOutPCM);
#                   endif // DUMP_WAV
                }
            }
#   endif   // TEST_INTERLEAVED_DATA

            FUNCTION_PROFILE_START(&fpDecode,MSAC_DECODE_PROFILE);
#   ifdef MEASURE_CLOCK
            PerfTimerStart(pPerfTimerInfo);
#   endif  // MEASURE_CLOCK

#endif // !DISCARD_OUTPUT

// #define BREAK_AT_SAMPLE 146431 /* tough_16m_16.wma overflow of noise_subst_level in next frame */
//#define BREAK_AT_SAMPLE 50680  /* dire_200k_wmaV1_16k16kHzM.wma unstable frame after this */
#define BREAK_AT_SAMPLE 68000 
#ifdef BREAK_AT_SAMPLE
            if ( g_ulOutputSamples <= BREAK_AT_SAMPLE && BREAK_AT_SAMPLE < (g_ulOutputSamples+num_samples) )
            { int j; j = (int)g_ulOutputSamples; }
#endif //BREAK_AT_SAMPLE

#if defined(PRINT_FROM_SAMPLE) && defined(PRINT_TO_SAMPLE)
            if ( g_ulOutputSamples <= PRINT_FROM_SAMPLE && PRINT_FROM_SAMPLE < (g_ulOutputSamples+num_samples) )
            { bPrintDctAtFrame = 0xff0; }	// flag wma_api.cpp to print coefs
            else if ( g_ulOutputSamples <= PRINT_TO_SAMPLE && PRINT_TO_SAMPLE < (g_ulOutputSamples+num_samples) )
            { bPrintDctAtFrame = 0; }
#endif

            g_ulOutputSamples += num_samples;

        } while (1);

    } while (1);
#endif // not AUTOPC_STYLE

    g_ulFullSec   = g_ulEndSec - g_ulStartFirstSec;
    FUNCTION_PROFILE_STOP(&fpDecode);
#ifdef MEASURE_CLOCK
    PerfTimerStopElapsed(pPerfTimerInfo);
#   ifndef DISCARD_OUTPUT
        PerfTimerStop(pPerfTimerInfo, 0 );
#   else
        PerfTimerStop(pPerfTimerInfo, g_ulOutputSamples * g_hdr.num_channels );
#   endif
#endif  // MEASURE_CLOCK

    HEAP_DEBUG_CHECK;

    fprintf(stderr,"Full Read and Decode took %d s.\r\nPlay Time would be %d s.\r\n",
        g_ulFullSec, g_ulOutputSamples / ( g_SampleRate ) );

#ifdef PROFILE
    {
        char szProfileMsg[400];
        DWORD dwDecodeTime = g_ulFullSec*1000;
#       ifdef MEASURE_CLOCK
            dwDecodeTime = (DWORD)(fltPerfTimerDecodeTime(pPerfTimerInfo)*1000); 
#       endif // MEASURE_CLOCK
        sprintf( szProfileMsg, "%d bps\r\n%d Hz,%d chans\r\n%d ms\r\n%s\r\n%s\r\n%s\r\nTrack = %d\r\nClock = %d\r\nIdle  = %d\r\n\r\n", 
            g_hdr.bitrate, g_SampleRate, g_hdr.num_channels, g_hdr.duration,
            desc.pTitle, desc.pAuthor, desc.pDescription, 
            0, dwDecodeTime, 0
            );
        Profiler_closeEX((unsigned int)(g_hdr.duration),dwDecodeTime,szProfileMsg);
    }
#endif  // PROFILE

#ifdef MEASURE_CLOCK
    PerfTimerReport(pPerfTimerInfo);
    PerfTimerFree(pPerfTimerInfo);
#endif  // MEASURE_CLOCK

#ifdef OBNOXIOUS
    // try to get PCM data now
    num_samples = WMAFileGetPCM (g_state, g_pLeft, g_pRight, MAX_SAMPLES);
    if ( num_samples > 0 )
        fprintf( stderr, "** Obnoxious WMAFileGetPCM returns %d samples.\n", num_samples);
    // try to decode data
    rc = WMAFileDecodeData (g_state);
    if ( rc == cWMA_NoErr )
        fprintf( stderr, "** Obnoxious WMAFileDecodeData returns NoErr.\n" );
#endif

lexit:

    /* clean up */

    HEAP_DEBUG_CHECK;

    if (g_fpLic) {
        fclose (g_fpLic);
        g_fpLic = NULL;
    }

#ifndef DISCARD_OUTPUT
#ifdef DUMP_WAV
    if (pwfioOut)
        wfioDelete (pwfioOut);
#else   /* DUMP_WAV */
    if (pfOutPCM) {
        fclose (pfOutPCM);
        pfOutPCM = NULL;
    }
#endif // DUMP_WAV
#endif // !DISCARD_OUTPUT

    if (g_fp) {
        fclose (g_fp);
        g_fp = NULL;
    }

#ifdef OBNOXIOUS
    // try to get PCM data now
    num_samples = WMAFileGetPCM (g_state, g_pLeft, g_pRight, MAX_SAMPLES);
    if ( num_samples > 0 )
    {
        fprintf( stderr, "** Obnoxious WMAFileGetPCM returns %d samples.\n", num_samples);
        assert( num_samples <= 0 );
    }
#endif

    WMAFileDecodeClose (&g_state);

    HEAP_DEBUG_CHECK;

#ifdef OBNOXIOUS
    // try to close interface a second time
    WMAFileDecodeClose (&g_state);
    // try to get PCM data now
    num_samples = WMAFileGetPCM (g_state, g_pLeft, g_pRight, MAX_SAMPLES);
    if ( num_samples > 0 )
    {
        fprintf( stderr, "** Obnoxious WMAFileGetPCM returns %d samples.\n", num_samples);
        assert( num_samples <= 0 );
    }
    // try to decode data
    rc = WMAFileDecodeData (g_state);
    if ( rc == cWMA_NoErr )
    {
        fprintf( stderr, "** Obnoxious WMAFileDecodeData returns NoErr.\n" );
        assert( rc != cWMA_NoErr );
    }
    // try to close a third time
    WMAFileDecodeClose (&g_state);
#endif

    HEAP_DEBUG_CHECK;
    
    return(iRV);
}


#endif // disable main

// Some compile time warning messages
#ifndef PLATFORM_SPECIFIC_COMPILER_MESSAGE
#   define COMPILER_MESSAGE(x)         message(x)
#endif
#ifdef MEASURE_CLOCK
#   pragma COMPILER_MESSAGE(__FILE__ "(927) : Warning - MEASURE_CLOCK Enabled.")
#endif
#ifdef PROFILE
#   pragma COMPILER_MESSAGE(__FILE__ "(930) : Warning - PROFILE Enabled.")
#endif
#ifdef DISCARD_OUTPUT
#   pragma COMPILER_MESSAGE(__FILE__ "(933) : Warning - DISCARD_OUTPUT Enabled.")
#endif
#ifdef OBNOXIOUS
#   pragma COMPILER_MESSAGE(__FILE__ "(936) : Warning - OBNOXIOUS tests Enabled.")
#endif
#ifdef REAL_OBNOXIOUS
#   pragma COMPILER_MESSAGE(__FILE__ "(939) : Warning - REAL OBNOXIOUS tests Enabled - output will be incorrect.")
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\wmalib\wmadec_s\lowrate_common.c ===
/*************************************************************************

Copyright (C) Microsoft Corporation, 1996 - 1999

Module Name:

    LowRate.c

Abstract:

    Implementation of functions only used by low bitrate or mid bitrates
	e.g. MidRate and LowRate specific code

Author:

    Wei-ge Chen (wchen) 14-July-1998

Revision History:
	Sil Sanders (sils)	17-Dec-1999 - Added MidRate specific functions


*************************************************************************/

#pragma code_seg("WMADEC")
#pragma data_seg("WMADEC_RW")
#pragma const_seg("WMADEC_RD")

#ifdef ENABLE_ALL_ENCOPT

#include <math.h>
#include <limits.h>
#include "stdio.h"

#include "AutoProfile.h" 
#include "msaudio.h"
#include "wmamath.h"
#include "..\..\..\dsound\dsndver.h"

#pragma warning (disable:4554)

#if defined(REFERENCE_RAND_24) || defined(REFERENCE_RAND_16)
#	pragma COMPILER_MESSAGE(__FILE__ "(36) : Warning - Non-32-bit random number generator in use.")
#endif

// DEBUG_BREAK at a particular Frame in prvInverseQuantizeHighRate or prvInverseQuantizeLowRate 
//#define INVERSE_QUANTIZE_AT_FRAME 178
// PRINT CoefRecon for all Frames in range (define or undefine both at once)
//#define PRINT_INVERSE_QUANTIZE_AT_FRAME_FIRST 177
//#define PRINT_INVERSE_QUANTIZE_AT_FRAME_LAST  177
#if defined(_DEBUG) && ( defined(INVERSE_QUANTIZE_AT_FRAME) || defined(PRINT_INVERSE_QUANTIZE_AT_FRAME_FIRST)  )
#	pragma COMPILER_MESSAGE(__FILE__ "(45) : Warning - Inverse Quantize LowRate/MidRate Debug Code Enabled.")
// these help match where we are with V4 which does not have a m_iFrameCount
extern int iInvQuantFrameCount = 0;
extern int iInvQuantSubFrameCount = 0;
#endif
#if defined(_DEBUG) && defined(INVERSE_QUANTIZE_AT_FRAME)
// these help match where we are with V4 which does not have a m_iFrameCount
#	define DEBUG_BREAK_AT_FRAME_INV_QUANT										\
		{ 																		\
			if ( pau->m_iCurrSubFrame == 0 && ppcinfo == pau->m_rgpcinfo )		\
			{	iInvQuantFrameCount++;	iInvQuantSubFrameCount = 0; }			\
			else if ( ppcinfo == pau->m_rgpcinfo ) iInvQuantSubFrameCount++;	\
			if ( iInvQuantFrameCount==INVERSE_QUANTIZE_AT_FRAME )				\
				DEBUG_BREAK();													\
		}
#elif defined(_DEBUG) && ( defined(PRINT_INVERSE_QUANTIZE_AT_FRAME) || defined(PRINT_INVERSE_QUANTIZE_AT_FRAME_FIRST) )
// these help match where we are with V4 which does not have a m_iFrameCount
#	define DEBUG_BREAK_AT_FRAME_INV_QUANT										\
		{ 																		\
			if ( pau->m_iCurrSubFrame == 0 && ppcinfo == pau->m_rgpcinfo )		\
			{	iInvQuantFrameCount++;	iInvQuantSubFrameCount = 0; }			\
			else if ( ppcinfo == pau->m_rgpcinfo ) iInvQuantSubFrameCount++;	\
		}
#else	// defined(_DEBUG) && defined(PRINT_INVERSE_QUANTIZE_AT_FRAME_FIRST) 
#	define DEBUG_BREAK_AT_FRAME_INV_QUANT
#endif	// ...

#ifdef BUILD_INTEGER
//Integer Version

//*********************************************************************************************************
// Verify CoefRecon
// Debug code which simulates V4 floating point code.
// If decoded inputs are in error, false verifications can occur.
// include this by defining VERIFY_DECODED_COEFS below or in the project file
//*********************************************************************************************************
//#define VERIFY_DECODED_COEFS
#if defined(_DEBUG) && defined(VERIFY_DECODED_COEFS)
#	pragma COMPILER_MESSAGE(__FILE__ "(83) : Warning - Inverse Quantize LowRate Verification Code Enabled.")
static int fIgnoreLRVerification = 1;		// avoid verify checks - set by hand in debugger only
static Float fltLowRateThreshold = 0.1F;	// change from the debugger ((really should be much smaller!!!))
void VerifyCoefReconLR( CAudioObject* pau, PerChannelInfo* ppcinfo, 
					  int iRecon, int iBark, I32 qrand, I32 iCoefRecon, int iCoefQ, int iWeightFactor, 
					  const U8* rgbBandNotCoded, int iNoiseBand, int cNoiseBand, 
					  const Int* rgiNoisePower, const FastFloat* rgffltSqrtBWRatio, const int* m_rgiBarkIndex )
{	// stolen and adapted from V4 
	if ( !fIgnoreLRVerification )
	{
		Float fltiCoefRecon = (Float)iCoefRecon/(1<<TRANSFORM_FRACT_BITS);
		Float fltNoise = ((Float) qrand / (Float) 0x20000000);
		Float fltInvMaxWeight = (Float)(1<<WEIGHTFACTOR_FRACT_BITS)/((Float)ppcinfo->m_iMaxWeight);
		Float fltWeightFactor = ((Float)iWeightFactor)/(1<<WEIGHTFACTOR_FRACT_BITS);
		double dblQuantStep = DOUBLE_FROM_QUANTSTEPTYPE(pau->m_qstQuantStep);
		Float dif, rel, fltCoefRecon, fltNoisePower;
		static fInBandNotCoded = 0;
		if (!pau->m_fNoiseSub) {
			if (iRecon < pau->m_cLowCutOff  || iRecon >= pau->m_cHighCutOff) 
				fltCoefRecon = 0;
			else
    			fltCoefRecon = (Float)( (Float)iCoefQ  * fltWeightFactor * dblQuantStep * fltInvMaxWeight );
		}
		else
		{
			if (iRecon < pau->m_cLowCutOff)  {
				fltNoise *= pau->m_fltDitherLevel;
				fltCoefRecon = (Float)(fltNoise * fltWeightFactor * dblQuantStep * fltInvMaxWeight);
				fInBandNotCoded = 0;
			}
			else if ( (fInBandNotCoded && iRecon >= m_rgiBarkIndex [iBark + 1] && rgbBandNotCoded [iBark+1] == 0) 
					|| (fInBandNotCoded==0 && iRecon >= pau->m_cHighCutOff) )  {
				fltNoise *= pau->m_fltDitherLevel;
				fltCoefRecon = (Float)(fltNoise * fltWeightFactor * dblQuantStep * fltInvMaxWeight);
				fInBandNotCoded = 0;
			}
			else if (iRecon >= pau->m_iFirstNoiseIndex && iBark < NUM_BARK_BAND && rgbBandNotCoded [iBark] == 1)
			{
				fltNoisePower = ((Float) pow (10, rgiNoisePower [iNoiseBand] / 20.0F)) * FloatFromFastFloat( rgffltSqrtBWRatio[iNoiseBand] );
				fltCoefRecon = fltNoise * fltNoisePower * fltWeightFactor * fltInvMaxWeight;
				fInBandNotCoded = 1;
			}
			else 
			{
				fltNoise *= pau->m_fltDitherLevel;
				fltCoefRecon = (Float)((iCoefQ + fltNoise) * fltWeightFactor * dblQuantStep * fltInvMaxWeight);
				fInBandNotCoded = 0;
			}
		}
		dif = (float) fabs(fltCoefRecon - fltiCoefRecon);
		rel = (float) fabs( (fabs(fltCoefRecon)>32) ? (dif/fltCoefRecon) : (dif/32));
		if ( rel > fltLowRateThreshold )
			DEBUG_BREAK();
		else 
		{	// when magnitude of integer version is much larger than float, we sometimes see differences
			// expect some false triggers, but often there is a relevant difference
			dif = (float)( fabs(fltiCoefRecon) - fabs(fltCoefRecon) );
			rel = (float) fabs( (fabs(fltCoefRecon)>32) ? (dif/fltCoefRecon) : (dif/32));
			if ( dif > 75.0f && rel > 0.000125f )		// test with all1_22s_22
				DEBUG_BREAK();
		}
	}
	MONITOR_RANGE(gMR_CoefRecon,iCoefRecon/((Float)(1<<TRANSFORM_FRACT_BITS)));
	MONITOR_RANGE(gMR_WeightRatio,(float)iWeightFactor/((float)ppcinfo->m_iMaxWeight));
	MONITOR_COUNT_CONDITIONAL(iCoefRecon==0,gMC_zeroCoefRecon,1);
#	if defined(PRINT_INVERSE_QUANTIZE_AT_FRAME_FIRST)
		if ( PRINT_INVERSE_QUANTIZE_AT_FRAME_FIRST <= iInvQuantFrameCount && iInvQuantFrameCount <= PRINT_INVERSE_QUANTIZE_AT_FRAME_LAST )
#           if UNDER_CE
			    MyOutputDbgStr(0,"%5d  %2d  %1d  %4d  %+16.6f  %+16.6f\n", 
				    iInvQuantFrameCount, iInvQuantSubFrameCount, ppcinfo-pau->m_rgpcinfo, iRecon, 
                    FLOAT_FROM_WEIGHT(rgiWeightFactor[iRecon]), FLOAT_FROM_COEF(rgiCoefRecon[iRecon]) );
#           else // !UNDER_CE
			    printf("%5d  %2d  %1d  %4d  %+16.6f  %+16.6f\n", 
				    iInvQuantFrameCount, iInvQuantSubFrameCount, ppcinfo-pau->m_rgpcinfo, iRecon, 
                    FLOAT_FROM_WEIGHT(rgiWeightFactor[iRecon]), FLOAT_FROM_COEF(rgiCoefRecon[iRecon]) );
#           endif   // UNDER_CE
#	endif
}
#define VERIFY_COEF_RECON_LR(idx,qRand,cNBand)																			\
	 VerifyCoefReconLR(	pau, ppcinfo,																					\
						iRecon, iBark, qRand, rgiCoefRecon[iRecon], rgiCoefQ[iCoefQ], rgiWeightFactor[idx],				\
						rgbBandNotCoded, iNoiseBand, cNBand, rgiNoisePower, rgffltSqrtBWRatio, pau->m_rgiBarkIndex )
#elif defined(_DEBUG) && defined(WMA_MONITOR)
#define VERIFY_COEF_RECON_LR(idx,qRand,cNBand)																			\
	MONITOR_RANGE(gMR_CoefRecon,rgiCoefRecon[iRecon]/((Float)(1<<TRANSFORM_FRACT_BITS)));                               \
	MONITOR_RANGE(gMR_WeightRatio,(float)rgiWeightFactor[iRecon]/((float)ppcinfo->m_wtMaxWeight));                      \
	MONITOR_COUNT_CONDITIONAL(rgiCoefRecon[iRecon]==0,gMC_zeroCoefRecon,1);
#elif defined(_DEBUG) && defined(PRINT_INVERSE_QUANTIZE_AT_FRAME_FIRST)
#   if UNDER_CE
#       define VERIFY_COEF_RECON_LR(idx,qRand,cNBand)																	\
            if ( PRINT_INVERSE_QUANTIZE_AT_FRAME_FIRST <= iInvQuantFrameCount                                           \
                 && iInvQuantFrameCount <= PRINT_INVERSE_QUANTIZE_AT_FRAME_LAST )                                       \
		        MyOutputDbgStr(0,"%5d  %2d  %1d  %4d  %+16.6f  %+16.6f\n",                                              \
				    iInvQuantFrameCount, iInvQuantSubFrameCount, ppcinfo-pau->m_rgpcinfo, iRecon,                       \
                    FLOAT_FROM_WEIGHT(rgiWeightFactor[iRecon]), FLOAT_FROM_COEF(rgiCoefRecon[iRecon]) );
#   else // !UNDER_CE
#       define VERIFY_COEF_RECON_LR(idx,qRand,cNBand)																	\
            if ( PRINT_INVERSE_QUANTIZE_AT_FRAME_FIRST <= iInvQuantFrameCount                                           \
                 && iInvQuantFrameCount <= PRINT_INVERSE_QUANTIZE_AT_FRAME_LAST )                                       \
		        printf("%5d  %2d  %1d  %4d  %+16.6f  %+16.6f\n",                                                        \
				    iInvQuantFrameCount, iInvQuantSubFrameCount, ppcinfo-pau->m_rgpcinfo, iRecon,                       \
                    FLOAT_FROM_WEIGHT(rgiWeightFactor[iRecon]), FLOAT_FROM_COEF(rgiCoefRecon[iRecon]) );
#   endif   // UNDER_CE
#else	// so not ( defined(_DEBUG) && defined(VERIFY_DECODED_COEFS) )
#define VERIFY_COEF_RECON_LR(idx,qRand,cNBand)
#endif	// defined(_DEBUG) && defined(VERIFY_DECODED_COEFS)




#define INV_MAX_WEIGHT_FRAC_BITS 30
#define MORE_WF_FRAC_BITS 0

#if (defined(BUILD_INTEGER) || defined(INTEGER_ENCODER))

    // WinCE and embedded compilers have lousy performance for I64 multiplication and division.
    // On the SH3, this saves .35% of playtime decoding 16m_16 by speeding up InverseQuadRoot 14%.

    INLINE UInt uiInverseMaxWeight(WeightType wtMaxWeight)
    {   
        U32 uiMSF = wtMaxWeight;
        Int iExp = (32-INV_MAX_WEIGHT_FRAC_BITS)+(32-WEIGHTFACTOR_FRACT_BITS);  // (32-30)+(32-21)=13
        int iMSF8;
        U32 uiFrac1;
        if ( uiMSF < ((U32)(1<<((32-INV_MAX_WEIGHT_FRAC_BITS)+(32-WEIGHTFACTOR_FRACT_BITS)))) ) 
            return 0xFFFFFFFF ;
        // normalize the fractional part
        while( (uiMSF & 0xF0000000)==0 ) {
            iExp -= 4;
            uiMSF <<= 4;
        }
        while( (uiMSF & 0x80000000)==0 ) {
            iExp--;
            uiMSF <<= 1;
        }
        // discard the most significant one bit (it's presence is built into g_InverseFraction)
        iExp--;
        uiMSF <<= 1;
        assert( iExp >= 0 );
        if ( iExp < 0 )
            return 0xFFFFFFFF ;
        // split into top INVERSE_FRACTION_TABLE_LOG2_SIZE==8 bits for fractional lookup and bottom bits for interpolation
        iMSF8 = uiMSF>>(32-INVERSE_FRACTION_TABLE_LOG2_SIZE);
        uiMSF <<= INVERSE_FRACTION_TABLE_LOG2_SIZE;
        // lookup and interpolate - tables are set up to return correct binary point for WeightType (we hope)
        uiFrac1  = g_InverseFraction[iMSF8++];
        uiFrac1 -= MULT_HI_UDWORD( uiMSF, uiFrac1 - g_InverseFraction[iMSF8] );
        return uiFrac1 >> iExp;
    }

#   define INVERSE_MAX_WEIGHT(mw) uiInverseMaxWeight(mw)

#else

#   define INVERSE_MAX_WEIGHT(mw) ((UInt)((((I64)1)<<(INV_MAX_WEIGHT_FRAC_BITS+WEIGHTFACTOR_FRACT_BITS))/(mw)))

#endif

//**************************************************************************************************
//
// prvInverseQuantizeLowRate handles LowRate inverse quantization
//
//**************************************************************************************************
WMARESULT prvInverseQuantizeLowRate (CAudioObject* pau, PerChannelInfo* ppcinfo, Int* rgiWeightFactor)
{
	Int iBark = 0;
	Int iCoefQ = 0;
	Int iRecon = 0;
    UInt uiWeightFactor, uiMaxWeight, uiQuantStepXInvMaxWeight;
    Int QuantStepXMaxWeightXWeightFactor, qrand, iNoise;
	Int cQSIMWFracBits, cFracBits, cFracBits2, cWFFracBits, cMaxWeightFracBits;
    Float fltCoefRecon;
    Int *rgiCoefRecon = ppcinfo->m_rgiCoefRecon;
    const I16* const rgiCoefQ                = ppcinfo->m_rgiCoefQ;
    const U8* const rgbBandNotCoded          = ppcinfo->m_rgbBandNotCoded;
    const Int* const rgiNoisePower           = ppcinfo->m_rgiNoisePower;
    const FastFloat* const rgffltSqrtBWRatio = ppcinfo->m_rgffltSqrtBWRatio;
    U8  cNoiseBand;
    Int iNoiseBand = 0;
	const Int iDitherFactor = 0x51EB851F;		// LPC  0.04 * 2^35 
	UInt uiInvMaxWeight = INVERSE_MAX_WEIGHT(ppcinfo->m_wtMaxWeight);
    FUNCTION_PROFILE(fp);
    FUNCTION_PROFILE_START(&fp,INVERSE_QUAN_LOW_RATE_PROFILE);
	//assert( uiInvMaxWeight == (UInt)((float)(1<<INV_MAX_WEIGHT_FRAC_BITS)*(float)(1<<WEIGHTFACTOR_FRACT_BITS)/((float)ppcinfo->m_wtMaxWeight) ) );
	//// Float 1/MaxWeight = uiInvMaxWeight/(1.0F*(1<<30))

	DEBUG_BREAK_AT_FRAME_INV_QUANT;
	MONITOR_COUNT(gMC_IQ,1);

    //Calculate QuantStep X invMaxWeight
    cQSIMWFracBits  = pau->m_qstQuantStep.iFracBits;                           
    uiQuantStepXInvMaxWeight = MULT_HI_DWORD(pau->m_qstQuantStep.iFraction,uiInvMaxWeight);
    //uiQuantStepXInvMaxWeight = (MULT_HI_DWORD(pau->m_qstQuantStep.iFraction,uiInvMaxWeight>>1)<<1);
	cQSIMWFracBits += (INV_MAX_WEIGHT_FRAC_BITS-32);
	// Float QSIMWF = uiQuantStepXInvMaxWeight*1.0F/(1<<cQSIMWFracBits)
	NormUInt( &uiQuantStepXInvMaxWeight, &cQSIMWFracBits, 0x3FFFFFFF );
	MONITOR_RANGE(gMR_QuantStepXInvMaxWeight,uiQuantStepXInvMaxWeight/pow(2,cQSIMWFracBits));

	// since all weights are less than MaxWeight, fast scale below by MaxWeight's FracBits
	uiMaxWeight = ppcinfo->m_wtMaxWeight<<MORE_WF_FRAC_BITS;;
	cMaxWeightFracBits = MORE_WF_FRAC_BITS;		// really should be WEIGHTFACTOR_FRACT_BITS+MORE_WF_FRAC_BITS but this way is for shift delta

	NormUInt( &uiMaxWeight, &cMaxWeightFracBits, 0x3FFFFFFF );

    if (!pau->m_fNoiseSub) {
		// Unusual case, but 8kHz Mono 8kpbs gets here
        memset (rgiCoefRecon, 0, pau->m_cLowCutOff * sizeof (Int));
        for (iRecon = pau->m_cLowCutOff; iRecon < pau->m_cHighCutOff; iRecon++, iCoefQ++)
		{	// rgfltCoefRecon [iRecon] = Float ((Float) (rgiCoefQ [iCoefQ]) * rgfltWeightFactor [iRecon] * dblQuantStep * fltInvMaxWeight);
			int iCoef;
			assert( rgiWeightFactor[iRecon] <= (0x7FFFFFFF>>cMaxWeightFracBits) );
			uiWeightFactor = rgiWeightFactor [iRecon] << cMaxWeightFracBits; 
			cWFFracBits = WEIGHTFACTOR_FRACT_BITS+cMaxWeightFracBits;
			//// Float WeightFactor = uiWeightFactor*1.0F/(1<<cWFFracBits)
			assert( uiWeightFactor <= 0x7FFFFFFF );
			NormUInt( &uiWeightFactor, &cWFFracBits, 0x3FFFFFFF );		
			MONITOR_RANGE(gMR_weightFactor,uiWeightFactor/pow(2,cWFFracBits));

			QuantStepXMaxWeightXWeightFactor = MULT_HI(uiQuantStepXInvMaxWeight,uiWeightFactor);		
			cFracBits = cQSIMWFracBits+cWFFracBits-31;
			//// Float QuantStep*WeightFactor/InvMaxWeight = QuantStepXMaxWeightXWeightFactor/(1.0F*(1<<cFracBits))
			MONITOR_RANGE(gMR_QuantStepXMaxWeightXWeightFactor,QuantStepXMaxWeightXWeightFactor/pow(2,cFracBits));

			iCoef = MULT_HI(((Int)(rgiCoefQ[iCoefQ])<<20),QuantStepXMaxWeightXWeightFactor);
			cFracBits += (20-31);
			//// Float Coef = iCoef*1.0F/(1<<cFracBits))

			rgiCoefRecon[iRecon] = Align2FracBits( iCoef, cFracBits, TRANSFORM_FRACT_BITS );
			//// Float CoefRecon = rgiCoefRecon[iRecon]/32.0F

			VERIFY_COEF_RECON_LR(iRecon,0,0);
		}
        memset (rgiCoefRecon + pau->m_cHighCutOff, 0, (pau->m_cSubband - pau->m_cHighCutOff) * sizeof (Int));
		FUNCTION_PROFILE_STOP(&fp);
		return WMA_OK;
    }

    cNoiseBand = rgbBandNotCoded [0];

	if (iRecon < pau->m_cLowCutOff ) {
		// not integerized since cLowCutOff is typically 0, so this is here for compatability with V1 
		Double dblQuantStep = DOUBLE_FROM_QUANTSTEPTYPE(pau->m_qstQuantStep);
		while  (iRecon < pau->m_cLowCutOff) 	{
			Float fltNoise = pau->m_fltDitherLevel * ((Float) quickRand (&(pau->m_tRandState)) / (Float) 0x20000000);//rgfltNoise [iRecon];
			Float fltWeightFactor = ((float)rgiWeightFactor [pau->m_cLowCutOff])/(1<<WEIGHTFACTOR_FRACT_BITS);
			// SH4 warning CBE4717 on the next line is ignorable - appraently a compiler mistake
			fltCoefRecon  = (Float) (fltNoise * fltWeightFactor * dblQuantStep * (float)(1<<WEIGHTFACTOR_FRACT_BITS)/((float)ppcinfo->m_wtMaxWeight) );
			rgiCoefRecon [iRecon] = (Int)(fltCoefRecon * (1<<TRANSFORM_FRACT_BITS));
			MONITOR_RANGE(gMR_CoefRecon,rgiCoefRecon[iRecon]/32.0f);
			MONITOR_RANGE(gMR_WeightRatio,(fltWeightFactor*(float)(1<<WEIGHTFACTOR_FRACT_BITS)/((float)ppcinfo->m_wtMaxWeight)));
			MONITOR_COUNT(gMC_IQ_Float,9);
			iRecon++;
		}
	}

	while  (iRecon < pau->m_iFirstNoiseIndex) {
        int iCoef,iCoefScaled,iCoefRecon,iNoiseScaled,iNoiseQuant;         
        assert(TRANSFORM_FRACT_BITS==5);
        qrand = quickRand (&(pau->m_tRandState));

        if (iRecon >= pau->m_rgiBarkIndex [iBark + 1]) 
			iBark++;
        assert(iBark < NUM_BARK_BAND);

	    // Since weight factors became unsigned, the following assert is not
	    // valid. Other wrap-around detection would have to be performed elsewhere.
		assert( rgiWeightFactor[iRecon] <= (0x7FFFFFFF>>cMaxWeightFracBits) );
        uiWeightFactor = rgiWeightFactor [iRecon] << cMaxWeightFracBits; 
        cWFFracBits = WEIGHTFACTOR_FRACT_BITS+cMaxWeightFracBits;
		//// Float WeightFactor = uiWeightFactor/(1.0F*(1<<cWFFracBits))
	    // Since weight factors became unsigned, the following assert is not
	    // valid. Other wrap-around detection would have to be performed elsewhere.
	    assert( uiWeightFactor <= 0x7FFFFFFF );
		NormUInt( &uiWeightFactor, &cWFFracBits, 0x3FFFFFFF );		// weightFactor with cWFFracBits fractional bits
		MONITOR_RANGE(gMR_weightFactor,uiWeightFactor/pow(2,cWFFracBits));
        
        QuantStepXMaxWeightXWeightFactor = MULT_HI(uiQuantStepXInvMaxWeight,uiWeightFactor);		
        cFracBits = cQSIMWFracBits+cWFFracBits-31;
        //// Float QuantStep*WeightFactor/MaxWeight = QuantStepXMaxWeightXWeightFactor/(1.0F*(1<<cFracBits))
		MONITOR_RANGE(gMR_QuantStepXMaxWeightXWeightFactor,QuantStepXMaxWeightXWeightFactor/pow(2,cFracBits));

        iCoef = MULT_HI(((Int)(rgiCoefQ[iCoefQ])<<20),QuantStepXMaxWeightXWeightFactor);
		cFracBits += (20-31);
		//// Float Coef = iCoef/(1.0F*(1<<cFracBits))

        //Rescale to TRANSFORM_FRACT_BITS for outputing to the inverse transform so that (float)iCoefScaled/(1<<TRANSFORM_FRACT_BITS)
		iCoefScaled = Align2FracBits( iCoef, cFracBits, TRANSFORM_FRACT_BITS );
		//// Float CoefScaled = iCoefScaled/32.0F

        iNoise = MULT_HI(iDitherFactor,qrand);
		cFracBits2 = 35+29-31;											// == 33
		//// Float Noise = iNoise/(1024.0F*(1<<(cFracBits2-10)))
        iNoiseQuant = MULT_HI(iNoise,QuantStepXMaxWeightXWeightFactor);
		cFracBits2 += ((cQSIMWFracBits+cWFFracBits-31)-31);
		//// Float NoiseQuant = iNoiseQuant/(1024.0F*(1<<(cFracBits2-10)))
		assert( (cFracBits+(33-20)) == cFracBits2 );

        //rescale iNoiseQuant so that (float)iNoiseScaled/(1<<TRANSFORM_FRACT_BITS)
		iNoiseScaled = Align2FracBits( iNoiseQuant, cFracBits2, TRANSFORM_FRACT_BITS );
		//// Float NoiseScaled = iNoiseScaled/32.0F

        iCoefRecon = iCoefScaled + iNoiseScaled;
        rgiCoefRecon [iRecon] = iCoefRecon;
		//// Float CoefRecon = rgiCoefRecon [iRecon]/32.0F

		VERIFY_COEF_RECON_LR(iRecon,qrand,cNoiseBand);

        iRecon++;
		iCoefQ++;
    }

    while  (iRecon < pau->m_cHighCutOff) {
		if (iRecon >= pau->m_rgiBarkIndex [iBark + 1]) 
			iBark++;
        assert(iBark < NUM_BARK_BAND);
        
		if (rgbBandNotCoded [iBark] == 1)
        {
			FastFloat ffltNoisePower;
            UInt uiNoisePowerXinvMaxWeight;
			Int iUBLimitOniRecon = min(pau->m_rgiBarkIndex [iBark + 1], pau->m_cHighCutOff);

			assert( iNoiseBand < cNoiseBand );

			ffltNoisePower = qstCalcQuantStep( rgiNoisePower[iNoiseBand] );
			//// Float Noise Power = ffltNoisePower.iFraction/(1.0F*(1<<ffltNoisePower.iFracBits))

			ffltNoisePower = ffltMultiply( ffltNoisePower, rgffltSqrtBWRatio[iNoiseBand] );
			//// Float Noise Power = ffltNoisePower.iFraction/(1.0F*(1<<ffltNoisePower.iFracBits))

            uiNoisePowerXinvMaxWeight = MULT_HI(ffltNoisePower.iFraction,uiInvMaxWeight>>1)<<1;
			cFracBits = ffltNoisePower.iFracBits + (INV_MAX_WEIGHT_FRAC_BITS-31);
			//// Float NoisePower/MaxWeight = uiNoisePowerXinvMaxWeight/(1.0F*(1<<cFracBits))
			NormUInt( &uiNoisePowerXinvMaxWeight, &cFracBits, 0x3FFFFFFF );

            while (iRecon < iUBLimitOniRecon)
            {
                Int iNoiseRand,iNoiseWeighted,iCoefRecon;

                qrand = quickRand (&(pau->m_tRandState));										// FB = 29												
                iNoiseRand = MULT_HI(uiNoisePowerXinvMaxWeight,qrand);
                cFracBits2 = cFracBits+29-31;
				//// Float NoiseRand = iNoiseRand/(1.0F*(1<<cFracBits2))

	            // Since weight factors became unsigned, the following assert is not
	            // valid. Other wrap-around detection would have to be performed elsewhere.
				assert( rgiWeightFactor[iRecon] <= (0x7FFFFFFF>>cMaxWeightFracBits) );
				uiWeightFactor = rgiWeightFactor [iRecon] << cMaxWeightFracBits; 
				cWFFracBits = WEIGHTFACTOR_FRACT_BITS+cMaxWeightFracBits;
				//// Float WeightFactor = 	uiWeightFactor/(1024.0F*(1<<(cWFFracBits-10)))
	            // Since weight factors became unsigned, the following assert is not
	            // valid. Other wrap-around detection would have to be performed elsewhere.
				assert( uiWeightFactor <= 0x7FFFFFFF );
				NormUInt( &uiWeightFactor, &cWFFracBits, 0x3FFFFFFF );		// uiWeightFactor with cWFFracBits fractional bits
				MONITOR_RANGE(gMR_weightFactor,uiWeightFactor/pow(2,cWFFracBits));

                iNoiseWeighted = MULT_HI(iNoiseRand,uiWeightFactor);	
				cFracBits2 += (cWFFracBits-31);
				//// Float NoiseWeighted = iNoiseWeighted/(1024.0F*(1<<(cFracBits2-10)))

				iCoefRecon = Align2FracBits( iNoiseWeighted, cFracBits2, TRANSFORM_FRACT_BITS );  //scale so that (float)iCoefRecon/(1<<TRANSFORM_FRACT_BITS)
                rgiCoefRecon [iRecon] = iCoefRecon;
				//// Float CoefRecon = rgiCoefRecon [iRecon]/32.0F

				VERIFY_COEF_RECON_LR(iRecon,qrand,cNoiseBand);

				iRecon++;	
			}

			iNoiseBand++;
		}
		else 
		{	// This should be the same as the first < FirstNoiseIndex loop
			// Float fltNoise = pau->m_fltDitherLevel * ((Float) quickRand (&(pau->m_tRandState)) / (Float) 0x20000000);
			// rgfltCoefRecon [iRecon] = (Float) ((rgiCoefQ [iCoefQ] + fltNoise) * rgfltWeightFactor[iRecon] * dblQuantStep * fltInvMaxWeight);			

            Int iCoef,iNoiseQuant,iCoefScaled,iCoefRecon;

            if (iRecon >= pau->m_rgiBarkIndex [iBark + 1]) 
				iBark++;
            assert(iBark < NUM_BARK_BAND);

			qrand = quickRand (&(pau->m_tRandState));

			assert( rgiWeightFactor[iRecon] <= (0x7FFFFFFF>>cMaxWeightFracBits) );
			uiWeightFactor = rgiWeightFactor [iRecon] << cMaxWeightFracBits; 
			cWFFracBits = WEIGHTFACTOR_FRACT_BITS+cMaxWeightFracBits;
			//// Float WeightFactor = uiWeightFactor/(1024.0F*(1<<(cWFFracBits-10)))
			assert( uiWeightFactor <= 0x7FFFFFFF );
			NormUInt( &uiWeightFactor, &cWFFracBits, 0x3FFFFFFF );		// uiWeightFactor with cWFFracBits fractional bits
			MONITOR_RANGE(gMR_weightFactor,uiWeightFactor/pow(2,cWFFracBits));

            QuantStepXMaxWeightXWeightFactor = MULT_HI(uiQuantStepXInvMaxWeight,uiWeightFactor);
            cFracBits = cQSIMWFracBits+cWFFracBits-31;
			//// Float QuantStep*WightFactor/MaxWeight = QuantStepXMaxWeightXWeightFactor/(1.0F*(1<<cFracBits))
			MONITOR_RANGE(gMR_QuantStepXMaxWeightXWeightFactor,QuantStepXMaxWeightXWeightFactor/pow(2,cFracBits));

            iNoise = MULT_HI(iDitherFactor,qrand); 
			cFracBits2 = 35+29-31;							// FP = 33
			//// Float Noise = iNoise/(1024.0F*(1<<(33-10)))

            iNoiseQuant = MULT_HI(iNoise,QuantStepXMaxWeightXWeightFactor);
			cFracBits2 += (cFracBits-31);
			//// Float NoiseQuant = iNoiseQuant/(1024.0F*(1<<(cFracBits2-10)))

            iCoef = MULT_HI( ((Int)rgiCoefQ[iCoefQ])<<20, QuantStepXMaxWeightXWeightFactor );
			cFracBits += (20-31);
			//// Float Coef = iCoef/(1.0F*(1<<cFracBits))

			iCoefScaled = Align2FracBits( iCoef, cFracBits, TRANSFORM_FRACT_BITS );  
			//// Float CoefScaled = iCoefScaled/32.0F

            assert(cFracBits2>=TRANSFORM_FRACT_BITS);
            iCoefRecon = iCoefScaled + (iNoiseQuant>>(cFracBits2-TRANSFORM_FRACT_BITS));
            rgiCoefRecon [iRecon] = iCoefRecon;
			//// Float CoefRecon = rgiCoefRecon [iRecon]/32.0F

			VERIFY_COEF_RECON_LR(iRecon,qrand,cNoiseBand);

            iRecon++;
		    iCoefQ++;
		}
	}

	{	//Calculate from highCutOff to m_cSubband
		UInt QuantStepXMaxWeightXWeightFactorXDither;
		
	    // Since weight factors became unsigned, the following assert is not
	    // valid. Other wrap-around detection would have to be performed elsewhere.
		assert( rgiWeightFactor[pau->m_cHighCutOff - 1] <= (0x7FFFFFFF>>cMaxWeightFracBits) );
		uiWeightFactor = rgiWeightFactor [pau->m_cHighCutOff - 1] << MORE_WF_FRAC_BITS;
		cWFFracBits = WEIGHTFACTOR_FRACT_BITS+MORE_WF_FRAC_BITS;
		//// Float WeightFactor = uiWeightFactor/(1024.0F*(1<<(cWFFracBits-10)))
		NormUInt( &uiWeightFactor, &cWFFracBits, 0x3FFFFFFF );		

		QuantStepXMaxWeightXWeightFactor = MULT_HI(uiQuantStepXInvMaxWeight,uiWeightFactor);
		cFracBits = cQSIMWFracBits+cWFFracBits-31;
		//// Float QuantStep*WeightFactor/MaxWeight = QuantStepXMaxWeightXWeightFactor/(1024.0F*(1<<(cFracBits-10)))
		NormUInt( (unsigned long *)&QuantStepXMaxWeightXWeightFactor, &cFracBits, 0x3FFFFFFF );

		QuantStepXMaxWeightXWeightFactorXDither = MULT_HI(QuantStepXMaxWeightXWeightFactor,iDitherFactor);
		cFracBits += (35-31);
		//// Float QS * WF/MaxWF * Dither = QuantStepXMaxWeightXWeightFactorXDither/(1024.0F*(1<<(cFracBits-10)))
		NormUInt( &QuantStepXMaxWeightXWeightFactorXDither, &cFracBits, 0x3FFFFFFF );

		while (iRecon < pau->m_cSubband) {
			Int iCoefScaled;
			Int qrand = quickRand (&(pau->m_tRandState));
			Int iCoefRecon = MULT_HI(QuantStepXMaxWeightXWeightFactorXDither,qrand);
			cFracBits2 = cFracBits + 29 - 31;
			//// Float CoefRecon = iCoefRecon/(1.0F*(1<<cFracBits2))
			
			iCoefScaled = Align2FracBits( iCoefRecon, cFracBits2, TRANSFORM_FRACT_BITS );
			rgiCoefRecon [iRecon] = iCoefScaled;		        
			//// Float CoefRecon = rgiCoefRecon [iRecon]/32.0F

			MONITOR_RANGE(gMR_QuantStepXMaxWeightXWeightFactor,QuantStepXMaxWeightXWeightFactor/pow(2,cFracBits));
			VERIFY_COEF_RECON_LR(pau->m_cHighCutOff - 1,qrand,cNoiseBand);

			iRecon++;
		}
	}

#   if defined(REFERENCE_RAND_24) || defined(REFERENCE_RAND_16)
        // call the random generator one extra time per subframe to improve subband randomness
        quickRand (&(pau->m_tRandState));
#   endif

	FUNCTION_PROFILE_STOP(&fp);
	return WMA_OK;
}
#pragma warning (default:4554)
#endif // BUILD_INTEGER

#endif //ENABLE_ALL_ENCOPT



//****************************************************************************
//****************************************************************************
//
//  MidRate 
//
//	Functions to implement MidRate
//
//****************************************************************************
//****************************************************************************

#ifdef ENABLE_ALL_ENCOPT
//#ifndef ENCODER


//******************************************************************************************
// Support routines for Resampling indexes to those used when the MaskQ's were last updated
//******************************************************************************************
#define MASKQ_RESAMPLE_OFFSET 6
typedef struct MaskResampleInfo
{
	Int iMaskResampleRatio;
	Int iMaskResampleRatioPow;
	Int cValidBarkBandLatestUpdate;
} MaskResampleInfo;

#ifdef HITACHI
#pragma inline(iResampleIndex)
static Int iResampleIndex( Int iRecon, const MaskResampleInfo MRI )
#else
static INLINE Int iResampleIndex( Int iRecon, const MaskResampleInfo MRI )
#endif
{	// return resampled linear index suitable for frame that was last updated with MaskQ
	// equvilent to iRecon shifted left or right by (MRI.iMaskResampleRatioPow-MASKQ_RESAMPLE_OFFSET)
	return ( (((iRecon) << MRI.iMaskResampleRatioPow) >> MASKQ_RESAMPLE_OFFSET) );
}

#ifdef HITACHI
#pragma inline(iUnResampleIndex)
static Int iUnResampleIndex( Int iResampled, const MaskResampleInfo MRI )
#else
static INLINE Int iUnResampleIndex( Int iResampled, const MaskResampleInfo MRI )
#endif
{	// return the reverse of iResampleIndex()
	// that is, convert from resampled indexes of MaskQ or WeightFactor to natural index for the current frame
    if (MRI.iMaskResampleRatioPow > MASKQ_RESAMPLE_OFFSET){
		// Rounding for down shift 
		// Although V4 did not round when resampling, this inverse funtion needs to round ???
        return (iResampled + (1<<(MRI.iMaskResampleRatioPow-(MASKQ_RESAMPLE_OFFSET+1)))) >> (MRI.iMaskResampleRatioPow-MASKQ_RESAMPLE_OFFSET);
        // return iResampled >> (MRI.iMaskResampleRatioPow-MASKQ_RESAMPLE_OFFSET);
    } else {
        return iResampled << (MASKQ_RESAMPLE_OFFSET-MRI.iMaskResampleRatioPow);
    }
}

// prvScanForNextBarkIndex scans for the next resampled bark index and then returns its unresampled linear index
//   iRecon and iHighLimit are linear indexes in the current frames natural scale.
//   iBarkResampled is the bark index in the resampled bark scale (appropriate for the frame when the MaskQ's were last updated)
//   rgiBarkIndex is the resampled bark index scale from that last updated MaskQ subframe
#ifdef HITACHI
#pragma inline(prvScanForNextBarkIndex)
static Int prvScanForNextBarkIndex( const Int iRecon, Int* piBarkResampled, const int iHighLimit, 
										  const Int* const rgiBarkIndexResampled, const MaskResampleInfo MRI )
#else
static INLINE Int prvScanForNextBarkIndex( const Int iRecon, Int* piBarkResampled, const int iHighLimit, 
										  const Int* const rgiBarkIndexResampled, const MaskResampleInfo MRI )
#endif
{   //Scan for the next resampled bark index
	Int iNextBarkIndex, iBarkResampled, iReconResampled;
	iReconResampled = iResampleIndex(iRecon, MRI);
    while ( iReconResampled >= rgiBarkIndexResampled [*piBarkResampled+1]) 
		++(*piBarkResampled);
	iBarkResampled = *piBarkResampled;
	if ( iBarkResampled >= MRI.cValidBarkBandLatestUpdate )
	{
		assert( iBarkResampled < MRI.cValidBarkBandLatestUpdate );
		return( MRI.cValidBarkBandLatestUpdate );
	}
	iNextBarkIndex = iUnResampleIndex( rgiBarkIndexResampled [iBarkResampled + 1], MRI );
    if (iNextBarkIndex > iHighLimit) 
		iNextBarkIndex = iHighLimit;
	return iNextBarkIndex;
}


//*****************************************************************************************
// Look up (10^(1/16)) ^ iMaskQ
//*****************************************************************************************
#ifdef HITACHI
#pragma inline(ffltMaskPower10)
static FastFloat ffltMaskPower10( Int iMaskQ )
#else
static INLINE FastFloat ffltMaskPower10( Int iMaskQ )
#endif
{	// (10^(1/16)) ^ iMaskQ
	FastFloat fflt;
	
#if !defined (ENCODER)
	assert( -MASK_MINUS_POWER_TABLE_SIZE < iMaskQ && iMaskQ <= MASK_PLUS_POWER_TABLE_SIZE );
#endif
	if ( iMaskQ <= 0 )
	{
		if (iMaskQ < -MASK_MINUS_POWER_TABLE_SIZE)
			iMaskQ = -(MASK_MINUS_POWER_TABLE_SIZE-1);
#if defined(BUILD_INTEGER) || defined(INTEGER_ENCODER)
		fflt.iFraction = rgiMaskMinusPower10[ -iMaskQ ];	// with MASK_POWER_FRAC_BITS==28 fractional bits
		fflt.iFracBits = MASK_POWER_FRAC_BITS+(-iMaskQ>>2);
#else
		fflt = rgiMaskMinusPower10[ -iMaskQ ] / (Float)(1<<(-iMaskQ>>2));
#endif
	}
	else
	{
		if (iMaskQ >= MASK_PLUS_POWER_TABLE_SIZE)
			iMaskQ = MASK_PLUS_POWER_TABLE_SIZE;
#if defined(BUILD_INTEGER) || defined(INTEGER_ENCODER)
		fflt.iFraction = rgiMaskPlusPower10[ iMaskQ-1 ];	// with MASK_POWER_FRAC_BITS==28 fractional bits
		fflt.iFracBits = MASK_POWER_FRAC_BITS-(iMaskQ>>2);
#else
		fflt = rgiMaskPlusPower10[ iMaskQ-1 ] * (Float)(1<<(iMaskQ>>2));
#endif
	}
	return fflt;
}

//function prototype, used to eliminate Mac warnings
Void prvGetBandWeightMidRate (CAudioObject* pau, PerChannelInfo* ppcinfo, const Int* const rgiBarkIndex, const Int* const rgiBarkIndexResampled, MaskResampleInfo MRI);

//*********************************************************************************
// prvGetBandWeightMidRate
// Calculate a band weight for bands which are not coded
// 
// BW = average( 10^(2*MaskQ[iBarkResampled]/16) ) over each linear frequency bin
// For most sampling rates, the bark scale when resampled does not equal the un-resampled bark scale
// But 32000 does have the nice property that the resampled bark scale = un-resampled in the noise substitution region
// So for 32000 Hz to 44099 Hz:  
//		BW = 10^((2/16)*MaskQ[iBarkResampled])
// For all other sampling frequencies:
//		BW = ( N1 * 10^(2*MarkQ[iBarkResampled]) + N2 * 10^(2*MarkQ[iBarkResampled+1]/16) ) / (N1 + N2)
//		where N1 is the number of linear frequency bins in the first resampled bark band
//		and   N2 is the number of linear frequency bins in the second resampled bark band
// BandWeights are only used as the sqrt of the ratio to the last noise BandWeight
// So for 32000 Hz to 44099 Hz
//		SqrtBWRatio = 10^((MaskQ[iBarkResampled] - MaskQ[iLast])/16)
// And for other sampling frequencies
//		SqrtBWRatio = sqrt( BW[i] / BW[last] )
// And for all cases where SqrtBWRatio[last] = 1
// Note that log to the base 10^(1/16) of the MaskQ are integers for 32000 but are not integers for non-32000Hz
// So doing all the inverse quantization in the exponent domain does not have the advantage of using integer exponents
// For this reason, SqrtBWRatio is stored and used as a FastFloat.
// TODO:  rgffltSqrtBWRatio seems to have a narrow range between 1/4 and 4. Consider making it a fixed point int.
// TODO:  Avoid recalculating when MaskQ's have not been updated and the resample ratio is the same as the previous subframe
//*********************************************************************************
Void prvGetBandWeightMidRate (CAudioObject* pau, PerChannelInfo* ppcinfo, 
							  const Int* const rgiBarkIndex, const Int* const rgiBarkIndexResampled, MaskResampleInfo MRI)
{
    U8*	rgbBandNotCoded			 = ppcinfo->m_rgbBandNotCoded;
	FastFloat* rgffltSqrtBWRatio = ppcinfo->m_rgffltSqrtBWRatio;
	Int* rgiMaskQ				 = ppcinfo->m_rgiMaskQ;
	U8 cNoiseBand	= 0;
	FastFloat fflt;
	Float flt;
	Int iCurrStart, iCurrBand, iCurrEnd;	// indexes for the current subframe
	Int iMaskStart, iMaskBand, iMaskEnd;	// indexes in the subframe where the MaskQ's were last updated
	Int iRsmpStart, iRsmpBand, iRsmpEnd;	// indexes for the current subframe resampled to the subframe where the MaskQ's were last updated
	int fAllBandsSynced = MRI.iMaskResampleRatioPow==MASKQ_RESAMPLE_OFFSET 
		|| ( pau->m_iVersion!=1 && 32000 <= pau->m_iSamplingRate && pau->m_iSamplingRate < 44100 );
	Int rgiMaskQ4BandNotCoded[10];			// used if bands Syncronized
	Float fltBandWeight[10];				// used if bands are no Syncronized
	Int cMaskHighCutOff;
    FUNCTION_PROFILE(fp);
    FUNCTION_PROFILE_START(&fp,GET_BAND_WEIGHTS_PROFILE);

	iCurrBand = pau->m_iFirstNoiseBand;
	iMaskBand = iRsmpBand = 0;
	if ( !fAllBandsSynced )
		cMaskHighCutOff = iResampleIndex( pau->m_cSubband, MRI ) * pau->m_cHighCutOffLong / pau->m_cFrameSampleHalf;

    while (WMAB_TRUE)    {
        assert (iCurrBand <= pau->m_cValidBarkBand);
        iCurrStart = max( rgiBarkIndex [iCurrBand], pau->m_iFirstNoiseIndex );
        if (iCurrStart >= pau->m_cHighCutOff)
            break;

		if (rgbBandNotCoded [iCurrBand] == 1)	{
			assert( cNoiseBand < 10 );		// probably (cNoiseBand < 5) would be OK

			// Determine the band for accessing the possibly resampled MaskQ's
			iMaskStart = iResampleIndex( iCurrStart, MRI );
			while ( rgiBarkIndexResampled [iMaskBand+1] <= iMaskStart ) 
				++iMaskBand;

			if ( fAllBandsSynced )
			{	// Current subFrame bands synced to band were MaskQ's were last updated
				rgiMaskQ4BandNotCoded[cNoiseBand] = rgiMaskQ[iMaskBand];
			}
			else
			{	// Have to check in detail about whether one or two MaskQ's are used by this BandNotCoded
				iCurrEnd   = min ( pau->m_cHighCutOff, rgiBarkIndex [iCurrBand + 1]);
				assert (iCurrEnd >= iCurrStart);
				iRsmpStart = iMaskStart;
				iMaskEnd = min( rgiBarkIndexResampled [ iMaskBand+1 ], cMaskHighCutOff );
				iRsmpEnd = min( iResampleIndex( iCurrEnd, MRI ), cMaskHighCutOff );
				while ( rgiBarkIndexResampled [iRsmpBand+1] <= (iRsmpEnd-1) ) 
					++iRsmpBand;
				assert( iMaskBand == iRsmpBand || (iMaskBand+1) == iRsmpBand );
				if ( iRsmpBand == iMaskBand )
				{	// just a constant MaskQ for the whole NoiseBand
					fflt = ffltMaskPower10( rgiMaskQ[iMaskBand] );
					flt = FLOAT_FROM_FASTFLOAT( fflt );
					fltBandWeight[cNoiseBand] = flt*flt;
					MONITOR_COUNT(gMC_GBW_floats,4);
				}
				else
				{	// Two different MaskQ's for this NoiseBand
					// BW = ( N1 * 10^(2*MarkQ[iBarkResampled]) + N2 * 10^(2*MarkQ[iBarkResampled+1]/16) ) / (N1 + N2)
					// This is not suited to FastFloat - leave in float.
					Float fltP1, fltP2;
					Int iUnRsmpEnd = iUnResampleIndex( iMaskEnd, MRI );
					fflt  = ffltMaskPower10( rgiMaskQ[iMaskBand] );
					fltP1 = FLOAT_FROM_FASTFLOAT( fflt );
					fflt  = ffltMaskPower10( rgiMaskQ[iRsmpBand] );
					fltP2 = FLOAT_FROM_FASTFLOAT( fflt );
					flt   = ( (iUnRsmpEnd-iCurrStart)*fltP1*fltP1 + (iCurrEnd-iUnRsmpEnd)*fltP2*fltP2 ) / (iCurrEnd - iCurrStart);
					fltBandWeight[cNoiseBand] = flt;
					MONITOR_COUNT(gMC_GBW_floats,13);
				}
			}
			cNoiseBand++;
		}
        iCurrBand++;
	}
	for( iCurrBand = 0; iCurrBand < (cNoiseBand-1); iCurrBand++ )
	{	
		if ( fAllBandsSynced )
		{
			fflt = ffltMaskPower10( rgiMaskQ4BandNotCoded[iCurrBand] - rgiMaskQ4BandNotCoded[cNoiseBand-1] );
			flt  = FLOAT_FROM_FASTFLOAT( fflt );
			rgffltSqrtBWRatio[iCurrBand] = fflt;
			//// float SqrtBWRatio = fflt.iFraction*1.0F/(1<<fflt.iFracBits)
		}
		else
		{
			// This calculation is not ideally suited to FastFloat, leave in float for time being
			// But note that limited range of the result probably means it can be done more quickly
			flt = (Float)sqrt( fltBandWeight[iCurrBand] / fltBandWeight[cNoiseBand-1] );
			fflt = FASTFLOAT_FROM_FLOAT( flt );
			rgffltSqrtBWRatio[iCurrBand] = fflt;
			//// float SqrtBWRatio = fflt.iFraction*1.0F/(1<<fflt.iFracBits)
		}
		MONITOR_RANGE(gMR_rgffltSqrtBWRatio,FLOAT_FROM_FASTFLOAT(fflt));
		MONITOR_COUNT(gMC_GBW_floats,14);		// count sqrt as 10.
	}
	if (cNoiseBand > 0)
	{	// last band has a ratio of 1.0

#if defined(BUILD_INTEGER) || defined(INTEGER_ENCODER)
		rgffltSqrtBWRatio[cNoiseBand-1].iFraction = 0x40000000;
		rgffltSqrtBWRatio[cNoiseBand-1].iFracBits = 30;
#else
		rgffltSqrtBWRatio[cNoiseBand-1] = 1.0F;
#endif
		MONITOR_RANGE(gMR_rgffltSqrtBWRatio,1.0F);
	}

	assert (cNoiseBand < pau->m_cValidBarkBand);
	assert (pau->m_iFirstNoiseBand > 0);
	rgbBandNotCoded [0] = cNoiseBand;				// used as cNoiseBand
    FUNCTION_PROFILE_STOP(&fp);
}


#pragma warning (disable:4554)

//*********************************************************************************************************
// Verify CoefRecon MidRate
// Debug code which simulates V4 floating point code.
// If decoded inputs are in error, false verifications can occur.
// include this by defining VERIFY_DECODED_COEFS below or in the project file
//*********************************************************************************************************
//#define VERIFY_DECODED_COEFS
#if defined(_DEBUG) && defined(VERIFY_DECODED_COEFS)
#	pragma COMPILER_MESSAGE(__FILE__ "(837) : Warning - Inverse Quantize MidRate Verification Code Enabled.")
static int fIgnoreMRVerification = 0;		// avoid verify checks - set by hand in debugger only
static Float fltMidRateThreshold = 0.025F;		// change from the debugger
void VerifyCoefReconMR( CAudioObject* pau, PerChannelInfo* ppcinfo, 
					  int iRecon, int iBark, int iBarkResampled, I32 qrand, I32 iCoefRecon, int iCoefQ,
					  const U8* const rgbBandNotCoded, int iNoiseBand, int cNoiseBand, 
					  const Int* const rgiNoisePower, const FastFloat* const rgffltSqrtBWRatio, const int* const m_rgiBarkIndex )
{	// stolen and adapted from V4 
	if ( !fIgnoreMRVerification  )
	{
		Float fltiCoefRecon = (Float)iCoefRecon/(1<<TRANSFORM_FRACT_BITS);
		Float fltNoise = ((Float) qrand / (Float) 0x20000000);
		Float fltWeightRatio = (float)pow(10,(ppcinfo->m_rgiMaskQ[iBarkResampled] - ppcinfo->m_iMaxMaskQ)/16.0);
		double dblQuantStep = DOUBLE_FROM_QUANTSTEPTYPE(pau->m_qstQuantStep);
		Float dif, rel, fltCoefRecon;
		Float fltNoisePower;
		double dblWeightedQuant;
		if (!pau->m_fNoiseSub) {
			if (iRecon < pau->m_cLowCutOff  || iRecon >= pau->m_cHighCutOff) 
				fltCoefRecon = 0;
			else
    			fltCoefRecon = (Float)( (Float)iCoefQ  * ( dblWeightedQuant = fltWeightRatio * dblQuantStep ) );
		}
		else
		{
			if (iRecon < pau->m_cLowCutOff)  
			{
				fltNoise *= pau->m_fltDitherLevel;
				fltCoefRecon = (Float)(fltNoise * (dblWeightedQuant = fltWeightRatio * dblQuantStep ) );
			}
			else if (iRecon >= pau->m_iFirstNoiseIndex && iBark < NUM_BARK_BAND && rgbBandNotCoded [iBark] == 1 )
			{
				fltNoisePower = ((Float) pow (10, rgiNoisePower [iNoiseBand] / 20.0F)) * 
									FloatFromFastFloat( rgffltSqrtBWRatio[iNoiseBand] );
				fltCoefRecon = fltNoise * (Float)(dblWeightedQuant = fltNoisePower * fltWeightRatio);
			}
			else if ( iRecon >= pau->m_cHighCutOff )  
			{
				fltNoise *= pau->m_fltDitherLevel;
				fltCoefRecon = (Float)(fltNoise * (dblWeightedQuant = fltWeightRatio * dblQuantStep) );
			}
			else 
			{
				fltNoise *= pau->m_fltDitherLevel;
				fltCoefRecon = (Float)((iCoefQ + fltNoise) * (dblWeightedQuant = fltWeightRatio * dblQuantStep) );
			}
		}
		dif = (float) fabs(fltCoefRecon - fltiCoefRecon);
		rel = (float) fabs( (fabs(fltCoefRecon)>32) ? (dif/fltCoefRecon) : (dif/32) );
		if (rel > ((dblWeightedQuant>131072.0) ? 10.0f*fltMidRateThreshold : fltMidRateThreshold) )
			DEBUG_BREAK();
		else 
		{	// when magnitude of integer version is much larger than float, we sometimes see differences
			// expect some false triggers, but often there is a relevant difference
			dif = (float)( fabs(fltiCoefRecon) - fabs(fltCoefRecon) );
			rel = (float) fabs( (fabs(fltCoefRecon)>32) ? (dif/fltCoefRecon) : (dif/32) );
			if ( dif > 75.0f && rel > 0.000125f )		// verify with all1_22s_22
				DEBUG_BREAK();
			else if ( fabs(fltCoefRecon) > (2.0F*(1<<30)) )
				DEBUG_BREAK();	// Overflow that should have been caught above
		}
	}
	MONITOR_RANGE(gMR_CoefRecon,iCoefRecon/((Float)(1<<TRANSFORM_FRACT_BITS)));
	MONITOR_RANGE(gMR_WeightRatio, (float)pow(10,(ppcinfo->m_rgiMaskQ[iBarkResampled] - ppcinfo->m_iMaxMaskQ)/16.0));
	MONITOR_COUNT_CONDITIONAL(iCoefRecon==0,gMC_zeroCoefRecon,1);
#	if defined(PRINT_INVERSE_QUANTIZE_AT_FRAME_FIRST)
		if ( PRINT_INVERSE_QUANTIZE_AT_FRAME_FIRST <= iInvQuantFrameCount && iInvQuantFrameCount <= PRINT_INVERSE_QUANTIZE_AT_FRAME_LAST )
			MyOutputDbgStr(0,"%5d  %2d  %1d  %4d  %+16.6f\n", 
				iInvQuantFrameCount, iInvQuantSubFrameCount, ppcinfo-pau->m_rgpcinfo, iRecon, iCoefRecon/((Float)(1<<TRANSFORM_FRACT_BITS)) );
#	endif
}
#define VERIFY_COEF_RECON_MR(idx,qRand,cNBand,iBarkRsmp)																			\
	 VerifyCoefReconMR(	pau, ppcinfo, iRecon, iBark, iBarkRsmp, qRand, rgiCoefRecon[iRecon], rgiCoefQ[iCoefQ],						\
						rgbBandNotCoded, iNoiseBand, cNBand, rgiNoisePower, ppcinfo->m_rgffltSqrtBWRatio, pau->m_rgiBarkIndex )
#elif defined(_DEBUG) && defined(WMA_MONITOR)
#define VERIFY_COEF_RECON_MR(idx,qRand,cNBand,iBarkRsmp)																			\
	MONITOR_RANGE(gMR_CoefRecon,FLOAT_FROM_COEF(rgiCoefRecon[iRecon]));											\
	MONITOR_RANGE(gMR_WeightRatio, (float)pow(10,(ppcinfo->m_rgiMaskQ[iBarkRsmp] - ppcinfo->m_iMaxMaskQ)/16.0F));					\
	MONITOR_COUNT_CONDITIONAL(rgiCoefRecon[iRecon]==0,gMC_zeroCoefRecon,1);
#elif defined(PRINT_INVERSE_QUANTIZE_AT_FRAME_FIRST)
#define VERIFY_COEF_RECON_MR(idx,qRand,cNBand,iBarkRsmp)                                                                                \
	if ( PRINT_INVERSE_QUANTIZE_AT_FRAME_FIRST <= iInvQuantFrameCount && iInvQuantFrameCount <= PRINT_INVERSE_QUANTIZE_AT_FRAME_LAST )  \
		MyOutputDbgStr(0,"%5d  %2d  %1d  %4d  %+16.6f\n",                                                                                         \
			iInvQuantFrameCount, iInvQuantSubFrameCount, ppcinfo-pau->m_rgpcinfo, iRecon, FLOAT_FROM_COEF(rgiCoefRecon[iRecon]) )
#else	// so not ( defined(_DEBUG) && defined(VERIFY_DECODED_COEFS) )
#define VERIFY_COEF_RECON_MR(idx,qRand,cNBand,iBarkRsmp)
#endif	// defined(_DEBUG) && defined(VERIFY_DECODED_COEFS)


// **********************************************************************
// Macros for DecodeCoefsMidRate with combined INTEGER and INT_FLOAT code

#if defined(BUILD_INTEGER) || defined(INTEGER_ENCODER)

#define MASK_X_QUANT(iLevel,ffltQuantizer) MULT_HI(((iLevel)<<16),ffltQuantizer.iFraction)
#define RAND_X_QUANT(rnd,ffltQuantizer) MULT_HI((rnd),ffltQuantizer.iFraction)
#define UNNORMED_MULT(fflt,c,shift) \
	fflt.iFraction = MULT_HI( fflt.iFraction, c );	\
	fflt.iFracBits += shift;

// SCALE_COEF_RECON shifts CoefRecon to give it TRANSFORM_FRACT_BITS==5 fractional bits
#if defined(PLATFORM_OPTIMIZE_MINIMIZE_BRANCHING)
	// This SCALE_COEF_RECON macro requires 6 ops and no branches
	// This SETUP_FOR_SCALE_COEF_RECON requires 5 ops plus 1 branch.
	// SCALE_COEFFICENT gets executed 25x as often as SETUP_FOR_SCALE_COEF_RECON, 
	// so this method requires 6.2 ops plus 0.04 branches per SCALE_COEFFICENT
#	define SCALE_COEF_RECON(iCR) ((((iCR)>>-iShift) & iMask2) | (((iCR)<<iShift) & iMask1))
//#	define SETUP_FOR_SCALE_COEF_RECON(iFB) iShift = iFB-TRANSFORM_FRACT_BITS;  \
//								      iMask2 = 0xFFFFFFFF ^ (iMask1 = (iShift>=0) ? 0xFFFFFFFF : 0)
// See comment below
#	define SETUP_FOR_SCALE_COEF_RECON(fftQ) iShift = fftQ.iFracBits-TRANSFORM_FRACT_BITS;  \
								      iMask2 = 0xFFFFFFFF ^ (iMask1 = (iShift>=0) ? 0xFFFFFFFF : 0)

#else
	// When branching is not a high penaty activity, do it the simplier way
	//   iCoefRecon = (t=iFracBits-5)<0 ? iCoefRecon>>-t : iCoefRecon<<t
	// This SCALE_COEF_RECON requires 3 ops plus 1 branch or 2 ops plus 1 branch.  
	// This SETUP_FOR_SCALE_COEF_RECON requires 2 ops
	// SCALE_COEFFICENT gets executed 25x as often as SETUP_FOR_SCALE_COEF_RECON, 
	// so this method requires 2.58 ops plus 0.04 branches per SCALE_COEFFICENT
	// On one test on a 500 MHz Pentium 686, this way saves 1% execution time over masking.
#	define SCALE_COEF_RECON(iCR) (iShift<0) ? (iCR)<<-iShift : (iCR)>>iShift
//#	define SETUP_FOR_SCALE_COEF_RECON(iFB) iShift=iFB-TRANSFORM_FRACT_BITS
// This more complex setup (with pre-normalization) is required to deal with 56_WMAv2.wma which ends
// with 1.5 seconds of DC bias at -890.  This results in a single large coef at 0 and the rest 0.
// Then in the noise band, iShift tries to be == 33...
#	define SETUP_FOR_SCALE_COEF_RECON(fftQ) \
    while( fftQ.iFracBits > (30+TRANSFORM_FRACT_BITS) ) { fftQ.iFracBits--; fftQ.iFraction>>=1; } \
    iShift=fftQ.iFracBits-TRANSFORM_FRACT_BITS;
#endif

#define COEF_PLUS_NOISE_FRAC_BITS 22
#define DITHER_FRAC_BITS 35
#define RAND_FRAC_BITS 29
#define MORE_WF_FRAC_BITS 0

const I32 cDitherFactorMR = 0x28F5C28F;		// BARK 0.02 * 2^35 (but I am not sure how to derive the 35)
#define RAND_TO_NOISE(qr) qr

// Inverse Quantize for "normal" case of CoefQ and Noise Dithering
static INLINE void CoefPlusNoiseInvQuant( const Int iRecon, const Int iCoefQ, I32 qrand, 
										  const I16* rgiCoefQ, I32* rgiCoefRecon, FastFloat ffltQuantizer, Int iShift )
{
	Int iNoise, iCoefPlusNoise, iCoefRecon;
	
	// Multiply by Dither and align iNoise fractional bits to be COEF_PLUS_NOISE_FRAC_BITS == 22
	iNoise = MULT_HI(cDitherFactorMR,qrand)>>((DITHER_FRAC_BITS+RAND_FRAC_BITS-31)-COEF_PLUS_NOISE_FRAC_BITS);
	//// Float Noise = iNoise/(1.0F*(1<<22))
	if ( abs(rgiCoefQ[iCoefQ]) >= (1<<(31-COEF_PLUS_NOISE_FRAC_BITS))  )
	{	// rare, but it does happen occasionally (e.g. tough_32m_32)
		Int iFB = 0;
		UInt uiCoefQ = abs(rgiCoefQ[iCoefQ]);
		while( uiCoefQ >= (1<<(31-COEF_PLUS_NOISE_FRAC_BITS)) )
		{
			uiCoefQ >>= 1;
			iFB++;
		}
		iCoefPlusNoise = (rgiCoefQ[iCoefQ]<<(COEF_PLUS_NOISE_FRAC_BITS-iFB)) + (iNoise>>iFB);
		//// Float Coef+Noise = iCoefPlusNoise/(1.0F*(1<<(22-iFB)))
		iCoefRecon = MULT_HI( iCoefPlusNoise, ffltQuantizer.iFraction );
		//// Float qrand = qrand/(1024.0F*(1<<25))
#if defined(BUILD_INTEGER) || defined(INTEGER_ENCODER)
        ffltQuantizer.iFracBits -= iFB;
		SETUP_FOR_SCALE_COEF_RECON(ffltQuantizer);
        ffltQuantizer.iFracBits += iFB;
#endif
		rgiCoefRecon [iRecon] = SCALE_COEF_RECON(iCoefRecon);
		//// Float CoefRecon = rgiCoefRecon[iRecon]/32.0F
		SETUP_FOR_SCALE_COEF_RECON(ffltQuantizer);
	}
	else
	{
		iCoefPlusNoise = (rgiCoefQ[iCoefQ]<<COEF_PLUS_NOISE_FRAC_BITS) + iNoise;	
		//// Float Coef+Noise = iCoefPlusNoise/(1.0F*(1<<22))
		iCoefRecon = MULT_HI( iCoefPlusNoise, ffltQuantizer.iFraction );
		//// Float qrand = qrand/(1024.0F*(1<<25))
		rgiCoefRecon [iRecon] = SCALE_COEF_RECON(iCoefRecon);
		//// Float CoefRecon = rgiCoefRecon[iRecon]/32.0F
	}
}

#else   // so must be BUILD_INT_FLOAT

#define MASK_X_QUANT(iLevel,ffltQuantizer) ((iLevel)*(ffltQuantizer))
#define RAND_X_QUANT(rnd,ffltQuantizer) ((rnd)*(ffltQuantizer))
#define UNNORMED_MULT(flt,c,shift) flt *= c

#define SCALE_COEF_RECON(iCR) (iCR)
#define SETUP_FOR_SCALE_COEF_RECON(ffltQ)

const Float cDitherFactorMR = 0.02F;		            // BARK_MODE: 0.02
const Float cfltInverseRand2Float = 1.0f/0x20000000;		// 2^-29

#define RAND_TO_NOISE(qr) (qr * cfltInverseRand2Float)

// Inverse Quantize for "normal" case of CoefQ and Noise Dithering
#ifdef HITACHI
#pragma inline(CoefPlusNoiseInvQuant)
static  void CoefPlusNoiseInvQuant( const Int iRecon, const Int iCoefQ, I32 qrand, 
										  const I16* rgiCoefQ, CoefType* rgiCoefRecon, QuantFloat qfltQuantizer, Int iShift )
#else
static INLINE void CoefPlusNoiseInvQuant( const Int iRecon, const Int iCoefQ, I32 qrand, 
										  const I16* rgiCoefQ, CoefType* rgiCoefRecon, QuantFloat qfltQuantizer, Int iShift )
#endif
{
	Float fltNoise =  qrand * (cDitherFactorMR * cfltInverseRand2Float);
	rgiCoefRecon [iRecon] = (rgiCoefQ[iCoefQ] + fltNoise) * qfltQuantizer;
}

#endif


WMARESULT prvInitNoiseSub (CAudioObject* pau)
{
    Int iWin, iBand;
    Float fltSamplingPeriod;

    Int *piBarkIndex;
    Int cFrameSample;
    Int iNoiseIndex;

    pau->m_fNoiseSub = WMAB_TRUE;
    pau->m_fltFirstNoiseFreq = (Float)(pau->m_iSamplingRate*0.5f);
    // adjust...
    // HongCho: This is related to Bark bands (re-adjust when Bark bands change)
    if(pau->m_iVersion == 1) {

        // version 1 was incorrectly using the inequalities...
        // do not change!!!

        if(pau->m_iSamplingRate == 22050) {
            // somewhat different parameters...
            if (pau->m_fltWeightedBitsPerSample >= 1.16f)
                pau->m_fNoiseSub = WMAB_FALSE;
            else if(pau->m_fltWeightedBitsPerSample >= 0.72f)
                pau->m_fltFirstNoiseFreq *= (Float)0.70;
            else
                pau->m_fltFirstNoiseFreq *= (Float)0.60;
        }
        else if (pau->m_iSamplingRate == 44100) {
            if (pau->m_fltWeightedBitsPerSample >= 0.61f)
                pau->m_fNoiseSub = WMAB_FALSE;
            else
                pau->m_fltFirstNoiseFreq *= (Float) 0.4;
        }
        else if (pau->m_iSamplingRate == 16000) {
            if (pau->m_fltBitsPerSample <= 0.5f)
                pau->m_fltFirstNoiseFreq *= (Float) 0.30;
            else {
                pau->m_fltFirstNoiseFreq *= (Float) 0.50;
                pau->m_iNoisePeakIgnoreBand = 3;
            }
        }
        else if (pau->m_iSamplingRate == 11025) {
            assert(1 == pau->m_iNoisePeakIgnoreBand);
            pau->m_fltFirstNoiseFreq *= (Float) 0.70;
            if (pau->m_fltBitsPerSample >= 0.9f)
                pau->m_iNoisePeakIgnoreBand = 3;
        }
        else if (pau->m_iSamplingRate == 8000) {
            assert(1 == pau->m_iNoisePeakIgnoreBand);
            if (pau->m_fltBitsPerSample <=0.625f)
                pau->m_fltFirstNoiseFreq *= (Float) 0.50;
            else if (pau->m_fltBitsPerSample <= 0.75f)
                pau->m_fltFirstNoiseFreq *= (Float) 0.65;
            else
                pau->m_fNoiseSub = WMAB_FALSE;
        }
        else {
            if(pau->m_fltBitsPerSample >= 0.8f)
                pau->m_fltFirstNoiseFreq *= (Float)0.75;
            else if(pau->m_fltBitsPerSample >= 0.6f)
                pau->m_fltFirstNoiseFreq *= (Float)0.60;
            else
                pau->m_fltFirstNoiseFreq *= (Float)0.5;
        }

    }
    else {

        // for newer versions...  more correct using inequality...

        if (pau->m_iSamplingRate >= 44100) {
            if (pau->m_fltWeightedBitsPerSample >= 0.61f)
                pau->m_fNoiseSub = WMAB_FALSE;
            else
                pau->m_fltFirstNoiseFreq *= (Float) 0.4;
        }
        else if(pau->m_iSamplingRate >= 22050) {
            // somewhat different parameters...
            if (pau->m_fltWeightedBitsPerSample >= 1.16f)
                pau->m_fNoiseSub = WMAB_FALSE;
            else if(pau->m_fltWeightedBitsPerSample >= 0.72f)
                pau->m_fltFirstNoiseFreq *= (Float)0.70;
            else
                pau->m_fltFirstNoiseFreq *= (Float)0.60;
        }
        else if (pau->m_iSamplingRate >= 16000) {
            if (pau->m_fltBitsPerSample <= 0.5f)
                pau->m_fltFirstNoiseFreq *= (Float) 0.30;
            else {
                pau->m_fltFirstNoiseFreq *= (Float) 0.50;
                pau->m_iNoisePeakIgnoreBand = 3;
            }
        }
        else if (pau->m_iSamplingRate >= 11025) {
            assert(1 == pau->m_iNoisePeakIgnoreBand);
            pau->m_fltFirstNoiseFreq *= (Float) 0.70;
            if (pau->m_fltBitsPerSample >= 0.9f)
                pau->m_iNoisePeakIgnoreBand = 3;
        }
        else if (pau->m_iSamplingRate >= 8000) {
            assert(1 == pau->m_iNoisePeakIgnoreBand);
            if (pau->m_fltBitsPerSample <=0.625f)
                pau->m_fltFirstNoiseFreq *= (Float) 0.50;
            else if (pau->m_fltBitsPerSample <= 0.75f)
                pau->m_fltFirstNoiseFreq *= (Float) 0.65;
            else
                pau->m_fNoiseSub = WMAB_FALSE;
        }
        else {
            if(pau->m_fltBitsPerSample >= 0.8f)
                pau->m_fltFirstNoiseFreq *= (Float)0.75;
            else if(pau->m_fltBitsPerSample >= 0.6f)
                pau->m_fltFirstNoiseFreq *= (Float)0.60;
            else
                pau->m_fltFirstNoiseFreq *= (Float)0.5;
        }
    }

	if (!pau->m_fNoiseSub)
        return WMA_OK;

    pau->m_rgiFirstNoiseBand = (Int*) auMalloc (sizeof (Int) * pau->m_cPossibleWinSize);
    if(pau->m_rgiFirstNoiseBand == NULL)
        return TraceResult(WMA_E_OUTOFMEMORY);
    pau->m_rgbBandNotCoded	= (U8*) auMalloc (pau->m_cValidBarkBand * pau->m_cChannel);	
    if (pau->m_rgbBandNotCoded == NULL)
        return TraceResult(WMA_E_OUTOFMEMORY);
    pau->m_rgiNoisePower	= (Int*) auMalloc (sizeof (Int) * pau->m_cValidBarkBand * pau->m_cChannel);
    if (pau->m_rgiNoisePower == NULL)
        return TraceResult(WMA_E_OUTOFMEMORY);
#ifndef BUILD_INTEGER
    pau->m_rgfltBandWeight	= (Float*) auMalloc (sizeof (Float) * pau->m_cValidBarkBand * pau->m_cChannel);
    if (pau->m_rgfltBandWeight == NULL)
        return TraceResult(WMA_E_OUTOFMEMORY);
#endif
    pau->m_rgffltSqrtBWRatio	= (FastFloat*) auMalloc (sizeof (FastFloat) * pau->m_cValidBarkBand * pau->m_cChannel);
    if (pau->m_rgffltSqrtBWRatio == NULL)
        return TraceResult(WMA_E_OUTOFMEMORY);

    //calculate index of each bark freq
    fltSamplingPeriod = 1.0F / pau->m_iSamplingRate;
    // wchen: we need to think what to do with the cut off frequencies: not include at all or include zeros.
    //for long window
    piBarkIndex = pau->m_rgiBarkIndexOrig;

    // for the v1 compatibility
    if(pau->m_iVersion == 1)
    {
        // precalculate the first noise bands
        // wchen: who put these two lines here? No use!
        //pau->m_rgiFirstNoiseBand[0] = (Int)(pau->m_fltFirstNoiseFreq*pau->m_cFrameSample*fltSamplingPeriod + 0.5);
        //if(pau->m_rgiFirstNoiseBand[0] > pau->m_cSubband) pau->m_rgiFirstNoiseBand[0] = pau->m_cSubband;
        for(iBand = 0; iBand < pau->m_rgcValidBarkBand[0]; iBand++) {
            if(g_rgiBarkFreq[iBand] > (Int)ftoi(pau->m_fltFirstNoiseFreq)) {
                pau->m_rgiFirstNoiseBand[0] = iBand;
                break;
            }
        }
        // if not there, turn it off...
        if(iBand == pau->m_rgcValidBarkBand[0])
            pau->m_fNoiseSub = WMAB_FALSE;
    }
    else
    {
        for (iWin = 0; iWin < pau->m_cPossibleWinSize; iWin++)    {
            // precalculate the first noise bands
            pau->m_rgiFirstNoiseBand[iWin] = pau->m_rgcValidBarkBand[iWin] - 1;// init to max...
            cFrameSample = pau->m_cFrameSample / (1 << iWin);
            iNoiseIndex = (Int)ftoi(pau->m_fltFirstNoiseFreq*cFrameSample*fltSamplingPeriod + 0.5f);
            for(iBand = 1; iBand < pau->m_rgcValidBarkBand[iWin]; iBand++) {
                if(piBarkIndex[iBand] > iNoiseIndex) {
                    pau->m_rgiFirstNoiseBand[iWin] = iBand - 1;
                    break;
                }
            }
            piBarkIndex +=  NUM_BARK_BAND + 1;
        }
    }
    pau->m_iFirstNoiseBand = pau->m_rgiFirstNoiseBand[0];    
    return WMA_OK;
}

//#define PRINT_RESAMPLE_WEIGHT_FACTOR 100000000
#	ifdef PRINT_RESAMPLE_WEIGHT_FACTOR
		// this function must be defined in fft.c
		extern void DebugDctPrintCoefs(CAudioObject* pau, int def, int id, float fac, CoefType* pfCoef);
#		define WFR_PRINT(id,pfCoef)  \
		DebugDctPrintCoefs(pau,PRINT_RESAMPLE_WEIGHT_FACTOR,id,1.0f*(1<<WEIGHTFACTOR_FRACT_BITS),(CoefType*)pfCoef)
#   else
#       define WFR_PRINT(id,pfCoef)
#   endif

Void auResampleWeightFactorLPC (CAudioObject* pau, PerChannelInfo* ppcinfo)
{
    Int iRatio;
    Int i, j;

    UInt*  rguiWeightFactor = ppcinfo->m_rguiWeightFactor;
    Int iSizeSrc = pau->m_subfrmconfigCurr.m_rgiSubFrameSize [pau->m_iCurrSubFrame - 1];
    Int iSizeDst = pau->m_subfrmconfigCurr.m_rgiSubFrameSize [pau->m_iCurrSubFrame];
    assert (pau->m_iCurrSubFrame > 0);
#ifndef BUILD_INTEGER
	assert( sizeof(Int) == sizeof(Float) );		// rgfltWegihtFactor == rgiWeightFactor
#endif

    // This should only be called for LPC mode. Bark mode resamples weight factor
    // from the original weight factor array to avoid losing information.
    assert(LPC_MODE == pau->m_iWeightingMode);

    if (iSizeSrc > iSizeDst) {
        //downsample
        iRatio = iSizeSrc / iSizeDst;
        i = 0;
        while (i < pau->m_cSubband) {
            rguiWeightFactor [i] = rguiWeightFactor [i * iRatio];
            i++;
        }
    }
    else if (iSizeSrc < iSizeDst) {
        //upsample
        iRatio = iSizeDst / iSizeSrc;
        i = pau->m_cSubband / iRatio - 1;
        while (i >= 0) {
            for (j = 0; j < iRatio; j++)    {
                rguiWeightFactor [i * iRatio + j] = rguiWeightFactor [i];
            }
            i--;
        }                
    }
    //if == don't need to do anything
	WFR_PRINT(iSizeSrc > iSizeDst ? 5 :(iSizeSrc < iSizeDst ? 6 : 7),rguiWeightFactor);
}


#ifdef ENCODER
Void auResampleWeightFactorBark (CAudioObject* pau, PerChannelInfo* ppcinfo)
{
    const Int *rgiBarkIndexLastUpdate = pau->m_rgiBarkIndexOrig + (NUM_BARK_BAND + 1) *
        LOG2 (pau->m_cFrameSampleHalf / pau->m_iSubFrameSizeWithUpdate);
    const Int cValidBarkBandLastUpdate = pau->m_rgcValidBarkBand [LOG2 (pau->m_cFrameSampleHalf /
        pau->m_iSubFrameSizeWithUpdate)];

    const Int c_iMaskResampleFB = 12;
    const Int c_iRoundUp = (1 << c_iMaskResampleFB) - 1;
    const Int iMaskResampleRatio = (pau->m_iSubFrameSizeWithUpdate << 12) /                           
                          pau->m_subfrmconfigCurr.m_rgiSubFrameSize [pau->m_iCurrSubFrame];
    const Int iIndexResampleRatio =
        (pau->m_subfrmconfigCurr.m_rgiSubFrameSize [pau->m_iCurrSubFrame] << 12) /
        pau->m_iSubFrameSizeWithUpdate;

    const Int cSubbandActual  = ppcinfo->m_cSubbandActual;

    U32*    rguiWeightFactor = ppcinfo->m_rguiWeightFactor;
    U32*    rguiWeightFactorPerBark = (U32 *) ppcinfo->m_rgfltWeightFactorPerBark;
    Int     i;
    Int     iNextBoundary;
    Int     iCurrBark;

    // Some assumptions made above
    assert(sizeof(U32) == sizeof(ppcinfo->m_rgfltWeightFactorPerBark[0]));
    assert(sizeof(U32) == sizeof(ppcinfo->m_rguiWeightFactor[0]));

    // This should only be called for bark mode
    assert(BARK_MODE == pau->m_iWeightingMode);

    iCurrBark = 0;
    i = 0;
    do
    {
        const Int   c_iResampledIdx = ((i * iMaskResampleRatio) >> c_iMaskResampleFB);
        U32         uiWeightFactor;

        // Advance bark index until we find one that maps past current i
        while (c_iResampledIdx >= rgiBarkIndexLastUpdate[iCurrBark])
            iCurrBark++;

        // iCurrBark currently points to the NEXT bark band
        assert(iCurrBark <= cValidBarkBandLastUpdate);
        assert(rgiBarkIndexLastUpdate[iCurrBark] >= 0 &&
            rgiBarkIndexLastUpdate[iCurrBark] <= 2048);
        iNextBoundary = ((rgiBarkIndexLastUpdate[iCurrBark] * iIndexResampleRatio) +
            c_iRoundUp) >> c_iMaskResampleFB;

        if (iNextBoundary > cSubbandActual)
            iNextBoundary = cSubbandActual; // Any work done past cSubbandActual is wasted

        // Make iCurrBark point to current bark band again
        iCurrBark -= 1;

        // Propagate new weight factor. We never touch rgfltWeightFactorPerBark
        // and so using it is equivalent to resampling from last updated weight factors.
        uiWeightFactor = rguiWeightFactorPerBark[iCurrBark];

        assert(iNextBoundary > i);
        assert(iNextBoundary <= cSubbandActual);
        for ( ; i < iNextBoundary; i++)
            rguiWeightFactor[i] = uiWeightFactor;

    } while (i < cSubbandActual);

#ifdef _DEBUG
    memset(&rguiWeightFactor[cSubbandActual], 0xCD, (pau->m_cSubband - cSubbandActual) *
        sizeof(rguiWeightFactor[0]));
#endif  // _DEBUG

}

#endif  // ENCODER


//**************************************************************************************************
//
// prvInverseQuantizeMidRate handles only MidRate inverse quantization
//
// rgiWeightFactor is not used.
//
//**************************************************************************************************
WMARESULT prvInverseQuantizeMidRate (CAudioObject* pau, PerChannelInfo* ppcinfo, Int* rgiWeightFactor)
{
	Int iBark = 0;					// index barks using natural scale for this cSubband (at this sampling frequency)
	Int iBarkResampled = 0;			// index barks using resampled scale from cSubbands when the MaskQ's were last updated
	Int iCoefQ = 0;
	Int iRecon = 0;
    const I16* rgiCoefQ				= ppcinfo->m_rgiCoefQ;
    const U8*  rgbBandNotCoded		= ppcinfo->m_rgbBandNotCoded;
    const Int* rgiNoisePower		= ppcinfo->m_rgiNoisePower;
	const FastFloat* rgffltSqrtBWRatio	= ppcinfo->m_rgffltSqrtBWRatio;
	const Int* rgiMaskQ				= ppcinfo->m_rgiMaskQ;
	const Int  iMaxMaskQ			= ppcinfo->m_iMaxMaskQ;
    const Int *rgiBarkIndex;
	const Int *rgiBarkIndexResampled;
    CoefType* rgiCoefRecon			= (CoefType*)ppcinfo->m_rgiCoefRecon;
	CoefType iCoefRecon; 
    Int qrand, iReconTarget;
    U8  cNoiseBand = rgbBandNotCoded [0];
    Int iNoiseBand = 0;
    QuantFloat qfltQuantizer;
	MaskResampleInfo MRI;
#if defined(PLATFORM_OPTIMIZATION_MINIMIZE_BRANCHING) && defined(BUILD_INTEGER)
    Int iMask1, iMask2;
#endif
    Int iShift = 0;
#if defined (SMOOTH_NMR)
    Bool *rgfMaskNeededForBark = ppcinfo->m_rgfMaskNeededForBark;
	// A mask value of a bark should be preserved if that bark:
	// (1) is needed for mask resampling,
	// (2) not coded (noise substituted),
	// (3) has a coded coeff with non-zero value,
	// (4) or has the maximum mask value used in normalization.
#endif // SMOOTH_NMR
    
    FUNCTION_PROFILE(fp);
    FUNCTION_PROFILE_START(&fp,INVERSE_QUAN_MID_RATE_PROFILE);

	DEBUG_BREAK_AT_FRAME_INV_QUANT;
	MONITOR_COUNT(gMC_IQ,1);
    assert (pau->m_fNoiseSub &&  pau->m_iWeightingMode == BARK_MODE);
    assert(TRANSFORM_FRACT_BITS==5);
    assert (pau->m_subfrmconfigCurr.m_rgiSubFrameSize [pau->m_iCurrSubFrame] != 0);         
    // assert (pau->m_cFrameSampleHalf <= (1<<MASKQ_RESAMPLE_OFFSET));       // why???                                  
    assert (pau->m_iSubFrameSizeWithUpdate != 0);                                           
	assert( pau->m_cPossibleWinSize <= MASKQ_RESAMPLE_OFFSET );
    
#if defined (SMOOTH_NMR)
    // Initially, no bark-mask needs to be preserved.
    memset(rgfMaskNeededForBark, 0, 25 * sizeof(Bool));
#endif //  SMOOTH_NMR
    
	// handle changing subFrame window sizes by resampling the indexes
    MRI.iMaskResampleRatio = (pau->m_iSubFrameSizeWithUpdate << MASKQ_RESAMPLE_OFFSET) /                           
                          pau->m_subfrmconfigCurr.m_rgiSubFrameSize [pau->m_iCurrSubFrame];    
    
	MRI.iMaskResampleRatioPow = LOG2(MRI.iMaskResampleRatio);
    rgiBarkIndexResampled     = pau->m_rgiBarkIndexOrig + (NUM_BARK_BAND + 1) *                    
                                  LOG2 (pau->m_cFrameSampleHalf / pau->m_iSubFrameSizeWithUpdate);   
    MRI.cValidBarkBandLatestUpdate = pau->m_rgcValidBarkBand [LOG2 (pau->m_cFrameSampleHalf / pau->m_iSubFrameSizeWithUpdate)];

	rgiBarkIndex  = pau->m_rgiBarkIndexOrig + (NUM_BARK_BAND + 1) * pau->m_iIncr;  

	prvGetBandWeightMidRate (pau, ppcinfo, rgiBarkIndex, rgiBarkIndexResampled, MRI);

    //Scan for the first bark index = note iRecon is 0 and rgiBarkIndex[1] ==0 for 16000 Hz and 11025 Hz frames with 128 or 64 samples
	prvScanForNextBarkIndex( iRecon, &iBarkResampled, pau->m_cLowCutOff, rgiBarkIndexResampled, MRI );
	while( iRecon >= rgiBarkIndex[iBark+1] )
		iBark++;

	if (iRecon < pau->m_cLowCutOff ) {
		// not integerized since cLowCutOff is typically 0, so this is here for compatability with V1 
		Double dblQuantStep = DOUBLE_FROM_QUANTSTEPTYPE(pau->m_qstQuantStep);
		Float fltCoefRecon;
		while  (iRecon < pau->m_cLowCutOff) 	{
			Float fltNoise = pau->m_fltDitherLevel * ((Float) quickRand (&(pau->m_tRandState)) / (Float) 0x20000000);//rgfltNoise [iRecon];
			Float fltWeightRatio = (float)pow(10.0f,(rgiMaskQ[iBarkResampled] - iMaxMaskQ)/16.0f);
			fltCoefRecon  = (Float) (fltNoise * fltWeightRatio * dblQuantStep);
			rgiCoefRecon [iRecon] = COEF_FROM_FLOAT(fltCoefRecon);
			MONITOR_COUNT(gMC_IQ_Float,9);
			iRecon++;
		}
	}

    while  (iRecon < pau->m_iFirstNoiseIndex) 
    {
        iReconTarget = prvScanForNextBarkIndex( iRecon, &iBarkResampled, pau->m_iFirstNoiseIndex, rgiBarkIndexResampled, MRI );
        
        qfltQuantizer = prvWeightedQuantization( pau, ppcinfo, iBarkResampled );
        INTEGER_ONLY( qfltQuantizer.iFracBits += COEF_PLUS_NOISE_FRAC_BITS - 31 );      // Account for MULT_HI in loop below
        //// Float Quantizer = qfltQuantizer.iFraction/(512.0F*(1<<qfltQuantizer.iFracBits)
        SETUP_FOR_SCALE_COEF_RECON(qfltQuantizer);              
        
        while ( iRecon < iReconTarget )
        {   
            //  CoefRecon[iR] = (CoefQ[iQ] + rand()*DitherLevel) * (10^(1/16)) ^ (MaskQ[iB]-Max(MaskQ[])) * (10^(1/20)) ^ QuantStepSize
            qrand = quickRand (&(pau->m_tRandState));       
            //// Float qrand = qrand/(1024.0F*(1<<25))
            CoefPlusNoiseInvQuant( iRecon, iCoefQ, qrand, rgiCoefQ, rgiCoefRecon, qfltQuantizer, iShift );
            //// Float CoefRecon = rgiCoefRecon[iRecon]/32.0F
            
            VERIFY_COEF_RECON_MR(iRecon,qrand,-1,iBarkResampled);
#if defined (SMOOTH_NMR)
            if (rgiCoefQ[iCoefQ]) rgfMaskNeededForBark[iBark] = WMAB_TRUE;
#endif // SMOOTH_NMR
            
            iRecon++;
            iCoefQ++;
        }
        if (iResampleIndex (iRecon+1, MRI) >= rgiBarkIndexResampled [iBarkResampled+1]) 
            iBarkResampled++;       // normal to increment except when hitting FirstNoiseIndex
        while( iRecon >= rgiBarkIndex[iBark+1] )
            iBark++;
    }
    
    while  (iRecon < pau->m_cHighCutOff) 
    {   // These Bands may or may not be coded, treat as appropriate
        
        if ( (rgbBandNotCoded [iBark] == 1))
        {   
            Int iLoopMax;
            
            
            // CoefRecon[iR] = rand() * ((10^(1/16)) ^ (MaskQ[iB]-Max(MaskQ[])) * sqrt( BandWeight[iN]/BandWeight[cN-1] ) * ((10^(1/20)) ^ NoisePower[iN])
            // Note BandsNotCoded span whole "natural" bark bands, which are not resampled and are not limited by m_cHighCutOff
            FastFloat ffltMaskPower, ffltNoisePower;
            
#if defined (SMOOTH_NMR)
            rgfMaskNeededForBark[iBark] = WMAB_TRUE;
#endif // SMOOTH_NMR

            assert( iNoiseBand < cNoiseBand );
            
            // auCalcQuantStep( rgiNoisePower[iNoiseBand], &ffltNoisePower.iFraction, &ffltNoisePower.iFracBits );
            ffltNoisePower = FASTFLOAT_FROM_QUANTSTEPTYPE( qstCalcQuantStep( rgiNoisePower[iNoiseBand] ) );
            ffltNoisePower = FASTFLOAT_MULT( ffltNoisePower, rgffltSqrtBWRatio[iNoiseBand] );
            //// Float Noise Power = ffltNoisePower.iFraction/(4.0F*(1<<ffltNoisePower.iFracBits))
            
            iLoopMax = min(rgiBarkIndex[iBark+1], pau->m_cHighCutOff);
            while(iRecon < iLoopMax)
            {
                ffltMaskPower = ffltMaskPower10( rgiMaskQ[iBarkResampled] - iMaxMaskQ );
                //// Float Mask Power = ffltMaskPower.iFraction/(1.0F*(1<<ffltMaskPower.iFracBits))
                
                qfltQuantizer = FASTFLOAT_MULT( ffltMaskPower, ffltNoisePower );
                INTEGER_ONLY( qfltQuantizer.iFracBits += (RAND_FRAC_BITS - 31) );       // Account for MULT_HI in loop below
                //// Float Quantizer = qfltQuantizer.iFraction/(4.0F*(1<<qfltQuantizer.iFracBits))
                SETUP_FOR_SCALE_COEF_RECON(qfltQuantizer);
                
                iReconTarget = prvScanForNextBarkIndex( iRecon, &iBarkResampled, iLoopMax, rgiBarkIndexResampled, MRI );
                while ( iRecon < iReconTarget )
                {   
                    qrand = quickRand (&(pau->m_tRandState));
                    //// Float qrand = qrand/(1024.0F*(1<<25))
                    iCoefRecon = RAND_X_QUANT( RAND_TO_NOISE(qrand), qfltQuantizer );
                    //// Float CoefRecon = iCoefRecon/(1.0F*(1<<qfltQuantizer.iFracBits))
                    rgiCoefRecon [iRecon] = SCALE_COEF_RECON(iCoefRecon);
                    //// Float CoefRecon = rgiCoefRecon[iRecon]/32.0F
                    
                    VERIFY_COEF_RECON_MR(iRecon,qrand,cNoiseBand,iBarkResampled);
                    
                    iRecon++;
                }
                if (iResampleIndex (iRecon+1, MRI) >= rgiBarkIndexResampled [iBarkResampled+1]) 
                    iBarkResampled++;       // normal to increment except when hitting end of Bark Band
            }
            iNoiseBand++;
        }
        else 
        {   // This Band is Coded (just like those before FirstNoiseIndex)
            // CoefRecon[iR] = (CoefQ[iQ] + rand()*DitherLevel) * 10^(MaskQ[iB]-Max(MaskQ[]))*2.5*0.5/20 * 10^(QuantStepSize/20)
            iReconTarget = prvScanForNextBarkIndex( iRecon, &iBarkResampled, pau->m_cHighCutOff, rgiBarkIndexResampled, MRI );
            if ( iReconTarget > rgiBarkIndex [iBark + 1] )
                iReconTarget = rgiBarkIndex [iBark + 1];        
            qfltQuantizer = prvWeightedQuantization( pau, ppcinfo, iBarkResampled );
            //// Float Quantizer = qfltQuantizer.iFraction/(1.0F*(1<<qfltQuantizer.iFracBits))
            // account for MULT_HI in loop below
            INTEGER_ONLY( qfltQuantizer.iFracBits += COEF_PLUS_NOISE_FRAC_BITS - 31 );
            //// Float Quantizer = qfltQuantizer.iFraction/(512.0F*(1<<qfltQuantizer.iFracBits))
            SETUP_FOR_SCALE_COEF_RECON(qfltQuantizer);
            
            while ( iRecon < iReconTarget )
            {   
                //  CoefRecon[iR] = (CoefQ[iQ] + rand()*DitherLevel) * (10^(1/16)) ^ (MaskQ[iB]-Max(MaskQ[])) * (10^(1/20)) ^ QuantStepSize
                qrand = quickRand (&(pau->m_tRandState));
                //// Float qrand = qrand/(1024.0F*(1<<25))
                CoefPlusNoiseInvQuant( iRecon, iCoefQ, qrand, rgiCoefQ, rgiCoefRecon, qfltQuantizer, iShift );
                //// Float CoefRecon = rgiCoefRecon[iRecon]/32.0F
                
#if defined (SMOOTH_NMR)
                if (rgiCoefQ[iCoefQ]) rgfMaskNeededForBark[iBark] = WMAB_TRUE;
#endif // SMOOTH_NMR

                VERIFY_COEF_RECON_MR(iRecon,qrand,-1,iBarkResampled);
                
                iRecon++;
                iCoefQ++;
            }
        }
        if (iResampleIndex (iRecon+1, MRI) >= rgiBarkIndexResampled [iBarkResampled+1]) 
            iBarkResampled++;       // normal to increment except when hitting HighCutOff
        while( iRecon >= rgiBarkIndex[iBark+1] )
            iBark++;
    }
    
    iReconTarget = pau->m_cSubband;
    if  (iRecon < iReconTarget) 
    {   //  CoefRecon[iR] = rand() * DitherLevel * (10^(1/16)) ^ (MaskQ[iB for HighCutOff-1]-Max(MaskQ[])) * (10^(1/20)) ^ QuantStepSize
        // We may have scaned past m_cHighCutOff doing a BandNotCoded, so search back to find it.
        while ( (((pau->m_cHighCutOff-1) << MRI.iMaskResampleRatioPow) >> MASKQ_RESAMPLE_OFFSET) < rgiBarkIndexResampled [iBarkResampled] ) 
            --iBarkResampled;
        
        qfltQuantizer = prvWeightedQuantization( pau, ppcinfo, iBarkResampled );
        //// Float Quantizer = qfltQuantizer.iFraction/(1.0F*(1<<qfltQuantizer.iFracBits))
        UNNORMED_MULT( qfltQuantizer, cDitherFactorMR, (DITHER_FRAC_BITS - 31) + (RAND_FRAC_BITS - 31) );
        //// Float Quantizer = qfltQuantizer.iFraction/(4.0F*(1<<qfltQuantizer.iFracBits))
        SETUP_FOR_SCALE_COEF_RECON(qfltQuantizer);
        
        while ( iRecon < iReconTarget )
        {   
            qrand = quickRand (&(pau->m_tRandState));
            //// Float qrand = qrand/(1024.0F*(1<<25))
            iCoefRecon = RAND_X_QUANT( RAND_TO_NOISE(qrand), qfltQuantizer );
            //// Float CoefRecon = iCoefRecon/(1.0F*(1<<qfltQuantizer.iFracBits))
            rgiCoefRecon [iRecon] = SCALE_COEF_RECON(iCoefRecon);
            //// Float CoefRecon = rgiCoefRecon[iRecon]/32.0F
            
            VERIFY_COEF_RECON_MR(iRecon,qrand,cNoiseBand,iBarkResampled);
            
            iRecon++;
        }
    }

#   if defined(REFERENCE_RAND_24) || defined(REFERENCE_RAND_16)
        // call the random generator one extra time per subframe to improve subband randomness
        quickRand (&(pau->m_tRandState));
#   endif

#   if defined (SMOOTH_NMR)
        // rgfMaskNeededForBark[bark corresponding to HighCutOff-1 should be made true. 
        for (iBark = pau->m_rgcValidBarkBand [pau->m_iIncr]-1; iBark >= 0; iBark--) {
            if ((pau->m_cHighCutOff >= rgiBarkIndex[iBark]) && (pau->m_cHighCutOff < rgiBarkIndex[iBark+1])) {
                rgfMaskNeededForBark[iBark] = WMAB_TRUE;
                break; 
            }
        }
#   endif // SMOOTH_NMR
    
    FUNCTION_PROFILE_STOP(&fp);
	return WMA_OK;
}


#if defined(ENCODER) && defined(SMOOTH_NMR) && !defined(INTEGER_ENCODER) && !defined(BUILD_INTEGER)
WMARESULT prvInverseQuantizeMidRateSkipNoise (CAudioObject* pau, PerChannelInfo* ppcinfo,
                                              Int* rgiWeightFactor, Bool fSkipNoise)
{
	Int iBark = 0;					// index barks using natural scale for this cSubband (at this sampling frequency)
	Int iBarkResampled = 0;			// index barks using resampled scale from cSubbands when the MaskQ's were last updated
	Int iCoefQ = 0;
	Int iRecon = 0;
    const I16* rgiCoefQ				= ppcinfo->m_rgiCoefQ;
    const U8*  rgbBandNotCoded		= ppcinfo->m_rgbBandNotCoded;
    const Int* rgiNoisePower		= ppcinfo->m_rgiNoisePower;
	const FastFloat* rgffltSqrtBWRatio	= ppcinfo->m_rgffltSqrtBWRatio;
	const Int* rgiMaskQ				= ppcinfo->m_rgiMaskQ;
	const Int  iMaxMaskQ			= ppcinfo->m_iMaxMaskQ;
    const Int *rgiBarkIndex;
	const Int *rgiBarkIndexResampled;
    CoefType* rgiCoefRecon			= (CoefType*)ppcinfo->m_rgiCoefRecon;
    Int iReconTarget;
    U8  cNoiseBand = rgbBandNotCoded [0];
    Int iNoiseBand = 0;
    QuantFloat qfltQuantizer;
	MaskResampleInfo MRI;
#if defined(PLATFORM_OPTIMIZATION_MINIMIZE_BRANCHING) && defined(BUILD_INTEGER)
    Int iMask1, iMask2;
#endif
    Int iShift = 0;
#if defined (SMOOTH_NMR)
    Bool *rgfMaskNeededForBark = ppcinfo->m_rgfMaskNeededForBark;
    // A mask value of a bark should be preserved if that bark:
    // (1) is needed for mask resampling,
    // (2) not coded (noise substituted),
    // (3) has a coded coeff with non-zero value,
    // (4) or has the maximum mask value used in normalization.
#endif // SMOOTH_NMR    
    
    FUNCTION_PROFILE(fp);
    FUNCTION_PROFILE_START(&fp,INVERSE_QUAN_MID_RATE_PROFILE);

	DEBUG_BREAK_AT_FRAME_INV_QUANT;
	MONITOR_COUNT(gMC_IQ,1);
    assert (pau->m_fNoiseSub &&  pau->m_iWeightingMode == BARK_MODE);
    assert(TRANSFORM_FRACT_BITS==5);
    assert (pau->m_subfrmconfigCurr.m_rgiSubFrameSize [pau->m_iCurrSubFrame] != 0);         
    // assert (pau->m_cFrameSampleHalf <= (1<<MASKQ_RESAMPLE_OFFSET));       // why???                                  
    assert (pau->m_iSubFrameSizeWithUpdate != 0);                                           
	assert( pau->m_cPossibleWinSize <= MASKQ_RESAMPLE_OFFSET );
    
    // Initially, no bark-mask needs to be preserved.
#if defined (SMOOTH_NMR)
    memset(rgfMaskNeededForBark, 0, 25 * sizeof(Bool));
#endif // SMOOTH_NMR
    
	// handle changing subFrame window sizes by resampling the indexes
    MRI.iMaskResampleRatio = (pau->m_iSubFrameSizeWithUpdate << MASKQ_RESAMPLE_OFFSET) /                           
                          pau->m_subfrmconfigCurr.m_rgiSubFrameSize [pau->m_iCurrSubFrame];    
    
	MRI.iMaskResampleRatioPow = LOG2(MRI.iMaskResampleRatio);
    rgiBarkIndexResampled     = pau->m_rgiBarkIndexOrig + (NUM_BARK_BAND + 1) *                    
                                  LOG2 (pau->m_cFrameSampleHalf / pau->m_iSubFrameSizeWithUpdate);   
    MRI.cValidBarkBandLatestUpdate = pau->m_rgcValidBarkBand [LOG2 (pau->m_cFrameSampleHalf / pau->m_iSubFrameSizeWithUpdate)];

	rgiBarkIndex  = pau->m_rgiBarkIndexOrig + (NUM_BARK_BAND + 1) * pau->m_iIncr;  

	prvGetBandWeightMidRate (pau, ppcinfo, rgiBarkIndex, rgiBarkIndexResampled, MRI);

    //Scan for the first bark index = note iRecon is 0 and rgiBarkIndex[1] ==0 for 16000 Hz and 11025 Hz frames with 128 or 64 samples
	prvScanForNextBarkIndex( iRecon, &iBarkResampled, pau->m_cLowCutOff, rgiBarkIndexResampled, MRI );
    while( iRecon >= rgiBarkIndex[iBark+1] )
        iBark++;
    
    if (iRecon < pau->m_cLowCutOff ) {
        // not integerized since cLowCutOff is typically 0, so this is here for compatability with V1 
        Double dblQuantStep = DOUBLE_FROM_QUANTSTEPTYPE(pau->m_qstQuantStep);
        Float fltCoefRecon;
        
        while  (iRecon < pau->m_cLowCutOff)     {
            Float fltNoise = pau->m_fltDitherLevel * ((Float) quickRand (&(pau->m_tRandState)) / (Float) 0x20000000);//rgfltNoise [iRecon];
            Float fltWeightRatio = (float)pow(10.0f,(rgiMaskQ[iBarkResampled] - iMaxMaskQ)/16.0f);
            fltCoefRecon  = (Float) (fltNoise * fltWeightRatio * dblQuantStep);
            rgiCoefRecon [iRecon] = COEF_FROM_FLOAT(fltCoefRecon);
            MONITOR_COUNT(gMC_IQ_Float,9);
            iRecon++;
        }
    }
    
    while  (iRecon < pau->m_iFirstNoiseIndex) 
    {
        iReconTarget = prvScanForNextBarkIndex( iRecon, &iBarkResampled, pau->m_iFirstNoiseIndex, rgiBarkIndexResampled, MRI );
        
        qfltQuantizer = prvWeightedQuantization( pau, ppcinfo, iBarkResampled );
        INTEGER_ONLY( qfltQuantizer.iFracBits += COEF_PLUS_NOISE_FRAC_BITS - 31 );      // Account for MULT_HI in loop below
        //// Float Quantizer = qfltQuantizer.iFraction/(512.0F*(1<<qfltQuantizer.iFracBits)
        SETUP_FOR_SCALE_COEF_RECON(qfltQuantizer);              
        
        while ( iRecon < iReconTarget )
        {   
            rgiCoefRecon[iRecon] = (rgiCoefQ[iCoefQ] + ppcinfo->m_rgfltDitherNoise[iRecon]) *
                qfltQuantizer;
            
#if defined (SMOOTH_NMR)
            if (rgiCoefQ[iCoefQ]) rgfMaskNeededForBark[iBark] = WMAB_TRUE;
#endif // SMOOTH_NMR
            
            iRecon++;
            iCoefQ++;
        }
        if (iResampleIndex (iRecon+1, MRI) >= rgiBarkIndexResampled [iBarkResampled+1]) 
            iBarkResampled++;       // normal to increment except when hitting FirstNoiseIndex
        while( iRecon >= rgiBarkIndex[iBark+1] )
            iBark++;
    }
    
    while  (iRecon < pau->m_cHighCutOff) 
    {   // These Bands may or may not be coded, treat as appropriate
        
        if ( (rgbBandNotCoded [iBark] == 1))
        {   
            Int iLoopMax;
            
            iLoopMax = min(rgiBarkIndex[iBark+1], pau->m_cHighCutOff);
            
#if defined (SMOOTH_NMR)
            rgfMaskNeededForBark[iBark] = WMAB_TRUE;
#endif // SMOOTH_NMR
            
            if (WMAB_FALSE == fSkipNoise)
            {
                // CoefRecon[iR] = rand() * ((10^(1/16)) ^ (MaskQ[iB]-Max(MaskQ[])) * sqrt( BandWeight[iN]/BandWeight[cN-1] ) * ((10^(1/20)) ^ NoisePower[iN])
                // Note BandsNotCoded span whole "natural" bark bands, which are not resampled and are not limited by m_cHighCutOff
                FastFloat ffltMaskPower, ffltNoisePower;
                assert( iNoiseBand < cNoiseBand );
                
                // auCalcQuantStep( rgiNoisePower[iNoiseBand], &ffltNoisePower.iFraction, &ffltNoisePower.iFracBits );
                ffltNoisePower = FASTFLOAT_FROM_QUANTSTEPTYPE( qstCalcQuantStep( rgiNoisePower[iNoiseBand] ) );
                ffltNoisePower = FASTFLOAT_MULT( ffltNoisePower, rgffltSqrtBWRatio[iNoiseBand] );
                //// Float Noise Power = ffltNoisePower.iFraction/(4.0F*(1<<ffltNoisePower.iFracBits))
                
                while(iRecon < iLoopMax)
                {
                    ffltMaskPower = ffltMaskPower10( rgiMaskQ[iBarkResampled] - iMaxMaskQ );
                    //// Float Mask Power = ffltMaskPower.iFraction/(1.0F*(1<<ffltMaskPower.iFracBits))
                    
                    qfltQuantizer = FASTFLOAT_MULT( ffltMaskPower, ffltNoisePower );
                    INTEGER_ONLY( qfltQuantizer.iFracBits += (RAND_FRAC_BITS - 31) );       // Account for MULT_HI in loop below
                    //// Float Quantizer = qfltQuantizer.iFraction/(4.0F*(1<<qfltQuantizer.iFracBits))
                    SETUP_FOR_SCALE_COEF_RECON(qfltQuantizer);
                    
                    iReconTarget = prvScanForNextBarkIndex( iRecon, &iBarkResampled, iLoopMax, rgiBarkIndexResampled, MRI );
                    while ( iRecon < iReconTarget )
                    {   
                        rgiCoefRecon [iRecon] = ppcinfo->m_rgfltDitherNoise[iRecon] * 
                            qfltQuantizer;
                        iRecon++;
                    }
                    if (iResampleIndex (iRecon+1, MRI) >= rgiBarkIndexResampled [iBarkResampled+1]) 
                        iBarkResampled++;       // normal to increment except when hitting end of Bark Band
                }
            }
            else
                iRecon = iLoopMax;
            
            iNoiseBand++;
        }
        else 
        {   // This Band is Coded (just like those before FirstNoiseIndex)
            // CoefRecon[iR] = (CoefQ[iQ] + rand()*DitherLevel) * 10^(MaskQ[iB]-Max(MaskQ[]))*2.5*0.5/20 * 10^(QuantStepSize/20)
            iReconTarget = prvScanForNextBarkIndex( iRecon, &iBarkResampled, pau->m_cHighCutOff, rgiBarkIndexResampled, MRI );
            if ( iReconTarget > rgiBarkIndex [iBark + 1] )
                iReconTarget = rgiBarkIndex [iBark + 1];        
            qfltQuantizer = prvWeightedQuantization( pau, ppcinfo, iBarkResampled );
            //// Float Quantizer = qfltQuantizer.iFraction/(1.0F*(1<<qfltQuantizer.iFracBits))
            // account for MULT_HI in loop below
            INTEGER_ONLY( qfltQuantizer.iFracBits += COEF_PLUS_NOISE_FRAC_BITS - 31 );
            //// Float Quantizer = qfltQuantizer.iFraction/(512.0F*(1<<qfltQuantizer.iFracBits))
            SETUP_FOR_SCALE_COEF_RECON(qfltQuantizer);
            
            while ( iRecon < iReconTarget )
            {   
                rgiCoefRecon[iRecon] = (rgiCoefQ[iCoefQ] + ppcinfo->m_rgfltDitherNoise[iRecon]) *
                    qfltQuantizer;
                
#if defined (SMOOTH_NMR)
                if (rgiCoefQ[iCoefQ]) rgfMaskNeededForBark[iBark] = WMAB_TRUE;
#endif // SMOOTH_NMR

                iRecon++;
                iCoefQ++;
            }
        }
        if (iResampleIndex (iRecon+1, MRI) >= rgiBarkIndexResampled [iBarkResampled+1]) 
            iBarkResampled++;       // normal to increment except when hitting HighCutOff
        while( iRecon >= rgiBarkIndex[iBark+1] )
            iBark++;
    }
    
    iReconTarget = pau->m_cSubband;
    if  (iRecon < iReconTarget) 
    {   //  CoefRecon[iR] = rand() * DitherLevel * (10^(1/16)) ^ (MaskQ[iB for HighCutOff-1]-Max(MaskQ[])) * (10^(1/20)) ^ QuantStepSize
        // We may have scaned past m_cHighCutOff doing a BandNotCoded, so search back to find it.
        while ( (((pau->m_cHighCutOff-1) << MRI.iMaskResampleRatioPow) >> MASKQ_RESAMPLE_OFFSET) < rgiBarkIndexResampled [iBarkResampled] ) 
            --iBarkResampled;
        
        qfltQuantizer = prvWeightedQuantization( pau, ppcinfo, iBarkResampled );
        //// Float Quantizer = qfltQuantizer.iFraction/(1.0F*(1<<qfltQuantizer.iFracBits))
        UNNORMED_MULT( qfltQuantizer, cDitherFactorMR, (DITHER_FRAC_BITS - 31) + (RAND_FRAC_BITS - 31) );
        //// Float Quantizer = qfltQuantizer.iFraction/(4.0F*(1<<qfltQuantizer.iFracBits))
        SETUP_FOR_SCALE_COEF_RECON(qfltQuantizer);
        
        while ( iRecon < iReconTarget )
        {   
            rgiCoefRecon[iRecon] = qfltQuantizer * ppcinfo->m_rgfltDitherNoise[iRecon];
            iRecon++;
        }
    }
    
#if defined (SMOOTH_NMR)
    // rgfMaskNeededForBark[bark corresponding to HighCutOff-1 should be made true. 
    for (iBark = pau->m_rgcValidBarkBand [pau->m_iIncr]-1; iBark >= 0; iBark--) {
        if ((pau->m_cHighCutOff >= rgiBarkIndex[iBark]) && (pau->m_cHighCutOff < rgiBarkIndex[iBark+1])) {
            rgfMaskNeededForBark[iBark] = WMAB_TRUE;
            break; 
        }
    }
#endif // SMOOTH_NMR
    
    FUNCTION_PROFILE_STOP(&fp);
	return WMA_OK;
} // prvInverseQuantizeMidRateSkipNoise
#endif  // defined(ENCODER) && defined(SMOOTH_NMR) && !defined(INTEGER_ENCODER) && !defined(BUILD_INTEGER)


#pragma warning (default:4554)


#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\wmalib\wmadec_s\msaudio.c ===
/*************************************************************************

Copyright (C) Microsoft Corporation, 1996 - 1999

Module Name:

    MsAudio.cpp

Abstract:

    Implementation of public member functions for CAudioObject.

Author:

    Wei-ge Chen (wchen) 11-March-1998

Revision History:


*************************************************************************/

#pragma code_seg("WMADEC")
#pragma data_seg("WMADEC_RW")
#pragma const_seg("WMADEC_RD")

// Print out the target we're building for
#define COMMONMACROS_OUTPUT_TARGET

#if !defined (_WIN32_WCE) && !defined (HITACHI)
#include <time.h>
#endif  // _WIN32_WCE

#include <math.h>
#include <limits.h>
#include <stdio.h>
#include "msaudio.h"
#include "AutoProfile.h"
#include "macros.h"
#include "float.h"
#include "cpudetect.h"
#include "wmamath.h"
#include "..\..\..\dsound\dsndver.h"

//*****************************************************************************************
// Forward Function Declarations
//*****************************************************************************************

void prvInitDiscardSilence(CAudioObject *pau);
void prvDiscardSilence(CAudioObject *pau, U16 *pcSampleDecoded,
                       U16 iChannels, U8 *pbBuf);
void prvSetAdjustedValues(CAudioObject *pau, Int fQToo);
void prvFFT4DCT(CoefType data[], Int nLog2np);


//*****************************************************************************************
//
// msaudioGetSamplePerFrame
//
//*****************************************************************************************
I32 msaudioGetSamplePerFrame (Int   cSamplePerSec, 
                              U32   dwBitPerSec, 
                              Int   cNumChannels,
                              Int   iVersion) 
{
    //return NEW samples coming into a frame; actual samples in a frame
    //should be * 2 due to 50% overlapping window
    I32 cSamplePerFrame;
    U32 dwBytesPerFrame;

        //don't know what to do
    if (dwBitPerSec == 0 || iVersion > 2)
        return 0;

    if (cSamplePerSec <= 8000)
        cSamplePerFrame = 512;
    else if (cSamplePerSec <= 11025)
        cSamplePerFrame = 512;
    else if (cSamplePerSec <= 16000) {
        cSamplePerFrame = 512;
    }
    else if (cSamplePerSec <= 22050) {
        cSamplePerFrame = 1024;
    }
    else if (cSamplePerSec <= 32000) {
        if(iVersion == 1)
            cSamplePerFrame = 1024;
        else
            cSamplePerFrame = 2048;
    }
    else if (cSamplePerSec <= 44100)
        cSamplePerFrame = 2048;
    else if (cSamplePerSec <= 48000)
        cSamplePerFrame = 2048;
    else
        return 0;
    dwBytesPerFrame = (U32) (((cSamplePerFrame*dwBitPerSec + cSamplePerSec/2)/cSamplePerSec + 7)/8);
    if ( dwBytesPerFrame==0 && (cSamplePerFrame*dwBitPerSec) == 0 ) {
        // this can happen when garbage data sets dwBitsPerSec to a very large number
        // avoid an infinite loop below
        dwBitPerSec = cSamplePerSec;
        dwBytesPerFrame = (U32) (((cSamplePerFrame*dwBitPerSec + cSamplePerSec/2)/cSamplePerSec + 7)/8);
    }
    if (dwBytesPerFrame <= 1) {   //silence mode
        while (dwBytesPerFrame == 0) {
            cSamplePerFrame *= 2;           //save more bits; quartz can't take too big a value
            dwBytesPerFrame = (U32) (((cSamplePerFrame*dwBitPerSec + cSamplePerSec/2)/cSamplePerSec + 7)/8);
        }
    }
    return cSamplePerFrame;
}

//*****************************************************************************************
//
// MaxSamplesPerPacket
//   Returns the largest possible number of PCM samples that the decoder can produce
//   from a single compressed packet.  
//
//*****************************************************************************************
U32 MaxSamplesPerPacket(U32 ulVersion, U32 ulSamplingRate, U32 ulChannels, U32 ulBitrate) {
   return (16 + 1) * msaudioGetSamplePerFrame(ulSamplingRate,ulBitrate,ulChannels,ulVersion);
}

//*****************************************************************************************
//
// mallocAligned & freeAligned
// allocates a buffer of size bytes aligned to iAlignToBytes bytes.
//
//*****************************************************************************************
void *mallocAligned(size_t size,Int iAlignToBytes){
    Int mask = -1;                                    //Initally set mask to 0xFFFFFFFF
    void *retBuffer;
    void *buffer = auMalloc(size+iAlignToBytes);        //allocate buffer + alignment bytes
    if(buffer == NULL)
    {
        TraceResult(WMA_E_OUTOFMEMORY);
        return NULL;
    }
    assert(iAlignToBytes > 0);
    assert(iAlignToBytes < 256);
    mask <<= LOG2(iAlignToBytes);                     //Generate mask to clear lsb's
    retBuffer = (void*)(((Int)((U8*)buffer+iAlignToBytes))&mask);//Generate aligned pointer
    ((U8*)retBuffer)[-1] = (U8)((U8*)retBuffer-(U8*)buffer);//Write offset to newPtr-1
    return retBuffer;
}

void freeAligned(void *ptr){
    U8* realBuffer = (U8*)ptr;
    U8 bytesBack;
    if (realBuffer == NULL) return; 
    bytesBack = ((U8*)ptr)[-1];      //Get offset to real pointer from -1 possition
    realBuffer -= bytesBack;    //Get original pointer address
    free(realBuffer);
}



// ----- Memory Allocation Functions -----
#ifdef STATIC_MEMALLOC
// Global vars
static MEMALLOCSTATE    g_maState = MAS_DELETE;
static U8              *g_pBuffer = NULL;
static I32              g_iBufRemaining = 0;
static I32              g_iAllocCount = 0;

I32 auMallocGetCount(void)
{
    return g_iAllocCount;
}


void auMallocSetState(const MEMALLOCSTATE maState, void *pBuf, const I32 iBufSize)
{
    switch (maState)
    {
        case MAS_ALLOCATE:
            assert(MAS_DELETE == g_maState);
            g_pBuffer = (U8 *) pBuf;
            g_iBufRemaining = iBufSize;
            g_maState = MAS_ALLOCATE;
            break;

        case MAS_LOCKED:
            assert(MAS_ALLOCATE == g_maState);
            g_maState = MAS_LOCKED;
            break;

        case MAS_DELETE:
            g_maState = MAS_DELETE;
            break;

        default:
            assert(WMAB_FALSE);
            break;
    }
}


void *auMalloc(const size_t iSize)
{
    WMARESULT   wmaResult = WMA_OK;
    void       *pResult = NULL;

    switch (g_maState)
    {
        case MAS_ALLOCATE:

            if (NULL == g_pBuffer)
            {
                pResult = malloc(iSize);
                if (NULL == pResult)
                    wmaResult = TraceResult(WMA_E_OUTOFMEMORY);
            }
            else
            {
                if (iSize <= (U32) g_iBufRemaining)
                {
                    pResult = g_pBuffer;
                    g_pBuffer += iSize;
                    g_iBufRemaining -= iSize;
                }
                else
                {
                    wmaResult = TraceResult(WMA_E_OUTOFMEMORY);
                    assert(WMAB_FALSE);
                }
            }

            g_iAllocCount += iSize;
            break;

        default:
            wmaResult = TraceResult(WMA_E_FAIL);
            assert(WMAB_FALSE); // We should only be called during allocation
            break;
    }

    return pResult;
}

void auFree(void *pFree)
{
    assert(MAS_DELETE == g_maState);
    if (NULL == g_pBuffer)
        free(pFree);
}
#else   // STATIC_MEMALLOC

I32 auMallocGetCount(void)
{
    return 0;
}

void auMallocSetState(const MEMALLOCSTATE maState, void *pBuf, const I32 iBufSize)
{
}

void *auMalloc(const size_t iSize)
{
    return malloc(iSize);
}

void auFree(void *pFree)
{
    free(pFree);
}

#endif  // STATIC_MEMALLOC


//*****************************************************************************************
//
// auNew
// create and initialize a CAudioObject
//
//*****************************************************************************************
CAudioObject* auNew ()
{
    CAudioObject* pau = (CAudioObject*) auMalloc (sizeof (CAudioObject));
    if ( pau == NULL )
    {
        TraceResult(WMA_E_OUTOFMEMORY);
        return pau;
    }

    memset(&pau->m_qstQuantStep, 0, sizeof(pau->m_qstQuantStep)); // May be struct or float/double
    // memset(pau->m_rgiQuantStepFract, 0, sizeof(pau->m_rgiQuantStepFract));
    pau->m_iPacketCurr = 0;
    pau->m_cBitPackedFrameSize = 0;
    pau->m_cBitPacketHeader = 0;
    pau->m_cdwPacketHeader = 0;
    pau->m_cBitPacketHeaderFractionDw = 0;
    pau->m_cBitPacketLength = 0;
    pau->m_cRunOfZeros = 0;
    pau->m_iLevel = 0; 
    pau->m_iSign = 0;
    pau->m_iHighCutOffCurr = 0;
    pau->m_iNextBarkIndex = 0;

    pau->m_fNoiseSub = WMAB_FALSE; 
    pau->m_fltBitsPerSample = 0;
    pau->m_fltWeightedBitsPerSample = 0;

    pau->m_iMaxEscSize = 9;
    pau->m_iMaxEscLevel = (1 << pau->m_iMaxEscSize) - 1;

    pau->m_iVersion = 0;
    pau->m_codecStatus = CODEC_NULL;
    pau->m_fSeekAdjustment = WMAB_FALSE;
    pau->m_fPacketLossAdj = WMAB_FALSE;
    pau->m_iSamplingRate = 0;
    pau->m_cChannel = 0;
    pau->m_cSubband = 0;

    pau->m_fAllowSuperFrame = WMAB_FALSE;
    pau->m_fAllowSubFrame = WMAB_FALSE;
    pau->m_iCurrSubFrame = 0;
    pau->m_fHeaderReset = WMAB_TRUE;
    pau->m_iSubFrameSizeWithUpdate = 0;
    pau->m_iMaxSubFrameDiv = 1;
    pau->m_cMinSubFrameSample = 0;
    pau->m_cMinSubFrameSampleHalf = 0;
    pau->m_cMinSubFrameSampleQuad = 0;
    pau->m_cPossibleWinSize = 0;
    pau->m_iIncr = 0;
    pau->m_cSubFrameSample = 0;
    pau->m_cSubFrameSampleHalf = 0;
    pau->m_cSubFrameSampleQuad = 0;
    memset(&pau->m_subfrmconfigPrev, 0, sizeof(pau->m_subfrmconfigPrev));
    memset(&pau->m_subfrmconfigCurr, 0, sizeof(pau->m_subfrmconfigCurr));
    memset(&pau->m_subfrmconfigNext, 0, sizeof(pau->m_subfrmconfigNext));

    pau->m_cBitsSubbandMax = 0;
    pau->m_cFrameSample = 0;
    pau->m_cFrameSampleHalf = 0;
    pau->m_cFrameSampleQuad = 0;

    pau->m_cLowCutOff = 0;
    pau->m_cHighCutOff = 0;
    pau->m_cLowCutOffLong = 0;
    pau->m_cHighCutOffLong = 0;

    pau->m_iWeightingMode = LPC_MODE;
    pau->m_stereoMode = STEREO_LEFTRIGHT;
    pau->m_iEntropyMode = 0;
    pau->m_fltDitherLevel = 0.04F;
    pau->m_iQuantStepSize = (MIN_QUANT + MAX_QUANT - 1) / 2;
    pau->m_fltFlatenFactor = 0.5F;
    pau->m_fltDctScale = 0;
    pau->m_cValidBarkBand = 0;
    pau->m_rgiBarkIndex = NULL;

#if defined(BUILD_INTEGER) || defined(INTEGER_ENCODER)
    pau->m_iSinRampUpStart = 0;
    pau->m_iCosRampUpStart = 0;
    pau->m_iSinRampUpPrior = 0;
    pau->m_iCosRampUpPrior = 0;
    pau->m_iSinRampUpStep = 0;
    pau->m_iSinRampDownStart = 0;
    pau->m_iCosRampDownStart = 0;
    pau->m_iSinRampDownPrior = 0;
    pau->m_iCosRampDownPrior = 0;
    pau->m_iSinRampDownStep = 0;
    memset(pau->m_iSinInit, 0, sizeof(pau->m_iSinInit));
    memset(pau->m_iCosInit, 0, sizeof(pau->m_iCosInit));
#endif

#if !defined(BUILD_INTEGER) || defined(INTEGER_ENCODER)
    pau->m_fltSinRampUpStart = 0;
    pau->m_fltCosRampUpStart = 0;
    pau->m_fltSinRampUpPrior = 0;
    pau->m_fltCosRampUpPrior = 0;
    pau->m_fltSinRampUpStep = 0;
    pau->m_fltSinRampDownStart = 0;
    pau->m_fltCosRampDownStart = 0;
    pau->m_fltSinRampDownPrior = 0;
    pau->m_fltCosRampDownPrior = 0;
    pau->m_fltSinRampDownStep = 0;
#endif
#ifdef USE_SIN_COS_TABLES
    //MMX tables
    pau->m_piSinForRecon2048 = NULL;
    pau->m_piSinForRecon1024 = NULL;
    pau->m_piSinForRecon512 = NULL;
    pau->m_piSinForRecon256 = NULL;
    pau->m_piSinForRecon128 = NULL;
    pau->m_piSinForRecon64 = NULL;
    pau->m_piSinForRecon = NULL;
    pau->m_piSinForSaveHistory = NULL;
#endif

    pau->m_iSizePrev = 0;
    pau->m_iSizeCurr = 0;
    pau->m_iSizeNext = 0;

    pau->m_iCoefRecurQ1 = 0;
    pau->m_iCoefRecurQ2 = 0;
    pau->m_iCoefRecurQ3 = 0;
    pau->m_iCoefRecurQ4 = 0;

    pau->m_rgiCoefQ = NULL;

    pau->m_rgpcinfo = NULL;
    pau->m_rgiCoefReconOrig = NULL;
    pau->m_rgiMaskQ = NULL;
    pau->m_rgcValidBarkBand = NULL;
    pau->m_rgiBarkIndexOrig = NULL;


    pau->m_piPrevOutput = NULL;
    pau->m_iDiscardSilence = 0;

#ifdef TRANSCODER
    pau->m_ttTranscodeType = TT_NONE;
#endif  // TRANSCODER

#ifdef ENABLE_ALL_ENCOPT
    pau->m_fltFirstNoiseFreq = 0;
    pau->m_iFirstNoiseBand = 0;
    pau->m_iFirstNoiseIndex = 0;
    pau->m_iNoisePeakIgnoreBand = 1;

    pau->m_rgiFirstNoiseBand = NULL;
    pau->m_rgbBandNotCoded = NULL;
    pau->m_rgffltSqrtBWRatio = NULL;
    pau->m_rgiNoisePower = NULL;
    pau->m_rgfltBandWeight = NULL;

#if defined(_DEBUG) && defined(LPC_COMPARE)
    memset(pau->m_rgfltLpsSpecCos, 0, sizeof(pau->m_rgfltLpsSpecCos));
    memset(pau->m_rgfltLpsSpecSin, 0, sizeof(pau->m_rgfltLpsSpecSin));
#endif  // _DEBUG
#endif  // ENABLE_ALL_ENCOPT

    pau->m_rgfltWeightFactor = NULL;
    pau->m_rguiWeightFactor = NULL;

    pau->m_iFrameNumber = 0;

#if defined(INTERPOLATED_DOWNSAMPLE)
    pau->m_fLowPass = WMAB_FALSE;
    pau->m_fDownsample = WMAB_FALSE;
    pau->m_iInterpolSrcBlkSize = 0;
    pau->m_iInterpolDstBlkSize = 0;
    pau->m_iInterpolIncr = 0;
    pau->m_iInterpolCarry = 0;
    pau->m_iInterpolWeightIncr = 0;
    pau->m_iInterpolAddInterval = 0;
    pau->m_iInterpolNextAdd = 0;
#endif  // defined(INTERPOLATED_DOWNSAMPLE)

#if defined(HALF_TRANSFORM) || defined(PAD2X_TRANSFORM)
    pau->m_fHalfTransform = WMAB_FALSE;
    pau->m_fUpsample = WMAB_FALSE;
    pau->m_fPad2XTransform = WMAB_FALSE;
    memset(pau->m_iPriorSample, 0, sizeof(pau->m_iPriorSample));
    //pau->m_htiHalfPrevState.m_fSaved = WMAB_FALSE;
    //pau->m_htiPad2XPrevState.m_fSaved = WMAB_FALSE;
    pau->m_cSubbandAdjusted = 0;
    pau->m_cFrameSampleAdjusted = 0; 
    pau->m_cFrameSampleHalfAdjusted = 0;
    pau->m_cSubFrameSampleAdjusted = 0;
    pau->m_cSubFrameSampleHalfAdjusted = 0;
    pau->m_cSubFrameSampleQuadAdjusted = 0;
    pau->m_cHighCutOffAdjusted = 0;
#endif  // defined(HALF_TRANSFORM) || defined(PAD2X_TRANSFORM)

	pau->m_fIntelFFT = WMAB_FALSE;

#if !defined(BUILD_INTEGER) && !defined(UNDER_CE) && defined(WMA_TARGET_X86)
    pau->m_fIntelFFT = WMAB_FALSE;
#endif  // !defined(BUILD_INTEGER) && !defined(UNDER_CE) && defined(WMA_TARGET_X86)

#ifdef ENABLE_ALL_ENCOPT
    pau->aupfnInverseQuantize = prvInverseQuantizeMidRate;
#else
    pau->aupfnInverseQuantize = NULL;
#endif
    pau->prvpfnInverseTransformMono = NULL; // Not currently used
    pau->aupfnGetNextRun = NULL;

	RandStateClear(&(pau->m_tRandState));

    // OK, now verify the sizes of all fundamental type definitions
#ifndef __QNX__
    assert(sizeof(U64) == 8);
    assert(sizeof(I64) == 8);
#endif
    assert(sizeof(U32) == 4);
    assert(sizeof(I32) == 4);
    assert(sizeof(U16) == 2);
    assert(sizeof(I16) == 2);
    assert(sizeof(U8) == 1);
    assert(sizeof(I8) == 1);

    return pau;
}


//*****************************************************************************************
//
// auDelete
// delete a CAudioObject
//
//*****************************************************************************************
Void    auDelete (CAudioObject* pau)
{
    DELETE_ARRAY (pau->m_rgpcinfo);

    DELETE_ARRAY (pau->m_piPrevOutput);

    {
        freeAligned(pau->m_rgiCoefReconOrig);
        DELETE_ARRAY (pau->m_rguiWeightFactor);
        pau->m_rgfltWeightFactor = NULL;
    }
    DELETE_ARRAY (pau->m_rgcValidBarkBand);
    DELETE_ARRAY (pau->m_rgiBarkIndexOrig);
    DELETE_ARRAY (pau->m_rgiMaskQ);

#ifdef ENABLE_ALL_ENCOPT
    {
#if defined(_DEBUG) && defined(LPC_COMPARE)
        Int i;
        for (i = 0; i < LPCORDER; i++)  {
            if ( pau->m_rgfltLpsSpecCos[i] != NULL )
                DELETE_ARRAY (pau->m_rgfltLpsSpecCos[i]);
            if ( pau->m_rgfltLpsSpecSin[i] != NULL )
                DELETE_ARRAY (pau->m_rgfltLpsSpecSin[i]);
        }
#endif
        DELETE_ARRAY (pau->m_rgiFirstNoiseBand);
        DELETE_ARRAY (pau->m_rgbBandNotCoded);
        DELETE_ARRAY (pau->m_rgffltSqrtBWRatio);
        DELETE_ARRAY (pau->m_rgiNoisePower);
        DELETE_ARRAY (pau->m_rgfltBandWeight);
    }
#endif //ENABLE_ALL_ENCOPT

    DELETE_ARRAY (pau->m_rgiCoefQ);

#if !defined(_Embedded_x86)
#if defined(WMA_TARGET_X86) && !(defined(BUILD_INTEGER) || defined(UNDER_CE))
    if (pau->m_fIntelFFT)
    {
        WMARESULT wmaResult;

        wmaResult = auFreeIntelFFT(pau, INTELFFT_FREE_PROCESS);
        TraceError(wmaResult);
    }
#endif  // WMA_TARGET_X86 && !defined(BUILD_INTEGER)
#endif

    auFree (pau);

    DUMP_MONITOR_RANGES(0);
}


//*****************************************************************************************
//
// auInit
// initialize a CAudioObject based on information from input file or stream
//
//*****************************************************************************************
WMARESULT auInit (CAudioObject* pau, 
                Int iVersionNumber,
                Int cSubband, 
                Int cSamplePerSec, 
                U16 cChannel, 
#ifdef WMA_V9
                U32 nBytePerSample,
                U16 nValidBitsPerSample,
                U32 nChannelMask,
#endif // WMA_V9
                Int cBytePerSec, 
                Int cbPacketLength,
                U16 iEncodeOpt,
                U16 iPlayerOpt)
{
    U16 iNonSupportedPlayerOpt;
    WMARESULT   wmaResult = WMA_OK;

    //set up default pcinfo for noise sub

    static const char fOKOptions[16] = {
        // WinCE Player Option Combinations
        WMAB_TRUE,  // 0: normal
        WMAB_TRUE,  // 1: Device that does not support 32kHz sampling -> interpolated downsample to 22kHz
        WMAB_TRUE,  // 2: Background HalfTransform mode to save CPU cycles
        WMAB_TRUE,  // 3: Background HalfTransform mode on device that does not support 32kHz sampling, ends up at 11kHz
        WMAB_TRUE,  // 4: A slow CPU which does not support F0 but does support 2*F0
        WMAB_TRUE,  // 5: Device that does not support 32kHz sample nor 22kHz playback, plays 32kHz data via 22kHz quality at 44kHz
        WMAB_TRUE,  // 6: Background HalfTransform mode for device that does not support half sampling rate
        WMAB_TRUE,  // 7: Background with downsampling - why?
        WMAB_TRUE,  // 8: Hide HP-430's lack of a low-pass filter for 22kHz output
        WMAB_FALSE, // 9: not appropriate - would need to interpolate to 44kHz if appropriate
        WMAB_TRUE,  // A: Background HalfTransform mode on a HP-430 at 22kHz, decode as normal (neither half nor doubled)
        WMAB_TRUE,  // B: why but why not allow?? 
        WMAB_FALSE, // C: not appropriate
        WMAB_FALSE, // D: not appropriate
        WMAB_FALSE, // E: not appropriate
        WMAB_FALSE  // F: not appropriate
    };
    assert( PLAYOPT_DOWNSAMPLE32TO22==1 && PLAYOPT_HALFTRANSFORM==2 && PLAYOPT_UPSAMPLE==4 && PLAYOPT_PAD2XTRANSFORM==8 );

    pau->m_iVersion = iVersionNumber;

#   if defined(WMA_TARGET_MIPS) && defined(BUILD_INTEGER)
        if (pau->m_iVersion < 2 && cSamplePerSec >= 44100 ) {
            // bug 813 - mips integer code gets an integer overflow exception on V1 content 11/21/2000
            wmaResult = TraceResult(WMA_E_NOTSUPPORTED);
            goto exit;
        }
#   endif

    pau->m_iWeightingMode    = (iEncodeOpt & ENCOPT_BARK) ? BARK_MODE : LPC_MODE;
    pau->m_fV5Lpc = (iEncodeOpt & ENCOPT_V5LPC);
#ifndef ENABLE_LPC
    if (LPC_MODE == pau->m_iWeightingMode)
    {
        // This build of the codec does not support LPC!
        wmaResult = TraceResult(WMA_E_NOTSUPPORTED);
        goto exit;
    }
#endif  // ENABLE_LPC

#if !defined(WMA_V9)
    if ( cChannel>2 ) {
        // when we add 5.1 support, we don't want existing decoders to try to decode them
        wmaResult = TraceResult(WMA_E_NOTSUPPORTED);
        goto exit;
    }
#endif

    pau->m_fAllowSuperFrame  = !!(iEncodeOpt & ENCOPT_SUPERFRAME);
    pau->m_fAllowSubFrame    = pau->m_fAllowSuperFrame && !!(iEncodeOpt & ENCOPT_SUBFRAME);

    if (pau->m_fAllowSubFrame) {
        pau->m_iMaxSubFrameDiv = ((iEncodeOpt & ENCOPT_SUBFRAMEDIVMASK) >>
            ENCOPT_SUBFRAMEDIVSHR);
        if (cBytePerSec / cChannel >= 4000)
            pau->m_iMaxSubFrameDiv = (8 << pau->m_iMaxSubFrameDiv);
        else 
            pau->m_iMaxSubFrameDiv = (2 << pau->m_iMaxSubFrameDiv);
    }
    else 
        pau->m_iMaxSubFrameDiv = 1;
    if (pau->m_iMaxSubFrameDiv > cSubband / MIN_FRAME_SIZE)
        pau->m_iMaxSubFrameDiv = cSubband / MIN_FRAME_SIZE;

    assert(TRANSCODER_AB(WMAB_TRUE, 0 == (iEncodeOpt & ENCOPT_TRANSCODE)));
#ifdef TRANSCODER
    if (iEncodeOpt & ENCOPT_TRANSCODE)
        pau->m_ttTranscodeType = TT_SIMPLE;
#endif  // TRANSCODER

    // When using noise substitution for uncoded bark or frequency bands, 
    // m_fltDitherLevel sets an overall "gain" of the substitution noise
    if (pau->m_iWeightingMode == LPC_MODE)
        pau->m_fltDitherLevel = 0.04F;
    else // BARK_MODE
        pau->m_fltDitherLevel = 0.02F;

    // --- Handle player options ---
    // First, figure out if the player has asked us for an option that we
    // didn't build
    iNonSupportedPlayerOpt = ~0; // Turn everything on
    DOWNSAMPLE_ONLY(iNonSupportedPlayerOpt &= ~(PLAYOPT_DOWNSAMPLE32TO22));
    HALFTRANSFORM_ONLY(iNonSupportedPlayerOpt &= ~(PLAYOPT_HALFTRANSFORM));
    UPSAMPLE_ONLY(iNonSupportedPlayerOpt &= ~(PLAYOPT_UPSAMPLE));
    PAD2XTRANSFORM_ONLY(iNonSupportedPlayerOpt &= ~(PLAYOPT_PAD2XTRANSFORM));

    if ( (iNonSupportedPlayerOpt & iPlayerOpt) || !fOKOptions[iPlayerOpt&0xF] )
    {
        // Player has requested something that we didn't build 
        // or wants an unsupported combination of options
        wmaResult = TraceResult(WMA_E_NOTSUPPORTED);
        goto exit;
    }

    if ( (iPlayerOpt&(PLAYOPT_HALFTRANSFORM|PLAYOPT_PAD2XTRANSFORM))==(PLAYOPT_HALFTRANSFORM|PLAYOPT_PAD2XTRANSFORM) )
    {
        // if in pad2X mode and a shift into the background sets half transform mode, do neither
        iPlayerOpt &= ~(PLAYOPT_HALFTRANSFORM|PLAYOPT_PAD2XTRANSFORM);
    }

#if defined(INTERPOLATED_DOWNSAMPLE)
    pau->m_fLowPass = WMAB_FALSE;
    pau->m_fDownsample = WMAB_FALSE;
    // 16000->11025 produces ticking sounds in tough_16m_16.  32000->22050 also produces ticking, but is less pronounced.
    // if ((iPlayerOpt & PLAYOPT_DOWNSAMPLE32TO22) && (32000 == cSamplePerSec || 16000 == cSamplePerSec) )
    if ((iPlayerOpt & PLAYOPT_DOWNSAMPLE32TO22) && (32000 == cSamplePerSec) )
    {
        pau->m_fLowPass = WMAB_TRUE;
        pau->m_fDownsample = WMAB_TRUE;
        // This works out to 32000=>22050 or 16000=>11025
        prvInterpolateInit(pau, cSamplePerSec, 32000 == cSamplePerSec ? 22000 : 11000, 441); 
    }
#endif  // INTERPOLATED_DOWNSAMPLE

#if defined(HALF_TRANSFORM) || defined(PAD2X_TRANSFORM)
    pau->m_fHalfTransform = WMAB_FALSE;
    if (iPlayerOpt & PLAYOPT_HALFTRANSFORM)
        pau->m_fHalfTransform = WMAB_TRUE;

    pau->m_fUpsample = WMAB_FALSE;
    if (iPlayerOpt & PLAYOPT_UPSAMPLE)
        pau->m_fUpsample = WMAB_TRUE;

    pau->m_fPad2XTransform = WMAB_FALSE;
    if ((iPlayerOpt & PLAYOPT_PAD2XTRANSFORM)  && 22050 == cSamplePerSec)
        pau->m_fPad2XTransform = WMAB_TRUE;
#endif  // defined(HALF_TRANSFORM) || defined(PAD2X_TRANSFORM)

    //assign some basic parameters/mode
    pau->m_iSamplingRate    = cSamplePerSec;
    pau->m_cChannel         = cChannel;
    pau->m_nBytePerSample   = sizeof (I16);
#ifdef WMA_V9
    pau->m_nBytePerSample   = nBytePerSample;
    pau->m_nValidBitsPerSample = nValidBitsPerSample;
    pau->m_nChannelMask     = nChannelMask;
#endif 
    pau->m_cSubband         = cSubband;
    pau->m_fltBitsPerSample  = (Float)(cBytePerSec*8.0f/(pau->m_iSamplingRate*pau->m_cChannel));    
    pau->m_fltWeightedBitsPerSample = pau->m_fltBitsPerSample;
    // With the same QuantStep, the stereo is equivant to the mono with 1.6 times the bitrate/ch.
    if (pau->m_cChannel > 1) 
        pau->m_fltWeightedBitsPerSample *= (Float) MSA_STEREO_WEIGHT;

    //decide secondary parameters
    //first the frame sizes
    pau->m_cFrameSample      = 2 * pau->m_cSubband;
    pau->m_cFrameSampleHalf  = pau->m_cSubband;
    pau->m_cFrameSampleQuad  = pau->m_cSubband / 2; 

    pau->m_cSubFrameSample      = pau->m_cFrameSample;
    pau->m_cSubFrameSampleHalf  = pau->m_cFrameSampleHalf;
    pau->m_cSubFrameSampleQuad  = pau->m_cFrameSampleQuad; 

    pau->m_iCoefRecurQ1 = 0;
    pau->m_iCoefRecurQ2 = pau->m_iCoefRecurQ3 = pau->m_cSubFrameSampleHalf;
    pau->m_iCoefRecurQ4 = pau->m_cSubFrameSample;

    //init now; but can be reassigned in each frame; if so, be careful with tran. det.
    pau->m_cMinSubFrameSample    = pau->m_cSubFrameSample / pau->m_iMaxSubFrameDiv;
    pau->m_cMinSubFrameSampleHalf= pau->m_cSubFrameSampleHalf / pau->m_iMaxSubFrameDiv;
    pau->m_cMinSubFrameSampleQuad= pau->m_cSubFrameSampleQuad / pau->m_iMaxSubFrameDiv; 
    pau->m_cPossibleWinSize = LOG2 ((U32)pau->m_iMaxSubFrameDiv) + 1;
    pau->m_cBitsSubbandMax = LOG2 ((U32)pau->m_cSubband);

    if(pau->m_iVersion == 1)
        pau->m_cLowCutOffLong    = LOW_CUTOFF_V1;                     //need investigation
    else
        pau->m_cLowCutOffLong    = LOW_CUTOFF;                        //need investigation
    pau->m_cHighCutOffLong       = pau->m_cSubband - 9 * pau->m_cSubband / 100; //need investigation

    //default
    pau->m_cLowCutOff            = pau->m_cLowCutOffLong;
    pau->m_cHighCutOff           = pau->m_cHighCutOffLong;

    //set up some global coding condtions based on bitrate
    pau->m_iEntropyMode = SIXTEENS_OB;                     //default

    if (pau->m_fltWeightedBitsPerSample < 0.72f) {
        if (pau->m_iSamplingRate >= 32000)
            pau->m_iEntropyMode = FOURTYFOURS_QB;
    }
    else if (pau->m_fltWeightedBitsPerSample < 1.16f) {
        if (pau->m_iSamplingRate >= 32000)   {
            pau->m_iEntropyMode = FOURTYFOURS_OB;
        }
    }

#if defined(HALF_TRANSFORM) || defined(PAD2X_TRANSFORM)
    prvSetAdjustedValues(pau, WMAB_TRUE);
#endif

    TRACEWMA_EXIT(wmaResult, prvAllocate (pau));

    //initialize constants for packetization
    pau->m_cBitPacketLength  = cbPacketLength * BITS_PER_BYTE;
    pau->m_cBitPackedFrameSize = LOG2 ((U32)ROUNDF (pau->m_fltBitsPerSample * pau->m_cFrameSampleHalf / 8.0F)) + 2;
//pau->m_cBitPackedFrameSize += 1;
    pau->m_cBitPacketHeader   = NBITS_PACKET_CNT + NBITS_FRM_CNT + pau->m_cBitPackedFrameSize + 3;
    pau->m_cdwPacketHeader     = pau->m_cBitPacketHeader / BITS_PER_DWORD;
    pau->m_cBitPacketHeaderFractionDw = pau->m_cBitPacketHeader % BITS_PER_DWORD;
    pau->m_iPacketCurr = 0;

#ifdef ENABLE_ALL_ENCOPT
#ifdef ENABLE_LPC
    prvInitInverseQuadRootTable(pau);    
#endif  // ENABLE_LPC

    if (pau->m_iWeightingMode == BARK_MODE) 
    {
        if (!pau->m_fNoiseSub)   
            pau->aupfnInverseQuantize = NULL;
        else
            pau->aupfnInverseQuantize = prvInverseQuantizeMidRate;
    }
    else
        pau->aupfnInverseQuantize = prvInverseQuantizeLowRate;
#endif  // ENABLE_ALL_ENCOPT

    pau->m_iFrameNumber = 0;

    pau->aupfnReconstruct = auReconstruct;

#if !(defined( WMA_TARGET_MIPS ) && defined( BUILD_INTEGER ))
    pau->aupfnDctIV = auDctIV;
    pau->aupfnFFT = prvFFT4DCT;
#endif

    
#if !defined(_Embedded_x86)
#if defined(WMA_TARGET_X86) && !(defined(BUILD_INTEGER) || defined(UNDER_CE))
    // auInitIntelFFT call checks CPU abilities for us (MMX, SIMD, etc)
    //wmaResult = auInitIntelFFT(pau, INTELFFT_INIT_PROCESS);
    if (WMA_SUCCEEDED(wmaResult))
    {
        pau->aupfnFFT = prvFFT4DCT_INTEL;
        pau->m_fIntelFFT = WMAB_FALSE;
    }

    // Failure means no applicable optimizations. This isn't a fatal error, so suppress it.
    wmaResult = WMA_OK;

#endif  // WMA_TARGET_X86 && !BUILD_INTEGER
#endif

#ifdef USE_SIN_COS_TABLES
#ifdef WMA_TARGET_X86
#if 0 //def BUILD_INTEGER
      //This function has been removed because of a streaming mode bug that is can be reproduced
      //by setting the streaming mode buffer to 2003
    if (g_SupportMMX()){
        pau->aupfnReconstruct = auReconstruct_MMX;
    }
#endif //BUILD_INTEGER

#ifdef BUILD_INT_FLOAT

    pau->aupfnReconstruct = auReconstruct_X86;
    if (pau->m_cChannel==2) {
        if (g_SupportMMX()) 
            pau->aupfnReconstruct = auReconStereo_MMX;

        if (g_SupportSIMD_FP()) 
            pau->aupfnReconstruct = auReconStereo_SIMDFP;
    }

#endif //BUILD_INT_FLOAT

#else  
#pragma message( "Warning! USE_SIN_COS_TABLES defined but no functions are using them. See X86.c for prototype functions." ) 
#endif //WMA_TARGET_X86
#endif //USE_SIN_COS_TABLES

#ifdef WMA_TARGET_MIPS
#   ifdef BUILD_INTEGER
        auInitMIPS(pau);
#   endif //BUILD_INTEGER
#endif //WMA_TARGET_MIPS

exit:
    return wmaResult;
}
                                  


//*****************************************************************************************
//
// prvAllocate
// allocate arrays used by a CAudioObject
// part of auInit
//
//*****************************************************************************************
WMARESULT prvAllocate (CAudioObject* pau)
{
    WMARESULT   wmaResult = WMA_OK;

    const int c_iSizeOfPrevOutput = pau->m_nBytePerSample * DOUBLE(pau->m_fPad2XTransform,pau->m_cFrameSampleHalf) * pau->m_cChannel;
#ifndef PREVOUTPUT_16BITS
    const int c_iSizeOfPrevOutputSign = DOUBLE(pau->m_fPad2XTransform,pau->m_cFrameSampleHalf) * pau->m_cChannel / BITS_PER_BYTE 
                                        + pau->m_cChannel * pau->m_nBytePerSample; //wchen: not sure what this is for; but needed
#else 
    const int c_iSizeOfPrevOutputSign = 0;
#endif

    pau->m_rgpcinfo = (PerChannelInfo*) auMalloc (sizeof (PerChannelInfo) * pau->m_cChannel);
    if(pau->m_rgpcinfo == NULL)
    {
        wmaResult = TraceResult(WMA_E_OUTOFMEMORY);
        goto exit;
    }

    pau->m_piPrevOutput = (I16*) auMalloc (c_iSizeOfPrevOutput + c_iSizeOfPrevOutputSign);
    if (pau->m_piPrevOutput == NULL)
    {
        wmaResult = TraceResult(WMA_E_OUTOFMEMORY);
        goto exit;
    }
    memset (pau->m_piPrevOutput, 0, c_iSizeOfPrevOutput + c_iSizeOfPrevOutputSign);

    pau->m_rgiCoefReconOrig     = (Int*) mallocAligned (sizeof (Int) *
        DOUBLE(pau->m_fPad2XTransform,pau->m_cSubband) * pau->m_cChannel, 32);
    if (pau->m_rgiCoefReconOrig == NULL)
    {
        wmaResult = TraceResult(WMA_E_OUTOFMEMORY);
        goto exit;
    }
    memset (pau->m_rgiCoefReconOrig, 0, 
            sizeof (Int) * DOUBLE(pau->m_fPad2XTransform,pau->m_cSubband) * pau->m_cChannel);    

    pau->m_rgcValidBarkBand  = (Int*) auMalloc (sizeof (Int) * pau->m_cPossibleWinSize);
    if (pau->m_rgcValidBarkBand == NULL)
    {
        wmaResult = TraceResult(WMA_E_OUTOFMEMORY);
        goto exit;
    }

    pau->m_rgiBarkIndexOrig = (Int*) auMalloc (sizeof (Int) * (NUM_BARK_BAND + 1) * pau->m_cPossibleWinSize); //+1 : including bottom and top end
    if (pau->m_rgiBarkIndexOrig == NULL)
    {
        wmaResult = TraceResult(WMA_E_OUTOFMEMORY);
        goto exit;
    }
    
    prvSetBarkIndex (pau);
    pau->m_rgiMaskQ         = (Int*) auMalloc (sizeof (Int) * pau->m_cValidBarkBand * pau->m_cChannel);
    if (pau->m_rgiMaskQ == NULL)
    {
        wmaResult = TraceResult(WMA_E_OUTOFMEMORY);
        goto exit;
    }

    //for v2 it has to be dynamically decided
    if (pau->m_iVersion == 1) 
        pau->m_fltDctScale = (Float) sqrt (2.0 / pau->m_cSubbandAdjusted);


#ifdef ENABLE_ALL_ENCOPT
    // find the region to apply noise subsitution, in the frequencies...
    TRACEWMA_EXIT(wmaResult, prvInitNoiseSub (pau));

#if defined(_DEBUG) && defined(LPC_COMPARE)
    if (pau->m_iWeightingMode == LPC_MODE) {
        Int i;
        for (i = 0; i < LPCORDER; i++)  {
            pau->m_rgfltLpsSpecCos [i] = NULL;
            pau->m_rgfltLpsSpecSin [i] = NULL;
        }
    }
#endif

    if (pau->m_iWeightingMode == LPC_MODE && pau->m_rguiWeightFactor==NULL)
    {
        pau->m_rguiWeightFactor = (UInt*) auMalloc (sizeof (UInt) * DOUBLE(pau->m_fPad2XTransform,pau->m_cSubband) * pau->m_cChannel);
        if (pau->m_rguiWeightFactor == NULL)
        {
            wmaResult = TraceResult(WMA_E_OUTOFMEMORY);
            goto exit;
        }
    }

#endif // ENABLE_ALL_ENCOPT

#ifdef USE_SIN_COS_TABLES          
        pau->m_piSinForRecon2048 = (BP2Type*)g_SinTableForReconstruction;
        pau->m_piSinForRecon1024 = pau->m_piSinForRecon2048+2048;
        pau->m_piSinForRecon512  = pau->m_piSinForRecon1024+1024;
        pau->m_piSinForRecon256  = pau->m_piSinForRecon512+512;
        pau->m_piSinForRecon128  = pau->m_piSinForRecon256+256;
        pau->m_piSinForRecon64   = pau->m_piSinForRecon128+128;

        pau->m_piSinForSaveHistory = pau->m_piSinForRecon2048+2048;
#endif
exit:
    return wmaResult;
}


//*****************************************************************************************
//
// prvSetBarkIndex
// part of prvAllocate which is part of auInit
//
//*****************************************************************************************
Void prvSetBarkIndex (CAudioObject* pau)
{
    Int i, iWin;
    Float fltSamplingPeriod;

    Int *piBarkIndex;
    Int cFrameSample;
    Bool bCombined;

    //calculate index of each bark freq
    fltSamplingPeriod = 1.0F / pau->m_iSamplingRate;
    // wchen: we need to think what to do with the cut off frequencies: not include at all or include zeros.
    //for long window
    piBarkIndex = pau->m_rgiBarkIndexOrig;

    // for the v1 compatibility
    if(pau->m_iVersion == 1)
    {
        assert(pau->m_cPossibleWinSize == 1);

        // set up the bark index
        piBarkIndex[0] = 0;
        for (i = 0; i < NUM_BARK_BAND; i++)
        {
            piBarkIndex [i + 1] = (Int) ftoi(g_rgiBarkFreq [i] * pau->m_cFrameSample * 
                                         fltSamplingPeriod + 0.5f); //open end
            assert (piBarkIndex [i + 1]);
            if (piBarkIndex [i + 1] > pau->m_cFrameSample / 2)
            {
                piBarkIndex [i + 1] = pau->m_cFrameSample / 2;
                pau->m_rgcValidBarkBand [0] = i + 1;
                break;
            }
        }
    }
    else
    {
        for (iWin = 0; iWin < pau->m_cPossibleWinSize; iWin++)    {
            piBarkIndex  [0] = 0;
            cFrameSample = pau->m_cFrameSample / (1 << iWin);
            bCombined = WMAB_FALSE;
            if (pau->m_iSamplingRate >= 44100) {
                if(cFrameSample == 1024) { // winsize = 512
                    bCombined = WMAB_TRUE;
                    pau->m_rgcValidBarkBand[iWin] = 17;
                    piBarkIndex[1]  = 5;    piBarkIndex[2]  = 12;
                    piBarkIndex[3]  = 18;   piBarkIndex[4]  = 25;
                    piBarkIndex[5]  = 34;   piBarkIndex[6]  = 46;
                    piBarkIndex[7]  = 54;   piBarkIndex[8]  = 63;
                    piBarkIndex[9]  = 86;   piBarkIndex[10] = 102;
                    piBarkIndex[11] = 123;  piBarkIndex[12] = 149;
                    piBarkIndex[13] = 179;  piBarkIndex[14] = 221;
                    piBarkIndex[15] = 279;  piBarkIndex[16] = 360;
                    piBarkIndex[17] = 512;
                }
                else if(cFrameSample == 512) { // winsize = 256
                    bCombined = WMAB_TRUE;
                    pau->m_rgcValidBarkBand[iWin] = 15;
                    piBarkIndex[1]  = 5;    piBarkIndex[2]  = 11;
                    piBarkIndex[3]  = 17;   piBarkIndex[4]  = 23;
                    piBarkIndex[5]  = 31;   piBarkIndex[6]  = 37;
                    piBarkIndex[7]  = 43;   piBarkIndex[8]  = 51;
                    piBarkIndex[9]  = 62;   piBarkIndex[10] = 74;
                    piBarkIndex[11] = 89;   piBarkIndex[12] = 110;
                    piBarkIndex[13] = 139;  piBarkIndex[14] = 180;
                    piBarkIndex[15] = 256;
                }
                else if(cFrameSample == 256)  { // winsize = 128
                    bCombined = WMAB_TRUE;
                    pau->m_rgcValidBarkBand [iWin] = 12;
                    piBarkIndex[1]  = 4;   piBarkIndex[2]  = 9;
                    piBarkIndex[3]  = 12;  piBarkIndex[4]  = 16;
                    piBarkIndex[5]  = 21;  piBarkIndex[6]  = 26;
                    piBarkIndex[7]  = 37;  piBarkIndex[8]  = 45;
                    piBarkIndex[9]  = 55;  piBarkIndex[10] = 70;
                    piBarkIndex[11] = 90;  piBarkIndex[12] = 128;
                }
            }
            else if(pau->m_iSamplingRate >= 32000) {
                if(cFrameSample == 1024) { // winsize = 512
                    bCombined = WMAB_TRUE;
                    pau->m_rgcValidBarkBand[iWin] = 16;
                    piBarkIndex[1]  = 6;   piBarkIndex[2]  = 13;
                    piBarkIndex[3]  = 20;  piBarkIndex[4]  = 29;
                    piBarkIndex[5]  = 41;  piBarkIndex[6]  = 55;
                    piBarkIndex[7]  = 74;  piBarkIndex[8]  = 101;
                    piBarkIndex[9]  = 141; piBarkIndex[10] = 170;
                    piBarkIndex[11] = 205; piBarkIndex[12] = 246;
                    piBarkIndex[13] = 304; piBarkIndex[14] = 384;
                    piBarkIndex[15] = 496; piBarkIndex[16] = 512;
                }
                else if(cFrameSample == 512) { // winsize = 256
                    bCombined = WMAB_TRUE;
                    pau->m_rgcValidBarkBand[iWin] = 15;
                    piBarkIndex[1]  = 5;   piBarkIndex[2]  = 10;
                    piBarkIndex[3]  = 15;  piBarkIndex[4]  = 20;
                    piBarkIndex[5]  = 28;  piBarkIndex[6]  = 37;
                    piBarkIndex[7]  = 50;  piBarkIndex[8]  = 70;
                    piBarkIndex[9]  = 85;  piBarkIndex[10] = 102;
                    piBarkIndex[11] = 123; piBarkIndex[12] = 152;
                    piBarkIndex[13] = 192; piBarkIndex[14] = 248;
                    piBarkIndex[15] = 256;
                }
                else if(cFrameSample == 256)  { // winsize = 128
                    bCombined = WMAB_TRUE;
                    pau->m_rgcValidBarkBand [iWin] = 11;
                    piBarkIndex[1]  = 4;   piBarkIndex[2]  = 9;
                    piBarkIndex[3]  = 14;  piBarkIndex[4]  = 19;
                    piBarkIndex[5]  = 25;  piBarkIndex[6]  = 35;
                    piBarkIndex[7]  = 51;  piBarkIndex[8]  = 76;
                    piBarkIndex[9]  = 96;  piBarkIndex[10] = 124;
                    piBarkIndex[11] = 128;
                }
            }
            else if(pau->m_iSamplingRate >= 22050) {
                if(cFrameSample == 512) { // winsize = 256
                    bCombined = WMAB_TRUE;
                    pau->m_rgcValidBarkBand [iWin] = 14;
                    piBarkIndex[1]  = 5;   piBarkIndex[2]  = 12;
                    piBarkIndex[3]  = 18;  piBarkIndex[4]  = 25;
                    piBarkIndex[5]  = 34;  piBarkIndex[6]  = 46;
                    piBarkIndex[7]  = 63;  piBarkIndex[8]  = 86;
                    piBarkIndex[9]  = 102; piBarkIndex[10] = 123;
                    piBarkIndex[11] = 149; piBarkIndex[12] = 179;
                    piBarkIndex[13] = 221; piBarkIndex[14] = 256;
                }
                else if(cFrameSample == 256) { // winsize = 128
                    bCombined = WMAB_TRUE;
                    pau->m_rgcValidBarkBand [iWin] = 10;
                    piBarkIndex[1]  = 5;   piBarkIndex[2]  = 11;
                    piBarkIndex[3]  = 17;  piBarkIndex[4]  = 23;
                    piBarkIndex[5]  = 31;  piBarkIndex[6]  = 43;
                    piBarkIndex[7]  = 62;  piBarkIndex[8]  = 89;
                    piBarkIndex[9]  = 110; piBarkIndex[10] = 128;
                }
            }

            if(!bCombined)
            {
                Float fltTemp = cFrameSample*fltSamplingPeriod;
                Int iIndex;
                Int iFreqCurr = 0;
                Int iCurr = 1;
                while(WMAB_TRUE)
                {
                    iIndex = ((Int) ftoi((g_rgiBarkFreq [iFreqCurr++]*fltTemp + 2.0f)/4.0f))*4; // open end

                    if(iIndex > piBarkIndex[iCurr - 1])
                        piBarkIndex[iCurr++] = iIndex;

                    if(iFreqCurr >= NUM_BARK_BAND ||
                       piBarkIndex[iCurr - 1] > cFrameSample/2)
                    {
                        piBarkIndex[iCurr - 1] = cFrameSample/2;
                        pau->m_rgcValidBarkBand[iWin] = iCurr - 1;
                        break;
                    }
                }
            }
            else
            {
                for (i = 0; i < pau->m_rgcValidBarkBand [iWin]; i++) {
                    piBarkIndex [i + 1] = ((piBarkIndex [i + 1] + 2) / 4) * 4;  //rounding
                    assert (piBarkIndex [i + 1] > piBarkIndex [i]);
                }
            }

            piBarkIndex +=  NUM_BARK_BAND + 1;
        }
    }
    //default
    pau->m_rgiBarkIndex = pau->m_rgiBarkIndexOrig;
    pau->m_cValidBarkBand = pau->m_rgcValidBarkBand [0];

#ifdef DEBUG
    // checking for multiples of 4!!!
    if(pau->m_iVersion != 1)
    {
        Int iWin, iBand;
        for(iWin = 0; iWin < pau->m_cPossibleWinSize; iWin++)
        {
            for(iBand = 0; iBand <= pau->m_rgcValidBarkBand[iWin]; iBand++)
            {
                i = pau->m_rgiBarkIndexOrig[iWin*(NUM_BARK_BAND + 1) + iBand];
                assert(i%4 == 0);
            }
        }
    }
#endif // DEBUG

}


#ifdef BUILD_INTEGER
#define COEF m_rgiCoefRecon
#else   // BUILD_INTEGER
#define COEF m_rgfltCoefRecon
#endif  // BUILD_INTEGER

Void auPreGetPCM (CAudioObject* pau, U16* pcSampleDecoded)
{
    I16 iChannel;
    Int iWinDiff;

    //set up for getPCM
    for (iChannel = 0; iChannel < pau->m_cChannel; iChannel++) 
    {
        PerChannelInfo* ppcinfo = pau->m_rgpcinfo + iChannel;
        ppcinfo->m_rgiCoefReconCurr = ((I32*) ppcinfo->COEF) + pau->m_cSubbandAdjusted /2;
        ppcinfo->m_iCurrGetPCM_SubFrame = 0;       //current position in a subframe
        ppcinfo->m_piPrevOutputCurr = ppcinfo->m_piPrevOutput;
    }

    *pcSampleDecoded = (U16) pau->m_cSubFrameSampleHalfAdjusted;
    iWinDiff = pau->m_iSizeCurr - pau->m_iSizePrev;
    if (iWinDiff > 0)   {
        *pcSampleDecoded -= (U16)(iWinDiff >> 1);
        for (iChannel = 0; iChannel < pau->m_cChannel; iChannel++) 
        {
            PerChannelInfo* ppcinfo = pau->m_rgpcinfo + iChannel;
            ppcinfo->m_rgiCoefReconCurr += iWinDiff >> 1;
            ppcinfo->m_iCurrGetPCM_SubFrame += (I16)(iWinDiff >> 1);
            assert(0<=ppcinfo->m_iCurrGetPCM_SubFrame && ppcinfo->m_iCurrGetPCM_SubFrame<=pau->m_cSubFrameSampleHalfAdjusted);
        }
    }
    iWinDiff = pau->m_iSizeCurr - pau->m_iSizeNext;
    if (iWinDiff > 0)
        *pcSampleDecoded += (U16)(iWinDiff >> 1);

    if (CODEC_BEGIN == pau->m_codecStatus)
        prvInitDiscardSilence(pau);
    else if (pau->m_fPacketLossAdj == WMAB_TRUE) //being seeked
        pau->m_iDiscardSilence = pau->m_cSubFrameSampleHalfAdjusted;
    pau->m_fPacketLossAdj = WMAB_FALSE;

    // Check if the samples we just generated are to be discarded (silence)
    // We want to only return what the user should expect to get back from auGetPCM
    if (pau->m_iDiscardSilence)
    {
        U16         uSilence;
        Bool        fUpdateTrig;

        // Part or all of the samples just generated will be discarded.
        if (pau->m_iDiscardSilence >= *pcSampleDecoded)
        {
            // ALL of the samples just generated will be discarded

            uSilence = *pcSampleDecoded;
            *pcSampleDecoded = 0;
            fUpdateTrig = WMAB_FALSE;
        }
        else
        {
            // We don't want to overreport what user will get back from auGetPCM,
            // so subtract the silence.
            uSilence = (U16) pau->m_iDiscardSilence;
            *pcSampleDecoded -= (U16) pau->m_iDiscardSilence;

            // The trigonometry is going to be used after this to compute PCM
            // Update it now as if we had called auGetPCM
            fUpdateTrig = WMAB_TRUE;
        }

        // SIMULATE call to auGetPCM on behalf of the user to flush silence bits out
        // Avoid calling auGetPCM to discard silence because the temporary buffer
        // needed is objectionable to small devices

        // First, do things that auReconMono would normally do
        for (iChannel = 0; iChannel < pau->m_cChannel; iChannel++)
        {
            PerChannelInfo *ppcinfo = &pau->m_rgpcinfo[iChannel];
            const U16 uSilenceQ2MAX = (U16)min(pau->m_iCoefRecurQ2 -
                ppcinfo->m_iCurrGetPCM_SubFrame, uSilence);
            Int iCoefCount;
            Int iCoefCountMAX;
            I32 iCoefPtrOffset;
            Int iCoefDelta;


            // Need to simulate movement of coefficient ptr in auGetPCM
            iCoefCount = ppcinfo->m_iCurrGetPCM_SubFrame;
            iCoefCountMAX = iCoefCount + uSilence;
            iCoefPtrOffset = 0;
            if (iCoefCount < pau->m_cSubFrameSampleQuadAdjusted)
            {
                iCoefDelta = min(iCoefCountMAX, pau->m_cSubFrameSampleQuadAdjusted) - iCoefCount;
                iCoefPtrOffset += iCoefDelta;
                iCoefCount += iCoefDelta;
            }

            if (iCoefCount < pau->m_iCoefRecurQ2)
            {
                iCoefDelta = min(iCoefCountMAX, pau->m_iCoefRecurQ2) - iCoefCount;
                iCoefPtrOffset -= iCoefDelta;
                iCoefCount += iCoefDelta;
            }

            if (iCoefCount < pau->m_iCoefRecurQ3)
            {
                iCoefDelta = min(iCoefCountMAX, pau->m_iCoefRecurQ3) - iCoefCount;
                iCoefPtrOffset -= iCoefDelta;
                iCoefCount = iCoefDelta;
            }

            assert(iCoefCount <= uSilence);
            ppcinfo->m_rgiCoefReconCurr += iCoefPtrOffset;
            ppcinfo->m_piPrevOutputCurr += uSilenceQ2MAX * pau->m_cChannel;
            ppcinfo->m_iCurrGetPCM_SubFrame += uSilence;

            if (fUpdateTrig)
            {
                Int         iSize;
                BP2Type     bpSinA;
                BP2Type     bpCosA;
                BP2Type     bpSinB;
                BP2Type     bpCosB;
                Int         iMultiplier;

                //if the adjacent size is bigger; just keep your own shape
                //otherwise a transition window is needed.
                if (pau->m_iSizePrev >= pau->m_iSizeCurr)
                {
                    //just forward copy curr
		            iSize = pau->m_iSizeCurr;
                }
                else
                {
                    //long start
		            iSize = pau->m_iSizePrev;
                }


                // It turns out that uSilenceQ2MAX is either equal to iSize
                // or equal to half of it. Our trig then simplifies to
                // sin(pi/(4*iSize) + pi/X) where X = 2 or 4.
                // Use trig ID's below to calculate these values.
                bpSinA = *((BP2Type*)(&ppcinfo->m_iSin));
                bpCosA = *((BP2Type*)(&ppcinfo->m_iCos));
                assert(uSilenceQ2MAX == iSize || uSilenceQ2MAX * 2 == iSize);
                iMultiplier = iSize / uSilenceQ2MAX;
                switch(iMultiplier)
                {
                    case 1:
                        bpSinB = BP2_FROM_FLOAT(1.0); // sin(pi/2)
                        bpCosB = BP2_FROM_FLOAT(0.0); // cos(pi/2)
                        break;

                    case 2:
                        bpSinB = BP2_FROM_FLOAT(0.70710678118654752440084436210485); // sin(pi/4)
                        bpCosB = BP2_FROM_FLOAT(0.70710678118654752440084436210485); // cos(pi/4)
                        break;

                    default:
                        assert(WMAB_FALSE);
                        break;
                }


                // Let A = start = pi/(4*iSize), B = pi/X where X = 2 or 4.
                // Trig ID's: sin(A+B) = sin(A)cos(B) + cos(A)sin(B)
                //            cos(A+B) = cos(A)cos(B) + sin(A)sin(B)
                // To get the prior step for recursion, note that subtracting
                // a step (step = 2*A) and simplifying gets us to
                // sin(pi/X - pi/(4*iSize)) where X = 2 or 4.
                *(BP2Type*)(&ppcinfo->m_iSin)  = MULT_BP2(bpSinA, bpCosB) +
                    MULT_BP2(bpCosA, bpSinB);
                *(BP2Type*)(&ppcinfo->m_iCos)  = MULT_BP2(bpCosA, bpCosB) -
                    MULT_BP2(bpSinA, bpSinB);
                *(BP2Type*)(&ppcinfo->m_iSin1) = MULT_BP2(bpSinB, bpCosA) -
                    MULT_BP2(bpCosB, bpSinA);
                *(BP2Type*)(&ppcinfo->m_iCos1) = MULT_BP2(bpCosB, bpCosA) +
                    MULT_BP2(bpSinB, bpSinA);

                // Check the accuracy
                assert(fabs(FLOAT_FROM_BP2(*((BP2Type*)(&ppcinfo->m_iSin))) -
                    sin(0.5 * PI / iSize / 2 * (2*uSilenceQ2MAX + 1))) <= 0.001);
                assert(fabs(FLOAT_FROM_BP2(*((BP2Type*)(&ppcinfo->m_iCos))) -
                    cos(0.5 * PI / iSize / 2 * (2*uSilenceQ2MAX + 1))) <= 0.001);
                assert(fabs(FLOAT_FROM_BP2(*((BP2Type*)(&ppcinfo->m_iSin1))) -
                    sin(0.5 * PI / iSize / 2 * (2*uSilenceQ2MAX - 1))) <= 0.001);
                assert(fabs(FLOAT_FROM_BP2(*((BP2Type*)(&ppcinfo->m_iCos1))) -
                    cos(0.5 * PI / iSize / 2 * (2*uSilenceQ2MAX - 1))) <= 0.001);

            }
        }

#ifdef USE_SIN_COS_TABLES
        if (fUpdateTrig && pau->m_rgpcinfo[0].m_iCurrGetPCM_SubFrame < pau->m_iCoefRecurQ2)
        {
            const U16 uSilenceQ2MAX = (U16)min(pau->m_iCoefRecurQ2 -
                pau->m_rgpcinfo[0].m_iCurrGetPCM_SubFrame, uSilence);

            pau->m_piSinForRecon += uSilenceQ2MAX; // Shared by both channels
        }
#endif  // USE_SIN_COS_TABLES

        // Next, do the things that auGetPCM would normally do
        pau->m_iDiscardSilence -= uSilence;
        assert(pau->m_iDiscardSilence >= 0);
        if (CODEC_BEGIN == pau->m_codecStatus)
            pau->m_codecStatus = CODEC_STEADY;

    }
}


WMARESULT auReconstruct (CAudioObject* pau, I16* piOutput, I16* pcSampleGet, Bool fForceTransformAll){
    Int iChannel;
    WMARESULT hr;
    for (iChannel = 0; iChannel < pau->m_cChannel; iChannel++)
    {
        hr = (auReconMono) (pau, 
                          pau->m_rgpcinfo + iChannel, 
                          piOutput + iChannel,  
                          (I16*)pcSampleGet,
                          fForceTransformAll);
    }
    return hr;
}


WMARESULT auGetPCM (CAudioObject* pau, U16* pcSample, U8* pbDst, U32 cbDstLength)
{  
    Int cbDstUsed;
    Int* pcbDstUsed = &cbDstUsed;
    WMARESULT hr;
    I16* piOutput = (I16*) pbDst;

    U32 cSamplesLeft;
    I16 cSamplesREQ;

    cSamplesLeft = *pcSample;
    do
    {
        const U32 cMaxSamplesInDst = (cbDstLength / sizeof (I16) / pau->m_cChannel);

        // Limit requested number of bytes to fit within the buffer
        const U32 u32MaxSamplesReq = min(cSamplesLeft, cMaxSamplesInDst);

        // limit request to fit in I16
        cSamplesREQ = (I16) min(u32MaxSamplesReq, SHRT_MAX);

        hr = (*pau->aupfnReconstruct) (pau,
                          piOutput,
                          &cSamplesREQ,
                          WMAB_FALSE);

        cSamplesLeft -= cSamplesREQ;
        if (0 == cSamplesREQ)
            // No more samples to retrieve, the well is dry. Avoid infinite loop
            break;

        // Check if we just reconstructed silence that we need to toss
        if (pau->m_iDiscardSilence)
            prvDiscardSilence(pau, (unsigned short *)&cSamplesREQ, pau->m_cChannel, pbDst);

    } while (0 == cSamplesREQ && 0 != cSamplesLeft);

    if (CODEC_BEGIN == pau->m_codecStatus)
        pau->m_codecStatus = CODEC_STEADY;

    *pcSample = cSamplesREQ;
    *pcbDstUsed = (*pcSample) * pau->m_cChannel * sizeof (I16); // in bytes

#   ifdef INTERPOLATED_DOWNSAMPLE
        if (pau->m_fDownsample) {
            prvInterpolate(pau, piOutput, *pcbDstUsed, pau->m_cChannel,
                piOutput, pcbDstUsed, pcSample);
        }
#   endif  // INTERPOLATED_DOWNSAMPLE

#if defined(HALF_TRANSFORM)
    // interpolate 2X 
    // This simple linear interpolation is fast but does not remove aliasing 
    // So it should not be used with the HALF_TRANSFORM case if audio quality is important
    if (pau->m_fUpsample && *pcbDstUsed > 0)
    {
        // work from back of buffer to front so we do not overwrite any values we still need to use
        Int iChannel;
        Int iSamplesPerChannel = *pcbDstUsed / (sizeof(I16) * pau->m_cChannel);
        const int c_iDecr = pau->m_cChannel;

        for (iChannel = 0; iChannel < c_iDecr; iChannel++)
        {

            I16 *piInput = piOutput + iChannel + (iSamplesPerChannel - 1) * c_iDecr;
            I16 *piOutputx = piOutput + iChannel + (2 * iSamplesPerChannel - 1) * c_iDecr;
            I16 iNextInput, iPrevInput;

            iNextInput = *piInput;
            while (piOutputx > (piOutput + iChannel + 2))
            {
                assert(piOutputx >= piInput + iChannel);
                *piOutputx = iNextInput;
                piOutputx -= c_iDecr;

                iPrevInput = iNextInput;

                piInput  -= c_iDecr;
                assert(piInput >= (piOutput + iChannel));
                iNextInput = *piInput;

                assert(piOutputx >= piInput + iChannel);
                *piOutputx = (iPrevInput >> 1) + (iNextInput >> 1);
                assert(fabs((double)(*piOutputx) - ((double)iPrevInput +
                    (double)iNextInput)/2.0) <= 1);

                piOutputx -= c_iDecr;
            }

            // handle beginning of buffer case
            assert( piOutputx == piOutput + iChannel + 2);
            *piOutputx = iNextInput;
            piOutputx -= c_iDecr;

            iPrevInput = iNextInput;

            assert(piInput >= (piOutput + iChannel));
            iNextInput = pau->m_iPriorSample[iChannel];

            assert(piOutputx >= piInput);
            *piOutputx = (iPrevInput >> 1) + (iNextInput >> 1);
            assert(fabs((double)(*piOutputx) - ((double)iPrevInput +
                (double)iNextInput)/2.0) <= 1);

            pau->m_iPriorSample[iChannel] = *(piOutput + iChannel + (2 * iSamplesPerChannel - 1) * c_iDecr);

        }

        *pcSample   *= 2;
        *pcbDstUsed *= 2;
    }
#endif  // defined(HALF_TRANSFORM)

    //FUNCTION_PROFILE_STOP(&fp);
    return WMA_OK;

}

//*****************************************************************************************
//
// prvInverseTransformMono
//  transform, window and combine an overlapping subframe of audio data
//  called repeatedly for each subframe in a frame
// 
//  using abbreviated names, the process in outline form is as follows:
//  
//      pSrc points to someplace in current or previous time-domain Output array
//      pDst points to someplace in current or previous time-domain Output array
//      between each "upto" step below, these two points may change
//
//      Coef is an array of frequency-domain coefs
//
//      call DCT and transform Coef to time-domain
//      pCoef set to middle of the now time-domain coeffiecents
//
//      Window and combine the transformed Coef and pSrc into pDst as follows:
//
//      Window
//                  ________________
//                 /                \
//                /                  \
//               /                    \
//      ________/                      \_________
//      |       | | |       |      | | |         |
//      0       Q Q Q       H      Q 3 Q         F
//              1 u 2       a      3 Q 4         u
//                a         l        u           l
//                d         f        a           l
//                                   d
//      
//      upto Q1 (eg 0): 
//          Dst <- Src                              [[++pDst, ++pCoef, ++pSrc]]
//
//      upto cSubFrameSampleQuad (eg 1024):
//          Dst <- ( sin(a) * Coef + Src<<5 ) >> 5  [[++pDst, ++pCoef, ++pSrc, ++a]]
//
//      upto Q2 (eg 2048):
//          Dst <- ( sin(a) * Coef + Src<<5 ) >> 5  [[++pDst, --pCoef, ++pSrc, ++a]]
//
//      upto cSubFrameSampleHalf (eg 2048):
//          Dst <- Coef >> 5                        [[++pDst, --pCoef]]
//
//      upto Q3 (eg 2944):
//          Dst <- Coef >> 5                        [[++pDst, --pCoef]]
//
//      upto 3 * cSubFrameSampleQuad (eg 3072):
//          Dst <- ( sin(a) * Coef ) >> 5;          [[++pDst, --pCoef]]
//      
//      upto Q4 (eg 3200):
//          Dst <- ( sin(a) * Coef ) >> 5;          [[++pDst, ++pCoef]]
//
//
//  
//  Values decoding the first few frames of Tough_44m_64.cmp (9/22/99 12:08PM version)
//  where pDst is relative to piOutput when c. and to piPrevOutput when p.
//
//                          iCurrSubFrame       iSubFrmOffset   pDst prior to loop:
//              FrameSample         cSubFrameSample               Q1     Q2     Q3     Q4
//                              
//  Decode             4096
//    inverseTransform          0       4096           0        c....0 c.1024 p....0 p.1024
//  Decode             4096
///   inverseTransform          0       2048         512        c..512 c.1024 c.1536 p....0
//    inverseTransform          1        256        1984        c.1984 p....0 p...64 p..128
//    inverseTransform          2        256        2112        p...64 p. 128 p..192 p..256
//    inverseTransform          3        256        2240        p. 192 p. 256 p..320 p..384
//    inverseTransform          4        256        2368        p..320 p..320 p..448 p..512
//    inverseTransform          5       1024        2304        p..256 p..512 p..768 p.1024
//  Decode             4096
//    inverseTransform          0       4096           0        c....0 c.1024 p....0 p.1024
//  Decode             4096
//    inverseTransform          0       4096           0        c....0 c.1024 p....0 p.1024
//  Decode             4096
//    inverseTransform          0       4096           0        c....0 c.1024 p....0 p.1024
//  Decode             4096
//    inverseTransform          0       2048         512        c..512 c.1024 c.1536 p....0
//    inverseTransform          1        512        1920        c.1920 p....0 p..128 p..256
//    inverseTransform          2        256        2240        p..192 p..256 p..320 p..384
//    inverseTransform          3        256        2368        p..320 p..384 p..448 p..512
//    inverseTransform          4        256        2496        p..448 p..512 p..576 p..640
//    inverseTransform          5        256        2624        p..576 p..640 p..704 p..768
//    inverseTransform          6        512        2688        p..640 p..768 p..896 p.1024
//
//*****************************************************************************************

#if defined(_DEBUG)
// Debugging Macros to break at a particular output sample or when sample values are out of range or to print sin values
//
// set IT_BREAK_AT_SAMPLE to a non-negative value to break when that sample is about to be processed
//#define IT_BREAK_AT_SAMPLE -2049
//
// set IT_BREAK_OUT_OF_RANGE to a positive value to break when a sample is stored out of the range
//#define IT_BREAK_OUT_OF_RANGE 32767
//#define IT_BREAK_OUT_OF_RANGE_PAST_SAMPLE 475500
//
// set IT_SIN_PRINT_ALL to print out all sin values as they are used
//#define IT_SIN_PRINT_ALL
//
// set IT_SIN_PRINT_INIT to print out initial sin values as they are used
//#define IT_SIN_PRINT_INIT
//
// set IT_SAMPLE_PRINT to print out sample values as they are generated
//#define IT_SAMPLE_PRINT
// 
// set IT_FRAME_PRINT to print out sample values as they are generated
//#define IT_FRAME_PRINT
// 
#   if defined(IT_BREAK_AT_SAMPLE) || defined(IT_BREAK_OUT_OF_RANGE)|| defined(IT_SIN_PRINT_ALL) \
    || defined(IT_SIN_PRINT_INIT) || defined(IT_SAMPLE_PRINT) || defined(IT_FRAME_PRINT)
#       pragma COMPILER_MESSAGE(__FILE__ "(1101) : Warning - Inverse Transform Debug Code Enabled.")
#       if defined(IT_BREAK_AT_SAMPLE)
            static int nSampleBreak = IT_BREAK_AT_SAMPLE;
#       else
            static int nSampleBreak = -2049;
#       endif
        static int nSampleBreakIdx = -2048;             // correction factor for startup
        static int nSampleBreakFrameSample = 0;         // prior frame's sample size
        static int iSubFrmOffset = 0;                   // Needed to add after merging with wchen's 12/17/99 checkin ???
#   endif
#   define IT_NO_SIN 0x7FEDCBA9
    static double dIorF2F = INTEGER_OR_INT_FLOAT(1.0/NF2BP2,1.0);
#   if defined(IT_SIN_PRINT_ALL)
#       define IT_DO_SIN_PRINT(idx1,idx2,v)                                     \
            if (v != IT_NO_SIN)                                                 \
                printf("%8d %4d %+.10f\n", idx1, idx2, v*dIorF2F )
#   else
#       define IT_DO_SIN_PRINT(a,b,c)
#   endif
#   if defined(IT_SAMPLE_PRINT)
#       define IT_DO_SAMPLE_PRINT(idx1,idx2,v) \
                printf("%8d %4d %+10d\n", idx1, idx2, (I32)v )
#   else
#       define IT_DO_SAMPLE_PRINT(a,b,c)
#   endif
#   if defined(IT_FRAME_PRINT)
#       define IT_DO_FRAME_PRINT                                                \
            if ( pau->m_iFrameNumber==0 )                                       \
                printf("\n");                                                   \
            printf("Frame %4d  SubFrm %2d  SFSamples %4d\n", pau->m_iFrameNumber, pau->m_iCurrSubFrame, pau->m_cSubFrameSampleAdjusted )
#   else
#       define IT_DO_FRAME_PRINT
#   endif
#   if defined(IT_BREAK_AT_SAMPLE) && defined(IT_BREAK_OUT_OF_RANGE)
#       define DEBUG_IT_SAMPLE_BREAK(idx,Dst,iSin)                              \
            if ( (nSampleBreakIdx+idx+iSubFrmOffset) == nSampleBreak || Dst < -IT_BREAK_OUT_OF_RANGE || Dst > IT_BREAK_OUT_OF_RANGE ) \
                DEBUG_BREAK();                                                  \
            IT_DO_SIN_PRINT(nSampleBreakIdx+idx+iSubFrmOffset,idx,iSin);        \
            IT_DO_SAMPLE_PRINT(nSampleBreakIdx+idx+iSubFrmOffset,idx,Dst)
#   elif defined(IT_BREAK_AT_SAMPLE)
#       define DEBUG_IT_SAMPLE_BREAK(idx,Dst,iSin)                              \
            if ( (nSampleBreakIdx+idx+iSubFrmOffset) == nSampleBreak )          \
                DEBUG_BREAK();                                                  \
            IT_DO_SIN_PRINT(nSampleBreakIdx+idx+iSubFrmOffset,idx,iSin);        \
            IT_DO_SAMPLE_PRINT(nSampleBreakIdx+idx+iSubFrmOffset,idx,Dst)
#   elif defined(IT_BREAK_OUT_OF_RANGE)
#       define DEBUG_IT_SAMPLE_BREAK(idx,Dst,iSin)                              \
            if ( ( Dst < -IT_BREAK_OUT_OF_RANGE || Dst > IT_BREAK_OUT_OF_RANGE )\
                 && (nSampleBreakIdx+idx+iSubFrmOffset) > IT_BREAK_OUT_OF_RANGE_PAST_SAMPLE )  \
                DEBUG_BREAK();                                                  \
            IT_DO_SIN_PRINT(nSampleBreakIdx+idx+iSubFrmOffset,idx,iSin);        \
            IT_DO_SAMPLE_PRINT(nSampleBreakIdx+idx+iSubFrmOffset,idx,Dst)
#   else
#       define DEBUG_IT_SAMPLE_BREAK(idx,Dst,iSin)                              \
            IT_DO_SIN_PRINT(nSampleBreakIdx+idx+iSubFrmOffset,idx,iSin);        \
            IT_DO_SAMPLE_PRINT(nSampleBreakIdx+idx+iSubFrmOffset,idx,Dst)
#   endif
#   if defined(IT_SIN_PRINT_INIT)
#       define DEBUG_IT_SIN_INIT(n,a,b,c,d,e)   \
                printf("%d  %+.10f  %+.10f  %+.10f  %+.10f  %+.10f\n", n, a*dIorF2F, b*dIorF2F, c*dIorF2F, d*dIorF2F, e*dIorF2F )
#   else
#       define DEBUG_IT_SIN_INIT(n,a,b,c,d,e)
#   endif
#   if defined(IT_BREAK_AT_SAMPLE) || defined(IT_BREAK_OUT_OF_RANGE) || defined(IT_SIN_PRINT_ALL) || defined(IT_SIN_PRINT_INIT)
        // break when nSampleBreak is within subframe
#       define DEBUG_IT_FRAME_BREAK \
            if ( pau->m_iCurrSubFrame == 0 && ppcinfo == pau->m_rgpcinfo )      \
            {   /* on first subframe of left channel */                         \
                nSampleBreakIdx += nSampleBreakFrameSample;                     \
                nSampleBreakFrameSample = pau->m_cFrameSampleHalfAdjusted;      \
            }                                                                   \
            IT_DO_FRAME_PRINT;                                                  \
            if ( nSampleBreakIdx+iSubFrmOffset <= nSampleBreak && nSampleBreak < (nSampleBreakIdx+iSubFrmOffset+pau->m_cSubFrameSampleAdjusted) )   \
                DEBUG_BREAK();
#   else
#       define DEBUG_IT_FRAME_BREAK
#   endif
#else
#   define DEBUG_IT_FRAME_BREAK
#   define DEBUG_IT_SAMPLE_BREAK(a,b,c)
#   define IT_NO_SIN 0x40000000
#   define DEBUG_IT_SIN_INIT(n,a,b,c,d,e)
#endif

#if defined(WMA_TARGET_SH4) && defined(BUILD_INT_FLOAT) && !defined(PREVOUTPUT_16BITS) && !defined(V4V5_COMPARE_MODE)

// for this build config find auReconMono and auSaveHistoryMono in sh4\transform_sh4.c 

#elif defined(WMA_TARGET_SH3) && defined(BUILD_INTEGER) && !defined(PREVOUTPUT_16BITS) && !defined(V4V5_COMPARE_MODE)

// for this build config find auReconMono and auSaveHistoryMono in sh3\transform_sh3.c

#elif defined(WMA_TARGET_MIPS) && defined(BUILD_INTEGER) && !defined(PREVOUTPUT_16BITS) && !defined(V4V5_COMPARE_MODE)

// for this build config find auReconMono and auSaveHistoryMono in mips\transform_mips_*.c

#else


// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
// auReconMono and auSaveHistoryMono for either Integer and Float

WMARESULT auReconMono ( CAudioObject* pau, 
                        PerChannelInfo* ppcinfo, 
                        I16* piOutput, 
                        I16* pcSampleGet,
                        Bool fForceTransformAll)
{
    //all starting from the begining of this frame
    //official starting of a subfrm (including leading zeros)
    //case 1 (Large -> Small):  starts later than what's been reconstructed w/o leading zeros
    //                          in this case dst should be skiped (this may mean memcpy from prev)
    //                          src and coef are fine
    //                          
    //case 2 (Small -> Large):  starts earler than what's been reconstructed but all leading zeros
    //                          in this case dst 

    BP2Type bp2SinT;     //temp sin value within recurrsion
    BP2Type bp2CosT;     //temp cos value within recurrsion
    CoefType *piCoef;   //floating vlaue = (float)*piCoef/(1<<5)  assuming TRANSFORM_FRACT_BITS = 5
    Int i, iEnd, iSegEnd;
    I16 *piSrc, *piDst; 
    I32 iResult;
    CoefType cfResult;
    // get local copies of these values which are used frequently or repeatedly (helps optimization)
    Int cChan = pau->m_cChannel;
    Int cSubFrameSampleHalf = pau->m_cSubFrameSampleHalfAdjusted;
    Int cSubFrameSampleQuad = pau->m_cSubFrameSampleQuadAdjusted;
    Int iCoefRecurQ2 = pau->m_iCoefRecurQ2;
    Int iCoefRecurQ3 = pau->m_iCoefRecurQ3;
    BP2Type bp2Sin  = *((BP2Type*)(&ppcinfo->m_iSin));
    BP2Type bp2Cos  = *((BP2Type*)(&ppcinfo->m_iCos));
    BP2Type bp2Sin1 = *((BP2Type*)(&ppcinfo->m_iSin1));
    BP2Type bp2Cos1 = *((BP2Type*)(&ppcinfo->m_iCos1));
    BP2Type bp2Step = *((BP2Type*)(&ppcinfo->m_iStep));
    int fTrigUpdated = 0;

#ifndef PREVOUTPUT_16BITS
    I16    *piSrcSign;
    U32     uiSignbitData;
    U32     uiSignbitCount;
#endif  // PREVOUTPUT_16BITS
#ifdef PROFILE
    FunctionProfile fp;
    FunctionProfileStart(&fp,RECON_MONO_PROFILE);
#endif
    DEBUG_IT_FRAME_BREAK;

    //persistent states
    i = ppcinfo->m_iCurrGetPCM_SubFrame;       //current position in a frame
    piCoef = (CoefType*)ppcinfo->m_rgiCoefReconCurr; 
    piSrc = ppcinfo->m_piPrevOutputCurr;

    //eventually we'll use piOutput directly
    piDst = piOutput;

    iEnd = i + *pcSampleGet;
    *pcSampleGet = 0;

    CALC_SIGN_OFFSETS(ppcinfo->m_piPrevOutput, piSrc, ppcinfo->m_piPrevOutputSign, piSrcSign, 
        uiSignbitData, uiSignbitCount, cChan)
    ASSERT_SIGNBIT_POINTER(piSrcSign);

#if defined(WMA_SHOW_FRAMES) && defined(_DEBUG)
    iSegEnd = 0;
    if (i < cSubFrameSampleQuad) iSegEnd = min (cSubFrameSampleQuad, iEnd);
    if (iSegEnd < iCoefRecurQ2)  iSegEnd = min (iCoefRecurQ2, iEnd);
    if (iSegEnd < iCoefRecurQ3)  iSegEnd = min (iCoefRecurQ3, iEnd);
    if ( i < iSegEnd )
        prvWmaShowFrames(pau, "RecMono", " %4d 0x%08x 0x%08x 0x%08x %4d %4d %4d %4d", 
            i, piCoef, piSrc, piDst, cSubFrameSampleQuad, iCoefRecurQ2, iCoefRecurQ3, iSegEnd);
#endif
    if (i < cSubFrameSampleQuad) 
    {
        DEBUG_IT_SIN_INIT(0,bp2Sin,bp2Cos,bp2Sin1,bp2Cos1,bp2Step);
        iSegEnd = min (cSubFrameSampleQuad, iEnd);
        if ( i < iSegEnd )
        {
            fTrigUpdated = 1;
            for (; i < iSegEnd; i++, (*pcSampleGet)++)    {

                COMBINE_SIGNBIT(iResult, *piSrc, piSrcSign, uiSignbitData,
                    uiSignbitCount);

                cfResult = INT_FROM_COEF( MULT_BP2(-bp2Sin,*piCoef++) + COEF_FROM_INT(iResult) );
                ROUND_SATURATE_STORE( piDst, cfResult, SHRT_MIN, SHRT_MAX, iResult );

                DEBUG_IT_SAMPLE_BREAK(i,  iResult, bp2Sin);

                piSrc += cChan;
                piDst += cChan;
                // sin(a+b) = sin(a-b) + 2*sin(b)*cos(a)
                // cos(a+b) = cos(a-b) - 2*sin(b)*sin(a)
                bp2SinT = bp2Sin1 + MULT_BP2(bp2Step,bp2Cos);
                bp2CosT = bp2Cos1 - MULT_BP2(bp2Step,bp2Sin);
                bp2Sin1 = bp2Sin;  bp2Sin = bp2SinT;
                bp2Cos1 = bp2Cos;  bp2Cos = bp2CosT;
            }
        }
    }
    if (i < iCoefRecurQ2)  
    {
        DEBUG_IT_SIN_INIT(1,bp2Sin,bp2Cos,bp2Sin1,bp2Cos1,bp2Step);
        iSegEnd = min (iCoefRecurQ2, iEnd);
        if ( i < iSegEnd )
        {
            fTrigUpdated = 1;
            for (; i < iSegEnd; i++,(*pcSampleGet)++)    {

                COMBINE_SIGNBIT(iResult, *piSrc, piSrcSign, uiSignbitData,
                    uiSignbitCount);

                cfResult = INT_FROM_COEF( MULT_BP2(bp2Sin,*--piCoef) + COEF_FROM_INT(iResult) );
                ROUND_SATURATE_STORE( piDst, cfResult, SHRT_MIN, SHRT_MAX, iResult );

                DEBUG_IT_SAMPLE_BREAK(i, iResult, bp2Sin);

                piSrc += cChan;
                piDst += cChan;

                bp2SinT = bp2Sin1 + MULT_BP2(bp2Step,bp2Cos);
                bp2CosT = bp2Cos1 - MULT_BP2(bp2Step,bp2Sin);
                bp2Sin1 = bp2Sin;  bp2Sin = bp2SinT;
                bp2Cos1 = bp2Cos;  bp2Cos = bp2CosT;
            }
        }
    }
    if (i < iCoefRecurQ3) 
    {
        iSegEnd = min (iCoefRecurQ3, iEnd);
        for (; i < iSegEnd; i++,(*pcSampleGet)++)    {
            cfResult = INT_FROM_COEF( *--piCoef );
            ROUND_SATURATE_STORE( piDst, cfResult, SHRT_MIN, SHRT_MAX, iResult );
            DEBUG_IT_SAMPLE_BREAK(i, iResult, IT_NO_SIN);
            piDst += cChan;
        }
    }

    SAVE_SIGNBIT_STATE(piSrcSign,uiSignbitData);
    if ( fTrigUpdated )
    {
        *(BP2Type*)(&ppcinfo->m_iSin)  = bp2Sin;
        *(BP2Type*)(&ppcinfo->m_iCos)  = bp2Cos;
        *(BP2Type*)(&ppcinfo->m_iSin1) = bp2Sin1;
        *(BP2Type*)(&ppcinfo->m_iCos1) = bp2Cos1;
    }
    ppcinfo->m_rgiCoefReconCurr = (Int*)piCoef;
    ppcinfo->m_iCurrGetPCM_SubFrame = (I16)i;
    ppcinfo->m_piPrevOutputCurr = piSrc;
#ifdef PROFILE
    FunctionProfileStop(&fp);
#endif
    return WMA_OK;
}

#if !defined(WMA_TARGET_X86) || !defined(USE_SIN_COS_TABLES) || defined(PREVOUTPUT_16BITS) || defined (BUILD_INTEGER) || defined (DISABLE_OPT)
WMARESULT auSaveHistoryMono (CAudioObject* pau, 
                            PerChannelInfo* ppcinfo, 
                            Bool fForceTransformAll)
{
    BP2Type bp2SinT;     //temp sin value within recurrsion
    BP2Type bp2CosT;     //temp cos value within recurrsion
    CoefType *piCoef;   //floating vlaue = (float)*piCoef/(1<<5)  assuming TRANSFORM_FRACT_BITS = 5
    
    Int i;      // , iEnd, iSegEnd;
    I16 *piDst; 
    I32 iResult;
    CoefType cfResult;

    // get local copies of these values which are used frequently or repeatedly (helps optimization)
    Int cChan = pau->m_cChannel;
    // HALF_TRANSFORM: the following member variables are not restored so continue to hold their halved values
    Int cSubFrameSample3Quad = 3 * pau->m_cSubFrameSampleQuadAdjusted;
    Int iCoefRecurQ4 = pau->m_iCoefRecurQ4;
    BP2Type bp2Sin  = INTEGER_OR_INT_FLOAT( pau->m_iSinRampDownStart, pau->m_fltSinRampDownStart );
    BP2Type bp2Cos  = INTEGER_OR_INT_FLOAT( pau->m_iCosRampDownStart, pau->m_fltCosRampDownStart );
    BP2Type bp2Sin1 = INTEGER_OR_INT_FLOAT( pau->m_iSinRampDownPrior, pau->m_fltSinRampDownPrior );
    BP2Type bp2Cos1 = INTEGER_OR_INT_FLOAT( pau->m_iCosRampDownPrior, pau->m_fltCosRampDownPrior );
    BP2Type bp2Step = INTEGER_OR_INT_FLOAT( pau->m_iSinRampDownStep,  pau->m_fltSinRampDownStep  );


#ifndef PREVOUTPUT_16BITS
    I16    *piDstSign = ppcinfo->m_piPrevOutputSign;
    U32     uiSignbitData = 0;
    U32     uiSignbitCount = 0;
#endif  // PREVOUTPUT_16BITS

#ifdef PROFILE
    FunctionProfile fp;
    FunctionProfileStart(&fp,SAVE_HISTORY_MONO_PROFILE);
#endif

    //all starting from the begining of this frame
    //official starting of a subfrm (including leading zeros)
    //case 1 (Large -> Small):  starts later than what's been reconstructed w/o leading zeros
    //                          in this case dst should be skiped (this may mean memcpy from prev)
    //                          src and coef are fine
    //                          
    //case 2 (Small -> Large):  starts earler than what's been reconstructed but all leading zeros
    //                          in this case dst 

    //eventually we'll use piOutput directly
    piDst = ppcinfo->m_piPrevOutput;

    DEBUG_IT_FRAME_BREAK;

    //persistent states
    i = ppcinfo->m_iCurrGetPCM_SubFrame;       //current position in a frame
    assert( (0<=i && i<=iCoefRecurQ4) || (i==CURRGETPCM_INVALID));
    piCoef = (CoefType*)ppcinfo->m_rgiCoefReconCurr; 
    ASSERT_SIGNBIT_POINTER(piDstSign);


#if defined(WMA_SHOW_FRAMES)  && defined(_DEBUG)
    prvWmaShowFrames(pau, "SavHist", " %4d 0x%08x 0x%08x %4d %4d", 
        i, piCoef, piDst, cSubFrameSample3Quad, iCoefRecurQ4);
#endif
    DEBUG_IT_SIN_INIT(3,bp2Sin,bp2Cos,bp2Sin1,bp2Cos1,bp2Step);
    for (; i < cSubFrameSample3Quad; i++)    {

        cfResult = INT_FROM_COEF( MULT_BP2(bp2Sin,*--piCoef) );
        ROUND_SATURATE_STORE( piDst, cfResult, I17_MIN, I17_MAX, iResult );

        DEBUG_IT_SAMPLE_BREAK(i, iResult, bp2Sin);
        piDst += cChan;

        RECORD_SIGNBIT(iResult, piDstSign, uiSignbitData,
            uiSignbitCount, 1);

        bp2SinT = bp2Sin1 + MULT_BP2(bp2Step,bp2Cos);
        bp2CosT = bp2Cos1 - MULT_BP2(bp2Step,bp2Sin);
        bp2Sin1 = bp2Sin;  bp2Sin = bp2SinT;
        bp2Cos1 = bp2Cos;  bp2Cos = bp2CosT;
    }

    for (; i < iCoefRecurQ4; i++)    {

        cfResult = INT_FROM_COEF( MULT_BP2(bp2Sin,*piCoef++) );
        ROUND_SATURATE_STORE( piDst, cfResult, I17_MIN, I17_MAX, iResult );

        DEBUG_IT_SAMPLE_BREAK(i, iResult, bp2Sin);
        piDst += cChan;

        RECORD_SIGNBIT(iResult, piDstSign, uiSignbitData,
            uiSignbitCount, 1);

        bp2SinT = bp2Sin1 + MULT_BP2(bp2Step,bp2Cos);
        bp2CosT = bp2Cos1 - MULT_BP2(bp2Step,bp2Sin);
        bp2Sin1 = bp2Sin;  bp2Sin = bp2SinT;
        bp2Cos1 = bp2Cos;  bp2Cos = bp2CosT;
    }
    DEBUG_IT_SIN_INIT(5,bp2Sin,bp2Cos,bp2Sin1,bp2Cos1,bp2Step);

    ppcinfo->m_iCurrGetPCM_SubFrame = (I16)i;       //protect ourself from multiple calls

#ifdef PROFILE
    FunctionProfileStop(&fp);
#endif
    return WMA_OK;
}
#endif  // !defined(WMA_TARGET_X86) || defined(PREVOUTPUT_16BITS) || defined (BUILD_INTEGER) || defined (DISABLE_OPT)
#endif  // first SH4, then anything else



#if defined(HALF_TRANSFORM) || defined(PAD2X_TRANSFORM)
void prvSetAdjustedValues(CAudioObject *pau, Int fQToo)
{
#if defined(HALF_TRANSFORM)
    if (pau->m_fHalfTransform)
    {
        pau->m_cSubbandAdjusted            = pau->m_cSubband>>1;
        pau->m_cFrameSampleAdjusted        = pau->m_cFrameSample>>1;
        pau->m_cFrameSampleHalfAdjusted    = pau->m_cFrameSampleHalf>>1;
        pau->m_cSubFrameSampleHalfAdjusted = pau->m_cSubFrameSampleHalf>>1;
        pau->m_cSubFrameSampleAdjusted     = pau->m_cSubFrameSample>>1;
        pau->m_cSubFrameSampleQuadAdjusted = pau->m_cSubFrameSampleQuad>>1;
        pau->m_cHighCutOffAdjusted         = pau->m_cHighCutOff>>1;
        pau->m_iSizePrev >>= 1;
        pau->m_iSizeCurr >>= 1;
        pau->m_iSizeNext >>= 1;
        if (fQToo)
        {   // normally only needed at initialization time
            pau->m_iCoefRecurQ1 >>= 1;
            pau->m_iCoefRecurQ2 >>= 1;
            pau->m_iCoefRecurQ3 >>= 1;
            pau->m_iCoefRecurQ4 >>= 1;
        }
    }
    else 
#endif // defined(HALF_TRANSFORM)
#if defined(PAD2X_TRANSFORM)
    if (pau->m_fPad2XTransform)
    {
        pau->m_cSubbandAdjusted            = pau->m_cSubband<<1;
        pau->m_cFrameSampleAdjusted        = pau->m_cFrameSample<<1;
        pau->m_cFrameSampleHalfAdjusted    = pau->m_cFrameSampleHalf<<1;
        pau->m_cSubFrameSampleHalfAdjusted = pau->m_cSubFrameSampleHalf<<1;
        pau->m_cSubFrameSampleAdjusted     = pau->m_cSubFrameSample<<1;
        pau->m_cSubFrameSampleQuadAdjusted = pau->m_cSubFrameSampleQuad<<1;
        pau->m_cHighCutOffAdjusted         = pau->m_cHighCutOff;    // unchanged
        pau->m_iSizePrev <<= 1;
        pau->m_iSizeCurr <<= 1;
        pau->m_iSizeNext <<= 1;
        if (fQToo)
        {   // normally only needed at initialization time
            pau->m_iCoefRecurQ1 <<= 1;
            pau->m_iCoefRecurQ2 <<= 1;
            pau->m_iCoefRecurQ3 <<= 1;
            pau->m_iCoefRecurQ4 <<= 1;
        }
    }
    else 
#endif // defined(PAD2X_TRANSFORM)
    {
        pau->m_cSubbandAdjusted            = pau->m_cSubband;
        pau->m_cFrameSampleAdjusted        = pau->m_cFrameSample; 
        pau->m_cFrameSampleHalfAdjusted    = pau->m_cFrameSampleHalf;
        pau->m_cSubFrameSampleAdjusted     = pau->m_cSubFrameSample;
        pau->m_cSubFrameSampleHalfAdjusted = pau->m_cSubFrameSampleHalf;
        pau->m_cSubFrameSampleQuadAdjusted = pau->m_cSubFrameSampleQuad;
        pau->m_cHighCutOffAdjusted         = pau->m_cHighCutOff;
    }
}
#endif // defined(HALF_TRANSFORM) || defined(PAD2X_TRANSFORM)


//*****************************************************************************************
//
// auAdaptToSubFrameConfig
// setup paramters for handling and transisting between varying size subframes
//
//*****************************************************************************************
WMARESULT auAdaptToSubFrameConfig (CAudioObject* pau)
{
    Int i, iTotal, iSizeCurr;
    PerChannelInfo* ppcinfo;
    WMARESULT   wmaResult = WMA_OK;

#ifdef PROFILE
    //FunctionProfile fp;
    //FunctionProfileStart(&fp,ADAPT_TO_SUB_FRAME_CONFIG_PROFILE);
#endif

    assert (pau->m_subfrmconfigCurr.m_cSubFrame <= 16);
    pau->m_iSizeCurr = iSizeCurr = pau->m_subfrmconfigCurr.m_rgiSubFrameSize [pau->m_iCurrSubFrame];

    if (pau->m_subfrmconfigCurr.m_cSubFrame > 1) {
        pau->m_iIncr = LOG2 ((U32)(pau->m_cFrameSampleHalf / iSizeCurr));
        if (pau->m_iIncr >= pau->m_cPossibleWinSize)   {
            assert (WMAB_FALSE);
            wmaResult = TraceResult(WMA_E_BROKEN_FRAME);
            goto exit;
        }
        i = 0;
        iTotal = 0;
        while (i < pau->m_iIncr) {iTotal += (pau->m_cFrameSampleQuad >> i); i++;}

        pau->m_cValidBarkBand = pau->m_rgcValidBarkBand [pau->m_iIncr];
        pau->m_rgiBarkIndex   = pau->m_rgiBarkIndexOrig + pau->m_iIncr * (NUM_BARK_BAND + 1);
    }
    else {
        pau->m_iIncr = 0;
        pau->m_cValidBarkBand       = pau->m_rgcValidBarkBand [0];
        pau->m_rgiBarkIndex         = pau->m_rgiBarkIndexOrig;
    }
    pau->m_cLowCutOff  = pau->m_subfrmconfigCurr.m_rgiSubFrameSize [pau->m_iCurrSubFrame]
                    * pau->m_cLowCutOffLong / pau->m_cFrameSampleHalf;    //proportional
    pau->m_cHighCutOff = pau->m_subfrmconfigCurr.m_rgiSubFrameSize [pau->m_iCurrSubFrame]
                    * pau->m_cHighCutOffLong / pau->m_cFrameSampleHalf;    //proportional

    pau->m_cSubFrameSampleHalf   = pau->m_subfrmconfigCurr.m_rgiSubFrameSize [pau->m_iCurrSubFrame];
    pau->m_cSubFrameSample       = pau->m_cSubFrameSampleHalf * 2;
    pau->m_cSubFrameSampleQuad   = pau->m_cSubFrameSampleHalf / 2; 
    pau->m_cSubband              = pau->m_cSubFrameSampleHalf;    //50% frame overlapping

    //init; could be modified by noise sub
    ppcinfo = pau->m_rgpcinfo;
    ppcinfo->m_cSubbandActual = pau->m_cHighCutOff - pau->m_cLowCutOff;
#ifndef ENCODER
    ppcinfo->m_rgiCoefRecon   = pau->m_rgiCoefReconOrig 
                              + DOUBLE(pau->m_fPad2XTransform,
                                    pau->m_cFrameSampleHalf - pau->m_cSubFrameSampleHalf);
    ppcinfo->m_rgfltCoefRecon = (Float *)(ppcinfo->m_rgiCoefRecon); 
#endif // ENCODER
    if (pau->m_cChannel == 2)   {
        ppcinfo = pau->m_rgpcinfo + 1;
        ppcinfo->m_cSubbandActual = pau->m_rgpcinfo [0].m_cSubbandActual;
#ifndef ENCODER
        ppcinfo->m_rgiCoefRecon   = pau->m_rgiCoefReconOrig 
                                  + DOUBLE(pau->m_fPad2XTransform,
                                        2 * pau->m_cFrameSampleHalf - pau->m_cSubFrameSampleHalf);
        ppcinfo->m_rgfltCoefRecon = (Float *)(ppcinfo->m_rgiCoefRecon); 
#endif // ENCODER
    }


#ifdef ENABLE_ALL_ENCOPT
    //update first noise index
    if (pau->m_fNoiseSub == WMAB_TRUE)    {
        pau->m_iFirstNoiseIndex = (Int) ftoi(0.5F + pau->m_fltFirstNoiseFreq * pau->m_cSubFrameSample 
            / ((Float) pau->m_iSamplingRate));  //open end
        if (pau->m_iFirstNoiseIndex > pau->m_cSubband) 
            pau->m_iFirstNoiseIndex = pau->m_cSubband;

        // use precalculated values
        pau->m_iFirstNoiseBand = pau->m_rgiFirstNoiseBand[pau->m_iIncr];
    }
#endif //ENABLE_ALL_ENCOPT

    //to decide the current window shape; look at sizes on the left and right

    pau->m_iSizePrev = (pau->m_iCurrSubFrame > 0) ? 
                        pau->m_subfrmconfigCurr.m_rgiSubFrameSize [pau->m_iCurrSubFrame - 1] :
                        pau->m_subfrmconfigPrev.m_rgiSubFrameSize [pau->m_subfrmconfigPrev.m_cSubFrame - 1];

    pau->m_iSizeNext = (pau->m_iCurrSubFrame < pau->m_subfrmconfigCurr.m_cSubFrame - 1) ? 
                        pau->m_subfrmconfigCurr.m_rgiSubFrameSize [pau->m_iCurrSubFrame + 1] :
                        pau->m_subfrmconfigNext.m_rgiSubFrameSize [0];


#if defined(HALF_TRANSFORM) || defined(PAD2X_TRANSFORM)
    prvSetAdjustedValues(pau, WMAB_FALSE);
#endif

    //if the adjacent size is bigger; just keep your own shape
    //otherwise a transition window is needed.
    if (pau->m_iSizePrev >= pau->m_iSizeCurr) {
        //just forward copy curr
        pau->m_iCoefRecurQ1 = 0;
        pau->m_iCoefRecurQ2 = pau->m_iSizeCurr;
    }
    else  {
        //long start
        pau->m_iCoefRecurQ1 = (pau->m_iSizeCurr - pau->m_iSizePrev) / 2;
        pau->m_iCoefRecurQ2 = (pau->m_iSizeCurr + pau->m_iSizePrev) / 2;
    }

    if (pau->m_iSizeNext >= pau->m_iSizeCurr) {
        pau->m_iCoefRecurQ3 = pau->m_cSubFrameSampleHalfAdjusted;
        pau->m_iCoefRecurQ4 = pau->m_cSubFrameSampleAdjusted;
    }
    else    {
        //just backward copy curr
        pau->m_iCoefRecurQ3 = pau->m_cSubFrameSampleHalfAdjusted + (pau->m_iSizeCurr - pau->m_iSizeNext) / 2;
        pau->m_iCoefRecurQ4 = pau->m_cSubFrameSampleHalfAdjusted + (pau->m_iSizeCurr + pau->m_iSizeNext) / 2;
    }

    prvAdaptTrigToSubframeConfig(pau);

exit:
#ifdef PROFILE
    //FunctionProfileStop(&fp);
#endif
    return wmaResult;
}



#if defined(BUILD_INTEGER) || defined(INTEGER_ENCODER)
WMARESULT prvAdaptTrigToSubframeConfig_INT(CAudioObject *pau)
{
    WMARESULT wmaResult = WMA_OK;
    const SinCosTable*  pSinCosTable;
    Int                 iSize;


    //if the adjacent size is bigger; just keep your own shape
    //otherwise a transition window is needed.
    if (pau->m_iSizePrev >= pau->m_iSizeCurr)
        iSize = pau->m_iSizeCurr;  //just forward copy curr
    else
        iSize = pau->m_iSizePrev;  //long start

#if 0 //def USE_SIN_COS_TABLES 
//marchold:I removed this code as I do not bieleve it to be necessary
    switch (iSize){
        case 2048:
            pau->m_piSinForRecon = pau->m_piSinForRecon2048;
            break;
        case 1024:
            pau->m_piSinForRecon = pau->m_piSinForRecon1024;
            break;
        case 512 :
            pau->m_piSinForRecon = pau->m_piSinForRecon512;
            break;
        case 256 :
            pau->m_piSinForRecon = pau->m_piSinForRecon256;
            break;
        case 128 :
            pau->m_piSinForRecon = pau->m_piSinForRecon128;
            break;
        case 64  :
            pau->m_piSinForRecon = pau->m_piSinForRecon64;
            break;
        default: 
            assert (0);
            return (TraceResult (WMA_E_BROKEN_FRAME));
    }
#endif  //maby else out next section

    // Use lookup-tables if we can
    if (iSize >= 64 && iSize <= 2048)
    {
        pSinCosTable = rgSinCosTables[iSize>>7];

        // START = sin( PI/(4*cSB) ) and cos( PI/(4*cSB) )
        pau->m_iSinRampUpStart =  pSinCosTable->sin_PIby4cSB>>1;    //(Int) (sin (0.5 * PI / iSizeCurr / 2) * 0x3FFFFFFF);
        pau->m_iCosRampUpStart =  pSinCosTable->cos_PIby4cSB>>1;    //(Int) (cos (0.5 * PI / iSizeCurr / 2) * 0x3FFFFFFF);

        // PRIOR should be sin(PI/(4*cSB) - PI/(2*cSB) ) = sin( -PI/(4*cSB) )
        pau->m_iSinRampUpPrior = -pSinCosTable->sin_PIby4cSB>>1;
        pau->m_iCosRampUpPrior =  pSinCosTable->cos_PIby4cSB>>1;
        pau->m_iSinRampUpStep  =  pSinCosTable->sin_PIby2cSB;   // STEP = 2 * sin (PI / 2 / iSizeCurr) * 0x3FFFFFFF;
    }
    else
    {
        pau->m_iSinRampUpStart =  (I32) (sin (0.5 * PI / iSize / 2) * NF2BP2);
        pau->m_iCosRampUpStart =  (I32) (cos (0.5 * PI / iSize / 2) * NF2BP2);
        pau->m_iSinRampUpPrior =  (I32) -(sin(0.5 * PI / iSize / 2) * NF2BP2);
        pau->m_iCosRampUpPrior =  (I32) (cos (0.5 * PI / iSize / 2) * NF2BP2);
        pau->m_iSinRampUpStep  =  (I32) (sin (PI / 2 / iSize) * NF2BP1);
    }

    // Include the next code-block to verify changes to the lookup-table
#ifdef _DEBUG
    assert(abs(pau->m_iSinRampUpStart - ((I32) (sin (0.5 * PI / iSize / 2) * NF2BP2))) <= 10000);
    assert(abs(pau->m_iCosRampUpStart - ((I32) (cos (0.5 * PI / iSize / 2) * NF2BP2))) <= 10000);
    assert(abs(pau->m_iSinRampUpPrior - ((I32) -(sin(0.5 * PI / iSize / 2) * NF2BP2))) <= 10000);
    assert(abs(pau->m_iCosRampUpPrior - ((I32) (cos (0.5 * PI / iSize / 2) * NF2BP2))) <= 10000);
    assert(abs(pau->m_iSinRampUpStep  - ((I32) (sin (PI / 2 / iSize) * NF2BP1))) <= 10000); // STEP = 2 * 
#endif


    
    if (pau->m_iSizeNext >= pau->m_iSizeCurr)
        iSize = pau->m_iSizeCurr;
    else
        iSize = pau->m_iSizeNext;  //just backward copy curr


    // Use lookup-tables if we can
    if (iSize >= 64 && iSize <= 2048)
    {
        pSinCosTable = rgSinCosTables[iSize>>7];

        // START = sin ((0.5 + cSB) * PI / (2*cSB) )
        //       = sin ( PI/(4*cSB) + PI/2 ) =  cos( PI/(4*cSB) )
        //         cos ((0.5 + cSB) * PI / (2*cSB) )
        //       = cos ( PI/(4*cSB) + PI/2 ) = -sin( PI/(4*cSB) )
        pau->m_iSinRampDownStart =  pSinCosTable->cos_PIby4cSB>>1;  //(Int) sin ((0.5 + iSizeNext) * PI / iSizeNext / 2);
        pau->m_iCosRampDownStart = -pSinCosTable->sin_PIby4cSB>>1;  //(Int) cos ((0.5 + iSizeNext) * PI / iSizeNext / 2);
        // PRIOR = sin ((0.5 + cSB) * PI / (2*cSB) -PI/(2*cSB) )
        //       = sin ( PI/(4*cSB) + PI/2 - PI/(2*cSB) ) = cos( -PI/(4*cSB) ) = cos( PI/(4*cSB) )
        //         cos ((0.5 + cSB) * PI / (2*cSB) -PI/(2*cSB) )
        //       = cos ( PI/(4*cSB) + PI/2 - PI/(2*cSB) ) =  -sin( -PI/(4*cSB) ) = sin( PI/(4*cSB) )
        pau->m_iSinRampDownPrior =  pSinCosTable->cos_PIby4cSB>>1;
        pau->m_iCosRampDownPrior =  pSinCosTable->sin_PIby4cSB>>1;
        pau->m_iSinRampDownStep  =  pSinCosTable->sin_PIby2cSB;     // STEP = 2 * sin (PI / 2 / iSizeCurr) * 0x3FFFFFFF;
    }
    else
    {
        pau->m_iSinRampDownStart =  (I32) (cos (0.5 * PI / iSize / 2) * NF2BP2);
        pau->m_iCosRampDownStart =  (I32) (-sin(0.5 * PI / iSize / 2) * NF2BP2);
        pau->m_iSinRampDownPrior =  (I32) (cos(0.5 * PI / iSize / 2) * NF2BP2);
        pau->m_iCosRampDownPrior =  (I32) (sin(0.5 * PI / iSize / 2) * NF2BP2);
        pau->m_iSinRampDownStep  =  (I32) (sin (PI / (2 * iSize)) * NF2BP1);
    }

    // Include the next code-block to verify changes to the lookup-table
#ifdef _DEBUG
    assert(abs(pau->m_iSinRampDownStart - ((I32) (cos (0.5 * PI / iSize / 2) * NF2BP2))) <= 10000);
    assert(abs(pau->m_iCosRampDownStart - ((I32) (-sin(0.5 * PI / iSize / 2) * NF2BP2))) <= 10000);
    assert(abs(pau->m_iSinRampDownPrior - ((I32) (cos(0.5 * PI / iSize / 2) * NF2BP2))) <= 10000);
    assert(abs(pau->m_iCosRampDownPrior - ((I32) (sin(0.5 * PI / iSize / 2) * NF2BP2))) <= 10000);
    assert(abs(pau->m_iSinRampDownStep  - ((I32) (sin (PI / (2 * iSize)) * NF2BP1))) <= 10000);
#endif
    return wmaResult;
}
#endif  // defined(BUILD_INTEGER) || defined(INTEGER_ENCODER)


#ifdef BUILD_INTEGER
WMARESULT prvAdaptTrigToSubframeConfig(CAudioObject *pau)
{
    WMARESULT wmaResult;
    ASSERTWMA_EXIT (wmaResult, prvAdaptTrigToSubframeConfig_INT(pau));
exit:
    return wmaResult;
}
#endif  // BUILD_INTEGER

//*****************************************************************************************
//
// auUpdateMaxEsc
//
//*****************************************************************************************
Void    auUpdateMaxEsc(CAudioObject* pau, Int iQuantStepSize)
{
    // HongCho: Adjust the max Tunstall level according to the quantization step...
    //          Matching if's in the decoder...
    //          Too many?  Maybe...
    // HongCho: Note...  For 22.05kHz, even with all 15bits, the bells don't ring...
    if(iQuantStepSize < 5)       pau->m_iMaxEscSize = 13;
    else if(iQuantStepSize < 15) pau->m_iMaxEscSize = 13;
    else if(iQuantStepSize < 32) pau->m_iMaxEscSize = 12;
    else if(iQuantStepSize < 40) pau->m_iMaxEscSize = 11;
    else if(iQuantStepSize < 45) pau->m_iMaxEscSize = 10;
    else if(iQuantStepSize < 55) pau->m_iMaxEscSize =  9;
    else                         pau->m_iMaxEscSize =  9;
    pau->m_iMaxEscLevel = (1<<pau->m_iMaxEscSize) - 1;
}


#if defined(INTERPOLATED_DOWNSAMPLE)

// Stolen from Algorithms in C, Sedgewick
Int GCD (Int u, Int v)
{
    Int t;

    while (u > 0)
    {
        if (u < v)
        {
            // Swap 'em
            t = u;
            u = v;
            v = t;
        }

        u = u - v;
    }

    return v;
}


void prvInterpolateInit(CAudioObject *pau, Int iSrcSampleRate,
                        Int iDstSampleRate, Int iAddInterval)
{
    Int iGCD;

    pau->m_iInterpolSrcBlkSize = iSrcSampleRate;
    pau->m_iInterpolDstBlkSize = iDstSampleRate;

    // Calculate the greatest common divisor between iSrcSampleRate
    // and iDstSampleRate and use to reduce iSrcBlkSize, iDstBlkSize
    iGCD = GCD(iSrcSampleRate, iDstSampleRate);
    if (0 != iGCD)
    {
        pau->m_iInterpolSrcBlkSize /= iGCD;
        pau->m_iInterpolDstBlkSize /= iGCD;
    }

    // Calculate pointer and difference increments to avoid div/mod ops
    pau->m_iInterpolIncr = pau->m_iInterpolSrcBlkSize / pau->m_iInterpolDstBlkSize;
    pau->m_iInterpolCarry = pau->m_iInterpolSrcBlkSize % pau->m_iInterpolDstBlkSize;

    // Calculate fixed-point increment to interpolation weight (x2 - x')
    pau->m_iInterpolWeightIncr = (I32) (-((float)pau->m_iInterpolSrcBlkSize /
        (float)pau->m_iInterpolDstBlkSize) * (1 << INTERPOL_FRACTBITS));

    pau->m_iInterpolAddInterval = iAddInterval;
    pau->m_iInterpolNextAdd = iAddInterval;
}


#ifdef BUILD_INTEGER
void auLowPass(CAudioObject *pau, Int *rgCoef, Int iNumCoefs)
{
    Int    *pEnd = rgCoef + iNumCoefs * 2; // Re and Im coefs (so times 2)
    Int    *pCurr;
#else   // BUILD_INTEGER
void auLowPass(CAudioObject *pau, Float *rgCoef, Int iNumCoefs)
{
    Float  *pEnd = rgCoef + iNumCoefs * 2; // Re and Im coefs (so times 2)
    Float  *pCurr;
#endif  // BUILD_INTEGER

    Int     iPassThruCoefs;

    // Figure out how many coefficients will pass through untouched
    iPassThruCoefs = (pau->m_iInterpolDstBlkSize * iNumCoefs) / 
        pau->m_iInterpolSrcBlkSize;
    pCurr = rgCoef + (2 * iPassThruCoefs);   // Re and Im coefs (so times 2)
    iNumCoefs -= iPassThruCoefs;

    while (iNumCoefs > 0)
    {
        *pCurr++ = 0;       // Re coef
        *pCurr++ = 0;       // Im coef
        iNumCoefs -= 1;
    }

    assert(pCurr == pEnd);
}
#endif  // defined(INTERPOLATED_DOWNSAMPLE)


#ifdef INTERPOLATED_DOWNSAMPLE
// We assume piSrc and piDst point to I16, channel-interleaved buffers
void prvInterpolate(CAudioObject *pau, I16 *piSourceBuffer, Int iNumSrcBytes,
                    Int iChannels, I16 *piDestBuffer, Int *piNumDstBytes, U16* pcSamples)
{
    Int iCurrChannel;
    Int iNewNextAdd = pau->m_iInterpolNextAdd;

    // Check if source buffer is a multiple of indivisible src blk size
    assert(0 == (iNumSrcBytes % pau->m_iInterpolSrcBlkSize));

    *piNumDstBytes = 0;
    *pcSamples = 0;
    for (iCurrChannel = 0; iCurrChannel < iChannels; iCurrChannel += 1)
    {
        const Int c_iInterpolationBlks = iNumSrcBytes /
            (iChannels * pau->m_iInterpolSrcBlkSize * sizeof(I16));

        I16    *piPrevSrc = piSourceBuffer + iCurrChannel;
        I16    *piSrc = piSourceBuffer + iCurrChannel + iChannels;
        I16    *piDst = piDestBuffer + iCurrChannel;
        Int     iNextAdd = pau->m_iInterpolNextAdd;
        Int     i;
        Bool    fAddExtraSample;

        // If we are not to add extra samples, set us up so iNextAdd never hits 0
        if (0 == iNextAdd)
        {
            iNextAdd = (c_iInterpolationBlks * pau->m_iInterpolDstBlkSize) + 1;
            fAddExtraSample = WMAB_FALSE;
        }
        else
            fAddExtraSample = WMAB_TRUE;

        for (i = 0; i < c_iInterpolationBlks; i++)
        {
            I32     fiWeight = (1 << INTERPOL_FRACTBITS);
            Int     iPtrIncrCarry = 0;
            Int     j;

#ifdef _DEBUG
            const Float c_fltWeightIncr = -((float)pau->m_iInterpolSrcBlkSize /
                (float)pau->m_iInterpolDstBlkSize);
            Float   fltWeight = 1.0f;
            Float   fltResult;
            Float   fltDiff;
            Float   fltRelErr;

            fltDiff = c_fltWeightIncr - ((float) pau->m_iInterpolWeightIncr /
                (float) (1 << INTERPOL_FRACTBITS));
            fltRelErr = fltDiff / c_fltWeightIncr;
            assert(0 == fltDiff || fltRelErr < 0.1f);
#endif  // _DEBUG

            for (j = 0; j < pau->m_iInterpolDstBlkSize; j++)
            {
                Int iSrcIncr;

                // Pre-read prev and next src to help compiler optimization
                // and to allow debug code to verify, since interpolation is in-place
                const I16   iPrevSrc = *piPrevSrc;
                const I16   iNextSrc = *piSrc;

                // Interpolate output sample (No rounding. I tried rounding but
                // it makes little difference and it adds 2% to computation time)
                *piDst = (I16) (MULT_HI_DWORD(fiWeight, (iPrevSrc -
                    iNextSrc) << (32 - INTERPOL_FRACTBITS)) + iNextSrc);

                // Add an extra sample if it's time to do so
                iNextAdd -= 1;
                if (iNextAdd <= 0)
                {
                    assert(iNextAdd == 0);
                    assert(fAddExtraSample);
                    *(piDst + iChannels) = *piDst;
                    piDst += iChannels;
                    iNextAdd = pau->m_iInterpolAddInterval;
                }

#ifdef _DEBUG
                fltResult = (I16) ROUNDF(fltWeight * (iPrevSrc - iNextSrc) + iNextSrc);
                fltDiff = fltResult - *piDst;
                fltRelErr = fltDiff / fltResult;
                assert(fabs(fltDiff) <= 1.0f || fabs(fltRelErr) < 0.1f);
#endif  // _DEBUG

                // Check if we need to carry
                iSrcIncr = pau->m_iInterpolIncr;
                iPtrIncrCarry += pau->m_iInterpolCarry;
                if (iPtrIncrCarry >= pau->m_iInterpolDstBlkSize)
                {
                    // Perform carry
                    iSrcIncr += 1;
                    iPtrIncrCarry -= pau->m_iInterpolDstBlkSize;
                }

                // Update pointers and vars
                piPrevSrc += iSrcIncr * iChannels;
                piSrc += iSrcIncr * iChannels;
                piDst += iChannels;

                // Now calculate the next weighting
                fiWeight += pau->m_iInterpolWeightIncr + (iSrcIncr << INTERPOL_FRACTBITS);

#ifdef _DEBUG
                fltWeight += c_fltWeightIncr + iSrcIncr;
                fltDiff = fltWeight - ((float)fiWeight / (float)(1 << INTERPOL_FRACTBITS));
                fltRelErr = fltDiff / fltWeight;
                assert(0 == fltDiff || fabs(fltRelErr) < 0.1f);
#endif  // _DEBUG

            } // for (interpolation block)
        } // for (entire source block)

        // Output number of samples outputted after interpolation
        *piNumDstBytes += sizeof(I16) * (piDst - iCurrChannel - piDestBuffer) / iChannels;

        // Record new countdown to next extra sample, unless we're not to add new samples
        if (0 == iCurrChannel && fAddExtraSample)
            iNewNextAdd = iNextAdd;

        assert(WMAB_FALSE == fAddExtraSample || iNextAdd == iNewNextAdd);

    } // for (all channels)

    *pcSamples = (*piNumDstBytes) / ( sizeof(I16) * iChannels );
    assert(*piNumDstBytes % (iChannels * sizeof(I16)) == 0);
    assert( *piNumDstBytes == (Int)(sizeof(I16) * (*pcSamples) * iChannels) );
    pau->m_iInterpolNextAdd = iNewNextAdd;

} // prvInterpolate

#endif  // INTERPOLATED_DOWNSAMPLE



//*****************************************************************************************
//
// qstCalcQuantStep
// like auCalcQuantStep but returns a QuantStepType which is either:
//   a FastFloat (for integer builds), a Float (Decoder) or a Double(Encoder)
//
//*****************************************************************************************
QuantStepType qstCalcQuantStep(Int iQSS) 
{
    QuantStepType qstQuantStep;

#if defined(BUILD_INTEGER) || defined(INTEGER_ENCODER)
    if ( iQSS < DBPOWER_TABLE_OFFSET )
    {   // This happens when iPower==0, not an important case, but return 10^(1/20) with 28 FractBits
        // It can also happen with a small NoisePower (-13 has been seen)
        if ( iQSS < 0 )
        {   // negative values of iQSS are being generated in the V5 encoder (LowRate in particular)
            qstQuantStep.iFraction = (I32)(0.382943866392*(1<<QUANTSTEP_FRACT_BITS)),      // Average Fraction
            qstQuantStep.iFracBits = QUANTSTEP_FRACT_BITS - ((-iQSS>>3)+1);                // Approximate Exponent
        }
        else
        {
            qstQuantStep.iFraction = (I32)(0.869439785679*(1<<QUANTSTEP_FRACT_BITS));     // Average Fraction
            qstQuantStep.iFracBits = QUANTSTEP_FRACT_BITS - ((iQSS>>3)+1);                // Approximate Exponent
        }
    }
    else if ( iQSS < (DBPOWER_TABLE_OFFSET+DBPOWER_TABLE_SIZE) )
    {   
        // *** normal case ***
        qstQuantStep.iFraction = rgDBPower10[ iQSS - DBPOWER_TABLE_OFFSET ];
        qstQuantStep.iFracBits = QUANTSTEP_FRACT_BITS - ((iQSS>>3)+4);    // implied FractBit scale for rgiDBPower table
        NormUInt( (UInt*)(&qstQuantStep.iFraction), &qstQuantStep.iFracBits, 0x3FFFFFFF );
    }
    else
    {   // This branch can handle out-of-range cases. 
        // rare - but used in some cases by encoder - e.g. Tough_16m_16, Tough_22m_22(?).
        const double    c_dblTenExpToTwo = 3.3219280948873623478703194294894; // ln(10)/ln(2);
        const double    c_dblPointNineNine = (1.0 - DBL_EPSILON);
        double  dblQuantStep,  dblExponent;
        Int     iNumWholeBits,  iNumFractBits;
        dblExponent = (double)(iQSS/(Float)QUANTSTEP_DENOMINATOR);
        dblQuantStep = pow (10, dblExponent);
        iNumWholeBits = (Int)(dblExponent * c_dblTenExpToTwo + c_dblPointNineNine); // Round UP
        iNumWholeBits = max(iNumWholeBits, 5);
        iNumFractBits = max(31 - iNumWholeBits, TRANSFORM_FRACT_BITS);
        if (dblQuantStep * (1 << iNumFractBits) <= UINT_MAX)
            qstQuantStep.iFraction = (I32)(dblQuantStep * (1 << iNumFractBits));
        else
            qstQuantStep.iFraction = UINT_MAX;      // iQSS of 218 seen in encoding Tough 16kHz Stereo 16kbps
        qstQuantStep.iFracBits = iNumFractBits;
        NormUInt( (UInt*)(&qstQuantStep.iFraction), &qstQuantStep.iFracBits, 0x3FFFFFFF );
    }
    MONITOR_RANGE( gMR_qstQuantStep, (qstQuantStep.iFraction)/(Double)(1 << qstQuantStep.iFracBits) );    

#else   // must be BUILD_INT_FLOAT or float encoder

    if ( iQSS < DBPOWER_TABLE_OFFSET )
    {   // This happens when iPower==0, not an important case, but return 10^(1/20) with 28 FractBits
        // It can also happen with a small NoisePower (-13 has been seen)
        if ( iQSS < 0 )
        {   // negative values of iQSS are being generated in the V5 encoder (LowRate in particular)
            qstQuantStep = 0.382943866392f,      // Average Fraction
            qstQuantStep /= (Float)(1<<((-iQSS>>3)+1));                // Approximate Exponent
        }
        else
        {
            qstQuantStep = 0.869439785679f;             // Average Fraction
            qstQuantStep *= (Float)(1<<((iQSS>>3)+1));      // Approximate Exponent
        }
    }
    else if ( iQSS < (DBPOWER_TABLE_OFFSET+DBPOWER_TABLE_SIZE) )
    {   // *** normal case ***
        // implied FractBit scale for rgiDBPower table
        qstQuantStep = rgDBPower10[ iQSS - DBPOWER_TABLE_OFFSET ] * rgfltDBPowerExponentScale[iQSS>>3];
    }
    else
    {   // This branch can handle out-of-range cases. 
        // rare - but used in some cases by encoder - e.g. Tough_16m_16.
        // iQSS of 218 seen in encoding Tough 16kHz Stereo 16kbps
        qstQuantStep = (QuantStepType)pow (10, (double)(iQSS/(Float)QUANTSTEP_DENOMINATOR) );
    }
    MONITOR_RANGE( gMR_qstQuantStep, qstQuantStep );

#endif

    return( qstQuantStep );
}


//*****************************************************************************************
//
// prvWeightedQuantization
// calculate 10^( (MaskQ-MaxMaskQ)*2.5*0.5/20 ) * 10^( QuantStepSize/20 )
//         = (10^(1/16))^( MaskQ-MaxMaskQ )     * (10^(1/20)^QuantStepSize
//*****************************************************************************************
QuantFloat prvWeightedQuantization(CAudioObject *pau, PerChannelInfo *ppcinfo, Int iBark)
{
    Int iIndex = ppcinfo->m_iMaxMaskQ - ppcinfo->m_rgiMaskQ[iBark];
    QuantFloat qfltRMS;
    assert( 0 <= iIndex );

    if (iIndex >= MASK_MINUS_POWER_TABLE_SIZE)
        iIndex = MASK_MINUS_POWER_TABLE_SIZE-1;
#if defined(BUILD_INTEGER) ||defined(INTEGER_ENCODER)
    {
        Int uiFraction, iFracBits;
        uiFraction = rgiMaskMinusPower10[ iIndex ];     // with MASK_POWER_FRAC_BITS==28 fractional bits
        iFracBits = MASK_POWER_FRAC_BITS+(iIndex>>2);
        MONITOR_RANGE(gMR_WeightRatio,(float)uiFraction/pow(2,iFracBits));
#       ifdef _DEBUG
        {
            Float realRMS = (Float)pow(10,(float)(ppcinfo->m_rgiMaskQ[iBark] - ppcinfo->m_iMaxMaskQ)/(1<<4));
            Float Calculated = (float)uiFraction/(float)pow(2,iFracBits); 
            Float diff = (Float)fabs(realRMS-Calculated);
            Float rel = (Float)fabs(diff/realRMS);
            if (rel > .00002)
                DEBUG_BREAK();
        }
#       endif
        qfltRMS.iFraction = MULT_HI(pau->m_qstQuantStep.iFraction,uiFraction);  
        qfltRMS.iFracBits = pau->m_qstQuantStep.iFracBits + iFracBits - 31;
        Norm4FastFloat( &qfltRMS );
    }

#else

    qfltRMS = rgiMaskMinusPower10[ iIndex ] / (Float)(1<<(iIndex>>2));
    MONITOR_RANGE(gMR_WeightRatio,qfltRMS);
    qfltRMS *= FLOAT_FROM_QUANTSTEPTYPE( pau->m_qstQuantStep );  

#endif

    return qfltRMS;
}

//*****************************************************************************************
//
// VERIFY_DECODED_COEFFICENT
//
// define VERIFY_DECODED_COEFS and set fltCoefIntFloatThreshold
//
//*****************************************************************************************
//#define VERIFY_DECODED_COEFS
#if defined(_DEBUG) && defined(VERIFY_DECODED_COEFS)
#   pragma COMPILER_MESSAGE(__FILE__ "(1235) : Warning - Decode Coef HighRate Debug Code Enabled.")
// define threshold ((it can be changed from debugger))
static Float fltCoefIntFloatThreshold = 0.00075F;
static void VerifyDecodedCoefficentHR(CAudioObject* pau, PerChannelInfo* ppcinfo, 
                                          Int iBark, CoefType iRecon, I16 iLevel, CoefType ctCoefRecon) {
    Float ff, f3, dif, rel, fltRecon;
    static Float fltReconMin = 1.0e30F;
    static Float fltReconMax = -1;
    Double dblQuantStep = DOUBLE_FROM_QUANTSTEPTYPE(pau->m_qstQuantStep);
    Float fltWeightFactor = ((float)ppcinfo->m_rgiWeightFactor[iBark])  / (1<<WEIGHTFACTOR_FRACT_BITS);     // divide by 1024.
    Float fltInvMaxWeight = 1.0F / ((float)ppcinfo->m_iMaxWeight / (1<<WEIGHTFACTOR_FRACT_BITS));           // didive by 1024.
    fltRecon = FLOAT_FROM_COEF(ctCoefRecon);                                                                // divide by 32.
    // This is the statement in float.c we are to match
    // rgfltCoefRecon [iRecon] = ((Float) rgiCoefQ [iCoefQ]) * rgfltWeightFactor [iBark] * ((Float) dblQuantStep) * fltInvMaxWeight;
    ff = fltWeightFactor * ((Float) dblQuantStep) * fltInvMaxWeight;
    f3 = ((Float) iLevel) * ff;
    dif = (float) fabs(f3 - fltRecon);  
    rel = (float) fabs(dif/f3); 
    // was ((iRecon < pau->m_cHighCutOff) && (dif > 2) && rel > 0.2)
    // fltRecon seems to range from 1e7 down to about 1.0, small values seem to be less accurate
    // consider using the same comparison as used with MidRate (See LowRate.c)
   if ( rel > (f3 > 100 ? fltCoefIntFloatThreshold : (fltCoefIntFloatThreshold*100/f3)) )   
        DEBUG_BREAK();
}
#define VERIFY_DECODED_COEFFICENT(idxBark) VerifyDecodedCoefficentHR(pau, ppcinfo, idxBark, iRecon, iLevel, ctCoefRecon)
#else
#define VERIFY_DECODED_COEFFICENT(idxBark)
#endif


// *************************************************************************************
// DEBUG_BREAK at a particular Frame in auReconCoefficentsHighRate
//
//#define DECODE_COEF_AT_FRAME 435
//#define DECODE_COEF_AT_SUBFRAME 0
//
#if defined(_DEBUG) && ( defined(DECODE_COEF_AT_FRAME) || defined(DECODE_COEF_AT_SUBFRAME) )
#   pragma COMPILER_MESSAGE(__FILE__ "(1154) : Warning - Decode Coefficient Debug Code Enabled.")
#   if defined(DECODE_COEF_AT_FRAME) && defined(DECODE_COEF_AT_SUBFRAME)
#       define DEBUG_BREAK_AT_FRAME_DECODE                                                          \
            if (  ( pau->m_iFrameNumber == DECODE_COEF_AT_FRAME || DECODE_COEF_AT_FRAME < 0 )       \
                &&( pau->m_iCurrSubFrame == DECODE_COEF_AT_SUBFRAME || DECODE_COEF_AT_SUBFRAME < 0 ) ) \
                DEBUG_BREAK();              
#   elif defined(DECODE_COEF_AT_FRAME)
#       define DEBUG_BREAK_AT_FRAME_DECODE                                                          \
            if ( pau->m_iFrameNumber == DECODE_COEF_AT_FRAME || DECODE_COEF_AT_FRAME < 0 )          \
                DEBUG_BREAK();              
#   else
#       define DEBUG_BREAK_AT_FRAME_DECODE                                                          \
            if ( pau->m_iCurrSubFrame == DECODE_COEF_AT_SUBFRAME || DECODE_COEF_AT_SUBFRAME < 0 )   \
                DEBUG_BREAK();
#   endif               
#else   // defined(_DEBUG) && defined(DECODE_COEF_AT_FRAME)
#   define DEBUG_BREAK_AT_FRAME_DECODE
#endif  // defined(_DEBUG) && defined(DECODE_COEF_AT_FRAME)


//#define RL_PRINT_SRC
#if defined(_DEBUG) && defined(RL_PRINT_SRC) && !defined(WMA_MONITOR)
#   define DBG_RUNLEVEL(a,b,c,d,e)                          \
        if(e) {                                             \
            printf("%d %d %d %d\n", a, b, c, d+1);          \
            fflush (stdout);                                \
        }
#elif defined(_DEBUG) && defined(RL_PRINT_SRC) && defined(WMA_MONITOR)
#   define DBG_RUNLEVEL(a,cRunOfZeros,iLevel,iSign,e)                       \
        if(e) {                                                             \
            printf("%d %d %d %d\n", a, b, c, d+1);                          \
            fflush (stdout);                                                \
        }                                                                   \
        MONITOR_RANGE(gMR_iCoefQ,(iLevel^iSign)-iSign);                     \
        MONITOR_COUNT_CONDITIONAL(cRunOfZeros>0,gMC_0CoefQ,cRunOfZeros);    \
        {   int ii;                                                         \
            for( ii = 0; ii < cRunOfZeros; ii++ )                           \
                MONITOR_RANGE(gMR_CoefRecon,0);                             \
            MONITOR_COUNT(gMC_zeroCoefRecon,cRunOfZeros);                   \
        }
#elif defined(_DEBUG) && !defined(RL_PRINT_SRC) && defined(WMA_MONITOR)
#   define DBG_RUNLEVEL(a,cRunOfZeros,iLevel,iSign,e)                       \
        MONITOR_RANGE(gMR_iCoefQ,(iLevel^iSign)-iSign);                     \
        MONITOR_COUNT_CONDITIONAL(cRunOfZeros>0,gMC_0CoefQ,cRunOfZeros);    \
        {   int ii;                                                         \
            for( ii = 0; ii < cRunOfZeros; ii++ )                           \
                MONITOR_RANGE(gMR_CoefRecon,0);                             \
            MONITOR_COUNT(gMC_zeroCoefRecon,cRunOfZeros);                   \
        }
#else
#   define DBG_RUNLEVEL(a,b,c,d,e)
#endif 


// DecodeCoefsHighRate with combined INTEGER and INT_FLOAT code

#ifdef BUILD_INTEGER

#define MULT_QUANT(iLevel,ffltQuantizer) MULT_HI(((iLevel)<<16),ffltQuantizer.iFraction)

// SCALE_COEF_RECON shifts CoefRecon to give it TRANSFORM_FRACT_BITS==5 fractional bits
#if defined(PLATFORM_OPTIMIZATION_MINIMIZE_BRANCHING)
    // This SCALE_COEF_RECON macro requires 6 ops and no branches
    // This MAKE_MASK_FOR_SCALING requires 5 ops plus 1 branch.
    // SCALE_COEFFICENT gets executed 25x as often as MAKE_MASK_FOR_SCALING, so this method requires 6.2 ops plus 0.04 branches per SCALE_COEFFICENT
#   define SCALE_COEF_RECON(iCR) (((iCR>>iShift) & iMask2) | ((iCR<<-iShift) & iMask1))
#   define MAKE_MASK_FOR_SCALING(iFB) iShift=iFB-(TRANSFORM_FRACT_BITS+31-16);                      \
                                      iMask2 = 0xFFFFFFFF ^ (iMask1 = (iShift<0) ? 0xFFFFFFFF : 0);
#else
    // When branching is not a high penaty activity, do it the simplier way
    //   iCoefRecon = (t=iFracBits-5)<0 ? iCoefRecon>>-t : iCoefRecon<<t
    // This SCALE_COEF_RECON requires 3 ops plus 1 branch or 2 ops plus 1 branch.  
    // This MAKE_MASK_FOR_SCALING requires 2 ops
    // SCALE_COEFFICENT gets executed 25x as often as MAKE_MASK_FOR_SCALING, so this method requires 2.58 ops plus 0.04 branches per SCALE_COEFFICENT
    // On one test on a 500 MHz Pentium 686, This way saves 1% execution time over masking.
#   define SCALE_COEF_RECON(iCR) (iShift<0) ? (iCR)<<-iShift : (iCR)>>iShift
#   define MAKE_MASK_FOR_SCALING(iFB) iShift=iFB+(16-31-TRANSFORM_FRACT_BITS)
#endif

#else

#define MULT_QUANT(iLevel,ffltQuantizer) (iLevel*ffltQuantizer)
#define SCALE_COEF_RECON(iCR) (iCR)
#define MAKE_MASK_FOR_SCALING(iFB)

#endif


///*****************************************************************************************
//
// auReconCoefficentsHighRate  - Integer or IntFloat Version
//
//*****************************************************************************************
//wchen: this function is not threadsafe!!
WMARESULT auReconCoefficentsHighRate (CAudioObject* pau, Void* pcaller, PerChannelInfo* ppcinfo, Int* piBitCnt)
{
    WMARESULT   wmaResult = WMA_OK;

    CoefType* rgiCoefRecon   = (CoefType*) ppcinfo->m_rgiCoefRecon;
    CoefType ctCoefRecon;
    Int iMaskResampleRatio, cValidBarkBandLatestUpdate;
    Int iBark = 0;
    I16* piRecon = &pau->m_iCurrReconCoef;
#if defined(PLATFORM_OPTIMIZATION_MINIMIZE_BRANCHING)
    Int iMask1,iMask2;
#endif
    INTEGER_ONLY( Int iShift; )
    Int iMaskResampleRatioPow;
    const Int *rgiBarkIndex;
    Int *piHighCutOff = &pau->m_iHighCutOffCurr;
    Int iHighToBeZeroed;
    QuantFloat qfltQuantizer;   // eithe a FastFloat or a Float, as appropriate to the build.
    Bool fPrint = WMAB_FALSE;
#ifdef PROFILE
    FunctionProfile fp;
    FunctionProfileStart(&fp,DECODE_COEFFICENTS_HIGH_RATE_PROFILE);
#endif

    assert (!pau->m_fNoiseSub &&  pau->m_iWeightingMode == BARK_MODE);
    assert (pau->m_subfrmconfigCurr.m_rgiSubFrameSize [pau->m_iCurrSubFrame] != 0);
    assert (pau->m_cFrameSampleHalf <= (1<<12));                                            
    assert (pau->m_iSubFrameSizeWithUpdate != 0);
    DEBUG_BREAK_AT_FRAME_DECODE;

    if (pau->m_iSubFrameSizeWithUpdate <= 0 || pau->m_subfrmconfigCurr.m_rgiSubFrameSize [pau->m_iCurrSubFrame] <= 0)
        wmaResult = WMA_E_BROKEN_FRAME;
    CHECKWMA_EXIT (wmaResult);

    iMaskResampleRatio = (pau->m_iSubFrameSizeWithUpdate << 12) /                           
                          pau->m_subfrmconfigCurr.m_rgiSubFrameSize [pau->m_iCurrSubFrame];    
    iMaskResampleRatioPow = LOG2(iMaskResampleRatio);
    rgiBarkIndex       = pau->m_rgiBarkIndexOrig + (NUM_BARK_BAND + 1) *                    
                         LOG2 (pau->m_cFrameSampleHalf / pau->m_iSubFrameSizeWithUpdate);   
    cValidBarkBandLatestUpdate = pau->m_rgcValidBarkBand [LOG2 (pau->m_cFrameSampleHalf / pau->m_iSubFrameSizeWithUpdate)];

    //// DEBUG NOTES below are preceeded by four slashes and typically allow cut and paste so you can view scaled integers as floats
    //// They are on the line below where the calculation occurs - of course, with BUILD_INT_FLOAT, they are unnecessary

    // zero all coefs so we can just skip the many zero ones as we detect them below
    // note 70% of coefficents are zero in High Rate
    // wchen: moved to outside
    //memset (rgiCoefRecon , 0, sizeof (CoefType) * pau->m_cHighCutOff);//(iRun+pau->m_cLowCutOff));                     

    iBark = 0;
    pau->m_iLevel = 0;
    *piHighCutOff = ppcinfo->m_cSubbandActual-1;//values need to be offset by -1 too 
    pau->m_iNextBarkIndex = -1; 

    //Scan for the first bark index = note iRecon is 0 and rgiBarkIndex[1] ==0 for 16000 Hz and 11025 Hz frames with 128 oir 64 samples
    while ((((*piRecon) * iMaskResampleRatio) >> 12) >= rgiBarkIndex [iBark+1]) 
        ++iBark;
        
    TRACEWMA_EXIT (wmaResult, (*pau->aupfnGetNextRun) (pcaller, ppcinfo, piBitCnt));
    DBG_RUNLEVEL(g_cBitGet-21,pau->m_cRunOfZeros,pau->m_iLevel,pau->m_iSign,fPrint);
    *piRecon += (I16)pau->m_cRunOfZeros+1;

    while (*piRecon < *piHighCutOff && iBark < cValidBarkBandLatestUpdate) {

        //Search for the next bark index
        while ((((*piRecon) * iMaskResampleRatio) >> 12) >= rgiBarkIndex [iBark+1]) 
            ++iBark;

        if ( iBark >= cValidBarkBandLatestUpdate )
        {
            assert( iBark < cValidBarkBandLatestUpdate );
            break;
        }

        // Get the quantStep * (10^(1/16))^(MaxMaskQ-MaskQ[iRecon])
        // as qfltQuantizer.fraction/(1<<(23-qfltQuantizer.exponent))
        // then scale coefficent to give it five FracBits
        if (*piRecon == pau->m_iNextBarkIndex) {                               
            //Reconstruct the coefficent before getting the next weighting factor if it lies at the end of a bark band        
            ctCoefRecon = MULT_QUANT(pau->m_iLevel,qfltQuantizer);
            //// Unsigned Float CoefRecon = ctCoefRecon/(1.0F*(1<<(qfltQuantizer.iFracBits+16-31)))
            INTEGER_ONLY( ctCoefRecon = SCALE_COEF_RECON(ctCoefRecon) );
            //// Unsigned Float CoefRecon = ctCoefRecon/32.0F
            VERIFY_DECODED_COEFFICENT(iBark-1);
            qfltQuantizer = prvWeightedQuantization(pau,ppcinfo,iBark);
            //// Float Quantizer = qfltQuantizer.iFraction/(1024.0F*(1<<(qfltQuantizer-10)))
            MAKE_MASK_FOR_SCALING(qfltQuantizer.iFracBits);
        } else {
            //Otherwize get the next weighting factor first
            assert( *piRecon > pau->m_iNextBarkIndex );
            qfltQuantizer = prvWeightedQuantization(pau,ppcinfo,iBark);         
            //// Float Quantizer = qfltQuantizer.iFraction/(1024.0F*(1<<(qfltQuantizer-10)))
            MAKE_MASK_FOR_SCALING(qfltQuantizer.iFracBits);
            ctCoefRecon = MULT_QUANT(pau->m_iLevel,qfltQuantizer);
            //// Unsigned Float CoefRecon = ctCoefRecon/(1.0F*(1<<(qfltQuantizer.iFracBits+16-31)))
            INTEGER_ONLY( ctCoefRecon = SCALE_COEF_RECON(ctCoefRecon) );
            //// Unsigned Float CoefRecon = ctCoefRecon/32.0F
            VERIFY_DECODED_COEFFICENT(iBark);
        }

        //Calculate the index of the end of this bark band
        if (iMaskResampleRatioPow > 12){
            pau->m_iNextBarkIndex = (rgiBarkIndex [iBark + 1] + (1<<(iMaskResampleRatioPow-13))) >> (iMaskResampleRatioPow-12);
        } else {
            pau->m_iNextBarkIndex = (rgiBarkIndex [iBark + 1] << (12-iMaskResampleRatioPow));
        }
        pau->m_iNextBarkIndex--; //correct by -1
        if (pau->m_iNextBarkIndex > *piHighCutOff) 
            pau->m_iNextBarkIndex = *piHighCutOff;

        do {
            rgiCoefRecon [*piRecon] = INTEGER_OR_INT_FLOAT( (ctCoefRecon^pau->m_iSign)-pau->m_iSign, 
                                    pau->m_iSign ? -ctCoefRecon : ctCoefRecon );
            //// Float CoefRecon = rgiCoefRecon [iRecon]/32.0F
            MONITOR_RANGE(gMR_CoefRecon,FLOAT_FROM_COEF(rgiCoefRecon[*piRecon]));
            MONITOR_COUNT_CONDITIONAL(rgiCoefRecon[*piRecon]==0,gMC_zeroCoefRecon,pau->m_cRunOfZeros);
            TRACEWMA_EXIT (wmaResult, (*pau->aupfnGetNextRun) (pcaller, ppcinfo, piBitCnt));
            DBG_RUNLEVEL(g_cBitGet-21,pau->m_cRunOfZeros,pau->m_iLevel,pau->m_iSign,fPrint);
            *piRecon += (I16)pau->m_cRunOfZeros+1;
            if (*piRecon >= pau->m_iNextBarkIndex) 
                break;
            ctCoefRecon = MULT_QUANT(pau->m_iLevel,qfltQuantizer);
            INTEGER_ONLY( ctCoefRecon = SCALE_COEF_RECON(ctCoefRecon) );
            VERIFY_DECODED_COEFFICENT(iBark);
        } while (WMAB_TRUE);   
        iBark++;
    }
    if (*piRecon == *piHighCutOff) {
        if ( *piRecon >= pau->m_iNextBarkIndex  )
        {   // skipped here via a cRunOfZeros past one or more iBark increments
            while ( ((iBark-1) < cValidBarkBandLatestUpdate) && (((*piRecon) * iMaskResampleRatio) >> 12) >= rgiBarkIndex [iBark] ) 
                ++iBark;
            if ( (iBark-1) <= cValidBarkBandLatestUpdate )
            {   
                qfltQuantizer = prvWeightedQuantization(pau,ppcinfo,iBark-1);         
                //// Float Quantizer = qfltQuantizer.iFraction/(1024.0F*(1<<(qfltQuantizer-10)))
                MAKE_MASK_FOR_SCALING(qfltQuantizer.iFracBits);
            }
        }
        else
        {
            assert(WMAB_FALSE);
        }
        ctCoefRecon = MULT_QUANT(pau->m_iLevel,qfltQuantizer);
        //// Unsigned Float CoefRecon = ctCoefRecon/(1.0F*(1<<(qfltQuantizer.iFracBits+16-31)))
        INTEGER_ONLY( ctCoefRecon = SCALE_COEF_RECON(ctCoefRecon) );
        //// Unsigned Float CoefRecon = ctCoefRecon/32.0F
        VERIFY_DECODED_COEFFICENT(iBark-1);
        rgiCoefRecon [*piRecon] = INTEGER_OR_INT_FLOAT( (ctCoefRecon^pau->m_iSign)-pau->m_iSign, 
                                pau->m_iSign ? -ctCoefRecon : ctCoefRecon );
        //// Float CoefRecon = rgiCoefRecon [iRecon]/32.0F
        MONITOR_RANGE(gMR_CoefRecon,FLOAT_FROM_COEF(rgiCoefRecon[*piRecon]));
        MONITOR_COUNT_CONDITIONAL(rgiCoefRecon[*piRecon]==0,gMC_zeroCoefRecon,pau->m_cRunOfZeros);
    }
    assert (*piRecon <= pau->m_cSubband); 
    assert (iBark <=  cValidBarkBandLatestUpdate );

    // do low cutoff here so there is less branching in the above loop
    if ( pau->m_cLowCutOff > 0 )
    {
        memset (rgiCoefRecon, 0, sizeof (Int) * pau->m_cLowCutOff);
#       if defined(_DEBUG) && defined(WMA_MONITOR)
        {   int ii;
            for( ii = 0; ii < pau->m_cLowCutOff; ii++ )
                MONITOR_RANGE(gMR_CoefRecon,0);
        }
#       endif
    }

    //do high cutoff here 
    iHighToBeZeroed = sizeof(CoefType) * (pau->m_cSubbandAdjusted - pau->m_cHighCutOffAdjusted);
    memset (rgiCoefRecon + pau->m_cHighCutOffAdjusted, 0, iHighToBeZeroed);    
#   if defined(_DEBUG) && defined(WMA_MONITOR)
    {   
    int ii;
    for( ii = 0; ii < iHighToBeZeroed; ii += sizeof(Int) )
        MONITOR_RANGE(gMR_CoefRecon,0);
    }
#   endif

exit:
#ifdef PROFILE
    FunctionProfileStop(&fp);
#endif
    return wmaResult;
}

#undef SCALE_COEFFICENT 
#undef MAKE_MASK_FOR_SCALING
#undef MULT_QUANT


void prvInitDiscardSilence(CAudioObject *pau)
{
    // If this is the very first frame, we need to determine if we are at the
    // start-of-file, rather than seeking. If so, we need to discard the silence
    // frames. If not, we need to only discard half a subframe. NOTE that for
    // V4 encoded streams, WE WILL GUESS INCORRECTLY. Our justification for accepting
    // this is that V4 never had timestamps and so sync was never guaranteed anyway.
    Bool fStartOfStream = WMAB_TRUE;
    int i;

    assert(CODEC_BEGIN == pau->m_codecStatus);

    // Due to SCRUNCH bug #32, v5 encoder forces fMaskUpdate to TRUE and
    // all channels' m_iPower to 1 in the very first frame only. If we find that
    // fMaskUpdate, m_iPower are all TRUE but in fact there is no power here,
    // then we know this is a v5-encoded file and this is start-of-file
    if (WMAB_FALSE == pau->m_subfrmconfigCurr.m_rgfMaskUpdate[0])
        fStartOfStream = WMAB_FALSE;

    for (i = 0; i < pau->m_cChannel; i++)
    {
        if (0 == pau->m_rgpcinfo[i].m_iPower)
            fStartOfStream = WMAB_FALSE;
    }

    if (fStartOfStream)
    {
        int iChan;
            
        // Bitstream has forced update, claims non-zero power for all channels.
        // Verify that claim.
        for (iChan = 0; iChan < pau->m_cChannel; iChan++)
        {
            if (0 != pau->m_rgpcinfo[iChan].m_iActualPower)
                fStartOfStream = WMAB_FALSE;
        } // for (channels)
    }

    // Finally the moment of truth: set m_iDiscardSilence
    pau->m_fSeekAdjustment = WMAB_FALSE;
    if (fStartOfStream)
        pau->m_iDiscardSilence = pau->m_cFrameSampleAdjusted;
    else
    {
        pau->m_iDiscardSilence = pau->m_cSubFrameSampleHalfAdjusted;
        pau->m_fSeekAdjustment = WMAB_TRUE;
    }
}


void prvDiscardSilence(CAudioObject *pau, U16 *pcSampleDecoded,
                       U16 iChannels, U8 *pbBuf)
{
    if (*pcSampleDecoded > pau->m_iDiscardSilence)
    {
        // We decoded more than we intend to discard.
        // Discard samples and collapse remaining samples to start of buffer
        memmove(pbBuf, pbBuf + (pau->m_iDiscardSilence * iChannels),
            (*pcSampleDecoded - pau->m_iDiscardSilence) * iChannels);
        *pcSampleDecoded -= (U16) pau->m_iDiscardSilence;
        pau->m_iDiscardSilence = 0;
    }
    else
    {
        // We intend to discard the entire output
        pau->m_iDiscardSilence -= *pcSampleDecoded;
        *pcSampleDecoded = 0;
    }
}



void SetActualPower(const I16 *piCoefQ, const int iCount,
                    PerChannelInfo *ppcinfo, const Status codecStatus)
{
    int i;

    ppcinfo->m_iActualPower = 0;
    if (CODEC_BEGIN != codecStatus || 0 == ppcinfo->m_iPower || NULL == piCoefQ)
        return;

    for (i = 0; i < iCount; i++)
    {
        if (0 != piCoefQ[i])
        {
            ppcinfo->m_iActualPower = 1;
            break;
        }
    }
}



void SetActualPowerHighRate(const I32 *piCoefRecon, const int iCount,
                            PerChannelInfo *ppcinfo, const Status codecStatus)
{
    int i;

    ppcinfo->m_iActualPower = 0;
    if (CODEC_BEGIN != codecStatus || 0 == ppcinfo->m_iPower || NULL == piCoefRecon)
        return;

    for (i = 0; i < iCount; i++)
    {
        if (0 != piCoefRecon[i])
        {
            ppcinfo->m_iActualPower = 1;
            break;
        }
    }
}



#ifdef TRANSCODER

#include "coefStream.h"

WMARESULT prvInverseQuantizeTRANSCODE(CAudioObject* pau, PerChannelInfo* ppcinfo, Int* rgiWeightFactor)
{
    WMARESULT       wmaResult;
    Float           fltQuantStep;
    I16            *piCoefQ = ppcinfo->m_rgiCoefQ;
    int             i;
    
    // *** TODO: Eliminate this buffer
    CoefType    ctCoefInvQ[2048];

    // Now just inverse quantize the coefficients and we're done
    fltQuantStep = FLOAT_FROM_QUANTSTEPTYPE(pau->m_qstQuantStep);

    // *** TODO: Just loop between m_cLowCutoff and m_cHighCutOff (m_cSubbandActual?)
    piCoefQ = ppcinfo->m_rgiCoefQ;
    for (i = 0; i < pau->m_cSubbandAdjusted; i++)
    {
        ctCoefInvQ[i] = (*piCoefQ * fltQuantStep);
        piCoefQ += 1;
    }

    if (0 == ppcinfo->m_iPower)
        memset(ctCoefInvQ, 0, pau->m_cSubbandAdjusted * sizeof(ctCoefInvQ[0]));
    
    TRACEWMA_EXIT(wmaResult, coefstrmRecordCoefs(ppcinfo->m_pcstrmCoefSaved,
        ctCoefInvQ, pau->m_cSubbandAdjusted));
    TRACEWMA_EXIT(wmaResult, coefstrmRecordDone(ppcinfo->m_pcstrmCoefSaved));

exit:
    return wmaResult;
} // prvDecodeSubFrameTRANSCODE

#endif  // TRANSCODER
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\wmalib\wmadec_s\strmdec_wma.c ===
/*************************************************************************

Copyright (C) 1996-1999  Microsoft Corporation

Module Name:

	strmdec_wma.c

Abstract:

	Decoder BitStream

Author:

	Craig Dowell (craigdo@microsoft.com) 10-December-1996
	Ming-Chieh Lee (mingcl@microsoft.com) 10-December-1996
	Bruce Lin (blin@microsoft.com) 10-December-1996

Revision History:
    Wei-ge Chen (wchen@microsoft.com) 20-July-1999
    Make it in C.


*************************************************************************/

#pragma code_seg("WMADEC")
#pragma data_seg("WMADEC_RW")
#pragma const_seg("WMADEC_RD")

#include <stdio.h>
#include <stdlib.h>
#include "..\common\macros.h"
#include "..\decoder\strmdec_wma.h"
#include "..\decoder\msaudiodec.h"
#include "..\..\..\dsound\dsndver.h"

#ifndef S_SUNOS5
const UInt getMask[33] = {
    0x00000000,
    0x00000001,
    0x00000003,
    0x00000007,
    0x0000000f,
    0x0000001f,
    0x0000003f,
    0x0000007f,
    0x000000ff,
    0x000001ff,
    0x000003ff,
    0x000007ff,
    0x00000fff,
    0x00001fff,
    0x00003fff,
    0x00007fff,
    0x0000ffff,
    0x0001ffff,
    0x0003ffff,
    0x0007ffff,
    0x000fffff,
    0x001fffff,
    0x003fffff,
    0x007fffff,
    0x00ffffff,
    0x01ffffff,
    0x03ffffff,
    0x07ffffff,
    0x0fffffff,
    0x1fffffff,
    0x3fffffff,
    0x7fffffff,
    0xffffffff
};
#endif

Void ibstrmInit (CWMAInputBitStream* pibstrm, Bool fAllowPackets)
{
    //added for streaming mode
    pibstrm->m_pfnGetMoreData = NULL;
    pibstrm->m_dwUser  = 0;
    pibstrm->m_dwOwner = 0;    
    pibstrm->m_dwHeaderBuf   = 0;
    pibstrm->m_pBufferBegin  = NULL;
    pibstrm->m_cbBuflenBegin = 0;    // used in association of m_pBufferBegin	
    //end of streaming mode

    pibstrm->m_pBuffer = NULL;
    pibstrm->m_cbBuflen = 0;
    pibstrm->m_dwDot = 0;
    pibstrm->m_dwBitsLeft = 0;
    pibstrm->m_iPrevPacketNum = (1 << NBITS_PACKET_CNT) - 1; // Keep -1 spacing w/ curr pkt num
    pibstrm->m_fAllowPackets = fAllowPackets;
    pibstrm->m_fSuppressPacketLoss = WMAB_TRUE; // Suppress first packet from loss detection
}

Void ibstrmReset(CWMAInputBitStream *pibstrm)
{
    pibstrm->m_dwDot = 0;
    pibstrm->m_dwBitsLeft = 0;
    pibstrm->m_cbBuflen = 0;
    pibstrm->m_fSuppressPacketLoss = WMAB_TRUE;
}

Void ibstrmAttach(CWMAInputBitStream *pibstrm, U32 dwDot, U32 dwBitsLeft, U8* pbSrc, I32 cbSrc)
{
    //added for streaming mode
    pibstrm->m_dwHeaderBuf   = 0;
    pibstrm->m_pBufferBegin  = NULL;
    pibstrm->m_cbBuflenBegin = 0;    // used in association of m_pBufferBegin	
    //end of streaming mode

    pibstrm->m_pBuffer = pbSrc;
    pibstrm->m_cbBuflen = cbSrc;
    pibstrm->m_dwDot = dwDot;
    pibstrm->m_dwBitsLeft = dwBitsLeft;
}

//this peekbits doens't generate ON_HOLD signal
WMARESULT ibstrmPeekBitsNonStop (CWMAInputBitStream *pibstrm, register UInt dwNumBits,
                          U32 *piRetBits)
{
    I16 cBitExtra;
    WMARESULT   wmaResult = WMA_OK;

    assert (dwNumBits <= 24); //only works for sure under this
    //make sure there is enougth data in dwDot for peek
    while (pibstrm->m_dwBitsLeft <= 24 && pibstrm->m_cbBuflen > 0) {
        pibstrm->m_dwDot <<= 8;
        pibstrm->m_dwDot |= *(pibstrm->m_pBuffer)++;
        --(pibstrm->m_cbBuflen);
        pibstrm->m_dwBitsLeft += 8;    
    }
    if (pibstrm->m_dwBitsLeft <= 24 && pibstrm->m_cbBuflen <= 0)
    {
        U32         iBufLen;
        TRACEWMA_EXIT(wmaResult, ibstrmGetMoreData (pibstrm, &iBufLen));
    }

    //if enough take the data and go home; else take what ever is left
    if (pibstrm->m_dwBitsLeft < dwNumBits)
        dwNumBits = pibstrm->m_dwBitsLeft;
    cBitExtra = (I16) pibstrm->m_dwBitsLeft - (I16) dwNumBits;

    assert(NULL != piRetBits); // Avoid conditionals
    *piRetBits = (pibstrm->m_dwDot >> cBitExtra) << (32 - dwNumBits);

exit:
    return wmaResult;
}

WMARESULT ibstrmPeekBits (CWMAInputBitStream *pibstrm, register UInt dwNumBits,
                          U32 *piRetBits)
{
    I16 cBitExtra;
    WMARESULT   wmaResult = WMA_OK;

    assert (dwNumBits <= 24); //only works for sure under this
    //make sure there is enougth data in dwDot for peek
    while (pibstrm->m_dwBitsLeft <= 24 && pibstrm->m_cbBuflen > 0) {
        pibstrm->m_dwDot <<= 8;
        pibstrm->m_dwDot |= *(pibstrm->m_pBuffer)++;
        --(pibstrm->m_cbBuflen);
        pibstrm->m_dwBitsLeft += 8;    
    }
    if (pibstrm->m_dwBitsLeft <= 24 && pibstrm->m_cbBuflen <= 0)
    {
        U32         iBufLen;
        TRACEWMA_EXIT(wmaResult, ibstrmGetMoreData (pibstrm, &iBufLen));
    }

    //if enough take the data and go home; else take what ever is left
    if (pibstrm->m_dwBitsLeft < dwNumBits)
    {
        wmaResult = WMA_E_ONHOLD;
        TraceResult(wmaResult);
        goto exit;
    }

    cBitExtra = (I16) pibstrm->m_dwBitsLeft - (I16) dwNumBits;
    assert(NULL != piRetBits); // Avoid conditionals
    *piRetBits = (pibstrm->m_dwDot >> cBitExtra) << (32 - dwNumBits);

exit:
    return wmaResult;
}

WMARESULT ibstrmLookForBits (CWMAInputBitStream *pibstrm, UInt dwNumBits)
{
    U32         iBufLen;
    WMARESULT   wmaResult = WMA_OK;

    assert (dwNumBits <= 32); //only case that works for certain
    if (dwNumBits > pibstrm->m_dwBitsLeft + pibstrm->m_cbBuflen * 8) 
    {
        //load up everything
        while (pibstrm->m_dwBitsLeft <= 24 && pibstrm->m_cbBuflen > 0) {
            pibstrm->m_dwDot <<= 8;
            pibstrm->m_dwDot |= *(pibstrm->m_pBuffer)++;
            --(pibstrm->m_cbBuflen);
            pibstrm->m_dwBitsLeft += 8;    
        }
        TRACEWMA_EXIT(wmaResult, ibstrmGetMoreData (pibstrm, &iBufLen));
    }

    if (dwNumBits > pibstrm->m_dwBitsLeft + pibstrm->m_cbBuflen * 8 )
    {
        wmaResult = WMA_E_ONHOLD;
        TraceResult(wmaResult);
        goto exit;
    }

exit:
    return wmaResult;
}

WMARESULT ibstrmFlushBits (CWMAInputBitStream *pibstrm, register UInt dwNumBits) 
{
 
    WMARESULT wmaResult = WMA_OK;

#if defined(_DEBUG) || defined(BITRATE_REPORT)
    g_cBitGet += dwNumBits;
#endif  // _DEBUG || BITRATE_REPORT

    assert (dwNumBits <= 24); //only works for sure under this
    //make sure there is enougth data in dwDot for peek
    while (pibstrm->m_dwBitsLeft <= 24 && pibstrm->m_cbBuflen > 0) {
        pibstrm->m_dwDot <<= 8;
        pibstrm->m_dwDot |= *(pibstrm->m_pBuffer)++;
        --(pibstrm->m_cbBuflen);
        pibstrm->m_dwBitsLeft += 8;    
    }
    if (pibstrm->m_dwBitsLeft <= 24 && pibstrm->m_cbBuflen <= 0)
    {
        U32 iBufLen;

        TRACEWMA_EXIT(wmaResult, ibstrmGetMoreData (pibstrm, &iBufLen));
    }

    //take the data and go home; or we have to pause
    if (dwNumBits <= pibstrm->m_dwBitsLeft)
        pibstrm->m_dwBitsLeft -= dwNumBits; 
    else 
        TRACEWMA_EXIT (wmaResult, WMA_E_ONHOLD);

exit:
    return wmaResult;
}

WMARESULT prvFinalLoad(CWMAInputBitStream* pibstrm,
                       UInt             dwRetval,
                       UInt             dwBitsToAdd,
                       U32             *piResult)
{
    WMARESULT   wmaResult = WMA_OK;
    U32         iBufLen;
    UInt        dwPosition = 4;

    pibstrm->m_dwDot = 0;
    pibstrm->m_dwBitsLeft = 0;

    for (; pibstrm->m_cbBuflen>0;) {
        pibstrm->m_dwDot <<= 8;
        pibstrm->m_dwDot |= *(pibstrm->m_pBuffer)++;
        --(pibstrm->m_cbBuflen);
        pibstrm->m_dwBitsLeft += 8;
    }

    TRACEWMA_EXIT(wmaResult, ibstrmGetMoreData (pibstrm, &iBufLen));

    if (iBufLen != 0) 
    { 
        while (pibstrm->m_dwBitsLeft < dwBitsToAdd) 
        {
            pibstrm->m_dwDot <<= 8;
            pibstrm->m_dwDot |= *(pibstrm->m_pBuffer)++;
            --(pibstrm->m_cbBuflen);
            pibstrm->m_dwBitsLeft += 8;
            assert (pibstrm->m_dwBitsLeft <= 32);
        }
    }

exit:
    dwRetval <<= dwBitsToAdd;
    dwRetval |= (pibstrm->m_dwDot >> (pibstrm->m_dwBitsLeft - dwBitsToAdd)) & getMask[dwBitsToAdd];
    pibstrm->m_dwBitsLeft -= dwBitsToAdd;
    *piResult = dwRetval;

    return wmaResult; // bugbug: propagating the error screws up many things. FIX LATER
    //return WMA_OK;
}


WMARESULT ibstrmGetMoreData(CWMAInputBitStream *pibs, U32 *piBufLen)
{
    //a new packet
    I32 iFirstBit = 0;
    U8 temp;

    WMARESULT   wmaResult;
    Bool        fNewPacket;

    assert (pibs->m_cbBuflen == 0);
    TRACEWMA_EXIT(wmaResult, pibs->m_pfnGetMoreData(&pibs->m_pBuffer,
        (U32 *)&pibs->m_cbBuflen, pibs->m_dwUser, pibs->m_pBufferExtra));
	pibs->m_pBuffer = pibs->m_pBufferExtra;
    fNewPacket = (wmaResult == WMA_S_NEWPACKET);

    assert(NULL != piBufLen); // Cut down on expensive conditionals
    if(pibs->m_cbBuflen == 0)
    {
        WMA_set_fNoMoreData(pibs->m_dwOwner, 1);
        *piBufLen = 0;
        wmaResult = WMA_OK;
        goto exit;
    }
    WMA_set_fNoMoreData(pibs->m_dwOwner, 0);

#ifdef WMA2CMP
    {   // write out bits to a .cmp file
        extern FILE *pfWma2Cmp;       // file (and flag) to output .cmp file
        if (pfWma2Cmp != NULL)
        {
            size_t uWritten = fwrite(pibs->m_pBuffer,pibs->m_cbBuflen,1,pfWma2Cmp);
            // Asserts are a lousy way to report errors, but this is for internal test purposes only
            assert( uWritten == 1 );
        }
    }
#endif

    if (fNewPacket)
    {
        pibs->m_pBufferBegin = pibs->m_pBuffer;
        pibs->m_cbBuflenBegin = pibs->m_cbBuflen;
    }

    if (WMAB_FALSE == pibs->m_fAllowPackets)
    {
        // In non-superframe mode, provide a running packet count that wraps around (to avoid I32 vs. U32 issues)
        if (fNewPacket)
        {
            assert(((~(NONSUPER_WRAPAROUND - 1) << 1) & NONSUPER_WRAPAROUND) == 0); // assert Pwr of 2
            pibs->m_dwHeaderBuf = (pibs->m_dwHeaderBuf + 1) & (NONSUPER_WRAPAROUND - 1);
        }
    }
    else if (fNewPacket) //set up packet header in superframe mode
    {
        Int iPrevPacketNum, iNextPacketNum;
        unsigned char nHdrBits = WMA_get_nHdrBits(pibs->m_dwOwner); // this only updates per file
        const int cPacketNumBitsRS = (BITS_PER_DWORD - NBITS_PACKET_CNT);

        iFirstBit = nHdrBits % 8;
        assert (pibs->m_pBuffer != NULL); //always get a valid one
        pibs->m_dwHeaderBuf = 0;
        pibs->m_dwHeaderBuf = (pibs->m_pBuffer[0]<<24)|(pibs->m_pBuffer[1]<<16)|(pibs->m_pBuffer[2]<<8)|pibs->m_pBuffer[3];
        pibs->m_pBuffer += nHdrBits / 8;
        pibs->m_cbBuflen -= nHdrBits / 8;
        assert (nHdrBits < BITS_PER_DWORD);
        assert (pibs->m_dwBitsLeft <= 24);  //so that we have enough to save the fractional byte that would otherwise be lost

        // Now we should check that we didn't lose a packet
        iNextPacketNum = (pibs->m_dwHeaderBuf >> cPacketNumBitsRS);
        iPrevPacketNum = pibs->m_iPrevPacketNum;
        pibs->m_iPrevPacketNum = iNextPacketNum;
        if (WMAB_FALSE == pibs->m_fSuppressPacketLoss)
        {
            if (WMAB_FALSE == (iNextPacketNum - iPrevPacketNum == 1 || 
//                iNextPacketNum - iPrevPacketNum == 0 ||
                iNextPacketNum - iPrevPacketNum + (1 << NBITS_PACKET_CNT) == 1))
            {
                // PACKET LOSS: Return error. Next call to DecodeInfo will cue to next frame
                *piBufLen = 0;
				pibs->m_pBuffer = pibs->m_pBufferBegin + 4;
				pibs->m_cbBuflen = pibs->m_cbBuflenBegin - 4;

				pibs->m_dwDot = pibs->m_dwHeaderBuf;
				assert (nHdrBits <= 32);
				pibs->m_dwBitsLeft = 32 - nHdrBits;

                TRACEWMA_EXIT (wmaResult, WMA_E_LOSTPACKET);
            }
        }
        else
            // Avoid checking for packet loss, eg, after a seek
            pibs->m_fSuppressPacketLoss = WMAB_FALSE;
    }

    while (pibs->m_cbBuflen > 0 && pibs->m_dwBitsLeft <= 24)    {
        temp = (*pibs->m_pBuffer++);
        pibs->m_cbBuflen--;

        //zeros out the top (not valid) bits
        temp = temp<<iFirstBit;
        temp = temp>>iFirstBit;
        pibs->m_dwDot = (pibs->m_dwDot<<(8 - iFirstBit))|temp;

        pibs->m_dwBitsLeft += (8 - iFirstBit);
        iFirstBit = 0;
    }
    *piBufLen = pibs->m_cbBuflen;

exit:
    return wmaResult;
}

Void ibstrmResetPacket(CWMAInputBitStream *pibs)
{
    U8 nHdrBits = WMA_get_nHdrBits(pibs->m_dwOwner); // this only updates per file
    I32 iFirstBit;
    U8 temp;

    assert (pibs->m_pBuffer != 0);
    assert (WMA_get_fNoMoreData(pibs->m_dwOwner) == WMAB_FALSE);
    //skip the packet header
    iFirstBit = nHdrBits % 8;
    pibs->m_pBuffer = pibs->m_pBufferBegin;
    pibs->m_pBuffer += nHdrBits / 8;
    pibs->m_cbBuflen = pibs->m_cbBuflenBegin - nHdrBits / 8;

    temp = (*pibs->m_pBuffer++);
    pibs->m_cbBuflen--;

    //zeros out the top (not valid) bits
    temp = temp<<iFirstBit;
    temp = temp>>iFirstBit;
    pibs->m_dwDot = temp;
    pibs->m_dwBitsLeft = (8 - iFirstBit);
}

WMARESULT ibstrmGetBits (CWMAInputBitStream* pibstrm, register UInt dwNumBits,
                         U32 *piResult)
{
    WMARESULT   wmaResult = WMA_OK;
    register UInt dwRetval;
    register UInt dwShift;

#if defined(_DEBUG) || defined(BITRATE_REPORT)
    g_cBitGet += dwNumBits;
#endif  // _DEBUG || BITRATE_REPORT

    if (pibstrm->m_dwBitsLeft <= 24 && pibstrm->m_cbBuflen <= 0)
    {
        U32         iBufLen;
        TRACEWMA_EXIT(wmaResult, ibstrmGetMoreData (pibstrm, &iBufLen));
    }

    //
    // This is a little unwieldly, but make sure the end-of-file test falls
    // through in the usual (not end-of-file) case to avoid CPU pipeline stalls
    // due to a branch (or mispredictions on more sophisticated processors).
    //
    if (((UInt) (pibstrm->m_cbBuflen << 3) >= dwNumBits || 
        pibstrm->m_dwBitsLeft + (pibstrm->m_cbBuflen << 3) >= dwNumBits)) {
        //
        // Do the most common case first.  If this doesn't play, we have one branch
        // to get to the next most common case (usually 1/32 of the time in the case
        // of the codec doing a huffman decode).  Note that we use a mask array to
        // avoid a special case branch when the bitcount is 32 (even though this is
        // relatively unlikely) since a left shift operation where the shift count
        // is equal to or greater than the number of bits in the destination is
        // undefined.
        //
        if (dwNumBits <= pibstrm->m_dwBitsLeft) {
            pibstrm->m_dwBitsLeft -= dwNumBits;
			*piResult = (pibstrm->m_dwDot >> pibstrm->m_dwBitsLeft) & getMask[dwNumBits];
            wmaResult = WMA_OK;
            goto exit;
        }
        //
        // The next most common case is when we have lots of data left in the buffer.
        // and we can fully load (i.e., all 32-bits) our accumulator.  This is
        // hard-wired to allow an optimizer to go crazy with all of the constants.
        // Note that the data is byte-swapped on the way in.
        //
        dwRetval = pibstrm->m_dwDot & getMask[pibstrm->m_dwBitsLeft];
        dwShift = dwNumBits - pibstrm->m_dwBitsLeft;

        if (pibstrm->m_cbBuflen >= 4) {
            register UInt     dwAcc;

            dwAcc = (UInt)pibstrm->m_pBuffer[3];
            dwAcc |= (UInt)(pibstrm->m_pBuffer[2]) << 8;
            dwAcc |= (UInt)(pibstrm->m_pBuffer[1]) << 16;
            dwAcc |= (UInt)(pibstrm->m_pBuffer[0]) << 24;
            pibstrm->m_dwDot = dwAcc;
            pibstrm->m_pBuffer += 4;
            pibstrm->m_cbBuflen -= 4;
            dwRetval <<= dwShift;
            dwRetval |= (dwAcc >> (32 - dwShift));// & getMask[dwShift];
            pibstrm->m_dwBitsLeft = 32 - dwShift;
            *piResult = dwRetval;
            wmaResult = WMA_OK;
            goto exit;
        }
        //
        // The final, and least likely case, is when we're at the end of the buffer.
        // Since there's really no point in having this inlined since it'll only
        // happen once, I'll call a function to make it happen and save the space
        // in the inline instances of getBits().
        //
		wmaResult = prvFinalLoad(pibstrm, dwRetval, dwShift, piResult);
        TraceError(wmaResult);
        goto exit;
    }
	else {
        *piResult = 0;
        TRACEWMA_EXIT (wmaResult, WMA_E_ONHOLD);
    }

exit:
    return wmaResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\wmalib\wmadec_s\msaudiodec.c ===
/*************************************************************************

Copyright (C) Microsoft Corporation, 1996 - 1999

Module Name:

    MsAudioDec.cpp

Abstract:

    Implementation of top level functions of CAudioObjectDecoder.

Author:

    Wei-ge Chen (wchen) 14-July-1998

Revision History:


*************************************************************************/

#pragma code_seg("WMADEC")
#pragma data_seg("WMADEC_RW")
#pragma const_seg("WMADEC_RD")

#include "..\decoder\msaudiodec.h"
#include "..\common\macros.h"

#include "AutoProfile.h" 
#include "..\..\..\dsound\dsndver.h"

#ifdef TRANSCODER
#include "coefstream.h"
#endif  // TRANSCODER

#if defined(_DEBUG) || defined(BITRATE_REPORT)
extern Int g_cBitGet = 0;
#endif  // _DEBUG || BITRATE_REPORT

#ifdef BUILD_INTEGER

#define COEF        m_rgiCoefRecon
#define SIN_START   pau->m_iSinRampUpStart
#define SIN1_START  pau->m_iSinRampUpPrior
#define COS_START   pau->m_iCosRampUpStart
#define COS1_START  pau->m_iCosRampUpPrior
#define SIN_STEP    pau->m_iSinRampUpStep

#else   // BUILD_INTEGER

#define COEF        m_rgfltCoefRecon
#define SIN_START   *((Int*) &pau->m_fltSinRampUpStart)
#define SIN1_START  *((Int*) &pau->m_fltSinRampUpPrior)
#define COS_START   *((Int*) &pau->m_fltCosRampUpStart)
#define COS1_START  *((Int*) &pau->m_fltCosRampUpPrior)
#define SIN_STEP    *((Int*) &pau->m_fltSinRampUpStep)

#endif  // BUILD_INTEGER


//***************************************************************************
// Local Function Prototypes
//***************************************************************************
Void auInitPcInfoDEC (CAudioObject* pau);



//*****************************************************************************************
//*****************************************************************************************
//
//  Outline of decoding process - major function call graph (HighRate is >= 32kbps)
//  Decode
//  ..audecDecode
//  ....prvDecodePacket
//  ......audecDecodeData
//  ........auSaveHistoryMono
//  ........prvDecodeSubFrameHighRate
//  ..........prvDecodeFrameHeader
//  ............prvUpdateSubFrameConfig
//  ............auAdaptToSubFrameConfig
//  ............prvAdaptEqToSubFrame
//  ............prvSetDetTable
//  ............prvReconWeightingFactor
//  ..........qstCalcQuantStep                      ; calc sub frame's quantization step size
//  ..........prvDecodeCoefficentsHighRate<float.c> ; fills rgiCoefRecon[] from bitstream with amplitude as a function of frequency
//  ..........InverseQuantizeHighRate<float.c>
//  ..........dctIV
//  ............FFT
//  ......audecGetPCM
//  ......audecDecodeInfo
//*****************************************************************************************
//*****************************************************************************************


//*****************************************************************************************
//
// audecDelete
//   free up and delete the CAudioObjectDecoder
//
//*****************************************************************************************
Void audecDelete (CAudioObjectDecoder* paudec)
{
    auMallocSetState(MAS_DELETE, NULL, 0);

    auDelete (paudec->pau);
    paudec->pau = NULL;

    auFree(paudec);
}


//*****************************************************************************************
//
// audecFlush
//   usually this deos do anything unless a subframe was put on-hold
//   because of the peekBits()'s look ahead. we set it to NonStop mode and finish it off.
//
//*****************************************************************************************

WMARESULT audecFlush (CAudioObjectDecoder* paudec, 
                    U8*  pbDst, 
                    Int  cbDstLength,
                    Int* pcbDstUsed,
                    U8*  pbEqu,
                    Int  cbEquLength,
                    Int* pcbEquUsed,
                    U32* pcSamplesFromBefore)
{
    WMARESULT hr = WMA_OK;
    Int     cbSrcUsed;
    U32     cSamplesPrevPacket = 0;

    assert (pbDst != NULL);
    assert (pcbDstUsed != NULL);

#if !defined(_Embedded_x86)
#if defined(WMA_TARGET_X86) && !(defined(BUILD_INTEGER) || defined(UNDER_CE))
    // This function may use the FFT. Therefore, on every call to this function,
    // we must check if the current thread has been initialized to use the Intel FFT.
    // This is because under the DMO, the thread which decoded may not be the
    // thread that does the flushing.
    if (paudec->pau->m_fIntelFFT)
        auInitIntelFFT(paudec->pau, INTELFFT_INIT_THREAD);
#endif // defined(WMA_TARGET_X86) && !(defined(BUILD_INTEGER) || defined(UNDER_CE))
#endif

    if (pcSamplesFromBefore != NULL)
        *pcSamplesFromBefore = cSamplesPrevPacket;
    if (pcbDstUsed != NULL)
        *pcbDstUsed = 0;
    if (pcbEquUsed != NULL)
        *pcbEquUsed = 0;

    paudec->m_ibstrm.ibstrmpfnPeekBits = ibstrmPeekBitsNonStop;

    if (paudec->pau->m_fAllowSuperFrame) {
        if (!paudec->m_fPacketLoss && 0 != paudec->m_cFrmInPacket)  
        {
            hr = prvDecodePacket (paudec, 
                                  NULL,
                                  0,
                                  &cbSrcUsed,
                                  pbDst,
                                  cbDstLength,
                                  pcbDstUsed,
                                  pbEqu,
                                  cbEquLength,
                                  pcbEquUsed,
                                  (I32 *)&cSamplesPrevPacket);

            if (pcSamplesFromBefore != NULL)
                *pcSamplesFromBefore = cSamplesPrevPacket;

            assert (*pcbDstUsed <= cbDstLength);
            if (*pcbDstUsed > cbDstLength)
                hr = TraceResult(WMA_E_BUFFEROVERFLOW);
        }
    }
    else                //don't do anything
        *pcbDstUsed = 0;

    audecReset(paudec);

    return hr;
} // audecFlush


//*****************************************************************************************
//
// audecNew
//   create and initialize a CAudioObjectDecoder object
//
//*****************************************************************************************
CAudioObjectDecoder* audecNew (void *pMemBuf, const I32 iMemBufSize)
{
    CAudioObjectDecoder* paudec;

    auMallocSetState(MAS_ALLOCATE, pMemBuf, iMemBufSize);
    paudec = (CAudioObjectDecoder*) auMalloc (sizeof (CAudioObjectDecoder));
    if(paudec == NULL)
    {
        TraceResult(WMA_E_OUTOFMEMORY);
        return paudec;
    }

    paudec->pau = NULL;
    paudec->m_fPacketLoss = WMAB_FALSE;
    paudec->m_cFrmInPacket = 0;
    paudec->m_pbSrcCurr = NULL;
    paudec->m_cbSrcCurrLength = 0; 
    paudec->m_decsts = BEGIN_PACKET;
    paudec->m_subfrmdecsts = SUBFRM_HDR;
    paudec->m_hdrdecsts = HDR_SIZE;
    paudec->m_rlsts = VLC;
    paudec->m_iChannel = 0;
    paudec->m_iBand = 0;
    paudec->m_fNoMoreData = WMAB_FALSE;
    paudec->m_fLastSubFrame = WMAB_TRUE;
    memset(&paudec->m_ibstrm, 0, sizeof(paudec->m_ibstrm));
    paudec->m_rgiRunEntry44ssQb = NULL;
    paudec->m_rgiLevelEntry44ssQb = NULL;
    paudec->m_rgiRunEntry44smQb = NULL;
    paudec->m_rgiLevelEntry44smQb = NULL;
    paudec->m_rgiRunEntry44ssOb = NULL;
    paudec->m_rgiLevelEntry44ssOb = NULL;
    paudec->m_rgiRunEntry44smOb = NULL;
    paudec->m_rgiLevelEntry44smOb = NULL;
    paudec->m_rgiRunEntry16ssOb = NULL;
    paudec->m_rgiLevelEntry16ssOb = NULL;
    paudec->m_rgiRunEntry16smOb = NULL;
    paudec->m_rgiLevelEntry16smOb = NULL;
#if defined(UNDER_CE) && defined(_ARM_)
    paudec->lPrivate1 = 0;
    paudec->lPrivate2 = 0;
#endif //defined(UNDER_CE) && defined(_ARM_)
#ifdef ENABLE_EQUALIZER
    memset(&paudec->m_rgfltEqBandWeight, 0, sizeof(paudec->m_rgfltEqBandWeight));
    memset(&paudec->m_rgwEqBandBoundary, 0, sizeof(paudec->m_rgwEqBandBoundary));
    paudec->m_cEqBand = 0;
    paudec->m_fNoEq = WMAB_TRUE; 
    memset(&paudec->m_rgbBandPower, 0, sizeof(paudec->m_rgbBandPower));
    paudec->m_fComputeBandPower = WMAB_FALSE;
    paudec->m_iEqFrameSize = 0;
#endif // ENABLE_EQUALIZER
    paudec->m_pfnDecodeSubFrame = NULL;
    paudec->m_pfnDecodeCoefficient = NULL;
    
    return paudec;
}


//*****************************************************************************************
//
// audecInit
//   initialize a CAudioObjectDecoder for parameters from input file or stream
//
//*****************************************************************************************
WMARESULT audecInit (CAudioObjectDecoder* paudec, 
                   Int iVersionNumber,
                   Int cSubband, 
                   Int iSamplingRate, 
                   U16 cChannel, 
                   Int cBytePerSec, 
                   Int cbPacketLength,
                   U16 wEncodeOpt,
                   U16 wPlayerOpt,
                   PFNGETMOREDATA pfnGetMoreData,
                   U32 dwUserData,
                   I32 *piMemUsed)
{
    Float fltBitsPerSample = 0.0F;
    CAudioObject* pau = paudec->pau;
    WMARESULT   wmaResult = WMA_OK;

    if (pau == NULL)
        paudec->pau = pau = auNew ();

    // Fill in function ptrs with decoder fns
    pau->aupfnGetNextRun = prvGetNextRunDEC;

    if (pau->m_codecStatus == CODEC_BEGIN)
        goto exit;

    //wchen: in the future we should use the one directly from the bitstream.
    //but for now the one in the bistream doesn't represent Sample/Frame
    //instead it represents Sample/Raw Packet that is useless for the decoder
    //other than serving the stupidity in the V4RTM decoder. We can't change the format for now.
    //but it should be changed to reprsent Sample/Frame and that should nullify the following function call.
    cSubband = msaudioGetSamplePerFrame (iSamplingRate, cBytePerSec * 8, cChannel, iVersionNumber);
    TRACEWMA_EXIT(wmaResult, auInit (pau, iVersionNumber, cSubband, iSamplingRate, 
        cChannel, cBytePerSec, cbPacketLength, wEncodeOpt, wPlayerOpt));
    auInitPcInfoDEC (pau);

    if (cChannel == 1)
        paudec->m_pfnDecodeCoefficient = &prvDecodeCoefficientMono;
    else
        paudec->m_pfnDecodeCoefficient = &prvDecodeCoefficientStereo;

#ifdef ENABLE_EQUALIZER
    wmaResult = audecResetEqualizer(paudec);
    TraceError(wmaResult);
#endif //ENABLE_EQUALIZER

    ibstrmInit (&paudec->m_ibstrm, pau->m_fAllowSuperFrame);
    ibstrmSetOwner (&paudec->m_ibstrm, (U32)paudec); 

    if (NULL == pfnGetMoreData)
    {
        // Set us up for non-streaming mode
        assert(0 == dwUserData); // We ignore user-supplied data in non-streaming mode
        pfnGetMoreData = prvWMAGetMoreData;
        dwUserData = (U32)paudec;
    }

    ibstrmSetGetMoreData (&paudec->m_ibstrm, pfnGetMoreData);
    ibstrmSetUserData (&paudec->m_ibstrm, (U32)dwUserData); //need to change for real streaming mode

    if (pau->m_fAllowSuperFrame)
        paudec->m_ibstrm.ibstrmpfnPeekBits = ibstrmPeekBits;
    else
        paudec->m_ibstrm.ibstrmpfnPeekBits = ibstrmPeekBitsNonStop;

    if (pau->m_iEntropyMode == SIXTEENS_OB)   {
        pau->m_rgpcinfo [0].m_rgiHuffDecTbl = g_rgiHuffDecTbl16smOb;
        pau->m_rgpcinfo [0].m_rgiRunEntry   = gRun16smOb;
        pau->m_rgpcinfo [0].m_rgiLevelEntry = gLevel16smOb;
    }
#ifdef ENABLE_ALL_ENCOPT
    else if (pau->m_iEntropyMode == FOURTYFOURS_QB)   {
        pau->m_rgpcinfo [0].m_rgiHuffDecTbl = g_rgiHuffDecTbl44smQb; 
        pau->m_rgpcinfo [0].m_rgiRunEntry   = gRun44smQb; 
        pau->m_rgpcinfo [0].m_rgiLevelEntry = gLevel44smQb;
    }
    else if (pau->m_iEntropyMode == FOURTYFOURS_OB)   {
        pau->m_rgpcinfo [0].m_rgiHuffDecTbl = g_rgiHuffDecTbl44smOb; 
        pau->m_rgpcinfo [0].m_rgiRunEntry   = gRun44smOb; 
        pau->m_rgpcinfo [0].m_rgiLevelEntry = gLevel44smOb;
    }
#endif // ENABLE_ALL_ENCOPT
    else {
        assert (WMAB_FALSE);
        wmaResult = TraceResult(WMA_E_INVALIDARG);
        goto exit;
    }

    //init subfrm configration
    pau->m_subfrmconfigPrev.m_cSubFrame = 1;
    pau->m_subfrmconfigPrev.m_rgiSubFrameSize [0]  = pau->m_cFrameSampleHalf;
    pau->m_subfrmconfigPrev.m_rgiSubFrameStart [0] = 0;
    pau->m_subfrmconfigPrev.m_iFirstTransientSubFrm = -1;
    pau->m_subfrmconfigPrev.m_iLastTransientSubFrm  = -1;
    memcpy (&pau->m_subfrmconfigCurr, &pau->m_subfrmconfigPrev, sizeof (SubFrameConfigInfo));
    memcpy (&pau->m_subfrmconfigNext, &pau->m_subfrmconfigPrev, sizeof (SubFrameConfigInfo));

    pau->m_codecStatus = CODEC_BEGIN;
    pau->m_iPacketCurr = -2;                // force a Packet Loss to begin

#if 0
    {   Int i;
        // Initialize quant step table
        for (i = 0; i < ARRAY_SIZE(paudec->m_rgiQuantStepFract); i++)
        {
            paudec->m_rgiQuantStepFract[i] = (UInt)(pow(10, (Float)(i + 1) / QUANTSTEP_DENOMINATOR) *
                (1 << QUANTSTEP_FRACT_BITS));
        }
    }
#endif  // 0

    if (pau->m_iWeightingMode == LPC_MODE || pau->m_fNoiseSub)
    {
        //low rate or mid rate
        paudec->m_pfnDecodeSubFrame = prvDecodeSubFrame;
    }
    else
    {
        //high rate
        paudec->m_pfnDecodeSubFrame = prvDecodeSubFrameHighRate;
    }

#ifdef BITRATE_REPORT
    printf("Fr#\tSubF#\tTime\tPCM\tSF Bits\tSF Bitr\tFr Bits\tFr Bitrate\n");
    printf("---\t-----\t----\t---\t-------\t-------\t-------\t----------\n");
#endif   // BITRATE_REPORT

    if (NULL != piMemUsed)
        *piMemUsed = auMallocGetCount();

    auMallocSetState(MAS_LOCKED, NULL, 0);

#ifdef TRANSCODER
    if (TT_SIMPLE == pau->m_ttTranscodeType)
        pau->aupfnInverseQuantize = prvInverseQuantizeTRANSCODE;
#endif  // TRANSCODER

exit:
    return wmaResult;
}


//*****************************************************************************************
//
// auInitPcInfoDEC
//
//*****************************************************************************************
Void auInitPcInfoDEC (CAudioObject* pau)
{
    I16 i;
    const U16 c_iSizeOfPrevOutput = (U16) DOUBLE(pau->m_fPad2XTransform,pau->m_cFrameSampleHalf) ;
    I16* piSignBase = pau->m_piPrevOutput + c_iSizeOfPrevOutput * pau->m_cChannel;
    for (i = 0; i < pau->m_cChannel; i++)
    {
        PerChannelInfo* ppcinfo = pau->m_rgpcinfo + i;

//      memset(ppcinfo->m_rgfltMask, 0, sizeof(ppcinfo->m_rgfltMask));
        ppcinfo->m_rgiCoefQ = NULL;
        ppcinfo->m_rgiMaskQ = pau->m_rgiMaskQ + pau->m_cValidBarkBand * i;
        ppcinfo->m_rgiHuffDecTbl = NULL;
        ppcinfo->m_rgiRunEntry = NULL;
        ppcinfo->m_rgiLevelEntry = NULL;
        ppcinfo->m_cSubbandActual = pau->m_cHighCutOff - pau->m_cLowCutOff;
        ppcinfo->m_iPower = 0;
        ppcinfo->m_iActualPower = 0;

        //ppcinfo->m_rgiWeightFactor: initialized below
        ppcinfo->m_rgiCoefRecon = pau->m_rgiCoefReconOrig + DOUBLE(pau->m_fPad2XTransform,
            pau->m_cSubband) * i;
        ppcinfo->m_iMaxMaskQ = 0;
        ppcinfo->m_iCurrGetPCM_SubFrame = (I16) pau->m_cSubFrameSampleHalfAdjusted;

        ppcinfo->m_rgiCoefReconCurr = ppcinfo->m_rgiCoefRecon + pau->m_cSubbandAdjusted /2;
        ppcinfo->m_piPrevOutput = pau->m_piPrevOutput + i;
        ppcinfo->m_piPrevOutputSign = piSignBase + i * (c_iSizeOfPrevOutput /
            BITS_PER_BYTE / sizeof (I16)); //non 17bit shouldn't use this pointer at all
        ppcinfo->m_piPrevOutputCurr = ppcinfo->m_piPrevOutput;

        ppcinfo->m_iSin = 0;
        ppcinfo->m_iCos = 0;
        ppcinfo->m_iSin1 = 0;
        ppcinfo->m_iCos1 = 0;
        ppcinfo->m_iStep = 0;

        ppcinfo->m_rgfltCoefRecon = (Float *)(ppcinfo->m_rgiCoefRecon); //This will soon be removed
    
        //ppcinfo->m_rgfltWeightFactor: initialized below
        ppcinfo->m_wtMaxWeight = 0; // Currently always used because LPC not integerized at encoder
    
        if (pau->m_iWeightingMode == LPC_MODE)
        { // LPC
            ppcinfo->m_rguiWeightFactor = pau->m_rguiWeightFactor + DOUBLE(pau->m_fPad2XTransform,pau->m_cSubband) * i;
            ppcinfo->m_rgfltWeightFactor = (float*)(pau->m_rguiWeightFactor + DOUBLE(pau->m_fPad2XTransform,pau->m_cSubband) * i);
        } else 
        {
            ppcinfo->m_rguiWeightFactor =(U32*) pau->m_rgpcinfo [i].m_rgiMaskQ;
            ppcinfo->m_rgfltWeightFactor = (float*)(pau->m_rgpcinfo [i].m_rgiMaskQ);
        }

        ppcinfo->m_rgbBandNotCoded = NULL;
        ppcinfo->m_rgffltSqrtBWRatio = NULL;
        ppcinfo->m_rgiNoisePower = NULL;
        ppcinfo->m_rgfltBandWeight = NULL;
#ifdef ENABLE_ALL_ENCOPT
        //set up default pcinfo for noise sub
        pau->m_rgpcinfo [i].m_rgbBandNotCoded   = pau->m_rgbBandNotCoded   + pau->m_cValidBarkBand * i;
        pau->m_rgpcinfo [i].m_rgffltSqrtBWRatio = pau->m_rgffltSqrtBWRatio + pau->m_cValidBarkBand * i;
        pau->m_rgpcinfo [i].m_rgiNoisePower     = pau->m_rgiNoisePower     + pau->m_cValidBarkBand * i;
#ifndef BUILD_INTEGER
        pau->m_rgpcinfo [i].m_rgfltBandWeight   = pau->m_rgfltBandWeight   + pau->m_cValidBarkBand * i;
#endif
#endif

    } // for
}

WMARESULT audecReset (CAudioObjectDecoder *paudec)
{
    CAudioObject* pau;
    if (paudec == NULL)
        return WMA_OK;
    pau = paudec->pau;

    //since a packet loss will be forced; the following are already being done there
#if 0
    for (i = 0; i < pau->m_cChannel; i++)
    {
        PerChannelInfo* ppcinfo = pau->m_rgpcinfo + i;
        ppcinfo->m_iCurrGetPCM_SubFrame = (I16) pau->m_iCoefRecurQ3;
    }

    if ( pau->m_piPrevOutput != NULL )
    {
        const int c_iSizeOfPrevOutput = sizeof (I16) * DOUBLE(pau->m_fPad2XTransform,pau->m_cFrameSampleHalf) * pau->m_cChannel;
#       ifndef PREVOUTPUT_16BITS
            const int c_iSizeOfPrevOutputSign = DOUBLE(pau->m_fPad2XTransform,pau->m_cFrameSampleHalf) * pau->m_cChannel / BITS_PER_BYTE + pau->m_cChannel*sizeof(I16);
#       else 
            const int c_iSizeOfPrevOutputSign = 0;
#       endif
        memset (pau->m_piPrevOutput, 0, c_iSizeOfPrevOutput + c_iSizeOfPrevOutputSign);
    }
#endif

    //this is not needed anymore
    //if we set packetheader to 0, meaning whatever left in the current packet
    //will be discarded by decodeInfo(). We just have to make sure
    //decodeInfo() gets called right after this. But it has to be since we are forcing
    //a packet loss situation.


	//to suppress packet loss check
    ibstrmReset(&paudec->m_ibstrm);
    ibstrmSetPacketHeader(&paudec->m_ibstrm, 0);

    //unlock ourself because there is an error already
    //wouldn't continue to decode the frame, making sure decodeInfo will be called
    if (pau->m_codecStatus == CODEC_ONHOLD)
    {
        pau->m_codecStatus = CODEC_STEADY;
    }

    //== to codec begin
    pau->m_iPacketCurr = -2;        //make sure we see a packet loss

    return WMA_OK;
}

U32 prvOutputBufferSize(Bool fAllowSuperFrame, Int cSamplesPerFrame, Int cChannels) {
  return sizeof (I16) * ( fAllowSuperFrame ? 32 : 1 )
                      * cSamplesPerFrame * cChannels;

}

U32 audecOutputBufferSize(Int iVersion, Int iSamplingRate, Int cChannels, Int cBytesPerSec, U16 wEncodeOpt) {
  return prvOutputBufferSize(!!(wEncodeOpt & ENCOPT_SUPERFRAME),
                             msaudioGetSamplePerFrame (iSamplingRate,
                                                       cBytesPerSec * 8,
                                                       cChannels,
                                                       iVersion),
                             cChannels);
}

//*****************************************************************************************
//
// audecDecode
//   decode a frame or subframe
//
//*****************************************************************************************
WMARESULT audecDecode (CAudioObjectDecoder* paudec, 
                     const U8* pbSrc,
                     Int       cbSrcLength,
                     Int*      pcbSrcUsed,
                     U8*       pbDst,
                     Int       cbDstLength,
                     Int*      pcbDstUsed,
                     U8*       pbEqu,
                     Int       cbEqu,
                     Int*      pcbEquUsed,
                     I32*      pcSamplesFromBefore)
{   
    WMARESULT hr;
    Int cbRawPacket;
    Int cbSrcUsed; 
    Int cbDstUsed;
    Int cbEquUsed;
    Int cbEquRemaining;
    Int cSamplesPrevPacket = 0;
    Bool fFirstPacket = WMAB_TRUE;
    CAudioObject* pau = paudec->pau;
#ifdef PROFILE
    //FunctionProfile fp;
    //FunctionProfileStart(&fp,DECODE_PROFILE);
#endif

    assert (pbSrc != NULL && pcbSrcUsed != NULL && pbDst != NULL && pcbDstUsed != NULL);
    if (pbSrc == NULL || pcbSrcUsed == NULL || pbDst == NULL || pcbDstUsed == NULL)
        return TraceResult(WMA_E_INVALIDARG);

    if (cbSrcLength <= 0) {  //nothing to decode
        *pcbDstUsed   = 0;
        hr = WMA_OK;
        goto exit;
    }

    cbRawPacket = prvOutputBufferSize(pau->m_fAllowSuperFrame, pau->m_cFrameSampleHalfAdjusted, pau->m_cChannel);
    
    *pcbSrcUsed = 0;
    *pcbDstUsed = 0;
    if (NULL != pcbEquUsed)
        *pcbEquUsed = 0;

    cbEquRemaining = cbEqu;
    hr = WMA_OK;
    while (WMAB_TRUE)    {
        if ((cbSrcLength - *pcbSrcUsed) * BITS_PER_BYTE < pau->m_cBitPacketLength ||
            (cbDstLength - *pcbDstUsed) < cbRawPacket)      //this is to be safe, usually less than cbRawPacket is needed
            break;

        hr = prvDecodePacket  (paudec,
                               pbSrc, 
                               pau->m_cBitPacketLength/BITS_PER_BYTE, 
                               &cbSrcUsed,
                               pbDst, 
                               cbDstLength - *pcbDstUsed, 
                               &cbDstUsed,
                               pbEqu,
                               cbEquRemaining,
                               &cbEquUsed, 
                               &cSamplesPrevPacket);

        //first time
        if (fFirstPacket && pcSamplesFromBefore != NULL)
        {
            *pcSamplesFromBefore = cSamplesPrevPacket;
            fFirstPacket = WMAB_FALSE;
        }

        assert (cbSrcUsed == pau->m_cBitPacketLength/BITS_PER_BYTE);
        pbSrc       += cbSrcUsed;
        *pcbSrcUsed += cbSrcUsed;

        CHECKWMA_EXIT(hr);

        assert (cbDstUsed <= cbRawPacket);
        pbDst       += cbDstUsed;
        *pcbDstUsed += cbDstUsed;

        if (NULL != pbEqu)
        {
            pbEqu       += cbEquUsed;
            cbEquRemaining -= cbEquUsed;
            if (NULL != pcbEquUsed)
                *pcbEquUsed += cbEquUsed;
        }
        
    }
exit:
#ifdef PROFILE
    //FunctionProfileStop(&fp);
#endif

    return hr;
}

#if defined(_DEBUG)
static int iSampleTotal = 0;
#endif

//*****************************************************************************************
//
// prvDecodePacket
//
//*****************************************************************************************
WMARESULT prvDecodePacket (CAudioObjectDecoder* paudec, 
                         const  U8*           pbSrc,
                         Int                  cbSrcLength,
                         Int*                 pcbSrcUsed,
                         U8*                  pbDst,
                         Int                  cbDstLength,
                         Int*                 pcbDstUsed,
                         U8*                  pbEqu,
                         Int                  cbEquLength,
                         Int*                 pcbEquUsed,
                         I32*                 pcSamplesPrevPacket)
{
    WMARESULT hr;
    Int cbRawFrame;
    U16 cSampleDecoded = 0;
    CAudioObject* pau = paudec->pau;
    Int cIteration = 0;
    Bool fDoDecode = WMAB_TRUE;
#ifdef PROFILE
    //FunctionProfile fp;
#endif

    assert(pcbSrcUsed != NULL && pbDst != NULL && pcbDstUsed != NULL);
    assert(paudec->m_ibstrm.m_pfnGetMoreData == prvWMAGetMoreData); // non-streaming mode MUST use the std fn
    assert(paudec->m_ibstrm.m_dwUser == (U32)paudec);

    if (pcbSrcUsed == NULL || pbDst == NULL || pcbDstUsed == NULL)
        return TraceResult(WMA_E_INVALIDARG);

    *pcbSrcUsed = *pcbDstUsed = 0;
    *pcSamplesPrevPacket = 0;
    cbRawFrame = pau->m_cFrameSampleHalfAdjusted * sizeof (I16) * pau->m_cChannel;

    // Verify that we have enough space in destination for worst-case scenario
    if ((paudec->pau->m_fAllowSuperFrame && cbDstLength < 16 * cbRawFrame) ||
        (WMAB_FALSE == paudec->pau->m_fAllowSuperFrame && cbDstLength < cbRawFrame))
        return TraceResult(WMA_E_BUFFEROVERFLOW);

#if defined(HALF_TRANSFORM) || defined(PAD2X_TRANSFORM)
    if ( pau->m_fUpsample || pau->m_fPad2XTransform )
        cbRawFrame *= 2;    
#endif

#ifdef PROFILE
    //FunctionProfileStart(&fp,DECODE_PACKET_PROFILE);
#endif

    *pcbSrcUsed = 0;
    *pcbDstUsed = 0;
    if (NULL != pcbEquUsed)
        *pcbEquUsed = 0;

    //to be used by getMoreData
    paudec->m_pbSrcCurr = (U8*) pbSrc; 
    paudec->m_cbSrcCurrLength = (U16) min (cbSrcLength, paudec->pau->m_cBitPacketLength/BITS_PER_BYTE); 
   
    while (fDoDecode)
    {
        switch (pau->m_codecStatus)
        {
        case CODEC_BEGIN:
        case CODEC_STEADY:
            //only flush will call with null,but, in which case it goes to on-hold directly
            if (pbSrc == NULL || cbSrcLength <= 0)
            {
                hr = TraceResult(WMA_E_INVALIDARG);
                goto exit;
            }

            TRACEWMA_EXIT (hr, audecDecodeInfo (paudec));
            *pcSamplesPrevPacket = *pcbDstUsed / pau->m_cChannel / sizeof (I16);
            fDoDecode = WMAB_FALSE;

#           if defined(WMA_SHOW_FRAMES) && defined(_DEBUG)
            prvWmaShowFrames(paudec->pau, "\nDecPkt2", " %1d ", 
                paudec->m_cFrmInPacket );
#           endif

        case CODEC_ONHOLD:
            // If no superframes, WMA_S_NO_MORE_SRCDATA always happens at the end of
            // each frame and should constitute an exit condition. If superframes,
            // WMA_S_NO_MORE_SRCDATA should not exit this loop or we may not decode
            // last frame.
            while (WMAB_TRUE) 
            {
                HEAP_DEBUG_CHECK;
                hr = audecDecodeData (paudec, &cSampleDecoded);
                HEAP_DEBUG_CHECK;

                if (hr == WMA_E_ONHOLD)
                {
                    //remembers it
                    pau->m_codecStatus = CODEC_ONHOLD; 
                    //map it to okay
                    TraceResult (hr = WMA_OK);
                    goto exit;
                }
                else if (hr == WMA_E_BROKEN_FRAME)
                {
                    audecReset (paudec);
                    TraceResult (hr = WMA_OK);
                    goto exit;  //bits will be advanced
                }
                else if (hr == WMA_E_LOSTPACKET)
                {
                    TraceResult (hr = WMA_OK);
                    break;      //try it again will call decodeInfo next round
                }

                CHECKWMA_EXIT(hr);

#               if defined(WMA_SHOW_FRAMES) && defined(_DEBUG)
                prvWmaShowFrames(pau, "GetPCM2", " %4d 0x%08x %6d     @%8d",
                    cSampleDecoded, pbDst, cbDstLength - *pcbDstUsed, iSampleTotal);
#               endif

                HEAP_DEBUG_CHECK;
                audecGetPCM (paudec, &cSampleDecoded, pbDst, cbDstLength - *pcbDstUsed);
                HEAP_DEBUG_CHECK;

#               if defined(_DEBUG)
                assert(pau->m_rgpcinfo[0].m_iCurrGetPCM_SubFrame >= pau->m_iCoefRecurQ3);
                iSampleTotal += cSampleDecoded;
#               endif
                cSampleDecoded *= sizeof (I16) * paudec->pau->m_cChannel; //in bytes
                //when seeking, we can return the 1st half of the subframe
                //whose begining the packet timestamp points to 
                //we use this negative number as a workaround
                if (pau->m_fSeekAdjustment && pau->m_fAllowSuperFrame)
                {
                    *pcSamplesPrevPacket -= pau->m_cSubFrameSampleHalfAdjusted;
                    pau->m_fSeekAdjustment = WMAB_FALSE;
                }

                pbDst           += cSampleDecoded;
                *pcbDstUsed     += cSampleDecoded;
                assert (*pcbDstUsed <= cbDstLength);
                if (*pcbDstUsed > cbDstLength)          //out of space
                {
                    //FUNCTION_PROFILE_STOP(&fp);
                    return TraceResult(WMA_E_BUFFEROVERFLOW);
                }
#ifdef ENABLE_EQUALIZER        
                if (paudec->m_fLastSubFrame)    
                {
                    if (NULL != pbEqu && paudec->m_fComputeBandPower) 
                    {
                        Int cbEquUsedFrame = sizeof (I8) * MAX_NO_EQBAND;
                        memcpy (pbEqu, paudec->m_rgbBandPower, cbEquUsedFrame);
                        pbEqu       += cbEquUsedFrame;
                        cbEquLength -= cbEquUsedFrame;
                        if (NULL != pcbEquUsed)
                            *pcbEquUsed += cbEquUsedFrame;
                    }
                }
#endif

                if (cIteration > pau->m_iMaxSubFrameDiv * 0x0F)
                    return TraceResult(WMA_E_BROKEN_FRAME);              //never overflow the stack
                else 
                {
                    cIteration++;
                    if (hr == WMA_S_NO_MORE_FRAME)
                        break;
                }
            }
            pau->m_codecStatus = CODEC_STEADY;
        }
    }

exit:
    // always tell them to give us the next packet.
    *pcbSrcUsed = pau->m_cBitPacketLength/BITS_PER_BYTE;

    //FUNCTION_PROFILE_STOP(&fp);
    HEAP_DEBUG_CHECK;
    return hr;
}

//*****************************************************************************************
//
// audecDecodeInfo
//
//*****************************************************************************************
WMARESULT audecDecodeInfo (CAudioObjectDecoder* paudec)
{   
    Int iPacketCurr;
    Int cBitLeftOver = 0;
    Int cBitLs, cBitRs;
    WMARESULT   wmaResult = WMA_OK;

    paudec->m_decsts = BEGIN_PACKET;
    paudec->m_fPacketLoss = WMAB_FALSE;
    paudec->m_cFrmInPacket = 1;

    if (paudec->pau->m_fAllowSuperFrame) 
    {
        //no left over
        while(ibstrmGetPacketHeader(&paudec->m_ibstrm) == 0) 
        {
            U32         iBufLen;

            ibstrmReset(&paudec->m_ibstrm);
            TRACEWMA_EXIT(wmaResult, ibstrmGetMoreData(&paudec->m_ibstrm, &iBufLen));

            if(paudec->m_fNoMoreData)
            {
                //wmaResult = WMA_S_NO_MORE_SRCDATA;
                //theoretically we can be on-hold but not tested as apps don't do this
                wmaResult = WMA_E_ONHOLD;
                goto exit;
            }
        }

        cBitLs = 0;
        cBitRs = (BITS_PER_DWORD - NBITS_PACKET_CNT);
        iPacketCurr = ibstrmGetPacketHeader(&paudec->m_ibstrm) >> cBitRs;
        if (iPacketCurr - paudec->pau->m_iPacketCurr == 1 || 
            iPacketCurr - paudec->pau->m_iPacketCurr + (1 << NBITS_PACKET_CNT) == 1) {
            paudec->m_fPacketLoss = WMAB_FALSE;
        }
        else 
            paudec->m_fPacketLoss = WMAB_TRUE;
        paudec->pau->m_iPacketCurr = iPacketCurr;

        cBitLs = NBITS_FRM_CNT;
        cBitRs = BITS_PER_DWORD - NBITS_FRM_CNT;
        paudec->m_cFrmInPacket = (U16) ((ibstrmGetPacketHeader(&paudec->m_ibstrm) 
                                 << cBitLs) >> cBitRs);
        assert (paudec->m_cFrmInPacket < (1 << NBITS_FRM_CNT));

        cBitLs = NBITS_PACKET_CNT + NBITS_FRM_CNT;
        cBitRs = BITS_PER_DWORD - (paudec->pau->m_cBitPackedFrameSize + 3); 
        cBitLeftOver = (ibstrmGetPacketHeader(&paudec->m_ibstrm) << cBitLs) >> cBitRs;
        if (cBitLeftOver == 0) 
            ibstrmResetPacket(&paudec->m_ibstrm);
        ibstrmSetPacketHeader(&paudec->m_ibstrm, 0);
    }
    else 
    {
        Int iCurrPrevDiff;

        // We should only hit this on very first frame
        if (paudec->pau->m_iPacketCurr < 0)
        {
            assert(ibstrmGetPacketHeader(&paudec->m_ibstrm) == 0);
            paudec->pau->m_iPacketCurr = ibstrmGetPacketHeader(&paudec->m_ibstrm);
        }

        iCurrPrevDiff = ibstrmGetPacketHeader(&paudec->m_ibstrm) -
            paudec->pau->m_iPacketCurr;

        // Non-superframe mode can't really lose packets
        assert(iCurrPrevDiff >= 0 || iCurrPrevDiff <= 1 - NONSUPER_WRAPAROUND);
        assert(iCurrPrevDiff < 0 || iCurrPrevDiff <= 1);
        assert(iCurrPrevDiff >= 0 || NONSUPER_WRAPAROUND + iCurrPrevDiff <= 1);

        // If, while processing the last frame we loaded in the start of next frame,
        // cue bitstream pointer to start of next frame
        if (iCurrPrevDiff != 0)
            ibstrmResetPacket(&paudec->m_ibstrm);

        // Advance to next payload: discard data until we hit next frame
        while (ibstrmGetPacketHeader(&paudec->m_ibstrm) == (U32)paudec->pau->m_iPacketCurr)
        {
            U32 iBufLen;

            ibstrmReset(&paudec->m_ibstrm);
            TRACEWMA_EXIT(wmaResult, ibstrmGetMoreData(&paudec->m_ibstrm, &iBufLen));

            if(paudec->m_fNoMoreData)
            {
                //wmaResult = WMA_S_NO_MORE_SRCDATA;
                wmaResult = WMA_E_ONHOLD;
                goto exit;
            }
        }

        paudec->pau->m_iPacketCurr = ibstrmGetPacketHeader(&paudec->m_ibstrm);

        if(paudec->m_fNoMoreData)
        {
            //wmaResult = WMA_S_NO_MORE_SRCDATA;
            wmaResult = WMA_E_FAIL;
            goto exit;
        }
    }

    if (paudec->m_fPacketLoss == WMAB_FALSE)
    {
        wmaResult = WMA_OK;
        goto exit;
    }
    else    {
        CAudioObject* pau = paudec->pau;
        I16 i;
        const int c_iSizeOfPrevOutput = sizeof (I16) * DOUBLE(pau->m_fPad2XTransform,pau->m_cFrameSampleHalf) * pau->m_cChannel;
#       ifndef PREVOUTPUT_16BITS
            const int c_iSizeOfPrevOutputSign = DOUBLE(pau->m_fPad2XTransform,pau->m_cFrameSampleHalf) * pau->m_cChannel / BITS_PER_BYTE + pau->m_cChannel*sizeof(I16);
#       else 
            const int c_iSizeOfPrevOutputSign = 0;
#       endif

        //packet loss or a broken frame earlier, seek to next complete frm
        while (cBitLeftOver > 24)   {
            TRACEWMA_EXIT(wmaResult, ibstrmFlushBits (&paudec->m_ibstrm, 24));
            cBitLeftOver -= 24;
        }
        TRACEWMA_EXIT(wmaResult, ibstrmFlushBits (&paudec->m_ibstrm, cBitLeftOver));

        for (i = 0; i < pau->m_cChannel; i++)
        {
            PerChannelInfo* ppcinfo = pau->m_rgpcinfo + i;
            ppcinfo->m_iCurrGetPCM_SubFrame = (I16) pau->m_iCoefRecurQ3;
        }

        if (pau->m_piPrevOutput != NULL)
            memset (pau->m_piPrevOutput, 0, c_iSizeOfPrevOutput + c_iSizeOfPrevOutputSign);

		//so that the 1st frame doesn't output anything
        pau->m_fPacketLossAdj = WMAB_TRUE;
        pau->m_fSeekAdjustment = WMAB_TRUE; //not relavent in streaming mode

        // Ignore packet loss, we're already set to deal with it
        wmaResult = WMA_OK; // WMA_BROKEN_FRAME;
        goto exit;
    }

exit:
    return wmaResult;
}

#ifdef BITRATE_REPORT
#define BITRATE_REPORT_VARS         Int cBitGet
#define BITRATE_REPORT_CHECKPT      cBitGet = g_cBitGet
#define BITRATE_REPORT_PRINT        PrintSubframeStats(pau, cBitGet)

Float g_fltRunningTime = 0;
Int g_cSubframeBits = 0;

void PrintSubframeStats(const CAudioObject *pau, const Int cBitGetCheckPt)
{
    Int iSubframePCM;
    Int iBitsInSubframe;
    Float fltSubframeTime;

    iSubframePCM = pau->m_cSubbandAdjusted;
    iBitsInSubframe = g_cBitGet - cBitGetCheckPt;
    fltSubframeTime = iSubframePCM / (float)pau->m_iSamplingRate;

    // Print frame number only for first subframe (helps with visual formatting)
    if (0 == pau->m_iCurrSubFrame)
        printf("%d\t", pau->m_iFrameNumber);
    else
        printf("\t");

    // Print subframe stats
    printf("%d\t%6.3f\t%4d\t%6d\t%7.0f", pau->m_iCurrSubFrame,
        g_fltRunningTime, iSubframePCM, iBitsInSubframe,
        iBitsInSubframe / fltSubframeTime);

    g_fltRunningTime += fltSubframeTime;
    g_cSubframeBits += iBitsInSubframe;

    // If last subframe in frame, print frame summary
    if (pau->m_iCurrSubFrame + 1 >= pau->m_subfrmconfigCurr.m_cSubFrame)
    {
        const Float fltFrameTime = (float)(2048.0 / pau->m_iSamplingRate);
        printf("\t%6d\t%7.0f\n", g_cSubframeBits, g_cSubframeBits / fltFrameTime);
        g_cSubframeBits = 0;
    }
    else
        printf("\n");
}
#else    // BITRATE_REPORT
#define BITRATE_REPORT_VARS
#define BITRATE_REPORT_CHECKPT
#define BITRATE_REPORT_PRINT
#endif  // BITRATE_REPORT

//*****************************************************************************************
//
// audecDecodeData
//
//*****************************************************************************************
WMARESULT audecDecodeData (CAudioObjectDecoder* paudec, U16* pcSampleReady)
{
    CAudioObject* pau = paudec->pau;
    PerChannelInfo* ppcinfo = pau->m_rgpcinfo;
    WMARESULT hr = WMA_OK;
    I16 iChannel;
    Int cBitUsed = 0;
    U32 iBufLen;

#ifdef PROFILE
    //FunctionProfile fp;
    //FunctionProfileStart(&fp,AUDEC_DECODE_DATA_PROFILE);
#endif

#if !defined(_Embedded_x86)
#if defined(WMA_TARGET_X86) && !(defined(BUILD_INTEGER) || defined(UNDER_CE))
    // This function may use the FFT. Therefore, on every call to this function,
    // we must check if the current thread has been initialized to use the Intel FFT.
    // This is because under the DMO, the thread which initialized us may not be the
    // thread that does the decoding.
    if (pau->m_fIntelFFT)
        auInitIntelFFT(pau, INTELFFT_INIT_THREAD);
#endif // defined(WMA_TARGET_X86) && !(defined(BUILD_INTEGER) || defined(UNDER_CE))
#endif // if !def embedded_x86

    *pcSampleReady = 0;
    //if we are being resumed, we need to get the new data
    if (paudec->m_fNoMoreData)
        TRACEWMA_EXIT(hr, ibstrmGetMoreData(&paudec->m_ibstrm, &iBufLen));

    while(1)
    {
        BITRATE_REPORT_VARS;
        switch (paudec->m_decsts)
        {
            case BEGIN_SUBFRAME :
                if (!paudec->m_fLastSubFrame) 
                {                   
                    for (iChannel = 0; iChannel < pau->m_cChannel; iChannel++)
                    {
                        ppcinfo = pau->m_rgpcinfo + iChannel;
                        if (!(ppcinfo->m_iCurrGetPCM_SubFrame==pau->m_iCoefRecurQ3 || ppcinfo->m_iCurrGetPCM_SubFrame>=pau->m_iCoefRecurQ4))
                            CHECKWMA_EXIT( hr = WMA_E_BROKEN_FRAME );

#if 0 // TRANSCODER
                        // No PCM required (or available) when doing simple transcode
                        // *** TODO: Enable this code to enhance efficiency.
                        if (TT_SIMPLE != paudec->pau->m_ttTranscodeType)
                        {
#endif  // TRANSCODER
                        HEAP_DEBUG_CHECK;
                        hr = auSaveHistoryMono (pau, ppcinfo, WMAB_FALSE);
                        HEAP_DEBUG_CHECK;

                        // Effectively disable GetPCM in case we find broken frame or packet
                        // (stupid caller maps WMA_E_LOSTPACKET to WMA_OK and therefore
                        // will try to retrieve the PCM, in which case we must return nothing)
                        pau->m_rgpcinfo[iChannel].m_iCurrGetPCM_SubFrame = CURRGETPCM_INVALID;
                    }

                    BITRATE_REPORT_CHECKPT;
                    paudec->m_decsts = DECODE_SUBFRAME; 
                    paudec->m_subfrmdecsts = SUBFRM_HDR;
                    paudec->m_hdrdecsts = HDR_SIZE;
                    paudec->m_iChannel = 0;  
                    paudec->m_iBand = 0;     

                }
                else 
                    paudec->m_decsts = END_SUBFRAME2;

            case DECODE_SUBFRAME :
                TRACEWMA_EXIT(hr, (*(paudec->m_pfnDecodeSubFrame))(paudec, &cBitUsed));

                HEAP_DEBUG_CHECK;
                BITRATE_REPORT_PRINT;
                if (paudec->m_subfrmdecsts == SUBFRM_DONE)
                    paudec->m_decsts = END_SUBFRAME1;

            case END_SUBFRAME1 :

#ifdef TRANSCODER
                // No PCM required (or available) when doing simple transcode
                if (TT_SIMPLE == paudec->pau->m_ttTranscodeType)
                {
                    *pcSampleReady = 0;

                    // Don't record the first frame, we want to fill NEXT subfrm config
                    if (CODEC_BEGIN != pau->m_codecStatus)
                    {
                        TRACEWMA_EXIT(hr, coefstrmRecordCoefs(pau->m_pcstrmSubFrameSizes,
                            &pau->m_cSubbandAdjusted, 1));
                        TRACEWMA_EXIT(hr, coefstrmRecordCoefs(pau->m_pcstrmBitAllocs,
                            &cBitUsed, 1));

                        if (paudec->m_fLastSubFrame)
                        {
                            TRACEWMA_EXIT(hr, coefstrmRecordDone(pau->m_pcstrmSubFrameSizes));
                            TRACEWMA_EXIT(hr, coefstrmRecordDone(pau->m_pcstrmBitAllocs));

                            TRACEWMA_EXIT(hr, coefstrmRecordCoefs(pau->m_pcstrmMaskUpdate,
                                &pau->m_subfrmconfigCurr.m_rgfMaskUpdate,
                                pau->m_subfrmconfigCurr.m_cSubFrame));
                            TRACEWMA_EXIT(hr, coefstrmRecordDone(pau->m_pcstrmMaskUpdate));
                        }
                    }
                }
#if 0
                // *** TODO: Enable this code to enhance efficiency.
                else
#endif
#endif  // TRANSCODER
                auPreGetPCM (pau, pcSampleReady);
                paudec->pau->m_iCurrSubFrame++;

            case END_SUBFRAME2 :
                if (paudec->m_fLastSubFrame) 
                {
                    //take care the end of a frame
                    if (pau->m_fAllowSuperFrame)
                    {
                        //copy next subfrm config to curr
                        memcpy (&pau->m_subfrmconfigPrev, &pau->m_subfrmconfigCurr, sizeof (SubFrameConfigInfo));
                        memcpy (&pau->m_subfrmconfigCurr, &pau->m_subfrmconfigNext, sizeof (SubFrameConfigInfo));
                    }
                    paudec->m_cFrmInPacket--;
                    //start decoding the next frame
                    paudec->m_decsts = BEGIN_FRAME; 

                    if (paudec->m_cFrmInPacket <= 0)
                    {
                        hr = WMA_S_NO_MORE_FRAME;
                        goto exit;
                    }
                }
                else                    
                    paudec->m_decsts = BEGIN_SUBFRAME; //goto the start of next subfrm
                goto exit;

           case BEGIN_PACKET:

                paudec->pau->m_fHeaderReset = WMAB_TRUE;
                assert (paudec->pau->m_fAllowSuperFrame || (paudec->m_cFrmInPacket == 1));
                paudec->m_decsts = BEGIN_FRAME; 

           case BEGIN_FRAME:
                paudec->pau->m_iFrameNumber++;
                paudec->pau->m_iCurrSubFrame = 0;
                paudec->m_fLastSubFrame = WMAB_FALSE;

                paudec->m_decsts = BEGIN_SUBFRAME;
                if (paudec->m_cFrmInPacket == 0)
                {
                    hr = WMA_S_NO_MORE_FRAME;
                    goto exit;
                }
                break;
         }
    }

exit:
    //FUNCTION_PROFILE_STOP(&fp);
#if defined(WMA_SHOW_FRAMES) && defined(_DEBUG)
        prvWmaShowFrames(paudec->pau, "RetDecD", hr<0 ? " 0x%08x " : " %d ", hr );
#endif
    HEAP_DEBUG_CHECK;

    return hr;
}

WMARESULT audecGetPCM (CAudioObjectDecoder* paudec, U16* pcSampleReady, U8* pbDst, U32 cbDstLength)
{
    WMARESULT wmaResult = WMA_OK;
    
#if 0
    // *** TODO: Enable this code to enhance efficiency.
    // No PCM required (or available) when doing simple transcode
    if (TT_SIMPLE == paudec->pau->m_ttTranscodeType)
    {
        *pcSampleReady = 0;
        return WMA_OK;
    }
#endif

    //get pcm only when we are in these states
    if (paudec->m_decsts == BEGIN_FRAME || paudec->m_decsts == BEGIN_SUBFRAME)
        wmaResult = auGetPCM (paudec->pau, pcSampleReady, pbDst, cbDstLength);
    else
        *pcSampleReady = 0;         //we are in a state of error; don't return anything

#if defined(WMA_SHOW_FRAMES) && defined(_DEBUG)
    prvWmaShowFrames(paudec->pau, "RetGetP", wmaResult<0 ? " 0x%08x " : " %d ", wmaResult );
#endif
    return wmaResult;
}



//*****************************************************************************************
//
// prvDecodeSubFrame
//
//*****************************************************************************************
WMARESULT prvDecodeSubFrame (CAudioObjectDecoder* paudec, Int* piBitCnt)
{
    WMARESULT hr = WMA_OK;
    Int     i, iChannel;
    CAudioObject* pau = paudec->pau;
    CoefType     ctTemp0, ctTemp1;
    CoefType*    pctCoefRecon0;
    CoefType*    pctCoefRecon1;

#ifdef PROFILE
    //FunctionProfile fp;
    //FunctionProfileStart(&fp,DECODE_SUB_FRAME_PROFILE);
#endif

    switch (paudec->m_subfrmdecsts)
    {
        case SUBFRM_HDR :   
            TRACEWMA_EXIT(hr, prvDecodeFrameHeader (paudec, piBitCnt));
            if (paudec->m_hdrdecsts == HDR_DONE)
            {
                paudec->m_subfrmdecsts = SUBFRM_COEF;
                paudec->pau->m_iCurrReconCoef = 0;             //iRecon is offset by -1 so comarison 
                paudec->m_iChannel = 0;
                paudec->m_rlsts = VLC;

            }
            else
                break;

        case SUBFRM_COEF:
            TRACEWMA_EXIT(hr, (*(paudec->m_pfnDecodeCoefficient))(paudec, pau->m_rgpcinfo, piBitCnt));
            paudec->m_subfrmdecsts = SUBFRM_DONE;

        case SUBFRM_DONE:
            // WMA Timestamps: To detect start-of-stream and discard correct amount of silence,
            // we need to verify claim that m_iPower[*] = 1, ForceMaskUpdate and actual power = 0.
            // If m_rgiCoefQ is all 0, we will accept that as actual power = 0 even though it is
            // theoretically possible for actual power != 0 if all bands inside noise-sub band are
            // substituted.
            if (CODEC_BEGIN == pau->m_codecStatus)
            {
                for (iChannel = 0; iChannel < pau->m_cChannel; iChannel++)
                {
                    PerChannelInfo *ppcinfo = &(pau->m_rgpcinfo[iChannel]);
                    if (pau->m_rgpcinfo[iChannel].m_iPower != 0)
                        SetActualPower (ppcinfo->m_rgiCoefQ, ppcinfo->m_cSubbandActual,
                                       ppcinfo, pau->m_codecStatus);
                }
            }

            pau->m_qstQuantStep = qstCalcQuantStep(pau->m_iQuantStepSize);
            for (iChannel = 0; iChannel < pau->m_cChannel; iChannel++) 
            {
                if (pau->m_rgpcinfo[iChannel].m_iPower != 0 ||
                    TRANSCODER_AB(TT_SIMPLE == pau->m_ttTranscodeType, WMAB_FALSE))
                {
                    TRACEWMA_EXIT(hr, (*pau->aupfnInverseQuantize)(pau, pau->m_rgpcinfo + iChannel,
                        (I32 *)(pau->m_rgpcinfo + iChannel)->m_rguiWeightFactor));
                }
                else
                {
                    memset (pau->m_rgpcinfo [iChannel].COEF, 0, sizeof (Int) * DOUBLE(pau->m_fPad2XTransform,pau->m_cSubband));
                }
            }

#if defined(WMA_SHOW_FRAMES) && defined(_DEBUG)
            if (pau->m_cChannel==1)
                prvWmaShowFrames(pau, "\nDecSub ", " %2d   0x%08x            [%4d %4d %4d]",
                    pau->m_rgpcinfo[0].m_iPower,
                    pau->m_rgpcinfo[0].m_rgiCoefRecon,
                    pau->m_cFrameSample,
                    pau->m_cSubFrameSample,
                    pau->m_cSubband );
            else
                prvWmaShowFrames(pau, "\nDecSub ", " %2d%2d 0x%08x 0x%08x [%4d %4d %4d]",
                    pau->m_rgpcinfo[0].m_iPower,
                    pau->m_rgpcinfo[1].m_iPower,
                    pau->m_rgpcinfo[0].m_rgiCoefRecon,
                    pau->m_rgpcinfo[1].m_rgiCoefRecon,
                    pau->m_cFrameSample,
                    pau->m_cSubFrameSample,
                    pau->m_cSubband );
#endif

#ifdef TRANSCODER
            // If performing simple transcode, we don't need to do any more processing
            if (TT_SIMPLE == pau->m_ttTranscodeType)
            {
                for (iChannel = 0; iChannel < pau->m_cChannel; iChannel++)
                {
                    PerChannelInfo *ppcinfo = &pau->m_rgpcinfo[iChannel];

                    //start recursion
                    ppcinfo->m_iSin  = SIN_START;
                    ppcinfo->m_iCos  = COS_START;
                    ppcinfo->m_iSin1 = SIN1_START;
                    ppcinfo->m_iCos1 = COS1_START;
                    ppcinfo->m_iStep = SIN_STEP;
                }
                break;
            }
#endif  // TRANSCODER

            //convert s/d to l/r
            if (pau->m_cChannel == 2 && pau->m_stereoMode == STEREO_SUMDIFF && 
                            (pau->m_rgpcinfo[0].m_iPower != 0 || pau->m_rgpcinfo[1].m_iPower != 0)) {
                pctCoefRecon0 = (CoefType*)pau->m_rgpcinfo[0].m_rgiCoefRecon;
                pctCoefRecon1 = (CoefType*)pau->m_rgpcinfo[1].m_rgiCoefRecon;
                for (i = pau->m_cSubbandAdjusted; i > 0; i--)   
                {
                    ctTemp0 = *pctCoefRecon0;
                    ctTemp1 = *pctCoefRecon1;
                    *pctCoefRecon0++ = ctTemp0 + ctTemp1;
                    *pctCoefRecon1++ = ctTemp0 - ctTemp1;
                }
                pau->m_rgpcinfo[0].m_iPower = 1;
                pau->m_rgpcinfo[1].m_iPower = 1;
            }

            if ( ! pau->m_fNoiseSub )
            {   // V4 only zeroed above HighCutOff when NoiseSubstitution was not in effect - e.g. it only zeros for HighRate
                Int iHighToBeZeroed = sizeof(CoefType) * (pau->m_cSubbandAdjusted - pau->m_cHighCutOffAdjusted);
                for (iChannel = 0; iChannel < pau->m_cChannel; iChannel++)
                {
                    memset (pau->m_rgpcinfo [iChannel].m_rgiCoefRecon + pau->m_cHighCutOffAdjusted, 0, iHighToBeZeroed);    
#           if defined(_DEBUG) && defined(WMA_MONITOR)
                    {   int ii;
                        for( ii = 0; ii < iHighToBeZeroed; ii += sizeof(Int) )
                            MONITOR_RANGE(gMR_CoefRecon,0);
                    }
#           endif
                }
            }

#ifdef ENABLE_EQUALIZER
            //equalize
            for (iChannel = 0; iChannel < pau->m_cChannel; iChannel++) {
                if (pau->m_rgpcinfo[iChannel].m_iPower != 0) {
                    TRACEWMA_EXIT(hr, prvEqualize(paudec, pau->m_rgpcinfo + iChannel));

                    if (paudec->m_fComputeBandPower == WMAB_TRUE)
                        prvComputeBandPower (paudec);
                }
            }
#endif // ENABLE_EQUALIZER

            {
                Float fltAfterScaleFactor = (pau->m_iVersion == 1) ? pau->m_fltDctScale :
                    (Float)(2.0f/pau->m_cSubband);

                for (iChannel = 0; iChannel < pau->m_cChannel; iChannel++) {
                    PerChannelInfo* ppcinfo = pau->m_rgpcinfo + iChannel;
#if defined(INTERPOLATED_DOWNSAMPLE)
                    if (paudec->pau->m_fLowPass)
                        auLowPass(paudec->pau, (CoefType*) ppcinfo->COEF, pau->m_cSubband / 2);
#endif  // defined(INTERPOLATED_DOWNSAMPLE)
                    if (ppcinfo->m_iPower != 0) 
                        (*pau->aupfnDctIV) (pau, (CoefType*) ppcinfo->COEF, fltAfterScaleFactor, NULL);

                    //start recursion
                    ppcinfo->m_iSin  = SIN_START;
                    ppcinfo->m_iCos  = COS_START;
                    ppcinfo->m_iSin1 = SIN1_START;
                    ppcinfo->m_iCos1 = COS1_START;
                    ppcinfo->m_iStep = SIN_STEP;
                }
            }
        }
exit:
    //FUNCTION_PROFILE_STOP(&fp);
    return hr;
}


//*****************************************************************************************
//
// prvUpdateSubFrameConfig
//
//*****************************************************************************************
WMARESULT prvUpdateSubFrameConfig (CAudioObjectDecoder* paudec, Int iSizeNext, Int iSizePrev,
                                 Int iSizeCurr)
{
    Int iStartCurr;
    CAudioObject* pau = paudec->pau;
/*** less than 0.5%
#ifdef PROFILE
    //FunctionProfile fp;
    //FunctionProfileStart(&fp,UPDATE_SUB_FRAME_CONFIG_PROFILE);
#endif
*///
    if (iSizeNext == 0) {
        assert (pau->m_subfrmconfigCurr.m_cSubFrame > 0);
        paudec->m_fLastSubFrame = WMAB_TRUE;
        return WMA_OK;
    }

    //only useful in case of packet loss and prev info lost or first in sequece
    if (iSizePrev != 0) {
        assert (pau->m_iCurrSubFrame == 0);
        pau->m_subfrmconfigPrev.m_cSubFrame = 1;
        pau->m_subfrmconfigPrev.m_rgiSubFrameSize [0] = iSizePrev;
    }

    //first frame in super and first sub frame; init
    if (iSizeCurr != 0) {
        assert (pau->m_iCurrSubFrame == 0);
        pau->m_subfrmconfigCurr.m_cSubFrame = 0;
        pau->m_subfrmconfigCurr.m_rgiSubFrameSize [0] = iSizeCurr;
        pau->m_subfrmconfigCurr.m_rgiSubFrameStart[0] = 0;
        pau->m_subfrmconfigCurr.m_cSubFrame++;
    }

    iStartCurr = pau->m_subfrmconfigCurr.m_rgiSubFrameStart [pau->m_iCurrSubFrame] 
                   + pau->m_subfrmconfigCurr.m_rgiSubFrameSize  [pau->m_iCurrSubFrame];
    if (iStartCurr >= pau->m_cFrameSampleHalf) {
        //init the next frame
        paudec->m_fLastSubFrame = WMAB_TRUE;
        pau->m_subfrmconfigNext.m_cSubFrame = 0;
        pau->m_subfrmconfigNext.m_rgiSubFrameSize [0] = iSizeNext;
        pau->m_subfrmconfigNext.m_rgiSubFrameStart[0] = 0;
        pau->m_subfrmconfigNext.m_cSubFrame++;
    }
    else {
        //must be within one frame; must have received the first one
        Int iCurr = pau->m_iCurrSubFrame;
        assert (pau->m_subfrmconfigCurr.m_cSubFrame == iCurr + 1);
        assert (iSizeNext < pau->m_cFrameSampleHalf);        //> 1 subfrm
        pau->m_subfrmconfigCurr.m_rgiSubFrameSize [iCurr + 1] = iSizeNext;
        pau->m_subfrmconfigCurr.m_rgiSubFrameStart[iCurr + 1] = 
            pau->m_subfrmconfigCurr.m_rgiSubFrameStart[iCurr] + 
            pau->m_subfrmconfigCurr.m_rgiSubFrameSize[iCurr];
        if (pau->m_subfrmconfigCurr.m_rgiSubFrameStart[iCurr + 1] + 
            pau->m_subfrmconfigCurr.m_rgiSubFrameSize [iCurr + 1] > pau->m_cFrameSampleHalf)  {
            assert (WMAB_FALSE);
            return TraceResult(WMA_E_BROKEN_FRAME);
        }
        pau->m_subfrmconfigCurr.m_cSubFrame++;
    }
/***
#ifdef PROFILE
    //FunctionProfileStop(&fp);
#endif
*///
    return WMA_OK;
}

//*****************************************************************************************
//
// prvDecodeSubFrameHighRate
//
//*****************************************************************************************
WMARESULT prvDecodeSubFrameHighRate (CAudioObjectDecoder* paudec, Int* piBitCnt)
{
    WMARESULT hr = WMA_OK;
    Int     iChannel,i;
    PerChannelInfo* ppcinfo;
    CoefType *pctCoefRecon0,*pctCoefRecon1, ctTemp0, ctTemp1;
    CAudioObject* pau = paudec->pau;

#ifdef PROFILE
    //FunctionProfile fp;
    //FunctionProfileStart(&fp,DECODE_SUB_FRAME_HIGH_RATE_PROFILE);
#endif  // PROFILE

    assert(0 == *piBitCnt); // Need this assumption, storing bit allocs for transcoding

    switch (paudec->m_subfrmdecsts)
    {
        case SUBFRM_HDR :   
            TRACEWMA_EXIT(hr, prvDecodeFrameHeader(paudec, piBitCnt));    
            pau->m_qstQuantStep = qstCalcQuantStep(pau->m_iQuantStepSize);
            if (paudec->m_hdrdecsts == HDR_DONE)
            {
                I16 iChannel;
                for (iChannel = 0; iChannel < pau->m_cChannel; iChannel++)
                {
                    ppcinfo = pau->m_rgpcinfo + iChannel;
                    memset (ppcinfo->m_rgiCoefRecon, 0, sizeof (CoefType) * pau->m_cHighCutOff);
                }
                paudec->m_subfrmdecsts = SUBFRM_COEF;

#ifdef TRANSCODER
                if (TT_SIMPLE == pau->m_ttTranscodeType)
                    paudec->pau->m_iCurrReconCoef = 0;
                else
#endif  // TRANSCODER
                    //iRecon is offset by -1 so comarison 
                    paudec->pau->m_iCurrReconCoef = (I16) pau->m_cLowCutOff-1;

                paudec->m_iChannel = 0;
                paudec->m_rlsts = VLC;
            }
            else
                break;

        case SUBFRM_COEF:
#ifdef TRANSCODER
            if (TT_SIMPLE == pau->m_ttTranscodeType)
            {
                TRACEWMA_EXIT(hr, (*(paudec->m_pfnDecodeCoefficient))(paudec,
                    pau->m_rgpcinfo, piBitCnt));
                paudec->m_iChannel = 0;
            }
#endif  // TRANSCODER

            //Decode coefficents for sum channel or left & right channels 
            for (; paudec->m_iChannel < pau->m_cChannel; paudec->m_iChannel++) 
            {
                ppcinfo = pau->m_rgpcinfo + paudec->m_iChannel;

#ifdef TRANSCODER
                if (TT_SIMPLE == pau->m_ttTranscodeType)
                    prvInverseQuantizeTRANSCODE(pau, ppcinfo, NULL);
                else
#endif  // TRANSCODER
                {
                    if (ppcinfo->m_iPower != 0)
                    {
                        TRACEWMA_EXIT(hr, auReconCoefficentsHighRate (paudec->pau,
                            paudec, ppcinfo, piBitCnt));
                    }
                }

                if(pau->m_iVersion == 1) 
                {
                    *piBitCnt += ibstrmBitsLeft (&paudec->m_ibstrm) % 8;
                    ibstrmFlush(&paudec->m_ibstrm);
                }
                assert (paudec->pau->m_iCurrReconCoef < (I16) pau->m_cSubband);
                paudec->pau->m_iCurrReconCoef = (I16) pau->m_cLowCutOff-1;             //iRecon is offset by -1 so comarison 
            }
            paudec->m_subfrmdecsts = SUBFRM_DONE;

        case SUBFRM_DONE:
            for (iChannel = 0; iChannel < pau->m_cChannel; iChannel++) {
                ppcinfo = pau->m_rgpcinfo + iChannel;
                if (ppcinfo->m_iPower != 0)
                {
                    // WMA Timestamps: To detect start-of-stream and discard correct amount of silence,
                    // we need to verify claim that m_iPower[*] = 1, ForceMaskUpdate and actual power = 0.
                    ppcinfo->m_iActualPower = 0;
                    if (CODEC_BEGIN == pau->m_codecStatus)
                    {
                        SetActualPowerHighRate (ppcinfo->m_rgiCoefRecon, 
                                                pau->m_cSubband, ppcinfo, pau->m_codecStatus);
                    }
                }
                else 
                {
                    memset (ppcinfo->COEF, 0, sizeof (CoefType) * pau->m_cSubbandAdjusted);
                    ppcinfo->m_iActualPower = 0;
                }
            }
#if defined(WMA_SHOW_FRAMES) && defined(_DEBUG)
            if (pau->m_cChannel==1)
                prvWmaShowFrames(pau, "\nDecSubH", " %2d   0x%08x            [%4d %4d %4d]",
                    pau->m_rgpcinfo[0].m_iPower,
                    pau->m_rgpcinfo[0].m_rgiCoefRecon,
                    pau->m_cFrameSample,
                    pau->m_cSubFrameSample,
                    pau->m_cSubband );
            else
                prvWmaShowFrames(pau, "\nDecSubH", " %2d%2d 0x%08x 0x%08x [%4d %4d %4d]",
                    pau->m_rgpcinfo[0].m_iPower,
                    pau->m_rgpcinfo[1].m_iPower,
                    pau->m_rgpcinfo[0].m_rgiCoefRecon,
                    pau->m_rgpcinfo[1].m_rgiCoefRecon,
                    pau->m_cFrameSample,
                    pau->m_cSubFrameSample,
                    pau->m_cSubband );
#endif

#ifdef TRANSCODER
            // If performing simple transcode, we don't need to do any more processing
            if (TT_SIMPLE == pau->m_ttTranscodeType)
            {
                for (iChannel = 0; iChannel < pau->m_cChannel; iChannel++)
                {
                    PerChannelInfo *ppcinfo = &pau->m_rgpcinfo[iChannel];

                    //start recursion
                    ppcinfo->m_iSin  = SIN_START;
                    ppcinfo->m_iCos  = COS_START;
                    ppcinfo->m_iSin1 = SIN1_START;
                    ppcinfo->m_iCos1 = COS1_START;
                    ppcinfo->m_iStep = SIN_STEP;
                }
                break;
            }
#endif  // TRANSCODER

            //convert s/d to l/r
            if (pau->m_cChannel == 2 && pau->m_stereoMode == STEREO_SUMDIFF && 
                            (pau->m_rgpcinfo[0].m_iPower != 0 || pau->m_rgpcinfo[1].m_iPower != 0)) {
                pctCoefRecon0 = (CoefType*)pau->m_rgpcinfo[0].m_rgiCoefRecon;
                pctCoefRecon1 = (CoefType*)pau->m_rgpcinfo[1].m_rgiCoefRecon;
                for (i = pau->m_cHighCutOffAdjusted; i >0; i--) {
                    ctTemp0 = *pctCoefRecon0;
                    *pctCoefRecon0++ = ctTemp0 + (ctTemp1 = *pctCoefRecon1);
                    *pctCoefRecon1++ = ctTemp0 - ctTemp1;
                }
                pau->m_rgpcinfo[0].m_iPower = 1;
                pau->m_rgpcinfo[1].m_iPower = 1;
                assert( pctCoefRecon0 == (CoefType*)pau->m_rgpcinfo [0].m_rgiCoefRecon + pau->m_cHighCutOffAdjusted );
                assert( pctCoefRecon1 == (CoefType*)pau->m_rgpcinfo [1].m_rgiCoefRecon + pau->m_cHighCutOffAdjusted );
            }

#ifdef ENABLE_EQUALIZER
            //equalize
            for (iChannel = 0; iChannel < pau->m_cChannel; iChannel++) {
                if (pau->m_rgpcinfo[iChannel].m_iPower != 0) {
                    TRACEWMA_EXIT(hr, prvEqualize(paudec, pau->m_rgpcinfo + iChannel));

                    if (paudec->m_fComputeBandPower == WMAB_TRUE)
                        prvComputeBandPower (paudec);
                }
            }
#endif // ENABLE_EQUALIZER
    
            {
                Float fltAfterScaleFactor = (pau->m_iVersion == 1) ? pau->m_fltDctScale :
                    (Float)(2.0f/pau->m_cSubband);

                for (iChannel = 0; iChannel < pau->m_cChannel; iChannel++) {
                    PerChannelInfo* ppcinfo = pau->m_rgpcinfo + iChannel;
#if defined(INTERPOLATED_DOWNSAMPLE)
                    if (paudec->pau->m_fLowPass)
                        auLowPass(paudec->pau, (CoefType*) ppcinfo->COEF, pau->m_cSubband / 2);
#endif  // defined(INTERPOLATED_DOWNSAMPLE)
                    if (ppcinfo->m_iPower != 0) 
                        (*pau->aupfnDctIV) (pau, (CoefType*) ppcinfo->COEF, fltAfterScaleFactor, NULL);

                    //start recursion
                    ppcinfo->m_iSin  = SIN_START;
                    ppcinfo->m_iCos  = COS_START;
                    ppcinfo->m_iSin1 = SIN1_START;
                    ppcinfo->m_iCos1 = COS1_START;
                    ppcinfo->m_iStep = SIN_STEP;
                }
            }
    }

exit:
#ifdef PROFILE
    //FunctionProfileStop(&fp);
#endif  // PROFILE

    return hr;
}



//*****************************************************************************************
//
// Std WMA_GetMoreData for non-streaming mode
//
//*****************************************************************************************
WMARESULT prvWMAGetMoreData (U8 **ppBuffer, U32 *pcbBuffer,
                             U32 dwUserData, U8* pDummy)
{
    CAudioObjectDecoder* paudec = (CAudioObjectDecoder*) dwUserData;

    if(paudec == NULL || ppBuffer == NULL || pcbBuffer == NULL)
    {
        if(ppBuffer != NULL)
            *ppBuffer = NULL;
        if(pcbBuffer != NULL)
            *pcbBuffer = 0;

        assert(WMAB_FALSE);
        return TraceResult(WMA_E_INVALIDARG);
    }

    if (paudec->m_pbSrcCurr != NULL)
    {
        *ppBuffer  = paudec->m_pbSrcCurr;
        *pcbBuffer = paudec->m_cbSrcCurrLength;
        //make sure nothing is left
        paudec->m_pbSrcCurr = NULL;
        paudec->m_cbSrcCurrLength = 0;
    }
    return WMA_S_NEWPACKET;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\wmalib\wmadec_s\userdll.c ===
/*M*
//
//               INTEL CORPORATION PROPRIETARY INFORMATION
//  This software is supplied under the terms of a license agreement or
//  nondisclosure agreement with Intel Corporation and may not be copied
//  or disclosed except in accordance with the terms of that agreement.
//        Copyright (c) 1999 Intel Corporation. All Rights Reserved.
//
//
//  Purpose: Generate custom DLL
//
*M*/

#include "../common/macros.h" // This will define WMA_TARGET_X86 (or not)
#include "msaudio.h"
#include "..\..\..\dsound\dsndver.h"

// The encoder requires the use of a multithreaded library w/ Intel FFT. Make sure we have it.
// Note that even if we do have it during compilation, we also must link to
// a multithreaded C runtime library at link time.
#if defined(ENCODER) && !defined(WMA_SERIALIZE) && !defined(_MT)
#error *** Encoder is multithreaded and therefore requires MT library when using Intel FFT ***
#endif  // defined(ENCODER) && !defined(WMA_SERIALIZE) && !defined(_MT)

// ###############################################################
// List of required CPUs.
//     PX=blend, M5=Pentium(R) with MMX(tm) support
//     P6=Pentium(R) Pro, M6=Pentium(R) Pro with MMX(tm) support
//     A6=Pentium(R) III

// Define the CPU's we want optimized. It costs ~100k per CPU included.
#define M6
#define A6

#if defined(WMA_TARGET_X86) && !defined(BUILD_INTEGER) && !defined(UNDER_CE)

static const char* SET_LIB_ERR = "Set PLib error";

//#define nsp_UsesAll

#ifndef _WINDOWS_
#   include <windows.h>
#endif


#define NSPAPI(type,name,arg)
#include "..\x86\nsp.h"

/// Describe Intel CPUs and libraries
typedef enum{CPU_PX=0, CPU_P6, CPU_M5, CPU_M6, CPU_A6, CPU_NOMORE} cpu_enum;
typedef enum{LIB_PX=0, LIB_P6, LIB_M5, LIB_M6, LIB_A6, LIB_NOMORE} lib_enum;

/// New cpu can use some libraries for old cpu
static const lib_enum libUsed[][LIB_NOMORE+1] = {
    { LIB_PX, LIB_NOMORE }, 
    { LIB_P6, LIB_PX, LIB_NOMORE },
    { LIB_M5, LIB_PX, LIB_NOMORE },
    { LIB_M6, LIB_M5, LIB_P6, LIB_PX, LIB_NOMORE },
    { LIB_A6, LIB_M6, LIB_M5, LIB_P6, LIB_PX, LIB_NOMORE }
};



#define __USERLIST__


#ifdef INTELFFT_FOR_CE
// For some reason, somebody has a #define __stdcall __cdecl somewhere.
// Get rid of this, because it's causing us linker errors.
#ifdef __stdcall
#undef __stdcall
#endif
#endif  // INTELFFT_FOR_CE

#ifdef PX
#   undef  NSPAPI
#   define NSPAPI(type,name,arg) extern type __stdcall px_##name arg;
#   define PX_NAME(name) (FARPROC)px_##name
#   include "..\x86\UserDll.h"
#else
#   define PX_NAME(name) NULL
#endif

#ifdef M5
#   undef  NSPAPI
#   define NSPAPI(type,name,arg) extern type __stdcall m5_##name arg;
#   define M5_NAME(name) (FARPROC)m5_##name
#   include "..\x86\UserDll.h"
#else
#   define M5_NAME(name) NULL
#endif

#ifdef P6
#   undef  NSPAPI
#   define NSPAPI(type,name,arg) extern type __stdcall p6_##name arg;
#   define P6_NAME(name) (FARPROC)p6_##name
#   include "..\x86\UserDll.h"
#else
#   define P6_NAME(name) NULL
#endif

#ifdef M6
#   undef  NSPAPI
#   define NSPAPI(type,name,arg) extern type __stdcall m6_##name arg;
#   define M6_NAME(name) (FARPROC)m6_##name
#   include "..\x86\UserDll.h"
#else
#   define M6_NAME(name) NULL
#endif

#ifdef A6
#   undef  NSPAPI
#   define NSPAPI(type,name,arg) extern type __stdcall a6_##name arg;
#   define A6_NAME(name) (FARPROC)a6_##name
#   include "..\x86\UserDll.h"
#else
#   define A6_NAME(name) NULL
#endif


#undef  NSPAPI
#define NSPAPI(type,name,arg) \
    static FARPROC d##name; \
__declspec(naked dllexport) void __stdcall name arg { __asm {jmp d##name } }
#include "..\x86\UserDll.h"


typedef struct _USER_Desc_t {
    FARPROC *WorkAddr;
    FARPROC FuncAddr[CPU_NOMORE];
} USER_Desc_t;

static USER_Desc_t AddressBook[] = {
#undef  NSPAPI
#define NSPAPI(type,name,arg) &d##name, \
    PX_NAME(name), P6_NAME(name), M5_NAME(name), M6_NAME(name), A6_NAME(name),
#include "..\x86\UserDll.h"
};
/// how large is the table of the functions
static const int sFuncCount  = sizeof( AddressBook ) / sizeof( AddressBook[0] );


#undef __USERLIST__

#if !defined( _USE_CPUINF32 )

/// try  define cpu yourself without cpuinf32.dll
/// because DLL generated must be used in the ring 0

/// ID flag in the EFLAGS register, bit 21
#define ID_FLAG   00200000h

/// MMX-extension, feature information after cpuid(1), EDX, bit 23
#define MMX_FLAG  00800000h

/// SSX-extension, feature information after cpuid(1), EDX, bit 25
/// Should be CR0.EM = 0 and CR4.OSFXSR = 1 (ring 0)
#define SSX_FLAG  02000000h

#define _read_stc _asm  _emit 00Fh _asm  _emit 031h
#define _cpuid    _asm  _emit 00Fh _asm  _emit 0A2h

typedef struct {
   int m_family; 
   int m_stepping;
   int m_model;
   int m_type;
   int m_feature;
   int m_tlb;
   int m_cache;
   int m_freq;
   int m_max_cpuid_input;
   int m_is_mmx;
   int m_is_ssx;
   int m_has_tsc;
} IntelCpu;

#pragma optimize("", off )

/// does cpu support cpuid instruction ?
static int has_cpuid() {
   _asm  pushfd
   _asm  pop   eax
   _asm  mov   ecx, eax
   _asm  xor   eax, ID_FLAG
   _asm  push  eax
   _asm  popfd
   _asm  pushfd
   _asm  pop   eax
   _asm  and   eax, ID_FLAG
   _asm  and   ecx, ID_FLAG
   _asm  cmp   eax, ecx
   _asm  jne   has_cpuid_lab
   return 0;
has_cpuid_lab:
   return 1;
}

/// cpu identification
static int pentium_ident( IntelCpu *cpu ) {

   _asm  mov   esi, cpu
   _asm  mov   eax, 0
   _asm  push  ebx
   _cpuid
   _asm  pop   ebx
   _asm  mov   edi, eax
   _asm  mov   [esi]IntelCpu.m_max_cpuid_input, eax
   _asm  cmp   edi, 1
   _asm  jae   above_eq_1
   return 0;
above_eq_1:
   _asm  mov   eax, 1
   _asm  push  ebx
   _cpuid
   _asm  pop   ebx
   _asm  mov   ecx, eax
   _asm  and   eax, 000Fh
   _asm  mov   [esi]IntelCpu.m_stepping, eax
   _asm  mov   eax, ecx
   _asm  shr   eax, 4
   _asm  and   eax, 000Fh
   _asm  mov   [esi]IntelCpu.m_model, eax
   _asm  mov   eax, ecx
   _asm  shr   eax, 8
   _asm  and   eax, 000Fh
   _asm  mov   [esi]IntelCpu.m_family, eax
   _asm  shr   eax, 11
   _asm  and   eax, 0003h
   _asm  mov   [esi]IntelCpu.m_type, eax
   _asm  mov   [esi]IntelCpu.m_feature, edx

   /// define IA mmx extension
   _asm  xor   eax, eax
   _asm  test  edx, MMX_FLAG
   _asm  setnz al
   _asm  mov   [esi]IntelCpu.m_is_mmx, eax

   /// define IA ssx extension
   _asm  xor   eax, eax
   _asm  test  edx, SSX_FLAG
   _asm  setnz al
   _asm  mov   [esi]IntelCpu.m_is_ssx, eax

   _asm  cmp   edi, 2
   _asm  jae   above_eq_2
   return 1;

above_eq_2:
   /// get extended info, for Pentium Pro and above
   _asm  mov   eax, 2
   _asm  push  ebx
   _cpuid
   _asm  pop   ebx
   _asm  mov   [esi]IntelCpu.m_tlb, eax
   _asm  mov   [esi]IntelCpu.m_cache, edx
   return 1;
}

static cpu_enum GetProcessorId(void) {

   IntelCpu cpu;
   if( !has_cpuid() || !pentium_ident( &cpu) ) return CPU_NOMORE;
   switch ( cpu.m_family ) {
   /// note that simple Pentium P5 is not supported
   case 5: return cpu.m_is_mmx ? CPU_M5 : CPU_PX;
   /// check ssx first, maybe it is mmx also
   case 6: return cpu.m_is_ssx ? CPU_A6 : cpu.m_is_mmx ? CPU_M6 : CPU_P6;
   }
   return CPU_PX;
}   

#else

/// Define target cpu with using cpuinf32.dll
/// Here is a solution for the case if cpu is unknown
/// Note. IF CPU IS UNKNOWN THEN PX LIBRARY WILL BE USED
///

__declspec(dllimport) unsigned short wincpuid(void);
__declspec(dllimport) unsigned short wincpuidext(void);
__declspec(dllimport) unsigned long  wincpufeatures(void);

static cpu_enum GetProcessorId(void)
{
    int cpuid = (int)wincpufeatures();
    int ismmx = cpuid & 0x00800000;        /// 0x00800000 - MMX(TM) technology
    int iskni = cpuid & 0x02000000;        /// 0x02000000 - SSX
    cpuid = (int)wincpuid();               /// 0x00000F00 - CPU
    
    // much more flexible in processor ID detection. Shinn
    switch (cpuid) {
    case 5: return ismmx ? CPU_M5 : CPU_PX;
        /// check ssx first, maybe it is mmx also
    case 6: return iskni ? CPU_A6 : ismmx ? CPU_M6 : CPU_P6;
    }
    return CPU_PX;
}
#endif

/// fill SPLib function address book in correspondence to the target cpu
static BOOL SetLib( lib_enum lib )
{    
   int i = 0;
   for ( i=0; i<sFuncCount; i++ ) 
      if( NULL == AddressBook[i].FuncAddr[lib] ) 
         return FALSE;
      else
        *(AddressBook[i].WorkAddr) = AddressBook[i].FuncAddr[lib];
   return TRUE;
}

static BOOL setCpuSpecificLib()
{
   //char buf[256] = "";
   cpu_enum cpu = GetProcessorId();
   if( sFuncCount > 0 && cpu >= CPU_PX && cpu < CPU_NOMORE ) {
      
      const lib_enum* libs = libUsed[ cpu ];
      while( *libs < LIB_NOMORE )
         if( SetLib( *libs++ ) ) return TRUE;     /// SUCCESS EXIT
   }
   /// if not found, then failed with error message
   //lstrcpy( buf, " No PLib matching to CPU was found during the Waterfall" );
   //MessageBeep( MB_ICONSTOP );
   //MessageBox( 0, buf, SET_LIB_ERR, MB_ICONSTOP | MB_OK );

   // Actually, for our purposes, it's OK to fail. Do so silently.

   return FALSE;
}

/*---- Warning!!! Please don't modify this section -----*/
/*---- Begin section  ----*/
void* __cdecl nspUndContext (void);
void* __cdecl nspInitContext (void* Context);
int   __cdecl nspSizeOfContext(void);
/*---- End of section ----*/

#ifndef TLS_OUT_OF_INDEXES
#define TLS_OUT_OF_INDEXES  (DWORD)0xFFFFFFFF
#endif  // !TLS_OUT_OF_INDEXES

static DWORD s_dwTlsIndex = TLS_OUT_OF_INDEXES;
static DWORD s_dwTlsIndexRefcount = 0;

void* __cdecl nspUndContext() {
    
    void *pContext = TlsGetValue( s_dwTlsIndex );
    if( NULL == pContext )  {
        pContext = (LPVOID)LocalAlloc( LPTR, nspSizeOfContext() );
        if( NULL == pContext )
        {
            assert(WMAB_FALSE);
            exit(-5);
        }
        
        nspInitContext (pContext);
        TlsSetValue( s_dwTlsIndex, pContext );
    }
    return pContext;
}


//BOOL WINAPI DllMain( HINSTANCE hinstDLL, DWORD fdwReason,
//                    LPVOID lpvReserved )
BOOL MyInitNSP(DWORD fdwReason)
{
    void * pContext = NULL;
    BOOL   fResult = TRUE;
    Int    iNewRefcount;

    switch (fdwReason)
    {
    //case DLL_PROCESS_ATTACH:
    case INTELFFT_INIT_PROCESS:
        
        // Bug #36310: It is possible for codec instances to overlap (create A, create B,
        // delete A, delete B), so ref-count s_dwTlsIndex so that we do not call TlsFree
        // during "delete A". We ignore the possibility of a race condition for TlsAlloc
        // and TlsGetValue because we assume:
        //   1) Race condition can only come out of multithreaded operation
        //   2) Multithreaded operation will use DMO
        //   3) Our FIRST call will be from DMO's DllMain's DLL_PROCESS_ATTACH
        iNewRefcount = InterlockedIncrement(&s_dwTlsIndexRefcount);
        assert(iNewRefcount >= 1);

        if (1 == iNewRefcount)
        {
            // Only if refcount went from 0 to 1, should we call TlsAlloc
            assert(TLS_OUT_OF_INDEXES == s_dwTlsIndex);
            s_dwTlsIndex = TlsAlloc();
            if(s_dwTlsIndex == TLS_OUT_OF_INDEXES)
            {
                fResult = FALSE;
                goto exit;
            }
            
            fResult = setCpuSpecificLib();
            if (FALSE == fResult)
                goto exit;
        }
        else if (TLS_OUT_OF_INDEXES == s_dwTlsIndex)
        {
            // If no TLS index, DLL_PROCESS_ATTACH initialization failed,
            // probably due to unsupported CPU.
            fResult = FALSE;
            goto exit;
        }
        
        /* No break: Initialize the index for first thread. */
        /* The attached process creates a new thread. */
        
    //case DLL_THREAD_ATTACH: 
    case INTELFFT_INIT_THREAD:
        
        if (s_dwTlsIndex != TLS_OUT_OF_INDEXES && NULL == TlsGetValue(s_dwTlsIndex))
        {
            pContext = (LPVOID)LocalAlloc(LPTR, nspSizeOfContext());
            if (pContext == NULL)
            {
                fResult = FALSE;
                goto exit;
            }

            nspInitContext (pContext);
            TlsSetValue( s_dwTlsIndex, pContext );
        }
        break;
        
    //case DLL_THREAD_DETACH:
    case INTELFFT_FREE_THREAD:
        
        if (s_dwTlsIndex != TLS_OUT_OF_INDEXES)
        {
            pContext = TlsGetValue( s_dwTlsIndex );
            if (pContext != NULL)
            {
                LocalFree( (HLOCAL) pContext );
                TlsSetValue( s_dwTlsIndex, NULL); // Avoid re-freeing this
            }
        }
        break;
        
    //case DLL_PROCESS_DETACH:
    case INTELFFT_FREE_PROCESS:
        
        if (s_dwTlsIndex != TLS_OUT_OF_INDEXES)
        {
            pContext = TlsGetValue(s_dwTlsIndex);
            if (pContext != NULL)
            {
                LocalFree((HLOCAL) pContext);
                TlsSetValue( s_dwTlsIndex, NULL); // Avoid re-freeing this
            }

            iNewRefcount = InterlockedDecrement(&s_dwTlsIndexRefcount);
            assert(iNewRefcount >= 0);

            // Only call TlsFree when refcount has dropped to zero
            if (0 == iNewRefcount)
            {
                TlsFree(s_dwTlsIndex);
                s_dwTlsIndex = TLS_OUT_OF_INDEXES;
            }
        }
        break;
        
    default:
        break;
    }

exit:
    if (FALSE == fResult && INTELFFT_INIT_PROCESS == fdwReason)
    {
        // Error occurred during attach/init, free everything. OTHERWISE if
        // setCpuSpecificLib() call failed, next time this process tries to create
        // a new codec, s_dwTlsIndex != TLS_OUT_OF_INDEXES and we will return TRUE
        // which will cause a crash (jump to NULL) when caller calls FFT.
        assert(NULL == pContext);

        iNewRefcount = InterlockedDecrement(&s_dwTlsIndexRefcount);

        // Only call TlsFree when refcount has dropped to zero
        if (0 == iNewRefcount && TLS_OUT_OF_INDEXES != s_dwTlsIndex)
        {
            TlsFree(s_dwTlsIndex);
            s_dwTlsIndex = TLS_OUT_OF_INDEXES;
        }
    }

    return fResult;
}


//***************************************************************************
// Function: DllInitCodec
//
// Purpose: This function receives DllMain notifications from the DMO's
//   DllMain, if we are being built as a DMO. This allows us to perform
//   per-thread initialization, as is required by the Intel FFT.
//
// Arguments:
//   ULONG ulReason - contains the DllMain notification, such as
//     DLL_PROCESS_ATTACH.
//***************************************************************************
void DllInitCodec(ULONG ulReason)
{
    DWORD   dwNewReason = -1;
    BOOL    fResult;

    // Tranlate original reason (such as DLL_PROCESS_ATTACH) to
    // new reason (such as INTELFFT_INIT_PROCESS).

    switch (ulReason)
    {
        case DLL_PROCESS_ATTACH:
            dwNewReason = INTELFFT_INIT_PROCESS;
            break;

        case DLL_THREAD_ATTACH:
            // DO NOTHING. This notification is given for every thread in the process,
            // while in reality only a few will end up using the codec. We check each
            // call into the codec and initialize Intel FFT there if it hasn't already
            // been done for that thread.
            goto exit;

        case DLL_THREAD_DETACH:
            dwNewReason = INTELFFT_FREE_THREAD;
            break;

        case DLL_PROCESS_DETACH:
            dwNewReason = INTELFFT_FREE_PROCESS;
            break;

        default:
            // We don't handle this code. Don't call MyInitNSP.
            goto exit;
    }

    assert(-1 != dwNewReason);
    fResult = MyInitNSP(dwNewReason);
    if (FALSE == fResult && DLL_PROCESS_ATTACH == ulReason)
    {
        // Special case: DllMain will not act on initialization failure,
        // which can occur if current CPU has no supported optimizations
        // (setCpuSpecificLib will fail). Therefore when DLL_PROCESS_DETACH
        // rolls around, we will decrement refcount below zero. More importantly,
        // our assumptions for race condition avoidance are violated. Therefore,
        // we need to artificially bump up the refcount. NOTE that with refcount
        // artificially bumped, refcount never goes down. That's fine, nothing
        // was allocated anyway.
        InterlockedIncrement(&s_dwTlsIndexRefcount);
    }

exit:
    return;
} // DllInitCodec

#endif  // WMA_TARGET_X86 && !defined(BUILD_INTEGER) && !defined(UNDER_CE)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\wmalib\wmadec_s\wavfileio.c ===
/* -------------------------------------------------------------------------
 *
 *  Microsoft Windows Media
 *
 *  Copyright (C) Microsoft Corporation, 1999 - 1999
 *
 *  File:       wavfileio.c
 *
 * ---------------------------------------------------------------------- */

#pragma code_seg("WMADEC")
#pragma data_seg("WMADEC_RW")
#pragma const_seg("WMADEC_RD")

#include <stdlib.h>
#include <memory.h>
#include "wavfileio.h"
#include "..\..\..\dsound\dsndver.h"

#if defined(UNDER_CE) && defined(WIN32_PLATFORM_PSPC)
	// Palm-size PC 2.11 needs this, H/PC Pro 2.11 does not
#   pragma warning( disable : 4273 )
	FILE *fopen( const char *filename, const char *mode );
	int fseek( FILE *stream, long offset, int origin );
	size_t fread( void *buffer, size_t size, size_t count, FILE *stream );
	size_t fwrite( const void *buffer, size_t size, size_t count, FILE *stream );
	int fclose( FILE *stream );
	int ferror( FILE *stream );
	int fflush( FILE *stream );
#endif // UNDER_CE

#ifndef mmioFOURCC
#  if WFIO_LITTLE_ENDIAN
#    define mmioFOURCC(ch0, ch1, ch2, ch3)  ((U32)(U8)(ch0)|((U32)(U8)(ch1)<<8)|((U32)(U8)(ch2)<<16)|((U32)(U8)(ch3)<<24))
#  else  /* WFIO_LITTLE_ENDIAN */
#    define mmioFOURCC(ch0, ch1, ch2, ch3)  ((U32)(U8)(ch3)|((U32)(U8)(ch2)<<8)|((U32)(U8)(ch1)<<16)|((U32)(U8)(ch0)<<24))
#  endif /* WFIO_LITTLE_ENDIAN */
#endif /* mmioFOURCC */

#define WFIO_FOURCC_RIFF    mmioFOURCC('R', 'I', 'F', 'F')
#define WFIO_FOURCC_WAVE    mmioFOURCC('W', 'A', 'V', 'E')
#define WFIO_FOURCC_fmt     mmioFOURCC('f', 'm', 't', ' ')
#define WFIO_FOURCC_data    mmioFOURCC('d', 'a', 't', 'a')
#define WFIO_FOURCC_fact    mmioFOURCC('f', 'a', 'c', 't')

/* forward declarations */
static I32 wfioReadHeaders(WavFileIO *pwfio);
static I32 wfioWriteHeaders(WavFileIO *pwfio, WAVEFORMATEX *pFormat, U32 cbFormat);
static I32 wfioCleanUpRead(WavFileIO *pwfio);
static I32 wfioCleanUpWrite(WavFileIO *pwfio);


/* utility functions */

U16
adjustByteOrder16(U16 val)
{
#if WFIO_LITTLE_ENDIAN
    return val;
#else  /* WFIO_LITTLE_ENDIAN */
    U8 *p = (U8 *)&val;
    return ((U16)p[0])|((U16)p[1]<<8);
#endif /* WFIO_LITTLE_ENDIAN */
}

U32
adjustByteOrder32(U32 val)
{
#if WFIO_LITTLE_ENDIAN
    return val;
#else  /* WFIO_LITTLE_ENDIAN */
    U8 *p = (U8 *)&val;
    return ((U32)p[0])|((U32)p[1]<<8)|((U32)p[2]<<16)|((U32)p[3]<<24);
#endif /* WFIO_LITTLE_ENDIAN */
}


WavFileIO *
wfioNew()
{
    WavFileIO *pwfio = (WavFileIO *)malloc(sizeof(WavFileIO));
    if(pwfio == NULL)
        return NULL;

    pwfio->m_mode = wfioModeRead;
#if WFIO_NO_WIN32
    pwfio->m_fpWav = NULL;
    pwfio->m_posRiffLength = 0;
    pwfio->m_posDataLength = 0;
#else   /* WFIO_NO_WIN32 */
    pwfio->m_hmmio = NULL;
#endif  /* WFIO_NO_WIN32 */
    pwfio->m_pFormat = NULL;
    pwfio->m_sizeFormat = 0;
    pwfio->m_sizeData = 0;
    pwfio->m_posDataStart = 0;

#if !WFIO_NO_WIN32
    memset(&pwfio->m_mmioinfo, 0, sizeof(pwfio->m_mmioinfo));
    memset(&pwfio->m_ckWave, 0, sizeof(pwfio->m_ckWave));
    memset(&pwfio->m_ck, 0, sizeof(pwfio->m_ck));
#endif  /* WFIO_NO_WIN32 */

    return pwfio;
}


void
wfioDelete(WavFileIO *pwfio)
{
    wfioClose(pwfio);
    free(pwfio);
}


I32
wfioOpen(WavFileIO *pwfio,
         const char *szFile,
         WAVEFORMATEX *pFormat,
         U32 cbFormat,
         I32 mode)
{
    I32 lr;

    if(pwfio == NULL)
        return MMSYSERR_ERROR;

#if WFIO_NO_WIN32

    if(pwfio->m_fpWav)
        return MMSYSERR_ERROR;

    pwfio->m_mode = mode;

    if(pwfio->m_mode == wfioModeWrite)
    {
        /* open the file for writing */
        pwfio->m_fpWav = fopen(szFile, "wb");
        if(pwfio->m_fpWav == NULL)
        {
            lr = MMSYSERR_ERROR;
            goto lerror;
        }

        /* write the header info */
        lr = wfioWriteHeaders(pwfio, pFormat, cbFormat);
        if(lr != MMSYSERR_NOERROR)
            goto lerror;
    }
    else
    {
        /* open the file for reading */
        pwfio->m_fpWav = fopen(szFile, "rb");
        if(pwfio->m_fpWav == NULL)
        {
            lr = MMSYSERR_ERROR;
            goto lerror;
        }

        /* read the hearder info */
        lr = wfioReadHeaders(pwfio);
        if(lr != MMSYSERR_NOERROR)
            goto lerror;

        /* seek to the beginning */
        wfioSeek(pwfio, 0, SEEK_CUR);
    }

#else  /* WFIO_NO_WIN32 */

    if(pwfio->m_hmmio)
        return MMSYSERR_ERROR;

    pwfio->m_mode = mode;

    /* slightly different for READ and WRITE */
    if(pwfio->m_mode == wfioModeRead)
    {
        /* open the file for read */
        pwfio->m_hmmio = mmioOpen((LPSTR)szFile, NULL, MMIO_READ/*|MMIO_DENYWRITE*/);
        if(pwfio->m_hmmio == NULL)
        {
            lr = MMSYSERR_ERROR;
            goto lerror;
        }

        /* read the header info */
        lr = wfioReadHeaders(pwfio);
        if(lr != MMSYSERR_NOERROR)
            goto lerror;

        /* seek to the beginning */
        wfioSeek(pwfio, 0, SEEK_CUR);
  }
  else
  {
      /* open the file for write */
      pwfio->m_hmmio = mmioOpen((LPSTR)szFile, NULL, MMIO_READWRITE|MMIO_CREATE|MMIO_ALLOCBUF/*|MMIO_DENYWRITE*/);
      if(pwfio->m_hmmio == NULL)
      {
          lr = MMSYSERR_ERROR;
          goto lerror;
      }

      lr = wfioWriteHeaders(pwfio, pFormat, cbFormat);
      if(lr != MMSYSERR_NOERROR)
          goto lerror;
  }

#endif /* WFIO_NO_WIN32 */

  return MMSYSERR_NOERROR;

lerror:
  wfioClose(pwfio);
  return lr;
}


void
wfioClose(WavFileIO *pwfio)
{
    if(pwfio == NULL)
        return;

#if WFIO_NO_WIN32

    if(pwfio->m_fpWav)
    {
        if(pwfio->m_mode == wfioModeWrite)
            wfioCleanUpWrite(pwfio);
        else
            wfioCleanUpRead(pwfio);

        fclose(pwfio->m_fpWav);
        pwfio->m_fpWav = NULL;
    }

    if(pwfio->m_pFormat)
    {
        free(pwfio->m_pFormat);
        pwfio->m_pFormat = NULL;

        pwfio->m_sizeFormat = 0;
    }

    pwfio->m_sizeData = 0;
    pwfio->m_posDataStart = 0;

    /* just for the safety... */
    pwfio->m_posRiffLength = 0;
    pwfio->m_posDataLength = 0;

#else  /* WFIO_NO_WIN32 */

    if(pwfio->m_hmmio)
    {
        if(pwfio->m_mode == wfioModeWrite)
            wfioCleanUpWrite(pwfio);
        else
            wfioCleanUpRead(pwfio);

        mmioClose(pwfio->m_hmmio, 0);
        pwfio->m_hmmio = NULL;
    }

    if(pwfio->m_pFormat)
    {
        free(pwfio->m_pFormat);
        pwfio->m_pFormat = NULL;

        pwfio->m_sizeFormat = 0;
    }

    pwfio->m_sizeData = 0;
    pwfio->m_posDataStart = 0;

    /* just for safety... */
    memset(&pwfio->m_mmioinfo, 0, sizeof(pwfio->m_mmioinfo));
    memset(&pwfio->m_ckWave, 0, sizeof(pwfio->m_ckWave));
    memset(&pwfio->m_ck, 0, sizeof(pwfio->m_ck));

#endif /* WFIO_NO_WIN32 */
}


I32
wfioSeek(WavFileIO *pwfio,
         I32 position,
         I32 origin)
{
    if(pwfio == NULL)
        return -1;

    /* only for reading... */
    if(pwfio->m_mode != wfioModeRead)
        return -1;

#if WFIO_NO_WIN32

    switch(origin)
    {
    case SEEK_SET:
        return fseek(pwfio->m_fpWav, pwfio->m_posDataStart + position, SEEK_SET);

    case SEEK_CUR:
        return fseek(pwfio->m_fpWav, position, SEEK_CUR);

    case SEEK_END:
        return fseek(pwfio->m_fpWav, pwfio->m_posDataStart + pwfio->m_sizeData - position, SEEK_SET);
    }

#else  /* WFIO_NO_WIN32 */

    switch(origin)
    {
    case SEEK_SET:
        return mmioSeek(pwfio->m_hmmio, pwfio->m_posDataStart + position, SEEK_SET);

    case SEEK_CUR:
        return mmioSeek(pwfio->m_hmmio, position, SEEK_CUR);

    case SEEK_END:
        return mmioSeek(pwfio->m_hmmio, pwfio->m_posDataStart + pwfio->m_sizeData - position, SEEK_SET);
    }

#endif /* WFIO_NO_WIN32 */

  return -1;
}


I32
wfioRead(WavFileIO *pwfio,
         U8 *pBuf,
         I32 cbBuf)
{
#if WFIO_NO_WIN32

    size_t ret;

    if(pwfio == NULL)
        return (I32)-1;

    if(pwfio->m_fpWav == NULL
       || pwfio->m_mode != wfioModeRead
       || pBuf == NULL)
        return (I32)-1;

    /* in alignment units... */
    cbBuf = (cbBuf/pwfio->m_pFormat->nBlockAlign)*pwfio->m_pFormat->nBlockAlign;

#if !WFIO_LITTLE_ENDIAN

    /* have to swap bytes... */

    if(pwfio->m_pFormat->wBitsPerSample == 16)
    {
        I32 i;
        U16 *p = (U16 *)pBuf;
        for(i = cbBuf/2; i > 0; i--, p++)
            *p = adjustByteOrder16(*p);
    }

#endif  /* WFIO_LITTLE_ENDIAN */

    ret = fread(pBuf, 1, cbBuf, pwfio->m_fpWav);
    if(ferror(pwfio->m_fpWav))
        return (I32)-1;

    return (I32)ret;

#else  /* WFIO_NO_WIN32 */

    if(pwfio == NULL)
        return (I32)-1;

    return mmioRead(pwfio->m_hmmio, (HPSTR)pBuf, cbBuf);

#endif /* WFIO_NO_WIN32 */
}


I32
wfioWrite(WavFileIO *pwfio,
          U8 *pBuf,
          I32 cbBuf)
{
#if WFIO_NO_WIN32

    size_t ret;

    if(pwfio == NULL)
        return (I32)-1;

    if(pwfio->m_fpWav == NULL
       || pwfio->m_mode != wfioModeWrite
       || pBuf == NULL)
        return (I32)-1;

    /* in alignment units... */
    cbBuf = (cbBuf/pwfio->m_pFormat->nBlockAlign)*pwfio->m_pFormat->nBlockAlign;

#if !WFIO_LITTLE_ENDIAN

    /* have to swap bytes... */

    if(pwfio->m_pFormat->wBitsPerSample == 16)
    {
        I32 i;
        U16 *p = (U16 *)pBuf;
        for(i = cbBuf/2; i > 0; i--, p++)
            *p = adjustByteOrder16(*p);
    }

#endif  /* WFIO_LITTLE_ENDIAN */

    ret = fwrite(pBuf, 1, cbBuf, pwfio->m_fpWav);
    if(ferror(pwfio->m_fpWav))
        return (I32)-1;

    pwfio->m_sizeData += ret;

    return ret;

#else  /* WFIO_NO_WIN32 */

    /* buffered write (MMIO_ALLOCBUF used for opening) */

    I32 lr;
    I32 cbBlock;
    I32 cbWritten = 0;

    if(pwfio == NULL)
        return (I32)-1;

    if(pBuf == NULL)
        return 0;

    while(cbBuf > 0)
    {
        /* check if we need to advance to the next buffer */
        if(pwfio->m_mmioinfo.pchNext == pwfio->m_mmioinfo.pchEndWrite)
        {
            pwfio->m_mmioinfo.dwFlags |= MMIO_DIRTY;
            lr = mmioAdvance(pwfio->m_hmmio, &pwfio->m_mmioinfo, MMIO_WRITE);
            if(lr != MMSYSERR_NOERROR)
                goto lerror;
        }

        /* copy in blocks */
        cbBlock = pwfio->m_mmioinfo.pchEndWrite - pwfio->m_mmioinfo.pchNext;
        if(cbBlock > cbBuf)
            cbBlock = cbBuf;
        CopyMemory(pwfio->m_mmioinfo.pchNext, pBuf, cbBlock);

        /* update pointers and counters */
        pBuf                      += cbBlock;
        pwfio->m_mmioinfo.pchNext += cbBlock;
        cbWritten                 += cbBlock;
        cbBuf                     -= cbBlock;

        /* update global stat members */
        pwfio->m_sizeData += cbBlock;
    }

lerror:
    return cbWritten;

#endif /* WFIO_NO_WIN32 */
}


WAVEFORMATEX *
wfioGetFormat(WavFileIO *pwfio)
{
    if(pwfio == NULL)
        return NULL;

    return pwfio->m_pFormat;
}


U32
wfioGetFormatLength(WavFileIO *pwfio)
{
    if(pwfio == NULL || pwfio->m_pFormat == NULL)
        return 0;

    return sizeof(WAVEFORMATEX) + pwfio->m_pFormat->cbSize;
}


U32
wfioGetSampleSize(WavFileIO *pwfio)
{
    if(pwfio == NULL || pwfio->m_pFormat == NULL)
        return 0;

    return pwfio->m_pFormat->nBlockAlign;
}


U32
wfioGetDataLength(WavFileIO *pwfio)
{
    if(pwfio == NULL)
        return 0;

    return pwfio->m_sizeData;
}


I32
wfioGetMode(WavFileIO *pwfio)
{
    if(pwfio == NULL)
        return 0;

    return pwfio->m_mode;
}


I32
wfioIsOpened(WavFileIO *pwfio)
{
#if WFIO_NO_WIN32
    return pwfio && pwfio->m_fpWav != NULL;
#else   /* WFIO_NO_WIN32 */
    return pwfio && pwfio->m_hmmio != NULL;
#endif  /* WFIO_NO_WIN32 */
}


I32
wfioReadHeaders(WavFileIO *pwfio)
{
    I32 lr;
    Bool fFmtChunkFound  = WMAB_FALSE;  
    Bool fDataChunkFound = WMAB_FALSE;
    
#if WFIO_NO_WIN32
    
    size_t ret;
    size_t offset = 0;
    size_t offSeek;
    
    U32 dwTemp;
    U32 dwSize;
    U32 dwHead;
    
    if(pwfio == NULL)
    {
        lr = MMSYSERR_ERROR;
        goto lerror;
    }
    
    if(pwfio->m_fpWav == NULL)
    {
        lr = MMSYSERR_ERROR;
        goto lerror;
    }
    
    /* -----------------------------------------------------------------------
    * find the RIFF/WAVE chunk
    */
    
    /* read "RIFF" */
    
    ret = fread(&dwHead, 1, sizeof(U32), pwfio->m_fpWav);
    if(ret != sizeof(U32))
    {
        lr = MMSYSERR_READERROR;
        goto lerror;
    }
    offset += ret;
    
    if(dwHead != WFIO_FOURCC_RIFF)
    {
        lr = MMSYSERR_ERROR;
        goto lerror;
    }
    
    /* read "RIFF" length */
    
    pwfio->m_posRiffLength = offset;
    
    ret = fread(&dwTemp, 1, sizeof(U32), pwfio->m_fpWav);
    if(ret != sizeof(U32))
    {
        lr = MMSYSERR_READERROR;
        goto lerror;
    }
    offset += ret;
    dwSize = adjustByteOrder32(dwTemp); //Ignored
    
    /* read "WAVE" */
    
    ret = fread(&dwHead, 1, sizeof(U32), pwfio->m_fpWav);
    if(ret != sizeof(U32))
    {
        lr = MMSYSERR_READERROR;
        goto lerror;
    }
    offset += ret;
    
    if(dwHead != WFIO_FOURCC_WAVE)
    {
        lr = MMSYSERR_ERROR;
        goto lerror;
    }
    
    offSeek = offset;
    
    /* -----------------------------------------------------------------------
    * find the FMT chunk: skip over unknown chunks
    */
    
    /* read "fmt " */
    fFmtChunkFound = WMAB_FALSE;  
    do {
        // Read chunk header
        ret = fread(&dwHead, 1, sizeof(U32), pwfio->m_fpWav);
        if(ret != sizeof(U32))
        {
            lr = MMSYSERR_READERROR;
            goto lerror;
        }
        offset += ret;
        
        if(dwHead == WFIO_FOURCC_fmt)
            fFmtChunkFound = WMAB_TRUE;
        
        /* read chunk length */
        ret = fread(&dwTemp, 1, sizeof(U32), pwfio->m_fpWav);
        if(ret != sizeof(U32))
        {
            lr = MMSYSERR_READERROR;
            goto lerror;
        }
        offset += ret;
        
        dwSize = adjustByteOrder32(dwTemp);
        if (!fFmtChunkFound) {
            /* read-off dwSize bytes */
            offset += dwSize;
            ret = fseek(pwfio->m_fpWav, offset, SEEK_SET);
            if ( ret ) {
                lr = MMSYSERR_READERROR;
                goto lerror;
            } 
        }  
    } while (!fFmtChunkFound);
    
    /* "fmt " length was read earlier */
    /* prepare the format buffer */
    
    pwfio->m_sizeFormat = dwSize;
    if(pwfio->m_sizeFormat < sizeof(WAVEFORMATEX))
        pwfio->m_sizeFormat = sizeof(WAVEFORMATEX);
    
    pwfio->m_pFormat = (WAVEFORMATEX *)malloc(pwfio->m_sizeFormat);
    if(pwfio->m_pFormat == NULL)
    {
        lr = MMSYSERR_NOMEM;
        goto lerror;
    }
    memset(pwfio->m_pFormat, 0, pwfio->m_sizeFormat);
    
    /* read the format chunk */
    
    ret = fread(pwfio->m_pFormat, 1, dwSize, pwfio->m_fpWav);
    if(ret != dwSize)
    {
        lr = MMSYSERR_READERROR;
        goto lerror;
    }
    offset += ret;
    
    /* HongCho: I can convert the fields into the correct order here,
    *          but since I don't know the layouts of all the possible
    *          formats, only the fields in WAVEFORMATEX will be
    *          converted.
    */
    
    pwfio->m_pFormat->wFormatTag      = adjustByteOrder16(pwfio->m_pFormat->wFormatTag);
    pwfio->m_pFormat->nChannels       = adjustByteOrder16(pwfio->m_pFormat->nChannels);
    pwfio->m_pFormat->nSamplesPerSec  = adjustByteOrder32(pwfio->m_pFormat->nSamplesPerSec);
    pwfio->m_pFormat->nAvgBytesPerSec = adjustByteOrder32(pwfio->m_pFormat->nAvgBytesPerSec);
    pwfio->m_pFormat->nBlockAlign     = adjustByteOrder16(pwfio->m_pFormat->nBlockAlign);
    pwfio->m_pFormat->wBitsPerSample  = adjustByteOrder16(pwfio->m_pFormat->wBitsPerSample);
    pwfio->m_pFormat->cbSize          = adjustByteOrder16(pwfio->m_pFormat->cbSize);
    
#if !WFIO_LITTLE_ENDIAN
    /* only PCM for big-endian platforms */
    if(pwfio->m_pFormat->wFormatTag != WAVE_FORMAT_PCM)
    {
        lr = MMSYSERR_ERROR;
        goto lerror;
    }
#endif /* WFIO_LITTLE_ENDIAN */
    
    /* the format chunk for PCM on WAVE files are WAVEFORMAT */
    if(pwfio->m_pFormat->wFormatTag == WAVE_FORMAT_PCM)
        pwfio->m_pFormat->cbSize = 0;
    
        /* -----------------------------------------------------------------------
        * find the DATA chunk: skip over other unknown chunks
    */
    fDataChunkFound = WMAB_FALSE;
    
    do {  
        /* Read Chunk Header */
        ret = fread(&dwHead, 1, sizeof(U32), pwfio->m_fpWav);
        if(ret != sizeof(U32))
        {
            lr = MMSYSERR_READERROR;
            goto lerror;
        }
        offset += ret;
        
        fDataChunkFound = (dwHead == WFIO_FOURCC_data);
        
        if (!fDataChunkFound)
        {
            /* Read chunk length */
            ret = fread(&dwTemp, 1, sizeof(U32), pwfio->m_fpWav);
            if(ret != sizeof(U32))
            {
                lr = MMSYSERR_READERROR;
                goto lerror;
            }
            offset += ret;
            
            dwSize = adjustByteOrder32(dwTemp);
            offset += dwSize;
            
            // Unknown/ un-needed chunk. Skip over it.
            /* read-off dwSize bytes */
            ret = fseek(pwfio->m_fpWav, offset, SEEK_SET);
            if ( ret) {
                lr = MMSYSERR_READERROR;
                goto lerror;
            }
        }
    } while (!fDataChunkFound);
    
    /* read "data" length */
    
    pwfio->m_posDataLength = offset;
    
    ret = fread(&dwTemp, 1, sizeof(U32), pwfio->m_fpWav);
    if(ret != sizeof(U32))
    {
        lr = MMSYSERR_READERROR;
        goto lerror;
    }
    offset += ret;
    
    pwfio->m_sizeData   = adjustByteOrder32(dwTemp);
    
    pwfio->m_posDataStart = offset;
    
#else  /* WFIO_NO_WIN32 */
    
    MMCKINFO ck;
    
    U32 cksize;
    
    if(pwfio == NULL)
    {
        lr = MMSYSERR_ERROR;
        goto lerror;
    }
    
    if(pwfio->m_hmmio == NULL)
    {
        lr = MMSYSERR_ERROR;
        goto lerror;
    }
    
    /* find the wave info chunk */
    pwfio->m_ckWave.fccType = WFIO_FOURCC_WAVE;
    lr = mmioDescend(pwfio->m_hmmio, &pwfio->m_ckWave, NULL, MMIO_FINDRIFF);
    if(lr != MMSYSERR_NOERROR)
        goto lerror;
    
    /* find FMT chunk */
    ck.ckid = WFIO_FOURCC_fmt;
    lr = mmioDescend(pwfio->m_hmmio, &ck, &pwfio->m_ckWave, MMIO_FINDCHUNK);
    if(lr != MMSYSERR_NOERROR)
        goto lerror;
    
    cksize = ck.cksize;
    if(cksize < sizeof(WAVEFORMATEX))
        cksize = sizeof(WAVEFORMATEX);
    
    /* prepare the format buffer */
    pwfio->m_sizeFormat = cksize;
    pwfio->m_pFormat = (WAVEFORMATEX *)malloc(pwfio->m_sizeFormat);
    if(pwfio->m_pFormat == NULL)
    {
        lr = MMSYSERR_NOMEM;
        goto lerror;
    }
    memset(pwfio->m_pFormat, 0, pwfio->m_sizeFormat);
    
    /* read the format chunk */
    lr = mmioRead(pwfio->m_hmmio, (HPSTR)pwfio->m_pFormat, ck.cksize);
    if(lr != (I32)ck.cksize)
    {
        lr = MMSYSERR_READERROR;
        goto lerror;
    }
    
    /* the format chunk for PCM on WAV files are WAVEFORMAT */
    if(pwfio->m_pFormat->wFormatTag == WAVE_FORMAT_PCM)
        pwfio->m_pFormat->cbSize = 0;
    
    /* ascend out of FMT */
    lr = mmioAscend(pwfio->m_hmmio, &ck, 0);
    if(lr != MMSYSERR_NOERROR)
        goto lerror;
    
    /* find DATA chunk */
    pwfio->m_ck.ckid = WFIO_FOURCC_data;
    lr = mmioDescend(pwfio->m_hmmio, &pwfio->m_ck, &pwfio->m_ckWave, MMIO_FINDCHUNK);
    if(lr != MMSYSERR_NOERROR)
        goto lerror;
    
    pwfio->m_sizeData     = pwfio->m_ck.cksize;
    
    pwfio->m_posDataStart = pwfio->m_ck.dwDataOffset;
    
    /* get info */
    lr = mmioGetInfo(pwfio->m_hmmio, &pwfio->m_mmioinfo, 0);
    if(lr != MMSYSERR_NOERROR)
        goto lerror;
    
#endif /* WFIO_NO_WIN32 */
    
    return MMSYSERR_NOERROR;
    
lerror:
    if(pwfio->m_pFormat)
    {
        free(pwfio->m_pFormat);
        pwfio->m_pFormat = NULL;
        
        pwfio->m_sizeFormat = 0;
    }
    return lr;
}


I32
wfioWriteHeaders(WavFileIO *pwfio,
                 WAVEFORMATEX *pFormat,
                 U32 cbFormat)
{
    I32 lr;

#if WFIO_NO_WIN32

    size_t ret;
    size_t offset = 0;

    U32 dwTemp;

    WAVEFORMATEX *pWavFormat = NULL;

    if(pwfio == NULL)
    {
        lr = MMSYSERR_ERROR;
        goto lerror;
    }

    if(pwfio->m_fpWav == NULL)
    {
        lr = MMSYSERR_ERROR;
        goto lerror;
    }
    if(pFormat == NULL)
    {
        lr = MMSYSERR_ERROR;
        goto lerror;
    }
    if(cbFormat < sizeof(WAVEFORMATEX))
    {
        lr = MMSYSERR_ERROR;
        goto lerror;
    }

    /* copy the format locally */

    if(pwfio->m_pFormat)
    {
        free(pwfio->m_pFormat);
        pwfio->m_pFormat = NULL;

        pwfio->m_sizeFormat = 0;
    }
    pwfio->m_sizeFormat = cbFormat;
    pwfio->m_pFormat = (WAVEFORMATEX *)malloc(pwfio->m_sizeFormat);
    if(pwfio->m_pFormat == NULL)
    {
        lr = MMSYSERR_NOMEM;
        goto lerror;
    }
    memcpy(pwfio->m_pFormat, pFormat, pwfio->m_sizeFormat);

    /* format in the right format... */
    pWavFormat = (WAVEFORMATEX *)malloc(pwfio->m_sizeFormat);
    if(pWavFormat == NULL)
    {
        lr = MMSYSERR_NOMEM;
        goto lerror;
    }
    memcpy(pWavFormat, pFormat, pwfio->m_sizeFormat);

#if !WFIO_LITTLE_ENDIAN
    /* only PCM for big-endian platforms... */
    if(pFormat->wFormatTag != WAVE_FORMAT_PCM)
    {
        lr = MMSYSERR_ERROR;
        goto lerror;
    }
#endif /* WFIO_LITTLE_ENDIAN */

    pWavFormat->wFormatTag      = adjustByteOrder16(pWavFormat->wFormatTag);
    pWavFormat->nChannels       = adjustByteOrder16(pWavFormat->nChannels);
    pWavFormat->nSamplesPerSec  = adjustByteOrder32(pWavFormat->nSamplesPerSec);
    pWavFormat->nAvgBytesPerSec = adjustByteOrder32(pWavFormat->nAvgBytesPerSec);
    pWavFormat->nBlockAlign     = adjustByteOrder16(pWavFormat->nBlockAlign);
    pWavFormat->wBitsPerSample  = adjustByteOrder16(pWavFormat->wBitsPerSample);
    pWavFormat->cbSize          = adjustByteOrder16(pWavFormat->cbSize);

    /* -----------------------------------------------------------------------
     * create RIFF/WAVE chunk
     */

    /* write "RIFF" */

    dwTemp = WFIO_FOURCC_RIFF;
    ret = fwrite(&dwTemp, 1, sizeof(U32), pwfio->m_fpWav);
    if(ret != sizeof(U32))
    {
        lr = MMSYSERR_WRITEERROR;
        goto lerror;
    }
    offset += ret;

    /* write "RIFF" length, temporarily */

    pwfio->m_posRiffLength = offset;

    dwTemp = 0;   /* temporary */
    ret = fwrite(&dwTemp, 1, sizeof(U32), pwfio->m_fpWav);
    if(ret != sizeof(U32))
    {
        lr = MMSYSERR_WRITEERROR;
        goto lerror;
    }
    offset += ret;

    /* write "WAVE" */

    dwTemp = WFIO_FOURCC_WAVE;
    ret = fwrite(&dwTemp, 1, sizeof(U32), pwfio->m_fpWav);
    if(ret != sizeof(U32))
    {
        lr = MMSYSERR_WRITEERROR;
        goto lerror;
    }
    offset += ret;

    /* -----------------------------------------------------------------------
     * create FMT chunk
     */

    /* write "fmt " */

    dwTemp = WFIO_FOURCC_fmt;
    ret = fwrite(&dwTemp, 1, sizeof(U32), pwfio->m_fpWav);
    if(ret != sizeof(U32))
    {
        lr = MMSYSERR_WRITEERROR;
        goto lerror;
    }
    offset += ret;

    /* write "fmt " length */

    dwTemp = adjustByteOrder32(cbFormat);
    ret = fwrite(&dwTemp, 1, sizeof(U32), pwfio->m_fpWav);
    if(ret != sizeof(U32))
    {
        lr = MMSYSERR_WRITEERROR;
        goto lerror;
    }
    offset += ret;

    /* write actual format */

    ret = fwrite(pWavFormat, 1, cbFormat, pwfio->m_fpWav);
    if(ret != cbFormat)
    {
        lr = MMSYSERR_WRITEERROR;
        goto lerror;
    }
    offset += ret;

    /* -----------------------------------------------------------------------
     * create DATA chunk
     */

    /* write "data" */

    dwTemp = WFIO_FOURCC_data;
    ret = fwrite(&dwTemp, 1, sizeof(U32), pwfio->m_fpWav);
    if(ret != sizeof(U32))
    {
        lr = MMSYSERR_WRITEERROR;
        goto lerror;
    }
    offset += ret;

    /* write "data" length */

    pwfio->m_posDataLength = offset;

    dwTemp = 0;
    ret = fwrite(&dwTemp, 1, sizeof(U32), pwfio->m_fpWav);
    if(ret != sizeof(U32))
    {
        lr = MMSYSERR_WRITEERROR;
        goto lerror;
    }
    offset += ret;

    pwfio->m_sizeData   = 0;

    pwfio->m_posDataStart = offset;

    if(pWavFormat)
    {
        free(pWavFormat);
        pWavFormat = NULL;
    }

    return MMSYSERR_NOERROR;

lerror:
    if(pwfio->m_pFormat)
    {
        free(pwfio->m_pFormat);
        pwfio->m_pFormat = NULL;

        pwfio->m_sizeFormat = 0;
    }

    if(pWavFormat)
    {
        free(pWavFormat);
        pWavFormat = NULL;
    }

    return lr;

#else  /* WFIO_NO_WIN32 */

    if(pwfio == NULL)
    {
        lr = MMSYSERR_ERROR;
        goto lerror;
    }
    if(pwfio->m_hmmio == NULL)
    {
        lr = MMSYSERR_ERROR;
        goto lerror;
    }
    if(pwfio->m_mode != wfioModeWrite)
    {
        lr = MMSYSERR_ERROR;
        goto lerror;
    }
    if(pFormat == NULL)
    {
        lr = MMSYSERR_ERROR;
        goto lerror;
    }
    if(cbFormat < sizeof(WAVEFORMATEX))
    {
        lr = MMSYSERR_ERROR;
        goto lerror;
    }

    /* copy the format locally */
    if(pwfio->m_pFormat)
    {
        free(pwfio->m_pFormat);
        pwfio->m_pFormat = NULL;

        pwfio->m_sizeFormat = 0;
    }
    pwfio->m_sizeFormat = cbFormat;
    pwfio->m_pFormat = (WAVEFORMATEX *)malloc(pwfio->m_sizeFormat);
    if(pwfio->m_pFormat == NULL)
    {
        lr = MMSYSERR_NOMEM;
        goto lerror;
    }
    CopyMemory(pwfio->m_pFormat, pFormat, pwfio->m_sizeFormat);

    /* create WAVE chunk */
    pwfio->m_ckWave.fccType = WFIO_FOURCC_WAVE;
    pwfio->m_ckWave.cksize  = 0;
    lr = mmioCreateChunk(pwfio->m_hmmio, &pwfio->m_ckWave, MMIO_CREATERIFF);
    if(lr != MMSYSERR_NOERROR)
        goto lerror;

    /* create FMT chunk */
    pwfio->m_ck.ckid   = WFIO_FOURCC_fmt;
    pwfio->m_ck.cksize = pwfio->m_sizeFormat;
    lr = mmioCreateChunk(pwfio->m_hmmio, &pwfio->m_ck, 0);
    if(lr != MMSYSERR_NOERROR)
        goto lerror;

    /* copy out the format */
    lr = mmioWrite(pwfio->m_hmmio, (HPSTR)pwfio->m_pFormat, pwfio->m_sizeFormat);
    if(lr != (I32)pwfio->m_sizeFormat)
    {
        lr = MMSYSERR_WRITEERROR;
        goto lerror;
    }

    /* ascend out of FMT */
    lr = mmioAscend(pwfio->m_hmmio, &pwfio->m_ck, 0);
    if(lr != MMSYSERR_NOERROR)
        goto lerror;

    /* create DATA chunk */

    pwfio->m_ck.ckid   = WFIO_FOURCC_data;
    pwfio->m_ck.cksize = 0;
    lr = mmioCreateChunk(pwfio->m_hmmio, &pwfio->m_ck, 0);
    if(lr != MMSYSERR_NOERROR)
        goto lerror;

    /* get info */
    lr = mmioGetInfo(pwfio->m_hmmio, &pwfio->m_mmioinfo, 0);
    if(lr != MMSYSERR_NOERROR)
        goto lerror;

    if(pwfio->m_pFormat)
    {
        free(pwfio->m_pFormat);
        pwfio->m_pFormat = NULL;

        pwfio->m_sizeFormat = 0;
    }

    return MMSYSERR_NOERROR;

lerror:
    if(pwfio->m_pFormat)
    {
        free(pwfio->m_pFormat);
        pwfio->m_pFormat = NULL;

        pwfio->m_sizeFormat = 0;
    }
    return lr;

#endif /* WFIO_NO_WIN32 */
}


I32
wfioCleanUpRead(WavFileIO *pwfio)
{
    if(pwfio == NULL)
        return MMSYSERR_ERROR;

    /* for a historic reason... */
    return MMSYSERR_NOERROR;
}


I32
wfioCleanUpWrite(WavFileIO *pwfio)
{
    I32 lr;

#if WFIO_NO_WIN32

    size_t ret;

    U32 dwTemp;

    if(pwfio == NULL)
    {
        lr = MMSYSERR_ERROR;
        goto lerror;
    }
    if(pwfio->m_fpWav == NULL)
    {
        lr = MMSYSERR_ERROR;
        goto lerror;
    }
    if(pwfio->m_mode != wfioModeWrite)
    {
        lr = MMSYSERR_ERROR;
        goto lerror;
    }

    /* flush it first */

    fflush(pwfio->m_fpWav);

    /* write back the data length */

    ret = fseek(pwfio->m_fpWav, pwfio->m_posDataLength, SEEK_SET);
    if(ret != 0)
    {
        lr = MMSYSERR_ERROR;
        goto lerror;
    }

    dwTemp = adjustByteOrder32(pwfio->m_sizeData);
    ret = fwrite(&dwTemp, 1, sizeof(U32), pwfio->m_fpWav);
    if(ret != sizeof(U32))
    {
        lr = MMSYSERR_WRITEERROR;
        goto lerror;
    }

    /* write back the riff length */

    ret = fseek(pwfio->m_fpWav, pwfio->m_posRiffLength, SEEK_SET);
    if(ret != 0)
    {
        lr = MMSYSERR_ERROR;
        goto lerror;
    }

    dwTemp = pwfio->m_sizeData + pwfio->m_posDataStart - 8; /* "RIFF" and its size (4 + 4 bytes) */
    dwTemp = adjustByteOrder32(dwTemp);
    ret = fwrite(&dwTemp, 1, sizeof(U32), pwfio->m_fpWav);
    if(ret != sizeof(U32))
    {
        lr = MMSYSERR_WRITEERROR;
        goto lerror;
    }

    /* flush again... */

    fflush(pwfio->m_fpWav);

#else   /* WFIO_NO_WIN32 */

    if(pwfio == NULL)
    {
        lr = MMSYSERR_ERROR;
        goto lerror;
    }
    if(pwfio->m_hmmio == NULL)
    {
        lr = MMSYSERR_ERROR;
        goto lerror;
    }
    if(pwfio->m_mode != wfioModeWrite)
    {
        lr = MMSYSERR_ERROR;
        goto lerror;
    }

    /* write back the info */
    pwfio->m_mmioinfo.dwFlags |= MMIO_DIRTY;
    lr = mmioSetInfo(pwfio->m_hmmio, &pwfio->m_mmioinfo, 0);
    if(lr != MMSYSERR_NOERROR)
        goto lerror;

    /* ascend out of DATA.  this will cause the write-out. */
    lr = mmioAscend(pwfio->m_hmmio, &pwfio->m_ck, 0);
    if(lr != MMSYSERR_NOERROR)
        goto lerror;

    /* ascend out of RIFF.  this will cause the file write-out, probably. */
    lr = mmioAscend(pwfio->m_hmmio, &pwfio->m_ckWave, 0);
    if(lr != MMSYSERR_NOERROR)
        goto lerror;

#endif  /* WFIO_NO_WIN32 */

    return MMSYSERR_NOERROR;

lerror:
    return lr;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\wmalib\common\lpcConst.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows Media
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       lpcConst.h
//
//--------------------------------------------------------------------------

#pragma MSVC_DISABLE_WARNING(4305)

#define LSP_CONST16(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p) \
	LSP_FROM_FLOAT(a),LSP_FROM_FLOAT(b),LSP_FROM_FLOAT(c),LSP_FROM_FLOAT(d),LSP_FROM_FLOAT(e), \
	LSP_FROM_FLOAT(f),LSP_FROM_FLOAT(g),LSP_FROM_FLOAT(h),LSP_FROM_FLOAT(i),LSP_FROM_FLOAT(j), \
	LSP_FROM_FLOAT(k),LSP_FROM_FLOAT(l),LSP_FROM_FLOAT(m),LSP_FROM_FLOAT(n),LSP_FROM_FLOAT(o), \
	LSP_FROM_FLOAT(p)

// -2.0F*(Float)cos(2.0*PI*rgfltLsfReconLevel [iLPC] [ilsfQ[iLPC]]); 
const LpType g_rgiLsfReconLevel [LPCORDER] [16] = {
LSP_CONST16(-1.9873287678,-1.9794453382,-1.9717909098,-1.9626054764,-1.9503837824,-1.9333611727,-1.9071923494,-1.8619141579,0.0000000000,0.0000000000,0.0000000000,0.0000000000,0.0000000000,0.0000000000,0.0000000000,0.0000000000),
LSP_CONST16(-1.9725999832,-1.9608316422,-1.9498258829,-1.9380615950,-1.9251661301,-1.9101020098,-1.8923232555,-1.8714981079,-1.8456481695,-1.8135806322,-1.7762006521,-1.7326526642,-1.6790785789,-1.6095907688,-1.5082964897,-1.3312033415),
LSP_CONST16(-1.9010910988,-1.8648242950,-1.8341966867,-1.8016844988,-1.7665011883,-1.7281632423,-1.6850270033,-1.6373825073,-1.5850157738,-1.5179518461,-1.4367990494,-1.3395057917,-1.2417620420,-1.1226072311,-0.9674966931,-0.7404826283),
LSP_CONST16(-1.7694386244,-1.6782246828,-1.5994637012,-1.5356057882,-1.4747079611,-1.4121016264,-1.3450953960,-1.2733950615,-1.1930381060,-1.0976517200,-0.9881871939,-0.8723944426,-0.7436917424,-0.5976818204,-0.4316863120,-0.1797702163),
LSP_CONST16(-1.4342834949,-1.3203835487,-1.2107408047,-1.1057798862,-1.0056174994,-0.9033592343,-0.8043748736,-0.7070966959,-0.6042739749,-0.4981404841,-0.3850953877,-0.2710680068,-0.1440741569,-0.0021991048,0.1672514081,0.3693608642),
LSP_CONST16(-0.9989568591,-0.8418816328,-0.7075374126,-0.5790659189,-0.4705556333,-0.3696696460,-0.2682664692,-0.1716338098,-0.0720839128,0.0306293573,1.4003738165,0.2512896955,0.3721393645,0.5107564926,0.6488751173,0.8030803204),
LSP_CONST16(-0.2651528120,-0.0631355122,0.0887208059,0.2110354751,0.3106967807,0.3968032300,0.4722347558,0.5416713357,0.6144474149,0.6894334555,0.7658020854,0.8517008424,0.9528906345,1.0651470423,1.2051070929,1.3761774302),
LSP_CONST16(0.5394030213,0.7377092838,0.8842487335,1.0111793280,1.1338908672,1.2683007717,1.4204199314,1.6203391552,1.1015881300,1.1651256084,1.2333712578,1.3041440248,1.3766331673,1.4685384035,1.5762579441,1.6689363718),
LSP_CONST16(0.3860199749,0.5600935221,0.6697848439,0.7602847219,0.8384606242,0.9086808562,0.9740887880,1.0369496346,0.0000000000,0.0000000000,0.0000000000,0.0000000000,0.0000000000,0.0000000000,0.0000000000,0.0000000000),
LSP_CONST16(1.5614498854,1.6594402790,1.7268968821,1.7785774469,1.8220300674,1.8622007370,1.9028397799,1.9482047558,0.0000000000,0.0000000000,0.0000000000,0.0000000000,0.0000000000,0.0000000000,0.0000000000,0.0000000000)
};							

#if (defined(PLATFORM_LPC_NO_TRIG_TABLE) || defined(PLATFORM_LPC_SMALL_TRIG_TABLE)) && defined(PLATFORM_LPC_FOLDED_PRUNED)

#if defined(PLATFORM_LPC_SMALL_TRIG_TABLE) || defined(_DEBUG)

#define BP2_CONST2(a,b) BP2_FROM_FLOAT(a),BP2_FROM_FLOAT(b)

// sin(pi*i/2048) and cos(pi*i/2048) used to derive the lpc constants

const BP2Type lpc_trig2048[] = {
    BP2_CONST2(0,1),    //0
    BP2_CONST2(0.00153398018628477,0.999998823451702),    //1
    BP2_CONST2(0.00306795676296598,0.999995293809576),    //2
    BP2_CONST2(0.00460192612044857,0.999989411081928),    //3
    BP2_CONST2(0.00613588464915448,0.999981175282601),    //4
    BP2_CONST2(0.0076698287395311,0.999970586430974),    //5
    BP2_CONST2(0.00920375478205982,0.999957644551964),    //6
    BP2_CONST2(0.0107376591672645,0.999942349676024),    //7
    BP2_CONST2(0.0122715382857199,0.999924701839145),    //8
    BP2_CONST2(0.0138053885280604,0.999904701082853),    //9
    BP2_CONST2(0.0153392062849881,0.999882347454213),    //10
    BP2_CONST2(0.0168729879472817,0.999857641005824),    //11
    BP2_CONST2(0.0184067299058048,0.999830581795823),    //12
    BP2_CONST2(0.0199404285515144,0.999801169887884),    //13
    BP2_CONST2(0.0214740802754695,0.999769405351215),    //14
    BP2_CONST2(0.0230076814688394,0.999735288260562),    //15
    BP2_CONST2(0.0245412285229123,0.999698818696204),    //16
    BP2_CONST2(0.0260747178291039,0.999659996743959),    //17
    BP2_CONST2(0.0276081457789657,0.999618822495179),    //18
    BP2_CONST2(0.0291415087641937,0.999575296046749),    //19
    BP2_CONST2(0.0306748031766366,0.999529417501093),    //20
    BP2_CONST2(0.0322080254083046,0.999481186966167),    //21
    BP2_CONST2(0.0337411718513776,0.999430604555462),    //22
    BP2_CONST2(0.0352742388982139,0.999377670388003),    //23
    BP2_CONST2(0.0368072229413588,0.99932238458835),    //24
    BP2_CONST2(0.0383401203735527,0.999264747286594),    //25
    BP2_CONST2(0.0398729275877398,0.999204758618364),    //26
    BP2_CONST2(0.0414056409770767,0.999142418724817),    //27
    BP2_CONST2(0.0429382569349408,0.999077727752645),    //28
    BP2_CONST2(0.0444707718549387,0.999010685854073),    //29
    BP2_CONST2(0.0460031821309146,0.998941293186857),    //30
    BP2_CONST2(0.0475354841569593,0.998869549914284),    //31
    BP2_CONST2(0.049067674327418,0.998795456205172),    //32
    BP2_CONST2(0.0505997490368993,0.998719012233873),    //33
    BP2_CONST2(0.0521317046802833,0.998640218180265),    //34
    BP2_CONST2(0.0536635376527305,0.998559074229759),    //35
    BP2_CONST2(0.0551952443496899,0.998475580573295),    //36
    BP2_CONST2(0.0567268211669077,0.99838973740734),    //37
    BP2_CONST2(0.0582582645004358,0.998301544933893),    //38
    BP2_CONST2(0.0597895707466399,0.998211003360478),    //39
    BP2_CONST2(0.0613207363022086,0.998118112900149),    //40
    BP2_CONST2(0.0628517575641614,0.998022873771486),    //41
    BP2_CONST2(0.0643826309298575,0.997925286198596),    //42
    BP2_CONST2(0.0659133527970038,0.997825350411112),    //43
    BP2_CONST2(0.0674439195636641,0.997723066644192),    //44
    BP2_CONST2(0.0689743276282667,0.99761843513852),    //45
    BP2_CONST2(0.0705045733896139,0.997511456140303),    //46
    BP2_CONST2(0.0720346532468893,0.997402129901275),    //47
    BP2_CONST2(0.0735645635996674,0.99729045667869),    //48
    BP2_CONST2(0.0750943008479213,0.997176436735326),    //49
    BP2_CONST2(0.0766238613920315,0.997060070339483),    //50
    BP2_CONST2(0.0781532416327942,0.996941357764982),    //51
    BP2_CONST2(0.0796824379714301,0.996820299291166),    //52
    BP2_CONST2(0.0812114468095924,0.996696895202896),    //53
    BP2_CONST2(0.0827402645493757,0.996571145790555),    //54
    BP2_CONST2(0.0842688875933241,0.996443051350043),    //55
    BP2_CONST2(0.0857973123444399,0.996312612182778),    //56
    BP2_CONST2(0.0873255352061921,0.996179828595697),    //57
    BP2_CONST2(0.0888535525825246,0.996044700901252),    //58
    BP2_CONST2(0.090381360877865,0.995907229417412),    //59
    BP2_CONST2(0.0919089564971327,0.99576741446766),    //60
    BP2_CONST2(0.0934363358457478,0.995625256380994),    //61
    BP2_CONST2(0.094963495329639,0.995480755491927),    //62
    BP2_CONST2(0.0964904313552526,0.995333912140482),    //63
    BP2_CONST2(0.0980171403295606,0.995184726672197),    //64
    BP2_CONST2(0.0995436186600693,0.995033199438119),    //65
    BP2_CONST2(0.101069862754828,0.994879330794806),    //66
    BP2_CONST2(0.102595869022436,0.994723121104326),    //67
    BP2_CONST2(0.104121633872055,0.994564570734255),    //68
    BP2_CONST2(0.105647153713411,0.994403680057679),    //69
    BP2_CONST2(0.107172424956809,0.994240449453188),    //70
    BP2_CONST2(0.108697444013139,0.994074879304879),    //71
    BP2_CONST2(0.110222207293883,0.993906970002356),    //72
    BP2_CONST2(0.111746711211127,0.993736721940725),    //73
    BP2_CONST2(0.113270952177564,0.993564135520595),    //74
    BP2_CONST2(0.11479492660651,0.993389211148081),    //75
    BP2_CONST2(0.116318630911905,0.993211949234794),    //76
    BP2_CONST2(0.117842061508325,0.993032350197851),    //77
    BP2_CONST2(0.119365214810991,0.992850414459865),    //78
    BP2_CONST2(0.120888087235777,0.992666142448948),    //79
    BP2_CONST2(0.122410675199216,0.99247953459871),    //80
    BP2_CONST2(0.123932975118512,0.992290591348257),    //81
    BP2_CONST2(0.125454983411546,0.992099313142192),    //82
    BP2_CONST2(0.126976696496886,0.991905700430609),    //83
    BP2_CONST2(0.128498110793793,0.9917097536691),    //84
    BP2_CONST2(0.130019222722233,0.991511473318744),    //85
    BP2_CONST2(0.131540028702883,0.991310859846115),    //86
    BP2_CONST2(0.133060525157139,0.991107913723277),    //87
    BP2_CONST2(0.134580708507126,0.99090263542778),    //88
    BP2_CONST2(0.136100575175706,0.990695025442665),    //89
    BP2_CONST2(0.137620121586486,0.990485084256457),    //90
    BP2_CONST2(0.139139344163826,0.990272812363169),    //91
    BP2_CONST2(0.140658239332849,0.990058210262297),    //92
    BP2_CONST2(0.142176803519448,0.989841278458821),    //93
    BP2_CONST2(0.143695033150294,0.989622017463201),    //94
    BP2_CONST2(0.145212924652847,0.98940042779138),    //95
    BP2_CONST2(0.146730474455362,0.989176509964781),    //96
    BP2_CONST2(0.148247678986896,0.988950264510303),    //97
    BP2_CONST2(0.149764534677322,0.988721691960324),    //98
    BP2_CONST2(0.15128103795733,0.988490792852697),    //99
    BP2_CONST2(0.152797185258443,0.988257567730749),    //100
    BP2_CONST2(0.15431297301302,0.988022017143284),    //101
    BP2_CONST2(0.155828397654265,0.987784141644572),    //102
    BP2_CONST2(0.157343455616238,0.987543941794359),    //103
    BP2_CONST2(0.158858143333861,0.987301418157858),    //104
    BP2_CONST2(0.160372457242928,0.987056571305751),    //105
    BP2_CONST2(0.161886393780112,0.986809401814186),    //106
    BP2_CONST2(0.163399949382973,0.986559910264775),    //107
    BP2_CONST2(0.16491312048997,0.986308097244599),    //108
    BP2_CONST2(0.166425903540464,0.986053963346195),    //109
    BP2_CONST2(0.167938294974731,0.985797509167567),    //110
    BP2_CONST2(0.169450291233968,0.985538735312176),    //111
    BP2_CONST2(0.170961888760301,0.985277642388941),    //112
    BP2_CONST2(0.172473083996796,0.98501423101224),    //113
    BP2_CONST2(0.173983873387464,0.984748501801904),    //114
    BP2_CONST2(0.175494253377271,0.984480455383221),    //115
    BP2_CONST2(0.177004220412149,0.984210092386929),    //116
    BP2_CONST2(0.178513770938998,0.983937413449219),    //117
    BP2_CONST2(0.1800229014057,0.98366241921173),    //118
    BP2_CONST2(0.181531608261125,0.983385110321551),    //119
    BP2_CONST2(0.183039887955141,0.983105487431216),    //120
    BP2_CONST2(0.18454773693862,0.982823551198705),    //121
    BP2_CONST2(0.186055151663447,0.982539302287441),    //122
    BP2_CONST2(0.18756212858253,0.982252741366289),    //123
    BP2_CONST2(0.189068664149806,0.981963869109555),    //124
    BP2_CONST2(0.190574754820253,0.981672686196983),    //125
    BP2_CONST2(0.192080397049892,0.981379193313755),    //126
    BP2_CONST2(0.193585587295804,0.981083391150487),    //127
    BP2_CONST2(0.195090322016128,0.98078528040323),    //128
    BP2_CONST2(0.19659459767008,0.980484861773469),    //129
    BP2_CONST2(0.198098410717954,0.980182135968117),    //130
    BP2_CONST2(0.199601757621131,0.979877103699518),    //131
    BP2_CONST2(0.201104634842092,0.979569765685441),    //132
    BP2_CONST2(0.202607038844421,0.979260122649082),    //133
    BP2_CONST2(0.204108966092817,0.978948175319062),    //134
    BP2_CONST2(0.205610413053099,0.978633924429423),    //135
    BP2_CONST2(0.207111376192219,0.978317370719628),    //136
    BP2_CONST2(0.208611851978263,0.977998514934557),    //137
    BP2_CONST2(0.21011183688047,0.97767735782451),    //138
    BP2_CONST2(0.211611327369228,0.9773539001452),    //139
    BP2_CONST2(0.213110319916091,0.977028142657754),    //140
    BP2_CONST2(0.214608810993787,0.976700086128712),    //141
    BP2_CONST2(0.21610679707622,0.976369731330021),    //142
    BP2_CONST2(0.217604274638484,0.976037079039039),    //143
    BP2_CONST2(0.21910124015687,0.975702130038529),    //144
    BP2_CONST2(0.220597690108874,0.975364885116657),    //145
    BP2_CONST2(0.222093620973204,0.975025345066994),    //146
    BP2_CONST2(0.22358902922979,0.974683510688511),    //147
    BP2_CONST2(0.225083911359793,0.974339382785576),    //148
    BP2_CONST2(0.22657826384561,0.973992962167956),    //149
    BP2_CONST2(0.228072083170886,0.973644249650812),    //150
    BP2_CONST2(0.229565365820519,0.973293246054698),    //151
    BP2_CONST2(0.231058108280671,0.97293995220556),    //152
    BP2_CONST2(0.232550307038775,0.972584368934732),    //153
    BP2_CONST2(0.234041958583543,0.972226497078936),    //154
    BP2_CONST2(0.235533059404975,0.971866337480279),    //155
    BP2_CONST2(0.237023605994367,0.971503890986252),    //156
    BP2_CONST2(0.238513594844318,0.971139158449725),    //157
    BP2_CONST2(0.240003022448741,0.97077214072895),    //158
    BP2_CONST2(0.241491885302869,0.970402838687556),    //159
    BP2_CONST2(0.242980179903264,0.970031253194544),    //160
    BP2_CONST2(0.244467902747824,0.969657385124292),    //161
    BP2_CONST2(0.245955050335795,0.969281235356549),    //162
    BP2_CONST2(0.247441619167773,0.968902804776429),    //163
    BP2_CONST2(0.24892760574572,0.968522094274417),    //164
    BP2_CONST2(0.250413006572965,0.968139104746362),    //165
    BP2_CONST2(0.251897818154217,0.967753837093476),    //166
    BP2_CONST2(0.25338203699557,0.967366292222329),    //167
    BP2_CONST2(0.254865659604515,0.966976471044852),    //168
    BP2_CONST2(0.256348682489943,0.966584374478333),    //169
    BP2_CONST2(0.257831102162159,0.966190003445413),    //170
    BP2_CONST2(0.259312915132886,0.965793358874084),    //171
    BP2_CONST2(0.260794117915276,0.965394441697689),    //172
    BP2_CONST2(0.262274707023914,0.96499325285492),    //173
    BP2_CONST2(0.263754678974831,0.964589793289813),    //174
    BP2_CONST2(0.265234030285512,0.964184063951746),    //175
    BP2_CONST2(0.266712757474898,0.96377606579544),    //176
    BP2_CONST2(0.268190857063403,0.963365799780954),    //177
    BP2_CONST2(0.269668325572915,0.962953266873684),    //178
    BP2_CONST2(0.271145159526808,0.962538468044359),    //179
    BP2_CONST2(0.272621355449949,0.962121404269042),    //180
    BP2_CONST2(0.274096909868706,0.961702076529123),    //181
    BP2_CONST2(0.275571819310958,0.961280485811321),    //182
    BP2_CONST2(0.2770460803061,0.96085663310768),    //183
    BP2_CONST2(0.278519689385053,0.960430519415566),    //184
    BP2_CONST2(0.279992643080273,0.960002145737666),    //185
    BP2_CONST2(0.281464937925758,0.959571513081985),    //186
    BP2_CONST2(0.282936570457055,0.959138622461842),    //187
    BP2_CONST2(0.284407537211272,0.958703474895872),    //188
    BP2_CONST2(0.285877834727081,0.958266071408018),    //189
    BP2_CONST2(0.28734745954473,0.957826413027533),    //190
    BP2_CONST2(0.288816408206049,0.957384500788976),    //191
    BP2_CONST2(0.290284677254462,0.956940335732209),    //192
    BP2_CONST2(0.291752263234989,0.956493918902395),    //193
    BP2_CONST2(0.293219162694259,0.956045251349996),    //194
    BP2_CONST2(0.294685372180514,0.955594334130771),    //195
    BP2_CONST2(0.296150888243624,0.955141168305771),    //196
    BP2_CONST2(0.297615707435086,0.954685754941338),    //197
    BP2_CONST2(0.29907982630804,0.954228095109106),    //198
    BP2_CONST2(0.300543241417273,0.95376818988599),    //199
    BP2_CONST2(0.302005949319228,0.953306040354194),    //200
    BP2_CONST2(0.303467946572011,0.952841647601199),    //201
    BP2_CONST2(0.304929229735402,0.952375012719766),    //202
    BP2_CONST2(0.306389795370861,0.951906136807932),    //203
    BP2_CONST2(0.307849640041535,0.951435020969008),    //204
    BP2_CONST2(0.309308760312269,0.950961666311575),    //205
    BP2_CONST2(0.310767152749611,0.950486073949482),    //206
    BP2_CONST2(0.312224813921825,0.950008245001843),    //207
    BP2_CONST2(0.313681740398892,0.949528180593037),    //208
    BP2_CONST2(0.315137928752522,0.949045881852701),    //209
    BP2_CONST2(0.316593375556166,0.94856134991573),    //210
    BP2_CONST2(0.318048077385015,0.948074585922276),    //211
    BP2_CONST2(0.319502030816016,0.947585591017741),    //212
    BP2_CONST2(0.320955232427875,0.947094366352777),    //213
    BP2_CONST2(0.32240767880107,0.946600913083284),    //214
    BP2_CONST2(0.323859366517853,0.946105232370403),    //215
    BP2_CONST2(0.325310292162263,0.945607325380521),    //216
    BP2_CONST2(0.326760452320132,0.945107193285261),    //217
    BP2_CONST2(0.328209843579092,0.94460483726148),    //218
    BP2_CONST2(0.329658462528587,0.944100258491273),    //219
    BP2_CONST2(0.331106305759876,0.94359345816196),    //220
    BP2_CONST2(0.332553369866044,0.943084437466093),    //221
    BP2_CONST2(0.333999651442009,0.942573197601447),    //222
    BP2_CONST2(0.335445147084532,0.942059739771017),    //223
    BP2_CONST2(0.33688985339222,0.941544065183021),    //224
    BP2_CONST2(0.338333766965541,0.941026175050889),    //225
    BP2_CONST2(0.339776884406827,0.940506070593268),    //226
    BP2_CONST2(0.341219202320282,0.939983753034014),    //227
    BP2_CONST2(0.342660717311994,0.93945922360219),    //228
    BP2_CONST2(0.344101425989939,0.938932483532065),    //229
    BP2_CONST2(0.345541324963989,0.938403534063108),    //230
    BP2_CONST2(0.346980410845924,0.93787237643999),    //231
    BP2_CONST2(0.348418680249435,0.937339011912575),    //232
    BP2_CONST2(0.349856129790135,0.936803441735922),    //233
    BP2_CONST2(0.351292756085567,0.936265667170278),    //234
    BP2_CONST2(0.352728555755211,0.93572568948108),    //235
    BP2_CONST2(0.35416352542049,0.935183509938948),    //236
    BP2_CONST2(0.355597661704784,0.934639129819681),    //237
    BP2_CONST2(0.35703096123343,0.934092550404259),    //238
    BP2_CONST2(0.358463420633737,0.933543772978836),    //239
    BP2_CONST2(0.359895036534988,0.932992798834739),    //240
    BP2_CONST2(0.361325805568454,0.932439629268462),    //241
    BP2_CONST2(0.362755724367397,0.931884265581668),    //242
    BP2_CONST2(0.36418478956708,0.93132670908118),    //243
    BP2_CONST2(0.365612997804774,0.930766961078984),    //244
    BP2_CONST2(0.367040345719767,0.930205022892219),    //245
    BP2_CONST2(0.368466829953372,0.929640895843181),    //246
    BP2_CONST2(0.369892447148934,0.929074581259316),    //247
    BP2_CONST2(0.371317193951838,0.928506080473216),    //248
    BP2_CONST2(0.372741067009516,0.927935394822618),    //249
    BP2_CONST2(0.374164062971458,0.927362525650401),    //250
    BP2_CONST2(0.375586178489217,0.926787474304582),    //251
    BP2_CONST2(0.377007410216418,0.926210242138311),    //252
    BP2_CONST2(0.378427754808766,0.925630830509873),    //253
    BP2_CONST2(0.379847208924051,0.925049240782678),    //254
    BP2_CONST2(0.381265769222162,0.924465474325263),    //255
    BP2_CONST2(0.38268343236509,0.923879532511287),    //256
    BP2_CONST2(0.384100195016935,0.923291416719528),    //257
    BP2_CONST2(0.385516053843919,0.922701128333879),    //258
    BP2_CONST2(0.386931005514389,0.922108668743345),    //259
    BP2_CONST2(0.388345046698826,0.921514039342042),    //260
    BP2_CONST2(0.389758174069856,0.92091724152919),    //261
    BP2_CONST2(0.391170384302254,0.920318276709111),    //262
    BP2_CONST2(0.392581674072951,0.919717146291227),    //263
    BP2_CONST2(0.393992040061048,0.919113851690058),    //264
    BP2_CONST2(0.395401478947816,0.918508394325212),    //265
    BP2_CONST2(0.39680998741671,0.91790077562139),    //266
    BP2_CONST2(0.398217562153374,0.917290997008378),    //267
    BP2_CONST2(0.399624199845647,0.916679059921043),    //268
    BP2_CONST2(0.401029897183576,0.916064965799332),    //269
    BP2_CONST2(0.402434650859418,0.915448716088268),    //270
    BP2_CONST2(0.403838457567654,0.914830312237946),    //271
    BP2_CONST2(0.40524131400499,0.914209755703531),    //272
    BP2_CONST2(0.406643216870369,0.913587047945251),    //273
    BP2_CONST2(0.408044162864979,0.912962190428398),    //274
    BP2_CONST2(0.409444148692258,0.912335184623323),    //275
    BP2_CONST2(0.410843171057904,0.91170603200543),    //276
    BP2_CONST2(0.412241226669883,0.911074734055176),    //277
    BP2_CONST2(0.413638312238435,0.910441292258067),    //278
    BP2_CONST2(0.415034424476082,0.909805708104652),    //279
    BP2_CONST2(0.416429560097637,0.909167983090522),    //280
    BP2_CONST2(0.417823715820212,0.908528118716306),    //281
    BP2_CONST2(0.419216888363224,0.907886116487666),    //282
    BP2_CONST2(0.420609074448403,0.907241977915296),    //283
    BP2_CONST2(0.4220002707998,0.906595704514915),    //284
    BP2_CONST2(0.423390474143796,0.905947297807268),    //285
    BP2_CONST2(0.424779681209109,0.905296759318119),    //286
    BP2_CONST2(0.4261678887268,0.904644090578246),    //287
    BP2_CONST2(0.427555093430282,0.903989293123443),    //288
    BP2_CONST2(0.428941292055329,0.903332368494512),    //289
    BP2_CONST2(0.430326481340083,0.902673318237259),    //290
    BP2_CONST2(0.431710658025057,0.902012143902493),    //291
    BP2_CONST2(0.433093818853152,0.901348847046022),    //292
    BP2_CONST2(0.434475960569656,0.900683429228647),    //293
    BP2_CONST2(0.435857079922255,0.90001589201616),    //294
    BP2_CONST2(0.437237173661044,0.899346236979342),    //295
    BP2_CONST2(0.438616238538528,0.898674465693954),    //296
    BP2_CONST2(0.439994271309633,0.89800057974074),    //297
    BP2_CONST2(0.441371268731717,0.897324580705418),    //298
    BP2_CONST2(0.44274722756457,0.89664647017868),    //299
    BP2_CONST2(0.444122144570429,0.895966249756185),    //300
    BP2_CONST2(0.445496016513982,0.895283921038558),    //301
    BP2_CONST2(0.446868840162374,0.894599485631383),    //302
    BP2_CONST2(0.44824061228522,0.893912945145203),    //303
    BP2_CONST2(0.449611329654607,0.893224301195515),    //304
    BP2_CONST2(0.450980989045104,0.892533555402765),    //305
    BP2_CONST2(0.452349587233771,0.891840709392343),    //306
    BP2_CONST2(0.453717121000164,0.891145764794583),    //307
    BP2_CONST2(0.455083587126344,0.890448723244758),    //308
    BP2_CONST2(0.456448982396884,0.889749586383073),    //309
    BP2_CONST2(0.457813303598877,0.889048355854665),    //310
    BP2_CONST2(0.459176547521944,0.888345033309596),    //311
    BP2_CONST2(0.46053871095824,0.887639620402854),    //312
    BP2_CONST2(0.461899790702463,0.886932118794342),    //313
    BP2_CONST2(0.46325978355186,0.886222530148881),    //314
    BP2_CONST2(0.464618686306238,0.8855108561362),    //315
    BP2_CONST2(0.465976495767966,0.884797098430938),    //316
    BP2_CONST2(0.467333208741988,0.884081258712635),    //317
    BP2_CONST2(0.468688822035828,0.883363338665732),    //318
    BP2_CONST2(0.470043332459596,0.882643339979563),    //319
    BP2_CONST2(0.471396736825998,0.881921264348355),    //320
    BP2_CONST2(0.472749031950343,0.881197113471222),    //321
    BP2_CONST2(0.47410021465055,0.880470889052161),    //322
    BP2_CONST2(0.475450281747156,0.879742592800047),    //323
    BP2_CONST2(0.476799230063322,0.879012226428634),    //324
    BP2_CONST2(0.478147056424843,0.878279791656542),    //325
    BP2_CONST2(0.479493757660153,0.877545290207261),    //326
    BP2_CONST2(0.480839330600334,0.876808723809146),    //327
    BP2_CONST2(0.482183772079123,0.876070094195407),    //328
    BP2_CONST2(0.483527078932919,0.875329403104111),    //329
    BP2_CONST2(0.484869248000791,0.874586652278176),    //330
    BP2_CONST2(0.486210276124486,0.873841843465367),    //331
    BP2_CONST2(0.487550160148436,0.87309497841829),    //332
    BP2_CONST2(0.488888896919763,0.872346058894392),    //333
    BP2_CONST2(0.490226483288291,0.871595086655951),    //334
    BP2_CONST2(0.49156291610655,0.870842063470079),    //335
    BP2_CONST2(0.492898192229784,0.870086991108711),    //336
    BP2_CONST2(0.49423230851596,0.869329871348607),    //337
    BP2_CONST2(0.495565261825773,0.868570705971341),    //338
    BP2_CONST2(0.496897049022654,0.867809496763303),    //339
    BP2_CONST2(0.498227666972782,0.867046245515693),    //340
    BP2_CONST2(0.499557112545082,0.866280954024513),    //341
    BP2_CONST2(0.500885382611241,0.865513624090569),    //342
    BP2_CONST2(0.502212474045711,0.864744257519462),    //343
    BP2_CONST2(0.503538383725718,0.863972856121587),    //344
    BP2_CONST2(0.504863108531268,0.863199421712124),    //345
    BP2_CONST2(0.506186645345155,0.862423956111041),    //346
    BP2_CONST2(0.507508991052971,0.861646461143081),    //347
    BP2_CONST2(0.508830142543107,0.860866938637767),    //348
    BP2_CONST2(0.510150096706767,0.86008539042939),    //349
    BP2_CONST2(0.51146885043797,0.859301818357008),    //350
    BP2_CONST2(0.512786400633563,0.858516224264443),    //351
    BP2_CONST2(0.514102744193222,0.857728610000272),    //352
    BP2_CONST2(0.515417878019463,0.856938977417829),    //353
    BP2_CONST2(0.51673179901765,0.856147328375194),    //354
    BP2_CONST2(0.518044504095999,0.855353664735196),    //355
    BP2_CONST2(0.51935599016559,0.854557988365401),    //356
    BP2_CONST2(0.520666254140367,0.853760301138111),    //357
    BP2_CONST2(0.521975292937154,0.852960604930364),    //358
    BP2_CONST2(0.523283103475656,0.85215890162392),    //359
    BP2_CONST2(0.524589682678469,0.851355193105265),    //360
    BP2_CONST2(0.525895027471085,0.850549481265603),    //361
    BP2_CONST2(0.527199134781901,0.849741768000853),    //362
    BP2_CONST2(0.528502001542228,0.84893205521164),    //363
    BP2_CONST2(0.529803624686295,0.848120344803297),    //364
    BP2_CONST2(0.531104001151255,0.847306638685858),    //365
    BP2_CONST2(0.532403127877198,0.846490938774052),    //366
    BP2_CONST2(0.533701001807153,0.845673246987299),    //367
    BP2_CONST2(0.534997619887097,0.844853565249707),    //368
    BP2_CONST2(0.536292979065963,0.844031895490066),    //369
    BP2_CONST2(0.537587076295645,0.843208239641845),    //370
    BP2_CONST2(0.538879908531008,0.842382599643186),    //371
    BP2_CONST2(0.540171472729893,0.841554977436898),    //372
    BP2_CONST2(0.541461765853123,0.840725374970458),    //373
    BP2_CONST2(0.542750784864516,0.839893794196),    //374
    BP2_CONST2(0.544038526730884,0.839060237070313),    //375
    BP2_CONST2(0.545324988422046,0.838224705554838),    //376
    BP2_CONST2(0.546610166910835,0.837387201615662),    //377
    BP2_CONST2(0.5478940591731,0.836547727223512),    //378
    BP2_CONST2(0.54917666218772,0.835706284353753),    //379
    BP2_CONST2(0.550457972936605,0.83486287498638),    //380
    BP2_CONST2(0.551737988404707,0.834017501106018),    //381
    BP2_CONST2(0.553016705580027,0.833170164701913),    //382
    BP2_CONST2(0.55429412145362,0.83232086776793),    //383
    BP2_CONST2(0.555570233019602,0.831469612302545),    //384
    BP2_CONST2(0.55684503727516,0.830616400308846),    //385
    BP2_CONST2(0.558118531220556,0.829761233794523),    //386
    BP2_CONST2(0.559390711859136,0.828904114771865),    //387
    BP2_CONST2(0.560661576197336,0.828045045257756),    //388
    BP2_CONST2(0.561931121244689,0.827184027273669),    //389
    BP2_CONST2(0.563199344013834,0.826321062845664),    //390
    BP2_CONST2(0.564466241520519,0.825456154004378),    //391
    BP2_CONST2(0.565731810783613,0.824589302785025),    //392
    BP2_CONST2(0.566996048825109,0.823720511227391),    //393
    BP2_CONST2(0.568258952670131,0.822849781375826),    //394
    BP2_CONST2(0.569520519346947,0.821977115279242),    //395
    BP2_CONST2(0.570780745886967,0.821102514991105),    //396
    BP2_CONST2(0.572039629324757,0.820225982569435),    //397
    BP2_CONST2(0.573297166698042,0.819347520076797),    //398
    BP2_CONST2(0.574553355047716,0.818467129580299),    //399
    BP2_CONST2(0.575808191417845,0.817584813151584),    //400
    BP2_CONST2(0.577061672855679,0.816700572866828),    //401
    BP2_CONST2(0.578313796411656,0.815814410806734),    //402
    BP2_CONST2(0.579564559139406,0.814926329056527),    //403
    BP2_CONST2(0.580813958095765,0.814036329705948),    //404
    BP2_CONST2(0.582061990340775,0.813144414849254),    //405
    BP2_CONST2(0.583308652937698,0.812250586585204),    //406
    BP2_CONST2(0.584553942953015,0.811354847017064),    //407
    BP2_CONST2(0.585797857456439,0.810457198252595),    //408
    BP2_CONST2(0.587040393520918,0.809557642404051),    //409
    BP2_CONST2(0.588281548222645,0.808656181588175),    //410
    BP2_CONST2(0.589521318641064,0.80775281792619),    //411
    BP2_CONST2(0.590759701858874,0.806847553543799),    //412
    BP2_CONST2(0.591996694962041,0.805940390571176),    //413
    BP2_CONST2(0.5932322950398,0.805031331142964),    //414
    BP2_CONST2(0.594466499184664,0.804120377398266),    //415
    BP2_CONST2(0.595699304492433,0.803207531480645),    //416
    BP2_CONST2(0.596930708062197,0.802292795538116),    //417
    BP2_CONST2(0.598160706996342,0.80137617172314),    //418
    BP2_CONST2(0.599389298400565,0.800457662192623),    //419
    BP2_CONST2(0.600616479383869,0.799537269107905),    //420
    BP2_CONST2(0.60184224705858,0.798614994634761),    //421
    BP2_CONST2(0.603066598540348,0.797690840943391),    //422
    BP2_CONST2(0.604289530948156,0.796764810208419),    //423
    BP2_CONST2(0.605511041404326,0.795836904608884),    //424
    BP2_CONST2(0.606731127034524,0.794907126328237),    //425
    BP2_CONST2(0.607949784967774,0.793975477554337),    //426
    BP2_CONST2(0.609167012336453,0.793041960479444),    //427
    BP2_CONST2(0.610382806276309,0.792106577300212),    //428
    BP2_CONST2(0.611597163926462,0.79116933021769),    //429
    BP2_CONST2(0.61281008242941,0.79023022143731),    //430
    BP2_CONST2(0.614021558931038,0.789289253168886),    //431
    BP2_CONST2(0.615231590580627,0.788346427626606),    //432
    BP2_CONST2(0.616440174530854,0.787401747029031),    //433
    BP2_CONST2(0.617647307937804,0.786455213599086),    //434
    BP2_CONST2(0.618852987960976,0.785506829564054),    //435
    BP2_CONST2(0.620057211763289,0.784556597155575),    //436
    BP2_CONST2(0.621259976511088,0.783604518609638),    //437
    BP2_CONST2(0.62246127937415,0.782650596166576),    //438
    BP2_CONST2(0.623661117525695,0.781694832071059),    //439
    BP2_CONST2(0.624859488142386,0.780737228572094),    //440
    BP2_CONST2(0.626056388404344,0.779777787923015),    //441
    BP2_CONST2(0.627251815495144,0.778816512381476),    //442
    BP2_CONST2(0.628445766601833,0.777853404209453),    //443
    BP2_CONST2(0.629638238914927,0.776888465673232),    //444
    BP2_CONST2(0.630829229628424,0.775921699043408),    //445
    BP2_CONST2(0.632018735939809,0.774953106594874),    //446
    BP2_CONST2(0.633206755050057,0.773982690606823),    //447
    BP2_CONST2(0.634393284163645,0.773010453362737),    //448
    BP2_CONST2(0.635578320488556,0.772036397150385),    //449
    BP2_CONST2(0.636761861236284,0.771060524261814),    //450
    BP2_CONST2(0.637943903621844,0.770082836993348),    //451
    BP2_CONST2(0.639124444863776,0.76910333764558),    //452
    BP2_CONST2(0.640303482184152,0.768122028523365),    //453
    BP2_CONST2(0.641481012808583,0.76713891193582),    //454
    BP2_CONST2(0.642657033966227,0.766153990196313),    //455
    BP2_CONST2(0.643831542889791,0.765167265622459),    //456
    BP2_CONST2(0.645004536815544,0.764178740536117),    //457
    BP2_CONST2(0.646176012983316,0.763188417263381),    //458
    BP2_CONST2(0.647345968636512,0.762196298134579),    //459
    BP2_CONST2(0.648514401022112,0.761202385484262),    //460
    BP2_CONST2(0.649681307390683,0.760206681651202),    //461
    BP2_CONST2(0.650846684996381,0.759209188978388),    //462
    BP2_CONST2(0.65201053109696,0.758209909813015),    //463
    BP2_CONST2(0.653172842953777,0.757208846506485),    //464
    BP2_CONST2(0.6543336178318,0.756206001414395),    //465
    BP2_CONST2(0.655492852999615,0.755201376896537),    //466
    BP2_CONST2(0.656650545729429,0.754194975316889),    //467
    BP2_CONST2(0.657806693297079,0.753186799043613),    //468
    BP2_CONST2(0.658961292982037,0.752176850449043),    //469
    BP2_CONST2(0.66011434206742,0.751165131909686),    //470
    BP2_CONST2(0.661265837839992,0.750151645806215),    //471
    BP2_CONST2(0.662415777590172,0.749136394523459),    //472
    BP2_CONST2(0.66356415861204,0.748119380450404),    //473
    BP2_CONST2(0.664710978203345,0.74710060598018),    //474
    BP2_CONST2(0.66585623366551,0.746080073510064),    //475
    BP2_CONST2(0.666999922303637,0.745057785441466),    //476
    BP2_CONST2(0.668142041426518,0.744033744179929),    //477
    BP2_CONST2(0.669282588346636,0.743007952135122),    //478
    BP2_CONST2(0.670421560380173,0.741980411720831),    //479
    BP2_CONST2(0.671558954847018,0.740951125354959),    //480
    BP2_CONST2(0.672694769070773,0.739920095459516),    //481
    BP2_CONST2(0.673829000378756,0.738887324460615),    //482
    BP2_CONST2(0.674961646102012,0.737852814788466),    //483
    BP2_CONST2(0.676092703575316,0.73681656887737),    //484
    BP2_CONST2(0.67722217013718,0.735778589165714),    //485
    BP2_CONST2(0.678350043129861,0.734738878095963),    //486
    BP2_CONST2(0.679476319899365,0.73369743811466),    //487
    BP2_CONST2(0.680600997795453,0.732654271672413),    //488
    BP2_CONST2(0.68172407417165,0.731609381223893),    //489
    BP2_CONST2(0.682845546385248,0.730562769227828),    //490
    BP2_CONST2(0.683965411797315,0.729514438146997),    //491
    BP2_CONST2(0.6850836677727,0.728464390448225),    //492
    BP2_CONST2(0.686200311680039,0.727412628602376),    //493
    BP2_CONST2(0.687315340891759,0.726359155084346),    //494
    BP2_CONST2(0.68842875278409,0.725303972373061),    //495
    BP2_CONST2(0.689540544737067,0.724247082951467),    //496
    BP2_CONST2(0.690650714134535,0.723188489306527),    //497
    BP2_CONST2(0.691759258364158,0.722128193929215),    //498
    BP2_CONST2(0.692866174817425,0.721066199314508),    //499
    BP2_CONST2(0.693971460889654,0.720002507961382),    //500
    BP2_CONST2(0.695075113980001,0.718937122372804),    //501
    BP2_CONST2(0.696177131491463,0.717870045055732),    //502
    BP2_CONST2(0.697277510830887,0.7168012785211),    //503
    BP2_CONST2(0.698376249408973,0.715730825283819),    //504
    BP2_CONST2(0.699473344640284,0.714658687862769),    //505
    BP2_CONST2(0.700568793943248,0.713584868780794),    //506
    BP2_CONST2(0.701662594740168,0.712509370564692),    //507
    BP2_CONST2(0.702754744457225,0.711432195745216),    //508
    BP2_CONST2(0.703845240524485,0.710353346857062),    //509
    BP2_CONST2(0.704934080375905,0.709272826438866),    //510
    BP2_CONST2(0.70602126144934,0.708190637033195),    //511
    BP2_CONST2(0.707106781186547,0.707106781186548)    //512
};

#if 1

#define TRIGTBL(i,j) lpc_trig2048[((i)<<(iShrink+1))+(j)]

#else
// When I tried to use separate tables to pulling unnecessary stuff into the cache 
// on smaller transforms, it had no effect on performancer

#define TRIGTBL(i,j) lpc_Trigs[iShrink][((i)<<1)+(j)]

const BP2Type lpc_trig1024[] = {
    BP2_CONST2(0,1),    //0
    BP2_CONST2(0.00306795676296598,0.999995293809576),    //1
    BP2_CONST2(0.00613588464915448,0.999981175282601),    //2
    BP2_CONST2(0.00920375478205982,0.999957644551964),    //3
    BP2_CONST2(0.0122715382857199,0.999924701839145),    //4
    BP2_CONST2(0.0153392062849881,0.999882347454213),    //5
    BP2_CONST2(0.0184067299058048,0.999830581795823),    //6
    BP2_CONST2(0.0214740802754695,0.999769405351215),    //7
    BP2_CONST2(0.0245412285229123,0.999698818696204),    //8
    BP2_CONST2(0.0276081457789657,0.999618822495179),    //9
    BP2_CONST2(0.0306748031766366,0.999529417501093),    //10
    BP2_CONST2(0.0337411718513776,0.999430604555462),    //11
    BP2_CONST2(0.0368072229413588,0.99932238458835),    //12
    BP2_CONST2(0.0398729275877398,0.999204758618364),    //13
    BP2_CONST2(0.0429382569349408,0.999077727752645),    //14
    BP2_CONST2(0.0460031821309146,0.998941293186857),    //15
    BP2_CONST2(0.049067674327418,0.998795456205172),    //16
    BP2_CONST2(0.0521317046802833,0.998640218180265),    //17
    BP2_CONST2(0.0551952443496899,0.998475580573295),    //18
    BP2_CONST2(0.0582582645004358,0.998301544933893),    //19
    BP2_CONST2(0.0613207363022086,0.998118112900149),    //20
    BP2_CONST2(0.0643826309298575,0.997925286198596),    //21
    BP2_CONST2(0.0674439195636641,0.997723066644192),    //22
    BP2_CONST2(0.0705045733896139,0.997511456140303),    //23
    BP2_CONST2(0.0735645635996674,0.99729045667869),    //24
    BP2_CONST2(0.0766238613920315,0.997060070339483),    //25
    BP2_CONST2(0.0796824379714301,0.996820299291166),    //26
    BP2_CONST2(0.0827402645493757,0.996571145790555),    //27
    BP2_CONST2(0.0857973123444399,0.996312612182778),    //28
    BP2_CONST2(0.0888535525825246,0.996044700901252),    //29
    BP2_CONST2(0.0919089564971327,0.99576741446766),    //30
    BP2_CONST2(0.094963495329639,0.995480755491927),    //31
    BP2_CONST2(0.0980171403295606,0.995184726672197),    //32
    BP2_CONST2(0.101069862754828,0.994879330794806),    //33
    BP2_CONST2(0.104121633872055,0.994564570734255),    //34
    BP2_CONST2(0.107172424956809,0.994240449453188),    //35
    BP2_CONST2(0.110222207293883,0.993906970002356),    //36
    BP2_CONST2(0.113270952177564,0.993564135520595),    //37
    BP2_CONST2(0.116318630911905,0.993211949234794),    //38
    BP2_CONST2(0.119365214810991,0.992850414459865),    //39
    BP2_CONST2(0.122410675199216,0.99247953459871),    //40
    BP2_CONST2(0.125454983411546,0.992099313142192),    //41
    BP2_CONST2(0.128498110793793,0.9917097536691),    //42
    BP2_CONST2(0.131540028702883,0.991310859846115),    //43
    BP2_CONST2(0.134580708507126,0.99090263542778),    //44
    BP2_CONST2(0.137620121586486,0.990485084256457),    //45
    BP2_CONST2(0.140658239332849,0.990058210262297),    //46
    BP2_CONST2(0.143695033150294,0.989622017463201),    //47
    BP2_CONST2(0.146730474455362,0.989176509964781),    //48
    BP2_CONST2(0.149764534677322,0.988721691960324),    //49
    BP2_CONST2(0.152797185258443,0.988257567730749),    //50
    BP2_CONST2(0.155828397654265,0.987784141644572),    //51
    BP2_CONST2(0.158858143333861,0.987301418157858),    //52
    BP2_CONST2(0.161886393780112,0.986809401814186),    //53
    BP2_CONST2(0.16491312048997,0.986308097244599),    //54
    BP2_CONST2(0.167938294974731,0.985797509167567),    //55
    BP2_CONST2(0.170961888760301,0.985277642388941),    //56
    BP2_CONST2(0.173983873387464,0.984748501801904),    //57
    BP2_CONST2(0.177004220412149,0.984210092386929),    //58
    BP2_CONST2(0.1800229014057,0.98366241921173),    //59
    BP2_CONST2(0.183039887955141,0.983105487431216),    //60
    BP2_CONST2(0.186055151663447,0.982539302287441),    //61
    BP2_CONST2(0.189068664149806,0.981963869109555),    //62
    BP2_CONST2(0.192080397049892,0.981379193313755),    //63
    BP2_CONST2(0.195090322016128,0.98078528040323),    //64
    BP2_CONST2(0.198098410717954,0.980182135968117),    //65
    BP2_CONST2(0.201104634842092,0.979569765685441),    //66
    BP2_CONST2(0.204108966092817,0.978948175319062),    //67
    BP2_CONST2(0.207111376192219,0.978317370719628),    //68
    BP2_CONST2(0.21011183688047,0.97767735782451),    //69
    BP2_CONST2(0.213110319916091,0.977028142657754),    //70
    BP2_CONST2(0.21610679707622,0.976369731330021),    //71
    BP2_CONST2(0.21910124015687,0.975702130038529),    //72
    BP2_CONST2(0.222093620973204,0.975025345066994),    //73
    BP2_CONST2(0.225083911359793,0.974339382785576),    //74
    BP2_CONST2(0.228072083170886,0.973644249650812),    //75
    BP2_CONST2(0.231058108280671,0.97293995220556),    //76
    BP2_CONST2(0.234041958583543,0.972226497078936),    //77
    BP2_CONST2(0.237023605994367,0.971503890986252),    //78
    BP2_CONST2(0.240003022448741,0.97077214072895),    //79
    BP2_CONST2(0.242980179903264,0.970031253194544),    //80
    BP2_CONST2(0.245955050335795,0.969281235356549),    //81
    BP2_CONST2(0.24892760574572,0.968522094274417),    //82
    BP2_CONST2(0.251897818154217,0.967753837093476),    //83
    BP2_CONST2(0.254865659604515,0.966976471044852),    //84
    BP2_CONST2(0.257831102162159,0.966190003445413),    //85
    BP2_CONST2(0.260794117915276,0.965394441697689),    //86
    BP2_CONST2(0.263754678974831,0.964589793289813),    //87
    BP2_CONST2(0.266712757474898,0.96377606579544),    //88
    BP2_CONST2(0.269668325572915,0.962953266873684),    //89
    BP2_CONST2(0.272621355449949,0.962121404269042),    //90
    BP2_CONST2(0.275571819310958,0.961280485811321),    //91
    BP2_CONST2(0.278519689385053,0.960430519415566),    //92
    BP2_CONST2(0.281464937925758,0.959571513081985),    //93
    BP2_CONST2(0.284407537211272,0.958703474895872),    //94
    BP2_CONST2(0.28734745954473,0.957826413027533),    //95
    BP2_CONST2(0.290284677254462,0.956940335732209),    //96
    BP2_CONST2(0.293219162694259,0.956045251349996),    //97
    BP2_CONST2(0.296150888243624,0.955141168305771),    //98
    BP2_CONST2(0.29907982630804,0.954228095109106),    //99
    BP2_CONST2(0.302005949319228,0.953306040354194),    //100
    BP2_CONST2(0.304929229735402,0.952375012719766),    //101
    BP2_CONST2(0.307849640041535,0.951435020969008),    //102
    BP2_CONST2(0.310767152749611,0.950486073949482),    //103
    BP2_CONST2(0.313681740398892,0.949528180593037),    //104
    BP2_CONST2(0.316593375556166,0.94856134991573),    //105
    BP2_CONST2(0.319502030816016,0.947585591017741),    //106
    BP2_CONST2(0.32240767880107,0.946600913083284),    //107
    BP2_CONST2(0.325310292162263,0.945607325380521),    //108
    BP2_CONST2(0.328209843579092,0.94460483726148),    //109
    BP2_CONST2(0.331106305759876,0.94359345816196),    //110
    BP2_CONST2(0.333999651442009,0.942573197601447),    //111
    BP2_CONST2(0.33688985339222,0.941544065183021),    //112
    BP2_CONST2(0.339776884406827,0.940506070593268),    //113
    BP2_CONST2(0.342660717311994,0.93945922360219),    //114
    BP2_CONST2(0.345541324963989,0.938403534063108),    //115
    BP2_CONST2(0.348418680249435,0.937339011912575),    //116
    BP2_CONST2(0.351292756085567,0.936265667170278),    //117
    BP2_CONST2(0.35416352542049,0.935183509938948),    //118
    BP2_CONST2(0.35703096123343,0.934092550404259),    //119
    BP2_CONST2(0.359895036534988,0.932992798834739),    //120
    BP2_CONST2(0.362755724367397,0.931884265581668),    //121
    BP2_CONST2(0.365612997804774,0.930766961078984),    //122
    BP2_CONST2(0.368466829953372,0.929640895843181),    //123
    BP2_CONST2(0.371317193951838,0.928506080473216),    //124
    BP2_CONST2(0.374164062971458,0.927362525650401),    //125
    BP2_CONST2(0.377007410216418,0.926210242138311),    //126
    BP2_CONST2(0.379847208924051,0.925049240782678),    //127
    BP2_CONST2(0.38268343236509,0.923879532511287),    //128
    BP2_CONST2(0.385516053843919,0.922701128333879),    //129
    BP2_CONST2(0.388345046698826,0.921514039342042),    //130
    BP2_CONST2(0.391170384302254,0.920318276709111),    //131
    BP2_CONST2(0.393992040061048,0.919113851690058),    //132
    BP2_CONST2(0.39680998741671,0.91790077562139),    //133
    BP2_CONST2(0.399624199845647,0.916679059921043),    //134
    BP2_CONST2(0.402434650859418,0.915448716088268),    //135
    BP2_CONST2(0.40524131400499,0.914209755703531),    //136
    BP2_CONST2(0.408044162864979,0.912962190428398),    //137
    BP2_CONST2(0.410843171057904,0.91170603200543),    //138
    BP2_CONST2(0.413638312238435,0.910441292258067),    //139
    BP2_CONST2(0.416429560097637,0.909167983090522),    //140
    BP2_CONST2(0.419216888363224,0.907886116487666),    //141
    BP2_CONST2(0.4220002707998,0.906595704514915),    //142
    BP2_CONST2(0.424779681209109,0.905296759318119),    //143
    BP2_CONST2(0.427555093430282,0.903989293123443),    //144
    BP2_CONST2(0.430326481340083,0.902673318237259),    //145
    BP2_CONST2(0.433093818853152,0.901348847046022),    //146
    BP2_CONST2(0.435857079922255,0.90001589201616),    //147
    BP2_CONST2(0.438616238538528,0.898674465693954),    //148
    BP2_CONST2(0.441371268731717,0.897324580705418),    //149
    BP2_CONST2(0.444122144570429,0.895966249756185),    //150
    BP2_CONST2(0.446868840162374,0.894599485631383),    //151
    BP2_CONST2(0.449611329654607,0.893224301195515),    //152
    BP2_CONST2(0.452349587233771,0.891840709392343),    //153
    BP2_CONST2(0.455083587126344,0.890448723244758),    //154
    BP2_CONST2(0.457813303598877,0.889048355854665),    //155
    BP2_CONST2(0.46053871095824,0.887639620402854),    //156
    BP2_CONST2(0.46325978355186,0.886222530148881),    //157
    BP2_CONST2(0.465976495767966,0.884797098430938),    //158
    BP2_CONST2(0.468688822035828,0.883363338665732),    //159
    BP2_CONST2(0.471396736825998,0.881921264348355),    //160
    BP2_CONST2(0.47410021465055,0.880470889052161),    //161
    BP2_CONST2(0.476799230063322,0.879012226428634),    //162
    BP2_CONST2(0.479493757660153,0.877545290207261),    //163
    BP2_CONST2(0.482183772079123,0.876070094195407),    //164
    BP2_CONST2(0.484869248000791,0.874586652278176),    //165
    BP2_CONST2(0.487550160148436,0.87309497841829),    //166
    BP2_CONST2(0.490226483288291,0.871595086655951),    //167
    BP2_CONST2(0.492898192229784,0.870086991108711),    //168
    BP2_CONST2(0.495565261825773,0.868570705971341),    //169
    BP2_CONST2(0.498227666972782,0.867046245515693),    //170
    BP2_CONST2(0.500885382611241,0.865513624090569),    //171
    BP2_CONST2(0.503538383725718,0.863972856121587),    //172
    BP2_CONST2(0.506186645345155,0.862423956111041),    //173
    BP2_CONST2(0.508830142543107,0.860866938637767),    //174
    BP2_CONST2(0.51146885043797,0.859301818357008),    //175
    BP2_CONST2(0.514102744193222,0.857728610000272),    //176
    BP2_CONST2(0.51673179901765,0.856147328375194),    //177
    BP2_CONST2(0.51935599016559,0.854557988365401),    //178
    BP2_CONST2(0.521975292937154,0.852960604930364),    //179
    BP2_CONST2(0.524589682678469,0.851355193105265),    //180
    BP2_CONST2(0.527199134781901,0.849741768000853),    //181
    BP2_CONST2(0.529803624686295,0.848120344803297),    //182
    BP2_CONST2(0.532403127877198,0.846490938774052),    //183
    BP2_CONST2(0.534997619887097,0.844853565249707),    //184
    BP2_CONST2(0.537587076295645,0.843208239641845),    //185
    BP2_CONST2(0.540171472729893,0.841554977436898),    //186
    BP2_CONST2(0.542750784864516,0.839893794196),    //187
    BP2_CONST2(0.545324988422046,0.838224705554838),    //188
    BP2_CONST2(0.5478940591731,0.836547727223512),    //189
    BP2_CONST2(0.550457972936605,0.83486287498638),    //190
    BP2_CONST2(0.553016705580027,0.833170164701913),    //191
    BP2_CONST2(0.555570233019602,0.831469612302545),    //192
    BP2_CONST2(0.558118531220556,0.829761233794523),    //193
    BP2_CONST2(0.560661576197336,0.828045045257756),    //194
    BP2_CONST2(0.563199344013834,0.826321062845664),    //195
    BP2_CONST2(0.565731810783613,0.824589302785025),    //196
    BP2_CONST2(0.568258952670131,0.822849781375826),    //197
    BP2_CONST2(0.570780745886967,0.821102514991105),    //198
    BP2_CONST2(0.573297166698042,0.819347520076797),    //199
    BP2_CONST2(0.575808191417845,0.817584813151584),    //200
    BP2_CONST2(0.578313796411656,0.815814410806734),    //201
    BP2_CONST2(0.580813958095765,0.814036329705948),    //202
    BP2_CONST2(0.583308652937698,0.812250586585204),    //203
    BP2_CONST2(0.585797857456439,0.810457198252595),    //204
    BP2_CONST2(0.588281548222645,0.808656181588175),    //205
    BP2_CONST2(0.590759701858874,0.806847553543799),    //206
    BP2_CONST2(0.5932322950398,0.805031331142964),    //207
    BP2_CONST2(0.595699304492433,0.803207531480645),    //208
    BP2_CONST2(0.598160706996342,0.80137617172314),    //209
    BP2_CONST2(0.600616479383869,0.799537269107905),    //210
    BP2_CONST2(0.603066598540348,0.797690840943391),    //211
    BP2_CONST2(0.605511041404326,0.795836904608884),    //212
    BP2_CONST2(0.607949784967774,0.793975477554337),    //213
    BP2_CONST2(0.610382806276309,0.792106577300212),    //214
    BP2_CONST2(0.61281008242941,0.79023022143731),    //215
    BP2_CONST2(0.615231590580627,0.788346427626606),    //216
    BP2_CONST2(0.617647307937804,0.786455213599086),    //217
    BP2_CONST2(0.620057211763289,0.784556597155575),    //218
    BP2_CONST2(0.62246127937415,0.782650596166576),    //219
    BP2_CONST2(0.624859488142386,0.780737228572094),    //220
    BP2_CONST2(0.627251815495144,0.778816512381476),    //221
    BP2_CONST2(0.629638238914927,0.776888465673232),    //222
    BP2_CONST2(0.632018735939809,0.774953106594874),    //223
    BP2_CONST2(0.634393284163645,0.773010453362737),    //224
    BP2_CONST2(0.636761861236284,0.771060524261814),    //225
    BP2_CONST2(0.639124444863776,0.76910333764558),    //226
    BP2_CONST2(0.641481012808583,0.76713891193582),    //227
    BP2_CONST2(0.643831542889791,0.765167265622459),    //228
    BP2_CONST2(0.646176012983316,0.763188417263381),    //229
    BP2_CONST2(0.648514401022112,0.761202385484262),    //230
    BP2_CONST2(0.650846684996381,0.759209188978388),    //231
    BP2_CONST2(0.653172842953777,0.757208846506485),    //232
    BP2_CONST2(0.655492852999615,0.755201376896537),    //233
    BP2_CONST2(0.657806693297079,0.753186799043613),    //234
    BP2_CONST2(0.66011434206742,0.751165131909686),    //235
    BP2_CONST2(0.662415777590172,0.749136394523459),    //236
    BP2_CONST2(0.664710978203345,0.74710060598018),    //237
    BP2_CONST2(0.666999922303637,0.745057785441466),    //238
    BP2_CONST2(0.669282588346636,0.743007952135122),    //239
    BP2_CONST2(0.671558954847018,0.740951125354959),    //240
    BP2_CONST2(0.673829000378756,0.738887324460615),    //241
    BP2_CONST2(0.676092703575316,0.73681656887737),    //242
    BP2_CONST2(0.678350043129861,0.734738878095963),    //243
    BP2_CONST2(0.680600997795453,0.732654271672413),    //244
    BP2_CONST2(0.682845546385248,0.730562769227828),    //245
    BP2_CONST2(0.6850836677727,0.728464390448225),    //246
    BP2_CONST2(0.687315340891759,0.726359155084346),    //247
    BP2_CONST2(0.689540544737067,0.724247082951467),    //248
    BP2_CONST2(0.691759258364158,0.722128193929215),    //249
    BP2_CONST2(0.693971460889654,0.720002507961382),    //250
    BP2_CONST2(0.696177131491463,0.717870045055732),    //251
    BP2_CONST2(0.698376249408973,0.715730825283819),    //252
    BP2_CONST2(0.700568793943248,0.713584868780794),    //253
    BP2_CONST2(0.702754744457225,0.711432195745216),    //254
    BP2_CONST2(0.704934080375905,0.709272826438866),    //255
    BP2_CONST2(0.707106781186547,0.707106781186548)     //256
};

const BP2Type lpc_trig512[] = {
    BP2_CONST2(0,1),    //0
    BP2_CONST2(0.00613588464915448,0.999981175282601),    //1
    BP2_CONST2(0.0122715382857199,0.999924701839145),    //2
    BP2_CONST2(0.0184067299058048,0.999830581795823),    //3
    BP2_CONST2(0.0245412285229123,0.999698818696204),    //4
    BP2_CONST2(0.0306748031766366,0.999529417501093),    //5
    BP2_CONST2(0.0368072229413588,0.99932238458835),    //6
    BP2_CONST2(0.0429382569349408,0.999077727752645),    //7
    BP2_CONST2(0.049067674327418,0.998795456205172),    //8
    BP2_CONST2(0.0551952443496899,0.998475580573295),    //9
    BP2_CONST2(0.0613207363022086,0.998118112900149),    //10
    BP2_CONST2(0.0674439195636641,0.997723066644192),    //11
    BP2_CONST2(0.0735645635996674,0.99729045667869),    //12
    BP2_CONST2(0.0796824379714301,0.996820299291166),    //13
    BP2_CONST2(0.0857973123444399,0.996312612182778),    //14
    BP2_CONST2(0.0919089564971327,0.99576741446766),    //15
    BP2_CONST2(0.0980171403295606,0.995184726672197),    //16
    BP2_CONST2(0.104121633872055,0.994564570734255),    //17
    BP2_CONST2(0.110222207293883,0.993906970002356),    //18
    BP2_CONST2(0.116318630911905,0.993211949234794),    //19
    BP2_CONST2(0.122410675199216,0.99247953459871),    //20
    BP2_CONST2(0.128498110793793,0.9917097536691),    //21
    BP2_CONST2(0.134580708507126,0.99090263542778),    //22
    BP2_CONST2(0.140658239332849,0.990058210262297),    //23
    BP2_CONST2(0.146730474455362,0.989176509964781),    //24
    BP2_CONST2(0.152797185258443,0.988257567730749),    //25
    BP2_CONST2(0.158858143333861,0.987301418157858),    //26
    BP2_CONST2(0.16491312048997,0.986308097244599),    //27
    BP2_CONST2(0.170961888760301,0.985277642388941),    //28
    BP2_CONST2(0.177004220412149,0.984210092386929),    //29
    BP2_CONST2(0.183039887955141,0.983105487431216),    //30
    BP2_CONST2(0.189068664149806,0.981963869109555),    //31
    BP2_CONST2(0.195090322016128,0.98078528040323),    //32
    BP2_CONST2(0.201104634842092,0.979569765685441),    //33
    BP2_CONST2(0.207111376192219,0.978317370719628),    //34
    BP2_CONST2(0.213110319916091,0.977028142657754),    //35
    BP2_CONST2(0.21910124015687,0.975702130038529),    //36
    BP2_CONST2(0.225083911359793,0.974339382785576),    //37
    BP2_CONST2(0.231058108280671,0.97293995220556),    //38
    BP2_CONST2(0.237023605994367,0.971503890986252),    //39
    BP2_CONST2(0.242980179903264,0.970031253194544),    //40
    BP2_CONST2(0.24892760574572,0.968522094274417),    //41
    BP2_CONST2(0.254865659604515,0.966976471044852),    //42
    BP2_CONST2(0.260794117915276,0.965394441697689),    //43
    BP2_CONST2(0.266712757474898,0.96377606579544),    //44
    BP2_CONST2(0.272621355449949,0.962121404269042),    //45
    BP2_CONST2(0.278519689385053,0.960430519415566),    //46
    BP2_CONST2(0.284407537211272,0.958703474895872),    //47
    BP2_CONST2(0.290284677254462,0.956940335732209),    //48
    BP2_CONST2(0.296150888243624,0.955141168305771),    //49
    BP2_CONST2(0.302005949319228,0.953306040354194),    //50
    BP2_CONST2(0.307849640041535,0.951435020969008),    //51
    BP2_CONST2(0.313681740398892,0.949528180593037),    //52
    BP2_CONST2(0.319502030816016,0.947585591017741),    //53
    BP2_CONST2(0.325310292162263,0.945607325380521),    //54
    BP2_CONST2(0.331106305759876,0.94359345816196),    //55
    BP2_CONST2(0.33688985339222,0.941544065183021),    //56
    BP2_CONST2(0.342660717311994,0.93945922360219),    //57
    BP2_CONST2(0.348418680249435,0.937339011912575),    //58
    BP2_CONST2(0.35416352542049,0.935183509938948),    //59
    BP2_CONST2(0.359895036534988,0.932992798834739),    //60
    BP2_CONST2(0.365612997804774,0.930766961078984),    //61
    BP2_CONST2(0.371317193951838,0.928506080473216),    //62
    BP2_CONST2(0.377007410216418,0.926210242138311),    //63
    BP2_CONST2(0.38268343236509,0.923879532511287),    //64
    BP2_CONST2(0.388345046698826,0.921514039342042),    //65
    BP2_CONST2(0.393992040061048,0.919113851690058),    //66
    BP2_CONST2(0.399624199845647,0.916679059921043),    //67
    BP2_CONST2(0.40524131400499,0.914209755703531),    //68
    BP2_CONST2(0.410843171057904,0.91170603200543),    //69
    BP2_CONST2(0.416429560097637,0.909167983090522),    //70
    BP2_CONST2(0.4220002707998,0.906595704514915),    //71
    BP2_CONST2(0.427555093430282,0.903989293123443),    //72
    BP2_CONST2(0.433093818853152,0.901348847046022),    //73
    BP2_CONST2(0.438616238538528,0.898674465693954),    //74
    BP2_CONST2(0.444122144570429,0.895966249756185),    //75
    BP2_CONST2(0.449611329654607,0.893224301195515),    //76
    BP2_CONST2(0.455083587126344,0.890448723244758),    //77
    BP2_CONST2(0.46053871095824,0.887639620402854),    //78
    BP2_CONST2(0.465976495767966,0.884797098430938),    //79
    BP2_CONST2(0.471396736825998,0.881921264348355),    //80
    BP2_CONST2(0.476799230063322,0.879012226428634),    //81
    BP2_CONST2(0.482183772079123,0.876070094195407),    //82
    BP2_CONST2(0.487550160148436,0.87309497841829),    //83
    BP2_CONST2(0.492898192229784,0.870086991108711),    //84
    BP2_CONST2(0.498227666972782,0.867046245515693),    //85
    BP2_CONST2(0.503538383725718,0.863972856121587),    //86
    BP2_CONST2(0.508830142543107,0.860866938637767),    //87
    BP2_CONST2(0.514102744193222,0.857728610000272),    //88
    BP2_CONST2(0.51935599016559,0.854557988365401),    //89
    BP2_CONST2(0.524589682678469,0.851355193105265),    //90
    BP2_CONST2(0.529803624686295,0.848120344803297),    //91
    BP2_CONST2(0.534997619887097,0.844853565249707),    //92
    BP2_CONST2(0.540171472729893,0.841554977436898),    //93
    BP2_CONST2(0.545324988422046,0.838224705554838),    //94
    BP2_CONST2(0.550457972936605,0.83486287498638),    //95
    BP2_CONST2(0.555570233019602,0.831469612302545),    //96
    BP2_CONST2(0.560661576197336,0.828045045257756),    //97
    BP2_CONST2(0.565731810783613,0.824589302785025),    //98
    BP2_CONST2(0.570780745886967,0.821102514991105),    //99
    BP2_CONST2(0.575808191417845,0.817584813151584),    //100
    BP2_CONST2(0.580813958095765,0.814036329705948),    //101
    BP2_CONST2(0.585797857456439,0.810457198252595),    //102
    BP2_CONST2(0.590759701858874,0.806847553543799),    //103
    BP2_CONST2(0.595699304492433,0.803207531480645),    //104
    BP2_CONST2(0.600616479383869,0.799537269107905),    //105
    BP2_CONST2(0.605511041404326,0.795836904608884),    //106
    BP2_CONST2(0.610382806276309,0.792106577300212),    //107
    BP2_CONST2(0.615231590580627,0.788346427626606),    //108
    BP2_CONST2(0.620057211763289,0.784556597155575),    //109
    BP2_CONST2(0.624859488142386,0.780737228572094),    //110
    BP2_CONST2(0.629638238914927,0.776888465673232),    //111
    BP2_CONST2(0.634393284163645,0.773010453362737),    //112
    BP2_CONST2(0.639124444863776,0.76910333764558),    //113
    BP2_CONST2(0.643831542889791,0.765167265622459),    //114
    BP2_CONST2(0.648514401022112,0.761202385484262),    //115
    BP2_CONST2(0.653172842953777,0.757208846506485),    //116
    BP2_CONST2(0.657806693297079,0.753186799043613),    //117
    BP2_CONST2(0.662415777590172,0.749136394523459),    //118
    BP2_CONST2(0.666999922303637,0.745057785441466),    //119
    BP2_CONST2(0.671558954847018,0.740951125354959),    //120
    BP2_CONST2(0.676092703575316,0.73681656887737),    //121
    BP2_CONST2(0.680600997795453,0.732654271672413),    //122
    BP2_CONST2(0.6850836677727,0.728464390448225),    //123
    BP2_CONST2(0.689540544737067,0.724247082951467),    //124
    BP2_CONST2(0.693971460889654,0.720002507961382),    //125
    BP2_CONST2(0.698376249408973,0.715730825283819),    //126
    BP2_CONST2(0.702754744457225,0.711432195745216),    //127
    BP2_CONST2(0.707106781186547,0.707106781186548)     //128
};
const BP2Type lpc_trig256[] = {
    BP2_CONST2(0,1),    //0
    BP2_CONST2(0.0122715382857199,0.999924701839145),    //1
    BP2_CONST2(0.0245412285229123,0.999698818696204),    //2
    BP2_CONST2(0.0368072229413588,0.99932238458835),    //3
    BP2_CONST2(0.049067674327418,0.998795456205172),    //4
    BP2_CONST2(0.0613207363022086,0.998118112900149),    //5
    BP2_CONST2(0.0735645635996674,0.99729045667869),    //6
    BP2_CONST2(0.0857973123444399,0.996312612182778),    //7
    BP2_CONST2(0.0980171403295606,0.995184726672197),    //8
    BP2_CONST2(0.110222207293883,0.993906970002356),    //9
    BP2_CONST2(0.122410675199216,0.99247953459871),    //10
    BP2_CONST2(0.134580708507126,0.99090263542778),    //11
    BP2_CONST2(0.146730474455362,0.989176509964781),    //12
    BP2_CONST2(0.158858143333861,0.987301418157858),    //13
    BP2_CONST2(0.170961888760301,0.985277642388941),    //14
    BP2_CONST2(0.183039887955141,0.983105487431216),    //15
    BP2_CONST2(0.195090322016128,0.98078528040323),    //16
    BP2_CONST2(0.207111376192219,0.978317370719628),    //17
    BP2_CONST2(0.21910124015687,0.975702130038529),    //18
    BP2_CONST2(0.231058108280671,0.97293995220556),    //19
    BP2_CONST2(0.242980179903264,0.970031253194544),    //20
    BP2_CONST2(0.254865659604515,0.966976471044852),    //21
    BP2_CONST2(0.266712757474898,0.96377606579544),    //22
    BP2_CONST2(0.278519689385053,0.960430519415566),    //23
    BP2_CONST2(0.290284677254462,0.956940335732209),    //24
    BP2_CONST2(0.302005949319228,0.953306040354194),    //25
    BP2_CONST2(0.313681740398892,0.949528180593037),    //26
    BP2_CONST2(0.325310292162263,0.945607325380521),    //27
    BP2_CONST2(0.33688985339222,0.941544065183021),    //28
    BP2_CONST2(0.348418680249435,0.937339011912575),    //29
    BP2_CONST2(0.359895036534988,0.932992798834739),    //30
    BP2_CONST2(0.371317193951838,0.928506080473216),    //31
    BP2_CONST2(0.38268343236509,0.923879532511287),    //32
    BP2_CONST2(0.393992040061048,0.919113851690058),    //33
    BP2_CONST2(0.40524131400499,0.914209755703531),    //34
    BP2_CONST2(0.416429560097637,0.909167983090522),    //35
    BP2_CONST2(0.427555093430282,0.903989293123443),    //36
    BP2_CONST2(0.438616238538528,0.898674465693954),    //37
    BP2_CONST2(0.449611329654607,0.893224301195515),    //38
    BP2_CONST2(0.46053871095824,0.887639620402854),    //39
    BP2_CONST2(0.471396736825998,0.881921264348355),    //40
    BP2_CONST2(0.482183772079123,0.876070094195407),    //41
    BP2_CONST2(0.492898192229784,0.870086991108711),    //42
    BP2_CONST2(0.503538383725718,0.863972856121587),    //43
    BP2_CONST2(0.514102744193222,0.857728610000272),    //44
    BP2_CONST2(0.524589682678469,0.851355193105265),    //45
    BP2_CONST2(0.534997619887097,0.844853565249707),    //46
    BP2_CONST2(0.545324988422046,0.838224705554838),    //47
    BP2_CONST2(0.555570233019602,0.831469612302545),    //48
    BP2_CONST2(0.565731810783613,0.824589302785025),    //49
    BP2_CONST2(0.575808191417845,0.817584813151584),    //50
    BP2_CONST2(0.585797857456439,0.810457198252595),    //51
    BP2_CONST2(0.595699304492433,0.803207531480645),    //52
    BP2_CONST2(0.605511041404326,0.795836904608884),    //53
    BP2_CONST2(0.615231590580627,0.788346427626606),    //54
    BP2_CONST2(0.624859488142386,0.780737228572094),    //55
    BP2_CONST2(0.634393284163645,0.773010453362737),    //56
    BP2_CONST2(0.643831542889791,0.765167265622459),    //57
    BP2_CONST2(0.653172842953777,0.757208846506485),    //58
    BP2_CONST2(0.662415777590172,0.749136394523459),    //59
    BP2_CONST2(0.671558954847018,0.740951125354959),    //60
    BP2_CONST2(0.680600997795453,0.732654271672413),    //61
    BP2_CONST2(0.689540544737067,0.724247082951467),    //62
    BP2_CONST2(0.698376249408973,0.715730825283819),    //63
    BP2_CONST2(0.707106781186547,0.707106781186548)     //64
};
const BP2Type lpc_trig128[] = {
    BP2_CONST2(0,1),    //0
    BP2_CONST2(0.0245412285229123,0.999698818696204),    //1
    BP2_CONST2(0.049067674327418,0.998795456205172),    //2
    BP2_CONST2(0.0735645635996674,0.99729045667869),    //3
    BP2_CONST2(0.0980171403295606,0.995184726672197),    //4
    BP2_CONST2(0.122410675199216,0.99247953459871),    //5
    BP2_CONST2(0.146730474455362,0.989176509964781),    //6
    BP2_CONST2(0.170961888760301,0.985277642388941),    //7
    BP2_CONST2(0.195090322016128,0.98078528040323),    //8
    BP2_CONST2(0.21910124015687,0.975702130038529),    //9
    BP2_CONST2(0.242980179903264,0.970031253194544),    //10
    BP2_CONST2(0.266712757474898,0.96377606579544),    //11
    BP2_CONST2(0.290284677254462,0.956940335732209),    //12
    BP2_CONST2(0.313681740398892,0.949528180593037),    //13
    BP2_CONST2(0.33688985339222,0.941544065183021),    //14
    BP2_CONST2(0.359895036534988,0.932992798834739),    //15
    BP2_CONST2(0.38268343236509,0.923879532511287),    //16
    BP2_CONST2(0.40524131400499,0.914209755703531),    //17
    BP2_CONST2(0.427555093430282,0.903989293123443),    //18
    BP2_CONST2(0.449611329654607,0.893224301195515),    //19
    BP2_CONST2(0.471396736825998,0.881921264348355),    //20
    BP2_CONST2(0.492898192229784,0.870086991108711),    //21
    BP2_CONST2(0.514102744193222,0.857728610000272),    //22
    BP2_CONST2(0.534997619887097,0.844853565249707),    //23
    BP2_CONST2(0.555570233019602,0.831469612302545),    //24
    BP2_CONST2(0.575808191417845,0.817584813151584),    //25
    BP2_CONST2(0.595699304492433,0.803207531480645),    //26
    BP2_CONST2(0.615231590580627,0.788346427626606),    //27
    BP2_CONST2(0.634393284163645,0.773010453362737),    //28
    BP2_CONST2(0.653172842953777,0.757208846506485),    //29
    BP2_CONST2(0.671558954847018,0.740951125354959),    //30
    BP2_CONST2(0.689540544737067,0.724247082951467),    //31
    BP2_CONST2(0.707106781186547,0.707106781186548)     //32
};

const BP2Type* lpc_Trigs[] = {
    lpc_trig2048, lpc_trig1024, lpc_trig512, lpc_trig256, lpc_trig128 };

#endif // 0

#endif  // _DEBUG

#elif defined(PLATFORM_LPC_FOLDED)

//#pragma COMPILER_MESSAGE(__FILE__ "(35) : Warning - constants for PLATFORM_LPC_FOLDED")

#define BP2_CONST6(a,b,c,d,e,f) BP2_FROM_FLOAT(a),BP2_FROM_FLOAT(b),BP2_FROM_FLOAT(c), \
                                BP2_FROM_FLOAT(d),BP2_FROM_FLOAT(e),BP2_FROM_FLOAT(f)


const BP2Type lpc_cnst4[] = {
    BP2_CONST6(-0.541195999830961,1.84775899909436,0,1.41421399917453,0.541195999830961,0.765366999432444),    //0
    BP2_CONST6(0.995386999100446,0.00920400023460388,0.996926999650895,0.00613600015640259,0.998464999720454,0.00306800007820129),    //1
    BP2_CONST6(-0.535177999176084,1.84421699866652,0.0043389992788434,1.40986800007522,0.543199999257922,0.762531000189483),    //2
    BP2_CONST6(-0.547202999703586,1.85126099921762,-0.0043389992788434,1.4185459986329,0.539190999232232,0.76820100005716),    //3
    BP2_CONST6(-1.41419899929314,1.42070699855685,-0.996926999650895,1.99998999945819,0.00216899998486042,1.4120429996401),    //4
    BP2_CONST6(0.990753999911248,0.0184069992974401,0.993844999931752,0.0122719993814826,0.996926999650895,0.00613600015640259),    //5
    BP2_CONST6(-0.529147999361157,1.84063599910587,0.00867699924856424,1.40550999995321,0.545201999135315,0.759694000706076),    //6
    BP2_CONST6(-0.553197999484837,1.85472399927675,-0.00867699924856424,1.42286399845033,0.537184999324381,0.771031999960541),    //7
    BP2_CONST6(-1.41415299940854,1.42716899886727,-0.993844999931752,1.99996199924498,0.0043389992788434,1.40986800007522),    //8
    BP2_CONST6(0.986098999157547,0.0276110004633665,0.990753999911248,0.0184069992974401,0.995386999100446,0.00920400023460388),    //9
    BP2_CONST6(-0.523106999695301,1.8370169987902,0.0130159994587302,1.40113800019025,0.547202999703586,0.756856000050902),    //10
    BP2_CONST6(-0.559181999415159,1.85814899858087,-0.0130159994587302,1.42716999910771,0.535177999176084,0.7738620005548),    //11
    BP2_CONST6(-1.41407899931073,1.43360299896448,-0.990753999911248,1.99991499911993,0.00650799926370382,1.40769100002944),    //12
    BP2_CONST6(0.981423999182879,0.0368130002170801,0.987652999348938,0.0245430003851652,0.993844999931752,0.0122719993814826),    //13
    BP2_CONST6(-0.517054999247193,1.83335799910128,0.0173549996688962,1.39675199985504,0.549202999100089,0.754015000537037),    //14
    BP2_CONST6(-0.565153999254107,1.86153399851173,-0.0173549996688962,1.43146199919283,0.53316899947822,0.776689999736845),    //15
    BP2_CONST6(-1.4139739992097,1.44000499881803,-0.987652999348938,1.99984899908304,0.00867699924856424,1.40550999995321),    //16
    BP2_CONST6(0.976726999506354,0.0460160002112389,0.984542999416589,0.0306780003011227,0.992300999350845,0.0153390001505613),    //17
    BP2_CONST6(-0.510991999879479,1.82966099958866,0.021692999638617,1.39235400035977,0.551200999878346,0.751172999851405),    //18
    BP2_CONST6(-0.571113999933004,1.86487899906933,-0.021692999638617,1.435739999637,0.531158999539911,0.779516000300645),    //19
    BP2_CONST6(-1.41383899934589,1.44637699890881,-0.984542999416589,1.99976499937474,0.0108469994738698,1.40332499984651),    //20
    BP2_CONST6(0.972009999677538,0.0552169997245073,0.981423999182879,0.0368130002170801,0.990753999911248,0.0184069992974401),    //21
    BP2_CONST6(-0.504917999729514,1.82592399884015,0.0260309996083379,1.38794299960136,0.553197999484837,0.748328999616205),    //22
    BP2_CONST6(-0.577060999348759,1.86818399932235,-0.0260309996083379,1.44000499881803,0.529147999361157,0.782341000624001),    //23
    BP2_CONST6(-1.41367399971932,1.45271799899637,-0.981423999182879,1.99966099858283,0.0130159994587302,1.40113800019025),    //24
    BP2_CONST6(0.967272999696433,0.0644159996882081,0.978294999338686,0.0429480001330376,0.989204999990761,0.0214749993756413),    //25
    BP2_CONST6(-0.498833999969065,1.82214999943971,0.0303689995780587,1.38351800013333,0.555193999782204,0.745481999590992),    //26
    BP2_CONST6(-0.582996999844908,1.87145099975168,-0.0303689995780587,1.44425599928945,0.527134999632835,0.785163999535143),    //27
    BP2_CONST6(-1.41347999963909,1.45902899932116,-0.978294999338686,1.99953799881041,0.0151849994435906,1.39894700050354),    //28
    BP2_CONST6(0.962514999322593,0.0736150005832314,0.975157999433577,0.0490819998085499,0.987652999348938,0.0245430003851652),    //29
    BP2_CONST6(-0.49273799918592,1.81833599880337,0.0347059993073344,1.37908199988305,0.557188999839127,0.742633999325335),    //30
    BP2_CONST6(-0.588919999077916,1.87467799894511,-0.0347069995477796,1.44849499873816,0.525121999904513,0.787983999587595),    //31
    BP2_CONST6(-1.41325499955564,1.46530799940228,-0.975157999433577,1.9993979986757,0.0173549996688962,1.39675199985504),    //32
    BP2_CONST6(0.957736999727785,0.0828109998255968,0.972010999917984,0.0552159994840622,0.986098999157547,0.0276110004633665),    //33
    BP2_CONST6(-0.486632999964058,1.81448399927467,0.0390439992770553,1.37463000044226,0.559181999415159,0.739784999750554),    //34
    BP2_CONST6(-0.594830999150872,1.87786499876528,-0.0390439992770553,1.45271899923682,0.523106999695301,0.790802999399602),    //35
    BP2_CONST6(-1.41300099994987,1.47155799902975,-0.972010999917984,1.99923799932003,0.0195239996537566,1.39455499965697),    //36
    BP2_CONST6(0.952937999740242,0.0920059997588396,0.968853999860584,0.0613500000908971,0.984542999416589,0.0306780003011227),    //37
    BP2_CONST6(-0.480516999959946,1.81059299968183,0.0433809999376535,1.3701669992879,0.561173999682068,0.736933999694883),    //38
    BP2_CONST6(-0.600728999823331,1.8810119992122,-0.0433809999376535,1.45692899916321,0.521090999245643,0.793620000593364),    //39
    BP2_CONST6(-1.41271599940955,1.47777399886399,-0.968853999860584,1.99905799981206,0.021692999638617,1.39235400035977),    //40
    BP2_CONST6(0.94811899960041,0.10120000038296,0.965688999742269,0.0674829995259643,0.982984999194741,0.033746000379324),    //41
    BP2_CONST6(-0.474390999414027,1.80666399933397,0.0477169994264841,1.36569099966436,0.563164999708533,0.7340799998492),    //42
    BP2_CONST6(-0.606614999473094,1.88411999866366,-0.0477169994264841,1.46112499851733,0.519072999246418,0.796436000615358),    //43
    BP2_CONST6(-1.41240199934691,1.4839609991759,-0.965688999742269,1.9988609990105,0.0238619996234775,1.39015000034123),    //44
    BP2_CONST6(0.943279999308288,0.110391000285745,0.962514999322593,0.0736150005832314,0.981423999182879,0.0368130002170801),    //45
    BP2_CONST6(-0.468254999257624,1.80269799847155,0.0520529998466372,1.36120199970901,0.565153999254107,0.731226000003516),    //46
    BP2_CONST6(-0.612486999481916,1.88718699943274,-0.0520529998466372,1.46530799940228,0.517054999247193,0.799248000606894),    //47
    BP2_CONST6(-1.41205799952149,1.49011599924415,-0.962514999322593,1.99864499922841,0.0260309996083379,1.38794299960136),    //48
    BP2_CONST6(0.938420999795198,0.119579999707639,0.959331999532878,0.0797459995374084,0.97986099962145,0.0398810002952814),    //49
    BP2_CONST6(-0.462108999490738,1.7986919991672,0.0563889993354678,1.35670000035315,0.567141999490559,0.72836900036782),    //50
    BP2_CONST6(-0.618346999399363,1.89021499920636,-0.0563889993354678,1.46947799902409,0.5150349996984,0.802059999667108),    //51
    BP2_CONST6(-1.41168299969285,1.49623799882829,-0.959331999532878,1.99840999860316,0.0281999995931983,1.38573199976235),    //52
    BP2_CONST6(0.933541999198496,0.128766000270844,0.956138999201357,0.0858770003542304,0.978294999338686,0.0429480001330376),    //53
    BP2_CONST6(-0.455952999182045,1.79464799910783,0.0607239995151758,1.35218499973416,0.56912799924612,0.725512000732123),    //54
    BP2_CONST6(-0.624192999675869,1.89320099912583,-0.0607239995151758,1.47363299876451,0.513013999909162,0.804868999868631),    //55
    BP2_CONST6(-1.41127899941056,1.50232999864965,-0.956138999201357,1.99815499875694,0.0303689995780587,1.38351800013333),    //56
    BP2_CONST6(0.928643999621272,0.137949000112712,0.952937999740242,0.0920059997588396,0.976727999746799,0.0460149999707937),    //57
    BP2_CONST6(-0.449787999503314,1.79056799877434,0.0650579994544387,1.34765799995511,0.571113999933004,0.722650999203324),    //58
    BP2_CONST6(-0.630026999861001,1.89614899922162,-0.0650579994544387,1.47777399886399,0.510991999879479,0.807676999829709),    //59
    BP2_CONST6(-1.4108449993655,1.50838999915868,-0.952937999740242,1.99788199923932,0.0325379995629191,1.38130099978297),    //60
    BP2_CONST6(0.923725999891757,0.147128999233246,0.949727999977767,0.0981349991634488,0.975157999433577,0.0490819998085499),    //61
    BP2_CONST6(-0.443612999282777,1.7864479990676,0.0693919993937016,1.34311799984425,0.573097999207675,0.719790000468492),    //62
    BP2_CONST6(-0.635845999233424,1.89905599877238,-0.0693919993937016,1.48190199863165,0.508967999368906,0.810483000241219),    //63
    BP2_CONST6(-1.41038199979811,1.51441799942404,-0.949727999977767,1.99759099911898,0.0347069995477796,1.37908099964261),    //64
    BP2_CONST6(0.918787999078631,0.156306000426412,0.946507999673485,0.104263999499381,0.973584999330341,0.0521499998867512),    //65
    BP2_CONST6(-0.437428999692202,1.78229199908673,0.0737249990925193,1.33856500033289,0.575079999864101,0.716926999390125),    //66
    BP2_CONST6(-0.641652999445796,1.90192299894988,-0.0737249990925193,1.48601499851793,0.506943999789655,0.813285999931395),    //67
    BP2_CONST6(-1.40988799929618,1.52041399851441,-0.946507999673485,1.99727999884635,0.0368749992921948,1.37685800064355),    //68
    BP2_CONST6(0.913830999284982,0.165479999966919,0.943279999308288,0.110391000285745,0.972010999917984,0.0552159994840622),    //69
    BP2_CONST6(-0.43123499955982,1.77809599880129,0.0780579997226596,1.33399899955838,0.577061999589204,0.71406100038439),    //70
    BP2_CONST6(-0.647445999085903,1.9047499988228,-0.0780579997226596,1.49011599924415,0.504917999729514,0.816087999381124),    //71
    BP2_CONST6(-1.4093639999628,1.5263759996742,-0.943279999308288,1.99695099890232,0.0390439992770553,1.37463000044226),    //72
    BP2_CONST6(0.908853999339044,0.174651000648737,0.940042999573051,0.116516999900341,0.97043399978429,0.0582829993218184),    //73
    BP2_CONST6(-0.425031999126077,1.77386399824172,0.0823899991810322,1.32942100055515,0.579040999524295,0.711195999756455),    //74
    BP2_CONST6(-0.653224999085068,1.90753599908202,-0.0823899991810322,1.49420099891722,0.502890999428927,0.818888000212609),    //75
    BP2_CONST6(-1.40881099924445,1.53230799920856,-0.940042999573051,1.99660299904644,0.0412119999527931,1.37240100000053),    //76
    BP2_CONST6(0.90385799948126,0.183818000368774,0.936796999536454,0.122642000205815,0.968854999169707,0.0613490007817745),    //77
    BP2_CONST6(-0.41882099956274,1.76959499903023,0.0867209993302822,1.32483100052922,0.581019999459385,0.708327000029385),    //78
    BP2_CONST6(-0.658989999443292,1.91028199903666,-0.0867209993302822,1.49827299918979,0.500862999819219,0.821685999631881),    //79
    BP2_CONST6(-1.40822799969464,1.53820699919015,-0.936796999536454,1.99623599927872,0.0433809999376535,1.3701669992879),    //80
    BP2_CONST6(0.898842999711632,0.192981000058353,0.933542999438941,0.128765000030398,0.967272999696433,0.0644159996882081),    //81
    BP2_CONST6(-0.412599999457598,1.76528699882328,0.0910509992390871,1.32022800017148,0.582996999844908,0.705457000061869),    //82
    BP2_CONST6(-0.664741999469697,1.91298799868673,-0.0910509992390871,1.5023309988901,0.498833999969065,0.824481999501585),    //83
    BP2_CONST6(-1.40761499945074,1.54407299868762,-0.933542999438941,1.99585099890828,0.0455489996820688,1.36793099995702),    //84
    BP2_CONST6(0.893808999098837,0.202140000648797,0.930278999730944,0.134887999854982,0.965688999742269,0.0674829995259643),    //85
    BP2_CONST6(-0.406370999291539,1.76094199903309,0.0953799998387694,1.31561299972236,0.584972999989986,0.702584999613463),    //86
    BP2_CONST6(-0.670478999614715,1.91565299872308,-0.0953799998387694,1.5063729993999,0.496802999638021,0.827277000062167),    //87
    BP2_CONST6(-1.40697199944406,1.54990699887275,-0.930278999730944,1.99544599931687,0.0477169994264841,1.36569099966436),    //88
    BP2_CONST6(0.888756999745965,0.211294000037014,0.927006999962031,0.141008999198675,0.964102999307215,0.0705490000545979),    //89
    BP2_CONST6(-0.400132999755442,1.75655999965965,0.0997089995071292,1.31098499987274,0.586946999654173,0.69971300009638),    //90
    BP2_CONST6(-0.676201999187469,1.91827699914574,-0.0997089995071292,1.510402998887,0.494770999997854,0.830068999901413),    //91
    BP2_CONST6(-1.40629899967461,1.55570699926465,-0.927006999962031,1.99502299912273,0.0498849991708994,1.36344800051301),    //92
    BP2_CONST6(0.88368499930948,0.220444000326097,0.923725999891757,0.147128999233246,0.962514999322593,0.0736150005832314),    //93
    BP2_CONST6(-0.393885999917984,1.7521399995312,0.104035999625921,1.30634600017219,0.588919999077916,0.696838000789284),    //94
    BP2_CONST6(-0.681910999119281,1.9208609983325,-0.104035999625921,1.51441799942404,0.49273799918592,0.832860000431537),    //95
    BP2_CONST6(-1.40559699945151,1.56147499941289,-0.923725999891757,1.99458099901676,0.0520529998466372,1.36120199970901),    //96
    BP2_CONST6(0.878593999892473,0.229589999653399,0.920435999520123,0.153247999958694,0.960924999788403,0.0766799999400973),    //97
    BP2_CONST6(-0.387631999328732,1.74768399912863,0.108362999744713,1.30169299989938,0.590891999192535,0.693961000069975),    //98
    BP2_CONST6(-0.687604999169707,1.92340399883687,-0.108362999744713,1.51841899938881,0.490703999996185,0.835647999309003),    //99
    BP2_CONST6(-1.40486499946564,1.56720999907702,-0.920435999520123,1.99411999899893,0.0542209995910525,1.35895300004631),    //100
    BP2_CONST6(0.873484999872744,0.238729999400675,0.917137999087572,0.159365000203252,0.959331999532878,0.0797459995374084),    //101
    BP2_CONST6(-0.381368999369442,1.74318999890238,0.112687999382615,1.29702899977564,0.592861999757587,0.691083000041544),    //102
    BP2_CONST6(-0.693284999579191,1.92590599879622,-0.112687999382615,1.52240499854087,0.488668999634683,0.838433999568223),    //103
    BP2_CONST6(-1.40410299971699,1.57291099894791,-0.917137999087572,1.99364099837839,0.0563889993354678,1.35670000035315),    //104
    BP2_CONST6(0.868357999250292,0.247866000048816,0.913830999284982,0.165479999966919,0.957736999727785,0.0828109998255968),    //105
    BP2_CONST6(-0.375097999349236,1.73865999933332,0.117011999711394,1.29235200025141,0.594830999150872,0.688203000463545),    //106
    BP2_CONST6(-0.698949999175965,1.92836799845099,-0.117011999711394,1.5263759996742,0.486632999964058,0.841217999346554),    //107
    BP2_CONST6(-1.40331099927425,1.57857899926602,-0.913830999284982,1.99314199853688,0.0585559997707605,1.35444500017911),    //108
    BP2_CONST6(0.863211999647319,0.256996000185609,0.910514999181032,0.17159500066191,0.956139999441802,0.0858760001137853),    //109
    BP2_CONST6(-0.368818999268115,1.73409299924969,0.121335999108851,1.2876630006358,0.596797999925911,0.685321999713778),    //110
    BP2_CONST6(-0.704599999822676,1.93078899942338,-0.121335999108851,1.5303349988535,0.484594999812543,0.844000999815762),    //111
    BP2_CONST6(-1.40248999930918,1.58421399910002,-0.910514999181032,1.99262499902397,0.0607239995151758,1.35218499973416),    //112
    BP2_CONST6(0.858046999201178,0.266121000051498,0.907190999947488,0.177706999704242,0.954539999365806,0.0889410004019737),    //113
    BP2_CONST6(-0.362531999126077,1.7294889986515,0.125657999888062,1.28296199999749,0.598764999769628,0.682438000105321),    //114
    BP2_CONST6(-0.710235999897122,1.93316899985074,-0.125657999888062,1.53427799977362,0.482556999661028,0.846780999563634),    //115
    BP2_CONST6(-1.40163899958133,1.58981499914079,-0.907190999947488,1.99208899959921,0.0628909999504685,1.34992399998009),    //116
    BP2_CONST6(0.852864999324083,0.275240000337362,0.90385799948126,0.183818000368774,0.952937999740242,0.0920059997588396),    //117
    BP2_CONST6(-0.356236999854445,1.72484699916094,0.129978999495506,1.27824900019913,0.600728999823331,0.679553999565541),    //118
    BP2_CONST6(-0.715855999849736,1.93550799973309,-0.129978999495506,1.53820699919015,0.480516999959946,0.849558999761939),    //119
    BP2_CONST6(-1.40075799915939,1.59538199845701,-0.90385799948126,1.99153499864041,0.0650579994544387,1.34765799995511),    //120
    BP2_CONST6(0.847663999535143,0.284354000352323,0.900516999885439,0.189926999621093,0.951333999633789,0.0950710000470281),    //121
    BP2_CONST6(-0.349934999831021,1.7201699996367,0.134298999793828,1.27352300006896,0.60269199963659,0.676667999476194),    //122
    BP2_CONST6(-0.721460999920964,1.9378059990704,-0.134298999793828,1.54212099965661,0.478475999087095,0.852336000651121),    //123
    BP2_CONST6(-1.399846999906,1.60091499984264,-0.900516999885439,1.99096099939197,0.0672249998897314,1.34538999944925),    //124
    BP2_CONST6(0.842445999383926,0.293461000546813,0.89716799929738,0.196034000255167,0.949727999977767,0.0981349991634488),    //125
    BP2_CONST6(-0.343625999987125,1.71545699983835,0.138616999611259,1.2687870003283,0.604653999209403,0.673780000768601),    //126
    BP2_CONST6(-0.727050999179482,1.94006299879401,-0.138616999611259,1.54602099955081,0.476433999836445,0.855109999887645),    //127
    BP2_CONST6(-1.39890699926763,1.60641499888151,-0.89716799929738,1.99036999884992,0.0693919993937016,1.34311799984425),    //128
    BP2_CONST6(0.837209999561309,0.302562000229955,0.893808999098837,0.202140000648797,0.94811899960041,0.10120000038296),    //129
    BP2_CONST6(-0.337308999150991,1.7107069985941,0.142933999188244,1.26403800025582,0.606614999473094,0.670889999717473),    //130
    BP2_CONST6(-0.732625999487936,1.94227899890393,-0.142933999188244,1.54990599863231,0.474390999414027,0.857882999815046),    //131
    BP2_CONST6(-1.39793699979782,1.61188099905848,-0.893808999098837,1.98975799884647,0.0715589998289943,1.34084299951791),    //132
    BP2_CONST6(0.831955999135971,0.311656000092626,0.890442999079823,0.20824300032109,0.946507999673485,0.104263999499381),    //133
    BP2_CONST6(-0.330984999425709,1.70592099893838,0.147249999456108,1.25927700009196,0.608572999946773,0.667999999597668),    //134
    BP2_CONST6(-0.738184999674558,1.94445299915969,-0.147249999456108,1.55377699900418,0.472346999682486,0.860652999952435),    //135
    BP2_CONST6(-1.39693799987435,1.61731299944221,-0.890442999079823,1.98912899848073,0.0737249990925193,1.33856600057333),    //136
    BP2_CONST6(0.826683999970555,0.320744999684393,0.887067999690771,0.214344999752939,0.944895999506115,0.107327000238001),    //137
    BP2_CONST6(-0.324654999189079,1.70109899900853,0.151564999483526,1.25450299959629,0.610530999489128,0.66510699968785),    //138
    BP2_CONST6(-0.743727999739348,1.94658699911087,-0.151564999483526,1.55763299856334,0.470300999470055,0.863421999849379),    //139
    BP2_CONST6(-1.39590899925678,1.62270999886095,-0.887067999690771,1.98848099913448,0.075891999527812,1.33628400042653),    //140
    BP2_CONST6(0.821394999511539,0.329826000146568,0.88368499930948,0.220444000326097,0.943279999308288,0.110391000285745),    //141
    BP2_CONST6(-0.318316999822855,1.69624099973589,0.155877999961376,1.24971899949014,0.612486999481916,0.662213000468909),    //142
    BP2_CONST6(-0.749255999922752,1.94867899920791,-0.155877999961376,1.56147499941289,0.468254999257624,0.866187999956309),    //143
    BP2_CONST6(-1.39484999980777,1.62807199917733,-0.88368499930948,1.98781399894505,0.0780579997226596,1.33399999979883),    //144
    BP2_CONST6(0.816087999381124,0.338901000097394,0.88029299955815,0.226541999727488,0.941662999801337,0.113454000093043),    //145
    BP2_CONST6(-0.311971999704838,1.69134599901735,0.160188999958336,1.24492299929261,0.614441999234259,0.659316999837756),    //146
    BP2_CONST6(-0.754766999743878,1.95072999969124,-0.160188999958336,1.56530099920928,0.466206999495625,0.86895199958235),    //147
    BP2_CONST6(-1.3937619999051,1.6334009990096,-0.88029299955815,1.98712799884378,0.0802239999175072,1.331712000072),    //148
    BP2_CONST6(0.810764999128878,0.347967000678182,0.876892999745905,0.232636999338865,0.940042999573051,0.116516999900341),    //149
    BP2_CONST6(-0.305620999075472,1.68641599826514,0.164498999714851,1.24011499993503,0.616394999437034,0.65641999989748),    //150
    BP2_CONST6(-0.760262999683618,1.95273999962955,-0.164498999714851,1.56911299936473,0.464158999733627,0.871713999658823),    //151
    BP2_CONST6(-1.39264499954879,1.6386949988082,-0.876892999745905,1.98642399907112,0.0823899991810322,1.3294220007956),    //152
    BP2_CONST6(0.805423999205231,0.357027000747621,0.873484999872744,0.23873099964112,0.938420999795198,0.119579999707639),    //153
    BP2_CONST6(-0.299263999797404,1.6814509993419,0.168807999230921,1.23529400024563,0.618346999399363,0.653521000407636),    //154
    BP2_CONST6(-0.765742999501526,1.95470799878239,-0.168807999230921,1.57291099894791,0.462108999490738,0.874474000185728),    //155
    BP2_CONST6(-1.3914979994297,1.64395499881356,-0.873484999872744,1.9857009993866,0.0845549991354346,1.32712900079786),    //156
    BP2_CONST6(0.80006599985063,0.366080000065267,0.870068999938666,0.244820999912918,0.936796999536454,0.122642000205815),    //157
    BP2_CONST6(-0.292899999767542,1.67644999921321,0.173114999197423,1.23046300001442,0.620296999812126,0.650620999746024),    //158
    BP2_CONST6(-0.771205999888479,1.95663499925285,-0.173114999197423,1.57669299840927,0.460057999938726,0.877232999540865),    //159
    BP2_CONST6(-1.39032099954783,1.64917899947613,-0.870068999938666,1.98495899979025,0.0867209993302822,1.32483100052922),    //160
    BP2_CONST6(0.79469099920243,0.375124000012875,0.866643999703228,0.25090999994427,0.935170999728143,0.125703999772668),    //161
    BP2_CONST6(-0.286529999226332,1.67141299881041,0.177419999614358,1.22561999969184,0.622245999984443,0.647718999534845),    //162
    BP2_CONST6(-0.776652999222278,1.95851999893784,-0.177419999614358,1.58045999892055,0.458005999214947,0.879989000037312),    //163
    BP2_CONST6(-1.38911499921232,1.6543679991737,-0.866643999703228,1.98419799935072,0.0888859992846847,1.32253100071102),    //164
    BP2_CONST6(0.789298999123275,0.384161000140011,0.863211999647319,0.256996000185609,0.933542999438941,0.128765000030398),    //165
    BP2_CONST6(-0.280153999105096,1.6663399990648,0.181723999790847,1.22076499927788,0.624192999675869,0.644816000014543),    //166
    BP2_CONST6(-0.782083999365568,1.96036399900913,-0.181723999790847,1.58421299885958,0.455952999182045,0.882743000052869),    //167
    BP2_CONST6(-1.38787999935448,1.65952299907803,-0.863211999647319,1.98341999948024,0.0910509992390871,1.32022800017148),    //168
    BP2_CONST6(0.783889999613165,0.393190000206232,0.859770999290049,0.263079999946058,0.931911999359726,0.131827000528574),    //169
    BP2_CONST6(-0.273770999163389,1.66123199835419,0.186025999486446,1.21589899994432,0.626138999126851,0.641910000704228),    //170
    BP2_CONST6(-0.78749799914658,1.96216699853539,-0.186025999486446,1.58795099891722,0.453898999840021,0.885494999587535),    //171
    BP2_CONST6(-1.38661499973386,1.66464199963957,-0.859770999290049,1.98262199852615,0.0932159991934896,1.31792200077325),    //172
    BP2_CONST6(0.778464999981224,0.402209999971092,0.856321999803185,0.269160999916494,0.930278999730944,0.134887999854982),    //173
    BP2_CONST6(-0.267383999191225,1.65608999878168,0.190325999632478,1.21102199982851,0.628082999959588,0.639004999771714),    //174
    BP2_CONST6(-0.792894999496638,1.96392799913883,-0.190325999632478,1.59167399909347,0.451843999326229,0.888244000263512),    //175
    BP2_CONST6(-1.38532099965959,1.6697259992361,-0.856321999803185,1.9818059997633,0.0953799998387694,1.3156139999628),    //176
    BP2_CONST6(0.773023999296128,0.411220000125468,0.852864999324083,0.275240000337362,0.928643999621272,0.137949000112712),    //177
    BP2_CONST6(-0.260989999398589,1.65091199893504,0.194623999297619,1.20613300055265,0.630025999620556,0.636096999980509),    //178
    BP2_CONST6(-0.798275999724864,1.96564699895679,-0.194623999297619,1.59538099914789,0.449787999503314,0.89099199976772),    //179
    BP2_CONST6(-1.38399799913167,1.67477499879896,-0.852864999324083,1.98096999898552,0.0975439995527267,1.31330200005322),    //180
    BP2_CONST6(0.767564999870955,0.420223999768496,0.849399999715387,0.281316000036895,0.927006999962031,0.141008999198675),    //181
    BP2_CONST6(-0.254590999335051,1.64569899905472,0.198920999653637,1.20123200025409,0.631967999972403,0.633186999708414),    //182
    BP2_CONST6(-0.803638999350368,1.96732399892061,-0.198920999653637,1.59907499887049,0.447730999439955,0.893737000413239),    //183
    BP2_CONST6(-1.38264499977231,1.67978799901902,-0.849399999715387,1.98011699970811,0.0997089995071292,1.31098499987274),    //184
    BP2_CONST6(0.762090999633073,0.42921799980104,0.845926999114453,0.287390000186861,0.925366999581456,0.144070000387728),    //185
    BP2_CONST6(-0.248186999931931,1.64045199938118,0.203214999288321,1.19632200058549,0.633907999843358,0.630276000127196),    //186
    BP2_CONST6(-0.808985999785363,1.96896099951118,-0.203214999288321,1.60275199916213,0.445671999827027,0.896482000127434),    //187
    BP2_CONST6(-1.38126299995929,1.68476599920541,-0.845926999114453,1.97924399841576,0.101871999911964,1.30866799969226),    //188
    BP2_CONST6(0.756600999273359,0.4382020002231,0.842445999383926,0.293461000546813,0.923725999891757,0.147128999233246),    //189
    BP2_CONST6(-0.241776999086142,1.63516999874264,0.207507999613881,1.19139899965375,0.635845999233424,0.627364000305533),    //190
    BP2_CONST6(-0.814315999858081,1.97055599931627,-0.207507999613881,1.60641499888151,0.443612999282777,0.899222999811172),    //191
    BP2_CONST6(-1.37985099945217,1.68970699887722,-0.842445999383926,1.97835299931466,0.104035999625921,1.30634600017219),    //192
    BP2_CONST6(0.751093999482691,0.447177999652922,0.838956999592483,0.29952900018543,0.922081999480724,0.150189000181854),    //193
    BP2_CONST6(-0.235361999832094,1.62985199969261,0.211798999458551,1.18646400049328,0.637782999314367,0.62445000000298),    //194
    BP2_CONST6(-0.819627999328076,1.97210799902677,-0.211798999458551,1.61006299871951,0.441552999429405,0.901961999945342),    //195
    BP2_CONST6(-1.37841099966317,1.69461399875581,-0.838956999592483,1.97744299937039,0.106198999099433,1.30402200017124),    //196
    BP2_CONST6(0.745571999810636,0.45614399947226,0.835459999740123,0.305594999343157,0.920435999520123,0.153247999958694),    //197
    BP2_CONST6(-0.22894199937582,1.62450099922716,0.216087999753654,1.18151899985969,0.639718999154865,0.621534000150859),    //198
    BP2_CONST6(-0.824922999367117,1.97361899912357,-0.216087999753654,1.61369499936699,0.439490999095142,0.904699000529944),    //199
    BP2_CONST6(-1.37694099918007,1.69948399905115,-0.835459999740123,1.9765149988234,0.108362999744713,1.30169299989938),    //200
    BP2_CONST6(0.740033999085426,0.465101000852883,0.831955999135971,0.311657000333071,0.918787999078631,0.156307000666857),    //201
    BP2_CONST6(-0.222516999579966,1.61911499872803,0.220374999567866,1.17656200006604,0.641652999445796,0.618617000058293),    //202
    BP2_CONST6(-0.830200999975204,1.97508799936622,-0.220374999567866,1.61731299944221,0.437428999692202,0.907433999702334),    //203
    BP2_CONST6(-1.37544199917465,1.70431799907237,-0.831955999135971,1.97556899860501,0.110524999909103,1.29936299938708),    //204
    BP2_CONST6(0.734479999169707,0.474047000519931,0.828442999161779,0.317716999910772,0.917137999087572,0.159365000203252),    //205
    BP2_CONST6(-0.216087999753654,1.61369499936699,0.224658999592066,1.17159599997103,0.643584999255836,0.615699999965727),    //206
    BP2_CONST6(-0.835459999740123,1.9765149988234,-0.224658999592066,1.62091399915516,0.435364999808371,0.910166999325156),    //207
    BP2_CONST6(-1.3739139996469,1.70911599881947,-0.828442999161779,1.97460299823433,0.112687999382615,1.29702899977564),    //208
    BP2_CONST6(0.728910999372601,0.482983999885619,0.824922999367117,0.323773000389338,0.915484999306499,0.162423000670969),    //209
    BP2_CONST6(-0.209653999656439,1.6082409992814,0.22894199937582,1.16661700047552,0.645515999756753,0.612780000083148),    //210
    BP2_CONST6(-0.840702999383211,1.97790099866688,-0.22894199937582,1.62450099922716,0.433300999924541,0.91289799939841),    //211
    BP2_CONST6(-1.37235699966549,1.71387799922376,-0.824922999367117,1.97361899912357,0.114849999547005,1.29469200037419),    //212
    BP2_CONST6(0.723325999453663,0.4919100003317,0.821394999511539,0.329826000146568,0.913830999284982,0.165479999966919),    //213
    BP2_CONST6(-0.203215999528766,1.60275299940258,0.233221999369562,1.16162800043821,0.647445999085903,0.609858000651001),    //214
    BP2_CONST6(-0.845926999114453,1.97924399841576,-0.233221999369562,1.62807199917733,0.43123499955982,0.915626999922096),    //215
    BP2_CONST6(-1.37077099923044,1.71860399842262,-0.821394999511539,1.97261599916964,0.117012999951839,1.29235100001096),    //216
    BP2_CONST6(0.717725999653339,0.500826000235974,0.817858999595046,0.33587700035423,0.912173999473452,0.168538000434637),    //217
    BP2_CONST6(-0.196772999130189,1.59722999855875,0.237500999122858,1.15662700030952,0.649373999796807,0.60693599935621),    //218
    BP2_CONST6(-0.851133999414741,1.98054599855095,-0.237500999122858,1.63162899855524,0.429167999885976,0.918353999964892),    //219
    BP2_CONST6(-1.36915599927306,1.72329399921,-0.817858999595046,1.97159499954432,0.119173999875784,1.29000899940729),    //220
    BP2_CONST6(0.712110999971628,0.509730999357998,0.814315999858081,0.341923999600112,0.910514999181032,0.17159500066191),    //221
    BP2_CONST6(-0.190325999632478,1.59167399909347,0.241776999086142,1.15161600057035,0.651299999095499,0.604012000374495),    //222
    BP2_CONST6(-0.856321999803185,1.98180499952286,-0.241776999086142,1.63516999874264,0.42710099928081,0.921076999977231),    //223
    BP2_CONST6(-1.36751199979335,1.72794699948281,-0.814315999858081,1.97055599931627,0.121335999108851,1.2876630006358),    //224
    BP2_CONST6(0.706479999236762,0.518626000732183,0.810764999128878,0.347967000678182,0.908853999339044,0.174651000648737),    //225
    BP2_CONST6(-0.183874999172986,1.58608399890363,0.246049999259412,1.14659500028938,0.653224999085068,0.601086000911891),    //226
    BP2_CONST6(-0.861491999588906,1.98302299901843,-0.246049999259412,1.6386949988082,0.425031999126077,0.923799999989569),    //227
    BP2_CONST6(-1.36583799961954,1.7325619990006,-0.810764999128878,1.96949799824506,0.123496999964118,1.28531399928033),    //228
    BP2_CONST6(0.700834999792277,0.527509000152349,0.807205999270081,0.354008000344038,0.907190999947488,0.177706999704242),    //229
    BP2_CONST6(-0.177419999614358,1.58045999892055,0.250321999192238,1.1415610006079,0.65514799952507,0.598159999586641),    //230
    BP2_CONST6(-0.866643999703228,1.98419799935072,-0.250321999192238,1.64220499899238,0.422962999902666,0.926518999971449),    //231
    BP2_CONST6(-1.36413599923253,1.73714199848473,-0.807205999270081,1.9684199988842,0.125657999888062,1.28296199999749),    //232
    BP2_CONST6(0.695174999535083,0.536381999962031,0.803638999350368,0.360046000219882,0.905525999143719,0.180763000622392),    //233
    BP2_CONST6(-0.170961999334395,1.57480399869382,0.254590999335051,1.13651800062507,0.657069999724626,0.595230999402701),    //234
    BP2_CONST6(-0.871777999214828,1.98533199913799,-0.254590999335051,1.64569999929517,0.420891999267042,0.929237999953329),    //235
    BP2_CONST6(-1.36240499932318,1.74168399907648,-0.803639999590814,1.96732499916106,0.127818999812007,1.28060699999332),    //236
    BP2_CONST6(0.689499999396502,0.54524299968034,0.80006599985063,0.366078999824822,0.90385799948126,0.183818000368774),    //237
    BP2_CONST6(-0.164499999955297,1.56911399960517,0.25885699968785,1.13146399985998,0.658989999443292,0.592302000150084),    //238
    BP2_CONST6(-0.876892999745905,1.98642399907112,-0.25885699968785,1.64917799923568,0.41882099956274,0.931952999904751),    //239
    BP2_CONST6(-1.36064499989151,1.74618999939411,-0.80006599985063,1.96621199976652,0.129978999495506,1.27824900019913),    //240
    BP2_CONST6(0.68381099961698,0.554092000238597,0.796483999118208,0.372110000811517,0.902188999578356,0.186873000115156),    //241
    BP2_CONST6(-0.158033999614418,1.56338999886065,0.263121999800205,1.12639799993485,0.660908999852836,0.589370999485254),    //242
    BP2_CONST6(-0.88198999967426,1.98747399915009,-0.263121999800205,1.6526429997757,0.416747999377549,0.934667000547051),    //243
    BP2_CONST6(-1.35885699931532,1.75065899919718,-0.796483999118208,1.96507899835705,0.132138999179006,1.27588800061494),    //244
    BP2_CONST6(0.678105999715626,0.562930000014603,0.792894999496638,0.378136999905109,0.900516999885439,0.189926999621093),    //245
    BP2_CONST6(-0.151564999483526,1.55763299856334,0.267382999882102,1.12132299970835,0.662825999781489,0.586438000202178),    //246
    BP2_CONST6(-0.887067999690771,1.98848099913448,-0.267382999882102,1.656089999713,0.414673999883235,0.937377999536693),    //247
    BP2_CONST6(-1.35703899990767,1.755090999417,-0.792894999496638,1.96392799913883,0.134298999793828,1.27352300006896),    //248
    BP2_CONST6(0.672387999482452,0.571755999699234,0.789298999123275,0.384161000140011,0.898842999711632,0.192981000058353),    //249
    BP2_CONST6(-0.145092999562621,1.5518439989537,0.271642999723554,1.11623699963092,0.664741999469697,0.583503999747335),    //250
    BP2_CONST6(-0.892126999795436,1.98944599926471,-0.271642999723554,1.65952299907803,0.412599999457598,0.940086999908089),    //251
    BP2_CONST6(-1.35519299935549,1.75948499888181,-0.789298999123275,1.96275899838656,0.136457999236882,1.27115700021386),    //252
    BP2_CONST6(0.666655999608337,0.58056899998337,0.785694999620318,0.390181000344455,0.89716799929738,0.196034000255167),    //253
    BP2_CONST6(-0.138616999611259,1.54602099955081,0.275898999534547,1.11114099994301,0.666655999608337,0.58056899998337),    //254
    BP2_CONST6(-0.89716799929738,1.99036999884992,-0.275898999534547,1.66293899901211,0.410524999722838,0.94279299955815),    //255
    BP2_CONST6(-1.35331799928098,1.76384299900382,-0.785694999620318,1.96157099958509,0.138616999611259,1.2687870003283),    //256
    BP2_CONST6(0.660908999852836,0.589370999485254,0.782083999365568,0.396197000518441,0.895489999093115,0.199087000451982),    //257
    BP2_CONST6(-0.132138999179006,1.54016599897295,0.280152999795973,1.10603399947285,0.668567999266088,0.577632999978959),    //258
    BP2_CONST6(-0.902188999578356,1.99125099927186,-0.280152999795973,1.6663399990648,0.408447999507189,0.945497999899089),    //259
    BP2_CONST6(-1.35141399968415,1.7681619990617,-0.782083999365568,1.96036499924957,0.140775999985635,1.26641299948096),    //260
    BP2_CONST6(0.65514799952507,0.598159999586641,0.778464999981224,0.402208999730647,0.893808999098837,0.202140000648797),    //261
    BP2_CONST6(-0.125657999888062,1.53427799977362,0.284404999576509,1.10091600008308,0.670478999614715,0.574694999493658),    //262
    BP2_CONST6(-0.907190999947488,1.99208899959921,-0.284404999576509,1.6697259992361,0.406370999291539,0.948200000450015),    //263
    BP2_CONST6(-1.34948199987411,1.77244499977678,-0.778464999981224,1.95913899969309,0.142933999188244,1.26403800025582),    //264
    BP2_CONST6(0.649373999796807,0.60693599935621,0.774838999845087,0.408218000084162,0.892126999795436,0.205191999673843),    //265
    BP2_CONST6(-0.119173999875784,1.52835699915885,0.288653999567032,1.09578800015151,0.672387999482452,0.571755999699234),    //266
    BP2_CONST6(-0.912173999473452,1.99288599938154,-0.288653999567032,1.67309599928557,0.404291999526322,0.950900999829173),    //267
    BP2_CONST6(-1.34752199985086,1.77669099904596,-0.774838999845087,1.95789599977433,0.145091999322176,1.2616590000689),    //268
    BP2_CONST6(0.643584999255836,0.615699999965727,0.771205999888479,0.414222999475896,0.890442999079823,0.20824300032109),    //269
    BP2_CONST6(-0.112687999382615,1.52240499854087,0.292899999767542,1.09064999967813,0.674295999109745,0.568815000355243),    //270
    BP2_CONST6(-0.917137999087572,1.99364099837839,-0.292899999767542,1.67644999921321,0.402212999761105,0.953598999418318),    //271
    BP2_CONST6(-1.34553199913352,1.78089699894189,-0.771205999888479,1.95663499925285,0.147249999456108,1.25927700009196),    //272
    BP2_CONST6(0.637782999314367,0.62445000000298,0.767564999870955,0.420223999768496,0.888756999745965,0.211294000037014),    //273
    BP2_CONST6(-0.106198999099433,1.51641899906098,0.297142999246716,1.08550100028514,0.676201999187469,0.565873000770807),    //274
    BP2_CONST6(-0.922081999480724,1.9943529991433,-0.297142999246716,1.67978799901902,0.400132999755442,0.956294000148773),    //275
    BP2_CONST6(-1.34351499937474,1.78506799880415,-0.767565999180078,1.95535499881953,0.149407999590039,1.25689100008457),    //276
    BP2_CONST6(0.631967999972403,0.633186999708414,0.763917999342083,0.426219999790192,0.887067999690771,0.214344999752939),    //277
    BP2_CONST6(-0.0997089995071292,1.510402998887,0.301382999867201,1.08034299965947,0.678105999715626,0.562930000014603),    //278
    BP2_CONST6(-0.927006999962031,1.99502299912273,-0.301382999867201,1.68310999963432,0.398051999509335,0.958987000398337),    //279
    BP2_CONST6(-1.34146799985319,1.78919899929314,-0.763917999342083,1.95405599847435,0.151564999483526,1.25450299959629),    //280
    BP2_CONST6(0.626138999126851,0.641911000013351,0.760262999683618,0.43221400026232,0.885376999154686,0.21739500015974),    //281
    BP2_CONST6(-0.0932159991934896,1.50435399916023,0.305620999075472,1.0751740001142,0.680008999072015,0.559986000880599),    //282
    BP2_CONST6(-0.931911999359726,1.99565099924802,-0.305620999075472,1.68641599826514,0.395968999713659,0.961678999476134),    //283
    BP2_CONST6(-1.33939399942755,1.79329299926757,-0.760262999683618,1.95273999962955,0.153720999136567,1.25211300048977),    //284
    BP2_CONST6(0.620296999812126,0.650620999746024,0.756600999273359,0.4382020002231,0.88368499930948,0.220444000326097),    //285
    BP2_CONST6(-0.0867209993302822,1.49827299918979,0.309855999425054,1.06999500002712,0.681910999119281,0.557039000093936),    //286
    BP2_CONST6(-0.936796999536454,1.99623599927872,-0.309855999425054,1.68970699887722,0.393885999917984,0.964367999695241),    //287
    BP2_CONST6(-1.33729099947959,1.79734899941831,-0.756600999273359,1.95140399876981,0.155877999961376,1.24971899949014),    //288
    BP2_CONST6(0.614441999234259,0.659316999837756,0.752931999973952,0.444186999462545,0.88198999967426,0.223492999561131),    //289
    BP2_CONST6(-0.0802239999175072,1.49215999990701,0.314087999984622,1.06480599939823,0.683809999376535,0.554093000479042),    //290
    BP2_CONST6(-0.941662999801337,1.99677999969571,-0.314087999984622,1.69298199936747,0.391801999881864,0.967054999433457),    //291
    BP2_CONST6(-1.33515899907797,1.80136699881404,-0.752931999973952,1.95005099941045,0.158033999614418,1.24732199963182),    //292
    BP2_CONST6(0.608572999946773,0.667999999597668,0.749254999682307,0.450167999602854,0.88029299955815,0.226541999727488),    //293
    BP2_CONST6(-0.0737249990925193,1.48601499851793,0.318316999822855,1.05960700009018,0.685708999633789,0.551142999902367),    //294
    BP2_CONST6(-0.946507999673485,1.99727999884635,-0.318316999822855,1.69624099973589,0.389716999605298,0.969739000312983),    //295
    BP2_CONST6(-1.33299999963492,1.8053469993174,-0.749254999682307,1.94867799896746,0.160188999958336,1.24492299929261),    //296
    BP2_CONST6(0.60269199963659,0.676667999476194,0.745571999810636,0.45614399947226,0.878593999892473,0.229589999653399),    //297
    BP2_CONST6(-0.0672249998897314,1.47983999922871,0.322542999871075,1.054397999309,0.687604999169707,0.54819400049746),    //298
    BP2_CONST6(-0.951333999633789,1.9977389993146,-0.322542999871075,1.69948399905115,0.387631999328732,0.972420000471174),    //299
    BP2_CONST6(-1.33081199973821,1.80928799882531,-0.745571999810636,1.94728799909353,0.162344999611378,1.24251999985426),    //300
    BP2_CONST6(0.596797999925911,0.685321999713778,0.741881999187171,0.462116000242531,0.876892999745905,0.23263799957931),    //301
    BP2_CONST6(-0.0607239995151758,1.47363299876451,0.326764999888837,1.0491800000891,0.689499999396502,0.54524299968034),    //302
    BP2_CONST6(-0.956139999441802,1.99815599899739,-0.326764999888837,1.70270999986678,0.385544999502599,0.97510000038892),    //303
    BP2_CONST6(-1.3285959996283,1.81319199874997,-0.741881999187171,1.94587999861687,0.164498999714851,1.24011499993503),    //304
    BP2_CONST6(0.590891999192535,0.693961000069975,0.738183999434113,0.468084000051022,0.875189999118447,0.235683999955654),    //305
    BP2_CONST6(-0.0542209995910525,1.46739499922841,0.330984999425709,1.04395100008696,0.691392999142408,0.54229100048542),    //306
    BP2_CONST6(-0.960924999788403,1.9985299995169,-0.330984999425709,1.70592099893838,0.383456999436021,0.977777999825775),    //307
    BP2_CONST6(-1.32635199930518,1.81705599930137,-0.738184999674558,1.94445399940013,0.166653999127448,1.23770599998533),    //308
    BP2_CONST6(0.584972999989986,0.702584999613463,0.734479999169707,0.474047000519931,0.873484999872744,0.23873099964112),    //309
    BP2_CONST6(-0.0477169994264841,1.46112499851733,0.335201999172568,1.03871200047433,0.693284999579191,0.539335999637842),    //310
    BP2_CONST6(-0.965688999742269,1.9988609990105,-0.335201999172568,1.70911599881947,0.381368999369442,0.98045300040394),    //311
    BP2_CONST6(-1.32407999970018,1.8208829993382,-0.734479999169707,1.94300699885934,0.168807999230921,1.23529500048607),    //312
    BP2_CONST6(0.579040999524295,0.711195000447332,0.73076899908483,0.480006000027061,0.871777999214828,0.241776000708342),    //313
    BP2_CONST6(-0.0412119999527931,1.45482499990612,0.339414999820292,1.03346399962902,0.695174999535083,0.536381999962031),    //314
    BP2_CONST6(-0.97043399978429,1.99915099889039,-0.339414999820292,1.7122939992696,0.379278999753296,0.983125999569892),    //315
    BP2_CONST6(-1.32177899964153,1.82466999907046,-0.73076899908483,1.94154399819672,0.170961999334395,1.23288000002503),    //316
    BP2_CONST6(0.573097999207675,0.719790000468492,0.727050999179482,0.485960000194609,0.870068999938666,0.244820999912918),    //317
    BP2_CONST6(-0.0347069995477796,1.44849399942904,0.343625999987125,1.0282049998641,0.697062999941408,0.533425999805331),    //318
    BP2_CONST6(-0.975157999433577,1.9993979986757,-0.343625999987125,1.71545699983835,0.377188999205828,0.985795999877154),    //319
    BP2_CONST6(-1.31945099961012,1.82841999921947,-0.727050999179482,1.94006299879401,0.173114999197423,1.23046300001442),    //320
    BP2_CONST6(0.567141999490559,0.72836900036782,0.723325999453663,0.4919100003317,0.868357999250292,0.247866000048816),    //321
    BP2_CONST6(-0.0281999995931983,1.44213199894875,0.347832999192178,1.02293700072914,0.698949999175965,0.530468000099062),    //322
    BP2_CONST6(-0.97986099962145,1.99960299953818,-0.347832999192178,1.71860399842262,0.375097999349236,0.988464000634849),    //323
    BP2_CONST6(-1.3170949993655,1.8321299990639,-0.723325999453663,1.93856199923902,0.175267999991775,1.22804299928247),    //324
    BP2_CONST6(0.561173999682068,0.736932999454438,0.719593999907374,0.49785599950701,0.866643999703228,0.25090999994427),    //325
    BP2_CONST6(-0.021692999638617,1.435739999637,0.352036999538541,1.0176600003615,0.700834999792277,0.527509000152349),    //326
    BP2_CONST6(-0.984542999416589,1.9997639991343,-0.352036999538541,1.72173399943858,0.373004999943078,0.991130999289453),    //327
    BP2_CONST6(-1.31470999959856,1.8358009988442,-0.719593999907374,1.93704399932175,0.177419999614358,1.22561999969184),    //328
    BP2_CONST6(0.555193999782204,0.745481999590992,0.715855999849736,0.503796000033617,0.864928999915719,0.253952999599278),    //329
    BP2_CONST6(-0.0151849994435906,1.42931699939072,0.356236999854445,1.01237399969249,0.702717999927699,0.524549999274313),    //330
    BP2_CONST6(-0.989204999990761,1.99988499935716,-0.356236999854445,1.72484799940139,0.370911999605596,0.993795000016689),    //331
    BP2_CONST6(-1.31229899916797,1.83943499904125,-0.715855999849736,1.93550799973309,0.179571999236941,1.22319400031119),    //332
    BP2_CONST6(0.549202999100089,0.754015000537037,0.712110999971628,0.509730999357998,0.863211999647319,0.256996000185609),    //333
    BP2_CONST6(-0.00867799948900938,1.42286499869078,0.360433999449015,1.00707700010389,0.704599999822676,0.521588999778032),    //334
    BP2_CONST6(-0.993844999931752,1.99996199924498,-0.360433999449015,1.72794499900192,0.368818999268115,0.996455000713467),    //335
    BP2_CONST6(-1.30985899921506,1.84302799869328,-0.712110999971628,1.93395299930125,0.181723999790847,1.22076499927788),    //336
    BP2_CONST6(0.543199999257922,0.762531000189483,0.708358999341726,0.515662000514566,0.861491999588906,0.260038999840617),    //337
    BP2_CONST6(-0.00216899998486042,1.41638099960982,0.364627999253571,1.00177100021392,0.706479999236762,0.518626000732183),    //338
    BP2_CONST6(-0.998464999720454,1.9999979995191,-0.364627999253571,1.73102699872106,0.366723999381065,0.999114000238478),    //339
    BP2_CONST6(-1.30739199928939,1.84658299852162,-0.708358999341726,1.93237999919801,0.183874999172986,1.21833400055766),    //340
    BP2_CONST6(0.537184999324381,0.771031999960541,0.704599999822676,0.521588999778032,0.859770999290049,0.263079999946058),    //341
    BP2_CONST6(0.0043389992788434,1.40986800007522,0.368817999958992,0.99645600002259,0.708358999341726,0.515662000514566),    //342
    BP2_CONST6(-1.00306299980729,1.99998999945819,-0.368818999268115,1.73409299924969,0.364627999253571,1.00177100021392),    //343
    BP2_CONST6(-1.30489599984139,1.8500979989767,-0.704599999822676,1.93078899942338,0.186025999486446,1.21589899994432),    //344
    BP2_CONST6(0.531158999539911,0.779516999609768,0.700834999792277,0.527509999461472,0.858046999201178,0.266122000291944),    //345
    BP2_CONST6(0.0108469994738698,1.40332499984651,0.373004999943078,0.991130999289453,0.710235999897122,0.512697000056505),    //346
    BP2_CONST6(-1.00764099974185,1.99994199909269,-0.3730059992522,1.73714199848473,0.362531999126077,1.00442500039935),    //347
    BP2_CONST6(-1.30237399972975,1.85357499960809,-0.700834999792277,1.92917999904602,0.188175999559462,1.21346199978142),    //348
    BP2_CONST6(0.525121999904513,0.787983999587595,0.697062999941408,0.533425999805331,0.856321999803185,0.269160999916494),    //349
    BP2_CONST6(0.0173539994284511,1.39675300009548,0.377188999205828,0.985795999877154,0.712110999971628,0.509730999357998),    //350
    BP2_CONST6(-1.0121959997341,1.99984899908304,-0.377188999205828,1.74017399828881,0.360433999449015,1.00707700010389),    //351
    BP2_CONST6(-1.2998239994049,1.85701299924403,-0.697062999941408,1.92755199968814,0.190325999632478,1.21102199982851),    //352
    BP2_CONST6(0.519072999246418,0.796436000615358,0.693284999579191,0.539336999878287,0.854593999683856,0.272202000021935),    //353
    BP2_CONST6(0.0238619996234775,1.39015000034123,0.381368999369442,0.98045300040394,0.713983999565243,0.506764000281691),    //354
    BP2_CONST6(-1.01673099957406,1.9997159987688,-0.381368999369442,1.74319099914282,0.358335999771953,1.00972699932754),    //355
    BP2_CONST6(-1.29724599979817,1.86041099950671,-0.693284999579191,1.92590699903666,0.192474999465048,1.20857900008559),    //356
    BP2_CONST6(0.513013999909162,0.804868999868631,0.689499999396502,0.54524299968034,0.852864999324083,0.275240000337362),    //357
    BP2_CONST6(0.0303689995780587,1.38351800013333,0.385544999502599,0.97510000038892,0.715855999849736,0.503796000033617),    //358
    BP2_CONST6(-1.02124399971216,1.99953899905085,-0.385544999502599,1.74618999939411,0.356236999854445,1.01237399969249),    //359
    BP2_CONST6(-1.29463999997824,1.8637689994648,-0.689499999396502,1.92424299847334,0.194623999297619,1.20613399986177),    //360
    BP2_CONST6(0.506943999789655,0.813285999931395,0.685708999633789,0.551142999902367,0.851132999174296,0.278278999961913),    //361
    BP2_CONST6(0.0368749992921948,1.37685800064355,0.389716999605298,0.969739000312983,0.717725999653339,0.500826000235974),    //362
    BP2_CONST6(-1.02573499921709,1.99931999854743,-0.389717999845743,1.74917399976402,0.354136999696493,1.01501899957656),    //363
    BP2_CONST6(-1.29200699925422,1.86708699911832,-0.685708999633789,1.92256099916994,0.196772999130189,1.20368400029838),    //364
    BP2_CONST6(0.500862999819219,0.821685999631881,0.681910999119281,0.557039000093936,0.849399999715387,0.281316000036895),    //365
    BP2_CONST6(0.0433809999376535,1.3701669992879,0.393885999917984,0.964367999695241,0.719593999907374,0.49785599950701),    //366
    BP2_CONST6(-1.0302049992606,1.99905999843031,-0.393885999917984,1.7521399995312,0.352036999538541,1.0176600003615),    //367
    BP2_CONST6(-1.28934699948877,1.87036699894815,-0.681910999119281,1.9208609983325,0.198920999653637,1.20123299956321),    //368
    BP2_CONST6(0.494770999997854,0.830068999901413,0.678106999956071,0.562928999774158,0.847663999535143,0.284354000352323),    //369
    BP2_CONST6(0.0498849991708994,1.36344900075346,0.398051999509335,0.958987000398337,0.721460999920964,0.494882999919355),    //370
    BP2_CONST6(-1.03465199936181,1.99875599890947,-0.398051999509335,1.755090999417,0.349934999831021,1.02030099928379),    //371
    BP2_CONST6(-1.28665999975055,1.87360799964517,-0.678106999956071,1.91914399992674,0.20106799993664,1.19877899996936),    //372
    BP2_CONST6(0.488668999634683,0.838433999568223,0.674295999109745,0.568815000355243,0.845926999114453,0.287390000186861),    //373
    BP2_CONST6(0.0563889993354678,1.35670000035315,0.402212999761105,0.953598000109195,0.723325999453663,0.4919100003317),    //374
    BP2_CONST6(-1.03907799907028,1.99840999860316,-0.402212999761105,1.75802499894052,0.347832999192178,1.02293800003826),    //375
    BP2_CONST6(-1.28394499979913,1.87680699955672,-0.674295999109745,1.91740699857473,0.203215999528766,1.19632100034505),    //376
    BP2_CONST6(0.482556999661028,0.846780999563634,0.670478999614715,0.574694999493658,0.844186999835073,0.290426000021398),    //377
    BP2_CONST6(0.0628909999504685,1.34992299973964,0.406370999291539,0.948200000450015,0.725188999436795,0.4889360005036),    //378
    BP2_CONST6(-1.04348099976778,1.99802099913358,-0.406370999291539,1.76094199903309,0.345729999244213,1.02557300031185),    //379
    BP2_CONST6(-1.28120299987494,1.87996799964457,-0.670478999614715,1.91565299872308,0.205361999571323,1.19386199954897),    //380
    BP2_CONST6(0.476433999836445,0.855109999887645,0.666655999608337,0.58056899998337,0.842445999383926,0.293461000546813),    //381
    BP2_CONST6(0.0693919993937016,1.34311799984425,0.410523999482393,0.942793999798595,0.727050999179482,0.485961000435054),    //382
    BP2_CONST6(-1.04786299914121,1.99759099911898,-0.410524999722838,1.76384299900382,0.343625999987125,1.0282049998641),    //383
    BP2_CONST6(-1.278433999978,1.88308899942785,-0.666655999608337,1.91388099920004,0.207507999613881,1.19139899965375),    //384
    BP2_CONST6(0.470300999470055,0.863421999849379,0.662825999781489,0.586438000202178,0.840702999383211,0.29649499990046),    //385
    BP2_CONST6(0.075891999527812,1.33628400042653,0.414673999883235,0.937377999536693,0.728910999372601,0.482983999885619),    //386
    BP2_CONST6(-1.05222299974411,1.99711899925023,-0.414673999883235,1.76672599930316,0.34152099955827,1.03083600010722),    //387
    BP2_CONST6(-1.27563799917697,1.8861689986661,-0.662825999781489,1.91209099907428,0.209653999656439,1.18893299996852),    //388
    BP2_CONST6(0.464158999733627,0.871713999658823,0.658989999443292,0.592302000150084,0.838956999592483,0.29952900018543),    //389
    BP2_CONST6(0.0823899991810322,1.32942100055515,0.41882099956274,0.931951999664306,0.73076899908483,0.480006000027061),    //390
    BP2_CONST6(-1.05655999947339,1.99660299904644,-0.41882099956274,1.76959499903023,0.339415999129415,1.03346300031989),    //391
    BP2_CONST6(-1.27281499933451,1.88920999877154,-0.658989999443292,1.91028199903666,0.211798999458551,1.18646499980241),    //392
    BP2_CONST6(0.458005999214947,0.879989000037312,0.65514799952507,0.598159999586641,0.837209999561309,0.302562000229955),    //393
    BP2_CONST6(0.0888859992846847,1.32253100071102,0.422962999902666,0.926518999971449,0.732624999247491,0.477028000168502),    //394
    BP2_CONST6(-1.06087499950081,1.99604599922895,-0.422962999902666,1.77244499977678,0.337308999150991,1.03608900029212),    //395
    BP2_CONST6(-1.26996499951928,1.89221099950373,-0.65514799952507,1.90845599863678,0.213943999260664,1.18399300053715),    //396
    BP2_CONST6(0.451843999326229,0.888244000263512,0.651299999095499,0.604012000374495,0.835459999740123,0.305594999343157),    //397
    BP2_CONST6(0.0953799998387694,1.3156139999628,0.42710099928081,0.921076999977231,0.734479999169707,0.474048000760376),    //398
    BP2_CONST6(-1.06516699958592,1.99544599931687,-0.42710099928081,1.77527999877929,0.335201999172568,1.03871200047433),    //399
    BP2_CONST6(-1.2670879997313,1.89517199900001,-0.651299999095499,1.90661199856549,0.216087999753654,1.18151899985969),    //400
    BP2_CONST6(0.445671999827027,0.896482000127434,0.647445999085903,0.609858000651001,0.833708999678492,0.308625999838114),    //401
    BP2_CONST6(0.101871999911964,1.30866799969226,0.43123499955982,0.915626999922096,0.736332999542355,0.471065999940038),    //402
    BP2_CONST6(-1.06943699996918,1.99480499979108,-0.43123499955982,1.77809699904173,0.333093999885023,1.04133299924433),    //403
    BP2_CONST6(-1.26418399997055,1.89809199981391,-0.647445999085903,1.9047499988228,0.218231999315321,1.17904200032353),    //404
    BP2_CONST6(0.439490999095142,0.904699000529944,0.643584999255836,0.615699000656604,0.831955999135971,0.311657000333071),    //405
    BP2_CONST6(0.108361999504268,1.30169400013983,0.435364999808371,0.910166999325156,0.738183999434113,0.468084000051022),    //406
    BP2_CONST6(-1.07368399947881,1.99411999899893,-0.435364999808371,1.78089699894189,0.330984999425709,1.04395100008696),    //407
    BP2_CONST6(-1.26125299930572,1.90097199846059,-0.643584999255836,1.90286999847739,0.220374999567866,1.17656300030648),    //408
    BP2_CONST6(0.433300999924541,0.91289799939841,0.639718999154865,0.621534000150859,0.830199999734759,0.31468699965626),    //409
    BP2_CONST6(0.114849999547005,1.29469200037419,0.439490999095142,0.904699000529944,0.740033999085426,0.465101000852883),    //410
    BP2_CONST6(-1.07790899928659,1.99339499883353,-0.439490999095142,1.78368099872022,0.328875999897718,1.04656599927693),    //411
    BP2_CONST6(-1.2582959998399,1.9038129998371,-0.639718999154865,1.90097199846059,0.222516999579966,1.1740809995681),    //412
    BP2_CONST6(0.42710099928081,0.921076999977231,0.635845999233424,0.627364000305533,0.828442999161779,0.317716999910772),    //413
    BP2_CONST6(0.121335999108851,1.2876630006358,0.443612999282777,0.899222999811172,0.741881999187171,0.462116000242531),    //414
    BP2_CONST6(-1.08210999984294,1.99262499902397,-0.443612999282777,1.78644899837672,0.32676599919796,1.04917900077998),    //415
    BP2_CONST6(-1.25531199946999,1.90661199856549,-0.635845999233424,1.89905599877238,0.224658999592066,1.17159599997103),    //416
    BP2_CONST6(0.420891999267042,0.929237000644207,0.631967999972403,0.633186999708414,0.826683999970555,0.320744999684393),    //417
    BP2_CONST6(0.127817999571562,1.28060800023376,0.447730999439955,0.893737000413239,0.743727999739348,0.45913099963218),    //418
    BP2_CONST6(-1.08628899976611,1.99181499890983,-0.447730999439955,1.78919899929314,0.324653999879956,1.05179099924862),    //419
    BP2_CONST6(-1.25230099912732,1.90937099885195,-0.631967999972403,1.89712299965322,0.226800999604166,1.16910799965262),    //420
    BP2_CONST6(0.414673999883235,0.937377999536693,0.628082999959588,0.639003999531269,0.824922999367117,0.323773000389338),    //421
    BP2_CONST6(0.134298999793828,1.27352300006896,0.451843999326229,0.888244000263512,0.745571999810636,0.45614399947226),    //422
    BP2_CONST6(-1.09044399950653,1.99096099939197,-0.451843999326229,1.79193199891597,0.322542999871075,1.054397999309),    //423
    BP2_CONST6(-1.24926399998366,1.91208999976515,-0.628082999959588,1.89517099969089,0.22894199937582,1.16661700047552),    //424
    BP2_CONST6(0.408447999507189,0.945497999899089,0.624192999675869,0.644816000014543,0.823159999214112,0.326799999922514),    //425
    BP2_CONST6(0.140775999985635,1.26641299948096,0.455952999182045,0.882743000052869,0.747414999641478,0.453156000003219),    //426
    BP2_CONST6(-1.09457699954509,1.99006699863821,-0.455952999182045,1.79464899841696,0.320429999381304,1.05700400006026),    //427
    BP2_CONST6(-1.24620099924504,1.91476899851113,-0.624192999675869,1.89320199936628,0.231082999147475,1.16412300057709),    //428
    BP2_CONST6(0.402212999761105,0.953598000109195,0.620296999812126,0.650620999746024,0.821394999511539,0.329826000146568),    //429
    BP2_CONST6(0.147249999456108,1.25927700009196,0.460057999938726,0.877232999540865,0.749254999682307,0.450167999602854),    //430
    BP2_CONST6(-1.09868599940091,1.98912899848073,-0.460057999938726,1.79734899941831,0.318316999822855,1.05960700009018),    //431
    BP2_CONST6(-1.24311099946498,1.91740699857473,-0.620296999812126,1.89121499937027,0.233221999369562,1.16162800043821),    //432
    BP2_CONST6(0.395968999713659,0.961678999476134,0.616394999437034,0.65641999989748,0.819627999328076,0.332852000370622),    //433
    BP2_CONST6(0.153720999136567,1.25211300048977,0.464158999733627,0.871713999658823,0.751093999482691,0.447177999652922),    //434
    BP2_CONST6(-1.10277199931442,1.98814999870955,-0.464158999733627,1.80003199912607,0.316202999092638,1.06220800057053),    //435
    BP2_CONST6(-1.23999499995261,1.92000499926507,-0.616394999437034,1.88920999877154,0.235361999832094,1.15912899933755),    //436
    BP2_CONST6(0.389716999605298,0.969738000072538,0.612486999481916,0.662212000228464,0.817858999595046,0.33587700035423),    //437
    BP2_CONST6(0.160188999958336,1.24492299929261,0.468254999257624,0.866187999956309,0.752931999973952,0.444186999462545),    //438
    BP2_CONST6(-1.10683499928563,1.98712799884378,-0.468254999257624,1.80269799847155,0.314087999984622,1.06480599939823),    //439
    BP2_CONST6(-1.23685199953615,1.92256099916994,-0.612486999481916,1.88718699943274,0.237500999122858,1.15662700030952),    //440
    BP2_CONST6(0.383456999436021,0.977777999825775,0.608572999946773,0.667999999597668,0.816087999381124,0.338901000097394),    //441
    BP2_CONST6(0.166653999127448,1.23770599998533,0.472346999682486,0.860652999952435,0.754766999743878,0.44119600020349),    //442
    BP2_CONST6(-1.1108739990741,1.98606399819254,-0.472346999682486,1.8053469993174,0.311971999704838,1.06740199960768),    //443
    BP2_CONST6(-1.23368399962782,1.92507799901068,-0.608572999946773,1.88514599949121,0.2396389991045,1.1541230008006),    //444
    BP2_CONST6(0.377188999205828,0.985795999877154,0.604653999209403,0.673780000768601,0.814315999858081,0.341923999600112),    //445
    BP2_CONST6(0.173114999197423,1.23046300001442,0.476433999836445,0.855109999887645,0.756600999273359,0.4382020002231),    //446
    BP2_CONST6(-1.11488999985158,1.98495899979025,-0.476433999836445,1.80797799956053,0.309855999425054,1.06999500002712),    //447
    BP2_CONST6(-1.23048899974673,1.92755299899727,-0.604653999209403,1.8830879991874,0.241776999086142,1.15161600057035),    //448
    BP2_CONST6(0.370911999605596,0.993793999776244,0.600728999823331,0.679553999565541,0.812540999613702,0.344945999793708),    //449
    BP2_CONST6(0.179571999236941,1.22319400031119,0.480516999959946,0.849558999761939,0.758432999253273,0.43520800024271),    //450
    BP2_CONST6(-1.11888199951499,1.98381099943071,-0.480516999959946,1.81059299968183,0.307738999836147,1.07258599996566),    //451
    BP2_CONST6(-1.22726799920201,1.92998699843883,-0.600728999823331,1.8810119992122,0.243913999758661,1.14910599961876),    //452
    BP2_CONST6(0.364627999253571,1.00177100021392,0.596797999925911,0.685321999713778,0.810764999128878,0.347967000678182),    //453
    BP2_CONST6(0.186025999486446,1.21589899994432,0.484594999812543,0.844000999815762,0.760262999683618,0.43221400026232),    //454
    BP2_CONST6(-1.1228509992361,1.98262199852615,-0.484594999812543,1.81319099944084,0.305620999075472,1.0751740001142),    //455
    BP2_CONST6(-1.22402099985629,1.93237999919801,-0.596797999925911,1.8789179995656,0.246049999259412,1.14659500028938),    //456
    BP2_CONST6(0.358335999771953,1.00972600001841,0.592861999757587,0.691083000041544,0.808985999785363,0.350988999940455),    //457
    BP2_CONST6(0.192474999465048,1.20857900008559,0.488668999634683,0.838433999568223,0.762090999633073,0.42921799980104),    //458
    BP2_CONST6(-1.12679599970579,1.98138999938964,-0.488668999634683,1.81577199883759,0.30350299924612,1.07776000071316),    //459
    BP2_CONST6(-1.22074799984693,1.93473199941217,-0.592861999757587,1.87680699955672,0.248185999691486,1.14407999999821),    //460
    BP2_CONST6(0.352036999538541,1.0176600003615,0.588919999077916,0.696838000789284,0.807205999270081,0.354008000344038),    //461
    BP2_CONST6(0.198920999653637,1.20123299956321,0.49273799918592,0.832860000431537,0.763917999342083,0.426219999790192),    //462
    BP2_CONST6(-1.13071699999272,1.98011699970811,-0.49273799918592,1.81833599880337,0.301382999867201,1.08034399989992),    //463
    BP2_CONST6(-1.21744999941438,1.93704499863088,-0.588919999077916,1.87467799894511,0.250321999192238,1.1415610006079),    //464
    BP2_CONST6(0.345729999244213,1.0255720000714,0.584972999989986,0.702584999613463,0.805423999205231,0.357027000747621),    //465
    BP2_CONST6(0.205361999571323,1.19386100023984,0.496802999638021,0.827277000062167,0.765742999501526,0.423221999779344),    //466
    BP2_CONST6(-1.13461299985647,1.97880099900066,-0.496802999638021,1.8208829993382,0.299263999797404,1.08292299974709),    //467
    BP2_CONST6(-1.21412499994039,1.93931499961763,-0.584972999989986,1.87253099959343,0.252456999383867,1.13904100004583),    //468
    BP2_CONST6(0.339414999820292,1.03346399962902,0.581019999459385,0.708327000029385,0.803638999350368,0.360046000219882),    //469
    BP2_CONST6(0.211798999458551,1.18646400049328,0.500862999819219,0.821685999631881,0.767564999870955,0.420223999768496),    //470
    BP2_CONST6(-1.13848599977791,1.97744299937039,-0.500862999819219,1.82341199927031,0.297142999246716,1.08550200052559),    //471
    BP2_CONST6(-1.21077499911189,1.94154399819672,-0.581019999459385,1.87036699894815,0.254590999335051,1.13651800062507),    //472
    BP2_CONST6(0.333093999885023,1.0413319999352,0.577061999589204,0.714061999693512,0.801852999255061,0.363064000383019),    //473
    BP2_CONST6(0.218230999074876,1.17904300056397,0.504917999729514,0.816087999381124,0.769386999309062,0.417222999967635),    //474
    BP2_CONST6(-1.1423349995166,1.97604399919509,-0.504917999729514,1.82592499908059,0.295021999627352,1.0880770003423),    //475
    BP2_CONST6(-1.20739899948239,1.94373299926519,-0.577061999589204,1.86818599887192,0.256724999286234,1.13399200048297),    //476
    BP2_CONST6(0.32676599919796,1.04917900077998,0.573097999207675,0.719790000468492,0.80006599985063,0.366078999824822),    //477
    BP2_CONST6(0.224658999592066,1.17159599997103,0.508967999368906,0.810483000241219,0.771205999888479,0.414222999475896),    //478
    BP2_CONST6(-1.14615999907255,1.97460299823433,-0.508968999609351,1.82841999921947,0.292899999767542,1.09064999967813),    //479
    BP2_CONST6(-1.2039979994297,1.94587999861687,-0.573097999207675,1.86598599888384,0.258857999928296,1.13146299961954),    //480
    BP2_CONST6(0.320429999381304,1.05700400006026,0.569128999486565,0.725511000491678,0.798275999724864,0.36909499950707),    //481
    BP2_CONST6(0.231081999838352,1.16412399988621,0.513013999909162,0.804868999868631,0.773022999987006,0.41122099943459),    //482
    BP2_CONST6(-1.14995999913662,1.97311999835073,-0.513013999909162,1.83089699968695,0.290776999667287,1.09322000015527),    //483
    BP2_CONST6(-1.20057099964469,1.94798599928617,-0.569128999486565,1.8637689994648,0.260989999398589,1.12893200013786),    //484
    BP2_CONST6(0.314087999984622,1.06480599939823,0.565153999254107,0.731226000003516,0.796483999118208,0.372110000811517),    //485
    BP2_CONST6(0.237500999122858,1.15662700030952,0.517054999247193,0.799248000606894,0.774838999845087,0.408218000084162),    //486
    BP2_CONST6(-1.15373599994927,1.97159499954432,-0.517054999247193,1.83335799910128,0.288653999567032,1.09578800015151),    //487
    BP2_CONST6(-1.19711899943649,1.95005099941045,-0.565153999254107,1.86153399851173,0.263121999800205,1.12639799993485),    //488
    BP2_CONST6(0.307738999836147,1.07258599996566,0.561173999682068,0.736933999694883,0.79469099920243,0.375124000012875),    //489
    BP2_CONST6(0.243913999758661,1.14910699985921,0.521090999245643,0.793620000593364,0.776652999222278,0.405214000493288),    //490
    BP2_CONST6(-1.15748799964785,1.97002899926155,-0.521090999245643,1.83580199908465,0.286529999226332,1.09835300035774),    //491
    BP2_CONST6(-1.19364199973642,1.9520749989897,-0.561173999682068,1.85928199905902,0.265252999961376,1.12386199925094),    //492
    BP2_CONST6(0.301383999176323,1.0803430005908,0.557188999839127,0.742633999325335,0.792894999496638,0.378138000145555),    //493
    BP2_CONST6(0.250321999192238,1.1415610006079,0.525121999904513,0.787983999587595,0.778464999981224,0.402208999730647),    //494
    BP2_CONST6(-1.16121499985456,1.96842099912464,-0.525121999904513,1.83822799939662,0.284404999576509,1.10091600008308),    //495
    BP2_CONST6(-1.19013899937272,1.9540569987148,-0.557188999839127,1.85701299924403,0.267383999191225,1.12132300063967),    //496
    BP2_CONST6(0.295021999627352,1.0880770003423,0.553198999725282,0.74832799937576,0.791097999550402,0.381148999556899),    //497
    BP2_CONST6(0.256723999977112,1.13399299979209,0.529147999361157,0.782341000624001,0.780274999327957,0.399203999899328),    //498
    BP2_CONST6(-1.16491699963808,1.96677099913358,-0.529147999361157,1.84063699934631,0.282279999926686,1.10347600001841),    //499
    BP2_CONST6(-1.18661099951714,1.9559979988262,-0.553197999484837,1.85472499858587,0.269512999802828,1.11878199968487),    //500
    BP2_CONST6(0.288653999567032,1.09578800015151,0.549202999100089,0.754015000537037,0.789298999123275,0.384161000140011),    //501
    BP2_CONST6(0.263121999800205,1.12639799993485,0.53316899947822,0.776689999736845,0.782083999365568,0.396196000277996),    //502
    BP2_CONST6(-1.16859399992972,1.96507799904793,-0.53316899947822,1.84302799869328,0.280152999795973,1.10603399947285),    //503
    BP2_CONST6(-1.18305699992924,1.95789599977433,-0.549202999100089,1.85242099873721,0.271642999723554,1.11623699963092),    //504
    BP2_CONST6(0.282279999926686,1.10347499977797,0.545201999135315,0.759694000706076,0.78749799914658,0.387171000242233),    //505
    BP2_CONST6(0.269512999802828,1.11878199968487,0.537184999324381,0.771031999960541,0.783889999613165,0.393188999965787),    //506
    BP2_CONST6(-1.17224799934774,1.96334599889814,-0.537184999324381,1.8454019986093,0.278026999905705,1.10858799982815),    //507
    BP2_CONST6(-1.17947899922728,1.95975499879568,-0.545201999135315,1.85009899828583,0.273770999163389,1.11369100026786),    //508
    BP2_CONST6(0.275898999534547,1.11114099994301,0.541195999830961,0.765366999432444,0.785694999620318,0.390181000344455),    //509
    BP2_CONST6(0.275898999534547,1.11114099994301,0.541195999830961,0.765366999432444,0.785694999620318,0.390181000344455),    //510
    BP2_CONST6(-1.17587599996477,1.96157099958509,-0.541195999830961,1.84775899909436,0.275898999534547,1.11114099994301),    //511
    BP2_CONST6(-1.17587599996477,1.96157099958509,-0.541195999830961,1.84775899909436,0.275898999534547,1.11114099994301)     //512
};

#elif !defined(PLATFORM_LPC_DIRECT)

//#pragma COMPILER_MESSAGE(__FILE__ "(559) : Warning - constants for MARCs LPC")

// TODO: rebuild lpc_const3 and lpc_const4 from first principles - LPC is sensitive and this does not generate as good precision as PLATFORM_LPC_DIRECT

#define BP2_CONST4(a,b,c,d) BP2_FROM_FLOAT(a),BP2_FROM_FLOAT(b),BP2_FROM_FLOAT(c),BP2_FROM_FLOAT(d)

// the following takes 2kb and will get loaded in the cache during prvLpcToSpectrum
const BP2Type lpc_cnst3[] = {
BP2_CONST4(1.000000,1.000000,-1.000000,-1.000000),      // previously was 0,0,0,0,
BP2_CONST4(1.012196,1.006117,-0.987653,-0.993845),
BP2_CONST4(1.024240,1.012196,-0.975158,-0.987653),
BP2_CONST4(1.036130,1.018237,-0.962515,-0.981424),
BP2_CONST4(1.047863,1.024240,-0.949728,-0.975158),
BP2_CONST4(1.059439,1.030204,-0.936797,-0.968855),
BP2_CONST4(1.070855,1.036130,-0.923726,-0.962515),
BP2_CONST4(1.082110,1.042016,-0.910515,-0.956140),
BP2_CONST4(1.093202,1.047863,-0.897168,-0.949728),
BP2_CONST4(1.104129,1.053671,-0.883685,-0.943280),
BP2_CONST4(1.114890,1.059439,-0.870069,-0.936797),
BP2_CONST4(1.125483,1.065167,-0.856322,-0.930279),
BP2_CONST4(1.135907,1.070855,-0.842446,-0.923726),
BP2_CONST4(1.146160,1.076503,-0.828443,-0.917138),
BP2_CONST4(1.156240,1.082110,-0.814316,-0.910515),
BP2_CONST4(1.166145,1.087676,-0.800066,-0.903858),
BP2_CONST4(1.175876,1.093202,-0.785695,-0.897168),
BP2_CONST4(1.185429,1.098686,-0.771206,-0.890443),
BP2_CONST4(1.194803,1.104129,-0.756601,-0.883685),
BP2_CONST4(1.203998,1.109531,-0.741882,-0.876893),
BP2_CONST4(1.213011,1.114890,-0.727051,-0.870069),
BP2_CONST4(1.221842,1.120208,-0.712111,-0.863212),
BP2_CONST4(1.230489,1.125483,-0.697063,-0.856322),
BP2_CONST4(1.238950,1.130716,-0.681911,-0.849400),
BP2_CONST4(1.247225,1.135907,-0.666656,-0.842446),
BP2_CONST4(1.255312,1.141055,-0.651300,-0.835460),
BP2_CONST4(1.263210,1.146160,-0.635846,-0.828443),
BP2_CONST4(1.270918,1.151221,-0.620297,-0.821395),
BP2_CONST4(1.278434,1.156240,-0.604654,-0.814316),
BP2_CONST4(1.285758,1.161214,-0.588920,-0.807206),
BP2_CONST4(1.292888,1.166145,-0.573098,-0.800066),
BP2_CONST4(1.299823,1.171033,-0.557189,-0.792895),
BP2_CONST4(1.306563,1.175876,-0.541196,-0.785695),
BP2_CONST4(1.313106,1.180674,-0.525122,-0.778465),
BP2_CONST4(1.319451,1.185429,-0.508968,-0.771206),
BP2_CONST4(1.325598,1.190138,-0.492738,-0.763918),
BP2_CONST4(1.331544,1.194803,-0.476434,-0.756601),
BP2_CONST4(1.337291,1.199423,-0.460058,-0.749255),
BP2_CONST4(1.342836,1.203998,-0.443613,-0.741882),
BP2_CONST4(1.348178,1.208528,-0.427101,-0.734480),
BP2_CONST4(1.353318,1.213012,-0.410524,-0.727051),
BP2_CONST4(1.358254,1.217450,-0.393886,-0.719594),
BP2_CONST4(1.362985,1.221842,-0.377189,-0.712111),
BP2_CONST4(1.367511,1.226189,-0.360434,-0.704600),
BP2_CONST4(1.371831,1.230489,-0.343626,-0.697063),
BP2_CONST4(1.375945,1.234743,-0.326765,-0.689500),
BP2_CONST4(1.379851,1.238950,-0.309856,-0.681911),
BP2_CONST4(1.383550,1.243111,-0.292900,-0.674296),
BP2_CONST4(1.387040,1.247225,-0.275899,-0.666656),
BP2_CONST4(1.390321,1.251292,-0.258857,-0.658990),
BP2_CONST4(1.393393,1.255312,-0.241777,-0.651300),
BP2_CONST4(1.396255,1.259285,-0.224659,-0.643585),
BP2_CONST4(1.398907,1.263210,-0.207508,-0.635846),
BP2_CONST4(1.401348,1.267088,-0.190326,-0.628083),
BP2_CONST4(1.403578,1.270918,-0.173115,-0.620297),
BP2_CONST4(1.405597,1.274700,-0.155878,-0.612487),
BP2_CONST4(1.407404,1.278434,-0.138617,-0.604654),
BP2_CONST4(1.408999,1.282120,-0.121336,-0.596798),
BP2_CONST4(1.410382,1.285758,-0.104036,-0.588920),
BP2_CONST4(1.411552,1.289347,-0.086721,-0.581020),
BP2_CONST4(1.412510,1.292888,-0.069392,-0.573098),
BP2_CONST4(1.413255,1.296380,-0.052053,-0.565154),
BP2_CONST4(1.413788,1.299823,-0.034706,-0.557189),
BP2_CONST4(1.414107,1.303218,-0.017355,-0.549203),
BP2_CONST4(1.414214,1.306563, 0.000000,-0.541196),
BP2_CONST4(1.414107,1.309859, 0.017355,-0.533169),
BP2_CONST4(1.413788,1.313106, 0.034707,-0.525122),
BP2_CONST4(1.413255,1.316303, 0.052053,-0.517055),
BP2_CONST4(1.412510,1.319451, 0.069392,-0.508968),
BP2_CONST4(1.411552,1.322549, 0.086721,-0.500863),
BP2_CONST4(1.410382,1.325598, 0.104036,-0.492738),
BP2_CONST4(1.408999,1.328596, 0.121336,-0.484595),
BP2_CONST4(1.407404,1.331544, 0.138617,-0.476434),
BP2_CONST4(1.405597,1.334443, 0.155878,-0.468255),
BP2_CONST4(1.403578,1.337291, 0.173115,-0.460058),
BP2_CONST4(1.401348,1.340088, 0.190326,-0.451844),
BP2_CONST4(1.398907,1.342836, 0.207508,-0.443613),
BP2_CONST4(1.396255,1.345532, 0.224659,-0.435365),
BP2_CONST4(1.393393,1.348178, 0.241777,-0.427101),
BP2_CONST4(1.390321,1.350774, 0.258857,-0.418821),
BP2_CONST4(1.387040,1.353318, 0.275899,-0.410525),
BP2_CONST4(1.383550,1.355812, 0.292900,-0.402213),
BP2_CONST4(1.379851,1.358254, 0.309856,-0.393886),
BP2_CONST4(1.375945,1.360645, 0.326765,-0.385545),
BP2_CONST4(1.371831,1.362985, 0.343626,-0.377189),
BP2_CONST4(1.367511,1.365274, 0.360434,-0.368819),
BP2_CONST4(1.362985,1.367511, 0.377189,-0.360434),
BP2_CONST4(1.358254,1.369697, 0.393886,-0.352037),
BP2_CONST4(1.353318,1.371831, 0.410525,-0.343626),
BP2_CONST4(1.348179,1.373914, 0.427101,-0.335202),
BP2_CONST4(1.342836,1.375945, 0.443613,-0.326766),
BP2_CONST4(1.337291,1.377924, 0.460058,-0.318317),
BP2_CONST4(1.331544,1.379851, 0.476434,-0.309856),
BP2_CONST4(1.325598,1.381727, 0.492738,-0.301383),
BP2_CONST4(1.319451,1.383550, 0.508969,-0.292900),
BP2_CONST4(1.313106,1.385321, 0.525122,-0.284405),
BP2_CONST4(1.306563,1.387040, 0.541196,-0.275899),
BP2_CONST4(1.299824,1.388707, 0.557189,-0.267384),
BP2_CONST4(1.292888,1.390321, 0.573098,-0.258858),
BP2_CONST4(1.285758,1.391883, 0.588920,-0.250322),
BP2_CONST4(1.278434,1.393393, 0.604654,-0.241777),
BP2_CONST4(1.270918,1.394850, 0.620297,-0.233222),
BP2_CONST4(1.263210,1.396255, 0.635846,-0.224659),
BP2_CONST4(1.255312,1.397607, 0.651300,-0.216088),
BP2_CONST4(1.247225,1.398907, 0.666656,-0.207508),
BP2_CONST4(1.238950,1.400154, 0.681911,-0.198921),
BP2_CONST4(1.230489,1.401348, 0.697063,-0.190326),
BP2_CONST4(1.221842,1.402489, 0.712111,-0.181724),
BP2_CONST4(1.213012,1.403578, 0.727051,-0.173115),
BP2_CONST4(1.203998,1.404614, 0.741882,-0.164499),
BP2_CONST4(1.194803,1.405597, 0.756601,-0.155878),
BP2_CONST4(1.185429,1.406527, 0.771206,-0.147250),
BP2_CONST4(1.175876,1.407404, 0.785695,-0.138617),
BP2_CONST4(1.166146,1.408228, 0.800066,-0.129979),
BP2_CONST4(1.156240,1.408999, 0.814316,-0.121336),
BP2_CONST4(1.146160,1.409717, 0.828443,-0.112688),
BP2_CONST4(1.135907,1.410382, 0.842446,-0.104036),
BP2_CONST4(1.125484,1.410994, 0.856322,-0.095380),
BP2_CONST4(1.114890,1.411552, 0.870069,-0.086721),
BP2_CONST4(1.104129,1.412058, 0.883685,-0.078058),
BP2_CONST4(1.093202,1.412510, 0.897168,-0.069392),
BP2_CONST4(1.082110,1.412909, 0.910515,-0.060724),
BP2_CONST4(1.070855,1.413255, 0.923726,-0.052053),
BP2_CONST4(1.059439,1.413548, 0.936797,-0.043381),
BP2_CONST4(1.047863,1.413788, 0.949728,-0.034707),
BP2_CONST4(1.036130,1.413974, 0.962515,-0.026031),
BP2_CONST4(1.024240,1.414107, 0.975158,-0.017355),
BP2_CONST4(1.012196,1.414187, 0.987653,-0.008677),
BP2_CONST4(1.000000,1.414213, 1.000000, 0.000000),  
0,0,0,0
};

#define BP2_CONST6(a,b,c,d,e,f) BP2_FROM_FLOAT(a),BP2_FROM_FLOAT(b),BP2_FROM_FLOAT(c), \
                                BP2_FROM_FLOAT(d),BP2_FROM_FLOAT(e),BP2_FROM_FLOAT(f)

// the following takes 12kb and will get loaded in the cache during prvLpcToSpectrum
const BP2Type lpc_cnst4[] = {
BP2_CONST6(1.000000,1.000000,1.000000,1.000000,1.000000,1.000000),   // previously 0,0,0,0,0,0,
BP2_CONST6(0.995387,1.004591,0.996927,1.003063,0.998465,1.001533),
BP2_CONST6(0.990754,1.009161,0.993845,1.006117,0.996927,1.003063),
BP2_CONST6(0.986099,1.013710,0.990754,1.009161,0.995387,1.004591),
BP2_CONST6(0.981424,1.018237,0.987653,1.012196,0.993845,1.006117),
BP2_CONST6(0.976727,1.022743,0.984543,1.015221,0.992301,1.007640),
BP2_CONST6(0.972010,1.027227,0.981424,1.018237,0.990754,1.009161),
BP2_CONST6(0.967273,1.031689,0.978295,1.021243,0.989205,1.010680),
BP2_CONST6(0.962515,1.036130,0.975158,1.024240,0.987653,1.012196),
BP2_CONST6(0.957737,1.040548,0.972011,1.027227,0.986099,1.013710),
BP2_CONST6(0.952938,1.044944,0.968854,1.030204,0.984543,1.015221),
BP2_CONST6(0.948119,1.049319,0.965689,1.033172,0.982985,1.016731),
BP2_CONST6(0.943280,1.053671,0.962515,1.036130,0.981424,1.018237),
BP2_CONST6(0.938421,1.058001,0.959332,1.039078,0.979861,1.019742),
BP2_CONST6(0.933542,1.062308,0.956139,1.042016,0.978295,1.021243),
BP2_CONST6(0.928644,1.066593,0.952938,1.044944,0.976728,1.022743),
BP2_CONST6(0.923726,1.070855,0.949728,1.047863,0.975158,1.024240),
BP2_CONST6(0.918788,1.075094,0.946508,1.050772,0.973585,1.025735),
BP2_CONST6(0.913831,1.079311,0.943280,1.053671,0.972011,1.027227),
BP2_CONST6(0.908854,1.083505,0.940043,1.056560,0.970434,1.028717),
BP2_CONST6(0.903858,1.087676,0.936797,1.059439,0.968855,1.030204),
BP2_CONST6(0.898843,1.091824,0.933543,1.062308,0.967273,1.031689),
BP2_CONST6(0.893809,1.095949,0.930279,1.065167,0.965689,1.033172),
BP2_CONST6(0.888757,1.100051,0.927007,1.068016,0.964103,1.034652),
BP2_CONST6(0.883685,1.104129,0.923726,1.070855,0.962515,1.036130),
BP2_CONST6(0.878594,1.108184,0.920436,1.073684,0.960925,1.037605),
BP2_CONST6(0.873485,1.112215,0.917138,1.076503,0.959332,1.039078),
BP2_CONST6(0.868358,1.116224,0.913831,1.079311,0.957737,1.040548),
BP2_CONST6(0.863212,1.120208,0.910515,1.082110,0.956140,1.042016),
BP2_CONST6(0.858047,1.124168,0.907191,1.084898,0.954540,1.043481),
BP2_CONST6(0.852865,1.128105,0.903858,1.087676,0.952938,1.044944),
BP2_CONST6(0.847664,1.132018,0.900517,1.090444,0.951334,1.046405),
BP2_CONST6(0.842446,1.135907,0.897168,1.093202,0.949728,1.047863),
BP2_CONST6(0.837210,1.139772,0.893809,1.095949,0.948119,1.049319),
BP2_CONST6(0.831956,1.143612,0.890443,1.098686,0.946508,1.050772),
BP2_CONST6(0.826684,1.147429,0.887068,1.101413,0.944896,1.052223),
BP2_CONST6(0.821395,1.151221,0.883685,1.104129,0.943280,1.053671),
BP2_CONST6(0.816088,1.154989,0.880293,1.106835,0.941663,1.055117),
BP2_CONST6(0.810765,1.158732,0.876893,1.109530,0.940043,1.056560),
BP2_CONST6(0.805424,1.162451,0.873485,1.112216,0.938421,1.058001),
BP2_CONST6(0.800066,1.166146,0.870069,1.114890,0.936797,1.059439),
BP2_CONST6(0.794691,1.169815,0.866644,1.117554,0.935171,1.060875),
BP2_CONST6(0.789299,1.173460,0.863212,1.120208,0.933543,1.062308),
BP2_CONST6(0.783890,1.177080,0.859771,1.122851,0.931912,1.063739),
BP2_CONST6(0.778465,1.180675,0.856322,1.125483,0.930279,1.065167),
BP2_CONST6(0.773024,1.184244,0.852865,1.128105,0.928644,1.066593),
BP2_CONST6(0.767565,1.187789,0.849400,1.130716,0.927007,1.068016),
BP2_CONST6(0.762091,1.191309,0.845927,1.133317,0.925367,1.069437),
BP2_CONST6(0.756601,1.194803,0.842446,1.135907,0.923726,1.070855),
BP2_CONST6(0.751094,1.198272,0.838957,1.138486,0.922082,1.072271),
BP2_CONST6(0.745572,1.201716,0.835460,1.141055,0.920436,1.073684),
BP2_CONST6(0.740034,1.205135,0.831956,1.143613,0.918788,1.075095),
BP2_CONST6(0.734480,1.208527,0.828443,1.146160,0.917138,1.076503),
BP2_CONST6(0.728911,1.211895,0.824923,1.148696,0.915485,1.077908),
BP2_CONST6(0.723326,1.215236,0.821395,1.151221,0.913831,1.079311),
BP2_CONST6(0.717726,1.218552,0.817859,1.153736,0.912174,1.080712),
BP2_CONST6(0.712111,1.221842,0.814316,1.156240,0.910515,1.082110),
BP2_CONST6(0.706480,1.225106,0.810765,1.158732,0.908854,1.083505),
BP2_CONST6(0.700835,1.228344,0.807206,1.161214,0.907191,1.084898),
BP2_CONST6(0.695175,1.231557,0.803639,1.163685,0.905526,1.086289),
BP2_CONST6(0.689500,1.234743,0.800066,1.166145,0.903858,1.087676),
BP2_CONST6(0.683811,1.237903,0.796484,1.168594,0.902189,1.089062),
BP2_CONST6(0.678106,1.241036,0.792895,1.171032,0.900517,1.090444),
BP2_CONST6(0.672388,1.244144,0.789299,1.173460,0.898843,1.091824),
BP2_CONST6(0.666656,1.247225,0.785695,1.175876,0.897168,1.093202),
BP2_CONST6(0.660909,1.250280,0.782084,1.178281,0.895490,1.094577),
BP2_CONST6(0.655148,1.253308,0.778465,1.180674,0.893809,1.095949),
BP2_CONST6(0.649374,1.256310,0.774839,1.183057,0.892127,1.097319),
BP2_CONST6(0.643585,1.259285,0.771206,1.185429,0.890443,1.098686),
BP2_CONST6(0.637783,1.262233,0.767565,1.187789,0.888757,1.100051),
BP2_CONST6(0.631968,1.265155,0.763918,1.190138,0.887068,1.101413),
BP2_CONST6(0.626139,1.268050,0.760263,1.192477,0.885377,1.102772),
BP2_CONST6(0.620297,1.270918,0.756601,1.194803,0.883685,1.104129),
BP2_CONST6(0.614442,1.273759,0.752932,1.197119,0.881990,1.105483),
BP2_CONST6(0.608573,1.276573,0.749255,1.199423,0.880293,1.106835),
BP2_CONST6(0.602692,1.279360,0.745572,1.201716,0.878594,1.108184),
BP2_CONST6(0.596798,1.282120,0.741882,1.203998,0.876893,1.109531),
BP2_CONST6(0.590892,1.284853,0.738184,1.206268,0.875190,1.110874),
BP2_CONST6(0.584973,1.287558,0.734480,1.208527,0.873485,1.112216),
BP2_CONST6(0.579041,1.290236,0.730769,1.210775,0.871778,1.113554),
BP2_CONST6(0.573098,1.292888,0.727051,1.213011,0.870069,1.114890),
BP2_CONST6(0.567142,1.295511,0.723326,1.215236,0.868358,1.116224),
BP2_CONST6(0.561174,1.298107,0.719594,1.217450,0.866644,1.117554),
BP2_CONST6(0.555194,1.300676,0.715856,1.219652,0.864929,1.118882),
BP2_CONST6(0.549203,1.303218,0.712111,1.221842,0.863212,1.120208),
BP2_CONST6(0.543200,1.305731,0.708359,1.224021,0.861492,1.121531),
BP2_CONST6(0.537185,1.308217,0.704600,1.226189,0.859771,1.122851),
BP2_CONST6(0.531159,1.310676,0.700835,1.228345,0.858047,1.124169),
BP2_CONST6(0.525122,1.313106,0.697063,1.230489,0.856322,1.125483),
BP2_CONST6(0.519073,1.315509,0.693285,1.232622,0.854594,1.126796),
BP2_CONST6(0.513014,1.317883,0.689500,1.234743,0.852865,1.128105),
BP2_CONST6(0.506944,1.320230,0.685709,1.236852,0.851133,1.129412),
BP2_CONST6(0.500863,1.322549,0.681911,1.238950,0.849400,1.130716),
BP2_CONST6(0.494771,1.324840,0.678107,1.241036,0.847664,1.132018),
BP2_CONST6(0.488669,1.327103,0.674296,1.243111,0.845927,1.133317),
BP2_CONST6(0.482557,1.329338,0.670479,1.245174,0.844187,1.134613),
BP2_CONST6(0.476434,1.331544,0.666656,1.247225,0.842446,1.135907),
BP2_CONST6(0.470301,1.333723,0.662826,1.249264,0.840703,1.137198),
BP2_CONST6(0.464159,1.335873,0.658990,1.251292,0.838957,1.138486),
BP2_CONST6(0.458006,1.337995,0.655148,1.253308,0.837210,1.139772),
BP2_CONST6(0.451844,1.340088,0.651300,1.255312,0.835460,1.141055),
BP2_CONST6(0.445672,1.342154,0.647446,1.257304,0.833709,1.142335),
BP2_CONST6(0.439491,1.344190,0.643585,1.259284,0.831956,1.143613),
BP2_CONST6(0.433301,1.346199,0.639719,1.261253,0.830200,1.144887),
BP2_CONST6(0.427101,1.348178,0.635846,1.263210,0.828443,1.146160),
BP2_CONST6(0.420892,1.350129,0.631968,1.265155,0.826684,1.147429),
BP2_CONST6(0.414674,1.352052,0.628083,1.267087,0.824923,1.148696),
BP2_CONST6(0.408448,1.353946,0.624193,1.269009,0.823160,1.149960),
BP2_CONST6(0.402213,1.355811,0.620297,1.270918,0.821395,1.151221),
BP2_CONST6(0.395969,1.357648,0.616395,1.272815,0.819628,1.152480),
BP2_CONST6(0.389717,1.359455,0.612487,1.274699,0.817859,1.153736),
BP2_CONST6(0.383457,1.361235,0.608573,1.276573,0.816088,1.154989),
BP2_CONST6(0.377189,1.362985,0.604654,1.278434,0.814316,1.156240),
BP2_CONST6(0.370912,1.364706,0.600729,1.280283,0.812541,1.157487),
BP2_CONST6(0.364628,1.366399,0.596798,1.282120,0.810765,1.158732),
BP2_CONST6(0.358336,1.368062,0.592862,1.283945,0.808986,1.159975),
BP2_CONST6(0.352037,1.369697,0.588920,1.285758,0.807206,1.161214),
BP2_CONST6(0.345730,1.371302,0.584973,1.287558,0.805424,1.162451),
BP2_CONST6(0.339415,1.372879,0.581020,1.289347,0.803639,1.163685),
BP2_CONST6(0.333094,1.374426,0.577062,1.291124,0.801853,1.164917),
BP2_CONST6(0.326766,1.375945,0.573098,1.292888,0.800066,1.166145),
BP2_CONST6(0.320430,1.377434,0.569129,1.294640,0.798276,1.167371),
BP2_CONST6(0.314088,1.378894,0.565154,1.296380,0.796484,1.168594),
BP2_CONST6(0.307739,1.380325,0.561174,1.298108,0.794691,1.169815),
BP2_CONST6(0.301384,1.381727,0.557189,1.299823,0.792895,1.171033),
BP2_CONST6(0.295022,1.383099,0.553199,1.301527,0.791098,1.172247),
BP2_CONST6(0.288654,1.384442,0.549203,1.303218,0.789299,1.173460),
BP2_CONST6(0.282280,1.385755,0.545202,1.304896,0.787498,1.174669),
BP2_CONST6(0.275899,1.387040,0.541196,1.306563,0.785695,1.175876),
BP2_CONST6(0.269513,1.388295,0.537185,1.308217,0.783890,1.177079),
BP2_CONST6(0.263122,1.389520,0.533169,1.309859,0.782084,1.178280),
BP2_CONST6(0.256724,1.390717,0.529148,1.311489,0.780275,1.179479),
BP2_CONST6(0.250322,1.391883,0.525122,1.313106,0.778465,1.180674),
BP2_CONST6(0.243914,1.393021,0.521091,1.314711,0.776653,1.181867),
BP2_CONST6(0.237501,1.394128,0.517055,1.316303,0.774839,1.183057),
BP2_CONST6(0.231082,1.395206,0.513014,1.317883,0.773023,1.184244),
BP2_CONST6(0.224659,1.396255,0.508968,1.319451,0.771206,1.185429),
BP2_CONST6(0.218231,1.397274,0.504918,1.321006,0.769387,1.186610),
BP2_CONST6(0.211799,1.398263,0.500863,1.322549,0.767565,1.187789),
BP2_CONST6(0.205362,1.399223,0.496803,1.324080,0.765743,1.188965),
BP2_CONST6(0.198921,1.400154,0.492738,1.325598,0.763918,1.190138),
BP2_CONST6(0.192475,1.401054,0.488669,1.327103,0.762091,1.191309),
BP2_CONST6(0.186026,1.401925,0.484595,1.328596,0.760263,1.192477),
BP2_CONST6(0.179572,1.402766,0.480517,1.330076,0.758433,1.193641),
BP2_CONST6(0.173115,1.403578,0.476434,1.331544,0.756601,1.194803),
BP2_CONST6(0.166654,1.404360,0.472347,1.333000,0.754767,1.195963),
BP2_CONST6(0.160189,1.405112,0.468255,1.334443,0.752932,1.197119),
BP2_CONST6(0.153721,1.405834,0.464159,1.335873,0.751094,1.198272),
BP2_CONST6(0.147250,1.406527,0.460058,1.337291,0.749255,1.199423),
BP2_CONST6(0.140776,1.407189,0.455953,1.338696,0.747415,1.200571),
BP2_CONST6(0.134299,1.407822,0.451844,1.340088,0.745572,1.201716),
BP2_CONST6(0.127818,1.408426,0.447731,1.341468,0.743728,1.202859),
BP2_CONST6(0.121336,1.408999,0.443613,1.342836,0.741882,1.203998),
BP2_CONST6(0.114850,1.409542,0.439491,1.344190,0.740034,1.205135),
BP2_CONST6(0.108362,1.410056,0.435365,1.345532,0.738184,1.206268),
BP2_CONST6(0.101872,1.410540,0.431235,1.346862,0.736333,1.207399),
BP2_CONST6(0.095380,1.410994,0.427101,1.348178,0.734480,1.208528),
BP2_CONST6(0.088886,1.411417,0.422963,1.349482,0.732625,1.209653),
BP2_CONST6(0.082390,1.411811,0.418821,1.350773,0.730769,1.210775),
BP2_CONST6(0.075892,1.412176,0.414674,1.352052,0.728911,1.211895),
BP2_CONST6(0.069392,1.412510,0.410524,1.353318,0.727051,1.213012),
BP2_CONST6(0.062891,1.412814,0.406371,1.354571,0.725189,1.214125),
BP2_CONST6(0.056389,1.413089,0.402213,1.355811,0.723326,1.215236),
BP2_CONST6(0.049885,1.413334,0.398052,1.357039,0.721461,1.216344),
BP2_CONST6(0.043381,1.413548,0.393886,1.358254,0.719594,1.217450),
BP2_CONST6(0.036875,1.413733,0.389717,1.359456,0.717726,1.218552),
BP2_CONST6(0.030369,1.413887,0.385545,1.360645,0.715856,1.219652),
BP2_CONST6(0.023862,1.414012,0.381369,1.361822,0.713984,1.220748),
BP2_CONST6(0.017354,1.414107,0.377189,1.362985,0.712111,1.221842),
BP2_CONST6(0.010847,1.414172,0.373005,1.364136,0.710236,1.222933),
BP2_CONST6(0.004339,1.414207,0.368818,1.365274,0.708359,1.224021),
BP2_CONST6(-0.002169,1.414212,0.364628,1.366399,0.706480,1.225106),
BP2_CONST6(-0.008678,1.414187,0.360434,1.367511,0.704600,1.226189),
BP2_CONST6(-0.015185,1.414132,0.356237,1.368611,0.702718,1.227268),
BP2_CONST6(-0.021693,1.414047,0.352037,1.369697,0.700835,1.228344),
BP2_CONST6(-0.028200,1.413932,0.347833,1.370770,0.698950,1.229418),
BP2_CONST6(-0.034707,1.413787,0.343626,1.371831,0.697063,1.230489),
BP2_CONST6(-0.041212,1.413613,0.339415,1.372879,0.695175,1.231557),
BP2_CONST6(-0.047717,1.413408,0.335202,1.373914,0.693285,1.232621),
BP2_CONST6(-0.054221,1.413174,0.330985,1.374936,0.691393,1.233684),
BP2_CONST6(-0.060724,1.412909,0.326765,1.375945,0.689500,1.234743),
BP2_CONST6(-0.067225,1.412615,0.322543,1.376941,0.687605,1.235799),
BP2_CONST6(-0.073725,1.412290,0.318317,1.377924,0.685709,1.236852),
BP2_CONST6(-0.080224,1.411936,0.314088,1.378894,0.683810,1.237903),
BP2_CONST6(-0.086721,1.411552,0.309856,1.379851,0.681911,1.238950),
BP2_CONST6(-0.093216,1.411138,0.305621,1.380795,0.680009,1.239995),
BP2_CONST6(-0.099709,1.410694,0.301383,1.381726,0.678106,1.241036),
BP2_CONST6(-0.106199,1.410220,0.297143,1.382644,0.676202,1.242075),
BP2_CONST6(-0.112688,1.409717,0.292900,1.383550,0.674296,1.243111),
BP2_CONST6(-0.119174,1.409183,0.288654,1.384442,0.672388,1.244144),
BP2_CONST6(-0.125658,1.408620,0.284405,1.385321,0.670479,1.245174),
BP2_CONST6(-0.132139,1.408027,0.280153,1.386187,0.668568,1.246201),
BP2_CONST6(-0.138617,1.407404,0.275899,1.387040,0.666656,1.247225),
BP2_CONST6(-0.145093,1.406751,0.271643,1.387880,0.664742,1.248246),
BP2_CONST6(-0.151565,1.406068,0.267383,1.388706,0.662826,1.249264),
BP2_CONST6(-0.158034,1.405356,0.263122,1.389520,0.660909,1.250280),
BP2_CONST6(-0.164500,1.404614,0.258857,1.390321,0.658990,1.251292),
BP2_CONST6(-0.170962,1.403842,0.254591,1.391109,0.657070,1.252301),
BP2_CONST6(-0.177420,1.403040,0.250322,1.391883,0.655148,1.253308),
BP2_CONST6(-0.183875,1.402209,0.246050,1.392645,0.653225,1.254311),
BP2_CONST6(-0.190326,1.401348,0.241777,1.393393,0.651300,1.255312),
BP2_CONST6(-0.196773,1.400457,0.237501,1.394128,0.649374,1.256310),
BP2_CONST6(-0.203216,1.399537,0.233222,1.394850,0.647446,1.257304),
BP2_CONST6(-0.209654,1.398587,0.228942,1.395559,0.645516,1.258296),
BP2_CONST6(-0.216088,1.397607,0.224659,1.396255,0.643585,1.259285),
BP2_CONST6(-0.222517,1.396598,0.220375,1.396937,0.641653,1.260270),
BP2_CONST6(-0.228942,1.395559,0.216088,1.397607,0.639719,1.261253),
BP2_CONST6(-0.235362,1.394490,0.211799,1.398263,0.637783,1.262233),
BP2_CONST6(-0.241777,1.393393,0.207508,1.398907,0.635846,1.263210),
BP2_CONST6(-0.248187,1.392265,0.203215,1.399537,0.633908,1.264184),
BP2_CONST6(-0.254591,1.391108,0.198921,1.400153,0.631968,1.265155),
BP2_CONST6(-0.260990,1.389922,0.194624,1.400757,0.630026,1.266123),
BP2_CONST6(-0.267384,1.388706,0.190326,1.401348,0.628083,1.267088),
BP2_CONST6(-0.273771,1.387461,0.186026,1.401925,0.626139,1.268049),
BP2_CONST6(-0.280154,1.386186,0.181724,1.402489,0.624193,1.269009),
BP2_CONST6(-0.286530,1.384883,0.177420,1.403040,0.622246,1.269965),
BP2_CONST6(-0.292900,1.383550,0.173115,1.403578,0.620297,1.270918),
BP2_CONST6(-0.299264,1.382187,0.168808,1.404102,0.618347,1.271868),
BP2_CONST6(-0.305621,1.380795,0.164499,1.404614,0.616395,1.272815),
BP2_CONST6(-0.311972,1.379374,0.160189,1.405112,0.614442,1.273759),
BP2_CONST6(-0.318317,1.377924,0.155878,1.405597,0.612487,1.274700),
BP2_CONST6(-0.324655,1.376444,0.151565,1.406068,0.610531,1.275638),
BP2_CONST6(-0.330985,1.374936,0.147250,1.406527,0.608573,1.276573),
BP2_CONST6(-0.337309,1.373398,0.142934,1.406972,0.606615,1.277505),
BP2_CONST6(-0.343626,1.371831,0.138617,1.407404,0.604654,1.278434),
BP2_CONST6(-0.349935,1.370235,0.134299,1.407822,0.602692,1.279360),
BP2_CONST6(-0.356237,1.368610,0.129979,1.408228,0.600729,1.280283),
BP2_CONST6(-0.362532,1.366957,0.125658,1.408620,0.598765,1.281203),
BP2_CONST6(-0.368819,1.365274,0.121336,1.408999,0.596798,1.282120),
BP2_CONST6(-0.375098,1.363562,0.117012,1.409364,0.594831,1.283034),
BP2_CONST6(-0.381369,1.361821,0.112688,1.409717,0.592862,1.283945),
BP2_CONST6(-0.387632,1.360052,0.108363,1.410056,0.590892,1.284853),
BP2_CONST6(-0.393886,1.358254,0.104036,1.410382,0.588920,1.285758),
BP2_CONST6(-0.400133,1.356427,0.099709,1.410694,0.586947,1.286660),
BP2_CONST6(-0.406371,1.354571,0.095380,1.410993,0.584973,1.287558),
BP2_CONST6(-0.412600,1.352687,0.091051,1.411279,0.582997,1.288454),
BP2_CONST6(-0.418821,1.350774,0.086721,1.411552,0.581020,1.289347),
BP2_CONST6(-0.425032,1.348832,0.082390,1.411811,0.579041,1.290237),
BP2_CONST6(-0.431235,1.346861,0.078058,1.412057,0.577062,1.291123),
BP2_CONST6(-0.437429,1.344863,0.073725,1.412290,0.575080,1.292007),
BP2_CONST6(-0.443613,1.342835,0.069392,1.412510,0.573098,1.292888),
BP2_CONST6(-0.449788,1.340780,0.065058,1.412716,0.571114,1.293765),
BP2_CONST6(-0.455953,1.338695,0.060724,1.412909,0.569128,1.294640),
BP2_CONST6(-0.462109,1.336583,0.056389,1.413089,0.567142,1.295511),
BP2_CONST6(-0.468255,1.334443,0.052053,1.413255,0.565154,1.296380),
BP2_CONST6(-0.474391,1.332273,0.047717,1.413408,0.563165,1.297245),
BP2_CONST6(-0.480517,1.330076,0.043381,1.413548,0.561174,1.298108),
BP2_CONST6(-0.486633,1.327851,0.039044,1.413674,0.559182,1.298967),
BP2_CONST6(-0.492738,1.325598,0.034706,1.413788,0.557189,1.299823),
BP2_CONST6(-0.498834,1.323316,0.030369,1.413887,0.555194,1.300676),
BP2_CONST6(-0.504918,1.321006,0.026031,1.413974,0.553198,1.301527),
BP2_CONST6(-0.510992,1.318669,0.021693,1.414047,0.551201,1.302374),
BP2_CONST6(-0.517055,1.316303,0.017355,1.414107,0.549203,1.303218),
BP2_CONST6(-0.523107,1.313910,0.013016,1.414154,0.547203,1.304059),
BP2_CONST6(-0.529148,1.311488,0.008677,1.414187,0.545202,1.304896),
BP2_CONST6(-0.535178,1.309039,0.004339,1.414207,0.543200,1.305731),
BP2_CONST6(-0.541196,1.306563,-0.000000,1.414214,0.541196,1.306563),
BP2_CONST6(-0.547203,1.304058,-0.004339,1.414207,0.539191,1.307392),
BP2_CONST6(-0.553198,1.301526,-0.008677,1.414187,0.537185,1.308217),
BP2_CONST6(-0.559182,1.298967,-0.013016,1.414154,0.535178,1.309040),
BP2_CONST6(-0.565154,1.296380,-0.017355,1.414107,0.533169,1.309859),
BP2_CONST6(-0.571114,1.293765,-0.021693,1.414047,0.531159,1.310675),
BP2_CONST6(-0.577061,1.291123,-0.026031,1.413974,0.529148,1.311489),
BP2_CONST6(-0.582997,1.288454,-0.030369,1.413887,0.527135,1.312299),
BP2_CONST6(-0.588920,1.285758,-0.034707,1.413788,0.525122,1.313106),
BP2_CONST6(-0.594831,1.283034,-0.039044,1.413675,0.523107,1.313910),
BP2_CONST6(-0.600729,1.280283,-0.043381,1.413548,0.521091,1.314711),
BP2_CONST6(-0.606615,1.277505,-0.047717,1.413408,0.519073,1.315509),
BP2_CONST6(-0.612487,1.274700,-0.052053,1.413255,0.517055,1.316303),
BP2_CONST6(-0.618347,1.271868,-0.056389,1.413089,0.515035,1.317095),
BP2_CONST6(-0.624193,1.269008,-0.060724,1.412909,0.513014,1.317883),
BP2_CONST6(-0.630027,1.266122,-0.065058,1.412716,0.510992,1.318669),
BP2_CONST6(-0.635846,1.263210,-0.069392,1.412510,0.508968,1.319451),
BP2_CONST6(-0.641653,1.260270,-0.073725,1.412290,0.506944,1.320230),
BP2_CONST6(-0.647446,1.257304,-0.078058,1.412058,0.504918,1.321006),
BP2_CONST6(-0.653225,1.254311,-0.082390,1.411811,0.502891,1.321779),
BP2_CONST6(-0.658990,1.251292,-0.086721,1.411552,0.500863,1.322549),
BP2_CONST6(-0.664742,1.248246,-0.091051,1.411280,0.498834,1.323316),
BP2_CONST6(-0.670479,1.245174,-0.095380,1.410993,0.496803,1.324080),
BP2_CONST6(-0.676202,1.242075,-0.099709,1.410694,0.494771,1.324840),
BP2_CONST6(-0.681911,1.238950,-0.104036,1.410382,0.492738,1.325598),
BP2_CONST6(-0.687605,1.235799,-0.108363,1.410056,0.490704,1.326352),
BP2_CONST6(-0.693285,1.232621,-0.112688,1.409717,0.488669,1.327103),
BP2_CONST6(-0.698950,1.229418,-0.117012,1.409364,0.486633,1.327851),
BP2_CONST6(-0.704600,1.226189,-0.121336,1.408999,0.484595,1.328596),
BP2_CONST6(-0.710236,1.222933,-0.125658,1.408620,0.482557,1.329338),
BP2_CONST6(-0.715856,1.219652,-0.129979,1.408228,0.480517,1.330076),
BP2_CONST6(-0.721461,1.216345,-0.134299,1.407822,0.478476,1.330812),
BP2_CONST6(-0.727051,1.213012,-0.138617,1.407404,0.476434,1.331544),
BP2_CONST6(-0.732626,1.209653,-0.142934,1.406972,0.474391,1.332274),
BP2_CONST6(-0.738185,1.206268,-0.147250,1.406527,0.472347,1.333000),
BP2_CONST6(-0.743728,1.202859,-0.151565,1.406068,0.470301,1.333723),
BP2_CONST6(-0.749256,1.199423,-0.155878,1.405597,0.468255,1.334443),
BP2_CONST6(-0.754767,1.195963,-0.160189,1.405112,0.466207,1.335159),
BP2_CONST6(-0.760263,1.192477,-0.164499,1.404614,0.464159,1.335873),
BP2_CONST6(-0.765743,1.188965,-0.168808,1.404103,0.462109,1.336583),
BP2_CONST6(-0.771206,1.185429,-0.173115,1.403578,0.460058,1.337291),
BP2_CONST6(-0.776653,1.181867,-0.177420,1.403040,0.458006,1.337995),
BP2_CONST6(-0.782084,1.178280,-0.181724,1.402489,0.455953,1.338696),
BP2_CONST6(-0.787498,1.174669,-0.186026,1.401925,0.453899,1.339394),
BP2_CONST6(-0.792895,1.171033,-0.190326,1.401348,0.451844,1.340088),
BP2_CONST6(-0.798276,1.167371,-0.194624,1.400757,0.449788,1.340780),
BP2_CONST6(-0.803639,1.163685,-0.198921,1.400154,0.447731,1.341468),
BP2_CONST6(-0.808986,1.159975,-0.203215,1.399537,0.445672,1.342154),
BP2_CONST6(-0.814316,1.156240,-0.207508,1.398907,0.443613,1.342836),
BP2_CONST6(-0.819628,1.152480,-0.211799,1.398264,0.441553,1.343515),
BP2_CONST6(-0.824923,1.148696,-0.216088,1.397607,0.439491,1.344190),
BP2_CONST6(-0.830201,1.144887,-0.220375,1.396938,0.437429,1.344863),
BP2_CONST6(-0.835460,1.141055,-0.224659,1.396255,0.435365,1.345532),
BP2_CONST6(-0.840703,1.137198,-0.228942,1.395559,0.433301,1.346199),
BP2_CONST6(-0.845927,1.133317,-0.233222,1.394850,0.431235,1.346862),
BP2_CONST6(-0.851134,1.129412,-0.237501,1.394128,0.429168,1.347522),
BP2_CONST6(-0.856322,1.125483,-0.241777,1.393393,0.427101,1.348178),
BP2_CONST6(-0.861492,1.121531,-0.246050,1.392645,0.425032,1.348832),
BP2_CONST6(-0.866644,1.117554,-0.250322,1.391883,0.422963,1.349482),
BP2_CONST6(-0.871778,1.113554,-0.254591,1.391109,0.420892,1.350130),
BP2_CONST6(-0.876893,1.109531,-0.258857,1.390321,0.418821,1.350774),
BP2_CONST6(-0.881990,1.105484,-0.263122,1.389521,0.416748,1.351415),
BP2_CONST6(-0.887068,1.101413,-0.267383,1.388707,0.414674,1.352052),
BP2_CONST6(-0.892127,1.097319,-0.271643,1.387880,0.412600,1.352687),
BP2_CONST6(-0.897168,1.093202,-0.275899,1.387040,0.410525,1.353318),
BP2_CONST6(-0.902189,1.089062,-0.280153,1.386187,0.408448,1.353946),
BP2_CONST6(-0.907191,1.084898,-0.284405,1.385321,0.406371,1.354571),
BP2_CONST6(-0.912174,1.080712,-0.288654,1.384442,0.404292,1.355193),
BP2_CONST6(-0.917138,1.076503,-0.292900,1.383550,0.402213,1.355812),
BP2_CONST6(-0.922082,1.072271,-0.297143,1.382645,0.400133,1.356427),
BP2_CONST6(-0.927007,1.068016,-0.301383,1.381727,0.398052,1.357039),
BP2_CONST6(-0.931912,1.063739,-0.305621,1.380795,0.395969,1.357648),
BP2_CONST6(-0.936797,1.059439,-0.309856,1.379851,0.393886,1.358254),
BP2_CONST6(-0.941663,1.055117,-0.314088,1.378894,0.391802,1.358857),
BP2_CONST6(-0.946508,1.050772,-0.318317,1.377924,0.389717,1.359456),
BP2_CONST6(-0.951334,1.046405,-0.322543,1.376941,0.387632,1.360052),
BP2_CONST6(-0.956140,1.042016,-0.326765,1.375945,0.385545,1.360645),
BP2_CONST6(-0.960925,1.037605,-0.330985,1.374936,0.383457,1.361235),
BP2_CONST6(-0.965689,1.033172,-0.335202,1.373914,0.381369,1.361822),
BP2_CONST6(-0.970434,1.028717,-0.339415,1.372879,0.379279,1.362405),
BP2_CONST6(-0.975158,1.024240,-0.343626,1.371831,0.377189,1.362985),
BP2_CONST6(-0.979861,1.019742,-0.347833,1.370771,0.375098,1.363562),
BP2_CONST6(-0.984543,1.015221,-0.352037,1.369697,0.373005,1.364136),
BP2_CONST6(-0.989205,1.010680,-0.356237,1.368611,0.370912,1.364707),
BP2_CONST6(-0.993845,1.006117,-0.360434,1.367511,0.368819,1.365274),
BP2_CONST6(-0.998465,1.001533,-0.364628,1.366399,0.366724,1.365838),
BP2_CONST6(-1.003063,0.996927,-0.368819,1.365274,0.364628,1.366399),
BP2_CONST6(-1.007641,0.992301,-0.373006,1.364136,0.362532,1.366957),
BP2_CONST6(-1.012196,0.987653,-0.377189,1.362985,0.360434,1.367511),
BP2_CONST6(-1.016731,0.982985,-0.381369,1.361822,0.358336,1.368063),
BP2_CONST6(-1.021244,0.978295,-0.385545,1.360645,0.356237,1.368611),
BP2_CONST6(-1.025735,0.973585,-0.389718,1.359456,0.354137,1.369156),
BP2_CONST6(-1.030205,0.968855,-0.393886,1.358254,0.352037,1.369697),
BP2_CONST6(-1.034652,0.964104,-0.398052,1.357039,0.349935,1.370236),
BP2_CONST6(-1.039078,0.959332,-0.402213,1.355812,0.347833,1.370771),
BP2_CONST6(-1.043481,0.954540,-0.406371,1.354571,0.345730,1.371303),
BP2_CONST6(-1.047863,0.949728,-0.410525,1.353318,0.343626,1.371831),
BP2_CONST6(-1.052223,0.944896,-0.414674,1.352052,0.341521,1.372357),
BP2_CONST6(-1.056560,0.940043,-0.418821,1.350774,0.339416,1.372879),
BP2_CONST6(-1.060875,0.935171,-0.422963,1.349482,0.337309,1.373398),
BP2_CONST6(-1.065167,0.930279,-0.427101,1.348179,0.335202,1.373914),
BP2_CONST6(-1.069437,0.925368,-0.431235,1.346862,0.333094,1.374427),
BP2_CONST6(-1.073684,0.920436,-0.435365,1.345532,0.330985,1.374936),
BP2_CONST6(-1.077909,0.915486,-0.439491,1.344190,0.328876,1.375442),
BP2_CONST6(-1.082110,0.910515,-0.443613,1.342836,0.326766,1.375945),
BP2_CONST6(-1.086289,0.905526,-0.447731,1.341468,0.324654,1.376445),
BP2_CONST6(-1.090444,0.900517,-0.451844,1.340088,0.322543,1.376941),
BP2_CONST6(-1.094577,0.895490,-0.455953,1.338696,0.320430,1.377434),
BP2_CONST6(-1.098686,0.890443,-0.460058,1.337291,0.318317,1.377924),
BP2_CONST6(-1.102772,0.885378,-0.464159,1.335873,0.316203,1.378411),
BP2_CONST6(-1.106835,0.880293,-0.468255,1.334443,0.314088,1.378894),
BP2_CONST6(-1.110874,0.875190,-0.472347,1.333000,0.311972,1.379374),
BP2_CONST6(-1.114890,0.870069,-0.476434,1.331544,0.309856,1.379851),
BP2_CONST6(-1.118882,0.864929,-0.480517,1.330076,0.307739,1.380325),
BP2_CONST6(-1.122851,0.859771,-0.484595,1.328596,0.305621,1.380795),
BP2_CONST6(-1.126796,0.854594,-0.488669,1.327103,0.303503,1.381263),
BP2_CONST6(-1.130717,0.849400,-0.492738,1.325598,0.301383,1.381727),
BP2_CONST6(-1.134613,0.844188,-0.496803,1.324080,0.299264,1.382187),
BP2_CONST6(-1.138486,0.838957,-0.500863,1.322549,0.297143,1.382645),
BP2_CONST6(-1.142335,0.833709,-0.504918,1.321007,0.295022,1.383099),
BP2_CONST6(-1.146160,0.828443,-0.508969,1.319451,0.292900,1.383550),
BP2_CONST6(-1.149960,0.823160,-0.513014,1.317883,0.290777,1.383997),
BP2_CONST6(-1.153736,0.817859,-0.517055,1.316303,0.288654,1.384442),
BP2_CONST6(-1.157488,0.812541,-0.521091,1.314711,0.286530,1.384883),
BP2_CONST6(-1.161215,0.807206,-0.525122,1.313106,0.284405,1.385321),
BP2_CONST6(-1.164917,0.801854,-0.529148,1.311489,0.282280,1.385756),
BP2_CONST6(-1.168594,0.796484,-0.533169,1.309859,0.280153,1.386187),
BP2_CONST6(-1.172248,0.791098,-0.537185,1.308217,0.278027,1.386615),
BP2_CONST6(-1.175876,0.785695,-0.541196,1.306563,0.275899,1.387040),
BP2_CONST6(-1.179479,0.780276,-0.545202,1.304897,0.273771,1.387462),
BP2_CONST6(-1.183057,0.774839,-0.549203,1.303218,0.271643,1.387880),
BP2_CONST6(-1.186611,0.769387,-0.553198,1.301527,0.269513,1.388295),
BP2_CONST6(-1.190139,0.763918,-0.557189,1.299824,0.267384,1.388707),
BP2_CONST6(-1.193642,0.758433,-0.561174,1.298108,0.265253,1.389115),
BP2_CONST6(-1.197119,0.752932,-0.565154,1.296380,0.263122,1.389520),
BP2_CONST6(-1.200571,0.747415,-0.569129,1.294640,0.260990,1.389922),
BP2_CONST6(-1.203998,0.741882,-0.573098,1.292888,0.258858,1.390321),
BP2_CONST6(-1.207399,0.736334,-0.577062,1.291124,0.256725,1.390717),
BP2_CONST6(-1.210775,0.730769,-0.581020,1.289347,0.254591,1.391109),
BP2_CONST6(-1.214125,0.725190,-0.584973,1.287558,0.252457,1.391498),
BP2_CONST6(-1.217450,0.719595,-0.588920,1.285758,0.250322,1.391883),
BP2_CONST6(-1.220748,0.713984,-0.592862,1.283945,0.248186,1.392266),
BP2_CONST6(-1.224021,0.708359,-0.596798,1.282120,0.246050,1.392645),
BP2_CONST6(-1.227268,0.702719,-0.600729,1.280283,0.243914,1.393020),
BP2_CONST6(-1.230489,0.697064,-0.604654,1.278434,0.241777,1.393393),
BP2_CONST6(-1.233684,0.691394,-0.608573,1.276573,0.239639,1.393762),
BP2_CONST6(-1.236852,0.685709,-0.612487,1.274700,0.237501,1.394128),
BP2_CONST6(-1.239995,0.680010,-0.616395,1.272815,0.235362,1.394491),
BP2_CONST6(-1.243111,0.674296,-0.620297,1.270918,0.233222,1.394850),
BP2_CONST6(-1.246201,0.668568,-0.624193,1.269009,0.231083,1.395206),
BP2_CONST6(-1.249264,0.662826,-0.628083,1.267088,0.228942,1.395559),
BP2_CONST6(-1.252301,0.657070,-0.631968,1.265155,0.226801,1.395909),
BP2_CONST6(-1.255312,0.651300,-0.635846,1.263210,0.224659,1.396255),
BP2_CONST6(-1.258296,0.645517,-0.639719,1.261253,0.222517,1.396598),
BP2_CONST6(-1.261253,0.639719,-0.643585,1.259285,0.220375,1.396938),
BP2_CONST6(-1.264184,0.633908,-0.647446,1.257304,0.218232,1.397274),
BP2_CONST6(-1.267088,0.628084,-0.651300,1.255312,0.216088,1.397607),
BP2_CONST6(-1.269965,0.622246,-0.655148,1.253308,0.213944,1.397937),
BP2_CONST6(-1.272815,0.616395,-0.658990,1.251292,0.211799,1.398264),
BP2_CONST6(-1.275638,0.610531,-0.662826,1.249265,0.209654,1.398587),
BP2_CONST6(-1.278434,0.604655,-0.666656,1.247225,0.207508,1.398907),
BP2_CONST6(-1.281203,0.598765,-0.670479,1.245174,0.205362,1.399224),
BP2_CONST6(-1.283945,0.592862,-0.674296,1.243111,0.203216,1.399537),
BP2_CONST6(-1.286660,0.586948,-0.678107,1.241037,0.201068,1.399847),
BP2_CONST6(-1.289347,0.581020,-0.681911,1.238950,0.198921,1.400154),
BP2_CONST6(-1.292007,0.575080,-0.685709,1.236852,0.196773,1.400457),
BP2_CONST6(-1.294640,0.569129,-0.689500,1.234743,0.194624,1.400758),
BP2_CONST6(-1.297246,0.563165,-0.693285,1.232622,0.192475,1.401054),
BP2_CONST6(-1.299824,0.557189,-0.697063,1.230489,0.190326,1.401348),
BP2_CONST6(-1.302374,0.551201,-0.700835,1.228345,0.188176,1.401638),
BP2_CONST6(-1.304896,0.545202,-0.704600,1.226189,0.186026,1.401925),
BP2_CONST6(-1.307392,0.539191,-0.708359,1.224021,0.183875,1.402209),
BP2_CONST6(-1.309859,0.533169,-0.712111,1.221842,0.181724,1.402489),
BP2_CONST6(-1.312299,0.527136,-0.715856,1.219652,0.179572,1.402766),
BP2_CONST6(-1.314710,0.521091,-0.719594,1.217450,0.177420,1.403040),
BP2_CONST6(-1.317095,0.515035,-0.723326,1.215236,0.175268,1.403311),
BP2_CONST6(-1.319451,0.508969,-0.727051,1.213012,0.173115,1.403578),
BP2_CONST6(-1.321779,0.502891,-0.730769,1.210775,0.170962,1.403842),
BP2_CONST6(-1.324080,0.496803,-0.734480,1.208527,0.168808,1.404103),
BP2_CONST6(-1.326352,0.490704,-0.738185,1.206269,0.166654,1.404360),
BP2_CONST6(-1.328596,0.484596,-0.741882,1.203998,0.164499,1.404614),
BP2_CONST6(-1.330812,0.478476,-0.745572,1.201716,0.162345,1.404865),
BP2_CONST6(-1.333000,0.472347,-0.749255,1.199423,0.160189,1.405112),
BP2_CONST6(-1.335159,0.466208,-0.752932,1.197119,0.158034,1.405356),
BP2_CONST6(-1.337291,0.460058,-0.756601,1.194803,0.155878,1.405597),
BP2_CONST6(-1.339394,0.453899,-0.760263,1.192477,0.153721,1.405834),
BP2_CONST6(-1.341468,0.447731,-0.763918,1.190138,0.151565,1.406068),
BP2_CONST6(-1.343515,0.441553,-0.767566,1.187789,0.149408,1.406299),
BP2_CONST6(-1.345532,0.435365,-0.771206,1.185429,0.147250,1.406527),
BP2_CONST6(-1.347522,0.429169,-0.774839,1.183057,0.145092,1.406751),
BP2_CONST6(-1.349482,0.422963,-0.778465,1.180674,0.142934,1.406972),
BP2_CONST6(-1.351414,0.416748,-0.782084,1.178281,0.140776,1.407189),
BP2_CONST6(-1.353318,0.410525,-0.785695,1.175876,0.138617,1.407404),
BP2_CONST6(-1.355193,0.404292,-0.789299,1.173460,0.136458,1.407615),
BP2_CONST6(-1.357039,0.398052,-0.792895,1.171033,0.134299,1.407822),
BP2_CONST6(-1.358857,0.391802,-0.796484,1.168595,0.132139,1.408027),
BP2_CONST6(-1.360645,0.385545,-0.800066,1.166146,0.129979,1.408228),
BP2_CONST6(-1.362405,0.379279,-0.803640,1.163685,0.127819,1.408426),
BP2_CONST6(-1.364136,0.373006,-0.807206,1.161214,0.125658,1.408620),
BP2_CONST6(-1.365838,0.366724,-0.810765,1.158733,0.123497,1.408811),
BP2_CONST6(-1.367512,0.360435,-0.814316,1.156240,0.121336,1.408999),
BP2_CONST6(-1.369156,0.354138,-0.817859,1.153736,0.119174,1.409183),
BP2_CONST6(-1.370771,0.347833,-0.821395,1.151221,0.117013,1.409364),
BP2_CONST6(-1.372357,0.341521,-0.824923,1.148696,0.114850,1.409542),
BP2_CONST6(-1.373914,0.335202,-0.828443,1.146160,0.112688,1.409717),
BP2_CONST6(-1.375442,0.328876,-0.831956,1.143613,0.110525,1.409888),
BP2_CONST6(-1.376941,0.322543,-0.835460,1.141055,0.108363,1.410056),
BP2_CONST6(-1.378411,0.316203,-0.838957,1.138486,0.106199,1.410221),
BP2_CONST6(-1.379851,0.309856,-0.842446,1.135907,0.104036,1.410382),
BP2_CONST6(-1.381263,0.303503,-0.845927,1.133317,0.101872,1.410540),
BP2_CONST6(-1.382645,0.297143,-0.849400,1.130717,0.099709,1.410694),
BP2_CONST6(-1.383998,0.290777,-0.852865,1.128105,0.097544,1.410846),
BP2_CONST6(-1.385321,0.284405,-0.856322,1.125484,0.095380,1.410994),
BP2_CONST6(-1.386615,0.278027,-0.859771,1.122851,0.093216,1.411138),
BP2_CONST6(-1.387880,0.271643,-0.863212,1.120208,0.091051,1.411279),
BP2_CONST6(-1.389115,0.265253,-0.866644,1.117554,0.088886,1.411417),
BP2_CONST6(-1.390321,0.258858,-0.870069,1.114890,0.086721,1.411552),
BP2_CONST6(-1.391498,0.252457,-0.873485,1.112216,0.084555,1.411684),
BP2_CONST6(-1.392645,0.246050,-0.876893,1.109531,0.082390,1.411812),
BP2_CONST6(-1.393762,0.239639,-0.880293,1.106835,0.080224,1.411936),
BP2_CONST6(-1.394850,0.233222,-0.883685,1.104129,0.078058,1.412058),
BP2_CONST6(-1.395909,0.226801,-0.887068,1.101413,0.075892,1.412176),
BP2_CONST6(-1.396938,0.220375,-0.890443,1.098686,0.073725,1.412291),
BP2_CONST6(-1.397937,0.213944,-0.893809,1.095949,0.071559,1.412402),
BP2_CONST6(-1.398907,0.207508,-0.897168,1.093202,0.069392,1.412510),
BP2_CONST6(-1.399847,0.201068,-0.900517,1.090444,0.067225,1.412615),
BP2_CONST6(-1.400758,0.194624,-0.903858,1.087677,0.065058,1.412716),
BP2_CONST6(-1.401639,0.188176,-0.907191,1.084898,0.062891,1.412815),
BP2_CONST6(-1.402490,0.181724,-0.910515,1.082110,0.060724,1.412909),
BP2_CONST6(-1.403311,0.175268,-0.913831,1.079311,0.058556,1.413001),
BP2_CONST6(-1.404103,0.168808,-0.917138,1.076503,0.056389,1.413089),
BP2_CONST6(-1.404865,0.162345,-0.920436,1.073684,0.054221,1.413174),
BP2_CONST6(-1.405597,0.155878,-0.923726,1.070855,0.052053,1.413255),
BP2_CONST6(-1.406299,0.149408,-0.927007,1.068016,0.049885,1.413333),
BP2_CONST6(-1.406972,0.142935,-0.930279,1.065167,0.047717,1.413408),
BP2_CONST6(-1.407615,0.136458,-0.933543,1.062308,0.045549,1.413480),
BP2_CONST6(-1.408228,0.129979,-0.936797,1.059439,0.043381,1.413548),
BP2_CONST6(-1.408811,0.123497,-0.940043,1.056560,0.041212,1.413613),
BP2_CONST6(-1.409364,0.117012,-0.943280,1.053671,0.039044,1.413674),
BP2_CONST6(-1.409888,0.110526,-0.946508,1.050772,0.036875,1.413733),
BP2_CONST6(-1.410382,0.104036,-0.949728,1.047863,0.034707,1.413788),
BP2_CONST6(-1.410845,0.097545,-0.952938,1.044944,0.032538,1.413839),
BP2_CONST6(-1.411279,0.091051,-0.956139,1.042016,0.030369,1.413887),
BP2_CONST6(-1.411683,0.084555,-0.959332,1.039078,0.028200,1.413932),
BP2_CONST6(-1.412058,0.078058,-0.962515,1.036130,0.026031,1.413974),
BP2_CONST6(-1.412402,0.071559,-0.965689,1.033172,0.023862,1.414012),
BP2_CONST6(-1.412716,0.065058,-0.968854,1.030204,0.021693,1.414047),
BP2_CONST6(-1.413001,0.058557,-0.972011,1.027227,0.019524,1.414079),
BP2_CONST6(-1.413255,0.052053,-0.975158,1.024240,0.017355,1.414107),
BP2_CONST6(-1.413480,0.045549,-0.978295,1.021243,0.015185,1.414132),
BP2_CONST6(-1.413674,0.039044,-0.981424,1.018237,0.013016,1.414154),
BP2_CONST6(-1.413839,0.032538,-0.984543,1.015222,0.010847,1.414172),
BP2_CONST6(-1.413974,0.026031,-0.987653,1.012196,0.008677,1.414187),
BP2_CONST6(-1.414079,0.019524,-0.990754,1.009161,0.006508,1.414199),
BP2_CONST6(-1.414153,0.013016,-0.993845,1.006117,0.004339,1.414207),
BP2_CONST6(-1.414199,0.006508,-0.996927,1.003063,0.002169,1.414212),
BP2_CONST6(-1.414214,0.000000,-1.000000,1.000000,0.000000,1.414214),
0,0,0,0,0,0 };

#endif	//  !defined(PLATFORM_LPC_DIRECT) 


#ifdef PLATFORM_LPC_LITDFT

#define BP2_CONST20(j,c1,s1,c2,s2,c3,s3,c4,s4,c5,s5,c6,s6,c7,s7,c8,s8,c9,s9,c10,s10) \
	BP2_FROM_FLOAT(c1),BP2_FROM_FLOAT(-s1),BP2_FROM_FLOAT(c2),BP2_FROM_FLOAT(-s2),     \
	BP2_FROM_FLOAT(c3),BP2_FROM_FLOAT(-s3),BP2_FROM_FLOAT(c4),BP2_FROM_FLOAT(-s4),     \
	BP2_FROM_FLOAT(c5),BP2_FROM_FLOAT(-s5),BP2_FROM_FLOAT(c6),BP2_FROM_FLOAT(-s6),     \
	BP2_FROM_FLOAT(c7),BP2_FROM_FLOAT(-s7),BP2_FROM_FLOAT(c8),BP2_FROM_FLOAT(-s8),     \
	BP2_FROM_FLOAT(c9),BP2_FROM_FLOAT(-s9),BP2_FROM_FLOAT(c10),BP2_FROM_FLOAT(-s10)

const BP2Type rgBP2LpcLitdftTrig[64*20] = {0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
BP2_CONST20(1,0.999998823452,0.001533980186,0.999995293810,0.003067956763,0.999989411082,0.004601926120,0.999981175283,0.006135884649,0.999970586431,0.007669828740,0.999957644552,0.009203754782,0.999942349676,0.010737659167,0.999924701839,0.012271538286,0.999904701083,0.013805388528,0.999882347454,0.015339206285),
BP2_CONST20(2,0.999995293810,0.003067956763,0.999981175283,0.006135884649,0.999957644552,0.009203754782,0.999924701839,0.012271538286,0.999882347454,0.015339206285,0.999830581796,0.018406729906,0.999769405351,0.021474080275,0.999698818696,0.024541228523,0.999618822495,0.027608145779,0.999529417501,0.030674803177),
BP2_CONST20(3,0.999989411082,0.004601926120,0.999957644552,0.009203754782,0.999904701083,0.013805388528,0.999830581796,0.018406729906,0.999735288261,0.023007681469,0.999618822495,0.027608145779,0.999481186966,0.032208025408,0.999322384588,0.036807222941,0.999142418725,0.041405640977,0.998941293187,0.046003182131),
BP2_CONST20(4,0.999981175283,0.006135884649,0.999924701839,0.012271538286,0.999830581796,0.018406729906,0.999698818696,0.024541228523,0.999529417501,0.030674803177,0.999322384588,0.036807222941,0.999077727753,0.042938256935,0.998795456205,0.049067674327,0.998475580573,0.055195244350,0.998118112900,0.061320736302),
BP2_CONST20(5,0.999970586431,0.007669828740,0.999882347454,0.015339206285,0.999735288261,0.023007681469,0.999529417501,0.030674803177,0.999264747287,0.038340120374,0.998941293187,0.046003182131,0.998559074230,0.053663537653,0.998118112900,0.061320736302,0.997618435139,0.068974327628,0.997060070339,0.076623861392),
BP2_CONST20(6,0.999957644552,0.009203754782,0.999830581796,0.018406729906,0.999618822495,0.027608145779,0.999322384588,0.036807222941,0.998941293187,0.046003182131,0.998475580573,0.055195244350,0.997925286199,0.064382630930,0.997290456679,0.073564563600,0.996571145791,0.082740264549,0.995767414468,0.091908956497),
BP2_CONST20(7,0.999942349676,0.010737659167,0.999769405351,0.021474080275,0.999481186966,0.032208025408,0.999077727753,0.042938256935,0.998559074230,0.053663537653,0.997925286199,0.064382630930,0.997176436735,0.075094300848,0.996312612183,0.085797312344,0.995333912140,0.096490431355,0.994240449453,0.107172424957),
BP2_CONST20(8,0.999924701839,0.012271538286,0.999698818696,0.024541228523,0.999322384588,0.036807222941,0.998795456205,0.049067674327,0.998118112900,0.061320736302,0.997290456679,0.073564563600,0.996312612183,0.085797312344,0.995184726672,0.098017140330,0.993906970002,0.110222207294,0.992479534599,0.122410675199),
BP2_CONST20(9,0.999904701083,0.013805388528,0.999618822495,0.027608145779,0.999142418725,0.041405640977,0.998475580573,0.055195244350,0.997618435139,0.068974327628,0.996571145791,0.082740264549,0.995333912140,0.096490431355,0.993906970002,0.110222207294,0.992290591348,0.123932975119,0.990485084256,0.137620121586),
BP2_CONST20(10,0.999882347454,0.015339206285,0.999529417501,0.030674803177,0.998941293187,0.046003182131,0.998118112900,0.061320736302,0.997060070339,0.076623861392,0.995767414468,0.091908956497,0.994240449453,0.107172424957,0.992479534599,0.122410675199,0.990485084256,0.137620121586,0.988257567731,0.152797185258),
BP2_CONST20(11,0.999857641006,0.016872987947,0.999430604555,0.033741171851,0.998719012234,0.050599749037,0.997723066644,0.067443919564,0.996443051350,0.084268887593,0.994879330795,0.101069862755,0.993032350198,0.117842061508,0.990902635428,0.134580708507,0.988490792853,0.151281037957,0.985797509168,0.167938294975),
BP2_CONST20(12,0.999830581796,0.018406729906,0.999322384588,0.036807222941,0.998475580573,0.055195244350,0.997290456679,0.073564563600,0.995767414468,0.091908956497,0.993906970002,0.110222207294,0.991709753669,0.128498110794,0.989176509965,0.146730474455,0.986308097245,0.164913120490,0.983105487431,0.183039887955),
BP2_CONST20(13,0.999801169888,0.019940428552,0.999204758618,0.039872927588,0.998211003360,0.059789570747,0.996820299291,0.079682437971,0.995033199438,0.099543618660,0.992850414460,0.119365214811,0.990272812363,0.139139344164,0.987301418158,0.158858143334,0.983937413449,0.178513770939,0.980182135968,0.198098410718),
BP2_CONST20(14,0.999769405351,0.021474080275,0.999077727753,0.042938256935,0.997925286199,0.064382630930,0.996312612183,0.085797312344,0.994240449453,0.107172424957,0.991709753669,0.128498110794,0.988721691960,0.149764534677,0.985277642389,0.170961888760,0.981379193314,0.192080397050,0.977028142658,0.213110319916),
BP2_CONST20(15,0.999735288261,0.023007681469,0.998941293187,0.046003182131,0.997618435139,0.068974327628,0.995767414468,0.091908956497,0.993389211148,0.114794926607,0.990485084256,0.137620121586,0.987056571306,0.160372457243,0.983105487431,0.183039887955,0.978633924429,0.205610413053,0.973644249651,0.228072083171),
BP2_CONST20(16,0.999698818696,0.024541228523,0.998795456205,0.049067674327,0.997290456679,0.073564563600,0.995184726672,0.098017140330,0.992479534599,0.122410675199,0.989176509965,0.146730474455,0.985277642389,0.170961888760,0.980785280403,0.195090322016,0.975702130039,0.219101240157,0.970031253195,0.242980179903),
BP2_CONST20(17,0.999659996744,0.026074717829,0.998640218180,0.052131704680,0.996941357765,0.078153241633,0.994564570734,0.104121633872,0.991511473319,0.130019222722,0.987784141645,0.155828397654,0.983385110322,0.181531608261,0.978317370720,0.207111376192,0.972584368935,0.232550307039,0.966190003445,0.257831102162),
BP2_CONST20(18,0.999618822495,0.027608145779,0.998475580573,0.055195244350,0.996571145791,0.082740264549,0.993906970002,0.110222207294,0.990485084256,0.137620121586,0.986308097245,0.164913120490,0.981379193314,0.192080397050,0.975702130039,0.219101240157,0.969281235357,0.245955050336,0.962121404269,0.272621355450),
BP2_CONST20(19,0.999575296047,0.029141508764,0.998301544934,0.058258264500,0.996179828596,0.087325535206,0.993211949235,0.116318630912,0.989400427791,0.145212924653,0.984748501802,0.173983873387,0.979260122649,0.202607038844,0.972939952206,0.231058108281,0.965793358874,0.259312915133,0.957826413028,0.287347459545),
BP2_CONST20(20,0.999529417501,0.030674803177,0.998118112900,0.061320736302,0.995767414468,0.091908956497,0.992479534599,0.122410675199,0.988257567731,0.152797185258,0.983105487431,0.183039887955,0.977028142658,0.213110319916,0.970031253195,0.242980179903,0.962121404269,0.272621355450,0.953306040354,0.302005949319),
BP2_CONST20(21,0.999481186966,0.032208025408,0.997925286199,0.064382630930,0.995333912140,0.096490431355,0.991709753669,0.128498110794,0.987056571306,0.160372457243,0.981379193314,0.192080397050,0.974683510689,0.223589029230,0.966976471045,0.254865659605,0.958266071408,0.285877834727,0.948561349916,0.316593375556),
BP2_CONST20(22,0.999430604555,0.033741171851,0.997723066644,0.067443919564,0.994879330795,0.101069862755,0.990902635428,0.134580708507,0.985797509168,0.167938294975,0.979569765685,0.201104634842,0.972226497079,0.234041958584,0.963776065795,0.266712757475,0.954228095109,0.299079826308,0.943593458162,0.331106305760),
BP2_CONST20(23,0.999377670388,0.035274238898,0.997511456140,0.070504573390,0.994403680058,0.105647153713,0.990058210262,0.140658239333,0.984480455383,0.175494253377,0.977677357825,0.210111836880,0.969657385124,0.244467902748,0.960430519416,0.278519689385,0.950008245002,0.312224813922,0.938403534063,0.345541324964),
BP2_CONST20(24,0.999322384588,0.036807222941,0.997290456679,0.073564563600,0.993906970002,0.110222207294,0.989176509965,0.146730474455,0.983105487431,0.183039887955,0.975702130039,0.219101240157,0.966976471045,0.254865659605,0.956940335732,0.290284677254,0.945607325381,0.325310292162,0.932992798835,0.359895036535),
BP2_CONST20(25,0.999264747287,0.038340120374,0.997060070339,0.076623861392,0.993389211148,0.114794926607,0.988257567731,0.152797185258,0.981672686197,0.190574754820,0.973644249651,0.228072083171,0.964184063952,0.265234030286,0.953306040354,0.302005949319,0.941026175051,0.338333766966,0.927362525650,0.374164062971),
BP2_CONST20(26,0.999204758618,0.039872927588,0.996820299291,0.079682437971,0.992850414460,0.119365214811,0.987301418158,0.158858143334,0.980182135968,0.198098410718,0.971503890986,0.237023605994,0.961280485811,0.275571819311,0.949528180593,0.313681740399,0.936265667170,0.351292756086,0.921514039342,0.388345046699),
BP2_CONST20(27,0.999142418725,0.041405640977,0.996571145791,0.082740264549,0.992290591348,0.123932975119,0.986308097245,0.164913120490,0.978633924429,0.205610413053,0.969281235357,0.245955050336,0.958266071408,0.285877834727,0.945607325381,0.325310292162,0.931326709081,0.364184789567,0.915448716088,0.402434650859),
BP2_CONST20(28,0.999077727753,0.042938256935,0.996312612183,0.085797312344,0.991709753669,0.128498110794,0.985277642389,0.170961888760,0.977028142658,0.213110319916,0.966976471045,0.254865659605,0.955141168306,0.296150888244,0.941544065183,0.336889853392,0.926210242138,0.377007410216,0.909167983091,0.416429560098),
BP2_CONST20(29,0.999010685854,0.044470771855,0.996044700901,0.088853552583,0.991107913723,0.133060525157,0.984210092387,0.177004220412,0.975364885117,0.220597690109,0.964589793290,0.263754678975,0.951906136808,0.306389795371,0.937339011913,0.348418680249,0.920917241529,0.389758174070,0.902673318237,0.430326481340),
BP2_CONST20(30,0.998941293187,0.046003182131,0.995767414468,0.091908956497,0.990485084256,0.137620121586,0.983105487431,0.183039887955,0.973644249651,0.228072083171,0.962121404269,0.272621355450,0.948561349916,0.316593375556,0.932992798835,0.359895036535,0.915448716088,0.402434650859,0.895966249756,0.444122144570),
BP2_CONST20(31,0.998869549914,0.047535484157,0.995480755492,0.094963495330,0.989841278459,0.142176803519,0.981963869110,0.189068664150,0.971866337480,0.235533059405,0.959571513082,0.281464937926,0.945107193285,0.326760452320,0.928506080473,0.371317193952,0.909805708105,0.415034424476,0.889048355855,0.457813303599),
BP2_CONST20(32,0.998795456205,0.049067674327,0.995184726672,0.098017140330,0.989176509965,0.146730474455,0.980785280403,0.195090322016,0.970031253195,0.242980179903,0.956940335732,0.290284677254,0.941544065183,0.336889853392,0.923879532511,0.382683432365,0.903989293123,0.427555093430,0.881921264348,0.471396736826),
BP2_CONST20(33,0.998719012234,0.050599749037,0.994879330795,0.101069862755,0.988490792853,0.151281037957,0.979569765685,0.201104634842,0.968139104746,0.250413006573,0.954228095109,0.299079826308,0.937872376440,0.346980410846,0.919113851690,0.393992040061,0.898000579741,0.439994271310,0.874586652278,0.484869248001),
BP2_CONST20(34,0.998640218180,0.052131704680,0.994564570734,0.104121633872,0.987784141645,0.155828397654,0.978317370720,0.207111376192,0.966190003445,0.257831102162,0.951435020969,0.307849640042,0.934092550404,0.357030961233,0.914209755704,0.405241314005,0.891840709392,0.452349587234,0.867046245516,0.498227666973),
BP2_CONST20(35,0.998559074230,0.053663537653,0.994240449453,0.107172424957,0.987056571306,0.160372457243,0.977028142658,0.213110319916,0.964184063952,0.265234030286,0.948561349916,0.316593375556,0.930205022892,0.367040345720,0.909167983091,0.416429560098,0.885510856136,0.464618686306,0.859301818357,0.511468850438),
BP2_CONST20(36,0.998475580573,0.055195244350,0.993906970002,0.110222207294,0.986308097245,0.164913120490,0.975702130039,0.219101240157,0.962121404269,0.272621355450,0.945607325381,0.325310292162,0.926210242138,0.377007410216,0.903989293123,0.427555093430,0.879012226429,0.476799230063,0.851355193105,0.524589682678),
BP2_CONST20(37,0.998389737407,0.056726821167,0.993564135521,0.113270952178,0.985538735312,0.169450291234,0.974339382786,0.225083911360,0.960002145738,0.279992643080,0.942573197601,0.333999651442,0.922108668743,0.386931005514,0.898674465694,0.438616238539,0.872346058894,0.488888896920,0.843208239642,0.537587076296),
BP2_CONST20(38,0.998301544934,0.058258264500,0.993211949235,0.116318630912,0.984748501802,0.173983873387,0.972939952206,0.231058108281,0.957826413028,0.287347459545,0.939459223602,0.342660717312,0.917900775621,0.396809987417,0.893224301196,0.449611329655,0.865513624091,0.500885382611,0.834862874986,0.550457972937),
BP2_CONST20(39,0.998211003360,0.059789570747,0.992850414460,0.119365214811,0.983937413449,0.178513770939,0.971503890986,0.237023605994,0.955594334131,0.294685372181,0.936265667170,0.351292756086,0.913587047945,0.406643216870,0.887639620403,0.460538710958,0.858516224264,0.512786400634,0.826321062846,0.563199344014),
BP2_CONST20(40,0.998118112900,0.061320736302,0.992479534599,0.122410675199,0.983105487431,0.183039887955,0.970031253195,0.242980179903,0.953306040354,0.302005949319,0.932992798835,0.359895036535,0.909167983091,0.416429560098,0.881921264348,0.471396736826,0.851355193105,0.524589682678,0.817584813152,0.575808191418),
BP2_CONST20(41,0.998022873771,0.062851757564,0.992099313142,0.125454983412,0.982252741366,0.187562128583,0.968522094274,0.248927605746,0.950961666312,0.309308760312,0.929640895843,0.368466829953,0.904644090578,0.426167888727,0.876070094195,0.482183772079,0.844031895490,0.536292979066,0.808656181588,0.588281548223),
BP2_CONST20(42,0.997925286199,0.064382630930,0.991709753669,0.128498110794,0.981379193314,0.192080397050,0.966976471045,0.254865659605,0.948561349916,0.316593375556,0.926210242138,0.377007410216,0.900015892016,0.435857079922,0.870086991109,0.492898192230,0.836547727224,0.547894059173,0.799537269108,0.600616479384),
BP2_CONST20(43,0.997825350411,0.065913352797,0.991310859846,0.131540028703,0.980484861773,0.196594597670,0.965394441698,0.260794117915,0.946105232370,0.323859366518,0.922701128334,0.385516053844,0.895283921039,0.445496016514,0.863972856122,0.503538383726,0.828904114772,0.559390711859,0.790230221437,0.612810082429),
BP2_CONST20(44,0.997723066644,0.067443919564,0.990902635428,0.134580708507,0.979569765685,0.201104634842,0.963776065795,0.266712757475,0.943593458162,0.331106305760,0.919113851690,0.393992040061,0.890448723245,0.455083587126,0.857728610000,0.514102744193,0.821102514991,0.570780745887,0.780737228572,0.624859488142),
BP2_CONST20(45,0.997618435139,0.068974327628,0.990485084256,0.137620121586,0.978633924429,0.205610413053,0.962121404269,0.272621355450,0.941026175051,0.338333766966,0.915448716088,0.402434650859,0.885510856136,0.464618686306,0.851355193105,0.524589682678,0.813144414849,0.582061990341,0.771060524262,0.636761861236),
BP2_CONST20(46,0.997511456140,0.070504573390,0.990058210262,0.140658239333,0.977677357825,0.210111836880,0.960430519416,0.278519689385,0.938403534063,0.345541324964,0.911706032005,0.410843171058,0.880470889052,0.474100214651,0.844853565250,0.534997619887,0.805031331143,0.593232295040,0.761202385484,0.648514401022),
BP2_CONST20(47,0.997402129901,0.072034653247,0.989622017463,0.143695033150,0.976700086129,0.214608810994,0.958703474896,0.284407537211,0.935725689481,0.352728555755,0.907886116488,0.419216888363,0.875329403104,0.483527078933,0.838224705555,0.545324988422,0.796764810208,0.604289530948,0.751165131910,0.660114342067),
BP2_CONST20(48,0.997290456679,0.073564563600,0.989176509965,0.146730474455,0.975702130039,0.219101240157,0.956940335732,0.290284677254,0.932992798835,0.359895036535,0.903989293123,0.427555093430,0.870086991109,0.492898192230,0.831469612303,0.555570233020,0.788346427627,0.615231590581,0.740951125355,0.671558954847),
BP2_CONST20(49,0.997176436735,0.075094300848,0.988721691960,0.149764534677,0.974683510689,0.223589029230,0.955141168306,0.296150888244,0.930205022892,0.367040345720,0.900015892016,0.435857079922,0.864744257519,0.502212474046,0.824589302785,0.565731810784,0.779777787923,0.626056388404,0.730562769228,0.682845546385),
BP2_CONST20(50,0.997060070339,0.076623861392,0.988257567731,0.152797185258,0.973644249651,0.228072083171,0.953306040354,0.302005949319,0.927362525650,0.374164062971,0.895966249756,0.444122144570,0.859301818357,0.511468850438,0.817584813152,0.575808191418,0.771060524262,0.636761861236,0.720002507961,0.693971460890),
BP2_CONST20(51,0.996941357765,0.078153241633,0.987784141645,0.155828397654,0.972584368935,0.232550307039,0.951435020969,0.307849640042,0.924465474325,0.381265769222,0.891840709392,0.452349587234,0.853760301138,0.520666254140,0.810457198253,0.585797857456,0.762196298135,0.647345968637,0.709272826439,0.704934080376),
BP2_CONST20(52,0.996820299291,0.079682437971,0.987301418158,0.158858143334,0.971503890986,0.237023605994,0.949528180593,0.313681740399,0.921514039342,0.388345046699,0.887639620403,0.460538710958,0.848120344803,0.529803624686,0.803207531481,0.595699304492,0.753186799044,0.657806693297,0.698376249409,0.715730825284),
BP2_CONST20(53,0.996696895203,0.081211446810,0.986809401814,0.161886393780,0.970402838688,0.241491885303,0.947585591018,0.319502030816,0.918508394325,0.395401478948,0.883363338666,0.468688822036,0.842382599643,0.538879908531,0.795836904609,0.605511041404,0.744033744180,0.668142041427,0.687315340892,0.726359155084),
BP2_CONST20(54,0.996571145791,0.082740264549,0.986308097245,0.164913120490,0.969281235357,0.245955050336,0.945607325381,0.325310292162,0.915448716088,0.402434650859,0.879012226429,0.476799230063,0.836547727224,0.547894059173,0.788346427627,0.615231590581,0.734738878096,0.678350043130,0.676092703575,0.736816568877),
BP2_CONST20(55,0.996443051350,0.084268887593,0.985797509168,0.167938294975,0.968139104746,0.250413006573,0.943593458162,0.331106305760,0.912335184623,0.409444148692,0.874586652278,0.484869248001,0.830616400309,0.556845037275,0.780737228572,0.624859488142,0.725303972373,0.688428752784,0.664710978203,0.747100605980),
BP2_CONST20(56,0.996312612183,0.085797312344,0.985277642389,0.170961888760,0.966976471045,0.254865659605,0.941544065183,0.336889853392,0.909167983091,0.416429560098,0.870086991109,0.492898192230,0.824589302785,0.565731810784,0.773010453363,0.634393284164,0.715730825284,0.698376249409,0.653172842954,0.757208846506),
BP2_CONST20(57,0.996179828596,0.087325535206,0.984748501802,0.173983873387,0.965793358874,0.259312915133,0.939459223602,0.342660717312,0.905947297807,0.423390474144,0.865513624091,0.500885382611,0.818467129580,0.574553355048,0.765167265622,0.643831542890,0.706021261449,0.708190637033,0.641481012809,0.767138911936),
BP2_CONST20(58,0.996044700901,0.088853552583,0.984210092387,0.177004220412,0.964589793290,0.263754678975,0.937339011913,0.348418680249,0.902673318237,0.430326481340,0.860866938638,0.508830142543,0.812250586585,0.583308652938,0.757208846506,0.653172842954,0.696177131491,0.717870045056,0.629638238915,0.776888465673),
BP2_CONST20(59,0.995907229417,0.090381360878,0.983662419212,0.180022901406,0.963365799781,0.268190857063,0.935183509939,0.354163525420,0.899346236979,0.437237173661,0.856147328375,0.516731799018,0.805940390571,0.591996694962,0.749136394523,0.662415777590,0.686200311680,0.727412628602,0.617647307938,0.786455213599),
BP2_CONST20(60,0.995767414468,0.091908956497,0.983105487431,0.183039887955,0.962121404269,0.272621355450,0.932992798835,0.359895036535,0.895966249756,0.444122144570,0.851355193105,0.524589682678,0.799537269108,0.600616479384,0.740951125355,0.671558954847,0.676092703575,0.736816568877,0.605511041404,0.795836904609),
BP2_CONST20(61,0.995625256381,0.093436335846,0.982539302287,0.186055151663,0.960856633108,0.277046080306,0.930766961079,0.365612997805,0.892533555403,0.450980989045,0.846490938774,0.532403127877,0.793041960479,0.609167012336,0.732654271672,0.680600997795,0.665856233666,0.746080073510,0.593232295040,0.805031331143),
BP2_CONST20(62,0.995480755492,0.094963495330,0.981963869110,0.189068664150,0.959571513082,0.281464937926,0.928506080473,0.371317193952,0.889048355855,0.457813303599,0.841554977437,0.540171472730,0.786455213599,0.617647307938,0.724247082951,0.689540544737,0.655492853000,0.755201376897,0.580813958096,0.814036329706),
BP2_CONST20(63,0.995333912140,0.096490431355,0.981379193314,0.192080397050,0.958266071408,0.285877834727,0.926210242138,0.377007410216,0.885510856136,0.464618686306,0.836547727224,0.547894059173,0.779777787923,0.626056388404,0.715730825284,0.698376249409,0.645004536816,0.764178740536,0.568258952670,0.822849781376)
};

#endif	// PLATFORM_LPC_LITDFT

#pragma MSVC_RESTORE_WARNING(4305)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\wmalib\wmadec_s\win32.c ===
/*************************************************************************

Copyright (C) Microsoft Corporation, 1996 - 1999

Module Name:

    Win32.c

Abstract:

    Win32-specific functions.

Author:

    Raymond Cheng (raych)       Aug 25, 1999

Revision History:
  
    Thumpudi Naveen (tnaveen)   May 9, 2000    Added NT specific timer.

*************************************************************************/

#include "..\common\macros.h"
#include "..\..\..\dsound\dsndver.h"


// Only build these functions for WIN32
#ifdef WMA_OSTARGET_WIN32

// **************************************************************************
// COMMON FUNCTIONS
// **************************************************************************

#ifdef WMA_TARGET_ANSI
#include "ansiwin.h"
#else   // WMA_TARGET_ANSI

#ifndef _WIN32
#define _WIN32  // We need this when including windows.h
#endif  // !_WIN32

#include "xtl.h"
#endif  // WMA_TARGET_ANSI


#ifdef PLATFORM_SPECIFIC_OUTPUTDEBUGSTRING
#define OUTPUT_DEBUG_STRING(sz) OutputDebugString(sz)
#endif  // PLATFORM_SPECIFIC_OUTPUTDEBUGSTRING

#ifdef UNICODE
#define SPRINTF swprintf
#else   // UNICODE
#define SPRINTF sprintf
#endif  // UNICODE

#ifdef PLATFORM_SPECIFIC_PERFTIMER

#include <stdio.h>

typedef struct tagPERFTIMERINFO
{
    int             fFirstTime;         // Used to record total time spent in decode loop
    LARGE_INTEGER   cDecodeTime;        // Time spent decoding only (running total)
    LARGE_INTEGER   cTotalDecLoopTime;  // Total time spent in decode loop
    LARGE_INTEGER   cDecodeStart;       // Could be easily optimized out but it's not worth it
    long            lSamplesPerSec;     // Samples per second, counting all channels
    LARGE_INTEGER   cPlaybackTime;      // Time required for playback (running total)
    LARGE_INTEGER   cPerfFrequency;     // Frequency of PerformanceCounter
    
    Bool            bIsWindowsNT;       // GetProcessTime available
} PERFTIMERINFO;


PERFTIMERINFO *PerfTimerNew(long lSamplesPerSecOutput)
{
    PERFTIMERINFO  *pInfo;
    Bool            fResult;
    
    pInfo = (PERFTIMERINFO*) malloc(sizeof(PERFTIMERINFO));
    if (NULL == pInfo)
        return NULL;
    
    pInfo->fFirstTime = WMAB_TRUE;
    pInfo->cDecodeTime.QuadPart = 0;
    pInfo->cTotalDecLoopTime.QuadPart  = 0;
    pInfo->cDecodeStart.QuadPart  = 0;
    pInfo->lSamplesPerSec = lSamplesPerSecOutput;
    pInfo->cPlaybackTime.QuadPart  = 0;
    
    pInfo->bIsWindowsNT = WMAB_TRUE;
    pInfo->cPerfFrequency.QuadPart = 10000000; // Ticks are hard coded to be 100ns
    
    return pInfo;
}

void PerfTimerStart(PERFTIMERINFO *pInfo)
{
    Bool     fResult;
    
    //
    // georgioc - removed from xbox
    //


}

void PerfTimerStop(PERFTIMERINFO *pInfo, long lSamplesDecoded)
{
    LARGE_INTEGER   cEndTime;
    Bool            fResult;
    
    //
    // georgioc - removed from xbox
    //

}

void PerfTimerStopElapsed(PERFTIMERINFO *pInfo)
{
    LARGE_INTEGER   cEndElapsedTime;
    Bool            fResult;
    
    //
    // georgioc - removed from xbox
    //

}

void PerfTimerReport(PERFTIMERINFO *pInfo)
{
    TCHAR           sz[256];
    float           fltDecodeTime;
    float           fltEntireDecodeTime;
    float           fltDecodeTimeFraction;
    float           fltPlaybackTime;
    
    if (pInfo->bIsWindowsNT) {
        SPRINTF(sz, TEXT("\n** Reporting aggregate of user time in all threads (NT)\n"));
        OUTPUT_DEBUG_STRING(sz);
    }
    
    SPRINTF(sz, TEXT("\n\n** Ticks per second (clock resolution): %f.\n"),
        (float)pInfo->cPerfFrequency.QuadPart);
    OUTPUT_DEBUG_STRING(sz);
    
    fltDecodeTime = (float) pInfo->cDecodeTime.QuadPart /
        (float) pInfo->cPerfFrequency.QuadPart;
    fltEntireDecodeTime = (float) pInfo->cTotalDecLoopTime.QuadPart /
        (float) pInfo->cPerfFrequency.QuadPart;
    SPRINTF(sz, TEXT("** Decode time: %f sec. Entire decode time: %f sec.\n"),
        fltDecodeTime, fltEntireDecodeTime);
    OUTPUT_DEBUG_STRING(sz);
    
    fltPlaybackTime = (float) pInfo->cPlaybackTime.QuadPart /
        (float) pInfo->cPerfFrequency.QuadPart;
    SPRINTF(sz, TEXT("** Playback time : %f sec.\n"),
        fltPlaybackTime);
    OUTPUT_DEBUG_STRING(sz);
    
    fltDecodeTimeFraction = (float)pInfo->cDecodeTime.QuadPart /
        (float) pInfo->cPlaybackTime.QuadPart;
    SPRINTF(sz, TEXT("** Percentage of playback time spent decoding: %f%%.\n"),
        fltDecodeTimeFraction * 100);
    OUTPUT_DEBUG_STRING(sz);
#       if defined(WMA_MONITOR)
    fprintf(stderr,"%s\n",sz);
#       endif
    
    SPRINTF(sz, TEXT("** Minimum MHz for realtime playback: %f of current CPU speed.\n"),
        fltDecodeTimeFraction);
    OUTPUT_DEBUG_STRING(sz);
    
    SPRINTF(sz, TEXT("** This CPU is %f times faster than required.\n\n"),
        (float)1.0 / fltDecodeTimeFraction);
    OUTPUT_DEBUG_STRING(sz);
    
#ifdef WRITE_TIME_TO_FILE
    {
        FILE*   fOut;
        
        fOut = fopen("time.txt", "wt");
        if (fOut != NULL) 
        { 
            fprintf(fOut, "%f\n", (float) fltDecodeTime);
            fclose(fOut);
            fOut = NULL;
        }
    }
#endif  //WRITE_TIME_TO_FILE
    
}


float fltPerfTimerDecodeTime(PERFTIMERINFO *pInfo)
{
    return (float) pInfo->cDecodeTime.QuadPart /
        (float) pInfo->cPerfFrequency.QuadPart;
}


void PerfTimerFree(PERFTIMERINFO *pInfo)
{
    free(pInfo);
}

#endif  // PLATFORM_SPECIFIC_PERFTIMER



//---------------------------------------------------------------------------
// Debug Infrastructure
//---------------------------------------------------------------------------
#if defined(PLATFORM_SPECIFIC_DEBUGINFRASTRUCTURE) && defined(_DEBUG)
#include <stdarg.h>
void TraceInfoHelper(const char *pszFile, int iLine, const char *pszFmt, ...)
{
    char    sz[512];
    va_list vargs;
    Int     iCharsWritten;

    // Prepend file/line identifier and "*** INFO ***" to get attention
    iCharsWritten = sprintf(sz, "%s(%d) : *** INFO *** ", pszFile, iLine);

    va_start(vargs, pszFmt);
    iCharsWritten += vsprintf(sz + iCharsWritten, pszFmt, vargs);
    va_end(vargs);

    // Append a newline and print it!
    sprintf(sz + iCharsWritten, "\n");
#if defined(_UNICODE) || defined(UNICODE)
    // let this do the string to unicode conversion
    MyOutputDbgStr(0,sz);
#else
    OUTPUT_DEBUG_STRING(sz);
#endif
}

#endif  // defined(PLATFORM_SPECIFIC_DEBUGINFRASTRUCTURE) && defined(_DEBUG)




// **************************************************************************
// ENCODER FUNCTIONS
// **************************************************************************
#ifdef ENCODER

// Following functions are for non-serialized code only
#ifndef WMA_SERIALIZE
#include "msaudioenc.h"

// Defines
#define SAFE_CLOSEHANDLE(x) if((x)) { CloseHandle((x));  (x) = NULL; }


void threadFuncEnc0(DWORD threadParam);
void threadFuncEnc1(DWORD threadParam);


void osInitThreadInfo(THREADINFO *pInfo)
{
    pInfo->m_hEncEvent0 = NULL;
    pInfo->m_hEncDone0 = NULL;
    pInfo->m_hEncEvent1 = NULL;
    pInfo->m_hEncDone1 = NULL;
    pInfo->m_hThreadEnc0 = NULL;
    pInfo->m_hThreadEnc1 = NULL;
    
    pInfo->m_bShutdownThreads = WMAB_FALSE;
    pInfo->m_fMultiProc = WMAB_FALSE;
    pInfo->m_pauenc = NULL;
}


void osCloseThreads(THREADINFO *pInfo)
{
    pInfo->m_bShutdownThreads = WMAB_TRUE;
    
    // signal all threads to stop...
    if (pInfo->m_hEncEvent0)  
        SetEvent (pInfo->m_hEncEvent0);
    if (pInfo->m_hEncEvent1)  
        SetEvent (pInfo->m_hEncEvent1);
    
    if (pInfo->m_hThreadEnc0)  
        WaitForSingleObject (pInfo->m_hThreadEnc0, INFINITE);
    if (pInfo->m_hThreadEnc1)  
        WaitForSingleObject (pInfo->m_hThreadEnc1, INFINITE);
    
    // clean up handles...
    
    SAFE_CLOSEHANDLE(pInfo->m_hThreadEnc0);
    SAFE_CLOSEHANDLE(pInfo->m_hEncEvent0);
    SAFE_CLOSEHANDLE(pInfo->m_hEncDone0);
    SAFE_CLOSEHANDLE(pInfo->m_hThreadEnc1);
    SAFE_CLOSEHANDLE(pInfo->m_hEncEvent1);
    SAFE_CLOSEHANDLE(pInfo->m_hEncDone1);
}

WMARESULT osInitThreads(CAudioObjectEncoder *pauenc)
{
    U32 uiThredEnc0, uiThredEnc1;
    
    THREADINFO *pInfo = &pauenc->m_rThreadInfo;
    SYSTEM_INFO rSysInfo;
    int iPriority = GetThreadPriority(GetCurrentThread());
    
    // Running dual-threaded on a single-proc machine is 7.4% slower than single-threaded
    pInfo->m_pauenc = pauenc;
    GetSystemInfo(&rSysInfo);
    if (rSysInfo.dwNumberOfProcessors == 1)
    {
        assert(WMAB_FALSE == pInfo->m_fMultiProc);
        return WMA_OK;
    }
    else
        pInfo->m_fMultiProc = WMAB_TRUE;
    
    pInfo->m_hEncEvent0 = CreateEvent(NULL, WMAB_FALSE, WMAB_FALSE, NULL);
    pInfo->m_hEncDone0 = CreateEvent(NULL, WMAB_FALSE, WMAB_FALSE, NULL);
    pInfo->m_hEncEvent1 = CreateEvent(NULL, WMAB_FALSE, WMAB_FALSE, NULL);
    pInfo->m_hEncDone1 = CreateEvent(NULL, WMAB_FALSE, WMAB_FALSE, NULL);
    
    pInfo->m_hThreadEnc0 = CreateThread (
        NULL,
        0,
        (LPTHREAD_START_ROUTINE) threadFuncEnc0,
        (LPVOID) pauenc,
        0,
        &uiThredEnc0
        );
    if (pInfo->m_hThreadEnc0 == NULL) 
        goto lerror;
    SetThreadPriority(pInfo->m_hThreadEnc0, iPriority);
    
    pInfo->m_hThreadEnc1 = CreateThread (
        NULL,
        0,
        (LPTHREAD_START_ROUTINE) threadFuncEnc1,
        (LPVOID) pauenc,
        0,
        &uiThredEnc1
        );
    if (pInfo->m_hThreadEnc1 == NULL) 
        goto lerror;
    SetThreadPriority(pInfo->m_hThreadEnc1, iPriority);
    
    return WMA_OK;
    
lerror:
    osCloseThreads (pInfo);
    return TraceResult(WMA_E_FAIL);
}

void threadFuncEnc0 (DWORD threadParam)
{
    CAudioObjectEncoder* pauenc = (CAudioObjectEncoder*) threadParam;

#if !defined(BUILD_INTEGER) && !defined(UNDER_CE) && defined(WMA_TARGET_X86)
    // Initialize Intel FFT for this thread
    if (pauenc->pau->m_fIntelFFT)
    {
        WMARESULT   wmaResult;

        wmaResult = auInitIntelFFT(pauenc->pau, INTELFFT_INIT_THREAD);
        TraceError(wmaResult);
    }
#endif  // !defined(BUILD_INTEGER) && !defined(UNDER_CE) && defined(WMA_TARGET_X86)

    for (;;) {

        while (WaitForSingleObject (pauenc->m_rThreadInfo.m_hEncEvent0,
            INFINITE) != WAIT_OBJECT_0);

        if (pauenc->m_rThreadInfo.m_bShutdownThreads)
            break;

        switch (pauenc->tEncStatus) {
        case PROCESS_A:
            prvProcess0A (pauenc);
            break;
        case PROCESS_B:
            prvProcess0B (pauenc);
            break;
        case PROCESS_C:
            prvProcess0C (pauenc);
            break;
        case QUANTIZE_ENTROPY:
            prvQuantizeAndEntropy0 (pauenc);
            break;
        case SEND_STREAM:
            prvSendStream0 (pauenc);
            break;
        case TRANSIENT_DETECTION:
            prvDetectTransientChannel (pauenc, 0);
            break;
        }
        SetEvent (pauenc->m_rThreadInfo.m_hEncDone0);
    }

#if !defined(BUILD_INTEGER) && !defined(UNDER_CE) && defined(WMA_TARGET_X86)
    // Free Intel FFT for this thread
    if (pauenc->pau->m_fIntelFFT)
    {
        WMARESULT   wmaResult;

        wmaResult = auFreeIntelFFT(pauenc->pau, INTELFFT_FREE_THREAD);
        TraceError(wmaResult);
    }
#endif  // !defined(BUILD_INTEGER) && !defined(UNDER_CE) && defined(WMA_TARGET_X86)

}

void threadFuncEnc1 (DWORD threadParam)
{
    CAudioObjectEncoder* pauenc = (CAudioObjectEncoder*) threadParam;

#if !defined(BUILD_INTEGER) && !defined(UNDER_CE) && defined(WMA_TARGET_X86)
    // Initialize Intel FFT for this thread
    if (pauenc->pau->m_fIntelFFT)
    {
        WMARESULT   wmaResult;

        wmaResult = auInitIntelFFT(pauenc->pau, INTELFFT_INIT_THREAD);
        TraceError(wmaResult);
    }
#endif  // !defined(BUILD_INTEGER) && !defined(UNDER_CE) && defined(WMA_TARGET_X86)

    for (;;) {
        while (WaitForSingleObject (pauenc->m_rThreadInfo.m_hEncEvent1,
            INFINITE) != WAIT_OBJECT_0);

        if (pauenc->m_rThreadInfo.m_bShutdownThreads)
            break;

        switch (pauenc->tEncStatus) {
        case PROCESS_A:
            prvProcess1A (pauenc);
            break;
        case PROCESS_B:
            prvProcess1B (pauenc);
            break;
        case PROCESS_C:
            prvProcess1C (pauenc);
            break;
        case QUANTIZE_ENTROPY:
            prvQuantizeAndEntropy1 (pauenc);
            break;
        case SEND_STREAM:
            prvSendStream1 (pauenc);
            break;
        case TRANSIENT_DETECTION:
            prvDetectTransientChannel (pauenc, 1);
            break;
        }
        SetEvent (pauenc->m_rThreadInfo.m_hEncDone1);
    }

#if !defined(BUILD_INTEGER) && !defined(UNDER_CE) && defined(WMA_TARGET_X86)
    // Free Intel FFT for this thread
    if (pauenc->pau->m_fIntelFFT)
    {
        WMARESULT   wmaResult;

        wmaResult = auFreeIntelFFT(pauenc->pau, INTELFFT_FREE_THREAD);
        TraceError(wmaResult);
    }
#endif  // !defined(BUILD_INTEGER) && !defined(UNDER_CE) && defined(WMA_TARGET_X86)

}


void osThreadEncAll (THREADINFO *pInfo)
{
    if (pInfo->m_fMultiProc)
    {
        SetEvent (pInfo->m_hEncEvent0);
        SetEvent (pInfo->m_hEncEvent1);
        
        WaitForSingleObject (pInfo->m_hEncDone0, INFINITE);
        WaitForSingleObject (pInfo->m_hEncDone1, INFINITE);
    }
    else
    {
        CAudioObjectEncoder *pauenc = pInfo->m_pauenc;
        
        switch (pauenc->tEncStatus)
        {
        case PROCESS:
            prvProcess0 (pauenc);
            prvProcess1 (pauenc);
            break;

        case PROCESS_A:
            prvProcess0A (pauenc);
            prvProcess1A (pauenc);
            break;

        case PROCESS_B:
            prvProcess0B (pauenc);
            prvProcess1B (pauenc);
            break;

        case PROCESS_C:
            prvProcess0C (pauenc);
            prvProcess1C (pauenc);
            break;
            
        case QUANTIZE_ENTROPY:
            prvQuantizeAndEntropy0 (pauenc);
            prvQuantizeAndEntropy1 (pauenc);
            break;
            
        case SEND_STREAM:
            prvSendStream0 (pauenc);
            prvSendStream1 (pauenc);
            break;
            
        case TRANSIENT_DETECTION:
            prvDetectTransientChannel (pauenc, 0);
            prvDetectTransientChannel (pauenc, 1);
            break;
            
        default:
            assert(WMAB_FALSE);
            break;
        } // switch
        
    } // else
    
} // osThreadEncAll

#else
// We need a placeholder because otherwise MSVC complains about error
// C2183 (the source file is empty after preprocessing).
static void fooWin32(void);
#endif  //!WMA_SERIALIZE
#endif  // ENCODER

#ifdef UNDER_CE
#	ifndef _CLOCK_T_DEFINED
		typedef long clock_t;
#		define _CLOCK_T_DEFINED
#	endif

	clock_t __cdecl clock(void) { 
		return (clock_t)GetTickCount(); 
	}

#	ifndef _TIME_T_DEFINED
		typedef long time_t;        /* time value */
#		define _TIME_T_DEFINED     /* avoid multiple def's of time_t */
#	endif

	time_t __cdecl time(time_t * pt) {
		SYSTEMTIME stNowTime;
		SYSTEMTIME st1970 = { 1970, 1, 0, 1, 0, 0, 0, 0 };
		FILETIME   ftNowTime, ft1970;
		ULARGE_INTEGER ulNowTime, ul1970;
		time_t tNowTime;	// seconds since 1/1/1970
		GetSystemTime( &stNowTime );
		if ( SystemTimeToFileTime( &stNowTime, &ftNowTime ) && SystemTimeToFileTime( &st1970, &ft1970 ) )
		{
			ulNowTime.HighPart = ftNowTime.dwHighDateTime;
			ulNowTime.LowPart  = ftNowTime.dwLowDateTime;
			ul1970.HighPart    = ft1970.dwHighDateTime;
			ul1970.LowPart     = ft1970.dwLowDateTime;
			tNowTime = (time_t)( (ulNowTime.QuadPart - ul1970.QuadPart)/10000000 );
		} else 
		{
			tNowTime = (time_t)clock();
		}
		if ( pt != NULL )
			*pt = tNowTime;
		return tNowTime;
	}
#endif


#endif  // WMA_OSTARGET_WIN32
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\wmalib\wmadec_s\wmadecS_api.c ===
#pragma code_seg("WMADEC")
#pragma data_seg("WMADEC_RW")
#pragma const_seg("WMADEC_RD")

#include "..\decoder\msaudiodec.h"
#include "..\decoder\wmadecS_api.h"
#include "..\common\macros.h"
#include "..\common\msaudio.h"
#include "..\..\..\dsound\dsndver.h"

typedef struct WMARawDecStruct
{
    CAudioObjectDecoder *pAudDecoder;
} WMARawDecStruct;

//#define WMAMEM_SIZE 27280 // for high bitrate
//#define WMAMEM_SIZE 27840 // for all rates
//U8_WMARawDec rgWMAMem [WMAMEM_SIZE];

WMARESULT WMARawDecInit (
    WMARawDecHandle* phWMARawDec,
    U32_WMARawDec dwUserData,
    void * pfnGetMoreData,
    U16_WMARawDec iVersionNumber,
    U16_WMARawDec cSamplesPerBlock, 
    U16_WMARawDec cSamplesPerSecond, 
    U16_WMARawDec cChannel, 
    U16_WMARawDec cBytePerSec, 
    U16_WMARawDec cPacketLength,
    U16_WMARawDec cEncodeOpt,
    U16_WMARawDec cPlayerOpt
) {
    WMARESULT hr;
    WMARawDecStruct* pWMARawDec;

//    phWMARawDec = NULL; // initialize as NULL for later checking
    pWMARawDec = (WMARawDecStruct*) malloc (sizeof (WMARawDecStruct));
    if (pWMARawDec == NULL)
        return WMA_E_OUTOFMEMORY;


    pWMARawDec->pAudDecoder = audecNew (NULL, 0);
//    pWMARawDec->pAudDecoder = audecNew (rgWMAMem, WMAMEM_SIZE);
    if (pWMARawDec->pAudDecoder == NULL)
        return WMA_E_OUTOFMEMORY;

    hr = audecInit (
        pWMARawDec->pAudDecoder,
        (Int) iVersionNumber,
        cSamplesPerBlock,
        cSamplesPerSecond,
        cChannel,
        cBytePerSec,
        cPacketLength,
        cEncodeOpt,
        cPlayerOpt,
        (PFNGETMOREDATA)pfnGetMoreData, 
        dwUserData,
        NULL
    );
// for unsupported formats

	if (hr == 0x80040000)
		return WMA_E_NOTSUPPORTED;
    
	if (WMA_FAILED (hr))
        return WMA_E_FAIL;

    *phWMARawDec = (WMARawDecHandle) pWMARawDec;
    return WMA_OK;
}
    
WMARESULT WMARawDecClose (WMARawDecHandle* phWMARawDec)
{
    WMARawDecStruct* pWMARawDec;

    pWMARawDec = (WMARawDecStruct*) (*phWMARawDec);
    if (pWMARawDec != NULL) {
        if (pWMARawDec->pAudDecoder != NULL) {
            audecDelete (pWMARawDec->pAudDecoder);
            pWMARawDec->pAudDecoder = NULL;
        }
        free (pWMARawDec);
        *phWMARawDec = NULL;
    }
    phWMARawDec = NULL;
    return WMA_OK;
}

WMARESULT WMARawDecReset (WMARawDecHandle hWMARawDec)
{
    WMARawDecStruct* pWMARawDec;
    pWMARawDec = (WMARawDecStruct*) hWMARawDec;

    if (pWMARawDec == NULL || pWMARawDec->pAudDecoder == NULL)
        return WMA_E_INVALIDARG;
    else
        return (audecReset (pWMARawDec->pAudDecoder));
}

WMARESULT WMARawDecStatus (WMARawDecHandle hWMARawDec)
{
    WMARawDecStruct* pWMARawDec;
    pWMARawDec = (WMARawDecStruct*) hWMARawDec;

    if (pWMARawDec == NULL || pWMARawDec->pAudDecoder == NULL)
        return WMA_E_INVALIDARG;
    else
        return (audecDecodeInfo (pWMARawDec->pAudDecoder));
}

WMARESULT WMARawDecDecodeData (WMARawDecHandle hWMARawDec)
{
    WMARawDecStruct* pWMARawDec;
    U16_WMARawDec cSamplesReady;
    pWMARawDec = (WMARawDecStruct*) hWMARawDec;

    if (pWMARawDec == NULL || pWMARawDec->pAudDecoder == NULL)
        return WMA_E_INVALIDARG;
    else
        return (audecDecodeData (pWMARawDec->pAudDecoder, &cSamplesReady));
}

WMARESULT WMARawDecGetPCM (WMARawDecHandle hWMARawDec, U16_WMARawDec* pcSampleReady, U8_WMARawDec* pbDst, U32_WMARawDec cbDstBufferLength)
{
    WMARawDecStruct* pWMARawDec;
    pWMARawDec = (WMARawDecStruct*) hWMARawDec;
    if (pWMARawDec == NULL || pWMARawDec->pAudDecoder == NULL)
        return WMA_E_INVALIDARG;
    else 
        return (audecGetPCM (pWMARawDec->pAudDecoder, pcSampleReady, pbDst, cbDstBufferLength));
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\wmalib\wmadec_s\wmamath.h ===
#ifndef __WMAMATH_H__
#define __WMAMATH_H__

static _declspec(naked) long FloatToLong(float x)
{
    __asm
    {
        cvttss2si eax, [esp+4]
        ret 4
    }
}

#define ftoi(x) (int)FloatToLong(x)

#endif // __WMAMATH_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\wmalib\wmadec_s\wmadec_api.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows Media
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       WMADEC_api.cpp
//
//--------------------------------------------------------------------------

// WMADEC_api.cpp

#pragma code_seg("WMADEC")
#pragma data_seg("WMADEC_RW")
#pragma const_seg("WMADEC_RD")

#include <stdlib.h>  
//#ifdef HITACHI
//typedef long I32;
//typedef unsigned long I32;
//#endif
#include "..\decoder\msaudiodec.h"
#include "..\decoder\wmadec_api.h"
#include "..\..\..\dsound\dsndver.h"


// ===========================================================================
// struct for the handle

#define WMADECHANDLE_MAGIC 0xdcfb8a8e

typedef struct _tCWMADECHANDLE
{
    // magic is just to check for a validity
    unsigned long magic;

    // needed later (acquired at init time)
    long nFrameLength;

    // the actual object
    CAudioObjectDecoder *pDecoder;

} CWMADECHANDLE;

long
WMADEChIsValid(CWMADECHANDLE *pHandle)
{
    return pHandle != NULL &&
           pHandle->magic == WMADECHANDLE_MAGIC &&
           pHandle->pDecoder != NULL;
}

CWMADECHANDLE *
WMADEChNew()
{
    CWMADECHANDLE *pHandle = (CWMADECHANDLE *)malloc(sizeof(CWMADECHANDLE));
    if(pHandle == NULL)
        return NULL;

    pHandle->magic        = WMADECHANDLE_MAGIC;
    pHandle->nFrameLength = 0;
    pHandle->pDecoder     = NULL;

    return pHandle;
}

void
WMADEChDelete(CWMADECHANDLE *pHandle)
{
    if(pHandle)
    {
        if(pHandle->pDecoder)
        {
            audecDelete(pHandle->pDecoder);
            pHandle->pDecoder = NULL;
        }
        free(pHandle);
    }
}


// ===========================================================================
// WMADECCreate()
//
// Creates a Microsoft Audio decoder object and returns it.
//
// Input: nVersion         : version of the WMA
//        nSamplesPerSec   : sampling rate in Hz
//        nChannels        : number of channels (1 for mono and 2 for stereo)
//        nBytesPerSec     : bits per second times 8
//        nSamplesPerBlock : decoded samples per block (powers of 2)
//        nFrameLength     : encoded frame length in bytes
//        nEncodeOpt       : encoding mode option (0 or 1)
//        nPlayerOpt       : decoding mode, see defines in the .h file.
//
// Returns NULL if not successful.

WMADECHANDLE
WMADECCreate(long nVersion,
           long nSamplesPerSec,
           long nChannels,
           long nBytesPerSec,
           long nSamplesPerBlock,
           long nFrameLength,
           long nEncodeOpt,
           long nPlayerOpt)
{
    WMARESULT hr;
    CWMADECHANDLE *pHandle = NULL;

    // create the handle
    pHandle = WMADEChNew();
    if(pHandle == NULL)
        goto lerror;

    // create the object
    pHandle->pDecoder = audecNew(NULL, 0);
    if(pHandle->pDecoder == NULL)
        goto lerror;

    // store this for later
    pHandle->nFrameLength = nFrameLength;

    // initialize the object
    hr = audecInit(pHandle->pDecoder,
                   nVersion,
                   nSamplesPerBlock,
                   nSamplesPerSec,
                   (U16)nChannels,
                   nBytesPerSec,
                   nFrameLength,
                   (U16)nEncodeOpt, 
                   (U16)nPlayerOpt,
                   NULL, (U32)0, NULL);
    if(hr != WMADECERR_NOERROR)
        goto lerror;


    return (WMADECHANDLE)pHandle;

lerror:
    if(pHandle)
        WMADEChDelete(pHandle);
    return NULL;
}


// ===========================================================================
// WMADECDestroy()
//
// Destroys the given Microsoft Audio decoder handle.

WMADECERROR
WMADECDestroy(WMADECHANDLE hDecoder)
{
    CWMADECHANDLE *pHandle = (CWMADECHANDLE *)hDecoder;

    // check for a valid handle
    if(!WMADEChIsValid(pHandle))
        return WMADECERR_INVALIDHANDLE;

    // destroy the object and the handle
    audecDelete(pHandle->pDecoder);
    pHandle->pDecoder = NULL;
    WMADEChDelete(pHandle);

    return WMADECERR_NOERROR;
}


// ===========================================================================
// WMADECDecode()
//
// Decodes the memory block with the previous created handle.
//
// Input: pSrc      : pointer to the source buffer
//        nSrcLen   : size of the source buffer in bytes
//        pnSrcUsed : pointer to receive the actual number of source bytes
//                    used
//        pDst      : pointer to the destination buffer
//        nDstLen   : size of the destination buffer in bytes
//        pnDstUsed : pointer to receive the actual number of destination
//                    bytes used

WMADECERROR
WMADECDecode(WMADECHANDLE hDecoder,
           unsigned char *pSrc,
           unsigned long nSrcLen,
           unsigned long *pnSrcUsed,
           unsigned char *pDst,
           unsigned long nDstLen,
           unsigned long *pnDstUsed,
           unsigned long *pnSamplesFromBefore
)
{
    WMARESULT hr;
    //NQF+
    //long nSrcUsed, nDstUsed;
    Int nSrcUsed, nDstUsed;    
    //NQF-
    CWMADECHANDLE *pHandle = (CWMADECHANDLE *)hDecoder;

    // check for a valid handle
    if(!WMADEChIsValid(pHandle))
        return WMADECERR_INVALIDHANDLE;

    // check for the memory pointers
    if(pSrc == NULL || pDst == NULL)
        return WMADECERR_INVALIDPOINTER;

    // decode
    hr = audecDecode(pHandle->pDecoder,
                     pSrc, nSrcLen, &nSrcUsed,
                     pDst, nDstLen, &nDstUsed,
                     NULL, 0, NULL, (long *)pnSamplesFromBefore);
	if (hr == 4)
		hr = WMADECERR_NOERROR; 
	if(hr != WMADECERR_NOERROR)
        return WMADECERR_FAIL;

    // update the out arguments
    if(pnSrcUsed)
        *pnSrcUsed = nSrcUsed;
    if(pnDstUsed)
        *pnDstUsed = nDstUsed;

    return WMADECERR_NOERROR;
}


// ===========================================================================
// WMADECFlush()
//
// Flushes out the internally buffered data, if any.
//
// Input: pDst      : pointer to the destination buffer
//        nDstLen   : size of the destination buffer in bytes
//        pnDstUsed : pointer to receive the actual number of destination
//                    bytes used

WMADECERROR
WMADECFlush(WMADECHANDLE hDecoder,
          unsigned char *pDst,
          unsigned long nDstLen,
          unsigned long *pnDstUsed)
{
    WMARESULT hr;
    //NQF+
    //long nDstUsed;
    Int nDstUsed;
    //NQF-
    
    CWMADECHANDLE *pHandle = (CWMADECHANDLE *)hDecoder;

    // check for a valid handle
    if(!WMADEChIsValid(pHandle))
        return WMADECERR_INVALIDHANDLE;

    // check for the memory pointers
    if(pDst == NULL)
        return WMADECERR_INVALIDPOINTER;
    
    // flush
    hr = audecFlush(pHandle->pDecoder,
                    pDst, nDstLen, &nDstUsed,
                    NULL, 0, NULL, NULL);
    if(hr != WMADECERR_NOERROR)
        return WMADECERR_FAIL;

    // update the out argument
    if(pnDstUsed)
        *pnDstUsed = nDstUsed;

    return WMADECERR_NOERROR;
}


// ===========================================================================
// WMADECOutputBufferSize()
//
// Returns the minimum Output Buffer Size for WMADECDecode.
//
// Input: nVersion         : version of the WMA
//        nSamplesPerSec   : sampling rate in Hz
//        nChannels        : number of channels (1 for mono and 2 for stereo)
//        nBytesPerSec     : bits per second times 8
//        nEncodeOpt       : encoding mode option (0 or 1)

unsigned long WMADECOutputBufferSize(long nVersion, 
                                     long nSamplingRate, 
                                     long nChannels, 
                                     long nBytesPerSec, 
                                     long nEncodeOpt)
{
    return (unsigned long)audecOutputBufferSize( (Int)nVersion, (Int)nSamplingRate, (Int)nChannels, 
                                                 (Int)nBytesPerSec, (U16)nEncodeOpt);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\wmalib\wmadec_s\wmaos.c ===
/*************************************************************************

Copyright (C) Microsoft Corporation, 1996 - 1999

Module Name:

    WmaOS.c

Abstract:

    Functions that should work under any generic OS.

Author:

    Raymond Cheng (raych)       September 27, 1999

Revision History:


*************************************************************************/

#pragma code_seg("WMADEC")
#pragma data_seg("WMADEC_RW")
#pragma const_seg("WMADEC_RD")

#include "msaudio.h"
#include "macros.h"
#include "AutoProfile.h"
#include <stdio.h>
#include "..\..\..\dsound\dsndver.h"
#if defined(_DEBUG) && defined(WMA_MONITOR)
#	include <math.h>
#endif
#if defined(HEAP_DEBUG_TEST) && defined(_DEBUG)
#include <malloc.h>
#endif
#if defined(WMA_SHOW_FRAMES) && defined(_DEBUG)
#include <stdarg.h>
#endif

#ifndef PLATFORM_SPECIFIC_PERFTIMER

#include <time.h>

typedef struct tagPERFTIMERINFO
{
    int     fFirstTime;         // Used to record total time spent in decode loop
    clock_t cDecodeTime;        // Time spent decoding only (running total)
    clock_t cTotalDecLoopTime;  // Total time spent in decode loop
    clock_t cDecodeStart;       // Could be easily optimized out but it's not worth it
    long    lSamplesPerSec;     // Samples per second, counting all channels
    long    lPlaybackTime;      // Time required for playback (running total)
} PERFTIMERINFO;

PERFTIMERINFO *PerfTimerNew(long lSamplesPerSecOutput)
{
    PERFTIMERINFO  *pInfo;

    pInfo = (PERFTIMERINFO*)(malloc(sizeof(PERFTIMERINFO)));
    if (NULL == pInfo)
        return NULL;

    pInfo->fFirstTime = WMAB_TRUE;
    pInfo->cDecodeTime = 0;
    pInfo->cTotalDecLoopTime = 0;
    pInfo->cDecodeStart = 0;
    pInfo->lSamplesPerSec = lSamplesPerSecOutput;
    pInfo->lPlaybackTime = 0;

    return pInfo;
}

void PerfTimerStart(PERFTIMERINFO *pInfo)
{
    pInfo->cDecodeStart = clock();

    if (pInfo->fFirstTime)
    {
        pInfo->cTotalDecLoopTime = pInfo->cDecodeStart;
        pInfo->fFirstTime = WMAB_FALSE;
    }
}

void PerfTimerStop(PERFTIMERINFO *pInfo, long lSamplesDecoded)
{
    clock_t cDecodeTime;

    cDecodeTime = clock() - pInfo->cDecodeStart;
    pInfo->cDecodeTime += cDecodeTime;

    // Record output playback time from this decode call, in clock() ticks
    pInfo->lPlaybackTime += lSamplesDecoded * CLOCKS_PER_SEC / pInfo->lSamplesPerSec;
}

void PerfTimerStopElapsed(PERFTIMERINFO *pInfo)
{
    pInfo->cTotalDecLoopTime = clock() - pInfo->cTotalDecLoopTime;
}

void PerfTimerReport(PERFTIMERINFO *pInfo)
{
    char    sz[256];
    float   fltDecodeTime;
    float   fltEntireDecodeTime;
    float   fltDecodeTimeFraction;
    float   fltPlaybackTime;

    sprintf(sz, "\n\n** Ticks per second (clock resolution): %ld.\n", CLOCKS_PER_SEC);
    OUTPUT_DEBUG_STRING(sz);

    fltDecodeTime = (float) pInfo->cDecodeTime / (float) CLOCKS_PER_SEC;
    fltEntireDecodeTime = (float) pInfo->cTotalDecLoopTime /
        (float) CLOCKS_PER_SEC;
    sprintf(sz, "** Decode time: %f sec. Entire decode time: %f sec.\n",
        fltDecodeTime, fltEntireDecodeTime);
    OUTPUT_DEBUG_STRING(sz);

    fltPlaybackTime = (float) pInfo->lPlaybackTime / (float) CLOCKS_PER_SEC;
    sprintf(sz, "** Playback time : %f sec.\n",
        fltPlaybackTime);
    OUTPUT_DEBUG_STRING(sz);

    fltDecodeTimeFraction = (float)pInfo->cDecodeTime / (float) pInfo->lPlaybackTime;
    sprintf(sz, "** Percentage of playback time spent decoding: %f%%.\n",
        fltDecodeTimeFraction * 100);
    OUTPUT_DEBUG_STRING(sz);
#	if defined(WMA_MONITOR)
		fprintf(stderr,"%s\n",sz);
#	endif

    sprintf(sz, "** Minimum MHz for realtime playback: %f of current CPU speed.\n",
        fltDecodeTimeFraction);
    OUTPUT_DEBUG_STRING(sz);

    sprintf(sz, "** This CPU is %f times faster than required.\n\n",
        (float)1.0 / fltDecodeTimeFraction);
    OUTPUT_DEBUG_STRING(sz);

}

float fltPerfTimerDecodeTime(PERFTIMERINFO *pInfo)
{
    return (float) pInfo->cDecodeTime / (float) CLOCKS_PER_SEC;
}

void PerfTimerFree(PERFTIMERINFO *pInfo)
{
    free(pInfo);
}

#endif  // PLATFORM_SPECIFIC_PERFTIMER


#if !defined(PLATFORM_SPECIFIC_DEBUGINFRASTRUCTURE) && defined(_DEBUG)
#include <stdarg.h>
void TraceInfoHelper(const char *pszFile, int iLine, const char *pszFmt, ...)
{
    char    sz[512];
    va_list vargs;
    Int     iCharsWritten;

    // Prepend file/line identifier and "*** INFO ***" to get attention
    iCharsWritten = sprintf(sz, "%s(%d) : *** INFO *** ", pszFile, iLine);

    va_start(vargs, pszFmt);
    iCharsWritten += vsprintf(sz + iCharsWritten, pszFmt, vargs);
    va_end(vargs);

    // Append a newline and print it!
    sprintf(sz + iCharsWritten, "\n");
    OUTPUT_DEBUG_STRING(sz);
}



#endif  // !!defined(PLATFORM_SPECIFIC_DEBUGINFRASTRUCTURE) && defined(_DEBUG)

#if DBG

WMARESULT MyOutputDbgStr(WMARESULT wmaReturn, const char *pszFmt, ...)
{
#if 0
    char    sz[512];
    va_list vargs;

    va_start(vargs, pszFmt);
    vsprintf(sz, pszFmt, vargs);
    va_end(vargs);

    OUTPUT_DEBUG_STRING(sz);
    return wmaReturn;
#endif
    return wmaReturn;
}

#endif

#if defined(_DEBUG) && defined(WMA_MONITOR)

#define DECL_MONITOR_RANGE(a) extern double a[4] = { 1.0e30, -1.0e30, 0, 0 };  extern long lc##a = 0;

// declare and define some range monitors in _DEBUG mode when WMA_MONITOR is defined
DECL_MONITOR_RANGE(gMR_iQuantStepSize)
DECL_MONITOR_RANGE(gMR_qstQuantStep)
DECL_MONITOR_RANGE(gMR_iCoefQ);
DECL_MONITOR_RANGE(gMC_0CoefQ);
DECL_MONITOR_RANGE(gMR_rgiMaskQ)
DECL_MONITOR_RANGE(gMR_rgiNoisePower)				// only for LowRate and MidRate
DECL_MONITOR_RANGE(gMR_rgiLspFreqQ)					// only for LowRate, e.g. LPC
DECL_MONITOR_RANGE(gMR_rgfltLspFreq)				// only for LowRate, e.g. LPC
DECL_MONITOR_RANGE(gMR_fltLPC_F)					// only for LowRate, e.g. LPC
DECL_MONITOR_RANGE(gMR_fltLPC_F1)					// only for LowRate, e.g. LPC
DECL_MONITOR_RANGE(gMR_fltLPC_F2)					// only for LowRate, e.g. LPC
DECL_MONITOR_RANGE(gMR_fltLPC_F3)					// only for LowRate, e.g. LPC
DECL_MONITOR_RANGE(gMR_rgfltWeightFactor)
DECL_MONITOR_RANGE(gMR_WeightRatio)
DECL_MONITOR_RANGE(gMR_rgfltBandWeight)				// only for MidRate and LowRate
DECL_MONITOR_RANGE(gMR_rgffltSqrtBWRatio)
DECL_MONITOR_RANGE(gMR_CoefRecon)
DECL_MONITOR_RANGE(gMC_zeroCoefRecon)
DECL_MONITOR_RANGE(gMR_DCTCoefIntoFFT)
DECL_MONITOR_RANGE(gMR_DCTCoefOut)
DECL_MONITOR_RANGE(gMC_ScalePowerToRMS)
DECL_MONITOR_RANGE(gMC_ScaleInverseQuadRoot)
DECL_MONITOR_RANGE(gMC_IQ)
//DECL_MONITOR_RANGE(gMC_IQ_iFractionBitsQuantStep)
DECL_MONITOR_RANGE(gMC_IQ_cQSIMWFracBits)
DECL_MONITOR_RANGE(gMR_QuantStepXInvMaxWeight)
DECL_MONITOR_RANGE(gMR_QuantStepXMaxWeightXWeightFactor)
DECL_MONITOR_RANGE(gMC_IQ_cWFFracBits)
DECL_MONITOR_RANGE(gMR_weightFactor)
DECL_MONITOR_RANGE(gMC_IQ_scale)
DECL_MONITOR_RANGE(gMC_IQ_scale2)
DECL_MONITOR_RANGE(gMC_IQ_Float)
DECL_MONITOR_RANGE(gMC_IQ_fltNoisePowCount)
DECL_MONITOR_RANGE(gMC_GBW_floats)

#if defined(WMA_MONITOR_FILE)
#	if defined(OUTPUT_DEBUG_STRING)
#		undef DUMP_MONITOR_RANGE
#		define DUMP_MONITOR_RANGE(a) if (lc##a>0) { sprintf(sz,"%14.6g %14.6g %14.6g %14.6g %8ld " #a "\n", a[0], a[1], a[2]/lc##a, sqrt((lc##a*a[3]-a[2]*a[2])/(((double)lc##a)*(lc##a-1))), lc##a ); OUTPUT_DEBUG_STRING(sz); }
#	else
#		undef DUMP_MONITOR_RANGE
#		define DUMP_MONITOR_RANGE(a) if (lc##a>0) fprintf(fp,"%14.6g %14.6g %14.6g %14.6g %8ld " #a "\n", a[0], a[1], a[2]/lc##a, sqrt((lc##a*a[3]-a[2]*a[2])/(((double)lc##a)*(lc##a-1))), lc##a );
#	endif
#endif

void DumpMonitorRanges(int fAppend) {
	FILE* fp = NULL;
#	if defined(WMA_MONITOR_FILE)
#		if defined(OUTPUT_DEBUG_STRING)
			char sz[256];
			int bODX = 0;
			if ( stricmp(WMA_MONITOR_FILE,"OutputDebugString")
				bODS = 1;
			else 
#		endif	// defined(OUTPUT_DEBUG_STRING)
		if ( stricmp(WMA_MONITOR_FILE,"stdout")
			fp = stdout;
		else
			fp = fopen(WMA_MONITOR_FILE,fAppend ? "w+" : "w");
#	else
		fp = stdout;
#	endif		

#	if defined(OUTPUT_DEBUG_STRING)
		if ( bODX )
			OUTPUT_DEBUG_STRING("\n       Minimum        Maximum           Mean StandDeviation    Count Variable\n");
		else
#	endif
		fprintf(fp,"\n       Minimum        Maximum           Mean StandDeviation    Count Variable\n");

	DUMP_MONITOR_RANGE(gMR_iQuantStepSize);
	DUMP_MONITOR_RANGE(gMR_qstQuantStep);
	DUMP_MONITOR_RANGE(gMR_iCoefQ);
	DUMP_MONITOR_RANGE(gMC_0CoefQ);
	DUMP_MONITOR_RANGE(gMR_rgiMaskQ);
#	ifdef ENABLE_LPC
		DUMP_MONITOR_RANGE(gMR_rgiLspFreqQ);
#		ifndef BUILD_INTEGER
			DUMP_MONITOR_RANGE(gMR_rgfltLspFreq);
#		endif
		DUMP_MONITOR_RANGE(gMR_fltLPC_F1);
		DUMP_MONITOR_RANGE(gMR_fltLPC_F2);
		DUMP_MONITOR_RANGE(gMR_fltLPC_F3);
#	endif
	DUMP_MONITOR_RANGE(gMR_rgiNoisePower);
	DUMP_MONITOR_RANGE(gMR_rgfltWeightFactor);
	DUMP_MONITOR_RANGE(gMR_WeightRatio);
	DUMP_MONITOR_RANGE(gMR_rgfltBandWeight);
	DUMP_MONITOR_RANGE(gMR_rgffltSqrtBWRatio);
	DUMP_MONITOR_RANGE(gMR_CoefRecon);
	DUMP_MONITOR_RANGE(gMC_zeroCoefRecon);
	DUMP_MONITOR_RANGE(gMR_DCTCoefIntoFFT);
	DUMP_MONITOR_RANGE(gMR_DCTCoefOut);
	DUMP_MONITOR_RANGE(gMR_QuantStepXInvMaxWeight);
	DUMP_MONITOR_RANGE(gMR_QuantStepXMaxWeightXWeightFactor);

	DUMP_MONITOR_RANGE(gMR_weightFactor);

	DUMP_MONITOR_RANGE(gMC_ScalePowerToRMS);
	DUMP_MONITOR_RANGE(gMC_ScaleInverseQuadRoot);
	DUMP_MONITOR_RANGE(gMC_IQ);
	//DUMP_MONITOR_RANGE(gMC_IQ_iFractionBitsQuantStep);
	DUMP_MONITOR_RANGE(gMC_IQ_cQSIMWFracBits);
	DUMP_MONITOR_RANGE(gMC_IQ_cWFFracBits);
	DUMP_MONITOR_RANGE(gMC_IQ_scale);
	DUMP_MONITOR_RANGE(gMC_IQ_scale2);
	DUMP_MONITOR_RANGE(gMC_IQ_Float);
	DUMP_MONITOR_RANGE(gMC_IQ_fltNoisePowCount);
	DUMP_MONITOR_RANGE(gMC_GBW_floats);
	if ( fp != NULL && fp != stdout )
		fclose(fp);
}
#	pragma COMPILER_MESSAGE(__FILE__ "(302) : Warning - WMA_MONITOR Debug Code Enabled.")
#endif


#if defined(WMA_SHOW_FRAMES) && defined(_DEBUG)

static FILE* fileShowFrames = NULL;

void prvWmaShowFrames(CAudioObject* pau, const char* pszID, const char* pszFmt, ...) {
#ifdef UNDER_CE
    if ( fileShowFrames == NULL )
        fileShowFrames = fopen("ShowFrames.txt","wt");
    if ( fileShowFrames == NULL )
        return;
#else
	fileShowFrames = stderr;
#endif
    fprintf(fileShowFrames,"%7s %3d.%d [%4d %4d %4d]",
        pszID,
        pau->m_iFrameNumber,
        pau->m_iCurrSubFrame,
        pau->m_cFrameSampleAdjusted,
        pau->m_cSubFrameSampleAdjusted,
        pau->m_cSubbandAdjusted
    );
    if ( pszFmt != NULL )
    {
        char    sz[512];
        va_list vargs;

        va_start(vargs, pszFmt);
        vsprintf(sz, pszFmt, vargs);
        va_end(vargs);

        fprintf(fileShowFrames,"%s",sz);
    }
    fprintf(fileShowFrames,"\n" );
}

#	pragma COMPILER_MESSAGE(__FILE__ "(341) : Warning - SHOW_FRAMES Debug Code Enabled.")
#endif

#if defined(BUILD_INT_FLOAT) && ( defined(WMA_TARGET_SH3) || defined(WMA_TARGET_MIPS) )
#	pragma COMPILER_MESSAGE(__FILE__ "(345) : Warning - Integer Float Build.")
#endif
#ifdef PROFILE
#	pragma COMPILER_MESSAGE(__FILE__ "(348) : Warning - PROFILE Enabled.")
#endif
#if defined(SDE_WANTS_ASSERTS) && defined(_DEBUG)
#	pragma COMPILER_MESSAGE(__FILE__ "(351) : Warning - Asserts are enabled - for SDE use only!")
#endif

#if defined(HEAP_DEBUG_TEST) && defined(_DEBUG)
// check the heap - see macros in msaudio.h
// _heapchk does not seem to be available under WinCE
void HeapDebugCheck()
	{ int  heapstatus;
	   /* Check heap status */
	   heapstatus = _heapchk();
	   switch( heapstatus )
	   {
	   case _HEAPOK:
		  //printf(" OK - heap is fine\n" );
		  break;
	   case _HEAPEMPTY:
		  printf(" OK - heap is empty\n" );
		  break;
	   case _HEAPBADBEGIN:
		  printf( "ERROR - bad start of heap\n" );
		  break;
	   case _HEAPBADNODE:
		  printf( "ERROR - bad node in heap\n" );
		  break;
	   }
	}
#endif

#ifdef UNDER_CE
// se need to define at least one public symbol
extern void wmaos_pacify(void) {}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\wmalib\wmadec_s\wmaudio.c ===
/*
 * Windows Media Audio (WMA) Decoder API (implementation)
 *
 * Copyright (c) Microsoft Corporation 1999.  All Rights Reserved.
 */

#pragma code_seg("WMADEC")
#pragma data_seg("WMADEC_RW")
#pragma const_seg("WMADEC_RD")

#include <stdio.h>
#include "malloc.h"

#if defined _WIN32
#include <windows.h>
#define _BOOL_DEFINED
#endif
#pragma warning( disable : 4005 )
#if ( defined(BOOL) || defined(_WIN32_WCE) ) && !defined(_BOOL_DEFINED)
#define _BOOL_DEFINED
#endif
#include "wmaudio.h"
#include "loadstuff.h"
#include "wmaudio_type.h"
#include "wmaguids.h"
//#include "msaudiodec.h"
#include "AutoProfile.h"
#include "..\decoder\wmadecS_api.h"
#include "..\..\..\dsound\dsndver.h"


#ifndef MIN
#define MIN(x, y)  ((x) < (y) ? (x) : (y))
#endif /* MIN */

//extern int iSubFrm;

#define WMAAPI_DEMO_LIMIT 60
//static const WMARESULT WMA_E_ONHOLD         = 0x80040004; 



//BYTE bGlobalDataBuffer[256];
#if 0
/****************************************************************************/
extern "C" size_t
strlen(const char *p)
{
    int cnt = 0;
    while(*p++)
    {
        cnt++;
    }
    return cnt;
}
#endif


/****************************************************************************/
/*
static tWMAFileStatus
TranslateCode(tWMAStatus rc)
{
    switch(rc)
    {
    case kWMA_NoErr:
        return cWMA_NoErr;
    case kWMA_BrokenFrame:
        return cWMA_BrokenFrame;
    case kWMA_NoMoreFrames:
        return cWMA_NoMoreFrames;
    case kWMA_BadSamplingRate:
        return cWMA_BadSamplingRate;
    case kWMA_BadNumberOfChannels:
        return cWMA_BadNumberOfChannels;
    case kWMA_BadVersionNumber:
        return cWMA_BadVersionNumber;
    case kWMA_BadWeightingMode:
        return cWMA_BadWeightingMode;
    case kWMA_BadPacketisation:
        return cWMA_BadPacketization;
    }

#ifdef LOCAL_DEBUG
    while(1);
#else
    return cWMA_Internal;
#endif
}
*/

/****************************************************************************/
static tWMAFileStatus WMAF_UpdateNewPayload (tWMAFileStateInternal *pInt)
{
    /* internal call, so pInt should be okay */

    /* HongCho: separated out these parts from the parsing loop, because
     *          other parts (when a new payload is about to be retrieved)
     *          need to update the offsets and other states.
     *
     *          used in WMAFileDecodeData() and WMARawDecCBGetData ().
     */

    WMAERR wmarc;
#ifndef WMAAPI_NO_DRM
    tWMA_U32 cbRead;
    HRESULT hr;
    BYTE *pLast15;
#endif
#ifndef WMAAPI_NO_DRM_STREAM
    tWMA_U32 cbLeftover;
    BYTE *pbDRMPayload;
    WORD wDRMOffset;
#endif

    do
    {
        switch (pInt->parse_state)
        {
        case csWMA_NewAsfPacket:

#ifdef WMAAPI_DEMO
            if (pInt->nSampleCount >= WMAAPI_DEMO_LIMIT*pInt->hdr_parse.nSamplesPerSec)
            {
                return cWMA_DemoExpired;
            }
#endif /* WMAAPI_DEMO */

            if (pInt->hdr_parse.nextPacketOffset > pInt->hdr_parse.cbLastPacketOffset)
            {
                return cWMA_NoMoreFrames;
            }

            pInt->hdr_parse.currPacketOffset = pInt->hdr_parse.nextPacketOffset;
            pInt->hdr_parse.nextPacketOffset += pInt->hdr_parse.cbPacketSize;

            wmarc = WMA_ParsePacketHeader (pInt);

			if (wmarc == WMAERR_BUFFERTOOSMALL)
			{
				pInt->hdr_parse.nextPacketOffset = pInt->hdr_parse.currPacketOffset;
			//	pInt->hdr_parse.currPacketOffset -= pInt->hdr_parse.cbPacketSize;
				return cWMA_NoMoreDataThisTime;
			}


            if(wmarc != WMAERR_OK)
            {
                return cWMA_BadPacketHeader;
            }

            if (pInt->ppex.fEccPresent && pInt->ppex.fParityPacket)
            {
                /* HongCho: for some reason, ARM's code thinks a parity packet is
                 *          only at the end...  Here, I am not assuming that.
                 */
                break;
            }

            pInt->parse_state = csWMA_DecodePayloadStart;
            pInt->iPayload = 0;
            break;

        case csWMA_DecodePayloadStart:

            if (pInt->iPayload >= pInt->ppex.cPayloads)
            {
                pInt->parse_state = csWMA_NewAsfPacket;
                break;
            }

            wmarc = WMA_ParsePayloadHeader(pInt);
            if(wmarc != WMAERR_OK)
            {
                pInt->parse_state = csWMA_DecodePayloadEnd;
                break;
            }

            pInt->wPayStart = pInt->payload.cbPacketOffset + pInt->payload.cbTotalSize
                            - pInt->payload.cbPayloadSize;

#ifndef WMAAPI_NO_DRM_STREAM
            if( pInt->payload.bStreamId == pInt->hdr_parse.bDRMAuxStreamNum )
            {
                /* Read this payload's data (should be 7-15 bytes) */
                cbRead = WMAFileCBGetData(
                                    (tHWMAFileState *) pInt,
                                    ((tHWMAFileState *)pInt)->pCallbackContext,                                    
                                    pInt->hdr_parse.currPacketOffset + pInt->wPayStart,
                                    pInt->payload.cbPayloadSize,
                                    &pbDRMPayload );
                
                if (cbRead != pInt->payload.cbPayloadSize)
                    return (cWMA_NoMoreFrames);

                if (cbRead > sizeof (pInt->rgbNextPayloadEnd))
                    cbRead = sizeof (pInt->rgbNextPayloadEnd);

                cbLeftover = sizeof (pInt->rgbNextPayloadEnd) - cbRead;

                /* Copy this payload's data into our internal state data */
                pInt->cbNextPayloadEndValid = (BYTE) cbRead - 1;

                memset( pInt->rgbNextPayloadEnd, 0, 15 );
                memcpy( pInt->rgbNextPayloadEnd + 7, pbDRMPayload+1, cbRead-1 );

                /* Move on to the next payload, which should be the corresponding audio data */
                pInt->parse_state = csWMA_DecodePayloadEnd;
                break;
            }
#endif  /* WMAAPI_NO_DRM_STREAM */

            if( pInt->payload.cbRepData != 1 )
            {
                pInt->parse_state = csWMA_DecodePayload;
                pInt->payload.bIsCompressedPayload =0; // Amit to take care of compressed payloads.
                break;
            }
            else if(pInt->payload.cbRepData == 1)    // Amit to take care of compressed payloads.
            {
                pInt->parse_state = csWMA_DecodeCompressedPayload;
                pInt->payload.bIsCompressedPayload =1;
                break;
            }
            /* a payload has to be a multiple of audio "packets" */

            if(pInt->payload.cbPayloadSize%pInt->hdr_parse.nBlockAlign != 0)
                return cWMA_BrokenFrame;

            pInt->parse_state = csWMA_DecodePayloadEnd;
            break;

        case csWMA_DecodePayload:
            if (pInt->payload.bStreamId !=pInt->hdr_parse.wAudioStreamId) // Added by Amit to skip Video Payload
            {
                 pInt->parse_state = csWMA_DecodePayloadEnd;
                break;
           
            }
            pInt->cbPayloadOffset = pInt->hdr_parse.currPacketOffset + pInt->wPayStart;
            pInt->bBlockStart     = TRUE;
            pInt->cbBlockLeft     = pInt->hdr_parse.nBlockAlign;
            pInt->cbPayloadLeft   = pInt->payload.cbPayloadSize - pInt->cbBlockLeft;

            /* new payload, so take care of DRM */

            if(pInt->bHasDRM)
            {

#ifdef WMAAPI_NO_DRM

                return cWMA_DRMUnsupported;

#else  /* WMAAPI_NO_DRM */

#ifndef WMAAPI_NO_DRM_STREAM

                if( 0 != pInt->cbNextPayloadEndValid )
                {
                    /* We pre-cached the last bytes of this payload - no need to seek / read */
                    pLast15 = pInt->rgbNextPayloadEnd;

                    /* Move the bytes to the appropriate offset */
                    wDRMOffset = pInt->payload.cbPayloadSize % 8;

                    if( ( 0 != wDRMOffset ) && ( 8 == pInt->cbNextPayloadEndValid ) )
                    {
                        memmove( pLast15 + 7 - wDRMOffset, pLast15 + 7, 8 );
                        memset( pLast15 + 15 - wDRMOffset, 0, wDRMOffset );
                    }
                }
                else
                {

#endif  /* WMAAPI_NO_DRM_STREAM */

                    /* We need to seek & read the last data from the end of this payload */
                    cbRead = WMAFileCBGetData(
                                    (tHWMAFileState *)pInt,
                                    ((tHWMAFileState *)pInt)->pCallbackContext,
                                    pInt->cbPayloadOffset + pInt->payload.cbPayloadSize - 15,
                                    15,
                                    &pLast15 );

                    if (cbRead != 15)
                        return (cWMA_NoMoreFrames);

#ifndef WMAAPI_NO_DRM_STREAM
                }
#endif  /* WMAAPI_NO_DRM_STREAM */

                /* Initialize DRM so it can decrypt this payload properly */

                hr = CDrmPD_InitPacket(pInt->pDRM_state, pLast15, pInt->payload.cbPayloadSize);
                if(hr != S_OK)
                {
#ifdef LOCAL_DEBUG
                    SerialPrintf("++ WMA_UpdateNewPayload: CDrmPD_InitPacket failed (0x%08x).\n\r", hr);
#endif /* LOCAL_DEBUG */
                    return cWMA_DRMFailed;
                }

#ifndef WMAAPI_NO_DRM_STREAM
                pInt->cbNextPayloadEndValid = 0;
#endif  /* WMAAPI_NO_DRM_STREAM */

#endif /* WMAAPI_NO_DRM */

            }

            /* Done updating */
/*            if (pInt->bDecInWaitState == 1)
			{
				pInt->parse_state = csWMA_DecodeLoopStart;
				pInt->bDecInWaitState =0;
			
			}
			else */
			{
				pInt->parse_state = csWMA_DecodePayloadHeader;
			}
            return cWMA_NoErr;

        case csWMA_DecodePayloadEnd:
            pInt->iPayload++;
            pInt->parse_state = csWMA_DecodePayloadStart;
            break;

        case csWMA_DecodeCompressedPayload: // Added by Amit to take care of compressed payloads
            if (pInt->payload.bStreamId !=pInt->hdr_parse.wAudioStreamId) // Added by Amit to skip Video Payload
            {
                 pInt->parse_state = csWMA_DecodePayloadEnd;
                break;           
            }
            pInt->cbPayloadOffset = pInt->hdr_parse.currPacketOffset + pInt->wPayStart;
            pInt->bBlockStart     = TRUE;
            pInt->cbBlockLeft     = pInt->hdr_parse.nBlockAlign;
            pInt->payload.wBytesRead =0;
            pInt->payload.bSubPayloadState = 1;

/****************************************************************************************/    
            
            /* new payload, so take care of DRM */

            if(pInt->bHasDRM)
            {

#ifdef WMAAPI_NO_DRM

                return cWMA_DRMUnsupported;

#else  /* WMAAPI_NO_DRM */

#ifndef WMAAPI_NO_DRM_STREAM

                if( 0 != pInt->cbNextPayloadEndValid )
                {
                    /* We pre-cached the last bytes of this payload - no need to seek / read */
                    pLast15 = pInt->rgbNextPayloadEnd;

                    /* Move the bytes to the appropriate offset */
                    wDRMOffset = pInt->payload.cbPayloadSize % 8;

                    if( ( 0 != wDRMOffset ) && ( 8 == pInt->cbNextPayloadEndValid ) )
                    {
                        memmove( pLast15 + 7 - wDRMOffset, pLast15 + 7, 8 );
                        memset( pLast15 + 15 - wDRMOffset, 0, wDRMOffset );
                    }
                }
                else
                {

#endif  /* WMAAPI_NO_DRM_STREAM */

                    /* We need to seek & read the last data from the end of this payload */
                    cbRead = WMAFileCBGetData(
                                    (tHWMAFileState *)pInt,
                                    ((tHWMAFileState *)pInt)->pCallbackContext,
                                    pInt->cbPayloadOffset + pInt->payload.cbPayloadSize - 15,
                                    15,
                                    &pLast15 );

                    if (cbRead != 15)
                        return (cWMA_NoMoreFrames);

#ifndef WMAAPI_NO_DRM_STREAM
                }
#endif  /* WMAAPI_NO_DRM_STREAM */

                /* Initialize DRM so it can decrypt this payload properly */

                hr = CDrmPD_InitPacket(pInt->pDRM_state, pLast15, pInt->payload.cbPayloadSize);
                if(hr != S_OK)
                {
#ifdef LOCAL_DEBUG
                    SerialPrintf("++ WMA_UpdateNewPayload: CDrmPD_InitPacket failed (0x%08x).\n\r", hr);
#endif /* LOCAL_DEBUG */
                    return cWMA_DRMFailed;
                }

#ifndef WMAAPI_NO_DRM_STREAM
                pInt->cbNextPayloadEndValid = 0;
#endif  /* WMAAPI_NO_DRM_STREAM */

#endif /* WMAAPI_NO_DRM */

            }

        
            
            
            
            
            
            
            
            
            
            
            
            
            
            
/*******************************************************************************************/            
            pInt->parse_state = csWMA_DecodePayloadHeader;
            
            return cWMA_NoErr;
            break;

        default:
#ifdef LOCAL_DEBUG
            while(1);
#else  /* LOCAL_DEBUG */
            return cWMA_Internal;
#endif /* LOCAL_DEBUG */
        }

    } while(1);

    return cWMA_NoErr;
}

#if 0
/****************************************************************************/
WMARESULT WMARawDecCBGetData (U8_WMARawDec **ppBuffer, U32_WMARawDec *pcbBuffer, U32_WMARawDec dwUserData)
{
    tWMAFileStateInternal *pInt = (tWMAFileStateInternal *) dwUserData;
    tWMA_U32 num_bytes = WMA_MAX_DATA_REQUESTED;
    tWMA_U32 cbActual =0;
    tWMA_U32 cbWanted =0;
    BYTE *pbuff = NULL;
    tWMAFileStatus rc;
    tWMAParseState parse_state;

#ifndef WMAAPI_NO_DRM
    HRESULT hr;
#endif // WMAAPI_NO_DRM

    if(pInt == NULL || ppBuffer == NULL || pcbBuffer == NULL)
    {
        if(ppBuffer != NULL)
        {
            *ppBuffer = NULL;
        }
        if(pcbBuffer != NULL)
        {
            *pcbBuffer = 0;
        }

        return WMA_E_INVALIDARG;
    }

    *ppBuffer = NULL;
    *pcbBuffer = 0;

    /* If we used up the current payload, try to get the
     * next one.
     */
    
    // Added by Amit to take care of compressed payloads
    if (pInt->payload.bIsCompressedPayload == 1)
    {
        do
        {
            switch (pInt->payload.bSubPayloadState)
            {
            case 1: // Compressed payload just started
                cbWanted = 1; //to read subpayload length
                cbActual = WMAFileCBGetData ((tHWMAFileState *)pInt,
                                             ((tHWMAFileState *)pInt)->pCallbackContext,
                                             pInt->cbPayloadOffset, cbWanted, &pbuff);
                pInt->cbPayloadOffset += cbWanted;
                pInt->bBlockStart = TRUE;
                pInt->cbBlockLeft = pInt->hdr_parse.nBlockAlign;

                pInt->payload.bNextSubPayloadSize = pbuff[0];
                pInt->payload.wSubpayloadLeft = pInt->payload.bNextSubPayloadSize;
                if (pInt->payload.wSubpayloadLeft > 0)
                    pInt->payload.wSubpayloadLeft -= (WORD)pInt->cbBlockLeft;

			    if( pInt->payload.wTotalDataBytes > pInt->payload.bNextSubPayloadSize)
				    pInt->payload.wBytesRead = pInt->payload.bNextSubPayloadSize+1;
			    else if ( pInt->payload.wTotalDataBytes == pInt->payload.bNextSubPayloadSize)
				    pInt->payload.wBytesRead = pInt->payload.bNextSubPayloadSize;

                pInt->payload.bSubPayloadState = 2;
                break;
            case 2: // Subpayload started
                if (pInt->cbBlockLeft == 0 && pInt->payload.wSubpayloadLeft == 0)
                {
                    pInt->payload.bSubPayloadState =3;
                    break;
                }
                else
                {
                    if(pInt->cbBlockLeft == 0)
                    {
                        if (/*pInt->cbPayloadLeft*/pInt->payload.wSubpayloadLeft == 0) /* done with the file */
                            return WMA_S_NEWPACKET;

                        if (pInt->payload.wSubpayloadLeft > 0)
                            pInt->payload.wSubpayloadLeft -= (WORD) pInt->hdr_parse.nBlockAlign;
                        pInt->bBlockStart = TRUE;
                        pInt->cbBlockLeft = pInt->hdr_parse.nBlockAlign;
                    }
                    if(num_bytes > pInt->cbBlockLeft)
                        num_bytes = pInt->cbBlockLeft;

                    *pcbBuffer = (unsigned int)WMAFileCBGetData((tHWMAFileState *)pInt,
                                                                ((tHWMAFileState *)pInt)->pCallbackContext,
                                                                pInt->cbPayloadOffset, num_bytes, ppBuffer);
                    pInt->cbPayloadOffset+=*pcbBuffer;
                    //pInt->payload.wSubpayloadLeft -= *pcbBuffer;
                    pInt->cbBlockLeft     -= *pcbBuffer;
                
/****************************************************************************************/
        if (pInt->bHasDRM)
        {

#ifdef WMAAPI_NO_DRM
            return WMA_S_NEWPACKET;
#else  /* WMAAPI_NO_DRM */

            hr = CDrmPD_Decrypt (pInt->pDRM_state, *ppBuffer, *pcbBuffer);
            if (hr != S_OK) {
#ifdef LOCAL_DEBUG
                SerialPrintf("++ WMARawDecCBGetData: CDrmPD_Decrypt failed (0x%08x).\n\r", hr);
#endif /* LOCAL_DEBUG */
                *ppBuffer = NULL;
                *pcbBuffer = 0;
                return WMA_S_NEWPACKET;
            }

#endif /* WMAAPI_NO_DRM */

        }



/****************************************************************************************/
                    if (pInt->bBlockStart) {
                        pInt->bBlockStart = FALSE;
                        return WMA_S_NEWPACKET;
                    }


                    return WMA_OK;
                }

                break;
            case 3: // Subpayload finished
                if ( pInt->payload.wTotalDataBytes > pInt->payload.wBytesRead)
                { // there are payloads to decode
                    cbWanted = 1; //to read subpayload length
                    cbActual = WMAFileCBGetData((tHWMAFileState *)pInt,
                                                ((tHWMAFileState *)pInt)->pCallbackContext,
                                                pInt->cbPayloadOffset, cbWanted, &pbuff);

                    pInt->cbPayloadOffset+=cbWanted;
                    pInt->bBlockStart     = TRUE;
                    pInt->cbBlockLeft     = pInt->hdr_parse.nBlockAlign;

                    
                    pInt->payload.bNextSubPayloadSize = pbuff[0];
                    pInt->payload.wSubpayloadLeft = pInt->payload.bNextSubPayloadSize;
                    if (pInt->payload.wSubpayloadLeft > 0)
                        pInt->payload.wSubpayloadLeft -= (WORD)pInt->cbBlockLeft;
					pInt->payload.wBytesRead+=pInt->payload.bNextSubPayloadSize+1;
                    pInt->payload.bSubPayloadState =2;                
                }
                else
                    pInt->payload.bSubPayloadState =4; // all subpayloads finished
                break;

            case 4: // All Subpayloads finished

                parse_state = pInt->parse_state;
                pInt->payload.bSubPayloadState =0;
                pInt->cbPayloadLeft =0;
                pInt->payload.bIsCompressedPayload =0;

                pInt->parse_state = csWMA_DecodePayloadEnd;
                rc = WMAF_UpdateNewPayload(pInt);
                pInt->parse_state = parse_state;  //restore 
                if((rc != cWMA_NoErr)) 
                    return WMA_S_NEWPACKET;
                break;
            }
        } while(1);


    }          
    else
    {
        if(pInt->cbBlockLeft == 0 && pInt->cbPayloadLeft == 0)
        {
            tWMAFileStatus rc;
            tWMAParseState parse_state;

            parse_state = pInt->parse_state;

            pInt->parse_state = csWMA_DecodePayloadEnd;
            rc = WMAF_UpdateNewPayload(pInt);
            pInt->parse_state = parse_state; /* restore */

            if(rc != cWMA_NoErr)
                return WMA_S_NEWPACKET;
        }

        /* return as much as we currently have left */

        if(pInt->cbBlockLeft == 0)
        {
            if(pInt->cbPayloadLeft == 0)
            {
                /* done with the file */
                return WMA_S_NEWPACKET;
            }

            pInt->cbPayloadLeft -= pInt->hdr_parse.nBlockAlign;
            pInt->bBlockStart = TRUE;
            pInt->cbBlockLeft = pInt->hdr_parse.nBlockAlign;
        }
        if(num_bytes > pInt->cbBlockLeft)
            num_bytes = pInt->cbBlockLeft;

        *pcbBuffer = (unsigned int)WMAFileCBGetData((tHWMAFileState *)pInt,
                                                    ((tHWMAFileState *)pInt)->pCallbackContext,
                                                    pInt->cbPayloadOffset, num_bytes, ppBuffer);
        pInt->cbPayloadOffset += *pcbBuffer;
        pInt->cbBlockLeft     -= *pcbBuffer;

        /* DRM decryption if necessary */

        if (pInt->bHasDRM)
        {

#ifdef WMAAPI_NO_DRM
            return WMA_S_NEWPACKET;
#else  /* WMAAPI_NO_DRM */

            hr = CDrmPD_Decrypt (pInt->pDRM_state, *ppBuffer, *pcbBuffer);
            if (hr != S_OK) {
#ifdef LOCAL_DEBUG
                SerialPrintf("++ WMARawDecCBGetData: CDrmPD_Decrypt failed (0x%08x).\n\r", hr);
#endif /* LOCAL_DEBUG */
                *ppBuffer = NULL;
                *pcbBuffer = 0;
                return WMA_S_NEWPACKET;
            }

#endif /* WMAAPI_NO_DRM */

        }

        if (pInt->bBlockStart) {
            pInt->bBlockStart = FALSE;
            return WMA_S_NEWPACKET;
        }

        return WMA_OK;
    }
    return WMA_OK;
}

#endif
/* ===========================================================================
 * WMAFileIsWMA
--------------------------------------------------------------------------- */
tWMAFileStatus WMAFileIsWMA (tWMAFileHdrState *pstate)
{
    tWMAFileHdrStateInternal *pInt = (tWMAFileHdrStateInternal *)pstate;
    WMAERR wmarc;

    if(sizeof(tWMAFileHdrState) != sizeof(tWMAFileHdrStateInternal))
    {
        /* this should NOT happen */
        WMADebugMessage("** Internal Error: sizeof(tWMAFileHdrStateInternal) = %d.\n\r",
                sizeof(tWMAFileHdrStateInternal));
        // while(1);
        return cWMA_BadArgument;
    }
    if(pInt == NULL)
        return cWMA_BadArgument;

    /* parse ASF header */

    wmarc = WMA_ParseAsfHeader(pInt, 0);
    if(wmarc != WMAERR_OK)
        return cWMA_BadAsfHeader;

    return cWMA_NoErr;
}

/* ===========================================================================
 * WMAGetLicenseStore
--------------------------------------------------------------------------- */
BYTE * WMAGetLicenseStore (tWMAFileHdrState *pstate,tWMA_U32 *pLen)
{
    tWMAFileHdrStateInternal *pInt = (tWMAFileHdrStateInternal *)pstate;

    if(sizeof(tWMAFileHdrState) != sizeof(tWMAFileHdrStateInternal))
    {
        /* this should NOT happen */
        WMADebugMessage("** Internal Error: sizeof(tWMAFileHdrStateInternal) = %d.\n\r",
                sizeof(tWMAFileHdrStateInternal));
        // while(1);
        return NULL;
    }
    if(pInt == NULL)
        return NULL;

    *pLen = pInt->m_dwLicenseLen;

    return pInt->m_pLicData;
}

/* ===========================================================================
 * WMAFileDecodeClose
--------------------------------------------------------------------------- */
tWMAFileStatus WMAFileDecodeClose (tHWMAFileState* phstate)
{
    tWMAFileStateInternal *pInt;
    unsigned int i;

    pInt = (tWMAFileStateInternal*) (*phstate);

    if (pInt != NULL ) {
        WMARawDecClose (&(pInt->hWMA));
#ifndef WMAAPI_NO_DRM
		if (pInt->pDRM_state != NULL) {
			free (pInt->pDRM_state);
            pInt->pDRM_state = NULL;
        }
#endif
#if 0
        if (pInt->hdr_parse.m_pMarkers) {
            for (i=0;i<pInt->hdr_parse.m_dwMarkerNum;i++)
                if ( pInt->hdr_parse.m_pMarkers[i].m_pwDescName != NULL )
                {
                    free (pInt->hdr_parse.m_pMarkers[i].m_pwDescName);
                    pInt->hdr_parse.m_pMarkers[i].m_pwDescName = NULL;
                }
            free (pInt->hdr_parse.m_pMarkers);
            pInt->hdr_parse.m_pMarkers = NULL;
        }
#endif 
        if (pInt->hdr_parse.m_pLicData) 
        {
    		free (pInt->hdr_parse.m_pLicData);
            pInt->hdr_parse.m_pLicData = NULL;
        }

        if(pInt->hdr_parse.m_pECDesc != NULL) {
            if(pInt->hdr_parse.m_pECDesc->cDescriptors > 0) {
                for (i = 0; i < (unsigned int) pInt->hdr_parse.m_pECDesc->cDescriptors; i++) {
                    free(pInt->hdr_parse.m_pECDesc->pDescriptors[i].uValue.pbBinary);
                    free(pInt->hdr_parse.m_pECDesc->pDescriptors[i].pwszName);
                    pInt->hdr_parse.m_pECDesc->pDescriptors[i].uValue.pbBinary = NULL;
                    pInt->hdr_parse.m_pECDesc->pDescriptors[i].pwszName = NULL;
                }
                free(pInt->hdr_parse.m_pECDesc->pDescriptors);
                pInt->hdr_parse.m_pECDesc->pDescriptors = NULL;
            }
            free(pInt->hdr_parse.m_pECDesc);
            pInt->hdr_parse.m_pECDesc = NULL;
        }

		free (pInt);
        *phstate = NULL;
    }
    phstate = NULL;
    return cWMA_NoErr;
}

/* ===========================================================================
 * WMAFileDecodeInit
--------------------------------------------------------------------------- */
BYTE pDrmBuffer[4096];
tWMAFileStatus WMAFileDecodeCreate (tHWMAFileState *phstate, void * pCallbackContext) // georgioc added pContext
{
    tWMAFileStateInternal *pInt;

#ifdef USE_WOW_FILTER
    WowControls         tempWowControls;
#endif

    // first try to close in case someone calls us without prior close
    WMAFileDecodeClose (phstate);

    // Now start to allocate and initialize

    pInt = (tWMAFileStateInternal*) malloc (sizeof (tWMAFileStateInternal));

    if (pInt == NULL)
        return cWMA_Failed;

    memset (pInt, 0, sizeof (tWMAFileStateInternal));

    /* initialize the some state */

    pInt->parse_state = csWMA_HeaderStart;
    // georgioc
    pInt->pCallbackContext = pCallbackContext;
    pInt->hdr_parse.pCallbackContext = pCallbackContext;

    /* parse ASF header */

    *phstate = (tHWMAFileState) pInt;

    return cWMA_NoErr;
}

tWMAFileStatus WMAFileDecodeInit (tHWMAFileState hstate)
{
    tWMAFileStateInternal *pInt;
    WMAERR wmarc;
    WMARESULT wmar;
#ifndef WMAAPI_NO_DRM
    HRESULT hr;
#endif // WMAAPI_NO_DRM

#ifdef USE_WOW_FILTER
    WowControls         tempWowControls;
#endif

    pInt = (tWMAFileStateInternal*) hstate;

    wmarc = WMA_ParseAsfHeader(&pInt->hdr_parse, 1);
    if(wmarc != WMAERR_OK)
        return cWMA_BadAsfHeader;

    /* Set up and initialize the WMA bitstreamd decoder */

    wmar = WMARawDecInit (
        &pInt->hWMA,
        (U32_WMARawDec) pInt,
        WMARawDecCBGetData,
        (U16_WMARawDec) pInt->hdr_parse.nVersion,
        (U16_WMARawDec) pInt->hdr_parse.nSamplesPerBlock,
        (U16_WMARawDec) pInt->hdr_parse.nSamplesPerSec,
        (U16_WMARawDec) pInt->hdr_parse.nChannels,
        (U16_WMARawDec) pInt->hdr_parse.nAvgBytesPerSec,
        (U16_WMARawDec) pInt->hdr_parse.nBlockAlign,
        (U16_WMARawDec) pInt->hdr_parse.nEncodeOpt,
        0
    );
 	if (wmar == 0x80040000)
        return cWMA_BadSamplingRate;

	if (wmar != WMA_OK)
        return cWMA_Failed;

    /* Set up the decryption if necessary */

    pInt->bHasDRM = (BOOL) 0;

    if(pInt->hdr_parse.cbSecretData > 0)
    {
        /* only for DRM now */
        char *p = (char *)pInt->hdr_parse.pbType;

        if(p[0] == 'D' && p[1] == 'R' && p[2] == 'M' && p[3] == '\0')
        {
            pInt->bHasDRM = (BOOL)( 1 );

#ifndef WMAAPI_NO_DRM
            pInt->pDRM_state = (CDrmPD*) malloc (sizeof (CDrmPD));
            if (pInt->pDRM_state == NULL)
                return cWMA_DRMFailed;
#ifndef WMAAPI_NO_DRM
#ifdef GLOBAL_SECRET
            SetSecret_1of7 (pInt->pDRM_state);
#endif // GLOBAL_SECRET
#endif /* WMAAPI_NO_DRM */
            hr = CDrmPD_Init(pInt->pDRM_state,pDrmBuffer,2048);
            if(hr != S_OK)
                return cWMA_DRMFailed;
#endif /* WMAAPI_NO_DRM */
        }
        else
            return cWMA_BadDRMType;
    }

    pInt->hdr_parse.cbLastPacketOffset = pInt->hdr_parse.cbFirstPacketOffset;
    if (pInt->hdr_parse.cPackets > 0)
        pInt->hdr_parse.cbLastPacketOffset += (pInt->hdr_parse.cPackets - 1)*pInt->hdr_parse.cbPacketSize;

	pInt->hdr_parse.currPacketOffset = pInt->hdr_parse.cbHeader;// Added by amit
    pInt->hdr_parse.nextPacketOffset = pInt->hdr_parse.cbHeader;
    pInt->parse_state = csWMA_NewAsfPacket;



#ifdef USE_WOW_FILTER
    tempWowControls.bEnableWow = TRUE;
    tempWowControls.bMonoInput = FALSE;
    tempWowControls.bHighBitRate = TRUE;
    tempWowControls.iSampleRate = k44100;
    tempWowControls.mBrightness = kHigh;
    tempWowControls.mSpeakerSize = kMedium;
    tempWowControls.dTruBass = 0.8;
    tempWowControls.dWidthControl = 0.6;

    switch(pInt->hdr_parse.nSamplesPerSec)
    {
        case 22050:
                tempWowControls.iSampleRate = k22050;
                break;
        case 32000:
                tempWowControls.iSampleRate = k32000;
                break;
        case 44100:
                tempWowControls.iSampleRate = k44100;
                break;
        default:
                break;
    }

    if ( pInt->hdr_parse.nChannels  == 1)
    {
            tempWowControls.bMonoInput          = TRUE;
    }

	if ( pInt->hdr_parse.nAvgBytesPerSec * 8 < 64000)
		tempWowControls.bHighBitRate    = FALSE;

    tempWowControls.bEnableWow      = TRUE;

    if ( InitWow(&(pInt->sWowChannel), &tempWowControls ) != 0) {
        return cWMA_BadDRMType;   //NQF_temp
    }

#endif  //USE_WOW_FILTER

    return cWMA_NoErr;
}


/* ===========================================================================
 * WMAFileDecodeInfo
--------------------------------------------------------------------------- */
tWMAFileStatus WMAFileDecodeInfo(tHWMAFileState hstate,
                  tWMAFileHeader *hdr)
{
    tWMAFileStateInternal *pInt; 
    pInt = (tWMAFileStateInternal*) hstate;

    if(pInt == NULL || hdr == NULL)
        return cWMA_BadArgument;

    /* Fill in the structure */

    hdr->version      = (tWMAFileVersion)pInt->hdr_parse.nVersion;
    hdr->num_channels = (tWMAFileChannels)pInt->hdr_parse.nChannels;

    switch(pInt->hdr_parse.nSamplesPerSec)
    {
    case 8000:
        hdr->sample_rate = cWMA_SR_08kHz;
        break;
    case 11025:
        hdr->sample_rate = cWMA_SR_11_025kHz;
        break;
    case 16000:
        hdr->sample_rate = cWMA_SR_16kHz;
        break;
    case 22050:
        hdr->sample_rate = cWMA_SR_22_05kHz;
        break;
    case 32000:
        hdr->sample_rate = cWMA_SR_32kHz;
        break;
    case 44100:
        hdr->sample_rate = cWMA_SR_44_1kHz;
        break;
    case 48000:
        hdr->sample_rate = cWMA_SR_48kHz;
        break;
    default:
        return cWMA_BadSamplingRate;
    }

    hdr->duration            = pInt->hdr_parse.msDuration;
    hdr->packet_size         = pInt->hdr_parse.cbPacketSize;
    hdr->first_packet_offset = pInt->hdr_parse.cbFirstPacketOffset;
    hdr->last_packet_offset  = pInt->hdr_parse.cbLastPacketOffset;

    hdr->has_DRM             = (tWMA_U32)pInt->bHasDRM;

    hdr->LicenseLength       = (tWMA_U32)pInt->hdr_parse.m_dwLicenseLen;

    hdr->bitrate             = pInt->hdr_parse.nAvgBytesPerSec*8;

    return cWMA_NoErr;
}


/* ===========================================================================
 * WMAFileContentDesc
--------------------------------------------------------------------------- */
tWMAFileStatus WMAFileContentDesc (tHWMAFileState hstate, tWMAFileContDesc *desc)
{
    tWMAFileStateInternal *pInt; 
    DWORD cbOffset;
    DWORD cbWanted;
    DWORD cbActual;

    pInt = (tWMAFileStateInternal*) hstate;
    if(pInt == NULL || desc == NULL)
        return cWMA_BadArgument;

    if(pInt->hdr_parse.cbCDOffset == 0)
    {
        /* no content description object in the header */

        desc->title_len       = 0;
        desc->author_len      = 0;
        desc->copyright_len   = 0;
        desc->description_len = 0;
        desc->rating_len      = 0;

        return cWMA_NoErr;
    }

    /* Title */

    if(desc->title_len > 0)
    {
        if(desc->pTitle != NULL)
        {
            if(pInt->hdr_parse.cbCDTitle > 0)
            {
                cbOffset = pInt->hdr_parse.cbCDOffset;
                cbWanted = MIN(pInt->hdr_parse.cbCDTitle, desc->title_len);
                cbActual = WMA_GetBuffer(pInt, cbOffset, cbWanted, desc->pTitle);
                if(cbActual != cbWanted)
                    return cWMA_BadAsfHeader;
            }
            else
                desc->pTitle[0] = desc->pTitle[1] = 0;
        }

        desc->title_len = pInt->hdr_parse.cbCDTitle;
    }

    /* Author */

    if (desc->author_len > 0)
    {
        if (desc->pAuthor != NULL)
        {
            if (pInt->hdr_parse.cbCDAuthor > 0)
            {
                cbOffset = pInt->hdr_parse.cbCDOffset
                         + pInt->hdr_parse.cbCDTitle;
                cbWanted = MIN(pInt->hdr_parse.cbCDAuthor, desc->author_len);
                cbActual = WMA_GetBuffer(pInt, cbOffset, cbWanted, desc->pAuthor);
                if(cbActual != cbWanted)
                    return cWMA_BadAsfHeader;
            }
            else
                desc->pAuthor[0] = desc->pAuthor[1] = 0;
        }
        desc->author_len = pInt->hdr_parse.cbCDAuthor;
    }

    /* Copyright */

    if(desc->copyright_len > 0)
    {
        if(desc->pCopyright != NULL)
        {
            if(pInt->hdr_parse.cbCDCopyright > 0)
            {
                cbOffset = pInt->hdr_parse.cbCDOffset
                         + pInt->hdr_parse.cbCDTitle + pInt->hdr_parse.cbCDAuthor;
                cbWanted = MIN(pInt->hdr_parse.cbCDCopyright, desc->copyright_len);
                cbActual = WMA_GetBuffer(pInt, cbOffset, cbWanted, desc->pCopyright);
                if(cbActual != cbWanted)
                    return cWMA_BadAsfHeader;
            }
            else
                desc->pCopyright[0] = desc->pCopyright[1] = 0;
        }
        desc->copyright_len = pInt->hdr_parse.cbCDCopyright;
    }

    /* Description */

    if(desc->description_len > 0)
    {
        if(desc->pDescription != NULL)
        {
            if(pInt->hdr_parse.cbCDDescription > 0)
            {
                cbOffset = pInt->hdr_parse.cbCDOffset
                         + pInt->hdr_parse.cbCDTitle + pInt->hdr_parse.cbCDAuthor
                         + pInt->hdr_parse.cbCDCopyright;
//                cbWanted = MIN(pInt->hdr_parse.cbCDCopyright, desc->copyright_len);
                cbWanted = MIN(pInt->hdr_parse.cbCDDescription, desc->description_len);
                cbActual = WMA_GetBuffer(pInt, cbOffset, cbWanted, desc->pDescription);
                if(cbActual != cbWanted)
                    return cWMA_BadAsfHeader;
            }
            else
                desc->pDescription[0] = desc->pDescription[1] = 0;
        }
        desc->description_len = pInt->hdr_parse.cbCDDescription;
    }

    /* Rating */

    if(desc->rating_len > 0)
    {
        if(desc->pRating != NULL)
        {
            if(pInt->hdr_parse.cbCDRating > 0)
            {
                cbOffset = pInt->hdr_parse.cbCDOffset
                         + pInt->hdr_parse.cbCDTitle + pInt->hdr_parse.cbCDAuthor
                         + pInt->hdr_parse.cbCDCopyright + pInt->hdr_parse.cbCDDescription;
                cbWanted = MIN(pInt->hdr_parse.cbCDRating, desc->rating_len);
                cbActual = WMA_GetBuffer(pInt, cbOffset, cbWanted, desc->pRating);

                if(cbActual != cbWanted)
                    return cWMA_BadAsfHeader;
            }
            else
                desc->pRating[0] = desc->pRating[1] = 0;
        }
        desc->rating_len = pInt->hdr_parse.cbCDRating;
    }

    return cWMA_NoErr;
}

/* ===========================================================================
 * WMAFileExtendedContentDesc
--------------------------------------------------------------------------- */
tWMAFileStatus WMAFileExtendedContentDesc (tHWMAFileState hstate, const tWMAExtendedContentDesc **pECDesc)
{
    tWMAFileStateInternal *pInt;

    pInt = (tWMAFileStateInternal*) hstate;
    if(pInt == NULL)
        return cWMA_BadArgument;

    if(pInt->hdr_parse.m_pECDesc == NULL) {
        *pECDesc = NULL;
    }
    else {
        *pECDesc = pInt->hdr_parse.m_pECDesc;
    }

    return cWMA_NoErr;
}

/******************************************************************************/

/* ===========================================================================
 * WMAGetNumberOfMarkers
--------------------------------------------------------------------------- */
int WMAGetNumberOfMarkers(tWMAFileHdrState *state)
{
    tWMAFileHdrStateInternal *pInt = (tWMAFileHdrStateInternal *)state;

    if(sizeof(tWMAFileHdrState) != sizeof(tWMAFileHdrStateInternal))
    {
        /* this should NOT happen */
        WMADebugMessage("** Internal Error: sizeof(tWMAFileHdrStateInternal) = %d.\n\r",
                sizeof(tWMAFileHdrStateInternal));

        return 0;
    }

    if(pInt == NULL)
    {
        return 0;
    }

    if (WMAERR_OK == WMA_GetMarkerObject(pInt, -1)) // filled up pInt->m_dwMarkerNum 
    {
        return pInt->m_dwMarkerNum;
    } else {
        return 0;  
    }
}


/* ===========================================================================
 * WMAGetMarker
--------------------------------------------------------------------------- */
tWMAFileStatus  WMAGetMarker(tWMAFileHdrState *state, int iIndex, MarkerEntry *pEntry)  
{
    tWMAFileHdrStateInternal *pInt = (tWMAFileHdrStateInternal *)state;

    if(sizeof(tWMAFileHdrState) != sizeof(tWMAFileHdrStateInternal))
    {
        /* this should NOT happen */
        WMADebugMessage("** Internal Error: sizeof(tWMAFileHdrStateInternal) = %d.\n\r",
                sizeof(tWMAFileHdrStateInternal));

        return cWMA_Failed; 
    }

    if(pInt == NULL)
    {
       return cWMA_Failed; 
    }
 
    if (WMAERR_OK != WMA_GetMarkerObject(pInt, -1)) // filled up pInt->m_dwMarkerNum
    {
        return cWMA_Failed;  
    } 

    if ( pInt->m_dwMarkerNum == 0 ) 
    {
        return cWMA_Failed;  
    } 

    if ( pEntry == NULL ) 
    {
        return cWMA_Failed;  
    } 

    pInt->m_pMarker = pEntry;  

    if ( 0 <= iIndex < (int) pInt->m_dwMarkerNum )
    {
        if (WMAERR_OK == WMA_GetMarkerObject(pInt, iIndex))
        {
            return cWMA_NoErr; 
        } else {
            return cWMA_Failed;  
        }

    } else {

        return cWMA_Failed; 
        
    }
}


/* ===========================================================================
 * WMAFileLicenseInit
--------------------------------------------------------------------------- */
tWMAFileStatus WMAFileLicenseInit (tHWMAFileState hstate, tWMAFileLicParams *lic_params, tWMA_U16 CheckLicTypes)
{
    tWMAFileStateInternal *pInt; 
#ifndef WMAAPI_NO_DRM
   	tWMA_U16 i;
#endif // WMAAPI_NO_DRM
    pInt = (tWMAFileStateInternal*) hstate;

    if(pInt == NULL || lic_params == NULL)
        return cWMA_BadArgument;

    if(pInt->bHasDRM)
    {

#ifdef WMAAPI_NO_DRM

        return cWMA_DRMUnsupported;

#else  /* WMAAPI_NO_DRM */

        HRESULT hr;
        PMLICENSE pmlic;
        DWORD dwRight;

        BYTE *pData;
        DWORD dwOffset;
        DWORD dwWanted;
        DWORD dwActual;

        /* set up for InitDecrypt */

        memset (&pmlic, 0, sizeof(pmlic));
        memcpy (pmlic.ld.KID, (char *)pInt->hdr_parse.pbKeyID,
               strlen((const char *)pInt->hdr_parse.pbKeyID) + 1);
        memcpy (pmlic.ld.appSec, APPSEC_1000, APPSEC_LEN);

	    CheckLicTypes = CheckLicTypes & 3;
        for (i = 1; i < 3; i++) {
		    if (CheckLicTypes & i) { 
				if (i == CHECK_NONSDMI_LIC)
			        dwRight = DRM_RIGHT_NONSDMI;
			    else    
			        dwRight = DRM_RIGHT_SDMI;

                memcpy (pmlic.ld.rights, (BYTE *)&dwRight, RIGHTS_LEN);

                dwOffset = 0;
                dwActual = WMA_MAX_DATA_REQUESTED;

                do
                {
                    dwWanted = dwActual;

                    if (pInt->hdr_parse.m_dwLicenseLen) 
                    {
                        dwActual = ((dwOffset +dwWanted) > pInt->hdr_parse.m_dwLicenseLen) ? 0: dwWanted;
                        pData = pInt->hdr_parse.m_pLicData + dwOffset;
                    } else {
                        return cWMA_DRMFailed;    
                        //dwActual = WMAFileCBGetLicenseData((tWMAFileState *)pInt,
                        //                                   dwOffset, dwWanted, &pData);
                    }
    
                    if(dwActual != dwWanted)
                        return cWMA_DRMFailed;

                    hr = CDrmPD_InitDecrypt(pInt->pDRM_state,
                                            &pmlic,
                                            lic_params->pPMID,
                                            lic_params->cbPMID,
                                            pData,
                                            &dwOffset,
                                            &dwActual);

#ifdef LOCAL_DEBUG
                    SerialPrintf("++ WMAFileLicenseInit: CDrmPD_InitDecrypt returned 0x%08x: next [%u @ %u].\n\r",
                                 hr, dwActual, dwOffset);
#endif /* LOCAL_DEBUG */

                } while (hr == 0x80041006 || hr == E_DRM_MORE_DATA);

                if (hr == S_OK)
                    return cWMA_NoErr;
            }
        }
#endif /* WMAAPI_NO_DRM */
    }

    return cWMA_DRMFailed;
}


/* ===========================================================================
 * WMAFileSeek
--------------------------------------------------------------------------- */
tWMA_U32 WMAFileSeek (tHWMAFileState hstate, tWMA_U32 msSeek)
{
    tWMAFileStateInternal *pInt; 
    tWMA_U32 msActual;
    tWMA_U32 nPacket;
    WMARESULT wmar;

    pInt = (tWMAFileStateInternal*) hstate;
    if(pInt == NULL || pInt->hWMA == NULL )
    {
        return cWMA_BadArgument;
    }

    /* which packet? */

    nPacket = 0;
    if(pInt->hdr_parse.msDuration > 0)
    {
        /* rounding down because I want the requested time frame to be
         * played */

        nPacket = msSeek / (pInt->hdr_parse.msDuration / pInt->hdr_parse.cPackets);
		//NQF, 061800, temp fix for the seek() bug reported by Creative 
		if ((nPacket) &&( nPacket % 16 == 0 )){
			nPacket++;  
		}
    }

    /* see if it's within the bounds */

    if(nPacket < pInt->hdr_parse.cPackets)
    {
        /* parse the packet and the payload header
         *
         * a bit of a duplication from WMAF_UpdateNewPayload...
         */

        pInt->hdr_parse.currPacketOffset = pInt->hdr_parse.cbHeader
                                         + nPacket*pInt->hdr_parse.cbPacketSize;

        if(WMA_ParsePacketHeader(pInt) != WMAERR_OK)
        {
            msActual = pInt->hdr_parse.msDuration;
            goto lexit;
        }

        if(pInt->ppex.fEccPresent && pInt->ppex.fParityPacket)
        {
            msActual = pInt->hdr_parse.msDuration;
            goto lexit;
        }

        pInt->iPayload = 0;

        if(WMA_ParsePayloadHeader(pInt) != WMAERR_OK)
        {
            msActual = pInt->hdr_parse.msDuration;
            goto lexit;
        }

        if(pInt->payload.cbRepData == 1)
        {
            msActual = pInt->hdr_parse.msDuration;
            goto lexit;
        }

        /* whew... finally got here */

        msActual = pInt->payload.msObjectPres - pInt->hdr_parse.msPreroll;
    }
    else
    {
        nPacket = pInt->hdr_parse.cPackets;
        msActual = pInt->hdr_parse.msDuration;
    }

lexit:

    /* reset the states */

    wmar = WMARawDecReset (pInt->hWMA);
    if (wmar != WMA_OK)
        return cWMA_Failed;
    pInt->hdr_parse.nextPacketOffset = pInt->hdr_parse.cbHeader
                                     + nPacket*pInt->hdr_parse.cbPacketSize;
    pInt->parse_state = csWMA_NewAsfPacket;

    return msActual;
}


/* ===========================================================================
 * WMAFileDecodeData
--------------------------------------------------------------------------- */
tWMAFileStatus WMAFileDecodeData(tHWMAFileState hstate)
{
    tWMAFileStateInternal *pInt;
    WMARESULT wmar;
    tWMAFileStatus rc;
    FUNCTION_PROFILE(fp);

    pInt = (tWMAFileStateInternal*) hstate;

    if(pInt == NULL || pInt->hWMA == NULL)
        return cWMA_BadArgument;

	FUNCTION_PROFILE_START(&fp,WMA_FILE_DECODE_DATA_PROFILE);

    do
    {
        switch(pInt->parse_state)
        {
        case csWMA_DecodePayloadHeader:


#ifdef WMAAPI_DEMO
            if(pInt->nSampleCount >= WMAAPI_DEMO_LIMIT*pInt->hdr_parse.nSamplesPerSec)
            {
				FUNCTION_PROFILE_STOP(&fp);
                return cWMA_DemoExpired;
            }
#endif /* WMAAPI_DEMO */
/*
			pInt->parse_state = csWMA_DecodeLoopStart;
			break;
*/
			if (pInt->bDecInWaitState == 1)
			{
				pInt->parse_state = csWMA_DecodeLoopStart;
				break;
			}

			if (pInt->bAllFramesDone ==1 || pInt->bDecInWaitState == 2 || pInt->bFirst ==0)
            {
				if (pInt->bDecInWaitState == 2)
					pInt->bDecInWaitState =0;
				else if (pInt->bAllFramesDone == 1)
					pInt->bAllFramesDone =0;

				pInt->bFirst =1;
				

				wmar = WMARawDecStatus (pInt->hWMA);
				

				if (wmar == WMA_E_ONHOLD) 
				{
					
					if (pInt->hdr_parse.nextPacketOffset <= pInt->hdr_parse.cbLastPacketOffset)
					{
						wmar = WMA_OK;
						pInt->bDecInWaitState =2;
						return cWMA_NoErr;
					}
					else
						return cWMA_NoMoreFrames;

				}

				if (wmar == WMA_E_LOSTPACKET)
					wmar = WMA_OK;

				if (WMARAW_FAILED (wmar)) {
					FUNCTION_PROFILE_STOP (&fp);
					return cWMA_Failed;
				}
			}
            pInt->parse_state = csWMA_DecodeLoopStart;
            break;

        case csWMA_DecodeLoopStart:
            {
#ifdef WMAAPI_DEMO
                if(pInt->nSampleCount >= WMAAPI_DEMO_LIMIT*pInt->hdr_parse.nSamplesPerSec)
                {
					FUNCTION_PROFILE_STOP(&fp);
                    return cWMA_DemoExpired;
                }
#endif /* WMAAPI_DEMO */
			if (pInt->bDecInWaitState == 1)
			{
				pInt->parse_state = csWMA_DecodePayloadHeader;
				pInt->bDecInWaitState =0;
			}


                wmar = WMARawDecDecodeData (pInt->hWMA);
				if (wmar == 4)
				{
					pInt->bAllFramesDone = 1;
				}

				if (wmar == WMA_E_LOSTPACKET)
				{
					wmar = WMA_OK;
					pInt->bAllFramesDone = 1;
					pInt->parse_state = csWMA_DecodePayloadHeader;

				}

                if (wmar == WMA_E_BROKEN_FRAME) {
#ifdef LOCAL_DEBUG
                    SerialSendString("\r** WMAFileDecodeData: WMADecodeData: broken frame\n");
#endif /* LOCAL_DEBUG */
                    // reset is recommended 
                    // then go to the next payload 
                    WMARawDecReset (pInt->hWMA);
                    pInt->bAllFramesDone = 1;
                    pInt->parse_state = csWMA_DecodePayloadEnd;
                    break;
                }

                if (wmar == WMA_E_ONHOLD) 
				{
					if (pInt->hdr_parse.nextPacketOffset <= pInt->hdr_parse.cbLastPacketOffset)
					{
						wmar = WMA_OK;
						pInt->bDecInWaitState =1;
						return cWMA_NoErr;
					}
					else
						return cWMA_NoMoreFrames;
				}

                if (wmar != WMA_OK) {
                    if (wmar == WMA_S_NO_MORE_SRCDATA) {
#ifdef LOCAL_DEBUG
                        SerialSendString("\r** WMAFileDecodeData: WMADecodeData: no more data\n");
#endif /* LOCAL_DEBUG */
						FUNCTION_PROFILE_STOP(&fp);
                        return cWMA_NoMoreFrames;
                    }
                    
					if (WMA_E_LOSTPACKET == wmar)
						return cWMA_NoErr;
					
					if (WMARAW_FAILED (wmar)) // Wei-ge recommends resetting after any error
                        WMARawDecReset (pInt->hWMA);
                    pInt->parse_state = csWMA_DecodePayloadHeader;
					FUNCTION_PROFILE_STOP(&fp);
					return cWMA_NoErr;
                }
            }

            /* WMAGetPCM will be done separately in WMAFileGetPCM */
			FUNCTION_PROFILE_STOP(&fp);
            return cWMA_NoErr;

        default:
            /* All other state operation is done in this function
             *   so that it can be done somewhere else as well
             */

            {
                rc = WMAF_UpdateNewPayload(pInt);
                if(rc != cWMA_NoErr)
                {
#ifdef LOCAL_DEBUG
                    SerialSendString("\r** WMAFileDecodeData: WMA_UpdateNewPlayload failed\n");
#endif /* LOCAL_DEBUG */
					FUNCTION_PROFILE_STOP(&fp);
                    return rc;
                }
            }
            break;
        }

    } while(1);

	FUNCTION_PROFILE_STOP(&fp);
    return cWMA_NoErr;
}


/* ===========================================================================
 * WMAFileGetPCM
--------------------------------------------------------------------------- */
tWMA_U32 WMAFileGetPCM (
    tHWMAFileState hstate,
    tWMA_I16 *pi16Channel0, tWMA_I16 *pi16Channel1,
    tWMA_U32 max_nsamples)
{
    tWMAFileStateInternal *pInt; 
    WMARESULT wmar;
    U16_WMARawDec samples_available = (U16_WMARawDec) max_nsamples;
	FUNCTION_PROFILE(fp);

    pInt = (tWMAFileStateInternal*) hstate;

    if (pInt == NULL || pInt->hWMA == NULL || pi16Channel0 == NULL)
        return 0;

	FUNCTION_PROFILE_START (&fp,WMA_FILE_GET_PCM_PROFILE);

    if (pi16Channel1 == NULL || pi16Channel1 == pi16Channel0 + 1 || pInt->hdr_parse.nChannels <= 1 ) {
		// caller wants interleaved data or this sound is mono
	    WMARawDecGetPCM (
            pInt->hWMA, 
            (U16_WMARawDec*) &samples_available, 
            (U8_WMARawDec*) pi16Channel0, 
            (U32_WMARawDec) max_nsamples * pInt->hdr_parse.nChannels * sizeof (I16_WMARawDec)
        );
    } 
    else {
		// caller wants de-interleaved stereo data
		U16_WMARawDec i;
		tWMA_I16 *pi16C0src = pi16Channel0;
		tWMA_I16 *pi16C0dst = pi16Channel0;
		tWMA_I16 *pi16C1    = pi16Channel1;
//		assert (pInt->hdr_parse.nChannels == 2);  // if it is  greather than two, this needs work...
		samples_available >>= 1;  // half the stereo samples in one buffer then they will get split into both
        wmar = WMARawDecGetPCM (
            pInt->hWMA, 
            (U16_WMARawDec*) &samples_available, 
            (U8_WMARawDec*) pi16Channel0, 
            (U32_WMARawDec) max_nsamples * pInt->hdr_parse.nChannels * sizeof (I16_WMARawDec)
        );
        if (wmar == WMA_OK) {
			for (i = 0; i < samples_available; i++) {
				*pi16C0dst++ = *pi16C0src++;
				*pi16C1++ = *pi16C0src++;
			}
		}
	}

#ifdef USE_WOW_FILTER
    wowFilter(&(pInt->sWowChannel), pi16Channel0, pi16Channel1, samples_available);
#endif //USE_WOW_FILTER

    pInt->nSampleCount += samples_available;

	FUNCTION_PROFILE_STOP(&fp);
    return samples_available;
}





/****************************************************************************/
WMARESULT WMARawDecCBGetData (U8_WMARawDec **ppBuffer, U32_WMARawDec *pcbBuffer, U32_WMARawDec dwUserData, U8_WMARawDec* pBuffer)
{
    tWMAFileStateInternal *pInt = (tWMAFileStateInternal *) dwUserData;
    tWMA_U32 num_bytes = WMA_MAX_DATA_REQUESTED;
    tWMA_U32 cbActual =0;
    tWMA_U32 cbWanted =0;
    BYTE *pbuff = NULL;
    tWMAFileStatus rc;
    tWMAParseState parse_state;

	BYTE *bGlobalDataBuffer = pBuffer;

#ifndef WMAAPI_NO_DRM
    HRESULT hr;
#endif // WMAAPI_NO_DRM

    if(pInt == NULL || ppBuffer == NULL || pcbBuffer == NULL)
    {
        if(ppBuffer != NULL)
        {
            *ppBuffer = NULL;
        }
        if(pcbBuffer != NULL)
        {
            *pcbBuffer = 0;
        }

        return WMA_E_INVALIDARG;
    }

    *ppBuffer = NULL;
    *pcbBuffer = 0;

    /* If we used up the current payload, try to get the
     * next one.
     */
    
    // Added by Amit to take care of compressed payloads
	do
	{
		switch (pInt->payload.bIsCompressedPayload)
		{


		case 1:
			{
				do
				{
					switch (pInt->payload.bSubPayloadState)
					{
					case 1: // Compressed payload just started
						cbWanted = 1; //to read subpayload length
						cbActual = WMAFileCBGetData ((tHWMAFileState *)pInt, 
                                                     (tHWMAFileState *)pInt->pCallbackContext,
                                                     pInt->cbPayloadOffset, cbWanted, &pbuff);

						pInt->cbPayloadOffset += cbWanted;
						pInt->bBlockStart = TRUE;
						pInt->cbBlockLeft = pInt->hdr_parse.nBlockAlign;

						pInt->payload.bNextSubPayloadSize = pbuff[0];
						pInt->payload.wSubpayloadLeft = pInt->payload.bNextSubPayloadSize;
						if (pInt->payload.wSubpayloadLeft > 0)
							pInt->payload.wSubpayloadLeft -= (WORD)pInt->cbBlockLeft;

						if( pInt->payload.wTotalDataBytes > pInt->payload.bNextSubPayloadSize)
							pInt->payload.wBytesRead = pInt->payload.bNextSubPayloadSize+1;
						else if ( pInt->payload.wTotalDataBytes == pInt->payload.bNextSubPayloadSize)
							pInt->payload.wBytesRead = pInt->payload.bNextSubPayloadSize;

						pInt->payload.bSubPayloadState = 2;
						break;
					case 2: // Subpayload started
						if (pInt->cbBlockLeft == 0 && pInt->payload.wSubpayloadLeft == 0)
						{
							pInt->payload.bSubPayloadState =3;
							break;
						}
						else
						{
							if(pInt->cbBlockLeft == 0)
							{
								if (/*pInt->cbPayloadLeft*/pInt->payload.wSubpayloadLeft == 0) /* done with the file */
									return WMA_S_NEWPACKET;

								if (pInt->payload.wSubpayloadLeft > 0)
									pInt->payload.wSubpayloadLeft -= (WORD) pInt->hdr_parse.nBlockAlign;
								pInt->bBlockStart = TRUE;
								pInt->cbBlockLeft = pInt->hdr_parse.nBlockAlign;
							}
							if(num_bytes > pInt->cbBlockLeft)
								num_bytes = pInt->cbBlockLeft;

							*pcbBuffer = (unsigned int)WMAFileCBGetData((tHWMAFileState *)pInt,
                                                                        (tHWMAFileState *)pInt->pCallbackContext,
																		pInt->cbPayloadOffset, num_bytes, ppBuffer);

							memcpy(&bGlobalDataBuffer[0], *ppBuffer,*pcbBuffer);
							*ppBuffer = &bGlobalDataBuffer[0];

							pInt->cbPayloadOffset+=*pcbBuffer;
							//pInt->payload.wSubpayloadLeft -= *pcbBuffer;
							pInt->cbBlockLeft     -= *pcbBuffer;
                
							if (pInt->bHasDRM)
							{
#ifdef WMAAPI_NO_DRM
								return WMA_S_NEWPACKET;
#else  /* WMAAPI_NO_DRM */
								hr = CDrmPD_Decrypt (pInt->pDRM_state, *ppBuffer, *pcbBuffer);
								if (hr != S_OK)
								{
#ifdef LOCAL_DEBUG
									SerialPrintf("++ WMARawDecCBGetData: CDrmPD_Decrypt failed (0x%08x).\n\r", hr);
#endif /* LOCAL_DEBUG */
									*ppBuffer = NULL;
									*pcbBuffer = 0;
									return WMA_S_NEWPACKET;
								}

#endif /* WMAAPI_NO_DRM */

							}

							if (pInt->bBlockStart) {
								pInt->bBlockStart = FALSE;
								return WMA_S_NEWPACKET;
							}

							return WMA_OK;
						}

						break;
					case 3: // Subpayload finished
						if ( pInt->payload.wTotalDataBytes > pInt->payload.wBytesRead)
						{ // there are payloads to decode
							cbWanted = 1; //to read subpayload length
							cbActual = WMAFileCBGetData((tHWMAFileState *)pInt,
                                                        (tHWMAFileState *)pInt->pCallbackContext,
														pInt->cbPayloadOffset, cbWanted, &pbuff);

							pInt->cbPayloadOffset+=cbWanted;
							pInt->bBlockStart     = TRUE;
							pInt->cbBlockLeft     = pInt->hdr_parse.nBlockAlign;

                    
							pInt->payload.bNextSubPayloadSize = pbuff[0];
							pInt->payload.wSubpayloadLeft = pInt->payload.bNextSubPayloadSize;
							if (pInt->payload.wSubpayloadLeft > 0)
								pInt->payload.wSubpayloadLeft -= (WORD)pInt->cbBlockLeft;
							pInt->payload.wBytesRead+=pInt->payload.bNextSubPayloadSize+1;
							pInt->payload.bSubPayloadState =2;                
						}
						else
							pInt->payload.bSubPayloadState =4; // all subpayloads finished
						break;

					case 4: // All Subpayloads finished

						parse_state = pInt->parse_state;
						pInt->payload.bSubPayloadState =0;
						pInt->cbPayloadLeft =0;
						pInt->payload.bIsCompressedPayload =0;

						pInt->parse_state = csWMA_DecodePayloadEnd;
						rc = WMAF_UpdateNewPayload(pInt);
						if (rc == cWMA_NoMoreDataThisTime)
						{
							*pcbBuffer = 0;
							return WMA_OK;
						}

						pInt->parse_state = parse_state;  //restore 
						if((rc != cWMA_NoErr)) 
							return WMA_S_NEWPACKET;
						break;
					default:
						return WMA_S_NEWPACKET;

					}
				} while(1);

				break;
			}          
		default :
			{
				if(pInt->cbBlockLeft == 0 && pInt->cbPayloadLeft == 0)
				{
					tWMAFileStatus rc;
					tWMAParseState parse_state;

					parse_state = pInt->parse_state;

					pInt->parse_state = csWMA_DecodePayloadEnd;
					rc = WMAF_UpdateNewPayload(pInt);
					if (rc == cWMA_NoMoreDataThisTime)
					{
						*pcbBuffer = 0;
						return WMA_OK;
					}
					pInt->parse_state = parse_state; /* restore */
					
					if (pInt->payload.bIsCompressedPayload ==1)
						break;
					if(rc != cWMA_NoErr)
						return WMA_S_NEWPACKET;
				}

				/* return as much as we currently have left */

				if(pInt->cbBlockLeft == 0)
				{
					if(pInt->cbPayloadLeft == 0)
					{
						/* done with the file */
						return WMA_S_NEWPACKET;
					}

					pInt->cbPayloadLeft -= pInt->hdr_parse.nBlockAlign;
					pInt->bBlockStart = TRUE;
					pInt->cbBlockLeft = pInt->hdr_parse.nBlockAlign;
				}
				if(num_bytes > pInt->cbBlockLeft)
					num_bytes = pInt->cbBlockLeft;

				*pcbBuffer = (unsigned int)WMAFileCBGetData((tHWMAFileState *)pInt,
                                                            (tHWMAFileState *)pInt->pCallbackContext,
															pInt->cbPayloadOffset, num_bytes, ppBuffer);

				memcpy(&bGlobalDataBuffer[0], *ppBuffer,*pcbBuffer);
				*ppBuffer = &bGlobalDataBuffer[0];

				pInt->cbPayloadOffset += *pcbBuffer;
				pInt->cbBlockLeft     -= *pcbBuffer;

				/* DRM decryption if necessary */

				if (pInt->bHasDRM)
				{

#ifdef WMAAPI_NO_DRM
					return WMA_S_NEWPACKET;
#else  /* WMAAPI_NO_DRM */

					hr = CDrmPD_Decrypt (pInt->pDRM_state, *ppBuffer, *pcbBuffer);
					if (hr != S_OK) {
#ifdef LOCAL_DEBUG
						SerialPrintf("++ WMARawDecCBGetData: CDrmPD_Decrypt failed (0x%08x).\n\r", hr);
#endif /* LOCAL_DEBUG */
						*ppBuffer = NULL;
						*pcbBuffer = 0;
						return WMA_S_NEWPACKET;
					}

#endif /* WMAAPI_NO_DRM */

				}

				if (pInt->bBlockStart) {
					pInt->bBlockStart = FALSE;
					return WMA_S_NEWPACKET;
				}

				return WMA_OK;
			}
		}


	}while(1);
    
	return WMA_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\wmalib\x86\macros.h ===
#ifndef __X86MACROS_H_
#define __X86MACROS_H_

#ifdef WMA_TARGET_X86

#pragma MSVC_DISABLE_WARNING(4035)

// ======================================================
// Typedefs
// ======================================================
#define FASTCALL    __fastcall


// ======================================================
// Macros
// ======================================================
#define MULT_HI_DWORD_DOWN(a,b) MultiplyHighDwordDown(a,b)
#define MULT_HI_DWORD(a,b)      MultiplyHighDword(a,b)
#define MULT_HI_UDWORD(a,b)     MultiplyHighUDword(a,b)

#pragma warning(disable: 4035)

#ifndef WMA_ANSI_COMPATIBILITY_MODE
// The following two functions, ROUNDF and ROUNDD, use the "round to nearest
// (even)" rounding mode in the Intel processor. This means -0.7 goes to -1,
// 1.3 goes to 1, 11.5 goes to 12 and 12.5 goes to 12. This unfortunately
// is a pain to do in software, so ANSI just rounds up in the case of 0.5
// (-0.7 to -1, 1.3 to 1, 11.5 to 12 and 12.5 to 13). Don't use these rounding
// macros if we want to compare x86 output with ANSI.
//-------------------------------------------------------

#ifdef PLATFORM_SPECIFIC_ROUND
INLINE Int FASTCALL ROUNDF(float f) {
    __int64 intval;
    _asm {
        fld         f
        fistp       dword ptr [intval]
        mov         eax,dword ptr [intval]
    }
}

//-------------------------------------------------------
INLINE Int FASTCALL ROUNDD(double f) {
    _asm {
        fld         f
        fistp       dword ptr [f]
        mov         eax,dword ptr [f]
    }
}
#endif // PLATFORM_SPECIFIC_ROUND
#endif // WMA_ANSI_COMPATIBILITY_MODE


//-------------------------------------------------------
INLINE I32 FASTCALL MultiplyHighDwordDown(I32 reg1, I32 reg2){
__asm{  mov     eax,reg1
        mov     edx,reg2
        imul    edx
        mov     eax,edx
        shl     eax,2
     }
}

//-------------------------------------------------------
INLINE I32 FASTCALL MultiplyHighDword(I32 reg1, I32 reg2){
__asm{  mov     eax,reg1
        mov     edx,reg2
        imul    edx
        mov     eax,edx
     }
}

//-------------------------------------------------------
INLINE I32 FASTCALL MultiplyHighUDword(U32 reg1, U32 reg2){
__asm{  mov     eax,reg1
        mov     edx,reg2
        mul     edx
        mov     eax,edx
     }
}


//-------------------------------------------------------
INLINE U32 FASTCALL ByteSwap(U32 i){
    __asm
    {
        mov     eax, i
        bswap   eax
    }
}

#pragma warning(default: 4035)

#ifdef PLATFORM_SPECIFIC_BITCOPY
//-------------------------------------------------------
//assuming dwsrc is zeroed out
INLINE void FASTCALL bitCpy (const U8* pbSrc, Int iBitStartSrc,
                                 Int cBits, U8* pbDst)
{
    const U32* pdwSrc = (U32 *) pbSrc;
    const U32* pdwSrcEnd;
    U32* pdwDst = (U32 *) pbDst;
    Int iShiftDown;
    U32 dw2, dw1;


    assert (pdwSrc != NULL && pdwDst != NULL);
    assert (iBitStartSrc < BITS_PER_DWORD && iBitStartSrc >= 0);
    assert (cBits >= 0);

    pdwSrcEnd = pdwSrc + (iBitStartSrc > 0) + 
                            (((cBits - iBitStartSrc) + 31) & ~31) / 32; //open
    iShiftDown = (BITS_PER_DWORD - iBitStartSrc);
    dw1 = DEFAULTENDIAN_TO_BIGENDIAN(*pdwSrc);
    while (pdwSrc < pdwSrcEnd) {
        pdwSrc++;
        dw2 = DEFAULTENDIAN_TO_BIGENDIAN(*pdwSrc);
        *pdwDst = BIGENDIAN_TO_DEFAULTENDIAN((dw1 << iBitStartSrc) | (dw2 >> iShiftDown));
        dw1 = dw2;
        pdwDst++;
    }
}
#endif  // PLATFORM_SPECIFIC_BITCOPY

#pragma MSVC_RESTORE_WARNING(4035)
//wchen: mmx detection has 25db mismatch with C version. Off for now.
#undef PLATFORM_SPECIFIC_FNPTR
#define PLATFORM_SPECIFIC_FNPTR                                                     \
    if (g_SupportMMX()){                                                            \
        if (g_SupportCMOV()) {                                                      \
            pauenc->m_pfnGetLowMedHiPowerStereo_48 = g_GetLowMedHiPower_48_MMX;     \
            pauenc->m_pfnGetLowMedHiPowerStereo_44 = g_GetLowMedHiPower_44_MMX;     \
            pauenc->m_pfnGetLowMedHiPowerStereo_32 = g_GetLowMedHiPower_32_MMX;     \
            pauenc->m_pfnGetLowMedHiPowerStereo_22 = g_GetLowMedHiPower_22_MMX;     \
        }                                                                           \
    }
#endif // WMA_TARGET_X86
#endif // __X86MACROS_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\codecs\wmalib\wmadec_s\x86.c ===
/*************************************************************************

Copyright (C) Microsoft Corporation, 1996 - 1999

Module Name:

    x86.c

Abstract:

    Intel x86-specific functions.

Author:

    Raymond Cheng (raych)       Jul 29, 1999

Revision History:


*************************************************************************/

#pragma code_seg("WMADEC")
#pragma data_seg("WMADEC_RW")
#pragma const_seg("WMADEC_RD")

#include "../common/macros.h" // This will define WMA_TARGET_X86 (or not)
#ifdef _XBOX
#define WMA_TARGET_X86
#define _SCRUNCH_INLINE_ASM
#endif

#ifdef WMA_TARGET_X86

#ifndef UNDER_CE
#include <time.h>
#endif
#include <math.h>
#include <limits.h>
#include "MsAudio.h"
#include "..\x86\opcodes.h"
#include "macros.h"
#include "AutoProfile.h"
#include "..\..\..\dsound\dsndver.h"


#ifdef ENCODER
#include "lpfilter.h"
#include "lpfmacro.h"
#include "MSAudioEnc.h"

#if !defined(QUANTIZER_CLIP_LIMIT)
// i.e. used in v7 mode. In v8 mode, the value is 1.0F
#define QUANTIZER_CLIP_LIMIT 1.25F
#endif
#endif

#pragma warning(disable:4730)

#if !defined(BUILD_INTEGER) && !defined(UNDER_CE)

#ifdef INTELFFT_FOR_CE
// For some reason, somebody has a #define __stdcall __cdecl somewhere.
// Get rid of this, because it's causing us linker errors.
#ifdef __stdcall
#undef __stdcall
#endif
#endif  // INTELFFT_FOR_CE

#if !defined(_Embedded_x86)

#include "..\x86\nsp.h"
#include "..\x86\nspfft.h"


// From userdll.c
Bool MyInitNSP(I32 fdwReason);

// This function initializes for prvFFT4DCT_INTEL as well as prvInvFftComplexConjugate_INTEL

WMARESULT auInitIntelFFT(const CAudioObject *pau,
                         const INTELFFT_INITCODE iCode)
{
    const int c_iMinFrameSizeLOG = LOG2(pau->m_cSubband / pau->m_iMaxSubFrameDiv);
    const int c_iMaxFrameSizeLOG = LOG2(pau->m_cSubband);
    WMARESULT   wmaResult = WMA_OK;

    int     i;
    Bool    fResult;

    fResult = MyInitNSP(iCode);
    if (WMAB_FALSE == fResult)
    {
        wmaResult = WMA_E_NOTSUPPORTED;
        goto exit;
    }

    for (i = c_iMinFrameSizeLOG; i < c_iMaxFrameSizeLOG; i++)
        nspcFft(NULL, i-1, NSP_Init); // Remember FFT size is frame size / 2, so subtract 1
    
#if defined (PEAQ_MASK) && defined (ENCODER)
    for (i = c_iMinFrameSizeLOG; i <= c_iMaxFrameSizeLOG; i++)
        nspsCcsFft(NULL, i+1, NSP_Init); // Remember FFT size is 2 * frame size, so add 1
#endif // PEAQ_MASK && ENCODER
    
exit:
    return wmaResult;
}



WMARESULT auFreeIntelFFT(CAudioObject *pau,
                         const INTELFFT_INITCODE iCode)
{
    Bool fResult;

    nspcFft(NULL, 0, NSP_Free);

    fResult = MyInitNSP(iCode);
    assert(fResult);

    return WMA_OK;
}


void prvFFT4DCT_INTEL(CoefType data[], Int nLog2np)
{
    nspcFft((SCplx *)data, nLog2np, NSP_Forw);
}


#if defined (PEAQ_MASK) && defined (ENCODER)
Void prvInvFftComplexConjugate_INTEL(Float rgfltData[], Int nLog2np)
{
    nspsCcsFft((float *)rgfltData, nLog2np, NSP_Inv);
}
#endif // PEAQ_MASK && ENCODER
#endif  // !defined(BUILD_INTEGER) && !defined(UNDER_CE)


#endif // if !defined(EMbedded_x86)


// ***************************************************************************
// CPU Detect MMX Functions
// ***************************************************************************

#ifdef _SCRUNCH_INLINE_ASM
Bool g_SupportMMX(void)
{
    static Bool g_bSupportMMX;
    static Int g_iSupportMMXCount = 0;

    Int cpuff;

#ifdef DISABLE_OPT
	return WMAB_FALSE;
#endif	// DISABLE_OPT

    g_iSupportMMXCount++;
    if (g_iSupportMMXCount != 1)
        return g_bSupportMMX;

    cpuff=0;
    _asm {
        // Push general purpose register and pop them out before finish.
        // Need to do push-pop general purpose register because 
        // compiler doesn't know the existence of CPUID which will affect
        // eax, ebx, ecx, edx.  
        push    eax
        push    ebx
        push    ecx
        push    edx

        pushfd                  // Get original EFLAGS
        pop     eax
        mov     ecx,eax
        xor     eax,200000h     // Flip ID bit in EFLAGS
        push    eax             // Save new EFLAGS value on stack
        popfd                   // Replace current EFLAGS value
        pushfd                  // Get new EFLAGS
        pop     eax             // Store new EFLAGS in EAX
        xor     eax,ecx         // Can not toggle ID bit,
        // CPUID opcode is not available, So is MMX 
        jz      noSupport       // Processor=80486  

        xor     eax,eax         // Set up for CPUID instruction
        CPU_ID                  // Get and save vendor ID
        cmp     eax,1           // Make sure 1 is valid input 
        jl      noSupport       // If not, jump to end
        xor     eax,eax
        inc     eax
        CPU_ID                  // Get family/model/stepping/
        and     edx,0x00800000  //   features
        mov     cpuff,edx
noSupport:
        pop edx
        pop ecx
        pop ebx
        pop eax
    }
    g_bSupportMMX = (cpuff != 0);
    return g_bSupportMMX;
} // g_SupportMMX



Bool g_SupportKNI(void)
{
    static Int g_iSupportKNIValue = -1;

    Int cpuff;

#ifdef DISABLE_OPT
	return WMAB_FALSE;
#endif	// DISABLE_OPT

    if (g_iSupportKNIValue > -1) return (Bool)g_iSupportKNIValue;

    cpuff=0;
    _asm {
        // Push general purpose register and pop them out before finish.
        // Need to do push-pop general purpose register because 
        // compiler doesn't know the existence of CPUID which will affect
        // eax, ebx, ecx, edx.  
        push    eax
        push    ebx
        push    ecx
        push    edx

        pushfd                  // Get original EFLAGS
        pop     eax
        mov     ecx,eax
        xor     eax,200000h     // Flip ID bit in EFLAGS
        push    eax             // Save new EFLAGS value on stack
        popfd                   // Replace current EFLAGS value
        pushfd                  // Get new EFLAGS
        pop     eax             // Store new EFLAGS in EAX
        xor     eax,ecx         // Can not toggle ID bit,
        // CPUID opcode is not available, So is MMX 
        jz      noSupport       // Processor=80486  

        xor     eax,eax         // Set up for CPUID instruction
        CPU_ID                  // Get and save vendor ID
        cmp     eax,1           // Make sure 1 is valid input 
        jl      noSupport       // If not, jump to end
		push	ebx
		push	edx
		push	ecx
		xor		ebx,0x756E6547
		xor		edx,0x49656E69
		xor		ecx,0x6C65746E
        xor     eax,eax
		or		ebx,edx
		or		ebx,ecx
		or		eax,ebx
		pop 	ecx
		pop 	edx
		pop 	ebx
		cmp		eax,0
		jz		INTEL
		push	ebx
		push	edx
		push	ecx
		xor		ebx,0x68747541
		xor		edx,0x69746E65
		xor		ecx,0x444D4163
        xor     eax,eax
		or		ebx,edx
		or		ebx,ecx
		or		eax,ebx
		pop 	ecx
		pop 	edx
		pop 	ebx
		cmp		eax,0
		jz		AMD
		jmp		noSupport
INTEL:
        xor     eax,eax
        inc     eax
        CPU_ID                  // Get family/model/stepping/
		// check bit 25 for KNI support
        and     edx,0x02000000  //   features
        mov     cpuff,edx
		jmp		noSupport
AMD:
        xor     eax,eax
        inc     eax
        CPU_ID                  // Get family/model/stepping/
		// check bit 25 for KNI support
        cmp     eax,0x0610  //   features
		jz		K7
        mov     cpuff,0
		jmp		noSupport
K7:
        mov     cpuff,1
noSupport:
        pop edx
        pop ecx
        pop ebx
        pop eax
    }
    g_iSupportKNIValue = (cpuff != 0);
    return (Bool)g_iSupportKNIValue;
} // g_SupportKNI



///////////////////////////////////////////////////////////////////////////////////////////
// Support SMPF FP - X86 vector floating point detection
//
// This function detects the presence of the vector floating point instructions
// as well as OS support it by attempting a harmless vector floating point instruction
// and catching the exception which is generated if the instructions are not supported
//
// A feture which is currently turned off attempts to detect if the emulation is enabled
// by timing the instruction. This is why the RDTSC instruction is used
//
///////////////////////////////////////////////////////////////////////////////////////////
Bool g_SupportSIMD_FP(void)
{
    static Int g_iSupportSIMD_FPValue = -1;

    I64 start;
    I64 end;
    Bool supported;

#ifdef DISABLE_OPT
	return WMAB_FALSE;
#endif	// DISABLE_OPT

    if (!g_SupportKNI()) return WMAB_FALSE;
    if (g_iSupportSIMD_FPValue > -1) return (Bool)g_iSupportSIMD_FPValue;

    supported = WMAB_TRUE;
    _try {
        _asm {
            lea     edi,start        //Check time stamp. Time operation to make sure emulator is not running
            RDTSC
            mov     [edi],eax
            mov     [edi+4],edx
            movaps  xmm1_xmm1
            lea     edi,end 
            RDTSC
            mov     [edi],eax
            mov     [edi+4],edx
        
        }
    } _except (1) {
        supported = WMAB_FALSE;
    }
//    if ((end-start) > 60) supported = WMAB_FALSE; //If it took a lot of clocks to execute the instruction then emulator is running
    g_iSupportSIMD_FPValue = (Int)supported;
    return supported;
} // g_SupportSIMD_FP


Bool g_SupportCMOV(void)
{
    static Bool g_bSupportCMOV = -1;
    Int cpuff;

#ifdef DISABLE_OPT
	return WMAB_FALSE;
#endif	// DISABLE_OPT

    if (g_bSupportCMOV != -1) return g_bSupportCMOV;

    cpuff=0;
    _asm {
        // Push general purpose register and pop them out before finish.
        // Need to do push-pop general purpose register because 
        // compiler doesn't know the existence of CPUID which will affect
        // eax, ebx, ecx, edx.  
        push    eax
        push    ebx
        push    ecx
        push    edx

        pushfd                  // Get original EFLAGS
        pop     eax
        mov     ecx,eax
        xor     eax,200000h     // Flip ID bit in EFLAGS
        push    eax             // Save new EFLAGS value on stack
        popfd                   // Replace current EFLAGS value
        pushfd                  // Get new EFLAGS
        pop     eax             // Store new EFLAGS in EAX
        xor     eax,ecx         // Can not toggle ID bit,
        // CPUID opcode is not available, So does not support CMOV 
        jz      noSupport       // Processor=80486  

        mov     eax,1           // Set up for CPUID instruction	for version and feture information
        CPU_ID                  // Get features
        and     edx,0x00008000  // Mask out all but bit 15 for CMOV detection  
        mov     cpuff,edx
noSupport:
        pop edx
        pop ecx
        pop ebx
        pop eax
    }
    g_bSupportCMOV = (cpuff != 0);
    return g_bSupportCMOV;
} // g_SupportCMOV
#endif // _SCRUNCH_INLINE_ASM


#ifdef ENCODER
// ***************************************************************************
// Quantization X86
// ***************************************************************************

//////////////////////////////////////////////////////////////////////////////////////
// Quantize Spectrum Mono - X86 version
// This function takes advantage of the fact that a floating point compare can be 
// done in the integer unit to avoid exercizing the floating point unit in the most
// common case where a coefficent is either 0 or 1. 
// iZeroThresh is the hex represintation of the floating point number under which 
// all quantized coeffients are zero, iOneThresh is the same but for vales less than 1.
// Basicly the loop optimizes the most common case (0 or 1) at the expence of the less
// common case which needs to do the floating point divide. In this case it is done by
// multiplying with the recripical which is precalculated in fltInverseQuantStep
///////////////////////////////////////////////////////////////////////////////////////
WMARESULT prvQuantizeSpectrumMono_X86(CAudioObjectEncoder *pauenc, PerChannelInfo *pcinfo)	
{
    Float fltInverseQuantStep = 1.0f / pauenc->m_fltQuantStep;

    Float fltZeroThresh = pauenc->m_fltQuantStep / 2;
    Float fltOneThresh  = pauenc->m_fltQuantStep + fltZeroThresh;
    Int iZeroThresh = (*(Int*)&fltZeroThresh) & 0x7fffffff; 
    Int iOneThresh  = (*(Int*)&fltOneThresh)  & 0x7fffffff;
    Int iEscape = 0;
    Int anyNonZero = 0;
    
    assert(WMAB_FALSE); // Unmaintained code! Does not have saturation limits etc.
    _asm{
        mov         ecx, pcinfo               
        mov         esi, [ecx]pcinfo.m_rgfltCoef//Get the source and destination pointers
        mov         edi, [ecx]pcinfo.m_rgiCoefQ

        mov         edx,iZeroThresh             //Get the step size values
        mov         ebx,iOneThresh
        fld         fltInverseQuantStep             
        
        mov         ecx, [ecx]pcinfo.m_cSubbandActual//Get Loop Length
        dec         ecx

        mov         eax,[esi+ecx*4] 

QuantizationLoop:
        and         eax,0x7fffffff              //Check for zero
        cmp         eax,edx
        jge         NotZero
        mov         dword Ptr [edi+ecx*2-2],0   
        mov         eax,[esi+ecx*4-4] 
        dec         ecx
        jns         QuantizationLoop
        jmp         end
NotZero:
        mov         [anyNonZero],1
        cmp         eax,ebx                     //Check for one
        jge         FloatingPointCalc
        mov         eax,[esi+ecx*4]
        sar         eax,15
        or          eax,0x10000
        mov         [edi+ecx*2-2],eax
        mov         eax,[esi+ecx*4-4] 
        dec         ecx
        jns         QuantizationLoop
        jmp         end
FloatingPointCalc:
        fld         [esi+ecx*4]                 //Do full floating point calculateion
        fmul        st(0),st(1)
        fistp       word Ptr [edi+ecx*2]
        movsx       eax,word Ptr [edi+ecx*2]
        cdq
        xor         eax,edx
        sub         eax,edx
        mov         edx,iEscape
        cmp         eax,16
        _asm _emit 0x0F _asm _emit 0x4D _asm _emit 0xD0 //cmovg       eax,edx
        mov         iEscape,edx
        mov         edx,iZeroThresh             //Restore step size value
        mov         eax,[esi+ecx*4-4] 
        dec         ecx
        jns         QuantizationLoop

end:    fstp        st(0)
    }              
    pcinfo->m_rgiCoefQ[-1] = (I16)iEscape;
    pcinfo->m_fAnyNonZeroCoefQ = anyNonZero;
    return WMA_OK;
}

//////////////////////////////////////////////////////////////////////////////////////////
// Quantize (Run Length Code) spectrum
// This function preforms similar functionality to the prvQuantizeSpectrumMono_X86 and 
// does the same integer compare of zero and 1 (see above comment)
// It improves on the basic approach by coding the values as run length codes. This
// is faster as in the most common case (quantized to zero) there is no need to actually 
// store the value and therefore eleinates a lot of bus transctions.
// 
// WARNING!!! The values are stored as 16bit ones complement numbers that is
// 1 = 0x0001 and -1 = 0x8001
// The purpose of storing the numers in this fromat is that the function that uses these
// function starts by taking the absolute value and extracting the sign bit, so the value
// is stored in a format that is more like the format that it will be used in.
// The final output is in the format of (16 bit zero run count) (16 bit ones compement number)
//////////////////////////////////////////////////////////////////////////////////////////////
WMARESULT prvQuantizeRLCSpectrum_X86(CAudioObjectEncoder *pauenc, PerChannelInfo *pcinfo)	
{
    Float fltInverseQuantStep = 1.0f / pauenc->m_fltQuantStep;

    Float fltZeroThresh = pauenc->m_fltQuantStep / 2;
    Float fltOneThresh  = pauenc->m_fltQuantStep + fltZeroThresh;
    Int iZeroThresh = (*(Int*)&fltZeroThresh) & 0x7fffffff; 
    Int iOneThresh  = (*(Int*)&fltOneThresh)  & 0x7fffffff;
    Int iEscape = 0;
    I16 run = 0;
    Int overflow = (Int) (pauenc->pau->m_iMaxEscLevel * QUANTIZER_CLIP_LIMIT);
    Int iMaxEscLevel = pauenc->pau->m_iMaxEscLevel;

    _asm{
        xor         eax,eax
        mov         [esp-20],eax
        mov         eax,overflow
        mov         [esp-16],eax
        mov         eax,iMaxEscLevel
        mov         [esp-8],eax

        mov         ecx, pcinfo               
        mov         esi, [ecx]pcinfo.m_rgfltCoef		//Get the source and destination pointers
        mov         edi, [ecx]pcinfo.m_rgiCoefQRLC

        mov         edx,iZeroThresh             //Get the step size values
        mov         [esp-12],edx
        mov         ebx,iOneThresh
        fld         fltInverseQuantStep             
        
        mov         ecx, [ecx]pcinfo.m_cSubbandActual//Get Loop Length
        lea         esi,[esi+ecx*4]
        neg         ecx

        mov         eax,[esi+ecx*4] 
        mov         [esp-4],ebp
        xor         ebp,ebp

QuantizationLoop:
        and         eax,0x7fffffff              //Check for zero
        cmp         eax,edx
        jge         NotZero
        inc         ebp
        mov         eax,[esi+ecx*4+4] 
        inc         ecx
        jl          QuantizationLoop
        jmp         end
NotZero:
        mov         [esp-20],1 
        cmp         eax,ebx                     //Check for one
        jge         FloatingPointCalc
        mov         eax,[esi+ecx*4]
        and         eax,0x80000000;
        xor         eax,0x80000000;
        or          eax,0x10000
        or          eax,ebp
        mov         [edi],eax
        xor         ebp,ebp
        add         edi,4
        mov         eax,[esi+ecx*4+4]
        inc         ecx
        jl          QuantizationLoop
        jmp         end
FloatingPointCalc:
        fld         [esi+ecx*4]                //Do full floating point calculateion
        fmul        st(0),st(1)
        fistp       word Ptr [edi]
        movsx       eax,word Ptr [edi]         //eax = quantized value 
        mov         edx,eax                  
        and         edx,0x80000000             //Get sign bit in edx
        xor         edx,0x80000000             //and reverse it
        or          ebp,edx                    //save in ebp
        cdq
        xor         eax,edx                    //absolute value of eax
        sub         eax,edx
        mov         edx,[esp-16]
        cmp         eax,edx
        jg          overflow_end
        mov         edx,[esp-8]                //Get copy of edx=pau->m_iMaxEscLevel
        cmp         eax,edx                    //if (eax > edx) eax = edx;
        _asm _emit 0x0F _asm _emit 0x4D _asm _emit 0xC2 //cmovg       eax,edx
        shl         eax,16
        or          eax,ebp
        mov         [edi],eax
        add         edi,4

        mov         edx,[esp-12]             //Restore step size value
        mov         eax,[esi+ecx*4+4] 
        xor         ebp,ebp
        inc         ecx
        jl          QuantizationLoop
        jmp         end

overflow_end:
        mov         ebp,[esp-4]
        mov         ecx,pauenc
        mov         [ecx].m_fQuantOverflow,1


end:    fstp        st(0)
    
        mov         ax,bp
        mov         ebp,[esp-4]
        cmp         ax,0                                                       
        jz          done
        mov         [edi],ax
        add         edi,2
        mov         word Ptr [edi],0
        add         edi,2
done:
        mov         ecx, pcinfo               
        mov         eax, [ecx]pcinfo.m_rgiCoefQRLC
        sub         edi, eax
        shr         edi,1
        mov         [eax-2],di
        mov         eax,[esp-20]
        mov         [ecx]pcinfo.m_fAnyNonZeroCoefQ,eax
              
    }
    return WMA_OK;
}



WMARESULT prvQuantizeRLCSpectrumInvQ_X86(CAudioObjectEncoder *pauenc,
                                         PerChannelInfo *pcinfo)
{
    I16* rgiCoefQ       = pcinfo->m_rgiCoefQRLC;
    const Float* rgfltCoef    = pcinfo->m_rgfltCoef;

    Float* rgfltCoefRecon = pcinfo->m_rgfltCoefRecon;
    const Float* rgfltWeight    = pcinfo->m_rgfltWeightFactor;

    const Int cSubbandActual  = pcinfo->m_cSubbandActual;

    const Float fltQuantStep = pauenc->m_fltQuantStep;
    const Float fltInverseQuantStep = 1.0f / pauenc->m_fltQuantStep;

    const Float fltZeroThresh = pauenc->m_fltQuantStep / 2;
    const Float fltOneThresh  = pauenc->m_fltQuantStep + fltZeroThresh;
    const Int iZeroThresh = (*(Int*)&fltZeroThresh) & 0x7fffffff; 
    const Int iOneThresh  = (*(Int*)&fltOneThresh)  & 0x7fffffff;
    Int i;
    const CAudioObject *pau = pauenc->pau;

    const Int *rgiBarkIndexLastUpdate = pau->m_rgiBarkIndexOrig + (NUM_BARK_BAND + 1) *
        LOG2 (pau->m_cFrameSampleHalf / pau->m_iSubFrameSizeWithUpdate);
    const Int cValidBarkBandLastUpdate = pau->m_rgcValidBarkBand [LOG2 (pau->m_cFrameSampleHalf /
        pau->m_iSubFrameSizeWithUpdate)];
    const Int *piNextBarkIndex = rgiBarkIndexLastUpdate;

    const Int c_iMaskResampleFB = 12;
    const Int c_iRoundUp = (1 << c_iMaskResampleFB) - 1;
    const Int iMaskResampleRatio = (pau->m_iSubFrameSizeWithUpdate << 12) /                           
                          pau->m_subfrmconfigCurr.m_rgiSubFrameSize [pau->m_iCurrSubFrame];
    const Int iIndexResampleRatio =
        (pau->m_subfrmconfigCurr.m_rgiSubFrameSize [pau->m_iCurrSubFrame] << 12) /
        pau->m_iSubFrameSizeWithUpdate;
    
    const I32 c_iOverflow = (I32) (pauenc->pau->m_iMaxEscLevel * QUANTIZER_CLIP_LIMIT);
    const I32 c_iMaxEscLevel = pauenc->pau->m_iMaxEscLevel;
    I32 iTemp;
    I32 fOverflow = WMAB_FALSE;
    I32 fNonZeroCoef = WMAB_FALSE;
    Float *pfltCoefRecon = rgfltCoefRecon;
    I16 *piCoefQRLC = rgiCoefQ;
    const Float *pfltCoef = rgfltCoef;

#ifdef _DEBUG
    I32 rgiFPUEnviro[10] = {0};
#endif  // _DEBUG

    // Setting everything to zero here is faster than doing it in loop
    memset (rgfltCoefRecon, 0, sizeof (CoefType) * pauenc->pau->m_cSubband);
    i = 0;

// Outer loop register assignments
#define rpiNextBarkIndex    eax
#define rpfltWeight         eax
#define riResampledIdx      edx
#define riNextI             edx
#define riNextBoundary      ecx

#define MASKRESAMPLE_FB     12
#define ROUNDUP             0x00000FFF

// Inner loop register assignments
#define rCoef           eax
#define rTemp           eax
#define rpfltCoef       esi
#define riCountZero     ecx
#define riRun           ebx
#define riZeroThresh    edx
#define rTemp2          edx
#define rpiCoefQRLC     edi

#define SIZEOF_I16      2
#define SIZEOF_I32      4
#define SIZEOF_FLOAT    4
    _asm
    {
        // Initialize FLOP stack
        fld     fltInverseQuantStep
        fld     fltQuantStep

        // Initialize persistent inner loop registers (untouched by outer loop)
        mov     rpfltCoef, pfltCoef
        xor     riRun, riRun                // run = 0
        mov     rpiCoefQRLC, piCoefQRLC

outerLoop:
        // Initialize outer loop registers
        mov     riResampledIdx, i
        mov     rpiNextBarkIndex, piNextBarkIndex
        imul    riResampledIdx, iMaskResampleRatio
        sar     riResampledIdx, MASKRESAMPLE_FB

        // Advance bark index until we find one that maps past current i
nextBarkIndex:
        mov     riNextBoundary, [rpiNextBarkIndex]
        add     rpiNextBarkIndex, SIZEOF_I32
        cmp     riResampledIdx, riNextBoundary
        jge     nextBarkIndex

        // Compute next boundary
        mov     riNextI, i
        imul    riNextBoundary, iIndexResampleRatio
        add     riNextBoundary, ROUNDUP
        sar     riNextBoundary, MASKRESAMPLE_FB
        cmp     riNextBoundary, cSubbandActual  // Clamp us to cSubbandActual
        cmovg   riNextBoundary, cSubbandActual

        // Compute inner loop iterations
        sub     rpiNextBarkIndex, SIZEOF_I32
        mov     piNextBarkIndex, rpiNextBarkIndex
        mov     rpfltWeight, rgfltWeight
        mov     i, riNextBoundary           // When we exit inner loop, i = iNextBoundary
        sub     riNextBoundary, riNextI     // Coincidence! riNextBoundary = riCountZero = ecx

        // Compute QuantStep times WeightFactor
        fld     dword ptr [rpfltWeight + SIZEOF_FLOAT * riNextI]    // Load weight factor
        fmul    st(0), st(1)                // QuantStep * WeightFactor
        fld     st(0)                       // Duplicate and
        fchs                                // make negative

        // ***** START OF INNER LOOP *****
        // Load non-persistent inner loop registers
        mov     riZeroThresh, iZeroThresh
        
checkZEROThreshold:
        mov     rCoef, dword ptr [rpfltCoef]// Load rgfltCoef[i] as integer
        and     rCoef, 0x7FFFFFFF       // Take absolute value
        cmp     rCoef, riZeroThresh     // Compare (iFltAbs < iZeroThresh)
        jge     checkONEThreshold
        add     rpfltCoef, SIZEOF_FLOAT // pfltCoef += 1
        inc     riRun                   // run += 1
        dec     riCountZero
        jg      checkZEROThreshold
        jmp     innerLoopEND

checkONEThreshold:
        cmp     rCoef, iOneThresh       // Compare (iFltAbs < iOneThresh)
        jge     moreThanONE
        mov     rCoef, dword ptr [rpfltCoef]// Load original rgfltCoef[i] for its sign
        add     rpfltCoef, SIZEOF_FLOAT // pfltCoef += 1
        not     rCoef                   // iSign = ((iFlt & 0x80000000) ^ 0x80000000)
        and     rCoef, 0x80000000       // We are writing to *piCoefQRLC one DWORD at a time

        // While sign is fresh in our flag register, do inverse quant
        fld     st(1)                   // Default is positive fltQuantStepXWeightFactor
        fcmove  st(0), st(1)            // Load negative fltQuantStepXWeightFactor if needed

        or      rCoef, 0x00010000       // (iSign | 1)
        or      rCoef, riRun            // Now record the run
        mov     dword ptr [rpiCoefQRLC], rCoef  // Write two I16's at a time to *piCoefQRLC
        add     rpiCoefQRLC, 2*SIZEOF_I16       // piCoefQRLC += 2

        // Finish inverse quant now that we have a register
        mov     rTemp, pfltCoefRecon
        lea     rTemp, [rTemp + SIZEOF_FLOAT * riRun + SIZEOF_FLOAT]    // Skip those 0's
        fstp    dword ptr [rTemp - SIZEOF_FLOAT]
        mov     pfltCoefRecon, rTemp

        xor     riRun, riRun            // run = 0
        mov     fNonZeroCoef, 1
        dec     riCountZero
        jg      checkZEROThreshold
        jmp     innerLoopEND

moreThanONE:
        fld     dword ptr [rpfltCoef]
        add     rpfltCoef, SIZEOF_FLOAT
        fmul    st(0), st(4)                // Full meal deal, rgfltCoef[i] * fltInverseQuantStep

#ifdef X86_C_EQUIVALENCE
        // Enable this to achieve bitwise identical output to C
        // Leave disabled for perf reasons
        fstp    dword ptr [iTemp]       // Convert to float so we are consistent with C
        fld     dword ptr [iTemp]
#endif

        fistp   dword ptr [iTemp]           // Round to integer
        mov     rCoef, dword ptr [iTemp]    // Load integer into register
        mov     rTemp2, rCoef               // Commandeer the iZeroThresh register
        not     rTemp2                      // Extract the sign bit
        and     rTemp2, 0x80000000

        // While sign is fresh in our flag register, prep inverse quant            
        fld     st(1)                   // Default is positive fltQuantStepXWeightFactor
        fcmove  st(0), st(1)            // Load negative fltQuantStepXWeightFactor if needed

        or      riRun, rTemp2           // Store sign bit in run register
        cdq                             // Take abs of integer (stored in eax)
        xor     eax, edx
        sub     eax, edx
        cmp     eax, c_iMaxEscLevel     // Clamp quantizer values to their maximums, and
        jg      moreThanONE_checkOverflow // also check for overflow

moreThanONE_invQ:
        mov     dword ptr [iTemp], eax
        fild    dword ptr [iTemp]
        fmulp   st(1), st(0)            // Do (clipTemp * fltQuantStepXWeightFactor)
        shl     eax, 16                 // Construct QRLC entry (entire DWORD at once)
        or      riRun, eax
        mov     dword ptr [edi], riRun  // Write two I16's at a time to *piCoefQRLC
        add     rpiCoefQRLC, 2*SIZEOF_I16   // piCoefQRLC += 2

        mov     riZeroThresh, iZeroThresh   // Restore iZeroThresh register
        and     riRun, 0x0000FFFF       // Restore run value so we can skip the 0's
        mov     rTemp, pfltCoefRecon
        lea     rTemp, [rTemp + SIZEOF_FLOAT * riRun + SIZEOF_FLOAT]
        fstp    dword ptr [rTemp - SIZEOF_FLOAT]
        mov     pfltCoefRecon, rTemp

        xor     riRun, riRun                // run = 0
        mov     fNonZeroCoef, 1
        dec     riCountZero
        jg      checkZEROThreshold
        jmp     innerLoopEND


moreThanONE_checkOverflow:
        cmp     rCoef, c_iOverflow
        cmovle  rCoef, c_iMaxEscLevel
        jle     moreThanONE_invQ

        // OVERFLOW!!
        mov     fOverflow, 1
        fstp    st(0)

        // Dump QuantStep * WeightFactor
        fstp    st(0)
        fstp    st(0)

        jmp     overflowExit


innerLoopEND:
        // Dump QuantStep * WeightFactor
        fstp    st(0)
        fstp    st(0)

        // ***** END OF INNER LOOP *****
        // Check for outer loop exit condition
        mov     rTemp, i
        cmp     rTemp, cSubbandActual
        jl      outerLoop

        // ***** END OF OUTER LOOP *****
        // If we have a non-zero run, write it out
        test    riRun, riRun
        je      overflowExit

        mov     [rpiCoefQRLC], riRun        // Write two I16's at a time to QRLC
        add     rpiCoefQRLC, 2*SIZEOF_I16

overflowExit:
        // Save position in QRLC
        mov     piCoefQRLC, rpiCoefQRLC

        // Dump floating point stack
        fstp    st(0)
        fstp    st(0)

#ifdef _DEBUG
        // Verify that FLOP stack is empty on exit
        fnstenv rgiFPUEnviro
        xor     eax, eax
        mov     eax, dword ptr [rgiFPUEnviro + 2*SIZEOF_I32]    // 3rd DWORD must be 0xFFFFFFFF
        not     eax
        test    eax, eax
        je      debugOUT

        int     3                // We need to clean up that FLOP stack!

debugOUT:
#endif  //_DEBUG
    }

    if (WMAB_FALSE == fOverflow)
    {
        pcinfo->m_rgiCoefQRLC[-1] = (piCoefQRLC - rgiCoefQ);
        pcinfo->m_fAnyNonZeroCoefQ = fNonZeroCoef;
    }
    else
    {
        pcinfo->m_rgiCoefQRLC[-1] = 0;
        pcinfo->m_fAnyNonZeroCoefQ = WMAB_TRUE;
        pauenc->m_fQuantOverflow = WMAB_TRUE;
    }

    return WMA_OK;
} // prvQuantizeRLCSpectrumInvQ_X86



WMARESULT prvQuantizeRLCSpectrumDIFFInvQ_X86(CAudioObjectEncoder *pauenc,
                                             PerChannelInfo *pcinfo)
{
    const Int       cSubbandActual  = pcinfo->m_cSubbandActual;
    const Float    *rgfltCoef = pcinfo->m_rgfltCoef;
    const Float     fltQuantStep = pauenc->m_fltQuantStep;
    const Float     fltInverseQuantStep = 1.0f / pauenc->m_fltQuantStep;
    const Float     fltZeroThresh = pauenc->m_fltQuantStep / 2;
    const Float     fltOneThresh  = pauenc->m_fltQuantStep + fltZeroThresh;
    const Int       iZeroThresh = (*(Int*)&fltZeroThresh) & 0x7fffffff; 
    const Int       iOneThresh  = (*(Int*)&fltOneThresh)  & 0x7fffffff;
    const I32       c_iOverflow = (I32) (pauenc->pau->m_iMaxEscLevel * QUANTIZER_CLIP_LIMIT);
    const I32       c_iMaxEscLevel = (I16) pauenc->pau->m_iMaxEscLevel;
    
    const I16      *rgiCoefQRLCIn = pcinfo->m_rgiCoefQRLC_DIFF;
    I16            *rgiCoefQRLCOut = pcinfo->m_rgiCoefQRLC;

    Float          *rgfltCoefRecon = pcinfo->m_rgfltCoefRecon;
    Float          *rgfltWeight = pcinfo->m_rgfltWeightFactor;
    const I16      *piSrcQ = rgiCoefQRLCIn;
    I16            *piDstQ = rgiCoefQRLCOut;
    Int             iQCount = rgiCoefQRLCIn[-1];
    Int             iCoefIdx = 0;

    Bool            fMergeZeroRuns = WMAB_FALSE;
    Bool            fNonZeroCoefs = WMAB_FALSE;
    Int             iZeroes;

    I32             iTemp = 0;
    I32             fOverflow = WMAB_FALSE;

#ifdef _DEBUG
    I32             rgiFPUEnviro[10] = {0};
#endif  // _DEBUG

    // Most coefficients end up going to zero, so it's faster to memset outside loop
    memset(rgfltCoefRecon, 0, sizeof(pcinfo->m_rgfltCoefRecon[0]) * cSubbandActual);

#define rCoef           eax
#define riCoefQRLC      eax
#define rTemp           eax
#define riZeroes        ebx
#define riLoopCtr       ecx
#define riCoefIdx       edx
#define rTemp2          edx
#define rpfltCoef       esi
#define rpiCoefQRLC     edi

#define SIZEOF_I16      2
#define SIZEOF_I32      4
#define SIZEOF_FLOAT    4

    assert(iQCount > 0);
    _asm
    {
        // Initialize loop
        mov     riLoopCtr, iQCount
        sar     riLoopCtr, 1                // We do 2 QRLC entries at a time in this loop
        mov     rpfltCoef, rgfltCoef
        mov     rpiCoefQRLC, rgiCoefQRLCIn
        xor     riZeroes, riZeroes
        xor     riCoefIdx, riCoefIdx

        // Initialize FLOP stack
        fld     fltInverseQuantStep
        fld     fltQuantStep
        fld     st(0)                       // Duplicate and
        fchs                                // make negative

        jmp nextZeroRun

requantToZero:
        inc     riCoefIdx
        inc     riZeroes                            // This level is one more zero to add to the run
        dec     riLoopCtr
        mov     fMergeZeroRuns, 1                   // fMergeZeroRuns = 1
        jle     loopExit

nextZeroRun:
        mov     riCoefQRLC, dword ptr [rpiCoefQRLC] // Read in I32 at a time from QRLC
        add     rpiCoefQRLC, SIZEOF_I32
        and     riCoefQRLC, 0x0000FFFF              // Only keep the run, the rest is requantized
        add     riCoefIdx, riCoefQRLC               // Increment index
        add     riZeroes, riCoefQRLC                // iZeroes += cRunOfZeroes

        // If QRLC ends with run of zeroes, don't read from rgfltCoef (reads past end of array)
        cmp     riCoefIdx, cSubbandActual
        jl      requantize

        dec     riLoopCtr
        mov     fMergeZeroRuns, 1                   // fMergeZeroRuns = 1
        jmp     loopExit

requantize:
        // Now requantize the level
        mov     rCoef, dword ptr [rpfltCoef + SIZEOF_FLOAT * riCoefIdx]        // Load coefficient
        and     rCoef, 0x7FFFFFFF                   // Take absolute value
        cmp     rCoef, iZeroThresh                  // Does this go to zero?
        jl      requantToZero

        // If we reach here, this requantized to something other than zero
        cmp     rCoef, iOneThresh
        jge     moreThanONE
        mov     rTemp, dword ptr [rpfltCoef + SIZEOF_FLOAT * riCoefIdx] // Reload original to get its sign
        not     rTemp
        and     rTemp, 0x80000000           // Extract that (reversed) sign bit

        // While sign is fresh in our flag register, prep inverse quant            
        fld     st(1)                   // Default is positive fltQuantStep
        fcmove  st(0), st(1)            // Load negative fltQuantStep if needed

        or      rTemp, 0x00010000           // Set magnitude to 1
        or      riZeroes, rTemp             // Construct QLRC entry (two I16's at a time)

        mov     rTemp, piDstQ                       // Write out two I16's at once to QRLC
        mov     dword ptr [rTemp], riZeroes
        add     rTemp, SIZEOF_I32
        mov     piDstQ, rTemp

        // Now finish inverse quantization
        mov     rTemp, rgfltWeight
        fld     dword ptr [rTemp + SIZEOF_FLOAT * riCoefIdx]    // Load rgfltWeight[iCoefIdx]
        mov     rTemp, rgfltCoefRecon
        fmulp   st(1), st(0)                        // (+/-) fltQuantStep * rgfltWeight[iCoefIdx]
        fstp    dword ptr [rTemp + SIZEOF_FLOAT * riCoefIdx]    // Store to rgfltCoefRecon[iCoefIdx]

        mov     fMergeZeroRuns, 0
        inc     riCoefIdx
        mov     fNonZeroCoefs, 1
        xor     riZeroes, riZeroes                  // iZeroes = 0

        dec     riLoopCtr
        jg      nextZeroRun
        jmp     loopExit

moreThanONE:
        // Requantize the mother
        fld     dword ptr [rpfltCoef + SIZEOF_FLOAT * riCoefIdx]
        fmul    st(0), st(3)            // rgfltCoef[iCoefIdx] * fltInverseQuantStep

#ifdef X86_C_EQUIVALENCE
        // Enable this to achieve bitwise identical output to C
        // Leave disabled for perf reasons
        fstp    dword ptr [iTemp]       // Convert to float so we are consistent with C
        fld     dword ptr [iTemp]
#endif

        fistp   dword ptr [iTemp]       // Round to integer
        mov     rTemp, dword ptr [iTemp]// Load rounded integer to register
        mov     iCoefIdx, riCoefIdx
        mov     rTemp2, rTemp           // Commandeer the riCoefIdx register
        not     rTemp2                  // Extract the sign bit
        and     rTemp2, 0x80000000

        // While sign is fresh in our flag register, prep inverse quant            
        fld     st(1)                   // Default is positive fltQuantStep
        fcmove  st(0), st(1)            // Load negative fltQuantStep if needed

        or      riZeroes, rTemp2        // Dump sign bit into riZeroes

        cdq                             // Take abs of integer (stored in eax)
        xor     eax, edx
        sub     eax, edx
        cmp     eax, c_iMaxEscLevel     // Clamp quantizer values to their maximums, and
        jg      moreThanONE_checkOverflow // also check for overflow

moreThanONE_invQ:
        mov     riCoefIdx, iCoefIdx     // Restore riCoefIdx
        mov     dword ptr [iTemp], eax
        fild    dword ptr [iTemp]       // Load quantizer value into FLOP
        fmulp   st(1), st(0)            // iQuantized * fltQuantStep
        shl     eax, 16                 // Construct next two I16's for QRLC
        or      riZeroes, eax

        mov     rTemp, piDstQ                       // Write out two I16's at once to QRLC
        mov     dword ptr [rTemp], riZeroes
        add     rTemp, SIZEOF_I32
        mov     piDstQ, rTemp

        // Now finish inverse quantization
        mov     rTemp, rgfltWeight
        fld     dword ptr [rTemp + SIZEOF_FLOAT * riCoefIdx]    // Load rgfltWeight[iCoefIdx]
        mov     rTemp, rgfltCoefRecon
        fmulp   st(1), st(0)                        // (+/-) fltQuantStep * rgfltWeight[iCoefIdx]
        fstp    dword ptr [rTemp + SIZEOF_FLOAT * riCoefIdx]    // Store to rgfltCoefRecon[iCoefIdx]

        mov     fMergeZeroRuns, 0
        inc     riCoefIdx
        mov     fNonZeroCoefs, 1
        xor     riZeroes, riZeroes                  // iZeroes = 0

        dec     riLoopCtr
        jg      nextZeroRun
        jmp     loopExit

moreThanONE_checkOverflow:
        cmp     eax, c_iOverflow
        cmovle  eax, c_iMaxEscLevel
        jle     moreThanONE_invQ

        // OVERFLOW!!
        mov     fOverflow, 1
        fstp    st(0)               // Dump +/- fltQuantStep
        jmp     loopExit


loopExit:
        // Save variables used in post-processing
        mov     iZeroes, riZeroes
        mov     piSrcQ, rpiCoefQRLC

#ifdef _DEBUG
        // Just for the asserts
        shl     riLoopCtr, 1        // We initially divide by 2 because we write 2 QRLC's at once
        mov     iQCount, riLoopCtr
        mov     iCoefIdx, riCoefIdx
#endif  // _DEBUG

        // Dump FLOP stack
        fstp    st(0)
        fstp    st(0)
        fstp    st(0)

#ifdef _DEBUG
        // Verify that FLOP stack is empty on exit
        fnstenv rgiFPUEnviro
        xor     eax, eax
        mov     eax, dword ptr [rgiFPUEnviro + 2*SIZEOF_I32]    // 3rd DWORD must be 0xFFFFFFFF
        not     eax
        test    eax, eax
        je      debugOUT

        int     3                // We need to clean up that FLOP stack!

debugOUT:
#endif  //_DEBUG
    } // asm

    if (fOverflow)
    {
        pauenc->m_fQuantOverflow = WMAB_TRUE;
        return WMA_OK;
    }

    assert(0 == iQCount); // Otherwise we read bogus memory
    assert(iCoefIdx == pcinfo->m_cSubbandActual);
    assert(piSrcQ == rgiCoefQRLCIn + rgiCoefQRLCIn[-1]);

    if (fMergeZeroRuns)
    {
        // Write out zero level to finish the QRLC table
        *piDstQ = (I16) iZeroes;
        *(piDstQ + 1) = 0;
        piDstQ += 2;
    }

    pcinfo->m_fAnyNonZeroCoefQ = fNonZeroCoefs;
    rgiCoefQRLCOut[-1] = (piDstQ - rgiCoefQRLCOut);

    return WMA_OK;
} // prvQuantizeRLCSpectrumDIFFInvQ_X86


#endif

#ifdef USE_SIN_COS_TABLES
//////////////////////////////////////////////////
//         MMX 32x32=32mbs's multiply           //
//////////////////////////////////////////////////

// input:  mm0 formated as defined by SHUFFLE_BITS
//         mm1 standerd 2s complement 32bit number 
//         mm7 = 0x0000FFFF0000FFFF
// output: mm1
#ifdef BEST_PRESITION
// temporary registers: mm2,mm4
#define MMX_MULT_BP2    _asm {                                     \
_asm                    movq        mm2,mm1                        \
_asm                    pand        mm2,mm7                        \
_asm                    pxor        mm1,mm2                        \
_asm                    psrlw       mm2,1                          \
_asm                    por         mm1,mm2                        \
_asm                    movq        mm2,mm0                        \
_asm                    pmaddwd     mm2,mm1                        \
_asm                    movq        mm4,mm1                        \
_asm                    pslld       mm4,16                         \
_asm                    pmaddwd     mm4,mm0                        \
_asm                    psrld       mm4,15                         \
_asm                    paddd       mm2,mm4                        \
_asm                    psrad       mm2,13                         \
_asm                    psrld       mm1,16                         \
_asm                    pmaddwd     mm1,mm0                        \
_asm                    pslld       mm1,2                          \
_asm                    paddd       mm1,mm2                        }
#else
// temporary registers: mm2
#define MMX_MULT_BP2     _asm {                                    \
_asm                     movq        mm2,mm1                       \
_asm                     pand        mm2,mm7                       \
_asm                     pxor        mm1,mm2                       \
_asm                     psrlw       mm2,1                         \
_asm                     por         mm1,mm2                       \
_asm                     movq        mm2,mm0                       \
_asm                     pmaddwd     mm2,mm1                       \
_asm                     psrad       mm2,13                        \
_asm                     psrld       mm1,16                        \
_asm                     pmaddwd     mm1,mm0                       \
_asm                     pslld       mm1,2                         \
_asm                     paddd       mm1,mm2                       }

#endif

///////////////////////////////////////////
//     Other macros for recomMono_MMX    //
///////////////////////////////////////////

#define LOAD_SIGN _asm  {                                          \
_asm                    movd        mm3,ebx                        \
_asm                    shr         ebx,14                         \
_asm                    movq        mm4,[g_rgiMMXSineTable+ebx*8]  \
_asm                    movd        ebx,mm3                        }

#define ADD_AND_SATURATE _asm {                                    \
_asm                    pslld       mm5,COEF_FRAC_BITS             \
_asm                    paddd       mm5,mm1                        \
_asm                    psrad       mm5,COEF_FRAC_BITS             \
_asm                    packssdw    mm5,mm5                        }

#define INIT_LOOP1_2 _asm {                                        \
_asm                    movzx       eax,word Ptr iLoopCount        \
_asm                    shr         eax,1                          \
_asm                    mov         edi,piDst                      \
_asm                    mov         esi,pSin                       \
_asm                    mov         ecx,piSrc                      \
_asm                    movq        mm7,x0000FFFF0000FFFF          \
_asm                    mov         edx,uiSignbitCount             \
_asm                    movzx       ebx,word Ptr uiSignbitData     }

#define SAVE_LOOP_STATE1_2 _asm {                                  \
_asm                mov         piSrc,ecx                          \
_asm                mov         piDst,edi                          \
_asm                mov         pSin,esi                           \
_asm                mov         uiSignbitCount,edx                 \
_asm                mov         uiSignbitData,bx                   }

#define GET_NEXT_SINES _asm {                                      \
_asm                    movd        mm3,eax                        \
_asm                    mov         eax,piSrcSign                  \
_asm                    movzx       ebx,word Ptr [eax]             \
_asm                    add         eax,2                          \
_asm                    mov         piSrcSign,eax                  \
_asm                    mov         edx,16                         \
_asm                    movd        eax,mm3                        }

#define LOAD_FLIP_SHIFT_SATURATE  _asm   {                         \
_asm                    movq        mm0,[eax-8]                    \
_asm                    movq        mm2,mm0                        \
_asm                    psrlq       mm0,32                         \
_asm                    psllq       mm2,32                         \
_asm                    por         mm0,mm2                        \
_asm                    psrad       mm0,COEF_FRAC_BITS             \
_asm                    packssdw    mm0,mm0                        }

#define INIT_LOOP_3 _asm {                                         \
_asm                    movzx       ecx,word Ptr iLoopCount        \
_asm                    shr         ecx,1                          \
_asm                    pxor        mm7,mm7                        \
_asm                    movq        mm6,xFFFF0000FFFF0000          \
_asm                    mov         edi,piDst                      \
_asm                    mov         eax,piCoef                     }


#ifdef BUILD_INTEGER

WMARESULT auReconstruct_MMX (CAudioObject* pau, I16* piOutput, I16* pcSampleGet, Bool fForceTransformAll){
    Int iChannel;
    WMARESULT hr;
    for (iChannel = 0; iChannel < pau->m_cChannel; iChannel++)
    {
        hr = (auReconMono_MMX) (pau, 
                          pau->m_rgpcinfo + iChannel, 
                          piOutput + iChannel,  
                          (I16*)pcSampleGet,
                          fForceTransformAll);
    }
    return hr;
}

WMARESULT auReconMono_MMX ( CAudioObject* pau, 
                        PerChannelInfo* ppcinfo, 
                        I16* piOutput, 
                        I16* pcSampleGet,
                        Bool fForceTransformAll)
{
    //all starting from the begining of this frame
    //official starting of a subfrm (including leading zeros)
    //case 1 (Large -> Small):  starts later than what's been reconstructed w/o leading zeros
    //                          in this case dst should be skiped (this may mean memcpy from prev)
    //                          src and coef are fine
    //                          
    //case 2 (Small -> Large):  starts earler than what's been reconstructed but all leading zeros
    //                          in this case dst 

    int *pSin = pau->m_piSinForRecon;
    static U32 g_rgiMMXSineTable[8] = { 0,0,0,0xFFFF0000,0xFFFF0000,0,0xFFFF0000,0xFFFF0000};
    static const __int64 x0000FFFF0000FFFF = 0x0000FFFF0000FFFF;
    static const __int64 xFFFF0000FFFF0000 = 0xFFFF0000FFFF0000;

    CoefType *piCoef;   //floating vlaue = (float)*piCoef/(1<<5)  assuming TRANSFORM_FRACT_BITS = 5
    Int i, iEnd, iSegEnd;
    I16 *piSrc, *piDst; 
    // get local copies of these values which are used frequently or repeatedly (helps optimization)
    Int cChan = pau->m_cChannel;
    Int cSubFrameSampleHalf = pau->m_cSubFrameSampleHalfAdjusted;
    Int cSubFrameSampleQuad = pau->m_cSubFrameSampleQuadAdjusted;
    Int iCoefRecurQ2 = pau->m_iCoefRecurQ2;
    Int iCoefRecurQ3 = pau->m_iCoefRecurQ3;

#ifndef PREVOUTPUT_16BITS
    I16    *piSrcSign;
    U16     uiSignbitData;
    U32     uiSignbitCount;
#else
    assert(0); //Not yet implemented
#   pragma COMPILER_MESSAGE("INVALID BUILD!! reconMono_MMX will not work with PREVOUTPUT_16BITS")
#endif  // PREVOUTPUT_16BITS
#ifdef PROFILE
    FunctionProfile fp;
    FunctionProfileStart(&fp,RECON_MONO_PROFILE);
#endif

    //persistent states
    i = ppcinfo->m_iCurrGetPCM_SubFrame;       //current position in a frame
    piCoef = (CoefType*)ppcinfo->m_rgiCoefReconCurr; 
    piSrc = ppcinfo->m_piPrevOutputCurr;

    //eventually we'll use piOutput directly
    piDst = piOutput;

    iEnd = i + *pcSampleGet;
    *pcSampleGet = 0;

    CALC_SIGN_OFFSETS(ppcinfo->m_piPrevOutput, piSrc, ppcinfo->m_piPrevOutputSign, piSrcSign, 
        uiSignbitData, uiSignbitCount, cChan)

    ASSERT_SIGNBIT_POINTER(piSrcSign);

    if (i < cSubFrameSampleQuad) 
    {
        iSegEnd = min (cSubFrameSampleQuad, iEnd);
        if ( i < iSegEnd )
        {
            if (cChan==1){
                I16 iLoopCount = (I16)(iSegEnd-i);
                assert((iLoopCount & 0xF) == 0); 
                (*pcSampleGet)+=iLoopCount;
                i+=iLoopCount;
                _asm{
                INIT_LOOP1_2
                pxor mm6,mm6

                Loop1m:
                    mov         [esp-12],eax

                    mov         eax,piCoef
                    movq        mm0,[esi]
                    movq        mm1,[eax]

                    MMX_MULT_BP2

                    LOAD_SIGN

                    movd        mm5,[ecx]
                    punpcklwd   mm5,mm6     //for mono
                    por         mm5,mm4       

                    ADD_AND_SATURATE

                    movd        [edi],mm5


                    add         ecx,2*2
                    add         edi,2*2
                    add         esi,2*4
                    add         eax,2*4
                    mov         piCoef,eax

                    sub         edx,2
                    shl         ebx,2
                    and         ebx,0xFFFF

                    cmp         edx,0
                    jnz         SineRegisterNotEmpty1m
                        GET_NEXT_SINES
                    SineRegisterNotEmpty1m:


                mov         eax,[esp-12]
                dec         eax
                jnz         Loop1m

                SAVE_LOOP_STATE1_2

                } 
            }else {
                I16 iLoopCount = (I16)(iSegEnd-i);
                assert((iLoopCount & 0xF) == 0); 
                (*pcSampleGet)+=iLoopCount;
                i+=iLoopCount;
                _asm{
                INIT_LOOP1_2
                movq        mm6,xFFFF0000FFFF0000     

                Loop1:
                    mov         [esp-12],eax

                    mov         eax,piCoef
                    movq        mm0,[esi]
                    movq        mm1,[eax]

                    MMX_MULT_BP2

                    LOAD_SIGN

                    movq        mm5,[ecx]
                    pand        mm5,mm7       
                    por         mm5,mm4       

                    ADD_AND_SATURATE

                    pxor        mm4,mm4        //interleved write for sterio
                    punpcklwd   mm5,mm4
                    movq        mm4,[edi]
                    pand        mm4,mm6
                    por         mm5,mm4
                    movq        [edi],mm5


                    add         ecx,4*2
                    add         edi,4*2
                    add         esi,2*4
                    add         eax,2*4
                    mov         piCoef,eax

                    sub         edx,2
                    shl         ebx,2
                    and         ebx,0xFFFF

                    cmp         edx,0
                    jnz         SineRegisterNotEmpty1
                        GET_NEXT_SINES
                    SineRegisterNotEmpty1:


                mov         eax,[esp-12]
                dec         eax
                jnz         Loop1

                SAVE_LOOP_STATE1_2

                } 
            }
        }
    }
    if (i < iCoefRecurQ2)  
    {
        iSegEnd = min (iCoefRecurQ2, iEnd);
        if ( i < iSegEnd )
        {
            I16 iLoopCount = (I16)(iSegEnd-i);
            assert((iLoopCount&0x1) == 0);
            (*pcSampleGet)+=iLoopCount;
            i+=iLoopCount;
            if (cChan==1){
                _asm{
                INIT_LOOP1_2
                pxor             mm6,mm6

                Loop2:
                    mov         [esp-12],eax

                    mov         eax,piCoef

                    movq        mm0,[esi]
                    movq        mm1,[eax-8]

                    movq        mm2,mm1   //Flip high and low 32 bits
                    psrlq       mm1,32
                    psllq       mm2,32
                    por         mm1,mm2

                    MMX_MULT_BP2

                    LOAD_SIGN

                    movd        mm5,[ecx]
                    punpcklwd   mm5,mm6     
                    por         mm5,mm4     

                    ADD_AND_SATURATE

                    movd        [edi],mm5


                    add         ecx,2*2
                    add         edi,2*2
                    add         esi,2*4

                    sub         eax,2*4
                    mov         piCoef,eax

                    sub         edx,2
                    shl         ebx,2
                    and         ebx,0xFFFF

                    cmp         edx,0
                    jnz         SineRegisterNotEmpty2
                        GET_NEXT_SINES
                    SineRegisterNotEmpty2:

                mov         eax,[esp-12]
                dec         eax
                jnz         Loop2

                SAVE_LOOP_STATE1_2

                } 
            } else {
                _asm{
                INIT_LOOP1_2
                movq        mm6,xFFFF0000FFFF0000     

                Loop2m:
                    mov         [esp-12],eax

                    mov         eax,piCoef

                    movq        mm0,[esi]
                    movq        mm1,[eax-8]

                    movq        mm2,mm1   //Flip high and low 32 bits
                    psrlq       mm1,32
                    psllq       mm2,32
                    por         mm1,mm2

                    MMX_MULT_BP2

                    LOAD_SIGN

                    movq        mm5,[ecx]
                    pand        mm5,mm7       //for sterio
                    por         mm5,mm4       //for sterio
                    //punpcklwd   mm5,mm6     //for mono

                    ADD_AND_SATURATE

                    pxor        mm4,mm4        //interleved write for sterio
                    punpcklwd   mm5,mm4
                    movq        mm4,[edi]
                    pand        mm4,mm6
                    por         mm5,mm4
                    movq        [edi],mm5


                    add         ecx,4*2
                    add         edi,4*2
                    add         esi,2*4

                    sub         eax,2*4
                    mov         piCoef,eax

                    sub         edx,2
                    shl         ebx,2
                    and         ebx,0xFFFF

                    cmp         edx,0
                    jnz         SineRegisterNotEmpty2m
                        GET_NEXT_SINES
                    SineRegisterNotEmpty2m:

                mov         eax,[esp-12]
                dec         eax
                jnz         Loop2m

                SAVE_LOOP_STATE1_2

                } 
            }
        }
    }
    if (i < iCoefRecurQ3) 
    {
        I16 iLoopCount;
        iSegEnd = min (iCoefRecurQ3, iEnd);
        iLoopCount = (I16)( iSegEnd - i );
        assert((iLoopCount&1)==0); 
        (*pcSampleGet)+=iLoopCount;
        i+=iLoopCount;
        if (iLoopCount) {
            if (cChan==1){
                _asm{
                INIT_LOOP_3
                Loop3m:      
                    LOAD_FLIP_SHIFT_SATURATE
                    movd        [edi],mm0   //store 
                    add         edi,2*2
                    sub         eax,2*4
                dec         ecx
                jnz         Loop3m
                mov         piDst,edi
                mov         piCoef,eax
                }
            }else{
                _asm{
                INIT_LOOP_3
                
                Loop3:      
                    LOAD_FLIP_SHIFT_SATURATE
                    punpcklwd   mm0,mm7     //Merge with interleved data
                    movq        mm1,[edi]
                    pand        mm1,mm6
                    por         mm0,mm1
                    movq        [edi],mm0   //store 
                    add         edi,4*2
                    sub         eax,2*4
                dec         ecx
                jnz         Loop3
                mov         piDst,edi
                mov         piCoef,eax
                }
            }
        }
    }
    _asm emms

    SAVE_SIGNBIT_STATE(piSrcSign,uiSignbitData);
    ppcinfo->m_rgiCoefReconCurr = (Int*)piCoef;
    ppcinfo->m_iCurrGetPCM_SubFrame = (I16)i;
    ppcinfo->m_piPrevOutputCurr = piSrc;
#ifdef PROFILE
    FunctionProfileStop(&fp);
#endif
    return WMA_OK;
}
#undef MMX_MULT_BP2
#undef LOAD_SIGN
#undef ADD_AND_SATURATE
#undef INIT_LOOP1_2
#undef SAVE_LOOP_STATE1_2 
#undef GET_NEXT_SINES
#undef LOAD_FLIP_SHIFT_SATURATE
#undef INIT_LOOP_3 

#else //not BUILD_INTEGER

#ifndef PREVOUTPUT_16BITS
#define COMBINE_SIGNBIT_FAST                                                   \
               iResult = (((uiSignbitData)>>15) & 0xFFFF0000) | (U16)*piSrc;   \
               uiSignbitData <<= 1;                                             
#else
#define COMBINE_SIGNBIT_FAST iResult = *piSrc; 
#endif            


#define RECORD_SIGNBIT_FAST                           \
    uiSignbitData <<= 1;                              \
    uiSignbitData |= ((iResult >> 31) & 0x00000001);  \
    uiSignbitCount += 1;                               


/////////////////////////////////////////////////////////////////////////////////////
// Save History Mono - X86 optimized version
// This function achieves its speedup by unrolling the loop so that the 1 out of 16
// brantch is removed and the same functionality is done with the loop structure.
// It also uses the sin tables instead of doing the recursion 
/////////////////////////////////////////////////////////////////////////////////////
#if !defined(PREVOUTPUT_16BITS) && !defined (BUILD_INTEGER) && !defined (DISABLE_OPT)
WMARESULT auSaveHistoryMono (CAudioObject* pau, 
                            PerChannelInfo* ppcinfo, 
                            Bool fForceTransformAll)
{
    CoefType *piCoef;   //floating vlaue = (float)*piCoef/(1<<5)  assuming TRANSFORM_FRACT_BITS = 5
    
    Int i;      // , iEnd, iSegEnd;
    I16 *piDst; 
    I32 iResult;
    CoefType cfResult;

    // get local copies of these values which are used frequently or repeatedly (helps optimization)
    Int cChan = pau->m_cChannel;
	// HALF_TRANSFORM: the following member variables are not restored so continue to hold their halved values
    Int cSubFrameSample3Quad = 3 * pau->m_cSubFrameSampleQuadAdjusted;
    Int iCoefRecurQ4 = pau->m_iCoefRecurQ4;
    BP2Type bp2Sin  = INTEGER_OR_INT_FLOAT( pau->m_iSinRampDownStart, pau->m_fltSinRampDownStart );
    BP2Type bp2Cos  = INTEGER_OR_INT_FLOAT( pau->m_iCosRampDownStart, pau->m_fltCosRampDownStart );
    BP2Type bp2Sin1 = INTEGER_OR_INT_FLOAT( pau->m_iSinRampDownPrior, pau->m_fltSinRampDownPrior );
    BP2Type bp2Cos1 = INTEGER_OR_INT_FLOAT( pau->m_iCosRampDownPrior, pau->m_fltCosRampDownPrior );
    BP2Type bp2Step = INTEGER_OR_INT_FLOAT( pau->m_iSinRampDownStep,  pau->m_fltSinRampDownStep  );
    Float *pfltSinTable = pau->m_piSinForSaveHistory;
    Int iLoopCnt;
    Int iLoopLen;
    Int iLoopBy16;
    Int iLoopBy1;

#ifndef PREVOUTPUT_16BITS
    I16    *piDstSign = ppcinfo->m_piPrevOutputSign;
    U32     uiSignbitData = 0;
    U32     uiSignbitCount = 0;
#endif  // PREVOUTPUT_16BITS

#ifdef PROFILE
    FunctionProfile fp;
    FunctionProfileStart(&fp,SAVE_HISTORY_MONO_PROFILE);
#endif

    //all starting from the begining of this frame
    //official starting of a subfrm (including leading zeros)
    //case 1 (Large -> Small):  starts later than what's been reconstructed w/o leading zeros
    //                          in this case dst should be skiped (this may mean memcpy from prev)
    //                          src and coef are fine
    //                          
    //case 2 (Small -> Large):  starts earler than what's been reconstructed but all leading zeros
    //                          in this case dst 

    //eventually we'll use piOutput directly
    piDst = ppcinfo->m_piPrevOutput;


    //persistent states
    i = ppcinfo->m_iCurrGetPCM_SubFrame;       //current position in a frame
    assert( (0<=i && i<=iCoefRecurQ4) || (i==CURRGETPCM_INVALID));
    piCoef = (CoefType*)ppcinfo->m_rgiCoefReconCurr; 
    ASSERT_SIGNBIT_POINTER(piDstSign);


#if defined(WMA_SHOW_FRAMES)  && defined(_DEBUG)
    prvWmaShowFrames(pau, "SavHist", " %4d 0x%08x 0x%08x %4d %4d", 
        i, piCoef, piDst, cSubFrameSample3Quad, iCoefRecurQ4);
#endif
    iLoopLen = cSubFrameSample3Quad - i;
    if ( iLoopLen<0 )
        iLoopLen = 0;
    iLoopBy1  = iLoopLen & 0xF;
    iLoopBy16 = iLoopLen >> 4;
    for (iLoopCnt = 0; iLoopCnt < iLoopBy16; iLoopCnt++,i+=16) {

        //1
        cfResult = INT_FROM_COEF( MULT_BP2(*--pfltSinTable,*--piCoef) );
        ROUND_SATURATE_STORE( piDst, cfResult, I17_MIN, I17_MAX, iResult );
        piDst += cChan;
        RECORD_SIGNBIT_FAST;

        //2
        cfResult = INT_FROM_COEF( MULT_BP2(*--pfltSinTable,*--piCoef) );
        ROUND_SATURATE_STORE( piDst, cfResult, I17_MIN, I17_MAX, iResult );
        piDst += cChan;
        RECORD_SIGNBIT_FAST;

        //3
        cfResult = INT_FROM_COEF( MULT_BP2(*--pfltSinTable,*--piCoef) );
        ROUND_SATURATE_STORE( piDst, cfResult, I17_MIN, I17_MAX, iResult );
        piDst += cChan;
        RECORD_SIGNBIT_FAST;

        //4
        cfResult = INT_FROM_COEF( MULT_BP2(*--pfltSinTable,*--piCoef) );
        ROUND_SATURATE_STORE( piDst, cfResult, I17_MIN, I17_MAX, iResult );
        piDst += cChan;
        RECORD_SIGNBIT_FAST;

        //5
        cfResult = INT_FROM_COEF( MULT_BP2(*--pfltSinTable,*--piCoef) );
        ROUND_SATURATE_STORE( piDst, cfResult, I17_MIN, I17_MAX, iResult );
        piDst += cChan;
        RECORD_SIGNBIT_FAST;

        //6
        cfResult = INT_FROM_COEF( MULT_BP2(*--pfltSinTable,*--piCoef) );
        ROUND_SATURATE_STORE( piDst, cfResult, I17_MIN, I17_MAX, iResult );
        piDst += cChan;
        RECORD_SIGNBIT_FAST;

        //7
        cfResult = INT_FROM_COEF( MULT_BP2(*--pfltSinTable,*--piCoef) );
        ROUND_SATURATE_STORE( piDst, cfResult, I17_MIN, I17_MAX, iResult );
        piDst += cChan;
        RECORD_SIGNBIT_FAST;

        //8
        cfResult = INT_FROM_COEF( MULT_BP2(*--pfltSinTable,*--piCoef) );
        ROUND_SATURATE_STORE( piDst, cfResult, I17_MIN, I17_MAX, iResult );
        piDst += cChan;
        RECORD_SIGNBIT_FAST;

        //9
        cfResult = INT_FROM_COEF( MULT_BP2(*--pfltSinTable,*--piCoef) );
        ROUND_SATURATE_STORE( piDst, cfResult, I17_MIN, I17_MAX, iResult );
        piDst += cChan;
        RECORD_SIGNBIT_FAST;

        //10
        cfResult = INT_FROM_COEF( MULT_BP2(*--pfltSinTable,*--piCoef) );
        ROUND_SATURATE_STORE( piDst, cfResult, I17_MIN, I17_MAX, iResult );
        piDst += cChan;
        RECORD_SIGNBIT_FAST;

        //11
        cfResult = INT_FROM_COEF( MULT_BP2(*--pfltSinTable,*--piCoef) );
        ROUND_SATURATE_STORE( piDst, cfResult, I17_MIN, I17_MAX, iResult );
        piDst += cChan;
        RECORD_SIGNBIT_FAST;

        //12
        cfResult = INT_FROM_COEF( MULT_BP2(*--pfltSinTable,*--piCoef) );
        ROUND_SATURATE_STORE( piDst, cfResult, I17_MIN, I17_MAX, iResult );
        piDst += cChan;
        RECORD_SIGNBIT_FAST;

        //13
        cfResult = INT_FROM_COEF( MULT_BP2(*--pfltSinTable,*--piCoef) );
        ROUND_SATURATE_STORE( piDst, cfResult, I17_MIN, I17_MAX, iResult );
        piDst += cChan;
        RECORD_SIGNBIT_FAST;

        //14
        cfResult = INT_FROM_COEF( MULT_BP2(*--pfltSinTable,*--piCoef) );
        ROUND_SATURATE_STORE( piDst, cfResult, I17_MIN, I17_MAX, iResult );
        piDst += cChan;
        RECORD_SIGNBIT_FAST;

        //15
        cfResult = INT_FROM_COEF( MULT_BP2(*--pfltSinTable,*--piCoef) );
        ROUND_SATURATE_STORE( piDst, cfResult, I17_MIN, I17_MAX, iResult );
        piDst += cChan;
        RECORD_SIGNBIT_FAST;

        //16
        cfResult = INT_FROM_COEF( MULT_BP2(*--pfltSinTable,*--piCoef) );
        ROUND_SATURATE_STORE( piDst, cfResult, I17_MIN, I17_MAX, iResult );
        piDst += cChan;
        RECORD_SIGNBIT_FAST;

        *piDstSign = (I16) uiSignbitData;                                       
        piDstSign += 1;                                                      
        uiSignbitCount = 0;                                                     

    }

    for (iLoopCnt = 0; iLoopCnt < iLoopBy1; iLoopBy1++,i++)    {

        cfResult = INT_FROM_COEF( MULT_BP2(*--pfltSinTable,*--piCoef) );
        ROUND_SATURATE_STORE( piDst, cfResult, I17_MIN, I17_MAX, iResult );

        piDst += cChan;

        RECORD_SIGNBIT(iResult, piDstSign, uiSignbitData,
            uiSignbitCount, 1);

    }

    iLoopLen = iCoefRecurQ4 - i;
    if ( iLoopLen < 0 )
        iLoopLen = 0;
    iLoopBy1  = iLoopLen & 0xF;
    iLoopBy16 = iLoopLen >> 4;
    for (iLoopCnt=0; iLoopCnt < iLoopBy16; iLoopCnt++,i++)    {

        cfResult = INT_FROM_COEF( MULT_BP2(-(*--pfltSinTable),*piCoef++) );
        ROUND_SATURATE_STORE( piDst, cfResult, I17_MIN, I17_MAX, iResult );
        piDst += cChan;
        RECORD_SIGNBIT_FAST;

        cfResult = INT_FROM_COEF( MULT_BP2(-(*--pfltSinTable),*piCoef++) );
        ROUND_SATURATE_STORE( piDst, cfResult, I17_MIN, I17_MAX, iResult );
        piDst += cChan;
        RECORD_SIGNBIT_FAST;

        cfResult = INT_FROM_COEF( MULT_BP2(-(*--pfltSinTable),*piCoef++) );
        ROUND_SATURATE_STORE( piDst, cfResult, I17_MIN, I17_MAX, iResult );
        piDst += cChan;
        RECORD_SIGNBIT_FAST;

        cfResult = INT_FROM_COEF( MULT_BP2(-(*--pfltSinTable),*piCoef++) );
        ROUND_SATURATE_STORE( piDst, cfResult, I17_MIN, I17_MAX, iResult );
        piDst += cChan;
        RECORD_SIGNBIT_FAST;

        cfResult = INT_FROM_COEF( MULT_BP2(-(*--pfltSinTable),*piCoef++) );
        ROUND_SATURATE_STORE( piDst, cfResult, I17_MIN, I17_MAX, iResult );
        piDst += cChan;
        RECORD_SIGNBIT_FAST;

        cfResult = INT_FROM_COEF( MULT_BP2(-(*--pfltSinTable),*piCoef++) );
        ROUND_SATURATE_STORE( piDst, cfResult, I17_MIN, I17_MAX, iResult );
        piDst += cChan;
        RECORD_SIGNBIT_FAST;

        cfResult = INT_FROM_COEF( MULT_BP2(-(*--pfltSinTable),*piCoef++) );
        ROUND_SATURATE_STORE( piDst, cfResult, I17_MIN, I17_MAX, iResult );
        piDst += cChan;
        RECORD_SIGNBIT_FAST;

        cfResult = INT_FROM_COEF( MULT_BP2(-(*--pfltSinTable),*piCoef++) );
        ROUND_SATURATE_STORE( piDst, cfResult, I17_MIN, I17_MAX, iResult );
        piDst += cChan;
        RECORD_SIGNBIT_FAST;

        cfResult = INT_FROM_COEF( MULT_BP2(-(*--pfltSinTable),*piCoef++) );
        ROUND_SATURATE_STORE( piDst, cfResult, I17_MIN, I17_MAX, iResult );
        piDst += cChan;
        RECORD_SIGNBIT_FAST;

        cfResult = INT_FROM_COEF( MULT_BP2(-(*--pfltSinTable),*piCoef++) );
        ROUND_SATURATE_STORE( piDst, cfResult, I17_MIN, I17_MAX, iResult );
        piDst += cChan;
        RECORD_SIGNBIT_FAST;

        cfResult = INT_FROM_COEF( MULT_BP2(-(*--pfltSinTable),*piCoef++) );
        ROUND_SATURATE_STORE( piDst, cfResult, I17_MIN, I17_MAX, iResult );
        piDst += cChan;
        RECORD_SIGNBIT_FAST;

        cfResult = INT_FROM_COEF( MULT_BP2(-(*--pfltSinTable),*piCoef++) );
        ROUND_SATURATE_STORE( piDst, cfResult, I17_MIN, I17_MAX, iResult );
        piDst += cChan;
        RECORD_SIGNBIT_FAST;

        cfResult = INT_FROM_COEF( MULT_BP2(-(*--pfltSinTable),*piCoef++) );
        ROUND_SATURATE_STORE( piDst, cfResult, I17_MIN, I17_MAX, iResult );
        piDst += cChan;
        RECORD_SIGNBIT_FAST;

        cfResult = INT_FROM_COEF( MULT_BP2(-(*--pfltSinTable),*piCoef++) );
        ROUND_SATURATE_STORE( piDst, cfResult, I17_MIN, I17_MAX, iResult );
        piDst += cChan;
        RECORD_SIGNBIT_FAST;

        cfResult = INT_FROM_COEF( MULT_BP2(-(*--pfltSinTable),*piCoef++) );
        ROUND_SATURATE_STORE( piDst, cfResult, I17_MIN, I17_MAX, iResult );
        piDst += cChan;
        RECORD_SIGNBIT_FAST;

        cfResult = INT_FROM_COEF( MULT_BP2(-(*--pfltSinTable),*piCoef++) );
        ROUND_SATURATE_STORE( piDst, cfResult, I17_MIN, I17_MAX, iResult );
        piDst += cChan;
        RECORD_SIGNBIT_FAST;

        *piDstSign = (I16) uiSignbitData;                                       
        piDstSign += 1;                                                      
        uiSignbitCount = 0;                                                     
    }
    for (iLoopCnt=0; iLoopCnt < iLoopBy1; iLoopCnt++,i++)    {

        cfResult = INT_FROM_COEF( MULT_BP2(-(*--pfltSinTable),*piCoef++) );
        
        ROUND_SATURATE_STORE( piDst, cfResult, I17_MIN, I17_MAX, iResult );

        piDst += cChan;

        RECORD_SIGNBIT(iResult, piDstSign, uiSignbitData,
            uiSignbitCount, 1);

    }

    ppcinfo->m_iCurrGetPCM_SubFrame = (I16)i;       //protect ourself from multiple calls

#ifdef PROFILE
    FunctionProfileStop(&fp);
#endif
    return WMA_OK;
}
#endif // !defined(PREVOUTPUT_16BITS) && !defined (BUILD_INTEGER) && !defined (DISABLE_OPT)

//This function is here to satisfy the function pointers to be compatible with the 
//reconStereo's
WMARESULT auReconstruct_X86 (CAudioObject* pau, I16* piOutput, I16* pcSampleGet, Bool fForceTransformAll){
    Int iChannel;
    WMARESULT hr;
    for (iChannel = 0; iChannel < pau->m_cChannel; iChannel++)
    {
        hr = (auReconMono_X86) (pau, 
                          pau->m_rgpcinfo + iChannel, 
                          piOutput + iChannel,  
                          (I16*)pcSampleGet,
                          fForceTransformAll);
        if (hr != WMA_OK){
            pau->aupfnReconstruct = auReconstruct;
            return auReconstruct(pau,piOutput,pcSampleGet,fForceTransformAll); 
        }
    }
    return hr;
}

/////////////////////////////////////////////////////////////////////////////////////
// Recon Mono - X86 optimized version
// This function achieves its speedup by unrolling the loop so that the 1 out of 16
// brantch is removed and the same functionality is done with the loop structure.
// It also uses the sin tables instead of doing the recursion 
/////////////////////////////////////////////////////////////////////////////////////

WMARESULT auReconMono_X86 ( CAudioObject* pau, 
                        PerChannelInfo* ppcinfo, 
                        I16* piOutput, 
                        I16* pcSampleGet,
                        Bool fForceTransformAll)
{
    //all starting from the begining of this frame
    //official starting of a subfrm (including leading zeros)
    //case 1 (Large -> Small):  starts later than what's been reconstructed w/o leading zeros
    //                          in this case dst should be skiped (this may mean memcpy from prev)
    //                          src and coef are fine
    //                          
    //case 2 (Small -> Large):  starts earler than what's been reconstructed but all leading zeros
    //                          in this case dst 

    CoefType *piCoef;   //floating vlaue = (float)*piCoef/(1<<5)  assuming TRANSFORM_FRACT_BITS = 5
    Int i, iEnd, iSegEnd;
    I16 *piSrc, *piDst; 
    I32 iResult;
    CoefType cfResult;
    // get local copies of these values which are used frequently or repeatedly (helps optimization)
    Int cChan = pau->m_cChannel;
    Int cSubFrameSampleHalf = pau->m_cSubFrameSampleHalfAdjusted;
    Int cSubFrameSampleQuad = pau->m_cSubFrameSampleQuadAdjusted;
    Int iCoefRecurQ2 = pau->m_iCoefRecurQ2;
    Int iCoefRecurQ3 = pau->m_iCoefRecurQ3;
    BP2Type bp2Sin  = *((BP2Type*)(&ppcinfo->m_iSin));
    BP2Type bp2Cos  = *((BP2Type*)(&ppcinfo->m_iCos));
    BP2Type bp2Sin1 = *((BP2Type*)(&ppcinfo->m_iSin1));
    BP2Type bp2Cos1 = *((BP2Type*)(&ppcinfo->m_iCos1));
    BP2Type bp2Step = *((BP2Type*)(&ppcinfo->m_iStep));
    float *piSin = pau->m_piSinForRecon;

#ifndef PREVOUTPUT_16BITS
    U16    *piSrcSign;
    I32     uiSignbitData;
    U32     uiSignbitCount;
#endif  // PREVOUTPUT_16BITS
#ifdef PROFILE
    FunctionProfile fp;
    FunctionProfileStart(&fp,RECON_MONO_PROFILE);
#endif

    //persistent states
    i = ppcinfo->m_iCurrGetPCM_SubFrame;       //current position in a frame
    piCoef = (CoefType*)ppcinfo->m_rgiCoefReconCurr; 
    piSrc = ppcinfo->m_piPrevOutputCurr;

    //eventually we'll use piOutput directly
    piDst = piOutput;

    iEnd = i + *pcSampleGet;
    *pcSampleGet = 0;

    CALC_SIGN_OFFSETS(ppcinfo->m_piPrevOutput, piSrc, ppcinfo->m_piPrevOutputSign, piSrcSign, 
        uiSignbitData, uiSignbitCount, cChan)
    ASSERT_SIGNBIT_POINTER(piSrcSign);

    if (i < cSubFrameSampleQuad) 
    {
        iSegEnd = min (cSubFrameSampleQuad, iEnd);
        if ( i < iSegEnd )
        {
            Int iLoopBy16,iLoopBy1,iLoopCnt;
            iLoopBy16 = (iSegEnd - i) >> 4;
            iLoopBy1  = (iSegEnd - i) & 0xF;
            (*pcSampleGet) += (I16)(iLoopBy16<<4);
            i += (iLoopBy16<<4);
            for (iLoopCnt = 0; iLoopCnt < iLoopBy16; iLoopCnt++)    {
                uiSignbitData<<=16;

                COMBINE_SIGNBIT_FAST
                cfResult = INT_FROM_COEF( MULT_BP2(*piSin++,*piCoef++) + COEF_FROM_INT(iResult) );
                ROUND_SATURATE_STORE( piDst, cfResult, SHRT_MIN, SHRT_MAX, iResult );
                piSrc += cChan;
                piDst += cChan;

                COMBINE_SIGNBIT_FAST
                cfResult = INT_FROM_COEF( MULT_BP2(*piSin++,*piCoef++) + COEF_FROM_INT(iResult) );
                ROUND_SATURATE_STORE( piDst, cfResult, SHRT_MIN, SHRT_MAX, iResult );
                piSrc += cChan;
                piDst += cChan;

                COMBINE_SIGNBIT_FAST                                                         
                cfResult = INT_FROM_COEF( MULT_BP2(*piSin++,*piCoef++) + COEF_FROM_INT(iResult) );
                ROUND_SATURATE_STORE( piDst, cfResult, SHRT_MIN, SHRT_MAX, iResult );
                piSrc += cChan;
                piDst += cChan;

                COMBINE_SIGNBIT_FAST                                                         
                cfResult = INT_FROM_COEF( MULT_BP2(*piSin++,*piCoef++) + COEF_FROM_INT(iResult) );
                ROUND_SATURATE_STORE( piDst, cfResult, SHRT_MIN, SHRT_MAX, iResult );
                piSrc += cChan;
                piDst += cChan;

                COMBINE_SIGNBIT_FAST                                                         
                cfResult = INT_FROM_COEF( MULT_BP2(*piSin++,*piCoef++) + COEF_FROM_INT(iResult) );
                ROUND_SATURATE_STORE( piDst, cfResult, SHRT_MIN, SHRT_MAX, iResult );
                piSrc += cChan;
                piDst += cChan;

                COMBINE_SIGNBIT_FAST                                                         
                cfResult = INT_FROM_COEF( MULT_BP2(*piSin++,*piCoef++) + COEF_FROM_INT(iResult) );
                ROUND_SATURATE_STORE( piDst, cfResult, SHRT_MIN, SHRT_MAX, iResult );
                piSrc += cChan;
                piDst += cChan;

                COMBINE_SIGNBIT_FAST                                                         
                cfResult = INT_FROM_COEF( MULT_BP2(*piSin++,*piCoef++) + COEF_FROM_INT(iResult) );
                ROUND_SATURATE_STORE( piDst, cfResult, SHRT_MIN, SHRT_MAX, iResult );
                piSrc += cChan;
                piDst += cChan;

                COMBINE_SIGNBIT_FAST                                                         
                cfResult = INT_FROM_COEF( MULT_BP2(*piSin++,*piCoef++) + COEF_FROM_INT(iResult) );
                ROUND_SATURATE_STORE( piDst, cfResult, SHRT_MIN, SHRT_MAX, iResult );
                piSrc += cChan;
                piDst += cChan;

                COMBINE_SIGNBIT_FAST                                                         
                cfResult = INT_FROM_COEF( MULT_BP2(*piSin++,*piCoef++) + COEF_FROM_INT(iResult) );
                ROUND_SATURATE_STORE( piDst, cfResult, SHRT_MIN, SHRT_MAX, iResult );
                piSrc += cChan;
                piDst += cChan;

                COMBINE_SIGNBIT_FAST                                                         
                cfResult = INT_FROM_COEF( MULT_BP2(*piSin++,*piCoef++) + COEF_FROM_INT(iResult) );
                ROUND_SATURATE_STORE( piDst, cfResult, SHRT_MIN, SHRT_MAX, iResult );
                piSrc += cChan;
                piDst += cChan;

                COMBINE_SIGNBIT_FAST                                                         
                cfResult = INT_FROM_COEF( MULT_BP2(*piSin++,*piCoef++) + COEF_FROM_INT(iResult) );
                ROUND_SATURATE_STORE( piDst, cfResult, SHRT_MIN, SHRT_MAX, iResult );
                piSrc += cChan;
                piDst += cChan;

                COMBINE_SIGNBIT_FAST                                                         
                cfResult = INT_FROM_COEF( MULT_BP2(*piSin++,*piCoef++) + COEF_FROM_INT(iResult) );
                ROUND_SATURATE_STORE( piDst, cfResult, SHRT_MIN, SHRT_MAX, iResult );
                piSrc += cChan;
                piDst += cChan;

                COMBINE_SIGNBIT_FAST                                                         
                cfResult = INT_FROM_COEF( MULT_BP2(*piSin++,*piCoef++) + COEF_FROM_INT(iResult) );
                ROUND_SATURATE_STORE( piDst, cfResult, SHRT_MIN, SHRT_MAX, iResult );
                piSrc += cChan;
                piDst += cChan;

                COMBINE_SIGNBIT_FAST                                                         
                cfResult = INT_FROM_COEF( MULT_BP2(*piSin++,*piCoef++) + COEF_FROM_INT(iResult) );
                ROUND_SATURATE_STORE( piDst, cfResult, SHRT_MIN, SHRT_MAX, iResult );
                piSrc += cChan;
                piDst += cChan;

                COMBINE_SIGNBIT_FAST                                                         
                cfResult = INT_FROM_COEF( MULT_BP2(*piSin++,*piCoef++) + COEF_FROM_INT(iResult) );
                ROUND_SATURATE_STORE( piDst, cfResult, SHRT_MIN, SHRT_MAX, iResult );
                piSrc += cChan;
                piDst += cChan;

                COMBINE_SIGNBIT_FAST                                                         
                cfResult = INT_FROM_COEF( MULT_BP2(*piSin++,*piCoef++) + COEF_FROM_INT(iResult) );
                ROUND_SATURATE_STORE( piDst, cfResult, SHRT_MIN, SHRT_MAX, iResult );
                piSrc += cChan;
                piDst += cChan;

                uiSignbitData = *piSrcSign++;                                              
            }
            uiSignbitCount = 16;                                                     
            if (iLoopBy1) return !WMA_OK;

/*            for (iLoopCnt = 0; iLoopCnt < iLoopBy1; iLoopCnt++, i++, (*pcSampleGet)++)    {

                COMBINE_SIGNBIT(iResult, *piSrc, piSrcSign, uiSignbitData,
                    uiSignbitCount);

                cfResult = INT_FROM_COEF( MULT_BP2(*piSin++,*piCoef++) + COEF_FROM_INT(iResult) );
                ROUND_SATURATE_STORE( piDst, cfResult, SHRT_MIN, SHRT_MAX, iResult );

                piSrc += cChan;
                piDst += cChan;
            }   */

        }
    }
    if (i < iCoefRecurQ2)  
    {
        iSegEnd = min (iCoefRecurQ2, iEnd);
        if ( i < iSegEnd )
        {
            Int iLoopBy16,iLoopBy1,iLoopCnt;
            iLoopBy16 = (iSegEnd - i) >> 4;
            iLoopBy1  = (iSegEnd - i) & 0xF;
            (*pcSampleGet) += (I16)(iLoopBy16<<4);
            i += (iLoopBy16<<4);
            for (iLoopCnt = 0;iLoopCnt < iLoopBy16;iLoopCnt++)    {
                uiSignbitData<<=16;

                COMBINE_SIGNBIT_FAST                                                         
                cfResult = INT_FROM_COEF( MULT_BP2(*piSin++,*--piCoef) + COEF_FROM_INT(iResult) );
                ROUND_SATURATE_STORE( piDst, cfResult, SHRT_MIN, SHRT_MAX, iResult );
                piSrc += cChan;
                piDst += cChan;

                COMBINE_SIGNBIT_FAST                                                         
                cfResult = INT_FROM_COEF( MULT_BP2(*piSin++,*--piCoef) + COEF_FROM_INT(iResult) );
                ROUND_SATURATE_STORE( piDst, cfResult, SHRT_MIN, SHRT_MAX, iResult );
                piSrc += cChan;
                piDst += cChan;

                COMBINE_SIGNBIT_FAST                                                         
                cfResult = INT_FROM_COEF( MULT_BP2(*piSin++,*--piCoef) + COEF_FROM_INT(iResult) );
                ROUND_SATURATE_STORE( piDst, cfResult, SHRT_MIN, SHRT_MAX, iResult );
                piSrc += cChan;
                piDst += cChan;

                COMBINE_SIGNBIT_FAST                                                         
                cfResult = INT_FROM_COEF( MULT_BP2(*piSin++,*--piCoef) + COEF_FROM_INT(iResult) );
                ROUND_SATURATE_STORE( piDst, cfResult, SHRT_MIN, SHRT_MAX, iResult );
                piSrc += cChan;
                piDst += cChan;

                COMBINE_SIGNBIT_FAST                                                         
                cfResult = INT_FROM_COEF( MULT_BP2(*piSin++,*--piCoef) + COEF_FROM_INT(iResult) );
                ROUND_SATURATE_STORE( piDst, cfResult, SHRT_MIN, SHRT_MAX, iResult );
                piSrc += cChan;
                piDst += cChan;

                COMBINE_SIGNBIT_FAST                                                         
                cfResult = INT_FROM_COEF( MULT_BP2(*piSin++,*--piCoef) + COEF_FROM_INT(iResult) );
                ROUND_SATURATE_STORE( piDst, cfResult, SHRT_MIN, SHRT_MAX, iResult );
                piSrc += cChan;
                piDst += cChan;

                COMBINE_SIGNBIT_FAST                                                         
                cfResult = INT_FROM_COEF( MULT_BP2(*piSin++,*--piCoef) + COEF_FROM_INT(iResult) );
                ROUND_SATURATE_STORE( piDst, cfResult, SHRT_MIN, SHRT_MAX, iResult );
                piSrc += cChan;
                piDst += cChan;

                COMBINE_SIGNBIT_FAST                                                         
                cfResult = INT_FROM_COEF( MULT_BP2(*piSin++,*--piCoef) + COEF_FROM_INT(iResult) );
                ROUND_SATURATE_STORE( piDst, cfResult, SHRT_MIN, SHRT_MAX, iResult );
                piSrc += cChan;
                piDst += cChan;

                COMBINE_SIGNBIT_FAST                                                         
                cfResult = INT_FROM_COEF( MULT_BP2(*piSin++,*--piCoef) + COEF_FROM_INT(iResult) );
                ROUND_SATURATE_STORE( piDst, cfResult, SHRT_MIN, SHRT_MAX, iResult );
                piSrc += cChan;
                piDst += cChan;

                COMBINE_SIGNBIT_FAST                                                         
                cfResult = INT_FROM_COEF( MULT_BP2(*piSin++,*--piCoef) + COEF_FROM_INT(iResult) );
                ROUND_SATURATE_STORE( piDst, cfResult, SHRT_MIN, SHRT_MAX, iResult );
                piSrc += cChan;
                piDst += cChan;

                COMBINE_SIGNBIT_FAST                                                         
                cfResult = INT_FROM_COEF( MULT_BP2(*piSin++,*--piCoef) + COEF_FROM_INT(iResult) );
                ROUND_SATURATE_STORE( piDst, cfResult, SHRT_MIN, SHRT_MAX, iResult );
                piSrc += cChan;
                piDst += cChan;

                COMBINE_SIGNBIT_FAST                                                         
                cfResult = INT_FROM_COEF( MULT_BP2(*piSin++,*--piCoef) + COEF_FROM_INT(iResult) );
                ROUND_SATURATE_STORE( piDst, cfResult, SHRT_MIN, SHRT_MAX, iResult );
                piSrc += cChan;
                piDst += cChan;

                COMBINE_SIGNBIT_FAST                                                         
                cfResult = INT_FROM_COEF( MULT_BP2(*piSin++,*--piCoef) + COEF_FROM_INT(iResult) );
                ROUND_SATURATE_STORE( piDst, cfResult, SHRT_MIN, SHRT_MAX, iResult );
                piSrc += cChan;
                piDst += cChan;

                COMBINE_SIGNBIT_FAST                                                         
                cfResult = INT_FROM_COEF( MULT_BP2(*piSin++,*--piCoef) + COEF_FROM_INT(iResult) );
                ROUND_SATURATE_STORE( piDst, cfResult, SHRT_MIN, SHRT_MAX, iResult );
                piSrc += cChan;
                piDst += cChan;

                COMBINE_SIGNBIT_FAST                                                         
                cfResult = INT_FROM_COEF( MULT_BP2(*piSin++,*--piCoef) + COEF_FROM_INT(iResult) );
                ROUND_SATURATE_STORE( piDst, cfResult, SHRT_MIN, SHRT_MAX, iResult );
                piSrc += cChan;
                piDst += cChan;

                COMBINE_SIGNBIT_FAST                                                         
                cfResult = INT_FROM_COEF( MULT_BP2(*piSin++,*--piCoef) + COEF_FROM_INT(iResult) );
                ROUND_SATURATE_STORE( piDst, cfResult, SHRT_MIN, SHRT_MAX, iResult );
                piSrc += cChan;
                piDst += cChan;

                uiSignbitData = *piSrcSign++;                                              
            }
            uiSignbitCount = 16;                                                     
            if (iLoopBy1) return !WMA_OK;
/*            for (iLoopCnt = 0; iLoopCnt < iLoopBy1; iLoopCnt++, i++,(*pcSampleGet)++)    {

                COMBINE_SIGNBIT(iResult, *piSrc, piSrcSign, uiSignbitData,
                    uiSignbitCount);

                cfResult = INT_FROM_COEF( MULT_BP2(*piSin++,*--piCoef) + COEF_FROM_INT(iResult) );
                ROUND_SATURATE_STORE( piDst, cfResult, SHRT_MIN, SHRT_MAX, iResult );

                piSrc += cChan;
                piDst += cChan;
            }  */
        }
    }
    if (i < iCoefRecurQ3) 
    {
        iSegEnd = min (iCoefRecurQ3, iEnd);
        for (; i < iSegEnd; i++,(*pcSampleGet)++)    {
            cfResult = INT_FROM_COEF( *--piCoef );
            ROUND_SATURATE_STORE( piDst, cfResult, SHRT_MIN, SHRT_MAX, iResult );
            piDst += cChan;
        }
    }

    SAVE_SIGNBIT_STATE(piSrcSign,uiSignbitData);
    if (pau->m_cChannel < 2 || ((pau->m_cChannel == 2) && (ppcinfo == &(pau->m_rgpcinfo[1]))))
        pau->m_piSinForRecon = piSin;

    ppcinfo->m_rgiCoefReconCurr = (Int*)piCoef;
    ppcinfo->m_iCurrGetPCM_SubFrame = (I16)i;
    ppcinfo->m_piPrevOutputCurr = piSrc;
#ifdef PROFILE
    FunctionProfileStop(&fp);
#endif
    return WMA_OK;
}


#if 0
//auReconStereo_X86 has been removed from build as the saturation code does not work with out the
//extra checking in ROUNDF_TO_S below which would cause it to be slow. I left it in the codebase
//as it serves as a good model for other reconStereo's for other platforms.

INLINE I16 FASTCALL ROUNDF_TO_S(float f) {
    I16 intval;
    if (f > 32767) f = 32767;
    if (f < -32767) f= -32767;
    _asm {
        fld         f
        fistp       word ptr [intval]
    }
    return intval;
}

WMARESULT auReconStereo_X86 (CAudioObject* pau, I16* piOutput, I16* pcSampleGet, Bool fForceTransformAll)
{
    Int overflow = 0;
    Float *piCoef2; 
    Float *piCoef;  
    Int i, iEnd, iSegEnd;
    I16 *piSrc, *piDst; 
    I32 iResult;
    Float cfResult;

    // get local copies of these values which are used frequently or repeatedly (helps optimization)
    Int cChan = pau->m_cChannel;
    Int cSubFrameSampleHalf = pau->m_cSubFrameSampleHalfAdjusted;
    Int cSubFrameSampleQuad = pau->m_cSubFrameSampleQuadAdjusted;
    Int iCoefRecurQ2 = pau->m_iCoefRecurQ2;
    Int iCoefRecurQ3 = pau->m_iCoefRecurQ3;
    float *piSin = pau->m_piSinForRecon;

    U16    *piSrcSign;
    I32     uiSignbitData;
    U32     uiSignbitCount;
    U16    *piSrcSign2;
    I32     uiSignbitData2;
    U32     uiSignbitCount2;

#ifdef PREVOUTPUT_16BITS
    assert(0);
#endif// PREVOUTPUT_16BITS

#ifdef PROFILE
    FunctionProfile fp;
    FunctionProfileStart(&fp,RECON_MONO_PROFILE);
#endif

    //persistent states
    i = pau->m_rgpcinfo[0].m_iCurrGetPCM_SubFrame;       //current position in a frame
    assert(i==pau->m_rgpcinfo[1].m_iCurrGetPCM_SubFrame);
    piCoef = (float*)pau->m_rgpcinfo[0].m_rgiCoefReconCurr; 
    piCoef2 = (float*)(pau->m_rgpcinfo[1].m_rgiCoefReconCurr); 

    piSrc = pau->m_rgpcinfo[0].m_piPrevOutputCurr;
    assert((piSrc+1) == pau->m_rgpcinfo[1].m_piPrevOutputCurr);
    
    //eventually we'll use piOutput directly
    piDst = piOutput;

    iEnd = i + *pcSampleGet;
    *pcSampleGet = 0;

    CALC_SIGN_OFFSETS(pau->m_rgpcinfo[0].m_piPrevOutput,(piSrc+0), pau->m_rgpcinfo[0].m_piPrevOutputSign, piSrcSign, 
        uiSignbitData, uiSignbitCount, cChan)

    CALC_SIGN_OFFSETS(pau->m_rgpcinfo[1].m_piPrevOutput,(piSrc+1), pau->m_rgpcinfo[1].m_piPrevOutputSign, piSrcSign2, 
        uiSignbitData2, uiSignbitCount2, cChan)

    ASSERT_SIGNBIT_POINTER(piSrcSign);

    if (i < cSubFrameSampleQuad) 
    {
        iSegEnd = min (cSubFrameSampleQuad, iEnd);
        if ( i < iSegEnd )
        {
            Int iLoopBy16,iLoopBy1,iLoopCnt;
            iLoopBy16 = (iSegEnd - i) >> 4;
            iLoopBy1  = (iSegEnd - i) & 0xF;
            (*pcSampleGet) += (I16)(iLoopBy16<<4);
            i += (iLoopBy16<<4);

            for (iLoopCnt = 0; iLoopCnt < iLoopBy16; iLoopCnt++)    {
                uiSignbitData<<=16;
                uiSignbitData2<<=16;

#               define RECONSTRUCT2                                                 \
                iResult = (((uiSignbitData)>>15) & 0xFFFF0000) | (U16)*piSrc;       \
                uiSignbitData <<= 1;                                                \
                cfResult = *piSin * *piCoef + iResult;                              \
                if ((*piDst = ROUNDF_TO_S(cfResult)) == 0x8000) overflow=1;         \
                iResult = (((uiSignbitData2)>>15) & 0xFFFF0000) | (U16)piSrc[1];    \
                uiSignbitData2 <<= 1;                                               \
                cfResult = *piSin * *piCoef2 + iResult;                             \
                if ((piDst[1] = ROUNDF_TO_S(cfResult)) == 0x8000) overflow=1;       \
                piSin++;                                                            \
                piCoef++;                                                           \
                piCoef2++;                                                          \
                piSrc += cChan;                                                     \
                piDst += cChan;     

                RECONSTRUCT2
                RECONSTRUCT2
                RECONSTRUCT2
                RECONSTRUCT2
                RECONSTRUCT2
                RECONSTRUCT2
                RECONSTRUCT2
                RECONSTRUCT2
                RECONSTRUCT2
                RECONSTRUCT2
                RECONSTRUCT2
                RECONSTRUCT2
                RECONSTRUCT2
                RECONSTRUCT2
                RECONSTRUCT2
                RECONSTRUCT2

#               undef RECONSTRUCT2          

                uiSignbitData = *piSrcSign++;                                              
                uiSignbitData2 = *piSrcSign2++;                                              
            }
            uiSignbitCount = 16;                                                     
        }
    }

    if (i < iCoefRecurQ2)  
    {
        iSegEnd = min (iCoefRecurQ2, iEnd);
        if ( i < iSegEnd )
        {
            U16 *piDstCopy = piDst;
            Int iLoopBy16,iLoopBy1,iLoopCnt;
            iLoopBy16 = (iSegEnd - i) >> 4;
            iLoopBy1  = (iSegEnd - i) & 0xF;
            for (iLoopCnt = 0;iLoopCnt < iLoopBy16;iLoopCnt++, i+=16,(*pcSampleGet)+=16)    {
                uiSignbitData<<=16;
                uiSignbitData2<<=16;

#               define RECONSTRUCT2                                                   \
                piCoef--;                                                             \
                piCoef2--;                                                            \
                iResult = (((uiSignbitData)>>15) & 0xFFFF0000) | (U16)*piSrc;         \
                uiSignbitData <<= 1;                                                  \
                cfResult = *piSin * *piCoef + iResult;                                \
                if ((*piDst = ROUNDF_TO_S(cfResult))==0x8000) overflow=1;             \
                iResult = (((uiSignbitData2)>>15) & 0xFFFF0000) | (U16)piSrc[1];      \
                uiSignbitData2 <<= 1;                                                 \
                cfResult = *piSin * *piCoef2 + iResult;                               \
                if ((piDst[1] = ROUNDF_TO_S(cfResult))==0x8000) overflow=1;           \
                piSin++;                                                              \
                piSrc += cChan;                                                       \
                piDst += cChan;     

                RECONSTRUCT2
                RECONSTRUCT2
                RECONSTRUCT2
                RECONSTRUCT2
                RECONSTRUCT2
                RECONSTRUCT2
                RECONSTRUCT2
                RECONSTRUCT2
                RECONSTRUCT2
                RECONSTRUCT2
                RECONSTRUCT2
                RECONSTRUCT2
                RECONSTRUCT2
                RECONSTRUCT2
                RECONSTRUCT2
                RECONSTRUCT2
#               undef RECONSTRUCT2          

                uiSignbitData = *piSrcSign++;                                              
                uiSignbitData2 = *piSrcSign2++;                                              
            }
            uiSignbitCount = 16;                                                     
            uiSignbitCount2 = 16;                                                     
        }
    }
    if (i < iCoefRecurQ3) 
    {
        iSegEnd = min (iCoefRecurQ3, iEnd);
        for (; i < iSegEnd; i++,(*pcSampleGet)++)    {
            cfResult = INT_FROM_COEF( *--piCoef );
            ROUND_SATURATE_STORE( piDst, cfResult, SHRT_MIN, SHRT_MAX, iResult );
            cfResult = INT_FROM_COEF( *--piCoef2 );
            ROUND_SATURATE_STORE( (piDst+1), cfResult, SHRT_MIN, SHRT_MAX, iResult );
            piDst += cChan;
        }
    }

    if (overflow){
        Int iChannel;
        for (iChannel = 0; iChannel < pau->m_cChannel; iChannel++)
        {
            //hr = 
            auReconMono_X86 (pau, 
                              pau->m_rgpcinfo + iChannel, 
                              piOutput + iChannel,  
                              (I16*)pcSampleGet,
                              fForceTransformAll);
        }
    } else {
        SAVE_SIGNBIT_STATE(piSrcSign,uiSignbitData);
        pau->m_rgpcinfo[0].m_rgiCoefReconCurr = (Int*)piCoef;
        pau->m_rgpcinfo[0].m_iCurrGetPCM_SubFrame = (I16)i;
        pau->m_rgpcinfo[0].m_piPrevOutputCurr = piSrc;


        SAVE_SIGNBIT_STATE(piSrcSign2,uiSignbitData2);
        pau->m_rgpcinfo[1].m_rgiCoefReconCurr = (Int*)piCoef2;
        pau->m_rgpcinfo[1].m_iCurrGetPCM_SubFrame = (I16)i;
        pau->m_rgpcinfo[1].m_piPrevOutputCurr = piSrc+1;

        pau->m_piSinForRecon = piSin;
    }         
    return WMA_OK;
}
#endif //if 0

////////////////////////////////////////////////////////////////////////////////////////
// Recon Stereo MMX
// This function improves on reconMono_X86 by doing both channels at once and using MMX
// to do the calculations 4 at a time for the integer part and doing the floating point part
// in a seperate loop. 
// If a non divisable by 16 frame is encounterd the function turns itself off and 
// calls the safer function 
////////////////////////////////////////////////////////////////////////////////////////

WMARESULT auReconStereo_MMX (CAudioObject* pau, I16* piOutput, I16* pcSampleGet, Bool fForceTransformAll)
{
    static const __int64 x0000FFFF0000FFFF = 0x0000FFFF0000FFFF;
    static const __int64 x8000800080008000 = 0x8000800080008000;
    Int tempBuf[2048];
    Int *tBuf;

    Float *piCoef2; 
    Float *piCoef;  
    Int i, iEnd, iSegEnd;
    I16 *piSrc, *piDst; 
    I32 iResult;
    Float cfResult;

    // get local copies of these values which are used frequently or repeatedly (helps optimization)
    Int cChan = pau->m_cChannel;
    Int cSubFrameSampleHalf = pau->m_cSubFrameSampleHalfAdjusted;
    Int cSubFrameSampleQuad = pau->m_cSubFrameSampleQuadAdjusted;
    Int iCoefRecurQ2 = pau->m_iCoefRecurQ2;
    Int iCoefRecurQ3 = pau->m_iCoefRecurQ3;
    float *piSin = pau->m_piSinForRecon;

    U16    *piSrcSign;
    I32     uiSignbitData;
    U32     uiSignbitCount;
    U16    *piSrcSign2;
    I32     uiSignbitData2;
    U32     uiSignbitCount2;

#ifdef PREVOUTPUT_16BITS
    assert(0);
#endif// PREVOUTPUT_16BITS

#ifdef PROFILE
    FunctionProfile fp;
    FunctionProfileStart(&fp,RECON_MONO_PROFILE);
#endif

    //persistent states
    i = pau->m_rgpcinfo[0].m_iCurrGetPCM_SubFrame;       //current position in a frame
    assert(i==pau->m_rgpcinfo[1].m_iCurrGetPCM_SubFrame);
    piCoef = (float*)pau->m_rgpcinfo[0].m_rgiCoefReconCurr; 
    piCoef2 = (float*)(pau->m_rgpcinfo[1].m_rgiCoefReconCurr); 

    piSrc = pau->m_rgpcinfo[0].m_piPrevOutputCurr;
    assert((piSrc+1) == pau->m_rgpcinfo[1].m_piPrevOutputCurr);
    
    //eventually we'll use piOutput directly
    piDst = piOutput;

    iEnd = i + *pcSampleGet;
    *pcSampleGet = 0;

    CALC_SIGN_OFFSETS(pau->m_rgpcinfo[0].m_piPrevOutput,(piSrc+0), pau->m_rgpcinfo[0].m_piPrevOutputSign, piSrcSign, 
        uiSignbitData, uiSignbitCount, cChan)

    CALC_SIGN_OFFSETS(pau->m_rgpcinfo[1].m_piPrevOutput,(piSrc+1), pau->m_rgpcinfo[1].m_piPrevOutputSign, piSrcSign2, 
        uiSignbitData2, uiSignbitCount2, cChan)

    ASSERT_SIGNBIT_POINTER(piSrcSign);

    if (i < cSubFrameSampleQuad) 
    {
        iSegEnd = min (cSubFrameSampleQuad, iEnd);
        if ( i < iSegEnd )
        {
            Int iLoopBy16,iLoopBy1;//,iLoopCnt;
            iLoopBy16 = (iSegEnd - i) >> 4;
            iLoopBy1  = (iSegEnd - i) & 0xF;
            (*pcSampleGet) += (I16)(iLoopBy16<<4);
            i += (iLoopBy16<<4);
            assert(iLoopBy1==0);
            tBuf = tempBuf;

            _asm{
            
            mov         esi,piSin
            mov         ecx,piCoef
            mov         edx,piCoef2
            lea         ebx,tempBuf
            mov         eax,iLoopBy16
            shl         eax,4
            Loop1F:

                fld         dword Ptr [esi]         //Load Sin value
                add         esi,4                   //piSin++
                fld         dword Ptr [ecx]         //Load Coefficent from channel 1
                fmul        st(0),st(1)             //Multiply it with Sin value
                add         ecx,4                   //piCoef++
                fld         dword Ptr [edx]         //Load Coefficent from channel 2
                fmulp       st(2),st(0)             //Multiply it with Sin value
                fistp       dword Ptr [ebx]         //Store as 32bit int
                add         edx,4                   //piCoef2++
                fistp       dword Ptr [ebx+4]       //Store as 32bit int
                add         ebx,8                   //bump temp buffer ptr

            dec         eax
            jnz         Loop1F
            mov         piSin,esi
            mov         piCoef,ecx
            mov         piCoef2,edx
   

            mov         ebx,piSrcSign
            mov         ecx,piSrcSign2
            mov         esi,piSrc
            mov         edx,tBuf 
            mov         edi,piDst

            movd        mm0,uiSignbitData    
            movd        mm1,uiSignbitData2

            mov         eax,iLoopBy16
            Loop1M:    
                    
                punpcklwd   mm0,mm1
                    
#               define RECONSTRUCT4(x) _asm {                                            \
_asm            movq        mm1,mm0                                                      \
_asm            psraw       mm1,15             /*sine extend sine bit data*/             \
_asm            movd        mm2,[esi+(x*8)]    /*load 2 16bit data elements*/            \
_asm            punpcklwd   mm2,mm1            /*merge with sign bit for 2 32bit values*/\
_asm            movq        mm1,[edx+(x*16)]   /*get 2 precalculated coef * sin */       \
_asm            paddd       mm1,mm2            /*add the 2 vectors*/                     \
_asm            pslld       mm0,1              /*shift sine bit data for next time*/     \
_asm            movq        mm3,mm0            /*repeat process for 2 more elements*/    \
_asm            psraw       mm3,15                                                       \
_asm            movd        mm4,[esi+(x*8)+4]                                            \
_asm            punpcklwd   mm4,mm3                                                      \
_asm            movq        mm3,[edx+(x*16)+8]                                           \
_asm            paddd       mm3,mm4                                                      \
_asm            packssdw    mm1,mm3           /*merge and saturate 2 sets of 2*/         \
_asm            movq        [edi+(x*8)],mm1   /*store 4 reconstructed samples*/          \
_asm            pslld       mm0,1             /*shift sine bit data for next time*/      }

                RECONSTRUCT4(0)
                RECONSTRUCT4(1)
                RECONSTRUCT4(2)
                RECONSTRUCT4(3)
                RECONSTRUCT4(4)
                RECONSTRUCT4(5)
                RECONSTRUCT4(6)
                RECONSTRUCT4(7)
                    
                add         esi,32*2
                add         edx,32*4
                add         edi,32*2

                movd        mm0,[ebx]
                movd        mm1,[ecx]

                add         ebx,2
                add         ecx,2
                

            dec         eax
            jnz         Loop1M

            mov         piSrc,esi
            mov         tBuf,edx
            mov         piDst,edi

            movd        uiSignbitData,mm0
            movd        uiSignbitData2,mm1
            mov         piSrcSign,ebx
            mov         piSrcSign2,ecx

            emms
            }
            uiSignbitCount  = 16;
            uiSignbitCount2 = 16;
            if (iLoopBy1) {
                pau->aupfnReconstruct = auReconstruct;
                return auReconstruct(pau,piOutput,pcSampleGet,fForceTransformAll); 
            }
/*            for (iLoopCnt = 0; iLoopCnt < iLoopBy1; iLoopCnt++, i++, (*pcSampleGet)++)    {
                //Channel 1
                COMBINE_SIGNBIT(iResult, *piSrc, piSrcSign, uiSignbitData,
                    uiSignbitCount);
                cfResult = INT_FROM_COEF( MULT_BP2(*piSin,*piCoef++) + COEF_FROM_INT(iResult) );
                ROUND_SATURATE_STORE( piDst, cfResult, SHRT_MIN, SHRT_MAX, iResult );
                piSrc++;
                piDst++;

                //Channel 2
                COMBINE_SIGNBIT(iResult, *piSrc, piSrcSign, uiSignbitData2,
                    uiSignbitCount2);
                cfResult = INT_FROM_COEF( MULT_BP2(*piSin++,*piCoef2++) + COEF_FROM_INT(iResult) );
                ROUND_SATURATE_STORE( piDst, cfResult, SHRT_MIN, SHRT_MAX, iResult );
                piSrc++;
                piDst++;
            }  */
        }
    }

    if (i < iCoefRecurQ2)  
    {
        iSegEnd = min (iCoefRecurQ2, iEnd);
        if ( i < iSegEnd )
        {
            Int iLoopBy16,iLoopBy1;//,iLoopCnt;
            iLoopBy16 = (iSegEnd - i) >> 4;
            iLoopBy1  = (iSegEnd - i) & 0xF;
            assert(iLoopBy1==0);
            (*pcSampleGet) += (I16)(iLoopBy16<<4);
            i += (iLoopBy16<<4);
            tBuf = tempBuf;
            _asm{
            mov         esi,piSin
            mov         ecx,piCoef
            mov         edx,piCoef2
            mov         ebx,tBuf
            mov         eax,iLoopBy16
            shl         eax,4
            Loop2F:

                fld         dword Ptr [esi]         //Load Sin value
                add         esi,4                   //piSin++
                fld         dword Ptr [ecx-4]       //Load Coefficent from channel 1
                fmul        st(0),st(1)             //Multiply it with Sin value
                sub         ecx,4                   //piCoef--
                fld         dword Ptr [edx-4]       //Load Coefficent from channel 2
                fmulp       st(2),st(0)             //Multiply it with Sin value
                fistp       dword Ptr [ebx]         //Store as 32bit int
                sub         edx,4                   //piCoef--
                fistp       dword Ptr [ebx+4]       //Store as 32bit int
                add         ebx,8                   //bump temp buffer ptr

            dec         eax
            jnz         Loop2F
            mov         piSin,esi
            mov         piCoef,ecx
            mov         piCoef2,edx
                
            mov         ebx,piSrcSign
            mov         ecx,piSrcSign2
            mov         esi,piSrc
            mov         edx,tBuf 
            mov         edi,piDst

            movd        mm0,uiSignbitData    
            movd        mm1,uiSignbitData2

            mov         eax,iLoopBy16
            Loop2M:    
                    
                punpcklwd   mm0,mm1
                    
                RECONSTRUCT4(0)
                RECONSTRUCT4(1)
                RECONSTRUCT4(2)
                RECONSTRUCT4(3)
                RECONSTRUCT4(4)
                RECONSTRUCT4(5)
                RECONSTRUCT4(6)
                RECONSTRUCT4(7)
                    
                add         esi,32*2
                add         edx,32*4
                add         edi,32*2

                movd        mm0,[ebx]
                movd        mm1,[ecx]

                add         ebx,2
                add         ecx,2
                

            dec         eax
            jnz         Loop2M

            mov         piSrc,esi
            mov         tBuf,edx
            mov         piDst,edi

            movd        uiSignbitData,mm0
            movd        uiSignbitData2,mm1
            mov         piSrcSign,ebx
            mov         piSrcSign2,ecx

            emms
#           undef RECONSTRUCT4
            }
            uiSignbitCount  = 16;
            uiSignbitCount2 = 16;
            if (iLoopBy1) {
                pau->aupfnReconstruct = auReconstruct;
                return auReconstruct(pau,piOutput,pcSampleGet,fForceTransformAll); 
            }

/*            for (iLoopCnt = 0; iLoopCnt < iLoopBy1; iLoopCnt++, i++, (*pcSampleGet)++)    {
                //Channel 1
                COMBINE_SIGNBIT(iResult, *piSrc, piSrcSign, uiSignbitData,
                    uiSignbitCount);
                cfResult = INT_FROM_COEF( MULT_BP2(*piSin,*--piCoef) + COEF_FROM_INT(iResult) );
                ROUND_SATURATE_STORE( piDst, cfResult, SHRT_MIN, SHRT_MAX, iResult );
                piSrc++;
                piDst++;

                //Channel 2
                COMBINE_SIGNBIT(iResult, *piSrc, piSrcSign, uiSignbitData2,
                    uiSignbitCount2);
                cfResult = INT_FROM_COEF( MULT_BP2(*piSin++,*--piCoef2) + COEF_FROM_INT(iResult) );
                ROUND_SATURATE_STORE( piDst, cfResult, SHRT_MIN, SHRT_MAX, iResult );
                piSrc++;
                piDst++;
            }   */
        }
    }
    if (i < iCoefRecurQ3) 
    {
        iSegEnd = min (iCoefRecurQ3, iEnd);

        for (; i < iSegEnd; i++,(*pcSampleGet)++)    {
            cfResult = INT_FROM_COEF( *--piCoef );
            ROUND_SATURATE_STORE( piDst, cfResult, SHRT_MIN, SHRT_MAX, iResult );
            cfResult = INT_FROM_COEF( *--piCoef2 );
            ROUND_SATURATE_STORE( (piDst+1), cfResult, SHRT_MIN, SHRT_MAX, iResult );
            piDst += cChan;
        }
    }

    SAVE_SIGNBIT_STATE(piSrcSign,uiSignbitData);
    pau->m_rgpcinfo[0].m_rgiCoefReconCurr = (Int*)piCoef;
    pau->m_rgpcinfo[0].m_iCurrGetPCM_SubFrame = (I16)i;
    pau->m_rgpcinfo[0].m_piPrevOutputCurr = piSrc;


    SAVE_SIGNBIT_STATE(piSrcSign2,uiSignbitData2);
    pau->m_rgpcinfo[1].m_rgiCoefReconCurr = (Int*)piCoef2;
    pau->m_rgpcinfo[1].m_iCurrGetPCM_SubFrame = (I16)i;//= (I16)i;
    pau->m_rgpcinfo[1].m_piPrevOutputCurr = piSrc+1;

    pau->m_piSinForRecon = piSin;

#ifdef PROFILE
    FunctionProfileStop(&fp);
#endif
    return WMA_OK;
}

/////////////////////////////////////////////////////////////////////////////////////////////
// Recon Stereo SIMD FP
// This function improves on auReconStereo_MMX by doing the floating point using intels
// vector floating point instructions and removing the floating point loop and intermixing
// it with the int/MMX loop. It is otherwize similar to auReconStereo_MMX
//////////////////////////////////////////////////////////////////////////////////////////////

WMARESULT auReconStereo_SIMDFP (CAudioObject* pau, I16* piOutput, I16* pcSampleGet, Bool fForceTransformAll)
{
    Int overflow = 0;
    Float *piCoef2; 
    Float *piCoef;  
    Int i, iEnd, iSegEnd;
    I16 *piSrc, *piDst; 
    I32 iResult;

    // get local copies of these values which are used frequently or repeatedly (helps optimization)
    Int cChan = pau->m_cChannel;
    Int cSubFrameSampleHalf = pau->m_cSubFrameSampleHalfAdjusted;
    Int cSubFrameSampleQuad = pau->m_cSubFrameSampleQuadAdjusted;
    Int iCoefRecurQ2 = pau->m_iCoefRecurQ2;
    Int iCoefRecurQ3 = pau->m_iCoefRecurQ3;
    float *piSin = pau->m_piSinForRecon;

    U16    *piSrcSign;
    I32     uiSignbitData;
    U32     uiSignbitCount;
    U16    *piSrcSign2;
    I32     uiSignbitData2;
    U32     uiSignbitCount2;

#ifdef PREVOUTPUT_16BITS
    assert(0);
#endif// PREVOUTPUT_16BITS

#ifdef PROFILE
    FunctionProfile fp;
    FunctionProfileStart(&fp,RECON_MONO_PROFILE);
#endif

    //persistent states
    i = pau->m_rgpcinfo[0].m_iCurrGetPCM_SubFrame;       //current position in a frame
    assert(i==pau->m_rgpcinfo[1].m_iCurrGetPCM_SubFrame);
    piCoef = (float*)pau->m_rgpcinfo[0].m_rgiCoefReconCurr; 
    piCoef2 = (float*)(pau->m_rgpcinfo[1].m_rgiCoefReconCurr); 

    piSrc = pau->m_rgpcinfo[0].m_piPrevOutputCurr;
    assert((piSrc+1) == pau->m_rgpcinfo[1].m_piPrevOutputCurr);
    
    //eventually we'll use piOutput directly
    piDst = piOutput;

    iEnd = i + *pcSampleGet;
    *pcSampleGet = 0;

    CALC_SIGN_OFFSETS(pau->m_rgpcinfo[0].m_piPrevOutput,(piSrc+0), pau->m_rgpcinfo[0].m_piPrevOutputSign, piSrcSign, 
        uiSignbitData, uiSignbitCount, cChan)

    CALC_SIGN_OFFSETS(pau->m_rgpcinfo[1].m_piPrevOutput,(piSrc+1), pau->m_rgpcinfo[1].m_piPrevOutputSign, piSrcSign2, 
        uiSignbitData2, uiSignbitCount2, cChan)

    ASSERT_SIGNBIT_POINTER(piSrcSign);

    if (i < cSubFrameSampleQuad) 
    {
        iSegEnd = min (cSubFrameSampleQuad, iEnd);
        if ( i < iSegEnd )
        {
            Int iLoopBy16,iLoopBy1;
            iLoopBy16 = (iSegEnd - i) >> 4;
            iLoopBy1  = (iSegEnd - i) & 0xF;
            (*pcSampleGet) += (I16)(iLoopBy16<<4);
            i += (iLoopBy16<<4);

            _asm {
            mov         ebx,piSin
            mov         ecx,piCoef
            mov         edx,piCoef2
            mov         esi,piSrc
            mov         edi,piDst
            
            movd        mm0,uiSignbitData    
            movd        mm1,uiSignbitData2

            mov         eax,iLoopBy16
            Loop1:

                punpcklwd   mm0,mm1
                                           //Note:The indentation of these comments tries
                                           //     to show logical paths since the instructions 
                                           //     have been scheduled out of logical paths

#define RECONSTRUCT8(x) _asm {                                                                                           \
_asm            movups      xmm3_ebx          /*Load 4 Sin values from table*/                                           \
_asm            movq        mm5,mm0               /*copy sign bit data*/                                                 \
_asm            add         ebx,4*4       /*Bump ptr*/                                                                   \
_asm            movaps      xmm0_xmm3         /*copy Sin values*/                                                        \
_asm            psraw       mm5,15                /*sine extend sine bit data*/                                          \
_asm            shufps      (xmm0_xmm3,0x50)  /*broadcast 1st and 2nd Sin values (a=a,b=a,c=b,d=b) */                    \
_asm            movd        mm2,[esi+(x*16)]      /*load 2 16bit data elements from piSrc*/                              \
_asm            movups      xmm4_ecx          /*Load Coefficents for channel 1*/                                         \
_asm            add         ecx,4*4       /*Bump ptr*/                                                                   \
_asm            punpcklwd   mm2,mm5               /*interleave src with sign bit for 2 32bit values*/                    \
_asm            movaps      xmm1_xmm4         /*make a copy of coefficents for channel 1*/                               \
_asm            pslld       mm0,1                 /*shift sine bit data for next 2*/                                     \
_asm            movups      xmm2_edx          /*Load Coefficents for channel 2*/                                         \
_asm            add         edx,4*4       /*Bump ptr*/                                                                   \
_asm            movq        mm6,mm0               /*copy sign bit data*/                                                 \
_asm            pslld       mm0,1                 /*shift sine bit data for next 2*/                                     \
_asm            unpcklps    xmm1_xmm2         /*Interleve first 2 Coefficents of channel 1 & 2*/                         \
_asm            psraw       mm6,15                /*sine extend sine bit data*/                                          \
_asm            mulps       xmm0_xmm1         /*Multiply coefficents with Sin values*/                                   \
_asm            movd        mm4,[esi+(x*16)+4]    /*load next 2 16bit data elements from piSrc*/                         \
_asm            cvtps2pi    mm1_xmm0          /*convert 2 lower multiply results to rounded integer values*/             \
_asm            punpcklwd   mm4,mm6               /*interleave src with sign bit for 2 32bit values*/                    \
_asm            shufps      (xmm0_xmm0,0xE)   /*move high elements in to low (a=c,b=d,c=a,d=a)*/                         \
_asm            movq        mm7,mm0                   /*copy sign bit data*/                                             \
_asm            pslld       mm0,1                     /*shift sine bit data for next 2*/                                 \
_asm            cvtps2pi    mm3_xmm0          /*convert 2 multiplyed results to rounded integer values*/                 \
_asm            psraw       mm7,15                    /*sine extend sine bit data*/                                      \
_asm            movaps      xmm0_xmm3                      /*copy Sin values*/                                           \
_asm            paddd       mm1,mm2           /*add the 2 vectors*/                                                      \
_asm            paddd       mm3,mm4           /*add the 2 other vectors*/                                                \
_asm            shufps      (xmm0_xmm3,0xFA)               /*broadcast 3rd and 4th Sin Values (a=c,b=c,c=d,d=d)*/        \
_asm            packssdw    mm1,mm3           /*merge and saturate vectors*/                                             \
_asm            movq        mm5,mm0                   /*copy sign bit data*/                                             \
_asm            movaps      xmm1_xmm4                      /*make a copy of coefficents for channel 1*/                  \
_asm            movq        [edi+(x*16)],mm1  /*store 4 reconstructed samples*/                                          \
_asm            unpckhps    xmm1_xmm2                      /*Interleve last 2 Coefficents of channel 1 & 2*/             \
_asm            movd        mm2,[esi+(x*16)+8]        /*load next 2 16bit data elements from piSrc*/                     \
_asm            pslld       mm0,1                     /*shift sine bit data for next 2*/                                 \
_asm            mulps       xmm0_xmm1                      /*Multiply coefficents with Sin values*/                      \
_asm            movd        mm4,[esi+(x*16)+12]       /*load next 2 16bit data elements from piSrc*/                     \
_asm            psraw       mm5,15                    /*sine extend sine bit data*/                                      \
_asm            cvtps2pi    mm1_xmm0                       /*convert 2 lower multiply results to rounded integer values*/\
_asm            punpcklwd   mm2,mm7                   /*merge with sign bit for 2 32bit values*/                         \
_asm            shufps      (xmm0_xmm0,0xE)                /*move high elements in to low (a=c,b=d,c=a,d=a)*/            \
_asm            punpcklwd   mm4,mm5                   /*interleave src with sign bit for 2 32bit values*/                \
_asm            paddd       mm1,mm2                        /*add the 2 vectors*/                                         \
_asm            cvtps2pi    mm3_xmm0                       /*convert 2 multiply results to rounded integer values*/      \
_asm            paddd       mm3,mm4                        /*add the 2 other vectors*/                                   \
_asm            packssdw    mm1,mm3                        /*merge and saturate 2 sets of 2*/                            \
_asm            movq        [edi+(x*16)+8],mm1             /*store 4 reconstructed samples*/                             }

                RECONSTRUCT8(0)
                RECONSTRUCT8(1)
                RECONSTRUCT8(2)
                RECONSTRUCT8(3)
                
                add         esi,2*32
                add         edi,2*32


                mov         iResult,ebx

                mov         ebx,piSrcSign  //uiSignbitData = *piSrcSign++;
                movd        mm0,[ebx]
                pslld       mm0,16
                psrld       mm0,16
                add         ebx,2
                mov         piSrcSign,ebx

                mov         ebx,piSrcSign2 //uiSignbitData2 = *piSrcSign2++;
                movd        mm1,[ebx]
                pslld       mm1,16
                psrld       mm1,16
                add         ebx,2
                mov         piSrcSign2,ebx

                mov         ebx,iResult
 
            dec         eax
            jnz         Loop1

            mov         piSrc,esi
            mov         piDst,edi
            mov         piSin,ebx
            mov         piCoef,ecx
            mov         piCoef2,edx
            movd        uiSignbitData,mm0
            movd        uiSignbitData2,mm1
#           undef RECONSTRUCT8
            }
            uiSignbitCount = 16;                                                     
            uiSignbitCount2 = 16;                                                     
            if (iLoopBy1) {
                pau->aupfnReconstruct = auReconstruct;
                return auReconstruct(pau,piOutput,pcSampleGet,fForceTransformAll); 
            }
        }
    }

    if (i < iCoefRecurQ2)  
    {
        iSegEnd = min (iCoefRecurQ2, iEnd);
        if ( i < iSegEnd )
        {
            U16 *piDstCopy = piDst;
            Int iLoopBy16,iLoopBy1;
            iLoopBy16 = (iSegEnd - i) >> 4;
            iLoopBy1  = (iSegEnd - i) & 0xF;
            (*pcSampleGet) += (I16)(iLoopBy16<<4);
            i += (iLoopBy16<<4);

            _asm {
            mov         ebx,piSin
            mov         ecx,piCoef
            mov         edx,piCoef2
            mov         esi,piSrc
            mov         edi,piDst
            
            movd        mm0,uiSignbitData    
            movd        mm1,uiSignbitData2

            mov         eax,iLoopBy16
            Loop2:

                punpcklwd   mm0,mm1

#define RECONSTRUCT8(x) _asm {                                                                                           \
_asm            movups      xmm3_ebx          /*Load 4 Sin values from table*/                                           \
_asm            movq        mm5,mm0               /*copy sign bit data*/                                                 \
_asm            add         ebx,4*4       /*Bump ptr*/                                                                   \
_asm            movaps      xmm0_xmm3         /*copy Sin values*/                                                        \
_asm            psraw       mm5,15                /*sine extend sine bit data*/                                          \
_asm            shufps      (xmm0_xmm3,0x50)  /*broadcast 1st and 2nd Sin values (a=a,b=a,c=b,d=b) */                    \
_asm            movd        mm2,[esi+(x*16)]      /*load 2 16bit data elements from piSrc*/                              \
_asm            sub         ecx,4*4       /*Bump ptr*/                                                                   \
_asm            movups      xmm4_ecx          /*Load Coefficents for channel 1*/                                         \
_asm            shufps      (xmm4_xmm4,0x1B)                                                                             \
_asm            punpcklwd   mm2,mm5               /*interleave src with sign bit for 2 32bit values*/                    \
_asm            movaps      xmm1_xmm4         /*make a copy of coefficents for channel 1*/                               \
_asm            pslld       mm0,1                 /*shift sine bit data for next 2*/                                     \
_asm            sub         edx,4*4       /*Bump ptr*/                                                                   \
_asm            movups      xmm2_edx          /*Load Coefficents for channel 2*/                                         \
_asm            shufps      (xmm2_xmm2,0x1B)                                                                             \
_asm            movq        mm6,mm0               /*copy sign bit data*/                                                 \
_asm            pslld       mm0,1                 /*shift sine bit data for next 2*/                                     \
_asm            unpcklps    xmm1_xmm2         /*Interleve first 2 Coefficents of channel 1 & 2*/                         \
_asm            psraw       mm6,15                /*sine extend sine bit data*/                                          \
_asm            mulps       xmm0_xmm1         /*Multiply coefficents with Sin values*/                                   \
_asm            movd        mm4,[esi+(x*16)+4]    /*load next 2 16bit data elements from piSrc*/                         \
_asm            cvtps2pi    mm1_xmm0          /*convert 2 lower multiply results to rounded integer values*/             \
_asm            punpcklwd   mm4,mm6               /*interleave src with sign bit for 2 32bit values*/                    \
_asm            shufps      (xmm0_xmm0,0xE)   /*move high elements in to low (a=c,b=d,c=a,d=a)*/                         \
_asm            movq        mm7,mm0                   /*copy sign bit data*/                                             \
_asm            pslld       mm0,1                     /*shift sine bit data for next 2*/                                 \
_asm            cvtps2pi    mm3_xmm0          /*convert 2 multiplyed results to rounded integer values*/                 \
_asm            psraw       mm7,15                    /*sine extend sine bit data*/                                      \
_asm            movaps      xmm0_xmm3                      /*copy Sin values*/                                           \
_asm            paddd       mm1,mm2           /*add the 2 vectors*/                                                      \
_asm            paddd       mm3,mm4           /*add the 2 other vectors*/                                                \
_asm            shufps      (xmm0_xmm3,0xFA)               /*broadcast 3rd and 4th Sin Values (a=c,b=c,c=d,d=d)*/        \
_asm            packssdw    mm1,mm3           /*merge and saturate vectors*/                                             \
_asm            movq        mm5,mm0                   /*copy sign bit data*/                                             \
_asm            movaps      xmm1_xmm4                      /*make a copy of coefficents for channel 1*/                  \
_asm            movq        [edi+(x*16)],mm1  /*store 4 reconstructed samples*/                                          \
_asm            unpckhps    xmm1_xmm2                      /*Interleve last 2 Coefficents of channel 1 & 2*/             \
_asm            movd        mm2,[esi+(x*16)+8]        /*load next 2 16bit data elements from piSrc*/                     \
_asm            pslld       mm0,1                     /*shift sine bit data for next 2*/                                 \
_asm            mulps       xmm0_xmm1                      /*Multiply coefficents with Sin values*/                      \
_asm            movd        mm4,[esi+(x*16)+12]       /*load next 2 16bit data elements from piSrc*/                     \
_asm            psraw       mm5,15                    /*sine extend sine bit data*/                                      \
_asm            cvtps2pi    mm1_xmm0                       /*convert 2 lower multiply results to rounded integer values*/\
_asm            punpcklwd   mm2,mm7                   /*merge with sign bit for 2 32bit values*/                         \
_asm            shufps      (xmm0_xmm0,0xE)                /*move high elements in to low (a=c,b=d,c=a,d=a)*/            \
_asm            punpcklwd   mm4,mm5                   /*interleave src with sign bit for 2 32bit values*/                \
_asm            paddd       mm1,mm2                        /*add the 2 vectors*/                                         \
_asm            cvtps2pi    mm3_xmm0                       /*convert 2 multiply results to rounded integer values*/      \
_asm            paddd       mm3,mm4                        /*add the 2 other vectors*/                                   \
_asm            packssdw    mm1,mm3                        /*merge and saturate 2 sets of 2*/                            \
_asm            movq        [edi+(x*16)+8],mm1             /*store 4 reconstructed samples*/                             }

                RECONSTRUCT8(0)
                RECONSTRUCT8(1)
                RECONSTRUCT8(2)
                RECONSTRUCT8(3)
                
                add         esi,2*32
                add         edi,2*32

                mov         iResult,ebx

                mov         ebx,piSrcSign   //uiSignbitData = *piSrcSign++;
                movd        mm0,[ebx]
                pslld       mm0,16
                psrld       mm0,16
                add         ebx,2
                mov         piSrcSign,ebx

                mov         ebx,piSrcSign2  //uiSignbitData2 = *piSrcSign2++;
                movd        mm1,[ebx]
                pslld       mm1,16
                psrld       mm1,16
                add         ebx,2
                mov         piSrcSign2,ebx

                mov         ebx,iResult
 
            dec         eax
            jnz         Loop2

            mov         piSrc,esi
            mov         piDst,edi
            mov         piSin,ebx
            mov         piCoef,ecx
            mov         piCoef2,edx
            movd        uiSignbitData,mm0
            movd        uiSignbitData2,mm1
#           undef RECONSTRUCT8

            }
            uiSignbitCount = 16;                                                     
            uiSignbitCount2 = 16;                                                     
            if (iLoopBy1) {
                pau->aupfnReconstruct = auReconstruct;
                return auReconstruct(pau,piOutput,pcSampleGet,fForceTransformAll); 
            }
        }
    }
    if (i < iCoefRecurQ3) 
    {
        Int iLoopBy4,iLoopBy1,iLoopCnt;
        iSegEnd = min (iCoefRecurQ3, iEnd);
        iLoopBy4 = (iSegEnd - i) >> 2;
        iLoopBy1 = (iSegEnd - i) & 0x3;
        (*pcSampleGet) += (I16)(iLoopBy4<<2);
        i += (iLoopBy4<<2);
        if (iLoopBy4 != 0)
        {
            _asm {

            mov         eax,iLoopBy4
            mov         ecx,piCoef
            mov         edx,piCoef2
            mov         edi,piDst
            Loop3:    
                sub         ecx,4*4                 //Bump ptr                                                              
                movups      xmm4_ecx                //Load Coefficents for channel 1
                sub         edx,4*4                 //Bump ptr                                          
                movups      xmm2_edx                //Load Coefficents for channel 2                                        
                cvtps2pi    mm0_xmm4                //convert 2 lower multiply results to rounded integer values            
                cvtps2pi    mm1_xmm2                //convert 2 lower multiply results to rounded integer values           
                shufps      (xmm4_xmm4,0xE)         //move high elements in to low (a=c,b=d,c=a,d=a)              
                shufps      (xmm2_xmm2,0xE)         //move high elements in to low (a=c,b=d,c=a,d=a)                        
                cvtps2pi    mm2_xmm4                //convert 2 lower multiply results to rounded integer values           
                cvtps2pi    mm3_xmm2                //convert 2 lower multiply results to rounded integer values            
                packssdw    mm2,mm3                 //Convert to 16bit and saturate
                pshufw      mm2_mm2 emit 0x8D     //Shuffle (a=b,b=d,c=a,b=c)
                packssdw    mm0,mm1                 //Convert to 16bit and saturate
                pshufw      mm0_mm0 emit 0x8D     //Shuffle (a=b,b=d,c=a,b=c)
                movq        [edi],mm2               //Store 4 16bit words
                movq        [edi+8],mm0             //Store 4 16bit words
                add         edi,2*8                 //Bump Ptr
            dec         eax
            jnz         Loop3
            mov         piCoef,ecx
            mov         piCoef2,edx
            mov         piDst,edi

            }
        }
        if (iLoopBy1) _asm emms
        for (iLoopCnt = 0; iLoopCnt < iLoopBy1; iLoopCnt++, i++,(*pcSampleGet)++)    {
            Float cfResult = INT_FROM_COEF( *--piCoef );
            ROUND_SATURATE_STORE( piDst, cfResult, SHRT_MIN, SHRT_MAX, iResult );
            cfResult = INT_FROM_COEF( *--piCoef2 );
            ROUND_SATURATE_STORE( (piDst+1), cfResult, SHRT_MIN, SHRT_MAX, iResult );
            piDst += cChan;
        }
    }
    _asm emms

    SAVE_SIGNBIT_STATE(piSrcSign,uiSignbitData);
    pau->m_rgpcinfo[0].m_rgiCoefReconCurr = (Int*)piCoef;
    pau->m_rgpcinfo[0].m_iCurrGetPCM_SubFrame = (I16)i;
    pau->m_rgpcinfo[0].m_piPrevOutputCurr = piSrc;


    SAVE_SIGNBIT_STATE(piSrcSign2,uiSignbitData2);
    pau->m_rgpcinfo[1].m_rgiCoefReconCurr = (Int*)piCoef2;
    pau->m_rgpcinfo[1].m_iCurrGetPCM_SubFrame = (I16)i;
    pau->m_rgpcinfo[1].m_piPrevOutputCurr = piSrc+1;

    pau->m_piSinForRecon = piSin;

#ifdef PROFILE
    FunctionProfileStop(&fp);
#endif
    return WMA_OK;
}

#endif //BUILD_INTEGER
#endif //USE_SIN_COS_TABLES

#ifdef ENCODER


//---------------------------------------------------------------------------
// Encoder Filter Verification
//---------------------------------------------------------------------------

#ifdef MMXVERIFY_ENABLE
void FourTapNUMERATOR_MMX_VERIFY
                      (const I16 *rgiCoefNum,
                       const I16 *piSource, I16* rgiSrc, I32 *piSrcCurr,
                       const I16 cChannel, const Int iSourceLength,
                       const I32 *piFIROutAligned, const I32 c_iAlignMultiple,
                       const I16 *piMMXCoefs, const I32 iSizeOfMMXCoefs)
{
    const Int c_minus1Mod3[] = {2, 0, 1};
    const Int ORDER = 3;

    I32 iSrcCurr = *piSrcCurr;
    int j;

    for (j = 0; j < iSourceLength; j++)
    {
        I32 iResult;

        assert (iSrcCurr >= 0 && iSrcCurr < 3);

        iResult = piSource[j*cChannel] * rgiCoefNum[0]
            + rgiSrc[iSrcCurr + 0] * rgiCoefNum[1]
            + rgiSrc[iSrcCurr + 1] * rgiCoefNum[2]
            + rgiSrc[iSrcCurr + 2] * rgiCoefNum[3];

        if (iResult != piFIROutAligned[j])
            DEBUG_BREAK();

        iSrcCurr = c_minus1Mod3[iSrcCurr];
        rgiSrc[iSrcCurr] = rgiSrc[iSrcCurr + ORDER] = piSource[j*cChannel];
    }

    *piSrcCurr = iSrcCurr;
}



void FiveTapNUMERATOR_MMX_VERIFY
                      (const I16 *rgiCoefNum,
                       const I16 *piSource, I16* rgiSrc, I32 *piSrcCurr,
                       const I16 cChannel, const Int iSourceLength,
                       const I32 *piFIROutAligned, const I32 c_iAlignMultiple,
                       const I16 *piMMXCoefs, const I32 iSizeOfMMXCoefs)
{
    const Int c_minus1Mod4[] = {3, 0, 1, 2};
    const Int ORDER = 4;

    I32 iSrcCurr = *piSrcCurr;
    int j;

    for (j = 0; j < iSourceLength; j++)
    {
        I32 iResult;

        assert (iSrcCurr >= 0 && iSrcCurr < ORDER);

        iResult = piSource[j*cChannel] * rgiCoefNum[0]
            + rgiSrc[iSrcCurr + 0] * rgiCoefNum[1]
            + rgiSrc[iSrcCurr + 1] * rgiCoefNum[2]
            + rgiSrc[iSrcCurr + 2] * rgiCoefNum[3]
            + rgiSrc[iSrcCurr + 3] * rgiCoefNum[4];

        if (iResult != piFIROutAligned[j])
            DEBUG_BREAK();

        iSrcCurr = c_minus1Mod4[iSrcCurr];
        rgiSrc[iSrcCurr] = rgiSrc[iSrcCurr + ORDER] = piSource[j*cChannel];
    }

    *piSrcCurr = iSrcCurr;
}



void EightTapNUMERATOR_MMX_VERIFY
                       (const I16 *rgiCoefNum,
                        const I16 *piSource,
                        I16* rgiSrc, I32 *piSrcCurr,
                        const I16 cChannel, const Int iSourceLength,
                        const I32 *piFIROutAligned, const I32 c_iAlignMultiple,
                        const I16 *piMMXCoefs, const I32 iSizeOfMMXCoefs)
{
    const Int c_minus1Mod6[] = {5, 0, 1, 2, 3, 4};
    const Int ORDER = 6;

    I32 iSrcCurr = *piSrcCurr;
    int j;

    for (j = 0; j < iSourceLength; j++)
    {
        I32 iResult;

        assert (iSrcCurr >= 0 && iSrcCurr < ORDER+1);

        iResult = piSource[j*cChannel] * rgiCoefNum[0]
            + rgiSrc[iSrcCurr + 0] * rgiCoefNum[1]
            + rgiSrc[iSrcCurr + 1] * rgiCoefNum[2]
            + rgiSrc[iSrcCurr + 2] * rgiCoefNum[3]
            + rgiSrc[iSrcCurr + 3] * rgiCoefNum[4]
            + rgiSrc[iSrcCurr + 4] * rgiCoefNum[5]
            + rgiSrc[iSrcCurr + 5] * rgiCoefNum[6]
            + rgiSrc[iSrcCurr + 6] * rgiCoefNum[7];

        if (iResult != piFIROutAligned[j])
            DEBUG_BREAK();

        iSrcCurr = c_minus1Mod6[iSrcCurr];
        rgiSrc[iSrcCurr] = rgiSrc[iSrcCurr + ORDER] = piSource[j*cChannel];
    }

    *piSrcCurr = iSrcCurr;
}



void FourTapDENOMINATOR_FLOP_VERIFY
                      (const Float *rgfltCoefDen,
                       const int position, const Float fltInvNumScale,
                       float *rgfltDst, I32 *piDstCurr,
                       const Int iSliceIncr, Float *pfltPower,
                       const Int iSourceLength, const I32 *piFIROutAligned)
{
    const Int c_minus1Mod3[] = {2, 0, 1};
    const Int ORDER = 3;
    const int c_iSliceMask = iSliceIncr - 1;

    Float fltSumSquared = 0;
    I32 iDstCurr = *piDstCurr;
    int j;

    for (j = 0; j < iSourceLength; )
    {
        Float fltDst;

        assert (rgfltCoefDen[0] == 1.0F);
        assert (iDstCurr >= 0 && iDstCurr < 3);

        fltDst = fltInvNumScale * piFIROutAligned[j]
            - rgfltCoefDen[1] * rgfltDst[iDstCurr + 0]
            - rgfltCoefDen[2] * rgfltDst[iDstCurr + 1]
            - rgfltCoefDen[3] * rgfltDst[iDstCurr + 2];

        iDstCurr = c_minus1Mod3[iDstCurr];
        rgfltDst[iDstCurr] = rgfltDst[iDstCurr + ORDER] = fltDst;

        fltSumSquared += fltDst * fltDst;

        j += 1;
        if ((j & c_iSliceMask) == 0)
        {
            if (fabs((pfltPower[position] - fltSumSquared)/fltSumSquared) >= 0.1)
                DEBUG_BREAK();

            pfltPower += 3;
            fltSumSquared = 0;
        } // if
    } // for

    *piDstCurr = iDstCurr;
}



void FiveTapDENOMINATOR_FLOP_VERIFY
                      (const Float *rgfltCoefDen,
                       const int position, const Float fltInvNumScale,
                       float *rgfltDst, I32 *piDstCurr,
                       const Int iSliceIncr, Float *pfltPower,
                       const Int iSourceLength, const I32 *piFIROutAligned)
{
    const Int c_minus1Mod4[] = {3, 0, 1, 2};
    const Int ORDER = 4;
    const int c_iSliceMask = iSliceIncr - 1;

    Float fltSumSquared = 0;
    I32 iDstCurr = *piDstCurr;
    int j;

    for (j = 0; j < iSourceLength; )
    {
        Float fltDst;

        assert (rgfltCoefDen[0] == 1.0F);
        assert (iDstCurr >= 0 && iDstCurr < ORDER);

        fltDst = fltInvNumScale * piFIROutAligned[j]
            - rgfltCoefDen[1] * rgfltDst[iDstCurr + 0]
            - rgfltCoefDen[2] * rgfltDst[iDstCurr + 1]
            - rgfltCoefDen[3] * rgfltDst[iDstCurr + 2]
            - rgfltCoefDen[4] * rgfltDst[iDstCurr + 3];

        iDstCurr = c_minus1Mod4[iDstCurr];
        rgfltDst[iDstCurr] = rgfltDst[iDstCurr + ORDER] = fltDst;

        fltSumSquared += fltDst * fltDst;

        j += 1;
        if ((j & c_iSliceMask) == 0)
        {
            if (fabs((pfltPower[position] - fltSumSquared)/fltSumSquared) >= 0.1)
                DEBUG_BREAK();

            pfltPower += 3;
            fltSumSquared = 0;
        } // if
    } // for

    *piDstCurr = iDstCurr;
}



void SevenTapDENOMINATOR_FLOP_VERIFY
                      (const Float *rgfltCoefDen,
                       const int position, const Float fltInvNumScale,
                       float *rgfltDst, I32 *piDstCurr,
                       const Int iSliceIncr, Float *pfltPower,
                       const Int iSourceLength, const I32 *piFIROutAligned)
{
    const Int c_minus1Mod6[] = {5, 0, 1, 2, 3, 4};
    const Int ORDER = 6;
    const int c_iSliceMask = iSliceIncr - 1;

    Float fltSumSquared = 0;
    I32 iDstCurr = *piDstCurr;
    int j;

    for (j = 0; j < iSourceLength; )
    {
        Float fltDst;

        assert (rgfltCoefDen[0] == 1.0F);
        assert (iDstCurr >= 0 && iDstCurr < ORDER+1);

        fltDst = fltInvNumScale * piFIROutAligned[j]
            - rgfltCoefDen[1] * rgfltDst[iDstCurr + 0]
            - rgfltCoefDen[2] * rgfltDst[iDstCurr + 1]
            - rgfltCoefDen[3] * rgfltDst[iDstCurr + 2]
            - rgfltCoefDen[4] * rgfltDst[iDstCurr + 3]
            - rgfltCoefDen[5] * rgfltDst[iDstCurr + 4]
            - rgfltCoefDen[6] * rgfltDst[iDstCurr + 5];

        iDstCurr = c_minus1Mod6[iDstCurr];
        rgfltDst[iDstCurr] = rgfltDst[iDstCurr + ORDER] = fltDst;

        fltSumSquared += fltDst * fltDst;

        j += 1;
        if ((j & c_iSliceMask) == 0)
        {
            if (fabs((pfltPower[position] - fltSumSquared)/fltSumSquared) >= 0.1)
                DEBUG_BREAK();

            pfltPower += 3;
            fltSumSquared = 0;
        } // if
    } // for

    *piDstCurr = iDstCurr;
}
#endif  // MMXVERIFY_ENABLE


//---------------------------------------------------------------------------
// Encoder Filter Helper Functions
//---------------------------------------------------------------------------

//***************************************************************************
// Function: NTapFIR_Unaligned_MMX
//
// Purpose:
//     This function performs FIR filter calculations on the given inputs,
// and when complete it updates the input history in a manner that the MMX
// numerator code can understand. Its purpose is to perform the math on the
// unaligned memory segment, thus allowing the MMX portion to operate only
// on aligned memory.
//
// Arguments
//  I16 *rgiCoefNum [in] - Numerator coefficients.
//  I16 *piSource [in] - Input data. piSource[0] must always be a valid input.
//     For mono sources, piSource[1] is next valid input. For stereo sources,
//     piSource[2] is next valid input (skip piSource[1]).
//  I32 iSourceLength [in] - Number of samples to filter.
//  I16 *rgiSrc [in/out] - Input data history buffer. Before returning, this
//     function updates this array to reflect the recently used inputs.
//     NOTE that this history is in MMX form, basically a quadword copy of the
//     last 4*N inputs (where N is an integer >= 1).
//  I32 *piFIROut [out] - The FIR filter output is stored here.
//  int cChannels [in] - number of channels in the input data stream (interleaved).
//  I32 iNumTaps [in] - number of taps in the FIR filter.
//***************************************************************************
void INLINE NTapFIR_Unaligned_MMX(const I16 *rgiCoefNum,
                                  const I16 *piSource, const I32 iSourceLength,
                                  I16 *rgiSrc, I32 *piFIROut,
                                  const int cChannels, const I32 iNumTaps)
{
    const int c_iTotalHistorySlots = 4*(((iNumTaps - 1) + 3)/4);

    int j;
    int iNewHistory;

    for (j = 0; j < iSourceLength; j++)
    {
        // Recall history is a quadword of last input vectors. Since we only need
        // (iNumTaps - 1) histories, calculate how many quadwords are required
        // and index to the end of that quadword.
        const int c_iHistoryStart = c_iTotalHistorySlots - 1;
        int i;
        int k;

        piFIROut[j] = 0;

        // Multiply current input samples by the coefficients
        for (i = 0; i <= j && i < iNumTaps; i++)
            piFIROut[j] += piSource[(j - i) * cChannels] * rgiCoefNum[i];

        // Next, multiply historic input samples by the coefficients (if required)
        for (k = i ; k < iNumTaps; k++)
            piFIROut[j] += rgiSrc[c_iHistoryStart - (k - i)] * rgiCoefNum[k];
    }

    // Now that we've calculated unaligned samples, update src history to reflect this
    // Recall number of history slots is always a multiple of 4, even if iNumTaps is not!
    // Right now we copy unused history slots, we can fix this later if we get bored.
    iNewHistory = min(c_iTotalHistorySlots, iSourceLength);

    if (iNewHistory < c_iTotalHistorySlots)
    {
        // Partial update of history: expunge expired samples by collapsing the array
        for (j = 0 ; j < c_iTotalHistorySlots - iNewHistory; j++)
            rgiSrc[j] = rgiSrc[j + iNewHistory];
    }

    // Read in the most recent samples, up to iNewHistory worth
    for (j = c_iTotalHistorySlots - iNewHistory; j < c_iTotalHistorySlots; j++)
        rgiSrc[j] = piSource[cChannels * (iSourceLength + j - c_iTotalHistorySlots)];

} // NTapFIR_Unaligned_MMX


//***************************************************************************
// Function: InitMMXFilterCoefs
//
// Purpose:
//     Writes coefficients to the given array to optimize MMX performance.
// To cut down on unaligned memory accesses, MMX coefficients are typically
// arranged to fit in one MMX register. For instance, given an input vector
// I = "5678" in an MMX register, plus history vector H = "1234", one would
// compute I * "a..." + H * ".dcb" to get a*5+b*4+c*3+d*2 = FIR output.
// Then, without changing input or history vectors, one uses a different
// MMX coefficient array to compute the next output (eg, "ba.." and "..cd").
//
// Arguments
//   I16 *piDst [out] - the function outputs the staggered MMX coefficients
//     to this given buffer. The minimal number of MMX registers are used,
//     ie, this function never returns an entire quadword of 0's.
//     THIS MEMORY SHOULD BE ALIGNED ON A 16-BYTE BOUNDARY (32 is even better).
//   U32 iDstSize [in] - size of buffer pointed to by *piDst.
//   I16 *piSrc [in] - FIR Numerator coefficients.
//   U32 iTapCount [in] - Number of taps in numberator.
//
// Perf Notes
//   Inlining this function actually slows down performance for some reason.
//***************************************************************************
void InitMMXFilterCoefs(I16 *piDst, const U32 iDstSize,
                        const I16 *piSrc, const U32 iTapCount)
{
    U32 i;

    const int c_rgiMod4Offset[] = {1, 0, 3, 2};
    const int c_iOffset0 = c_rgiMod4Offset[iTapCount % 4];
    const int c_iOffset1 = 4*((c_iOffset0 + iTapCount + 3) / 4) + (c_iOffset0 + 1)%4;
    const int c_iOffset2 = 4*((c_iOffset1 + iTapCount + 3) / 4) + (c_iOffset0 + 2)%4;
    const int c_iOffset3 = 4*((c_iOffset2 + iTapCount + 3) / 4) + (c_iOffset0 + 3)%4;

    // We know what multiple-of-4 SIMD coefs look like, so verify those
    assert(iTapCount % 4 != 0 || (U32)c_iOffset0 == 1);
    assert(iTapCount % 4 != 0 || (U32)c_iOffset1 == 1 * (iTapCount + 4) + 2);
    assert(iTapCount % 4 != 0 || (U32)c_iOffset2 == 2 * (iTapCount + 4) + 3);
    assert(iTapCount % 4 != 0 || (U32)c_iOffset3 == 3 * (iTapCount + 4));

    assert(iDstSize >= (iTapCount + 3) * 4 * sizeof(I16)); // Check dest size
    assert((((U32)piDst) & 0x0000001F) == 0); // Verify 32-byte alignment of dst

    memset(piDst, 0, iDstSize); // The cheater's way to fill in the zeroes
    for (i = 0; i < iTapCount; i++)
    {
        const I16 iCurrCoef = piSrc[(iTapCount - 1) - i];

        // Do first-position coefficient array (x432 1xxx)
        piDst[i + c_iOffset0] = iCurrCoef;

        // Next, second-position coefficient array (xx43 21xx)
        piDst[i + c_iOffset1] = iCurrCoef;

        // Next, third-position coefficient array (xxx4 321x)
        piDst[i + c_iOffset2] = iCurrCoef;

        // Finally, fourth-position (unstaggered) coefficient array (4321)
        piDst[i + c_iOffset3] = iCurrCoef;
    }
} // InitMMXFilterCoefs



//***************************************************************************
// MMX MONO NUMERATORS
//
// I used these functions to construct stereo versions of the MMX numerators.
// Unfortunately it appears that MMX mono is no faster than the C code, so
// I've decided not to include them. These filters will probably be deleted
// from the codebase soon after this (I just want to record for posterity).
//***************************************************************************
#ifdef MMXMONO
void INLINE FourTapNUMERATOR_MMX_MONO(const I16 *rgiCoefNum,
                                      const I16 *piSource, I16* rgiSrc, I32 *piSrcCurr,
                                      const Int iSourceLength,
                                      I32 *piFIROutAligned, const I32 c_iAlignMultiple,
                                      I16 *piMMXCoefs, const I32 iSizeOfMMXCoefs)
{
    const int cChannel = 1;

    Int iSrcCurr = *piSrcCurr;

    I32    *piFIROut = piFIROutAligned;

    int     iNumUnalignedStart;             // Number of unaligned samples at start of block
    int     iNumUnalignedEnd;               // Number of unaligned samples at end of block
    int     iAlignedBlocksOfFour;           // Number of aligned blocks of 4 samples

    // Determine number of aligned, unaligned samples
    assert(((c_iAlignMultiple - 1) & c_iAlignMultiple) == 0); // Pure power of 2
    iNumUnalignedStart = ((((U32) piSource + c_iAlignMultiple - 1) & ~(c_iAlignMultiple - 1)) -
        (U32) piSource) / sizeof(*piSource);
    iAlignedBlocksOfFour = (iSourceLength - iNumUnalignedStart) / 4; // DIV 4
    iNumUnalignedEnd = (iSourceLength - iNumUnalignedStart) & (4-1); // MOD 4


    // FIRST, calculate unaligned start samples
    NTapFIR_Unaligned_MMX(rgiCoefNum, piSource, iNumUnalignedStart, rgiSrc,
        piFIROut, cChannel, 4);
    piSource += iNumUnalignedStart;
    assert(0 == (((U32)piSource) & (c_iAlignMultiple -1)));
    piFIROut += iNumUnalignedStart;

    // Set up staggered MMX coefficient arrays, then go MMX for aligned inputs
    // Align staggered MMX coefficient array on 32-byte boundary

    // Perf tests indicate that initializing MMX coefs EVERY TIME is slightly
    // faster than init once and much faster than hard-coded tables or
    // pre-initialized. Strange but true. Mem alignment is definitely a factor.

    InitMMXFilterCoefs(piMMXCoefs, iSizeOfMMXCoefs, rgiCoefNum, 4);

    assert(0 == ((U32)piFIROut & 1)); // Verify we're on a DWORD boundary
    assert(0 == *piSrcCurr); // MMX history matches input order, it's NOT a doubled history

#define piFIROutput     ebx
#define iLoopCtr        ecx
#define piSrcHistory    edx
#define piSrc           esi
#define piMMXCoefsASM   edi

#define SIZEOF_I16      2
#define SIZEOF_I32      4

    _asm
    {
        mov         iLoopCtr, iAlignedBlocksOfFour  // Load the index ctr
        mov         piSrcHistory, rgiSrc
        mov         piSrc, piSource
        movq        mm7, [piSrcHistory]                 // Oldest 4 samples (history): unaligned, but only done once
        mov         piFIROutput, piFIROut
        mov         piMMXCoefsASM, piMMXCoefs

        movq        mm2, [piMMXCoefsASM + SIZEOF_I16*0] // Load 1-offset coefs (part 1)
        movq        mm3, [piMMXCoefsASM + SIZEOF_I16*4] // Load 1-offset coefs (part 2)
        movq        mm4, [piMMXCoefsASM + SIZEOF_I16*24]    // Load 4-offset coefs

MMXLOOP:
        // We used to pre-load input. DON'T DO THIS, last iteration can read past valid memory
        movq        mm6, [piSrc]                        // Load in the input

        // ---INTERATION 0---
        movq        mm1, mm7                            // Copy oldest history
        pmaddwd     mm1, mm2                            // MADD oldest history w/ 1-offset coefs
        movq        mm0, mm6                            // Copy current input vector
        pmaddwd     mm0, mm3                            // MADD current input vector
        paddd       mm0, mm1                            // Sum mm1 + mm0 results
        movq        mm1, mm0                            // Now sum horizontally: HI32(mm0) + LO32(mm0)
        psrlq       mm0, 32
        paddd       mm0, mm1

        movd        [piFIROutput + SIZEOF_I32*0], mm0   // Output results


        // ---INTERATION 1---
        movq        mm1, mm7                            // Copy oldest history
        pmaddwd     mm1, [piMMXCoefsASM + SIZEOF_I16*8] // MADD oldest history w/ 2-offset coefs
        movq        mm0, mm6                            // Copy current input vector
        pmaddwd     mm0, [piMMXCoefsASM + SIZEOF_I16*12]// MADD current input vector
        paddd       mm0, mm1                            // Sum mm1 + mm0 results
        movq        mm1, mm0                            // Now sum horizontally: HI32(mm0) + LO32(mm0)
        psrlq       mm0, 32
        paddd       mm0, mm1

        movd        [piFIROutput + SIZEOF_I32*1], mm0   // Output results


        // ---INTERATION 2---
        movq        mm1, mm7                            // Copy oldest history
        pmaddwd     mm1, [piMMXCoefsASM + SIZEOF_I16*16]// MADD oldest history w/ 3-offset coefs
        movq        mm0, mm6                            // Copy current input vector
        pmaddwd     mm0, [piMMXCoefsASM + SIZEOF_I16*20]// MADD current input vector
        paddd       mm0, mm1                            // Sum mm1 + mm0 results
        movq        mm1, mm0                            // Now sum horizontally: HI32(mm0) + LO32(mm0)
        psrlq       mm0, 32
        paddd       mm0, mm1

        movd        [piFIROutput + SIZEOF_I32*2], mm0   // Output results


        // ---INTERATION 3---
        movq        mm0, mm6                            // Copy current input vector
        pmaddwd     mm0, mm4                            // MADD current input vector
        movq        mm1, mm0                            // Now sum horizontally: HI32(mm0) + LO32(mm0)
        psrlq       mm0, 32
        paddd       mm0, mm1

        movd        [piFIROutput + SIZEOF_I32*3], mm0   // Output results


        // Load next input, decrement ctrs, advance ptrs and loop around
        add         piSrc, 4*SIZEOF_I16
        add         piFIROutput, 4*SIZEOF_I32
        dec         iLoopCtr
        movq        mm7, mm6                    // Current input vector is now history

        jnz         MMXLOOP

        // End of loop
        movq        [piSrcHistory], mm7                 // Oldest 4 samples (history): unaligned, but only done once
        emms
    } // asm
    piSource += iAlignedBlocksOfFour * 4;
    piFIROut += iAlignedBlocksOfFour * 4;

    // Finish off the unaligned samples
    NTapFIR_Unaligned_MMX(rgiCoefNum, piSource, iNumUnalignedEnd, rgiSrc,
        piFIROut, cChannel, 4);
} // FourTapNUMERATOR_MMX_MONO


void INLINE
FiveTapNUMERATOR_MMX_MONO
                      (const I16 *rgiCoefNum,
                       const I16 *piSource, I16* rgiSrc, I32 *piSrcCurr,
                       const Int iSourceLength,
                       I32 *piFIROutAligned, const I32 c_iAlignMultiple,
                       I16 *piMMXCoefs, const I32 iSizeOfMMXCoefs)
{
    const int cChannel = 1;

    Int iSrcCurr = *piSrcCurr;

    I32    *piFIROut = piFIROutAligned;

    int     iNumUnalignedStart;             // Number of unaligned samples at start of block
    int     iNumUnalignedEnd;               // Number of unaligned samples at end of block
    int     iAlignedBlocksOfFour;           // Number of aligned blocks of 4 samples

    // Determine number of aligned, unaligned samples
    assert(((c_iAlignMultiple - 1) & c_iAlignMultiple) == 0); // Pure power of 2
    iNumUnalignedStart = ((((U32) piSource + c_iAlignMultiple - 1) & ~(c_iAlignMultiple - 1)) -
        (U32) piSource) / sizeof(*piSource);
    iAlignedBlocksOfFour = (iSourceLength - iNumUnalignedStart) / 4; // DIV 4
    iNumUnalignedEnd = (iSourceLength - iNumUnalignedStart) & (4-1); // MOD 4


    // FIRST, calculate unaligned start samples
    NTapFIR_Unaligned_MMX(rgiCoefNum, piSource, iNumUnalignedStart, rgiSrc,
        piFIROut, cChannel, 5);
    piSource += iNumUnalignedStart;
    assert(0 == (((U32)piSource) & (c_iAlignMultiple -1)));
    piFIROut += iNumUnalignedStart;

    // Set up staggered MMX coefficient arrays, then go MMX for aligned inputs
    // Align staggered MMX coefficient array on 32-byte boundary

    // Perf tests indicate that initializing MMX coefs EVERY TIME is slightly
    // faster than init once and much faster than hard-coded tables or
    // pre-initialized. Strange but true. Mem alignment is definitely a factor.

    InitMMXFilterCoefs(piMMXCoefs, iSizeOfMMXCoefs, rgiCoefNum, 5);

    assert(0 == ((U32)piFIROut & 1)); // Verify we're on a DWORD boundary
    assert(0 == *piSrcCurr); // MMX history matches input order, it's NOT a doubled history

#define piFIROutput     ebx
#define iLoopCtr        ecx
#define piSrcHistory    edx
#define piSrc           esi
#define piMMXCoefsASM   edi

#define SIZEOF_I16      2
#define SIZEOF_I32      4

    _asm
    {
        mov         iLoopCtr, iAlignedBlocksOfFour  // Load the index ctr
        mov         piSrcHistory, rgiSrc
        mov         piSrc, piSource
        movq        mm7, [piSrcHistory]                 // Oldest 4 samples (history): unaligned, but only done once
        mov         piFIROutput, piFIROut
        mov         piMMXCoefsASM, piMMXCoefs

        movq        mm2, [piMMXCoefsASM + SIZEOF_I16*0] // Load 1-offset coefs (part 1)
        movq        mm3, [piMMXCoefsASM + SIZEOF_I16*4] // Load 1-offset coefs (part 2)

MMXLOOP:
        // We used to pre-load input. DON'T DO THIS, last iteration can read past valid memory
        movq        mm6, [piSrc]                        // Load in the input

        // ---INTERATION 0---
        movq        mm1, mm7                            // Copy oldest history
        pmaddwd     mm1, mm2                            // MADD oldest history w/ 1-offset coefs
        movq        mm0, mm6                            // Copy current input vector
        pmaddwd     mm0, mm3                            // MADD current input vector
        paddd       mm0, mm1                            // Sum mm1 + mm0 results
        movq        mm1, mm0                            // Now sum horizontally: HI32(mm0) + LO32(mm0)
        psrlq       mm0, 32
        paddd       mm0, mm1

        movd        [piFIROutput + SIZEOF_I32*0], mm0   // Output results


        // ---INTERATION 1---
        movq        mm1, mm7                            // Copy oldest history
        pmaddwd     mm1, [piMMXCoefsASM + SIZEOF_I16*8] // MADD oldest history w/ 2-offset coefs
        movq        mm0, mm6                            // Copy current input vector
        pmaddwd     mm0, [piMMXCoefsASM + SIZEOF_I16*12]// MADD current input vector
        paddd       mm0, mm1                            // Sum mm1 + mm0 results
        movq        mm1, mm0                            // Now sum horizontally: HI32(mm0) + LO32(mm0)
        psrlq       mm0, 32
        paddd       mm0, mm1

        movd        [piFIROutput + SIZEOF_I32*1], mm0   // Output results


        // ---INTERATION 2---
        movq        mm1, mm7                            // Copy oldest history
        pmaddwd     mm1, [piMMXCoefsASM + SIZEOF_I16*16]// MADD oldest history w/ 3-offset coefs
        movq        mm0, mm6                            // Copy current input vector
        pmaddwd     mm0, [piMMXCoefsASM + SIZEOF_I16*20]// MADD current input vector
        paddd       mm0, mm1                            // Sum mm1 + mm0 results
        movq        mm1, mm0                            // Now sum horizontally: HI32(mm0) + LO32(mm0)
        psrlq       mm0, 32
        paddd       mm0, mm1

        movd        [piFIROutput + SIZEOF_I32*2], mm0   // Output results


        // ---INTERATION 3---
        movq        mm1, mm7                            // Copy oldest history
        pmaddwd     mm1, [piMMXCoefsASM + SIZEOF_I16*24]// MADD oldest history w/ 4-offset coefs
        movq        mm0, mm6                            // Copy current input vector
        pmaddwd     mm0, [piMMXCoefsASM + SIZEOF_I16*28]// MADD current input vector
        paddd       mm0, mm1                            // Sum mm1 + mm0 results
        movq        mm1, mm0                            // Now sum horizontally: HI32(mm0) + LO32(mm0)
        psrlq       mm0, 32
        paddd       mm0, mm1

        movd        [piFIROutput + SIZEOF_I32*3], mm0   // Output results


        // Load next input, decrement ctrs, advance ptrs and loop around
        add         piSrc, 4*SIZEOF_I16
        add         piFIROutput, 4*SIZEOF_I32
        dec         iLoopCtr
        movq        mm7, mm6                    // Current input vector is now history

        jnz         MMXLOOP

        // End of loop
        movq        [piSrcHistory], mm7                 // Oldest 4 samples (history): unaligned, but only done once
        emms
    } // asm
    piSource += iAlignedBlocksOfFour * 4;
    piFIROut += iAlignedBlocksOfFour * 4;

    // Finish off the unaligned samples
    NTapFIR_Unaligned_MMX(rgiCoefNum, piSource, iNumUnalignedEnd, rgiSrc,
        piFIROut, cChannel, 5);
} // FiveTapNUMERATOR_MMX_MONO


void INLINE
EightTapNUMERATOR_MMX_MONO
                       (const I16 *rgiCoefNum,
                        const I16 *piSource,
                        I16* rgiSrc, I32 *piSrcCurr,
                        const Int iSourceLength,
                        I32 *piFIROutAligned, const I32 c_iAlignMultiple,
                        I16 *piMMXCoefs, const I32 iSizeOfMMXCoefs)
{
    const int cChannel = 1;

    Int iSrcCurr = *piSrcCurr;
    I32    *piFIROut = piFIROutAligned;

    int     iNumUnalignedStart;             // Number of unaligned samples at start of block
    int     iNumUnalignedEnd;               // Number of unaligned samples at end of block
    int     iAlignedBlocksOfFour;           // Number of aligned blocks of 4 samples

    // Determine number of aligned, unaligned samples
    assert(((c_iAlignMultiple - 1) & c_iAlignMultiple) == 0); // Pure power of 2
    iNumUnalignedStart = ((((U32) piSource + c_iAlignMultiple - 1) & ~(c_iAlignMultiple - 1)) -
        (U32) piSource) / sizeof(*piSource);
    iAlignedBlocksOfFour = (iSourceLength - iNumUnalignedStart) / 4; // DIV 4
    iNumUnalignedEnd = (iSourceLength - iNumUnalignedStart) & (4-1); // MOD 4

    // FIRST, calculate unaligned start samples
    NTapFIR_Unaligned_MMX(rgiCoefNum, piSource, iNumUnalignedStart, rgiSrc,
        piFIROut, cChannel, 8);
    piSource += iNumUnalignedStart;
    assert(0 == (((U32)piSource) & (c_iAlignMultiple -1)));
    piFIROut += iNumUnalignedStart;

    // Set up staggered MMX coefficient arrays, then go MMX for aligned inputs
    // Align staggered MMX coefficient array on 32-byte boundary

    // Perf tests indicate that initializing MMX coefs EVERY TIME is slightly
    // faster than init once and much faster than hard-coded tables or
    // pre-initialized. Strange but true. Mem alignment is definitely a factor.

    InitMMXFilterCoefs(piMMXCoefs, iSizeOfMMXCoefs, rgiCoefNum, 8);

    assert(0 == ((U32)piFIROut & 1)); // Verify we're on a DWORD boundary
    assert(0 == *piSrcCurr); // MMX history matches input order, it's NOT a doubled history

#define piFIROutput     ebx
#define iLoopCtr        ecx
#define piSrcHistory    edx
#define piSrc           esi
#define piMMXCoefsASM   edi

#define SIZEOF_I16      2
#define SIZEOF_I32      4

    _asm
    {
        mov         iLoopCtr, iAlignedBlocksOfFour  // Load the index ctr
        mov         piSrcHistory, rgiSrc
        mov         piSrc, piSource
        movq        mm7, [piSrcHistory]                 // Oldest 4 samples (history): unaligned, but only done once
        movq        mm6, [piSrcHistory + 4*SIZEOF_I16]  // Second-oldest 4 samples (history): unaligned, but only done once
        mov         piFIROutput, piFIROut
        mov         piMMXCoefsASM, piMMXCoefs

MMXLOOP:
        // We used to pre-load input. DON'T DO THIS, last iteration can read past valid memory
        movq        mm5, [piSrc]                        // Load in the input

        // ---INTERATION 0---
        movq        mm2, mm7                            // Copy oldest history
        movq        mm1, mm6                            // Copy second-oldest history
        pmaddwd     mm2, [piMMXCoefsASM + SIZEOF_I16*0] // MADD oldest history w/ 1-offset coefs
        movq        mm0, mm5                            // Copy current input vector
        pmaddwd     mm1, [piMMXCoefsASM + SIZEOF_I16*4] // MADD second-oldest history
        pmaddwd     mm0, [piMMXCoefsASM + SIZEOF_I16*8] // MADD current input vector
        paddd       mm2, mm1                            // Sum mm1 + mm2 results
        paddd       mm0, mm2                            // Sum (mm1 + mm2) + mm0 results
        movq        mm1, mm0                            // Now sum horizontally: HI32(mm0) + LO32(mm0)
        psrlq       mm0, 32
        paddd       mm0, mm1

        movd        [piFIROutput + SIZEOF_I32*0], mm0   // Output results


        // ---INTERATION 1---
        movq        mm2, mm7                            // Copy oldest history
        movq        mm1, mm6                            // Copy second-oldest history
        pmaddwd     mm2, [piMMXCoefsASM + SIZEOF_I16*12]// MADD oldest history w/ 2-offset coefs
        movq        mm0, mm5                            // Copy current input vector
        pmaddwd     mm1, [piMMXCoefsASM + SIZEOF_I16*16]// MADD second-oldest history
        pmaddwd     mm0, [piMMXCoefsASM + SIZEOF_I16*20]// MADD current input vector
        paddd       mm2, mm1                            // Sum mm1 + mm2 results
        paddd       mm0, mm2                            // Sum (mm1 + mm2) + mm0 results
        movq        mm1, mm0                            // Now sum horizontally: HI32(mm0) + LO32(mm0)
        psrlq       mm0, 32
        paddd       mm0, mm1

        movd        [piFIROutput + SIZEOF_I32*1], mm0   // Output results


        // ---INTERATION 2---
        movq        mm2, mm7                            // Copy oldest history
        movq        mm1, mm6                            // Copy second-oldest history
        pmaddwd     mm2, [piMMXCoefsASM + SIZEOF_I16*24]// MADD oldest history w/ 3-offset coefs
        movq        mm0, mm5                            // Copy current input vector
        pmaddwd     mm1, [piMMXCoefsASM + SIZEOF_I16*28]// MADD second-oldest history
        pmaddwd     mm0, [piMMXCoefsASM + SIZEOF_I16*32]// MADD current input vector
        paddd       mm2, mm1                            // Sum mm1 + mm2 results
        paddd       mm0, mm2                            // Sum (mm1 + mm2) + mm0 results
        movq        mm1, mm0                            // Now sum horizontally: HI32(mm0) + LO32(mm0)
        psrlq       mm0, 32
        paddd       mm0, mm1

        movd        [piFIROutput + SIZEOF_I32*2], mm0   // Output results


        // ---INTERATION 3---
        movq        mm1, mm6                            // Copy second-oldest history
        movq        mm0, mm5                            // Copy current input vector
        pmaddwd     mm1, [piMMXCoefsASM + SIZEOF_I16*36]// MADD second-oldest history w/ 4-offset coefs
        pmaddwd     mm0, [piMMXCoefsASM + SIZEOF_I16*40]// MADD current input vector
        paddd       mm0, mm1                            // Sum mm1 + mm0 results
        movq        mm1, mm0                            // Now sum horizontally: HI32(mm0) + LO32(mm0)
        psrlq       mm0, 32
        paddd       mm0, mm1

        movd        [piFIROutput + SIZEOF_I32*3], mm0   // Output results


        // Load next input, decrement ctrs, advance ptrs and loop around
        add         piSrc, 4*SIZEOF_I16
        add         piFIROutput, 4*SIZEOF_I32
        dec         iLoopCtr
        movq        mm7, mm6                    // Second-oldest history is now oldest
        movq        mm6, mm5                    // Current input vector is now 2nd oldest

        jnz         MMXLOOP

        // End of loop
        movq        [piSrcHistory], mm7                 // Oldest 4 samples (history): unaligned, but only done once
        movq        [piSrcHistory + 4*SIZEOF_I16], mm6  // Second-oldest 4 samples (history): unaligned, but only done once
        emms
    } // asm
    piSource += iAlignedBlocksOfFour * 4;
    piFIROut += iAlignedBlocksOfFour * 4;

    // Finish off the unaligned samples
    NTapFIR_Unaligned_MMX(rgiCoefNum, piSource, iNumUnalignedEnd, rgiSrc,
        piFIROut, cChannel, 8);
} // EightTapNUMERATOR_MMX_MONO


#endif  // MMXMONO



//***************************************************************************
// MMX STEREO NUMERATORS
//***************************************************************************
void INLINE
FourTapNUMERATOR_MMX_STEREO
                      (const I16 *rgiCoefNum,
                       const I16 *piSource, I16* rgiSrc, I32 *piSrcCurr,
                       const Int iSourceLength,
                       I32 *piFIROutAligned, const I32 c_iAlignMultiple,
                       I16 *piMMXCoefs, const I32 iSizeOfMMXCoefs)
{
    const int cChannel = 2;

    Int iSrcCurr = *piSrcCurr;

    I32    *piFIROut = piFIROutAligned;
    I32     iShiftLeft;

    int     iNumUnalignedStart;             // Number of unaligned samples at start of block
    int     iNumUnalignedStartALL;          // Unaligned samples at start including other channel's
    int     iNumUnalignedEnd;               // Number of unaligned samples at end of block
    int     iAlignedBlocksOfFour;           // Number of aligned blocks of 4 samples

    // Determine number of aligned, unaligned samples
    assert(((c_iAlignMultiple - 1) & c_iAlignMultiple) == 0); // Pure power of 2
    iNumUnalignedStartALL = ((((U32) piSource + c_iAlignMultiple - 1) & ~(c_iAlignMultiple - 1)) -
        (U32) piSource) / sizeof(*piSource);
    iNumUnalignedStart = (iNumUnalignedStartALL + 1) / cChannel;
    iAlignedBlocksOfFour = (iSourceLength - iNumUnalignedStart) / 4; // DIV 4
    iNumUnalignedEnd = (iSourceLength - iNumUnalignedStart) & (4-1); // MOD 4

    // FIRST, calculate unaligned start samples
    NTapFIR_Unaligned_MMX(rgiCoefNum, piSource, iNumUnalignedStart, rgiSrc,
        piFIROut, cChannel, 4);
    piSource += iNumUnalignedStartALL;
    assert(0 == (((U32)piSource) & (c_iAlignMultiple -1)));
    piFIROut += iNumUnalignedStart;

    // Set up staggered MMX coefficient arrays, then go MMX for aligned inputs
    // Align staggered MMX coefficient array on 32-byte boundary

    // Perf tests indicate that initializing MMX coefs EVERY TIME is slightly
    // faster than init once and much faster than hard-coded tables or
    // pre-initialized. Strange but true. Mem alignment is definitely a factor.

    InitMMXFilterCoefs(piMMXCoefs, iSizeOfMMXCoefs, rgiCoefNum, 4);
    if (iNumUnalignedStartALL & 1)
    {
        // ODD # samples from piSource to align point,
        // we use sizeof(I16) offset from align
        iShiftLeft = 0; // Desired input will get read into slots 1,3
    }
    else
    {
        // EVEN # samples from piSource to align point,
        // we use 0 offset from align
        iShiftLeft = 16; // Desired input will get read into slots 0,2
    }

    assert(0 == ((U32)piFIROut & 1)); // Verify we're on a DWORD boundary
    assert(0 == *piSrcCurr); // MMX history matches input order, it's NOT a doubled history

#define iShiftLeftASM   eax
#define piFIROutput     ebx
#define iLoopCtr        ecx
#define piSrcHistory    edx
#define piSrc           esi
#define piMMXCoefsASM   edi

#define SIZEOF_I16      2
#define SIZEOF_I32      4

    _asm
    {
        mov         iShiftLeftASM, iShiftLeft
        mov         iLoopCtr, iAlignedBlocksOfFour  // Load the index ctr
        mov         piSrcHistory, rgiSrc
        mov         piSrc, piSource
        movq        mm7, [piSrcHistory]                 // Oldest 4 samples (history): unaligned, but only done once
        mov         piFIROutput, piFIROut
        mov         piMMXCoefsASM, piMMXCoefs

        movq        mm2, [piMMXCoefsASM + SIZEOF_I16*0] // Load 1-offset coefs (part 1)
        movq        mm3, [piMMXCoefsASM + SIZEOF_I16*4] // Load 1-offset coefs (part 2)

MMXLOOP:
        // We used to pre-load input. DON'T DO THIS, last iteration can read past valid memory
        movq        mm5, [piSrc + 0*SIZEOF_I16]         // Load in the input
        movq        mm4, [piSrc + 4*SIZEOF_I16]

        // Throw away the samples we don't want to construct next input vector
        pxor        mm1, mm1                    // Zero it
        movd        mm1, iShiftLeftASM
        movq        mm6, mm5
        pslld       mm6, mm1                    // Shift left by 16 or 0
        psrad       mm6, 16                     // Shift right is always 16
        pslld       mm4, mm1                    // Shift left by 16 or 0
        psrad       mm4, 16                     // Shift right is always 16
        packssdw    mm6, mm4                    // Combine the results to get 4 inputs

        // ---INTERATION 0---
        movq        mm1, mm7                            // Copy oldest history
        pmaddwd     mm1, mm2                            // MADD oldest history w/ 1-offset coefs
        movq        mm0, mm6                            // Copy current input vector
        pmaddwd     mm0, mm3                            // MADD current input vector
        paddd       mm0, mm1                            // Sum mm1 + mm0 results
        movq        mm1, mm0                            // Now sum horizontally: HI32(mm0) + LO32(mm0)
        psrlq       mm0, 32
        paddd       mm0, mm1

        movd        [piFIROutput + SIZEOF_I32*0], mm0   // Output results


        // ---INTERATION 1---
        movq        mm1, mm7                            // Copy oldest history
        pmaddwd     mm1, [piMMXCoefsASM + SIZEOF_I16*8] // MADD oldest history w/ 2-offset coefs
        movq        mm0, mm6                            // Copy current input vector
        pmaddwd     mm0, [piMMXCoefsASM + SIZEOF_I16*12]// MADD current input vector
        paddd       mm0, mm1                            // Sum mm1 + mm0 results
        movq        mm1, mm0                            // Now sum horizontally: HI32(mm0) + LO32(mm0)
        psrlq       mm0, 32
        paddd       mm0, mm1

        movd        [piFIROutput + SIZEOF_I32*1], mm0   // Output results


        // ---INTERATION 2---
        movq        mm1, mm7                            // Copy oldest history
        pmaddwd     mm1, [piMMXCoefsASM + SIZEOF_I16*16]// MADD oldest history w/ 3-offset coefs
        movq        mm0, mm6                            // Copy current input vector
        pmaddwd     mm0, [piMMXCoefsASM + SIZEOF_I16*20]// MADD current input vector
        paddd       mm0, mm1                            // Sum mm1 + mm0 results
        movq        mm1, mm0                            // Now sum horizontally: HI32(mm0) + LO32(mm0)
        psrlq       mm0, 32
        paddd       mm0, mm1

        movd        [piFIROutput + SIZEOF_I32*2], mm0   // Output results


        // ---INTERATION 3---
        movq        mm0, mm6                            // Copy current input vector
        pmaddwd     mm0, [piMMXCoefsASM + SIZEOF_I16*24]// MADD current input vector
        movq        mm1, mm0                            // Now sum horizontally: HI32(mm0) + LO32(mm0)
        psrlq       mm0, 32
        paddd       mm0, mm1

        movd        [piFIROutput + SIZEOF_I32*3], mm0   // Output results


        // Load next input, decrement ctrs, advance ptrs and loop around
        add         piSrc, 8*SIZEOF_I16
        add         piFIROutput, 4*SIZEOF_I32
        dec         iLoopCtr
        movq        mm7, mm6                    // Current input vector is now history

        jnz         MMXLOOP

        // End of loop
        movq        [piSrcHistory], mm7                 // Oldest 4 samples (history): unaligned, but only done once
        emms
    } // asm
    piSource += iAlignedBlocksOfFour * 4 * cChannel;
    piFIROut += iAlignedBlocksOfFour * 4;

    // Remember that piSource was made to point to 32-byte boundary, even if actual input sources
    // don't live on that boundary (eg, ABAB with first "A" on 32-byte boundary, our inputs are the "B"'s)
    // If we were reading the odd ones, we need to add one here
    if (iNumUnalignedStartALL & 1)
        piSource += 1;

    // Finish off the unaligned samples
    NTapFIR_Unaligned_MMX(rgiCoefNum, piSource, iNumUnalignedEnd, rgiSrc,
        piFIROut, cChannel, 4);
} // FourTapNUMERATOR_MMX_STEREO


void INLINE
FiveTapNUMERATOR_MMX_STEREO
                      (const I16 *rgiCoefNum,
                       const I16 *piSource, I16* rgiSrc, I32 *piSrcCurr,
                       const Int iSourceLength,
                       I32 *piFIROutAligned, const I32 c_iAlignMultiple,
                       I16 *piMMXCoefs, const I32 iSizeOfMMXCoefs)
{
    const int cChannel = 2;

    Int iSrcCurr = *piSrcCurr;

    I32    *piFIROut = piFIROutAligned;
    I32     iShiftLeft;

    int     iNumUnalignedStart;             // Number of unaligned samples at start of block
    int     iNumUnalignedStartALL;          // Unaligned samples at start including other channel's
    int     iNumUnalignedEnd;               // Number of unaligned samples at end of block
    int     iAlignedBlocksOfFour;           // Number of aligned blocks of 4 samples

    // Determine number of aligned, unaligned samples
    assert(((c_iAlignMultiple - 1) & c_iAlignMultiple) == 0); // Pure power of 2
    iNumUnalignedStartALL = ((((U32) piSource + c_iAlignMultiple - 1) & ~(c_iAlignMultiple - 1)) -
        (U32) piSource) / sizeof(*piSource);
    iNumUnalignedStart = (iNumUnalignedStartALL + 1) / cChannel;
    iAlignedBlocksOfFour = (iSourceLength - iNumUnalignedStart) / 4; // DIV 4
    iNumUnalignedEnd = (iSourceLength - iNumUnalignedStart) & (4-1); // MOD 4

    // FIRST, calculate unaligned start samples
    NTapFIR_Unaligned_MMX(rgiCoefNum, piSource, iNumUnalignedStart, rgiSrc,
        piFIROut, cChannel, 5);
    piSource += iNumUnalignedStartALL;
    assert(0 == (((U32)piSource) & (c_iAlignMultiple -1)));
    piFIROut += iNumUnalignedStart;

    // Set up staggered MMX coefficient arrays, then go MMX for aligned inputs
    // Align staggered MMX coefficient array on 32-byte boundary

    // Perf tests indicate that initializing MMX coefs EVERY TIME is slightly
    // faster than init once and much faster than hard-coded tables or
    // pre-initialized. Strange but true. Mem alignment is definitely a factor.

    InitMMXFilterCoefs(piMMXCoefs, iSizeOfMMXCoefs, rgiCoefNum, 5);
    if (iNumUnalignedStartALL & 1)
    {
        // ODD # samples from piSource to align point,
        // we use sizeof(I16) offset from align
        iShiftLeft = 0; // Desired input will get read into slots 1,3
    }
    else
    {
        // EVEN # samples from piSource to align point,
        // we use 0 offset from align
        iShiftLeft = 16; // Desired input will get read into slots 0,2
    }

    assert(0 == ((U32)piFIROut & 1)); // Verify we're on a DWORD boundary
    assert(0 == *piSrcCurr); // MMX history matches input order, it's NOT a doubled history

#define iShiftLeftASM   eax
#define piFIROutput     ebx
#define iLoopCtr        ecx
#define piSrcHistory    edx
#define piSrc           esi
#define piMMXCoefsASM   edi

#define SIZEOF_I16      2
#define SIZEOF_I32      4

    _asm
    {
        mov         iShiftLeftASM, iShiftLeft
        mov         iLoopCtr, iAlignedBlocksOfFour  // Load the index ctr
        mov         piSrcHistory, rgiSrc
        mov         piSrc, piSource
        movq        mm7, [piSrcHistory]                 // Oldest 4 samples (history): unaligned, but only done once
        mov         piFIROutput, piFIROut
        mov         piMMXCoefsASM, piMMXCoefs

        movq        mm2, [piMMXCoefsASM + SIZEOF_I16*0] // Load 1-offset coefs (part 1)
        movq        mm3, [piMMXCoefsASM + SIZEOF_I16*4] // Load 1-offset coefs (part 2)

MMXLOOP:
        // We used to pre-load input. DON'T DO THIS, last iteration can read past valid memory
        movq        mm5, [piSrc + 0*SIZEOF_I16]         // Load in the input
        movq        mm4, [piSrc + 4*SIZEOF_I16]

        // Throw away the samples we don't want to construct next input vector
        pxor        mm1, mm1                    // Zero it
        movd        mm1, iShiftLeftASM
        movq        mm6, mm5
        pslld       mm6, mm1                    // Shift left by 16 or 0
        psrad       mm6, 16                     // Shift right is always 16
        pslld       mm4, mm1                    // Shift left by 16 or 0
        psrad       mm4, 16                     // Shift right is always 16
        packssdw    mm6, mm4                    // Combine the results to get 4 inputs

        // ---INTERATION 0---
        movq        mm1, mm7                            // Copy oldest history
        pmaddwd     mm1, mm2                            // MADD oldest history w/ 1-offset coefs
        movq        mm0, mm6                            // Copy current input vector
        pmaddwd     mm0, mm3                            // MADD current input vector
        paddd       mm0, mm1                            // Sum mm1 + mm0 results
        movq        mm1, mm0                            // Now sum horizontally: HI32(mm0) + LO32(mm0)
        psrlq       mm0, 32
        paddd       mm0, mm1

        movd        [piFIROutput + SIZEOF_I32*0], mm0   // Output results


        // ---INTERATION 1---
        movq        mm1, mm7                            // Copy oldest history
        pmaddwd     mm1, [piMMXCoefsASM + SIZEOF_I16*8] // MADD oldest history w/ 2-offset coefs
        movq        mm0, mm6                            // Copy current input vector
        pmaddwd     mm0, [piMMXCoefsASM + SIZEOF_I16*12]// MADD current input vector
        paddd       mm0, mm1                            // Sum mm1 + mm0 results
        movq        mm1, mm0                            // Now sum horizontally: HI32(mm0) + LO32(mm0)
        psrlq       mm0, 32
        paddd       mm0, mm1

        movd        [piFIROutput + SIZEOF_I32*1], mm0   // Output results


        // ---INTERATION 2---
        movq        mm1, mm7                            // Copy oldest history
        pmaddwd     mm1, [piMMXCoefsASM + SIZEOF_I16*16]// MADD oldest history w/ 3-offset coefs
        movq        mm0, mm6                            // Copy current input vector
        pmaddwd     mm0, [piMMXCoefsASM + SIZEOF_I16*20]// MADD current input vector
        paddd       mm0, mm1                            // Sum mm1 + mm0 results
        movq        mm1, mm0                            // Now sum horizontally: HI32(mm0) + LO32(mm0)
        psrlq       mm0, 32
        paddd       mm0, mm1

        movd        [piFIROutput + SIZEOF_I32*2], mm0   // Output results


        // ---INTERATION 3---
        movq        mm1, mm7                            // Copy oldest history
        pmaddwd     mm1, [piMMXCoefsASM + SIZEOF_I16*24]// MADD oldest history w/ 4-offset coefs
        movq        mm0, mm6                            // Copy current input vector
        pmaddwd     mm0, [piMMXCoefsASM + SIZEOF_I16*28]// MADD current input vector
        paddd       mm0, mm1                            // Sum mm1 + mm0 results
        movq        mm1, mm0                            // Now sum horizontally: HI32(mm0) + LO32(mm0)
        psrlq       mm0, 32
        paddd       mm0, mm1

        movd        [piFIROutput + SIZEOF_I32*3], mm0   // Output results


        // Load next input, decrement ctrs, advance ptrs and loop around
        add         piSrc, 8*SIZEOF_I16
        add         piFIROutput, 4*SIZEOF_I32
        dec         iLoopCtr
        movq        mm7, mm6                    // Current input vector is now history

        jnz         MMXLOOP

        // End of loop
        movq        [piSrcHistory], mm7                 // Oldest 4 samples (history): unaligned, but only done once
        em