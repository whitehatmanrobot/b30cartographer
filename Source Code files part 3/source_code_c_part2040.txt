ROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86_dbaccessor_no-public-key_12.4.56.0_x-ww_3b09b0bb
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86_dbaccessor_no-public-key_12.4.56.0_x-ww_3b09b0bb.manifest
XP_MANIFEST_PATH=manifests\x86_dbaccessor_no-public-key_12.4.56.0_x-ww_3b09b0bb.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86_dbaccessor_no-public-key_12.4.56.0_x-ww_3b09b0bb.cat
XP_CATALOG_PATH=manifests\x86_dbaccessor_no-public-key_12.4.56.0_x-ww_3b09b0bb.cat
XP_PAYLOAD_PATH=x86_dbaccessor_no-public-key_12.4.56.0_x-ww_3b09b0bb
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=dbaccessor,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\genealogy\geneadmin\genecommon\DBControl.h ===
#undef DEF_BINDPARAM_IN
#undef DEF_BINDPARAMOPT_IN
#undef DEF_BINDPARAM_INOUT
#undef DEF_BINDPARAM_OUT
#undef DEF_BINDPARAMSAFE_IN
#undef DEF_BINDPARAMSAFE_INOUT
#undef DEF_BINDPARAMSAFE_OUT
#undef DEF_BINDPARAMSEQ_IN
#undef DEF_BINDPARAMSEQ_INOUT
#undef DEF_BINDPARAMSEQ_OUT
#undef DEF_BINDCOL
#undef DEF_BINDCOLSEQ

#ifdef DOBINDINGS
#define DEF_BINDPARAM_IN(stmt, col, type, varname, target)    \
    if(!DBStmtBindParam(stmt, col, PARAM_IO_INPUT, &varname)) goto target;
#define DEF_BINDPARAMOPT_IN(stmt, col, type, varname, varoptname, target)    \
    if(!DBStmtBindParam(stmt, col, PARAM_IO_INPUT, &varname, &varoptname)) goto target;
#define DEF_BINDPARAM_INOUT(stmt, col, type, varname, varoptname, target)    \
    if(!DBStmtBindParam(stmt, col, PARAM_IO_INPUT_OUTPUT, &varname, &varoptname)) goto target;
#define DEF_BINDPARAM_OUT(stmt, col, type, varname, varoptname, target)    \
    if(!DBStmtBindParam(stmt, col, PARAM_IO_OUTPUT, &varname, &varoptname)) goto target;

#define DEF_BINDPARAMSAFE_IN(stmt, col, varname, size, varoptname, target)                      \
    varoptname = size;                                                                          \
    if(!DBStmtBindParamSeq(stmt, col, PARAM_IO_INPUT, (CHAR *) ((const CHAR *) varname), &varoptname)) goto target;
#define DEF_BINDPARAMSAFE_INOUT(stmt, col, varname, size, varoptname, target)                   \
    varoptname = size;                                                                          \
    if(!DBStmtBindParamSeq(stmt, col, PARAM_IO_INPUT_OUTPUT, (CHAR *) ((const CHAR *) varname), &varoptname)) goto target;
#define DEF_BINDPARAMSAFE_OUT(stmt, col, varname, size, varoptname, target)                     \
    varoptname = size;                                                                          \
    if(!DBStmtBindParamSeq(stmt, col, PARAM_IO_OUTPUT, (CHAR *) ((const CHAR *) varname), &varoptname)) goto target;
    
#define DEF_BINDPARAMSEQ_IN(stmt, col, type, varname, size, varoptname, target)                 \
    varoptname = sizeof(type) * size;                                                           \
    if(!DBStmtBindParamSeq(stmt, col, PARAM_IO_INPUT, varname, &varoptname)) goto target;
#define DEF_BINDPARAMSEQ_INOUT(stmt, col, type, varname, size, varoptname, target)              \
    varoptname = sizeof(type) * size;                                                           \
    if(!DBStmtBindParamSeq(stmt, col, PARAM_IO_INPUT_OUTPUT, varname, &varoptname)) goto target;
#define DEF_BINDPARAMSEQ_OUT(stmt, col, type, varname, size, varoptname, target)                \
    varoptname = sizeof(type) * size;                                                           \
    if(!DBStmtBindParamSeq(stmt, col, PARAM_IO_OUTPUT, varname, &varoptname)) goto target;

#define DEF_BINDCOL(stmt, col, type, varname, varoptname, target)     \
    varoptname = sizeof(type);                              \
    if(!DBStmtBindCol(stmt, col, &varname, &varoptname)) goto target;
#define DEF_BINDCOLSEQ(stmt, col, type, varname, size, varoptname, target)     \
    varoptname = sizeof(type) * size;                               \
    if(!DBStmtBindCol(stmt, col, varname, size, &varoptname)) goto target;

// #endif // DOBINDINGS
#elif defined(DODECLARATIONS)
#define DEF_BINDPARAM_IN(stmt, col, type, varname, target)    \
    public: type varname;
#define DEF_BINDPARAMOPT_IN(stmt, col, type, varname, varoptname, target)    \
    public: type varname; int varoptname;
#define DEF_BINDPARAM_INOUT(stmt, col, type, varname, varoptname, target)    \
    public: type varname; int varoptname;
#define DEF_BINDPARAM_OUT(stmt, col, type, varname, varoptname, target)    \
    public: type varname; int varoptname;

#define DEF_BINDPARAMSAFE_IN(stmt, col, varname, size, varoptname, target)                      \
    public: TSafeStr<size> varname; DWORD varoptname;
#define DEF_BINDPARAMSAFE_INOUT(stmt, col, varname, size, varoptname, target)                   \
    public: TSafeStr<size> varname; DWORD varoptname;
#define DEF_BINDPARAMSAFE_OUT(stmt, col, varname, size, varoptname, target)                     \
    public: TSafeStr<size> varname; DWORD varoptname;

#define DEF_BINDPARAMSEQ_IN(stmt, col, type, varname, size, varoptname, target)    \
    public: type varname[size]; DWORD varoptname;
#define DEF_BINDPARAMSEQ_INOUT(stmt, col, type, varname, size, varoptname, target)    \
    public: type varname[size]; DWORD varoptname;
#define DEF_BINDPARAMSEQ_OUT(stmt, col, type, varname, size, varoptname, target)    \
    public: type varname[size]; DWORD varoptname;

#define DEF_BINDCOL(stmt, col, type, varname, varoptname, target) \
    public: type varname; DWORD varoptname;
#define DEF_BINDCOLSEQ(stmt, col, type, varname, size, varoptname, target) \
    public: type varname[size]; DWORD varoptname;
//#endif // DODECLARATIONS
#elif defined(DOINITIALIZATION)
#define DEF_BINDPARAM_IN(stmt, col, type, varname, target)    \
    memset(&varname, 0, sizeof(type));
#define DEF_BINDPARAMOPT_IN(stmt, col, type, varname, varoptname, target)    \
    memset(&varname, 0, sizeof(type)); varoptname = 0;
#define DEF_BINDPARAM_INOUT(stmt, col, type, varname, varoptname, target)    \
    memset(&varname, 0, sizeof(type)); varoptname = 0;
#define DEF_BINDPARAM_OUT(stmt, col, type, varname, varoptname, target)    \
    memset(&varname, 0, sizeof(type)); varoptname = 0;

#define DEF_BINDPARAMSAFE_IN(stmt, col, varname, size, varoptname, target)                      \
    varname = ""; varoptname = 0; varname.AllowTruncate(TRUE);
#define DEF_BINDPARAMSAFE_INOUT(stmt, col, varname, size, varoptname, target)                   \
    varname = ""; varoptname = 0; varname.AllowTruncate(TRUE);
#define DEF_BINDPARAMSAFE_OUT(stmt, col, varname, size, varoptname, target)                     \
    varname = ""; varoptname = 0; varname.AllowTruncate(TRUE);

#define DEF_BINDPARAMSEQ_IN(stmt, col, type, varname, size, varoptname, target)    \
    memset(&varname, 0, size * sizeof(type)); varoptname = 0;
#define DEF_BINDPARAMSEQ_INOUT(stmt, col, type, varname, size, varoptname, target)    \
    memset(&varname, 0, size * sizeof(type)); varoptname = 0;
#define DEF_BINDPARAMSEQ_OUT(stmt, col, type, varname, size, varoptname, target)    \
    memset(&varname, 0, size * sizeof(type)); varoptname = 0;

#define DEF_BINDCOL(stmt, col, type, varname, varoptname, target) \
    memset(&varname, 0, sizeof(type)); varoptname = 0;
#define DEF_BINDCOLSEQ(stmt, col, type, varname, size, varoptname, target) \
    memset(&varname, 0, size * sizeof(type)); varoptname = 0;
#endif // DOINITIALIZATION


#undef DODECLARATIONS
#undef DOBINDINGS
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\genealogy\geneadmin\genecommon\eventing.h ===
#pragma once

#ifndef CALL_TYPE
#define CALL_TYPE __stdcall
#endif // CALL_TYPE

#define EVENT_GENE_BEGIN_FILE_PROCESSING    0xC001
#define EVENT_GENE_FINISHED_FILE_PROCESSING 0xC002
#define EVENT_GENE_FILE_COPIED              0xC004

#define EVENT_GENE_SEARCH_FAILED                    0xC008
#define EVENT_GENE_FILEOPEN_FAILED                  0xC009
#define EVENT_GENE_FILECOPY_FAILED                  0xC00A
#define EVENT_GENE_FILEMOVE_FAILED                  0xC00B
#define EVENT_GENE_FILEDELETE_FAILED                0xC00D
#define EVENT_GENE_FILECREATE_FAILED                0xC00E
#define EVENT_GENE_FILEMAPPING_FAILED               0xC00F
#define EVENT_GENE_INVALID_PATH                     0xC010
#define EVENT_GENE_PARSE_FAILED                     0xC011
#define EVENT_GENE_FILE_PROCESSING_FAILED           0xC012
#define EVENT_GENE_INVALID_PARAMETER                0xC013

#define EVENT_GENE_SERVICE_CRITICAL_FAILURE         0xC201
#define EVENT_GENE_SERVICE_BAD_COMMAND              0xC202
#define EVENT_GENE_SERVICE_STARTED                  0xC203
#define EVENT_GENE_SERVICE_STOPPED                  0xC204


void   CALL_TYPE SetEventSource(const CHAR *szSource);
DWORD _cdecl LogEvent(WORD wSeverity, WORD wMessageID, const CHAR *szFmt, ...);
DWORD CALL_TYPE AddEventSource(const CHAR *szParentLog, const CHAR *szEventSourceName, const CHAR *szFileName = 0);
DWORD CALL_TYPE RemoveEventSource(const CHAR *szParentLog, const CHAR *szEventSourceName);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\genealogy\geneadmin\genecommon\eventing.cpp ===
#include <windows.h>
#include <stdio.h>
#include <assert.h>
#include <malloc.h>
#include "strcls.h"
#include "eventing.h"


static TSafeStr<50> s_szEventSource;

void CALL_TYPE SetEventSource(const CHAR *szSource)
{
    s_szEventSource = szSource;
}

DWORD _cdecl LogEvent(WORD wSeverity, WORD wMessageID, const CHAR *szFmt, ...)
{
    CSafeStr msg(8192);
    va_list varargs;
    DWORD dwRes = 0;
    HANDLE  hEventSource = 0;
    LPCSTR  lpszStrings[1];

    va_start(varargs, szFmt);
    msg.VAFormatText(szFmt, varargs);
    va_end(varargs);

    lpszStrings[0] = msg;

    // Ensure we have a source
    assert((bool) s_szEventSource);

    /* Get a handle to use with ReportEvent(). */
    hEventSource = RegisterEventSourceA(NULL, s_szEventSource);
    if (hEventSource != NULL)
    {
        /* Write to event log. */
        if(!ReportEventA(hEventSource, wSeverity, 0, wMessageID, NULL, 1, 0, lpszStrings, NULL))
            goto DebugString;
    }
    else
    {
DebugString:
        // As we failed to log an event, try a debug string.
        dwRes = GetLastError();
        OutputDebugStringA(msg);
        OutputDebugStringA("\n");
    }

    if(hEventSource)
        DeregisterEventSource(hEventSource);
    return dwRes;
}

DWORD CALL_TYPE AddEventSource(const CHAR *szParentLog, const CHAR *szEventSourceName, DWORD dwCatCount, const CHAR *szFileName)
{
    HKEY hk = 0; 
    DWORD dwData, dwLen, dwErr = 0; 
    CHAR szBuf[256]; 
    CHAR szFile[MAX_PATH];
 
    // Add your source name as a subkey under the Application 
    // key in the EventLog registry key. 
    if(!szFileName)
    {
        if(!GetModuleFileNameA( NULL, szFile, MAX_PATH ))
            return GetLastError();
        dwLen = strlen(szFile);
    }
    else
    {
        dwLen = strlen(szFileName);
        if(dwLen > MAX_PATH - 1)
            return ERROR_LABEL_TOO_LONG;
        strncpy(szFile, szFileName, dwLen);
        szFile[dwLen] = 0;
    }
    _snprintf(szBuf, sizeof(szBuf) - 1, "SYSTEM\\CurrentControlSet\\Services\\EventLog\\%s\\%s", szParentLog, szEventSourceName);
    if (RegCreateKeyA(HKEY_LOCAL_MACHINE, szBuf, &hk)) 
    {
        hk = 0;
        dwErr = GetLastError(); 
        goto Exit;
    }
 
    // Set the name of the message file. 
 
    // Add the name to the EventMessageFile subkey. 
 
    if (RegSetValueExA(hk,             // subkey handle 
            "EventMessageFile",       // value name 
            0,                        // must be zero 
            REG_EXPAND_SZ,            // value type 
            (LPBYTE) szFile,           // pointer to value data 
            dwLen + 1))       // length of value data 
    {
        dwErr = GetLastError(); 
        goto Exit;
    }
 
    // Set the supported event types in the TypesSupported subkey. 
 
    dwData = EVENTLOG_ERROR_TYPE | EVENTLOG_WARNING_TYPE | 
        EVENTLOG_INFORMATION_TYPE; 
 
    if (RegSetValueExA(hk,      // subkey handle 
            "TypesSupported",  // value name 
            0,                 // must be zero 
            REG_DWORD,         // value type 
            (LPBYTE) &dwData,  // pointer to value data 
            sizeof(DWORD)))    // length of value data 
    {
        dwErr = GetLastError();
        goto Exit;
    } 

    if (RegSetValueExA(hk,       // subkey handle
            "CategoryCount",    // value name
            0,                  // reserved
            REG_DWORD,          // type
            (LPBYTE) &dwCatCount,   // value
            sizeof(DWORD)))     // size
    {
        dwErr = GetLastError();
        goto Exit;
    }

Exit:
    if(hk)
        RegCloseKey(hk); 
    return dwErr;
} 

DWORD CALL_TYPE RemoveEventSource(const CHAR *szParentLog, const CHAR *szEventSourceName)
{
    CHAR szBuf[256]; 
 
    // Add your source name as a subkey under the Application 
    // key in the EventLog registry key. 
 
    _snprintf(szBuf, sizeof(szBuf) - 1, "SYSTEM\\CurrentControlSet\\Services\\EventLog\\%s\\%s", szParentLog, szEventSourceName);
    szBuf[sizeof(szBuf) - 1] = 0;
    if (RegDeleteKeyA(HKEY_LOCAL_MACHINE, szBuf)) 
        return GetLastError(); 

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\genealogy\geneadmin\genecommon\mappedfile.h ===
#pragma once

class CMappedFile
{
public:
    CMappedFile();
    ~CMappedFile();

    // Maps a file to memory, returning the address of the first mapped chunk.
    PVOID MapFile(const CHAR *szFileName, bool fReadOnly = false);

    // Returns the last error that occurred
    DWORD GetLastError();

    // Closes the file
    VOID Close();

    // Returns the address of the currently mapped chunk
    PVOID GetAddr();

    // Returns the size of the entire file
    DWORDLONG GetFileSize();

    // Returns the size of the current chunk of the file mapped
    DWORD GetMappedSize();
    
    // Returns the offset into the file where the current chunk is mapped
    DWORDLONG GetMapOffset();

    // Returns the address to the next file chunk, zero on error or end of file
    PVOID MapNextFileChunk();

    // Returns the address to the file chunk mapped starting from the offset specified relative to the entire file
    PVOID MapNextFileChunkFrom(const DWORDLONG& dwlOffset);

    // Returns the address to the file chunk mapped starting from the offset specified relative to the current position
    PVOID MapNextFileChunkFromCurrent(const DWORD& dwOffset);

protected:
    // Resets the variables
    void Reset();

    bool m_fReadOnly;
    HANDLE m_hFile;
    HANDLE m_hMap;
    PVOID  m_addr;
    DWORDLONG m_dwlSize;
    DWORD m_dwError;
    DWORD m_dwMappedSize;
    DWORDLONG m_dwlOffset;
    DWORD m_dwGranularity;
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\genealogy\geneadmin\genecommon\search.cpp ===
#undef UNICODE

#include <windows.h>
#include "search.h"

CFileSearch::CFileSearch()
{
    m_hSearch = INVALID_HANDLE_VALUE;
    m_fFirst = FALSE;
    m_dwError = 0;
}

CFileSearch::~CFileSearch()
{
    Cleanup();
}

BOOL CFileSearch::Start(const CHAR *szSearch)
{
    Cleanup();
    memset(&m_wfd, 0, sizeof(WIN32_FIND_DATA));
    m_dwError = 0;
    m_hSearch = FindFirstFileA(szSearch, &m_wfd);
    if(!m_hSearch || INVALID_HANDLE_VALUE == m_hSearch)
    {
        m_dwError = ::GetLastError();
        return FALSE;
    }

    m_fFirst = TRUE;
    return TRUE;
}

BOOL CFileSearch::GetNext()
{
    if(!m_hSearch || INVALID_HANDLE_VALUE == m_hSearch)
        return FALSE;
    
    if(m_fFirst)
    {
        m_fFirst = FALSE;
        return TRUE;
    }

    m_dwError = 0;
    memset(&m_wfd, 0, sizeof(WIN32_FIND_DATA));
    if(!FindNextFile(m_hSearch, &m_wfd))
    {
        m_dwError = ::GetLastError();
        return FALSE;
    }
    return TRUE;
}

VOID CFileSearch::Cleanup()
{
    if(m_hSearch && INVALID_HANDLE_VALUE != m_hSearch)
    {
        FindClose(m_hSearch);
    }

    m_hSearch = INVALID_HANDLE_VALUE;
    m_fFirst = FALSE;
    m_dwError = 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\genealogy\geneadmin\genecommon\key.h ===
#pragma once

#define EVENT_GENE_REGKEY_OPEN_FAILED           0xC101
#define EVENT_GENE_REGKEY_SET_FAILED            0xC102
#define EVENT_GENE_REGKEY_QUERY_FAILED          0xC103
#define EVENT_GENE_REGKEY_TYPE_MISMATCH         0xC104
#define EVENT_GENE_REGKEY_ENUM_FAILED           0xC105

class CKey
{
public:
    CKey();
    CKey(HKEY hKey);
    CKey(const CKey &cKey);

    ~CKey();

    CKey& operator=(const CKey &cKey);
    CKey& operator=(HKEY hKey);

    inline operator HKEY() const {return m_hKey;}
    inline operator BOOL() const {return m_hKey != NULL;}
    inline operator bool() const {return m_hKey != NULL;}

    inline LONG GetLastError() const {return m_err;}
    inline BOOL IsGood() const {return m_hKey != NULL;}

    LONG Open(const HKEY hKey, const CHAR *szKey, REGSAM sd = KEY_ALL_ACCESS);
    LONG Open(const HKEY hKey, const WCHAR *szKey, REGSAM sd = KEY_ALL_ACCESS);

    LONG ReOpen(REGSAM sd = KEY_ALL_ACCESS);

    LONG SetValue(const CHAR *szValueName, DWORD dwValue);
    LONG SetValue(const WCHAR *szValueName, DWORD dwValue);

    LONG SetValue(const CHAR *szValueName, const CHAR *szBuffer, DWORD dwSize, DWORD dwType = REG_SZ);
    LONG SetValue(const WCHAR *szValueName, const CHAR *szBuffer, DWORD dwSize, DWORD dwType = REG_SZ);

    BOOL ExistValue(const CHAR *szValueName);
    BOOL ExistValue(const WCHAR *szValueName);
    
    LONG QueryValue(const CHAR *szValueName, DWORD &dwValue);
    LONG QueryValue(const WCHAR *szValueName, DWORD &dwValue);

    LONG QueryValue(const CHAR *szValueName, CHAR *szBuffer, DWORD &dwSize, DWORD &dwType);
    LONG QueryValue(const WCHAR *szValueName, CHAR *szBuffer, DWORD &dwSize, DWORD &dwType);

    LONG EnumerateKeys(DWORD dwIndex, CHAR *szName, DWORD &dwSize);
    LONG EnumerateKeys(DWORD dwIndex, WCHAR *szName, DWORD &dwSize);

    LONG EnumerateValues(DWORD dwIndex, CHAR *szName, DWORD &dwSize, DWORD &dwType);
    LONG EnumerateValues(DWORD dwIndex, WCHAR *szName, DWORD &dwSize, DWORD &dwType);

    BOOL TestValue(const CHAR *szValueName, const CHAR *szValue, DWORD dwSize, BOOL fRetValIfNotFound = FALSE);
    BOOL TestValue(const WCHAR *szValueName, const CHAR *szValue, DWORD dwSize, BOOL fRetValIfNotFound = FALSE);

    VOID Close();

protected:
    HKEY m_hKey;
    LONG m_err;
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\genealogy\geneadmin\genecommon\mappedfile.cpp ===
#include <windows.h>
#include "eventing.h"
#include "mappedfile.h"

#define CHUNK_SIZE  1048576

inline DWORD HIDWORD(const DWORDLONG &dwl)
{
    return (DWORD) (dwl >> 32);
}

inline DWORD LODWORD(const DWORDLONG &dwl)
{
    return (DWORD) (dwl & 0xFFFFFFFF);
}

inline DWORDLONG MAKEDWORDLONG(const DWORD dwHi, const DWORD dwLo)
{
    DWORDLONG dwl = dwHi;
    dwl <<= 32;
    dwl += dwLo;
    return dwl;
}

CMappedFile::CMappedFile()
{
    Reset();
}

CMappedFile::~CMappedFile()
{
    Close();
}

PVOID CMappedFile::MapFile(const CHAR *szFileName, bool fReadOnly)
{
    DWORD dwHi, dwLo, dwError;
    SYSTEM_INFO sysInfo;
    Close();

    GetSystemInfo(&sysInfo);
    m_dwGranularity = sysInfo.dwAllocationGranularity;

    m_hFile = CreateFileA(szFileName, GENERIC_READ | ((fReadOnly) ? 0 : GENERIC_WRITE), 0, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
    if(!m_hFile || INVALID_HANDLE_VALUE == m_hFile)
    {
        dwError = GetLastError();
        LogEvent(EVENTLOG_ERROR_TYPE, EVENT_GENE_FILEOPEN_FAILED, "Could not open \"%s\" for reading.  Error code: %d", szFileName, dwError);
        goto Error;
    }

    dwLo = ::GetFileSize(m_hFile, &dwHi);
    m_dwlSize = MAKEDWORDLONG(dwHi, dwLo);

    m_hMap = CreateFileMapping(m_hFile, NULL, (fReadOnly) ? PAGE_READONLY : PAGE_READWRITE, dwHi, dwLo, NULL);
    if(!m_hMap || INVALID_HANDLE_VALUE == m_hMap)
    {
        dwError = GetLastError();
        LogEvent(EVENTLOG_ERROR_TYPE, EVENT_GENE_FILEMAPPING_FAILED, "Could not create a file mapping for \"%s\".  Error code: %d", szFileName, dwError);
        goto Error;
    }

    m_dwMappedSize = (DWORD) min(m_dwlSize, CHUNK_SIZE);
    m_dwlOffset = 0;
    m_addr = MapViewOfFile(m_hMap, (fReadOnly) ? FILE_MAP_READ : FILE_MAP_WRITE, 0, 0, m_dwMappedSize);
    if(!m_addr)
    {
        dwError = GetLastError();
        LogEvent(EVENTLOG_ERROR_TYPE, EVENT_GENE_FILEMAPPING_FAILED, "Could not map a view of the file \"%s\".  Error code: %d", szFileName, dwError);
        goto Error;
    }
    m_fReadOnly = fReadOnly;

    return m_addr;
Error:
    Close();
    m_dwError = dwError;
    return 0;
}

DWORD CMappedFile::GetLastError()
{
    return m_dwError;
}

VOID CMappedFile::Close()
{
    if(m_hMap && INVALID_HANDLE_VALUE != m_hMap)
    {
        UnmapViewOfFile(m_addr);
        CloseHandle(m_hMap);
    }
    if(m_hFile && INVALID_HANDLE_VALUE != m_hFile)
        CloseHandle(m_hFile);

    Reset();
}

void CMappedFile::Reset()
{
    m_hFile = INVALID_HANDLE_VALUE;
    m_hMap = INVALID_HANDLE_VALUE;
    m_addr = 0;
    m_dwlSize = 0;
    m_dwError = 0;
    m_dwMappedSize = 0;
    m_dwlOffset = 0;
    m_dwGranularity = 0;
    m_fReadOnly = 0;
}

DWORDLONG CMappedFile::GetFileSize()
{
    return m_dwlSize;
}

DWORD CMappedFile::GetMappedSize()
{
    return m_dwMappedSize;
}

// Returns the offset into the file where the current chunk is mapped
DWORDLONG CMappedFile::GetMapOffset()
{
    return m_dwlOffset;
}

// Returns the address to the next file chunk, zero on error or end of file
PVOID CMappedFile::MapNextFileChunk()
{
    DWORDLONG dwlOffset = m_dwlOffset + m_dwMappedSize;
    return MapNextFileChunkFrom(dwlOffset);
}

// Returns the address to the file chunk mapped starting from the offset specified relative to the entire file
PVOID CMappedFile::MapNextFileChunkFrom(const DWORDLONG& dwlOffset)
{
    DWORDLONG dwlOff = dwlOffset;
    if(m_hMap && INVALID_HANDLE_VALUE != m_hMap)
    {
        if(dwlOff > m_dwlSize)
            return 0;

        dwlOff -= dwlOff % m_dwGranularity;
        UnmapViewOfFile(m_addr);
        
        m_dwMappedSize = (DWORD) min(m_dwlSize - dwlOff, CHUNK_SIZE);
        if(m_dwMappedSize)
        {
            m_addr = MapViewOfFile(m_hMap, (m_fReadOnly) ? FILE_MAP_READ : FILE_MAP_WRITE, HIDWORD(dwlOff), LODWORD(dwlOff), m_dwMappedSize);
            if(!m_addr)
            {
                m_dwError = GetLastError();
                LogEvent(EVENTLOG_ERROR_TYPE, EVENT_GENE_FILEMAPPING_FAILED, "Could not map a new view of the file.  Error code: %d", m_dwError);
            }
            else
            {
                m_dwlOffset = dwlOff;
            }
        }
        else
            m_addr = 0;
        return m_addr;
    }

    return 0;
}

// Returns the address to the file chunk mapped starting from the offset specified relative to the current position
PVOID CMappedFile::MapNextFileChunkFromCurrent(const DWORD& dwOffset)
{
    DWORDLONG dwlOffset = m_dwlOffset + dwOffset;
    return MapNextFileChunkFrom(dwlOffset);
}

PVOID CMappedFile::GetAddr()
{
    return m_addr;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\genealogy\geneadmin\genecommon\key.cpp ===
#include <windows.h>
#include <malloc.h>
#include "key.h"
#include "eventing.h"

CKey::CKey()
{
    m_hKey = NULL;
    m_err = 0;
}

CKey::CKey(HKEY hKey)
{
    m_err = RegOpenKey(hKey, NULL, &m_hKey);
    if(m_err)
    {
        LogEvent(EVENTLOG_ERROR_TYPE, EVENT_GENE_REGKEY_OPEN_FAILED, "Could not reopen a registry key.  Error code: %d", m_err);
        m_hKey = NULL;
    }
}

CKey::CKey(const CKey &cKey)
{
    m_err = RegOpenKey(cKey, NULL, &m_hKey);
    if(m_err)
    {
        LogEvent(EVENTLOG_ERROR_TYPE, EVENT_GENE_REGKEY_OPEN_FAILED, "Could not reopen a registry key.  Error code: %d", m_err);
        m_hKey = NULL;
    }
}


CKey::~CKey()
{
    if(m_hKey)
    {
        RegCloseKey(m_hKey);
    }
}

CKey& CKey::operator=(const CKey &cKey)
{
    Close();
    m_err = RegOpenKey(cKey, NULL, &m_hKey);
    if(m_err)
    {
        LogEvent(EVENTLOG_ERROR_TYPE, EVENT_GENE_REGKEY_OPEN_FAILED, "Could not reopen a registry key.  Error code: %d", m_err);
        m_hKey = NULL;
    }

    return *this;
}

CKey& CKey::operator=(HKEY hKey)
{
    Close();
    m_err = RegOpenKey(hKey, NULL, &m_hKey);
    if(m_err)
    {
        LogEvent(EVENTLOG_ERROR_TYPE, EVENT_GENE_REGKEY_OPEN_FAILED, "Could not reopen a registry key.  Error code: %d", m_err);
        m_hKey = NULL;
    }

    return *this;
}


LONG CKey::Open(const HKEY hKey, const CHAR *szKey, REGSAM sd)
{
    Close();
    m_err = RegOpenKeyExA(hKey, szKey, 0, sd, &m_hKey);
    if(m_err)
    {
        LogEvent(EVENTLOG_ERROR_TYPE, EVENT_GENE_REGKEY_OPEN_FAILED, "Could not open the registry key \"%s\".  Error code: %d", szKey, m_err);
    }
    return m_err;
}

LONG CKey::Open(const HKEY hKey, const WCHAR *szKey, REGSAM sd)
{
    Close();
    m_err = RegOpenKeyExW(hKey, szKey, 0, sd, &m_hKey);
    if(m_err)
    {
        LogEvent(EVENTLOG_ERROR_TYPE, EVENT_GENE_REGKEY_OPEN_FAILED, "Could not open the registry key \"%S\".  Error code: %d", szKey, m_err);
    }
    return m_err;
}

LONG CKey::ReOpen(REGSAM sd)
{
    HKEY hKey = m_hKey;
    m_err = RegOpenKeyEx(hKey, 0, 0, sd, &m_hKey);
    if(m_err)
    {
        LogEvent(EVENTLOG_ERROR_TYPE, EVENT_GENE_REGKEY_OPEN_FAILED, "Could not reopen the registry key with new ACLs.  Error code: %d", m_err);
        m_hKey = hKey;
        return m_err;
    }

    RegCloseKey(hKey);
    return m_err;
}

LONG CKey::SetValue(const CHAR *szValueName, DWORD dwValue)
{
    m_err = RegSetValueExA(m_hKey, szValueName, 0, REG_DWORD, (LPBYTE) &dwValue, sizeof(DWORD));
    if(m_err)
    {
        LogEvent(EVENTLOG_ERROR_TYPE, EVENT_GENE_REGKEY_SET_FAILED, "Could not set \"%s\" to value %d in the registry.  Error code: %d", szValueName, dwValue, m_err);
    }
    return m_err;
}

LONG CKey::SetValue(const WCHAR *szValueName, DWORD dwValue)
{
    m_err = RegSetValueExW(m_hKey, szValueName, 0, REG_DWORD, (LPBYTE) &dwValue, sizeof(DWORD));
    if(m_err)
    {
        LogEvent(EVENTLOG_ERROR_TYPE, EVENT_GENE_REGKEY_SET_FAILED, "Could not set \"%S\" to value %d in the registry.  Error code: %d", szValueName, dwValue, m_err);
    }
    return m_err;
}

LONG CKey::SetValue(const CHAR *szValueName, const CHAR *szBuffer, DWORD dwSize, DWORD dwType)
{
    m_err = RegSetValueExA(m_hKey, szValueName, 0, dwType, (LPBYTE) szBuffer, dwSize);
    if(m_err)
    {
        LogEvent(EVENTLOG_ERROR_TYPE, EVENT_GENE_REGKEY_SET_FAILED, "Could not set the value on \"%s\" in the registry.  Error code: %d", szValueName, m_err);
    }
    return m_err;
}

LONG CKey::SetValue(const WCHAR *szValueName, const CHAR *szBuffer, DWORD dwSize, DWORD dwType)
{
    m_err = RegSetValueExW(m_hKey, szValueName, 0, dwType, (LPBYTE) szBuffer, dwSize);
    if(m_err)
    {
        LogEvent(EVENTLOG_ERROR_TYPE, EVENT_GENE_REGKEY_SET_FAILED, "Could not set the value on \"%S\" in the registry.  Error code: %d", szValueName, m_err);
    }
    return m_err;
}

BOOL CKey::ExistValue(const CHAR *szValueName)
{
    DWORD dwType;
    DWORD dwSize = 0;

    m_err = RegQueryValueExA(m_hKey, szValueName, 0, &dwType, NULL, &dwSize);
    if(m_err)
    {
        return FALSE;
    }
    return TRUE;
}

BOOL CKey::ExistValue(const WCHAR *szValueName)
{
    DWORD dwType;
    DWORD dwSize = 0;

    m_err = RegQueryValueExW(m_hKey, szValueName, 0, &dwType, NULL, &dwSize);
    if(m_err)
    {
        return FALSE;
    }
    return TRUE;
}

LONG CKey::QueryValue(const CHAR *szValueName, DWORD &dwValue)
{
    DWORD dwType;
    DWORD dwVal;
    DWORD dwSize = sizeof(DWORD);

    m_err = RegQueryValueExA(m_hKey, szValueName, 0, &dwType, (LPBYTE) &dwVal, &dwSize);
    if(m_err)
    {
        LogEvent(EVENTLOG_ERROR_TYPE, EVENT_GENE_REGKEY_QUERY_FAILED, "Could not query the value on \"%s\" in the registry.  Error code: %d", szValueName, m_err);
        goto Exit;
    }

    if(REG_DWORD != dwType)
    {
        LogEvent(EVENTLOG_ERROR_TYPE, EVENT_GENE_REGKEY_TYPE_MISMATCH, "The value of \"%s\" in the registry was not a DWORD.  Type is: %d", szValueName, dwType);
        m_err = 1629L;      // ERROR_DATATYPE_MISMATCH
        goto Exit;
    }

    dwValue = dwVal;
Exit:
    return m_err;
}

LONG CKey::QueryValue(const WCHAR *szValueName, DWORD &dwValue)
{
    DWORD dwType;
    DWORD dwVal;
    DWORD dwSize = sizeof(DWORD);

    m_err = RegQueryValueExW(m_hKey, szValueName, 0, &dwType, (LPBYTE) &dwVal, &dwSize);
    if(m_err)
    {
        LogEvent(EVENTLOG_ERROR_TYPE, EVENT_GENE_REGKEY_QUERY_FAILED, "Could not query the value on \"%S\" in the registry.  Error code: %d", szValueName, m_err);
        goto Exit;
    }

    if(REG_DWORD != dwType)
    {
        LogEvent(EVENTLOG_ERROR_TYPE, EVENT_GENE_REGKEY_TYPE_MISMATCH, "The value of \"%S\" in the registry was not a DWORD.  Type is: %d", szValueName, dwType);
        m_err = 1629L;  // ERROR_DATATYPE_MISMATCH
        goto Exit;
    }

    dwValue = dwVal;
Exit:
    return m_err;
}

LONG CKey::QueryValue(const CHAR *szValueName, CHAR *szBuffer, DWORD &dwSize, DWORD &dwType)
{
    m_err = RegQueryValueExA(m_hKey, szValueName, 0, &dwType, (LPBYTE) szBuffer, &dwSize);
    if(m_err)
    {
        LogEvent(EVENTLOG_ERROR_TYPE, EVENT_GENE_REGKEY_QUERY_FAILED, "Could not query the value of \"%s\" in the registry.  Error code: %d", szValueName, m_err);
    }
    return m_err;
}

LONG CKey::QueryValue(const WCHAR *szValueName, CHAR *szBuffer, DWORD &dwSize, DWORD &dwType)
{
    m_err = RegQueryValueExW(m_hKey, szValueName, 0, &dwType, (LPBYTE) szBuffer, &dwSize);
    if(m_err)
    {
        LogEvent(EVENTLOG_ERROR_TYPE, EVENT_GENE_REGKEY_QUERY_FAILED, "Could not query the value of \"%S\" in the registry.  Error code: %d", szValueName, m_err);
    }
    return m_err;
}

LONG CKey::EnumerateKeys(DWORD dwIndex, CHAR *szName, DWORD &dwSize)
{
    m_err = RegEnumKeyExA(m_hKey, dwIndex, szName, &dwSize, 0, 0, 0, 0);
    if(m_err)
    {
        LogEvent(EVENTLOG_ERROR_TYPE, EVENT_GENE_REGKEY_ENUM_FAILED, "Could not enumerate the keys of \"%s\" in the registry.  Error code: %d", szName, m_err);
    }
    return m_err;
}

LONG CKey::EnumerateKeys(DWORD dwIndex, WCHAR *szName, DWORD &dwSize)
{
    m_err = RegEnumKeyExW(m_hKey, dwIndex, szName, &dwSize, 0, 0, 0, 0);
    if(m_err)
    {
        LogEvent(EVENTLOG_ERROR_TYPE, EVENT_GENE_REGKEY_ENUM_FAILED, "Could not enumerate the keys of \"%S\" in the registry.  Error code: %d", szName, m_err);
    }
    return m_err;
}

LONG CKey::EnumerateValues(DWORD dwIndex, CHAR *szName, DWORD &dwSize, DWORD &dwType)
{
    m_err = RegEnumValueA(m_hKey, dwIndex, szName, &dwSize, 0, &dwType, 0, 0);
    if(m_err)
    {
        LogEvent(EVENTLOG_ERROR_TYPE, EVENT_GENE_REGKEY_ENUM_FAILED, "Could not enumerate the values of \"%s\" in the registry.  Error code: %d", szName, m_err);
    }
    return m_err;
}

LONG CKey::EnumerateValues(DWORD dwIndex, WCHAR *szName, DWORD &dwSize, DWORD &dwType)
{
    m_err = RegEnumValueW(m_hKey, dwIndex, szName, &dwSize, 0, &dwType, 0, 0);
    if(m_err)
    {
        LogEvent(EVENTLOG_ERROR_TYPE, EVENT_GENE_REGKEY_ENUM_FAILED, "Could not enumerate the values of \"%S\" in the registry.  Error code: %d", szName, m_err);
    }
    return m_err;
}

BOOL CKey::TestValue(const CHAR *szValueName, const CHAR *szValue, DWORD dwSize, BOOL fRetValIfNotFound)
{
    CHAR szData[MAX_PATH];
    DWORD dwDataSize = min(sizeof(szData), dwSize);

    m_err = RegQueryValueExA(m_hKey, szValueName, 0, 0, (LPBYTE) szData, &dwDataSize);
    if(ERROR_SUCCESS != m_err)
        return fRetValIfNotFound;

    if(dwDataSize != dwSize)
        return FALSE;

    if(memcmp(szData, szValue, dwSize))
        return FALSE;

    return TRUE;
}

BOOL CKey::TestValue(const WCHAR *szValueName, const CHAR *szValue, DWORD dwSize, BOOL fRetValIfNotFound)
{
    CHAR szData[MAX_PATH];
    DWORD dwDataSize = min(sizeof(szData), dwSize);

    m_err = RegQueryValueExW(m_hKey, szValueName, 0, 0, (LPBYTE) szData, &dwDataSize);
    if(ERROR_SUCCESS != m_err)
        return fRetValIfNotFound;

    if(dwDataSize != dwSize)
        return FALSE;

    if(memcmp(szData, szValue, dwSize))
        return FALSE;

    return TRUE;
}


VOID CKey::Close()
{
    if(m_hKey)
    {
        RegCloseKey(m_hKey);
    }
    m_hKey = NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\genealogy\geneadmin\genecommon\utility.cpp ===
#include <windows.h>
#include <stdio.h>
#pragma warning ( disable : 4201 )
#include <winioctl.h>
#pragma warning ( error : 4201 )
#include "strcls.h"
#include "dbaccessor.h"
#include "utility.h"

void CALL_TYPE DebugOutput(const char *szFmt, ...)
{
    va_list vargs;
    va_start(vargs, szFmt);
    CSafeStr szMsg(1024);
    szMsg.AllowTruncate(TRUE);
    szMsg.VAFormatText(szFmt, vargs);
    OutputDebugStringA(szMsg);
    va_end(vargs);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\genealogy\geneadmin\genecommon\search.h ===
#ifndef SEARCH_H
#define SEARCH_H
#undef UNICODE
class CFileSearch
{
public:
    CFileSearch();
    ~CFileSearch();

    BOOL Start(const CHAR *szSearch);
    BOOL GetNext();
    VOID Cleanup();
    inline DWORD GetLastError() {return m_dwError;}
    
    inline const WIN32_FIND_DATA * operator->() {return &m_wfd;}

protected:
	WIN32_FIND_DATA m_wfd;
	HANDLE m_hSearch;
    BOOL m_fFirst;
    DWORD m_dwError;
};

#endif // SEARCH_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\genealogy\geneadmin\genecommon\obj\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86_genecommon_none_12.4.56.0_none_a9d6954379c4d8bc
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86_genecommon_no-public-key_12.4.56.0_x-ww_7ce2bc36
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=genecommon
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86_genecommon_no-public-key_12.4.56.0_x-ww_7ce2bc36
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86_genecommon_no-public-key_12.4.56.0_x-ww_7ce2bc36.manifest
XP_MANIFEST_PATH=manifests\x86_genecommon_no-public-key_12.4.56.0_x-ww_7ce2bc36.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86_genecommon_no-public-key_12.4.56.0_x-ww_7ce2bc36.cat
XP_CATALOG_PATH=manifests\x86_genecommon_no-public-key_12.4.56.0_x-ww_7ce2bc36.cat
XP_PAYLOAD_PATH=x86_genecommon_no-public-key_12.4.56.0_x-ww_7ce2bc36
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=genecommon,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\genealogy\geneadmin\genecommon\strcls.h ===
#pragma once

#include <assert.h>
#include <malloc.h>

//---- Template class
template <DWORD m_size> class TSafeStr
{
public:
    TSafeStr(BOOL truncate = FALSE) 
        {
            m_len = 0;
            m_str[m_size] = 0;
			m_str[m_len] = 0;
            m_trunc = truncate;
        }

    ~TSafeStr() {}

    inline BOOL AllowTruncate(BOOL truncate) {BOOL bTemp = m_trunc; m_trunc = truncate; return bTemp;}
    inline DWORD Length() const {return m_len;}
    inline DWORD Size() const {return m_size;}

    inline CHAR operator[](DWORD i) const {if(i > m_len) return 0; return m_str[i];}
    inline operator const CHAR *() const {return m_str;}
    
    inline TSafeStr& operator=(const CHAR *str)
        {
            DWORD dwLen;
            if(!str)
            {
                assert(!"Attempting to copy from NULL!");
                m_str[0] = 0;
                m_len = 0;
                return *this;
            }
            dwLen = strlen(str);
            if(!m_trunc && m_size < dwLen)
                assert(!"TSafeStr buffer is too small to copy.");
            m_len = min(dwLen, m_size);
            memcpy(m_str, str, m_len);
			m_str[m_len] = 0;
            return *this;
        }
    inline TSafeStr& operator +=(const CHAR *str)
        {
            DWORD s, dwLen;
            if(!str)
            {
                assert(!"Attempting to copy from NULL!");
                return *this;
            }
            dwLen = strlen(str);
            if(!m_trunc && m_size < dwLen + m_len)
                assert(!"TSafeStr buffer is too small to append.");
            s = min(m_size - m_len, dwLen);
            memcpy(m_str + m_len, str, s);
			m_len += s;
			m_str[m_len] = 0;
            return *this;
        }
    inline TSafeStr& operator +=(CHAR ch)
        {
            if(!ch)
                return *this;
            if(!m_trunc && m_size < 1 + m_len)
                assert(!"TSafeStr buffer is too small to append.");
            m_str[m_len++] = ch;
            m_str[m_len] = 0;
            return *this;
        }

    inline operator bool() {return 0 != m_str[0];}

    inline TSafeStr& AppendN(const CHAR *str, DWORD len)
        {
            DWORD s, t, slen;
            if(!str)
            {
                assert(!"Attempting to copy from NULL!");
                return *this;
            }
            slen = strlen(str);
            t = min(slen, len);
            if(!m_trunc && m_size < t + m_len)
                assert(!"TSafeStr buffer is too small to append.");
            s = min(m_size - m_len, t);
            memcpy(m_str + m_len, str, s);
            m_len += s;
            m_str[m_len] = 0;
            return *this;
        }
    inline TSafeStr& CopyN(const CHAR *str, DWORD len)
        {
            DWORD t, dwLen;
            if(!str)
            {
                assert(!"Attempting to copy from NULL!");
                m_str[0] = 0;
                m_len = 0;
                return *this;
            }
            dwLen = strlen(str);
            t = min(dwLen, len);
            if(!m_trunc && m_size < t)
                assert(!"TSafeStr buffer is too small to copy.");
            m_len = min(t, m_size);
            memcpy(m_str, str, m_len);
            m_str[m_len] = 0;
            return *this;
        }

    TSafeStr& VAFormatText(const CHAR *fmt, va_list varargs)
    {
        _vsnprintf(m_str, m_size, fmt, varargs);
        return *this;
    }
    TSafeStr& FormatText(const CHAR *fmt, ...)
    {
        va_list pArg;
        va_start(pArg, fmt);
        _vsnprintf(m_str, m_size, fmt, pArg);
        va_end(pArg);
        return *this;
    }
    
    inline const CHAR *LineFromFile(FILE *fFile) 
        {
            const CHAR *szRes = fgets(m_str, m_size, fFile); 
            if(!szRes) 
            {
                m_str[0] = 0;
            }
            m_len = strlen(m_str); 
            return szRes;
        }
    
    inline void UpperCase() {_strupr(m_str);}
    inline void LowerCase() {_strlwr(m_str);}
    
protected:
    BOOL m_trunc;
    DWORD m_len;
    CHAR m_str[m_size + 1];
};

template <> class TSafeStr<0>
{
private:
    TSafeStr() {}
};

/*
template <DWORD size> inline DWORD strlen(const TSafeStr<size>& str) {return str.Length();};
template <DWORD size> inline TSafeStr<size>& strcpy(TSafeStr<size>& dest, const CHAR *src) {return dest = src;};
template <DWORD size> inline TSafeStr<size>& strcat(TSafeStr<size>& dest, const CHAR *src) {return dest += src;};
template <DWORD size> inline TSafeStr<size>& strncpy(TSafeStr<size>& dest, const CHAR *src, DWORD len) {return dest.CopyN(src, len);};
template <DWORD size> inline TSafeStr<size>& strncat(TSafeStr<size>& dest, const CHAR *src, DWORD len) {return dest.AppendN(src, len);};
*/

//---- Standard class
class CSafeStr
{
public:
    CSafeStr(DWORD size, BOOL truncate = FALSE) 
        {
            if(!size) assert(!"Cannot instantiate a string class of size 0."); 
            m_str = (CHAR *) malloc(size + 1);
            if(!m_str) assert(!"Failed to allocate memory for the string class.");
            m_size = size;
            m_len = 0;
            m_str[size] = 0;
			m_str[m_len] = 0;
            m_trunc = truncate;
        }
    CSafeStr(const CSafeStr& str, BOOL truncate = FALSE)
        {
            m_str = (CHAR *) malloc(str.m_size + 1);
            if(!m_str) assert(!"Failed to allocate memory for the string class.");
            m_size = str.m_size;
            m_len = str.m_len;
            memcpy(m_str, str.m_str, m_len);
            m_str[m_size] = 0;
			m_str[m_len] = 0;
            m_trunc = truncate;
        }

    ~CSafeStr() {if(m_str) free(m_str);}

    inline DWORD RawFromFile(FILE *fFile, DWORD dwBytes)
        {
            DWORD dwRead = min(m_size, dwBytes);
            dwRead = fread(m_str, 1, dwRead, fFile);
            m_str[dwRead] = 0;
            m_len = dwRead;
            return dwRead;
        }
    
    inline const CHAR *LineFromFile(FILE *fFile) 
        {
            const CHAR *szRes = fgets(m_str, m_size, fFile); 
            if(!szRes) 
            {
                m_str[0] = 0;
            }
            m_len = strlen(m_str); 
            return szRes;
        }

    inline const CHAR *FirstToken(const CHAR *szDelim) {return strtok(m_str, szDelim);}
    inline const CHAR *NextToken(const CHAR * szDelim) {return strtok(0, szDelim);}

    inline BOOL AllowTruncate(BOOL truncate) {BOOL bTemp = m_trunc; m_trunc = truncate; return bTemp;}
    inline DWORD Length() const {return m_len;}
    inline DWORD Size() const {return m_size;}

    inline CHAR operator[](DWORD i) const {if(i > m_len) return 0; return m_str[i];}
    inline operator const CHAR *() const {return m_str;}

    inline operator bool() const {return 0 != m_str[0];}

    inline CSafeStr& operator=(const CSafeStr& str)
        {
            if(!m_trunc && m_size < str.m_len)
                assert(!"CSafeStr buffer is too small to copy.");
            m_len = min(str.m_len, m_size);
            memcpy(m_str, str.m_str, m_len);
			m_str[m_len] = 0;
            return *this;
        }
    inline CSafeStr& operator=(const CHAR *str)
        {
            DWORD dwLen;
            if(!str)
            {
                assert(!"Attempting to copy from NULL!");
                m_str[0] = 0;
                m_len = 0;
                return *this;
            }
            dwLen = strlen(str);
            if(!m_trunc && m_size < dwLen)
                assert(!"CSafeStr buffer is too small to copy.");
            m_len = min(dwLen, m_size);
            memcpy(m_str, str, m_len);
			m_str[m_len] = 0;
            return *this;
        }
    inline CSafeStr& operator +=(const CSafeStr& str)
        {
            DWORD s;
            if(!m_trunc && m_size < str.m_len + m_len)
                assert(!"CSafeStr buffer is too small to append.");
            s = min(m_size - m_len, str.m_len);
            memcpy(m_str + m_len, str.m_str, s);
            m_len += s;
			m_str[m_len] = 0;
            return *this;
        }
    inline CSafeStr& operator +=(const CHAR *str)
        {
            DWORD s, dwLen;
            if(!str)
            {
                assert(!"Attempting to copy from NULL!");
                return *this;
            }
            dwLen = strlen(str);
            if(!m_trunc && m_size < dwLen + m_len)
                assert(!"CSafeStr buffer is too small to append.");
            s = min(m_size - m_len, dwLen);
            memcpy(m_str + m_len, str, s);
            m_len += s;
			m_str[m_len] = 0;
            return *this;
        }
    inline CSafeStr& operator +=(CHAR ch)
        {
            if(!ch)
                return *this;
            if(!m_trunc && m_size < 1 + m_len)
                assert(!"CSafeStr buffer is too small to append.");
            m_str[m_len++] = ch;
            m_str[m_len] = 0;
            return *this;
        }
    inline CSafeStr& AppendN(const CSafeStr& str, DWORD len)
        {
            DWORD s, t;
            t = min(str.m_len, len);
            if(!m_trunc && m_size < t + m_len)
                assert(!"CSafeStr buffer is too small to append.");
            s = min(m_size - m_len, t);
            memcpy(m_str + m_len, str.m_str, s);
            m_len += s;
            m_str[m_len] = 0;
            return *this;
        }
    inline CSafeStr& AppendN(const CHAR *str, DWORD len)
        {
            DWORD s, t, slen;
            if(!str)
            {
                assert(!"Attempting to copy from NULL!");
                return *this;
            }
            slen = strlen(str);
            t = min(slen, len);
            if(!m_trunc && m_size < t + m_len)
                assert(!"CSafeStr buffer is too small to append.");
            s = min(m_size - m_len, t);
            memcpy(m_str + m_len, str, s);
            m_len += s;
            m_str[m_len] = 0;
            return *this;
        }
    inline CSafeStr& CopyN(const CSafeStr& str, DWORD len)
        {
            DWORD t = min(str.m_len, len);
            if(!m_trunc && m_size < t)
                assert(!"CSafeStr buffer is too small to copy.");
            m_len = min(t, m_size);
            memcpy(m_str, str.m_str, m_len);
            m_str[m_len] = 0;
            return *this;
        }
    inline CSafeStr& CopyN(const CHAR *str, DWORD len)
        {
            DWORD t, dwLen;
            if(!str)
            {
                assert(!"Attempting to copy from NULL!");
                m_str[0] = 0;
                m_len = 0;
                return *this;
            }
            dwLen = strlen(str);
            t = min(dwLen, len);
            if(!m_trunc && m_size < t)
                assert(!"CSafeStr buffer is too small to copy.");
            m_len = min(t, m_size);
            memcpy(m_str, str, m_len);
            m_str[m_len] = 0;
            return *this;
        }

    CSafeStr& VAFormatText(const CHAR *fmt, va_list varargs)
    {
        _vsnprintf(m_str, m_size, fmt, varargs);
        return *this;
    }
    CSafeStr& FormatText(const CHAR *fmt, ...)
    {
        va_list pArg;
        va_start(pArg, fmt);
        _vsnprintf(m_str, m_size, fmt, pArg);
        va_end(pArg);
        return *this;
    }
    void DelChars(const CHAR *szChLst)
    {
        DWORD dwIndex, dwLen;
        if(!szChLst)
            return;
        
        for(dwIndex = dwLen = 0; m_str[dwLen];++dwLen)
        {
            if(!strchr(szChLst, m_str[dwLen]))
            {
                m_str[dwIndex++] = m_str[dwLen];
            }
        }
        m_str[dwIndex] = 0;
    }
    
    inline void UpperCase() {_strupr(m_str);}
    inline void LowerCase() {_strlwr(m_str);}
    
    
protected:
    BOOL m_trunc;
    DWORD m_size;
    DWORD m_len;
    CHAR * m_str;

private:
    CSafeStr() {};   // Prevent others from building empty versions.
};


//#pragma deprecated(strlen, strcpy, strcat, strncpy, strncat)

/*
inline DWORD strlen(const CSafeStr& str) {return str.Length();}
inline CSafeStr& strcpy(CSafeStr& dest, const CHAR *src) {return dest = src;}
inline CSafeStr& strcat(CSafeStr& dest, const CHAR *src) {return dest += src;}
inline CSafeStr& strncpy(CSafeStr& dest, const CHAR *src, DWORD len) {return dest.CopyN(src, len);}
inline CSafeStr& strncat(CSafeStr& dest, const CHAR *src, DWORD len) {return dest.AppendN(src, len);}

*/
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\genealogy\geneadmin\genecommon\objd\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86_genecommon_none_12.4.56.0_none_a9d6954379c4d8bc
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86_genecommon_no-public-key_12.4.56.0_x-ww_7ce2bc36
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=genecommon
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86_genecommon_no-public-key_12.4.56.0_x-ww_7ce2bc36
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86_genecommon_no-public-key_12.4.56.0_x-ww_7ce2bc36.manifest
XP_MANIFEST_PATH=manifests\x86_genecommon_no-public-key_12.4.56.0_x-ww_7ce2bc36.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86_genecommon_no-public-key_12.4.56.0_x-ww_7ce2bc36.cat
XP_CATALOG_PATH=manifests\x86_genecommon_no-public-key_12.4.56.0_x-ww_7ce2bc36.cat
XP_PAYLOAD_PATH=x86_genecommon_no-public-key_12.4.56.0_x-ww_7ce2bc36
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=genecommon,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\genealogy\geneadmin\GeneParser\base64.h ===
/*++

    Copyright (c) Microsoft Corporation

    Module Name:

        Base64.h

--*/

#ifndef __BASE64_H
#define __BASE64_H

#ifdef __cplusplus
extern "C" {
#endif

#define BASE64_ENCODE_BUFFER_SIZE( ulSrcSize ) (((((ulSrcSize) + 2) / 3) * 4) + 1)

BOOL WINAPI
Base64Encode(               
    const LPBYTE    pSrc,
    ULONG           ulSrcSize,
    LPSTR           pszDst
    );

#define BASE64_DECODE_BUFFER_SIZE( ulSrcSize ) (((ulSrcSize) / 4) * 3)

BOOL WINAPI
Base64Decode(
    LPCSTR      pszSrc,
    ULONG       ulSrcSize,
    LPBYTE      pDst,
    PULONG      pulDstSize
    );

#ifdef __cplusplus
}
#endif

#endif // __BASE64_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\genealogy\geneadmin\GeneParser\base64.cpp ===
/*++

    Copyright (c) Microsoft Corporation

    Module Name:

        Base64.cpp

    Abstract:

        Base64 encode/decode functions.

--*/

#include "stdafx.h"

#include <windows.h>
#include <assert.h>

#include "Base64.h"

BYTE g_achBase64DecodeTable[256]={
    64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,
    64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,62,64,64,64,63,
    52,53,54,55,56,57,58,59,60,61,64,64,64,64,64,64,64,0,1,2,3,4,5,6,7,8,9,
    10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,64,64,64,64,64,64,26,27,
    28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,
    64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,
    64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,
    64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,
    64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,
    64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,
    64,64,64,64,64,64,64,64,64,64,64,64,64
};

CHAR g_achBase64EncodeTable[64] = {
    'A','B','C','D','E','F','G','H','I','J','K','L','M',
    'N','O','P','Q','R','S','T','U','V','W','X','Y','Z',
    'a','b','c','d','e','f','g','h','i','j','k','l','m',
    'n','o','p','q','r','s','t','u','v','w','x','y','z',
    '0','1','2','3','4','5','6','7','8','9','+','/'
};

BOOL WINAPI
Base64Decode(
    LPCSTR  pszSrc,
    ULONG   ulSrcSize,
    LPBYTE  pDst,
    PULONG  pulDstSize
    )

/*++

Routine Description:

    Base64Decode    This method decodes a Base-64 encoded chunk of binary data.

Arguments:

    pszSrc      Points to Base64-encoded string to decode.

    ulSrcSize   Length of the string pointed to by pszSrc, not including 
                terminating null character.

    pDst        Buffer to copy the decoded binary data into.  The size of this
                buffer must be at least BASE64_DECODE_BUFFER_SIZE(ulSrcSize)

    pulDstSize  On return contains the length in bytes of the decoded buffer.

Return Value:

     0 - Decode was successful.

--*/

{
    ULONG   ulIndex;
    ULONG   ulCurOut;
    DWORD   dwGroup;
    DWORD   dwCur;
    DWORD   dwPadSeen;
    CHAR    chCur;

    dwGroup  = 0;
    dwPadSeen = 0;
    ulCurOut = 0;

    if(ulSrcSize % 4 != 0)
        return FALSE;

    for(ulIndex = 0; ulIndex < ulSrcSize; ulIndex++)
    {
        chCur = pszSrc[ulIndex];
        if(chCur == '=')
        {
            dwPadSeen++;
            dwCur = 0;
        }
        else
        {
            dwCur = g_achBase64DecodeTable[chCur];
        }
        assert( dwCur != 64 );
        
        dwGroup |= (dwCur << (6 * (ulIndex & 0x3)));

        if((ulIndex & 0x3) == 0x3)
        {
            pDst[ulCurOut++] = (CHAR)( dwGroup        & 0xff);

            if(dwPadSeen <= 1)
            {
                pDst[ulCurOut++] = (CHAR)((dwGroup >>  8) & 0xff);

                if(dwPadSeen == 0)
                    pDst[ulCurOut++] = (CHAR)((dwGroup >> 16) & 0xff);
            }

            dwGroup = 0;
        }
    }

    *pulDstSize = ulCurOut;
    assert( ulCurOut <= BASE64_DECODE_BUFFER_SIZE(ulSrcSize) );
    
    return TRUE;
}

BOOL WINAPI
Base64Encode(
    const LPBYTE    pSrc,
    ULONG           ulSrcSize,
    LPSTR           pszDst
    )

/*++

Routine Description:

    Base64Encode    This method converts a buffer of arbitrary binary data into
                    a Base-64 encoded string.

Arguments:

    pSrc        Points to the buffer of bytes to encode.

    ulSrcSize   Number of bytes in pSrc to encode.

    pszDst      Buffer to copy the encoded output into.  The length of the buffer
                must be at least BASE64_ENCODE_BUFFER_SIZE(ulSrcSize).

Return Value:

     0 - Encoding successful.

--*/

{
    DWORD   dwGroup;
    ULONG   ulCurGroup = 0, ulIndex;

    for(ulIndex = 0; ulIndex < (ulSrcSize - (ulSrcSize % 3)); ulIndex += 3)
    {
        dwGroup = (pSrc[ulIndex+2] << 16) | (pSrc[ulIndex+1] << 8) | pSrc[ulIndex];

        pszDst[ulCurGroup++] = g_achBase64EncodeTable[  dwGroup        & 0x3f ];
        pszDst[ulCurGroup++] = g_achBase64EncodeTable[ (dwGroup >> 6)  & 0x3f ];
        pszDst[ulCurGroup++] = g_achBase64EncodeTable[ (dwGroup >> 12) & 0x3f ];
        pszDst[ulCurGroup++] = g_achBase64EncodeTable[ (dwGroup >> 18) & 0x3f ];
    }

    //  Do the end special case.
    switch(ulSrcSize % 3)
    {
    case 2:
        dwGroup = (pSrc[ulIndex+1]  << 8)| pSrc[ulIndex];

        pszDst[ulCurGroup++] = g_achBase64EncodeTable[  dwGroup        & 0x3f ];
        pszDst[ulCurGroup++] = g_achBase64EncodeTable[ (dwGroup >> 6)  & 0x3f ];
        pszDst[ulCurGroup++] = g_achBase64EncodeTable[ (dwGroup >> 12) & 0x3f ];
        pszDst[ulCurGroup++] = '=';

        break;

    case 1:
        dwGroup = pSrc[ulIndex];

        pszDst[ulCurGroup++] = g_achBase64EncodeTable[  dwGroup        & 0x3f ];
        pszDst[ulCurGroup++] = g_achBase64EncodeTable[ (dwGroup >> 6)  & 0x3f ];
        pszDst[ulCurGroup++] = '=';
        pszDst[ulCurGroup++] = '=';

        break;
    }

    //  Null terminate the string.
    pszDst[ulCurGroup] = 0; 
    assert( ulCurGroup < BASE64_ENCODE_BUFFER_SIZE(ulSrcSize) );
    
    return TRUE;
}

// EOF
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\genealogy\geneadmin\GeneParser\dbconn.h ===
#pragma once


#define DODECLARATIONS
#include "DBControl.h"


/******************************************************************************
    CDBConn Class
 ******************************************************************************/

/*  CDBConn is the base class that provides the basic functionality of connecting to the database and 
    initializing the statement handle
*/
class CDBConn
{
public:
    VOID Disconnect();
    BOOL Connected();
protected:
    CDBConn();
    virtual ~CDBConn();

    BOOL Connect(const CHAR *szServer, const CHAR *szDatabase, const CHAR *szQuery, const CHAR *szUID = NULL, const CHAR *szPWD = NULL);

    BOOL m_fBound;
    HDBCONN m_hConn;
    HDBSTMT m_hStmt;
}; // CDBConn

/******************************************************************************
    CDBGetMissingFields Class
 ******************************************************************************/
// {call p_CMDGetMissingFields(?, ?, ?)}

#define DEFGETMISSINGFIELDS(stmt, jumpto)                                           \
    DEF_BINDPARAMSAFE_IN(stmt, 1, m_szSerial, 21, m_dwSerialLen, jumpto)            \
    DEF_BINDPARAMSAFE_IN(stmt, 2, m_szKey, 180, m_dwKeyLen, jumpto)                 \
    DEF_BINDPARAMSAFE_IN(stmt, 3, m_szKeyVer, 5, m_dwKeyVerLen, jumpto)             \
	DEF_BINDCOL(stmt, 1, DWORD, m_dwBugID, m_dwBugIDOpt, jumpto)					\
    DEF_BINDCOLSEQ(stmt, 2, CHAR, m_szPartNo, 12, m_dwPartNoLen, jumpto)            \
    DEF_BINDCOLSEQ(stmt, 3, CHAR, m_szMACAddr, 13, m_dwMACLen, jumpto)              \
    DEF_BINDCOLSEQ(stmt, 4, CHAR, m_szGameReg, 10, m_dwGameRegLen, jumpto)          \
    DEF_BINDCOLSEQ(stmt, 5, CHAR, m_szTVReg, 10, m_dwTVRegLen, jumpto)              \
    DEF_BINDCOLSEQ(stmt, 6, CHAR, m_szIsActive, 2, m_dwIsActiveLen, jumpto)

class CDBGetMissingFields : public CDBConn
{
public:
    CDBGetMissingFields();
    ~CDBGetMissingFields() {}

    BOOL Connect(const CHAR *szMachine, const CHAR *szDatabase, const CHAR *szUID = NULL, const CHAR *szPWD = NULL);
    DWORD GetMissingFields(const CHAR *szSerial, const CHAR *szKey, const CHAR *szKeyVer);

    DEFGETMISSINGFIELDS(0, 0);
};

/******************************************************************************
    CDBVerifyKeyExists Class
 ******************************************************************************/
// {call p_CMDVerifyKeyExists(?, ?, ?)}

#define DEFVERIFYKEYEXISTS(stmt, jumpto)                                            \
    DEF_BINDPARAMSAFE_IN(stmt, 1, m_szSerial, 21, m_dwSerialLen, jumpto)            \
    DEF_BINDPARAMSAFE_IN(stmt, 2, m_szKey, 180, m_dwKeyLen, jumpto)                 \
    DEF_BINDPARAMSAFE_IN(stmt, 3, m_szKeyVer, 5, m_dwKeyVerLen, jumpto)             \
	DEF_BINDCOL(stmt, 1, DWORD, m_dwBugID, m_dwBugIDOpt, jumpto)					\
    DEF_BINDCOL(stmt, 2, DWORD, m_dwCount, m_dwCountOpt, jumpto)

class CDBVerifyKeyExists : public CDBConn
{
public:
    CDBVerifyKeyExists();
    ~CDBVerifyKeyExists() {}

    BOOL Connect(const CHAR *szMachine, const CHAR *szDatabase, const CHAR *szUID = NULL, const CHAR *szPWD = NULL);
    DWORD VerifyKeyExists(const CHAR *szSerial, const CHAR *szKey, const CHAR *szKeyVer);

    DEFVERIFYKEYEXISTS(0, 0);
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\genealogy\geneadmin\GeneParser\dbconn.cpp ===
#include "stdafx.h"
#include "critsect.h"
#include "dbconn.h"

/******************************************************************************
    CDBGetMissingFields Class
 ******************************************************************************/
static CHAR szGetMissingFields[] = "{call p_CMDGetMissingFields(?, ?, ?)}";

#define DOINITIALIZATION
#include "DBControl.h"

CDBGetMissingFields::CDBGetMissingFields()
{
    DEFGETMISSINGFIELDS(0, 0);
}

#define DOBINDINGS
#include "DBControl.h"

DWORD CDBGetMissingFields::GetMissingFields(const CHAR *szSerial, const CHAR *szKey, const CHAR *szKeyVer)
{
    BOOL fLast = FALSE;
    DWORD dwCount = 0;
    
    if(!Connected())
        return (DWORD) -1;

    if(!m_fBound)
    {
        DEFGETMISSINGFIELDS(m_hStmt, Cleanup);
    }
    m_fBound = TRUE;

    m_szSerial = szSerial;
	m_dwSerialLen = m_szSerial.Length();
    m_szKey = szKey;
	m_dwKeyLen = m_szKey.Length();
    m_szKeyVer = szKeyVer;
	m_dwKeyVerLen = m_szKeyVer.Length();
    if(!DBStmtExecute(m_hStmt))
    {
        m_fBound = FALSE;
        goto Cleanup;
    }

    m_szPartNo[0] = 0;
    while(DBStmtFetch(m_hStmt, fLast))
        ++dwCount;
    
    return dwCount;

Cleanup:
    if(!m_fBound)
    {
        Disconnect();
    }
    return (DWORD) -1;
}

BOOL CDBGetMissingFields::Connect(const CHAR *szMachine, const CHAR *szDatabase, const CHAR *szUID, const CHAR *szPWD)
{
    if(!Connected())
        return CDBConn::Connect(szMachine, szDatabase, szGetMissingFields, szUID, szPWD);
    return TRUE;
}


/******************************************************************************
    CDBVerifyKeyExists Class
 ******************************************************************************/
static CHAR szVerifyKeyExists[] = "{call p_CMDVerifyKeyExists(?, ?, ?)}";

#define DOINITIALIZATION
#include "DBControl.h"

CDBVerifyKeyExists::CDBVerifyKeyExists()
{
    DEFVERIFYKEYEXISTS(0, 0);
}

#define DOBINDINGS
#include "DBControl.h"

DWORD CDBVerifyKeyExists::VerifyKeyExists(const CHAR *szSerial, const CHAR *szKey, const CHAR *szKeyVer)
{
    BOOL fLast = FALSE;
    
    if(!Connected())
        return (DWORD) -1;

    if(!m_fBound)
    {
        DEFVERIFYKEYEXISTS(m_hStmt, Cleanup);
    }
    m_fBound = TRUE;

    m_szSerial = szSerial;
	m_dwSerialLen = m_szSerial.Length();
    m_szKey = szKey;
	m_dwKeyLen = m_szKey.Length();
    m_szKeyVer = szKeyVer;
	m_dwKeyVerLen = m_szKeyVer.Length();
    if(!DBStmtExecute(m_hStmt))
    {
        m_fBound = FALSE;
        goto Cleanup;
    }

    while(DBStmtFetch(m_hStmt, fLast))
        ;
    
    return m_dwCount;

Cleanup:
    if(!m_fBound)
    {
        Disconnect();
    }
    return (DWORD) -1;
}

BOOL CDBVerifyKeyExists::Connect(const CHAR *szMachine, const CHAR *szDatabase, const CHAR *szUID, const CHAR *szPWD)
{
    if(!Connected())
        return CDBConn::Connect(szMachine, szDatabase, szVerifyKeyExists, szPWD, szUID);
    return TRUE;
}


/******************************************************************************
    CDBConn Class
 ******************************************************************************/
CDBConn::CDBConn()
{
    m_fBound = FALSE;
    m_hConn = 0;
    m_hStmt = 0;
}

CDBConn::~CDBConn()
{
    Disconnect();
}

BOOL CDBConn::Connect(const CHAR *szServer, const CHAR *szDatabase, const CHAR *szQuery, const CHAR *szUID, const CHAR *szPWD)
{
    Disconnect();
    m_hConn = DBSQLConnect((CHAR *) szServer, (CHAR *) szDatabase, (CHAR *) szUID, (CHAR *) szPWD);
    if(!m_hConn)
    {
        // TODO: Log an event
        return FALSE;
    }
    m_hStmt = DBPrepare(m_hConn, (CHAR *) szQuery);
    if(!m_hStmt)
    {
        Disconnect();
        return FALSE;
    }
    return TRUE;
}

BOOL CDBConn::Connected()
{
    return 0 != m_hStmt;
}

VOID CDBConn::Disconnect()
{
    if(m_hStmt)
        DBClose(m_hStmt);
    if(m_hConn)
        DBClose(m_hConn);
    m_hStmt = 0;
    m_hConn = 0;
    m_fBound = FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\genealogy\geneadmin\genecommon\utility.h ===
#pragma once

#ifndef CALL_TYPE
#define CALL_TYPE __stdcall
#endif // CALL_TYPE

enum DATE_FIELD
{
    DF_YEAR,
    DF_MONTH,
    DF_DAY,
    DF_HOUR,
    DF_MINUTE,
    DF_SECOND,
    DF_MILLISECOND
};

inline BOOL FileExists(const CHAR *szFile)
{
    if(((DWORD) -1) == GetFileAttributesA(szFile))
        return FALSE;
    return TRUE;
}

inline DWORDLONG FileSize(const CHAR *szFile)
{
    WIN32_FILE_ATTRIBUTE_DATA wfad;
    DWORDLONG size;
    if(!GetFileAttributesExA(szFile, GetFileExInfoStandard, &wfad))
        return 0;
    size = wfad.nFileSizeHigh;
    size <<= 32;
    size += wfad.nFileSizeLow;
    return size;
}

inline DWORD AlphaCount(const CHAR *sz)
{
    const CHAR *s = sz;
    while(('a' <= *s && *s <= 'z') || ('A' <= *s && *s <= 'Z'))
        ++s;
    return s - sz;
}

inline DWORD PartNoCount(const CHAR *sz)
{
    const CHAR *s = sz;
    while (('0' <= *s && *s <= '9') || ('-' == *s) || ('a' <= *s && *s <= 'z') || ('A' <= *s && *s <= 'Z'))
        ++s;
    return s - sz;
}

inline DWORD Base64Count(const CHAR *sz)
{
    const CHAR *s = sz;
    while (('0' <= *s && *s <= '9') || ('+' == *s) || ('a' <= *s && *s <= 'z') || ('A' <= *s && *s <= 'Z') || ('/' == *s))
        ++s;
    while ('=' == *s)
        ++s;
    return s - sz;
}

inline DWORD TextCount(const CHAR *sz)
{
    const CHAR *s = sz;
    while(('a' <= *s && *s <= 'z') || ('A' <= *s && *s <= 'Z') || (' ' == *s) || ('\t' == *s))
        ++s;
    return s - sz;
}

inline DWORD WSCount(const CHAR *sz)
{
    const CHAR *s = sz;
    while(' ' == *s || '\t' == *s)
        ++s;
    return s - sz;
}

inline DWORD DigitCount(const CHAR *sz)
{
    const CHAR *s = sz;
    while('0' <= *s && *s <= '9')
        ++s;
    return s - sz;
}

inline DWORD HexCount(const CHAR *sz)
{
    const CHAR *s = sz;
    while(('0' <= *s && *s <= '9') || ('a' <= *s && *s <= 'f') || ('A' <= *s && *s <= 'F'))
        ++s;
    return s -sz;
}

inline void CombinePathFile(CSafeStr& dst, const CSafeStr& src, const CHAR *file)
{
    DWORD dwLen = src.Length();
    if(dwLen && '\\' == src[dwLen - 1])
        --dwLen;
    dst.CopyN(src, dwLen);
    dst += '\\';
    dst += file;
}

inline void CombinePathFile(CSafeStr& dst, const CHAR *src, const CHAR *file)
{
	DWORD dwLen = (src) ? strlen(src) : 0;
    if(dwLen && '\\' == src[dwLen - 1])
        --dwLen;
	if(!dwLen)
	{
	    dst = file;
	}
	else
	{
		dst.CopyN(src, dwLen);
		dst += '\\';
	    dst += file;
	}
}
template <DWORD i> inline void CombinePathFile(CSafeStr& dst, const TSafeStr<i>& src, const CHAR *file)
{
    DWORD dwLen = src.Length();
    if(dwLen && '\\' == src[dwLen - 1])
        --dwLen;
    dst.CopyN(src, dwLen);
    dst += '\\';
    dst += file;
}

inline DWORD ChangeTime(SYSTEMTIME &st, DATE_FIELD df, short int delta)
{
    LONGLONG shift = delta;
    LONGLONG ft;
    switch(df)
    {
    case DF_YEAR:
        st.wYear = (WORD) (st.wYear + delta);
        return 0;
    case DF_MONTH:
        {
            int month, year;
            month = ((st.wMonth + delta - 1) % 12);
            month += (month < 0) ? 12 : 0;
            year = (st.wMonth + delta - 1 - month) / 12;
            st.wMonth = (WORD) (month + 1);
            st.wYear = (WORD) year;
            return 0;
        }
    case DF_DAY:
        shift *= 24;
    case DF_HOUR:
        shift *= 60;
    case DF_MINUTE:
        shift *= 60;
    case DF_SECOND:
        shift *= 1000;
    case DF_MILLISECOND:
        shift *= 1000 * 10;
    };
    if(!SystemTimeToFileTime(&st, (FILETIME *) &ft))
        return GetLastError();
    ft += shift;
    if(!FileTimeToSystemTime((FILETIME *) &ft, &st))
        return GetLastError();
    return 0;
}

inline void SystemTimeToDBTimestamp(const SYSTEMTIME &st, DBTIMESTAMP &db)
{
    db.year = st.wYear;
    db.month = st.wMonth;
    db.day = st.wDay;
    db.hour = st.wHour;
    db.minute = st.wMinute;
    db.second = st.wSecond;
    db.fraction = st.wMilliseconds;
    db.fraction *= 1000 * 1000;
}

inline void DBTimestampToSystemTime(const DBTIMESTAMP &db, SYSTEMTIME &st)
{
    st.wYear = db.year;
    st.wMonth = db.month;
    st.wDay = db.day;
    st.wDayOfWeek = 0;
    st.wHour = db.hour;
    st.wMinute = db.minute;
    st.wSecond = db.second;
    st.wMilliseconds = (WORD) (db.fraction / 1000 / 1000);
}

inline DWORD ChangeTime(DBTIMESTAMP &db, DATE_FIELD df, short int delta)
{
    SYSTEMTIME st;
    DWORD dwRes = 0;
    DBTimestampToSystemTime(db, st);
    dwRes = ChangeTime(st, df, delta);
    if(dwRes)
        return dwRes;
    SystemTimeToDBTimestamp(st, db);
    return dwRes;
}


inline DWORDLONG ToComparableTime(const DBTIMESTAMP &time)
{
    /* Division: 12 bits for year, 4 bits for month, 5 bits for day, 5 bits for hour, 6 bits for minutes, 6 bits for seconds = 36 bits */
    DWORDLONG t = 0;
    t = time.year;
    t <<= 4;
    t += time.month;
    t <<= 5;
    t += time.day;
    t <<= 5;
    t += time.hour;
    t <<= 6;
    t += time.minute;
    t <<= 6;
    t += time.second;
    return t;
}

inline DWORDLONG ToComparableTime(const SYSTEMTIME &time)
{
    /* Division: 12 bits for year, 4 bits for month, 5 bits for day, 5 bits for hour, 6 bits for minutes, 6 bits for seconds = 36 bits */
    DWORDLONG t = 0;
    t = time.wYear;
    t <<= 4;
    t += time.wMonth;
    t <<= 5;
    t += time.wDay;
    t <<= 5;
    t += time.wHour;
    t <<= 6;
    t += time.wMinute;
    t <<= 6;
    t += time.wSecond;
    return t;
}

inline int CurYear()
{
	SYSTEMTIME st;
	GetSystemTime(&st);
	return st.wYear;
}

inline int CompareTime(const SYSTEMTIME &lhs, const SYSTEMTIME &rhs)
{
    DWORDLONG flhs, frhs;
    flhs = ToComparableTime(lhs);
    frhs = ToComparableTime(rhs);
    if(flhs < frhs)
        return -1;
    if(flhs > frhs)
        return 1;
    return 0;
}

#define INRANGE(val, low, high)		(val >= low && val <= high)
inline int CompareTime(const DBTIMESTAMP &lhs, const DBTIMESTAMP &rhs)
{
    DWORDLONG flhs = 0, frhs = 0;
	int year = CurYear();
    flhs = ToComparableTime(lhs);
    frhs = ToComparableTime(rhs);
    if(!INRANGE(lhs.year, 2000, year) || !INRANGE(rhs.year, 2000, year))
        OutputDebugStringA("Invalid date and time compared.");
    if(flhs < frhs)
        return -1;
    if(flhs > frhs)
        return 1;
    return 0;
}

inline DWORD LocalTimeToUTC(SYSTEMTIME &stLocal, SYSTEMTIME &stUTC)
{
    TIME_ZONE_INFORMATION tzi;
    DWORD dwTimeZoneID;
    SHORT lBias;
    dwTimeZoneID = GetTimeZoneInformation(&tzi);
    if(TIME_ZONE_ID_UNKNOWN == dwTimeZoneID)
    {
        OutputDebugStringA("Can't identify the time zone I'm in!");
        return GetLastError();
    }

    lBias = (SHORT) tzi.Bias;

    memcpy(&stUTC, &stLocal, sizeof(SYSTEMTIME));
    return ChangeTime(stUTC, DF_MINUTE, lBias);
}

inline DWORD CompressFile(const CHAR *szFile)
{
    HANDLE hFile = INVALID_HANDLE_VALUE;
    USHORT usCompression = COMPRESSION_FORMAT_DEFAULT;
    DWORD dwBytes = 0;
    DWORD dwError = 0;
    hFile = CreateFileA(szFile, GENERIC_ALL | STANDARD_RIGHTS_ALL, 0, NULL, OPEN_EXISTING, 0, NULL);
    if(!hFile || INVALID_HANDLE_VALUE == hFile)
        return dwError = GetLastError();
    if(!DeviceIoControl(hFile, FSCTL_SET_COMPRESSION, &usCompression, sizeof(usCompression), 0, 0, &dwBytes, 0))
        dwError = GetLastError();
    CloseHandle(hFile);
    return dwError;
}

inline DWORD ClearRO(const CHAR *szFile)
{
    if(!SetFileAttributesA(szFile, FILE_ATTRIBUTE_NORMAL | FILE_ATTRIBUTE_NOT_CONTENT_INDEXED))
        return GetLastError();
    return 0;
}

void CALL_TYPE DebugOutput(const char *szFmt, ...);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\genealogy\geneadmin\GeneParser\geneparser.cpp ===
// GeneParser.cpp : Implementation of WinMain

#include "stdafx.h"
#include "resource.h"
#include "GeneParser.h"
#include "geneparser_i.c"
#include <stdio.h>

class CGeneParserModule : public CAtlServiceModuleT< CGeneParserModule, IDS_SERVICENAME >
{
public :
	DECLARE_LIBID(LIBID_GeneParserLib)
	DECLARE_REGISTRY_APPID_RESOURCEID(IDR_GENEPARSER, "{CFAC340F-C6CE-4A52-80CB-742CBCE5EEA3}")

	// This function provides the default security settings for your service,
	// you should overide this in your specific service module class to change
	// as appropriate.  By default, this will allow any caller and calls will be
	// on the callers security token (impersonated).
	HRESULT InitializeSecurity() throw()
	{
		return CoInitializeSecurity(NULL, -1, NULL, NULL, RPC_C_AUTHN_LEVEL_PKT, RPC_C_IMP_LEVEL_IMPERSONATE, NULL, EOAC_NONE, NULL);
	}

};

CGeneParserModule _AtlModule;


//
extern "C" int WINAPI _tWinMain(HINSTANCE /*hInstance*/, HINSTANCE /*hPrevInstance*/, 
                                LPTSTR /*lpCmdLine*/, int nShowCmd)
{
    SetErrorReporting(/*DB_REPORT_INFORMATIONAL |*/ DB_REPORT_DEBUGSTRING | DB_REPORT_EVENT, "GeneParser");
    return _AtlModule.WinMain(nShowCmd);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\genealogy\geneadmin\GeneParser\mfgparse.h ===
#pragma once

DWORD ParseAMFeedData(CKeyMgr &keys, const CHAR *szText);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\genealogy\geneadmin\GeneParser\keymgr.h ===
#pragma once
#include <windows.h>
#include <winioctl.h>
#include <comutil.h>
#pragma warning(disable : 4702)
#include <map>
#pragma warning(error : 4702)
#include "dbaccessor.h"
#include "dbconn.h"

#include "strcls.h"

struct SKeyEntry
{
	DWORD dwBugID;
    TSafeStr<172> szKey;
    TSafeStr<4> szVer;
};

struct SNewKey
{
	DWORD dwBugID;
    TSafeStr<9> szPartNo;
    TSafeStr<172> szKey;
    TSafeStr<4> szVer;
    TSafeStr<12> szMAC;
    TSafeStr<8> szGameReg;
    TSafeStr<8> szTVReg;
};

typedef std::multimap< LONGLONG, SKeyEntry > mapFailures;
typedef std::multimap< LONGLONG, SNewKey > mapFeedRows;
    
class CKeyMgr
{
public:
    CKeyMgr() {}
    ~CKeyMgr() {}

	BOOL Connected();
    BOOL SetSourceDatabase(const CHAR *szMachine, const CHAR *szDatabase, const CHAR *szUID = NULL, const CHAR *szPWD = NULL);

    DWORD AddRow(const TSafeStr<12> &szSerial, const TSafeStr<172> &szKey, const TSafeStr<4> &szVersion);
    DWORD AddRow(const TSafeStr<12> &szSerial, const TSafeStr<9> &szPartNo, const TSafeStr<172> &szKey, const TSafeStr<4> &szVersion, const TSafeStr<12> &szMAC, const TSafeStr<8> &szGameReg, const TSafeStr<8> &szTVReg);

    DWORD GetNewOnlineKeyCount();
    DWORD GetDupOnlineKeyCount();

    DWORD GetReport(_bstr_t &szReport);
    DWORD GetNewFeedRows(_bstr_t &szFeedRows);
	DWORD GetAffectedBugsPSQ(_bstr_t &bsPSQ);
	DWORD GetNoNewRowsPSQ(_bstr_t &bsPSQ);

protected:
	BOOL ValidSN(const TSafeStr<12> &szSerial);
	BOOL ValidPartNo(const TSafeStr<9> &szPartNo);
	BOOL ValidOnlineKey(const TSafeStr<172> &szKey);
	BOOL ValidKeyVersion(const TSafeStr<4> &szVer);
	BOOL ValidMACAddress(const TSafeStr<12> &szMAC);
	BOOL ValidGameReg(const TSafeStr<8> &szGameReg);
	BOOL ValidTVReg(const TSafeStr<8> &szTVReg);

    CDBGetMissingFields m_gmf;
    CDBVerifyKeyExists m_vke;

    mapFailures m_rgDupes;
    mapFailures m_rgFailed;
    mapFeedRows m_rgNewKeys;
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\genealogy\geneadmin\GeneParser\keymgr.cpp ===
#include "stdafx.h"
#include "keymgr.h"
#include "base64.h"
#include "utility.h"

BOOL CKeyMgr::Connected()
{
	return m_gmf.Connected() && m_vke.Connected();
}

BOOL CKeyMgr::SetSourceDatabase(const CHAR *szMachine, const CHAR *szDatabase, const CHAR *szUID, const CHAR *szPWD)
{
    if((DWORD) -1 == m_gmf.Connect(szMachine, szDatabase, szUID, szPWD) || (DWORD) -1 == m_vke.Connect(szMachine, szDatabase, szUID, szPWD))
        return FALSE;
    return TRUE;
}

DWORD CKeyMgr::AddRow(const TSafeStr<12> &szSerial, const TSafeStr<172> &szKey, const TSafeStr<4> &szVersion)
{
    LONGLONG llKey;
    SKeyEntry skeValue;
    SNewKey snkValue;
	if(!ValidSN(szSerial) || !ValidOnlineKey(szKey) || !ValidKeyVersion(szVersion))
	{
		return (DWORD) -2;
	}

    DWORD dwResult = m_vke.VerifyKeyExists(szSerial, szKey, szVersion);
    
    if((DWORD) -1 == dwResult)
    {
        return dwResult;
    }

    llKey = _atoi64(szSerial);
    if(dwResult)
    {
		skeValue.dwBugID = m_vke.m_dwBugID;
        skeValue.szKey = szKey;
        skeValue.szVer = szVersion;
        m_rgDupes.insert( mapFailures::value_type(llKey, skeValue) );
        return 0;
    }

    dwResult = m_gmf.GetMissingFields(szSerial, szKey, szVersion);
    if((DWORD) -1 == dwResult)
    {
        return (DWORD) -1;
    }

    if(!dwResult)
    {
		skeValue.dwBugID = m_vke.m_dwBugID;
        skeValue.szKey = szKey;
        skeValue.szVer = szVersion;
        m_rgFailed.insert( mapFailures::value_type(llKey, skeValue) );
        return 0;
    }

	skeValue.dwBugID = m_gmf.m_dwBugID;
    snkValue.szPartNo = m_gmf.m_szPartNo;
    snkValue.szKey = szKey;
    snkValue.szVer = szVersion;
    snkValue.szMAC = m_gmf.m_szMACAddr;
    snkValue.szGameReg = m_gmf.m_szGameReg;
    snkValue.szTVReg = m_gmf.m_szTVReg;

    m_rgNewKeys.insert( mapFeedRows::value_type(llKey, snkValue) );

    return 0;
}

DWORD CKeyMgr::AddRow(const TSafeStr<12> &szSerial, const TSafeStr<9> &szPartNo, const TSafeStr<172> &szKey, const TSafeStr<4> &szVersion, const TSafeStr<12> &szMAC, const TSafeStr<8> &szGameReg, const TSafeStr<8> &szTVReg)
{
	if(!ValidSN(szSerial) || !ValidOnlineKey(szKey) || !ValidKeyVersion(szVersion) || !ValidPartNo(szPartNo) || !ValidMACAddress(szMAC) || !ValidGameReg(szGameReg) || !ValidTVReg(szTVReg))
	{
		return (DWORD) -2;
	}

    LONGLONG llKey;
    SKeyEntry skeValue;
    SNewKey snkValue;
    DWORD dwResult = m_vke.VerifyKeyExists(szSerial, szKey, szVersion);
    
    if((DWORD) -1 == dwResult)
    {
        return dwResult;
    }

    llKey = _atoi64(szSerial);
    if(dwResult)
    {
		skeValue.dwBugID = m_vke.m_dwBugID;
        skeValue.szKey = szKey;
        skeValue.szVer = szVersion;
        m_rgDupes.insert( mapFailures::value_type(llKey, skeValue) );
        return 0;
    }

	snkValue.dwBugID = m_vke.m_dwBugID;
    snkValue.szPartNo = szPartNo;
    snkValue.szKey = szKey;
    snkValue.szVer = szVersion;
    snkValue.szMAC = szMAC;
    snkValue.szGameReg = szGameReg;
    snkValue.szTVReg = szTVReg;

    m_rgNewKeys.insert( mapFeedRows::value_type(llKey, snkValue) );

    return 0;
}

DWORD CKeyMgr::GetNewOnlineKeyCount()
{
    return m_rgNewKeys.size();
}

DWORD CKeyMgr::GetDupOnlineKeyCount()
{
    return m_rgDupes.size();
}

DWORD CKeyMgr::GetReport(_bstr_t &szReport)
{
    TSafeStr<250> szRow;
	LONGLONG llLast = 0;
    CHAR szNum[20];
    DWORD dwLen, dwCount;
    _bstr_t bsNewKeys;
    mapFailures::iterator iter;

    dwCount = 0;

	llLast = 0;
    szReport = "The following serial numbers introduced no new online keys:\n";
    for(iter = m_rgDupes.begin(); iter != m_rgDupes.end(); ++iter)
    {
		if(llLast == iter->first)
			continue;
		llLast = iter->first;
        if(m_rgNewKeys.find(iter->first) == m_rgNewKeys.end())
        {
	        ++dwCount;
            szRow = "";
            _i64toa(iter->first, szNum, 10);
            dwLen = strlen(szNum);
            for(;dwLen < 12; ++dwLen)
            {
                szRow += "0";
            }
            szRow += szNum;
			if(iter->second.dwBugID)
			{
				_i64toa(iter->second.dwBugID, szNum, 10);
				szRow += " (Bug: ";
				szRow += szNum;
				szRow += ')';
			}
            szRow += '\n';
            szReport += (const CHAR *) szRow;
        }
    }

	if(!dwCount)
	{
		szReport = "";
	}

    if(m_rgDupes.size())
    {
        if(dwCount)
        {
            szReport += "\n";
        }
        szReport += "The following serial number/online key pairs were already found in the feeds:\n";
        for(iter = m_rgDupes.begin(); iter != m_rgDupes.end(); ++iter)
        {
            szRow = "";
            _i64toa(iter->first, szNum, 10);
            dwLen = strlen(szNum);
            for(;dwLen < 12; ++dwLen)
            {
                szRow += "0";
            }
            szRow += szNum;
            szRow += '\t';
            szRow.AppendN(iter->second.szKey, 12);
            szRow += '\t';
            szRow += iter->second.szVer;
            szRow += "\n";
            szReport += (const CHAR *) szRow;
        }
    }
    dwCount += m_rgDupes.size();

    if(m_rgFailed.size())
    {
        if(dwCount)
        {
            szReport += "\n";
        }
        szReport += "The following serial number/online key pairs had new online keys but no other fields were found to construct a valid feed row:\n";
        for(iter = m_rgFailed.begin(); iter != m_rgFailed.end(); ++iter)
        {
            szRow = "";
            _i64toa(iter->first, szNum, 10);
            dwLen = strlen(szNum);
            for(;dwLen < 12; ++dwLen)
            {
                szRow += "0";
            }
            szRow += szNum;
            szRow += '\t';
            szRow.AppendN(iter->second.szKey, 12);
            szRow += '\t';
            szRow += iter->second.szVer;
            szRow += "\n";
            szReport += (const CHAR *) szRow;
        }
    }
    dwCount += m_rgFailed.size();

    if(m_rgNewKeys.size() && GetNewFeedRows(bsNewKeys))
    {
        if(dwCount)
        {
            szReport += "\n";
        }
        szReport += "The following are the new feed rows:\n";
        szReport += bsNewKeys;
    }
    dwCount += m_rgNewKeys.size();

    if(!dwCount)
    {
        szReport = "No feed data has been processed.";
    }
    return 0;
}

DWORD CKeyMgr::GetNewFeedRows(_bstr_t &szFeedRows)
{
    TSafeStr<250> szRow;
    CHAR szNum[20];
    DWORD dwLen;
    mapFeedRows::iterator iter;
    szFeedRows = "";
    for(iter = m_rgNewKeys.begin(); iter != m_rgNewKeys.end(); ++iter)
    {
        szRow = "";
        _i64toa(iter->first, szNum, 10);
        dwLen = strlen(szNum);
        for(;dwLen < 12; ++dwLen)
        {
            szRow += "0";
        }
        szRow += szNum;
        szRow += '\t';
        szRow += iter->second.szPartNo;
        szRow += '\t';
        szRow += iter->second.szKey;
        szRow += '\t';
        szRow += iter->second.szVer;
        szRow += '\t';
        szRow += iter->second.szMAC;
        szRow += '\t';
        szRow += iter->second.szGameReg;
        szRow += '\t';
        szRow += iter->second.szTVReg;
        szRow += "\t1\n";
        szFeedRows += (const CHAR *) szRow;
    }
    return m_rgNewKeys.size();
}

BOOL CKeyMgr::ValidSN(const TSafeStr<12> &szSerial)
{
	return 12 == DigitCount(szSerial);
}

BOOL CKeyMgr::ValidPartNo(const TSafeStr<9> &szPartNo)
{
	return 9 == PartNoCount(szPartNo);
}

BOOL CKeyMgr::ValidOnlineKey(const TSafeStr<172> &szKey)
{
	CHAR szBuf[130];
	DWORD dwBufLen = sizeof(szBuf);
	if(172 != Base64Count(szKey))
		return FALSE;
	return Base64Decode(szKey, 172, (LPBYTE) szBuf, &dwBufLen);
}

BOOL CKeyMgr::ValidKeyVersion(const TSafeStr<4> &szVer)
{
	return 4 == DigitCount(szVer);
}

BOOL CKeyMgr::ValidMACAddress(const TSafeStr<12> &szMAC)
{
	return 12 == HexCount(szMAC);
}

BOOL CKeyMgr::ValidGameReg(const TSafeStr<8> &szGameReg)
{
	return 8 == DigitCount(szGameReg);
}

BOOL CKeyMgr::ValidTVReg(const TSafeStr<8> &szTVReg)
{
	return 8 == DigitCount(szTVReg);
}

const CHAR szPSQHeader[] = "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<Data Application=\"Product Studio\" Type=\"Query\" Version=\"1.2\"><ModeBar Product=\"XboxOnline\" CurrentMode=\"Bugs\"/><Bugs><Query xml:space=\"preserve\" Product=\"XboxOnline\"><Group GroupOperator=\"and\" Explicit=\"0\"><Expression Column=\"TreeID\" FieldType=\"16\" Operator=\"under\" IsProduct=\"-1\"><Number>0</Number></Expression><Group GroupOperator=\"or\" Explicit=\"-1\">";
const CHAR szPSQFooter[] = "</Group></Group></Query><Results><Column Name=\"ID\" Width=\"140\"/><Column Name=\"Title\" Width=\"844\"/><OrderBy><Column Name=\"ID\" Ascending=\"-1\"/></OrderBy></Results></Bugs></Data>";
const CHAR szPSQBugID[] = "<Expression Column=\"ID\" FieldType=\"32\" Operator=\"equals\"><Number>%d</Number></Expression>";

DWORD CKeyMgr::GetAffectedBugsPSQ(_bstr_t &bsPSQ)
{
	LONGLONG llCur;
	TSafeStr<150> szBugInfo;
	mapFailures::iterator mfsA, mfsB;
	mapFeedRows::iterator mfr;
	mfsA = m_rgDupes.begin();
	mfsB = m_rgFailed.begin();
	mfr = m_rgNewKeys.begin();
	DWORD dwCount = 0;
	DWORD dwBugID = 0;

	bsPSQ = szPSQHeader;
	while(mfsA != m_rgDupes.end() || mfsB != m_rgFailed.end() || mfr != m_rgNewKeys.end())
	{
		llCur = 0x7FFFFFFFFFFFFFFF;
		if(mfsA != m_rgDupes.end())
		{
			llCur = mfsA->first;
			dwBugID = mfsA->second.dwBugID;
		}
		if(mfsB != m_rgFailed.end() && mfsB->first < llCur)
		{
			llCur = mfsB->first;
			dwBugID = mfsB->second.dwBugID;
		}
		if(mfr != m_rgNewKeys.end() && mfr->first < llCur)
		{
			llCur = mfr->first;
			dwBugID = mfr->second.dwBugID;
		}

		if(llCur != 0 && llCur != 0x7FFFFFFFFFFFFFFF && dwBugID)
		{
			szBugInfo.FormatText(szPSQBugID, dwBugID);
			bsPSQ += (const CHAR *) szBugInfo;
			++dwCount;
		}

		while(mfsA != m_rgDupes.end() && mfsA->first <= llCur)
			++mfsA;
		while(mfsB != m_rgFailed.end() && mfsB->first <= llCur)
			++mfsB;
		while(mfr != m_rgNewKeys.end() && mfr->first <= llCur)
			++mfr;
	}
	bsPSQ += szPSQFooter;
	return dwCount;
}

DWORD CKeyMgr::GetNoNewRowsPSQ(_bstr_t &bsPSQ)
{
	LONGLONG llLast = 0;
	TSafeStr<150> szBugInfo;
	mapFailures::iterator iter;
	DWORD dwCount = 0;

	bsPSQ = szPSQHeader;
    for(iter = m_rgDupes.begin(); iter != m_rgDupes.end(); ++iter)
    {
		if(llLast == iter->first)
			continue;
		llLast = iter->first;
        if(m_rgNewKeys.find(iter->first) == m_rgNewKeys.end())
        {
			if(iter->second.dwBugID)
			{
				szBugInfo.FormatText(szPSQBugID, iter->second.dwBugID);
				++dwCount;
			}
			bsPSQ += (const CHAR *) szBugInfo;
        }
    }
	bsPSQ += szPSQFooter;
	return dwCount;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\genealogy\geneadmin\GeneParser\mfgparse.cpp ===
#include "stdafx.h"
#include "keymgr.h"
#include "utility.h"
#include "strcls.h"
#include "base64.h"

DWORD ParseAMFeedData(CKeyMgr &keys, const CHAR *szText)
{
	TSafeStr<12> szSerial;
	TSafeStr<172> szKey;
	TSafeStr<4> szKeyVer;
	TSafeStr<9> szPartNo;
	TSafeStr<12> szMACAddr;
	TSafeStr<8> szGameReg;
	TSafeStr<8> szTVReg;
	CHAR szBuf[130];
	DWORD dwBufSize = sizeof(szBuf);
	DWORD dwCount = 0;

	const CHAR *szNext, *szPos = szText;
	if(!szText)
		return 0;

	while(szPos)
	{
		szNext = strpbrk(szPos, "\r\n");

		/* 12 Digit Serial Number (12 digits) */
		szPos += WSCount(szPos);
		if(12 != DigitCount(szPos))
			goto NextLine;
		szSerial.CopyN(szPos, 12);
		szPos += 12;

		/* 20 Digit Serial Number (20 digits) */
		szPos += WSCount(szPos);
		if(20 != DigitCount(szPos))
			goto NextLine;
		szPos += 20;

		/* Part Number (9 characters) */
		szPos += WSCount(szPos);
		if(9 != PartNoCount(szPos))
			goto NextLine;
		szPartNo.CopyN(szPos, 9);
		szPos += 9;

		/* HD Key (24 base 64 chars) */
		szPos += WSCount(szPos);
		if(24 != Base64Count(szPos))
			goto NextLine;
		dwBufSize = sizeof(szBuf);
		if(!Base64Decode(szPos, 24, (LPBYTE) szBuf, &dwBufSize))
			goto NextLine;
		szPos += 24;

		/* Recovery Key (4 characters) */
		szPos += WSCount(szPos);
		if(4 != AlphaCount(szPos))
			goto NextLine;
		szPos += 4;

		/* Online Key (172 base 64 chars) */
		szPos += WSCount(szPos);
		if(172 != Base64Count(szPos))
			goto NextLine;
		dwBufSize = sizeof(szBuf);
		if(!Base64Decode(szPos, 172, (LPBYTE) szBuf, &dwBufSize))
			goto NextLine;
		szKey.CopyN(szPos, 172);
		szPos += 172;

		/* Online Key Version (4 digits) */
		szPos += WSCount(szPos);
		if(4 != DigitCount(szPos))
			goto NextLine;
		szKeyVer.CopyN(szPos, 4);
		szPos += 4;

		/* MAC Address (12 hex characters) */
		szPos += WSCount(szPos);
		if(12 != HexCount(szPos))
			goto NextLine;
		szMACAddr.CopyN(szPos, 12);
		szPos += 12;

		/* Game Region (8 digits) */
		szPos += WSCount(szPos);
		if(8 != DigitCount(szPos))
			goto NextLine;
		szGameReg.CopyN(szPos, 8);
		szPos += 8;

		/* TV Region (8 digits) */
		szPos += WSCount(szPos);
		if(8 != DigitCount(szPos))
			goto NextLine;
		szTVReg.CopyN(szPos, 8);

		keys.AddRow(szSerial, szPartNo, szKey, szKeyVer, szMACAddr, szGameReg, szTVReg);
		++dwCount;

NextLine:
		szPos = szNext;
		while(szPos && ('\r' == *szPos || '\n' == *szPos))
			++szPos;
	}

	return dwCount;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\genealogy\geneadmin\GeneParser\parser.cpp ===
// Parser.cpp : Implementation of CParser

#include "stdafx.h"
#include "Parser.h"
#include "xmlparse.h"
#include "mfgparse.h"
#include "mappedfile.h"
#include "search.h"
#include "utility.h"


// CParser

CParser::CParser()
{
}

STDMETHODIMP CParser::ParseAMFeed(BSTR bsAMFeed)
{
	// TODO: Add your implementation code here
	if(!SysStringLen(bsAMFeed))
		return E_INVALIDARG;
	_bstr_t bsText = bsAMFeed;

	if(!ParseAMFeedData(m_keys, bsText))
		return S_FALSE;

	return S_OK;
}

STDMETHODIMP CParser::ParseXMLFiles(BSTR bsSourcePath)
{
	// TODO: Add your implementation code here
	if(!SysStringLen(bsSourcePath))
		return E_INVALIDARG;

	CFileSearch wfd;
	_bstr_t bsPath = bsSourcePath;
	CSafeStr szSearch(2*MAX_PATH);
	TSafeStr<12> szSerial;
	TSafeStr<172> szKey;
	TSafeStr<4> szKeyVer;
	CMappedFile mfFile;
	CHAR *szBuf;

	CombinePathFile(szSearch, (const CHAR *) bsPath, "*.xml");
	if(!wfd.Start(szSearch))
		return S_FALSE;
	while(wfd.GetNext())
	{
        if(wfd->dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY ||
            wfd->dwFileAttributes & FILE_ATTRIBUTE_OFFLINE || 
            (!wfd->nFileSizeHigh && !wfd->nFileSizeLow))
            continue;

		CombinePathFile(szSearch, (const CHAR *) bsPath, wfd->cFileName);
		szBuf = (CHAR *) mfFile.MapFile(szSearch, true);
		if(!szBuf)
		{
			mfFile.Close();
			continue;
		}

		if(!ParseTestServerXML(szBuf, szSerial, szKey, szKeyVer))
		{
			mfFile.Close();
			continue;
		}
		mfFile.Close();

		m_keys.AddRow(szSerial, szKey, szKeyVer);
	}
	return S_OK;
}

STDMETHODIMP CParser::ParseXMLFeed(BSTR bsXMLFeed)
{
	// TODO: Add your implementation code here
	if(!SysStringLen(bsXMLFeed))
		return E_INVALIDARG;
	_bstr_t bsXML = bsXMLFeed;
	TSafeStr<12> szSerial;
	TSafeStr<172> szKey;
	TSafeStr<4> szKeyVer;
	if(!ParseTestServerXML(bsXML, szSerial, szKey, szKeyVer))
		return S_FALSE;
	
	m_keys.AddRow(szSerial, szKey, szKeyVer);

	return S_OK;
}

STDMETHODIMP CParser::GetReport(BSTR* bsReport)
{
	// TODO: Add your implementation code here
	if(!bsReport)
		return E_INVALIDARG;

	_bstr_t bsRep;
	m_keys.GetReport(bsRep);
	*bsReport = bsRep.copy();
	return S_OK;
}

STDMETHODIMP CParser::GetFeedRows(BSTR* bsFeedRows)
{
	// TODO: Add your implementation code here
	if(!bsFeedRows)
		return E_INVALIDARG;
	_bstr_t bsFRs;
	m_keys.GetNewFeedRows(bsFRs);
	*bsFeedRows = bsFRs.copy();
	return S_OK;
}

STDMETHODIMP CParser::SetSourceDatabase(BSTR bsMachine, BSTR bsDatabase, BSTR bsUID, BSTR bsPWD, VARIANT_BOOL* fConnected)
{
	// TODO: Add your implementation code here
	if(!fConnected)
		return E_INVALIDARG;
	_bstr_t mac = bsMachine, db = bsDatabase, uid = bsUID, pwd = bsPWD;
	*fConnected = (m_keys.SetSourceDatabase(mac, db, uid, pwd)) ? VARIANT_TRUE : VARIANT_FALSE;
	return S_OK;
}

STDMETHODIMP CParser::Connected(VARIANT_BOOL* fConnected)
{
	// TODO: Add your implementation code here
	if(!fConnected)
		return E_INVALIDARG;
	*fConnected = (m_keys.Connected()) ? VARIANT_TRUE : VARIANT_FALSE;
	return S_OK;
}

STDMETHODIMP CParser::GetNoNewRowsPSQ(BSTR* bsPSQContent)
{
	if(!bsPSQContent)
		return E_INVALIDARG;
	_bstr_t bsPSQ;
	m_keys.GetNoNewRowsPSQ(bsPSQ);
	*bsPSQContent = bsPSQ.copy();
	return S_OK;
}

STDMETHODIMP CParser::GetAffectedBugsPSQ(BSTR* bsPSQContent)
{
	if(!bsPSQContent)
		return E_INVALIDARG;
	_bstr_t bsPSQ;
	m_keys.GetAffectedBugsPSQ(bsPSQ);
	*bsPSQContent = bsPSQ.copy();
	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\genealogy\geneadmin\GeneParser\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
// GeneParser.pch will be the pre-compiled header
// stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\genealogy\geneadmin\GeneParser\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Visual C++ generated include file.
// Used by GeneParser.rc
//
#define IDS_SERVICENAME                 100
#define IDR_GENEPARSER                  101
#define IDR_PARSER                      102

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        201
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           103
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\genealogy\geneadmin\GeneParser\parser.h ===
// Parser.h : Declaration of the CParser

#pragma once
#include "resource.h"       // main symbols
#include "keymgr.h"
#include "GeneParser.h"


// CParser

class ATL_NO_VTABLE CParser : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CParser, &CLSID_Parser>,
	public IDispatchImpl<IParser, &IID_IParser, &LIBID_GeneParserLib, /*wMajor =*/ 1, /*wMinor =*/ 0>
{
public:
	CParser();

DECLARE_REGISTRY_RESOURCEID(IDR_PARSER)


BEGIN_COM_MAP(CParser)
	COM_INTERFACE_ENTRY(IParser)
	COM_INTERFACE_ENTRY(IDispatch)
END_COM_MAP()


	DECLARE_PROTECT_FINAL_CONSTRUCT()

	HRESULT FinalConstruct()
	{
		return S_OK;
	}
	
	void FinalRelease() 
	{
	}

protected:
	CKeyMgr m_keys;

public:
	STDMETHOD(SetSourceDatabase)(BSTR bsMachine, BSTR bsDatabase, BSTR bsUID, BSTR bsPWD, VARIANT_BOOL* fConnected);
	STDMETHOD(Connected)(VARIANT_BOOL* fConnected);
	STDMETHOD(ParseAMFeed)(BSTR bsAMFeed);
	STDMETHOD(ParseXMLFiles)(BSTR bsSourcePath);
	STDMETHOD(ParseXMLFeed)(BSTR bsXMLFeed);
	STDMETHOD(GetReport)(BSTR* bsReport);
	STDMETHOD(GetFeedRows)(BSTR* bsFeedRows);
	STDMETHOD(GetNoNewRowsPSQ)(BSTR* bsPSQContent);
	STDMETHOD(GetAffectedBugsPSQ)(BSTR* bsPSQContent);
};

OBJECT_ENTRY_AUTO(__uuidof(Parser), CParser)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\genealogy\geneadmin\GeneParser\xmlparse.h ===
#pragma once

DWORD ParseTestServerXML(const CHAR *szText, TSafeStr<12> &szSerial, TSafeStr<172> &szOnlineKey, TSafeStr<4> &szKeyVersion);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\genealogy\geneadmin\GeneParser\stdafx.h ===
// stdafx.h : include file for standard system include files,
// or project specific include files that are used frequently,
// but are changed infrequently

#pragma once

#ifndef STRICT
#define STRICT
#endif

#undef UNICODE
#undef _UNICODE

#undef WIN32_LEAN_AND_MEAN

// Modify the following defines if you have to target a platform prior to the ones specified below.
// Refer to MSDN for the latest info on corresponding values for different platforms.
#ifndef WINVER				// Allow use of features specific to Windows 95 and Windows NT 4 or later.
#define WINVER 0x0400		// Change this to the appropriate value to target Windows 98 and Windows 2000 or later.
#endif

#ifndef _WIN32_WINNT		// Allow use of features specific to Windows NT 4 or later.
#define _WIN32_WINNT 0x0400	// Change this to the appropriate value to target Windows 2000 or later.
#endif						

#ifndef _WIN32_WINDOWS		// Allow use of features specific to Windows 98 or later.
#define _WIN32_WINDOWS 0x0410 // Change this to the appropriate value to target Windows Me or later.
#endif

#ifndef _WIN32_IE			// Allow use of features specific to IE 4.0 or later.
#define _WIN32_IE 0x0400	// Change this to the appropriate value to target IE 5.0 or later.
#endif

#define _ATL_APARTMENT_THREADED
#define _ATL_NO_AUTOMATIC_NAMESPACE

#define _ATL_CSTRING_EXPLICIT_CONSTRUCTORS	// some CString constructors will be explicit

// turns off ATL's hiding of some common and often safely ignored warning messages
#define _ATL_ALL_WARNINGS


#include "resource.h"
#include <atlbase.h>
#include <atlcom.h>
#include <winioctl.h>
#include <comutil.h>
#include <assert.h>
#include <stdio.h>

#include "dbaccessor.h"
#include "strcls.h"
using namespace ATL;
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\genealogy\geneadmin\GeneParser\xmlparse.cpp ===
#include "stdafx.h"
#include <winioctl.h>
#include "utility.h"
#include "base64.h"

DWORD ParseTestServerXML(const CHAR *szText, TSafeStr<12> &szSerial, TSafeStr<172> &szOnlineKey, TSafeStr<4> &szKeyVersion)
{
	CHAR szBuf[130];
	DWORD dwBufSize = sizeof(szBuf);
    DWORD dwRes = 0;
    const CHAR *szPos;
    
    szPos = strstr(szText, "<SerialNumber>");
    if(!szPos)
        goto Exit;
    szPos += 14;
    szPos += WSCount(szPos);
    if(12 != DigitCount(szPos))
        goto Exit;
    szSerial.CopyN(szPos, 12);
    
    szPos = strstr(szPos, "<OnLineKeyVer>");
    if(!szPos)
        goto Exit;
    szPos += 14;
    szPos += WSCount(szPos);
    if(4 != DigitCount(szPos))
        goto Exit;
    szKeyVersion.CopyN(szPos, 4);

    szPos = strstr(szPos, "<OnLineKey>");
    if(!szPos)
        goto Exit;
    szPos += 11;
    szPos += WSCount(szPos);
    if(172 != Base64Count(szPos))
        goto Exit;
	if(!Base64Decode(szPos, 172, (LPBYTE) szBuf, &dwBufSize))
		goto Exit;
    szOnlineKey.CopyN(szPos, 172);

    dwRes = 1;
Exit:
    if(1 != dwRes)
        szSerial = "";
    
    return dwRes;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\genealogy\geneadmin\GeneParser\obj\i386\dlldata.c ===
/*********************************************************
   DllData file -- generated by MIDL compiler 

        DO NOT ALTER THIS FILE

   This file is regenerated by MIDL on every IDL file compile.

   To completely reconstruct this file, delete it and rerun MIDL
   on all the IDL files in this DLL, specifying this file for the
   /dlldata command line option

*********************************************************/

#define PROXY_DELEGATION

#include <rpcproxy.h>

#ifdef __cplusplus
extern "C"   {
#endif

EXTERN_PROXY_FILE( geneparser )


PROXYFILE_LIST_START
/* Start of list */
  REFERENCE_PROXY_FILE( geneparser ),
/* End of list */
PROXYFILE_LIST_END


DLLDATA_ROUTINES( aProxyFileList, GET_DLL_CLSID )

#ifdef __cplusplus
}  /*extern "C" */
#endif

/* end of generated dlldata file */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\genealogy\geneadmin\GeneParser\objd\i386\dlldata.c ===
/*********************************************************
   DllData file -- generated by MIDL compiler 

        DO NOT ALTER THIS FILE

   This file is regenerated by MIDL on every IDL file compile.

   To completely reconstruct this file, delete it and rerun MIDL
   on all the IDL files in this DLL, specifying this file for the
   /dlldata command line option

*********************************************************/

#define PROXY_DELEGATION

#include <rpcproxy.h>

#ifdef __cplusplus
extern "C"   {
#endif

EXTERN_PROXY_FILE( geneparser )


PROXYFILE_LIST_START
/* Start of list */
  REFERENCE_PROXY_FILE( geneparser ),
/* End of list */
PROXYFILE_LIST_END


DLLDATA_ROUTINES( aProxyFileList, GET_DLL_CLSID )

#ifdef __cplusplus
}  /*extern "C" */
#endif

/* end of generated dlldata file */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\genealogy\geneadmin\GeneParser\obj\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86_geneparser_none_12.4.56.0_none_f000a9a65930fa26
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86_geneparser_no-public-key_12.4.56.0_x-ww_458beeaa
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=geneparser
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86_geneparser_no-public-key_12.4.56.0_x-ww_458beeaa
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86_geneparser_no-public-key_12.4.56.0_x-ww_458beeaa.manifest
XP_MANIFEST_PATH=manifests\x86_geneparser_no-public-key_12.4.56.0_x-ww_458beeaa.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86_geneparser_no-public-key_12.4.56.0_x-ww_458beeaa.cat
XP_CATALOG_PATH=manifests\x86_geneparser_no-public-key_12.4.56.0_x-ww_458beeaa.cat
XP_PAYLOAD_PATH=x86_geneparser_no-public-key_12.4.56.0_x-ww_458beeaa
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=geneparser,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\genealogy\geneadmin\GeneParser\objd\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86_geneparser_none_12.4.56.0_none_f000a9a65930fa26
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86_geneparser_no-public-key_12.4.56.0_x-ww_458beeaa
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=geneparser
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86_geneparser_no-public-key_12.4.56.0_x-ww_458beeaa
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86_geneparser_no-public-key_12.4.56.0_x-ww_458beeaa.manifest
XP_MANIFEST_PATH=manifests\x86_geneparser_no-public-key_12.4.56.0_x-ww_458beeaa.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86_geneparser_no-public-key_12.4.56.0_x-ww_458beeaa.cat
XP_CATALOG_PATH=manifests\x86_geneparser_no-public-key_12.4.56.0_x-ww_458beeaa.cat
XP_PAYLOAD_PATH=x86_geneparser_no-public-key_12.4.56.0_x-ww_458beeaa
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=geneparser,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\genealogy\geneadmin\GeneParser\obj\i386\geneparser_i.c ===
/* this ALWAYS GENERATED file contains the IIDs and CLSIDs */

/* link this file in with the server and any clients */


 /* File created by MIDL compiler version 7.00.0500 */
/* Compiler settings for geneparser.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, oldnames, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#pragma warning( disable: 4049 )  /* more than 64k source lines */


#ifdef __cplusplus
extern "C"{
#endif 


#include <rpc.h>
#include <rpcndr.h>

#ifdef _MIDL_USE_GUIDDEF_

#ifndef INITGUID
#define INITGUID
#include <guiddef.h>
#undef INITGUID
#else
#include <guiddef.h>
#endif

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        DEFINE_GUID(name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8)

#else // !_MIDL_USE_GUIDDEF_

#ifndef __IID_DEFINED__
#define __IID_DEFINED__

typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;

#endif // __IID_DEFINED__

#ifndef CLSID_DEFINED
#define CLSID_DEFINED
typedef IID CLSID;
#endif // CLSID_DEFINED

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        const type name = {l,w1,w2,{b1,b2,b3,b4,b5,b6,b7,b8}}

#endif !_MIDL_USE_GUIDDEF_

MIDL_DEFINE_GUID(IID, IID_IParser,0x470CDB4D,0x5FEA,0x44A5,0xBC,0x4F,0x6D,0x5C,0x68,0xA3,0x73,0xC2);


MIDL_DEFINE_GUID(IID, LIBID_GeneParserLib,0x0755BE4F,0x2361,0x479B,0xBF,0xCC,0x29,0x5F,0xFB,0x67,0x59,0x2F);


MIDL_DEFINE_GUID(CLSID, CLSID_Parser,0xC5D3928E,0xE971,0x4FBB,0xA1,0xC2,0x07,0xBC,0xBC,0xC7,0xC7,0xB6);

#undef MIDL_DEFINE_GUID

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\genealogy\geneadmin\GeneParser\objd\i386\geneparser_i.c ===
/* this ALWAYS GENERATED file contains the IIDs and CLSIDs */

/* link this file in with the server and any clients */


 /* File created by MIDL compiler version 7.00.0500 */
/* Compiler settings for geneparser.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, oldnames, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#pragma warning( disable: 4049 )  /* more than 64k source lines */


#ifdef __cplusplus
extern "C"{
#endif 


#include <rpc.h>
#include <rpcndr.h>

#ifdef _MIDL_USE_GUIDDEF_

#ifndef INITGUID
#define INITGUID
#include <guiddef.h>
#undef INITGUID
#else
#include <guiddef.h>
#endif

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        DEFINE_GUID(name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8)

#else // !_MIDL_USE_GUIDDEF_

#ifndef __IID_DEFINED__
#define __IID_DEFINED__

typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;

#endif // __IID_DEFINED__

#ifndef CLSID_DEFINED
#define CLSID_DEFINED
typedef IID CLSID;
#endif // CLSID_DEFINED

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        const type name = {l,w1,w2,{b1,b2,b3,b4,b5,b6,b7,b8}}

#endif !_MIDL_USE_GUIDDEF_

MIDL_DEFINE_GUID(IID, IID_IParser,0x470CDB4D,0x5FEA,0x44A5,0xBC,0x4F,0x6D,0x5C,0x68,0xA3,0x73,0xC2);


MIDL_DEFINE_GUID(IID, LIBID_GeneParserLib,0x0755BE4F,0x2361,0x479B,0xBF,0xCC,0x29,0x5F,0xFB,0x67,0x59,0x2F);


MIDL_DEFINE_GUID(CLSID, CLSID_Parser,0xC5D3928E,0xE971,0x4FBB,0xA1,0xC2,0x07,0xBC,0xBC,0xC7,0xC7,0xB6);

#undef MIDL_DEFINE_GUID

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\genealogy\geneadmin\GeneParser\objd\i386\geneparser_p.c ===
/* this ALWAYS GENERATED file contains the proxy stub code */


 /* File created by MIDL compiler version 7.00.0500 */
/* Compiler settings for geneparser.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, oldnames, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#if !defined(_M_IA64) && !defined(_M_AMD64)


#pragma warning( disable: 4049 )  /* more than 64k source lines */
#if _MSC_VER >= 1200
#pragma warning(push)
#endif

#pragma warning( disable: 4211 )  /* redefine extern to static */
#pragma warning( disable: 4232 )  /* dllimport identity*/
#pragma warning( disable: 4024 )  /* array to pointer mapping*/
#pragma warning( disable: 4152 )  /* function/data pointer conversion in expression */
#pragma warning( disable: 4100 ) /* unreferenced arguments in x86 call */

#pragma optimize("", off ) 

#define USE_STUBLESS_PROXY


/* verify that the <rpcproxy.h> version is high enough to compile this file*/
#ifndef __REDQ_RPCPROXY_H_VERSION__
#define __REQUIRED_RPCPROXY_H_VERSION__ 475
#endif


#include "rpcproxy.h"
#ifndef __RPCPROXY_H_VERSION__
#error this stub requires an updated version of <rpcproxy.h>
#endif // __RPCPROXY_H_VERSION__


#include "geneparser.h"

#define TYPE_FORMAT_STRING_SIZE   71                                
#define PROC_FORMAT_STRING_SIZE   349                               
#define EXPR_FORMAT_STRING_SIZE   1                                 
#define TRANSMIT_AS_TABLE_SIZE    0            
#define WIRE_MARSHAL_TABLE_SIZE   1            

typedef struct _geneparser_MIDL_TYPE_FORMAT_STRING
    {
    short          Pad;
    unsigned char  Format[ TYPE_FORMAT_STRING_SIZE ];
    } geneparser_MIDL_TYPE_FORMAT_STRING;

typedef struct _geneparser_MIDL_PROC_FORMAT_STRING
    {
    short          Pad;
    unsigned char  Format[ PROC_FORMAT_STRING_SIZE ];
    } geneparser_MIDL_PROC_FORMAT_STRING;

typedef struct _geneparser_MIDL_EXPR_FORMAT_STRING
    {
    long          Pad;
    unsigned char  Format[ EXPR_FORMAT_STRING_SIZE ];
    } geneparser_MIDL_EXPR_FORMAT_STRING;


static RPC_SYNTAX_IDENTIFIER  _RpcTransferSyntax = 
{{0x8A885D04,0x1CEB,0x11C9,{0x9F,0xE8,0x08,0x00,0x2B,0x10,0x48,0x60}},{2,0}};


extern const geneparser_MIDL_TYPE_FORMAT_STRING geneparser__MIDL_TypeFormatString;
extern const geneparser_MIDL_PROC_FORMAT_STRING geneparser__MIDL_ProcFormatString;
extern const geneparser_MIDL_EXPR_FORMAT_STRING geneparser__MIDL_ExprFormatString;


extern const MIDL_STUB_DESC Object_StubDesc;


extern const MIDL_SERVER_INFO IParser_ServerInfo;
extern const MIDL_STUBLESS_PROXY_INFO IParser_ProxyInfo;


extern const USER_MARSHAL_ROUTINE_QUADRUPLE UserMarshalRoutines[ WIRE_MARSHAL_TABLE_SIZE ];

#if !defined(__RPC_WIN32__)
#error  Invalid build platform for this stub.
#endif
#if !(TARGET_IS_NT51_OR_LATER)
#error You need a Windows XP or later to run this stub because it uses these features:
#error   #error However, your C/C++ compilation flags indicate you intend to run this app on earlier systems.
#error This app will fail with the RPC_X_WRONG_STUB_VERSION error.
#endif


static const geneparser_MIDL_PROC_FORMAT_STRING geneparser__MIDL_ProcFormatString =
    {
        0,
        {

	/* Procedure ParseAMFeed */

			0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/*  2 */	NdrFcLong( 0x0 ),	/* 0 */
/*  6 */	NdrFcShort( 0x7 ),	/* 7 */
/*  8 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 10 */	NdrFcShort( 0x0 ),	/* 0 */
/* 12 */	NdrFcShort( 0x8 ),	/* 8 */
/* 14 */	0x46,		/* Oi2 Flags:  clt must size, has return, has ext, */
			0x2,		/* 2 */
/* 16 */	0x8,		/* 8 */
			0x45,		/* Ext Flags:  new corr desc, srv corr check, has range on conformance */
/* 18 */	NdrFcShort( 0x0 ),	/* 0 */
/* 20 */	NdrFcShort( 0x1 ),	/* 1 */
/* 22 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter bsAMFeed */

/* 24 */	NdrFcShort( 0x8b ),	/* Flags:  must size, must free, in, by val, */
/* 26 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 28 */	NdrFcShort( 0x26 ),	/* Type Offset=38 */

	/* Return value */

/* 30 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 32 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 34 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure ParseXMLFiles */

/* 36 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 38 */	NdrFcLong( 0x0 ),	/* 0 */
/* 42 */	NdrFcShort( 0x8 ),	/* 8 */
/* 44 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 46 */	NdrFcShort( 0x0 ),	/* 0 */
/* 48 */	NdrFcShort( 0x8 ),	/* 8 */
/* 50 */	0x46,		/* Oi2 Flags:  clt must size, has return, has ext, */
			0x2,		/* 2 */
/* 52 */	0x8,		/* 8 */
			0x45,		/* Ext Flags:  new corr desc, srv corr check, has range on conformance */
/* 54 */	NdrFcShort( 0x0 ),	/* 0 */
/* 56 */	NdrFcShort( 0x4 ),	/* 4 */
/* 58 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter bsSourcePath */

/* 60 */	NdrFcShort( 0x8b ),	/* Flags:  must size, must free, in, by val, */
/* 62 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 64 */	NdrFcShort( 0x26 ),	/* Type Offset=38 */

	/* Return value */

/* 66 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 68 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 70 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure ParseXMLFeed */

/* 72 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 74 */	NdrFcLong( 0x0 ),	/* 0 */
/* 78 */	NdrFcShort( 0x9 ),	/* 9 */
/* 80 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 82 */	NdrFcShort( 0x0 ),	/* 0 */
/* 84 */	NdrFcShort( 0x8 ),	/* 8 */
/* 86 */	0x46,		/* Oi2 Flags:  clt must size, has return, has ext, */
			0x2,		/* 2 */
/* 88 */	0x8,		/* 8 */
			0x45,		/* Ext Flags:  new corr desc, srv corr check, has range on conformance */
/* 90 */	NdrFcShort( 0x0 ),	/* 0 */
/* 92 */	NdrFcShort( 0x4 ),	/* 4 */
/* 94 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter bsXMLFeed */

/* 96 */	NdrFcShort( 0x8b ),	/* Flags:  must size, must free, in, by val, */
/* 98 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 100 */	NdrFcShort( 0x26 ),	/* Type Offset=38 */

	/* Return value */

/* 102 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 104 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 106 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetReport */

/* 108 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 110 */	NdrFcLong( 0x0 ),	/* 0 */
/* 114 */	NdrFcShort( 0xa ),	/* 10 */
/* 116 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 118 */	NdrFcShort( 0x0 ),	/* 0 */
/* 120 */	NdrFcShort( 0x8 ),	/* 8 */
/* 122 */	0x45,		/* Oi2 Flags:  srv must size, has return, has ext, */
			0x2,		/* 2 */
/* 124 */	0x8,		/* 8 */
			0x43,		/* Ext Flags:  new corr desc, clt corr check, has range on conformance */
/* 126 */	NdrFcShort( 0x1 ),	/* 1 */
/* 128 */	NdrFcShort( 0x0 ),	/* 0 */
/* 130 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter bsReport */

/* 132 */	NdrFcShort( 0x2113 ),	/* Flags:  must size, must free, out, simple ref, srv alloc size=8 */
/* 134 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 136 */	NdrFcShort( 0x38 ),	/* Type Offset=56 */

	/* Return value */

/* 138 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 140 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 142 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetFeedRows */

/* 144 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 146 */	NdrFcLong( 0x0 ),	/* 0 */
/* 150 */	NdrFcShort( 0xb ),	/* 11 */
/* 152 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 154 */	NdrFcShort( 0x0 ),	/* 0 */
/* 156 */	NdrFcShort( 0x8 ),	/* 8 */
/* 158 */	0x45,		/* Oi2 Flags:  srv must size, has return, has ext, */
			0x2,		/* 2 */
/* 160 */	0x8,		/* 8 */
			0x43,		/* Ext Flags:  new corr desc, clt corr check, has range on conformance */
/* 162 */	NdrFcShort( 0x5 ),	/* 5 */
/* 164 */	NdrFcShort( 0x0 ),	/* 0 */
/* 166 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter bsFeedRows */

/* 168 */	NdrFcShort( 0x2113 ),	/* Flags:  must size, must free, out, simple ref, srv alloc size=8 */
/* 170 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 172 */	NdrFcShort( 0x38 ),	/* Type Offset=56 */

	/* Return value */

/* 174 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 176 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 178 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure SetSourceDatabase */

/* 180 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 182 */	NdrFcLong( 0x0 ),	/* 0 */
/* 186 */	NdrFcShort( 0xc ),	/* 12 */
/* 188 */	NdrFcShort( 0x1c ),	/* x86 Stack size/offset = 28 */
/* 190 */	NdrFcShort( 0x0 ),	/* 0 */
/* 192 */	NdrFcShort( 0x22 ),	/* 34 */
/* 194 */	0x46,		/* Oi2 Flags:  clt must size, has return, has ext, */
			0x6,		/* 6 */
/* 196 */	0x8,		/* 8 */
			0x45,		/* Ext Flags:  new corr desc, srv corr check, has range on conformance */
/* 198 */	NdrFcShort( 0x0 ),	/* 0 */
/* 200 */	NdrFcShort( 0x13 ),	/* 19 */
/* 202 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter bsMachine */

/* 204 */	NdrFcShort( 0x8b ),	/* Flags:  must size, must free, in, by val, */
/* 206 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 208 */	NdrFcShort( 0x26 ),	/* Type Offset=38 */

	/* Parameter bsDatabase */

/* 210 */	NdrFcShort( 0x8b ),	/* Flags:  must size, must free, in, by val, */
/* 212 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 214 */	NdrFcShort( 0x26 ),	/* Type Offset=38 */

	/* Parameter bsUID */

/* 216 */	NdrFcShort( 0x8b ),	/* Flags:  must size, must free, in, by val, */
/* 218 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 220 */	NdrFcShort( 0x26 ),	/* Type Offset=38 */

	/* Parameter bsPWD */

/* 222 */	NdrFcShort( 0x8b ),	/* Flags:  must size, must free, in, by val, */
/* 224 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 226 */	NdrFcShort( 0x26 ),	/* Type Offset=38 */

	/* Parameter fConnected */

/* 228 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
/* 230 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
/* 232 */	0x6,		/* FC_SHORT */
			0x0,		/* 0 */

	/* Return value */

/* 234 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 236 */	NdrFcShort( 0x18 ),	/* x86 Stack size/offset = 24 */
/* 238 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure Connected */

/* 240 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 242 */	NdrFcLong( 0x0 ),	/* 0 */
/* 246 */	NdrFcShort( 0xd ),	/* 13 */
/* 248 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 250 */	NdrFcShort( 0x0 ),	/* 0 */
/* 252 */	NdrFcShort( 0x22 ),	/* 34 */
/* 254 */	0x44,		/* Oi2 Flags:  has return, has ext, */
			0x2,		/* 2 */
/* 256 */	0x8,		/* 8 */
			0x41,		/* Ext Flags:  new corr desc, has range on conformance */
/* 258 */	NdrFcShort( 0x0 ),	/* 0 */
/* 260 */	NdrFcShort( 0x0 ),	/* 0 */
/* 262 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter fConnected */

/* 264 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
/* 266 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 268 */	0x6,		/* FC_SHORT */
			0x0,		/* 0 */

	/* Return value */

/* 270 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 272 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 274 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetNoNewRowsPSQ */

/* 276 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 278 */	NdrFcLong( 0x0 ),	/* 0 */
/* 282 */	NdrFcShort( 0xe ),	/* 14 */
/* 284 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 286 */	NdrFcShort( 0x0 ),	/* 0 */
/* 288 */	NdrFcShort( 0x8 ),	/* 8 */
/* 290 */	0x45,		/* Oi2 Flags:  srv must size, has return, has ext, */
			0x2,		/* 2 */
/* 292 */	0x8,		/* 8 */
			0x43,		/* Ext Flags:  new corr desc, clt corr check, has range on conformance */
/* 294 */	NdrFcShort( 0x1 ),	/* 1 */
/* 296 */	NdrFcShort( 0x0 ),	/* 0 */
/* 298 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter bsPSQContent */

/* 300 */	NdrFcShort( 0x2113 ),	/* Flags:  must size, must free, out, simple ref, srv alloc size=8 */
/* 302 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 304 */	NdrFcShort( 0x38 ),	/* Type Offset=56 */

	/* Return value */

/* 306 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 308 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 310 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetAffectedBugsPSQ */

/* 312 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 314 */	NdrFcLong( 0x0 ),	/* 0 */
/* 318 */	NdrFcShort( 0xf ),	/* 15 */
/* 320 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 322 */	NdrFcShort( 0x0 ),	/* 0 */
/* 324 */	NdrFcShort( 0x8 ),	/* 8 */
/* 326 */	0x45,		/* Oi2 Flags:  srv must size, has return, has ext, */
			0x2,		/* 2 */
/* 328 */	0x8,		/* 8 */
			0x43,		/* Ext Flags:  new corr desc, clt corr check, has range on conformance */
/* 330 */	NdrFcShort( 0x7 ),	/* 7 */
/* 332 */	NdrFcShort( 0x0 ),	/* 0 */
/* 334 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter bsPSQContent */

/* 336 */	NdrFcShort( 0x2113 ),	/* Flags:  must size, must free, out, simple ref, srv alloc size=8 */
/* 338 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 340 */	NdrFcShort( 0x38 ),	/* Type Offset=56 */

	/* Return value */

/* 342 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 344 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 346 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

			0x0
        }
    };

static const geneparser_MIDL_TYPE_FORMAT_STRING geneparser__MIDL_TypeFormatString =
    {
        0,
        {
			NdrFcShort( 0x0 ),	/* 0 */
/*  2 */	
			0x12, 0x0,	/* FC_UP */
/*  4 */	NdrFcShort( 0x18 ),	/* Offset= 24 (28) */
/*  6 */	
			0x1b,		/* FC_CARRAY */
			0x1,		/* 1 */
/*  8 */	NdrFcShort( 0x2 ),	/* 2 */
/* 10 */	0x9,		/* Corr desc: FC_ULONG */
			0x0,		/*  */
/* 12 */	NdrFcShort( 0xfffc ),	/* -4 */
/* 14 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 16 */	0x0 , 
			0x0,		/* 0 */
/* 18 */	NdrFcLong( 0x0 ),	/* 0 */
/* 22 */	NdrFcLong( 0x0 ),	/* 0 */
/* 26 */	0x6,		/* FC_SHORT */
			0x5b,		/* FC_END */
/* 28 */	
			0x17,		/* FC_CSTRUCT */
			0x3,		/* 3 */
/* 30 */	NdrFcShort( 0x8 ),	/* 8 */
/* 32 */	NdrFcShort( 0xffe6 ),	/* Offset= -26 (6) */
/* 34 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 36 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 38 */	0xb4,		/* FC_USER_MARSHAL */
			0x83,		/* 131 */
/* 40 */	NdrFcShort( 0x0 ),	/* 0 */
/* 42 */	NdrFcShort( 0x4 ),	/* 4 */
/* 44 */	NdrFcShort( 0x0 ),	/* 0 */
/* 46 */	NdrFcShort( 0xffd4 ),	/* Offset= -44 (2) */
/* 48 */	
			0x11, 0x4,	/* FC_RP [alloced_on_stack] */
/* 50 */	NdrFcShort( 0x6 ),	/* Offset= 6 (56) */
/* 52 */	
			0x13, 0x0,	/* FC_OP */
/* 54 */	NdrFcShort( 0xffe6 ),	/* Offset= -26 (28) */
/* 56 */	0xb4,		/* FC_USER_MARSHAL */
			0x83,		/* 131 */
/* 58 */	NdrFcShort( 0x0 ),	/* 0 */
/* 60 */	NdrFcShort( 0x4 ),	/* 4 */
/* 62 */	NdrFcShort( 0x0 ),	/* 0 */
/* 64 */	NdrFcShort( 0xfff4 ),	/* Offset= -12 (52) */
/* 66 */	
			0x11, 0xc,	/* FC_RP [alloced_on_stack] [simple_pointer] */
/* 68 */	0x6,		/* FC_SHORT */
			0x5c,		/* FC_PAD */

			0x0
        }
    };

static const USER_MARSHAL_ROUTINE_QUADRUPLE UserMarshalRoutines[ WIRE_MARSHAL_TABLE_SIZE ] = 
        {
            
            {
            BSTR_UserSize
            ,BSTR_UserMarshal
            ,BSTR_UserUnmarshal
            ,BSTR_UserFree
            }

        };



/* Object interface: IUnknown, ver. 0.0,
   GUID={0x00000000,0x0000,0x0000,{0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46}} */


/* Object interface: IDispatch, ver. 0.0,
   GUID={0x00020400,0x0000,0x0000,{0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46}} */


/* Object interface: IParser, ver. 0.0,
   GUID={0x470CDB4D,0x5FEA,0x44A5,{0xBC,0x4F,0x6D,0x5C,0x68,0xA3,0x73,0xC2}} */

#pragma code_seg(".orpc")
static const unsigned short IParser_FormatStringOffsetTable[] =
    {
    (unsigned short) -1,
    (unsigned short) -1,
    (unsigned short) -1,
    (unsigned short) -1,
    0,
    36,
    72,
    108,
    144,
    180,
    240,
    276,
    312
    };

static const MIDL_STUBLESS_PROXY_INFO IParser_ProxyInfo =
    {
    &Object_StubDesc,
    geneparser__MIDL_ProcFormatString.Format,
    &IParser_FormatStringOffsetTable[-3],
    0,
    0,
    0
    };


static const MIDL_SERVER_INFO IParser_ServerInfo = 
    {
    &Object_StubDesc,
    0,
    geneparser__MIDL_ProcFormatString.Format,
    &IParser_FormatStringOffsetTable[-3],
    0,
    0,
    0,
    0};
CINTERFACE_PROXY_VTABLE(16) _IParserProxyVtbl = 
{
    &IParser_ProxyInfo,
    &IID_IParser,
    IUnknown_QueryInterface_Proxy,
    IUnknown_AddRef_Proxy,
    IUnknown_Release_Proxy ,
    0 /* (void *) (INT_PTR) -1 /* IDispatch::GetTypeInfoCount */ ,
    0 /* (void *) (INT_PTR) -1 /* IDispatch::GetTypeInfo */ ,
    0 /* (void *) (INT_PTR) -1 /* IDispatch::GetIDsOfNames */ ,
    0 /* IDispatch_Invoke_Proxy */ ,
    (void *) (INT_PTR) -1 /* IParser::ParseAMFeed */ ,
    (void *) (INT_PTR) -1 /* IParser::ParseXMLFiles */ ,
    (void *) (INT_PTR) -1 /* IParser::ParseXMLFeed */ ,
    (void *) (INT_PTR) -1 /* IParser::GetReport */ ,
    (void *) (INT_PTR) -1 /* IParser::GetFeedRows */ ,
    (void *) (INT_PTR) -1 /* IParser::SetSourceDatabase */ ,
    (void *) (INT_PTR) -1 /* IParser::Connected */ ,
    (void *) (INT_PTR) -1 /* IParser::GetNoNewRowsPSQ */ ,
    (void *) (INT_PTR) -1 /* IParser::GetAffectedBugsPSQ */
};


static const PRPC_STUB_FUNCTION IParser_table[] =
{
    STUB_FORWARDING_FUNCTION,
    STUB_FORWARDING_FUNCTION,
    STUB_FORWARDING_FUNCTION,
    STUB_FORWARDING_FUNCTION,
    NdrStubCall2,
    NdrStubCall2,
    NdrStubCall2,
    NdrStubCall2,
    NdrStubCall2,
    NdrStubCall2,
    NdrStubCall2,
    NdrStubCall2,
    NdrStubCall2
};

CInterfaceStubVtbl _IParserStubVtbl =
{
    &IID_IParser,
    &IParser_ServerInfo,
    16,
    &IParser_table[-3],
    CStdStubBuffer_DELEGATING_METHODS
};

static const MIDL_STUB_DESC Object_StubDesc = 
    {
    0,
    NdrOleAllocate,
    NdrOleFree,
    0,
    0,
    0,
    0,
    0,
    geneparser__MIDL_TypeFormatString.Format,
    1, /* -error bounds_check flag */
    0x60001, /* Ndr library version */
    0,
    0x70001f4, /* MIDL Version 7.0.500 */
    0,
    UserMarshalRoutines,
    0,  /* notify & notify_flag routine table */
    0x1, /* MIDL flag */
    0, /* cs routines */
    0,   /* proxy/server info */
    0
    };

const CInterfaceProxyVtbl * _geneparser_ProxyVtblList[] = 
{
    ( CInterfaceProxyVtbl *) &_IParserProxyVtbl,
    0
};

const CInterfaceStubVtbl * _geneparser_StubVtblList[] = 
{
    ( CInterfaceStubVtbl *) &_IParserStubVtbl,
    0
};

PCInterfaceName const _geneparser_InterfaceNamesList[] = 
{
    "IParser",
    0
};

const IID *  _geneparser_BaseIIDList[] = 
{
    &IID_IDispatch,
    0
};


#define _geneparser_CHECK_IID(n)	IID_GENERIC_CHECK_IID( _geneparser, pIID, n)

int __stdcall _geneparser_IID_Lookup( const IID * pIID, int * pIndex )
{
    
    if(!_geneparser_CHECK_IID(0))
        {
        *pIndex = 0;
        return 1;
        }

    return 0;
}

const ExtendedProxyFileInfo geneparser_ProxyFileInfo = 
{
    (PCInterfaceProxyVtblList *) & _geneparser_ProxyVtblList,
    (PCInterfaceStubVtblList *) & _geneparser_StubVtblList,
    (const PCInterfaceName * ) & _geneparser_InterfaceNamesList,
    (const IID ** ) & _geneparser_BaseIIDList,
    & _geneparser_IID_Lookup, 
    1,
    2,
    0, /* table of [async_uuid] interfaces */
    0, /* Filler1 */
    0, /* Filler2 */
    0  /* Filler3 */
};
#pragma optimize("", on )
#if _MSC_VER >= 1200
#pragma warning(pop)
#endif


#endif /* !defined(_M_IA64) && !defined(_M_AMD64)*/
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\genealogy\geneadmin\GeneParser\obj\i386\geneparser.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 7.00.0500 */
/* Compiler settings for geneparser.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, oldnames, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#pragma warning( disable: 4049 )  /* more than 64k source lines */


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 500
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __geneparser_h__
#define __geneparser_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __IParser_FWD_DEFINED__
#define __IParser_FWD_DEFINED__
typedef interface IParser IParser;
#endif 	/* __IParser_FWD_DEFINED__ */


#ifndef __Parser_FWD_DEFINED__
#define __Parser_FWD_DEFINED__

#ifdef __cplusplus
typedef class Parser Parser;
#else
typedef struct Parser Parser;
#endif /* __cplusplus */

#endif 	/* __Parser_FWD_DEFINED__ */


/* header files for imported files */
#include "oaidl.h"
#include "ocidl.h"

#ifdef __cplusplus
extern "C"{
#endif 


#ifndef __IParser_INTERFACE_DEFINED__
#define __IParser_INTERFACE_DEFINED__

/* interface IParser */
/* [unique][helpstring][nonextensible][dual][uuid][object] */ 


EXTERN_C const IID IID_IParser;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("470CDB4D-5FEA-44A5-BC4F-6D5C68A373C2")
    IParser : public IDispatch
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ParseAMFeed( 
            /* [in] */ BSTR bsAMFeed) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ParseXMLFiles( 
            /* [in] */ BSTR bsSourcePath) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ParseXMLFeed( 
            /* [in] */ BSTR bsXMLFeed) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetReport( 
            /* [retval][out] */ BSTR *bsReport) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetFeedRows( 
            /* [retval][out] */ BSTR *bsFeedRows) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE SetSourceDatabase( 
            /* [in] */ BSTR bsMachine,
            /* [in] */ BSTR bsDatabase,
            /* [defaultvalue][in] */ BSTR bsUID,
            /* [defaultvalue][in] */ BSTR bsPWD,
            /* [retval][out] */ VARIANT_BOOL *fConnected) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Connected( 
            /* [retval][out] */ VARIANT_BOOL *fConnected) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetNoNewRowsPSQ( 
            /* [retval][out] */ BSTR *bsPSQContent) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetAffectedBugsPSQ( 
            /* [retval][out] */ BSTR *bsPSQContent) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IParserVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IParser * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IParser * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IParser * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IParser * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IParser * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IParser * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IParser * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *ParseAMFeed )( 
            IParser * This,
            /* [in] */ BSTR bsAMFeed);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *ParseXMLFiles )( 
            IParser * This,
            /* [in] */ BSTR bsSourcePath);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *ParseXMLFeed )( 
            IParser * This,
            /* [in] */ BSTR bsXMLFeed);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetReport )( 
            IParser * This,
            /* [retval][out] */ BSTR *bsReport);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetFeedRows )( 
            IParser * This,
            /* [retval][out] */ BSTR *bsFeedRows);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *SetSourceDatabase )( 
            IParser * This,
            /* [in] */ BSTR bsMachine,
            /* [in] */ BSTR bsDatabase,
            /* [defaultvalue][in] */ BSTR bsUID,
            /* [defaultvalue][in] */ BSTR bsPWD,
            /* [retval][out] */ VARIANT_BOOL *fConnected);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Connected )( 
            IParser * This,
            /* [retval][out] */ VARIANT_BOOL *fConnected);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetNoNewRowsPSQ )( 
            IParser * This,
            /* [retval][out] */ BSTR *bsPSQContent);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetAffectedBugsPSQ )( 
            IParser * This,
            /* [retval][out] */ BSTR *bsPSQContent);
        
        END_INTERFACE
    } IParserVtbl;

    interface IParser
    {
        CONST_VTBL struct IParserVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IParser_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IParser_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IParser_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IParser_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IParser_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IParser_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IParser_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IParser_ParseAMFeed(This,bsAMFeed)	\
    ( (This)->lpVtbl -> ParseAMFeed(This,bsAMFeed) ) 

#define IParser_ParseXMLFiles(This,bsSourcePath)	\
    ( (This)->lpVtbl -> ParseXMLFiles(This,bsSourcePath) ) 

#define IParser_ParseXMLFeed(This,bsXMLFeed)	\
    ( (This)->lpVtbl -> ParseXMLFeed(This,bsXMLFeed) ) 

#define IParser_GetReport(This,bsReport)	\
    ( (This)->lpVtbl -> GetReport(This,bsReport) ) 

#define IParser_GetFeedRows(This,bsFeedRows)	\
    ( (This)->lpVtbl -> GetFeedRows(This,bsFeedRows) ) 

#define IParser_SetSourceDatabase(This,bsMachine,bsDatabase,bsUID,bsPWD,fConnected)	\
    ( (This)->lpVtbl -> SetSourceDatabase(This,bsMachine,bsDatabase,bsUID,bsPWD,fConnected) ) 

#define IParser_Connected(This,fConnected)	\
    ( (This)->lpVtbl -> Connected(This,fConnected) ) 

#define IParser_GetNoNewRowsPSQ(This,bsPSQContent)	\
    ( (This)->lpVtbl -> GetNoNewRowsPSQ(This,bsPSQContent) ) 

#define IParser_GetAffectedBugsPSQ(This,bsPSQContent)	\
    ( (This)->lpVtbl -> GetAffectedBugsPSQ(This,bsPSQContent) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IParser_INTERFACE_DEFINED__ */



#ifndef __GeneParserLib_LIBRARY_DEFINED__
#define __GeneParserLib_LIBRARY_DEFINED__

/* library GeneParserLib */
/* [helpstring][version][uuid] */ 


EXTERN_C const IID LIBID_GeneParserLib;

EXTERN_C const CLSID CLSID_Parser;

#ifdef __cplusplus

class DECLSPEC_UUID("C5D3928E-E971-4FBB-A1C2-07BCBCC7C7B6")
Parser;
#endif
#endif /* __GeneParserLib_LIBRARY_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

unsigned long             __RPC_USER  BSTR_UserSize(     unsigned long *, unsigned long            , BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserMarshal(  unsigned long *, unsigned char *, BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserUnmarshal(unsigned long *, unsigned char *, BSTR * ); 
void                      __RPC_USER  BSTR_UserFree(     unsigned long *, BSTR * ); 

unsigned long             __RPC_USER  BSTR_UserSize64(     unsigned long *, unsigned long            , BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserMarshal64(  unsigned long *, unsigned char *, BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserUnmarshal64(unsigned long *, unsigned char *, BSTR * ); 
void                      __RPC_USER  BSTR_UserFree64(     unsigned long *, BSTR * ); 

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\genealogy\geneadmin\GeneParser\objd\i386\geneparser.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 7.00.0500 */
/* Compiler settings for geneparser.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, oldnames, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#pragma warning( disable: 4049 )  /* more than 64k source lines */


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 500
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __geneparser_h__
#define __geneparser_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __IParser_FWD_DEFINED__
#define __IParser_FWD_DEFINED__
typedef interface IParser IParser;
#endif 	/* __IParser_FWD_DEFINED__ */


#ifndef __Parser_FWD_DEFINED__
#define __Parser_FWD_DEFINED__

#ifdef __cplusplus
typedef class Parser Parser;
#else
typedef struct Parser Parser;
#endif /* __cplusplus */

#endif 	/* __Parser_FWD_DEFINED__ */


/* header files for imported files */
#include "oaidl.h"
#include "ocidl.h"

#ifdef __cplusplus
extern "C"{
#endif 


#ifndef __IParser_INTERFACE_DEFINED__
#define __IParser_INTERFACE_DEFINED__

/* interface IParser */
/* [unique][helpstring][nonextensible][dual][uuid][object] */ 


EXTERN_C const IID IID_IParser;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("470CDB4D-5FEA-44A5-BC4F-6D5C68A373C2")
    IParser : public IDispatch
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ParseAMFeed( 
            /* [in] */ BSTR bsAMFeed) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ParseXMLFiles( 
            /* [in] */ BSTR bsSourcePath) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ParseXMLFeed( 
            /* [in] */ BSTR bsXMLFeed) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetReport( 
            /* [retval][out] */ BSTR *bsReport) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetFeedRows( 
            /* [retval][out] */ BSTR *bsFeedRows) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE SetSourceDatabase( 
            /* [in] */ BSTR bsMachine,
            /* [in] */ BSTR bsDatabase,
            /* [defaultvalue][in] */ BSTR bsUID,
            /* [defaultvalue][in] */ BSTR bsPWD,
            /* [retval][out] */ VARIANT_BOOL *fConnected) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Connected( 
            /* [retval][out] */ VARIANT_BOOL *fConnected) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetNoNewRowsPSQ( 
            /* [retval][out] */ BSTR *bsPSQContent) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetAffectedBugsPSQ( 
            /* [retval][out] */ BSTR *bsPSQContent) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IParserVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IParser * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IParser * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IParser * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IParser * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IParser * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IParser * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IParser * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *ParseAMFeed )( 
            IParser * This,
            /* [in] */ BSTR bsAMFeed);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *ParseXMLFiles )( 
            IParser * This,
            /* [in] */ BSTR bsSourcePath);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *ParseXMLFeed )( 
            IParser * This,
            /* [in] */ BSTR bsXMLFeed);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetReport )( 
            IParser * This,
            /* [retval][out] */ BSTR *bsReport);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetFeedRows )( 
            IParser * This,
            /* [retval][out] */ BSTR *bsFeedRows);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *SetSourceDatabase )( 
            IParser * This,
            /* [in] */ BSTR bsMachine,
            /* [in] */ BSTR bsDatabase,
            /* [defaultvalue][in] */ BSTR bsUID,
            /* [defaultvalue][in] */ BSTR bsPWD,
            /* [retval][out] */ VARIANT_BOOL *fConnected);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Connected )( 
            IParser * This,
            /* [retval][out] */ VARIANT_BOOL *fConnected);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetNoNewRowsPSQ )( 
            IParser * This,
            /* [retval][out] */ BSTR *bsPSQContent);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetAffectedBugsPSQ )( 
            IParser * This,
            /* [retval][out] */ BSTR *bsPSQContent);
        
        END_INTERFACE
    } IParserVtbl;

    interface IParser
    {
        CONST_VTBL struct IParserVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IParser_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IParser_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IParser_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IParser_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IParser_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IParser_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IParser_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IParser_ParseAMFeed(This,bsAMFeed)	\
    ( (This)->lpVtbl -> ParseAMFeed(This,bsAMFeed) ) 

#define IParser_ParseXMLFiles(This,bsSourcePath)	\
    ( (This)->lpVtbl -> ParseXMLFiles(This,bsSourcePath) ) 

#define IParser_ParseXMLFeed(This,bsXMLFeed)	\
    ( (This)->lpVtbl -> ParseXMLFeed(This,bsXMLFeed) ) 

#define IParser_GetReport(This,bsReport)	\
    ( (This)->lpVtbl -> GetReport(This,bsReport) ) 

#define IParser_GetFeedRows(This,bsFeedRows)	\
    ( (This)->lpVtbl -> GetFeedRows(This,bsFeedRows) ) 

#define IParser_SetSourceDatabase(This,bsMachine,bsDatabase,bsUID,bsPWD,fConnected)	\
    ( (This)->lpVtbl -> SetSourceDatabase(This,bsMachine,bsDatabase,bsUID,bsPWD,fConnected) ) 

#define IParser_Connected(This,fConnected)	\
    ( (This)->lpVtbl -> Connected(This,fConnected) ) 

#define IParser_GetNoNewRowsPSQ(This,bsPSQContent)	\
    ( (This)->lpVtbl -> GetNoNewRowsPSQ(This,bsPSQContent) ) 

#define IParser_GetAffectedBugsPSQ(This,bsPSQContent)	\
    ( (This)->lpVtbl -> GetAffectedBugsPSQ(This,bsPSQContent) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IParser_INTERFACE_DEFINED__ */



#ifndef __GeneParserLib_LIBRARY_DEFINED__
#define __GeneParserLib_LIBRARY_DEFINED__

/* library GeneParserLib */
/* [helpstring][version][uuid] */ 


EXTERN_C const IID LIBID_GeneParserLib;

EXTERN_C const CLSID CLSID_Parser;

#ifdef __cplusplus

class DECLSPEC_UUID("C5D3928E-E971-4FBB-A1C2-07BCBCC7C7B6")
Parser;
#endif
#endif /* __GeneParserLib_LIBRARY_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

unsigned long             __RPC_USER  BSTR_UserSize(     unsigned long *, unsigned long            , BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserMarshal(  unsigned long *, unsigned char *, BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserUnmarshal(unsigned long *, unsigned char *, BSTR * ); 
void                      __RPC_USER  BSTR_UserFree(     unsigned long *, BSTR * ); 

unsigned long             __RPC_USER  BSTR_UserSize64(     unsigned long *, unsigned long            , BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserMarshal64(  unsigned long *, unsigned char *, BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserUnmarshal64(unsigned long *, unsigned char *, BSTR * ); 
void                      __RPC_USER  BSTR_UserFree64(     unsigned long *, BSTR * ); 

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\genealogy\geneadmin\GeneParser\obj\i386\geneparser_p.c ===
/* this ALWAYS GENERATED file contains the proxy stub code */


 /* File created by MIDL compiler version 7.00.0500 */
/* Compiler settings for geneparser.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, oldnames, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#if !defined(_M_IA64) && !defined(_M_AMD64)


#pragma warning( disable: 4049 )  /* more than 64k source lines */
#if _MSC_VER >= 1200
#pragma warning(push)
#endif

#pragma warning( disable: 4211 )  /* redefine extern to static */
#pragma warning( disable: 4232 )  /* dllimport identity*/
#pragma warning( disable: 4024 )  /* array to pointer mapping*/
#pragma warning( disable: 4152 )  /* function/data pointer conversion in expression */
#pragma warning( disable: 4100 ) /* unreferenced arguments in x86 call */

#pragma optimize("", off ) 

#define USE_STUBLESS_PROXY


/* verify that the <rpcproxy.h> version is high enough to compile this file*/
#ifndef __REDQ_RPCPROXY_H_VERSION__
#define __REQUIRED_RPCPROXY_H_VERSION__ 475
#endif


#include "rpcproxy.h"
#ifndef __RPCPROXY_H_VERSION__
#error this stub requires an updated version of <rpcproxy.h>
#endif // __RPCPROXY_H_VERSION__


#include "geneparser.h"

#define TYPE_FORMAT_STRING_SIZE   71                                
#define PROC_FORMAT_STRING_SIZE   349                               
#define EXPR_FORMAT_STRING_SIZE   1                                 
#define TRANSMIT_AS_TABLE_SIZE    0            
#define WIRE_MARSHAL_TABLE_SIZE   1            

typedef struct _geneparser_MIDL_TYPE_FORMAT_STRING
    {
    short          Pad;
    unsigned char  Format[ TYPE_FORMAT_STRING_SIZE ];
    } geneparser_MIDL_TYPE_FORMAT_STRING;

typedef struct _geneparser_MIDL_PROC_FORMAT_STRING
    {
    short          Pad;
    unsigned char  Format[ PROC_FORMAT_STRING_SIZE ];
    } geneparser_MIDL_PROC_FORMAT_STRING;

typedef struct _geneparser_MIDL_EXPR_FORMAT_STRING
    {
    long          Pad;
    unsigned char  Format[ EXPR_FORMAT_STRING_SIZE ];
    } geneparser_MIDL_EXPR_FORMAT_STRING;


static RPC_SYNTAX_IDENTIFIER  _RpcTransferSyntax = 
{{0x8A885D04,0x1CEB,0x11C9,{0x9F,0xE8,0x08,0x00,0x2B,0x10,0x48,0x60}},{2,0}};


extern const geneparser_MIDL_TYPE_FORMAT_STRING geneparser__MIDL_TypeFormatString;
extern const geneparser_MIDL_PROC_FORMAT_STRING geneparser__MIDL_ProcFormatString;
extern const geneparser_MIDL_EXPR_FORMAT_STRING geneparser__MIDL_ExprFormatString;


extern const MIDL_STUB_DESC Object_StubDesc;


extern const MIDL_SERVER_INFO IParser_ServerInfo;
extern const MIDL_STUBLESS_PROXY_INFO IParser_ProxyInfo;


extern const USER_MARSHAL_ROUTINE_QUADRUPLE UserMarshalRoutines[ WIRE_MARSHAL_TABLE_SIZE ];

#if !defined(__RPC_WIN32__)
#error  Invalid build platform for this stub.
#endif
#if !(TARGET_IS_NT51_OR_LATER)
#error You need a Windows XP or later to run this stub because it uses these features:
#error   #error However, your C/C++ compilation flags indicate you intend to run this app on earlier systems.
#error This app will fail with the RPC_X_WRONG_STUB_VERSION error.
#endif


static const geneparser_MIDL_PROC_FORMAT_STRING geneparser__MIDL_ProcFormatString =
    {
        0,
        {

	/* Procedure ParseAMFeed */

			0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/*  2 */	NdrFcLong( 0x0 ),	/* 0 */
/*  6 */	NdrFcShort( 0x7 ),	/* 7 */
/*  8 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 10 */	NdrFcShort( 0x0 ),	/* 0 */
/* 12 */	NdrFcShort( 0x8 ),	/* 8 */
/* 14 */	0x46,		/* Oi2 Flags:  clt must size, has return, has ext, */
			0x2,		/* 2 */
/* 16 */	0x8,		/* 8 */
			0x45,		/* Ext Flags:  new corr desc, srv corr check, has range on conformance */
/* 18 */	NdrFcShort( 0x0 ),	/* 0 */
/* 20 */	NdrFcShort( 0x1 ),	/* 1 */
/* 22 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter bsAMFeed */

/* 24 */	NdrFcShort( 0x8b ),	/* Flags:  must size, must free, in, by val, */
/* 26 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 28 */	NdrFcShort( 0x26 ),	/* Type Offset=38 */

	/* Return value */

/* 30 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 32 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 34 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure ParseXMLFiles */

/* 36 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 38 */	NdrFcLong( 0x0 ),	/* 0 */
/* 42 */	NdrFcShort( 0x8 ),	/* 8 */
/* 44 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 46 */	NdrFcShort( 0x0 ),	/* 0 */
/* 48 */	NdrFcShort( 0x8 ),	/* 8 */
/* 50 */	0x46,		/* Oi2 Flags:  clt must size, has return, has ext, */
			0x2,		/* 2 */
/* 52 */	0x8,		/* 8 */
			0x45,		/* Ext Flags:  new corr desc, srv corr check, has range on conformance */
/* 54 */	NdrFcShort( 0x0 ),	/* 0 */
/* 56 */	NdrFcShort( 0x4 ),	/* 4 */
/* 58 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter bsSourcePath */

/* 60 */	NdrFcShort( 0x8b ),	/* Flags:  must size, must free, in, by val, */
/* 62 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 64 */	NdrFcShort( 0x26 ),	/* Type Offset=38 */

	/* Return value */

/* 66 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 68 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 70 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure ParseXMLFeed */

/* 72 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 74 */	NdrFcLong( 0x0 ),	/* 0 */
/* 78 */	NdrFcShort( 0x9 ),	/* 9 */
/* 80 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 82 */	NdrFcShort( 0x0 ),	/* 0 */
/* 84 */	NdrFcShort( 0x8 ),	/* 8 */
/* 86 */	0x46,		/* Oi2 Flags:  clt must size, has return, has ext, */
			0x2,		/* 2 */
/* 88 */	0x8,		/* 8 */
			0x45,		/* Ext Flags:  new corr desc, srv corr check, has range on conformance */
/* 90 */	NdrFcShort( 0x0 ),	/* 0 */
/* 92 */	NdrFcShort( 0x4 ),	/* 4 */
/* 94 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter bsXMLFeed */

/* 96 */	NdrFcShort( 0x8b ),	/* Flags:  must size, must free, in, by val, */
/* 98 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 100 */	NdrFcShort( 0x26 ),	/* Type Offset=38 */

	/* Return value */

/* 102 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 104 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 106 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetReport */

/* 108 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 110 */	NdrFcLong( 0x0 ),	/* 0 */
/* 114 */	NdrFcShort( 0xa ),	/* 10 */
/* 116 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 118 */	NdrFcShort( 0x0 ),	/* 0 */
/* 120 */	NdrFcShort( 0x8 ),	/* 8 */
/* 122 */	0x45,		/* Oi2 Flags:  srv must size, has return, has ext, */
			0x2,		/* 2 */
/* 124 */	0x8,		/* 8 */
			0x43,		/* Ext Flags:  new corr desc, clt corr check, has range on conformance */
/* 126 */	NdrFcShort( 0x1 ),	/* 1 */
/* 128 */	NdrFcShort( 0x0 ),	/* 0 */
/* 130 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter bsReport */

/* 132 */	NdrFcShort( 0x2113 ),	/* Flags:  must size, must free, out, simple ref, srv alloc size=8 */
/* 134 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 136 */	NdrFcShort( 0x38 ),	/* Type Offset=56 */

	/* Return value */

/* 138 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 140 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 142 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetFeedRows */

/* 144 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 146 */	NdrFcLong( 0x0 ),	/* 0 */
/* 150 */	NdrFcShort( 0xb ),	/* 11 */
/* 152 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 154 */	NdrFcShort( 0x0 ),	/* 0 */
/* 156 */	NdrFcShort( 0x8 ),	/* 8 */
/* 158 */	0x45,		/* Oi2 Flags:  srv must size, has return, has ext, */
			0x2,		/* 2 */
/* 160 */	0x8,		/* 8 */
			0x43,		/* Ext Flags:  new corr desc, clt corr check, has range on conformance */
/* 162 */	NdrFcShort( 0x5 ),	/* 5 */
/* 164 */	NdrFcShort( 0x0 ),	/* 0 */
/* 166 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter bsFeedRows */

/* 168 */	NdrFcShort( 0x2113 ),	/* Flags:  must size, must free, out, simple ref, srv alloc size=8 */
/* 170 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 172 */	NdrFcShort( 0x38 ),	/* Type Offset=56 */

	/* Return value */

/* 174 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 176 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 178 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure SetSourceDatabase */

/* 180 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 182 */	NdrFcLong( 0x0 ),	/* 0 */
/* 186 */	NdrFcShort( 0xc ),	/* 12 */
/* 188 */	NdrFcShort( 0x1c ),	/* x86 Stack size/offset = 28 */
/* 190 */	NdrFcShort( 0x0 ),	/* 0 */
/* 192 */	NdrFcShort( 0x22 ),	/* 34 */
/* 194 */	0x46,		/* Oi2 Flags:  clt must size, has return, has ext, */
			0x6,		/* 6 */
/* 196 */	0x8,		/* 8 */
			0x45,		/* Ext Flags:  new corr desc, srv corr check, has range on conformance */
/* 198 */	NdrFcShort( 0x0 ),	/* 0 */
/* 200 */	NdrFcShort( 0x13 ),	/* 19 */
/* 202 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter bsMachine */

/* 204 */	NdrFcShort( 0x8b ),	/* Flags:  must size, must free, in, by val, */
/* 206 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 208 */	NdrFcShort( 0x26 ),	/* Type Offset=38 */

	/* Parameter bsDatabase */

/* 210 */	NdrFcShort( 0x8b ),	/* Flags:  must size, must free, in, by val, */
/* 212 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 214 */	NdrFcShort( 0x26 ),	/* Type Offset=38 */

	/* Parameter bsUID */

/* 216 */	NdrFcShort( 0x8b ),	/* Flags:  must size, must free, in, by val, */
/* 218 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 220 */	NdrFcShort( 0x26 ),	/* Type Offset=38 */

	/* Parameter bsPWD */

/* 222 */	NdrFcShort( 0x8b ),	/* Flags:  must size, must free, in, by val, */
/* 224 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 226 */	NdrFcShort( 0x26 ),	/* Type Offset=38 */

	/* Parameter fConnected */

/* 228 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
/* 230 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
/* 232 */	0x6,		/* FC_SHORT */
			0x0,		/* 0 */

	/* Return value */

/* 234 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 236 */	NdrFcShort( 0x18 ),	/* x86 Stack size/offset = 24 */
/* 238 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure Connected */

/* 240 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 242 */	NdrFcLong( 0x0 ),	/* 0 */
/* 246 */	NdrFcShort( 0xd ),	/* 13 */
/* 248 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 250 */	NdrFcShort( 0x0 ),	/* 0 */
/* 252 */	NdrFcShort( 0x22 ),	/* 34 */
/* 254 */	0x44,		/* Oi2 Flags:  has return, has ext, */
			0x2,		/* 2 */
/* 256 */	0x8,		/* 8 */
			0x41,		/* Ext Flags:  new corr desc, has range on conformance */
/* 258 */	NdrFcShort( 0x0 ),	/* 0 */
/* 260 */	NdrFcShort( 0x0 ),	/* 0 */
/* 262 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter fConnected */

/* 264 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
/* 266 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 268 */	0x6,		/* FC_SHORT */
			0x0,		/* 0 */

	/* Return value */

/* 270 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 272 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 274 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetNoNewRowsPSQ */

/* 276 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 278 */	NdrFcLong( 0x0 ),	/* 0 */
/* 282 */	NdrFcShort( 0xe ),	/* 14 */
/* 284 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 286 */	NdrFcShort( 0x0 ),	/* 0 */
/* 288 */	NdrFcShort( 0x8 ),	/* 8 */
/* 290 */	0x45,		/* Oi2 Flags:  srv must size, has return, has ext, */
			0x2,		/* 2 */
/* 292 */	0x8,		/* 8 */
			0x43,		/* Ext Flags:  new corr desc, clt corr check, has range on conformance */
/* 294 */	NdrFcShort( 0x1 ),	/* 1 */
/* 296 */	NdrFcShort( 0x0 ),	/* 0 */
/* 298 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter bsPSQContent */

/* 300 */	NdrFcShort( 0x2113 ),	/* Flags:  must size, must free, out, simple ref, srv alloc size=8 */
/* 302 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 304 */	NdrFcShort( 0x38 ),	/* Type Offset=56 */

	/* Return value */

/* 306 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 308 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 310 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetAffectedBugsPSQ */

/* 312 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 314 */	NdrFcLong( 0x0 ),	/* 0 */
/* 318 */	NdrFcShort( 0xf ),	/* 15 */
/* 320 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 322 */	NdrFcShort( 0x0 ),	/* 0 */
/* 324 */	NdrFcShort( 0x8 ),	/* 8 */
/* 326 */	0x45,		/* Oi2 Flags:  srv must size, has return, has ext, */
			0x2,		/* 2 */
/* 328 */	0x8,		/* 8 */
			0x43,		/* Ext Flags:  new corr desc, clt corr check, has range on conformance */
/* 330 */	NdrFcShort( 0x7 ),	/* 7 */
/* 332 */	NdrFcShort( 0x0 ),	/* 0 */
/* 334 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter bsPSQContent */

/* 336 */	NdrFcShort( 0x2113 ),	/* Flags:  must size, must free, out, simple ref, srv alloc size=8 */
/* 338 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 340 */	NdrFcShort( 0x38 ),	/* Type Offset=56 */

	/* Return value */

/* 342 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 344 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 346 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

			0x0
        }
    };

static const geneparser_MIDL_TYPE_FORMAT_STRING geneparser__MIDL_TypeFormatString =
    {
        0,
        {
			NdrFcShort( 0x0 ),	/* 0 */
/*  2 */	
			0x12, 0x0,	/* FC_UP */
/*  4 */	NdrFcShort( 0x18 ),	/* Offset= 24 (28) */
/*  6 */	
			0x1b,		/* FC_CARRAY */
			0x1,		/* 1 */
/*  8 */	NdrFcShort( 0x2 ),	/* 2 */
/* 10 */	0x9,		/* Corr desc: FC_ULONG */
			0x0,		/*  */
/* 12 */	NdrFcShort( 0xfffc ),	/* -4 */
/* 14 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 16 */	0x0 , 
			0x0,		/* 0 */
/* 18 */	NdrFcLong( 0x0 ),	/* 0 */
/* 22 */	NdrFcLong( 0x0 ),	/* 0 */
/* 26 */	0x6,		/* FC_SHORT */
			0x5b,		/* FC_END */
/* 28 */	
			0x17,		/* FC_CSTRUCT */
			0x3,		/* 3 */
/* 30 */	NdrFcShort( 0x8 ),	/* 8 */
/* 32 */	NdrFcShort( 0xffe6 ),	/* Offset= -26 (6) */
/* 34 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 36 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 38 */	0xb4,		/* FC_USER_MARSHAL */
			0x83,		/* 131 */
/* 40 */	NdrFcShort( 0x0 ),	/* 0 */
/* 42 */	NdrFcShort( 0x4 ),	/* 4 */
/* 44 */	NdrFcShort( 0x0 ),	/* 0 */
/* 46 */	NdrFcShort( 0xffd4 ),	/* Offset= -44 (2) */
/* 48 */	
			0x11, 0x4,	/* FC_RP [alloced_on_stack] */
/* 50 */	NdrFcShort( 0x6 ),	/* Offset= 6 (56) */
/* 52 */	
			0x13, 0x0,	/* FC_OP */
/* 54 */	NdrFcShort( 0xffe6 ),	/* Offset= -26 (28) */
/* 56 */	0xb4,		/* FC_USER_MARSHAL */
			0x83,		/* 131 */
/* 58 */	NdrFcShort( 0x0 ),	/* 0 */
/* 60 */	NdrFcShort( 0x4 ),	/* 4 */
/* 62 */	NdrFcShort( 0x0 ),	/* 0 */
/* 64 */	NdrFcShort( 0xfff4 ),	/* Offset= -12 (52) */
/* 66 */	
			0x11, 0xc,	/* FC_RP [alloced_on_stack] [simple_pointer] */
/* 68 */	0x6,		/* FC_SHORT */
			0x5c,		/* FC_PAD */

			0x0
        }
    };

static const USER_MARSHAL_ROUTINE_QUADRUPLE UserMarshalRoutines[ WIRE_MARSHAL_TABLE_SIZE ] = 
        {
            
            {
            BSTR_UserSize
            ,BSTR_UserMarshal
            ,BSTR_UserUnmarshal
            ,BSTR_UserFree
            }

        };



/* Object interface: IUnknown, ver. 0.0,
   GUID={0x00000000,0x0000,0x0000,{0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46}} */


/* Object interface: IDispatch, ver. 0.0,
   GUID={0x00020400,0x0000,0x0000,{0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46}} */


/* Object interface: IParser, ver. 0.0,
   GUID={0x470CDB4D,0x5FEA,0x44A5,{0xBC,0x4F,0x6D,0x5C,0x68,0xA3,0x73,0xC2}} */

#pragma code_seg(".orpc")
static const unsigned short IParser_FormatStringOffsetTable[] =
    {
    (unsigned short) -1,
    (unsigned short) -1,
    (unsigned short) -1,
    (unsigned short) -1,
    0,
    36,
    72,
    108,
    144,
    180,
    240,
    276,
    312
    };

static const MIDL_STUBLESS_PROXY_INFO IParser_ProxyInfo =
    {
    &Object_StubDesc,
    geneparser__MIDL_ProcFormatString.Format,
    &IParser_FormatStringOffsetTable[-3],
    0,
    0,
    0
    };


static const MIDL_SERVER_INFO IParser_ServerInfo = 
    {
    &Object_StubDesc,
    0,
    geneparser__MIDL_ProcFormatString.Format,
    &IParser_FormatStringOffsetTable[-3],
    0,
    0,
    0,
    0};
CINTERFACE_PROXY_VTABLE(16) _IParserProxyVtbl = 
{
    &IParser_ProxyInfo,
    &IID_IParser,
    IUnknown_QueryInterface_Proxy,
    IUnknown_AddRef_Proxy,
    IUnknown_Release_Proxy ,
    0 /* (void *) (INT_PTR) -1 /* IDispatch::GetTypeInfoCount */ ,
    0 /* (void *) (INT_PTR) -1 /* IDispatch::GetTypeInfo */ ,
    0 /* (void *) (INT_PTR) -1 /* IDispatch::GetIDsOfNames */ ,
    0 /* IDispatch_Invoke_Proxy */ ,
    (void *) (INT_PTR) -1 /* IParser::ParseAMFeed */ ,
    (void *) (INT_PTR) -1 /* IParser::ParseXMLFiles */ ,
    (void *) (INT_PTR) -1 /* IParser::ParseXMLFeed */ ,
    (void *) (INT_PTR) -1 /* IParser::GetReport */ ,
    (void *) (INT_PTR) -1 /* IParser::GetFeedRows */ ,
    (void *) (INT_PTR) -1 /* IParser::SetSourceDatabase */ ,
    (void *) (INT_PTR) -1 /* IParser::Connected */ ,
    (void *) (INT_PTR) -1 /* IParser::GetNoNewRowsPSQ */ ,
    (void *) (INT_PTR) -1 /* IParser::GetAffectedBugsPSQ */
};


static const PRPC_STUB_FUNCTION IParser_table[] =
{
    STUB_FORWARDING_FUNCTION,
    STUB_FORWARDING_FUNCTION,
    STUB_FORWARDING_FUNCTION,
    STUB_FORWARDING_FUNCTION,
    NdrStubCall2,
    NdrStubCall2,
    NdrStubCall2,
    NdrStubCall2,
    NdrStubCall2,
    NdrStubCall2,
    NdrStubCall2,
    NdrStubCall2,
    NdrStubCall2
};

CInterfaceStubVtbl _IParserStubVtbl =
{
    &IID_IParser,
    &IParser_ServerInfo,
    16,
    &IParser_table[-3],
    CStdStubBuffer_DELEGATING_METHODS
};

static const MIDL_STUB_DESC Object_StubDesc = 
    {
    0,
    NdrOleAllocate,
    NdrOleFree,
    0,
    0,
    0,
    0,
    0,
    geneparser__MIDL_TypeFormatString.Format,
    1, /* -error bounds_check flag */
    0x60001, /* Ndr library version */
    0,
    0x70001f4, /* MIDL Version 7.0.500 */
    0,
    UserMarshalRoutines,
    0,  /* notify & notify_flag routine table */
    0x1, /* MIDL flag */
    0, /* cs routines */
    0,   /* proxy/server info */
    0
    };

const CInterfaceProxyVtbl * _geneparser_ProxyVtblList[] = 
{
    ( CInterfaceProxyVtbl *) &_IParserProxyVtbl,
    0
};

const CInterfaceStubVtbl * _geneparser_StubVtblList[] = 
{
    ( CInterfaceStubVtbl *) &_IParserStubVtbl,
    0
};

PCInterfaceName const _geneparser_InterfaceNamesList[] = 
{
    "IParser",
    0
};

const IID *  _geneparser_BaseIIDList[] = 
{
    &IID_IDispatch,
    0
};


#define _geneparser_CHECK_IID(n)	IID_GENERIC_CHECK_IID( _geneparser, pIID, n)

int __stdcall _geneparser_IID_Lookup( const IID * pIID, int * pIndex )
{
    
    if(!_geneparser_CHECK_IID(0))
        {
        *pIndex = 0;
        return 1;
        }

    return 0;
}

const ExtendedProxyFileInfo geneparser_ProxyFileInfo = 
{
    (PCInterfaceProxyVtblList *) & _geneparser_ProxyVtblList,
    (PCInterfaceStubVtblList *) & _geneparser_StubVtblList,
    (const PCInterfaceName * ) & _geneparser_InterfaceNamesList,
    (const IID ** ) & _geneparser_BaseIIDList,
    & _geneparser_IID_Lookup, 
    1,
    2,
    0, /* table of [async_uuid] interfaces */
    0, /* Filler1 */
    0, /* Filler2 */
    0  /* Filler3 */
};
#pragma optimize("", on )
#if _MSC_VER >= 1200
#pragma warning(pop)
#endif


#endif /* !defined(_M_IA64) && !defined(_M_AMD64)*/
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\genealogy\geneadmin\GeneQuery\filemgr.h ===
#pragma once

class CFileMgr : public CCriticalSection
{
public:
    CFileMgr() : m_szFile(50), m_szBuffer(MAX_PATH) {m_dwRefCount = 0; m_hFile = 0;}
    ~CFileMgr() {assert(0 == m_dwRefCount);}
    DWORD GetEventFile(const CHAR *szKey);
    DWORD Write(const CHAR *szStr);
    VOID Close();
protected:
    DWORD m_dwRefCount;
    CSafeStr m_szFile;
    CSafeStr m_szBuffer;
    HANDLE m_hFile;
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\genealogy\geneadmin\GeneQuery\GAQuery.h ===
// GAQuery.h : Declaration of the CGAQuery

#pragma once
#include "resource.h"       // main symbols

#include "GeneQuery.h"


// CGAQuery

class ATL_NO_VTABLE CGAQuery : 
	public CComObjectRootEx<CComMultiThreadModel>,
	public CComCoClass<CGAQuery, &CLSID_GAQuery>,
	public IDispatchImpl<IGAQuery, &IID_IGAQuery, &LIBID_GeneQueryLib, /*wMajor =*/ 1, /*wMinor =*/ 0>
{
public:
	CGAQuery()
	{
	}

DECLARE_REGISTRY_RESOURCEID(IDR_GAQUERY)


BEGIN_COM_MAP(CGAQuery)
	COM_INTERFACE_ENTRY(IGAQuery)
	COM_INTERFACE_ENTRY(IDispatch)
END_COM_MAP()


	DECLARE_PROTECT_FINAL_CONSTRUCT()

	HRESULT FinalConstruct()
	{
		return S_OK;
	}
	
	void FinalRelease() 
	{
	}

public:

	STDMETHOD(SubmitEvent)(BSTR SerialNumber, DATE FailureDate);
};

OBJECT_ENTRY_AUTO(__uuidof(GAQuery), CGAQuery)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\genealogy\geneadmin\GeneQuery\dbconn.cpp ===
#include "stdafx.h" 
#include "dbconn.h"

#define DOBINDINGS
#include "DBControl.h"

/******************************************************************************
    CDBQueryMaster Class
 ******************************************************************************/
static CHAR szGetUODBNames[] = "SELECT name FROM sys.databases WHERE name like ? and name not like '%replica%'";

BOOL CDBQueryMaster::Connect(const CHAR *szServer, const CHAR *szDbPrefix)
{
    m_dwDbPrefixLen = strlen(szDbPrefix)+1;
    if (m_dwDbPrefixLen >= sizeof(m_szDbPrefix))
        return false;
    strcpy(m_szDbPrefix, szDbPrefix);
    strcat(m_szDbPrefix, "%");

    return CDBConn::Connect(szServer, "master", szGetUODBNames);
}

DWORD CDBQueryMaster::GetUODBCount()
{
    BOOL fLast;
    DWORD dwCount = 0;

    if(!Connected())
        return (DWORD) -1;

    if(!m_fBound)
    {
        DEFQUERYMASTER(m_hStmt, Cleanup);
    }
    m_fBound = TRUE;

    // need to reset the value as the bind operation defaults it.
    m_dwDbPrefixLen = strlen(m_szDbPrefix)+1;
    
    if(!DBStmtExecute(m_hStmt))
    {
        m_fBound = FALSE;
        goto Cleanup;
    }

    while(DBStmtFetch(m_hStmt, fLast))
    {
        ++dwCount;
    }

    return dwCount;

Cleanup:
    if(!m_fBound)
    {
        Disconnect();
    }
    return (DWORD) -1;
}

BOOL CDBQueryMaster::Start()
{
    if(!Connected())
        return FALSE;

    if(!m_fBound)
    {
        DEFQUERYMASTER(m_hStmt, Cleanup);
    }
    m_fBound = TRUE;

    // need to reset the value as the bind operation defaults it.
    m_dwDbPrefixLen = strlen(m_szDbPrefix)+1;
    
    DBStmtCloseCursor(m_hStmt);
    if(!DBStmtExecute(m_hStmt))
        m_fBound = FALSE;

Cleanup:
    if(!m_fBound)
    {
        Disconnect();
        return FALSE;
    }
    return TRUE;
}

BOOL CDBQueryMaster::GetNext()
{
    BOOL fLast;
    BOOL ret = DBStmtFetch(m_hStmt, fLast);

    if (ret)
    {
        DebugOutput("UODB database fetch complete: len=%d, value=%s\n", m_dwDbNameLen, m_szDbName);
    }
    return ret;
}

/******************************************************************************
    CDBQueryUODB Class
 ******************************************************************************/
static CHAR szGetUODBDate[] = "SELECT dt_reset_date FROM t_machines WHERE vc_serial_num=?";

DWORD CDBQueryUODB::GetResetDate(const CHAR *szMachine, const CHAR *szDatabase, const CHAR *szSerial, DBTIMESTAMP& dtReset)
{
    BOOL fLast;
    DWORD dwCount = 0;
    m_dwSerialLen = strlen(szSerial);
    if(m_dwSerialLen >= sizeof(m_szSerial))
        return (DWORD) -1;

    if(!Connected() && !Connect(szMachine, szDatabase))
        return (DWORD) -1;

    if(!m_fBound)
    {
        DEFQUERYUODB(m_hStmt, Cleanup);
    }
    m_fBound = TRUE;

    m_dwSerialLen = strlen(szSerial);
    strcpy(m_szSerial, szSerial);
    if(!DBStmtExecute(m_hStmt))
    {
        m_fBound = FALSE;
        goto Cleanup;
    }

    while(DBStmtFetch(m_hStmt, fLast))
    {
        memcpy(&dtReset, &m_dtReset, sizeof(DBTIMESTAMP));
        ++dwCount;
    }

    return dwCount;

Cleanup:
    if(!m_fBound)
    {
        Disconnect();
    }
    return (DWORD) -1;
}

DWORD CDBQueryUODB::GetResetDate(const CHAR *szSerial, DBTIMESTAMP& dtReset)
{
    BOOL fLast;
    DWORD dwCount = 0;
    m_dwSerialLen = strlen(szSerial);
    if(m_dwSerialLen >= sizeof(m_szSerial))
        return (DWORD) -1;

    if(!Connected())
        return (DWORD) -1;

    if(!m_fBound)
    {
        DEFQUERYUODB(m_hStmt, Cleanup);
    }
    m_fBound = TRUE;

    m_dwSerialLen = strlen(szSerial);
    strcpy(m_szSerial, szSerial);
    if(!DBStmtExecute(m_hStmt))
    {
        m_fBound = FALSE;
        goto Cleanup;
    }

    while(DBStmtFetch(m_hStmt, fLast))
    {
        memcpy(&dtReset, &m_dtReset, sizeof(DBTIMESTAMP));
        ++dwCount;
    }

    return dwCount;

Cleanup:
    if(!m_fBound)
    {
        Disconnect();
    }
    return (DWORD) -1;
}

BOOL CDBQueryUODB::Connect(const CHAR *szServer, const CHAR *szDatabase)
{
    return CDBConn::Connect(szServer, szDatabase, szGetUODBDate);
}


/******************************************************************************
    CDBGeneFailRow Class
 ******************************************************************************/
static CHAR szGetGeneFailedRows[] = "SELECT dtmCreated, strFileName, strErrorDesc, strRowData FROM t_geneerrors WHERE Left(strrowdata, 12)=? ORDER BY dtmCreated";

BOOL CDBGeneFailRow::Start(const CHAR *szMachine, const CHAR *szDatabase, const CHAR *szSerial)
{
    m_dwSerialLen = strlen(szSerial);
    if(m_dwSerialLen >= sizeof(m_szSerial))
        return FALSE;

    if(!Connected() && !Connect(szMachine, szDatabase, szGetGeneFailedRows))
        return FALSE;

    if(!m_fBound)
    {
        DBGENEFAILED_ROWS(m_hStmt, Cleanup);
    }
    m_fBound = TRUE;

    m_dwSerialLen = strlen(szSerial);
    strcpy(m_szSerial, szSerial);
    DBStmtCloseCursor(m_hStmt);
    if(!DBStmtExecute(m_hStmt))
        m_fBound = FALSE;

Cleanup:
    if(!m_fBound)
    {
        Disconnect();
        return FALSE;
    }
    return TRUE;
}

BOOL CDBGeneFailRow::GetNext()
{
    BOOL fLast;
    return DBStmtFetch(m_hStmt, fLast);
}

/******************************************************************************
    CDBGeneImportRow Class
 ******************************************************************************/
static CHAR szGetGeneImportRows[] = "SELECT PartNumber, LEFT(OnlineKey, 12), LastUpdated, SequenceNumber, SequenceChangeDate FROM OnlineGaming WHERE SerialNumber=? ORDER BY LastUpdated";


BOOL CDBGeneImportRow::Start(const CHAR *szMachine, const CHAR *szDatabase, const CHAR *szSerial)
{
    m_dwSerialLen = strlen(szSerial);
    if(m_dwSerialLen >= sizeof(m_szSerial))
        return FALSE;

    if(!Connected() && !Connect(szMachine, szDatabase, szGetGeneImportRows))
        return FALSE;

    if(!m_fBound)
    {
        DBGENEIMPORT_ROWS(m_hStmt, Cleanup);
    }
    m_fBound = TRUE;

    m_dwSerialLen = strlen(szSerial);
    strcpy(m_szSerial, szSerial);
    DBStmtCloseCursor(m_hStmt);
    if(!DBStmtExecute(m_hStmt))
        m_fBound = FALSE;

Cleanup:
    if(!m_fBound)
    {
        Disconnect();
        return FALSE;
    }
    return TRUE;
}

BOOL CDBGeneImportRow::GetNext()
{
    BOOL fLast;
    return DBStmtFetch(m_hStmt, fLast);
}

/******************************************************************************
    CDBConn Class
 ******************************************************************************/
CDBConn::CDBConn()
{
    m_fBound = FALSE;
    m_hConn = 0;
    m_hStmt = 0;
}

CDBConn::~CDBConn()
{
    Disconnect();
}

BOOL CDBConn::Connect(const CHAR *szServer, const CHAR *szDatabase, const CHAR *szQuery)
{
    Disconnect();
    m_hConn = DBSQLConnect((CHAR *) szServer, (CHAR *) szDatabase);
    if(!m_hConn)
    {
        // TODO: Log an event
        return FALSE;
    }
    m_hStmt = DBPrepare(m_hConn, (CHAR *) szQuery);
    if(!m_hStmt)
    {
        Disconnect();
        return FALSE;
    }
    return TRUE;
}

BOOL CDBConn::Connected()
{
    return 0 != m_hStmt;
}

VOID CDBConn::Disconnect()
{
    if(m_hStmt)
        DBClose(m_hStmt);
    if(m_hConn)
        DBClose(m_hConn);
    m_hStmt = 0;
    m_hConn = 0;
    m_fBound = FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\genealogy\geneadmin\GeneQuery\dbconn.h ===
#pragma once
#include "dbaccessor.h"

#define DODECLARATIONS
#include "DBControl.h"


/******************************************************************************
    CDBConn Class
 ******************************************************************************/
/*  CDBConn is the base class that provides the basic functionality of connecting to the database and 
    initializing the statement handle
*/

class CDBConn
{
public:
    virtual VOID Disconnect();
protected:
    CDBConn();
    virtual ~CDBConn();

    virtual BOOL Connect(const CHAR *szServer, const CHAR *szDatabase, const CHAR *szQuery);
    virtual BOOL Connected();

    BOOL m_fBound;
    HDBCONN m_hConn;
    HDBSTMT m_hStmt;
}; // CDBConn


/******************************************************************************
    CDBGeneImportRow Class
 ******************************************************************************/
//  SELECT PartNumber, LEFT(OnlineKey, 12), LastUpdated, SequenceNumber, SequenceChangeDate FROM OnlineGaming WHERE SerialNumber=? ORDER BY LastUpdated

#define DBGENEIMPORT_ROWS(stmt, jumpto)                                                 \
    DEF_BINDPARAMSEQ_IN(stmt, 1, CHAR, m_szSerial, 21, m_dwSerialLen, jumpto)           \
    DEF_BINDCOLSEQ(stmt, 1, CHAR, m_szPartNo, 10, m_dwPartNoLen, jumpto)                \
    DEF_BINDCOLSEQ(stmt, 2, CHAR, m_szKey, 13, m_dwKeyLen, jumpto)                      \
    DEF_BINDCOL(stmt, 3, DBTIMESTAMP, m_dtLast, m_optLast, jumpto)                      \
    DEF_BINDCOL(stmt, 4, DWORD, m_dwSeqNo, m_optSeqNo, jumpto)                          \
    DEF_BINDCOL(stmt, 5, DBTIMESTAMP, m_dtSeq, m_optSeq, jumpto)

class CDBGeneImportRow : public CDBConn
{
public:
    CDBGeneImportRow() {}
    virtual ~CDBGeneImportRow() {}

    BOOL Start(const CHAR *szMachine, const CHAR *szDatabase, const CHAR *szSerial);
    BOOL GetNext();

    DBGENEIMPORT_ROWS(0, 0);
};

/******************************************************************************
    CDBGeneFailRow Class
 ******************************************************************************/
//  SELECT dtmCreated, strFileName, strErrorDesc, strRowData FROM t_geneerrors WHERE Left(strrowdata, 12)=? ORDER BY dtmCreated

#define DBGENEFAILED_ROWS(stmt, jumpto)                                                 \
    DEF_BINDPARAMSEQ_IN(stmt, 1, CHAR, m_szSerial, 21, m_dwSerialLen, jumpto)           \
    DEF_BINDCOL(stmt, 1, DBTIMESTAMP, m_dtCreated, m_optCreated, jumpto)                \
    DEF_BINDCOLSEQ(stmt, 2, CHAR, m_szFile, MAX_PATH, m_dwFileLen, jumpto)              \
    DEF_BINDCOLSEQ(stmt, 3, CHAR, m_szDesc, 256, m_dwDescLen, jumpto)                   \
    DEF_BINDCOLSEQ(stmt, 4, CHAR, m_szRow, 512, m_dwRowLen, jumpto)

class CDBGeneFailRow : public CDBConn
{
public:
    CDBGeneFailRow() {}
    virtual ~CDBGeneFailRow() {}

    BOOL Start(const CHAR *szMachine, const CHAR *szDatabase, const CHAR *szSerial);
    BOOL GetNext();

    DBGENEFAILED_ROWS(0, 0);
};

/******************************************************************************
    CDBQueryUODB Class
 ******************************************************************************/
//  SELECT dt_reset_date FROM t_machines WHERE vc_serial_num=?

#define DEFQUERYUODB(stmt, jumpto)                                                  \
    DEF_BINDPARAMSEQ_IN(stmt, 1, CHAR, m_szSerial, 21, m_dwSerialLen, jumpto)       \
    DEF_BINDCOL(stmt, 1, DBTIMESTAMP, m_dtReset, m_optReset, jumpto)

class CDBQueryUODB : public CDBConn
{
public:
    CDBQueryUODB() {}
    virtual ~CDBQueryUODB () {}
    DWORD GetResetDate(const CHAR *szMachine, const CHAR *szDatabase, const CHAR *szSerial, DBTIMESTAMP& dtReset);
    DWORD GetResetDate(const CHAR *szSerial, DBTIMESTAMP& dtReset);
    
    BOOL Connect(const CHAR *szServer, const CHAR *szDatabase);

    DEFQUERYUODB(0, 0);
};

/******************************************************************************
    CDBQueryMaster Class
 ******************************************************************************/
//  SELECT name FROM sys.databases where name like 'uodb%'

#define DEFQUERYMASTER(stmt, jumpto)                                                  \
    DEF_BINDPARAMSEQ_IN(stmt, 1, CHAR, m_szDbPrefix, 256, m_dwDbPrefixLen, jumpto)       \
    DEF_BINDCOLSEQ(stmt, 1, CHAR, m_szDbName, 256, m_dwDbNameLen, jumpto)

class CDBQueryMaster : public CDBConn
{
public:
    CDBQueryMaster() {}
    virtual ~CDBQueryMaster () {}
    DWORD GetUODBCount();
    BOOL Start();
    BOOL GetNext();

    BOOL Connect(const CHAR *szServer, const CHAR *szDbPrefix);

    DEFQUERYMASTER(0, 0);
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\genealogy\geneadmin\GeneQuery\filemgr.cpp ===
#include "stdafx.h"

DWORD CFileMgr::Write(const CHAR *szStr)
{
    DWORD dwErr = 0;
    DWORD dwToWrite = strlen(szStr);
    Enter();
    {
        if(!m_hFile)
        {
            dwErr = ERROR_INVALID_HANDLE;
            goto Exit;
        }

        if(!WriteFile(m_hFile, szStr, dwToWrite, &dwToWrite, NULL))
        {
            dwErr = GetLastError();
            goto Exit;
        }
Exit:
        ;
    }
    Leave();
    return dwErr;
}

VOID CFileMgr::Close()
{
    Enter();
    {
        if(!m_hFile)
            assert(!"A file is not open to close.");

        --m_dwRefCount;
        if(!m_dwRefCount)
            CloseHandle(m_hFile);
        m_hFile = 0;
    }
    Leave();
}

DWORD CFileMgr::GetEventFile(const CHAR *szKey)
{
    DWORD dwErr = 0, dwRes = 0;
    SYSTEMTIME st;
 
    Enter();
    {
        if(m_hFile)
            goto OpenSuccess;

        if(!m_hFile && m_dwRefCount)
            assert(!"There is a reference count on a zero handle!");
        if(m_dwRefCount > 1000)
            assert(!"File reference count exceeds 1000.  Check to see if close calls are being made.");
        
        GetSystemTime(&st);
        
        if(! ((bool) m_szFile))
            m_szFile.FormatText("%s.%d%02d%02d.%02d%02d%02d%03d.txt", szKey, st.wYear, st.wMonth, st.wDay, st.wHour, st.wMinute, st.wSecond, st.wMilliseconds);

        CombinePathFile(m_szBuffer, g_szOutputDir, m_szFile);
        m_hFile = CreateFile(m_szBuffer, GENERIC_WRITE, 0, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
        if(!m_hFile || INVALID_HANDLE_VALUE == m_hFile || (INVALID_SET_FILE_POINTER == (dwRes = SetFilePointer(m_hFile, 0, 0, FILE_END))))
        {
            dwErr = GetLastError();
            if(ERROR_FILE_NOT_FOUND == dwErr || ERROR_SHARING_VIOLATION == dwErr || INVALID_SET_FILE_POINTER == dwRes)   // If the file doesn't exist or the file is in use elsewhere.
            {
                ChangeTime(st, DF_MILLISECOND, 1);
                m_szFile.FormatText("%s.%d%02d%02d.%02d%02d%02d%03d.txt", szKey, st.wYear, st.wMonth, st.wDay, st.wHour, st.wMinute, st.wSecond, st.wMilliseconds);
                CombinePathFile(m_szBuffer, g_szOutputDir, m_szFile);
                m_hFile = CreateFile(m_szBuffer, GENERIC_WRITE, 0, NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
                if(!m_hFile || INVALID_HANDLE_VALUE == m_hFile)
                {
                    m_hFile = 0;
                    dwErr = GetLastError();
                    goto Exit;
                }
                goto OpenSuccess;
            }
            m_hFile = 0;
            goto Exit;
        }
        
OpenSuccess:
        ++m_dwRefCount;
        dwErr = 0;
Exit:
        ;
    }
    Leave();
    return dwErr;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\genealogy\geneadmin\GeneQuery\GeneQuery.cpp ===
// GeneQuery.cpp : Implementation of WinMain

#include "stdafx.h"
#include "resource.h"
#include "GeneQuery.h"
#include <stdio.h>
#include "QueryDB.h"
#include "key.h"
#include "eventing.h"
#include "genequery_i.c"
 
#include "globals.h"

class CGeneQueryModule : public CAtlServiceModuleT< CGeneQueryModule, IDS_SERVICENAME >
{
public :
	DECLARE_LIBID(LIBID_GeneQueryLib)
	DECLARE_REGISTRY_APPID_RESOURCEID(IDR_GENEQUERY, "{4D694311-0187-436E-9ABD-A907BA7FBE71}")

	// This function provides the default security settings for your service,
	// you should overide this in your specific service module class to change
	// as appropriate.  By default, this will allow any caller and calls will be
	// on the callers security token (impersonated).
	HRESULT InitializeSecurity() throw()
	{
		return CoInitializeSecurity(NULL, -1, NULL, NULL, RPC_C_AUTHN_LEVEL_PKT, RPC_C_IMP_LEVEL_IMPERSONATE, NULL, EOAC_NONE, NULL);
	}

	virtual void RunMessageLoop();
        DWORD QueryRegistry();
};

CGeneQueryModule _AtlModule;

DWORD CGeneQueryModule::QueryRegistry()
{
    CKey key;
    // Read configuration from registry (HKLM\Software\Microsoft\GeneAdmin)
    if(key.Open(HKEY_LOCAL_MACHINE, "Software\\Microsoft\\GeneQuery", KEY_READ))
    {
        ::LogEvent(EVENTLOG_ERROR_TYPE, EVENT_GENE_REGKEY_OPEN_FAILED, _T("Failed to open a key at HKEY_LOCAL_MACHINE\\Software\\Microsoft\\GeneQuery.  The error is: %d"), key.GetLastError());
        return key.GetLastError();
    }

#define GLOBAL_IMPLEMENTATION
#include "globals.h"

    return 0;
}

void CGeneQueryModule::RunMessageLoop() throw()
{
    MSG msg;
    DWORD dwIndex;
    bool fKeepRunning = true;
    
    SetEventSource("GeneQuery");
    SetErrorReporting(/*DB_REPORT_INFORMATIONAL |*/ DB_REPORT_DEBUGSTRING | DB_REPORT_EVENT, "GeneQuery");

    if(QueryRegistry())
        return;
    
    while (fKeepRunning)
    {
        dwIndex = MsgWaitForMultipleObjects(0, 0, FALSE, g_dwCheckFrequency * 60 * 1000, QS_ALLEVENTS);
        if(WAIT_OBJECT_0 == dwIndex)
        {
            if(GetMessage(&msg, 0, 0, 0) > 0)
            {
                TranslateMessage(&msg);
                DispatchMessage(&msg);
            }
            else
            {
                fKeepRunning = false;
            }
        }
        else if(WAIT_TIMEOUT == dwIndex)
        {
            QueryInputPath();
        }
    }
}

//
extern "C" int WINAPI _tWinMain(HINSTANCE /*hInstance*/, HINSTANCE /*hPrevInstance*/, 
                                LPTSTR /*lpCmdLine*/, int nShowCmd)
{
    return _AtlModule.WinMain(nShowCmd);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\genealogy\geneadmin\GeneQuery\globals.h ===
#ifndef GLOBALS_H
  #define GLOBALS_H
  #define DEF_SZMULTI(name, length)     extern CHAR g_sz##name[length + 1];
  #define DEF_STRING(name, length)      extern TSafeStr<length> g_sz##name; 
  #define DEF_DWORD(name, defvalue)     extern DWORD g_dw##name;
#elif !defined(GLOBAL_IMPLEMENTATION)  // !GLOBALS_H
  #undef DEF_SZMULTI
  #undef DEF_STRING
  #undef DEF_DWORD
  #define DEF_SZMULTI(name, length)     CHAR g_sz##name[length + 1];
  #define DEF_STRING(name, length)      TSafeStr<length> g_sz##name;
  #define DEF_DWORD(name, defvalue)     DWORD g_dw##name = defvalue;
#else // GLOBALS_H && GLOBAL_IMPLEMENTATION
  #undef DEF_SZMULTI
  #undef DEF_STRING
  #undef DEF_DWORD
    DWORD dwSize, dwType;
    CHAR szTemp[1024];

  #define DEF_SZMULTI(name, length)                         \
    dwSize = length;                                        \
    if(key.QueryValue(#name, g_sz##name, dwSize, dwType))   \
    {                                                       \
        ::LogEvent(EVENTLOG_ERROR_TYPE, EVENT_GENE_REGKEY_QUERY_FAILED, _T("Failed to read the value at HKEY_LOCAL_MACHINE\\Software\\Microsoft\\GeneQuery\\%s.  The error is: %d"), #name, key.GetLastError());   \
        return key.GetLastError();                          \
    }                                                       \
    g_sz##name[length] = 0;
        
  #define DEF_DWORD(name, defvalue)                                     \
    if(!key.ExistValue(#name) || key.QueryValue(#name, g_dw##name))     \
    {                                                                   \
        g_dw##name = defvalue;                                          \
    }
    
  #define DEF_STRING(name, length)                      \
    dwSize = g_sz##name.Size();                         \
    if(key.QueryValue(#name, szTemp, dwSize, dwType))   \
    {                                                   \
        ::LogEvent(EVENTLOG_ERROR_TYPE, EVENT_GENE_REGKEY_QUERY_FAILED, _T("Failed to read the value at HKEY_LOCAL_MACHINE\\Software\\Microsoft\\GeneQuery\\%s.  The error is: %d"), #name, key.GetLastError());   \
        return key.GetLastError();                      \
    }                                                   \
    g_sz##name = szTemp;

#endif // !GLOBALS_H

// Output Directory for events and results (OutputDir, REG_SZ, Required, max size: MAX_PATH)
// Input Directory for serial number files (InputDir, REG_SZ, Required, max size: MAX_PATH)
// Genealogy machine name (GeneMachine, REG_SZ, Required, max size: 50)
// Genealogy database name (GeneDatabase, REG_SZ, Required, max size: 50)
// UODB machine names (UODBMachines, REG_SZ (semicolon separated values), Required, max size: 4000)
// UODB database (UODBDatabase, REG_SZ (must be the same name for all machines), Required, max size: 50)
// Input Directory Check Frequency (CheckFrequency, REG_DWORD, optional, default value: 5)

DEF_STRING(OutputDir, MAX_PATH)
DEF_STRING(InputDir, MAX_PATH)
DEF_STRING(GeneMachine, 50)
DEF_STRING(GeneDatabase, 50)
DEF_SZMULTI(UODBMachines, 4000)
DEF_STRING(UODBDatabase, 50)
DEF_DWORD(CheckFrequency, 5)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\genealogy\geneadmin\GeneQuery\GAQuery.cpp ===
// GAQuery.cpp : Implementation of CGAQuery

#include "stdafx.h"
#include "GAQuery.h"
#include "eventing.h"

// CGAQuery

static CFileMgr s_EventFile;

STDMETHODIMP CGAQuery::SubmitEvent(BSTR SerialNumber, DATE FailureDate)
{
    DWORD dwErr = 0;
    SYSTEMTIME st;
    COleDateTime dtFailed(FailureDate);
    CSafeStr szBuffer(80);
    _bstr_t bsSerial(SerialNumber);
    if(!dtFailed.GetAsSystemTime(st))
    {
        LogEvent(EVENTLOG_ERROR_TYPE, EVENT_GENE_INVALID_PARAMETER, "CGAQuery::SubmitEvent: An invalid date was passed to the function.  COleDateTime error: %d", dtFailed.GetStatus());
        return E_INVALIDARG;
    }

    if(bsSerial.length() != 12 || DigitCount((const CHAR *) bsSerial) != 12)
    {
        LogEvent(EVENTLOG_ERROR_TYPE, EVENT_GENE_INVALID_PARAMETER, "CGAQuery::SubmitEvent: An invalid serial number was passed to the function.  The serial number passed was: %s", (const CHAR *) bsSerial);
        return E_INVALIDARG;
    }
    
    dwErr = s_EventFile.GetEventFile("GeneEvents");
    if(dwErr)
    {
        LogEvent(EVENTLOG_ERROR_TYPE, EVENT_GENE_FILECREATE_FAILED, "Could not open a file for reporting new Genealogy events to.  Error code: %d", dwErr);
        return HRESULT_FROM_WIN32(dwErr);
    }
    szBuffer.FormatText("%d/%02d/%02d %02d:%02d:%02d,%s,ROW_EVENT\r\n", st.wYear, st.wMonth, st.wDay, st.wHour, st.wMinute, st.wSecond, (const CHAR *) bsSerial);
    s_EventFile.Write(szBuffer);
    s_EventFile.Close();
    
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\genealogy\geneadmin\GeneQuery\QueryDB.h ===
#pragma once

void QueryInputPath();
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\genealogy\geneadmin\GeneQuery\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Visual C++ generated include file.
// Used by GeneQuery.rc
//
#define IDS_SERVICENAME                 100
#define IDR_GENEQUERY                   101
#define IDR_GAQUERY                     102

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        201
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           103
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\genealogy\geneadmin\GeneQuery\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
// GeneQuery.pch will be the pre-compiled header
// stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\genealogy\geneadmin\GeneQuery\stdafx.h ===
// stdafx.h : include file for standard system include files,
// or project specific include files that are used frequently,
// but are changed infrequently

#pragma once

#undef UNICODE
#undef _UNICODE

#undef WIN32_LEAN_AND_MEAN

#ifndef STRICT
#define STRICT
#endif

// Modify the following defines if you have to target a platform prior to the ones specified below.
// Refer to MSDN for the latest info on corresponding values for different platforms.
#ifndef WINVER				// Allow use of features specific to Windows 95 and Windows NT 4 or later.
#define WINVER 0x0400		// Change this to the appropriate value to target Windows 98 and Windows 2000 or later.
#endif

#ifndef _WIN32_WINNT		// Allow use of features specific to Windows NT 4 or later.
#define _WIN32_WINNT 0x0400	// Change this to the appropriate value to target Windows 2000 or later.
#endif						

#ifndef _WIN32_WINDOWS		// Allow use of features specific to Windows 98 or later.
#define _WIN32_WINDOWS 0x0410 // Change this to the appropriate value to target Windows Me or later.
#endif

#ifndef _WIN32_IE			// Allow use of features specific to IE 4.0 or later.
#define _WIN32_IE 0x0400	// Change this to the appropriate value to target IE 5.0 or later.
#endif

#define _ATL_APARTMENT_THREADED
#define _ATL_NO_AUTOMATIC_NAMESPACE

#define _ATL_CSTRING_EXPLICIT_CONSTRUCTORS	// some CString constructors will be explicit

// turns off ATL's hiding of some common and often safely ignored warning messages
#define _ATL_ALL_WARNINGS


#include "resource.h"
#include <atlbase.h>
#include <atlcom.h>
#include <atlcomtime.h>
#include <comutil.h>
#include <assert.h>
#include <stdio.h>
#include "dbaccessor.h"
#include "critsect.h"
#include "strcls.h"
#include "utility.h"
#include "filemgr.h"
#include "globals.h"

using namespace ATL;
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\genealogy\geneadmin\GeneQuery\QueryDB.cpp ===
#include "stdafx.h"
#include "dbconn.h"
#include "search.h"
#include "strcls.h"
#include "dbconn.h"
#include "eventing.h"

#define EVENT_GENE_DB_NO_UODB_ENTRIES           0xCC01
#define EVENT_GENE_DB_UODB_CONNECT_FAILED   0xCC02

int QueryDBs(const char *szInputFile, const char *szOutputFile, CDBGeneImportRow& dbImported, CDBGeneFailRow& dbFailed, CDBQueryUODB *pUODB, DWORD dwUODBCount);
CDBQueryUODB *GetUODBMachines(DWORD &dwUODBCount);

void QueryInputPath()
{
    CFileSearch wfd;
    CSafeStr szSearch(MAX_PATH);
    CSafeStr szOutput(MAX_PATH);
    CDBGeneImportRow dbImported;
    CDBGeneFailRow dbFailed;
    CDBQueryUODB *pUODB = 0;
    DWORD dwUODBCount = 0;

    CombinePathFile(szSearch, g_szInputDir, "*.txt");
    
    if(!wfd.Start(szSearch))
    {
        if(ERROR_FILE_NOT_FOUND != wfd.GetLastError())
        {
            LogEvent(EVENTLOG_ERROR_TYPE, EVENT_GENE_SEARCH_FAILED, "QueryInputPath: Failed to search for \"%s\".  Error code: %d", (const CHAR *) szSearch, wfd.GetLastError());
        }
        return;
    }

    while(wfd.GetNext())
    {
        // We get the file name to check it in our destination directory
        if(wfd->dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY ||
            wfd->dwFileAttributes & FILE_ATTRIBUTE_OFFLINE)
            continue;

        CombinePathFile(szSearch, g_szInputDir, wfd->cFileName);
        CombinePathFile(szOutput, g_szOutputDir, wfd->cFileName);
        ClearRO(szSearch);
        
        if(!wfd->nFileSizeHigh && !wfd->nFileSizeLow)
        {
            DeleteFile(szSearch);
            continue;
        }

        if(!pUODB)
            pUODB = GetUODBMachines(dwUODBCount);
        
        if(QueryDBs(szSearch, szOutput, dbImported, dbFailed, pUODB, dwUODBCount))
            goto Cleanup;
    }

Cleanup:
    if(pUODB)
        delete [] pUODB;
        
}


int QueryDBs(const char *szInputFile, const char *szOutputFile, CDBGeneImportRow& dbImported, CDBGeneFailRow& dbFailed, CDBQueryUODB *pUODB, DWORD dwUODBCount)
{
    FILE *fIn = 0, *fOut = 0;
    static CSafeStr szLine(2048);
    CHAR szSerial[21];
    DWORD dwLen, dwGoodCount = 0, dwCount = 0, dwIndex;
    SYSTEMTIME st;
    DBTIMESTAMP dt;
    DWORD dwSerialCount = 0, dwMachineAccounts = 0, dwFeedRows = 0, dwErrorRows = 0, dwNoFeedRows = 0;
    bool fDelete = false;

    szLine.AllowTruncate(TRUE);
    
    int retval = -1;

    fIn = fopen(szInputFile, "r");
    fOut = fopen(szOutputFile, "w");
    if(!fIn || !fOut)
    {
        if(!fIn)
        {
            DebugOutput("Failed to open input file.");
            LogEvent(EVENTLOG_ERROR_TYPE, EVENT_GENE_FILEOPEN_FAILED, "Failed to open input file \"%s\".  Error code: %d", szInputFile, GetLastError());
        }
        if(!fOut)
        {
            DebugOutput("Failed to open output file.");
            LogEvent(EVENTLOG_ERROR_TYPE, EVENT_GENE_FILECREATE_FAILED, "Failed to open output file \"%s\".  Error code: %d", szOutputFile, GetLastError());
        }
        goto Cleanup;
    }

    DebugOutput("Files opened.");
    LogEvent(EVENTLOG_INFORMATION_TYPE, EVENT_GENE_BEGIN_FILE_PROCESSING, "Started processing file \"%s\"\nWriting to \"%s\"", szInputFile, szOutputFile);

    while(fgets(szSerial, 21, fIn))
    {
        dwCount = dwGoodCount = 0;
        szSerial[12] = 0;
        if(DigitCount(szSerial) != 12)
            continue;
        DebugOutput("Processing %s: ", szSerial);
        ++dwSerialCount;
        if(!dbImported.Start(g_szGeneMachine, g_szGeneDatabase, szSerial))
        {
            DebugOutput("Query against genealogy failed.\n");
            goto Cleanup;
        }

        while(dbImported.GetNext())
        {
            GetSystemTime(&st);
            // Format: Current date & time, serial number, row type (ROW_FEED), Part#, Key, LastUpdateDate, Seq#, SeqDate
            szLine.FormatText("%04d/%02d/%02d %02d:%02d:%02d,%s,ROW_FEED,%s,%s,%04d/%02d/%02d %02d:%02d:%02d,%d,%04d/%02d/%02d %02d:%02d:%02d",
                st.wYear, st.wMonth, st.wDay, st.wHour, st.wMinute, st.wSecond, szSerial, (const CHAR *) dbImported.m_szPartNo, (const CHAR *) dbImported.m_szKey,
                dbImported.m_dtLast.year, dbImported.m_dtLast.month, dbImported.m_dtLast.day, dbImported.m_dtLast.hour, dbImported.m_dtLast.minute, dbImported.m_dtLast.second,
                dbImported.m_dwSeqNo, dbImported.m_dtSeq.year, dbImported.m_dtSeq.month, dbImported.m_dtSeq.day, dbImported.m_dtSeq.hour, dbImported.m_dtSeq.minute, dbImported.m_dtSeq.second);
            fputs(szLine, fOut);
            fputs("\n", fOut);
            ++dwGoodCount;
            ++dwCount;
            ++dwFeedRows;
        }

        DebugOutput("%d feed rows, ", dwGoodCount);

        if(!dbFailed.Start(g_szGeneMachine, g_szGeneDatabase, szSerial))
        {
            DebugOutput("Query against genealogy failed.");
            goto Cleanup;
        }

        while(dbFailed.GetNext())
        {
            GetSystemTime(&st);
            // Format: Current date & time, serial number, row type (ROW_ERROR), import date, filename, row data, description
            szLine.FormatText("%04d/%02d/%02d %02d:%02d:%02d,%s,ROW_ERROR,%04d/%02d/%02d %02d:%02d:%02d,%s,%s,%s",
                st.wYear, st.wMonth, st.wDay, st.wHour, st.wMinute, st.wSecond, szSerial, 
                dbFailed.m_dtCreated.year, dbFailed.m_dtCreated.month, dbFailed.m_dtCreated.day, dbFailed.m_dtCreated.hour, dbFailed.m_dtCreated.minute, dbFailed.m_dtCreated.second,
                (const CHAR *) dbFailed.m_szFile, (const CHAR *) dbFailed.m_szRow, (const CHAR *) dbFailed.m_szDesc);
            szLine.DelChars("\r\n");
            fputs(szLine, fOut);
            fputs("\n", fOut);
            ++dwCount;
            ++dwErrorRows;
        }

        DebugOutput("%d failed rows", dwCount - dwGoodCount);

        // If we have never received a row, we don't expect a record in the UODB.
        if(!dwCount)
        {
            GetSystemTime(&st);
            // Format: Current date & time, serial number, row type (ROW_NONE)
            szLine.FormatText("%04d/%02d/%02d %02d:%02d:%02d,%s,ROW_NONE\n", st.wYear, st.wMonth, st.wDay, st.wHour, st.wMinute, st.wSecond, szSerial);
            fputs(szLine, fOut);
            DebugOutput("\n");
            ++dwNoFeedRows;
            continue;
        }

        if(!dwGoodCount)
        {
            DebugOutput("\n");
            continue;
        }

        for(dwIndex = 0; dwIndex < dwUODBCount; ++dwIndex)
        {
            dwLen = pUODB[dwIndex].GetResetDate(szSerial, dt);
            if((DWORD) -1 == dwLen)
            {
                DebugOutput("Query against the UODB failed at UODB machine index %d.", dwIndex);
                goto Cleanup;
            }
            if(dwLen)
            {
                GetSystemTime(&st);
                // Format: Current date & time, serial number, row type (ROW_ACCOUNT), account reset date
                szLine.FormatText("%04d/%02d/%02d %02d:%02d:%02d,%s,ROW_ACCOUNT,%04d/%02d/%02d %02d:%02d:%02d",
                    st.wYear, st.wMonth, st.wDay, st.wHour, st.wMinute, st.wSecond, szSerial,
                    dt.year, dt.month, dt.day, dt.hour, dt.minute, dt.second);
                DebugOutput(", account found");
                fputs(szLine, fOut);
                fputs("\n", fOut);
                ++dwMachineAccounts;
                continue;      // Will only appear in one database
            }
        }

        DebugOutput("\n");
    }

    LogEvent(EVENTLOG_INFORMATION_TYPE, EVENT_GENE_FINISHED_FILE_PROCESSING, "Finished processing input file %s.\n%d serial numbers processed\n%d feed rows found\n%d error rows found\n%d SNs without feed data\n%d machine accounts found", szInputFile, dwSerialCount, dwFeedRows, dwErrorRows, dwNoFeedRows, dwMachineAccounts);
    retval = 0;
    
Cleanup:
    if(fIn && feof(fIn))
        fDelete = true;
    if(fIn)
        fclose(fIn);
    if(fDelete)
        DeleteFile(szInputFile);
    if(fOut)
        fclose(fOut);
    return retval;
}

CDBQueryUODB *GetUODBMachines(DWORD &dwUODBCount)
{
    const CHAR *szPos;
    DWORD dwLen, i;
    CDBQueryUODB *pUODB = 0;
    szPos = g_szUODBMachines;
    for(dwUODBCount = 0; *szPos; )
    {
        CDBQueryMaster dbMaster;

        if (!dbMaster.Connect(szPos, g_szUODBDatabase))
        {
            LogEvent(EVENTLOG_ERROR_TYPE, EVENT_GENE_DB_UODB_CONNECT_FAILED, "Failed to connect to UODB machine %s (using database 'master') listed in the registry to connect to.  Please verify the registry is correct.", szPos);
            dwUODBCount = 0;
            return 0;
        }
        dwLen = dbMaster.GetUODBCount();
        if (dwLen == (DWORD)-1)
        {
            LogEvent(EVENTLOG_ERROR_TYPE, EVENT_GENE_DB_UODB_CONNECT_FAILED, "Failed to determine count of UODB databases on machine %s (using database 'master') listed in the registry to connect to.  Please verify the registry is correct.", szPos);
            dwUODBCount = 0;
            return 0;
        }

        dwUODBCount += dwLen;
        dwLen = strlen(szPos);
        szPos += dwLen + 1;
    }

    DebugOutput("Found %d UODB databases to connect to.\n", dwUODBCount);

    if(!dwUODBCount)
        LogEvent(EVENTLOG_ERROR_TYPE, EVENT_GENE_DB_NO_UODB_ENTRIES, "There were no UODB machines listed in the registry to connect to.  Please verify the registry is correct.");

    pUODB = new CDBQueryUODB[dwUODBCount];
    if(!pUODB)
    {
        dwUODBCount = 0;
        return 0;
    }

    szPos = g_szUODBMachines;
    for(i = 0; *szPos; )
    {
        CDBQueryMaster dbUODBs;

        if (!dbUODBs.Connect(szPos, g_szUODBDatabase) || !dbUODBs.Start())
        {
            dwUODBCount = 0;
            break;
        }

        while (dbUODBs.GetNext())
        {
            if(!pUODB[i].Connect(szPos, dbUODBs.m_szDbName))
            {
                LogEvent(EVENTLOG_ERROR_TYPE, EVENT_GENE_DB_UODB_CONNECT_FAILED, "Failed to connect to UODB machine %s (using database %s) listed in the registry to connect to.  Please verify the registry is correct.", szPos, (const CHAR *) dbUODBs.m_szDbName);
                dwUODBCount = 0;
                break;
            }
            DebugOutput("Established connection to %s:%s\n", szPos, dbUODBs.m_szDbName);
            i++;
        }
        szPos += strlen(szPos) + 1;
    }
    if(!dwUODBCount)
    {
        delete [] pUODB;
        pUODB = 0;
    }
    return pUODB;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\genealogy\geneadmin\GeneQuery\obj\i386\dlldata.c ===
/*********************************************************
   DllData file -- generated by MIDL compiler 

        DO NOT ALTER THIS FILE

   This file is regenerated by MIDL on every IDL file compile.

   To completely reconstruct this file, delete it and rerun MIDL
   on all the IDL files in this DLL, specifying this file for the
   /dlldata command line option

*********************************************************/

#define PROXY_DELEGATION

#include <rpcproxy.h>

#ifdef __cplusplus
extern "C"   {
#endif

EXTERN_PROXY_FILE( genequery )


PROXYFILE_LIST_START
/* Start of list */
  REFERENCE_PROXY_FILE( genequery ),
/* End of list */
PROXYFILE_LIST_END


DLLDATA_ROUTINES( aProxyFileList, GET_DLL_CLSID )

#ifdef __cplusplus
}  /*extern "C" */
#endif

/* end of generated dlldata file */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\genealogy\geneadmin\GeneQuery\obj\i386\genequery.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 7.00.0500 */
/* Compiler settings for genequery.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, oldnames, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#pragma warning( disable: 4049 )  /* more than 64k source lines */


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 500
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __genequery_h__
#define __genequery_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __IGAQuery_FWD_DEFINED__
#define __IGAQuery_FWD_DEFINED__
typedef interface IGAQuery IGAQuery;
#endif 	/* __IGAQuery_FWD_DEFINED__ */


#ifndef __GAQuery_FWD_DEFINED__
#define __GAQuery_FWD_DEFINED__

#ifdef __cplusplus
typedef class GAQuery GAQuery;
#else
typedef struct GAQuery GAQuery;
#endif /* __cplusplus */

#endif 	/* __GAQuery_FWD_DEFINED__ */


/* header files for imported files */
#include "oaidl.h"
#include "ocidl.h"

#ifdef __cplusplus
extern "C"{
#endif 


#ifndef __IGAQuery_INTERFACE_DEFINED__
#define __IGAQuery_INTERFACE_DEFINED__

/* interface IGAQuery */
/* [unique][helpstring][nonextensible][dual][uuid][object] */ 


EXTERN_C const IID IID_IGAQuery;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("0B472B16-2C90-45F2-BC76-ADD4DD7A4672")
    IGAQuery : public IDispatch
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE SubmitEvent( 
            /* [in] */ BSTR SerialNumber,
            /* [in] */ DATE FailureDate) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IGAQueryVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IGAQuery * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IGAQuery * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IGAQuery * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IGAQuery * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IGAQuery * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IGAQuery * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IGAQuery * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *SubmitEvent )( 
            IGAQuery * This,
            /* [in] */ BSTR SerialNumber,
            /* [in] */ DATE FailureDate);
        
        END_INTERFACE
    } IGAQueryVtbl;

    interface IGAQuery
    {
        CONST_VTBL struct IGAQueryVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IGAQuery_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IGAQuery_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IGAQuery_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IGAQuery_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IGAQuery_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IGAQuery_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IGAQuery_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IGAQuery_SubmitEvent(This,SerialNumber,FailureDate)	\
    ( (This)->lpVtbl -> SubmitEvent(This,SerialNumber,FailureDate) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IGAQuery_INTERFACE_DEFINED__ */



#ifndef __GeneQueryLib_LIBRARY_DEFINED__
#define __GeneQueryLib_LIBRARY_DEFINED__

/* library GeneQueryLib */
/* [helpstring][version][uuid] */ 


EXTERN_C const IID LIBID_GeneQueryLib;

EXTERN_C const CLSID CLSID_GAQuery;

#ifdef __cplusplus

class DECLSPEC_UUID("7B9AF05A-B886-4D1A-BCAB-E66A79AD3A74")
GAQuery;
#endif
#endif /* __GeneQueryLib_LIBRARY_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

unsigned long             __RPC_USER  BSTR_UserSize(     unsigned long *, unsigned long            , BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserMarshal(  unsigned long *, unsigned char *, BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserUnmarshal(unsigned long *, unsigned char *, BSTR * ); 
void                      __RPC_USER  BSTR_UserFree(     unsigned long *, BSTR * ); 

unsigned long             __RPC_USER  BSTR_UserSize64(     unsigned long *, unsigned long            , BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserMarshal64(  unsigned long *, unsigned char *, BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserUnmarshal64(unsigned long *, unsigned char *, BSTR * ); 
void                      __RPC_USER  BSTR_UserFree64(     unsigned long *, BSTR * ); 

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\genealogy\geneadmin\GeneQuery\obj\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86_genequery_none_12.4.56.0_none_9ae5df4a32a0b369
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86_genequery_no-public-key_12.4.56.0_x-ww_ecc1ed49
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=genequery
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86_genequery_no-public-key_12.4.56.0_x-ww_ecc1ed49
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86_genequery_no-public-key_12.4.56.0_x-ww_ecc1ed49.manifest
XP_MANIFEST_PATH=manifests\x86_genequery_no-public-key_12.4.56.0_x-ww_ecc1ed49.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86_genequery_no-public-key_12.4.56.0_x-ww_ecc1ed49.cat
XP_CATALOG_PATH=manifests\x86_genequery_no-public-key_12.4.56.0_x-ww_ecc1ed49.cat
XP_PAYLOAD_PATH=x86_genequery_no-public-key_12.4.56.0_x-ww_ecc1ed49
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=genequery,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\genealogy\geneadmin\GeneQuery\objd\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86_genequery_none_12.4.56.0_none_9ae5df4a32a0b369
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86_genequery_no-public-key_12.4.56.0_x-ww_ecc1ed49
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=genequery
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86_genequery_no-public-key_12.4.56.0_x-ww_ecc1ed49
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86_genequery_no-public-key_12.4.56.0_x-ww_ecc1ed49.manifest
XP_MANIFEST_PATH=manifests\x86_genequery_no-public-key_12.4.56.0_x-ww_ecc1ed49.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86_genequery_no-public-key_12.4.56.0_x-ww_ecc1ed49.cat
XP_CATALOG_PATH=manifests\x86_genequery_no-public-key_12.4.56.0_x-ww_ecc1ed49.cat
XP_PAYLOAD_PATH=x86_genequery_no-public-key_12.4.56.0_x-ww_ecc1ed49
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=genequery,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\genealogy\geneadmin\GeneQuery\objd\i386\dlldata.c ===
/*********************************************************
   DllData file -- generated by MIDL compiler 

        DO NOT ALTER THIS FILE

   This file is regenerated by MIDL on every IDL file compile.

   To completely reconstruct this file, delete it and rerun MIDL
   on all the IDL files in this DLL, specifying this file for the
   /dlldata command line option

*********************************************************/

#define PROXY_DELEGATION

#include <rpcproxy.h>

#ifdef __cplusplus
extern "C"   {
#endif

EXTERN_PROXY_FILE( genequery )


PROXYFILE_LIST_START
/* Start of list */
  REFERENCE_PROXY_FILE( genequery ),
/* End of list */
PROXYFILE_LIST_END


DLLDATA_ROUTINES( aProxyFileList, GET_DLL_CLSID )

#ifdef __cplusplus
}  /*extern "C" */
#endif

/* end of generated dlldata file */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\genealogy\geneadmin\GeneQuery\obj\i386\genequery_i.c ===
/* this ALWAYS GENERATED file contains the IIDs and CLSIDs */

/* link this file in with the server and any clients */


 /* File created by MIDL compiler version 7.00.0500 */
/* Compiler settings for genequery.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, oldnames, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#pragma warning( disable: 4049 )  /* more than 64k source lines */


#ifdef __cplusplus
extern "C"{
#endif 


#include <rpc.h>
#include <rpcndr.h>

#ifdef _MIDL_USE_GUIDDEF_

#ifndef INITGUID
#define INITGUID
#include <guiddef.h>
#undef INITGUID
#else
#include <guiddef.h>
#endif

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        DEFINE_GUID(name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8)

#else // !_MIDL_USE_GUIDDEF_

#ifndef __IID_DEFINED__
#define __IID_DEFINED__

typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;

#endif // __IID_DEFINED__

#ifndef CLSID_DEFINED
#define CLSID_DEFINED
typedef IID CLSID;
#endif // CLSID_DEFINED

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        const type name = {l,w1,w2,{b1,b2,b3,b4,b5,b6,b7,b8}}

#endif !_MIDL_USE_GUIDDEF_

MIDL_DEFINE_GUID(IID, IID_IGAQuery,0x0B472B16,0x2C90,0x45F2,0xBC,0x76,0xAD,0xD4,0xDD,0x7A,0x46,0x72);


MIDL_DEFINE_GUID(IID, LIBID_GeneQueryLib,0x750B7219,0x87D4,0x4D6F,0x83,0xF7,0x27,0x76,0x30,0xFE,0xA0,0x7C);


MIDL_DEFINE_GUID(CLSID, CLSID_GAQuery,0x7B9AF05A,0xB886,0x4D1A,0xBC,0xAB,0xE6,0x6A,0x79,0xAD,0x3A,0x74);

#undef MIDL_DEFINE_GUID

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\genealogy\geneadmin\GeneQuery\objd\i386\genequery.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 7.00.0500 */
/* Compiler settings for genequery.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, oldnames, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#pragma warning( disable: 4049 )  /* more than 64k source lines */


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 500
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __genequery_h__
#define __genequery_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __IGAQuery_FWD_DEFINED__
#define __IGAQuery_FWD_DEFINED__
typedef interface IGAQuery IGAQuery;
#endif 	/* __IGAQuery_FWD_DEFINED__ */


#ifndef __GAQuery_FWD_DEFINED__
#define __GAQuery_FWD_DEFINED__

#ifdef __cplusplus
typedef class GAQuery GAQuery;
#else
typedef struct GAQuery GAQuery;
#endif /* __cplusplus */

#endif 	/* __GAQuery_FWD_DEFINED__ */


/* header files for imported files */
#include "oaidl.h"
#include "ocidl.h"

#ifdef __cplusplus
extern "C"{
#endif 


#ifndef __IGAQuery_INTERFACE_DEFINED__
#define __IGAQuery_INTERFACE_DEFINED__

/* interface IGAQuery */
/* [unique][helpstring][nonextensible][dual][uuid][object] */ 


EXTERN_C const IID IID_IGAQuery;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("0B472B16-2C90-45F2-BC76-ADD4DD7A4672")
    IGAQuery : public IDispatch
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE SubmitEvent( 
            /* [in] */ BSTR SerialNumber,
            /* [in] */ DATE FailureDate) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IGAQueryVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IGAQuery * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IGAQuery * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IGAQuery * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IGAQuery * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IGAQuery * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IGAQuery * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IGAQuery * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *SubmitEvent )( 
            IGAQuery * This,
            /* [in] */ BSTR SerialNumber,
            /* [in] */ DATE FailureDate);
        
        END_INTERFACE
    } IGAQueryVtbl;

    interface IGAQuery
    {
        CONST_VTBL struct IGAQueryVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IGAQuery_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IGAQuery_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IGAQuery_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IGAQuery_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IGAQuery_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IGAQuery_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IGAQuery_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IGAQuery_SubmitEvent(This,SerialNumber,FailureDate)	\
    ( (This)->lpVtbl -> SubmitEvent(This,SerialNumber,FailureDate) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IGAQuery_INTERFACE_DEFINED__ */



#ifndef __GeneQueryLib_LIBRARY_DEFINED__
#define __GeneQueryLib_LIBRARY_DEFINED__

/* library GeneQueryLib */
/* [helpstring][version][uuid] */ 


EXTERN_C const IID LIBID_GeneQueryLib;

EXTERN_C const CLSID CLSID_GAQuery;

#ifdef __cplusplus

class DECLSPEC_UUID("7B9AF05A-B886-4D1A-BCAB-E66A79AD3A74")
GAQuery;
#endif
#endif /* __GeneQueryLib_LIBRARY_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

unsigned long             __RPC_USER  BSTR_UserSize(     unsigned long *, unsigned long            , BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserMarshal(  unsigned long *, unsigned char *, BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserUnmarshal(unsigned long *, unsigned char *, BSTR * ); 
void                      __RPC_USER  BSTR_UserFree(     unsigned long *, BSTR * ); 

unsigned long             __RPC_USER  BSTR_UserSize64(     unsigned long *, unsigned long            , BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserMarshal64(  unsigned long *, unsigned char *, BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserUnmarshal64(unsigned long *, unsigned char *, BSTR * ); 
void                      __RPC_USER  BSTR_UserFree64(     unsigned long *, BSTR * ); 

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\genealogy\geneadmin\GeneQuery\obj\i386\genequery_p.c ===
/* this ALWAYS GENERATED file contains the proxy stub code */


 /* File created by MIDL compiler version 7.00.0500 */
/* Compiler settings for genequery.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, oldnames, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#if !defined(_M_IA64) && !defined(_M_AMD64)


#pragma warning( disable: 4049 )  /* more than 64k source lines */
#if _MSC_VER >= 1200
#pragma warning(push)
#endif

#pragma warning( disable: 4211 )  /* redefine extern to static */
#pragma warning( disable: 4232 )  /* dllimport identity*/
#pragma warning( disable: 4024 )  /* array to pointer mapping*/
#pragma warning( disable: 4152 )  /* function/data pointer conversion in expression */
#pragma warning( disable: 4100 ) /* unreferenced arguments in x86 call */

#pragma optimize("", off ) 

#define USE_STUBLESS_PROXY


/* verify that the <rpcproxy.h> version is high enough to compile this file*/
#ifndef __REDQ_RPCPROXY_H_VERSION__
#define __REQUIRED_RPCPROXY_H_VERSION__ 475
#endif


#include "rpcproxy.h"
#ifndef __RPCPROXY_H_VERSION__
#error this stub requires an updated version of <rpcproxy.h>
#endif // __RPCPROXY_H_VERSION__


#include "genequery.h"

#define TYPE_FORMAT_STRING_SIZE   49                                
#define PROC_FORMAT_STRING_SIZE   43                                
#define EXPR_FORMAT_STRING_SIZE   1                                 
#define TRANSMIT_AS_TABLE_SIZE    0            
#define WIRE_MARSHAL_TABLE_SIZE   1            

typedef struct _genequery_MIDL_TYPE_FORMAT_STRING
    {
    short          Pad;
    unsigned char  Format[ TYPE_FORMAT_STRING_SIZE ];
    } genequery_MIDL_TYPE_FORMAT_STRING;

typedef struct _genequery_MIDL_PROC_FORMAT_STRING
    {
    short          Pad;
    unsigned char  Format[ PROC_FORMAT_STRING_SIZE ];
    } genequery_MIDL_PROC_FORMAT_STRING;

typedef struct _genequery_MIDL_EXPR_FORMAT_STRING
    {
    long          Pad;
    unsigned char  Format[ EXPR_FORMAT_STRING_SIZE ];
    } genequery_MIDL_EXPR_FORMAT_STRING;


static RPC_SYNTAX_IDENTIFIER  _RpcTransferSyntax = 
{{0x8A885D04,0x1CEB,0x11C9,{0x9F,0xE8,0x08,0x00,0x2B,0x10,0x48,0x60}},{2,0}};


extern const genequery_MIDL_TYPE_FORMAT_STRING genequery__MIDL_TypeFormatString;
extern const genequery_MIDL_PROC_FORMAT_STRING genequery__MIDL_ProcFormatString;
extern const genequery_MIDL_EXPR_FORMAT_STRING genequery__MIDL_ExprFormatString;


extern const MIDL_STUB_DESC Object_StubDesc;


extern const MIDL_SERVER_INFO IGAQuery_ServerInfo;
extern const MIDL_STUBLESS_PROXY_INFO IGAQuery_ProxyInfo;


extern const USER_MARSHAL_ROUTINE_QUADRUPLE UserMarshalRoutines[ WIRE_MARSHAL_TABLE_SIZE ];

#if !defined(__RPC_WIN32__)
#error  Invalid build platform for this stub.
#endif
#if !(TARGET_IS_NT51_OR_LATER)
#error You need a Windows XP or later to run this stub because it uses these features:
#error   #error However, your C/C++ compilation flags indicate you intend to run this app on earlier systems.
#error This app will fail with the RPC_X_WRONG_STUB_VERSION error.
#endif


static const genequery_MIDL_PROC_FORMAT_STRING genequery__MIDL_ProcFormatString =
    {
        0,
        {

	/* Procedure SubmitEvent */

			0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/*  2 */	NdrFcLong( 0x0 ),	/* 0 */
/*  6 */	NdrFcShort( 0x7 ),	/* 7 */
/*  8 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
/* 10 */	NdrFcShort( 0x10 ),	/* 16 */
/* 12 */	NdrFcShort( 0x8 ),	/* 8 */
/* 14 */	0x46,		/* Oi2 Flags:  clt must size, has return, has ext, */
			0x3,		/* 3 */
/* 16 */	0x8,		/* 8 */
			0x45,		/* Ext Flags:  new corr desc, srv corr check, has range on conformance */
/* 18 */	NdrFcShort( 0x0 ),	/* 0 */
/* 20 */	NdrFcShort( 0x1 ),	/* 1 */
/* 22 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter SerialNumber */

/* 24 */	NdrFcShort( 0x8b ),	/* Flags:  must size, must free, in, by val, */
/* 26 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 28 */	NdrFcShort( 0x26 ),	/* Type Offset=38 */

	/* Parameter FailureDate */

/* 30 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 32 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 34 */	0xc,		/* FC_DOUBLE */
			0x0,		/* 0 */

	/* Return value */

/* 36 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 38 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 40 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

			0x0
        }
    };

static const genequery_MIDL_TYPE_FORMAT_STRING genequery__MIDL_TypeFormatString =
    {
        0,
        {
			NdrFcShort( 0x0 ),	/* 0 */
/*  2 */	
			0x12, 0x0,	/* FC_UP */
/*  4 */	NdrFcShort( 0x18 ),	/* Offset= 24 (28) */
/*  6 */	
			0x1b,		/* FC_CARRAY */
			0x1,		/* 1 */
/*  8 */	NdrFcShort( 0x2 ),	/* 2 */
/* 10 */	0x9,		/* Corr desc: FC_ULONG */
			0x0,		/*  */
/* 12 */	NdrFcShort( 0xfffc ),	/* -4 */
/* 14 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 16 */	0x0 , 
			0x0,		/* 0 */
/* 18 */	NdrFcLong( 0x0 ),	/* 0 */
/* 22 */	NdrFcLong( 0x0 ),	/* 0 */
/* 26 */	0x6,		/* FC_SHORT */
			0x5b,		/* FC_END */
/* 28 */	
			0x17,		/* FC_CSTRUCT */
			0x3,		/* 3 */
/* 30 */	NdrFcShort( 0x8 ),	/* 8 */
/* 32 */	NdrFcShort( 0xffe6 ),	/* Offset= -26 (6) */
/* 34 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 36 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 38 */	0xb4,		/* FC_USER_MARSHAL */
			0x83,		/* 131 */
/* 40 */	NdrFcShort( 0x0 ),	/* 0 */
/* 42 */	NdrFcShort( 0x4 ),	/* 4 */
/* 44 */	NdrFcShort( 0x0 ),	/* 0 */
/* 46 */	NdrFcShort( 0xffd4 ),	/* Offset= -44 (2) */

			0x0
        }
    };

static const USER_MARSHAL_ROUTINE_QUADRUPLE UserMarshalRoutines[ WIRE_MARSHAL_TABLE_SIZE ] = 
        {
            
            {
            BSTR_UserSize
            ,BSTR_UserMarshal
            ,BSTR_UserUnmarshal
            ,BSTR_UserFree
            }

        };



/* Object interface: IUnknown, ver. 0.0,
   GUID={0x00000000,0x0000,0x0000,{0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46}} */


/* Object interface: IDispatch, ver. 0.0,
   GUID={0x00020400,0x0000,0x0000,{0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46}} */


/* Object interface: IGAQuery, ver. 0.0,
   GUID={0x0B472B16,0x2C90,0x45F2,{0xBC,0x76,0xAD,0xD4,0xDD,0x7A,0x46,0x72}} */

#pragma code_seg(".orpc")
static const unsigned short IGAQuery_FormatStringOffsetTable[] =
    {
    (unsigned short) -1,
    (unsigned short) -1,
    (unsigned short) -1,
    (unsigned short) -1,
    0
    };

static const MIDL_STUBLESS_PROXY_INFO IGAQuery_ProxyInfo =
    {
    &Object_StubDesc,
    genequery__MIDL_ProcFormatString.Format,
    &IGAQuery_FormatStringOffsetTable[-3],
    0,
    0,
    0
    };


static const MIDL_SERVER_INFO IGAQuery_ServerInfo = 
    {
    &Object_StubDesc,
    0,
    genequery__MIDL_ProcFormatString.Format,
    &IGAQuery_FormatStringOffsetTable[-3],
    0,
    0,
    0,
    0};
CINTERFACE_PROXY_VTABLE(8) _IGAQueryProxyVtbl = 
{
    &IGAQuery_ProxyInfo,
    &IID_IGAQuery,
    IUnknown_QueryInterface_Proxy,
    IUnknown_AddRef_Proxy,
    IUnknown_Release_Proxy ,
    0 /* (void *) (INT_PTR) -1 /* IDispatch::GetTypeInfoCount */ ,
    0 /* (void *) (INT_PTR) -1 /* IDispatch::GetTypeInfo */ ,
    0 /* (void *) (INT_PTR) -1 /* IDispatch::GetIDsOfNames */ ,
    0 /* IDispatch_Invoke_Proxy */ ,
    (void *) (INT_PTR) -1 /* IGAQuery::SubmitEvent */
};


static const PRPC_STUB_FUNCTION IGAQuery_table[] =
{
    STUB_FORWARDING_FUNCTION,
    STUB_FORWARDING_FUNCTION,
    STUB_FORWARDING_FUNCTION,
    STUB_FORWARDING_FUNCTION,
    NdrStubCall2
};

CInterfaceStubVtbl _IGAQueryStubVtbl =
{
    &IID_IGAQuery,
    &IGAQuery_ServerInfo,
    8,
    &IGAQuery_table[-3],
    CStdStubBuffer_DELEGATING_METHODS
};

static const MIDL_STUB_DESC Object_StubDesc = 
    {
    0,
    NdrOleAllocate,
    NdrOleFree,
    0,
    0,
    0,
    0,
    0,
    genequery__MIDL_TypeFormatString.Format,
    1, /* -error bounds_check flag */
    0x60001, /* Ndr library version */
    0,
    0x70001f4, /* MIDL Version 7.0.500 */
    0,
    UserMarshalRoutines,
    0,  /* notify & notify_flag routine table */
    0x1, /* MIDL flag */
    0, /* cs routines */
    0,   /* proxy/server info */
    0
    };

const CInterfaceProxyVtbl * _genequery_ProxyVtblList[] = 
{
    ( CInterfaceProxyVtbl *) &_IGAQueryProxyVtbl,
    0
};

const CInterfaceStubVtbl * _genequery_StubVtblList[] = 
{
    ( CInterfaceStubVtbl *) &_IGAQueryStubVtbl,
    0
};

PCInterfaceName const _genequery_InterfaceNamesList[] = 
{
    "IGAQuery",
    0
};

const IID *  _genequery_BaseIIDList[] = 
{
    &IID_IDispatch,
    0
};


#define _genequery_CHECK_IID(n)	IID_GENERIC_CHECK_IID( _genequery, pIID, n)

int __stdcall _genequery_IID_Lookup( const IID * pIID, int * pIndex )
{
    
    if(!_genequery_CHECK_IID(0))
        {
        *pIndex = 0;
        return 1;
        }

    return 0;
}

const ExtendedProxyFileInfo genequery_ProxyFileInfo = 
{
    (PCInterfaceProxyVtblList *) & _genequery_ProxyVtblList,
    (PCInterfaceStubVtblList *) & _genequery_StubVtblList,
    (const PCInterfaceName * ) & _genequery_InterfaceNamesList,
    (const IID ** ) & _genequery_BaseIIDList,
    & _genequery_IID_Lookup, 
    1,
    2,
    0, /* table of [async_uuid] interfaces */
    0, /* Filler1 */
    0, /* Filler2 */
    0  /* Filler3 */
};
#pragma optimize("", on )
#if _MSC_VER >= 1200
#pragma warning(pop)
#endif


#endif /* !defined(_M_IA64) && !defined(_M_AMD64)*/
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\genealogy\geneadmin\GeneQuery\objd\i386\genequery_i.c ===
/* this ALWAYS GENERATED file contains the IIDs and CLSIDs */

/* link this file in with the server and any clients */


 /* File created by MIDL compiler version 7.00.0500 */
/* Compiler settings for genequery.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, oldnames, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#pragma warning( disable: 4049 )  /* more than 64k source lines */


#ifdef __cplusplus
extern "C"{
#endif 


#include <rpc.h>
#include <rpcndr.h>

#ifdef _MIDL_USE_GUIDDEF_

#ifndef INITGUID
#define INITGUID
#include <guiddef.h>
#undef INITGUID
#else
#include <guiddef.h>
#endif

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        DEFINE_GUID(name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8)

#else // !_MIDL_USE_GUIDDEF_

#ifndef __IID_DEFINED__
#define __IID_DEFINED__

typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;

#endif // __IID_DEFINED__

#ifndef CLSID_DEFINED
#define CLSID_DEFINED
typedef IID CLSID;
#endif // CLSID_DEFINED

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        const type name = {l,w1,w2,{b1,b2,b3,b4,b5,b6,b7,b8}}

#endif !_MIDL_USE_GUIDDEF_

MIDL_DEFINE_GUID(IID, IID_IGAQuery,0x0B472B16,0x2C90,0x45F2,0xBC,0x76,0xAD,0xD4,0xDD,0x7A,0x46,0x72);


MIDL_DEFINE_GUID(IID, LIBID_GeneQueryLib,0x750B7219,0x87D4,0x4D6F,0x83,0xF7,0x27,0x76,0x30,0xFE,0xA0,0x7C);


MIDL_DEFINE_GUID(CLSID, CLSID_GAQuery,0x7B9AF05A,0xB886,0x4D1A,0xBC,0xAB,0xE6,0x6A,0x79,0xAD,0x3A,0x74);

#undef MIDL_DEFINE_GUID

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\genealogy\geneadmin\mailscript\makefile.inc ===
!include $(INETROOT)\build\makefile.inc

COPYFILES:
    echo Copying mailscript...
    -robocopy . $(_NTTREE)\tools\geneadmin\mailscript *.vbs /XD obj objd /R:0 /NP /NJH /NJS /A-:R
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\genealogy\geneadmin\GeneQuery\objd\i386\genequery_p.c ===
/* this ALWAYS GENERATED file contains the proxy stub code */


 /* File created by MIDL compiler version 7.00.0500 */
/* Compiler settings for genequery.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, oldnames, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#if !defined(_M_IA64) && !defined(_M_AMD64)


#pragma warning( disable: 4049 )  /* more than 64k source lines */
#if _MSC_VER >= 1200
#pragma warning(push)
#endif

#pragma warning( disable: 4211 )  /* redefine extern to static */
#pragma warning( disable: 4232 )  /* dllimport identity*/
#pragma warning( disable: 4024 )  /* array to pointer mapping*/
#pragma warning( disable: 4152 )  /* function/data pointer conversion in expression */
#pragma warning( disable: 4100 ) /* unreferenced arguments in x86 call */

#pragma optimize("", off ) 

#define USE_STUBLESS_PROXY


/* verify that the <rpcproxy.h> version is high enough to compile this file*/
#ifndef __REDQ_RPCPROXY_H_VERSION__
#define __REQUIRED_RPCPROXY_H_VERSION__ 475
#endif


#include "rpcproxy.h"
#ifndef __RPCPROXY_H_VERSION__
#error this stub requires an updated version of <rpcproxy.h>
#endif // __RPCPROXY_H_VERSION__


#include "genequery.h"

#define TYPE_FORMAT_STRING_SIZE   49                                
#define PROC_FORMAT_STRING_SIZE   43                                
#define EXPR_FORMAT_STRING_SIZE   1                                 
#define TRANSMIT_AS_TABLE_SIZE    0            
#define WIRE_MARSHAL_TABLE_SIZE   1            

typedef struct _genequery_MIDL_TYPE_FORMAT_STRING
    {
    short          Pad;
    unsigned char  Format[ TYPE_FORMAT_STRING_SIZE ];
    } genequery_MIDL_TYPE_FORMAT_STRING;

typedef struct _genequery_MIDL_PROC_FORMAT_STRING
    {
    short          Pad;
    unsigned char  Format[ PROC_FORMAT_STRING_SIZE ];
    } genequery_MIDL_PROC_FORMAT_STRING;

typedef struct _genequery_MIDL_EXPR_FORMAT_STRING
    {
    long          Pad;
    unsigned char  Format[ EXPR_FORMAT_STRING_SIZE ];
    } genequery_MIDL_EXPR_FORMAT_STRING;


static RPC_SYNTAX_IDENTIFIER  _RpcTransferSyntax = 
{{0x8A885D04,0x1CEB,0x11C9,{0x9F,0xE8,0x08,0x00,0x2B,0x10,0x48,0x60}},{2,0}};


extern const genequery_MIDL_TYPE_FORMAT_STRING genequery__MIDL_TypeFormatString;
extern const genequery_MIDL_PROC_FORMAT_STRING genequery__MIDL_ProcFormatString;
extern const genequery_MIDL_EXPR_FORMAT_STRING genequery__MIDL_ExprFormatString;


extern const MIDL_STUB_DESC Object_StubDesc;


extern const MIDL_SERVER_INFO IGAQuery_ServerInfo;
extern const MIDL_STUBLESS_PROXY_INFO IGAQuery_ProxyInfo;


extern const USER_MARSHAL_ROUTINE_QUADRUPLE UserMarshalRoutines[ WIRE_MARSHAL_TABLE_SIZE ];

#if !defined(__RPC_WIN32__)
#error  Invalid build platform for this stub.
#endif
#if !(TARGET_IS_NT51_OR_LATER)
#error You need a Windows XP or later to run this stub because it uses these features:
#error   #error However, your C/C++ compilation flags indicate you intend to run this app on earlier systems.
#error This app will fail with the RPC_X_WRONG_STUB_VERSION error.
#endif


static const genequery_MIDL_PROC_FORMAT_STRING genequery__MIDL_ProcFormatString =
    {
        0,
        {

	/* Procedure SubmitEvent */

			0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/*  2 */	NdrFcLong( 0x0 ),	/* 0 */
/*  6 */	NdrFcShort( 0x7 ),	/* 7 */
/*  8 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
/* 10 */	NdrFcShort( 0x10 ),	/* 16 */
/* 12 */	NdrFcShort( 0x8 ),	/* 8 */
/* 14 */	0x46,		/* Oi2 Flags:  clt must size, has return, has ext, */
			0x3,		/* 3 */
/* 16 */	0x8,		/* 8 */
			0x45,		/* Ext Flags:  new corr desc, srv corr check, has range on conformance */
/* 18 */	NdrFcShort( 0x0 ),	/* 0 */
/* 20 */	NdrFcShort( 0x1 ),	/* 1 */
/* 22 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter SerialNumber */

/* 24 */	NdrFcShort( 0x8b ),	/* Flags:  must size, must free, in, by val, */
/* 26 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 28 */	NdrFcShort( 0x26 ),	/* Type Offset=38 */

	/* Parameter FailureDate */

/* 30 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 32 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 34 */	0xc,		/* FC_DOUBLE */
			0x0,		/* 0 */

	/* Return value */

/* 36 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 38 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 40 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

			0x0
        }
    };

static const genequery_MIDL_TYPE_FORMAT_STRING genequery__MIDL_TypeFormatString =
    {
        0,
        {
			NdrFcShort( 0x0 ),	/* 0 */
/*  2 */	
			0x12, 0x0,	/* FC_UP */
/*  4 */	NdrFcShort( 0x18 ),	/* Offset= 24 (28) */
/*  6 */	
			0x1b,		/* FC_CARRAY */
			0x1,		/* 1 */
/*  8 */	NdrFcShort( 0x2 ),	/* 2 */
/* 10 */	0x9,		/* Corr desc: FC_ULONG */
			0x0,		/*  */
/* 12 */	NdrFcShort( 0xfffc ),	/* -4 */
/* 14 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 16 */	0x0 , 
			0x0,		/* 0 */
/* 18 */	NdrFcLong( 0x0 ),	/* 0 */
/* 22 */	NdrFcLong( 0x0 ),	/* 0 */
/* 26 */	0x6,		/* FC_SHORT */
			0x5b,		/* FC_END */
/* 28 */	
			0x17,		/* FC_CSTRUCT */
			0x3,		/* 3 */
/* 30 */	NdrFcShort( 0x8 ),	/* 8 */
/* 32 */	NdrFcShort( 0xffe6 ),	/* Offset= -26 (6) */
/* 34 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 36 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 38 */	0xb4,		/* FC_USER_MARSHAL */
			0x83,		/* 131 */
/* 40 */	NdrFcShort( 0x0 ),	/* 0 */
/* 42 */	NdrFcShort( 0x4 ),	/* 4 */
/* 44 */	NdrFcShort( 0x0 ),	/* 0 */
/* 46 */	NdrFcShort( 0xffd4 ),	/* Offset= -44 (2) */

			0x0
        }
    };

static const USER_MARSHAL_ROUTINE_QUADRUPLE UserMarshalRoutines[ WIRE_MARSHAL_TABLE_SIZE ] = 
        {
            
            {
            BSTR_UserSize
            ,BSTR_UserMarshal
            ,BSTR_UserUnmarshal
            ,BSTR_UserFree
            }

        };



/* Object interface: IUnknown, ver. 0.0,
   GUID={0x00000000,0x0000,0x0000,{0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46}} */


/* Object interface: IDispatch, ver. 0.0,
   GUID={0x00020400,0x0000,0x0000,{0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46}} */


/* Object interface: IGAQuery, ver. 0.0,
   GUID={0x0B472B16,0x2C90,0x45F2,{0xBC,0x76,0xAD,0xD4,0xDD,0x7A,0x46,0x72}} */

#pragma code_seg(".orpc")
static const unsigned short IGAQuery_FormatStringOffsetTable[] =
    {
    (unsigned short) -1,
    (unsigned short) -1,
    (unsigned short) -1,
    (unsigned short) -1,
    0
    };

static const MIDL_STUBLESS_PROXY_INFO IGAQuery_ProxyInfo =
    {
    &Object_StubDesc,
    genequery__MIDL_ProcFormatString.Format,
    &IGAQuery_FormatStringOffsetTable[-3],
    0,
    0,
    0
    };


static const MIDL_SERVER_INFO IGAQuery_ServerInfo = 
    {
    &Object_StubDesc,
    0,
    genequery__MIDL_ProcFormatString.Format,
    &IGAQuery_FormatStringOffsetTable[-3],
    0,
    0,
    0,
    0};
CINTERFACE_PROXY_VTABLE(8) _IGAQueryProxyVtbl = 
{
    &IGAQuery_ProxyInfo,
    &IID_IGAQuery,
    IUnknown_QueryInterface_Proxy,
    IUnknown_AddRef_Proxy,
    IUnknown_Release_Proxy ,
    0 /* (void *) (INT_PTR) -1 /* IDispatch::GetTypeInfoCount */ ,
    0 /* (void *) (INT_PTR) -1 /* IDispatch::GetTypeInfo */ ,
    0 /* (void *) (INT_PTR) -1 /* IDispatch::GetIDsOfNames */ ,
    0 /* IDispatch_Invoke_Proxy */ ,
    (void *) (INT_PTR) -1 /* IGAQuery::SubmitEvent */
};


static const PRPC_STUB_FUNCTION IGAQuery_table[] =
{
    STUB_FORWARDING_FUNCTION,
    STUB_FORWARDING_FUNCTION,
    STUB_FORWARDING_FUNCTION,
    STUB_FORWARDING_FUNCTION,
    NdrStubCall2
};

CInterfaceStubVtbl _IGAQueryStubVtbl =
{
    &IID_IGAQuery,
    &IGAQuery_ServerInfo,
    8,
    &IGAQuery_table[-3],
    CStdStubBuffer_DELEGATING_METHODS
};

static const MIDL_STUB_DESC Object_StubDesc = 
    {
    0,
    NdrOleAllocate,
    NdrOleFree,
    0,
    0,
    0,
    0,
    0,
    genequery__MIDL_TypeFormatString.Format,
    1, /* -error bounds_check flag */
    0x60001, /* Ndr library version */
    0,
    0x70001f4, /* MIDL Version 7.0.500 */
    0,
    UserMarshalRoutines,
    0,  /* notify & notify_flag routine table */
    0x1, /* MIDL flag */
    0, /* cs routines */
    0,   /* proxy/server info */
    0
    };

const CInterfaceProxyVtbl * _genequery_ProxyVtblList[] = 
{
    ( CInterfaceProxyVtbl *) &_IGAQueryProxyVtbl,
    0
};

const CInterfaceStubVtbl * _genequery_StubVtblList[] = 
{
    ( CInterfaceStubVtbl *) &_IGAQueryStubVtbl,
    0
};

PCInterfaceName const _genequery_InterfaceNamesList[] = 
{
    "IGAQuery",
    0
};

const IID *  _genequery_BaseIIDList[] = 
{
    &IID_IDispatch,
    0
};


#define _genequery_CHECK_IID(n)	IID_GENERIC_CHECK_IID( _genequery, pIID, n)

int __stdcall _genequery_IID_Lookup( const IID * pIID, int * pIndex )
{
    
    if(!_genequery_CHECK_IID(0))
        {
        *pIndex = 0;
        return 1;
        }

    return 0;
}

const ExtendedProxyFileInfo genequery_ProxyFileInfo = 
{
    (PCInterfaceProxyVtblList *) & _genequery_ProxyVtblList,
    (PCInterfaceStubVtblList *) & _genequery_StubVtblList,
    (const PCInterfaceName * ) & _genequery_InterfaceNamesList,
    (const IID ** ) & _genequery_BaseIIDList,
    & _genequery_IID_Lookup, 
    1,
    2,
    0, /* table of [async_uuid] interfaces */
    0, /* Filler1 */
    0, /* Filler2 */
    0  /* Filler3 */
};
#pragma optimize("", on )
#if _MSC_VER >= 1200
#pragma warning(pop)
#endif


#endif /* !defined(_M_IA64) && !defined(_M_AMD64)*/
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\genealogy\geneadmin\mailscript\obj\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86__mailscript_1_none_12.4.56.0_none_31951f0d60f138c3
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86__mailscript_1_no-public-key_12.4.56.0_x-ww_1021a4c9
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=_mailscript_1
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86__mailscript_1_no-public-key_12.4.56.0_x-ww_1021a4c9
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86__mailscript_1_no-public-key_12.4.56.0_x-ww_1021a4c9.manifest
XP_MANIFEST_PATH=manifests\x86__mailscript_1_no-public-key_12.4.56.0_x-ww_1021a4c9.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86__mailscript_1_no-public-key_12.4.56.0_x-ww_1021a4c9.cat
XP_CATALOG_PATH=manifests\x86__mailscript_1_no-public-key_12.4.56.0_x-ww_1021a4c9.cat
XP_PAYLOAD_PATH=x86__mailscript_1_no-public-key_12.4.56.0_x-ww_1021a4c9
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=_mailscript_1,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\genealogy\geneadmin\parser\makefile.inc ===
!include $(INETROOT)\build\makefile.inc

COPYFILES:
    echo Copying parser...
    -robocopy . $(_NTTREE)\tools\geneadmin\parser *.asp /XD obj objd /R:0 /NP /NJH /NJS /A-:R
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\genealogy\geneadmin\parser\obj\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86__parser_0_none_12.4.56.0_none_e6cda39451aabecf
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86__parser_0_no-public-key_12.4.56.0_x-ww_be9fa4e5
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=_parser_0
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86__parser_0_no-public-key_12.4.56.0_x-ww_be9fa4e5
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86__parser_0_no-public-key_12.4.56.0_x-ww_be9fa4e5.manifest
XP_MANIFEST_PATH=manifests\x86__parser_0_no-public-key_12.4.56.0_x-ww_be9fa4e5.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86__parser_0_no-public-key_12.4.56.0_x-ww_be9fa4e5.cat
XP_CATALOG_PATH=manifests\x86__parser_0_no-public-key_12.4.56.0_x-ww_be9fa4e5.cat
XP_PAYLOAD_PATH=x86__parser_0_no-public-key_12.4.56.0_x-ww_be9fa4e5
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=_parser_0,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\genealogy\geneadmin\mailscript\objd\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86__mailscript_1_none_12.4.56.0_none_31951f0d60f138c3
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86__mailscript_1_no-public-key_12.4.56.0_x-ww_1021a4c9
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=_mailscript_1
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86__mailscript_1_no-public-key_12.4.56.0_x-ww_1021a4c9
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86__mailscript_1_no-public-key_12.4.56.0_x-ww_1021a4c9.manifest
XP_MANIFEST_PATH=manifests\x86__mailscript_1_no-public-key_12.4.56.0_x-ww_1021a4c9.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86__mailscript_1_no-public-key_12.4.56.0_x-ww_1021a4c9.cat
XP_CATALOG_PATH=manifests\x86__mailscript_1_no-public-key_12.4.56.0_x-ww_1021a4c9.cat
XP_PAYLOAD_PATH=x86__mailscript_1_no-public-key_12.4.56.0_x-ww_1021a4c9
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=_mailscript_1,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\genealogy\geneadmin\psstats\makefile.inc ===
!include $(INETROOT)\build\makefile.inc

COPYFILES:
    echo Copying psstats...
    -robocopy . $(_NTTREE)\tools\geneadmin\psstats *.asp /XD obj objd /R:0 /NP /NJH /NJS /A-:R
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\genealogy\geneadmin\parser\objd\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86__parser_0_none_12.4.56.0_none_e6cda39451aabecf
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86__parser_0_no-public-key_12.4.56.0_x-ww_be9fa4e5
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=_parser_0
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86__parser_0_no-public-key_12.4.56.0_x-ww_be9fa4e5
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86__parser_0_no-public-key_12.4.56.0_x-ww_be9fa4e5.manifest
XP_MANIFEST_PATH=manifests\x86__parser_0_no-public-key_12.4.56.0_x-ww_be9fa4e5.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86__parser_0_no-public-key_12.4.56.0_x-ww_be9fa4e5.cat
XP_CATALOG_PATH=manifests\x86__parser_0_no-public-key_12.4.56.0_x-ww_be9fa4e5.cat
XP_PAYLOAD_PATH=x86__parser_0_no-public-key_12.4.56.0_x-ww_be9fa4e5
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=_parser_0,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\genealogy\geneadmin\psstats\obj\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86__psstats_0_none_12.4.56.0_none_f42bf8772fc52e4e
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86__psstats_0_no-public-key_12.4.56.0_x-ww_4c5f6224
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=_psstats_0
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86__psstats_0_no-public-key_12.4.56.0_x-ww_4c5f6224
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86__psstats_0_no-public-key_12.4.56.0_x-ww_4c5f6224.manifest
XP_MANIFEST_PATH=manifests\x86__psstats_0_no-public-key_12.4.56.0_x-ww_4c5f6224.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86__psstats_0_no-public-key_12.4.56.0_x-ww_4c5f6224.cat
XP_CATALOG_PATH=manifests\x86__psstats_0_no-public-key_12.4.56.0_x-ww_4c5f6224.cat
XP_PAYLOAD_PATH=x86__psstats_0_no-public-key_12.4.56.0_x-ww_4c5f6224
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=_psstats_0,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\genealogy\geneadmin\service\Base64.cpp ===
/*++

    Copyright (c) Microsoft Corporation

    Module Name:

        Base64.cpp

    Abstract:

        Base64 encode/decode functions.

--*/

#include "stdafx.h"

#include <windows.h>
#include <assert.h>

#include "Base64.h"

BYTE g_achBase64DecodeTable[256]={
    64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,
    64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,62,64,64,64,63,
    52,53,54,55,56,57,58,59,60,61,64,64,64,64,64,64,64,0,1,2,3,4,5,6,7,8,9,
    10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,64,64,64,64,64,64,26,27,
    28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,
    64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,
    64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,
    64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,
    64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,
    64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,
    64,64,64,64,64,64,64,64,64,64,64,64,64
};

CHAR g_achBase64EncodeTable[64] = {
    'A','B','C','D','E','F','G','H','I','J','K','L','M',
    'N','O','P','Q','R','S','T','U','V','W','X','Y','Z',
    'a','b','c','d','e','f','g','h','i','j','k','l','m',
    'n','o','p','q','r','s','t','u','v','w','x','y','z',
    '0','1','2','3','4','5','6','7','8','9','+','/'
};

BOOL WINAPI
Base64Decode(
    LPCSTR  pszSrc,
    ULONG   ulSrcSize,
    LPBYTE  pDst,
    PULONG  pulDstSize
    )

/*++

Routine Description:

    Base64Decode    This method decodes a Base-64 encoded chunk of binary data.

Arguments:

    pszSrc      Points to Base64-encoded string to decode.

    ulSrcSize   Length of the string pointed to by pszSrc, not including 
                terminating null character.

    pDst        Buffer to copy the decoded binary data into.  The size of this
                buffer must be at least BASE64_DECODE_BUFFER_SIZE(ulSrcSize)

    pulDstSize  On return contains the length in bytes of the decoded buffer.

Return Value:

     0 - Decode was successful.

--*/

{
    ULONG   ulIndex;
    ULONG   ulCurOut;
    DWORD   dwGroup;
    DWORD   dwCur;
    DWORD   dwPadSeen;
    CHAR    chCur;

    dwGroup  = 0;
    dwPadSeen = 0;
    ulCurOut = 0;

    if(ulSrcSize % 4 != 0)
        return FALSE;

    for(ulIndex = 0; ulIndex < ulSrcSize; ulIndex++)
    {
        chCur = pszSrc[ulIndex];
        if(chCur == '=')
        {
            dwPadSeen++;
            dwCur = 0;
        }
        else
        {
            dwCur = g_achBase64DecodeTable[chCur];
        }
        assert( dwCur != 64 );
        
        dwGroup |= (dwCur << (6 * (ulIndex & 0x3)));

        if((ulIndex & 0x3) == 0x3)
        {
            pDst[ulCurOut++] = (CHAR)( dwGroup        & 0xff);

            if(dwPadSeen <= 1)
            {
                pDst[ulCurOut++] = (CHAR)((dwGroup >>  8) & 0xff);

                if(dwPadSeen == 0)
                    pDst[ulCurOut++] = (CHAR)((dwGroup >> 16) & 0xff);
            }

            dwGroup = 0;
        }
    }

    *pulDstSize = ulCurOut;
    assert( ulCurOut <= BASE64_DECODE_BUFFER_SIZE(ulSrcSize) );
    
    return TRUE;
}

BOOL WINAPI
Base64Encode(
    const LPBYTE    pSrc,
    ULONG           ulSrcSize,
    LPSTR           pszDst
    )

/*++

Routine Description:

    Base64Encode    This method converts a buffer of arbitrary binary data into
                    a Base-64 encoded string.

Arguments:

    pSrc        Points to the buffer of bytes to encode.

    ulSrcSize   Number of bytes in pSrc to encode.

    pszDst      Buffer to copy the encoded output into.  The length of the buffer
                must be at least BASE64_ENCODE_BUFFER_SIZE(ulSrcSize).

Return Value:

     0 - Encoding successful.

--*/

{
    DWORD   dwGroup;
    ULONG   ulCurGroup = 0, ulIndex;

    for(ulIndex = 0; ulIndex < (ulSrcSize - (ulSrcSize % 3)); ulIndex += 3)
    {
        dwGroup = (pSrc[ulIndex+2] << 16) | (pSrc[ulIndex+1] << 8) | pSrc[ulIndex];

        pszDst[ulCurGroup++] = g_achBase64EncodeTable[  dwGroup        & 0x3f ];
        pszDst[ulCurGroup++] = g_achBase64EncodeTable[ (dwGroup >> 6)  & 0x3f ];
        pszDst[ulCurGroup++] = g_achBase64EncodeTable[ (dwGroup >> 12) & 0x3f ];
        pszDst[ulCurGroup++] = g_achBase64EncodeTable[ (dwGroup >> 18) & 0x3f ];
    }

    //  Do the end special case.
    switch(ulSrcSize % 3)
    {
    case 2:
        dwGroup = (pSrc[ulIndex+1]  << 8)| pSrc[ulIndex];

        pszDst[ulCurGroup++] = g_achBase64EncodeTable[  dwGroup        & 0x3f ];
        pszDst[ulCurGroup++] = g_achBase64EncodeTable[ (dwGroup >> 6)  & 0x3f ];
        pszDst[ulCurGroup++] = g_achBase64EncodeTable[ (dwGroup >> 12) & 0x3f ];
        pszDst[ulCurGroup++] = '=';

        break;

    case 1:
        dwGroup = pSrc[ulIndex];

        pszDst[ulCurGroup++] = g_achBase64EncodeTable[  dwGroup        & 0x3f ];
        pszDst[ulCurGroup++] = g_achBase64EncodeTable[ (dwGroup >> 6)  & 0x3f ];
        pszDst[ulCurGroup++] = '=';
        pszDst[ulCurGroup++] = '=';

        break;
    }

    //  Null terminate the string.
    pszDst[ulCurGroup] = 0; 
    assert( ulCurGroup < BASE64_ENCODE_BUFFER_SIZE(ulSrcSize) );
    
    return TRUE;
}

// EOF
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\genealogy\geneadmin\service\base64.h ===
/*++

    Copyright (c) Microsoft Corporation

    Module Name:

        Base64.h

--*/

#ifndef __BASE64_H
#define __BASE64_H

#ifdef __cplusplus
extern "C" {
#endif

#define BASE64_ENCODE_BUFFER_SIZE( ulSrcSize ) (((((ulSrcSize) + 2) / 3) * 4) + 1)

BOOL WINAPI
Base64Encode(               
    const LPBYTE    pSrc,
    ULONG           ulSrcSize,
    LPSTR           pszDst
    );

#define BASE64_DECODE_BUFFER_SIZE( ulSrcSize ) (((ulSrcSize) / 4) * 3)

BOOL WINAPI
Base64Decode(
    LPCSTR      pszSrc,
    ULONG       ulSrcSize,
    LPBYTE      pDst,
    PULONG      pulDstSize
    );

#ifdef __cplusplus
}
#endif

#endif // __BASE64_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\genealogy\geneadmin\psstats\objd\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86__psstats_0_none_12.4.56.0_none_f42bf8772fc52e4e
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86__psstats_0_no-public-key_12.4.56.0_x-ww_4c5f6224
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=_psstats_0
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86__psstats_0_no-public-key_12.4.56.0_x-ww_4c5f6224
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86__psstats_0_no-public-key_12.4.56.0_x-ww_4c5f6224.manifest
XP_MANIFEST_PATH=manifests\x86__psstats_0_no-public-key_12.4.56.0_x-ww_4c5f6224.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86__psstats_0_no-public-key_12.4.56.0_x-ww_4c5f6224.cat
XP_CATALOG_PATH=manifests\x86__psstats_0_no-public-key_12.4.56.0_x-ww_4c5f6224.cat
XP_PAYLOAD_PATH=x86__psstats_0_no-public-key_12.4.56.0_x-ww_4c5f6224
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=_psstats_0,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\genealogy\geneadmin\service\copythread.cpp ===
#include "Stdafx.h"

#include "feedthread.h"
#include "DBConn.h"

// Determines whether a file has been completely imported into the database
//  Return value 1: yes, file is completely imported
//  Return value 0: no, file is not completely imported
//  First parameter is file name (input only)
//  Second parameter is file size (input only)
static CHAR szFileIDQuery[] = "{? = call getSourceFileID(?, ?)}";

unsigned __stdcall fnCopyFileWorkerThread(void *)
{
    HANDLE hEndThreadEvent = NULL;
    DWORD dwIndex;
    DWORD dwTimeout;
    DWORD dwLen;
    DWORD dwFileID;
    CSafeStr szSourceSearch(2*MAX_PATH), szDest(2*MAX_PATH);
    DWORDLONG dwlSource, dwlBytesProcessed;
    DWORD dwError;

    bool bFirst = true;

    // Hook up to the end service event
    hEndThreadEvent = _Module.EndThreadEvent();

    while(!(g_dwDisableThreads & FEED_THREADS))
    {
        CFileSearch wfd;
        if(!bFirst)
        {
            if(!g_dwFeedCopyFrequency)
                dwTimeout = 20 * 60 * 1000;
            else
                dwTimeout = g_dwFeedCopyFrequency * 60 * 1000;
            dwIndex = WaitForSingleObject(hEndThreadEvent, dwTimeout);
            if(WAIT_OBJECT_0 == dwIndex)
                break;
        }

        bFirst = false;

        // Every time I get here, check the drop dir for new feeds and copy them over to the local inbound directory
        CombinePathFile(szSourceSearch, g_szFeedDropPath, "*.txt");
        if(!wfd.Start(szSourceSearch))
        {
            if(ERROR_FILE_NOT_FOUND != wfd.GetLastError())
            {
                LogEvent(EVENTLOG_ERROR_TYPE, EVENT_GENE_SEARCH_FAILED, "CopyThread: Failed to search for the following: \"%s\".\nThe error that occurred is: %d", (const CHAR *) szSourceSearch, wfd.GetLastError());
            }
            SetEvent(g_hInitialCopyDone);
            continue;
        }

        CDBQuerySourceFile qsf;

        while(wfd.GetNext())
        {
            // We get the file name to check it in our destination directory
            if(wfd->dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY ||
                wfd->dwFileAttributes & FILE_ATTRIBUTE_OFFLINE)
                continue;
            CombinePathFile(szSourceSearch, g_szFeedDropPath, wfd->cFileName);
            dwlSource = wfd->nFileSizeHigh;
            dwlSource <<= 32;
            dwlSource += wfd->nFileSizeLow;
            if(!dwlSource)
            {
                continue;
            }

            CombinePathFile(szDest, g_szFeedLocalPath, wfd->cFileName);

            // Skip the file if we've already copied it.
            if(dwlSource <= FileSize(szDest))
                continue;

            // Check the database to see if we have imported it, and if so how much.  If what we have imported 
            // is less than the file size, we need to continue just in case (file is partially imported, service stopped,
            // file deleted, service restarted, should pick up where it left off).
            dwLen = strlen(wfd->cFileName);
            dwFileID = qsf.GetSourceFileInfo(wfd->cFileName, dwlBytesProcessed);
            if(dwFileID && dwFileID != ((DWORD) -1) && dwlBytesProcessed >= dwlSource)
                continue;

            if(!CopyFile(szSourceSearch, szDest, FALSE))
            {
                LogEvent(EVENTLOG_WARNING_TYPE, EVENT_GENE_FILECOPY_FAILED, "Failed to copy file \"%s\" to \"%s\".  Error code: %d", (const CHAR *) szSourceSearch, (const CHAR *) szDest, GetLastError());
                dwError = GetLastError();
            }
            else
            {
                LogEvent(EVENTLOG_INFORMATION_TYPE, EVENT_GENE_FILE_COPIED, "File copied from \"%s\" to \"%s\".", (const CHAR *) szSourceSearch, (const CHAR *) szDest);
            }
        } // all txt files in the source directory

        SetEvent(g_hInitialCopyDone);
    }

    _Module.ThreadCompleting();
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\genealogy\geneadmin\service\copythread.h ===
#pragma once


unsigned __stdcall fnCopyFileWorkerThread(void *);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\genealogy\geneadmin\service\DBConn.h ===
#pragma once


#define DODECLARATIONS
#include "DBControl.h"


/******************************************************************************
    CDBConn Class
 ******************************************************************************/

/*  CDBConn is the base class that provides the basic functionality of connecting to the database and 
    initializing the statement handle
*/
class CDBConn
{
public:
    VOID Disconnect();
protected:
    CDBConn();
    virtual ~CDBConn();

    BOOL Connect(const CHAR *szServer, const CHAR *szDatabase, const CHAR *szQuery, const CHAR *szUserName = NULL, const CHAR *szPassword = NULL);
    BOOL Connected();

    BOOL m_fBound;
    HDBCONN m_hConn;
    HDBSTMT m_hStmt;
}; // CDBConn

/******************************************************************************
    CDBFailedSet Class
 ******************************************************************************/
/*  {call p_SVCGetGeneFailures}
*/
#define DBFAILED_ROWS(stmt, jumpto)                                                 \
    DEF_BINDCOLSEQ(stmt, 1, CHAR, m_szSerial, 21, m_dwSerialLen, jumpto)            \
    DEF_BINDCOL(stmt, 2, DBTIMESTAMP, m_dtFirst, m_optFirst, jumpto)                \
    DEF_BINDCOL(stmt, 3, DBTIMESTAMP, m_dtLast, m_optLast, jumpto)                  \
    DEF_BINDCOL(stmt, 4, DWORD, m_dwBugID, m_optBugID, jumpto)                      \
    DEF_BINDCOL(stmt, 5, DWORD, m_dwState, m_optState, jumpto)                      \
    DEF_BINDCOL(stmt, 6, DBTIMESTAMP, m_dtAccount, m_optAccount, jumpto)            \
    DEF_BINDCOL(stmt, 7, DBTIMESTAMP, m_dtProd, m_optProd, jumpto)                  \
    DEF_BINDCOL(stmt, 8, DBTIMESTAMP, m_dtBugProdUpd, m_optBugProdUpd, jumpto)

class CDBFailedSet : public CDBConn
{
public:
    CDBFailedSet();
    ~CDBFailedSet() {}

    BOOL Start();
    BOOL GetNext();

    DBFAILED_ROWS(0, 0);
};

/******************************************************************************
    CDBFeedRows Class
 ******************************************************************************/
//  {call p_SVCGetFeedRows(?)}
#define DBFEED_ROWS(stmt, jumpto)                                                   \
    DEF_BINDPARAMSAFE_IN(stmt, 1, m_szSerial, 21, m_dwSerialLen, jumpto)            \
    DEF_BINDCOL(stmt, 1, BOOL, m_fUnicode, m_optUnicode, jumpto)                    \
    DEF_BINDCOL(stmt, 2, DBTIMESTAMP, m_dtFileDate, m_optFileDate, jumpto)          \
    DEF_BINDCOLSEQ(stmt, 3, CHAR, m_szFileName, 256, m_dwFileNameLen, jumpto)       \
    DEF_BINDCOLSEQ(stmt, 4, CHAR, m_szPartNo, 10, m_dwPartNoLen, jumpto)            \
    DEF_BINDCOLSEQ(stmt, 5, CHAR, m_szKey, 13, m_dwKeyLen, jumpto)

class CDBFeedRows : public CDBConn
{
public:
    CDBFeedRows();
    ~CDBFeedRows() {}

    BOOL Start(CHAR *szSerial);
    BOOL GetNext();

    DBFEED_ROWS(0, 0);
};

/******************************************************************************
    CDBQuerySourceFile Class
 ******************************************************************************/
//  {? = call p_SVCGetFeedFile(?, ?)}


#define DEFQUERYSOURCEFILE(stmt, jumpto)                                            \
    DEF_BINDPARAM_OUT(stmt, 1, DWORD, m_dwBugID, m_optBugID, jumpto)                \
    DEF_BINDPARAMSAFE_IN(stmt, 2, m_szFileName, 256, m_dwFileNameLen, jumpto)       \
    DEF_BINDPARAM_OUT(stmt, 3, DWORDLONG, m_dwlProcessed, m_optProcessed, jumpto)

class CDBQuerySourceFile : public CDBConn
{
public:
    CDBQuerySourceFile();
    ~CDBQuerySourceFile () {}
    DWORD GetSourceFileInfo(const CHAR *szFileName, DWORDLONG& dwlBytesProcessed);

    DEFQUERYSOURCEFILE(0, 0);
};

/******************************************************************************
    CDBInsertSourceFile Class
 ******************************************************************************/
// {? = call p_SVCInsertFeedFile(?, ?)}

#define DEFINSERTSOURCEFILE(stmt, jumpto)                                           \
    DEF_BINDPARAM_OUT(stmt, 1, DWORD, m_dwBugID, m_optBugID, jumpto)                \
    DEF_BINDPARAMSAFE_IN(stmt, 2, m_szFileName, 256, m_dwFileNameLen, jumpto)       \
    DEF_BINDPARAM_IN(stmt, 3, BOOL, m_fUnicode, jumpto)

class CDBInsertSourceFile : public CDBConn
{
public:
    CDBInsertSourceFile();
    ~CDBInsertSourceFile() {}
    DWORD InsertSourceFile(const CHAR *szFileName, bool fUnicode);

    DEFINSERTSOURCEFILE(0, 0);
};

/******************************************************************************
    CDBInsertFailure Class
 ******************************************************************************/
// {call p_SVCInsertGeneFailure(?, ?)}

#define DEFINSERTFAILURE(stmt, jumpto)                                              \
    DEF_BINDPARAMSAFE_IN(stmt, 1, m_szSerial, 21, m_dwSerialLen, jumpto)            \
    DEF_BINDPARAM_IN(stmt, 2, DBTIMESTAMP, m_dtSeen, jumpto)

class CDBInsertFailure : public CDBConn
{
public:
    CDBInsertFailure();
    ~CDBInsertFailure() {}

    DWORD InsertFailure(const CHAR *szSerial, const SYSTEMTIME& dtSeen);

    DEFINSERTFAILURE(0, 0);
};

/******************************************************************************
    CDBUpdateFailure Class
 ******************************************************************************/
// {call p_SVCUpdateGeneFailure(?, ?, ?)}

#define DEFUPDATEFAILURE(stmt, jumpto)                                              \
    DEF_BINDPARAMSAFE_IN(stmt, 1, m_szSerial, 21, m_dwSerialLen, jumpto)            \
    DEF_BINDPARAM_IN(stmt, 2, DWORD, m_dwBugID, jumpto)                             \
    DEF_BINDPARAM_IN(stmt, 3, DWORD, m_dwState, jumpto)

class CDBUpdateFailure : public CDBConn
{
public:
    CDBUpdateFailure();
    ~CDBUpdateFailure() {}

    DWORD UpdateFailure(const CHAR *szSerial, DWORD dwBugID, DWORD dwState);

    DEFUPDATEFAILURE(0, 0);
};


/******************************************************************************
    CDBInsertParsedRow Class
 ******************************************************************************/
// {call p_SVCInsertFeedRow(?, ?, ?, ?, ?, ?, ?, ?, ?, ?)}

#define DEFINSERTPARSEDROW(stmt, jumpto)                                            \
    DEF_BINDPARAM_IN(stmt, 1, DWORD, m_dwFileID, jumpto)                            \
    DEF_BINDPARAMSAFE_IN(stmt, 2, m_szSerial, 21, m_dwSerialLen, jumpto)            \
    DEF_BINDPARAMSAFE_IN(stmt, 3, m_szPartNo, 12, m_dwPartNoLen, jumpto)            \
    DEF_BINDPARAMSAFE_IN(stmt, 4, m_szKey, 180, m_dwKeyLen, jumpto)                 \
    DEF_BINDPARAMSAFE_IN(stmt, 5, m_szKeyVer, 5, m_dwKeyVerLen, jumpto)             \
    DEF_BINDPARAMSAFE_IN(stmt, 6, m_szMACAddr, 13, m_dwMACLen, jumpto)              \
    DEF_BINDPARAMSAFE_IN(stmt, 7, m_szGameReg, 10, m_dwGameRegLen, jumpto)          \
    DEF_BINDPARAMSAFE_IN(stmt, 8, m_szTVReg, 10, m_dwTVRegLen, jumpto)              \
    DEF_BINDPARAMSAFE_IN(stmt, 9, m_szIsActive, 2, m_dwIsActiveLen, jumpto)         \
    DEF_BINDPARAM_IN(stmt, 10, DWORDLONG, m_dwlProcessed, jumpto)

class CDBInsertParsedRow : public CDBConn
{
public:
    CDBInsertParsedRow();
    ~CDBInsertParsedRow() {}
    DWORD InsertRow(DWORD dwFileID, const CHAR *szSerial, const CHAR *szPartNo, const CHAR *szKey,
                    const CHAR *szKeyVer, const CHAR *szMACAddr, const CHAR *szGameReg, const CHAR *szTVReg,
                    const CHAR *szIsActive, const DWORDLONG& dwlProcessed);

    DWORD InsertRow(DWORD dwFileID, const DWORDLONG& dwlProcessed);

    DEFINSERTPARSEDROW(0, 0);
};

/******************************************************************************
    CDBInsertFailedRow Class
 ******************************************************************************/
// {call p_SVCInsertFeedError(?, ?, ?, ?)}

#define DEFINSERTFAILEDROW(stmt, jumpto)                                            \
    DEF_BINDPARAM_IN(stmt, 1, DWORD, m_dwFileID, jumpto)                            \
    DEF_BINDPARAMSAFE_IN(stmt, 2, m_szDesc, 100, m_dwDescLen, jumpto)               \
    DEF_BINDPARAMSAFE_IN(stmt, 3, m_szRow, 512, m_dwRowLen, jumpto)                 \
    DEF_BINDPARAM_IN(stmt, 4, DWORDLONG, m_dwlProcessed, jumpto)

class CDBInsertFailedRow : public CDBConn
{
public:
    CDBInsertFailedRow();
    ~CDBInsertFailedRow() {}
    DWORD InsertRow(DWORD dwFileID, const CHAR *szErrorDesc, const CHAR *szRowData, const DWORDLONG& dwlProcessed);

    DEFINSERTFAILEDROW(0, 0);
};

/******************************************************************************
    CDBSetFailedUODBDate Class
 ******************************************************************************/
// {call UPDATE p_SVCSetMachineAccountDate(?, ?)}

#define DEFSETFAILEDUODBDATE(stmt, jumpto)                                          \
    DEF_BINDPARAMSAFE_IN(stmt, 1, m_szSerial, 21, m_dwSerialLen, jumpto)            \
    DEF_BINDPARAM_IN(stmt, 2, DBTIMESTAMP, m_dtAccount, jumpto)

class CDBSetFailedUODBDate : public CDBConn
{
public:
    CDBSetFailedUODBDate();
    ~CDBSetFailedUODBDate() {}
    DWORD SetUODBDate(const CHAR *szSerial, const DBTIMESTAMP& dt);

    DEFSETFAILEDUODBDATE(0, 0);
};

/******************************************************************************
    CDBSetProdDate Class
 ******************************************************************************/
// {call p_SVCSetLastProdQueryDate(?, ?)}

#define DEFSETFAILEDPRODDATE(stmt, jumpto)                                          \
    DEF_BINDPARAMSAFE_IN(stmt, 1, m_szSerial, 21, m_dwSerialLen, jumpto)            \
    DEF_BINDPARAM_IN(stmt, 2, DBTIMESTAMP, m_dtAccount, jumpto)                     \

class CDBSetProdDate : public CDBConn
{
public:
    CDBSetProdDate();
    ~CDBSetProdDate() {}
    DWORD SetProdDate(const CHAR *szSerial, const DBTIMESTAMP& dt);

    DEFSETFAILEDPRODDATE(0, 0);
};

/******************************************************************************
    CDBInsertProdFeedRow Class
 ******************************************************************************/
// {call p_SVCInsertProdRow(?, ?, ?, ?, ?, ?, ?)}

#define DEFINSERTPRODFEEDROW(stmt, jumpto)                                          \
    DEF_BINDPARAMSAFE_IN(stmt, 1, m_szSerial, 21, m_dwSerialLen, jumpto)            \
    DEF_BINDPARAMSAFE_IN(stmt, 2, m_szPartNo, 10, m_dwPartNoLen, jumpto)            \
    DEF_BINDPARAMSAFE_IN(stmt, 3, m_szKey, 13, m_dwKeyLen, jumpto)                  \
    DEF_BINDPARAM_IN(stmt, 4, DBTIMESTAMP, m_dtLast, jumpto)                        \
    DEF_BINDPARAM_IN(stmt, 5, DWORD, m_dwSeqNo, jumpto)                             \
    DEF_BINDPARAM_IN(stmt, 6, DBTIMESTAMP, m_dtSeq, jumpto)                         \
    DEF_BINDPARAM_IN(stmt, 7, DBTIMESTAMP, m_dtQuery, jumpto)

class CDBInsertProdFeedRow : public CDBConn
{
public:
    CDBInsertProdFeedRow();
    ~CDBInsertProdFeedRow() {}
    DWORD InsertProdFeedRow(const CHAR *szSerial, const CHAR *szPartNo, const CHAR *szKey, const DBTIMESTAMP& dtLast, DWORD dwSeqNo, const DBTIMESTAMP& dtSeq, const DBTIMESTAMP& dtQuery);

    DEFINSERTPRODFEEDROW(0, 0);
};

/******************************************************************************
    CDBInsertProdErrorRow Class
 ******************************************************************************/
// {call p_SVCInsertProdError(?, ?, ?, ?, ?, ?)}

#define DEFINSERTPRODERRORROW(stmt, jumpto)                                         \
    DEF_BINDPARAMSAFE_IN(stmt, 1, m_szSerial, 21, m_dwSerialLen, jumpto)            \
    DEF_BINDPARAM_IN(stmt, 2, DBTIMESTAMP, m_dtFailed, jumpto)                      \
    DEF_BINDPARAMSAFE_IN(stmt, 3, m_szFileName, 256, m_dwFileNameLen, jumpto)       \
    DEF_BINDPARAMSAFE_IN(stmt, 4, m_szDesc, 256, m_dwDescLen, jumpto)               \
    DEF_BINDPARAMSAFE_IN(stmt, 5, m_szRow, 512, m_dwRowLen, jumpto)                 \
    DEF_BINDPARAM_IN(stmt, 6, DBTIMESTAMP, m_dtQuery, jumpto)

class CDBInsertProdErrorRow : public CDBConn
{
public:
    CDBInsertProdErrorRow();
    ~CDBInsertProdErrorRow() {}
    DWORD InsertProdErrorRow(const CHAR *szSerial, const DBTIMESTAMP& dtFailed, const CHAR *szFileName, const CHAR *szDesc, const CHAR *szErrorRow, const DBTIMESTAMP& dtQuery);

    DEFINSERTPRODERRORROW(0, 0);
};

/******************************************************************************
    CDBGetProdRows Class
 ******************************************************************************/
//  {call p_SVCGetProdRows(?)}
#define DBGETPRODROWS(stmt, jumpto)                                                 \
    DEF_BINDPARAMSAFE_IN(stmt, 1, m_szSerial, 21, m_dwSerialLen, jumpto)            \
    DEF_BINDCOLSEQ(stmt, 1, CHAR, m_szPartNo, 10, m_dwPartNoLen, jumpto)            \
    DEF_BINDCOLSEQ(stmt, 2, CHAR, m_szKey, 13, m_dwKeyLen, jumpto)                  \
    DEF_BINDCOL(stmt, 3, DBTIMESTAMP, m_dtLast, m_optLast, jumpto)                  \
    DEF_BINDCOL(stmt, 4, DWORD, m_dwSeqNo, m_optSeqNo, jumpto)                      \
    DEF_BINDCOL(stmt, 5, DBTIMESTAMP, m_dtSeq, m_optSeq, jumpto)

class CDBGetProdRows : public CDBConn
{
public:
    CDBGetProdRows();
    ~CDBGetProdRows() {}

    BOOL Start(CHAR *szSerial);
    BOOL GetNext();

    DBGETPRODROWS(0, 0);
};

/******************************************************************************
    CDBGetProdErrors Class
 ******************************************************************************/
//  {call p_SVCGetProdErrors(?)}

#define DBGETPRODERRORS(stmt, jumpto)                                               \
    DEF_BINDPARAMSAFE_IN(stmt, 1, m_szSerial, 21, m_dwSerialLen, jumpto)            \
    DEF_BINDCOL(stmt, 1, DBTIMESTAMP, m_dtFailed, m_optFailed, jumpto)              \
    DEF_BINDCOLSEQ(stmt, 2, CHAR, m_szFile, 256, m_dwFileLen, jumpto)               \
    DEF_BINDCOLSEQ(stmt, 3, CHAR, m_szDesc, 256, m_dwDescLen, jumpto)

class CDBGetProdErrors : public CDBConn
{
public:
    CDBGetProdErrors();
    ~CDBGetProdErrors() {}

    BOOL Start(CHAR *szSerial);
    BOOL GetNext();

    DBGETPRODERRORS(0, 0);
};

/******************************************************************************
    CDBGetFeedFailed Class
 ******************************************************************************/
//  {call p_SVCGetFeedErrors(?)}

#define DBGETFEEDFAILED(stmt, jumpto)                                               \
    DEF_BINDPARAMSAFE_IN(stmt, 1, m_szSerial, 21, m_dwSerialLen, jumpto)            \
    DEF_BINDCOL(stmt, 1, DBTIMESTAMP, m_dtFailed, m_optFailed, jumpto)              \
    DEF_BINDCOLSEQ(stmt, 2, CHAR, m_szFile, 256, m_dwFileLen, jumpto)               \
    DEF_BINDCOLSEQ(stmt, 3, CHAR, m_szDesc, 256, m_dwDescLen, jumpto)

class CDBGetFeedFailed : public CDBConn
{
public:
    CDBGetFeedFailed();
    ~CDBGetFeedFailed() {}

    BOOL Start(CHAR *szSerial);
    BOOL GetNext();

    DBGETFEEDFAILED(0, 0);
};

/******************************************************************************
    CDBSetLastProdUpdateDate Class
 ******************************************************************************/
// {call p_SVCSetLastProdUpdateDate(?, ?)}

#define DEFSETLASTPRODUPDATEDATE(stmt, jumpto)                                      \
    DEF_BINDPARAMSAFE_IN(stmt, 1, m_szSerial, 21, m_dwSerialLen, jumpto)            \
    DEF_BINDPARAM_IN(stmt, 2, DBTIMESTAMP, m_dtLastUpdated, jumpto)

class CDBSetLastProdUpdateDate : public CDBConn
{
public:
    CDBSetLastProdUpdateDate();
    ~CDBSetLastProdUpdateDate() {}
    DWORD SetLastProdUpdateDate(const CHAR *szSerial, const DBTIMESTAMP& dt);

    DEFSETLASTPRODUPDATEDATE(0, 0);
};

/******************************************************************************
    CDBGetNewKeyCount Class
 ******************************************************************************/
// {call p_SVCGetNewKeyCount(?, ?)}

#define DEFGETNEWKEYCOUNT(stmt, jumpto)                                             \
    DEF_BINDPARAMSAFE_IN(stmt, 1, m_szSerial, 21, m_dwSerialLen, jumpto)            \
    DEF_BINDPARAM_IN(stmt, 2, DBTIMESTAMP, m_dtLastFailed, jumpto)                  \
    DEF_BINDCOL(stmt, 1, DWORD, m_dwCount, m_dwCountOpt, jumpto)

class CDBGetNewKeyCount : public CDBConn
{
public:
    CDBGetNewKeyCount();
    ~CDBGetNewKeyCount() {}
    DWORD GetNewKeyCount(const CHAR *szSerial, const DBTIMESTAMP& dt);

    DEFGETNEWKEYCOUNT(0, 0);
};

/******************************************************************************
    CDBGetSNByBugID Class
 ******************************************************************************/
// {call p_SVCGetSNByBugID(?)}

#define DEFGETSNBYBUGID(stmt, jumpto)                                             \
    DEF_BINDPARAM_IN(stmt, 1, DWORD, m_dwBugID, jumpto)                             \
    DEF_BINDCOLSEQ(stmt, 1, CHAR, m_szSerial, 21, m_dwSerialLen, jumpto)

class CDBGetSNByBugID : public CDBConn
{
public:
    CDBGetSNByBugID();
    ~CDBGetSNByBugID() {}
    DWORD GetSNByBugID(DWORD dwBugID, TSafeStr<21> szSerial);

    DEFGETSNBYBUGID(0, 0);
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\genealogy\geneadmin\service\eventthread.h ===
#pragma once


unsigned __stdcall fnEventFileWorkerThread(void *);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\genealogy\geneadmin\service\eventthread.cpp ===
#include "Stdafx.h"
#include "DBConn.h"

DWORD ProcessEventFile(CDBInsertFailure& dbif, const CHAR *szFileName, const CHAR *szType);

unsigned __stdcall fnEventFileWorkerThread(void *)
{
    HANDLE hEndThreadEvent = INVALID_HANDLE_VALUE;
    bool bFirst = true;
    DWORD dwIndex, dwTimeout;
    CSafeStr szSearch(2*MAX_PATH);
    CHAR *szPos;

    hEndThreadEvent = _Module.EndThreadEvent();

    while(!(g_dwDisableThreads & EVENT_THREAD))
    {
        CFileSearch wfd;
        if(!bFirst)
        {
            if(!g_dwFeedCopyFrequency)
                dwTimeout = 20 * 60 * 1000;
            else
                dwTimeout = g_dwFeedCopyFrequency * 60 * 1000;
            dwIndex = WaitForSingleObject(hEndThreadEvent, dwTimeout);
            if(WAIT_OBJECT_0 == dwIndex)
                break;
        }

        bFirst = false;

        // Every time I get here, check the drop dir for new feeds and copy them over to the local inbound directory
        CombinePathFile(szSearch, g_szEventLocalPath, "*.*");
        if(!wfd.Start(szSearch))
        {
            if(ERROR_FILE_NOT_FOUND != wfd.GetLastError())
            {
               LogEvent(EVENTLOG_ERROR_TYPE, EVENT_GENE_SEARCH_FAILED, "EventThread: Failed to search for the following: \"%s\".\nThe error that occurred is: %d", (const CHAR *) szSearch, wfd.GetLastError());
            }
            continue;
        }

        CDBInsertFailure dbif;

        while(wfd.GetNext())
        {
            // We get the file name to check it in our destination directory
            if(wfd->dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY ||
                wfd->dwFileAttributes & FILE_ATTRIBUTE_OFFLINE)
                continue;
            szPos = (CHAR *)strrchr(wfd->cFileName, '.');
            if(!szPos || (_stricmp(szPos, ".txt") && _stricmp(szPos, ".csv") && _stricmp(szPos, ".log")))
                continue;
            
            CombinePathFile(szSearch, g_szEventLocalPath, wfd->cFileName);
            ClearRO(szSearch);
            
            if(!wfd->nFileSizeHigh && !wfd->nFileSizeLow)
            {
                DeleteFile(szSearch);
                continue;
            }
            
            dwIndex = ProcessEventFile(dbif, szSearch, szPos + 1);
            if((DWORD) -1 == dwIndex)
                break;
        } // all txt files in the source directory
    }

    _Module.ThreadCompleting();
    return 0;
}

DWORD ProcessEventFile(CDBInsertFailure& dbif, const CHAR *szFileName, const CHAR *szType)
{
    CSafeStr szBuf(10240);
    CSafeStr szSerial(21);
    const CHAR *szTok;
    DWORD dwRetVal = (DWORD) -1;
    FILE *fEvents = fopen(szFileName, "r");
    SYSTEMTIME st;
    SYSTEMTIME lbound = {2002, 8, 0, 15, 12, 0, 0, 0};
    DWORDLONG ft, ftLBound;
    DWORD dwGood = 0;
    if(!fEvents)
        return 0;

    SystemTimeToFileTime(&lbound, (LPFILETIME) &ftLBound);
    LogEvent(EVENTLOG_INFORMATION_TYPE, EVENT_GENE_BEGIN_FILE_PROCESSING, "Starting processing on log file \"%s\".", szFileName);
    if(!_stricmp(szType, "txt"))
    {
        while(szBuf.LineFromFile(fEvents))
        {
            szTok = szBuf.FirstToken(","); // First token is event number
            if(!szTok)
                continue;
            szTok = szBuf.NextToken(",");     // Second token is event id
            if(!szTok)
                continue;
            if(strcmp(szTok, "50309"))
                continue;
            szTok = szBuf.NextToken(",");     // date and time is the next token
            if(!szTok)
                continue;
            memset(&st, 0, sizeof(SYSTEMTIME));
            szTok += WSCount(szTok);
            st.wMonth = (WORD) atoi(szTok);
            szTok += DigitCount(szTok) + 1;
            st.wDay = (WORD) atoi(szTok);
            szTok += DigitCount(szTok) + 1;
            st.wYear = (WORD) atoi(szTok);
            szTok += DigitCount(szTok);
            szTok += WSCount(szTok);
            st.wHour = (WORD) atoi(szTok);
            szTok += DigitCount(szTok) + 1;
            st.wMinute = (WORD) atoi(szTok);
            szTok += DigitCount(szTok) + 1;
            st.wSecond = (WORD) atoi(szTok);
            szTok += DigitCount(szTok);
            szTok += WSCount(szTok);
            if('P' == *szTok  || 'p' == *szTok)
                st.wHour = (st.wHour % 12) + 12;
            else if(12 == st.wHour)
                st.wHour = 0;

            if(!SystemTimeToFileTime(&st, (LPFILETIME) &ft))        // Make sure we have a valid date
                continue;
            
            if(ft < ftLBound)                               // Make sure the event is after genealogy database was loaded.
                continue;
            
            szTok = szBuf.NextToken(",");
            if(!szTok)
                continue;
            szTok += WSCount(szTok);
            if(_strnicmp(szTok, "xmacs", 5))                // Skip non-xmacs errors.
                continue;
            
            szTok = szBuf.NextToken(",");             // Machine
            if(!szTok)
                continue;
            szTok = szBuf.NextToken(",");             // Type (warning)
            if(!szTok)
                continue;

            szTok = szBuf.NextToken("");              // Message
            if(!szTok)
                continue;
            szTok = strstr(szTok, "SN-");
            if(!szTok)
                continue;
            szTok += 3;
            if(DigitCount(szTok) != 12)
                continue;
            szSerial.CopyN(szTok, 12);

            ++dwGood;
            LocalTimeToUTC(st, st);
            if((DWORD) -1 == dbif.InsertFailure(szSerial, st))
                goto Cleanup;
        }
    }
    else if(!_stricmp(szType, "csv"))
    {
        while(szBuf.LineFromFile(fEvents))
        {
            szTok = szBuf.FirstToken(","); // First token is the date of the event
            if(!szTok)
                continue;
            memset(&st, 0, sizeof(SYSTEMTIME));
            szTok += WSCount(szTok);
            st.wMonth = (WORD) atoi(szTok);
            szTok += DigitCount(szTok) + 1;
            st.wDay = (WORD) atoi(szTok);
            szTok += DigitCount(szTok) + 1;
            st.wYear = (WORD) atoi(szTok);

            szTok = szBuf.NextToken(",");     // Get the time of the event
            if(!szTok)
                continue;
            szTok += WSCount(szTok);
            st.wHour = (WORD) atoi(szTok);
            szTok += DigitCount(szTok) + 1;
            st.wMinute = (WORD) atoi(szTok);
            szTok += DigitCount(szTok) + 1;
            st.wSecond = (WORD) atoi(szTok);
            szTok += DigitCount(szTok);
            szTok += WSCount(szTok);
            if('P' == *szTok  || 'p' == *szTok)
                st.wHour = (st.wHour % 12) + 12;
            else if(12 == st.wHour)
                st.wHour = 0;
                
            if(!SystemTimeToFileTime(&st, (LPFILETIME) &ft))
                continue;
            
            if(ft < ftLBound)                               // Make sure the event is after genealogy database was loaded.
                continue;

            szTok = szBuf.NextToken(",");
            if(!szTok)
                continue;
            szTok += WSCount(szTok);
            if(!szTok)
                continue;
            if(_strnicmp(szTok, "xmacs", 5))                // Skip non-xmacs errors.
                continue;
            
            szTok = szBuf.NextToken(",");             // Type (warning)
            if(!szTok)
                continue;
            szTok = szBuf.NextToken(",");             // None (???)
            if(!szTok)
                continue;

            szTok = szBuf.NextToken(",");             // Event id
            if(!szTok)
                continue;
            if(strcmp(szTok, "50309"))
                continue;

            szTok = szBuf.NextToken(",");             // N/A (???)
            if(!szTok)
                continue;
            szTok = szBuf.NextToken(",");             // Machine name
            if(!szTok)
                continue;

            szTok = szBuf.NextToken("");              // Message
            if(!szTok)
                continue;
            szTok = strstr(szTok, "SN-");
            if(!szTok)
                continue;
            szTok += 3;
            if(DigitCount(szTok) != 12)
                continue;
            szSerial.CopyN(szTok, 12);

            ++dwGood;
            LocalTimeToUTC(st, st);
            if((DWORD) -1 == dbif.InsertFailure(szSerial, st))
                goto Cleanup;
        }
    }
    else if(!_stricmp(szType, "log"))
    {
        while(szBuf.LineFromFile(fEvents))
        {
            szTok = szBuf.FirstToken("|");
            if(!szTok)
                continue;

            szTok += WSCount(szTok);
            memset(&st, 0, sizeof(SYSTEMTIME));
            st.wYear = (WORD) atoi(szTok);
            szTok += DigitCount(szTok) + 1;
            st.wMonth = (WORD) atoi(szTok);
            szTok += DigitCount(szTok) + 1;
            st.wDay = (WORD) atoi(szTok);
            szTok += DigitCount(szTok);
            szTok += WSCount(szTok);
            st.wHour = (WORD) atoi(szTok);
            szTok += DigitCount(szTok) + 1;
            st.wMinute = (WORD) atoi(szTok);
            szTok += DigitCount(szTok) + 1;
            st.wSecond = (WORD) atoi(szTok);

            if(!SystemTimeToFileTime(&st, (LPFILETIME) &ft))
                continue;
            
            if(ft < ftLBound)                                   // Make sure the event is after genealogy database was loaded.
                continue;

            szTok = szBuf.NextToken("|");
            if(!szTok)
                continue;
            szTok += WSCount(szTok);
            if(!_strnicmp(szTok, "XMACS:(RetrievePrincipal)", 25))
            {
                szTok += 25;
                szTok = strstr(szTok, "SN-");
                if(!szTok)
                    continue;
                szTok += 3;
                if(12 != DigitCount(szTok))
                    continue;

                szSerial.CopyN(szTok, 12);

                ++dwGood;
                LocalTimeToUTC(st, st);
                if((DWORD) -1 == dbif.InsertFailure(szSerial, st))
                    goto Cleanup;
                continue;
            }
            else if(12 == DigitCount(szTok))
            {
                szSerial.CopyN(szTok, 12);
                szTok = szBuf.NextToken("|");
                szTok += WSCount(szTok);
                if(_strnicmp(szTok, "acc", 3))
                    continue;
                szTok = szBuf.NextToken("|");
                szTok += WSCount(szTok);
                if('1' != szTok[0] || '8' != szTok[1] || (szTok[2] >= '0' && szTok[2] <= '9'))
                    continue;

                ++dwGood;
                if((DWORD) -1 == dbif.InsertFailure(szSerial, st))
                    goto Cleanup;
                continue;
            }            
            else
            {
                continue;
            }
        }
    }

    LogEvent(EVENTLOG_INFORMATION_TYPE, EVENT_GENE_FINISHED_FILE_PROCESSING, "Finished processing on log file \"%s\".\n%d relevant events found.", szFileName, dwGood);
    dwRetVal = 0;

Cleanup:
    fclose(fEvents);
    if(!dwRetVal)
        DeleteFile(szFileName);
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\genealogy\geneadmin\service\feedthread.cpp ===
#include "stdafx.h"
#include "base64.h"
#include "DBConn.h"

enum UNICODE_TYPE
{
    UT_NONE,
    UT_LEND,
    UT_BEND
};

class CDBCollection
{
public:
    CDBQuerySourceFile qsf;
    CDBInsertSourceFile isf;
    CDBInsertParsedRow ipr;
    CDBInsertFailedRow ifr;
};

UNICODE_TYPE UnicodeType(CMappedFile& mapFile);

void ProcessFile(CDBCollection& DB, HANDLE hEndThreadEvent, const CHAR *szFullFileName, const CHAR *szFileName, DWORDLONG& dwlFileSize);
DWORD ImportFile(HANDLE hEndThreadEvent, CDBCollection &DB, CMappedFile& mapFile, const DWORDLONG& dwlInitOffset, DWORD dwFileID, UNICODE_TYPE ut);

unsigned __stdcall fnFeedWorkerThread(void *)
{
    HANDLE hEndThreadEvent = NULL;
    DWORD dwIndex;
    bool bFirstRun = true;
    DWORD dwTimeout = INFINITE;
    CSafeStr szSource(2 * MAX_PATH);
    DWORDLONG dwlSource;

    // Hook up to the end service event
    hEndThreadEvent = _Module.EndThreadEvent();

    if(!(g_dwDisableThreads & FEED_THREADS))
    {
        WaitForSingleObject(g_hInitialCopyDone, INFINITE);
    }
    
    while(!(g_dwDisableThreads & FEED_THREADS))
    {
        CFileSearch wfd;
        // Import immediately for a first run if possible
        if(!bFirstRun)
        {
            if(g_dwFeedCopyFrequency)
                dwTimeout = g_dwFeedCopyFrequency * 60 * 1000;
            else
                dwTimeout = 20 * 60 * 1000;
            dwIndex = WaitForSingleObject(hEndThreadEvent, dwTimeout);
            if(WAIT_OBJECT_0 == dwIndex)
                break;
        }
        
        bFirstRun = false;

        // Get the path for all drops
        CombinePathFile(szSource, g_szFeedLocalPath, "*.txt");
        if(!wfd.Start(szSource))
        {
            if(ERROR_FILE_NOT_FOUND != wfd.GetLastError())
            {
                LogEvent(EVENTLOG_ERROR_TYPE, EVENT_GENE_SEARCH_FAILED, "FeedThread: Failed to search for the following: \"%s\".\nThe error that occurred is: %d", (const CHAR *) szSource, wfd.GetLastError());
            }
            continue;
        }

        CDBCollection DB;

        while(wfd.GetNext())
        {
            if(WAIT_OBJECT_0 == WaitForSingleObject(hEndThreadEvent, 0))
                break;

            // We get the file name to check it in our destination directory
            if(wfd->dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY ||
                wfd->dwFileAttributes & FILE_ATTRIBUTE_OFFLINE)
                continue;

            CombinePathFile(szSource, g_szFeedLocalPath, wfd->cFileName);
            ClearRO(szSource);
            
            dwlSource = wfd->nFileSizeHigh;
            dwlSource <<= 32;
            dwlSource += wfd->nFileSizeLow;
            if(!dwlSource)
            {
                DeleteFile(szSource);
                continue;
            }
            
            // Process the file
            ProcessFile(DB, hEndThreadEvent, szSource, wfd->cFileName, dwlSource);
        }
    }

    _Module.ThreadCompleting();
    return 0;
}

void MoveProcessedFile(const CHAR *szFullFileName, const CHAR *szFileName, const DWORDLONG& dwlSize)
{
    CSafeStr szProcessedLocation(1024);
    DWORDLONG dwlDestSize;

    if(!g_szFeedProcessedPath.Length())
    {
        LogEvent(EVENTLOG_ERROR_TYPE, EVENT_GENE_INVALID_PATH, "The path to move processed files to is empty.");
        return;
    }

    CombinePathFile(szProcessedLocation, g_szFeedProcessedPath, szFileName);
    dwlDestSize = FileSize(szProcessedLocation);
    if(dwlDestSize >= dwlSize)  // If the destination file is the same or larger than the one that was processed
    {
        if(!DeleteFile(szFullFileName))
        {
            LogEvent(EVENTLOG_WARNING_TYPE, EVENT_GENE_FILEDELETE_FAILED, "Could not delete the file \"%s\".  Error code: %d", szFullFileName, GetLastError());
        }
        return;
    }
    else                        // If the destination file doesn't exist or is smaller.
    {
        if(!DeleteFile(szProcessedLocation))    // Somehow the destination is truncated, so we will copy over.
        {
            if(ERROR_FILE_NOT_FOUND != GetLastError())
            {
                LogEvent(EVENTLOG_WARNING_TYPE, EVENT_GENE_FILEDELETE_FAILED, "Could not delete the file \"%s\".  Error code: %d", (const CHAR *) szProcessedLocation, GetLastError());
            }
        }
        if(!MoveFile(szFullFileName, szProcessedLocation))
        {
                LogEvent(EVENTLOG_WARNING_TYPE, EVENT_GENE_FILEMOVE_FAILED, "Could not move the file \"%s\" to \"%s\".  Error code: %d", szFullFileName, (const CHAR *) szProcessedLocation, GetLastError());
        }
        CompressFile(szProcessedLocation);
    }
}

void ProcessFile(CDBCollection& DB, HANDLE hEndThreadEvent, const CHAR *szFullFileName, const CHAR *szFileName, DWORDLONG& dwlFileSize)
{
    DWORD dwFileID;
    CMappedFile mapFile;
    UNICODE_TYPE ut;
    DWORDLONG dwlInitOffset = 0;

    dwFileID = DB.qsf.GetSourceFileInfo(szFileName, dwlInitOffset);

    if((DWORD) -1 == dwFileID)
        goto Cleanup;

    if(dwlInitOffset == dwlFileSize)
    {
        MoveProcessedFile(szFullFileName, szFileName, dwlFileSize);
        goto Cleanup;
    }

    if(0 == dwFileID)            // File has never been imported
    {
        bool fUnicode;
        if(!mapFile.MapFile(szFullFileName, true))
            goto Error;

        ut = UnicodeType(mapFile);
        dwlInitOffset = 0;
        fUnicode = ut != UT_NONE;
        dwFileID = DB.isf.InsertSourceFile(szFileName, fUnicode);
        if((DWORD) -1 == dwFileID || !dwFileID)
            goto Error;
    }
    else
    {
        if(!mapFile.MapFile(szFullFileName, true))
            goto Error;

        ut = UnicodeType(mapFile);
    }    

    LogEvent(EVENTLOG_INFORMATION_TYPE, EVENT_GENE_BEGIN_FILE_PROCESSING, "Starting processing feed file \"%s\" from %I64d.", szFullFileName, dwlInitOffset);
    if(!ImportFile(hEndThreadEvent, DB, mapFile, dwlInitOffset, dwFileID, ut))
        goto Error;
    mapFile.Close();

    MoveProcessedFile(szFullFileName, szFileName, dwlFileSize);

Cleanup:
    return;

Error:
    goto Cleanup;
}

BOOL ParseLine(CMappedFile& mapFile, UNICODE_TYPE ut, DWORDLONG& dwlOffset, CSafeStr& szRow);
int ValidateLine(CDBCollection& DB, const CHAR *szRow);

static CHAR *szErrorDesc[] = 
    {
        "End of line encountered too early",
        "Failed to parse the serial number",
        "Failed to parse the part number",
        "Failed to parse or base64 decode the online key",
        "Failed to parse the online key version",
        "Failed to parse the MAC address",
        "Failed to parse the game region",
        "Failed to parse the TV region",
        "Failed to parse the IsActive field",
        "Row parsed out as a title row"
    };

DWORD ImportFile(HANDLE hEndThreadEvent, CDBCollection& DB, CMappedFile& mapFile, const DWORDLONG& dwlInitOffset, DWORD dwFileID, UNICODE_TYPE ut)
{
    DWORD dwRetVal = 0;
    int iResult;
    CSafeStr szLine(512);
    DWORDLONG dwlOffset = dwlInitOffset;
    DWORD dwGoodRows = 0, dwBadRows = 0;
    while(dwlOffset < mapFile.GetFileSize() && ParseLine(mapFile, ut, dwlOffset, szLine))
    {
        if(WAIT_OBJECT_0 == WaitForSingleObject(hEndThreadEvent, 0))
            goto Cleanup;

        iResult = ValidateLine(DB, szLine);
        if(iResult < 0)
        {
            ++dwGoodRows;
            if(DB.ipr.InsertRow(dwFileID, dwlOffset) == -1)
                goto Cleanup;
        }
        else
        {
            ++dwBadRows;
            if(DB.ifr.InsertRow(dwFileID, szErrorDesc[iResult], szLine, dwlOffset) == -1)
                goto Cleanup;
        }
    }
    LogEvent(EVENTLOG_INFORMATION_TYPE, EVENT_GENE_FINISHED_FILE_PROCESSING, "Finished processing feed file.\nRows successfully parsed: %d\nRows failing parse: %d", dwGoodRows, dwBadRows);

    dwRetVal = 1;
Cleanup:
    return dwRetVal;
}

BOOL ParseLine(CMappedFile& mapFile, UNICODE_TYPE ut, DWORDLONG& dwlOffset, CSafeStr& szRow)
{
    DWORD dwPos = 0;
    CHAR *szFinalOffset;
    // Make sure we are mapped into the region where we want to start from.
    // The 512 makes sure that we don't have to do alot of work in terms of handling boundaries of mapped regions
    while((dwlOffset < mapFile.GetMapOffset() || dwlOffset > mapFile.GetMapOffset() + mapFile.GetMappedSize() - 512) && 
                                    (mapFile.GetMapOffset() + mapFile.GetMappedSize() < mapFile.GetFileSize()))
    {
        if(!mapFile.MapNextFileChunkFrom(dwlOffset))
            return FALSE;
    }
    if(!dwlOffset && ut != UT_NONE)
        dwlOffset = 2;  // Skip unicode leader bytes

    szRow = "";
    switch(ut)
    {
    case UT_NONE:       // Not unicode, pretty much a straight copy
        {
            CHAR *szData = (CHAR *) mapFile.GetAddr() + ((DWORD) (dwlOffset - mapFile.GetMapOffset()));
            CHAR *szLast = ((CHAR *) mapFile.GetAddr()) + mapFile.GetMappedSize();

            while(dwPos < szRow.Size() && szData < szLast)
            {
                if('\r' == *szData || '\n' == *szData)
                    break;
                szRow += *szData;
                ++dwPos;
                ++szData;
            }
            while(szData < szLast && ('\r' == *szData || '\n' == *szData))
                ++szData;

            szFinalOffset = szData;
            break;
        }
    case UT_LEND:       // Little endian unicode copy (we expect ansi in unicode)
        {
            WCHAR *szData = (WCHAR *) (((CHAR *) mapFile.GetAddr()) + ((DWORD) (dwlOffset - mapFile.GetMapOffset())));
            WCHAR *szLast = (WCHAR *) (((CHAR *) mapFile.GetAddr()) + mapFile.GetMappedSize());
            while(dwPos < szRow.Size() && szData < szLast)
            {
                if('\r' == *szData || '\n' == *szData)
                    break;
                szRow += (CHAR) *szData;
                ++dwPos;
                ++szData;
            }
            while(szData < szLast && ('\r' == *szData || '\n' == *szData))
                ++szData;

            szFinalOffset = (CHAR *) szData;
            break;
        }
    case UT_BEND:       // Big endian unicode copy (we expect ansi in unicode)
        {
            WCHAR *szData = (WCHAR *) (((CHAR *) mapFile.GetAddr()) + ((DWORD) (dwlOffset - mapFile.GetMapOffset())));
            WCHAR *szLast = (WCHAR *) (((CHAR *) mapFile.GetAddr()) + mapFile.GetMappedSize());
            while(dwPos < szRow.Size() && szData < szLast)
            {
                if('\r' == (*szData >> 8) || '\n' == (*szData >> 8))
                    break;
                szRow += (CHAR) (*szData >> 8);
                ++dwPos;
                ++szData;
            }
            while(szData < szLast && ('\r' == (*szData >> 8) || '\n' == (*szData >> 8)))
                ++szData;

            szFinalOffset = (CHAR *) szData;
            break;
        }
    default:
        return FALSE;
    };
    dwlOffset = mapFile.GetMapOffset() + (szFinalOffset - (CHAR *) mapFile.GetAddr());
    return TRUE;
}

typedef DWORD (*fnSeqValidator)(const CHAR *sz);
    
template <DWORD size> BOOL CopyValidatedSeq(TSafeStr<size> & dst, const CHAR * &src,  fnSeqValidator fnSeq, DWORD len)
{
    DWORD dwCount;
    src += WSCount(src);
    dwCount = fnSeq(src);
    if(dwCount < len)
        return FALSE;

    dst.CopyN(src, len);
    src += len;
    return TRUE;
}

int ValidateLine(CDBCollection& DB, const CHAR *szRow)
{
    const CHAR *szPos = szRow;
	const CHAR *szUnk = "UNKNOWN";
	DWORD dwPos;
    DWORD dwCount;
    BYTE szHolder[130];
    DWORD dwSize = 130;

    dwCount = strlen(szRow);
    if(dwCount == TextCount(szRow))
        return 9;

    if(dwCount < 226)
        return 0;

    // Serial number
    if(!CopyValidatedSeq(DB.ipr.m_szSerial, szPos, DigitCount, 12))
        return 1;

    // Part number
    if(!CopyValidatedSeq(DB.ipr.m_szPartNo, szPos, PartNoCount, 9))
        return 2;
    
    // Online Key
    if(!CopyValidatedSeq(DB.ipr.m_szKey, szPos, Base64Count, 172))
        return 3;

    // Make sure the online key is base 64 decodable.
    if(!Base64Decode(DB.ipr.m_szKey, 172, szHolder, &dwSize))
        return 3;
    // Check to make sure the online key isn't just UNKNOWN...UNKNOWNUNK=
    for(dwPos = 0; dwPos < 171; ++dwPos)
        if(DB.ipr.m_szKey[dwPos] != szUnk[dwPos % 7])
            break;
    if(171 == dwPos)
        return 3;
    
    // Online Key Version
    if(!CopyValidatedSeq(DB.ipr.m_szKeyVer, szPos, DigitCount, 4))
        return 4;

    // MAC Address
    if(!CopyValidatedSeq(DB.ipr.m_szMACAddr, szPos, HexCount, 12))
        return 5;

    // Game Region
    if(!CopyValidatedSeq(DB.ipr.m_szGameReg, szPos, DigitCount, 8))
        return 6;

    // TV Region
    if(!CopyValidatedSeq(DB.ipr.m_szTVReg, szPos, DigitCount, 8))
        return 7;

    // IsActive
    szPos += WSCount(szPos);
    if('1' == *szPos || 't' == *szPos || 'T' == *szPos)
        DB.ipr.m_szIsActive = "1";
    else if('0' == *szPos || 'f' == *szPos || 'F' == *szPos)
        DB.ipr.m_szIsActive = "0";
    else
        return 8;

    return -1;
}

UNICODE_TYPE UnicodeType(CMappedFile& mapFile)
{
    DWORDLONG dwlOffset;
    UNICODE_TYPE cUnicode = UT_NONE;
    unsigned short *u;

    if(!mapFile.GetAddr())
    {
        return UT_NONE;
    }

    dwlOffset = mapFile.GetMapOffset();
    if(dwlOffset)
    {
        mapFile.MapNextFileChunkFrom(0);
    }

    u = (unsigned short *) mapFile.GetAddr();
    if(!u)
        return UT_NONE;     // We failed to get the file, so it really doesn't matter what we return.

    if((unsigned short) 0xFFFE == *u)
    {
        cUnicode = UT_BEND;
    }
    else if((unsigned short) 0xFEFF == *u)
    {
        cUnicode = UT_LEND;
    }
    
    if(dwlOffset)
    {
        mapFile.MapNextFileChunkFrom(dwlOffset);
    }

    return cUnicode;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\genealogy\geneadmin\service\feedthread.h ===
#pragma once

unsigned __stdcall fnFeedWorkerThread(void *);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\genealogy\geneadmin\service\DBConn.cpp ===
#include "stdafx.h"
#include "critsect.h"
#include "dbconn.h"

/******************************************************************************
    CDBGetSNByBugID Class
 ******************************************************************************/
static CHAR szGetSNByBugID[] = "{call p_SVCGetSNByBugID(?)}";

#define DOINITIALIZATION
#include "DBControl.h"

CDBGetSNByBugID::CDBGetSNByBugID()
{
    DEFGETSNBYBUGID(0, 0);
}

#define DOBINDINGS
#include "DBControl.h"

DWORD CDBGetSNByBugID::GetSNByBugID(DWORD dwBugID, TSafeStr<21> szSerial)
{
    BOOL fLast = FALSE;
    DWORD dwCount = 0;
    
    if(!Connected() && !Connect(g_szFeedMachine, g_szFeedDatabase, szGetSNByBugID, g_szFeedUID, g_szFeedPWD))
        return (DWORD) -1;

    if(!m_fBound)
    {
        DEFGETSNBYBUGID(m_hStmt, Cleanup);
    }
    m_fBound = TRUE;

    m_dwBugID = dwBugID;
    if(!DBStmtExecute(m_hStmt))
    {
        m_fBound = FALSE;
        goto Cleanup;
    }

    while(DBStmtFetch(m_hStmt, fLast))
    {
        if(!dwCount)
        {
            szSerial = m_szSerial;
        }
        ++dwCount;
    }

    return dwCount;

Cleanup:
    if(!m_fBound)
    {
        Disconnect();
    }
    return (DWORD) -1;
}


/******************************************************************************
    CDBGetNewKeyCount Class
 ******************************************************************************/
static CHAR szGetNewKeyCount[] = "{call p_SVCGetNewKeyCount(?, ?)}";

#define DOINITIALIZATION
#include "DBControl.h"

CDBGetNewKeyCount::CDBGetNewKeyCount()
{
    DEFGETNEWKEYCOUNT(0, 0);
}

#define DOBINDINGS
#include "DBControl.h"

DWORD CDBGetNewKeyCount::GetNewKeyCount(const CHAR *szSerial, const DBTIMESTAMP& dt)
{
    BOOL fLast = FALSE;
    if(!Connected() && !Connect(g_szFeedMachine, g_szFeedDatabase, szGetNewKeyCount, g_szFeedUID, g_szFeedPWD))
        return (DWORD) -1;

    if(!m_fBound)
    {
        DEFGETNEWKEYCOUNT(m_hStmt, Cleanup);
    }
    m_fBound = TRUE;

    m_dwCount = 0;
    m_szSerial = szSerial;
    m_dwSerialLen = m_szSerial.Length();
    memcpy(&m_dtLastFailed, &dt, sizeof(DBTIMESTAMP));
    if(!DBStmtExecute(m_hStmt))
    {
        m_fBound = FALSE;
        goto Cleanup;
    }

    while(DBStmtFetch(m_hStmt, fLast))
        ;

    return m_dwCount;

Cleanup:
    if(!m_fBound)
    {
        Disconnect();
    }
    return (DWORD) -1;
}



/******************************************************************************
    CDBSetLastProdUpdateDate Class
 ******************************************************************************/
static CHAR szSetLastProdUpdateDate[] = "{call p_SVCSetLastProdUpdateDate(?, ?)}";

#define DOINITIALIZATION
#include "DBControl.h"

CDBSetLastProdUpdateDate::CDBSetLastProdUpdateDate()
{
    DEFSETLASTPRODUPDATEDATE(0, 0);
}

#define DOBINDINGS
#include "DBControl.h"

DWORD CDBSetLastProdUpdateDate::SetLastProdUpdateDate(const CHAR *szSerial, const DBTIMESTAMP& dt)
{
    if(!Connected() && !Connect(g_szFeedMachine, g_szFeedDatabase, szSetLastProdUpdateDate, g_szFeedUID, g_szFeedPWD))
        return (DWORD) -1;

    if(!m_fBound)
    {
        DEFSETLASTPRODUPDATEDATE(m_hStmt, Cleanup);
    }
    m_fBound = TRUE;

    m_szSerial = szSerial;
    m_dwSerialLen = m_szSerial.Length();
    memcpy(&m_dtLastUpdated, &dt, sizeof(DBTIMESTAMP));
    if(!DBStmtExecute(m_hStmt))
    {
        m_fBound = FALSE;
        goto Cleanup;
    }

    while(DBStmtMoreResults(m_hStmt))
        ;

    return 0;

Cleanup:
    if(!m_fBound)
    {
        Disconnect();
    }
    return (DWORD) -1;
}


/******************************************************************************
    CDBGetFeedFailed Class
 ******************************************************************************/
static CHAR szGetFeedFailed[] = "{call p_SVCGetFeedErrors(?)}";

#define DOINITIALIZATION
#include "DBControl.h"

CDBGetFeedFailed::CDBGetFeedFailed()
{
    DBGETFEEDFAILED(0, 0);
}

#define DOBINDINGS
#include "DBControl.h"

BOOL CDBGetFeedFailed::Start(CHAR *szSerial)
{
    if(!Connected() && !Connect(g_szFeedMachine, g_szFeedDatabase, szGetFeedFailed, g_szFeedUID, g_szFeedPWD))
        return FALSE;

    if(!m_fBound)
    {
        DBGETFEEDFAILED(m_hStmt, Cleanup);
    }
    m_fBound = TRUE;

    m_szSerial = szSerial;
    m_dwSerialLen = m_szSerial.Length();
    if(!DBStmtExecute(m_hStmt))
        m_fBound = FALSE;

Cleanup:
    if(!m_fBound)
    {
        Disconnect();
        return FALSE;
    }
    return TRUE;
}

BOOL CDBGetFeedFailed::GetNext()
{
    BOOL fLast;
    return DBStmtFetch(m_hStmt, fLast);
}

/******************************************************************************
    CDBGetProdErrors Class
 ******************************************************************************/
static CHAR szGetProdErrors[] = "{call p_SVCGetProdErrors(?)}";

#define DOINITIALIZATION
#include "DBControl.h"

CDBGetProdErrors::CDBGetProdErrors()
{
    DBGETPRODERRORS(0, 0);
}

#define DOBINDINGS
#include "DBControl.h"

BOOL CDBGetProdErrors::Start(CHAR *szSerial)
{
    if(!Connected() && !Connect(g_szFeedMachine, g_szFeedDatabase, szGetProdErrors, g_szFeedUID, g_szFeedPWD))
        return FALSE;

    if(!m_fBound)
    {
        DBGETPRODERRORS(m_hStmt, Cleanup);
    }
    m_fBound = TRUE;

    m_szSerial = szSerial;
    m_dwSerialLen = m_szSerial.Length();
    if(!DBStmtExecute(m_hStmt))
        m_fBound = FALSE;

Cleanup:
    if(!m_fBound)
    {
        Disconnect();
        return FALSE;
    }
    return TRUE;
}

BOOL CDBGetProdErrors::GetNext()
{
    BOOL fLast;
    return DBStmtFetch(m_hStmt, fLast);
}


/******************************************************************************
    CDBGetProdRows Class
 ******************************************************************************/
static CHAR szGetProdFeedRows[] = "{call p_SVCGetProdRows(?)}";

#define DOINITIALIZATION
#include "DBControl.h"

CDBGetProdRows::CDBGetProdRows()
{
    DBGETPRODROWS(0, 0);
}

#define DOBINDINGS
#include "DBControl.h"

BOOL CDBGetProdRows::Start(CHAR *szSerial)
{
    if(!Connected() && !Connect(g_szFeedMachine, g_szFeedDatabase, szGetProdFeedRows, g_szFeedUID, g_szFeedPWD))
        return FALSE;

    if(!m_fBound)
    {
        DBGETPRODROWS(m_hStmt, Cleanup);
    }
    m_fBound = TRUE;

    m_szSerial = szSerial;
    m_dwSerialLen = m_szSerial.Length();
    if(!DBStmtExecute(m_hStmt))
        m_fBound = FALSE;

Cleanup:
    if(!m_fBound)
    {
        Disconnect();
        return FALSE;
    }
    return TRUE;
}

BOOL CDBGetProdRows::GetNext()
{
    BOOL fLast;
    return DBStmtFetch(m_hStmt, fLast);
}


/******************************************************************************
    CDBInsertProdErrorRow Class
 ******************************************************************************/
static CHAR szInsertProdErrorRow[] = "{call p_SVCInsertProdError(?, ?, ?, ?, ?, ?)}";

#define DOINITIALIZATION
#include "DBControl.h"


CDBInsertProdErrorRow::CDBInsertProdErrorRow()
{
    DEFINSERTPRODERRORROW(0, 0);
}

#define DOBINDINGS
#include "DBControl.h"


DWORD CDBInsertProdErrorRow::InsertProdErrorRow(const CHAR *szSerial, const DBTIMESTAMP& dtFailed, const CHAR *szFileName, const CHAR *szDesc, const CHAR *szErrorRow, const DBTIMESTAMP& dtQuery)
{
    if(!Connected() && !Connect(g_szFeedMachine, g_szFeedDatabase, szInsertProdErrorRow, g_szFeedUID, g_szFeedPWD))
        return (DWORD) -1;

    if(!m_fBound)
    {
        DEFINSERTPRODERRORROW(m_hStmt, Cleanup);
    }
    m_fBound = TRUE;

    m_szSerial = szSerial;
    m_szFileName = szFileName;
    m_szRow = szErrorRow;
    m_szDesc = szDesc;
    m_dwSerialLen = m_szSerial.Length();
    m_dwFileNameLen = m_szFileName.Length();
    m_dwDescLen = m_szDesc.Length();
    m_dwRowLen = m_szRow.Length();
    memcpy(&m_dtFailed, &dtFailed, sizeof(DBTIMESTAMP));
    memcpy(&m_dtQuery, &dtQuery, sizeof(DBTIMESTAMP));
    if(!DBStmtExecute(m_hStmt))
    {
        m_fBound = FALSE;
        goto Cleanup;
    }

    while(DBStmtMoreResults(m_hStmt))
        ;

    return 0;

Cleanup:
    if(!m_fBound)
    {
        Disconnect();
    }
    return (DWORD) -1;
}

/******************************************************************************
    CDBInsertProdFeedRow Class
 ******************************************************************************/
static CHAR szInsertProdFeedRow[] = "{call p_SVCInsertProdRow(?, ?, ?, ?, ?, ?, ?)}";

#define DOINITIALIZATION
#include "DBControl.h"


CDBInsertProdFeedRow::CDBInsertProdFeedRow()
{
    DEFINSERTPRODFEEDROW(0, 0);
}

#define DOBINDINGS
#include "DBControl.h"


DWORD CDBInsertProdFeedRow::InsertProdFeedRow(const CHAR *szSerial, const CHAR *szPartNo, const CHAR *szKey, const DBTIMESTAMP& dtLast, DWORD dwSeqNo, const DBTIMESTAMP& dtSeq, const DBTIMESTAMP& dtQuery)
{
    if(!Connected() && !Connect(g_szFeedMachine, g_szFeedDatabase, szInsertProdFeedRow, g_szFeedUID, g_szFeedPWD))
        return (DWORD) -1;

    if(!m_fBound)
    {
        DEFINSERTPRODFEEDROW(m_hStmt, Cleanup);
    }
    m_fBound = TRUE;

    m_szSerial = szSerial;
    m_szPartNo = szPartNo;
    m_szKey = szKey;
    m_dwSerialLen = m_szSerial.Length();
    m_dwPartNoLen = m_szPartNo.Length();
    m_dwKeyLen = m_szKey.Length();
    m_dwSeqNo = dwSeqNo;
    memcpy(&m_dtLast, &dtLast, sizeof(DBTIMESTAMP));
    memcpy(&m_dtSeq, &dtSeq, sizeof(DBTIMESTAMP));
    memcpy(&m_dtQuery, &dtQuery, sizeof(DBTIMESTAMP));
    if(!DBStmtExecute(m_hStmt))
    {
        m_fBound = FALSE;
        goto Cleanup;
    }

    while(DBStmtMoreResults(m_hStmt))
        ;

    return 0;

Cleanup:
    if(!m_fBound)
    {
        Disconnect();
    }
    return (DWORD) -1;
}

/******************************************************************************
    CDBSetProdDate Class
 ******************************************************************************/
static CHAR szSetFailedProdDate[] = "{call p_SVCSetLastProdQueryDate(?, ?)}";

#define DOINITIALIZATION
#include "DBControl.h"


CDBSetProdDate::CDBSetProdDate()
{
    DEFSETFAILEDPRODDATE(0, 0);
}

#define DOBINDINGS
#include "DBControl.h"

DWORD CDBSetProdDate::SetProdDate(const CHAR *szSerial, const DBTIMESTAMP& dt)
{
    if(!Connected() && !Connect(g_szFeedMachine, g_szFeedDatabase, szSetFailedProdDate, g_szFeedUID, g_szFeedPWD))
        return (DWORD) -1;

    if(!m_fBound)
    {
        DEFSETFAILEDPRODDATE(m_hStmt, Cleanup);
    }
    m_fBound = TRUE;

    m_szSerial = szSerial;
    m_dwSerialLen = m_szSerial.Length();
    memcpy(&m_dtAccount, &dt, sizeof(DBTIMESTAMP));
    if(!DBStmtExecute(m_hStmt))
    {
        m_fBound = FALSE;
        goto Cleanup;
    }

    while(DBStmtMoreResults(m_hStmt))
        ;

    return 0;

Cleanup:
    if(!m_fBound)
    {
        Disconnect();
    }
    return (DWORD) -1;
}

/******************************************************************************
    CDBSetFailedUODBDate Class
 ******************************************************************************/
static CHAR szSetFailedUODBDate[] = "{call p_SVCSetMachineAccountDate(?, ?)}";

#define DOINITIALIZATION
#include "DBControl.h"


CDBSetFailedUODBDate::CDBSetFailedUODBDate()
{
    DEFSETFAILEDUODBDATE(0, 0);
}

#define DOBINDINGS
#include "DBControl.h"

DWORD CDBSetFailedUODBDate::SetUODBDate(const CHAR *szSerial, const DBTIMESTAMP& dt)
{
    if(!Connected() && !Connect(g_szFeedMachine, g_szFeedDatabase, szSetFailedUODBDate, g_szFeedUID, g_szFeedPWD))
        return (DWORD) -1;

    if(!m_fBound)
    {
        DEFSETFAILEDUODBDATE(m_hStmt, Cleanup);
    }
    m_fBound = TRUE;

    m_szSerial = szSerial;
    m_dwSerialLen = m_szSerial.Length();
    memcpy(&m_dtAccount, &dt, sizeof(DBTIMESTAMP));
    if(!DBStmtExecute(m_hStmt))
    {
        m_fBound = FALSE;
        goto Cleanup;
    }

    while(DBStmtMoreResults(m_hStmt))
        ;

    return 0;

Cleanup:
    if(!m_fBound)
    {
        Disconnect();
    }
    return (DWORD) -1;
}

/******************************************************************************
    CDBInsertFailedRow Class
 ******************************************************************************/
static CHAR szInsertFailedFeedRow[] = "{call p_SVCInsertFeedError(?, ?, ?, ?)}";

#define DOINITIALIZATION
#include "DBControl.h"

CDBInsertFailedRow::CDBInsertFailedRow()
{
    DEFINSERTFAILEDROW(0, 0);
}

#define DOBINDINGS
#include "DBControl.h"

DWORD CDBInsertFailedRow::InsertRow(DWORD dwFileID, const CHAR *szErrorDesc, const CHAR *szRowData, const DWORDLONG& dwlProcessed)
{
    if(!Connected() && !Connect(g_szFeedMachine, g_szFeedDatabase, szInsertFailedFeedRow, g_szFeedUID, g_szFeedPWD))
        return (DWORD) -1;

    if(!m_fBound)
    {
        DEFINSERTFAILEDROW(m_hStmt, Cleanup);
    }
    m_fBound = TRUE;

    m_dwFileID = dwFileID;
    m_szDesc = szErrorDesc;
    m_szRow = szRowData;
    m_dwDescLen = m_szDesc.Length();
    m_dwRowLen = m_szRow.Length();
    m_dwlProcessed = dwlProcessed;
    if(!DBStmtExecute(m_hStmt))
    {
        m_fBound = FALSE;
        goto Cleanup;
    }

    while(DBStmtMoreResults(m_hStmt))
        ;

    return 0;

Cleanup:
    if(!m_fBound)
    {
        Disconnect();
    }
    return (DWORD) -1;
}

/******************************************************************************
    CDBInsertParsedRow Class
 ******************************************************************************/
static CHAR szInsertParsedRow[] = "{call p_SVCInsertFeedRow(?, ?, ?, ?, ?, ?, ?, ?, ?, ?)}";

#define DOINITIALIZATION
#include "DBControl.h"

CDBInsertParsedRow::CDBInsertParsedRow()
{
    DEFINSERTPARSEDROW(0, 0);
}

#define DOBINDINGS
#include "DBControl.h"

DWORD CDBInsertParsedRow::InsertRow(DWORD dwFileID, const CHAR *szSerial, const CHAR *szPartNo, const CHAR *szKey,
                    const CHAR *szKeyVer, const CHAR *szMACAddr, const CHAR *szGameReg, const CHAR *szTVReg,
                    const CHAR *szIsActive, const DWORDLONG& dwlProcessed)
{
    if(!Connected() && !Connect(g_szFeedMachine, g_szFeedDatabase, szInsertParsedRow, g_szFeedUID, g_szFeedPWD))
        return (DWORD) -1;

    if(!m_fBound)
    {
        DEFINSERTPARSEDROW(m_hStmt, Cleanup);
    }
    m_fBound = TRUE;

    m_dwFileID = dwFileID;
    m_szSerial = szSerial;
    m_szPartNo = szPartNo;
    m_szKey = szKey;
    m_szKeyVer = szKeyVer;
    m_szMACAddr = szMACAddr;
    m_szGameReg = szGameReg;
    m_szTVReg = szTVReg;
    m_szIsActive = szIsActive;
    m_dwSerialLen = m_szSerial.Length();
    m_dwPartNoLen = m_szPartNo.Length();
    m_dwKeyLen = m_szKey.Length();
    m_dwKeyVerLen = m_szKeyVer.Length();
    m_dwMACLen = m_szMACAddr.Length();
    m_dwGameRegLen = m_szGameReg.Length();
    m_dwTVRegLen = m_szTVReg.Length();
    m_dwIsActiveLen = m_szIsActive.Length();
    m_dwlProcessed = dwlProcessed;
    if(!DBStmtExecute(m_hStmt))
    {
        m_fBound = FALSE;
        goto Cleanup;
    }

    while(DBStmtMoreResults(m_hStmt))
        ;

    return 0;

Cleanup:
    if(!m_fBound)
    {
        Disconnect();
    }
    return (DWORD) -1;
}

DWORD CDBInsertParsedRow::InsertRow(DWORD dwFileID, const DWORDLONG& dwlProcessed)
{
    if(!Connected() && !Connect(g_szFeedMachine, g_szFeedDatabase, szInsertParsedRow, g_szFeedUID, g_szFeedPWD))
        return (DWORD) -1;
    m_dwlProcessed = m_dwFileID = 0;
    if(!m_fBound)
    {
        DEFINSERTPARSEDROW(m_hStmt, Cleanup);
    }
    m_fBound = TRUE;

    m_dwFileID = dwFileID;
    m_dwSerialLen = m_szSerial.Length();
    m_dwPartNoLen = m_szPartNo.Length();
    m_dwKeyLen = m_szKey.Length();
    m_dwKeyVerLen = m_szKeyVer.Length();
    m_dwMACLen = m_szMACAddr.Length();
    m_dwGameRegLen = m_szGameReg.Length();
    m_dwTVRegLen = m_szTVReg.Length();
    m_dwIsActiveLen = m_szIsActive.Length();
    m_dwlProcessed = dwlProcessed;
    if(!DBStmtExecute(m_hStmt))
    {
        m_fBound = FALSE;
        goto Cleanup;
    }

    while(DBStmtMoreResults(m_hStmt))
        ;

    return 0;

Cleanup:
    if(!m_fBound)
    {
        Disconnect();
    }
    return (DWORD) -1;
}

/******************************************************************************
    CDBUpdateFailure Class
 ******************************************************************************/
static CHAR szUpdateFailRow[] = "{call p_SVCUpdateGeneFailure(?, ?, ?)}";

#define DOINITIALIZATION
#include "DBControl.h"

CDBUpdateFailure::CDBUpdateFailure()
{
    DEFUPDATEFAILURE(0, 0);
}

#define DOBINDINGS
#include "DBControl.h"

DWORD CDBUpdateFailure::UpdateFailure(const CHAR *szSerial, DWORD dwBugID, DWORD dwState)
{
    if(!Connected() && !Connect(g_szFeedMachine, g_szFeedDatabase, szUpdateFailRow, g_szFeedUID, g_szFeedPWD))
        return (DWORD) -1;

    if(!m_fBound)
    {
        DEFUPDATEFAILURE(m_hStmt, Cleanup);
    }
    m_fBound = TRUE;

    m_szSerial = szSerial;
    m_dwSerialLen = m_szSerial.Length();
    m_dwBugID = dwBugID;
    m_dwState = dwState;
    if(!DBStmtExecute(m_hStmt))
    {
        m_fBound = FALSE;
        goto Cleanup;
    }

    while(DBStmtMoreResults(m_hStmt))
        ;

    return 0;

Cleanup:
    if(!m_fBound)
    {
        Disconnect();
    }
    return (DWORD) -1;
}


/******************************************************************************
    CDBInsertFailure Class
 ******************************************************************************/
static CHAR szInsertFailureQuery[] = "{call p_SVCInsertGeneFailure(?, ?)}";

#define DOINITIALIZATION
#include "DBControl.h"

CDBInsertFailure::CDBInsertFailure()
{
    DEFINSERTFAILURE(0, 0);
}

#define DOBINDINGS
#include "DBControl.h"

DWORD CDBInsertFailure::InsertFailure(const CHAR *szSerial, const SYSTEMTIME& dtSeen)
{
    if(!Connected() && !Connect(g_szFeedMachine, g_szFeedDatabase, szInsertFailureQuery, g_szFeedUID, g_szFeedPWD))
        return (DWORD) -1;

    if(!m_fBound)
    {
        DEFINSERTFAILURE(m_hStmt, Cleanup);
    }
    m_fBound = TRUE;

    m_szSerial = szSerial;
    m_dwSerialLen = m_szSerial.Length();
    SystemTimeToDBTimestamp(dtSeen, m_dtSeen);
    if(!DBStmtExecute(m_hStmt))
    {
        m_fBound = FALSE;
        goto Cleanup;
    }

    while(DBStmtMoreResults(m_hStmt))
        ;

    return 0;

Cleanup:
    if(!m_fBound)
    {
        Disconnect();
    }
    return (DWORD) -1;
}

/******************************************************************************
    CDBInsertSourceFile Class
 ******************************************************************************/
static CHAR szFileInsertQuery[] = "{? = call p_SVCInsertFeedFile(?, ?)}";

#define DOINITIALIZATION
#include "DBControl.h"

CDBInsertSourceFile::CDBInsertSourceFile()
{
    DEFINSERTSOURCEFILE(0, 0);
}

#define DOBINDINGS
#include "DBControl.h"

DWORD CDBInsertSourceFile::InsertSourceFile(const CHAR *szFileName, bool fUnicode)
{
    if(!Connected() && !Connect(g_szFeedMachine, g_szFeedDatabase, szFileInsertQuery, g_szFeedUID, g_szFeedPWD))
        return (DWORD) -1;

    if(!m_fBound)
    {
        DEFINSERTSOURCEFILE(m_hStmt, Cleanup);
    }
    m_fBound = TRUE;

    m_szFileName = szFileName;
    m_dwFileNameLen = m_szFileName.Length();
    m_fUnicode = fUnicode;
    if(!DBStmtExecute(m_hStmt))
    {
        m_fBound = FALSE;
        goto Cleanup;
    }

    while(DBStmtMoreResults(m_hStmt))
        ;

    return m_dwBugID;

Cleanup:
    if(!m_fBound)
    {
        Disconnect();
    }
    return (DWORD) -1;
}

/******************************************************************************
    CDBQuerySourceFile Class
 ******************************************************************************/
static CHAR szFileIDQuery[] = "{? = call p_SVCGetFeedFile(?, ?)}";

#define DOINITIALIZATION
#include "DBControl.h"

CDBQuerySourceFile::CDBQuerySourceFile()
{
    DEFQUERYSOURCEFILE(0, 0);
}

#define DOBINDINGS
#include "DBControl.h"

DWORD CDBQuerySourceFile::GetSourceFileInfo(const CHAR *szFileName, DWORDLONG& dwlBytesProcessed)
{
    if(!Connected() && !Connect(g_szFeedMachine, g_szFeedDatabase, szFileIDQuery, g_szFeedUID, g_szFeedPWD))
        return (DWORD) -1;

    if(!m_fBound)
    {
        DEFQUERYSOURCEFILE(m_hStmt, Cleanup);
    }
    m_fBound = TRUE;

    m_szFileName = szFileName;
    m_dwFileNameLen = m_szFileName.Length();
    if(!DBStmtExecute(m_hStmt))
    {
        m_fBound = FALSE;
        goto Cleanup;
    }

    while(DBStmtMoreResults(m_hStmt))
        ;

    dwlBytesProcessed = m_dwlProcessed;
    return m_dwBugID;

Cleanup:
    if(!m_fBound)
    {
        Disconnect();
    }
    return (DWORD) -1;
}

/******************************************************************************
    CDBFeedRows Class
 ******************************************************************************/
static CHAR szSNQuery[] = "{call p_SVCGetFeedRows(?)}";

#define DOINITIALIZATION
#include "DBControl.h"

CDBFeedRows::CDBFeedRows()
{
    DBFEED_ROWS(0, 0);
}

#define DOBINDINGS
#include "DBControl.h"

BOOL CDBFeedRows::Start(CHAR *szSerial)
{
    if(!Connected() && !Connect(g_szFeedMachine, g_szFeedDatabase, szSNQuery, g_szFeedUID, g_szFeedPWD))
        return FALSE;

    if(!m_fBound)
    {
        DBFEED_ROWS(m_hStmt, Cleanup);
    }
    m_fBound = TRUE;

    m_szSerial = szSerial;
    m_dwSerialLen = m_szSerial.Length();
    if(!DBStmtExecute(m_hStmt))
        m_fBound = FALSE;

Cleanup:
    if(!m_fBound)
    {
        Disconnect();
        return FALSE;
    }
    return TRUE;
}

BOOL CDBFeedRows::GetNext()
{
    BOOL fLast;
    return DBStmtFetch(m_hStmt, fLast);
}

/******************************************************************************
    CDBFailedSet Class
 ******************************************************************************/
static CHAR szGetFailedSNsQuery[] = "{call p_SVCGetGeneFailures}";

#define DOINITIALIZATION
#include "DBControl.h"

CDBFailedSet::CDBFailedSet()
{
    DBFAILED_ROWS(0, 0);
}

#define DOBINDINGS
#include "DBControl.h"

BOOL CDBFailedSet::Start()
{
    if(!Connected() && !Connect(g_szFeedMachine, g_szFeedDatabase, szGetFailedSNsQuery, g_szFeedUID, g_szFeedPWD))
        return FALSE;

    if(!m_fBound)
    {
        DBFAILED_ROWS(m_hStmt, Cleanup);
    }
    m_fBound = TRUE;

    if(!DBStmtExecute(m_hStmt))
        m_fBound = FALSE;

Cleanup:
    if(!m_fBound)
    {
        Disconnect();
        return FALSE;
    }
    return TRUE;
}

BOOL CDBFailedSet::GetNext()
{
    BOOL fLast;
    return DBStmtFetch(m_hStmt, fLast);
}


/******************************************************************************
    CDBConn Class
 ******************************************************************************/
CDBConn::CDBConn()
{
    m_fBound = FALSE;
    m_hConn = 0;
    m_hStmt = 0;
}

CDBConn::~CDBConn()
{
    Disconnect();
}

BOOL CDBConn::Connect(const CHAR *szServer, const CHAR *szDatabase, const CHAR *szQuery, const CHAR *szUserName, const CHAR *szPassword)
{
    Disconnect();
    m_hConn = DBSQLConnect((CHAR *) szServer, (CHAR *) szDatabase, (CHAR *) ((szUserName && szUserName[0]) ? szUserName : NULL), (CHAR *) ((szPassword && szPassword[0] ? szPassword : NULL)));
    if(!m_hConn)
    {
        // TODO: Log an event
        return FALSE;
    }
    m_hStmt = DBPrepare(m_hConn, (CHAR *) szQuery);
    if(!m_hStmt)
    {
        Disconnect();
        return FALSE;
    }
    return TRUE;
}

BOOL CDBConn::Connected()
{
    return 0 != m_hStmt;
}

VOID CDBConn::Disconnect()
{
    if(m_hStmt)
        DBClose(m_hStmt);
    if(m_hConn)
        DBClose(m_hConn);
    m_hStmt = 0;
    m_hConn = 0;
    m_fBound = FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\genealogy\geneadmin\service\globals.h ===
#ifndef GLOBALS_H
  #define GLOBALS_H
  #define DEF_STRING(name, length)      extern TSafeStr<length> g_sz##name; 
  #define DEF_STRING_DEF(name, length, def) extern TSafeStr<length> g_sz##name; 
  #define DEF_DWORD(name, defvalue)     extern DWORD g_dw##name;
  #define DEF_VAR(type, name)           extern type name;
#elif !defined(GLOBAL_IMPLEMENT)  // !GLOBALS_H
  #undef DEF_STRING
  #undef DEF_STRING_DEF
  #undef DEF_DWORD
  #undef DEF_VAR
  #define DEF_STRING_DEF(name, length, def) TSafeStr<length> g_sz##name; 
  #define DEF_STRING(name, length)      TSafeStr<length> g_sz##name;
  #define DEF_DWORD(name, defvalue)     DWORD g_dw##name = defvalue;
  #define DEF_VAR(type, name)           type name;
#else
  #undef DEF_STRING
  #undef DEF_STRING_DEF
  #undef DEF_DWORD
  #undef DEF_VAR

  #define DEF_VAR(type, name)
    DWORD dwSize, dwType;
    CHAR szTemp[1024];

  #define DEF_DWORD(name, defvalue)                                     \
    if(!key.ExistValue(#name) || key.QueryValue(#name, g_dw##name))     \
    {                                                                   \
        g_dw##name = defvalue;                                          \
    }
    
  #define DEF_STRING(name, length)                      \
    dwSize = g_sz##name.Size();                         \
    if(key.QueryValue(#name, szTemp, dwSize, dwType))   \
    {                                                   \
        LogEvent(EVENTLOG_ERROR_TYPE, EVENT_GENE_REGKEY_QUERY_FAILED, _T("Failed to read the value at HKEY_LOCAL_MACHINE\\Software\\Microsoft\\GeneAdmin\\%s.  The error is: %d"), #name, key.GetLastError());   \
        return key.GetLastError();                      \
    }                                                   \
    g_sz##name = szTemp;

  #define DEF_STRING_DEF(name, length, def)             \
    dwSize = g_sz##name.Size();                         \
    if(key.ExistValue(#name) && !key.QueryValue(#name, szTemp, dwSize, dwType))   \
    {                                                   \
        g_sz##name = szTemp;                            \
    }                                                   \
    else                                                \
    {                                                   \
        g_sz##name = def;                               \
    }
    
#endif // !GLOBALS_H

//  Copy worker thread information needed:
//      Destination feed directory (FeedLocalPath, REG_SZ, Required, max size: MAX_PATH)
//      Source feed directory (FeedDropPath, REG_SZ, Required, max size: MAX_PATH)
//      Check frequency (FeedCopyFrequency, DWORD (minutes), Optional, default 5 minutes)
//      Database machine (FeedMachine, REG_SZ, Required, max size: 40)
//      Database name (FeedDatabase, REG_SZ, Required, max size: 40)

//  Feed worker thread information needed:
//      Source feed directory (FeedLocalPath, REG_SZ, Required, max size: MAX_PATH)
//      Database machine (FeedMachine, REG_SZ, Required, max size: 40)
//      Database name (FeedDatabase, REG_SZ, Required, max size: 40)

//  Event & mail worker thread information needed:
//      Product studio machine (ProductStudioMachine, REG_SZ, Required, max size: 40)
//      Product studio database (ProductStudioDatabase, REG_SZ, Required, max size: 40)
//      Database machine (EventMachine, REG_SZ, Required, max size: 40)
//      Database name (EventDatabase, REG_SZ, Required, max size: 40)

DEF_STRING(FeedLocalPath, MAX_PATH)
DEF_STRING(FeedDropPath, MAX_PATH)
DEF_STRING(FeedProcessedPath, MAX_PATH)
DEF_DWORD(FeedCopyFrequency, 5)
DEF_STRING(FeedMachine, 40)
DEF_STRING(FeedDatabase, 40)
DEF_STRING_DEF(FeedUID, 60, "")
DEF_STRING_DEF(FeedPWD, 20, "")

DEF_STRING(EventLocalPath, MAX_PATH)
DEF_STRING(UODBLocalPath, MAX_PATH)

DEF_STRING(ProductStudioMachine, 40)
DEF_STRING(ProductStudioDatabase, 40)
DEF_STRING(ProductStudioStore, 40)
DEF_STRING(MailStore, 128)
DEF_STRING(IssueOwner, 20)

DEF_DWORD(Test, 0)
DEF_DWORD(ValidatePSFields, 0)
DEF_DWORD(DisableThreads, 0)
DEF_DWORD(ControlBits, 0)

DEF_VAR(HANDLE, g_hInitialCopyDone)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\genealogy\geneadmin\service\mailthread.cpp ===
#include "stdafx.h"
#include <mapix.h>
#include <atlcom.h>
#include "DBConn.h"

#define EVENT_GENE_MAIL_INITIALIZATION_FAILED       0xC301
#define EVENT_GENE_MAIL_INITIALIZED                         0xC302
#define EVENT_GENE_MAIL_LOGON_FAILED                    0xC303
#define EVENT_GENE_MAIL_MESSAGE_FAILURE                 0xC304
#define EVENT_GENE_MAIL_MESSAGE_DELETE_FAILED       0xC305
#define EVENT_GENE_MAIL_FOLDER_FAILURE                  0xC306
#define EVENT_GENE_MAIL_PROCESSED                       0xC307
#define EVENT_GENE_MAIL_STORE_FAILURE                   0xC308
#define EVENT_GENE_MAIL_PROGRESS						0xC309

static DWORD s_dwMessageProcessedCount = 0;
const CHAR c_EventText[] = "XMACS:(RetrievePrincipal)";

class CSRowSet
{
public:
    CSRowSet() {m_pRows = 0;}
    ~CSRowSet() {Clear();}

    SRowSet ** operator&() {return &m_pRows;}
    SRowSet* operator->() {return m_pRows;}
    SRowSet& operator[] (int index) {return m_pRows[index];}

    void Clear() 
        {
            if(!m_pRows) return; 
            for(DWORD i = 0; i < m_pRows->cRows; ++i) 
                MAPIFreeBuffer(m_pRows->aRow[i].lpProps); 
            MAPIFreeBuffer(m_pRows);
            m_pRows = 0;
        }
protected:
    SRowSet *m_pRows;
};

template <class T> class tMAPIPtr
{
public:
    tMAPIPtr() { m_ptr = 0; }
    virtual ~tMAPIPtr() { if(m_ptr) MAPIFreeBuffer(m_ptr); }

    T** operator &() { return &m_ptr; }
    T* operator ->() { return m_ptr; }
    T& operator [](int index) { return m_ptr[index]; }
    void Clear() { if(m_ptr) MAPIFreeBuffer(m_ptr); m_ptr = 0; }

protected:
    T *m_ptr;
};

class CMailHandler
{
public:
    CMailHandler(HANDLE h) : fInitialized(FALSE)
    {
        HRESULT hr = S_OK;
        try
        {
            MAPIINIT_0 mapiInit;
            hEndThreadEvent = h;
            mapiInit.ulVersion = MAPI_INIT_VERSION;
            mapiInit.ulFlags = MAPI_MULTITHREAD_NOTIFICATIONS | MAPI_NT_SERVICE;
            hr = MAPIInitialize(&mapiInit);
            if(FAILED(hr)) 
            {
                LogEvent(EVENTLOG_ERROR_TYPE, EVENT_GENE_MAIL_INITIALIZATION_FAILED, "Could not initialize MAPI for mail handling.  Error Code: 0x%08x", hr);
                goto Cleanup;
            }
            LogEvent(EVENTLOG_INFORMATION_TYPE, EVENT_GENE_MAIL_INITIALIZED, "MAPI Initialized.");
			return;
    Cleanup:
            MAPIUninitialize();
        }
        catch(...)
        {
            hr = E_FAIL;
        }
    }

    ~CMailHandler() 
    {
        MAPIUninitialize();
    }

    BOOL Connect()
    {
        HRESULT hr = S_OK;
        try
        {
            hr = MAPILogonEx(0, 0, 0, MAPI_EXTENDED | MAPI_NEW_SESSION | MAPI_NT_SERVICE | MAPI_USE_DEFAULT, &pSession);
            if(FAILED(hr)) 
            {
                LogEvent(EVENTLOG_ERROR_TYPE, EVENT_GENE_MAIL_LOGON_FAILED, "Could not logon to retrieve mail.  Error Code: 0x%08x", hr);
                goto Cleanup;
            }
            hr = AcquireDesiredStore();
            if(FAILED(hr))  goto Cleanup;
            
            return TRUE;
        }
        catch(...)
        {
            hr = E_FAIL;
        }
Cleanup:
      if(pMsgStore)
        {
            DWORD dwFlags = LOGOFF_NO_WAIT;
            pMsgStore->StoreLogoff(&dwFlags);
            pMsgStore.Release();
        }

        if(pSession)
        {
            pSession->Logoff(0, 0, 0);
            pSession.Release();
        }
        return FALSE;
}
    VOID Disconnect()
    {
      if(pMsgStore)
        {
            DWORD dwFlags = LOGOFF_NO_WAIT;
            pMsgStore->StoreLogoff(&dwFlags);
            pMsgStore.Release();
        }

        if(pSession)
        {
            pSession->Logoff(0, 0, 0);
            pSession.Release();
        }
    }
    
    HRESULT SearchStore();
    HRESULT SearchFolder(CComQIPtr<IMAPIFolder, &IID_IMAPIFolder>& pParent, bool fSubFolders = TRUE);
    void ProcessMail(CComQIPtr<IMAPIFolder, &IID_IMAPIFolder>& pSearchFolder);


protected:
    HRESULT AcquireDesiredStore();

    CComQIPtr<IMAPISession, &IID_IMAPISession> pSession;
    CComQIPtr<IMsgStore, &IID_IMsgStore> pMsgStore;
    CDBInsertFailure DB;
    HANDLE hEndThreadEvent;
    BOOL fInitialized;
};

unsigned __stdcall fnMailWorkerThread(void *)
{
    HRESULT hr; 
    HANDLE hEndThreadEvent = INVALID_HANDLE_VALUE;
    DWORD dwIndex, dwTimeout;
    bool bFirst = true;

    // Hook up to the end service event
    hEndThreadEvent = _Module.EndThreadEvent();
    CMailHandler Mail(hEndThreadEvent);

    while(!(g_dwDisableThreads & MAIL_THREAD))
    {
        if(!bFirst)
        {
            if(!g_dwFeedCopyFrequency)
                dwTimeout = 20 * 60 * 1000;
            else
                dwTimeout = g_dwFeedCopyFrequency * 60 * 1000;
            dwIndex = WaitForSingleObject(hEndThreadEvent, dwTimeout);
            if(WAIT_OBJECT_0 == dwIndex)
                break;
        }

        bFirst = false;

        if(Mail.Connect())
            hr = Mail.SearchStore();
        Mail.Disconnect();
    }

    _Module.ThreadCompleting();
    return 0;
}

LPSRestriction MailRestriction()
{
    static bool fInit = false;
    static SRestriction rEmail[2], rFromName[2], rBody[2], rJoined[2], rFinal;
    static SPropValue pEmailValue, pEmailValue2, pBodyValue;
    if(fInit)
        return &rFinal;

    rFinal.rt = RES_AND;
    rFinal.res.resAnd.cRes = 2;
    rFinal.res.resAnd.lpRes = rJoined;

    rJoined[0].rt = RES_AND;
    rJoined[0].res.resAnd.cRes = 2;
    rJoined[0].res.resAnd.lpRes = rEmail;
    rJoined[1].rt = RES_AND;
    rJoined[1].res.resAnd.cRes = 2;
    rJoined[1].res.resAnd.lpRes = rBody;

    if(!g_dwTest)
    {
        rEmail[0].rt = RES_EXIST;
        rEmail[0].res.resExist.ulReserved1 = rEmail[0].res.resExist.ulReserved2 = 0;
        rEmail[0].res.resExist.ulPropTag = PR_SENDER_NAME | PT_STRING8;
        rEmail[1].rt = RES_OR;
        rEmail[1].res.resOr.cRes = 2;
        rEmail[1].res.resOr.lpRes = rFromName;
        rFromName[0].rt = RES_CONTENT;
        rFromName[0].res.resContent.ulFuzzyLevel = FL_SUBSTRING | FL_LOOSE | FL_IGNORECASE | FL_IGNORENONSPACE;
        rFromName[0].res.resContent.ulPropTag = PR_SENDER_NAME| PT_STRING8;
        rFromName[0].res.resContent.lpProp = &pEmailValue;
        rFromName[1].rt = RES_CONTENT;
        rFromName[1].res.resContent.ulFuzzyLevel = FL_SUBSTRING | FL_LOOSE | FL_IGNORECASE | FL_IGNORENONSPACE;
        rFromName[1].res.resContent.ulPropTag = PR_SENDER_NAME| PT_STRING8;
        rFromName[1].res.resContent.lpProp = &pEmailValue2;
        pEmailValue.ulPropTag = PR_SENDER_NAME| PT_STRING8;
        pEmailValue.dwAlignPad = 0;
        pEmailValue.Value.lpszA = "xoc@microsoft.com";
        pEmailValue2.ulPropTag = PR_SENDER_NAME| PT_STRING8;
        pEmailValue2.dwAlignPad = 0;
        pEmailValue2.Value.lpszA = "XBox Operations Center";
    }
    else
    {
        rEmail[0].rt = RES_EXIST;
        rEmail[0].res.resExist.ulReserved1 = rEmail[0].res.resExist.ulReserved2 = 0;
        rEmail[0].res.resExist.ulPropTag = PR_SUBJECT | PT_STRING8;
        rEmail[1].rt = RES_CONTENT;
        rEmail[1].res.resContent.ulFuzzyLevel = FL_PREFIX | FL_LOOSE | FL_IGNORECASE | FL_IGNORENONSPACE;
        rEmail[1].res.resContent.ulPropTag = PR_SUBJECT | PT_STRING8;
        rEmail[1].res.resContent.lpProp = &pEmailValue;
        pEmailValue.ulPropTag = PR_SUBJECT | PT_STRING8;
        pEmailValue.dwAlignPad = 0;
        pEmailValue.Value.lpszA = "GeneAdminServiceTestMessage";
    }

    
    rBody[0].rt = RES_EXIST;
    rBody[0].res.resExist.ulReserved1 = rBody[0].res.resExist.ulReserved2 = 0;
    rBody[0].res.resExist.ulPropTag = PR_BODY | PT_STRING8;
    rBody[1].rt = RES_CONTENT;
    rBody[1].res.resContent.ulFuzzyLevel = FL_SUBSTRING | FL_LOOSE | FL_IGNORECASE | FL_IGNORENONSPACE;
    rBody[1].res.resContent.ulPropTag = PR_BODY | PT_STRING8;
    rBody[1].res.resContent.lpProp = &pBodyValue;
    pBodyValue.ulPropTag = PR_BODY | PT_STRING8;
    pBodyValue.dwAlignPad = 0;
    pBodyValue.Value.lpszA = (LPSTR) c_EventText;

    fInit = true;
    return &rFinal;
}

HRESULT ProcessMessage(CDBInsertFailure& DB, CComQIPtr<IMAPIFolder, &IID_IMAPIFolder>& pFolder, SBinary& entry)
{
    CComPtr<IUnknown> pUnk;
    CComQIPtr<IMessage, &IID_IMessage> pMessage;
    HRESULT hr = S_OK;
    ENTRYLIST el;
    ULONG dwType;
    ULONG dwPropCount;
    ULONG rgMsgProps[] = {1, PR_BODY};
    LPSPropTagArray pMsgProps = (LPSPropTagArray) rgMsgProps;
    tMAPIPtr<SPropValue> pMsgValues;
    DWORD dwOccurrences = 0;
    CHAR *szPos, *szBase, *szBody, *szNextRecord;
    CSafeStr szSerial(13);
    SYSTEMTIME st;

    try
    {
        hr = pFolder->OpenEntry(entry.cb, (LPENTRYID) entry.lpb, NULL, MAPI_BEST_ACCESS, &dwType, &pUnk);
        if(FAILED(hr))
        {
            LogEvent(EVENTLOG_ERROR_TYPE, EVENT_GENE_MAIL_MESSAGE_FAILURE, "ProcessMessage: Failed to open a message.  Error code: 0x%08x", hr);
            goto Cleanup;
        }

        if(MAPI_MESSAGE != dwType)
		{
			LogEvent(EVENTLOG_ERROR_TYPE, EVENT_GENE_MAIL_MESSAGE_FAILURE, "ProcessMessage: Got a result that wasn't a message.  What the hell?  Message type is: 0x%08x", dwType);
            goto Cleanup;
		}

        hr = pUnk->QueryInterface(IID_IMessage, (void **) &pMessage);
        if(FAILED(hr))
        {
            LogEvent(EVENTLOG_ERROR_TYPE, EVENT_GENE_MAIL_MESSAGE_FAILURE, "ProcessMessage: Failed to convert IUnknown to IMessage.  Error code: 0x%08x", hr);
            goto Cleanup;
        }

        hr = pMessage->GetProps(pMsgProps, 0, &dwPropCount, &pMsgValues);
        if(FAILED(hr))
        {
            LogEvent(EVENTLOG_ERROR_TYPE, EVENT_GENE_MAIL_MESSAGE_FAILURE, "ProcessMessage: Failed to retrieve the properties of the message.  Error code: 0x%08x", hr);
            goto Cleanup;
        }
        
        if(dwPropCount != rgMsgProps[0])
        {
            LogEvent(EVENTLOG_ERROR_TYPE, EVENT_GENE_MAIL_MESSAGE_FAILURE, "ProcessMessage: Failed to retrieve all of the properties of the message.  Error code: 0x%08x", hr);
            goto Cleanup;
        }

        if( (pMsgValues[0].ulPropTag & 0xFFFF) != PT_STRING8)
        {
            LogEvent(EVENTLOG_ERROR_TYPE, EVENT_GENE_MAIL_MESSAGE_FAILURE, "ProcessMessage: Failed to process this message, body was of the wrong type: 0x%04x", (pMsgValues[0].ulPropTag & 0xFFFF));
            goto Cleanup;
        }

        // Skip subject testing for now until we know what the script will generate
        szNextRecord = szBase = szBody = pMsgValues[0].Value.lpszA;
        while(1)
        {
            // ensure we are dealing with a RetrievePrincipal error, get the serial number and the time
            // First search for the event text
            if(!szNextRecord)
                break;
            szPos = strstr(szNextRecord, c_EventText);
            if(!szPos)
                break;
            // Find out where the next record is and avoid associating anything from this record with the next 
            // This handles any potential wierd truncations of the data.
            szNextRecord = strstr(szPos + 1, c_EventText);
            szPos = strstr(szBase, "SN-");
            if(!szPos || (szNextRecord && szNextRecord < szPos))
                continue;
            // Get the serial number
            szPos += 3;
            if(12 != DigitCount(szPos))
                continue;
            szSerial.CopyN(szPos, 12);
            szPos = strstr(szBase, "Time: ");
            if(!szPos || (szNextRecord && szNextRecord < szPos))
                continue;

            szPos += 6;
			szPos += WSCount(szPos);
            memset(&st, 0, sizeof(st));
            st.wMonth = (WORD) atoi(szPos);
            szPos += DigitCount(szPos) + 1;
            st.wDay = (WORD) atoi(szPos);
            szPos += DigitCount(szPos) + 1;
            st.wYear = (WORD) atoi(szPos);
            szPos += DigitCount(szPos) + 1;
            st.wHour = (WORD) atoi(szPos);
            szPos += DigitCount(szPos) + 1;
            st.wMinute = (WORD) atoi(szPos);
            szPos += DigitCount(szPos) + 1;
            st.wSecond = (WORD) atoi(szPos);

            LocalTimeToUTC(st, st);
            if((DWORD) -1 == DB.InsertFailure(szSerial, st))
                goto Cleanup;

            szBase = szPos;
            ++dwOccurrences;
        }

        if(dwOccurrences)
        {
            ++s_dwMessageProcessedCount;
            el.cValues = 1;
            el.lpbin = &entry;
            hr = pFolder->DeleteMessages(&el, 0, 0, 0);
            if(FAILED(hr))
            {
                LogEvent(EVENTLOG_ERROR_TYPE, EVENT_GENE_MAIL_MESSAGE_DELETE_FAILED, "ProcessMessage: Failed to delete a processed message.  Error code: 0x%08x", hr);
                goto Cleanup;
            }
        }
    }
    catch(...)
    {
        hr = E_FAIL;
    }

Cleanup:
    return hr;
}

HRESULT CMailHandler::SearchStore()
{
    HRESULT hr = S_OK;
    ULONG rgFolderProps[] = {2, PR_ENTRYID, PR_MESSAGE_CLASS};
    SPropTagArray *pFolderProps = (SPropTagArray *) rgFolderProps;
    CComQIPtr<IMAPITable, &IID_IMAPITable> pTable;
    ULONG dwType;

    try
    {
        s_dwMessageProcessedCount = 0;
        hr = pMsgStore->GetReceiveFolderTable(0, &pTable);
        if(FAILED(hr))
        {
            LogEvent(EVENTLOG_ERROR_TYPE, EVENT_GENE_MAIL_FOLDER_FAILURE, "SearchStore: Failed to open the receive folder table.  Error code: 0x%08x", hr);
            goto Cleanup;
        }

        hr = pTable->SetColumns(pFolderProps, 0);
        if(FAILED(hr))
        {
            LogEvent(EVENTLOG_ERROR_TYPE, EVENT_GENE_MAIL_FOLDER_FAILURE, "SearchStore: Failed to set columns on the receive folder table.  Error code: 0x%08x", hr);
            goto Cleanup;
        }

		if(g_dwControlBits & CONTROLBIT_MAILPROGRESS)
		{
			LogEvent(EVENTLOG_INFORMATION_TYPE, EVENT_GENE_MAIL_PROGRESS, "SearchStore: Successfully got the receive folder table and set columns.");
		}

        while(1)
        {
            CComPtr<IUnknown> pUnk;
            CSRowSet pFolders;

            hr = pTable->QueryRows(1, 0, &pFolders);
            if(FAILED(hr))
            {
                LogEvent(EVENTLOG_ERROR_TYPE, EVENT_GENE_MAIL_FOLDER_FAILURE, "SearchStore: Failed to query a row from the receive folder table.  Error code: 0x%08x", hr);
                goto Cleanup;
            }

            if(!pFolders->cRows || !pFolders->aRow[0].cValues)
                break;

            hr = pMsgStore->OpenEntry(pFolders->aRow[0].lpProps[0].Value.bin.cb,
                                      (LPENTRYID) pFolders->aRow[0].lpProps[0].Value.bin.lpb,
                                      NULL, MAPI_BEST_ACCESS, &dwType, &pUnk);
            if(FAILED(hr))
            {
                LogEvent(EVENTLOG_ERROR_TYPE, EVENT_GENE_MAIL_FOLDER_FAILURE, "SearchStore: Failed to open a folder.  Error code: 0x%08x", hr);
                goto Cleanup;
            }
                
            if(MAPI_FOLDER == dwType)
            {
                CComQIPtr<IMAPIFolder, &IID_IMAPIFolder> pFolder;
                hr = pUnk->QueryInterface(IID_IMAPIFolder, (void **) &pFolder);
                if(FAILED(hr))
                {
                    LogEvent(EVENTLOG_ERROR_TYPE, EVENT_GENE_MAIL_FOLDER_FAILURE, "SearchStore: Failed to change IUnknown to an IMAPIFolder.  Error code: 0x%08x", hr);
                    goto Cleanup;
                }
                
                hr = SearchFolder(pFolder);
                if(FAILED(hr))
                    goto Cleanup;
            }
        }
        if(s_dwMessageProcessedCount)
            LogEvent(EVENTLOG_INFORMATION_TYPE, EVENT_GENE_MAIL_PROCESSED, "Successfully found and processed %d mail messages.",  s_dwMessageProcessedCount);
    }
    catch(...)
    {
        hr = E_FAIL;
    }

Cleanup:
    return hr;
}


HRESULT GetFolderName(CComQIPtr<IMAPIFolder, &IID_IMAPIFolder>& pParent, CComBSTR &bsDest)
{
    ULONG rgMsgProps[] = {1, PR_DISPLAY_NAME};
    LPSPropTagArray pMsgProps = (LPSPropTagArray) rgMsgProps;
    tMAPIPtr<SPropValue> pMsgValues;
	HRESULT hr = S_OK;
	DWORD dwPropCount;

    hr = pParent->GetProps(pMsgProps, 0, &dwPropCount, &pMsgValues);
    if(FAILED(hr))
    {
        LogEvent(EVENTLOG_ERROR_TYPE, EVENT_GENE_MAIL_MESSAGE_FAILURE, "GetFolderName: Failed to retrieve the display name of the folder.  Error code: 0x%08x", hr);
        goto Cleanup;
    }
    
    if(dwPropCount != rgMsgProps[0])
    {
        LogEvent(EVENTLOG_ERROR_TYPE, EVENT_GENE_MAIL_MESSAGE_FAILURE, "GetFolderName: Failed to retrieve the display name of the folder.  Error code: 0x%08x", hr);
        goto Cleanup;
    }

    if( (pMsgValues[0].ulPropTag & 0xFFFF) != PT_STRING8)
    {
        goto Cleanup;
    }
	
	bsDest = pMsgValues[0].Value.lpszA;

Cleanup:
	if(FAILED(hr))
		bsDest = "<Unknown Folder Name>";
	return hr;
}

HRESULT CMailHandler::SearchFolder(CComQIPtr<IMAPIFolder, &IID_IMAPIFolder>& pParent, bool fSubFolders)
{
    HRESULT hr = S_OK;
    CComQIPtr<IMAPITable, &IID_IMAPITable> pTable;
    ULONG rgFolderProps[] = {2, PR_ENTRYID, PR_MESSAGE_CLASS};
    SPropTagArray *pFolderProps = (SPropTagArray *) rgFolderProps;
	CComBSTR bsName;

	GetFolderName(pParent, bsName);
    // Process folders first, then messages
    try
    {
		if(g_dwControlBits & CONTROLBIT_MAILPROGRESS)
		{
			LogEvent(EVENTLOG_INFORMATION_TYPE, EVENT_GENE_MAIL_PROGRESS, "SearchFolder: Searching Folder: %S", (BSTR) bsName);
		}

		if(fSubFolders)
        {
            ULONG dwType;

            hr = pParent->GetHierarchyTable(CONVENIENT_DEPTH, &pTable);
            if(FAILED(hr))
            {
                LogEvent(EVENTLOG_ERROR_TYPE, EVENT_GENE_MAIL_FOLDER_FAILURE, "SearchFolder: Failed to retrieve the hierarchy table.  Error code: 0x%08x", hr);
                goto Cleanup;
            }

            hr = pTable->SetColumns(pFolderProps, 0);
            if(FAILED(hr))
            {
                LogEvent(EVENTLOG_ERROR_TYPE, EVENT_GENE_MAIL_FOLDER_FAILURE, "SearchFolder: Failed to set columns on  the hierarchy table.  Error code: 0x%08x", hr);
                goto Cleanup;
            }

            while(1)
            {
                CSRowSet pFolders;
                CComPtr<IUnknown> pUnk;

                if(WAIT_OBJECT_0 == WaitForSingleObject(hEndThreadEvent, 0))
                    break;

                hr = pTable->QueryRows(1, 0, &pFolders);
                if(FAILED(hr))
                {
                    LogEvent(EVENTLOG_ERROR_TYPE, EVENT_GENE_MAIL_FOLDER_FAILURE, "SearchFolder: Failed to retrieve a row from the hierarchy table.  Error code: 0x%08x", hr);
                    break;
                }

                if(!pFolders->cRows || !pFolders->aRow[0].cValues)
                    break;

                hr = pParent->OpenEntry(pFolders->aRow[0].lpProps[0].Value.bin.cb,
                                        (LPENTRYID) pFolders->aRow[0].lpProps[0].Value.bin.lpb,
                                        NULL, MAPI_BEST_ACCESS, &dwType, &pUnk);
                if(FAILED(hr))
                {
                    LogEvent(EVENTLOG_ERROR_TYPE, EVENT_GENE_MAIL_FOLDER_FAILURE, "SearchFolder: Failed to open a folder.  Error code: 0x%08x", hr);
                    break;
                }

                if(MAPI_FOLDER == dwType)
                {
                    CComQIPtr<IMAPIFolder, &IID_IMAPIFolder> pFolder;
                    hr = pUnk->QueryInterface(IID_IMAPIFolder, (void **) &pFolder);
                    if(FAILED(hr))
                    {
                        LogEvent(EVENTLOG_ERROR_TYPE, EVENT_GENE_MAIL_FOLDER_FAILURE, "SearchFolder: Failed to change IUnknown to an IMAPIFolder.  Error code: 0x%08x", hr);
                        goto Cleanup;
                    }
                    hr = SearchFolder(pFolder, FALSE);
                    if(FAILED(hr))
                        break;
                }
            }
        }

        // Process Messages
        ProcessMail(pParent);
    }
    catch(...)
    {
        hr = E_FAIL;
    }
Cleanup:
    return hr;
}

void CMailHandler::ProcessMail(CComQIPtr<IMAPIFolder, &IID_IMAPIFolder>& pSearchFolder)
{
    HRESULT hr = S_OK;
    CComQIPtr<IMAPITable, &IID_IMAPITable> pMsgTable;
    ULONG rgMailEntryIDs[] = {1, PR_ENTRYID};
    SPropTagArray* pMailEntryIDsOnly = (SPropTagArray*) rgMailEntryIDs;
    SBinary entry;

    try
    {
        hr = pSearchFolder->GetContentsTable(0, &pMsgTable);
        if(FAILED(hr))
        {
            LogEvent(EVENTLOG_ERROR_TYPE, EVENT_GENE_MAIL_FOLDER_FAILURE, "ProcessMail: Failed to get the contents table.  Error code: 0x%08x", hr);
            goto Cleanup;
        }

        hr = pMsgTable->SetColumns(pMailEntryIDsOnly, 0);
        if(FAILED(hr))
        {
            LogEvent(EVENTLOG_ERROR_TYPE, EVENT_GENE_MAIL_FOLDER_FAILURE, "ProcessMail: Failed to set the columns on the contents table.  Error code: 0x%08x", hr);
            goto Cleanup;
        }

        while(1)
        {
            CSRowSet pMsgEntry;
            if(WAIT_OBJECT_0 == WaitForSingleObject(hEndThreadEvent, 0))
                break;

            hr = pMsgTable->FindRow(MailRestriction(), BOOKMARK_CURRENT, 0);
            if(MAPI_E_NOT_FOUND == hr)
                break;
            
            if(FAILED(hr))
            {
                LogEvent(EVENTLOG_ERROR_TYPE, EVENT_GENE_MAIL_FOLDER_FAILURE, "ProcessMail: Failed to search the messages.  Error code: 0x%08x", hr);
                goto Cleanup;
            }

            hr = pMsgTable->QueryRows(1, 0, &pMsgEntry);
            if(FAILED(hr))
            {
                LogEvent(EVENTLOG_ERROR_TYPE, EVENT_GENE_MAIL_MESSAGE_FAILURE, "ProcessMail: Failed to retrieve the message entry id.  Error code: 0x%08x", hr);
                goto Cleanup;
            }

            if(!pMsgEntry->cRows || !pMsgEntry->aRow[0].cValues)
                break;

            entry.cb = pMsgEntry->aRow[0].lpProps[0].Value.bin.cb;
            entry.lpb = pMsgEntry->aRow[0].lpProps[0].Value.bin.lpb;
            hr = ProcessMessage(DB, pSearchFolder, entry);
            if(FAILED(hr))
                goto Cleanup;
        }
        /*
        while(1)
        {
            CSRowSet pMsgEntry;

            if(WAIT_OBJECT_0 == WaitForSingleObject(hEndThreadEvent, 0))
                break;

            hr = pMsgTable->QueryRows(1, 0, &pMsgEntry);
            if(FAILED(hr))
            {
                _Module.LogEvent(EVENTLOG_ERROR_TYPE, "ProcessMail: Failed to retrieve a row from the contents table.  Error code: 0x%08x", hr);
                goto Cleanup;
            }

            if(!pMsgEntry->cRows || !pMsgEntry->aRow[0].cValues)
                break;

            entry.cb = pMsgEntry->aRow[0].lpProps[0].Value.bin.cb;
            entry.lpb = pMsgEntry->aRow[0].lpProps[0].Value.bin.lpb;
            hr = ProcessMessage(DB, pSearchFolder, entry);
            if(FAILED(hr))
                goto Cleanup;
        }
        */
    Cleanup:
        if(pMsgTable)
            pMsgTable.Release();

    }
    catch(...)
    {
        hr = E_FAIL;
    }
}

HRESULT CMailHandler::AcquireDesiredStore()
{
    HRESULT hr = S_OK;
    CComQIPtr<IMAPITable, &IID_IMAPITable> pTable;
    DWORD dwRowCount;
    CSRowSet pDefaultStoreRow;
    ULONG rgTableProperties[3] = {2, PR_DISPLAY_NAME, PR_ENTRYID};
    SPropTagArray& tableProperties = (SPropTagArray&) rgTableProperties;
    DWORD dwIndex;

    try
    {
        hr = pSession->GetMsgStoresTable(0, &pTable);
        if(FAILED(hr))
        {
            LogEvent(EVENTLOG_ERROR_TYPE, EVENT_GENE_MAIL_STORE_FAILURE, "AcquireDesiredStore: Failed to retrieve the message store table.  Error code: 0x%08x", hr);
            goto Cleanup;
        }

        hr = pTable->SetColumns(&tableProperties, 0);
        if(FAILED(hr))
        {
            LogEvent(EVENTLOG_ERROR_TYPE, EVENT_GENE_MAIL_STORE_FAILURE, "AcquireDesiredStore: Failed to set the desired columns on the message store table.  Error code: 0x%08x", hr);
            goto Cleanup;
        }
        
        hr = pTable->GetRowCount(0, &dwRowCount);
        if(FAILED(hr))
        {
            LogEvent(EVENTLOG_ERROR_TYPE, EVENT_GENE_MAIL_STORE_FAILURE, "AcquireDesiredStore: Failed to retrieve the row count of message stores from the message store table.  Error code: 0x%08x", hr);
            goto Cleanup;
        }

        hr = pTable->QueryRows(dwRowCount, TBL_NOADVANCE, &pDefaultStoreRow);
        if(FAILED(hr))
        {
            LogEvent(EVENTLOG_ERROR_TYPE, EVENT_GENE_MAIL_STORE_FAILURE, "AcquireDesiredStore: Failed to retrieve rows from the message store table.  Error code: 0x%08x", hr);
            goto Cleanup;
        }
        if(!pDefaultStoreRow->cRows)
        {
            hr = MAPI_E_NOT_FOUND;
            LogEvent(EVENTLOG_ERROR_TYPE, EVENT_GENE_MAIL_STORE_FAILURE, "AcquireDesiredStore: No rows were found in the message store table.  Error code: 0x%08x", hr);
            goto Cleanup;
        }

        for(dwIndex = 0; dwIndex < pDefaultStoreRow->cRows; ++dwIndex)
        {
            if(!_stricmp(pDefaultStoreRow->aRow[dwIndex].lpProps[0].Value.lpszA, g_szMailStore))
            {
                hr = pSession->OpenMsgStore(0, pDefaultStoreRow->aRow[dwIndex].lpProps[1].Value.bin.cb, 
                                            (LPENTRYID) pDefaultStoreRow->aRow[dwIndex].lpProps[1].Value.bin.lpb, 
                                            &IID_IMsgStore, MDB_WRITE | MDB_NO_DIALOG, &pMsgStore);
                if(FAILED(hr))
                {
                    LogEvent(EVENTLOG_ERROR_TYPE, EVENT_GENE_MAIL_STORE_FAILURE, "AcquireDesiredStore: Failed to open the message store \"%s\".  Error code: 0x%08x", g_szMailStore, hr);
                    goto Cleanup;
                }
                hr = S_OK;
                goto Cleanup;
            }
        }
    
        hr = MAPI_E_NOT_FOUND;
        LogEvent(EVENTLOG_ERROR_TYPE, EVENT_GENE_MAIL_STORE_FAILURE, "AcquireDesiredStore: Failed to find the message store \"%s\".  Error code: 0x%08x", g_szMailStore, hr);
    }
    catch(...)
    {
        hr = E_FAIL;
    }
    Cleanup:
        return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\genealogy\geneadmin\service\geneadmin.cpp ===
// geneadmin.cpp : Implementation of WinMain


// Note: Proxy/Stub Information
//      To build a separate proxy/stub DLL, 
//      run nmake -f geneadminps.mk in the project directory.

#include "stdafx.h"
#include "resource.h"

#include "globals.h"

#define USES_IID_IMAPIFolder    1
#define USES_IID_IMsgStore      1
#define USES_IID_IMessage       1

#include <atlimpl.cpp>

#include <initguid.h>
#include <mapiguid.h>

#include <process.h>
#include "geneadmin.h"

#include "geneadmin_i.c"


#include <stdio.h>

#include "copythread.h"
#include "feedthread.h"
#include "mailthread.h"
#include "psthread.h"
#include "eventthread.h"
#include "uodbthread.h"
#include "Manage.h"

CServiceModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
OBJECT_ENTRY(CLSID_Manage, CManage)
END_OBJECT_MAP()


LPCTSTR FindOneOf(LPCTSTR p1, LPCTSTR p2)
{
    while (p1 != NULL && *p1 != NULL)
    {
        LPCTSTR p = p2;
        while (p != NULL && *p != NULL)
        {
            if (*p1 == *p)
                return CharNext(p1);
            p = CharNext(p);
        }
        p1 = CharNext(p1);
    }
    return NULL;
}

// Although some of these functions are big they are declared inline since they are only used once

inline HRESULT CServiceModule::RegisterServer(BOOL bRegTypeLib, BOOL bService)
{
    HRESULT hr = CoInitialize(NULL);
    if (FAILED(hr))
        return hr;

    // Remove any previous service since it may point to
    // the incorrect file
    Uninstall();

    // Add service entries
    UpdateRegistryFromResource(IDR_Geneadmin, TRUE);

    // Adjust the AppID for Local Server or Service
    CRegKey keyAppID;
    LONG lRes = keyAppID.Open(HKEY_CLASSES_ROOT, _T("AppID"), KEY_WRITE);
    if (lRes != ERROR_SUCCESS)
        return lRes;

    CRegKey key;
    lRes = key.Open(keyAppID, _T("{1DCD9252-AFF1-4E59-ABE4-6DC1FFCDD768}"), KEY_WRITE);
    if (lRes != ERROR_SUCCESS)
        return lRes;
    key.DeleteValue(_T("LocalService"));
    
    if (bService)
    {
        key.SetStringValue(_T("LocalService"), _T("geneadmin"));
        key.SetStringValue(_T("ServiceParameters"), _T("-Service"));
        // Create service
        Install();
    }

    // Add object entries
    hr = CComModule::RegisterServer(bRegTypeLib);

    CoUninitialize();
    return hr;
}

inline HRESULT CServiceModule::UnregisterServer()
{
    HRESULT hr = CoInitialize(NULL);
    if (FAILED(hr))
        return hr;

    // Remove service entries
    UpdateRegistryFromResource(IDR_Geneadmin, FALSE);
    // Remove service
    Uninstall();
    // Remove object entries
    CComModule::UnregisterServer(TRUE);
    CoUninitialize();
    return S_OK;
}

inline void CServiceModule::Init(_ATL_OBJMAP_ENTRY* p, HINSTANCE h, UINT nServiceNameID, const GUID* plibid)
{
    CComModule::Init(p, h, plibid);

    m_bService = TRUE;

    LoadString(h, nServiceNameID, m_szServiceName, sizeof(m_szServiceName) / sizeof(TCHAR));
    
    SetEventSource(m_szServiceName);

    // set up the initial service status 
    m_hServiceStatus = NULL;
    m_status.dwServiceType = SERVICE_WIN32_OWN_PROCESS;
    m_status.dwCurrentState = SERVICE_STOPPED;
    m_status.dwControlsAccepted = SERVICE_ACCEPT_STOP;
    m_status.dwWin32ExitCode = 0;
    m_status.dwServiceSpecificExitCode = 0;
    m_status.dwCheckPoint = 0;
    m_status.dwWaitHint = 0;
}

LONG CServiceModule::Unlock()
{
    LONG l = CComModule::Unlock();
    if (l == 0 && !m_bService)
        PostThreadMessage(dwThreadID, WM_QUIT, 0, 0);
    return l;
}

BOOL CServiceModule::IsInstalled()
{
    BOOL bResult = FALSE;

    SC_HANDLE hSCM = ::OpenSCManager(NULL, NULL, SC_MANAGER_ALL_ACCESS);

    if (hSCM != NULL)
    {
        SC_HANDLE hService = ::OpenService(hSCM, m_szServiceName, SERVICE_QUERY_CONFIG);
        if (hService != NULL)
        {
            bResult = TRUE;
            ::CloseServiceHandle(hService);
        }
        ::CloseServiceHandle(hSCM);
    }
    return bResult;
}

inline BOOL CServiceModule::Install()
{
    if (IsInstalled())
        return TRUE;

    SC_HANDLE hSCM = ::OpenSCManager(NULL, NULL, SC_MANAGER_ALL_ACCESS);
    if (hSCM == NULL)
    {
        MessageBox(NULL, _T("Couldn't open service manager"), m_szServiceName, MB_OK);
        return FALSE;
    }

    // Get the executable file path
    TCHAR szFilePath[_MAX_PATH];
    ::GetModuleFileName(NULL, szFilePath, _MAX_PATH);

    SC_HANDLE hService = ::CreateService(
        hSCM, m_szServiceName, m_szServiceName,
        SERVICE_ALL_ACCESS, SERVICE_WIN32_OWN_PROCESS,
        SERVICE_DEMAND_START, SERVICE_ERROR_NORMAL,
        szFilePath, NULL, NULL, _T("RPCSS\0"), NULL, NULL);

    if (hService == NULL)
    {
        ::CloseServiceHandle(hSCM);
        MessageBox(NULL, _T("Couldn't create service"), m_szServiceName, MB_OK);
        return FALSE;
    }

    ::CloseServiceHandle(hService);
    ::CloseServiceHandle(hSCM);
    return TRUE;
}

inline BOOL CServiceModule::Uninstall()
{
    if (!IsInstalled())
        return TRUE;

    SC_HANDLE hSCM = ::OpenSCManager(NULL, NULL, SC_MANAGER_ALL_ACCESS);

    if (hSCM == NULL)
    {
        MessageBox(NULL, _T("Couldn't open service manager"), m_szServiceName, MB_OK);
        return FALSE;
    }

    SC_HANDLE hService = ::OpenService(hSCM, m_szServiceName, SERVICE_STOP | DELETE);

    if (hService == NULL)
    {
        ::CloseServiceHandle(hSCM);
        MessageBox(NULL, _T("Couldn't open service"), m_szServiceName, MB_OK);
        return FALSE;
    }
    SERVICE_STATUS status;
    ::ControlService(hService, SERVICE_CONTROL_STOP, &status);

    BOOL bDelete = ::DeleteService(hService);
    ::CloseServiceHandle(hService);
    ::CloseServiceHandle(hSCM);

    if (bDelete)
        return TRUE;

    MessageBox(NULL, _T("Service could not be deleted"), m_szServiceName, MB_OK);
    return FALSE;
}

//////////////////////////////////////////////////////////////////////////////////////////////
// Service startup and registration
inline void CServiceModule::Start()
{
    SERVICE_TABLE_ENTRY st[] =
    {
        { m_szServiceName, _ServiceMain },
        { NULL, NULL }
    };
    if (m_bService && !::StartServiceCtrlDispatcher(st))
    {
        m_bService = FALSE;
    }
    if (m_bService == FALSE)
        Run();
}

inline void CServiceModule::ServiceMain(DWORD /* dwArgc */, LPTSTR* /* lpszArgv */)
{
    // Register the control request handler
    m_status.dwCurrentState = SERVICE_START_PENDING;
    m_hServiceStatus = RegisterServiceCtrlHandler(m_szServiceName, _Handler);
    if (m_hServiceStatus == NULL)
    {
        ::LogEvent(EVENTLOG_ERROR_TYPE, EVENT_GENE_SERVICE_CRITICAL_FAILURE, _T("Handler not installed"));
        return;
    }
    SetServiceStatus(SERVICE_START_PENDING);

    m_status.dwWin32ExitCode = S_OK;
    m_status.dwCheckPoint = 0;
    m_status.dwWaitHint = 0;

    // When the Run function returns, the service has stopped.
    Run();

    SetServiceStatus(SERVICE_STOPPED);
    ::LogEvent(EVENTLOG_INFORMATION_TYPE, EVENT_GENE_SERVICE_STOPPED, _T("Service stopped"));
}

inline void CServiceModule::Handler(DWORD dwOpcode)
{
    switch (dwOpcode)
    {
    case SERVICE_CONTROL_STOP:
        SetServiceStatus(SERVICE_STOP_PENDING);
        PostThreadMessage(dwThreadID, WM_QUIT, 0, 0);
        break;
    case SERVICE_CONTROL_PAUSE:
        break;
    case SERVICE_CONTROL_CONTINUE:
        break;
    case SERVICE_CONTROL_INTERROGATE:
        break;
    case SERVICE_CONTROL_SHUTDOWN:
        break;
    default:
        ::LogEvent(EVENTLOG_WARNING_TYPE, EVENT_GENE_SERVICE_BAD_COMMAND, _T("Bad service request"));
    }
}

void WINAPI CServiceModule::_ServiceMain(DWORD dwArgc, LPTSTR* lpszArgv)
{
    _Module.ServiceMain(dwArgc, lpszArgv);
}
void WINAPI CServiceModule::_Handler(DWORD dwOpcode)
{
    _Module.Handler(dwOpcode); 
}

void CServiceModule::SetServiceStatus(DWORD dwState)
{
    m_status.dwCurrentState = dwState;
    ::SetServiceStatus(m_hServiceStatus, &m_status);
}

LONG CServiceModule::ReadRegistry()
{
    CKey key;
    // Read configuration from registry (HKLM\Software\Microsoft\GeneAdmin)
    if(key.Open(HKEY_LOCAL_MACHINE, "Software\\Microsoft\\GeneAdmin", KEY_READ))
    {
        ::LogEvent(EVENTLOG_ERROR_TYPE, EVENT_GENE_REGKEY_OPEN_FAILED, _T("Failed to open a key at HKEY_LOCAL_MACHINE\\Software\\Microsoft\\GeneAdmin.  The error is: %d"), key.GetLastError());
        return key.GetLastError();
    }

#define GLOBAL_IMPLEMENT
#include "globals.h"

    return 0;
}

#define START_THREAD(index, fnname, id, target)                                                        \
    ++m_dwThreadsRunning;                                                                                        \
    rghThreads[index] = (HANDLE) _beginthreadex(NULL, 0, fnname, 0, 0, (unsigned int*) &id);    \
    if(!rghThreads[index] || INVALID_HANDLE_VALUE == rghThreads[index])                    \
    {                                                                                                                            \
        --m_dwThreadsRunning;                                                                                       \
        dwLastIndex = index;                                                                                           \
        goto target;                                                                                                         \
    }

void CServiceModule::Run()
{
    HANDLE rghThreads[6] = {INVALID_HANDLE_VALUE, INVALID_HANDLE_VALUE, INVALID_HANDLE_VALUE, INVALID_HANDLE_VALUE, INVALID_HANDLE_VALUE, INVALID_HANDLE_VALUE};
    DWORD dwIndex, dwCopyFileThreadId, dwFeedImportThreadId, dwMailProcThreadId, dwProdStudioThreadId, dwEventFileThreadId, dwUODBThreadId;
    DWORD dwLastIndex = 0;
    CHAR szMsg[80];
    _Module.dwThreadID = GetCurrentThreadId();

    m_dwThreadsRunning = 0;
    
    SetErrorReporting(/*DB_REPORT_INFORMATIONAL |*/ DB_REPORT_DEBUGSTRING | DB_REPORT_EVENT, m_szServiceName);
    m_hEndServiceEvent = CreateEvent(NULL, TRUE, FALSE, NULL);
    m_hWaitOnThreadsEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
    g_hInitialCopyDone = CreateEvent(NULL, TRUE, FALSE, NULL);

    _snprintf(szMsg, sizeof(szMsg) - 1, "Main thread ID: %d\n", _Module.dwThreadID);
    szMsg[sizeof(szMsg) - 1] = 0;
    OutputDebugStringA(szMsg);

//    HRESULT hr = CoInitialize(NULL);
//  If you are running on NT 4.0 or higher you can use the following call
//  instead to make the EXE free threaded.
//  This means that calls come in on a random RPC thread
    HRESULT hr = CoInitializeEx(NULL, COINIT_MULTITHREADED);

    _ASSERTE(SUCCEEDED(hr));

    // This provides a NULL DACL which will allow access to everyone.
    CSecurityDescriptor sd;
    sd.InitializeFromThreadToken();
    hr = CoInitializeSecurity(sd, -1, NULL, NULL,
        RPC_C_AUTHN_LEVEL_PKT, RPC_C_IMP_LEVEL_IMPERSONATE, NULL, EOAC_NONE, NULL);
    _ASSERTE(SUCCEEDED(hr));

    hr = _Module.RegisterClassObjects(CLSCTX_LOCAL_SERVER | CLSCTX_REMOTE_SERVER, REGCLS_MULTIPLEUSE);
    _ASSERTE(SUCCEEDED(hr));

    // Create an event that will notify all threads that they should stop...
    if(NULL == m_hEndServiceEvent || 
        NULL == m_hWaitOnThreadsEvent || 
        NULL == g_hInitialCopyDone)
    {
        ::LogEvent(EVENTLOG_ERROR_TYPE, EVENT_GENE_SERVICE_CRITICAL_FAILURE, _T("Failed to create the global service end event handle.  The error is: %d"), GetLastError());
        if(m_bService)
            SetServiceStatus(SERVICE_STOPPED);
        goto Cleanup;
    }

    // Read registry configuration:
    if(ReadRegistry())
    {
        goto Cleanup;
    }

    // Create necessary worker threads
    //  Worker thread that copies from the drop server to the inbound feed directory
    START_THREAD(0, fnCopyFileWorkerThread, dwCopyFileThreadId, Cleanup);

    //  Worker thread that processes new files in the inbound feed directory
    START_THREAD(1, fnFeedWorkerThread, dwFeedImportThreadId, WaitAndStop);

    // Worer thread that processes uodb dump files into the database
    START_THREAD(2, fnUODBWorkerThread, dwUODBThreadId, WaitAndStop);

    //  Worker thread that checks the GeneFailures table for work to do against product studio
    START_THREAD(3, fnProductStudioWorkerThread, dwProdStudioThreadId, WaitAndStop);
    
    // Worker thread that checks for event dumps to update serial numbers that have failed from genealogy.
    START_THREAD(4, fnEventFileWorkerThread, dwEventFileThreadId, WaitAndStop);

    //  Worker thread that processes new dumps to the event & mail inbound directory
    START_THREAD(5, fnMailWorkerThread, dwMailProcThreadId, WaitAndStop);

    LogEvent(EVENTLOG_INFORMATION_TYPE, EVENT_GENE_SERVICE_STARTED, _T("Service started"));
    if (m_bService)
        SetServiceStatus(SERVICE_RUNNING);

    MSG msg;
    while (GetMessage(&msg, 0, 0, 0))
        DispatchMessage(&msg);

WaitAndStop:
    SetEvent(m_hEndServiceEvent);

    // Wait for all threads to close and process messages in the mean time just in case one of the other threads needs it
    while(1)
    {
        dwIndex = MsgWaitForMultipleObjects(1, &m_hWaitOnThreadsEvent, FALSE, INFINITE, QS_ALLEVENTS);
        if(WAIT_OBJECT_0 + 1 == dwIndex)
        {
            GetMessage(&msg, 0, 0, 0);
            DispatchMessage(&msg);
            continue;
        }
        break;
    }

Cleanup:
    for(dwIndex = 0; dwIndex <= dwLastIndex; ++dwIndex)
    {
        if(rghThreads[dwIndex] && INVALID_HANDLE_VALUE != rghThreads[dwIndex])
            CloseHandle(rghThreads[dwIndex]);
    }

    if(NULL != m_hEndServiceEvent)
        CloseHandle(m_hEndServiceEvent);

    if(NULL != m_hWaitOnThreadsEvent)
        CloseHandle(m_hWaitOnThreadsEvent);
    
    if(NULL != g_hInitialCopyDone)
        CloseHandle(g_hInitialCopyDone);

    _Module.RevokeClassObjects();

    CoUninitialize();
}


void CServiceModule::ThreadCompleting()
{
    m_cs.Enter();
    --m_dwThreadsRunning;
    if(!m_dwThreadsRunning)
        SetEvent(m_hWaitOnThreadsEvent);
    m_cs.Leave();
}

HANDLE CServiceModule::EndThreadEvent()
{
    return m_hEndServiceEvent;
}


/////////////////////////////////////////////////////////////////////////////
//
extern "C" int WINAPI _tWinMain(HINSTANCE hInstance, 
    HINSTANCE /*hPrevInstance*/, LPTSTR lpCmdLine, int /*nShowCmd*/)
{
    lpCmdLine = GetCommandLine(); //this line necessary for _ATL_MIN_CRT
    _Module.Init(ObjectMap, hInstance, IDS_SERVICENAME, &LIBID_GENEADMINLib);
    _Module.m_bService = TRUE;
    
    TCHAR szTokens[] = _T("-/");

    LPCTSTR lpszToken = FindOneOf(lpCmdLine, szTokens);
    while (lpszToken != NULL)
    {
        if (lstrcmpi(lpszToken, _T("UnregServer"))==0)
            return _Module.UnregisterServer();

        // Register as Local Server
        if (lstrcmpi(lpszToken, _T("RegServer"))==0)
            return _Module.RegisterServer(TRUE, FALSE);
        
        // Register as Service
        if (lstrcmpi(lpszToken, _T("Service"))==0)
            return _Module.RegisterServer(TRUE, TRUE);
        
        lpszToken = FindOneOf(lpszToken, szTokens);
    }

    // Are we Service or Local Server
    CRegKey keyAppID;
    LONG lRes = keyAppID.Open(HKEY_CLASSES_ROOT, _T("AppID"), KEY_READ);
    if (lRes != ERROR_SUCCESS)
        return lRes;

    CRegKey key;
    lRes = key.Open(keyAppID, _T("{1DCD9252-AFF1-4E59-ABE4-6DC1FFCDD768}"), KEY_READ);
    if (lRes != ERROR_SUCCESS)
        return lRes;

    TCHAR szValue[_MAX_PATH];
    DWORD dwLen = _MAX_PATH;
    lRes = key.QueryStringValue(_T("LocalService"), szValue, &dwLen);

    _Module.m_bService = FALSE;
    if (lRes == ERROR_SUCCESS)
        _Module.m_bService = TRUE;

    _Module.Start();

    // When we get here, the service has been stopped
    return _Module.m_status.dwWin32ExitCode;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\genealogy\geneadmin\service\mailthread.h ===
#pragma once


unsigned __stdcall fnMailWorkerThread(void *);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\genealogy\geneadmin\service\Manage.h ===
// Manage.h : Declaration of the CManage

#ifndef __MANAGE_H_
#define __MANAGE_H_

#include "resource.h"       // main symbols

/////////////////////////////////////////////////////////////////////////////
// CManage
class ATL_NO_VTABLE CManage : 
	public CComObjectRootEx<CComMultiThreadModel>,
	public CComCoClass<CManage, &CLSID_Manage>,
	public IDispatchImpl<IManage, &IID_IManage, &LIBID_GENEADMINLib>
{
public:
	CManage()
	{
		m_pUnkMarshaler = NULL;
	}

DECLARE_REGISTRY_RESOURCEID(IDR_MANAGE)
DECLARE_GET_CONTROLLING_UNKNOWN()

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CManage)
	COM_INTERFACE_ENTRY(IManage)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY_AGGREGATE(IID_IMarshal, m_pUnkMarshaler.p)
END_COM_MAP()

	HRESULT FinalConstruct()
	{
		return CoCreateFreeThreadedMarshaler(
			GetControllingUnknown(), &m_pUnkMarshaler.p);
	}

	void FinalRelease()
	{
		m_pUnkMarshaler.Release();
	}

	CComPtr<IUnknown> m_pUnkMarshaler;

// IManage
public:
	STDMETHOD(Stop)();
};

#endif //__MANAGE_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\genealogy\geneadmin\service\Manage.cpp ===
// Manage.cpp : Implementation of CManage
#include "stdafx.h"
#include "Geneadmin.h"
#include "Manage.h"

/////////////////////////////////////////////////////////////////////////////
// CManage


STDMETHODIMP CManage::Stop()
{
	PostThreadMessage(_Module.dwThreadID, WM_QUIT, 0, 0);
	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\genealogy\geneadmin\service\pscom.h ===
#pragma once

#import "psom10.tlb" rename_namespace("ProductStudio"), named_guids, raw_dispinterfaces, raw_native_types, raw_interfaces_only, raw_dispinterfaces, no_implementation

class CProductStudioInterface
{
public:
    CProductStudioInterface();
    ~CProductStudioInterface();

    BOOL Connected();

    DWORD CreateBug(const CHAR *szSerial, CComBSTR &bsDescription);
    DWORD CloseBug(DWORD dwBugID, CComBSTR &bsDescription);
    DWORD ResolveBug(DWORD dwBugID, const CHAR *szResolution, CComBSTR &bsDescription);
    DWORD UpdateBug(DWORD dwBugID, CComBSTR &bsDescription);
    DWORD ReopenBug(DWORD dwBugID, CComBSTR &bsDescription);
protected:
    HRESULT SetField(ProductStudio::IFieldsPtr& fields, CComVariant vtField, CComVariant vtValue);
    HRESULT GetField(ProductStudio::IFieldsPtr& fields, CComVariant vtField, CComVariant &vtValue);
    DWORD GetBug(DWORD dwBugID, ProductStudio::IBugPtr &bug);

    ProductStudio::IDirectoryPtr m_pDirectory;
    ProductStudio::IProductPtr m_pXboxOnline;
    ProductStudio::IDatastorePtr m_pDatastore;
    ProductStudio::IDatastoreItemListPtr m_pStoreList;
    ProductStudio::IDatastoreItemsPtr m_pBugs;
    long m_lTreeNodeId;
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\genealogy\geneadmin\service\pscom.cpp ===
#include "stdafx.h"
#include "pscom.h"

#define EVAL(p) ((BOOL) (p))
#define SETHRJUMP(hr, val, dest) {hr = val; goto dest;}

#define EVENT_GENE_PS_CRITICAL_FAILURE          0xC401
#define EVENT_GENE_PS_BUGCREATE_FAILED        0xC402
#define EVENT_GENE_PS_SEARCH_FAILED              0xC403
#define EVENT_GENE_PS_BUGCLOSE_FAILED          0xC404
#define EVENT_GENE_PS_BUGUPDATE_FAILED        0xC405
#define EVENT_GENE_PS_BUGRESOLVE_FAILED      0xC406
#define EVENT_GENE_PS_BUGREOPEN_FAILED        0xC407
#define EVENT_GENE_PS_BUGVALIDATE_FAILED     0xC408
#define EVENT_GENE_PS_BUGEDIT_FAILED             0xC409
#define EVENT_GENE_PS_BUGREAD_FAILED            0xC40A
DATE GetUTCDate()
{
    UDATE ud;
    DWORD dwFlags;
    HRESULT hr = S_OK;
    DATE dt = 0;

    GetSystemTime(&ud.st);
    ud.wDayOfYear = 0;
    dwFlags = 0;

    hr = VarDateFromUdate(&ud, dwFlags, &dt);
    if(FAILED(hr))
        goto Exit;

Exit:
    return dt;
}

bool CheckValid(ProductStudio::IFieldsPtr &fields, DWORD dwBugID, const CHAR *szSerial = 0);

CProductStudioInterface::CProductStudioInterface()
{
    ProductStudio::INodePtr pRootNode, pTemp;
    ProductStudio::INodesPtr pNodes;
    HRESULT hr = S_OK;
    CComVariant vt;
    CComBSTR bs;
    m_lTreeNodeId = -1;

    try
    {
        hr = m_pDirectory.CreateInstance(ProductStudio::CLSID_Directory);
        if(FAILED(hr))
        {
            LogEvent(EVENTLOG_ERROR_TYPE, EVENT_GENE_PS_CRITICAL_FAILURE, "Failed to create a ProductStudio::IDirectory instance.  Error code: 0x%08x", hr);
            goto Cleanup;
        }
        hr = m_pDirectory->Connect(0, 0, 0);
        if(FAILED(hr))
        {
            LogEvent(EVENTLOG_ERROR_TYPE, EVENT_GENE_PS_CRITICAL_FAILURE, "Could not connect to the ProductStudio Directory.  Error code: 0x%08x", hr);
            goto Cleanup;
        }
        hr = m_pDirectory->GetProductByName(bs = g_szProductStudioStore, &m_pXboxOnline);
        if(FAILED(hr))
        {
            LogEvent(EVENTLOG_ERROR_TYPE, EVENT_GENE_PS_CRITICAL_FAILURE, "Could not get the product \"%s\" from the ProductStudio Directory.  Error code: 0x%08x", (const CHAR *) g_szProductStudioStore, hr);
            goto Cleanup;
        }
        hr = m_pXboxOnline->Connect(0, 0, 0, &m_pDatastore);
        if(FAILED(hr))
        {
            LogEvent(EVENTLOG_ERROR_TYPE, EVENT_GENE_PS_CRITICAL_FAILURE, "Could not get connect to the product store \"%s\".  Error code: 0x%08x", (const CHAR *) g_szProductStudioStore, hr);
            goto Cleanup;
        }

        hr = m_pStoreList.CreateInstance(ProductStudio::CLSID_DatastoreItemList);
        if(FAILED(hr))
        {
            LogEvent(EVENTLOG_ERROR_TYPE, EVENT_GENE_PS_CRITICAL_FAILURE, "Could not create a ProductStudio::DatastoreItemList instance.  Error code: 0x%08x", hr);
            goto Cleanup;
        }

        hr = m_pStoreList->putref_Datastore(m_pDatastore);
        if(FAILED(hr))
        {
            LogEvent(EVENTLOG_ERROR_TYPE, EVENT_GENE_PS_CRITICAL_FAILURE, "Failed to set the datastore on the DatastoreItemList.  Error code: 0x%08x", hr);
            goto Cleanup;
        }

        hr = m_pStoreList->CreateBlank(ProductStudio::psDatastoreItemTypeBugs);
        if(FAILED(hr))
        {
            LogEvent(EVENTLOG_ERROR_TYPE, EVENT_GENE_PS_CRITICAL_FAILURE, "Failed to create a blank store list.  Error code: 0x%08x", hr);
            goto Cleanup;
        }
        
        hr = m_pStoreList->get_DatastoreItems(&m_pBugs);        
        if(FAILED(hr))
        {
            LogEvent(EVENTLOG_ERROR_TYPE, EVENT_GENE_PS_CRITICAL_FAILURE, "Failed to retrieve the store list.  Error code: 0x%08x", hr);
            goto Cleanup;
        }

        hr = m_pDatastore->get_RootNode(&pRootNode);
        if(FAILED(hr))
        {
            LogEvent(EVENTLOG_ERROR_TYPE, EVENT_GENE_PS_CRITICAL_FAILURE, "Failed to retrieve the root node from the datastore.  Error code: 0x%08x", hr);
            goto Cleanup;
        }

        hr = pRootNode->get_Nodes(&pNodes);
        if(FAILED(hr))
        {
            LogEvent(EVENTLOG_ERROR_TYPE, EVENT_GENE_PS_CRITICAL_FAILURE, "Failed to retrieve the list of nodes from the root node.  Error code: 0x%08x", hr);
            goto Cleanup;
        }

        vt = L"Customer Service";
        hr = pNodes->get_Item(vt, &pTemp);
        if(FAILED(hr))
        {
            LogEvent(EVENTLOG_ERROR_TYPE, EVENT_GENE_PS_CRITICAL_FAILURE, "Failed to find the \"Customer Service\" branch in the list of nodes.  Error code: 0x%08x", hr);
            goto Cleanup;
        }
        hr = pTemp->get_ID(&m_lTreeNodeId);
        if(FAILED(hr))
        {
            LogEvent(EVENTLOG_ERROR_TYPE, EVENT_GENE_PS_CRITICAL_FAILURE, "Failed to retrieve the ID of  the \"Customer Service\" branch in the list of nodes.  Error code: 0x%08x", hr);
            goto Cleanup;
        }
    }
    catch(...)
    {
        LogEvent(EVENTLOG_ERROR_TYPE, EVENT_GENE_PS_CRITICAL_FAILURE, "An exception occurred while initializing the connection to Product Studio.");
        hr = E_FAIL;
        goto Cleanup;
    }

Cleanup:
    if(FAILED(hr))
    {
        try
        {
            if(pTemp)
                pTemp.Release();
            if(pNodes)
                pNodes.Release();
            if(pRootNode)
                pRootNode.Release();
            if(m_pBugs)
                m_pBugs.Release();
            if(m_pStoreList)
                m_pStoreList.Release();
            if(m_pDatastore)
                m_pDatastore.Release();
            if(m_pXboxOnline)
                m_pXboxOnline.Release();
            m_pDirectory->Disconnect();
            if(m_pDirectory)
                m_pDirectory.Release();
        }
        catch(...)
        {
            LogEvent(EVENTLOG_ERROR_TYPE, EVENT_GENE_PS_CRITICAL_FAILURE, "An exception occurred while closing the connection to Product Studio.");
            hr = E_FAIL;
        }
    }
}

CProductStudioInterface::~CProductStudioInterface()
{
    HRESULT hr = S_OK;
    try
    {
        if(m_pBugs)
            m_pBugs.Release();
        if(m_pStoreList)
            m_pStoreList.Release();
        if(m_pDatastore)
            m_pDatastore.Release();
        if(m_pXboxOnline)
            m_pXboxOnline.Release();
        m_pDirectory->Disconnect();
        if(m_pDirectory)
            m_pDirectory.Release();
    }
    catch(...)
    {
        LogEvent(EVENTLOG_ERROR_TYPE, EVENT_GENE_PS_CRITICAL_FAILURE, "An exception occurred while closing the connection to Product Studio.");
        hr = E_FAIL;
    }
}

BOOL CProductStudioInterface::Connected()
{
    return m_pBugs;
}

HRESULT CProductStudioInterface::SetField(ProductStudio::IFieldsPtr& fields, CComVariant vtField, CComVariant vtValue)
{
    HRESULT hr = S_OK;
    ProductStudio::IFieldPtr field;
    try
    {
        hr = fields->get_Item(vtField, &field);
        if(FAILED(hr)) 
        {
            LogEvent(EVENTLOG_ERROR_TYPE, EVENT_GENE_PS_BUGREAD_FAILED, "SetField: Failed to retrieve the field \"%S\".  Error code: 0x%08x", vtField.bstrVal, hr);
            goto Cleanup;
        }
        hr = field->put_Value(vtValue);
        if(FAILED(hr)) 
        {
            LogEvent(EVENTLOG_ERROR_TYPE, EVENT_GENE_PS_BUGEDIT_FAILED, "SetField: Failed to place a value into the field \"%S\".  Error code: 0x%08x", vtField.bstrVal, hr);
            goto Cleanup;
        }
    }
    catch(...)
    {
        hr = E_FAIL;
    }

Cleanup:
    return hr;
}

HRESULT CProductStudioInterface::GetField(ProductStudio::IFieldsPtr& fields, CComVariant vtField, CComVariant &vtValue)
{
    HRESULT hr = S_OK;
    ProductStudio::IFieldPtr field;
    try
    {
        hr = fields->get_Item(vtField, &field);
        if(FAILED(hr))
        {
            LogEvent(EVENTLOG_ERROR_TYPE, EVENT_GENE_PS_BUGREAD_FAILED, "GetField: Failed to retrieve the field \"%S\".  Error code: 0x%08x", vtField.bstrVal, hr);
            goto Cleanup;
        }
        hr = field->get_Value(&vtValue);
        if(FAILED(hr))
        {
            LogEvent(EVENTLOG_ERROR_TYPE, EVENT_GENE_PS_BUGREAD_FAILED, "GetField: Failed to retrieve the value from the field \"%S\".  Error code: 0x%08x", vtField.bstrVal, hr);
            goto Cleanup;
        }
    }
    catch(...)
    {
        hr = E_FAIL;
    }

Cleanup:
    return hr;
}

DWORD CProductStudioInterface::CreateBug(const CHAR *szSerial, CComBSTR &bsDescription)
{
    ProductStudio::IDatastoreItemPtr bug;
    ProductStudio::IFieldsPtr fields;
    HRESULT hr;
    CComBSTR text;
    CComVariant vt;
    DWORD dwBugID = (DWORD) -1;

    if(!Connected())
        return (DWORD) -1;

    try
    {
        hr = m_pBugs->Add(0, ProductStudio::psApplyRulesAll, &bug);
        if(FAILED(hr))
        {
            LogEvent(EVENTLOG_ERROR_TYPE, EVENT_GENE_PS_BUGCREATE_FAILED, "CreateBug: Failed to add a new bug for serial number %s.  Error code: 0x%08x", szSerial, hr);
            goto Cleanup;
        }

        hr = bug->get_Fields(&fields);
        if(FAILED(hr))
        {
            LogEvent(EVENTLOG_ERROR_TYPE, EVENT_GENE_PS_BUGREAD_FAILED, "CreateBug: Failed to retrieve the fields for creating a new bug for serial number %s.  Error code: 0x%08x", szSerial, hr);
            goto Cleanup;
        }

        text = "Genealogy: SN-";
        text += szSerial;
        text += " cannot connect";
        hr = SetField(fields, "Title", (BSTR) text);
        if(FAILED(hr)) goto Cleanup;
        hr = SetField(fields, "TreeID", m_lTreeNodeId);
        if(FAILED(hr)) goto Cleanup;
        hr = SetField(fields, "Changed By", (const CHAR *) g_szIssueOwner);
        if(FAILED(hr)) goto Cleanup;
        hr = SetField(fields, "Severity", 2);
        if(FAILED(hr)) goto Cleanup;
        hr = SetField(fields, "Fix Priority", 2);
        if(FAILED(hr)) goto Cleanup;
        hr = SetField(fields, "Opened By", (const CHAR *) g_szIssueOwner);
        if(FAILED(hr)) goto Cleanup;
        hr = SetField(fields, "Assigned To", (const CHAR *) g_szIssueOwner);
        if(FAILED(hr)) goto Cleanup;
        hr = SetField(fields, "Issue Type", "Other");
        if(FAILED(hr)) goto Cleanup;
        hr = SetField(fields, "How Found", "XOC monitoring");
        if(FAILED(hr)) goto Cleanup;
        hr = SetField(fields, "Fix ETA", "2 Weeks");
        if(FAILED(hr)) goto Cleanup;
        hr = SetField(fields, "Description", (BSTR) bsDescription);
        if(FAILED(hr)) goto Cleanup;
        hr = SetField(fields, "Service Component", "Genealogy");
        if(FAILED(hr)) goto Cleanup;
        hr = SetField(fields, "OS", "N/A (Infrastructure)");
        if(FAILED(hr)) goto Cleanup;
/*        hr = SetField(fields, "Opened Date", GetUTCDate());
        if(FAILED(hr)) goto Cleanup;*/

        /*{
            ProductStudio::IFieldPtr pTemp;
            long dwIndex, dwCount;
            dwCount = fields->Count;
            for(dwIndex = 0; dwIndex < dwCount; ++dwIndex)
            {
                pTemp = fields->get_Item(vt = dwIndex);
                if(!EVAL(pTemp))
                    continue;
                text = pTemp->Name;
                vt = pTemp->IsRequired;
                vt.ChangeType(VT_BOOL);
                if(vt.boolVal)
                {
                    OutputDebugStringW(text);
                    OutputDebugStringW(L"\n");
                }
            }
        }*/

        if(!CheckValid(fields, 0, szSerial))
            goto Cleanup;

        hr = bug->Save(VARIANT_TRUE);
        if(FAILED(hr))
        {
            LogEvent(EVENTLOG_ERROR_TYPE, EVENT_GENE_PS_BUGCREATE_FAILED, "CreateBug: Failed to save the new bug for serial number %s.  Error code: 0x%08x", szSerial, hr);
            goto Cleanup;
        }

        hr = bug->get_ID((long *) &dwBugID);
        if(FAILED(hr))
        {
            LogEvent(EVENTLOG_ERROR_TYPE, EVENT_GENE_PS_BUGREAD_FAILED, "CreateBug: Failed to retrieve the bug ID for serial number %s.  Error code: 0x%08x", szSerial, hr);
            goto Cleanup;
        }
        return dwBugID;
    }
    catch(...)
    {
        goto Cleanup;
    }
Cleanup:
    return (DWORD) -1;
}

static CHAR szSelectBug[] = "<Query><Expression Column='ID' Operator='equals'><Number>%d</Number></Expression></Query>";

DWORD CProductStudioInterface::GetBug(DWORD dwBugID, ProductStudio::IBugPtr &bug)
{
    ProductStudio::IDatastoreItemPtr pItem;
    ProductStudio::IDatastoreItemListPtr pList;
    ProductStudio::IDatastoreItemsPtr pBugs;
    ProductStudio::IQueryPtr query;
    HRESULT hr;
    TSafeStr<127> szQuery;
    CComBSTR bs;

    szQuery.FormatText(szSelectBug, dwBugID);

    hr = pList.CreateInstance(ProductStudio::CLSID_DatastoreItemList);
    if(FAILED(hr))
    {
        LogEvent(EVENTLOG_ERROR_TYPE, EVENT_GENE_PS_BUGREAD_FAILED, "GetBug: Failed to create a ProductStudio::DatastoreItemList instance.  Error code: 0x%08x", hr);
        goto Cleanup;
    }
    hr = query.CreateInstance(ProductStudio::CLSID_Query);
    if(FAILED(hr))
    {
        LogEvent(EVENTLOG_ERROR_TYPE, EVENT_GENE_PS_BUGREAD_FAILED, "GetBug: Failed to create a ProductStudio::Query instance.  Error code: 0x%08x", hr);
        goto Cleanup;
    }

    hr = query->put_CountOnly(VARIANT_FALSE);
    if(FAILED(hr))
    {
        LogEvent(EVENTLOG_ERROR_TYPE, EVENT_GENE_PS_BUGREAD_FAILED, "GetBug: Failed to set the CountOnly flag on the query.  Error code: 0x%08x", hr);
        goto Cleanup;
    }
    hr = query->put_SelectionCriteria(bs = szQuery);
    if(FAILED(hr))
    {
        LogEvent(EVENTLOG_ERROR_TYPE, EVENT_GENE_PS_BUGREAD_FAILED, "GetBug: Failed to set the SelectionCriteria on the query.  Error code: 0x%08x", hr);
        goto Cleanup;
    }
    hr = pList->putref_Query(query);
    if(FAILED(hr))
    {
        LogEvent(EVENTLOG_ERROR_TYPE, EVENT_GENE_PS_BUGREAD_FAILED, "GetBug: Failed to set the query on the item list.  Error code: 0x%08x", hr);
        goto Cleanup;
    }
    hr = pList->putref_Datastore(m_pDatastore);
    if(FAILED(hr))
    {
        LogEvent(EVENTLOG_ERROR_TYPE, EVENT_GENE_PS_BUGREAD_FAILED, "GetBug: Failed to set the datastore on the item list.  Error code: 0x%08x", hr);
        goto Cleanup;
    }

    hr = pList->Execute();
    if(FAILED(hr))
    {
        LogEvent(EVENTLOG_ERROR_TYPE, EVENT_GENE_PS_BUGREAD_FAILED, "GetBug: Failed to execute the query on the list of bugs.  Error code: 0x%08x", hr);
        goto Cleanup;
    }

    hr = pList->get_DatastoreItems(&pBugs);
    if(FAILED(hr))
    {
        LogEvent(EVENTLOG_ERROR_TYPE, EVENT_GENE_PS_BUGREAD_FAILED, "GetBug: Failed to retrieve the matching bugs from the query.  Error code: 0x%08x", hr);
        goto Cleanup;
    }

    if(bug)
        bug.Release();
    hr = pBugs->get_ItemByID(dwBugID, &pItem);
    if(FAILED(hr))
    {
        LogEvent(EVENTLOG_ERROR_TYPE, EVENT_GENE_PS_BUGREAD_FAILED, "GetBug: Failed to retrieve the bug %d.  Error code: 0x%08x", dwBugID, hr);
        goto Cleanup;
    }

    hr = pItem.QueryInterface(ProductStudio::IID_IBug, &bug);
    if(FAILED(hr))
    {
        LogEvent(EVENTLOG_ERROR_TYPE, EVENT_GENE_PS_BUGREAD_FAILED, "GetBug: Failed to query the bug interface from the item returned for bug %d.  Error code: 0x%08x", dwBugID, hr);
        goto Cleanup;
    }
    return 0;
Cleanup:
    return (DWORD) -1;
}

DWORD CProductStudioInterface::CloseBug(DWORD dwBugID, CComBSTR &bsDescription)
{
    ProductStudio::IBugPtr bug;
    ProductStudio::IFieldsPtr fields;
    HRESULT hr;
    CComVariant vt;
    CComBSTR bs;

    if(GetBug(dwBugID, bug))
        goto Cleanup;

    hr = bug->get_Fields(&fields);
    if(FAILED(hr))
    {
        LogEvent(EVENTLOG_ERROR_TYPE, EVENT_GENE_PS_BUGREAD_FAILED, "CloseBug: Failed to retrieve the fields for bug %d.  Error code: 0x%08x", dwBugID, hr);
        goto Cleanup;
    }

    hr = GetField(fields, "Status", vt);
    if(FAILED(hr)) goto Cleanup;
    hr = vt.ChangeType(VT_BSTR);
    bs = vt.bstrVal;

    if(!wcscmp(bs, L"Active"))
    {
        hr = bug->Edit(ProductStudio::psBugEditActionResolve, bs = (const CHAR *) g_szIssueOwner, ProductStudio::psApplyRulesAll);
        if(FAILED(hr))
        {
            LogEvent(EVENTLOG_ERROR_TYPE, EVENT_GENE_PS_BUGRESOLVE_FAILED, "CloseBug: Failed to edit the bug %d to resolving.  Error code: 0x%08x", dwBugID, hr);
            goto Cleanup;
        }

        hr = SetField(fields, "Assigned To", (const CHAR *) g_szIssueOwner);
        if(FAILED(hr)) goto Cleanup;
        hr = SetField(fields, "Resolution", "Fixed");
        if(FAILED(hr)) goto Cleanup;
        hr = SetField(fields, "Cause", "Other");
        if(FAILED(hr)) goto Cleanup;
        hr = SetField(fields, "Change", "None");
        if(FAILED(hr)) goto Cleanup;

        if(!CheckValid(fields, dwBugID))
            goto Cleanup;
        
        hr = bug->Save(VARIANT_FALSE);
        if(FAILED(hr))
        {
            LogEvent(EVENTLOG_ERROR_TYPE, EVENT_GENE_PS_BUGRESOLVE_FAILED, "CloseBug: Failed to save the bug %d for resolving.  Error code: 0x%08x", dwBugID, hr);
            goto Cleanup;
        }
    }
    else if(!wcscmp(bs, L"Closed"))
    {
        return 0;
    }

    hr = bug->Edit(ProductStudio::psBugEditActionClose, bs = (const CHAR *) g_szIssueOwner, ProductStudio::psApplyRulesAll);
    if(FAILED(hr))
    {
        LogEvent(EVENTLOG_ERROR_TYPE, EVENT_GENE_PS_BUGCLOSE_FAILED, "CloseBug: Failed to edit the bug %d to closing.  Error code: 0x%08x", dwBugID, hr);
        goto Cleanup;
    }

    hr = SetField(fields, "Description", (BSTR) bsDescription);
    if(FAILED(hr)) goto Cleanup;

    if(!CheckValid(fields, dwBugID))
        goto Cleanup;

    hr = bug->Save(VARIANT_TRUE);
    if(FAILED(hr))
    {
        LogEvent(EVENTLOG_ERROR_TYPE, EVENT_GENE_PS_BUGCLOSE_FAILED, "CloseBug: Failed to save the bug %d for closing.  Error code: 0x%08x", dwBugID, hr);
        goto Cleanup;
    }

    return 0;
Cleanup:
    return (DWORD) -1;
}

DWORD CProductStudioInterface::UpdateBug(DWORD dwBugID, CComBSTR &bsDescription)
{
    ProductStudio::IBugPtr bug;
    ProductStudio::IFieldsPtr fields;
    HRESULT hr;
    CComVariant vt;
    CComBSTR bs;

    if(GetBug(dwBugID, bug))
        goto Cleanup;

    hr = bug->get_Fields(&fields);
    if(FAILED(hr))
    {
        LogEvent(EVENTLOG_ERROR_TYPE, EVENT_GENE_PS_BUGUPDATE_FAILED, "UpdateBug: Failed to retrieve the fields for bug %d.  Error code: 0x%08x", dwBugID, hr);
        goto Cleanup;
    }

    hr = GetField(fields, "Status", vt);
    if(FAILED(hr)) goto Cleanup;
    hr = vt.ChangeType(VT_BSTR);
    bs = vt.bstrVal;

    hr = bug->Edit(ProductStudio::psDatastoreItemEditActionEdit, bs = (const CHAR *) g_szIssueOwner, ProductStudio::psApplyRulesAll);
    if(FAILED(hr))
    {
        LogEvent(EVENTLOG_ERROR_TYPE, EVENT_GENE_PS_BUGUPDATE_FAILED, "UpdateBug: Failed to edit the bug %d.  Error code: 0x%08x", dwBugID, hr);
        goto Cleanup;
    }

    hr = SetField(fields, "Description", (BSTR) bsDescription);
    if(FAILED(hr)) goto Cleanup;

    if(!CheckValid(fields, dwBugID))
        goto Cleanup;

    hr = bug->Save(VARIANT_TRUE);
    if(FAILED(hr))
    {
        LogEvent(EVENTLOG_ERROR_TYPE, EVENT_GENE_PS_BUGUPDATE_FAILED, "UpdateBug: Failed to save the bug %d.  Error code: 0x%08x", dwBugID, hr);
        goto Cleanup;
    }

    return 0;
Cleanup:
    return (DWORD) -1;
}

DWORD CProductStudioInterface::ResolveBug(DWORD dwBugID, const CHAR *szResolution, CComBSTR &bsDescription)
{
    ProductStudio::IBugPtr bug;
    ProductStudio::IFieldsPtr fields;
    HRESULT hr;
    CComVariant vt;
    CComBSTR bs;

    if(GetBug(dwBugID, bug))
        goto Cleanup;

    hr = bug->get_Fields(&fields);
    if(FAILED(hr))
    {
        LogEvent(EVENTLOG_ERROR_TYPE, EVENT_GENE_PS_BUGRESOLVE_FAILED, "ResolveBug: Failed to retrieve the fields for bug %d.  Error code: 0x%08x", dwBugID, hr);
        goto Cleanup;
    }

    hr = GetField(fields, "Status", vt);
    if(FAILED(hr)) goto Cleanup;
    hr = vt.ChangeType(VT_BSTR);
    bs = vt.bstrVal;

    if(!wcscmp(bs, L"Active"))
    {
        hr = bug->Edit(ProductStudio::psBugEditActionResolve, bs = (const CHAR *) g_szIssueOwner, ProductStudio::psApplyRulesAll);
        if(FAILED(hr))
        {
            LogEvent(EVENTLOG_ERROR_TYPE, EVENT_GENE_PS_BUGRESOLVE_FAILED, "ResolveBug: Failed to resolve bug %d.  Error code: 0x%08x", dwBugID, hr);
            goto Cleanup;
        }
    }
    else if(!wcscmp(bs, L"Resolved"))
    {
        hr = bug->Edit(ProductStudio::psDatastoreItemEditActionEdit, bs = (const CHAR *) g_szIssueOwner, ProductStudio::psApplyRulesAll);
        if(FAILED(hr))
        {
            LogEvent(EVENTLOG_ERROR_TYPE, EVENT_GENE_PS_BUGRESOLVE_FAILED, "ResolveBug: Failed to edit resolved bug %d.  Error code: 0x%08x", dwBugID, hr);
            goto Cleanup;
        }
    }
    else
	{
		if((DWORD) -1 == ReopenBug(dwBugID, bs = "This bug was unexpectedly closed.  Reopening for resolving."))
			goto Cleanup;

        hr = bug->Edit(ProductStudio::psBugEditActionResolve, bs = (const CHAR *) g_szIssueOwner, ProductStudio::psApplyRulesAll);
        if(FAILED(hr))
        {
            LogEvent(EVENTLOG_ERROR_TYPE, EVENT_GENE_PS_BUGRESOLVE_FAILED, "ResolveBug: Failed to resolve bug %d.  Error code: 0x%08x", dwBugID, hr);
            goto Cleanup;
        }
    }
    
    hr = SetField(fields, "Assigned To", (const CHAR *) g_szIssueOwner);
    if(FAILED(hr)) goto Cleanup;
    hr = SetField(fields, "Resolution", szResolution);
    if(FAILED(hr)) goto Cleanup;
    hr = SetField(fields, "Cause", "Other");
    if(FAILED(hr)) goto Cleanup;
    hr = SetField(fields, "Change", "None");
    if(FAILED(hr)) goto Cleanup;
    hr = SetField(fields, "Description", (BSTR) bsDescription);
    if(FAILED(hr)) goto Cleanup;
    
    if(!CheckValid(fields, dwBugID))
        goto Cleanup;
    
    hr = bug->Save(VARIANT_TRUE);
    if(FAILED(hr))
    {
        LogEvent(EVENTLOG_ERROR_TYPE, EVENT_GENE_PS_BUGRESOLVE_FAILED, "ResolveBug: Failed to save bug %d for resolving.  Error code: 0x%08x", dwBugID, hr);
        goto Cleanup;
    }
    return 0;
Cleanup:
    return (DWORD) -1;
}

DWORD CProductStudioInterface::ReopenBug(DWORD dwBugID, CComBSTR &bsDescription)
{
    ProductStudio::IBugPtr bug;
    ProductStudio::IFieldsPtr fields;
    HRESULT hr;
    CComVariant vt;
    CComBSTR bs;

    if(GetBug(dwBugID, bug))
        goto Cleanup;

    hr = bug->get_Fields(&fields);
    if(FAILED(hr))
    {
        LogEvent(EVENTLOG_ERROR_TYPE, EVENT_GENE_PS_BUGREOPEN_FAILED, "ReopenBug: Failed to retrieve the fields for bug %d.  Error code: 0x%08x", dwBugID, hr);
        goto Cleanup;
    }

    hr = GetField(fields, "Status", vt);
    if(FAILED(hr)) goto Cleanup;
    hr = vt.ChangeType(VT_BSTR);
    bs = vt.bstrVal;

    hr = bug->Edit(ProductStudio::psBugEditActionActivate, bs = (const CHAR *) g_szIssueOwner, ProductStudio::psApplyRulesAll);
    if(FAILED(hr))
    {
        LogEvent(EVENTLOG_ERROR_TYPE, EVENT_GENE_PS_BUGREOPEN_FAILED, "ReopenBug: Failed to edit the bug %d for reopening.  Error code: 0x%08x", dwBugID, hr);
        goto Cleanup;
    }

    hr = SetField(fields, "Assigned To", (const CHAR *) g_szIssueOwner);
    if(FAILED(hr)) goto Cleanup;

    hr = SetField(fields, "Description", (BSTR) bsDescription);
    if(FAILED(hr)) goto Cleanup;

    bug->ClearDuplicate();
    if(!CheckValid(fields, dwBugID))
        goto Cleanup;
    
    hr = bug->Save(VARIANT_TRUE);
    if(FAILED(hr))
    {
        LogEvent(EVENTLOG_ERROR_TYPE, EVENT_GENE_PS_BUGREOPEN_FAILED, "ReopenBug: Failed to save the bug %d for reopening.  Error code: 0x%08x", dwBugID, hr);
        goto Cleanup;
    }

    return 0;
Cleanup:
    return (DWORD) -1;
}


bool CheckValid(ProductStudio::IFieldsPtr &fields, DWORD dwBugID, const CHAR *szSerial)
{
    long index = 0, count;
    bool good = true;
    ProductStudio::PsFieldStatusEnum validity;
    CComVariant vt;
    CComBSTR bs, msg;
    HRESULT hr;

    if(!g_dwValidatePSFields)
        return good;
        
    hr = fields->get_Count(&count);
    if(FAILED(hr)) 
    {
        LogEvent(EVENTLOG_ERROR_TYPE, EVENT_GENE_PS_BUGVALIDATE_FAILED, "Could not retrieve the count of fields for the bug.  Error code 0x%08x", index, hr);
        goto Cleanup;
    }

    for(index = 0; index < count; ++index)
    {
        ProductStudio::IFieldPtr field;
        hr = fields->get_Item(vt = index, &field);
        if(FAILED(hr)) 
        {
            LogEvent(EVENTLOG_ERROR_TYPE, EVENT_GENE_PS_BUGVALIDATE_FAILED, "Could not retrieve field with index %d.  Error code 0x%08x", index, hr);
            goto Cleanup;
        }
        hr = field->get_Name(&bs);
        if(FAILED(hr))
        {
            LogEvent(EVENTLOG_ERROR_TYPE, EVENT_GENE_PS_BUGVALIDATE_FAILED, "Could not retrieve the name of the field with index %d.  Error code 0x%08x", index, hr);
            goto Cleanup;
        }
        hr = field->get_Validity(&validity);
        if(FAILED(hr))
        {
            LogEvent(EVENTLOG_ERROR_TYPE, EVENT_GENE_PS_BUGVALIDATE_FAILED, "Could not retrieve the validity of the field \"%S\" with index %d.  Error code 0x%08x", (WCHAR *) bs, index, hr);
            goto Cleanup;
        }
        hr = field->get_Value(&vt);
        if(FAILED(hr))
        {
            LogEvent(EVENTLOG_ERROR_TYPE, EVENT_GENE_PS_BUGVALIDATE_FAILED, "Could not retrieve the value of the field \"%S\" with index %d.  Error code 0x%08x", (WCHAR *) bs, index, hr);
            goto Cleanup;
        }
        if(validity)
        {
            if(good)
            {
                if(dwBugID)
                {
                    msg = "The bug ";
                    vt = dwBugID;
                    vt.ChangeType(VT_BSTR);
                    msg += vt.bstrVal;
                    msg += " has the following invalid fields and will not be saved:\n";
                }
                else if(szSerial)
                {
                    msg = "The bug for serial number ";
                    msg += szSerial;
                    msg += " has the following invalid fields and will not be saved:\n";
                }
                else
                {
                    msg = "An unknown bug has the following invalid fields and will not be saved:\n";
                }
            }
            msg += bs;
            switch(validity)
            {
            case ProductStudio::psFieldStatusInvalidEmpty:
                msg += ": This field cannot be empty\n";
                break;
            case ProductStudio::psFieldStatusInvalidNotEmpty:
                msg += ": This field must be empty\n";
                break;
            case ProductStudio::psFieldStatusInvalidFormat:
                msg += ": This field has an invalid format\n";
                break;
            case ProductStudio::psFieldStatusInvalidListValue:
                msg += ": This field has an invalid list value\n";
                break;
            case ProductStudio::psFieldStatusInvalidOldValue:
                msg += ": This field has changed from a previous version\n";
                break;
            case ProductStudio::psFieldStatusInvalidNotOldValue:
                msg += ": This field has not changed from a previous version\n";
                break;
            case ProductStudio::psFieldStatusInvalidUnknown:
                msg += ": This field is invalid for an unknown reason\n";
                break;
            case ProductStudio::psFieldStatusInvalidDate:
                msg += ": This field has an invalid date value\n";
                break;
            case ProductStudio::psFieldStatusInvalidTooLong:
                msg += ": This data for this field is too long\n";
                break;
            case ProductStudio::psFieldStatusInvalidNegative:
                msg += ": This field contains a negative value\n";
                break;
            case ProductStudio::psFieldStatusInvalidType:
                msg += ": This field contains a value that cannot be converted to the correct type\n";
                break;
            default:
                msg += ": A completely unknown error occurred for this field\n";
                break;
            };
            good = false;
        }
    }

    if(!good)
    {
        LogEvent(EVENTLOG_ERROR_TYPE, EVENT_GENE_PS_BUGVALIDATE_FAILED, "%S", (WCHAR *) msg);
    }
Cleanup:
    if(FAILED(hr))
        good = false;
    return good;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\genealogy\geneadmin\service\PSConn.h ===
#pragma once

#include "dbconn.h"

#define DODECLARATIONS
#include "DBControl.h"

enum BUG_STATE
{
    BUG_Active,
    BUG_Resolved,
    BUG_Closed,
    BUG_Other
};

enum BUG_RESOLUTION
{
    BUG_ResNone,
    BUG_ResFixed,
    BUG_ResWontFix,
    BUG_ResPostponed,
    BUG_ResByDesign = BUG_ResPostponed,
    BUG_ResDuplicate,
    BUG_ResExternal,
    BUG_ResOther
};

/******************************************************************************
    CPSGetSNStatus Class
 ******************************************************************************/
// SELECT BugID, Status, ResolvedDate, Resolution FROM bugs WHERE Title LIKE ? AND EventID='50309' AND BugID > ? ORDER BY BugID

#define DEFGETSNSTATUS(stmt, jumpto)                                                \
    DEF_BINDPARAMSAFE_IN(stmt, 1, m_szSerial, 23, m_dwSerialLen, jumpto)            \
    DEF_BINDPARAM_IN(stmt, 2, DWORD, m_dwMinBugID, jumpto)                          \
    DEF_BINDCOL(stmt, 1, DWORD, m_dwBugID, m_optBugID, jumpto)                      \
    DEF_BINDCOLSEQ(stmt, 2, CHAR, m_szStatus, 40, m_dwStatusLen, jumpto)            \
    DEF_BINDCOL(stmt, 3, DBTIMESTAMP, m_dtResolved, m_optResolved, jumpto)          \
    DEF_BINDCOLSEQ(stmt, 4, CHAR, m_szRes, 40, m_dwResLen, jumpto)                  \
    DEF_BINDCOL(stmt, 5, DBTIMESTAMP, m_dtChanged, m_optChanged, jumpto)

class CPSGetSNStatus : public CDBConn
{
public:
    CPSGetSNStatus();
    ~CPSGetSNStatus() {}
    // Returns the number of rows found, parameters store the first encountered
    DWORD GetSNStatus(const CHAR *szSerial, DWORD &dwBugID, BUG_STATE &bsState, DBTIMESTAMP &stResolved, BUG_RESOLUTION &brResolution);

    DEFGETSNSTATUS(0, 0);
};

/******************************************************************************
    CPSGetBugStatus Class
 ******************************************************************************/
// SELECT Status, ResolvedDate, Resolution FROM bugs WHERE BugID=?

#define DEFGETBUGSTATUS(stmt, jumpto)                                               \
    DEF_BINDPARAM_IN(stmt, 1, DWORD, m_dwBugID, jumpto)                             \
    DEF_BINDCOLSEQ(stmt, 1, CHAR, m_szStatus, 40, m_dwStatusLen, jumpto)            \
    DEF_BINDCOL(stmt, 2, DBTIMESTAMP, m_dtResolved, m_optResolved, jumpto)          \
    DEF_BINDCOLSEQ(stmt, 3, CHAR, m_szRes, 40, m_dwResLen, jumpto)

class CPSGetBugStatus : public CDBConn
{
public:
    CPSGetBugStatus();
    ~CPSGetBugStatus() {}
    // Returns the number of rows found, parameters store the first encountered
    DWORD GetBugStatus(DWORD dwBugID, BUG_STATE &bsState, DBTIMESTAMP &stResolved, BUG_RESOLUTION &brResolution);

    DEFGETBUGSTATUS(0, 0);
};

class CPSConnection
{
public:
    CPSConnection() {}
    ~CPSConnection() {}

    CPSGetBugStatus bug;
    CPSGetSNStatus sn;
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\genealogy\geneadmin\service\PSConn.cpp ===
#include "stdafx.h"
#include "critsect.h"
#include "psconn.h"

// TEST_AND_JUMP
#define TAJ(stmt, dest) if(stmt) { /* Log an event */ goto dest;}

BUG_STATE MapStatus(CHAR *szState);
BUG_RESOLUTION MapResolution(CHAR *szRes);

/******************************************************************************
    CPSGetSNStatus Class
 ******************************************************************************/
static CHAR szSNStatusQuery[] = "SELECT BugID, Status, ResolvedDate, Resolution FROM bugs WHERE Title LIKE ? AND EventID='50309' AND BugID > ? ORDER BY BugID";

#define DOINITIALIZATION
#include "DBControl.h"


CPSGetSNStatus::CPSGetSNStatus()
{
    DEFGETSNSTATUS(0, 0);
}

#define DOBINDINGS
#include "DBControl.h"

DWORD CPSGetSNStatus::GetSNStatus(const CHAR *szSerial, DWORD &dwBugID, BUG_STATE &bsState, DBTIMESTAMP &stResolved, BUG_RESOLUTION &brResolution)
{
    BOOL fLast;
    DWORD dwCount = 0;
    BOOL fFound = FALSE;

    if(!Connected() && !Connect(g_szProductStudioMachine, g_szProductStudioDatabase, szSNStatusQuery))
        return (DWORD) -1;

    if(!m_fBound)
    {
        DEFGETSNSTATUS(m_hStmt, Cleanup);
        m_szSerial.AllowTruncate(FALSE);
    }
    m_fBound = TRUE;

    m_szSerial = "%";
    m_szSerial += szSerial;
    m_szSerial += '%';
    m_dwSerialLen = m_szSerial.Length();
    m_dwMinBugID = dwBugID;
    DBStmtCloseCursor(m_hStmt);
    if(!DBStmtExecute(m_hStmt))
    {
        m_fBound = FALSE;
        goto Cleanup;
    }

    m_optResolved = sizeof(DBTIMESTAMP);
    m_optChanged = sizeof(DBTIMESTAMP);
    while(DBStmtFetch(m_hStmt, fLast))
    {
        if(!fFound)
        {
            dwBugID = m_dwBugID;
            if(DB_NULL_DATA != m_optResolved)
                memcpy(&stResolved, &m_dtResolved, sizeof(DBTIMESTAMP));
            else
                memset(&stResolved, 0, sizeof(DBTIMESTAMP));
            bsState = MapStatus(m_szStatus);
            if(BUG_Active == bsState)
                brResolution = BUG_ResNone;
            else
                brResolution = MapResolution(m_szRes);
            fFound = TRUE;
            if(BUG_ResDuplicate == brResolution)
                fFound = FALSE;
            ++dwCount;
        }
        m_optResolved = sizeof(DBTIMESTAMP);
        m_optChanged = sizeof(DBTIMESTAMP);
    }

    if(!fLast)
        return (DWORD) -1;

    return dwCount;

Cleanup:
    if(!m_fBound)
    {
        Disconnect();
    }
    return (DWORD) -1;
}

/******************************************************************************
    CPSGetBugStatus Class
 ******************************************************************************/
static CHAR szBugStatusQuery[] = "SELECT Status, ResolvedDate, Resolution FROM bugs WHERE BugID=?";

#define DOINITIALIZATION
#include "DBControl.h"


CPSGetBugStatus::CPSGetBugStatus()
{
    DEFGETBUGSTATUS(0, 0);
}

#define DOBINDINGS
#include "DBControl.h"

DWORD CPSGetBugStatus::GetBugStatus(DWORD dwBugID, BUG_STATE &bsState, DBTIMESTAMP &stResolved, BUG_RESOLUTION &brResolution)
{
    BOOL fLast;
    DWORD dwCount = 0;

    if(!Connected() && !Connect(g_szProductStudioMachine, g_szProductStudioDatabase, szBugStatusQuery))
        return (DWORD) -1;

    if(!m_fBound)
    {
        DEFGETBUGSTATUS(m_hStmt, Cleanup);
    }
    m_fBound = TRUE;

    m_dwBugID = dwBugID;
    DBStmtCloseCursor(m_hStmt);
    if(!DBStmtExecute(m_hStmt))
    {
        m_fBound = FALSE;
        goto Cleanup;
    }

    while(DBStmtFetch(m_hStmt, fLast))
    {
        if(!dwCount)
        {
            if(DB_NULL_DATA != m_optResolved)
                memcpy(&stResolved, &m_dtResolved, sizeof(DBTIMESTAMP));
            else
                memset(&stResolved, 0, sizeof(DBTIMESTAMP));
            bsState = MapStatus(m_szStatus);
            brResolution = MapResolution(m_szRes);
        }
        ++dwCount;
    }

    if(!fLast)
        return (DWORD) -1;

    return dwCount;

Cleanup:
    if(!m_fBound)
    {
        Disconnect();
    }
    return (DWORD) -1;
}

BUG_STATE MapStatus(CHAR *szState)
{
    BUG_STATE bs;

    if(!_stricmp(szState, "Active"))
        bs = BUG_Active;
    else if(!_stricmp(szState, "Resolved"))
        bs = BUG_Resolved;
    else if(!_stricmp(szState, "Closed"))
        bs = BUG_Closed;
    else
        bs = BUG_Other;

    return bs;
}

BUG_RESOLUTION MapResolution(CHAR *szRes)
{
    BUG_RESOLUTION br;
    if(!_stricmp(szRes, "Fixed"))
        br = BUG_ResFixed;
    else if(!_stricmp(szRes, "Postponed"))
        br = BUG_ResPostponed;
    else if(!_stricmp(szRes, "Won't Fix"))
        br = BUG_ResWontFix;
    else if(!_stricmp(szRes, "By Design"))
        br = BUG_ResByDesign;
    else if(!_stricmp(szRes, "Duplicate"))
        br = BUG_ResDuplicate;
    else if(!_stricmp(szRes, "External"))
        br = BUG_ResExternal;
    else
        br = BUG_ResOther;

    return br;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\genealogy\geneadmin\service\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by geneadmin.rc
//
#define IDS_SERVICENAME                 100
#define IDR_Geneadmin                   100
#define IDR_MANAGE                      101
#define IDD_DIALOG1                     201

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        202
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           102
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\genealogy\geneadmin\service\psthread.h ===
#pragma once

unsigned __stdcall fnProductStudioWorkerThread(void *);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\genealogy\geneadmin\service\psthread.cpp ===
#include "stdafx.h"

#include "psconn.h"
#include "dbconn.h"
#include "pscom.h"
#pragma warning( disable : 4702 )
#include <set>
#pragma warning( error : 4702 )

/* Objectives: 
    1. Go through the list of bugs with zero as their bug id and see if a bug has been
        created for this serial number yet
    2. Check the status of bugs versus the time and date of event occurrences
    3. **Create a bug if a serial number isn't found
    4. **Reactivate a closed bug if the event is after the closure date
    5. **Reactivate a resolved bug if:
            a) The bug is resolved fixed and the bug event time is > 1 days after the resolved date
            b) The bug is resolved postponed and their is a new feed since resolution with the same
                online key
            c) The bug is resolved postponed, a new feed has occurred since then, and the event has
                fired after > 1 days after the feed (resolution date < feed date < latest event date)
    6. **The bug is resolved postponed and there is a new feed with a different online key
        update the bug indicating the first 8 characters of the new key

  **'ed entries are todo's if possible since they require modifying the database.  We can incorporate
  the logic for a web page though:
    CurrentState mapping in GeneFailures table:
        0: Investigate
        1: Bug needs to be created
        2: Bug created and active
        3: Bug resolved fixed--waiting for confirmation
        4: Bug resolved fixed--bug needs reopened since event fired > 1 day after resolution date
        5: Bug resolved won't fix--ignore
        6: Bug resolved postponed--waiting for new feed
        7: Bug resolved postponed--bug needs reactivated--new feed had same online key
        8: Bug resolved postponed--new feed seen with new key--waiting for confirmation
        9: Bug resolved postponed--new feed seen with new key--resolved date + 2 < feed date + 1 < event date
        10: Bug closed--treat as Bug resolved fixed
        11: Bug closed--treat as Bug resolved won't fix
        12: Bug active--new feed came in--check to see if machine account created
        13: Bug can be closed--UODB account created since last failure
        14: Bug active--new feed came in--no new keys
        15: Bug active--update with new production information
        0x100 + state: More than one bug exists for this serial number

  Postponed and By Design are treated the same.
*/

class CDBPSCollection
{
public:
    CDBFailedSet eventFailures;
    CDBFeedRows feedRows;
    CDBGetFeedFailed feedFailed;

    CDBUpdateFailure updateEvent;
    CDBGetNewKeyCount keyCount;

    CDBGetProdRows prodFeedRows;
    CDBGetProdErrors prodFeedErrors;

    CDBSetLastProdUpdateDate updateFailedProdDate;

    CDBGetSNByBugID getSNByBugID;
};

void DEBUG_OUT(const char *szFmt, ...)
{
    va_list vargs;
    CHAR szBuf[1024];
    va_start(vargs, szFmt);
    _vsnprintf(szBuf, sizeof(szBuf) - 1, szFmt, vargs);
    szBuf[sizeof(szBuf) - 1] = 0;
    OutputDebugString(szBuf);
    va_end(vargs);
}

void ProcessFailed(CProductStudioInterface &PSBugMgr, HANDLE hEndThreadEvent);
BOOL ProcessRow(CDBPSCollection& DB, CPSConnection& PS, CProductStudioInterface& PSBugMgr);

enum SN_STATE
{
    SN_Investigate,
    SN_NeedsToBeCreated,                       // Create the bug
    SN_Active,
    SN_ResolvedFixed,
    SN_ResFixedReopen,                          // Reactivate the bug
    SN_ResolvedWontFix,                         // Close the bug
    SN_ResolvedPostpone,
    SN_ResPostponeReopen,                   // Reactivate the bug
    SN_ResPostponeNewKey,
    SN_ResPostponeNewKeyReopen,         // Duplicate key reactivate
    SN_Closed,
    SN_ClosedWontFix,
    SN_ActiveNewFeed,                           // Resolve fixed and update
    SN_BugCanBeClosed,                      // Close the bug
    SN_ActiveNewFeedNoNewKeys,       // Activate the bug and update
    SN_ActiveUpdateBug,
	SN_ResolvedExternal,
};

unsigned __stdcall fnProductStudioWorkerThread(void *)
{
    HANDLE hEndThreadEvent = INVALID_HANDLE_VALUE;
    bool bFirst = true;
    DWORD dwTimeout, dwIndex;
    CProductStudioInterface PSBugMgr;

    // Hook up to the end service event
    hEndThreadEvent = _Module.EndThreadEvent();

    while(!(g_dwDisableThreads & PS_THREAD))
    {
        if(!bFirst)
        {
            if(!g_dwFeedCopyFrequency)
                dwTimeout = 20 * 60 * 1000;
            else
                dwTimeout = g_dwFeedCopyFrequency * 60 * 1000;
            dwIndex = WaitForSingleObject(hEndThreadEvent, dwTimeout);
            if(WAIT_OBJECT_0 == dwIndex)
                break;
        }

        bFirst = false;
        if(PSBugMgr.Connected())
            ProcessFailed(PSBugMgr, hEndThreadEvent);
    }

    _Module.ThreadCompleting();
    return 0;
}

void ProcessFailed(CProductStudioInterface& PSBugMgr, HANDLE hEndThreadEvent)
{
    CPSConnection PS;
    CDBPSCollection DB;

    {
        if(!PSBugMgr.Connected())
            goto Cleanup;
        if(!DB.eventFailures.Start())
            goto Cleanup;

        while(DB.eventFailures.GetNext())
        {
            if(WAIT_OBJECT_0 == WaitForSingleObject(hEndThreadEvent, 0))
                break;

            if(!ProcessRow(DB, PS, PSBugMgr))
                break;
        }
    }

Cleanup:
    ;
}

class Key
{
public:
    Key() {memset(m_key, 0, sizeof(m_key));}
    ~Key() {}
    Key(const Key& key) {strcpy_s(m_key, _countof(m_key), key.m_key);};

    Key& operator=(const CHAR *key) {strncpy(m_key, key, 12); m_key[12] = 0; return *this;}
    Key& operator=(const Key& key) {strcpy_s(m_key, _countof(m_key), key.m_key); return *this;}
    operator const CHAR *() const {return m_key;}

    bool operator<(const Key& key) const {return strcmp(m_key, key.m_key) < 0;} 
    bool operator==(const Key& key) const {return strcmp(m_key, key.m_key) == 0;}
    bool operator>(const Key& key) const {return strcmp(m_key, key.m_key) > 0;}
    bool operator!=(const Key& key) const {return strcmp(m_key, key.m_key) != 0;}
    bool operator<=(const Key& key) const {return strcmp(m_key, key.m_key) < 1;}
    bool operator>=(const Key& key) const {return strcmp(m_key, key.m_key) > -1;}

protected:
    CHAR m_key[13];
};


bool Exists(std::set<Key>& keys, Key key)
{
    std::set<Key>::iterator end, iter;
    end = keys.end();
    for(iter = keys.begin(); iter != end; iter++)
    {
        if(key == *iter)
            return true;
    }
    return false;
}

BOOL ProcessRow(CDBPSCollection& DB, CPSConnection& PS, CProductStudioInterface& PSBugMgr)
{
    BOOL fSuccess = FALSE;
    BOOL fUpdate = FALSE;
    BUG_STATE bs;
    BUG_RESOLUTION br;
    DBTIMESTAMP st;
    DWORD dwCount, dwFeedRows, dwFeedErr1, dwSNsUsingBugID;
    DWORD dwOldBugID = DB.eventFailures.m_dwBugID;
    DWORD dwOldState = DB.eventFailures.m_dwState;
    Key key;
    std::set<Key> rgKeys;
    std::set<Key>::iterator end, iter;
    bool fNewKey = false, fNewFeed = false, fFailedRow = false;
    CComBSTR bsDesc = "";
    TSafeStr<256> szLine;
    TSafeStr<21> szSerial;

    // If we don't have a bug id, we need to find out if one exists
    if(!DB.eventFailures.m_dwBugID)
    {
        // Search to see if a bug exists in the database.  If there does exist one in the database and it is assigned to 
        // some other serial number, search again.
        dwCount = PS.sn.GetSNStatus(DB.eventFailures.m_szSerial, DB.eventFailures.m_dwBugID, bs, st, br);
        while(dwCount && (DWORD) -1 != dwCount)
        {
            dwSNsUsingBugID = DB.getSNByBugID.GetSNByBugID(DB.eventFailures.m_dwBugID, szSerial);
            if((DWORD) -1 == dwSNsUsingBugID)
                goto Cleanup;
            if(!dwSNsUsingBugID)        // If there is a serial number that is using this bug, it shouldn't be the serial # I'm looking at.
                break;
            dwCount = PS.sn.GetSNStatus(DB.eventFailures.m_szSerial, DB.eventFailures.m_dwBugID, bs, st, br);
        }
        if((DWORD) -1 == dwCount)   // Error?
            goto Cleanup;

        if(dwCount)                 // We found one, we will do further processing below
        {
            fUpdate = TRUE;
        }
        if(!dwCount)                // No bugs found, mark the state and update
        {
            if(SN_Investigate == DB.eventFailures.m_dwState /* && DB_NULL_DATA != DB.eventFailures.m_optProd*/)    // Only if the bug is in investigate mode // and production had a new query done
            {
                int check = 0;
                int failed = 0;
                szLine.FormatText("The most recent failure date for this serial number is: %04d/%02d/%02d %02d:%02d:%02d\n\n", DB.eventFailures.m_dtLast.year, DB.eventFailures.m_dtLast.month, DB.eventFailures.m_dtLast.day,
                                    DB.eventFailures.m_dtLast.hour, DB.eventFailures.m_dtLast.minute, DB.eventFailures.m_dtLast.second);
                bsDesc += (const CHAR *) szLine;

                DB.eventFailures.m_dwState = SN_NeedsToBeCreated;
                /*** Go through our internal feed table to look for records ***/
                if(!DB.feedRows.Start(DB.eventFailures.m_szSerial))
                    goto Cleanup;
                dwFeedRows = 0;
                while(DB.feedRows.GetNext())
                {
                    if(!dwFeedRows)
                        bsDesc += "This serial number appears in the following feeds:\n";

                    key = DB.feedRows.m_szKey;
                    rgKeys.insert(key);
                    szLine.FormatText("%04d/%02d/%02d: %s %s (%s)\n", DB.feedRows.m_dtFileDate.year, DB.feedRows.m_dtFileDate.month, DB.feedRows.m_dtFileDate.day,
                                                        DB.feedRows.m_szPartNo, DB.feedRows.m_szKey, DB.feedRows.m_szFileName);

                    bsDesc += (const CHAR *) szLine;
                    ++dwFeedRows;
                }

                if(!dwFeedRows)
                    bsDesc += "This serial number does not appear in any feeds with good rows.\n";

                bsDesc += "\n";

                /*** Go through our internal error table and look for records ***/
                if(!DB.feedFailed.Start(DB.eventFailures.m_szSerial))
                    goto Cleanup;
                dwFeedErr1 = 0;
                while(DB.feedFailed.GetNext())
                {
                    if(!dwFeedErr1)
                        bsDesc += "This serial number appears in the following feeds with errors:\n";

                    szLine.FormatText("%04d/%02d/%02d (%s): %s \n", DB.feedFailed.m_dtFailed.year, DB.feedFailed.m_dtFailed.month, DB.feedFailed.m_dtFailed.day,
                                                        DB.feedFailed.m_szFile, DB.feedFailed.m_szDesc);

                    bsDesc += (const CHAR *) szLine;
                    ++dwFeedErr1;
                }

                if(!dwFeedErr1)
                    bsDesc += "This serial number did not have any errors from the feed.\n";
            
				bsDesc += "\n";

				// Check the serial number for validity
		#define SNDigit(x)	(DB.eventFailures.m_szSerial[x - 1] - 48)
				check = SNDigit(11) * 10 + SNDigit(12);
				if(check < 2 || check > 6 || 4 == check)
					failed |= 1;	// Factory field failed
				check = SNDigit(8);
				if(check < 1 || check > CurYear() - 2000)
					failed |= 2;	// Year field failed
				check = SNDigit(9) * 10 + SNDigit(10);
				if(check < 1 || check > 53)
					failed |= 4;	// Week field failed
				check = SNDigit(1) + SNDigit(2) + SNDigit(3) + SNDigit(4) + SNDigit(5) + SNDigit(6);
				check = 7 - (check % 7);
				if(check != SNDigit(7))
					failed |= 8;

				if(failed)
				{
					int p = 0;
					bsDesc += "This serial number is invalid.  It failed the fields: ";
					if(failed & 1)
					{
						bsDesc += "Factory";
						p = 1;
					}
					if(failed & 2)
					{
						if(p) bsDesc += ", Year";
						else  bsDesc += "Year";
						p = 1;
					}
					if(failed & 4)
					{
						if(p) bsDesc += ", Week";
						else  bsDesc += "Week";
						p = 1;
					}
					if(failed & 8)
					{
						if(p) bsDesc += ", Check Digit";
						else  bsDesc += "Check Digit";
					}
					bsDesc += "\n\n";
				}

                fUpdate = TRUE;
            }
            goto Update;
        }
    }
    else                            // This bug has a bug id, get the status of it
    {
        dwCount = PS.bug.GetBugStatus(DB.eventFailures.m_dwBugID, bs, st, br);
        if((DWORD) -1 == dwCount)
            goto Cleanup;
        if(!dwCount)            // Error occurred
            goto Cleanup;
        dwSNsUsingBugID = DB.getSNByBugID.GetSNByBugID(DB.eventFailures.m_dwBugID, szSerial);
        if((DWORD) -1 == dwSNsUsingBugID)
            goto Cleanup;
        if(dwSNsUsingBugID > 1)
        {
            DB.eventFailures.m_dwBugID = 0;
            DB.eventFailures.m_dwState = 0;
            if((DWORD) -1 == DB.updateEvent.UpdateFailure(DB.eventFailures.m_szSerial, DB.eventFailures.m_dwBugID, DB.eventFailures.m_dwState))
                goto Cleanup;
            
            fSuccess = TRUE;
            goto Cleanup;
        }
    }

    // If the serial number has successfully created an account since the last failure, close it out.
    if(bs != BUG_Closed && DB_NULL_DATA != DB.eventFailures.m_optAccount && CompareTime(DB.eventFailures.m_dtAccount, DB.eventFailures.m_dtLast) > 0)
    {
        szLine.FormatText("A machine account has been created on %04d/%02d/%02d %02d:%02d:%02d.\n", DB.eventFailures.m_dtAccount.year, DB.eventFailures.m_dtAccount.month, DB.eventFailures.m_dtAccount.day,
                    DB.eventFailures.m_dtAccount.hour, DB.eventFailures.m_dtAccount.minute, DB.eventFailures.m_dtAccount.second);
        bsDesc += (const CHAR *) szLine;
        DB.eventFailures.m_dwState = SN_BugCanBeClosed;
        goto Update;
    }

    switch(bs)
    {
    case BUG_Active:
        DB.eventFailures.m_dwState = SN_Active;
        break;
    case BUG_Resolved:
        {
            switch(br)
            {
            case BUG_ResWontFix:
                DB.eventFailures.m_dwState = SN_ResolvedWontFix;
                bsDesc += "This bug is closed.";
                break;
			case BUG_ResExternal:
				DB.eventFailures.m_dwState = SN_ResolvedExternal;
				break;
            case BUG_ResPostponed:
                DB.eventFailures.m_dwState = SN_ResolvedPostpone;
                break;
            default:
                DB.eventFailures.m_dwState = SN_ResolvedFixed;
                break;
            };
            break;
        }
    case BUG_Closed:
    case BUG_Other: // Treat as closed
        if(BUG_ResWontFix == br)
            DB.eventFailures.m_dwState = SN_ClosedWontFix;
        else
            DB.eventFailures.m_dwState = SN_Closed;
        break;
    };

    rgKeys.empty();

    switch(DB.eventFailures.m_dwState)
    {
    case SN_ResolvedWontFix:
    case SN_ClosedWontFix:
        goto Update;

    case SN_Active:
        {
            /*** Check to see if there are new production feeds ***/
            if(DB_NULL_DATA != DB.eventFailures.m_optProd && 
                (DB_NULL_DATA == DB.eventFailures.m_optBugProdUpd || CompareTime(DB.eventFailures.m_dtProd, DB.eventFailures.m_dtBugProdUpd) > 0))
            {
                if(!DB.prodFeedRows.Start(DB.eventFailures.m_szSerial))
                    goto Cleanup;
                
                dwFeedRows = 0;
                while(DB.prodFeedRows.GetNext())
                {
                    // If we have never updated the bug with production information or production rows have been updated since
                    if(DB_NULL_DATA == DB.eventFailures.m_optBugProdUpd || 
                        CompareTime(DB.prodFeedRows.m_dtLast, DB.eventFailures.m_dtBugProdUpd) > 0 || 
                        CompareTime(DB.prodFeedRows.m_dtSeq, DB.eventFailures.m_dtBugProdUpd) > 0)
                    {
                        if(!dwFeedRows)
                        {
                            if(DB_NULL_DATA == DB.eventFailures.m_optBugProdUpd)
                                bsDesc += "Production genealogy information:\n";
                            else
                                bsDesc += "Production genealogy information (only new records):\n";
                        }

        /*              // Used to diff between feeds and production
                        key = DB.prodFeedRows.m_szKey;
                        rgKeys.erase(key);
        */
                        szLine.FormatText("%04d/%02d/%02d: %s %s Seq: %d (%04d/%02d/%02d)\n", DB.prodFeedRows.m_dtLast.year, DB.prodFeedRows.m_dtLast.month, DB.prodFeedRows.m_dtLast.day, 
                                    DB.prodFeedRows.m_szPartNo, DB.prodFeedRows.m_szKey, DB.prodFeedRows.m_dwSeqNo, DB.prodFeedRows.m_dtSeq.year, DB.prodFeedRows.m_dtSeq.month, DB.prodFeedRows.m_dtSeq.day);
                        bsDesc += (const CHAR *) szLine;
                        ++dwFeedRows;
                    }
                }

                // If this is the first time we have received a response of no data, update the bug, otherwise do nothing.
                if(!dwFeedRows && DB_NULL_DATA == DB.eventFailures.m_optBugProdUpd)
                    bsDesc += "Production genealogy does not contain any successful records.\n";

                if(bsDesc.Length())
                    bsDesc += "\n";

                // Clear the update data if for some reason we couldn't update the database to indicate we are updating it.
                if((DWORD) -1 == DB.updateFailedProdDate.SetLastProdUpdateDate(DB.eventFailures.m_szSerial, DB.eventFailures.m_dtProd))
                {
                    OutputDebugStringA("Failed to update the last production update date.");
                    bsDesc.Empty();
                }
                else
                    DB.eventFailures.m_dwState = SN_ActiveUpdateBug;
                
                // Go through and see if there are any keys that were in the feeds but not in production to 
                // determine recommendation
                /*
                end = rgKeys.end();
                for(iter = rgKeys.begin(); iter != end; iter++)
                {
                    if(iter == rgKeys.begin())
                    {
                        bsDesc += "The following keys were found in the feeds and not in production.  Please ensure these keys are entered in production:\n";
                    }
                    bsDesc += (const CHAR *) *iter;
                    bsDesc += "\n";
                }

                if(!rgKeys.size())
                {
                    bsDesc += "All feed keys appear in production.  Assign to OpsIT to investigate.\n";
                }
                */
            }

            if(!DB.feedRows.Start(DB.eventFailures.m_szSerial))
            {
                goto Cleanup;
            }

            while(DB.feedRows.GetNext())
            {
                key = DB.feedRows.m_szKey;
                st = DB.feedRows.m_dtFileDate;
                ChangeTime(st, DF_DAY, 1);
                if(CompareTime(st, DB.eventFailures.m_dtLast) < 0)
                {
                    rgKeys.insert(key);
                }
                else
                {
                    fNewFeed = true;
                    if(!Exists(rgKeys, key))
                    {
                        fNewKey = true;
                    }
                }
            }

            if(!DB.feedFailed.Start(DB.eventFailures.m_szSerial))
                goto Cleanup;

            while(DB.feedFailed.GetNext())
            {
                if(CompareTime(DB.feedFailed.m_dtFailed, DB.eventFailures.m_dtLast) >= 0)
                {
                    fNewFeed = true;
                    fFailedRow = true;
                }
            }
            if(fNewFeed && fNewKey)
            {
                bsDesc += "A new feed has occurred for this serial number containing a new online key since it's last failure.\n";
                DB.eventFailures.m_dwState = SN_ActiveNewFeed;
            }
            else if(fNewFeed && !fNewKey)
            {
                bsDesc += "A new feed has occurred for this serial number since it's last failure, however, it doesn't introduce any new online keys.\n";
                DB.eventFailures.m_dwState = SN_ActiveNewFeedNoNewKeys;
            }

            if(fNewFeed && fFailedRow)
            {
                bsDesc += "This serial number appears in a new feed with an error.\n";
            }
        }
        goto Update;

    case SN_Closed:
        {
            // Reactivate the bug if there hasn't been an account created
            if(DB_NULL_DATA == DB.eventFailures.m_optAccount)
            {
                bsDesc += "This bug should not have been closed.  A machine account has not yet been created.";
                DB.eventFailures.m_dwState = SN_ResFixedReopen;
            }
            else if(CompareTime(DB.eventFailures.m_dtAccount, DB.eventFailures.m_dtLast) < 0)
            {
                bsDesc += "This bug should not have been closed.  The machine account is older than the last failure.";
                DB.eventFailures.m_dwState = SN_ResFixedReopen;
            }
        }
        goto Update;
        
    case SN_ResolvedFixed:
        {
            SYSTEMTIME now;
            DBTIMESTAMP dbNow;
            ChangeTime(st, DF_DAY, 1);
            GetSystemTime(&now);
            SystemTimeToDBTimestamp(now, dbNow);
            if(CompareTime(DB.eventFailures.m_dtLast, st) > 0 && 
                !DB.keyCount.GetNewKeyCount(DB.eventFailures.m_szSerial, DB.eventFailures.m_dtLast))  // If it failed over a day after the resolution and there aren't any new keys since the failure.
            {
                szLine.FormatText("This serial number failed again on: %04d/%02d/%02d %02d:%02d:%02d\n",
                    DB.eventFailures.m_dtLast.year, DB.eventFailures.m_dtLast.month, DB.eventFailures.m_dtLast.day, DB.eventFailures.m_dtLast.hour, DB.eventFailures.m_dtLast.minute, DB.eventFailures.m_dtLast.second);
                bsDesc += (const CHAR *) szLine;
                DB.eventFailures.m_dwState = SN_ResFixedReopen;
                goto Update;
            }
        }
        goto Update;

    case SN_ResolvedExternal:
    case SN_ResolvedPostpone:
        {
            {
                if(!DB.feedRows.Start(DB.eventFailures.m_szSerial))
                    goto Cleanup;

                while(DB.feedRows.GetNext())
                {
                    DBTIMESTAMP stFeedFileDate;

                    key = DB.feedRows.m_szKey;
                    stFeedFileDate = DB.feedRows.m_dtFileDate;
                    ChangeTime(stFeedFileDate, DF_DAY, 1);
                    // If the date of the feed is before the date of the last failures, insert the key into the list (list of keys that don't work)
                    if(CompareTime(stFeedFileDate, DB.eventFailures.m_dtLast) < 0)
                    {
                        rgKeys.insert(key);
                    }
                    // Otherwise this is a new feed row so let's make sure it's after when we resolved the bug otherwise we don't care about it
                    else if(CompareTime(stFeedFileDate, DB.feedRows.m_dtFileDate) < 0)
                    {
                        fNewFeed = true;
                        if(!Exists(rgKeys, key))
                            fNewKey = true;
                    }
                }

                if(!DB.feedFailed.Start(DB.eventFailures.m_szSerial))
                    goto Cleanup;

                while(DB.feedFailed.GetNext())
                {
                    // Make sure the feed row is after the failure date and after the resolution date.
                    if(CompareTime(DB.feedFailed.m_dtFailed, DB.eventFailures.m_dtLast) >= 0 && CompareTime(DB.feedFailed.m_dtFailed, st) >= 0)
                    {
                        fNewFeed = true;
                        fFailedRow = true;
                    }
                }
                if(fNewFeed && !fNewKey)
                {
                    bsDesc += "This serial number appeared in a new feed, but no new keys appeared.\n\nThis serial number will still fail.\n";
                    DB.eventFailures.m_dwState = SN_ResPostponeReopen;
                }
                else if(fNewFeed && fNewKey)
                {
                    bsDesc += "This serial number appeared in a new feed with a new key.\nWaiting to see if this fixes the user's problem.\n";
                    DB.eventFailures.m_dwState = SN_ResPostponeNewKey;
                }

                if(fNewFeed && fFailedRow)
                {
                    bsDesc += "This serial number appears in a new feed with an error.\n";
                    DB.eventFailures.m_dwState = SN_ResPostponeReopen;
                }

                ChangeTime(st, DF_DAY, 7);
                if(CompareTime(DB.eventFailures.m_dtLast, st) > 0 && SN_ResolvedPostpone == DB.eventFailures.m_dwState)
                {
                    bsDesc += "This serial number has failed after 7 days of being postponed.\n";
                    DB.eventFailures.m_dwState = SN_ResPostponeReopen;
                }
            }
        }
        goto Update;
    };

Update:
    // if(dwCount > 1) DB.eventFailures.m_dwState += 0x100;
    if(dwOldBugID != DB.eventFailures.m_dwBugID || dwOldState != DB.eventFailures.m_dwState) 
        fUpdate = TRUE;
    else
        fUpdate = FALSE;

    if(fUpdate)
    {
        fUpdate = FALSE;
        switch(DB.eventFailures.m_dwState)
        {
        case SN_NeedsToBeCreated:            // Create the bug in product studio
            if(bsDesc.Length() && (DWORD) -1 == (DB.eventFailures.m_dwBugID = PSBugMgr.CreateBug(DB.eventFailures.m_szSerial, bsDesc)))
                goto Cleanup;
            DB.eventFailures.m_dwState = SN_Active;
            fUpdate = TRUE;
            break;
        case SN_ActiveUpdateBug:
            if(bsDesc.Length() && (DWORD) -1 == PSBugMgr.UpdateBug(DB.eventFailures.m_dwBugID, bsDesc))
                goto Cleanup;
            DB.eventFailures.m_dwState = SN_Active;
            fUpdate = TRUE;
            break;
        case SN_ResFixedReopen:              // Reopen the bug and indicate the user failed to connect again
            if(bsDesc.Length() && (DWORD) -1 == PSBugMgr.ReopenBug(DB.eventFailures.m_dwBugID, bsDesc))
                goto Cleanup;
            DB.eventFailures.m_dwState = SN_Active;
            fUpdate = TRUE;
            break;
        case SN_ResolvedWontFix:             // Close the bug
            if(bsDesc.Length() && (DWORD) -1 == PSBugMgr.CloseBug(DB.eventFailures.m_dwBugID, bsDesc))
                goto Cleanup;
            DB.eventFailures.m_dwState = SN_ClosedWontFix;
            fUpdate = TRUE;
            break;
        case SN_ResPostponeReopen:           // Reopen the bug since the new feed contains no new keys--might be able to research
            if(bsDesc.Length() && (DWORD) -1 == PSBugMgr.ReopenBug(DB.eventFailures.m_dwBugID, bsDesc))
                goto Cleanup;
            DB.eventFailures.m_dwState = SN_Active;
            fUpdate = TRUE;
            break;
        case SN_ResPostponeNewKeyReopen:     // A new key appeared in the feed, but the user still cannot connect--might be able to research
            if(bsDesc.Length() && (DWORD) -1 == PSBugMgr.ReopenBug(DB.eventFailures.m_dwBugID, bsDesc))
                goto Cleanup;
            DB.eventFailures.m_dwState = SN_Active;
            fUpdate = TRUE;
            break;
        case SN_ResPostponeNewKey:
        case SN_ActiveNewFeed:               // Update the bug to indicate that new feed data has appeared including a new key
            if(bsDesc.Length() && (DWORD) -1 == PSBugMgr.ResolveBug(DB.eventFailures.m_dwBugID, "Fixed", bsDesc))
                goto Cleanup;
            DB.eventFailures.m_dwState = SN_ResolvedFixed;
            fUpdate = TRUE;
            break;
        case SN_BugCanBeClosed:              // Close the bug since the user can now connect
            if(bsDesc.Length() && (DWORD) -1 == PSBugMgr.CloseBug(DB.eventFailures.m_dwBugID, bsDesc))
                goto Cleanup;
            DB.eventFailures.m_dwState = SN_Closed;
            fUpdate = TRUE;
            break;
        case SN_ActiveNewFeedNoNewKeys:      // Update the bug to indicate that new feed data has appeared but the key matches previous keys
            if(bsDesc.Length() && (DWORD) -1 == PSBugMgr.UpdateBug(DB.eventFailures.m_dwBugID, bsDesc))
                goto Cleanup;
            fUpdate = TRUE;
            break;

        default:
            fUpdate = TRUE;
        };

        if(fUpdate && (DWORD) -1 == DB.updateEvent.UpdateFailure(DB.eventFailures.m_szSerial, DB.eventFailures.m_dwBugID, DB.eventFailures.m_dwState))
            goto Cleanup;
    }

    fSuccess = TRUE;
Cleanup:
    return fSuccess;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\genealogy\geneadmin\service\StdAfx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\genealogy\geneadmin\service\uodbthread.h ===
#pragma once


unsigned __stdcall fnUODBWorkerThread(void *);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\genealogy\geneadmin\service\uodbthread.cpp ===
#include "Stdafx.h"

#include "feedthread.h"
#include "DBConn.h"

class CUODBCollection
{
public:
    CDBSetFailedUODBDate       UODBDate;
    CDBSetProdDate                 ProdDate;
    CDBInsertProdFeedRow       ProdFeed;
    CDBInsertProdErrorRow      ProdError;
    CDBInsertFailure                GeneFailure;
};

DWORD ProcessUODBFile(CUODBCollection &DB, const CHAR *szFileName);

unsigned __stdcall fnUODBWorkerThread(void *)
{
    HANDLE hEndThreadEvent = INVALID_HANDLE_VALUE;
    DWORD dwIndex;
    DWORD dwTimeout;
    CSafeStr szSearch(2*MAX_PATH);

    bool bFirst = true;

    // Hook up to the end service event
    hEndThreadEvent = _Module.EndThreadEvent();

    while(!(g_dwDisableThreads & UODB_THREAD))
    {
        CFileSearch wfd;
        if(!bFirst)
        {
            if(!g_dwFeedCopyFrequency)
                dwTimeout = 20 * 60 * 1000;
            else
                dwTimeout = g_dwFeedCopyFrequency * 60 * 1000;
            dwIndex = WaitForSingleObject(hEndThreadEvent, dwTimeout);
            if(WAIT_OBJECT_0 == dwIndex)
                break;
        }

        bFirst = false;

        // Every time I get here, check the drop dir for new feeds and copy them over to the local inbound directory
        CombinePathFile(szSearch, g_szUODBLocalPath, "*.txt");
        if(!wfd.Start(szSearch))
        {
            if(ERROR_FILE_NOT_FOUND != wfd.GetLastError())
            {
                LogEvent(EVENTLOG_ERROR_TYPE, EVENT_GENE_SEARCH_FAILED, "UODBThread: Failed to search for \"%s\".  Error code: %d", (const CHAR *) szSearch, wfd.GetLastError());
            }
            continue;
        }

        CUODBCollection DB;

        while(wfd.GetNext())
        {
            // We get the file name to check it in our destination directory
            if(wfd->dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY ||
                wfd->dwFileAttributes & FILE_ATTRIBUTE_OFFLINE)
                continue;

            CombinePathFile(szSearch, g_szUODBLocalPath, wfd->cFileName);
            ClearRO(szSearch);
            
            if(!wfd->nFileSizeHigh && !wfd->nFileSizeLow)
            {
                DeleteFile(szSearch);
                continue;
            }

            ProcessUODBFile(DB, szSearch);
        } // all txt files in the source directory
    }

    _Module.ThreadCompleting();
    return 0;
}

const CHAR *ParseDate(const CHAR *sz, DBTIMESTAMP *dt)
{
    const CHAR *szPos = sz;
    SYSTEMTIME st;
    DWORDLONG ft = 0;
    memset(dt, 0, sizeof(DBTIMESTAMP));
    szPos += WSCount(szPos);
    if(!DigitCount(szPos))
        return 0;
    dt->year = (WORD) atoi(szPos);
    szPos += DigitCount(szPos);
    if('/' != *szPos || !DigitCount(szPos + 1))
        return 0;
    ++szPos;
    dt->month = (WORD) atoi(szPos);
    szPos += DigitCount(szPos);
    if('/' != *szPos || !DigitCount(szPos + 1))
        return 0;
    ++szPos;
    dt->day = (WORD) atoi(szPos);
    szPos += DigitCount(szPos);
    szPos += WSCount(szPos);
    dt->hour = (WORD) atoi(szPos);
    szPos += DigitCount(szPos);
    if(':' != *szPos || !DigitCount(szPos + 1))
        return 0;
    ++szPos;
    dt->minute = (WORD) atoi(szPos);
    szPos += DigitCount(szPos);
    if(':' != *szPos || !DigitCount(szPos + 1))
        return 0;
    ++szPos;
    dt->second = (WORD) atoi(szPos);
    szPos += DigitCount(szPos);
    szPos += WSCount(szPos);
    DBTimestampToSystemTime(*dt, st);                    // Make sure the date is valid.
    if(!SystemTimeToFileTime(&st, (FILETIME *) &ft))
        return 0;
    return szPos;
}

DWORD ProcessUODBFile(CUODBCollection &DB, const CHAR *szFileName)
{
    FILE *fFile = 0;
    CSafeStr szBuf(2048);
    CSafeStr szSerial(13), szPartNo(10), szKey(13), szFile(256), szDesc(256), szRow(512);
    const CHAR *szPos, *szPos2;
    DWORD dwLen, dwRetVal = (DWORD) -1, dwSeqNo;
    DBTIMESTAMP qdt, uodbdt, dtLast, dtSeq, dtError;
    DWORD dwNoRows = 0, dwFeedGoodRows = 0, dwFeedBadRows = 0, dwMachineAccounts = 0, dwBadRows = 0, dwNewEvents = 0;

    szDesc.AllowTruncate(TRUE);
    szRow.AllowTruncate(TRUE);
    szFile.AllowTruncate(TRUE);
    
    fFile = fopen(szFileName, "r");
    if(!fFile)
    {
        LogEvent(EVENTLOG_ERROR_TYPE, EVENT_GENE_FILEOPEN_FAILED, "Failed to open the file \"%s\".  Error code: %d", szFileName, GetLastError());
        return 0;
    }
    LogEvent(EVENTLOG_INFORMATION_TYPE, EVENT_GENE_BEGIN_FILE_PROCESSING, "Starting to process file \"%s\".", szFileName);
    
    while(szBuf.LineFromFile(fFile))
    {
        szPos = ParseDate(szBuf, &qdt);         // Get the query date
        if(!szPos || ',' != *szPos)
        {
            LogEvent(EVENTLOG_WARNING_TYPE, EVENT_GENE_PARSE_FAILED, "Failed to parse production information (bad date):\n%s", szBuf);
            ++dwBadRows;
            goto NextRow;
        }
        ++szPos;
        szPos += WSCount(szPos);                // Get the serial number
        dwLen = DigitCount(szPos);
        if(12 != dwLen)
        {
            LogEvent(EVENTLOG_WARNING_TYPE, EVENT_GENE_PARSE_FAILED, "Failed to parse production information (bad serial number):\n%s", szBuf);
            ++dwBadRows;
            goto NextRow;
        }
        szSerial.CopyN(szPos, 12);
        szPos += 12;
        szPos += WSCount(szPos);
        if(',' != *szPos)
        {
            LogEvent(EVENTLOG_WARNING_TYPE, EVENT_GENE_PARSE_FAILED, "Failed to parse production information (bad serial number field):\n%s", szBuf);
            ++dwBadRows;
            goto NextRow;
        }
        ++szPos;
        if(!strncmp(szPos, "ROW_EVENT", 9))
        {
            // Indicates that a xbox with the given serial number failed to connect due to genealogy
            SYSTEMTIME st;
            DBTimestampToSystemTime(qdt, st);
            if((DWORD) -1 == DB.GeneFailure.InsertFailure(szSerial, st))
                goto Cleanup;
            ++dwNewEvents;
            goto NextRow;
        }
        if(!strncmp(szPos, "ROW_NONE", 8))
        {
            // Indicate in the failed row the latest date that the query was made to production
            if((DWORD) -1 == DB.ProdDate.SetProdDate(szSerial, qdt))
                goto Cleanup;
            ++dwNoRows;
            goto NextRow;
        }
        if(!strncmp(szPos, "ROW_FEED", 8))
        {
            // Add the feed record to the production feed table and update when the query was last made to production
            szPos += 8;
            szPos += WSCount(szPos);
            if(',' != *szPos)
            {
                LogEvent(EVENTLOG_WARNING_TYPE, EVENT_GENE_PARSE_FAILED, "Failed to parse production information (bad ROW_FEED field):\n%s", szBuf);
                ++dwBadRows;
                goto NextRow;
            }
            ++szPos;
            szPos += WSCount(szPos);
            dwLen = PartNoCount(szPos);
            if(9 != dwLen)
            {
                LogEvent(EVENTLOG_WARNING_TYPE, EVENT_GENE_PARSE_FAILED, "Failed to parse production information (bad part number):\n%s", szBuf);
                ++dwBadRows;
                goto NextRow;
            }
            szPartNo.CopyN(szPos, 9);
            szPos += dwLen;
            szPos += WSCount(szPos);
            if(',' != *szPos)
            {
                LogEvent(EVENTLOG_WARNING_TYPE, EVENT_GENE_PARSE_FAILED, "Failed to parse production information (bad part number field):\n%s", szBuf);
                ++dwBadRows;
                goto NextRow;
            }
            ++szPos;
            szPos += WSCount(szPos);
            dwLen = Base64Count(szPos);
            if(12 != dwLen)
            {
                LogEvent(EVENTLOG_WARNING_TYPE, EVENT_GENE_PARSE_FAILED, "Failed to parse production information (bad online key):\n%s", szBuf);
                ++dwBadRows;
                goto NextRow;
            }
            szKey.CopyN(szPos, 12);
            szPos += 12;
            szPos += WSCount(szPos);
            if(',' != *szPos)
            {
                LogEvent(EVENTLOG_WARNING_TYPE, EVENT_GENE_PARSE_FAILED, "Failed to parse production information (bad online key field):\n%s", szBuf);
                ++dwBadRows;
                goto NextRow;
            }
            ++szPos;
            szPos = ParseDate(szPos, &dtLast);
            if(!szPos || ',' != *szPos)
            {
                LogEvent(EVENTLOG_WARNING_TYPE, EVENT_GENE_PARSE_FAILED, "Failed to parse production information (bad last change date):\n%s", szBuf);
                ++dwBadRows;
                goto NextRow;
            }
            ++szPos;
            szPos += WSCount(szPos);
            if(!DigitCount(szPos))
            {
                LogEvent(EVENTLOG_WARNING_TYPE, EVENT_GENE_PARSE_FAILED, "Failed to parse production information (bad sequence number):\n%s", szBuf);
                ++dwBadRows;
                goto NextRow;
            }
            dwSeqNo = atoi(szPos);
            szPos += DigitCount(szPos);
            szPos += WSCount(szPos);
            if(',' != *szPos)
            {
                LogEvent(EVENTLOG_WARNING_TYPE, EVENT_GENE_PARSE_FAILED, "Failed to parse production information (bad sequence number field):\n%s", szBuf);
                ++dwBadRows;
                goto NextRow;
            }
            ++szPos;
            szPos = ParseDate(szPos, &dtSeq);
            if(!szPos)
            {
                LogEvent(EVENTLOG_WARNING_TYPE, EVENT_GENE_PARSE_FAILED, "Failed to parse production information (bad sequence date):\n%s", szBuf);
                ++dwBadRows;
                goto NextRow;
            }
            if((DWORD) -1 == DB.ProdFeed.InsertProdFeedRow(szSerial, szPartNo, szKey, dtLast, dwSeqNo, dtSeq, qdt))
                goto Cleanup;
            ++dwFeedGoodRows;
            goto NextRow;
        }
        if(!strncmp(szPos, "ROW_ERROR", 9))
        {
            // Add the feed record to the production error table and update when the query was last made to production
            szPos += 9;
            szPos += WSCount(szPos);
            if(',' != *szPos)
            {
                LogEvent(EVENTLOG_WARNING_TYPE, EVENT_GENE_PARSE_FAILED, "Failed to parse production information (bad ROW_ERROR field):\n%s", szBuf);
                ++dwBadRows;
                goto NextRow;
            }
            ++szPos;
            szPos = ParseDate(szPos, &dtError);
            if(!szPos || ',' != *szPos)
            {
                LogEvent(EVENTLOG_WARNING_TYPE, EVENT_GENE_PARSE_FAILED, "Failed to parse production information (bad failure date):\n%s", szBuf);
                ++dwBadRows;
                goto NextRow;
            }
            ++szPos;
            szPos += WSCount(szPos);            // Filename
            szPos2 = strchr(szPos, ',');
            if(!szPos2)
            {
                LogEvent(EVENTLOG_WARNING_TYPE, EVENT_GENE_PARSE_FAILED, "Failed to parse production information (bad row):\n%s", szBuf);
                ++dwBadRows;
                goto NextRow;
            }
            while(szPos2 > szPos && (' ' == *(szPos2 - 1) || '\t' == *(szPos2 - 1)))
                --szPos2;
            dwLen = szPos2 - szPos;
            if(!dwLen)
            {
                LogEvent(EVENTLOG_WARNING_TYPE, EVENT_GENE_PARSE_FAILED, "Failed to parse production information (bad filename):\n%s", szBuf);
                ++dwBadRows;
                goto NextRow;
            }
            szFile.CopyN(szPos, dwLen);
            szPos = szPos2;
            szPos += WSCount(szPos);
            if(',' != *szPos)
            {
                LogEvent(EVENTLOG_WARNING_TYPE, EVENT_GENE_PARSE_FAILED, "Failed to parse production information (bad filename field):\n%s", szBuf);
                ++dwBadRows;
                goto NextRow;
            }
            ++szPos;
            szPos += WSCount(szPos);            // Row data
            szPos2 = strchr(szPos, ',');
            if(!szPos2)
            {
                LogEvent(EVENTLOG_WARNING_TYPE, EVENT_GENE_PARSE_FAILED, "Failed to parse production information (bad row):\n%s", szBuf);
                ++dwBadRows;
                goto NextRow;
            }
            while(szPos2 > szPos && (' ' == *(szPos2 - 1) || '\t' == *(szPos2 - 1)))
                --szPos2;
            dwLen = szPos2 - szPos;
            if(!dwLen)
            {
                LogEvent(EVENTLOG_WARNING_TYPE, EVENT_GENE_PARSE_FAILED, "Failed to parse production information (bad error row):\n%s", szBuf);
                ++dwBadRows;
                goto NextRow;
            }
            szRow.CopyN(szPos, dwLen);
            szPos = szPos2;
            szPos += WSCount(szPos);
            if(',' != *szPos)
            {
                LogEvent(EVENTLOG_WARNING_TYPE, EVENT_GENE_PARSE_FAILED, "Failed to parse production information (bad error row field):\n%s", szBuf);
                ++dwBadRows;
                goto NextRow;
            }
            ++szPos;
            szPos += WSCount(szPos);            // Description of error
            dwLen = strlen(szPos);
            while(dwLen > 0 && (' ' == szPos[dwLen] || '\t' == szPos[dwLen] || '\r' == szPos[dwLen] || '\n' == szPos[dwLen]))
                --dwLen;
            if(!dwLen)
            {
                LogEvent(EVENTLOG_WARNING_TYPE, EVENT_GENE_PARSE_FAILED, "Failed to parse production information (bad error description):\n%s", szBuf);
                ++dwBadRows;
                goto NextRow;
            }
            szDesc.CopyN(szPos, dwLen);
            if((DWORD) -1 == DB.ProdError.InsertProdErrorRow(szSerial, dtError, szFile, szDesc, szRow, qdt))
                goto Cleanup;
            ++dwFeedBadRows;
            goto NextRow;
        }
        if(!strncmp(szPos, "ROW_ACCOUNT", 11))
        {
            // Add the machine account date to the failures table
            szPos += 11;
            szPos += WSCount(szPos);
            if(',' != *szPos)
            {
                LogEvent(EVENTLOG_WARNING_TYPE, EVENT_GENE_PARSE_FAILED, "Failed to parse production information (bad ROW_ACCOUNT field):\n%s", szBuf);
                ++dwBadRows;
                goto NextRow;
            }
            ++szPos;
            szPos = ParseDate(szPos, &uodbdt);
            if(!szPos)
            {
                LogEvent(EVENTLOG_WARNING_TYPE, EVENT_GENE_PARSE_FAILED, "Failed to parse production information (bad UODB account date):\n%s", szBuf);
                ++dwBadRows;
                goto NextRow;
            }
            if((DWORD) -1 == DB.UODBDate.SetUODBDate(szSerial, uodbdt))
                goto Cleanup;
            ++dwMachineAccounts;
            goto NextRow;
        }

NextRow:
        szBuf = "";
    }

    LogEvent(EVENTLOG_INFORMATION_TYPE, EVENT_GENE_FINISHED_FILE_PROCESSING, "Finished Processing \"%s\".\nNo production data: %d\nGood production feed data: %d\nFailed production feed data: %d\nMachine Accounts: %d\nRows failed to parse: %d\nNew Events: %d", szFileName, dwNoRows, dwFeedGoodRows, dwFeedBadRows, dwMachineAccounts, dwBadRows, dwNewEvents);
    dwRetVal = 0;
Cleanup:
    if(fFile)
        fclose(fFile);
    if(!dwRetVal)
        DeleteFile(szFileName);
    else
        LogEvent(EVENTLOG_INFORMATION_TYPE, EVENT_GENE_FILE_PROCESSING_FAILED, "Failed to finish processing \"%s\".\n", szFileName);
           
    return dwRetVal;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\genealogy\geneadmin\service\StdAfx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__8DE9EE13_6EF8_4B4B_972D_A5D22688EC3E__INCLUDED_)
#define AFX_STDAFX_H__8DE9EE13_6EF8_4B4B_972D_A5D22688EC3E__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#undef UNICODE
#undef _UNICODE

#undef WIN32_LEAN_AND_MEAN

#define STRICT
#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#endif
#define _ATL_APARTMENT_THREADED

#include <atlbase.h>
#include <assert.h>
#include <stdio.h>
#include "strcls.h"

#include "globals.h"
#include "key.h"
#include "mappedfile.h"
#include "critsect.h"

#include "dbaccessor.h"
#include "utility.h"
#include "search.h"
#include "eventing.h"

//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module

class CServiceModule : public CComModule
{
public:
	HRESULT RegisterServer(BOOL bRegTypeLib, BOOL bService);
	HRESULT UnregisterServer();
	void Init(_ATL_OBJMAP_ENTRY* p, HINSTANCE h, UINT nServiceNameID, const GUID* plibid = NULL);
    void Start();
	void ServiceMain(DWORD dwArgc, LPTSTR* lpszArgv);
    void Handler(DWORD dwOpcode);
    void Run();
    BOOL IsInstalled();
    BOOL Install();
    BOOL Uninstall();
	LONG Unlock();
    LONG ReadRegistry();
    void SetServiceStatus(DWORD dwState);
    void SetupAsLocalServer();
    void ThreadCompleting();
    HANDLE EndThreadEvent();

//Implementation
private:
    CCriticalSection m_cs;
    HANDLE m_hEndServiceEvent;
    DWORD m_dwThreadsRunning;
    HANDLE m_hWaitOnThreadsEvent;
	static void WINAPI _ServiceMain(DWORD dwArgc, LPTSTR* lpszArgv);
    static void WINAPI _Handler(DWORD dwOpcode);

// data members
public:
    TCHAR m_szServiceName[256];
    SERVICE_STATUS_HANDLE m_hServiceStatus;
    SERVICE_STATUS m_status;
	DWORD dwThreadID;
	BOOL m_bService;
};

extern CServiceModule _Module;
#include <atlcom.h>

#define FEED_THREADS    1
#define UODB_THREAD     2
#define PS_THREAD       4
#define MAIL_THREAD     8
#define EVENT_THREAD    16

#define CONTROLBIT_MAILPROGRESS		1

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__8DE9EE13_6EF8_4B4B_972D_A5D22688EC3E__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\genealogy\geneadmin\service\obj\i386\geneadmin_i.c ===
/* this ALWAYS GENERATED file contains the IIDs and CLSIDs */

/* link this file in with the server and any clients */


 /* File created by MIDL compiler version 7.00.0500 */
/* Compiler settings for geneadmin.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, oldnames, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#pragma warning( disable: 4049 )  /* more than 64k source lines */


#ifdef __cplusplus
extern "C"{
#endif 


#include <rpc.h>
#include <rpcndr.h>

#ifdef _MIDL_USE_GUIDDEF_

#ifndef INITGUID
#define INITGUID
#include <guiddef.h>
#undef INITGUID
#else
#include <guiddef.h>
#endif

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        DEFINE_GUID(name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8)

#else // !_MIDL_USE_GUIDDEF_

#ifndef __IID_DEFINED__
#define __IID_DEFINED__

typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;

#endif // __IID_DEFINED__

#ifndef CLSID_DEFINED
#define CLSID_DEFINED
typedef IID CLSID;
#endif // CLSID_DEFINED

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        const type name = {l,w1,w2,{b1,b2,b3,b4,b5,b6,b7,b8}}

#endif !_MIDL_USE_GUIDDEF_

MIDL_DEFINE_GUID(IID, IID_IManage,0x647E3CBC,0x7D11,0x4652,0xB9,0x19,0x34,0xA2,0x6E,0x6D,0x25,0x3C);


MIDL_DEFINE_GUID(IID, LIBID_GENEADMINLib,0x36439233,0x8981,0x4972,0x9D,0x5A,0x88,0x74,0x86,0xB5,0x61,0xA6);


MIDL_DEFINE_GUID(CLSID, CLSID_Manage,0xAF94AC92,0x39B4,0x4850,0x8E,0xD1,0x15,0xA7,0x27,0xCC,0x75,0xAE);

#undef MIDL_DEFINE_GUID

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\genealogy\geneadmin\service\obj\i386\dlldata.c ===
/*********************************************************
   DllData file -- generated by MIDL compiler 

        DO NOT ALTER THIS FILE

   This file is regenerated by MIDL on every IDL file compile.

   To completely reconstruct this file, delete it and rerun MIDL
   on all the IDL files in this DLL, specifying this file for the
   /dlldata command line option

*********************************************************/

#define PROXY_DELEGATION

#include <rpcproxy.h>

#ifdef __cplusplus
extern "C"   {
#endif

EXTERN_PROXY_FILE( geneadmin )


PROXYFILE_LIST_START
/* Start of list */
  REFERENCE_PROXY_FILE( geneadmin ),
/* End of list */
PROXYFILE_LIST_END


DLLDATA_ROUTINES( aProxyFileList, GET_DLL_CLSID )

#ifdef __cplusplus
}  /*extern "C" */
#endif

/* end of generated dlldata file */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\genealogy\geneadmin\service\obj\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86_geneadmin_none_12.4.56.0_none_924b4c86a0c508ca
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86_geneadmin_no-public-key_12.4.56.0_x-ww_885b86d0
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=geneadmin
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86_geneadmin_no-public-key_12.4.56.0_x-ww_885b86d0
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86_geneadmin_no-public-key_12.4.56.0_x-ww_885b86d0.manifest
XP_MANIFEST_PATH=manifests\x86_geneadmin_no-public-key_12.4.56.0_x-ww_885b86d0.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86_geneadmin_no-public-key_12.4.56.0_x-ww_885b86d0.cat
XP_CATALOG_PATH=manifests\x86_geneadmin_no-public-key_12.4.56.0_x-ww_885b86d0.cat
XP_PAYLOAD_PATH=x86_geneadmin_no-public-key_12.4.56.0_x-ww_885b86d0
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=geneadmin,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\genealogy\geneadmin\service\obj\i386\geneadmin.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 7.00.0500 */
/* Compiler settings for geneadmin.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, oldnames, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#pragma warning( disable: 4049 )  /* more than 64k source lines */


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 500
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __geneadmin_h__
#define __geneadmin_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __IManage_FWD_DEFINED__
#define __IManage_FWD_DEFINED__
typedef interface IManage IManage;
#endif 	/* __IManage_FWD_DEFINED__ */


#ifndef __Manage_FWD_DEFINED__
#define __Manage_FWD_DEFINED__

#ifdef __cplusplus
typedef class Manage Manage;
#else
typedef struct Manage Manage;
#endif /* __cplusplus */

#endif 	/* __Manage_FWD_DEFINED__ */


/* header files for imported files */
#include "oaidl.h"
#include "ocidl.h"

#ifdef __cplusplus
extern "C"{
#endif 


#ifndef __IManage_INTERFACE_DEFINED__
#define __IManage_INTERFACE_DEFINED__

/* interface IManage */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IManage;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("647E3CBC-7D11-4652-B919-34A26E6D253C")
    IManage : public IDispatch
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Stop( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IManageVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IManage * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IManage * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IManage * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IManage * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IManage * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IManage * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IManage * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Stop )( 
            IManage * This);
        
        END_INTERFACE
    } IManageVtbl;

    interface IManage
    {
        CONST_VTBL struct IManageVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IManage_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IManage_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IManage_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IManage_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IManage_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IManage_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IManage_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IManage_Stop(This)	\
    ( (This)->lpVtbl -> Stop(This) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IManage_INTERFACE_DEFINED__ */



#ifndef __GENEADMINLib_LIBRARY_DEFINED__
#define __GENEADMINLib_LIBRARY_DEFINED__

/* library GENEADMINLib */
/* [helpstring][version][uuid] */ 


EXTERN_C const IID LIBID_GENEADMINLib;

EXTERN_C const CLSID CLSID_Manage;

#ifdef __cplusplus

class DECLSPEC_UUID("AF94AC92-39B4-4850-8ED1-15A727CC75AE")
Manage;
#endif
#endif /* __GENEADMINLib_LIBRARY_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\genealogy\geneadmin\service\objd\i386\geneadmin_i.c ===
/* this ALWAYS GENERATED file contains the IIDs and CLSIDs */

/* link this file in with the server and any clients */


 /* File created by MIDL compiler version 7.00.0500 */
/* Compiler settings for geneadmin.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, oldnames, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#pragma warning( disable: 4049 )  /* more than 64k source lines */


#ifdef __cplusplus
extern "C"{
#endif 


#include <rpc.h>
#include <rpcndr.h>

#ifdef _MIDL_USE_GUIDDEF_

#ifndef INITGUID
#define INITGUID
#include <guiddef.h>
#undef INITGUID
#else
#include <guiddef.h>
#endif

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        DEFINE_GUID(name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8)

#else // !_MIDL_USE_GUIDDEF_

#ifndef __IID_DEFINED__
#define __IID_DEFINED__

typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;

#endif // __IID_DEFINED__

#ifndef CLSID_DEFINED
#define CLSID_DEFINED
typedef IID CLSID;
#endif // CLSID_DEFINED

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        const type name = {l,w1,w2,{b1,b2,b3,b4,b5,b6,b7,b8}}

#endif !_MIDL_USE_GUIDDEF_

MIDL_DEFINE_GUID(IID, IID_IManage,0x647E3CBC,0x7D11,0x4652,0xB9,0x19,0x34,0xA2,0x6E,0x6D,0x25,0x3C);


MIDL_DEFINE_GUID(IID, LIBID_GENEADMINLib,0x36439233,0x8981,0x4972,0x9D,0x5A,0x88,0x74,0x86,0xB5,0x61,0xA6);


MIDL_DEFINE_GUID(CLSID, CLSID_Manage,0xAF94AC92,0x39B4,0x4850,0x8E,0xD1,0x15,0xA7,0x27,0xCC,0x75,0xAE);

#undef MIDL_DEFINE_GUID

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\genealogy\geneadmin\service\objd\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86_geneadmin_none_12.4.56.0_none_924b4c86a0c508ca
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86_geneadmin_no-public-key_12.4.56.0_x-ww_885b86d0
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=geneadmin
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86_geneadmin_no-public-key_12.4.56.0_x-ww_885b86d0
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86_geneadmin_no-public-key_12.4.56.0_x-ww_885b86d0.manifest
XP_MANIFEST_PATH=manifests\x86_geneadmin_no-public-key_12.4.56.0_x-ww_885b86d0.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86_geneadmin_no-public-key_12.4.56.0_x-ww_885b86d0.cat
XP_CATALOG_PATH=manifests\x86_geneadmin_no-public-key_12.4.56.0_x-ww_885b86d0.cat
XP_PAYLOAD_PATH=x86_geneadmin_no-public-key_12.4.56.0_x-ww_885b86d0
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=geneadmin,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\genealogy\geneadmin\service\obj\i386\geneadmin_p.c ===
/* this ALWAYS GENERATED file contains the proxy stub code */


 /* File created by MIDL compiler version 7.00.0500 */
/* Compiler settings for geneadmin.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, oldnames, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#if !defined(_M_IA64) && !defined(_M_AMD64)


#pragma warning( disable: 4049 )  /* more than 64k source lines */
#if _MSC_VER >= 1200
#pragma warning(push)
#endif

#pragma warning( disable: 4211 )  /* redefine extern to static */
#pragma warning( disable: 4232 )  /* dllimport identity*/
#pragma warning( disable: 4024 )  /* array to pointer mapping*/
#pragma warning( disable: 4152 )  /* function/data pointer conversion in expression */
#pragma warning( disable: 4100 ) /* unreferenced arguments in x86 call */

#pragma optimize("", off ) 

#define USE_STUBLESS_PROXY


/* verify that the <rpcproxy.h> version is high enough to compile this file*/
#ifndef __REDQ_RPCPROXY_H_VERSION__
#define __REQUIRED_RPCPROXY_H_VERSION__ 475
#endif


#include "rpcproxy.h"
#ifndef __RPCPROXY_H_VERSION__
#error this stub requires an updated version of <rpcproxy.h>
#endif // __RPCPROXY_H_VERSION__


#include "geneadmin.h"

#define TYPE_FORMAT_STRING_SIZE   3                                 
#define PROC_FORMAT_STRING_SIZE   31                                
#define EXPR_FORMAT_STRING_SIZE   1                                 
#define TRANSMIT_AS_TABLE_SIZE    0            
#define WIRE_MARSHAL_TABLE_SIZE   0            

typedef struct _geneadmin_MIDL_TYPE_FORMAT_STRING
    {
    short          Pad;
    unsigned char  Format[ TYPE_FORMAT_STRING_SIZE ];
    } geneadmin_MIDL_TYPE_FORMAT_STRING;

typedef struct _geneadmin_MIDL_PROC_FORMAT_STRING
    {
    short          Pad;
    unsigned char  Format[ PROC_FORMAT_STRING_SIZE ];
    } geneadmin_MIDL_PROC_FORMAT_STRING;

typedef struct _geneadmin_MIDL_EXPR_FORMAT_STRING
    {
    long          Pad;
    unsigned char  Format[ EXPR_FORMAT_STRING_SIZE ];
    } geneadmin_MIDL_EXPR_FORMAT_STRING;


static RPC_SYNTAX_IDENTIFIER  _RpcTransferSyntax = 
{{0x8A885D04,0x1CEB,0x11C9,{0x9F,0xE8,0x08,0x00,0x2B,0x10,0x48,0x60}},{2,0}};


extern const geneadmin_MIDL_TYPE_FORMAT_STRING geneadmin__MIDL_TypeFormatString;
extern const geneadmin_MIDL_PROC_FORMAT_STRING geneadmin__MIDL_ProcFormatString;
extern const geneadmin_MIDL_EXPR_FORMAT_STRING geneadmin__MIDL_ExprFormatString;


extern const MIDL_STUB_DESC Object_StubDesc;


extern const MIDL_SERVER_INFO IManage_ServerInfo;
extern const MIDL_STUBLESS_PROXY_INFO IManage_ProxyInfo;



#if !defined(__RPC_WIN32__)
#error  Invalid build platform for this stub.
#endif
#if !(TARGET_IS_NT51_OR_LATER)
#error You need a Windows XP or later to run this stub because it uses these features:
#error   #error However, your C/C++ compilation flags indicate you intend to run this app on earlier systems.
#error This app will fail with the RPC_X_WRONG_STUB_VERSION error.
#endif


static const geneadmin_MIDL_PROC_FORMAT_STRING geneadmin__MIDL_ProcFormatString =
    {
        0,
        {

	/* Procedure Stop */

			0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/*  2 */	NdrFcLong( 0x0 ),	/* 0 */
/*  6 */	NdrFcShort( 0x7 ),	/* 7 */
/*  8 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 10 */	NdrFcShort( 0x0 ),	/* 0 */
/* 12 */	NdrFcShort( 0x8 ),	/* 8 */
/* 14 */	0x44,		/* Oi2 Flags:  has return, has ext, */
			0x1,		/* 1 */
/* 16 */	0x8,		/* 8 */
			0x41,		/* Ext Flags:  new corr desc, has range on conformance */
/* 18 */	NdrFcShort( 0x0 ),	/* 0 */
/* 20 */	NdrFcShort( 0x0 ),	/* 0 */
/* 22 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Return value */

/* 24 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 26 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 28 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

			0x0
        }
    };

static const geneadmin_MIDL_TYPE_FORMAT_STRING geneadmin__MIDL_TypeFormatString =
    {
        0,
        {
			NdrFcShort( 0x0 ),	/* 0 */

			0x0
        }
    };


/* Object interface: IUnknown, ver. 0.0,
   GUID={0x00000000,0x0000,0x0000,{0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46}} */


/* Object interface: IDispatch, ver. 0.0,
   GUID={0x00020400,0x0000,0x0000,{0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46}} */


/* Object interface: IManage, ver. 0.0,
   GUID={0x647E3CBC,0x7D11,0x4652,{0xB9,0x19,0x34,0xA2,0x6E,0x6D,0x25,0x3C}} */

#pragma code_seg(".orpc")
static const unsigned short IManage_FormatStringOffsetTable[] =
    {
    (unsigned short) -1,
    (unsigned short) -1,
    (unsigned short) -1,
    (unsigned short) -1,
    0
    };

static const MIDL_STUBLESS_PROXY_INFO IManage_ProxyInfo =
    {
    &Object_StubDesc,
    geneadmin__MIDL_ProcFormatString.Format,
    &IManage_FormatStringOffsetTable[-3],
    0,
    0,
    0
    };


static const MIDL_SERVER_INFO IManage_ServerInfo = 
    {
    &Object_StubDesc,
    0,
    geneadmin__MIDL_ProcFormatString.Format,
    &IManage_FormatStringOffsetTable[-3],
    0,
    0,
    0,
    0};
CINTERFACE_PROXY_VTABLE(8) _IManageProxyVtbl = 
{
    &IManage_ProxyInfo,
    &IID_IManage,
    IUnknown_QueryInterface_Proxy,
    IUnknown_AddRef_Proxy,
    IUnknown_Release_Proxy ,
    0 /* (void *) (INT_PTR) -1 /* IDispatch::GetTypeInfoCount */ ,
    0 /* (void *) (INT_PTR) -1 /* IDispatch::GetTypeInfo */ ,
    0 /* (void *) (INT_PTR) -1 /* IDispatch::GetIDsOfNames */ ,
    0 /* IDispatch_Invoke_Proxy */ ,
    (void *) (INT_PTR) -1 /* IManage::Stop */
};


static const PRPC_STUB_FUNCTION IManage_table[] =
{
    STUB_FORWARDING_FUNCTION,
    STUB_FORWARDING_FUNCTION,
    STUB_FORWARDING_FUNCTION,
    STUB_FORWARDING_FUNCTION,
    NdrStubCall2
};

CInterfaceStubVtbl _IManageStubVtbl =
{
    &IID_IManage,
    &IManage_ServerInfo,
    8,
    &IManage_table[-3],
    CStdStubBuffer_DELEGATING_METHODS
};

static const MIDL_STUB_DESC Object_StubDesc = 
    {
    0,
    NdrOleAllocate,
    NdrOleFree,
    0,
    0,
    0,
    0,
    0,
    geneadmin__MIDL_TypeFormatString.Format,
    1, /* -error bounds_check flag */
    0x60001, /* Ndr library version */
    0,
    0x70001f4, /* MIDL Version 7.0.500 */
    0,
    0,
    0,  /* notify & notify_flag routine table */
    0x1, /* MIDL flag */
    0, /* cs routines */
    0,   /* proxy/server info */
    0
    };

const CInterfaceProxyVtbl * _geneadmin_ProxyVtblList[] = 
{
    ( CInterfaceProxyVtbl *) &_IManageProxyVtbl,
    0
};

const CInterfaceStubVtbl * _geneadmin_StubVtblList[] = 
{
    ( CInterfaceStubVtbl *) &_IManageStubVtbl,
    0
};

PCInterfaceName const _geneadmin_InterfaceNamesList[] = 
{
    "IManage",
    0
};

const IID *  _geneadmin_BaseIIDList[] = 
{
    &IID_IDispatch,
    0
};


#define _geneadmin_CHECK_IID(n)	IID_GENERIC_CHECK_IID( _geneadmin, pIID, n)

int __stdcall _geneadmin_IID_Lookup( const IID * pIID, int * pIndex )
{
    
    if(!_geneadmin_CHECK_IID(0))
        {
        *pIndex = 0;
        return 1;
        }

    return 0;
}

const ExtendedProxyFileInfo geneadmin_ProxyFileInfo = 
{
    (PCInterfaceProxyVtblList *) & _geneadmin_ProxyVtblList,
    (PCInterfaceStubVtblList *) & _geneadmin_StubVtblList,
    (const PCInterfaceName * ) & _geneadmin_InterfaceNamesList,
    (const IID ** ) & _geneadmin_BaseIIDList,
    & _geneadmin_IID_Lookup, 
    1,
    2,
    0, /* table of [async_uuid] interfaces */
    0, /* Filler1 */
    0, /* Filler2 */
    0  /* Filler3 */
};
#pragma optimize("", on )
#if _MSC_VER >= 1200
#pragma warning(pop)
#endif


#endif /* !defined(_M_IA64) && !defined(_M_AMD64)*/
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\genealogy\geneadmin\service\objd\i386\dlldata.c ===
/*********************************************************
   DllData file -- generated by MIDL compiler 

        DO NOT ALTER THIS FILE

   This file is regenerated by MIDL on every IDL file compile.

   To completely reconstruct this file, delete it and rerun MIDL
   on all the IDL files in this DLL, specifying this file for the
   /dlldata command line option

*********************************************************/

#define PROXY_DELEGATION

#include <rpcproxy.h>

#ifdef __cplusplus
extern "C"   {
#endif

EXTERN_PROXY_FILE( geneadmin )


PROXYFILE_LIST_START
/* Start of list */
  REFERENCE_PROXY_FILE( geneadmin ),
/* End of list */
PROXYFILE_LIST_END


DLLDATA_ROUTINES( aProxyFileList, GET_DLL_CLSID )

#ifdef __cplusplus
}  /*extern "C" */
#endif

/* end of generated dlldata file */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\genealogy\geneadmin\service\objd\i386\geneadmin.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 7.00.0500 */
/* Compiler settings for geneadmin.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, oldnames, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#pragma warning( disable: 4049 )  /* more than 64k source lines */


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 500
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __geneadmin_h__
#define __geneadmin_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __IManage_FWD_DEFINED__
#define __IManage_FWD_DEFINED__
typedef interface IManage IManage;
#endif 	/* __IManage_FWD_DEFINED__ */


#ifndef __Manage_FWD_DEFINED__
#define __Manage_FWD_DEFINED__

#ifdef __cplusplus
typedef class Manage Manage;
#else
typedef struct Manage Manage;
#endif /* __cplusplus */

#endif 	/* __Manage_FWD_DEFINED__ */


/* header files for imported files */
#include "oaidl.h"
#include "ocidl.h"

#ifdef __cplusplus
extern "C"{
#endif 


#ifndef __IManage_INTERFACE_DEFINED__
#define __IManage_INTERFACE_DEFINED__

/* interface IManage */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IManage;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("647E3CBC-7D11-4652-B919-34A26E6D253C")
    IManage : public IDispatch
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Stop( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IManageVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IManage * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IManage * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IManage * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IManage * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IManage * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IManage * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IManage * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Stop )( 
            IManage * This);
        
        END_INTERFACE
    } IManageVtbl;

    interface IManage
    {
        CONST_VTBL struct IManageVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IManage_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IManage_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IManage_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IManage_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IManage_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IManage_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IManage_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IManage_Stop(This)	\
    ( (This)->lpVtbl -> Stop(This) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IManage_INTERFACE_DEFINED__ */



#ifndef __GENEADMINLib_LIBRARY_DEFINED__
#define __GENEADMINLib_LIBRARY_DEFINED__

/* library GENEADMINLib */
/* [helpstring][version][uuid] */ 


EXTERN_C const IID LIBID_GENEADMINLib;

EXTERN_C const CLSID CLSID_Manage;

#ifdef __cplusplus

class DECLSPEC_UUID("AF94AC92-39B4-4850-8ED1-15A727CC75AE")
Manage;
#endif
#endif /* __GENEADMINLib_LIBRARY_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\genealogy\geneadmin\sql\makefile.inc ===
!include $(INETROOT)\build\makefile.inc

COPYFILES:
    echo Copying sql...
    -robocopy . $(_NTTREE)\tools\GeneAdmin\sql *.sql /XD obj objd /XF FailureCausecount.sql /R:0 /NP /NJH /NJS /A-:R
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\genealogy\geneadmin\sql\obj\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86__sql_4_none_12.4.56.0_none_a9546ef0f19d7f66
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86__sql_4_no-public-key_12.4.56.0_x-ww_63ae09ba
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=_sql_4
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86__sql_4_no-public-key_12.4.56.0_x-ww_63ae09ba
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86__sql_4_no-public-key_12.4.56.0_x-ww_63ae09ba.manifest
XP_MANIFEST_PATH=manifests\x86__sql_4_no-public-key_12.4.56.0_x-ww_63ae09ba.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86__sql_4_no-public-key_12.4.56.0_x-ww_63ae09ba.cat
XP_CATALOG_PATH=manifests\x86__sql_4_no-public-key_12.4.56.0_x-ww_63ae09ba.cat
XP_PAYLOAD_PATH=x86__sql_4_no-public-key_12.4.56.0_x-ww_63ae09ba
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=_sql_4,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\genealogy\geneadmin\sql\objd\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86__sql_4_none_12.4.56.0_none_a9546ef0f19d7f66
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86__sql_4_no-public-key_12.4.56.0_x-ww_63ae09ba
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=_sql_4
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86__sql_4_no-public-key_12.4.56.0_x-ww_63ae09ba
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86__sql_4_no-public-key_12.4.56.0_x-ww_63ae09ba.manifest
XP_MANIFEST_PATH=manifests\x86__sql_4_no-public-key_12.4.56.0_x-ww_63ae09ba.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86__sql_4_no-public-key_12.4.56.0_x-ww_63ae09ba.cat
XP_CATALOG_PATH=manifests\x86__sql_4_no-public-key_12.4.56.0_x-ww_63ae09ba.cat
XP_PAYLOAD_PATH=x86__sql_4_no-public-key_12.4.56.0_x-ww_63ae09ba
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=_sql_4,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\genealogy\geneadmin\web\makefile.inc ===
!include $(INETROOT)\build\makefile.inc

COPYFILES:
    echo Copying web...
    -robocopy . $(_NTTREE)\tools\GeneAdmin\web /XF build.err build.log build.wrn buildd.err buildd.log buildd.wrn makefile makefile.inc sources update.cmd /XD obj objd /R:0 /NP /NJH /NJS /A-:R
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\genealogy\geneadmin\service\objd\i386\geneadmin_p.c ===
/* this ALWAYS GENERATED file contains the proxy stub code */


 /* File created by MIDL compiler version 7.00.0500 */
/* Compiler settings for geneadmin.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, oldnames, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#if !defined(_M_IA64) && !defined(_M_AMD64)


#pragma warning( disable: 4049 )  /* more than 64k source lines */
#if _MSC_VER >= 1200
#pragma warning(push)
#endif

#pragma warning( disable: 4211 )  /* redefine extern to static */
#pragma warning( disable: 4232 )  /* dllimport identity*/
#pragma warning( disable: 4024 )  /* array to pointer mapping*/
#pragma warning( disable: 4152 )  /* function/data pointer conversion in expression */
#pragma warning( disable: 4100 ) /* unreferenced arguments in x86 call */

#pragma optimize("", off ) 

#define USE_STUBLESS_PROXY


/* verify that the <rpcproxy.h> version is high enough to compile this file*/
#ifndef __REDQ_RPCPROXY_H_VERSION__
#define __REQUIRED_RPCPROXY_H_VERSION__ 475
#endif


#include "rpcproxy.h"
#ifndef __RPCPROXY_H_VERSION__
#error this stub requires an updated version of <rpcproxy.h>
#endif // __RPCPROXY_H_VERSION__


#include "geneadmin.h"

#define TYPE_FORMAT_STRING_SIZE   3                                 
#define PROC_FORMAT_STRING_SIZE   31                                
#define EXPR_FORMAT_STRING_SIZE   1                                 
#define TRANSMIT_AS_TABLE_SIZE    0            
#define WIRE_MARSHAL_TABLE_SIZE   0            

typedef struct _geneadmin_MIDL_TYPE_FORMAT_STRING
    {
    short          Pad;
    unsigned char  Format[ TYPE_FORMAT_STRING_SIZE ];
    } geneadmin_MIDL_TYPE_FORMAT_STRING;

typedef struct _geneadmin_MIDL_PROC_FORMAT_STRING
    {
    short          Pad;
    unsigned char  Format[ PROC_FORMAT_STRING_SIZE ];
    } geneadmin_MIDL_PROC_FORMAT_STRING;

typedef struct _geneadmin_MIDL_EXPR_FORMAT_STRING
    {
    long          Pad;
    unsigned char  Format[ EXPR_FORMAT_STRING_SIZE ];
    } geneadmin_MIDL_EXPR_FORMAT_STRING;


static RPC_SYNTAX_IDENTIFIER  _RpcTransferSyntax = 
{{0x8A885D04,0x1CEB,0x11C9,{0x9F,0xE8,0x08,0x00,0x2B,0x10,0x48,0x60}},{2,0}};


extern const geneadmin_MIDL_TYPE_FORMAT_STRING geneadmin__MIDL_TypeFormatString;
extern const geneadmin_MIDL_PROC_FORMAT_STRING geneadmin__MIDL_ProcFormatString;
extern const geneadmin_MIDL_EXPR_FORMAT_STRING geneadmin__MIDL_ExprFormatString;


extern const MIDL_STUB_DESC Object_StubDesc;


extern const MIDL_SERVER_INFO IManage_ServerInfo;
extern const MIDL_STUBLESS_PROXY_INFO IManage_ProxyInfo;



#if !defined(__RPC_WIN32__)
#error  Invalid build platform for this stub.
#endif
#if !(TARGET_IS_NT51_OR_LATER)
#error You need a Windows XP or later to run this stub because it uses these features:
#error   #error However, your C/C++ compilation flags indicate you intend to run this app on earlier systems.
#error This app will fail with the RPC_X_WRONG_STUB_VERSION error.
#endif


static const geneadmin_MIDL_PROC_FORMAT_STRING geneadmin__MIDL_ProcFormatString =
    {
        0,
        {

	/* Procedure Stop */

			0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/*  2 */	NdrFcLong( 0x0 ),	/* 0 */
/*  6 */	NdrFcShort( 0x7 ),	/* 7 */
/*  8 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 10 */	NdrFcShort( 0x0 ),	/* 0 */
/* 12 */	NdrFcShort( 0x8 ),	/* 8 */
/* 14 */	0x44,		/* Oi2 Flags:  has return, has ext, */
			0x1,		/* 1 */
/* 16 */	0x8,		/* 8 */
			0x41,		/* Ext Flags:  new corr desc, has range on conformance */
/* 18 */	NdrFcShort( 0x0 ),	/* 0 */
/* 20 */	NdrFcShort( 0x0 ),	/* 0 */
/* 22 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Return value */

/* 24 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 26 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 28 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

			0x0
        }
    };

static const geneadmin_MIDL_TYPE_FORMAT_STRING geneadmin__MIDL_TypeFormatString =
    {
        0,
        {
			NdrFcShort( 0x0 ),	/* 0 */

			0x0
        }
    };


/* Object interface: IUnknown, ver. 0.0,
   GUID={0x00000000,0x0000,0x0000,{0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46}} */


/* Object interface: IDispatch, ver. 0.0,
   GUID={0x00020400,0x0000,0x0000,{0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46}} */


/* Object interface: IManage, ver. 0.0,
   GUID={0x647E3CBC,0x7D11,0x4652,{0xB9,0x19,0x34,0xA2,0x6E,0x6D,0x25,0x3C}} */

#pragma code_seg(".orpc")
static const unsigned short IManage_FormatStringOffsetTable[] =
    {
    (unsigned short) -1,
    (unsigned short) -1,
    (unsigned short) -1,
    (unsigned short) -1,
    0
    };

static const MIDL_STUBLESS_PROXY_INFO IManage_ProxyInfo =
    {
    &Object_StubDesc,
    geneadmin__MIDL_ProcFormatString.Format,
    &IManage_FormatStringOffsetTable[-3],
    0,
    0,
    0
    };


static const MIDL_SERVER_INFO IManage_ServerInfo = 
    {
    &Object_StubDesc,
    0,
    geneadmin__MIDL_ProcFormatString.Format,
    &IManage_FormatStringOffsetTable[-3],
    0,
    0,
    0,
    0};
CINTERFACE_PROXY_VTABLE(8) _IManageProxyVtbl = 
{
    &IManage_ProxyInfo,
    &IID_IManage,
    IUnknown_QueryInterface_Proxy,
    IUnknown_AddRef_Proxy,
    IUnknown_Release_Proxy ,
    0 /* (void *) (INT_PTR) -1 /* IDispatch::GetTypeInfoCount */ ,
    0 /* (void *) (INT_PTR) -1 /* IDispatch::GetTypeInfo */ ,
    0 /* (void *) (INT_PTR) -1 /* IDispatch::GetIDsOfNames */ ,
    0 /* IDispatch_Invoke_Proxy */ ,
    (void *) (INT_PTR) -1 /* IManage::Stop */
};


static const PRPC_STUB_FUNCTION IManage_table[] =
{
    STUB_FORWARDING_FUNCTION,
    STUB_FORWARDING_FUNCTION,
    STUB_FORWARDING_FUNCTION,
    STUB_FORWARDING_FUNCTION,
    NdrStubCall2
};

CInterfaceStubVtbl _IManageStubVtbl =
{
    &IID_IManage,
    &IManage_ServerInfo,
    8,
    &IManage_table[-3],
    CStdStubBuffer_DELEGATING_METHODS
};

static const MIDL_STUB_DESC Object_StubDesc = 
    {
    0,
    NdrOleAllocate,
    NdrOleFree,
    0,
    0,
    0,
    0,
    0,
    geneadmin__MIDL_TypeFormatString.Format,
    1, /* -error bounds_check flag */
    0x60001, /* Ndr library version */
    0,
    0x70001f4, /* MIDL Version 7.0.500 */
    0,
    0,
    0,  /* notify & notify_flag routine table */
    0x1, /* MIDL flag */
    0, /* cs routines */
    0,   /* proxy/server info */
    0
    };

const CInterfaceProxyVtbl * _geneadmin_ProxyVtblList[] = 
{
    ( CInterfaceProxyVtbl *) &_IManageProxyVtbl,
    0
};

const CInterfaceStubVtbl * _geneadmin_StubVtblList[] = 
{
    ( CInterfaceStubVtbl *) &_IManageStubVtbl,
    0
};

PCInterfaceName const _geneadmin_InterfaceNamesList[] = 
{
    "IManage",
    0
};

const IID *  _geneadmin_BaseIIDList[] = 
{
    &IID_IDispatch,
    0
};


#define _geneadmin_CHECK_IID(n)	IID_GENERIC_CHECK_IID( _geneadmin, pIID, n)

int __stdcall _geneadmin_IID_Lookup( const IID * pIID, int * pIndex )
{
    
    if(!_geneadmin_CHECK_IID(0))
        {
        *pIndex = 0;
        return 1;
        }

    return 0;
}

const ExtendedProxyFileInfo geneadmin_ProxyFileInfo = 
{
    (PCInterfaceProxyVtblList *) & _geneadmin_ProxyVtblList,
    (PCInterfaceStubVtblList *) & _geneadmin_StubVtblList,
    (const PCInterfaceName * ) & _geneadmin_InterfaceNamesList,
    (const IID ** ) & _geneadmin_BaseIIDList,
    & _geneadmin_IID_Lookup, 
    1,
    2,
    0, /* table of [async_uuid] interfaces */
    0, /* Filler1 */
    0, /* Filler2 */
    0  /* Filler3 */
};
#pragma optimize("", on )
#if _MSC_VER >= 1200
#pragma warning(pop)
#endif


#endif /* !defined(_M_IA64) && !defined(_M_AMD64)*/
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\genealogy\geneadmin\web\obj\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86__web_0_none_12.4.56.0_none_4e1e47d1583a7260
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86__web_0_no-public-key_12.4.56.0_x-ww_091140bc
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=_web_0
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86__web_0_no-public-key_12.4.56.0_x-ww_091140bc
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86__web_0_no-public-key_12.4.56.0_x-ww_091140bc.manifest
XP_MANIFEST_PATH=manifests\x86__web_0_no-public-key_12.4.56.0_x-ww_091140bc.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86__web_0_no-public-key_12.4.56.0_x-ww_091140bc.cat
XP_CATALOG_PATH=manifests\x86__web_0_no-public-key_12.4.56.0_x-ww_091140bc.cat
XP_PAYLOAD_PATH=x86__web_0_no-public-key_12.4.56.0_x-ww_091140bc
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=_web_0,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\genealogy\Genealogy\base64.h ===
/*++

    Copyright (c) Microsoft Corporation

    Module Name:

        Base64.h

--*/

#ifndef __BASE64_H
#define __BASE64_H

#ifdef __cplusplus
extern "C" {
#endif

#define BASE64_ENCODE_BUFFER_SIZE( ulSrcSize ) (((((ulSrcSize) + 2) / 3) * 4) + 1)

BOOL WINAPI
Base64Encode(               
    const LPBYTE    pSrc,
    ULONG           ulSrcSize,
    LPSTR           pszDst
    );

#define BASE64_DECODE_BUFFER_SIZE( ulSrcSize ) (((ulSrcSize) / 4) * 3)

BOOL WINAPI
Base64Decode(
    LPCSTR      pszSrc,
    ULONG       ulSrcSize,
    LPBYTE      pDst,
    PULONG      pulDstSize
    );

#ifdef __cplusplus
}
#endif

#endif // __BASE64_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\genealogy\geneadmin\web\objd\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86__web_0_none_12.4.56.0_none_4e1e47d1583a7260
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86__web_0_no-public-key_12.4.56.0_x-ww_091140bc
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=_web_0
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86__web_0_no-public-key_12.4.56.0_x-ww_091140bc
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86__web_0_no-public-key_12.4.56.0_x-ww_091140bc.manifest
XP_MANIFEST_PATH=manifests\x86__web_0_no-public-key_12.4.56.0_x-ww_091140bc.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86__web_0_no-public-key_12.4.56.0_x-ww_091140bc.cat
XP_CATALOG_PATH=manifests\x86__web_0_no-public-key_12.4.56.0_x-ww_091140bc.cat
XP_PAYLOAD_PATH=x86__web_0_no-public-key_12.4.56.0_x-ww_091140bc
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=_web_0,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\genealogy\Genealogy\Base64.cpp ===
/*++

    Copyright (c) Microsoft Corporation

    Module Name:

        Base64.cpp

    Abstract:

        Base64 encode/decode functions.

--*/


#include "stdinc.h"

#include "Base64.h"

BYTE g_achBase64DecodeTable[256]={
    64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,
    64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,62,64,64,64,63,
    52,53,54,55,56,57,58,59,60,61,64,64,64,64,64,64,64,0,1,2,3,4,5,6,7,8,9,
    10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,64,64,64,64,64,64,26,27,
    28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,
    64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,
    64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,
    64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,
    64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,
    64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,
    64,64,64,64,64,64,64,64,64,64,64,64,64
};

CHAR g_achBase64EncodeTable[64] = {
    'A','B','C','D','E','F','G','H','I','J','K','L','M',
    'N','O','P','Q','R','S','T','U','V','W','X','Y','Z',
    'a','b','c','d','e','f','g','h','i','j','k','l','m',
    'n','o','p','q','r','s','t','u','v','w','x','y','z',
    '0','1','2','3','4','5','6','7','8','9','+','/'
};

BOOL WINAPI
Base64Decode(
    LPCSTR  pszSrc,
    ULONG   ulSrcSize,
    LPBYTE  pDst,
    PULONG  pulDstSize
    )

/*++

Routine Description:

    Base64Decode    This method decodes a Base-64 encoded chunk of binary data.

Arguments:

    pszSrc      Points to Base64-encoded string to decode.

    ulSrcSize   Length of the string pointed to by pszSrc, not including 
                terminating null character.

    pDst        Buffer to copy the decoded binary data into.  The size of this
                buffer must be at least BASE64_DECODE_BUFFER_SIZE(ulSrcSize)

    pulDstSize  On return contains the length in bytes of the decoded buffer.

Return Value:

     0 - Decode was successful.

--*/

{
    ULONG   ulIndex;
    ULONG   ulCurOut;
    DWORD   dwGroup;
    DWORD   dwCur;
    DWORD   dwPadSeen;
    CHAR    chCur;

    dwGroup  = 0;
    dwPadSeen = 0;
    ulCurOut = 0;

    if(ulSrcSize % 4 != 0)
        return FALSE;

    for(ulIndex = 0; ulIndex < ulSrcSize; ulIndex++)
    {
        chCur = pszSrc[ulIndex];
        if(chCur == '=')
        {
            dwPadSeen++;
            dwCur = 0;
        }
        else
        {
            dwCur = g_achBase64DecodeTable[chCur];
        }
        assert( dwCur != 64 );
        
        dwGroup |= (dwCur << (6 * (ulIndex & 0x3)));

        if((ulIndex & 0x3) == 0x3)
        {
            pDst[ulCurOut++] = (CHAR)( dwGroup        & 0xff);

            if(dwPadSeen <= 1)
            {
                pDst[ulCurOut++] = (CHAR)((dwGroup >>  8) & 0xff);

                if(dwPadSeen == 0)
                    pDst[ulCurOut++] = (CHAR)((dwGroup >> 16) & 0xff);
            }

            dwGroup = 0;
        }
    }

    *pulDstSize = ulCurOut;
    assert( ulCurOut <= BASE64_DECODE_BUFFER_SIZE(ulSrcSize) );
    
    return TRUE;
}

BOOL WINAPI
Base64Encode(
    const LPBYTE    pSrc,
    ULONG           ulSrcSize,
    LPSTR           pszDst
    )

/*++

Routine Description:

    Base64Encode    This method converts a buffer of arbitrary binary data into
                    a Base-64 encoded string.

Arguments:

    pSrc        Points to the buffer of bytes to encode.

    ulSrcSize   Number of bytes in pSrc to encode.

    pszDst      Buffer to copy the encoded output into.  The length of the buffer
                must be at least BASE64_ENCODE_BUFFER_SIZE(ulSrcSize).

Return Value:

     0 - Encoding successful.

--*/

{
    DWORD   dwGroup;
    ULONG   ulCurGroup = 0, ulIndex;

    for(ulIndex = 0; ulIndex < (ulSrcSize - (ulSrcSize % 3)); ulIndex += 3)
    {
        dwGroup = (pSrc[ulIndex+2] << 16) | (pSrc[ulIndex+1] << 8) | pSrc[ulIndex];

        pszDst[ulCurGroup++] = g_achBase64EncodeTable[  dwGroup        & 0x3f ];
        pszDst[ulCurGroup++] = g_achBase64EncodeTable[ (dwGroup >> 6)  & 0x3f ];
        pszDst[ulCurGroup++] = g_achBase64EncodeTable[ (dwGroup >> 12) & 0x3f ];
        pszDst[ulCurGroup++] = g_achBase64EncodeTable[ (dwGroup >> 18) & 0x3f ];
    }

    //  Do the end special case.
    switch(ulSrcSize % 3)
    {
    case 2:
        dwGroup = (pSrc[ulIndex+1]  << 8)| pSrc[ulIndex];

        pszDst[ulCurGroup++] = g_achBase64EncodeTable[  dwGroup        & 0x3f ];
        pszDst[ulCurGroup++] = g_achBase64EncodeTable[ (dwGroup >> 6)  & 0x3f ];
        pszDst[ulCurGroup++] = g_achBase64EncodeTable[ (dwGroup >> 12) & 0x3f ];
        pszDst[ulCurGroup++] = '=';

        break;

    case 1:
        dwGroup = pSrc[ulIndex];

        pszDst[ulCurGroup++] = g_achBase64EncodeTable[  dwGroup        & 0x3f ];
        pszDst[ulCurGroup++] = g_achBase64EncodeTable[ (dwGroup >> 6)  & 0x3f ];
        pszDst[ulCurGroup++] = '=';
        pszDst[ulCurGroup++] = '=';

        break;
    }

    //  Null terminate the string.
    pszDst[ulCurGroup] = 0; 
    assert( ulCurGroup < BASE64_ENCODE_BUFFER_SIZE(ulSrcSize) );
    
    return TRUE;
}

// EOF
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\genealogy\Genealogy\EEPROMDataFile.cpp ===
#include "stdinc.h"
#include "EEPROMDataFile.h"

CEEPROMDataFile::CEEPROMDataFile( void )
    : m_pbSerialNumber( NULL ),
      m_pbEncryptedData( NULL )
{
    ZeroMemory( m_szSerialNumber, sizeof( m_szSerialNumber ) );
    ZeroMemory( m_abEEPROMData, EEPROM_DATA_FILE_LENGTH * sizeof( BYTE ) );
}

CEEPROMDataFile::~CEEPROMDataFile( void )
{
    m_pbSerialNumber = NULL;
    m_pbEncryptedData = NULL;
}

HRESULT CEEPROMDataFile::Read( FILE* pFile )
{
    HRESULT hr = S_OK;
    size_t uiRead = 0;
    int iRet = 0;

    //
    // read the data from the data file
    //

    uiRead = fread( m_abEEPROMData, 1, EEPROM_DATA_FILE_LENGTH, pFile );

    //
    // make sure the proper number of bytes were read from the file
    //

    if ( EEPROM_DATA_FILE_LENGTH != uiRead )
    {
        hr = E_FAIL;
        ERROR2( XEVENT_GENEALOGY_VERIFY_ERROR_WRONG_NUMBER_BYTES_READ, "wrong number of bytes read from EEPROM file. Expected %u, read %u\n", EEPROM_DATA_FILE_LENGTH, uiRead );
    }

    //
    // set up the pointers
    //

    if ( SUCCEEDED( hr ) )
    {
        m_pbSerialNumber = m_abEEPROMData + EEPROM_DATA_FILE_SERIAL_NUMBER_OFFSET;
        m_pbEncryptedData = m_abEEPROMData + EEPROM_DATA_FILE_ENCRYPTED_BLOB_OFFSET;

        //
        // make the SN bytes into a string
        //

        iRet = sprintf( m_szSerialNumber, "%12s", m_pbSerialNumber );

        if ( XBSERIAL_NUMBER_LENGTH != iRet )
        {
            hr = E_FAIL;
            ERROR2( XEVENT_GENEALOGY_VERIFY_ERROR_CREATING_SERIAL_NUMBER, "creation of serail number string from buffer failed. Expected %u bytes, got %u bytes\n", XBSERIAL_NUMBER_LENGTH, iRet );
        }
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\genealogy\Genealogy\constants.h ===
///////////////////////////////////////////////////////////////////////////////
//
// Name: constants.h
//
// Author: Dan Rosenstein (danrose)
//
// Description: the constants used in the genealogy tool
//
///////////////////////////////////////////////////////////////////////////////

#pragma once

//
// update parsing error codes
//

static const HRESULT S_EOF_FOUND              = 0x0000FFFF;
static const HRESULT E_EOF_FOUND_EARLY        = 0xF000FFFF;

//
// lengths of data fields from db
//

static const DWORD XBSERIAL_NUMBER_LENGTH = 12;
static const DWORD PART_NUMBER_LENGTH = 9;
static const DWORD ONLINE_KEY_LENGTH = 172;
static const DWORD ONLINE_KEY_VERSION_LENGTH = 4;
static const DWORD MAC_ADDRESS_LENGTH = 12;
static const DWORD GAME_REGION_CODE_LENGTH = 8;
static const DWORD TV_REGION_CODE_LENGTH = 8;
static const DWORD IS_ACTIVE_LENGTH = 1;
static const DWORD PPA2_LENGTH = 8;
static const DWORD SPPA1_LENGTH = 20;

//
// bind sizes
//

static const DWORD GAMING_TABLE_BIND_SIZE = 11;
static const DWORD PART_TABLE_BIND_SIZE = 1;
static const DWORD ERROR_TABLE_BIND_SIZE = 4;

//
// the offset in the EEPROM file for the serial number
//

static const DWORD EEPROM_DATA_FILE_SERIAL_NUMBER_OFFSET = 52;

//
// the offset in the EEPROM file for the encrypted blob
//

static const DWORD EEPROM_DATA_FILE_ENCRYPTED_BLOB_OFFSET = 256;

//
// the maximum length of a data feed row
//

static const DWORD FEED_ROW_LENGTH = 235;

//
// the number of bytes in the EEPROM file
//

static const DWORD EEPROM_DATA_FILE_LENGTH = 300;

//
// the number of fields in the database
//

static const DWORD NUMBER_DATABASE_FIELDS = 8;

//
// number of bytes in the header compare string
//

static const DWORD HEADER_COMPARE_STRING_LENGTH = 12;

//
// value used to dictate that we read a title row
//

static const DWORD TITLE_ROW_VALUE = 0xFFFFFFFF;

//
// the text used to id a header row
//

static const LPSTR HEADER_COMPARE_STRING = "SerialNumber";

//
// the parse string for a data feed row
//

static const LPSTR PARSE_STRING = "%12s %9s %172s %4s %12s %8s %8s %1s";

//
// the db init string
//

static const WCHAR* DB_INIT_STRING = 
    L"Provider=SQLOLEDB; Initial Catalog=%S; Data Source=%S; Trusted_Connection=yes";

//
// the update genealogy sproc call
//

static const WCHAR* UPDATE_GENEALOGY_SPROC_CALL_STRING = 
    L"{ %T = CALL dbo.p_update_genealogy;1 ( %S, %S, %S, %S, %S, %S, %S, %S, %vlB, %vlB, %D ) }";

//
// the geneErrors sproc call
//

static const WCHAR* BAD_GENE_SPROC_CALL_STRING =  
    L"{ %T = CALL dbo.p_BadGene;1 ( %S, %S, %S, %D ) }";

//
// the get partumber sproc call
//

static const WCHAR* GET_PARTNUMBERS_SPROC_CALL_STRING = 
    L"{ %T = CALL dbo.p_get_partnumbers;1 }";

//
// the get online key sproc call
//

static const WCHAR* GET_ONLINE_KEY_SPROC_CALL_STRING = L"{ %T = CALL dbo.p_get_online_key;1 ( %S ) }";

//
// the get all data sproc
//

static const WCHAR* GET_ALL_DATA_SPROC_CALL_STRING = L"{ %T = CALL dbo.p_get_all_data;1 }";
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\genealogy\Genealogy\EEPROMDataFile.h ===
///////////////////////////////////////////////////////////////////////////////
//
// Name: EEPROMDataFile.h
//
// Author: Dan Rosenstein (danrose)
//
// Description: the interfrace for the EEPROM dat file class
//
///////////////////////////////////////////////////////////////////////////////

#pragma once

///////////////////////////////////////////////////////////////////////////////
//
// necessary includes
//
///////////////////////////////////////////////////////////////////////////////

#include "stdinc.h"

///////////////////////////////////////////////////////////////////////////////
//
// CEEPROMDataFile class - class used to abstract out the EEPROM file
//
///////////////////////////////////////////////////////////////////////////////

class CEEPROMDataFile 
{
public:

    CEEPROMDataFile( void );
    ~CEEPROMDataFile( void );

    //
    // Read EEPROM data
    //

    HRESULT Read( FILE* pFile );

    //
    // get the serial number and encrypted data
    //

    LPSTR GetSerialNumber( void ) { return m_szSerialNumber; };
    LPBYTE GetEncryptedData( void ) { return m_pbEncryptedData; };


private:

    //
    // pointers into the data array
    //

    LPBYTE m_pbSerialNumber;
    LPBYTE m_pbEncryptedData;

    //
    // a string version of the serial number
    //

    CHAR m_szSerialNumber[XBSERIAL_NUMBER_LENGTH + 1];

    //
    // the raw data from the EEPROM file
    //

    BYTE m_abEEPROMData[EEPROM_DATA_FILE_LENGTH];
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\genealogy\Genealogy\DataFeed.cpp ===
#include "stdinc.h"
#include "DataFeed.h"

CDataFeed::CDataFeed( void )
    : m_dwCount( 0 ),
      m_dwBadCount( 0 ),
      m_dwRead( 0 )
{
	ZeroMemory( m_szRowData, FEED_ROW_LENGTH + 1 );
}

CDataFeed::~CDataFeed( void )
{
    m_dwCount = 0;
    m_dwBadCount = 0;
    m_dwRead = 0;
}

BOOL CDataFeed::SkipToNextLine( FILE* pInputFile )
{
    CHAR c = '\0';
    size_t nBytes = 0;

    //
    // read until the \n is found or EOF is found
    //

    do
    {
        nBytes = fread( &c, sizeof( CHAR ), 1, pInputFile );
    }
    while ( 0 != nBytes && '\n' != c );

    //
    // TRUE for EOL, FALSE for EOF
    //

    return '\n' == c;
}

BOOL CDataFeed::ReadOneChar( FILE* pInputFile )
{
    size_t nBytes = 0;
    
    //
    // read one byte to the buffer
    //

    nBytes = fread( m_szRowData + m_dwRead, sizeof( CHAR ), 1, pInputFile );
	m_dwRead++;

    //
    // TRUE for byte read, FALSE if not
    //

    return 0 != nBytes;
}

void CDataFeed::StampDateTimes( SOnlineGaming* pOnlineGaming )
{
    SYSTEMTIME st;

    GetSystemTime(&st);

    //
    // set the first/last update date time with the current time
    //

    pOnlineGaming->timeAppeared = st;
}

HRESULT CDataFeed::ParseLine( SOnlineGaming* pOnlineGaming )
{
    int iRet = 0;

	//
	// parse the strings out of the master string
	//

	iRet = sscanf( m_szRowData, 
				   PARSE_STRING, 
				   pOnlineGaming->szSerialNumber, 
				   pOnlineGaming->szPartNumber,
				   pOnlineGaming->szOnlineKey,
				   pOnlineGaming->szOnlineKeyVersion,
				   pOnlineGaming->szMacAddress,
				   pOnlineGaming->szGameRegion,
				   pOnlineGaming->szTVRegion,
				   pOnlineGaming->szIsActive );
    
	//
	// make sure the string parsed correctly
	//

	if ( EOF == iRet )
	{
        IncrementBadCount();

        ERROR1( XEVENT_GENEALOGY_UPDATE_ERROR_EOF_FOUND_TOO_EARLY, "EOF Found too early on line %u\n", GetGoodCount() );

        return E_EOF_FOUND_EARLY;
	}

	//
	// make sure the EXACT number of bytes where read
	//

	if ( NUMBER_DATABASE_FIELDS != iRet )
	{
		IncrementBadCount();
    
        ERROR1( XEVENT_GENEALOGY_UPDATE_ERROR_NUM_DB_FIELDS_WRONG, "Wrong number of DB fields on line %u\n", GetGoodCount() );

        return S_FALSE;
	}

	//
	// make sure we did not get bogus data
	//

	if ( 0 == iRet )
	{
        IncrementBadCount();
    	
        ERROR1( XEVENT_GENEALOGY_UPDATE_ERROR_BAD_DATA_PARSE, "Bad parse of data on line %u\n", GetGoodCount() );

        return S_FALSE;
	}

    return S_OK;
}

HRESULT CDataFeed::Process( FILE* pInputFile, SOnlineGaming* pOnlineGaming )
{
	//
	// zero out the online gaming struct
	//

    ZeroMemory( pOnlineGaming, sizeof( SOnlineGaming ) );

    //
    // reset the bytes read
    //

    ResetReadCounter();

	//
	// read from the file, byte by byte
	//

	do
	{
        if ( ! ReadOneChar( pInputFile ) )
        {
            //
            // if we are at the first char of the file, then EOF is acceptable
            //

            if ( AtFirstPos() )
            {
                return S_EOF_FOUND;
            }
            else
            {
                ERROR1( XEVENT_GENEALOGY_UPDATE_ERROR_EOF_FOUND_TOO_EARLY_1, "EOF found too early on line %u\n", GetGoodCount() );
                return E_EOF_FOUND_EARLY;
            }
        }

        //
        // if we've read enough data, check if this is a header row. if it is, skip it
        //

        if ( IsHeaderRow() )
        {
            IncrementGoodCount();
            IncrementBadCount();
            //
            // goto next valid row
            //

            if ( ! SkipToNextLine( pInputFile ) )
            {
                ERROR1( XEVENT_GENEALOGY_UPDATE_ERROR_EOF_FOUND_TOO_EARLY_2, "EOF found too early on line %u\n", GetGoodCount() );
                return E_EOF_FOUND_EARLY;
            }

            ERROR1( XEVENT_GENEALOGY_WARN_TITLE_ROW_DISCARDED, "Title row found on line %u\n", GetGoodCount() );

            return S_FALSE;
        }
	} 

    //
    // until we are done reading
    //

	while ( ! DoneReading() );

	//
	// if we've made it here, then a line was consumed (even if it was bogus)
	//

	IncrementGoodCount();

    //
    // stamp the dates and times
    //

    StampDateTimes( pOnlineGaming );

	//
	// see if we encountered end of line to early 
	//

	if ( LineTooShort() )
	{
		IncrementBadCount();
		
        ERROR1( XEVENT_GENEALOGY_UPDATE_ERROR_EOL_FOUND_TOO_EARLY, "End of line found too early on line %u\n", GetGoodCount() );

        return S_FALSE;
	}

	//
	// or too late
	//

	if ( LineTooLong() )
	{
		IncrementBadCount();

        //
        // skip until next row
        //

        if ( ! SkipToNextLine( pInputFile ) )
        {
            ERROR1( XEVENT_GENEALOGY_UPDATE_ERROR_EOF_FOUND_TOO_EARLY_3, "EOF found too early on line %u\n", GetGoodCount() );
            return E_EOF_FOUND_EARLY;
        }

        ERROR1( XEVENT_GENEALOGY_UPDATE_ERROR_LINE_TOO_LONG, "Extra data encountered on line %u\n", GetGoodCount() );

        return S_FALSE;
	}

    //
    // now parse the line
    //

    return ParseLine( pOnlineGaming );
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\genealogy\Genealogy\DataFeed.h ===
///////////////////////////////////////////////////////////////////////////////
//
// Name: DataFeed.h
//
// Author: Dan Rosenstein (danrose)
//
// Description: the interfrace for the data feed class
//
///////////////////////////////////////////////////////////////////////////////

#pragma once

///////////////////////////////////////////////////////////////////////////////
//
// necessary includes
//
///////////////////////////////////////////////////////////////////////////////

#include "stdinc.h"

///////////////////////////////////////////////////////////////////////////////
//
// CDataFeed class - class used to abstract out importing of genealogy feeds
//
///////////////////////////////////////////////////////////////////////////////

class CDataFeed
{
public:

    //
    // constructor and destructor
    //

    CDataFeed( void );
    ~CDataFeed( void );

    //
    // public processing function
    //

    HRESULT Process( FILE* pInputFile, SOnlineGaming* pOnlineGaming );

    //
    // accessors
    //

    DWORD GetGoodCount( void ) { return m_dwCount; };
    DWORD GetBadCount( void ) { return m_dwBadCount; };

    LPSTR GetRowData( void ) { return m_szRowData; };

    //
    // counter handlers
    //

    void IncrementGoodCount( void ) { ++m_dwCount; };
    void IncrementBadCount( void ) { ++m_dwBadCount; };

private:

    //
    // quick logic checkers
    //

    BOOL IsHeaderRow( void ) { return HEADER_COMPARE_STRING_LENGTH == m_dwRead && 0 == strcmp( m_szRowData, HEADER_COMPARE_STRING ); }
    BOOL AtEndOfLineChar( void ) { return '\n' == m_szRowData[m_dwRead-1]; };
    BOOL AtEndOfLinePos( void ) { return  FEED_ROW_LENGTH == m_dwRead; };
    BOOL AtFirstPos( void ) { return 1 == m_dwRead; };
    BOOL DoneReading( void ) { return AtEndOfLinePos() || AtEndOfLineChar(); };
    BOOL LineTooShort( void ) { return ! AtEndOfLinePos() && AtEndOfLineChar(); };
    BOOL LineTooLong( void ) { return AtEndOfLinePos() && ! AtEndOfLineChar(); };

    //
    // skip reading to the next line
    //
    
    BOOL SkipToNextLine( FILE* pInputFile );

    //
    // function to read one char at a time
    //

    BOOL ReadOneChar( FILE* pInputFile );

    //
    // parse the line once it's been read
    // 

    HRESULT ParseLine( SOnlineGaming* pOnlineGaming );

    //
    // add the date/time to the online gaming struct
    //

    void StampDateTimes( SOnlineGaming* pOnlineGaming );

    //
    // function to reset parsing state
    //

    void ResetReadCounter( void ) { m_dwRead = 0; ZeroMemory( m_szRowData, FEED_ROW_LENGTH + 1 ); };

    //
    // the count of good and bad lines read
    //

    DWORD m_dwCount;
    DWORD m_dwBadCount;

    //
    // the number of chars read on this line
    //

    DWORD m_dwRead;

	//
	// place to hold the line by line data
	//

    CHAR m_szRowData[FEED_ROW_LENGTH + 1];
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\genealogy\Genealogy\macros.h ===
///////////////////////////////////////////////////////////////////////////////
//
// Name: macros.h
//
// Author: Dan Rosenstein (danrose)
//
// Description: the macros used in the genealogy tool
//
///////////////////////////////////////////////////////////////////////////////

#pragma once

extern CHAR g_szError[1024];

//
// no parameter error
//

#define ERROR0( nCode, szStr )                     \
{										           \
    sprintf( g_szError, szStr );                   \
	printf( szStr );                               \
	XomNtEvent( nCode, szStr );                   \
}

//
// 1 parameter error
//

#define ERROR1( nCode, szStr, param1 )             \
{										           \
    sprintf( g_szError, szStr, param1 );           \
	printf( szStr, param1 );                       \
	XomNtEvent( nCode, szStr, param1 );           \
}

//
// 2 parameter error
//

#define ERROR2( nCode, szStr, param1, param2 )     \
{										           \
    sprintf( g_szError, szStr, param1, param2 );   \
	printf( szStr, param1, param2 );               \
	XomNtEvent( nCode, szStr, param1, param2 );   \
}

//
// 3 parameter error
//

#define ERROR3( nCode, szStr, param1, param2, param3 )     \
{										                   \
    sprintf( g_szError, szStr, param1, param2, param3 );   \
	printf( szStr, param1, param2, param3 );               \
	XomNtEvent( nCode, szStr, param1, param2, param3 );   \
}

//
// no parameter info
//

#define INFO0( nCode, szStr )                      \
{										           \
	printf( szStr );                               \
	XomNtEvent( nCode, szStr );                   \
}

//
// 1 parameter info
//

#define INFO1( nCode, szStr, param1 )              \
{										           \
	printf( szStr, param1 );                       \
	XomNtEvent( nCode, szStr, param1 );           \
}

//
// 2 parameter info
//

#define INFO2( nCode, szStr, param1, param2 )      \
{										           \
	printf( szStr, param1, param2 );               \
	XomNtEvent( nCode, szStr, param1, param2 );   \
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\genealogy\Genealogy\Genealogy.h ===
///////////////////////////////////////////////////////////////////////////////
//
// Name: Genealogy.h
//
// Author: Dan Rosenstein (danrose)
//
// Description: the interface for the CGenealogy object
//
///////////////////////////////////////////////////////////////////////////////

#pragma once

///////////////////////////////////////////////////////////////////////////////
//
// necessary includes
//
///////////////////////////////////////////////////////////////////////////////

#include "stdinc.h"
#include "Params.h"
#include "nCipher.h"
#include "EEPROMDataFile.h"
#include "DataFeed.h"
#include "Xrc4.h"

///////////////////////////////////////////////////////////////////////////////
//
// CGenealogy class - class used to access Genealogy DB and act accordingly
//
///////////////////////////////////////////////////////////////////////////////

class CGenealogy
{
public:

    //
    // constructor and destructor
    //

    CGenealogy( CParams* pParams );
    ~CGenealogy( void );

    //
    // init function
    //

    HRESULT Init( void );

    //
    // process function
    //

    HRESULT Process( void );

private:

    //
    // open the DB
    //

    HRESULT OpenDB( void );

    //
    // verify or update
    //

    HRESULT Verify( void );
    HRESULT Update( void );
    HRESULT VerifyFromEEPROMFile( void );

    //
    // call the stored proc
    //
    HRESULT CallStoredProc( CWSProcCache* pCache, DBBINDING* pBind, DWORD nBindings, const WCHAR* wszSProcCall, LPSTR szSerialNum = NULL, SOnlineGaming* pOnlineGaming = NULL );

    //
    // get the next row
    //

    BOOL GetNextRow( SOnlineGaming* pOnlineGaming );

    //
    // get valid part number list
    //

    HRESULT GetPartNumberTable( void );

    //
    // get one online key
    //

    HRESULT GetOnlineKey( void );

    //
    // compute the PPA info for the online gaming struct
    //

    BOOL ComputePPA( LPBYTE abKey, SOnlineGaming* pOnlineGaming );

    //
    // preform the update
    //

    HRESULT Update( SOnlineGaming* pOnlineGaming );

    //
    // validate the individual fields of a game record
    //

    BOOL CompareStrings( LPSTR szFirst, LPSTR szSecond, LPSTR szString );
    BOOL OnlineKeyContainsValidData( SOnlineGaming* pOnlineGaming );
    BOOL ValidateInternalOnlineKey( LPBYTE pOnlineKey );
    BOOL ValidateInternalSerialNumber( LPSTR szSerialNumber );
    BOOL ValidateInternalGameRegion( LPSTR szGameRegion );
    BOOL ValidateInternalMacAddress( LPSTR szMacAddress );
    BOOL ValidateInternalTVRegion( LPSTR szTVRegion );
    BOOL ValidateString( LPSTR szString, LPSTR szStringName, DWORD dwLength, CHAR chMinVal, CHAR chMaxVal );
    BOOL ValidateSerialNumberValue( LPSTR szSerialNumber );
    BOOL ValidateSerialNumber( LPSTR szSerialNumber );
    BOOL ValidatePartNumber( LPSTR szPartNumber );
    BOOL ValidateOnlineKey( SOnlineGaming* pOnlineGaming );
    BOOL ValidateOnlineKeyVersion( LPSTR szOnlineKeyVersion );
    BOOL ValidateMacAddress( LPSTR szMacAddress );
    BOOL ValidateGameRegion( LPSTR szGameRegion );
    BOOL ValidateTVRegion( LPSTR szTVRegion );
    BOOL ValidateIsActive( LPSTR szISActive );

    //
    // validate a gaming record
    //

    BOOL Validate( SOnlineGaming* pOnlineGaming );

    //
    // make sure a record belongs in this db
    //

    BOOL RecordBelongs( LPSTR szPartNumber );

    //
    // enter an error in the error table
    //

    void ReportError( void );

    //
    // write the datafeed buffer( or the current online gaming struct) to the output file
    //

  //  void WriteBufferToOutputFile( SOnlineGaming* pOnlineGaming = NULL );

    //
    // the params
    //

    CParams* m_pParams;

    //
    // the db session
    //

    CODBWSession* m_pSes;

    //
    // the caches
    //

    CWSProcCache* m_pGamingTableCache;
    CWSProcCache* m_pPartNumberCache;
    CWSProcCache* m_pErrorCache;

    //
    // the nCipher
    // 

    CNCipher* m_pNCipher;

    //
    // the EEPROM data file
    //

    CEEPROMDataFile* m_pEEPROMDataFile;

    //
    // the data feed
    //

    CDataFeed* m_pDataFeed;

    //
    // the vector to hold the part numbers
    //

    vector<LPCSTR> m_vPartNumbers;

    //
    // the count of good and bad records
    //

    DWORD m_dwCount;
    DWORD m_dwBadCount;

    //
    // the bindings
    //

    static DBBINDING m_partBind[];
    static DBBINDING m_gamingBind[];
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\genealogy\Genealogy\main.cpp ===
#include "stdinc.h"
#include "Genealogy.h"
#include "Params.h"
   
int __cdecl main( int argc, char* argv[] )
{
    HRESULT hr = S_OK;

    //
    // the parameters
    //

    CParams params;

    //
    // the genealogy processor
    //

    CGenealogy genealogy( &params );

    //
    // init the parameters
    //

    if ( SUCCEEDED( hr ) )
    {
        hr = params.ParseArgs( argc, argv );
    }

    //
    // drop a white ball to say we have started
    //

    if ( SUCCEEDED( hr ) )
    {
        INFO0( XEVENT_GENEALOGY_INFO_APP_START, "Arguments parsed successfuly. Starting Genealogy\n" );
    }

    //
    // init genealogy, only if not parsing
    //

    if ( SUCCEEDED( hr ) && ! params.ShouldParse() )
    {
        hr = genealogy.Init();
    }

    //
    // process the params
    //

    if ( SUCCEEDED( hr ) )
    {
        hr = genealogy.Process();
    }

    //
    // cast the unsigned HRESULT to a signed int and return
    //

    return (int) hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\genealogy\Genealogy\nCipher.cpp ===
#include "stdinc.h"
#include "nCipher.h"

CNCipher::CNCipher( void )
    : m_hProv( NULL ),
      m_hPrvKey( NULL )
{
    ZeroMemory( m_abDecodedBase64OnlineKey, 256 );
}

CNCipher::~CNCipher( void )
{
    BOOL bRet = FALSE;

    //
    // destroy the key
    //

    if ( NULL != m_hPrvKey )
    {
        bRet = CryptDestroyKey( m_hPrvKey );

        if ( ! bRet )
        {
            ERROR0( XEVENT_GENEALOGY_ERROR_DESTROYING_KEY_HANDLE, "Could not destory key handle\n" );
        }

        m_hPrvKey = NULL;
    }

    //
    // destory the crypto context
    //

    if ( NULL != m_hProv )
    {
        bRet = CryptReleaseContext( m_hProv, 0 );

        if ( ! bRet )
        {
            ERROR0( XEVENT_GENEALOGY_ERROR_RELEASING_CRYPT_CONTEXT, "Could not release context\n" );
        }

        m_hProv = NULL;
    }
}

HRESULT CNCipher::AquireKeys( void )
{
    HRESULT hr = S_OK;
    BOOL bResult = FALSE;

    //
    // get the crypto context
    //

    if ( SUCCEEDED( hr ) )
    {
        bResult = CryptAcquireContextA( &m_hProv, "XboxOnlineKeyV1", "nCipher Enhanced Cryptographic Provider", PROV_RSA_FULL, CRYPT_MACHINE_KEYSET );
        hr = FALSE == bResult ? E_FAIL : S_OK;

        if ( FAILED( hr ) )
        {
            ERROR0( XEVENT_GENEALOGY_ERROR_AQUIRE_CRYPT_CONTEXT, "Could not aquire crypt context\n" );
        }
    }

    //
    // get key
    //

    if ( SUCCEEDED( hr ) )
    {
        bResult = CryptGetUserKey( m_hProv, AT_KEYEXCHANGE, &m_hPrvKey );
        hr = FALSE == bResult ? E_FAIL : S_OK;

        if ( FAILED( hr ) )
        {
            ERROR0( XEVENT_GENEALOGY_ERROR_GET_USER_KEY, "Could not get user key\n" );
        }
    }

    return hr;
}

XBOX_ENCRYPTED_ONLINE_DATA* CNCipher::DecodeKey( LPSTR szKey )
{
    DWORD dwSize = 0;

    //
    // base 64 decode the online key
    //
        
    BOOL bResult = Base64Decode( szKey, ONLINE_KEY_LENGTH, m_abDecodedBase64OnlineKey, &dwSize );   
    
    //
    // make sure the decode was successful
    //

    if ( ! bResult || ONLINE_KEY_PKENC_SIZE != dwSize )
    {
        ERROR0( XEVENT_GENEALOGY_ERROR_DECODE_ONLINE_KEY, "Could not base 64 decode Online key\n" );
        return NULL;
    }

    //
    // make sure the decrypt was successful
    //

    bResult = CryptDecrypt( m_hPrvKey, NULL, TRUE, 0, m_abDecodedBase64OnlineKey, &dwSize );

    if ( ! bResult || sizeof( XBOX_ENCRYPTED_ONLINE_DATA ) != dwSize )
    {
        ERROR0( XEVENT_GENEALOGY_ERROR_DECRYPT_ONLINE_KEY, "Could not decrypt online key\n" );
        return NULL;
    }

    //
    // cast the blob to a useful pointer, and return it
    //

    return (PXBOX_ENCRYPTED_ONLINE_DATA) m_abDecodedBase64OnlineKey;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\genealogy\Genealogy\Genealogy.cpp ===
#include "stdinc.h"
#include "Genealogy.h"

//
// the global error string
//

CHAR g_szError[1024];

//
// the part table binding
//

DBBINDING CGenealogy::m_partBind[] = { 
    WSBIND( 1, offsetof( SOnlineGaming, szPartNumber ), DBTYPE_STR, PART_NUMBER_LENGTH + 1 ) 
};

//
// the gaming table binding
//

DBBINDING CGenealogy::m_gamingBind[] = { 
    WSBIND( 1, offsetof( SOnlineGaming, szSerialNumber ), DBTYPE_STR, XBSERIAL_NUMBER_LENGTH + 1 ),
    WSBIND( 2, offsetof( SOnlineGaming, szPartNumber ), DBTYPE_STR, PART_NUMBER_LENGTH + 1 ),
    WSBIND( 3, offsetof( SOnlineGaming, szOnlineKey ), DBTYPE_STR, ONLINE_KEY_LENGTH + 1 ),
    WSBIND( 4, offsetof( SOnlineGaming, szOnlineKeyVersion ), DBTYPE_STR, ONLINE_KEY_VERSION_LENGTH + 1 ),
    WSBIND( 5, offsetof( SOnlineGaming, szMacAddress ), DBTYPE_STR, MAC_ADDRESS_LENGTH + 1 ),
    WSBIND( 6, offsetof( SOnlineGaming, szGameRegion ), DBTYPE_STR, GAME_REGION_CODE_LENGTH + 1 ),
    WSBIND( 7, offsetof( SOnlineGaming, szTVRegion ), DBTYPE_STR, TV_REGION_CODE_LENGTH + 1 ),
    WSBIND( 8, offsetof( SOnlineGaming, szIsActive ), DBTYPE_STR, IS_ACTIVE_LENGTH + 1 ),
    WSBIND( 9, offsetof( SOnlineGaming, abPPA2 ), DBTYPE_BYTES, PPA2_LENGTH ),
    WSBIND( 10, offsetof( SOnlineGaming, abSPPA1 ), DBTYPE_BYTES, SPPA1_LENGTH ),
    WSBIND( 11, offsetof( SOnlineGaming, timeAppeared ), DBTYPE_DATE, sizeof( COleDateTime ) )
};

CGenealogy::CGenealogy( CParams* pParams )
    : m_vPartNumbers(),
      m_pParams( pParams ),
      m_pSes( NULL ),
      m_pGamingTableCache( NULL ),
      m_pPartNumberCache( NULL ),
      m_pErrorCache( NULL ),
      m_pNCipher( NULL ),
      m_pEEPROMDataFile( NULL ),
      m_pDataFeed( NULL ),
      m_dwCount( 0 ),
      m_dwBadCount( 0 )
{
    //
    // No code here
    //
}

CGenealogy::~CGenealogy( void )
{
    //
    // destory the session
    //
    
    if ( m_pSes )
    {
        delete m_pSes;
        m_pSes = NULL;
    }

    //
    // destory the gaming table cache
    //

    if ( m_pGamingTableCache )
    {
        delete m_pGamingTableCache;
        m_pGamingTableCache = NULL;
    }

    //
    // destory the part number table cache
    //

    if ( m_pPartNumberCache )
    {
        delete m_pPartNumberCache;
        m_pPartNumberCache = NULL;
    }

    //
    // destory the error cache
    //

    if ( m_pErrorCache )
    {
        delete m_pErrorCache;
        m_pErrorCache = NULL;
    }

    //
    // kill the nCipher
    //

    if ( m_pNCipher )
    {
        delete m_pNCipher;
        m_pNCipher = NULL;
    }

    //
    // kill the EEPROM Data file
    //

    if ( m_pEEPROMDataFile )
    {
        delete m_pEEPROMDataFile;
        m_pEEPROMDataFile = NULL;
    }

    //
    // kill the data feed file
    //

    if ( m_pDataFeed )
    {
        delete m_pDataFeed;
        m_pDataFeed = NULL;
    }

    //
    // destory all the strings within the vector
    //

    for ( DWORD i = 0; i < m_vPartNumbers.size(); i++ )
    {
        delete [] m_vPartNumbers[i];
    }

    //
    // reset the params pointer
    //

    m_pParams = NULL;
}

HRESULT CGenealogy::Verify( void )
{
    HRESULT hr = S_OK;

    //
    // the online gaming struct
    //

    SOnlineGaming onlineGaming;
    ZeroMemory( &onlineGaming, sizeof( SOnlineGaming ) );

    //
    // call the sproc
    //

    if ( SUCCEEDED( hr ) )
    {
        hr = CallStoredProc( m_pGamingTableCache, 
                             m_gamingBind, 
                             GAMING_TABLE_BIND_SIZE,
                             GET_ALL_DATA_SPROC_CALL_STRING );
    }

    //
    // get the rows and validate them
    //

    while( SUCCEEDED( hr ) && GetNextRow( &onlineGaming ) )
    {   
        Validate( &onlineGaming );
    }  

    return hr;
}

BOOL CGenealogy::RecordBelongs( LPSTR szPartNumber )
{
    //
    // if we are only parsing, accept the part number as golden
    //

    if ( m_pParams->ShouldParse() )
    {
        return TRUE;
    }

    //
    // make sure this entry belongs in this DB
    //

    for ( DWORD i = 0; i < m_vPartNumbers.size(); i++ )
    {
        //
        // check the string in the part number table against the part number read in
        //

        if ( 0 == _stricmp( m_vPartNumbers[i], szPartNumber ) )   
        {
            return TRUE;
        }
    }

    ERROR1( XEVENT_GENEALOGY_ERROR_INVALID_PART_NUMBER, "%s is an invalid part number\n", szPartNumber );

    return FALSE;
}

BOOL CGenealogy::ValidateString( LPSTR szString, LPSTR szStringName, DWORD dwLength, CHAR chMinVal, CHAR chMaxVal )
{
    //
    // check the length of the string
    //

    if ( dwLength != strlen( szString ) )
    {
        ERROR3( XEVENT_GENEALOGY_VERIFY_WRONG_STRING_LENGTH, "String %s is wrong length: expected %u, got %u\n", szStringName, strlen( szString ), dwLength );
        return FALSE;
    }

    //
    // check the chars within the string
    //

    for ( DWORD i = 0; i < dwLength; i++ )
    {
        if ( szString[i] < chMinVal || szString[i] > chMaxVal )
        {
            ERROR2( XEVENT_GENEALOGY_VERIFY_BAD_STRING_DATA, "String %s has bad character %c\n", szStringName, szString[i] );
          
            return FALSE;
        }
    }

    //
    // string is good!
    //

    return TRUE;
}

BOOL CGenealogy::ValidateInternalOnlineKey( LPBYTE pOnlineKey )
{
    BOOL bResult = TRUE;

    //
    // only verify the online key of a data file is being used
    //

    if ( m_pParams->ShouldVerifyEEPROMFile() )
    {
        //
        // rc4 hmac decrypt the blob using the online key
        //

        bResult = rc4HmacDecrypt( pOnlineKey, 
                                  ONLINE_KEY_LEN, 
                                  (LPBYTE)( m_pEEPROMDataFile->GetEncryptedData() + sizeof( RC4_SHA1_HEADER ) ), 
                                  ONLINE_KEY_LEN, 
                                  m_pEEPROMDataFile->GetEncryptedData() );

        if ( ! bResult )
        {
            ERROR0( XEVENT_GENEALOGY_VERIFY_ERROR_RC4_DECRYPT, "Could not RC4Hmac decrypt online key\n" );
            return FALSE;
        }
    }

    return TRUE;
}

BOOL CGenealogy::ComputePPA( LPBYTE abKey, SOnlineGaming* pOnlineGaming )
{
    BOOL bVal = FALSE;

    //
    // compute the PPA and the SPPA based on the online key and sn
    //

    bVal =  GenPPAforDB( pOnlineGaming->szSerialNumber, 
                        (const XOCryptoKeyStruct *) abKey,
                        (XOCryptoSPPAStruct *) pOnlineGaming->abSPPA1,
                        (XOCryptoPPAStruct *) pOnlineGaming->abPPA2 );

    //
    // error if failure
    //

    if ( ! bVal )
    {
        ERROR1( XEVENT_GENEALOGY_VERIFY_ERROR_COMPUTE_PPA, "Could not compute PPA for SN %s\n", pOnlineGaming->szSerialNumber );
    }

    return bVal;

}

BOOL CGenealogy::OnlineKeyContainsValidData( SOnlineGaming* pOnlineGaming )
{
    SOnlineGaming onlineGaming;
    ZeroMemory( &onlineGaming, sizeof( SOnlineGaming ) );
    BOOL bReportError = FALSE;

    //
    // if we are only parsing, just pretend key has good data
    //

    if ( m_pParams->ShouldParse() )
    {
        return TRUE;
    }

    //
    // decode the online key using the nCipher
    //

    XBOX_ENCRYPTED_ONLINE_DATA* pData = m_pNCipher->DecodeKey( pOnlineGaming->szOnlineKey );

    //
    // if decoding failed, then fail
    //

    if ( NULL == pData )
    {
        return FALSE;
    }

    //
    // create strings from data
    //

    sprintf( onlineGaming.szSerialNumber, "%12.12s", pData->XboxSerialNumber );

    for ( DWORD i = 0; i < ETHERNET_MAC_ADDR_LEN; i++ )
    {
        sprintf( onlineGaming.szMacAddress + i * 2, "%2.2X", pData->MACAddress[i] );
    }

    sprintf( onlineGaming.szGameRegion, "%8.8u", pData->GameRegion );
    sprintf( onlineGaming.szTVRegion, "%8.8u", pData->AVRegion );

    if( !ValidateInternalSerialNumber( onlineGaming.szSerialNumber ) ||
        !ValidateInternalOnlineKey( pData->OnlineKey ) )
        return FALSE;

    //
    //  If any inner/outer mismatch, copy inner data to outer
    //

    if( !CompareStrings( pOnlineGaming->szSerialNumber, onlineGaming.szSerialNumber, "Serial Number" ) )
    {
        bReportError = TRUE;
        memcpy(pOnlineGaming->szSerialNumber, onlineGaming.szSerialNumber, XBSERIAL_NUMBER_LENGTH + 1);
    }

    if( !CompareStrings( pOnlineGaming->szMacAddress, onlineGaming.szMacAddress, "Mac Address" ) )
    {
        bReportError = TRUE;
        memcpy(pOnlineGaming->szMacAddress, onlineGaming.szMacAddress, MAC_ADDRESS_LENGTH + 1);
    }

    if( !CompareStrings( pOnlineGaming->szGameRegion, onlineGaming.szGameRegion, "Game Region" ) )
    {
        bReportError = TRUE;
        memcpy(pOnlineGaming->szGameRegion, onlineGaming.szGameRegion, GAME_REGION_CODE_LENGTH + 1);
    }

    //
    //  Compute PPA
    //

    if( !ComputePPA( pData->OnlineKey, pOnlineGaming ) )
    {
        return FALSE;
    }

    //
    //  Do we need to report this row as an error?
    //

    if(bReportError)
        ReportError();

    //
    // non-critical validation
    //

    ValidateInternalGameRegion( onlineGaming.szGameRegion );
    ValidateInternalMacAddress( onlineGaming.szMacAddress );
    ValidateInternalTVRegion( onlineGaming.szTVRegion );

    return TRUE;
}

BOOL CGenealogy::CompareStrings( LPSTR szFirst, LPSTR szSecond, LPSTR szString )
{
    if ( 0 != strcmp( szFirst, szSecond ) )
    {
        ERROR3( XEVENT_GENEALOGY_VERIFY_ERROR_INTERNAL_EXTERNAL_COMPARE, "Internal/External %s Compare failed. External: %s  Internal: %s\n", szString, szFirst, szSecond );
        return FALSE;
    }

    return TRUE;
}

BOOL CGenealogy::ValidateSerialNumberValue( LPSTR szSerialNumber )
{
    //
    // must be all 9's or pass PSS
    //

    if ( 0 != strcmp( szSerialNumber, "999999999999" ) && 
         0 != ( ( ( szSerialNumber[0] - '0' ) +
                  ( szSerialNumber[1] - '0' ) +
                  ( szSerialNumber[2] - '0' ) +
                  ( szSerialNumber[3] - '0' ) +
                  ( szSerialNumber[4] - '0' ) +
                  ( szSerialNumber[5] - '0' ) +
                  ( szSerialNumber[6] - '0' ) ) % 7 ) )
    {
        ERROR1( XEVENT_GENEALOGY_VERIFY_BAD_SERIAL_NUMBER_VALUE, "Serial number value %s does not verify\n", szSerialNumber );
        return FALSE;
    }

    return TRUE;
}

BOOL CGenealogy::ValidateInternalSerialNumber( LPSTR szSerialNumber )
{
    return ValidateString( szSerialNumber, "Internal Serial Number", XBSERIAL_NUMBER_LENGTH, '0', '9' );
}

BOOL CGenealogy::ValidateInternalGameRegion( LPSTR szGameRegion )
{
    return ValidateString( szGameRegion, "Internal Game Region", GAME_REGION_CODE_LENGTH, '0', '9' );
}

BOOL CGenealogy::ValidateInternalMacAddress( LPSTR szMacAddress )
{
    return ValidateString( szMacAddress, "Internal Mac Address", MAC_ADDRESS_LENGTH, '0', 'F' );
}

BOOL CGenealogy::ValidateInternalTVRegion( LPSTR szTVRegion )
{
    return ValidateString( szTVRegion, "Internal TV Region", TV_REGION_CODE_LENGTH, '0', '9' );
}

BOOL CGenealogy::ValidateSerialNumber( LPSTR szSerialNumber )
{
    return ValidateString( szSerialNumber, "Serial Number", XBSERIAL_NUMBER_LENGTH, '0', '9' ) &&
           ValidateSerialNumberValue( szSerialNumber );
}

BOOL CGenealogy::ValidatePartNumber( LPSTR szPartNumber )
{
    BOOL bReturn;

    if( !ValidateString( szPartNumber, "Part Number", PART_NUMBER_LENGTH, '-', 'z' ) )
    {
        bReturn = FALSE;
    }
    else
    {
        //
        //  This will spit out an event if the part number is unknown, but
        //  processing will now continue in this case.
        //

        RecordBelongs( szPartNumber );

        bReturn = TRUE;
    }

    return bReturn;
}

BOOL CGenealogy::ValidateOnlineKey( SOnlineGaming* pOnlineGaming )
{
    return ValidateString( pOnlineGaming->szOnlineKey, "Online Key", ONLINE_KEY_LENGTH, '+', 'z' ) &&
           OnlineKeyContainsValidData( pOnlineGaming );
}

BOOL CGenealogy::ValidateOnlineKeyVersion( LPSTR szOnlineKeyVersion )
{
    return ValidateString( szOnlineKeyVersion, "Online Key Version", ONLINE_KEY_VERSION_LENGTH, '0', '9' );
}

BOOL CGenealogy::ValidateMacAddress( LPSTR szMacAddress )
{
    return ValidateString( szMacAddress, "Mac Address", MAC_ADDRESS_LENGTH, '0', 'F' );
}

BOOL CGenealogy::ValidateGameRegion( LPSTR szGameRegion )
{
    return ValidateString( szGameRegion, "Game Region", GAME_REGION_CODE_LENGTH, '0', '9' );
}

BOOL CGenealogy::ValidateTVRegion( LPSTR szTVRegion )
{
    return ValidateString( szTVRegion, "TV Region", TV_REGION_CODE_LENGTH, '0', '9' );
}

BOOL CGenealogy::ValidateIsActive( LPSTR szIsActive )
{
    return ValidateString( szIsActive, "Is Active", IS_ACTIVE_LENGTH, '0', '9' );
}

BOOL CGenealogy::Validate( SOnlineGaming* pOnlineGaming )
{
    //
    // count 1 more record as processed
    //

    if ( 0 == ( ++m_dwCount % 1000 ) )
    {
     //   printf( "%u Bad\\%u Processed\n", m_dwBadCount, m_dwCount );
    }

	//
	// validate the fields
	//

	if ( ! ValidateSerialNumber( pOnlineGaming->szSerialNumber ) ||
         ! ValidatePartNumber( pOnlineGaming->szPartNumber ) ||
         ! ValidateOnlineKey( pOnlineGaming ) )
	{
        m_dwBadCount++;

        //
        // if validation failed increment the bad count, write the bad record,
        // but only if we are dealing with an input data feed
        //

		if ( m_pDataFeed )
        {
            m_pDataFeed->IncrementBadCount();
        }
        
        //
        // report an error
        //

        ReportError();

        return FALSE;
	}

    //
    //  Secondary validation.  For these cases we will output events and add the row to
    //  the errors table, but still continue using the row anyway
    //

    if(  ! ValidateMacAddress( pOnlineGaming->szMacAddress ) ||
         ! ValidateGameRegion( pOnlineGaming->szGameRegion ) ||
         ! ValidateTVRegion( pOnlineGaming->szTVRegion ) ||
         ! ValidateOnlineKeyVersion( pOnlineGaming->szOnlineKeyVersion ) ||
         ! ValidateIsActive( pOnlineGaming->szIsActive ) )
    {
        ReportError();
    }

    return TRUE;
}

HRESULT CGenealogy::Update( SOnlineGaming* pOnlineGaming )
{
    HRESULT hr = S_OK;

    //
    // first validate and see if it belongs
    // then fill in the DOS PPA stuff, but only if we are not only parsing
    //

    if ( Validate( pOnlineGaming ) && ! m_pParams->ShouldParse() )
    {
        //
        // if it does, call the sproc
        //

        hr = CallStoredProc( m_pGamingTableCache, 
                             NULL, 
                             GAMING_TABLE_BIND_SIZE,
							 UPDATE_GENEALOGY_SPROC_CALL_STRING,
                             pOnlineGaming->szSerialNumber,
                             pOnlineGaming );
 
    }

    return hr;
}

void CGenealogy::ReportError( void )
{
    //
    // only report an error if we are not parsing
    //

    if ( ! m_pParams->ShouldParse() )
    {
        CallStoredProc( m_pErrorCache, NULL, ERROR_TABLE_BIND_SIZE, BAD_GENE_SPROC_CALL_STRING );
    }
}

HRESULT CGenealogy::Update( void )
{
    HRESULT hr = S_OK;

    SOnlineGaming onlineGaming;

    //
    // create the data feed processor
    //

    if ( SUCCEEDED( hr ) )
    {
        m_pDataFeed = new CDataFeed();

        if ( NULL == m_pDataFeed )
        {
            hr = E_OUTOFMEMORY;
            ERROR0( XEVENT_GENEALOGY_OUT_OF_MEMORY, "Could not create data feed processor\n" );
        }
    }

    //
    // process the data feed file
    //

    while ( SUCCEEDED( hr ) )
    {
        hr = m_pDataFeed->Process( m_pParams->GetDataFeedFile(), &onlineGaming );

        //
        // either we finished correctly
        //

        if ( S_EOF_FOUND == hr )
        {

            hr = S_OK;

            break;
        }

        //
        // we finished too early
        //

        else if ( E_EOF_FOUND_EARLY == hr )
        {
            //
            // report the EOF too early as an error
            //

            ReportError();
            break;
        }

        //
        // we got one corupt record
        //

        else if ( S_FALSE == hr )
        {
            //
            // Report as an error
            //

            ReportError();

            continue;
        }

        //
        // or this record was golden
        //

        else if ( S_OK == hr )
        {
            hr = Update( &onlineGaming );
        }
    }

    return hr;
}

HRESULT CGenealogy::CallStoredProc( CWSProcCache* pCache, DBBINDING* pBind, DWORD nBindings, const WCHAR* wszSProcCall, LPSTR szSerialNum, SOnlineGaming* pOnlineGaming )
{
    HRESULT hr = S_OK;

    //
    // call the sproc
    //
        
    if ( NULL == pOnlineGaming && NULL == szSerialNum && NULL != pBind )
    {
        //
        // sprocs that take no params, but return a set of data
        // 

        hr = m_pSes->CallProc( pCache, wszSProcCall );
    }

    else if ( NULL == pOnlineGaming && NULL == szSerialNum && NULL == pBind )
    {
        SYSTEMTIME st;

        GetSystemTime(&st);

        //
        // sprocs that return no data, have nothing to do with serial number of the online gaming struct (error sproc)
        //

        hr = m_pSes->CallProc( pCache,
                               wszSProcCall,
                               NULL == m_pParams->GetInputFileName() ? "" : m_pParams->GetInputFileName(),
                               NULL == g_szError ? "" : g_szError,
                               NULL == m_pDataFeed ? "" : m_pDataFeed->GetRowData(),
                               COleDateTime(st) );
    
    }

    else if ( NULL == pOnlineGaming )
    {
        //
        // only serial number
        //

        hr = m_pSes->CallProc( pCache,
                               wszSProcCall,
                               szSerialNum );
    }
    else
    {
        //
        // whole online gamign struct
        //

        hr = m_pSes->CallProc( pCache, 
                               wszSProcCall,
                               szSerialNum, 
							   pOnlineGaming->szPartNumber,
							   pOnlineGaming->szOnlineKey,
							   pOnlineGaming->szOnlineKeyVersion,
							   pOnlineGaming->szMacAddress,
							   pOnlineGaming->szGameRegion,
							   pOnlineGaming->szTVRegion,
							   pOnlineGaming->szIsActive,
                               pOnlineGaming->abPPA2,
                               PPA2_LENGTH,
                               pOnlineGaming->abSPPA1,
                               SPPA1_LENGTH,
                               pOnlineGaming->timeAppeared );
    }

    if ( FAILED( hr ) )
    {
        ERROR2( XEVENT_GENEALOGY_ERROR_CALL_SPROC, "Could not call stored proc %S. HR=0x%x\n", wszSProcCall, hr );
    }

    //
    // setup the bindings
    //

	if ( SUCCEEDED( hr ) && NULL != pBind )
    {
        hr = m_pSes->SetBindings( pBind, nBindings );

        if ( FAILED( hr ) )
        {
            ERROR2( XEVENT_GENEALOGY_ERROR_SETUP_TABLE_BINDINGS, "Could not set up table bindings for sproc %S. HR=0x%x\n", wszSProcCall, hr );
        }
	}

    return hr;
}

BOOL CGenealogy::GetNextRow( SOnlineGaming* pOnlineGaming )
{  

    //
    // the number of rows
    //

	DWORD cRows = 1;

    //
    // get the rows 1 at a time
    //

    HRESULT hr = m_pSes->GetRows( &cRows, pOnlineGaming, sizeof( SOnlineGaming ) );
    
    if ( FAILED( hr ) )
    {
        ERROR1( XEVENT_GENEALOGY_ERROR_GET_NEXT_ROW, "Could not get row from DB. HR=0x%x\n", hr );
        return FALSE;
    }

    //
    // see if we are done running through rows
    //

    if ( 0 == cRows )
    {
        return FALSE;
    }

    return TRUE;
}

HRESULT CGenealogy::GetPartNumberTable( void )
{
    HRESULT hr = S_OK;

    //
    // a temp string
    //

    LPSTR szTemp = NULL;

    //
    // the online gaming struct
    //

    SOnlineGaming onlineGaming;
    ZeroMemory( &onlineGaming, sizeof( SOnlineGaming ) );

    //
    // call the sproc
    //

    if ( SUCCEEDED( hr ) )
    {
        hr = CallStoredProc( m_pPartNumberCache, m_partBind, PART_TABLE_BIND_SIZE, GET_PARTNUMBERS_SPROC_CALL_STRING );
    }

    //
    // get the whole part number table
    //

    while( SUCCEEDED( hr ) && GetNextRow( &onlineGaming ) )
    {
        //
        // allocate some space for the string
        //

        if ( SUCCEEDED( hr ) )
        {
            szTemp = new CHAR[PART_NUMBER_LENGTH + 1];
            hr = NULL == szTemp ? E_OUTOFMEMORY : S_OK;
            
            if ( FAILED( hr ) )
            {
                ERROR0( XEVENT_GENEALOGY_OUT_OF_MEMORY_1, "Could not allocate memory for part number\n" );
            }
        }

        //
        // copy over the string and insert it into the vector
        //

        if ( SUCCEEDED( hr ) )
        {
            strcpy( szTemp, onlineGaming.szPartNumber );
            m_vPartNumbers.push_back( szTemp );
        }
    }

    return hr;
}

HRESULT CGenealogy::GetOnlineKey( void )
{
    HRESULT hr = S_OK;

    //
    // the online gaming struct
    //

    SOnlineGaming onlineGaming;
    ZeroMemory( &onlineGaming, sizeof( SOnlineGaming ) );

    //
    // call the sproc
    //

    if ( SUCCEEDED( hr ) )
    {
        hr = CallStoredProc( m_pGamingTableCache, 
                             m_gamingBind, 
                             GAMING_TABLE_BIND_SIZE,
                             GET_ONLINE_KEY_SPROC_CALL_STRING,
                             m_pEEPROMDataFile->GetSerialNumber() );
    }

    //
    // get the rows and validate them
    //

    while( SUCCEEDED( hr ) && GetNextRow( &onlineGaming ) )
    {    
        Validate( &onlineGaming );
    }

    //
    // make sure the sn was in the DB
    //

    if ( SUCCEEDED( hr ) && 0 == strcmp( onlineGaming.szSerialNumber, "" ) )
    {
        ERROR1( XEVENT_GENEALOGY_SERIAL_NUMBER_NOT_FOUND, "Serail number %s not found in DB\n", m_pEEPROMDataFile->GetSerialNumber() );
        hr = E_FAIL;
    }

    return hr;
}


HRESULT CGenealogy::VerifyFromEEPROMFile( void )
{
    HRESULT hr = S_OK;

    //
    // create the EEPROM data file
    //

    m_pEEPROMDataFile = new CEEPROMDataFile();

    if ( NULL == m_pEEPROMDataFile )
    {
        hr = E_OUTOFMEMORY;
        ERROR0( XEVENT_GENEALOGY_OUT_OF_MEMORY_2, "Could not allocate memory for EEPROM data file\n" );
    }

    //
    // init the EEPROM file
    //

    if ( SUCCEEDED( hr ) )
    {
        hr = m_pEEPROMDataFile->Read( m_pParams->GetEEPROMFile() );
    }

    //
    // get the online key
    //

    if ( SUCCEEDED( hr ) )
    {
        hr = GetOnlineKey();
    }

    return hr;
}

HRESULT CGenealogy::Process( void )
{
    HRESULT hr = S_OK;

    //
    // get the part number table (since verify and update both need it)
    //

    if ( SUCCEEDED( hr ) && ! m_pParams->ShouldParse() )
    {
        hr = GetPartNumberTable();
    }

    //
    // verify the db
    //

    if ( SUCCEEDED( hr ) && m_pParams->ShouldVerifyDB() )
    {
        hr = Verify();

        if ( SUCCEEDED( hr ) )
        {
            INFO2( XEVENT_TOOLS_INFO_8, 
                   "Verify of genealogy completed sucessfuly. %u entires processed, %u entires bad\n",
                   m_dwCount,
                   m_dwBadCount );
        }
    }

    //
    // update the DB
    //

    if ( SUCCEEDED( hr ) && m_pParams->ShouldUpdate() )
    {
        hr = Update();

        //
        // set the event
        //
            
        if ( SUCCEEDED( hr ) )
        {
            INFO2( XEVENT_TOOLS_INFO_9, 
                   "Update of Genealogy completed successfuly. %u entries processed, %u entries discarded\n", 
                   m_pDataFeed->GetGoodCount(), 
                   m_pDataFeed->GetBadCount() );
        }
    }

    //
    // verify a EEPROM file
    //
        
    if ( SUCCEEDED( hr ) && m_pParams->ShouldVerifyEEPROMFile() )
    {
        hr = VerifyFromEEPROMFile();

        if ( SUCCEEDED( hr ) )
        {
            INFO1( XEVENT_GENEALOGY_INFO_EEPROM_VERIFY_COMPLETE,
                   "Verify from EEPROM file for Serial Number %s completed successfuly\n",
                   m_pEEPROMDataFile->GetSerialNumber() );
        }
    }

    return hr;
}

HRESULT CGenealogy::OpenDB( void )
{
    HRESULT hr = S_OK;

    INT iRet = 0;
    WCHAR wszFullDBName[MAX_PATH];

	//
	// create the full DB init string
	//

	if ( SUCCEEDED( hr ) )
	{
		iRet = swprintf( wszFullDBName, DB_INIT_STRING, m_pParams->GetDBName(), m_pParams->GetMachineName() );

		//
		// make sure the length of the new string is correct
		//

		if ( iRet != wcslen( wszFullDBName ) )
		{
			hr = E_FAIL;
			ERROR3( XEVENT_GENEALOGY_ERROR_DB_INIT_STRING_CREATE, "creation of db init string %S failed. Expected %u, got %u\n", wszFullDBName, wcslen( wszFullDBName ), iRet );
		}
	}

    //
    // create the session
    //

    if ( SUCCEEDED( hr ) )
    {
        m_pSes = new CODBWSession();

        if ( NULL == m_pSes )
        {
            hr = E_OUTOFMEMORY;
            ERROR0( XEVENT_GENEALOGY_OUT_OF_MEMORY_3, "Could not create db session\n" );
        }
    }

	//
	// open the DB
	//

	if ( SUCCEEDED( hr ) ) 
	{
		hr = m_pSes->InitializeEx( wszFullDBName );

		if ( FAILED( hr ) )
		{
			ERROR1( XEVENT_GENEALOGY_ERROR_DB_OPEN_FAILED, "Opening of DB %S failed\n", wszFullDBName );
		}
	}

    return hr;
}

HRESULT CGenealogy::Init( void )
{
    HRESULT hr = S_OK;

    //
    // open the DB
    //

    if ( SUCCEEDED( hr ) )
    {
        hr = OpenDB();
    }

    //
    // create the nCipher
    //

    if ( SUCCEEDED( hr ) )
    {
        m_pNCipher = new CNCipher();

        if ( NULL == m_pNCipher )
        {
            hr = E_OUTOFMEMORY;
            ERROR0( XEVENT_GENEALOGY_OUT_OF_MEMORY_4, "Could not allocate nCipher\n" );
        }
    }

    //
    // get the keys from the nCipher
    //

    if ( SUCCEEDED( hr ) )
    {
        hr = m_pNCipher->AquireKeys();
    }

    //
    // create the gaming cache
    //

    if ( SUCCEEDED( hr ) )
    {
        m_pGamingTableCache = new CWSProcCache();

        if ( NULL == m_pGamingTableCache )
        {
            hr = E_OUTOFMEMORY;
            ERROR0( XEVENT_GENEALOGY_OUT_OF_MEMORY_5, "Could not create gaming cache\n" );
        }
    }

    //
    // create the part table cache
    //

    if ( SUCCEEDED( hr ) )
    {
        m_pPartNumberCache = new CWSProcCache();

        if ( NULL == m_pPartNumberCache )
        {
            hr = E_OUTOFMEMORY;
            ERROR0( XEVENT_GENEALOGY_OUT_OF_MEMORY_6, "Could not create part number cache\n" );
        }
    }

    //
    // create the error cache
    //

    if ( SUCCEEDED( hr ) )
    {
        m_pErrorCache = new CWSProcCache();

        if ( NULL == m_pErrorCache )
        {
            hr = E_OUTOFMEMORY;
            ERROR0( XEVENT_GENEALOGY_OUT_OF_MEMORY_7, "could not create error cache\n" );
        }
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\genealogy\Genealogy\nCipher.h ===
///////////////////////////////////////////////////////////////////////////////
//
// Name: nCipher.h
//
// Author: Dan Rosenstein (danrose)
//
// Description: the interfrace for the CNCipher class
//
///////////////////////////////////////////////////////////////////////////////

#pragma once

///////////////////////////////////////////////////////////////////////////////
//
// necessary includes
//
///////////////////////////////////////////////////////////////////////////////

#include "stdinc.h"
#include "base64.h"

///////////////////////////////////////////////////////////////////////////////
//
// CNCipher class - class used to abstract out access of the nCipher device
//
///////////////////////////////////////////////////////////////////////////////

class CNCipher
{
public:

    CNCipher( void );
    ~CNCipher( void );

    HRESULT AquireKeys( void );
    XBOX_ENCRYPTED_ONLINE_DATA* DecodeKey( LPSTR szKey );

private:

    //
    // the provider handle
    //

    HCRYPTPROV m_hProv;

    //
    // the key handle
    //

    HCRYPTKEY m_hPrvKey;

    //
    // the array of decoded bytes
    //

    BYTE m_abDecodedBase64OnlineKey[256];
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\genealogy\Genealogy\Params.h ===
///////////////////////////////////////////////////////////////////////////////
//
// Name: Params.h
//
// Author: Dan Rosenstein (danrose)
//
// Description: the interfrace for the CParams class
//
///////////////////////////////////////////////////////////////////////////////

#pragma once

///////////////////////////////////////////////////////////////////////////////
//
// necessary includes
//
///////////////////////////////////////////////////////////////////////////////

#include "stdinc.h"

///////////////////////////////////////////////////////////////////////////////
//
// CParams class - class used to parse command line parameters
//                 and set up the resources for the genealogy tool
//
///////////////////////////////////////////////////////////////////////////////

class CParams
{
public:

    //
    // the constructor and destructor for the params object
    //

    CParams( void );
    ~CParams( void );

    //
    // the argument parsing function
    //

    HRESULT ParseArgs( int argc, char* argv[] );

    //
    // boolean accessors
    //

    BOOL ShouldVerifyDB( void ) { return NULL != m_szVerify; };
    BOOL ShouldUpdate( void ) { return NULL != m_pInputDataFeedFile; };
    BOOL ShouldParse( void ) { return m_bShouldParse; };
    BOOL ShouldVerifyEEPROMFile( void ) { return NULL != m_pInputEEPROMDatFile; };

    //
    // string accessors
    //

    LPSTR GetDBName( void ) { return m_szDBName; };
    LPSTR GetMachineName( void ) { return m_szMachineName; };

    //
    // file pointer accessors
    //

    FILE* GetDataFeedFile( void ) { return m_pInputDataFeedFile; };
    FILE* GetEEPROMFile( void ) { return m_pInputEEPROMDatFile; };

    //
    // file name accessor
    //

    LPSTR GetInputFileName( void ) { return m_szInputFileName; };

private:

    //
    // how to use this app
    //

    HRESULT Usage( LPSTR szVal );
    
    //
    // check the params for mutual exclusion
    //

    HRESULT CheckParams( void );

    //
    // init the resources
    //

    HRESULT InitResources( void );

    //
    // helper to open a file
    //

    HRESULT OpenFile( FILE** ppFile, LPSTR szPath, BOOL bInput );

    //
    // open a file based on a setting
    //

    HRESULT OpenFileFromSetting( FILE** ppFile, LPCSTR szSetting, BOOL bInput );

    //
    // set a string based on a setting
    //

    HRESULT SetStringFromSetting( LPCSTR szSetting, LPSTR* pszString );

    //
    // get a config string
    //

    HRESULT GetSettingString( LPCSTR szLookup, LPSTR* pszSetting );

    //
    // set a string only if it is null originaly
    //

    void SetString( LPSTR* pszString, LPSTR szVal );

    //
    // set the machine, db name, config file name, verify value
    //

    void SetDBName( LPSTR szName );
    void SetMachineName( LPSTR szName );
    void SetConfigFileName( LPSTR szName );
    void SetVerify( LPSTR szName );
    void SetShouldParse( BOOL bVal );

    //
    // helper to process the config file
    //

    HRESULT ProcessConfigFile( void );

    //
    // the file pointers
    //

    FILE* m_pInputDataFeedFile;
    FILE* m_pInputEEPROMDatFile;

    //
    // value of the verify value
    //

    LPSTR m_szVerify;

    //
    // the db name
    //

    LPSTR m_szDBName;

    //
    // the machine name
    //

    LPSTR m_szMachineName;

    //
    // the name of the input file
    //

    LPSTR m_szInputFileName;

    //
    // the config file
    //

    LPSTR m_szConfigFileName;

    //
    // flag to decide if parsing only should happen on input file
    //

    BOOL m_bShouldParse;
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\genealogy\Genealogy\stdinc.h ===
///////////////////////////////////////////////////////////////////////////////
//
// Name: stdinc.h
//
// Author: Dan Rosenstein (danrose)
//
// Description: the common set of includes for the genealogy tool
//
///////////////////////////////////////////////////////////////////////////////

#pragma once

#ifdef WIN32_LEAN_AND_MEAN
#undef WIN32_LEAN_AND_MEAN
#endif

#include <ATLComTime.h>
#include <windows.h>
 
//#include <winsockx.h> 
#include <wsockntp.h>
#include <xonlinep.h>
#include <cryptoHelper.h>

#include <rc4.h>
#include <sha.h>
#include <xcrypt.h>
#include <wincrypt.h>
#include <stdio.h>
#include <stdlib.h>
#include <assert.h>
#include <atlbase.h>
#include <atlcom.h>

#include <OleDBWrapper.h>
#include <xmgmt.h>
#include <xeventids.h>

#include <vector>
using namespace std;

#include "macros.h"
#include "constants.h"
#include "structs.h"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\genealogy\Genealogy\structs.h ===
///////////////////////////////////////////////////////////////////////////////
//
// Name: structs.h
//
// Author: Dan Rosenstein (danrose)
//
// Description: the structs used in the genealogy tool
//
///////////////////////////////////////////////////////////////////////////////

#pragma once

//
// the online gaming Row set decleration
//

struct SOnlineGaming
{
    CHAR szSerialNumber[XBSERIAL_NUMBER_LENGTH + 1];
    CHAR szPartNumber[PART_NUMBER_LENGTH + 1];
    CHAR szOnlineKey[ONLINE_KEY_LENGTH + 1];
    CHAR szOnlineKeyVersion[ONLINE_KEY_VERSION_LENGTH + 1];
    CHAR szMacAddress[MAC_ADDRESS_LENGTH + 1];
    CHAR szGameRegion[GAME_REGION_CODE_LENGTH + 1];
    CHAR szTVRegion[TV_REGION_CODE_LENGTH + 1];
    CHAR szIsActive[IS_ACTIVE_LENGTH + 1];
    BYTE abPPA2[PPA2_LENGTH];
    BYTE abSPPA1[SPPA1_LENGTH];
    COleDateTime timeAppeared;

};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\genealogy\Genealogy\Params.cpp ===
#include "stdinc.h"
#include "Params.h"

CParams::CParams( void )
    : m_pInputDataFeedFile( NULL ),
      m_pInputEEPROMDatFile( NULL ),
      m_szInputFileName( NULL ),
      m_szDBName( NULL ),
      m_szMachineName( NULL ),
      m_szConfigFileName( NULL ),
      m_szVerify( NULL ),
      m_bShouldParse( FALSE )
{
    //
    // no code here
    //
}

CParams::~CParams( void )
{
    int iClose = 0;

    //
    // close the input data feed file
    //

    if ( m_pInputDataFeedFile )
    {
        iClose = fclose( m_pInputDataFeedFile );

        if ( iClose != 0 )
        {
            ERROR0( XEVENT_GENEALOGY_UPDATE_ERROR_CLOSE_DATA_FEED, "Could not close Input Data Feed File\n" );
        }

        m_pInputDataFeedFile = NULL;
    }

    //
    // close the input eeprom dat file
    //

    if ( m_pInputEEPROMDatFile )
    {
        iClose = fclose( m_pInputEEPROMDatFile );

        if ( iClose != 0 )
        {
            ERROR0( XEVENT_GENEALOGY_VERIFY_ERROR_CLOSE_EEPROM_DAT_FILE, "Could not close Input EEPROM Dat File\n" );
        }

        m_pInputEEPROMDatFile = NULL;
    }

	//
	// close the mgmt framework
	//

	g_xomcentral.Term();

    //
    // reset the db name and machine name and the flags
    //

    m_szDBName = NULL;
    m_szMachineName = NULL;
    m_szConfigFileName = NULL;
    m_szVerify = NULL;
}

HRESULT CParams::Usage( LPSTR szVal )
{
    HRESULT hr = E_FAIL;

    if ( NULL != szVal )
    {
        printf( "Invalid argument to Genealogy: %s\n", szVal );
        hr = E_INVALIDARG;
    }

    printf( "\n" );
    printf( "Usage:     Genealogy <SWITCHES>\n" );
    printf( "\n" );
    printf( "Example 1: Genealogy -c ..\\..\\Genealogy.ini\n" );
    printf( "\n" );
    printf( "           will process genealogy based on the specified ini file\n" );
    printf( "\n" );
    printf( "Example 2: Genealogy -d Genealogy -m XONTEGENESQL102 -e eeprom.dat\n" );
    printf( "\n" );
    printf( "           will process genealogy from the database \"Genealogy\",\n" );
    printf( "           from the machine named \"XONTEGENESQL102\"\n" );
    printf( "           and verify against the eeprom data dump file \"eeprom.dat\"\n" );
    printf( "\n" );
    printf( "Example 3: Genealogy -d Genealogy -m XONTEGENESQL102 -v\n" );
    printf( "\n" );
    printf( "           will verify the entire genealogy database \"Genealogy\"\n" );
    printf( "           on the machine \"XONTEGENESQL102\"\n" );
    printf( "\n" );
    printf( "Example 4: Genealogy -d Genealogy -m XONTEGENESQL102 -i input_file -o out_file\n" );
    printf( "\n" );
    printf( "           will import the data from \"input_file\"\n" );
    printf( "           into genealogy DB \"Genealogy\" on machine \"XONTEGENESQL102\"\n" );
    printf( "           and put output bad records to file \"out_file\"\n" );
    printf( "\n" );
    printf( "Valid switches:\n" );
    printf( "\n" );
    printf( "-c config_file  - process genealogy from a config file\n" );
    printf( "-d db_name      - the database that has genealogy\n" );
    printf( "-e eeprom_file  - the name of the EEPROM dat file\n" );
    printf( "-i input_file   - file to import genealogy from\n" );
    printf( "-m machine_name - name of machine with db on it\n" );
    printf( "-v              - verify the entire genealogy db\n" );
    printf( "-p              - only parse, do not import the input file\n" );
    printf( "-h, -?          - show this help screen\n" );
    printf( "\n" );
    printf( "Config File format:\n" );
    printf( "\n" );
    printf( "[Genealogy]\n" );
    printf( "DataFeedFile=\n" );
    printf( "EEPROMDatFile=\n" );
    printf( "DB=\n" );
    printf( "Machine=\n" );
    printf( "Verify=\n" );
    printf( "\n" );
    printf( "Notes:\n" );
    printf( "\n" );
    printf( "1) Command line parameters take precedence over config file settings\n" );
    printf( "2) Parameters are processed as first come, first processed\n" );
    printf( "3) Only 1 of -v, -i and -e may be specified, but one must be specified. \n" );
    printf( "4) -d and -m must be always be specified\n" );
    printf( "\n" );

    return hr;
}

void CParams::SetString( LPSTR* pszString, LPSTR szVal )
{
    if ( NULL == *pszString )
    {
        *pszString = szVal;
    }
}

void CParams::SetDBName( LPSTR szName )
{
    SetString( &m_szDBName, szName );
}

void CParams::SetMachineName( LPSTR szName )
{
    SetString( &m_szMachineName, szName );
}

void CParams::SetConfigFileName( LPSTR szName )
{
    SetString( &m_szConfigFileName, szName );
}

void CParams::SetVerify( LPSTR szName )
{
    SetString( &m_szVerify, szName );
}

void CParams::SetShouldParse( BOOL bVal )
{
    m_bShouldParse = bVal;
}

HRESULT CParams::OpenFile( FILE** ppFile, LPSTR szPath, BOOL bInput )
{
    HRESULT hr = S_OK;

    //
    // make sure file has not been open
    //

    if ( NULL == *ppFile )
    {
        *ppFile = fopen( szPath, bInput ? "rb" : "wb" );
		
		//
		// make sure the file could be opened
		//

		if ( NULL == *ppFile )
		{
			hr = HRESULT_FROM_WIN32( ERROR_FILE_NOT_FOUND );
			ERROR1( XEVENT_GENEALOGY_ERROR_OPEN_FILE, "could not open file %s\n", szPath );
		}
    }

    return hr;
}

HRESULT CParams::GetSettingString( LPCSTR szLookup, LPSTR* pszSetting )
{
    HRESULT hr = S_OK;
    LPSTR szRet = NULL;

    //
    // the mgmt setting
    //

    CXomSetting* pSetting = NULL;

    //
    // get the setting
    //

    hr = g_xomcentral.GetSetting( szLookup, &pSetting );

    //
    // E_FAIL is returned if a setting is not in the file
    //

    if ( E_FAIL == hr )
    {
        hr = S_OK;
    }

    if ( FAILED( hr ) )
    {
        ERROR1( XEVENT_GENEALOGY_ERROR_GET_SETTING, "Could not get setting %s\n", szLookup );
    }

    //
    // get the string value
    //

    if ( SUCCEEDED( hr ) && NULL != pSetting )
    {
        *pszSetting = (LPSTR) pSetting->GetStr();

        //
        // make sure the string was not empty, if it was, make it NULL
        //

        if ( '\0' == **pszSetting )
        {
            *pszSetting = NULL;
        }
    }

    return hr;
}

HRESULT CParams::SetStringFromSetting( LPCSTR szSetting, LPSTR* pszString )
{
    HRESULT hr = S_OK;
    LPSTR szVal = NULL;

    //
    // get the setting string
    //

    if ( SUCCEEDED( hr ) )
    {
        hr = GetSettingString( szSetting, &szVal );
    }

    //
    // set the internal string
    //

    if ( SUCCEEDED( hr ) && NULL != szVal )
    {
        SetString( pszString, szVal );
    }

    return hr;
}

HRESULT CParams::OpenFileFromSetting( FILE** ppFile, LPCSTR szSetting, BOOL bInput )
{
    HRESULT hr = S_OK;
    LPSTR szVal = NULL;

    //
    // get the setting string
    //

    if ( SUCCEEDED( hr ) )
    {
        hr = GetSettingString( szSetting, &szVal );
    }

    //
    // open the file based on the string
    //

    if ( SUCCEEDED( hr ) && NULL != szVal )
    {
        hr = OpenFile( ppFile, szVal, bInput );
    }

    return hr;
}

HRESULT CParams::ProcessConfigFile( void )
{
    HRESULT hr = S_OK;

    //
    // open the datafeed file
    //

    if ( SUCCEEDED( hr ) )
    {
        hr = OpenFileFromSetting( &m_pInputDataFeedFile, "Genealogy.DataFeedFile", TRUE );
    }

    //
    // open the eeprom dat file
    //

    if ( SUCCEEDED( hr ) )
    {
        hr = OpenFileFromSetting( &m_pInputEEPROMDatFile, "Genealogy.EEPROMDatFile", TRUE );
    }

    //
    // get the db name
    //

    if ( SUCCEEDED( hr ) )
    {
        hr = SetStringFromSetting( "Genealogy.DB", &m_szDBName );
    }

    //
    // get the Machine name
    //

    if ( SUCCEEDED( hr ) )
    {
        hr = SetStringFromSetting( "Genealogy.Machine", &m_szMachineName );
    }

    //
    // get the verify value
    //

    if ( SUCCEEDED( hr ) )
    {
        hr = SetStringFromSetting( "Genealogy.Verify", &m_szVerify );
    }

    return hr;
}

HRESULT CParams::CheckParams( void )
{
    HRESULT hr = S_OK;

    //
    // if no input file was specified and Verify was not specified, no idea what to do!
    //

    if ( SUCCEEDED( hr ) && ! ShouldVerifyDB() && ! ShouldUpdate() && ! ShouldVerifyEEPROMFile() )
    {
        hr = Usage( "one of -i, -e, -v must be specified" );
    }

    //
    // if verify was specified and either update or verify EEPROM was specified, error
    //

    if ( SUCCEEDED( hr ) && ( ShouldVerifyDB() && ( ShouldUpdate() || ShouldVerifyEEPROMFile() ) ) )
    {
        hr = Usage( "can not specify -v and -i or -e" );
    }

    //
    // only allow input from one sources
    //

    if ( SUCCEEDED( hr ) && ShouldUpdate() && ShouldVerifyEEPROMFile() )
    {
        hr = Usage( "can not specify -i and -e" );
    }

    //
    // make sure if only parsing, input file was set
    //

    if ( SUCCEEDED( hr ) && ShouldParse() && ! ShouldUpdate() )
    {
        hr = Usage( "can not specify -p without -i" );
    }

    //
    // check db name. do not need a db name if only parsing
    //

    if ( SUCCEEDED( hr ) && NULL == m_szDBName && ! ShouldParse() )
    {
        hr = Usage( "-d not specified" );
    }

    //
    // check machine name. do not need a machine name if only parsing
    //

    if ( SUCCEEDED( hr ) && NULL == m_szMachineName  && ! ShouldParse() )
    {
        hr = Usage( "-m not specified" );
    }

    return hr;
}

HRESULT CParams::InitResources( void )
{
    HRESULT hr = S_OK;

    //
	// Initialize mgmt framework
	// 
	
	if ( SUCCEEDED( hr ) )
	{
        hr = g_xomcentral.Init( "Genealogy", m_szConfigFileName );
        
        if ( FAILED( hr ) )
		{
			ERROR0( XEVENT_GENEALOGY_ERROR_XMGMT_INIT_FAIL, "Init of xmgmt Failed\n" );
		}
	}

    //
    // if a config file was entered, then process it.
    // we can only process it after the xmgmt init!
    //

    if ( SUCCEEDED( hr ) && m_szConfigFileName )
    {
        hr = ProcessConfigFile();
    }

    //
    // check the params now that the config file has been processed
    //

    if ( SUCCEEDED( hr ) )
    {
        hr = CheckParams();
    }

    return hr;
}

HRESULT CParams::ParseArgs( int argc, char* argv[] )
{
    HRESULT hr = S_OK;

    //
    // make sure some parameters were passed in
    //

    if ( SUCCEEDED( hr ) && 1 == argc )
    {
        hr = Usage( NULL );
    }

    //
    // go through the arguments
    //

    while ( SUCCEEDED( hr ) && 1 != argc )
    {
        //
        // look at the argument after the / or
        //

        switch ( toupper( argv[1][1] ) )
        {
            //
            // -c config_file - setup the input config (ini) file
            //

            case 'C':
            {
                //
                // make sure there is another param
                //

                if ( argc > 2 )
                {
                    SetConfigFileName( argv[2] );
                    --argc;
                    ++argv;
                }

                //
                // otherwise inform the user how to use the app
                //

                else
                {
                    hr = Usage( NULL );
                }

                break;
            }

            //
            // -d db_name - setup database name
            //

            case 'D':
            {
                //
                // make sure there is another param
                //

                if ( argc > 2 )
                {
                    SetDBName( argv[2] );
                    --argc;
                    ++argv;
                }

                //
                // otherwise inform the user how to use the app
                //

                else
                {
                    hr = Usage( NULL );
                }

                break;
            }

            //
            // -e eeprom_file - setup the eeprom .DAT file
            //

            case 'E':
            {
                //
                // make sure there is another param
                //

                if ( argc > 2 )
                {
                    hr = OpenFile( &m_pInputEEPROMDatFile, argv[2], TRUE );
                    --argc;
                    ++argv;
                }

                //
                // otherwise inform the user how to use the app
                //

                else
                {
                    hr = Usage( NULL );
                }

                break;
            }

            //
            // -? or -h - get help
            //

            case '?':
            case 'H':
            {
                hr = Usage( NULL );
                break;
            }

            //
            // -i input_file - setup the data feed file
            //

            case 'I':
            {
                //
                // make sure there is another param
                //

                if ( argc > 2 )
                {
                    m_szInputFileName = argv[2];
                    hr = OpenFile( &m_pInputDataFeedFile, argv[2], TRUE );
                    --argc;
                    ++argv;
                }

                //
                // otherwise inform the user how to use the app
                //

                else
                {
                    hr = Usage( NULL );
                }

                break;
            }

            //
            // -m machine_name - setup machine name
            //

            case 'M':
            {
                //
                // make sure there is another param
                //

                if ( argc > 2 )
                {
                    SetMachineName( argv[2] );
                    --argc;
                    ++argv;
                }

                //
                // otherwise inform the user how to use the app
                //

                else
                {
                    hr = Usage( NULL );
                }

                break;
            }

            //
            // -v - verify the entire database
            //

            case 'V':
            {
                SetVerify( "1" );
                break;
            }

            //
            // -p - parse the input file only
            //

            case 'P':
            {
                SetShouldParse( TRUE );
                break;
            }

            //
            // if the param was not known, give the usage
            //

            default:
            {
                hr = Usage( argv[1] );
                break;
            }
        }

        --argc;
        ++argv;
    }

    //
    // now init the resources
    //

    if ( SUCCEEDED( hr ) )
    {
        hr = InitResources();
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\genealogy\Genealogy\XRC4.h ===
#pragma once

#include <rc4.h>
#include <sha.h>
#include <xcrypt.h>

#define RC4_CONFOUNDER_LEN 8

//
// Header before encrypted data
//
typedef struct _RC4_SHA1_HEADER {
    UCHAR Checksum[XC_SERVICE_DIGEST_SIZE];
    UCHAR Confounder[RC4_CONFOUNDER_LEN];
} RC4_SHA1_HEADER, *PRC4_SHA1_HEADER;

void XcRC4Key( IN PUCHAR pbKeyStruct, IN ULONG dwKeyLength, IN PUCHAR pbKey );
void XcRC4Crypt( IN PUCHAR pbKeyStruct, IN ULONG dwInputLength, IN PUCHAR pbInput );

void XcHMAC( IN PBYTE pbKeyMaterial, IN ULONG cbKeyMaterial, IN PBYTE pbData, IN ULONG cbData, IN PBYTE pbData2, IN ULONG cbData2, OUT PBYTE HmacData );

void rc4HmacEncrypt( IN PUCHAR confounder, IN PUCHAR pbKey, IN ULONG cbKey, IN PUCHAR pbInput, IN ULONG cbInput, OUT PUCHAR pbHeader );
BOOL rc4HmacDecrypt( IN PUCHAR pbKey, IN ULONG cbKey, IN PUCHAR pbInput, IN ULONG cbInput, IN PUCHAR pbHeader );
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\genealogy\genesvc\base64.h ===
/*++

    Copyright (c) Microsoft Corporation

    Module Name:

        Base64.h

--*/

#ifndef __BASE64_H
#define __BASE64_H

#ifdef __cplusplus
extern "C" {
#endif

#define BASE64_ENCODE_BUFFER_SIZE( ulSrcSize ) (((((ulSrcSize) + 2) / 3) * 4) + 1)

BOOL WINAPI
Base64Encode(               
    const LPBYTE    pSrc,
    ULONG           ulSrcSize,
    LPSTR           pszDst
    );

#define BASE64_DECODE_BUFFER_SIZE( ulSrcSize ) (((ulSrcSize) / 4) * 3)

BOOL WINAPI
Base64Decode(
    LPCSTR      pszSrc,
    ULONG       ulSrcSize,
    LPBYTE      pDst,
    PULONG      pulDstSize
    );

#ifdef __cplusplus
}
#endif

#endif // __BASE64_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\genealogy\Genealogy\obj\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86_genealogy_none_12.4.56.0_none_92559d88a0bbe63b
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86_genealogy_no-public-key_12.4.56.0_x-ww_69f457d7
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=genealogy
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86_genealogy_no-public-key_12.4.56.0_x-ww_69f457d7
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86_genealogy_no-public-key_12.4.56.0_x-ww_69f457d7.manifest
XP_MANIFEST_PATH=manifests\x86_genealogy_no-public-key_12.4.56.0_x-ww_69f457d7.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86_genealogy_no-public-key_12.4.56.0_x-ww_69f457d7.cat
XP_CATALOG_PATH=manifests\x86_genealogy_no-public-key_12.4.56.0_x-ww_69f457d7.cat
XP_PAYLOAD_PATH=x86_genealogy_no-public-key_12.4.56.0_x-ww_69f457d7
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=genealogy,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\genealogy\Genealogy\XRC4.cpp ===
#include "stdinc.h"
#include "XRC4.h"

void
XcRC4Key(
    IN PUCHAR pbKeyStruct,
    IN ULONG dwKeyLength,
    IN PUCHAR pbKey
    )
{
    rc4_key((RC4_KEYSTRUCT*)pbKeyStruct, dwKeyLength, pbKey);
}
   
void
XcRC4Crypt(
    IN PUCHAR pbKeyStruct,
    IN ULONG dwInputLength,
    IN PUCHAR pbInput
    )
{
    rc4((RC4_KEYSTRUCT*)pbKeyStruct, dwInputLength, pbInput);
}
   
void
XcHMAC(
    IN PBYTE pbKeyMaterial,
    IN ULONG cbKeyMaterial,
    IN PBYTE pbData,
    IN ULONG cbData,
    IN PBYTE pbData2,
    IN ULONG cbData2,
    OUT PBYTE HmacData // length must be A_SHA_DIGEST_LEN
    )
{
#define HMAC_K_PADSIZE              64
#define HMAC_KI_XOR_FACTOR            ((DWORD)0x36363636)
#define HMAC_KO_XOR_FACTOR            ((DWORD)0x5C5C5C5C)
    BYTE Kipad[HMAC_K_PADSIZE];
    BYTE Kopad[HMAC_K_PADSIZE];
    BYTE HMACTmp[HMAC_K_PADSIZE+A_SHA_DIGEST_LEN];
    ULONG dwBlock;
    A_SHA_CTX shaHash;

    // truncate
    if (cbKeyMaterial > HMAC_K_PADSIZE)
        cbKeyMaterial = HMAC_K_PADSIZE;

    RtlZeroMemory(Kipad, HMAC_K_PADSIZE);
    RtlCopyMemory(Kipad, pbKeyMaterial, cbKeyMaterial);

    RtlZeroMemory(Kopad, HMAC_K_PADSIZE);
    RtlCopyMemory(Kopad, pbKeyMaterial, cbKeyMaterial);

    //
    // Kipad, Kopad are padded sMacKey. Now XOR across...
    //
    for(dwBlock=0; dwBlock<HMAC_K_PADSIZE/sizeof(DWORD); dwBlock++)
    {
        ((DWORD*)Kipad)[dwBlock] ^= HMAC_KI_XOR_FACTOR;
        ((DWORD*)Kopad)[dwBlock] ^= HMAC_KO_XOR_FACTOR;
    }

    //
    // prepend Kipad to data, Hash to get H1
    //

    A_SHAInit(&shaHash);
    A_SHAUpdate(&shaHash, Kipad, HMAC_K_PADSIZE);
    if (cbData != 0)
    {
        A_SHAUpdate(&shaHash, pbData, cbData);
    }
    if (cbData2 != 0)
    {
        A_SHAUpdate(&shaHash, pbData2, cbData2);
    }

    // Finish off the hash
    A_SHAFinal(&shaHash,HMACTmp+HMAC_K_PADSIZE);

    // prepend Kopad to H1, hash to get HMAC
    RtlCopyMemory(HMACTmp, Kopad, HMAC_K_PADSIZE);

    // final hash: output value into passed-in buffer
    A_SHAInit(&shaHash);
    A_SHAUpdate(&shaHash,HMACTmp, sizeof(HMACTmp));
    A_SHAFinal(&shaHash,HmacData);
}

void rc4HmacEncrypt(
    IN PUCHAR confounder, // RC4_CONFOUNDER_LEN bytes
    IN PUCHAR pbKey,
    IN ULONG cbKey,
    IN PUCHAR pbInput,
    IN ULONG cbInput,
    OUT PUCHAR pbHeader // XC_SERVICE_DIGEST_SIZE + RC4_CONFOUNDER_LEN bytes
    )
{
    PRC4_SHA1_HEADER CryptHeader = (PRC4_SHA1_HEADER) pbHeader;
    BYTE LocalKey[XC_SERVICE_DIGEST_SIZE];
    BYTE Rc4KeyStruct[XC_SERVICE_RC4_KEYSTRUCT_SIZE];

    //
    // Create the header - the confounder & checksum
    //
    RtlZeroMemory( CryptHeader->Checksum, XC_SERVICE_DIGEST_SIZE );
    RtlCopyMemory( CryptHeader->Confounder, confounder, RC4_CONFOUNDER_LEN );

    //
    // Checksum everything but the checksum
    //
    XcHMAC( pbKey, cbKey,
            CryptHeader->Confounder, RC4_CONFOUNDER_LEN,
            pbInput, cbInput,
            CryptHeader->Checksum );

    //
    // HMAC the checksum into the key
    //
    XcHMAC( pbKey, cbKey,
            CryptHeader->Checksum, XC_SERVICE_DIGEST_SIZE,
            NULL, 0,
            LocalKey );

    //
    // Use the generated key as the RC4 encryption key
    //
    XcRC4Key( Rc4KeyStruct, XC_SERVICE_DIGEST_SIZE, LocalKey );

    //
    // Encrypt everything but the checksum
    //
    XcRC4Crypt( Rc4KeyStruct, RC4_CONFOUNDER_LEN, CryptHeader->Confounder );
    XcRC4Crypt( Rc4KeyStruct, cbInput, pbInput );
}


BOOL rc4HmacDecrypt(
    IN PUCHAR pbKey,
    IN ULONG cbKey,
    IN PUCHAR pbInput,
    IN ULONG cbInput,
    IN PUCHAR pbHeader // XC_SERVICE_DIGEST_SIZE + RC4_CONFOUNDER_LEN bytes
    )
{
    PRC4_SHA1_HEADER CryptHeader = (PRC4_SHA1_HEADER) pbHeader;
    RC4_SHA1_HEADER TempHeader;
    BYTE LocalKey[XC_SERVICE_DIGEST_SIZE];
    BYTE Rc4KeyStruct[XC_SERVICE_RC4_KEYSTRUCT_SIZE];

    RtlCopyMemory( TempHeader.Confounder, CryptHeader->Confounder, RC4_CONFOUNDER_LEN );

    //
    // HMAC the checksum into the key
    //
    XcHMAC( pbKey, cbKey,
            CryptHeader->Checksum, XC_SERVICE_DIGEST_SIZE,
            NULL, 0,
            LocalKey );

    //
    // Use the generated key as the RC4 encryption key
    //
    XcRC4Key( Rc4KeyStruct, XC_SERVICE_DIGEST_SIZE, LocalKey );

    //
    // Decrypt confounder and data
    //
    XcRC4Crypt( Rc4KeyStruct, RC4_CONFOUNDER_LEN, TempHeader.Confounder );
    XcRC4Crypt( Rc4KeyStruct, cbInput, pbInput );

    //
    // Now verify the checksum.
    //
    XcHMAC( pbKey, cbKey,
            TempHeader.Confounder, RC4_CONFOUNDER_LEN,
            pbInput, cbInput,
            TempHeader.Checksum );

    //
    // Decrypt is successful only if checksum matches
    //
    return ( RtlEqualMemory(
                TempHeader.Checksum,
                CryptHeader->Checksum,
                XC_SERVICE_DIGEST_SIZE) );
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\genealogy\genesvc\DataFeed.cpp ===
#include "stdinc.h"
#include "DataFeed.h"

CDataFeed::CDataFeed( void )
    : m_dwCount( 0 ),
      m_dwBadCount( 0 ),
      m_dwRead( 0 ),
      m_szInputFile( NULL ),
      m_pInputFile( NULL ),
      m_FileEncoding( FILE_ENCODING_NONE )
{
	ZeroMemory( m_szRowData, FEED_ROW_LENGTH_EX + 1 );
}

CDataFeed::~CDataFeed( void )
{
    m_dwCount = 0;
    m_dwBadCount = 0;
    m_dwRead = 0;

    if(m_pInputFile != NULL)
        fclose(m_pInputFile);

}

HRESULT CDataFeed::OpenInputFile(LPCSTR szInputFile)
{
    HRESULT hr;
    BYTE    readBuf[3];
    WCHAR   cIndicator;

    while((m_pInputFile = fopen(szInputFile, "rb")) == NULL)
    {
        DWORD dwError = GetLastError();

        if(dwError == ERROR_SHARING_VIOLATION)
        {
            Sleep(1000);
            continue;
        }

        hr = HRESULT_FROM_WIN32(dwError);
        ERROR2(XEVENT_GENEALOGY_ERROR_OPEN_FILE_1,
               "Opening file \"%s\" failed.  Error = 0x%08X.",
               szInputFile,
               hr);
        m_szInputFile = NULL;
        goto Cleanup;
    }

    //
    //  Figure out the encoding for the file
    //

    if(fread(readBuf, 1, sizeof(readBuf), m_pInputFile) < sizeof(readBuf))
    {
        //  The file is too small
        fclose(m_pInputFile);
        m_pInputFile = NULL;
        hr = E_FAIL;
        goto Cleanup;
    }

    if(*(LPWSTR)readBuf == UNICODE_INDICATOR)
    {
        m_FileEncoding = FILE_ENCODING_UNICODE;
        fseek(m_pInputFile, SEEK_SET, 0);
        fread(readBuf, sizeof(WCHAR), 1, m_pInputFile);
    }
    else if(MultiByteToWideChar(CP_UTF8, 0, (LPCSTR)readBuf, sizeof(readBuf), &cIndicator, 1) == 1 &&
            cIndicator == UNICODE_INDICATOR)
        m_FileEncoding = FILE_ENCODING_UTF8;
    else
    {
        m_FileEncoding = FILE_ENCODING_ANSI;
        fseek(m_pInputFile, SEEK_SET, 0);
    }

    //
    //  File opened successfully, assign filename
    //

    m_szInputFile = szInputFile;

    hr = S_OK;

Cleanup:

    return hr;
}

HRESULT CDataFeed::CloseInputFile()
{
    HRESULT hr;

    if(m_pInputFile == NULL)
    {
        hr = S_OK;
        goto Cleanup;
    }

    if(fclose(m_pInputFile) == EOF)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        ERROR1(XEVENT_GENEALOGY_UPDATE_ERROR_CLOSE_DATA_FEED_1,
               "Closing input file failed.  Error = 0x%08X.",
               hr);
        goto Cleanup;
    }

    hr = S_OK;

Cleanup:

    m_pInputFile = NULL;
    m_szInputFile = NULL;
    m_FileEncoding = FILE_ENCODING_NONE;

    return hr;
}

BOOL CDataFeed::SkipToNextLine( FILE* m_pInputFile )
{
    BOOL bReturn;
    size_t nBytes = 0;

    //
    // read until the \n is found or EOF is found
    //

    switch(m_FileEncoding)
    {
    case FILE_ENCODING_ANSI:
    case FILE_ENCODING_UTF8: // don't bother parsing characters as utf8, we only care about \n which is one byte
        {
            CHAR c = '\0';

            do
            {
                nBytes = fread( &c, sizeof( CHAR ), 1, m_pInputFile );
            }
            while ( 0 != nBytes && '\n' != c );

            //
            // TRUE for EOL, FALSE for EOF
            //

            bReturn = ( '\n' == c );
        }
        break;

    case FILE_ENCODING_UNICODE:
        {
            WCHAR wc = L'\0';

            do
            {
                nBytes = fread( &wc, sizeof( WCHAR ), 1, m_pInputFile );
            }
            while ( 0 != nBytes && L'\n' != wc );

            //
            // TRUE for EOL, FALSE for EOF
            //

            bReturn = ( L'\n' == wc );
        }
        break;

    default:
        bReturn = FALSE;
        break;
    }

    return bReturn;
}

BOOL CDataFeed::ReadOneChar( FILE* m_pInputFile )
{
    size_t nChars = 0;
    
    //
    // read one character to the buffer
    //

    switch(m_FileEncoding)
    {
    case FILE_ENCODING_ANSI:
        nChars = fread( m_szRowData + m_dwRead, sizeof( CHAR ), 1, m_pInputFile );
        break;

    case FILE_ENCODING_UTF8:
        {
            WCHAR wc;
            int nCharsRead = 0;
            BYTE pBuf[4] = { 0, 0, 0, 0 }; // max size of a utf 8 character

            //
            //  Read as many bytes as necessary to get a single utf 8 character
            //

            while(nChars == 0 && nCharsRead < sizeof(pBuf))
            {
                if(fread( pBuf + nCharsRead, sizeof( BYTE ), 1, m_pInputFile ) == 0)
                    break;

                ++nCharsRead;

                nChars = MultiByteToWideChar(CP_UTF8, 0, (LPCSTR)pBuf, nCharsRead, &wc, 1);
            }

            //
            //  If we got one, convert from wchar back to char and insert into buffer
            //

            if(nChars != 0)
            {
                CHAR c;
                nChars = WideCharToMultiByte(CP_ACP, 0, &wc, 1, &c, 1, NULL, NULL);
                if(nChars == 1)
                {
                    *(m_szRowData + m_dwRead) = c;
                }
                else
                    nChars = 0;
            }
        }
        break;

    case FILE_ENCODING_UNICODE:
        {
            WCHAR wc;

            nChars = fread( &wc, sizeof(WCHAR), 1, m_pInputFile );

            if(nChars != 0)
            {
                CHAR c;
                nChars = WideCharToMultiByte(CP_ACP, 0, &wc, 1, &c, 1, NULL, NULL);
                if(nChars == 1)
                {
                    *(m_szRowData + m_dwRead) = c;
                }
                else
                    nChars = 0;
            }
        }
        break;

    default:
        //  Unknown encoding, treat as EOF
        break;
    }

    ++m_dwRead;

    //
    // TRUE for byte read, FALSE if not
    //

    return 0 != nChars;
}

void CDataFeed::StampDateTimes( SOnlineGaming& OnlineGaming )
{
    SYSTEMTIME st;

    GetSystemTime(&st);

    //
    // set the first/last update date time with the current time
    //

    OnlineGaming.timeAppeared = st;
}

//
//  Utility functions used by ParseLine below
//

#define TOHEX(c) ( (c >= '0' && c <= '9') ? c - '0' : tolower(c) - 'a' + 10 )

ULONG HexToBytes(LPCSTR szHexString, LPBYTE pByteArray, ULONG ulByteArrayLen)
{
    ULONG ulBytesConverted = 0;
    ULONG ulStringLen;

    // bad string pointer?
    if(szHexString == NULL)
        goto Cleanup;

    ulStringLen = (ULONG)lstrlenA(szHexString);

    //  If odd number of chars or too many, then bail.
    if(ulStringLen & 0x1 ||
       ((ulStringLen >> 1) > ulByteArrayLen) )
        goto Cleanup;

    //  convert the string
    for(; ulBytesConverted < ulByteArrayLen; ++ulBytesConverted)
    {
        char c1 = szHexString[ulBytesConverted << 1];
        char c2 = szHexString[( ulBytesConverted << 1 ) + 1];

        //  If not hex digit, then we're done
        if(!isxdigit(c1) || !isxdigit(c2))
            goto Cleanup;

        pByteArray[ulBytesConverted] = (TOHEX(c1) << 4) + TOHEX(c2);
    }

Cleanup:

    return ulBytesConverted;
}

HRESULT CDataFeed::ParseLine( SOnlineGaming& OnlineGaming )
{
    int iRet = 0;
    int iRowLen = lstrlenA(m_szRowData);
    int iExpectedFields;

	//
	// parse the strings out of the master string
	//

    if(iRowLen == FEED_ROW_LENGTH)
    {
        iExpectedFields = NUMBER_DATABASE_FIELDS;

        iRet = sscanf(  m_szRowData, 
                        PARSE_STRING, 
                        OnlineGaming.szSerialNumber, 
                        OnlineGaming.szPartNumber,
                        OnlineGaming.szOnlineKey,
                        OnlineGaming.szOnlineKeyVersion,
                        OnlineGaming.szMacAddress,
                        OnlineGaming.szGameRegion,
                        OnlineGaming.szTVRegion,
                        OnlineGaming.szIsActive );
    }
    else if(iRowLen == FEED_ROW_LENGTH_EX)
    {
        char szPPA2[(PPA2_LENGTH << 1) + 1];
        char szSPPA1[(SPPA1_LENGTH << 1) + 1];
        char szDate[32];
        char szTime[16];

        iExpectedFields = NUMBER_DATABASE_FIELDS_EX;

        iRet = sscanf(  m_szRowData, 
                        PARSE_STRING_EX, 
                        OnlineGaming.szSerialNumber, 
                        OnlineGaming.szPartNumber,
                        OnlineGaming.szOnlineKey,
                        OnlineGaming.szOnlineKeyVersion,
                        OnlineGaming.szMacAddress,
                        OnlineGaming.szGameRegion,
                        OnlineGaming.szTVRegion,
                        OnlineGaming.szIsActive,
                        szPPA2,
                        szSPPA1,
                        szDate,
                        szTime);

        if(lstrlenA(szPPA2) != (PPA2_LENGTH << 1) ||
           HexToBytes(szPPA2, OnlineGaming.abPPA2, PPA2_LENGTH) != PPA2_LENGTH)
        {
            IncrementBadCount();

            return S_FALSE;
        }

        if(lstrlenA(szSPPA1) != (SPPA1_LENGTH << 1) ||
           HexToBytes(szSPPA1, OnlineGaming.abSPPA1, SPPA1_LENGTH) != SPPA1_LENGTH)
        {
            IncrementBadCount();

            return S_FALSE;
        }

        lstrcatA(szDate, " ");
        lstrcatA(szDate, szTime);

        if(!OnlineGaming.timeAppeared.ParseDateTime(szDate))
        {
            IncrementBadCount();

            return S_FALSE;
        }
    }
    else
    {
        IncrementBadCount();

        ERROR3(XEVENT_GENEALOGY_UPDATE_ERROR_BAD_DATA_PARSE_1,
               "Wrong number of characters on line. Line had %d characters, expecting %d or %d.",
               iRowLen,
               FEED_ROW_LENGTH,
               FEED_ROW_LENGTH_EX);

        return S_FALSE;
    }

    //
    // make sure the string parsed correctly
    //

    if ( EOF == iRet )
    {
        IncrementBadCount();

        ERROR1( XEVENT_GENEALOGY_UPDATE_ERROR_EOF_FOUND_TOO_EARLY_4, "EOF Found too early on line %u\n", GetGoodCount() );

        return E_EOF_FOUND_EARLY;
    }

    //
    // make sure the EXACT number of bytes were read
    // in the second clause we add one because the date/time is read
    // in as two separate fields by sscanf and then concatenated later.
    //

    if ( NUMBER_DATABASE_FIELDS != iRet && NUMBER_DATABASE_FIELDS_EX + 1 != iRet )
    {
        IncrementBadCount();

        ERROR1( XEVENT_GENEALOGY_UPDATE_ERROR_NUM_DB_FIELDS_WRONG_1, "Wrong number of DB fields on line %u\n", GetGoodCount() );

        return S_FALSE;
    }

    //
    // make sure we did not get bogus data
    //

    if ( 0 == iRet )
    {
        IncrementBadCount();

        ERROR1( XEVENT_GENEALOGY_UPDATE_ERROR_BAD_DATA_PARSE_2, "Bad parse of data on line %u\n", GetGoodCount() );

        return S_FALSE;
    }

    return S_OK;
}

HRESULT CDataFeed::Process( SOnlineGaming& OnlineGaming )
{
    if(m_pInputFile == NULL)
        return E_UNEXPECTED;

    //
    // zero out the online gaming struct
    //

    ZeroMemory( &OnlineGaming, sizeof( SOnlineGaming ) );

    //
    // reset the bytes read
    //

    ResetReadCounter();

    //
    // read from the file, byte by byte
    //

    do
    {
        if ( ! ReadOneChar( m_pInputFile ) )
        {
            //
            // if we are at the first char of the file, then EOF is acceptable
            //

            if ( AtFirstPos() )
            {
                return S_EOF_FOUND;
            }
            else
            {
                ERROR1( XEVENT_GENEALOGY_UPDATE_ERROR_EOF_FOUND_TOO_EARLY_5, "EOF found too early on line %u\n", GetGoodCount() );
                return E_EOF_FOUND_EARLY;
            }
        }

        //
        // if we've read enough data, check if this is a header row. if it is, skip it
        //

        if ( IsHeaderRow() )
        {
            IncrementGoodCount();
            IncrementBadCount();
            //
            // goto next valid row
            //

            if ( ! SkipToNextLine( m_pInputFile ) )
            {
                ERROR1( XEVENT_GENEALOGY_UPDATE_ERROR_EOF_FOUND_TOO_EARLY_6, "EOF found too early on line %u\n", GetGoodCount() );
                return E_EOF_FOUND_EARLY;
            }

            ERROR1( XEVENT_GENEALOGY_WARN_TITLE_ROW_DISCARDED_1, "Title row found on line %u\n", GetGoodCount() );

            return S_FALSE;
        }
    } 

    //
    // until we are done reading
    //

    while ( ! DoneReading() );

    //
    // if we've made it here, then a line was consumed (even if it was bogus)
    //

    IncrementGoodCount();

    //
    // stamp the dates and times
    //

    StampDateTimes( OnlineGaming );

    //
    // see if we encountered end of line to early 
    //

    if ( LineTooShort() )
    {
        IncrementBadCount();

        ERROR1( XEVENT_GENEALOGY_UPDATE_ERROR_EOL_FOUND_TOO_EARLY_1, "End of line found too early on line %u\n", GetGoodCount() );

        return S_FALSE;
    }

    //
    // or too late
    //

    if ( LineTooLong() )
    {
        IncrementBadCount();

        //
        // skip until next row
        //

        if ( ! SkipToNextLine( m_pInputFile ) )
        {
            ERROR1( XEVENT_GENEALOGY_UPDATE_ERROR_EOF_FOUND_TOO_EARLY_7, "EOF found too early on line %u\n", GetGoodCount() );
            return E_EOF_FOUND_EARLY;
        }

        ERROR1( XEVENT_GENEALOGY_UPDATE_ERROR_LINE_TOO_LONG_1, "Extra data encountered on line %u\n", GetGoodCount() );

        return S_FALSE;
    }

    //
    // now parse the line
    //

    return ParseLine( OnlineGaming );
}

// EOF
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\genealogy\Genealogy\objd\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86_genealogy_none_12.4.56.0_none_92559d88a0bbe63b
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86_genealogy_no-public-key_12.4.56.0_x-ww_69f457d7
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=genealogy
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86_genealogy_no-public-key_12.4.56.0_x-ww_69f457d7
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86_genealogy_no-public-key_12.4.56.0_x-ww_69f457d7.manifest
XP_MANIFEST_PATH=manifests\x86_genealogy_no-public-key_12.4.56.0_x-ww_69f457d7.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86_genealogy_no-public-key_12.4.56.0_x-ww_69f457d7.cat
XP_CATALOG_PATH=manifests\x86_genealogy_no-public-key_12.4.56.0_x-ww_69f457d7.cat
XP_PAYLOAD_PATH=x86_genealogy_no-public-key_12.4.56.0_x-ww_69f457d7
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=genealogy,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\genealogy\genesvc\constants.h ===
///////////////////////////////////////////////////////////////////////////////
//
// Name: constants.h
//
// Author: Dan Rosenstein (danrose)
//
// Description: the constants used in the genealogy tool
//
///////////////////////////////////////////////////////////////////////////////

#pragma once

//
// unicode indicator
//

static const WCHAR UNICODE_INDICATOR = 0xFEFF;

//
// update parsing error codes
//

static const HRESULT S_EOF_FOUND              = 0x0000FFFF;
static const HRESULT E_EOF_FOUND_EARLY        = 0xF000FFFF;

//
// lengths of data fields from db
//

static const DWORD XBSERIAL_NUMBER_LENGTH = 12;
static const DWORD PART_NUMBER_LENGTH = 9;
static const DWORD ONLINE_KEY_LENGTH = 172;
static const DWORD ONLINE_KEY_VERSION_LENGTH = 4;
static const DWORD MAC_ADDRESS_LENGTH = 12;
static const DWORD GAME_REGION_CODE_LENGTH = 8;
static const DWORD TV_REGION_CODE_LENGTH = 8;
static const DWORD IS_ACTIVE_LENGTH = 1;
static const DWORD PPA2_LENGTH = 8;
static const DWORD SPPA1_LENGTH = 20;

static const DWORD ENVIRONMENT_MASK_LENGTH = sizeof(USHORT);

//
// bind sizes
//

static const DWORD GAMING_TABLE_BIND_SIZE = 11;
static const DWORD PART_TABLE_BIND_SIZE = 1;

//
// the maximum length of a data feed row
//

static const DWORD FEED_ROW_LENGTH    = 235; // first eight fields only
static const DWORD FEED_ROW_LENGTH_EX = 313; // all fields, includes ppa2, sppa1 and date

//
// the number of fields in the database
//

static const DWORD NUMBER_DATABASE_FIELDS    = 8;
static const DWORD NUMBER_DATABASE_FIELDS_EX = 11;

//
// number of bytes in the header compare string
//

static const DWORD HEADER_COMPARE_STRING_LENGTH = 12;

//
// value used to dictate that we read a title row
//

static const DWORD TITLE_ROW_VALUE = 0xFFFFFFFF;

//
// the text used to id a header row
//

static const LPSTR HEADER_COMPARE_STRING = "SerialNumber";

//
// the parse string for a data feed row
//

static const LPSTR PARSE_STRING    = "%12s %9s %172s %4s %12s %8s %8s %1s";
static const LPSTR PARSE_STRING_EX = "%12s %9s %172s %4s %12s %8s %8s %1s %16s %40s %10s %8s";

//
// the db init string
//

static const WCHAR* DB_INIT_STRING = 
    L"Provider=SQLOLEDB; Initial Catalog=%S; Data Source=%S; Trusted_Connection=yes";

//
// the update genealogy sproc call
//

static const WCHAR* UPDATE_GENEALOGY_SPROC_CALL_STRING = 
    L"{ %T = CALL dbo.p_update_genealogy;1 ( %S, %S, %S, %S, %S, %S, %S, %S, %vlB, %vlB, %D ) }";

//
// the geneErrors sproc call
//

static const WCHAR* BAD_GENE_SPROC_CALL_STRING =  
    L"{ %T = CALL dbo.p_BadGene;1 ( %S, %S, %S, %D ) }";

//
// the get part number sproc call
//

static const WCHAR* GET_PARTNUMBERS_SPROC_CALL_STRING = 
    L"{ %T = CALL dbo.p_get_partnumbers;1 }";

//
// the update part number sproc call
//

static const WCHAR* UPDATE_PARTNUMBERS_SPROC_CALL_STRING = 
    L"{ %T = CALL dbo.p_set_part_number;1 ( %S ) }";
static const WCHAR* UPDATE_PARTNUMBERS_SPROC_CALL_STRING_EX = 
    L"{ %T = CALL dbo.p_set_part_number_ex;1 ( %S, %N ) }";

//
// datacenter environment definitions
//

#define REF             0
#define DEV             1
#define TEST            2
#define PARTNER         3
#define BETA            4
#define CERT            5
#define PREPROD         6
#define PROD            7
#define MAXENV          8

#define REF_MASK        (1 << REF)
#define DEV_MASK        (1 << DEV)
#define TEST_MASK       (1 << TEST)
#define PARTNER_MASK    (1 << PARTNER)
#define BETA_MASK       (1 << BETA)
#define CERT_MASK       (1 << CERT)
#define PREPROD_MASK    (1 << PREPROD)
#define PROD_MASK       (1 << PROD)

#define IGNORE_MASK     0x8000 // Used to indicate that no environment information is here
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\genealogy\genesvc\Base64.cpp ===
/*++

    Copyright (c) Microsoft Corporation

    Module Name:

        Base64.cpp

    Abstract:

        Base64 encode/decode functions.

--*/

#include "stdinc.h"
#include "Base64.h"

BYTE g_achBase64DecodeTable[256]={
    64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,
    64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,62,64,64,64,63,
    52,53,54,55,56,57,58,59,60,61,64,64,64,64,64,64,64,0,1,2,3,4,5,6,7,8,9,
    10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,64,64,64,64,64,64,26,27,
    28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,
    64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,
    64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,
    64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,
    64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,
    64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,
    64,64,64,64,64,64,64,64,64,64,64,64,64
};

CHAR g_achBase64EncodeTable[64] = {
    'A','B','C','D','E','F','G','H','I','J','K','L','M',
    'N','O','P','Q','R','S','T','U','V','W','X','Y','Z',
    'a','b','c','d','e','f','g','h','i','j','k','l','m',
    'n','o','p','q','r','s','t','u','v','w','x','y','z',
    '0','1','2','3','4','5','6','7','8','9','+','/'
};

BOOL WINAPI
Base64Decode(
    LPCSTR  pszSrc,
    ULONG   ulSrcSize,
    LPBYTE  pDst,
    PULONG  pulDstSize
    )

/*++

Routine Description:

    Base64Decode    This method decodes a Base-64 encoded chunk of binary data.

Arguments:

    pszSrc      Points to Base64-encoded string to decode.

    ulSrcSize   Length of the string pointed to by pszSrc, not including 
                terminating null character.

    pDst        Buffer to copy the decoded binary data into.  The size of this
                buffer must be at least BASE64_DECODE_BUFFER_SIZE(ulSrcSize)

    pulDstSize  On return contains the length in bytes of the decoded buffer.

Return Value:

     0 - Decode was successful.

--*/

{
    ULONG   ulIndex;
    ULONG   ulCurOut;
    DWORD   dwGroup;
    DWORD   dwCur;
    DWORD   dwPadSeen;
    CHAR    chCur;

    dwGroup  = 0;
    dwPadSeen = 0;
    ulCurOut = 0;

    if(ulSrcSize % 4 != 0)
        return FALSE;

    for(ulIndex = 0; ulIndex < ulSrcSize; ulIndex++)
    {
        chCur = pszSrc[ulIndex];
        if(chCur == '=')
        {
            dwPadSeen++;
            dwCur = 0;
        }
        else
        {
            dwCur = g_achBase64DecodeTable[chCur];
        }
        assert( dwCur != 64 );
        
        dwGroup |= (dwCur << (6 * (ulIndex & 0x3)));

        if((ulIndex & 0x3) == 0x3)
        {
            pDst[ulCurOut++] = (CHAR)( dwGroup        & 0xff);

            if(dwPadSeen <= 1)
            {
                pDst[ulCurOut++] = (CHAR)((dwGroup >>  8) & 0xff);

                if(dwPadSeen == 0)
                    pDst[ulCurOut++] = (CHAR)((dwGroup >> 16) & 0xff);
            }

            dwGroup = 0;
        }
    }

    *pulDstSize = ulCurOut;
    assert( ulCurOut <= BASE64_DECODE_BUFFER_SIZE(ulSrcSize) );
    
    return TRUE;
}

BOOL WINAPI
Base64Encode(
    const LPBYTE    pSrc,
    ULONG           ulSrcSize,
    LPSTR           pszDst
    )

/*++

Routine Description:

    Base64Encode    This method converts a buffer of arbitrary binary data into
                    a Base-64 encoded string.

Arguments:

    pSrc        Points to the buffer of bytes to encode.

    ulSrcSize   Number of bytes in pSrc to encode.

    pszDst      Buffer to copy the encoded output into.  The length of the buffer
                must be at least BASE64_ENCODE_BUFFER_SIZE(ulSrcSize).

Return Value:

     0 - Encoding successful.

--*/

{
    DWORD   dwGroup;
    ULONG   ulCurGroup = 0, ulIndex;

    for(ulIndex = 0; ulIndex < (ulSrcSize - (ulSrcSize % 3)); ulIndex += 3)
    {
        dwGroup = (pSrc[ulIndex+2] << 16) | (pSrc[ulIndex+1] << 8) | pSrc[ulIndex];

        pszDst[ulCurGroup++] = g_achBase64EncodeTable[  dwGroup        & 0x3f ];
        pszDst[ulCurGroup++] = g_achBase64EncodeTable[ (dwGroup >> 6)  & 0x3f ];
        pszDst[ulCurGroup++] = g_achBase64EncodeTable[ (dwGroup >> 12) & 0x3f ];
        pszDst[ulCurGroup++] = g_achBase64EncodeTable[ (dwGroup >> 18) & 0x3f ];
    }

    //  Do the end special case.
    switch(ulSrcSize % 3)
    {
    case 2:
        dwGroup = (pSrc[ulIndex+1]  << 8)| pSrc[ulIndex];

        pszDst[ulCurGroup++] = g_achBase64EncodeTable[  dwGroup        & 0x3f ];
        pszDst[ulCurGroup++] = g_achBase64EncodeTable[ (dwGroup >> 6)  & 0x3f ];
        pszDst[ulCurGroup++] = g_achBase64EncodeTable[ (dwGroup >> 12) & 0x3f ];
        pszDst[ulCurGroup++] = '=';

        break;

    case 1:
        dwGroup = pSrc[ulIndex];

        pszDst[ulCurGroup++] = g_achBase64EncodeTable[  dwGroup        & 0x3f ];
        pszDst[ulCurGroup++] = g_achBase64EncodeTable[ (dwGroup >> 6)  & 0x3f ];
        pszDst[ulCurGroup++] = '=';
        pszDst[ulCurGroup++] = '=';

        break;
    }

    //  Null terminate the string.
    pszDst[ulCurGroup] = 0; 
    assert( ulCurGroup < BASE64_ENCODE_BUFFER_SIZE(ulSrcSize) );
    
    return TRUE;
}

// EOF
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\genealogy\genesvc\DataFeed.h ===
///////////////////////////////////////////////////////////////////////////////
//
// Name: DataFeed.h
//
// Author: Dan Rosenstein (danrose)
//
// Description: the interfrace for the data feed class
//
///////////////////////////////////////////////////////////////////////////////

#pragma once

///////////////////////////////////////////////////////////////////////////////
//
// CDataFeed class - class used to abstract out importing of genealogy feeds
//
///////////////////////////////////////////////////////////////////////////////

typedef enum { FILE_ENCODING_NONE = 0, FILE_ENCODING_ANSI, FILE_ENCODING_UTF8, FILE_ENCODING_UNICODE } FILE_ENCODING;

class CDataFeed
{
public:

    //
    // constructor and destructor
    //

    CDataFeed( void );
    ~CDataFeed( void );

    //
    // tell this object which file to process
    //

    HRESULT OpenInputFile(LPCSTR szInputFile);
    HRESULT CloseInputFile(void);

    //
    // public processing function
    //

    HRESULT Process( SOnlineGaming& OnlineGaming );

    //
    // accessors
    //

    DWORD GetGoodCount( void ) { return m_dwCount; };
    DWORD GetBadCount( void ) { return m_dwBadCount; };

    LPSTR GetRowData( void ) { return m_szRowData; };

    LPCSTR GetInputFile( void ) { return m_szInputFile; };

    //
    // counter handlers
    //

    void IncrementGoodCount( void ) { ++m_dwCount; };
    void IncrementBadCount( void ) { ++m_dwBadCount; };

private:

    //
    // quick logic checkers
    //

    BOOL IsHeaderRow( void ) { return HEADER_COMPARE_STRING_LENGTH == m_dwRead && 0 == strcmp( m_szRowData, HEADER_COMPARE_STRING ); }
    BOOL AtEndOfLineChar( void ) { return '\n' == m_szRowData[m_dwRead-1]; };
    BOOL AtEndOfLinePos( void ) { return ((FEED_ROW_LENGTH_EX == m_dwRead) || (FEED_ROW_LENGTH == m_dwRead)); };
    BOOL AtFirstPos( void ) { return 1 == m_dwRead; };
    BOOL DoneReading( void ) { return AtEndOfLineChar(); };
    BOOL LineTooShort( void ) { return ! AtEndOfLinePos() && AtEndOfLineChar(); };
    BOOL LineTooLong( void ) { return AtEndOfLinePos() && ! AtEndOfLineChar(); };

    //
    // skip reading to the next line
    //
    
    BOOL SkipToNextLine( FILE* pInputFile );

    //
    // function to read one char at a time
    //

    BOOL ReadOneChar( FILE* pInputFile );

    //
    // parse the line once it's been read
    // 

    HRESULT ParseLine( SOnlineGaming& OnlineGaming );

    //
    // add the date/time to the online gaming struct
    //

    void StampDateTimes( SOnlineGaming& OnlineGaming );

    //
    // function to reset parsing state
    //

    void ResetReadCounter( void ) { m_dwRead = 0; ZeroMemory( m_szRowData, FEED_ROW_LENGTH_EX + 1 ); };

    //
    // the count of good and bad lines read
    //

    DWORD m_dwCount;
    DWORD m_dwBadCount;

    //
    // the number of chars read on this line
    //

    DWORD m_dwRead;

	//
	// place to hold the line by line data
	//

    CHAR m_szRowData[FEED_ROW_LENGTH_EX + 1];

    //
    // input file name
    //

    LPCSTR m_szInputFile;

    //
    // input file
    //

    FILE* m_pInputFile;

    //
    // is the file unicode, utf8 or ansi?
    //

    FILE_ENCODING m_FileEncoding;
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\genealogy\genesvc\dbutil.h ===
#pragma once

#ifndef __DBUTIL_H
#define __DBUTIL_H

extern HRESULT Export(LPCSTR szDSN, LPCSTR szQuery);
extern HRESULT InitODBWSession(LPCSTR szMachineName, LPCSTR szDBName, CODBWSession& ses);


#endif // __DBUTIL_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\genealogy\genesvc\dbutil.cpp ===
#include "stdinc.h"
#include "dbutil.h"

//
//  Utility function to perform a bulk copy export given a DSN and query string.
//

HRESULT Export(
    LPCSTR  szDSN,                
    LPCSTR  szQuery
    )
{
    HRESULT             hr = S_OK;
    SQLHENV             henv = SQL_NULL_HENV;
    HDBC                hdbc1 = SQL_NULL_HDBC;
    CHAR                szOutConnStr[1024];
    SQLSMALLINT         swStrLen;

    //
    //  Allocate an ODBC environment handle
    //

    // Allocate the ODBC environment and save handle.
    IF_SQL_ERROR(SQLAllocHandle (SQL_HANDLE_ENV, NULL, &henv));
    IF_SQL_ERROR(SQLSetEnvAttr(henv, 
                            SQL_ATTR_ODBC_VERSION,
                            (SQLPOINTER) SQL_OV_ODBC3,
                            SQL_IS_INTEGER));

    // Allocate ODBC connection handle, set bulk copy mode, and 
    // then connect.
    IF_SQL_ERROR(SQLAllocHandle(SQL_HANDLE_DBC, henv, &hdbc1));
    IF_SQL_ERROR(SQLSetConnectAttr(hdbc1, SQL_COPT_SS_BCP,
                                (void *)SQL_BCP_ON,
                                SQL_IS_INTEGER));
    IF_SQL_ERROR(SQLDriverConnect(hdbc1, 
                                  NULL,
                                  (SQLCHAR*)szDSN, 
                                  SQL_NTS,
                                  (SQLCHAR*)szOutConnStr, 
                                  sizeof(szOutConnStr), 
                                  &swStrLen, 
                                  SQL_DRIVER_NOPROMPT));


    hr = S_OK;

Cleanup:

    /* Clean up. */
    if(hdbc1 != SQL_NULL_HDBC)
    {
        SQLDisconnect(hdbc1);
        SQLFreeHandle(SQL_HANDLE_DBC, hdbc1);
    }

    if(henv != SQL_NULL_HENV)
    {
        SQLFreeHandle(SQL_HANDLE_ENV, henv);
    }

    return hr;
}

//
//  Get a session to the database
//

HRESULT InitODBWSession(
    LPCSTR          szMachineName,
    LPCSTR          szDBName,    
    CODBWSession&   ses
    )
{
    HRESULT hr;
    int     iRet;
    WCHAR   wszDBInitString[MAX_PATH];

    if(szMachineName == NULL || szDBName == NULL)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

	//
	// create the full DB init string
	//

	iRet = swprintf( wszDBInitString, DB_INIT_STRING, szDBName, szMachineName );

	//
	// make sure the length of the new string is correct
	//

	if ( iRet != wcslen( wszDBInitString ) )
	{
		hr = E_FAIL;
		ERROR3( XEVENT_GENEALOGY_ERROR_DB_INIT_STRING_CREATE_1, 
                "creation of db init string %S failed. Expected %u, got %u\n", 
                wszDBInitString, 
                wcslen( wszDBInitString ), 
                iRet );
	}

    //
    //  Initialize the session
    //

    hr = ses.InitializeEx(wszDBInitString, FALSE);
    if(FAILED(hr))
    {
        ERROR2(XEVENT_GENEALOGY_ERROR_DB_OPEN_FAILED_1,
               "Initializing database session specified by \"%ls\" failed with error = 0x%08X",
               wszDBInitString,
               hr);
        goto Cleanup;
    }

    //
    //  Success, assign out param and return code
    //

    hr = S_OK;

Cleanup:

    return hr;
}

// EOF
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\genealogy\genesvc\global.h ===
#pragma once

#ifndef __GLOBAL_H
#define __GLOBAL_H

extern  CParams             g_Params;
extern  CPartNumberTable*   g_pParts;
extern  LPCSTR              g_szEnvStrings[MAXENV];
extern  string              g_cszOutputPaths[MAXENV];

#endif // __GLOBAL_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\genealogy\genesvc\Genealogy.h ===
///////////////////////////////////////////////////////////////////////////////
//
// Name: Genealogy.h
//
// Author: Dan Rosenstein (danrose)
//
// Description: the interface for the CGenealogy object
//
///////////////////////////////////////////////////////////////////////////////

#pragma once

///////////////////////////////////////////////////////////////////////////////
//
// necessary includes
//
///////////////////////////////////////////////////////////////////////////////

#include "Params.h"
#include "nCipher.h"
#include "DataFeed.h"
#include "Xrc4.h"

///////////////////////////////////////////////////////////////////////////////
//
// CGenealogy class - class used to access Genealogy DB and act accordingly
//
///////////////////////////////////////////////////////////////////////////////

class CGenealogy
{
public:

    //
    // constructor and destructor
    //

    CGenealogy( CODBWSession* pSes, CNCipher* pNCipher );
    ~CGenealogy( void );

    //
    // init function
    //

    HRESULT Init( void );

    //
    // process function
    //

    HRESULT Process( LPCSTR szFileName );

private:

    //
    // verify or update
    //

    HRESULT Update( LPCSTR szFileName );

    //
    // compute the PPA info for the online gaming struct
    //

    BOOL ComputePPA( LPBYTE abKey, SOnlineGaming& OnlineGaming );

    //
    // preform the update
    //

    HRESULT Update( SOnlineGaming& OnlineGaming );

    //
    // validate the individual fields of a game record
    //

    BOOL CompareStrings( LPSTR szFirst, LPSTR szSecond, LPSTR szString );
    BOOL OnlineKeyContainsValidData( SOnlineGaming& OnlineGaming );
    BOOL ValidateInternalOnlineKey( LPBYTE pOnlineKey );
    BOOL ValidateInternalSerialNumber( LPSTR szSerialNumber );
    BOOL ValidateInternalGameRegion( LPSTR szGameRegion );
    BOOL ValidateInternalMacAddress( LPSTR szMacAddress );
    BOOL ValidateInternalTVRegion( LPSTR szTVRegion );
    BOOL ValidateString( LPSTR szString, LPSTR szStringName, DWORD dwLength, CHAR chMinVal, CHAR chMaxVal );
    BOOL ValidateSerialNumberValue( LPSTR szSerialNumber );
    BOOL ValidateSerialNumber( LPSTR szSerialNumber );
    BOOL ValidatePartNumber( LPSTR szPartNumber );
    BOOL ValidateOnlineKey( SOnlineGaming& OnlineGaming );
    BOOL ValidateOnlineKeyVersion( LPSTR szOnlineKeyVersion );
    BOOL ValidateMacAddress( LPSTR szMacAddress );
    BOOL ValidateGameRegion( LPSTR szGameRegion );
    BOOL ValidateTVRegion( LPSTR szTVRegion );
    BOOL ValidateIsActive( LPSTR szISActive );

    //
    // validate a gaming record
    //

    BOOL Validate( SOnlineGaming& OnlineGaming );

    //
    // make sure a record belongs in this db
    //

    BOOL RecordBelongs( LPSTR szPartNumber );

    //
    // enter an error in the error table
    //

    void ReportError( void );

    //
    // write the datafeed buffer( or the current online gaming struct) to the output file
    //

    //  void WriteBufferToOutputFile( SOnlineGaming& OnlineGaming = NULL );

    //
    // the db session
    //

    CODBWSession* m_pSes;

    //
    // the caches
    //

    CWSProcCache* m_pGamingTableCache;
    CWSProcCache* m_pErrorCache;

    //
    // the nCipher
    // 

    CNCipher* m_pNCipher;

    //
    // the data feed
    //

    CDataFeed* m_pDataFeed;

    //
    // the count of good and bad records
    //

    DWORD m_dwCount;
    DWORD m_dwBadCount;

    //
    // array of output file handles, one for each environment
    //

    FILE* m_ahOutputFiles[MAXENV];

    //
    // the bindings
    //

    static DBBINDING m_partBind[];
    static DBBINDING m_gamingBind[];
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\genealogy\genesvc\Genealogy.cpp ===
#include "stdinc.h"

//
// the global error string
//

CHAR g_szError[1024];
HANDLE g_hEventSource = NULL;

//
// the part table binding
//

DBBINDING CGenealogy::m_partBind[] = { 
    WSBIND( 1, offsetof( SOnlineGaming, szPartNumber ), DBTYPE_STR, PART_NUMBER_LENGTH + 1 ) 
};

//
// the gaming table binding
//

DBBINDING CGenealogy::m_gamingBind[] = { 
    WSBIND( 1, offsetof( SOnlineGaming, szSerialNumber ), DBTYPE_STR, XBSERIAL_NUMBER_LENGTH + 1 ),
    WSBIND( 2, offsetof( SOnlineGaming, szPartNumber ), DBTYPE_STR, PART_NUMBER_LENGTH + 1 ),
    WSBIND( 3, offsetof( SOnlineGaming, szOnlineKey ), DBTYPE_STR, ONLINE_KEY_LENGTH + 1 ),
    WSBIND( 4, offsetof( SOnlineGaming, szOnlineKeyVersion ), DBTYPE_STR, ONLINE_KEY_VERSION_LENGTH + 1 ),
    WSBIND( 5, offsetof( SOnlineGaming, szMacAddress ), DBTYPE_STR, MAC_ADDRESS_LENGTH + 1 ),
    WSBIND( 6, offsetof( SOnlineGaming, szGameRegion ), DBTYPE_STR, GAME_REGION_CODE_LENGTH + 1 ),
    WSBIND( 7, offsetof( SOnlineGaming, szTVRegion ), DBTYPE_STR, TV_REGION_CODE_LENGTH + 1 ),
    WSBIND( 8, offsetof( SOnlineGaming, szIsActive ), DBTYPE_STR, IS_ACTIVE_LENGTH + 1 ),
    WSBIND( 9, offsetof( SOnlineGaming, abPPA2 ), DBTYPE_BYTES, PPA2_LENGTH ),
    WSBIND( 10, offsetof( SOnlineGaming, abSPPA1 ), DBTYPE_BYTES, SPPA1_LENGTH ),
    WSBIND( 11, offsetof( SOnlineGaming, timeAppeared ), DBTYPE_DATE, sizeof( COleDateTime ) )
};

CGenealogy::CGenealogy( CODBWSession* pSes, CNCipher* pNCipher )
    : m_pSes( pSes ),
      m_pGamingTableCache( NULL ),
      m_pErrorCache( NULL ),
      m_pNCipher( pNCipher ),
      m_pDataFeed( NULL ),
      m_dwCount( 0 ),
      m_dwBadCount( 0 )
{
    memset(m_ahOutputFiles, 0, sizeof(m_ahOutputFiles));
}

CGenealogy::~CGenealogy( void )
{
    //
    // destory the gaming table cache
    //

    if ( m_pGamingTableCache )
    {
        delete m_pGamingTableCache;
        m_pGamingTableCache = NULL;
    }

    //
    // destory the error cache
    //

    if ( m_pErrorCache )
    {
        delete m_pErrorCache;
        m_pErrorCache = NULL;
    }

    //
    // kill the data feed file
    //

    if ( m_pDataFeed )
    {
        delete m_pDataFeed;
        m_pDataFeed = NULL;
    }
}

BOOL CGenealogy::RecordBelongs( LPSTR szPartNumber )
{
    //
    // make sure this entry belongs in this DB
    //

    if(g_pParts->Exists(szPartNumber))
        return TRUE;

    ERROR1( XEVENT_GENEALOGY_ERROR_INVALID_PART_NUMBER_1, "%s is an invalid part number\n", szPartNumber );

    return FALSE;
}

BOOL CGenealogy::ValidateString( LPSTR szString, LPSTR szStringName, DWORD dwLength, CHAR chMinVal, CHAR chMaxVal )
{
    //
    // check the length of the string
    //

    if ( dwLength != strlen( szString ) )
    {
        ERROR3( XEVENT_GENEALOGY_VERIFY_WRONG_STRING_LENGTH_1, "String %s is wrong length: expected %u, got %u\n", szStringName, strlen( szString ), dwLength );
        return FALSE;
    }

    //
    // check the chars within the string
    //

    for ( DWORD i = 0; i < dwLength; i++ )
    {
        if ( szString[i] < chMinVal || szString[i] > chMaxVal )
        {
            ERROR2( XEVENT_GENEALOGY_VERIFY_BAD_STRING_DATA_1, "String %s has bad character %c\n", szStringName, szString[i] );
          
            return FALSE;
        }
    }

    //
    // string is good!
    //

    return TRUE;
}

BOOL CGenealogy::ValidateInternalOnlineKey( LPBYTE pOnlineKey )
{
    BOOL bResult = TRUE;

    return TRUE;
}

BOOL CGenealogy::ComputePPA( LPBYTE abKey, SOnlineGaming& OnlineGaming )
{
    BOOL bVal = FALSE;

    //
    // compute the PPA and the SPPA based on the online key and sn
    //

    bVal =  GenPPAforDB( OnlineGaming.szSerialNumber, 
                        (const XOCryptoKeyStruct *) abKey,
                        (XOCryptoSPPAStruct *) OnlineGaming.abSPPA1,
                        (XOCryptoPPAStruct *) OnlineGaming.abPPA2 );

    //
    // error if failure
    //

    if ( ! bVal )
    {
        ERROR1( XEVENT_GENEALOGY_VERIFY_ERROR_COMPUTE_PPA_1, "Could not compute PPA for SN %s\n", OnlineGaming.szSerialNumber );
    }

    return bVal;

}

BOOL CGenealogy::OnlineKeyContainsValidData( SOnlineGaming& OnlineGaming )
{
    if(m_pNCipher != NULL)
    {
        BOOL bReportError = FALSE;
        SOnlineGaming onlineGaming;
        ZeroMemory( &onlineGaming, sizeof( SOnlineGaming ) );

        //
        // decode the online key using the nCipher
        //

        XBOX_ENCRYPTED_ONLINE_DATA* pData = m_pNCipher->DecodeKey( OnlineGaming.szOnlineKey );

        //
        // if decoding failed, then fail
        //

        if ( NULL == pData )
        {
            return FALSE;
        }

        //
        // create strings from data
        //

        sprintf( onlineGaming.szSerialNumber, "%12.12s", pData->XboxSerialNumber );

        for ( DWORD i = 0; i < ETHERNET_MAC_ADDR_LEN; i++ )
        {
            sprintf( onlineGaming.szMacAddress + i * 2, "%2.2X", pData->MACAddress[i] );
        }

        sprintf( onlineGaming.szGameRegion, "%8.8u", pData->GameRegion );
        sprintf( onlineGaming.szTVRegion, "%8.8u", pData->AVRegion );

        if( !ValidateInternalSerialNumber( onlineGaming.szSerialNumber ) ||
            !ValidateInternalOnlineKey( pData->OnlineKey ) )
            return FALSE;

        //
        //  If any inner/outer mismatch, copy inner data to outer
        //

        if( !CompareStrings( OnlineGaming.szSerialNumber, onlineGaming.szSerialNumber, "Serial Number" ) )
        {
            bReportError = TRUE;
            memcpy(OnlineGaming.szSerialNumber, onlineGaming.szSerialNumber, XBSERIAL_NUMBER_LENGTH + 1);
        }

        if( !CompareStrings( OnlineGaming.szMacAddress, onlineGaming.szMacAddress, "Mac Address" ) )
        {
            bReportError = TRUE;
            memcpy(OnlineGaming.szMacAddress, onlineGaming.szMacAddress, MAC_ADDRESS_LENGTH + 1);
        }

        if( !CompareStrings( OnlineGaming.szGameRegion, onlineGaming.szGameRegion, "Game Region" ) )
        {
            bReportError = TRUE;
            memcpy(OnlineGaming.szGameRegion, onlineGaming.szGameRegion, GAME_REGION_CODE_LENGTH + 1);
        }

        //
        //  Compute PPA
        //

        if( !ComputePPA( pData->OnlineKey, OnlineGaming ) )
        {
            return FALSE;
        }

        //
        //  Do we need to report this row as an error?
        //

        if(bReportError)
            ReportError();

        //
        // non-critical validation
        //

        ValidateInternalGameRegion( onlineGaming.szGameRegion );
        ValidateInternalMacAddress( onlineGaming.szMacAddress );
        ValidateInternalTVRegion( onlineGaming.szTVRegion );

        return TRUE;
    }
    else
    {
        //
        //  In this case, we expect the online gaming struct to contain PPA data
        //

        static BYTE g_abEmptyPPA2[PPA2_LENGTH] = 
        {
            0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0
        };
        static BYTE g_abEmptySPPA1[SPPA1_LENGTH] = 
        {
            0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
            0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
            0x0, 0x0, 0x0, 0x0
        };

        BOOL bReturn = ( memcmp(OnlineGaming.abPPA2,  g_abEmptyPPA2,  sizeof(g_abEmptyPPA2))  != 0 &&
                         memcmp(OnlineGaming.abSPPA1, g_abEmptySPPA1, sizeof(g_abEmptySPPA1)) != 0 );

        if(!bReturn)
        {
            ERROR0(XEVENT_GENEALOGY_ERROR_MISSING_PPA_DATA_IN_ROW, 
                   "PPA data was expected in the data feed row because the service is running in import mode.  "
                   "The data feed row did not contain PPA data and was not imported.  "
                   "Check the errors table for the complete row.");
        }

        return bReturn;
    }
}

BOOL CGenealogy::CompareStrings( LPSTR szFirst, LPSTR szSecond, LPSTR szString )
{
    if ( 0 != strcmp( szFirst, szSecond ) )
    {
        ERROR3( XEVENT_GENEALOGY_VERIFY_ERROR_INTERNAL_EXTERNAL_COMPARE_1, "Internal/External %s Compare failed. External: %s  Internal: %s\n", szString, szFirst, szSecond );
        return FALSE;
    }

    return TRUE;
}

BOOL CGenealogy::ValidateSerialNumberValue( LPSTR szSerialNumber )
{
    //
    // must be all 9's or pass PSS
    //

    if ( 0 != strcmp( szSerialNumber, "999999999999" ) && 
         0 != ( ( ( szSerialNumber[0] - '0' ) +
                  ( szSerialNumber[1] - '0' ) +
                  ( szSerialNumber[2] - '0' ) +
                  ( szSerialNumber[3] - '0' ) +
                  ( szSerialNumber[4] - '0' ) +
                  ( szSerialNumber[5] - '0' ) +
                  ( szSerialNumber[6] - '0' ) ) % 7 ) )
    {
        ERROR1( XEVENT_GENEALOGY_VERIFY_BAD_SERIAL_NUMBER_VALUE_1, "Serial number value %s does not verify\n", szSerialNumber );
        return FALSE;
    }

    return TRUE;
}

BOOL CGenealogy::ValidateInternalSerialNumber( LPSTR szSerialNumber )
{
    return ValidateString( szSerialNumber, "Internal Serial Number", XBSERIAL_NUMBER_LENGTH, '0', '9' );
}

BOOL CGenealogy::ValidateInternalGameRegion( LPSTR szGameRegion )
{
    return ValidateString( szGameRegion, "Internal Game Region", GAME_REGION_CODE_LENGTH, '0', '9' );
}

BOOL CGenealogy::ValidateInternalMacAddress( LPSTR szMacAddress )
{
    return ValidateString( szMacAddress, "Internal Mac Address", MAC_ADDRESS_LENGTH, '0', 'F' );
}

BOOL CGenealogy::ValidateInternalTVRegion( LPSTR szTVRegion )
{
    return ValidateString( szTVRegion, "Internal TV Region", TV_REGION_CODE_LENGTH, '0', '9' );
}

BOOL CGenealogy::ValidateSerialNumber( LPSTR szSerialNumber )
{
    return ValidateString( szSerialNumber, "Serial Number", XBSERIAL_NUMBER_LENGTH, '0', '9' ) &&
           ValidateSerialNumberValue( szSerialNumber );
}

BOOL CGenealogy::ValidatePartNumber( LPSTR szPartNumber )
{
    BOOL bReturn;

    if( !ValidateString( szPartNumber, "Part Number", PART_NUMBER_LENGTH, '-', 'z' ) )
    {
        bReturn = FALSE;
    }
    else
    {
        //
        //  This will spit out an event if the part number is unknown, but
        //  processing will now continue in this case.
        //

        RecordBelongs( szPartNumber );

        bReturn = TRUE;
    }

    return bReturn;
}

BOOL CGenealogy::ValidateOnlineKey( SOnlineGaming& OnlineGaming )
{
    return ValidateString( OnlineGaming.szOnlineKey, "Online Key", ONLINE_KEY_LENGTH, '+', 'z' ) &&
           OnlineKeyContainsValidData( OnlineGaming );
}

BOOL CGenealogy::ValidateOnlineKeyVersion( LPSTR szOnlineKeyVersion )
{
    return ValidateString( szOnlineKeyVersion, "Online Key Version", ONLINE_KEY_VERSION_LENGTH, '0', '9' );
}

BOOL CGenealogy::ValidateMacAddress( LPSTR szMacAddress )
{
    return ValidateString( szMacAddress, "Mac Address", MAC_ADDRESS_LENGTH, '0', 'F' );
}

BOOL CGenealogy::ValidateGameRegion( LPSTR szGameRegion )
{
    return ValidateString( szGameRegion, "Game Region", GAME_REGION_CODE_LENGTH, '0', '9' );
}

BOOL CGenealogy::ValidateTVRegion( LPSTR szTVRegion )
{
    return ValidateString( szTVRegion, "TV Region", TV_REGION_CODE_LENGTH, '0', '9' );
}

BOOL CGenealogy::ValidateIsActive( LPSTR szIsActive )
{
    return ValidateString( szIsActive, "Is Active", IS_ACTIVE_LENGTH, '0', '9' );
}

BOOL CGenealogy::Validate( SOnlineGaming& OnlineGaming )
{
    //
    // count 1 more record as processed
    //

    ++m_dwCount;

	//
	// validate the critical fields
	//

	if ( ! ValidateSerialNumber( OnlineGaming.szSerialNumber ) ||
         ! ValidatePartNumber( OnlineGaming.szPartNumber )  ||
         ! ValidateOnlineKey( OnlineGaming ) )
	{
        m_dwBadCount++;

        //
        // if validation failed increment the bad count, write the bad record,
        // but only if we are dealing with an input data feed
        //

		if ( m_pDataFeed )
        {
            m_pDataFeed->IncrementBadCount();
        }
        
        //
        // report an error
        //

        ReportError();

        return FALSE;
	}

    //
    //  Secondary validation.  For these cases we will output events and add the row to
    //  the errors table, but still continue using the row anyway
    //

    if(  ! ValidateMacAddress( OnlineGaming.szMacAddress ) ||
         ! ValidateGameRegion( OnlineGaming.szGameRegion ) ||
         ! ValidateTVRegion( OnlineGaming.szTVRegion ) ||
         ! ValidateOnlineKeyVersion( OnlineGaming.szOnlineKeyVersion ) ||
         ! ValidateIsActive( OnlineGaming.szIsActive ) )
    {
        ReportError();
    }

    return TRUE;
}

HRESULT CGenealogy::Update( SOnlineGaming& OnlineGaming )
{
    HRESULT hr = S_OK;

    //
    // first validate and see if it belongs
    // then fill in the DOS PPA stuff
    //

    if ( Validate( OnlineGaming ) )
    {
        //
        // if it does, call the sproc
        //

        hr = m_pSes->CallProc( m_pGamingTableCache, 
                                UPDATE_GENEALOGY_SPROC_CALL_STRING,
                                OnlineGaming.szSerialNumber, 
                                OnlineGaming.szPartNumber,
                                OnlineGaming.szOnlineKey,
                                OnlineGaming.szOnlineKeyVersion,
                                OnlineGaming.szMacAddress,
                                OnlineGaming.szGameRegion,
                                OnlineGaming.szTVRegion,
                                OnlineGaming.szIsActive,
                                OnlineGaming.abPPA2,
                                PPA2_LENGTH,
                                OnlineGaming.abSPPA1,
                                SPPA1_LENGTH,
                                OnlineGaming.timeAppeared );

        if ( FAILED( hr ) )
        {
            ERROR2( XEVENT_GENEALOGY_ERROR_CALL_SPROC_1, 
                    "Could not call stored proc %S. HR=0x%x\n", 
                    UPDATE_GENEALOGY_SPROC_CALL_STRING, 
                    hr );
        }
    }

    return hr;
}

void CGenealogy::ReportError( void )
{
    HRESULT hr;
    SYSTEMTIME st;

    GetSystemTime(&st);

    hr = m_pSes->CallProc(  m_pErrorCache,
                            BAD_GENE_SPROC_CALL_STRING,
                            NULL == m_pDataFeed->GetInputFile() ? "" : m_pDataFeed->GetInputFile(),
                            NULL == g_szError ? "" : g_szError,
                            NULL == m_pDataFeed ? "" : m_pDataFeed->GetRowData(),
                            COleDateTime(st) );

    if ( FAILED( hr ) )
    {
        ERROR2( XEVENT_GENEALOGY_ERROR_CALL_SPROC_2, "Could not call stored proc %S. HR=0x%x\n", BAD_GENE_SPROC_CALL_STRING, hr );
    }
}

HRESULT CGenealogy::Update( LPCSTR szInputFile )
{
    HRESULT         hr;
    int             nCurEnv;
    SOnlineGaming   onlineGaming;
    LPCSTR          szFileName;

    //
    //  Get the filename.
    //

    szFileName = (LPCSTR)strrchr(szInputFile, '\\');
    if(szFileName == NULL)
        szFileName = szInputFile;
    else
        ++szFileName;

    //
    // create output files if we need to
    //

    memset(m_ahOutputFiles, 0, sizeof(m_ahOutputFiles));

    if(g_Params.GetOutputPath() != NULL)
    {
        for(nCurEnv = 0; nCurEnv < MAXENV; ++nCurEnv)
        {
            string cszFile;
            string cszLatest;

            //
            //  Path to output file
            //

            cszFile = g_cszOutputPaths[nCurEnv] + "\\" + szFileName;

            //
            //  Path to latest.txt
            //

            cszLatest = g_cszOutputPaths[nCurEnv] + "\\latest.txt";

            //
            //  Open output file
            //

            m_ahOutputFiles[nCurEnv] = fopen(cszFile.c_str(), "w");
            if(m_ahOutputFiles[nCurEnv] == NULL)
            {
                hr = HRESULT_FROM_WIN32(GetLastError());
                ERROR2(XEVENT_TOOLS_CONFIG_8,
                       "Could not create output file \"%s\".  Error = 0x%08X.",
                       cszFile.c_str(),
                       hr);
                goto Cleanup;
            }

            //
            //  Delete latest.txt.  We'll recreate after we're done writing output files.
            //

            if(remove(cszLatest.c_str()) == -1)
            {
                if(errno == EACCES)
                {
                    hr = HRESULT_FROM_WIN32(ERROR_ACCESS_DENIED);
                    ERROR2(XEVENT_TOOLS_CONFIG_9,
                           "Could not delete file \"%s\".  Error = %08X.",
                           cszLatest.c_str(),
                           hr);
                    goto Cleanup;
                }
            }
        }
    }

    //
    // create the data feed processor
    //

    m_pDataFeed = new CDataFeed();

    if ( NULL == m_pDataFeed )
    {
        hr = E_OUTOFMEMORY;
        ERROR0( XEVENT_GENEALOGY_OUT_OF_MEMORY_8, "Could not create data feed processor\n" );
        goto Cleanup;
    }

    //
    // set the file name
    //

    hr = m_pDataFeed->OpenInputFile(szInputFile);
    if(FAILED(hr))
        goto Cleanup;

    //
    // process the data feed file
    //

    while ( SUCCEEDED( hr ) )
    {
        hr = m_pDataFeed->Process( onlineGaming );

        //
        // either we finished correctly
        //

        if ( S_EOF_FOUND == hr )
        {

            hr = S_OK;

            break;
        }

        //
        // we finished too early
        //

        else if ( E_EOF_FOUND_EARLY == hr )
        {
            //
            // report the EOF too early as an error
            //

            ReportError();
            hr = S_OK;
            break;
        }

        //
        // we got one corupt record
        //

        else if ( S_FALSE == hr )
        {
            //
            // Report as an error
            //

            ReportError();
            hr = S_OK;
            continue;
        }

        //
        // or this record was golden
        //

        else if ( S_OK == hr )
        {
            hr = Update( onlineGaming );
            if(FAILED(hr))
            {
                goto Cleanup;
            }

            //
            //  Do we need to emit this data to one or more output files?
            //

            if(g_Params.GetOutputPath() != NULL)
            {
                int nCurEnv;
                CHAR szOutputLine[FEED_ROW_LENGTH_EX + 1];

                //
                //  Format the output line
                //

                szOutputLine[FEED_ROW_LENGTH_EX] = '\0';
                _snprintf(szOutputLine, FEED_ROW_LENGTH_EX + 1,
                    "%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%02X%02X%02X%02X%02X%02X%02X%02X\t%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X\t%04d-%02d-%02d %02d:%02d:%02d\n",
                    onlineGaming.szSerialNumber,
                    onlineGaming.szPartNumber,
                    onlineGaming.szOnlineKey,
                    onlineGaming.szOnlineKeyVersion,
                    onlineGaming.szMacAddress,
                    onlineGaming.szGameRegion,
                    onlineGaming.szTVRegion,
                    onlineGaming.szIsActive,
                    onlineGaming.abPPA2[0],
                    onlineGaming.abPPA2[1],
                    onlineGaming.abPPA2[2],
                    onlineGaming.abPPA2[3],
                    onlineGaming.abPPA2[4],
                    onlineGaming.abPPA2[5],
                    onlineGaming.abPPA2[6],
                    onlineGaming.abPPA2[7],
                    onlineGaming.abSPPA1[0],
                    onlineGaming.abSPPA1[1],
                    onlineGaming.abSPPA1[2],
                    onlineGaming.abSPPA1[3],
                    onlineGaming.abSPPA1[4],
                    onlineGaming.abSPPA1[5],
                    onlineGaming.abSPPA1[6],
                    onlineGaming.abSPPA1[7],
                    onlineGaming.abSPPA1[8],
                    onlineGaming.abSPPA1[9],
                    onlineGaming.abSPPA1[10],
                    onlineGaming.abSPPA1[11],
                    onlineGaming.abSPPA1[12],
                    onlineGaming.abSPPA1[13],
                    onlineGaming.abSPPA1[14],
                    onlineGaming.abSPPA1[15],
                    onlineGaming.abSPPA1[16],
                    onlineGaming.abSPPA1[17],
                    onlineGaming.abSPPA1[18],
                    onlineGaming.abSPPA1[19],
                    onlineGaming.timeAppeared.GetYear(),
                    onlineGaming.timeAppeared.GetMonth(),
                    onlineGaming.timeAppeared.GetDay(),
                    onlineGaming.timeAppeared.GetHour(),
                    onlineGaming.timeAppeared.GetMinute(),
                    onlineGaming.timeAppeared.GetSecond());

                //
                //  Write to output file for each applicable environment
                //

                for(nCurEnv = 0; nCurEnv < MAXENV; ++nCurEnv)
                {
                    if(m_ahOutputFiles[nCurEnv] != NULL)
                    {
                        fwrite(szOutputLine, 1, strlen(szOutputLine), m_ahOutputFiles[nCurEnv]);
                    }
                }
            }
        }
    }

    //
    //  If everything is ok at this point, we can now re-create latest.txt for
    //  each output directory.
    //

    if(g_Params.GetOutputPath() != NULL)
    {
        for(nCurEnv = 0; nCurEnv < MAXENV; ++nCurEnv)
        {
            if(g_cszOutputPaths[nCurEnv].length() != 0)
            {
                string  cszLatest;
                FILE*   hLatest;

                //
                //  Path to latest.txt
                //

                cszLatest = g_cszOutputPaths[nCurEnv] + "\\latest.txt";

                //
                //  Open latest.txt file
                //

                hLatest = fopen(cszLatest.c_str(), "w");
                if(m_ahOutputFiles[nCurEnv] == NULL)
                {
                    hr = HRESULT_FROM_WIN32(GetLastError());
                    ERROR2(XEVENT_TOOLS_CONFIG_10,
                            "Could not create output file \"%s\".  Error = 0x%08X.",
                            cszLatest.c_str(),
                            hr);
                    continue;
                }

                //
                //  Close the file
                //

                fclose(hLatest);
            }
        }
    }

    INFO2( XEVENT_GENEALOGY_INFO_UPDATE_COMPLETE, 
            "Update of Genealogy completed successfuly. %u entries processed, %u entries discarded\n", 
            m_pDataFeed->GetGoodCount(), 
            m_pDataFeed->GetBadCount() );

Cleanup:

    //
    //  Close all output files
    //

    for(nCurEnv = 0; nCurEnv < MAXENV; ++nCurEnv)
    {
        if(m_ahOutputFiles[nCurEnv] != NULL)
        {
            fclose(m_ahOutputFiles[nCurEnv]);
            m_ahOutputFiles[nCurEnv] = NULL;
        }
    }

    //
    //  Clean up the data feed object
    //

    if(m_pDataFeed != NULL)
    {
        m_pDataFeed->CloseInputFile();
        delete m_pDataFeed;
        m_pDataFeed = NULL;
    }

    return hr;
}

HRESULT CGenealogy::Process( LPCSTR szInputFile )
{
    HRESULT     hr = S_OK;

    //
    // update the DB
    //

    hr = Update(szInputFile);

    return hr;
}

HRESULT CGenealogy::Init( void )
{
    HRESULT hr = S_OK;

    //
    // create the gaming cache
    //

    if ( SUCCEEDED( hr ) )
    {
        m_pGamingTableCache = new CWSProcCache();

        if ( NULL == m_pGamingTableCache )
        {
            hr = E_OUTOFMEMORY;
            ERROR0( XEVENT_GENEALOGY_OUT_OF_MEMORY_9, "Could not create gaming cache\n" );
        }
    }

    //
    // create the error cache
    //

    if ( SUCCEEDED( hr ) )
    {
        m_pErrorCache = new CWSProcCache();

        if ( NULL == m_pErrorCache )
        {
            hr = E_OUTOFMEMORY;
            ERROR0( XEVENT_GENEALOGY_OUT_OF_MEMORY_10, "could not create error cache\n" );
        }
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\genealogy\genesvc\macros.h ===
///////////////////////////////////////////////////////////////////////////////
//
// Name: macros.h
//
// Author: Dan Rosenstein (danrose)
//
// Description: the macros used in the genealogy tool
//
///////////////////////////////////////////////////////////////////////////////

#pragma once

extern CHAR g_szError[1024];
extern HANDLE g_hEventSource;

//
// no parameter error
//

#define ERROR0( nCode, szStr )      \
{                                   \
    sprintf( g_szError, szStr );    \
	printf( szStr );                \
    LPCSTR pszError = g_szError;    \
	ReportEvent(g_hEventSource, EVENTLOG_ERROR_TYPE, 0, nCode, NULL, 1, 0, &pszError, NULL );   \
}

//
// 1 parameter error
//

#define ERROR1( nCode, szStr, param1 )              \
{										            \
    sprintf( g_szError, szStr, param1 );            \
	printf( szStr, param1 );                        \
    LPCSTR pszError = g_szError;    \
	ReportEvent(g_hEventSource, EVENTLOG_ERROR_TYPE, 0, nCode, NULL, 1, 0, &pszError, NULL );   \
}

//
// 2 parameter error
//

#define ERROR2( nCode, szStr, param1, param2 )     \
{										           \
    sprintf( g_szError, szStr, param1, param2 );   \
	printf( szStr, param1, param2 );               \
    LPCSTR pszError = g_szError;    \
	ReportEvent(g_hEventSource, EVENTLOG_ERROR_TYPE, 0, nCode, NULL, 1, 0, &pszError, NULL );   \
}

//
// 3 parameter error
//

#define ERROR3( nCode, szStr, param1, param2, param3 )     \
{										                   \
    sprintf( g_szError, szStr, param1, param2, param3 );   \
	printf( szStr, param1, param2, param3 );               \
    LPCSTR pszError = g_szError;    \
	ReportEvent(g_hEventSource, EVENTLOG_ERROR_TYPE, 0, nCode, NULL, 1, 0, &pszError, NULL );   \
}

//
// no parameter info
//

#define INFO0( nCode, szStr )                      \
{										           \
	printf( szStr );                               \
    LPCSTR pszError = g_szError;    \
	ReportEvent(g_hEventSource, EVENTLOG_INFORMATION_TYPE, 0, nCode, NULL, 1, 0, &pszError, NULL );   \
}

//
// 1 parameter info
//

#define INFO1( nCode, szStr, param1 )              \
{										           \
	printf( szStr, param1 );                       \
    LPCSTR pszError = g_szError;    \
	ReportEvent(g_hEventSource, EVENTLOG_INFORMATION_TYPE, 0, nCode, NULL, 1, 0, &pszError, NULL );   \
}

//
// 2 parameter info
//

#define INFO2( nCode, szStr, param1, param2 )      \
{										           \
	printf( szStr, param1, param2 );               \
    LPCSTR pszError = g_szError;    \
	ReportEvent(g_hEventSource, EVENTLOG_INFORMATION_TYPE, 0, nCode, NULL, 1, 0, &pszError, NULL );   \
}

//
// 3 parameter info
//

#define INFO3( nCode, szStr, param1, param2, param3 )      \
{										                   \
	printf( szStr, param1, param2, param3 );               \
    LPCSTR pszError = g_szError;    \
	ReportEvent(g_hEventSource, EVENTLOG_INFORMATION_TYPE, 0, nCode, NULL, 1, 0, &pszError, NULL );   \
}

//
// 4 parameter info
//

#define INFO4( nCode, szStr, param1, param2, param3, param4 )      \
{										                           \
	printf( szStr, param1, param2, param3, param4 );               \
    LPCSTR pszError = g_szError;    \
	ReportEvent(g_hEventSource, EVENTLOG_INFORMATION_TYPE, 0, nCode, NULL, 1, 0, &pszError, NULL );   \
}

//
// 5 parameter info
//

#define INFO5( nCode, szStr, param1, param2, param3, param4, param5 )      \
{										                                   \
	printf( szStr, param1, param2, param3, param4, param5 );               \
    LPCSTR pszError = g_szError;    \
	ReportEvent(g_hEventSource, EVENTLOG_INFORMATION_TYPE, 0, nCode, NULL, 1, 0, &pszError, NULL );   \
}

//
//  Error handling macros
//

#define IF_SQL_ERROR(x)                             \
if(x == SQL_ERROR)                                  \
{                                                   \
    goto Cleanup;                                   \
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\genealogy\genesvc\main.cpp ===
#include "stdinc.h"

//
//  Function forward declarations
//

int             GeneServiceMain(void);
void WINAPI     GeneServiceStart(DWORD, LPSTR*);
void WINAPI     GeneServiceCtrlHandler(DWORD);
HRESULT         GeneServiceInitialization(int argc, char** argv, DWORD* specificError);
VOID CALLBACK   ProcessDroppedFiles(VOID);
UINT __stdcall  GeneServiceThreadProc(LPVOID pv);
void            GeneServiceCleanup(void);
int             RegisterGeneService(int, char**);
int             UnregisterGeneService(void);
BOOL            BreakIntoGeneService(void);
void            Usage(void);
HRESULT         MakeConfigPath(void);
HRESULT         ProcessDataFeedFile(LPCSTR);
HRESULT         ProcessPartNumberFile(LPCSTR);
BOOL            VerifyDirectoryExists(LPCSTR);

//
//  Global variables
//

SERVICE_STATUS          g_GeneServiceStatus; 
SERVICE_STATUS_HANDLE   g_GeneServiceStatusHandle = NULL; 
string                  g_cszConfigFilename;
CParams                 g_Params;
CPartNumberTable*       g_pParts = NULL;
HANDLE                  g_hServiceStopEvent = NULL;
HANDLE                  g_hWorkerThread = NULL;
string                  g_cszInputPath;
string                  g_cszArchivePath;
string                  g_cszOutputPaths[MAXENV];
CNCipher*               g_pNCipher = NULL;

LPCSTR g_szEnvStrings[MAXENV] = { "ref", "dev", "test", "partner", "beta", "cert", "preprod", "prod" };

SERVICE_TABLE_ENTRY     g_DispatchTable[] = 
{ 
    { "GenealogyService", GeneServiceStart  }, 
    { NULL,               NULL              } 
}; 

//
//  Process entry point
//

int __cdecl main( int argc, char* argv[] )
{
    //
    //  Help
    //

    if(argc == 2 && lstrcmpiA(argv[1], "/?") == 0)
    {
        Usage();
        return 0;
    }

    //
    // are we starting as a service?  In this case the command line will just be "genealogy.exe"
    //

    if(argc == 1)
    {
        return GeneServiceMain();
    }

    //
    // are we registering the service?
    // In this case the command line will just be "genesvc.exe /registerservice [/runas:<domain\user> /pwd:<password>]"
    //

    if((argc == 2 || argc == 4) && lstrcmpiA(argv[1], "/registerservice") == 0)
    {
        return RegisterGeneService(argc, argv);
    }

    //
    // are we unregistering the service?
    //

    if(argc == 2 && lstrcmpiA(argv[1], "/unregisterservice") == 0)
    {
        return UnregisterGeneService();
    }

    //
    // print out usage text
    //

    Usage();

    return 0;
}

//
//  Main service entry point; start service dispatcher.
//

int GeneServiceMain(void)
{
    //
    //  Break into the service if so configured.
    //
    
    if(BreakIntoGeneService())
        DebugBreak();

    //
    //  Start the service, execution continues in GeneServiceStart.
    //

    if (!StartServiceCtrlDispatcher( g_DispatchTable)) 
    {
        DWORD dwError = GetLastError();
        ERROR1(XEVENT_GENEALOGY_SERVICE_START_FAILED, "Failed to start the service control dispatcher. Error = %08X.", dwError);
    }

    return 0;
}

//
//  Start up the service.  Registers the control handler, initializes the service and starts the worker thread.
//

void GeneServiceStart(DWORD argc, LPSTR *argv)
{
    DWORD status; 
    DWORD specificError;

    //
    //  Register the service control handler
    //

    g_GeneServiceStatusHandle = RegisterServiceCtrlHandler( 
        "GeneSvc", 
        GeneServiceCtrlHandler); 
 
    if (g_GeneServiceStatusHandle == (SERVICE_STATUS_HANDLE)0) 
    { 
        //ERROR1(XEVENT_GENEALOGY_SERVICE_START_FAILED_1, "Failed to register the service control handler.  Error = %1.", GetLastError());
        goto Cleanup; 
    } 
 
    //
    //  Set initial status
    //

    g_GeneServiceStatus.dwServiceType        = SERVICE_WIN32; 
    g_GeneServiceStatus.dwCurrentState       = SERVICE_START_PENDING; 
    g_GeneServiceStatus.dwControlsAccepted   = SERVICE_ACCEPT_STOP; 
    g_GeneServiceStatus.dwWin32ExitCode      = 0; 
    g_GeneServiceStatus.dwServiceSpecificExitCode = 0; 
    g_GeneServiceStatus.dwCheckPoint         = 0; 
    g_GeneServiceStatus.dwWaitHint           = 1000;

    if (!SetServiceStatus (g_GeneServiceStatusHandle, &g_GeneServiceStatus))
    { 
        status = GetLastError();
        ERROR1(XEVENT_GENEALOGY_SET_STATUS_FAILED, "Failed to set service status.  Error = 0x%08X.", status);
    } 
 
    //
    // Initialize service
    //

    status = GeneServiceInitialization(argc, argv, &specificError); 
    if (status != S_OK) 
    { 
        g_GeneServiceStatus.dwCurrentState       = SERVICE_STOPPED; 
        g_GeneServiceStatus.dwCheckPoint         = 0; 
        g_GeneServiceStatus.dwWaitHint           = 0; 
        g_GeneServiceStatus.dwWin32ExitCode      = status; 
        g_GeneServiceStatus.dwServiceSpecificExitCode = specificError; 
 
        if (!SetServiceStatus (g_GeneServiceStatusHandle, &g_GeneServiceStatus))
        { 
            status = GetLastError();
            ERROR1(XEVENT_GENEALOGY_SET_STATUS_FAILED_1, "Failed to set service status.  Error = 0x%08X.", status);
        }

        GeneServiceCleanup();

        goto Cleanup; 
    } 
 
    //
    //  Initialization successful
    //

    g_GeneServiceStatus.dwCurrentState            = SERVICE_RUNNING; 
    g_GeneServiceStatus.dwWin32ExitCode           = 0; 
    g_GeneServiceStatus.dwServiceSpecificExitCode = 0; 
    g_GeneServiceStatus.dwCheckPoint++;
    g_GeneServiceStatus.dwWaitHint                = 0;

    if (!SetServiceStatus (g_GeneServiceStatusHandle, &g_GeneServiceStatus))
    { 
        status = GetLastError();
        ERROR1(XEVENT_GENEALOGY_SET_STATUS_FAILED_2, "Failed to set service status.  Error = 0x%08X.", status);
    }

    //
    //  Tell the worker thread to start
    //

    ResumeThread(g_hWorkerThread);

Cleanup:

    return;
}

//
//  This function performs service initialization:
//
//  1.  Initialize COM.
//  2.  Load the configuration file.  Create drop directory if necessary.
//  3.  Load nCipher keys if not disabled in configuration file.
//  4.  Load the part number file.
//  5.  Create worker thread in a suspended state.
//

VOID PartNumberProgress(VOID)
{
    ++g_GeneServiceStatus.dwCheckPoint; 
    g_GeneServiceStatus.dwWaitHint = 1000;

    if (!SetServiceStatus (g_GeneServiceStatusHandle, &g_GeneServiceStatus))
    { 
        DWORD status = GetLastError();
        ERROR1(XEVENT_GENEALOGY_SET_STATUS_FAILED_3, "Failed to set service status.  Error = 0x%08X.", status);
    } 
}

HRESULT GeneServiceInitialization(int argc, char** argv, DWORD* specificError)
{
    HRESULT         hr;
    unsigned int    nThreadId;
    CODBWSession    ses;

    //
    //  Initialize COM
    //

    hr = CoInitializeEx(NULL, COINIT_MULTITHREADED);
    if(FAILED(hr))
        goto Cleanup;

    //
    //  Initialize the event source.
    //

    g_hEventSource = RegisterEventSource(NULL, "genesvc");

    //
    //  Try to load .ini file.  NT Events cannot be put into the
    //  event log until after xmgmt is initialized.
    //  Create the drop directory if it doesn't exist.
    //

    //  First construct the path
    hr = MakeConfigPath();
    if(FAILED(hr))
        goto Cleanup;

    //  Load the file and initialize xmgmt
    hr = g_Params.LoadConfig(g_cszConfigFilename.c_str());
    if(FAILED(hr))
        goto Cleanup;
    
    //  Make sure we have all required config settings
    if(g_Params.GetInputPath() == NULL)
    {
        ERROR0(XEVENT_TOOLS_CONFIG_13,
               "The 'InputPath' setting in the configuration file was missing or empty.  "
               "Add an 'InputPath' setting to the [Genealogy] section of the configuration file.");
        hr = E_FAIL;
        goto Cleanup;
    }

    if(g_Params.GetMachineName() == NULL)
    {
        ERROR0(XEVENT_TOOLS_CONFIG_14,
               "The 'Machine' setting in the configuration file was missing or empty.  "
               "Add an 'Machine' setting to the [Genealogy] section of the configuration file.");
        hr = E_FAIL;
        goto Cleanup;
    }

    if(g_Params.GetDBName() == NULL)
    {
        ERROR0(XEVENT_TOOLS_CONFIG_15,
               "The 'DB' setting in the configuration file was missing or empty.  "
               "Add an 'DB' setting to the [Genealogy] section of the configuration file.");
        hr = E_FAIL;
        goto Cleanup;
    }

    //  Massage the input path into the proper form.
    g_cszInputPath = g_Params.GetInputPath();
    if(g_cszInputPath.length() == 0)
    {
        ERROR0(XEVENT_TOOLS_CONFIG_16,
               "The 'InputPath' setting in the configuration file was missing or empty.  "
               "Add an 'InputPath' setting to the [Genealogy] section of the configuration file.");
        hr = E_FAIL;
        goto Cleanup;
    }

    if(g_cszInputPath[g_cszInputPath.length() - 1] == '\\')
        g_cszInputPath = g_cszInputPath.substr(0, g_cszInputPath.length() - 1);

    //  Make sure the input path isn't too long.
    if(g_cszInputPath.length() > MAX_PATH)
    {
        ERROR0(XEVENT_TOOLS_CONFIG_17,
               "The input path specified is too long.");
        hr = E_FAIL;
        goto Cleanup;
    }

    //  Make sure the input directory exists
    if(!VerifyDirectoryExists(g_cszInputPath.c_str()))
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        ERROR2(XEVENT_TOOLS_CONFIG_18,
                "Failed to create input directory \"%s\".  Error = 0x%08X.  Service is stopping.",
                g_cszInputPath.c_str(),
                hr);
        goto Cleanup;
    }

    //
    //  Create archive directory if configured
    //

    if(g_Params.GetArchivePath() != NULL)
    {
        g_cszArchivePath = g_Params.GetArchivePath();
        if(!VerifyDirectoryExists(g_cszArchivePath.c_str()))
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            ERROR2(XEVENT_TOOLS_CONFIG_19,
                    "Failed to create input directory \"%s\".  Error = 0x%08X.  Service is stopping.",
                    g_cszInputPath.c_str(),
                    hr);
            goto Cleanup;
        }
    }
    else
    {
        g_cszArchivePath = "";
    }

    //
    //  Was the output path configured?  If so, create all output directories.
    //

    if(g_Params.GetOutputPath() != NULL)
    {
        string          cszOutput;
        int             nCurEnv;

        //  Strip off any trailing slash, we'll add it back in a sec

        cszOutput = g_Params.GetOutputPath();
        if(cszOutput[cszOutput.length() - 1] == '\\')
            cszOutput = cszOutput.substr(0, cszOutput.length() - 1);

        //  Make sure that the root directory exists

        if(!VerifyDirectoryExists(cszOutput.c_str()))
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            ERROR2(XEVENT_TOOLS_CONFIG_20,
                    "Failed to create output directory \"%s\".  Error = 0x%08X.  Service is stopping.",
                    cszOutput.c_str(),
                    hr);
            goto Cleanup;
        }

        //
        //  Now create each environment-specific directory
        //

        for(nCurEnv = 0; nCurEnv < MAXENV; ++ nCurEnv)
        {
            string cszLeafDir = cszOutput + "\\" + g_szEnvStrings[nCurEnv];

            if(!VerifyDirectoryExists(cszLeafDir.c_str()))
            {
                hr = HRESULT_FROM_WIN32(GetLastError());
                ERROR2(XEVENT_TOOLS_CONFIG_21,
                        "Failed to create output directory \"%s\".  Error = 0x%08X.  Service is stopping.",
                        cszLeafDir.c_str(),
                        hr);
                goto Cleanup;
            }

            g_cszOutputPaths[nCurEnv] = cszLeafDir;
        }
    }

    //
    //  Load part numbers from DB
    //

    g_pParts = new CPartNumberTable();
    if(g_pParts == NULL)
    {
        ERROR0(XEVENT_TOOLS_CODE_29,
                "Out of memory while trying to allocate internal part number data structures.");
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    hr = InitODBWSession(g_Params.GetMachineName(), g_Params.GetDBName(), ses);
    if(FAILED(hr))
        goto Cleanup;

    hr = g_pParts->LoadFromDB(ses, PartNumberProgress);
    if(FAILED(hr))
        goto Cleanup;

    //
    // create the nCipher object and acquire keys
    //

    if(!g_Params.NCipherDisabled())
    {
        g_pNCipher = new CNCipher();
        if ( NULL == g_pNCipher )
        {
            hr = E_OUTOFMEMORY;
            ERROR0( XEVENT_GENEALOGY_OUT_OF_MEMORY_11, "Could not allocate nCipher\n" );
            goto Cleanup;
        }

        //
        // get the keys from the nCipher
        //

        hr = g_pNCipher->AquireKeys();
        if(FAILED(hr))
        {
            delete g_pNCipher;
            g_pNCipher = NULL;
            goto Cleanup;
        }
    }
    else
        ERROR0(XEVENT_TOOLS_CONFIG_22,
               "NCipher is disabled.  Encrypted portion of data feed will not be verified.");

    //
    //  Create the service stop event
    //

    g_hServiceStopEvent = CreateEvent(NULL, TRUE, FALSE, NULL);
    if(g_hServiceStopEvent == NULL)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        ERROR1(XEVENT_GENEALOGY_SERVICE_START_FAILED_2,
               "Failed to create an event, service start failed.  Error = 0x%08X.",
               hr);
        goto Cleanup;
    }

    //
    //  Create worker thread in a suspended state.
    //

    g_hWorkerThread = (HANDLE)_beginthreadex(NULL, 0, GeneServiceThreadProc, NULL, CREATE_SUSPENDED, &nThreadId);
    if(g_hWorkerThread == NULL)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        ERROR1(XEVENT_GENEALOGY_SERVICE_START_FAILED_3,
               "Failed to create the worker thread, service start failed.  Error = 0x%08X.",
               hr);
        goto Cleanup;
    }

    hr = S_OK;

Cleanup:

    return hr;
}

//
//  Main worker thread
//

UINT __stdcall GeneServiceThreadProc(LPVOID pv)
{
    HRESULT hr;
    BOOL    bServiceStopping = FALSE;
    HANDLE  ahWaitHandles[2];

    //
    //  Initialize COM on this thread
    //

    hr = CoInitializeEx(NULL, COINIT_MULTITHREADED);
    if(FAILED(hr))
        goto Cleanup;

    //
    //  Initialize wait handle array
    //

    ahWaitHandles[0] = g_hServiceStopEvent;

    //
    //  Create a new file notification handle.  If this fails we stop
    //  the thread and the service.
    //

    ahWaitHandles[1] = FindFirstChangeNotification(g_cszInputPath.c_str(), 
                                                   FALSE, 
                                                   FILE_NOTIFY_CHANGE_LAST_WRITE | FILE_NOTIFY_CHANGE_FILE_NAME);
    if(ahWaitHandles[1] == INVALID_HANDLE_VALUE)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        ERROR2(XEVENT_TOOLS_CONFIG_25, 
               "Creating the file change notification handle for the drop path \"%s\" failed with error = 0x%08X.",
               g_cszInputPath.c_str(), 
               hr);

        GeneServiceCleanup();

        // Do whatever it takes to stop here. 
        g_GeneServiceStatus.dwWin32ExitCode = hr; 
        g_GeneServiceStatus.dwCurrentState  = SERVICE_STOPPED; 
        g_GeneServiceStatus.dwCheckPoint    = 0; 
        g_GeneServiceStatus.dwWaitHint      = 0; 

        if (!SetServiceStatus (g_GeneServiceStatusHandle, &g_GeneServiceStatus))
        { 
            DWORD status = GetLastError();
            ERROR1(XEVENT_GENEALOGY_SET_STATUS_FAILED_4, "Failed to set service status.  Error = 0x%08X.", status);
        } 

        INFO0(XEVENT_GENEALOGY_SERVICE_STOPPED, "Genealogy import service has stopped.");

        goto Cleanup;
    }

    INFO0(XEVENT_GENEALOGY_SERVICE_STARTED, "The genealogy import service has started successfully.");

    //
    //  Process any files that were dropped here since the last wake time.
    //

    ProcessDroppedFiles();

    //
    //  Main loop of sleeping and working...hmmm just like my life, weird.
    //

    while(!bServiceStopping)
    {

        DWORD dwStatus = WaitForMultipleObjects(sizeof(ahWaitHandles)/sizeof(HANDLE),
                                                ahWaitHandles,
                                                FALSE,
                                                INFINITE);

        switch(dwStatus)
        {
        case WAIT_OBJECT_0 + 0:
            bServiceStopping = TRUE;
            break;

        case WAIT_OBJECT_0 + 1:
            ProcessDroppedFiles();
            FindNextChangeNotification(ahWaitHandles[1]);
            break;

        //  WAIT_FAILED, WAIT_TIMEOUT or WAIT_ABANDONED
        //  Only WAIT_FAILED is a possibility.    
        default:
            break;
        }
    }

    //
    //  Cleanup file notification handle
    //

    if(ahWaitHandles[1] != NULL)
    {
        FindCloseChangeNotification(ahWaitHandles[1]);
        ahWaitHandles[1] = NULL;
    }

    hr = S_OK;

Cleanup:

    return hr;
}


//
//  Process any new/changed files in the drop directory.
//

VOID CALLBACK ProcessDroppedFiles(VOID)
{
    WIN32_FIND_DATA findData;
    HANDLE          hFindFile;
    string          cszFindPath;

    cszFindPath = g_cszInputPath + "\\*";

    //
    //  Process all files in the directory.
    //

    memset(&findData, 0, sizeof(WIN32_FIND_DATA));

    hFindFile = FindFirstFile(cszFindPath.c_str(), &findData);
    if(hFindFile == INVALID_HANDLE_VALUE)
    {
        HRESULT hr = HRESULT_FROM_WIN32(GetLastError());

        ERROR2(XEVENT_TOOLS_CODE_32,
               "Failed to find changed files in \"%s\".  Error = 0x%08X.",
               cszFindPath.c_str(),
               hr);
        return;
    }

    //
    //  Process all new/changed files in the directory.
    //

    do
    {
        HRESULT hr = S_OK;
        string cszFilePath;
        CHAR szExtension[_MAX_EXT];

        //
        //  Don't process directories
        //

        if(findData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
            continue;

        //
        //  Get the filename extension
        //

        _splitpath(findData.cFileName, NULL, NULL, NULL, szExtension);

        //
        //  Build full path to the file.
        //

        cszFilePath = g_cszInputPath + "\\" + findData.cFileName;

        INFO1(XEVENT_GENEALOGY_INFO_FILES_IN_DROP_DIR, 
              "Genealogy import service has detected a new file for processing: %s", 
              cszFilePath.c_str());

        //
        //  Wait for exclusive access
        //

        {
            HANDLE hFile;
            BOOL bError = FALSE;

            while((hFile = CreateFile(cszFilePath.c_str(), GENERIC_READ, 0, NULL, OPEN_EXISTING, 0, NULL)) == INVALID_HANDLE_VALUE)
            {
                if(GetLastError() == ERROR_FILE_NOT_FOUND)
                {
                    bError = TRUE;
                    break;
                }

                Sleep(500);
            }

            if(bError)
                continue;

            CloseHandle(hFile);
        }

        //
        //  New genealogy data file?
        //

        if(lstrcmpiA(szExtension, ".txt") == 0)
        {
            hr = ProcessDataFeedFile(cszFilePath.c_str());
        }

        //
        //  New part numbers file?
        //

        if(lstrcmpiA(szExtension, ".csv") == 0)
        {
            hr = ProcessPartNumberFile(cszFilePath.c_str());
        }

        //
        //  Archive or delete input file?
        //

        if(hr == S_OK)
        {
            if(g_cszArchivePath.length() != 0)
            {
                string cszDestPath = g_cszArchivePath;

                if(cszDestPath[cszDestPath.length() - 1] != '\\')
                    cszDestPath += "\\";

                cszDestPath += cszFilePath.substr(cszFilePath.rfind('\\'));

                if(!MoveFileA(cszFilePath.c_str(), cszDestPath.c_str()))
                {
                    HRESULT hr = HRESULT_FROM_WIN32(GetLastError());
                    ERROR2(XEVENT_TOOLS_CONFIG_26,
                        "Could not move file \"%s\" to archive directory.  Error = 0x%08X.",
                        cszFilePath.c_str(),
                        hr);
                }
            }
            else
            {
                if(!DeleteFileA(cszFilePath.c_str()))
                {
                    HRESULT hr = HRESULT_FROM_WIN32(GetLastError());
                        ERROR2(XEVENT_TOOLS_CONFIG_27,
                            "Could not delete file \"%s\".  Error = %08X.",
                            cszFilePath.c_str(),
                            hr);
                }
            }
        }
    }
    while(FindNextFile(hFindFile, &findData));

    FindClose(hFindFile);
}

//
//  Process a new data feed file
//

HRESULT ProcessDataFeedFile(
    LPCSTR  szFilePath
    )
{
    HRESULT         hr;
    CODBWSession    ses;
    CGenealogy*     pGenealogy = NULL;

    //
    //  Create database session
    //

    hr = InitODBWSession(g_Params.GetMachineName(), g_Params.GetDBName(), ses);
    if(FAILED(hr))
    {
        goto Cleanup;
    }

    pGenealogy = new CGenealogy(&ses, g_pNCipher);
    if(pGenealogy == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    hr = pGenealogy->Init();
    if(FAILED(hr))
    {
        goto Cleanup;
    }

    hr = pGenealogy->Process(szFilePath);
    if(FAILED(hr))
    {
        ERROR2(XEVENT_TOOLS_CODE_33,
                "Error 0x%08X while processing file %s.",
                hr,
                szFilePath);
        goto Cleanup;
    }

    hr = S_OK;

Cleanup:

    if(pGenealogy != NULL)
        delete pGenealogy;

    return hr;
}

//
//  Load part numbers from file
//

HRESULT ProcessPartNumberFile(LPCSTR szFilePath)
{
    HRESULT         hr;
    CODBWSession    ses;

    if(g_pParts == NULL)
    {
        g_pParts = new CPartNumberTable();
        if(g_pParts == NULL)
        {
            ERROR0(XEVENT_TOOLS_CODE_34,
                "Out of memory while trying to load the part number table.");
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }
    }

    hr = InitODBWSession(g_Params.GetMachineName(), g_Params.GetDBName(), ses);
    if(FAILED(hr))
        goto Cleanup;

    if(!g_pParts->Load(szFilePath, ses))
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    //
    //  Do we need write output files?
    //

    if(g_Params.GetOutputPath() != NULL)
    {
        int nCurEnv;
        string cszFileName = szFilePath;

        cszFileName = cszFileName.substr(cszFileName.rfind('\\'));

        for(nCurEnv = 0; nCurEnv < MAXENV; ++nCurEnv)
        {
            string cszLatest   = g_cszOutputPaths[nCurEnv] + "\\latest.txt";
            string cszFilePath = g_cszOutputPaths[nCurEnv] + "\\" + cszFileName;

            //  delete latest.txt
            DeleteFile(cszLatest.c_str());

            //  write to output file
            g_pParts->Write(cszFilePath.c_str(), 1 << nCurEnv);

            //  recreate latest.txt
            fclose(fopen(cszLatest.c_str(), "w"));
        }
    }

    hr = S_OK;

Cleanup:

    return hr;
}

//
//  Service done, cleanup.
//

void GeneServiceCleanup()
{
    if(g_hServiceStopEvent != NULL)
    {
        CloseHandle(g_hServiceStopEvent);
        g_hServiceStopEvent = NULL;
    }

    if(g_pNCipher != NULL)
    {
        delete g_pNCipher;
        g_pNCipher = NULL;
    }

    if(g_pParts != NULL)
    {
        delete g_pParts;
        g_pParts = NULL;
    }
}

//
//  Command line usage
//

void Usage(void)
{
    printf("To register the service:\r\n\r\n"
                "\tgenesvc.exe /registerservice [/runas:<domain\\user> /pwd:<password>]\r\n\r\n"
                "\tIf domain account and password are not specified,\r\n\tservice runs as local system.\r\n\r\n"
           "To unregister the service:\r\n\r\n"
                "\tgenesvc.exe /unregisterservice\r\n");
}

//
//  Create the path the config file based on the path of the genesvc.exe.
//

HRESULT MakeConfigPath(void)
{
    HRESULT hr;
    CHAR    szFileNameBuf[MAX_PATH << 1];
    DWORD   dwFileNameLen;
    int     nBackslashPos;

    dwFileNameLen = GetModuleFileNameA(NULL, szFileNameBuf, sizeof(szFileNameBuf) - 1);

    // error
    if(dwFileNameLen == 0)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto Cleanup;
    }

    // path too long
    if(dwFileNameLen == sizeof(szFileNameBuf) - 1)
    {
        ERROR0(XEVENT_TOOLS_CONFIG_28,
               "The path to genesvc.exe is too long, failed to open configuration file.");
        hr = E_FAIL;
        goto Cleanup;
    }

    g_cszConfigFilename = szFileNameBuf;

    nBackslashPos = g_cszConfigFilename.rfind('\\');
    if(nBackslashPos == g_cszConfigFilename.npos)
        g_cszConfigFilename = "genealogy.ini";
    else
        g_cszConfigFilename = g_cszConfigFilename.substr(0, nBackslashPos + 1) + "genealogy.ini";

    hr = S_OK;

Cleanup:

    return hr;
}

//
//  Register the genealogy import service.
//

int RegisterGeneService(int argc, char* argv[])
{
    SC_HANDLE   schSCManager;
    SC_HANDLE   schService;
    LPSTR       szUserName = NULL;
    LPSTR       szPassword = NULL;
    CHAR        szFilename[MAX_PATH];

    if(argc == 4)
    {
        LPSTR lpNameColon = strchr(argv[2], ':');
        LPSTR lpPwdColon = strchr(argv[3], ':');

        if(lpNameColon == NULL ||
            lpPwdColon == NULL ||
            _strnicmp(argv[2], "/runas:", 7) != 0 ||
            _strnicmp(argv[3], "/pwd:", 5) != 0 ||
            *(lpNameColon + 1) == '\0' ||
            *(lpPwdColon + 1) == '\0')
        {
            Usage();
            return -1;
        }

        szUserName = lpNameColon + 1;
        szPassword = lpPwdColon + 1;
    }

    // Open a handle to the SC Manager database. 
        
    schSCManager = OpenSCManager( 
        NULL,                    // local machine 
        NULL,                    // ServicesActive database 
        SC_MANAGER_ALL_ACCESS);  // full access rights 
        
    if (schSCManager == NULL)
    {
        printf("Error opening service control manager.\r\n");
        return -1;
    }

    GetModuleFileNameA(NULL, szFilename, sizeof(szFilename));

    schService = CreateServiceA( 
        schSCManager,              // SCManager database 
        "GeneSvc",                 // name of service 
        "Genealogy Import Service",// service name to display 
        SERVICE_ALL_ACCESS,        // desired access 
        SERVICE_WIN32_OWN_PROCESS, // service type 
        SERVICE_DEMAND_START,      // start type 
        SERVICE_ERROR_NORMAL,      // error control type 
        szFilename,                // service's binary 
        NULL,                      // no load ordering group 
        NULL,                      // no tag identifier 
        NULL,                      // no dependencies 
        szUserName,                // runas
        szPassword);               // password 

    if (schService == NULL)
    {
        DWORD dwError = GetLastError();
        switch(dwError)
        {
        case ERROR_ACCESS_DENIED:
            printf("Insufficient permissions to create a service.\r\n");
            break;

        case ERROR_SERVICE_EXISTS:
            printf("The genealogy import service has already been created.\r\n");
            break;

        case ERROR_INVALID_SERVICE_ACCOUNT:
            printf("Invalid user account specified.\r\n");
            break;

        case ERROR_DUP_NAME:
            printf("Duplicate service name.\r\n");
            break;

        default:
            printf("Creating genealogy import service failed with error = 0x%08X.\r\n", GetLastError());
            break;
        }
    }
    else 
        printf("Genealogy import service created.\r\n"); 

    CloseServiceHandle(schService); 
    CloseServiceHandle(schSCManager);

    return 0;
}

//
//  Unregister the genealogy import service.
//

int UnregisterGeneService(void)
{
    SC_HANDLE   schSCManager;
    SC_HANDLE   schService;

    // Open a handle to the SC Manager database. 
        
    schSCManager = OpenSCManager( 
        NULL,                    // local machine 
        NULL,                    // ServicesActive database 
        SC_MANAGER_ALL_ACCESS);  // full access rights 
        
    if (schSCManager == NULL)
    {
        printf("Error opening service control manager.\r\n");
        return -1;
    }

    schService = OpenService( 
        schSCManager,              // SCManager database 
        "GeneSvc",                 // name of service 
        DELETE);

    if (schService == NULL)
    {
        printf("Opening genealogy import service failed with error = 0x%08X.\r\n", GetLastError());
        CloseServiceHandle(schSCManager);
        return -1;
    }

    if(!DeleteService(schService))
    {
        printf("Deleting genealogy import service failed with error = 0x%08X.\r\n", GetLastError());
    }

    printf("Genealogy import service has been deleted.\r\n");

    CloseServiceHandle(schService); 
    CloseServiceHandle(schSCManager);

    return 0;
}

//
//  Returns TRUE if the startup breakpoint has been configured.  FALSE otherwise.
//

BOOL BreakIntoGeneService(void)
{
    BOOL    bReturn;
    HKEY    hkGeneService = NULL;
    DWORD   dwType;
    DWORD   dwValue;
    DWORD   dwDataLen;

    if(RegOpenKeyEx(HKEY_LOCAL_MACHINE, "SYSTEM\\CurrentControlSet\\Services\\GeneSvc", 0, KEY_READ, &hkGeneService) != ERROR_SUCCESS)
    {
        bReturn = FALSE;
        goto Cleanup;
    }

    dwDataLen = sizeof(DWORD);
    if(RegQueryValueEx(hkGeneService, "BreakOnServiceStart", NULL, &dwType, (LPBYTE)&dwValue, &dwDataLen) != ERROR_SUCCESS)
    {
        bReturn = FALSE;
        goto Cleanup;
    }

    bReturn = (dwType == REG_DWORD && dwValue != 0);

Cleanup:

    if(hkGeneService != NULL)
        RegCloseKey(hkGeneService);
    
    return bReturn;
}

VOID WINAPI GeneServiceCtrlHandler(DWORD Opcode)
{
    DWORD status; 
 
    switch(Opcode) 
    { 
        case SERVICE_CONTROL_STOP:

            g_GeneServiceStatus.dwCurrentState  = SERVICE_STOP_PENDING;
            g_GeneServiceStatus.dwCheckPoint    = 0;
            g_GeneServiceStatus.dwWaitHint      = 1000;

            if (!SetServiceStatus (g_GeneServiceStatusHandle, &g_GeneServiceStatus))
            { 
                status = GetLastError();
                ERROR1(XEVENT_GENEALOGY_SET_STATUS_FAILED_5, "Failed to set service status.  Error = 0x%08X.", status);
            } 

            //
            //  Set the stop event and wait a while for the thread to finish.  It should finish
            //  quickly, but if it doesn't after five seconds we'll just shut down anyway
            //

            SetEvent(g_hServiceStopEvent);

            while(WaitForSingleObject(g_hWorkerThread, 1000) == WAIT_TIMEOUT && g_GeneServiceStatus.dwCheckPoint < 5)
            {
                ++g_GeneServiceStatus.dwCheckPoint;
                g_GeneServiceStatus.dwWaitHint = 1000;

                if (!SetServiceStatus (g_GeneServiceStatusHandle, &g_GeneServiceStatus))
                { 
                    status = GetLastError();
                    ERROR1(XEVENT_GENEALOGY_SET_STATUS_FAILED_6, "Failed to set service status.  Error = 0x%08X.", status);
                }  
            }
 
            //
            //  Terminate thread and clean up
            //

            if(g_GeneServiceStatus.dwCheckPoint >= 5)
                TerminateThread(g_hWorkerThread, -1);

            GeneServiceCleanup();

            // Do whatever it takes to stop here. 
            g_GeneServiceStatus.dwWin32ExitCode = 0; 
            g_GeneServiceStatus.dwCurrentState  = SERVICE_STOPPED; 
            g_GeneServiceStatus.dwCheckPoint    = 0; 
            g_GeneServiceStatus.dwWaitHint      = 0; 
 
            if (!SetServiceStatus (g_GeneServiceStatusHandle, &g_GeneServiceStatus))
            { 
                status = GetLastError();
                ERROR1(XEVENT_GENEALOGY_SET_STATUS_FAILED_7, "Failed to set service status.  Error = 0x%08X.", status);
            } 
 
            INFO0(XEVENT_GENEALOGY_SERVICE_STOPPED_1, "Genealogy import service has stopped.");

            break; 
 
        default: 
            // Send current status. 
            if (!SetServiceStatus (g_GeneServiceStatusHandle,  &g_GeneServiceStatus)) 
            { 
                status = GetLastError(); 
                ERROR1(XEVENT_GENEALOGY_SET_STATUS_FAILED_8, "Failed to set service status.  Error = 0x%08X.", status);
            } 
            break;
    } 
 
    return; 
}

BOOL VerifyDirectoryExists(LPCSTR szDir)
{
    BOOL bReturn;

    if(!CreateDirectory(szDir, NULL))
    {
        DWORD dwError = GetLastError();

        switch(dwError)
        {
        case ERROR_FILE_EXISTS:
        case ERROR_ALREADY_EXISTS:
            bReturn = TRUE;
            goto Cleanup;

        default:
            bReturn = FALSE;
            goto Cleanup;
        }
    }
    else
        bReturn = TRUE;

Cleanup:

    return bReturn;
}

// EOF
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\genealogy\genesvc\nCipher.cpp ===
#include "stdinc.h"
#include "nCipher.h"

CNCipher::CNCipher( void )
    : m_hProv( NULL ),
      m_hPrvKey( NULL )
{
    ZeroMemory( m_abDecodedBase64OnlineKey, 256 );
}

CNCipher::~CNCipher( void )
{
    BOOL bRet = FALSE;

    //
    // destroy the key
    //

    if ( NULL != m_hPrvKey )
    {
        bRet = CryptDestroyKey( m_hPrvKey );

        if ( ! bRet )
        {
            ERROR0( XEVENT_GENEALOGY_ERROR_DESTROYING_KEY_HANDLE_1, "Could not destory key handle\n" );
        }

        m_hPrvKey = NULL;
    }

    //
    // destory the crypto context
    //

    if ( NULL != m_hProv )
    {
        bRet = CryptReleaseContext( m_hProv, 0 );

        if ( ! bRet )
        {
            ERROR0( XEVENT_GENEALOGY_ERROR_RELEASING_CRYPT_CONTEXT_1, "Could not release context\n" );
        }

        m_hProv = NULL;
    }
}

HRESULT CNCipher::AquireKeys( void )
{
    HRESULT hr = S_OK;
    BOOL bResult = FALSE;

    //
    // get the crypto context
    //

    if ( SUCCEEDED( hr ) )
    {
        bResult = CryptAcquireContext( &m_hProv, "XboxOnlineKeyV1", "nCipher Enhanced Cryptographic Provider", PROV_RSA_FULL, CRYPT_MACHINE_KEYSET );
        hr = FALSE == bResult ? E_FAIL : S_OK;

        if ( FAILED( hr ) )
        {
            ERROR0( XEVENT_GENEALOGY_ERROR_AQUIRE_CRYPT_CONTEXT_1, "Could not aquire crypt context\n" );
        }
    }

    //
    // get key
    //

    if ( SUCCEEDED( hr ) )
    {
        bResult = CryptGetUserKey( m_hProv, AT_KEYEXCHANGE, &m_hPrvKey );
        hr = FALSE == bResult ? E_FAIL : S_OK;

        if ( FAILED( hr ) )
        {
            ERROR0( XEVENT_GENEALOGY_ERROR_GET_USER_KEY_1, "Could not get user key\n" );
        }
    }

    return hr;
}

XBOX_ENCRYPTED_ONLINE_DATA* CNCipher::DecodeKey( LPSTR szKey )
{
    DWORD dwSize = 0;

    //
    // base 64 decode the online key
    //
        
    BOOL bResult = Base64Decode( szKey, ONLINE_KEY_LENGTH, m_abDecodedBase64OnlineKey, &dwSize );   
    
    //
    // make sure the decode was successful
    //

    if ( ! bResult || ONLINE_KEY_PKENC_SIZE != dwSize )
    {
        ERROR0( XEVENT_GENEALOGY_ERROR_DECODE_ONLINE_KEY_1, "Could not base 64 decode Online key\n" );
        return NULL;
    }

    //
    // make sure the decrypt was successful
    //

    bResult = CryptDecrypt( m_hPrvKey, NULL, TRUE, 0, m_abDecodedBase64OnlineKey, &dwSize );

    if ( ! bResult || sizeof( XBOX_ENCRYPTED_ONLINE_DATA ) != dwSize )
    {
        ERROR0( XEVENT_GENEALOGY_ERROR_DECRYPT_ONLINE_KEY_1, "Could not decrypt online key\n" );
        return NULL;
    }

    //
    // cast the blob to a useful pointer, and return it
    //

    return (PXBOX_ENCRYPTED_ONLINE_DATA) m_abDecodedBase64OnlineKey;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\genealogy\genesvc\structs.h ===
///////////////////////////////////////////////////////////////////////////////
//
// Name: structs.h
//
// Author: Dan Rosenstein (danrose)
//
// Description: the structs used in the genealogy tool
//
///////////////////////////////////////////////////////////////////////////////

#pragma once

//
// the online gaming Row set decleration
//

struct SOnlineGaming
{
    CHAR szSerialNumber[XBSERIAL_NUMBER_LENGTH + 1];
    CHAR szPartNumber[PART_NUMBER_LENGTH + 1];
    CHAR szOnlineKey[ONLINE_KEY_LENGTH + 1];
    CHAR szOnlineKeyVersion[ONLINE_KEY_VERSION_LENGTH + 1];
    CHAR szMacAddress[MAC_ADDRESS_LENGTH + 1];
    CHAR szGameRegion[GAME_REGION_CODE_LENGTH + 1];
    CHAR szTVRegion[TV_REGION_CODE_LENGTH + 1];
    CHAR szIsActive[IS_ACTIVE_LENGTH + 1];
    BYTE abPPA2[PPA2_LENGTH];
    BYTE abSPPA1[SPPA1_LENGTH];
    COleDateTime timeAppeared;

};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\genealogy\genesvc\nCipher.h ===
///////////////////////////////////////////////////////////////////////////////
//
// Name: nCipher.h
//
// Author: Dan Rosenstein (danrose)
//
// Description: the interfrace for the CNCipher class
//
///////////////////////////////////////////////////////////////////////////////

#pragma once

///////////////////////////////////////////////////////////////////////////////
//
// necessary includes
//
///////////////////////////////////////////////////////////////////////////////

#include "base64.h"

///////////////////////////////////////////////////////////////////////////////
//
// CNCipher class - class used to abstract out access of the nCipher device
//
///////////////////////////////////////////////////////////////////////////////

class CNCipher
{
public:

    CNCipher( void );
    ~CNCipher( void );

    HRESULT AquireKeys( void );
    XBOX_ENCRYPTED_ONLINE_DATA* DecodeKey( LPSTR szKey );

private:

    //
    // the provider handle
    //

    HCRYPTPROV m_hProv;

    //
    // the key handle
    //

    HCRYPTKEY m_hPrvKey;

    //
    // the array of decoded bytes
    //

    BYTE m_abDecodedBase64OnlineKey[256];
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\genealogy\genesvc\XRC4.cpp ===
#include "stdinc.h"
#include "XRC4.h"

void
XcRC4Key(
    IN PUCHAR pbKeyStruct,
    IN ULONG dwKeyLength,
    IN PUCHAR pbKey
    )
{
    rc4_key((RC4_KEYSTRUCT*)pbKeyStruct, dwKeyLength, pbKey);
}
   
void
XcRC4Crypt(
    IN PUCHAR pbKeyStruct,
    IN ULONG dwInputLength,
    IN PUCHAR pbInput
    )
{
    rc4((RC4_KEYSTRUCT*)pbKeyStruct, dwInputLength, pbInput);
}
   
void
XcHMAC(
    IN PBYTE pbKeyMaterial,
    IN ULONG cbKeyMaterial,
    IN PBYTE pbData,
    IN ULONG cbData,
    IN PBYTE pbData2,
    IN ULONG cbData2,
    OUT PBYTE HmacData // length must be A_SHA_DIGEST_LEN
    )
{
#define HMAC_K_PADSIZE              64
#define HMAC_KI_XOR_FACTOR            ((DWORD)0x36363636)
#define HMAC_KO_XOR_FACTOR            ((DWORD)0x5C5C5C5C)
    BYTE Kipad[HMAC_K_PADSIZE];
    BYTE Kopad[HMAC_K_PADSIZE];
    BYTE HMACTmp[HMAC_K_PADSIZE+A_SHA_DIGEST_LEN];
    ULONG dwBlock;
    A_SHA_CTX shaHash;

    // truncate
    if (cbKeyMaterial > HMAC_K_PADSIZE)
        cbKeyMaterial = HMAC_K_PADSIZE;

    RtlZeroMemory(Kipad, HMAC_K_PADSIZE);
    RtlCopyMemory(Kipad, pbKeyMaterial, cbKeyMaterial);

    RtlZeroMemory(Kopad, HMAC_K_PADSIZE);
    RtlCopyMemory(Kopad, pbKeyMaterial, cbKeyMaterial);

    //
    // Kipad, Kopad are padded sMacKey. Now XOR across...
    //
    for(dwBlock=0; dwBlock<HMAC_K_PADSIZE/sizeof(DWORD); dwBlock++)
    {
        ((DWORD*)Kipad)[dwBlock] ^= HMAC_KI_XOR_FACTOR;
        ((DWORD*)Kopad)[dwBlock] ^= HMAC_KO_XOR_FACTOR;
    }

    //
    // prepend Kipad to data, Hash to get H1
    //

    A_SHAInit(&shaHash);
    A_SHAUpdate(&shaHash, Kipad, HMAC_K_PADSIZE);
    if (cbData != 0)
    {
        A_SHAUpdate(&shaHash, pbData, cbData);
    }
    if (cbData2 != 0)
    {
        A_SHAUpdate(&shaHash, pbData2, cbData2);
    }

    // Finish off the hash
    A_SHAFinal(&shaHash,HMACTmp+HMAC_K_PADSIZE);

    // prepend Kopad to H1, hash to get HMAC
    RtlCopyMemory(HMACTmp, Kopad, HMAC_K_PADSIZE);

    // final hash: output value into passed-in buffer
    A_SHAInit(&shaHash);
    A_SHAUpdate(&shaHash,HMACTmp, sizeof(HMACTmp));
    A_SHAFinal(&shaHash,HmacData);
}

void rc4HmacEncrypt(
    IN PUCHAR confounder, // RC4_CONFOUNDER_LEN bytes
    IN PUCHAR pbKey,
    IN ULONG cbKey,
    IN PUCHAR pbInput,
    IN ULONG cbInput,
    OUT PUCHAR pbHeader // XC_SERVICE_DIGEST_SIZE + RC4_CONFOUNDER_LEN bytes
    )
{
    PRC4_SHA1_HEADER CryptHeader = (PRC4_SHA1_HEADER) pbHeader;
    BYTE LocalKey[XC_SERVICE_DIGEST_SIZE];
    BYTE Rc4KeyStruct[XC_SERVICE_RC4_KEYSTRUCT_SIZE];

    //
    // Create the header - the confounder & checksum
    //
    RtlZeroMemory( CryptHeader->Checksum, XC_SERVICE_DIGEST_SIZE );
    RtlCopyMemory( CryptHeader->Confounder, confounder, RC4_CONFOUNDER_LEN );

    //
    // Checksum everything but the checksum
    //
    XcHMAC( pbKey, cbKey,
            CryptHeader->Confounder, RC4_CONFOUNDER_LEN,
            pbInput, cbInput,
            CryptHeader->Checksum );

    //
    // HMAC the checksum into the key
    //
    XcHMAC( pbKey, cbKey,
            CryptHeader->Checksum, XC_SERVICE_DIGEST_SIZE,
            NULL, 0,
            LocalKey );

    //
    // Use the generated key as the RC4 encryption key
    //
    XcRC4Key( Rc4KeyStruct, XC_SERVICE_DIGEST_SIZE, LocalKey );

    //
    // Encrypt everything but the checksum
    //
    XcRC4Crypt( Rc4KeyStruct, RC4_CONFOUNDER_LEN, CryptHeader->Confounder );
    XcRC4Crypt( Rc4KeyStruct, cbInput, pbInput );
}


BOOL rc4HmacDecrypt(
    IN PUCHAR pbKey,
    IN ULONG cbKey,
    IN PUCHAR pbInput,
    IN ULONG cbInput,
    IN PUCHAR pbHeader // XC_SERVICE_DIGEST_SIZE + RC4_CONFOUNDER_LEN bytes
    )
{
    PRC4_SHA1_HEADER CryptHeader = (PRC4_SHA1_HEADER) pbHeader;
    RC4_SHA1_HEADER TempHeader;
    BYTE LocalKey[XC_SERVICE_DIGEST_SIZE];
    BYTE Rc4KeyStruct[XC_SERVICE_RC4_KEYSTRUCT_SIZE];

    RtlCopyMemory( TempHeader.Confounder, CryptHeader->Confounder, RC4_CONFOUNDER_LEN );

    //
    // HMAC the checksum into the key
    //
    XcHMAC( pbKey, cbKey,
            CryptHeader->Checksum, XC_SERVICE_DIGEST_SIZE,
            NULL, 0,
            LocalKey );

    //
    // Use the generated key as the RC4 encryption key
    //
    XcRC4Key( Rc4KeyStruct, XC_SERVICE_DIGEST_SIZE, LocalKey );

    //
    // Decrypt confounder and data
    //
    XcRC4Crypt( Rc4KeyStruct, RC4_CONFOUNDER_LEN, TempHeader.Confounder );
    XcRC4Crypt( Rc4KeyStruct, cbInput, pbInput );

    //
    // Now verify the checksum.
    //
    XcHMAC( pbKey, cbKey,
            TempHeader.Confounder, RC4_CONFOUNDER_LEN,
            pbInput, cbInput,
            TempHeader.Checksum );

    //
    // Decrypt is successful only if checksum matches
    //
    return ( RtlEqualMemory(
                TempHeader.Checksum,
                CryptHeader->Checksum,
                XC_SERVICE_DIGEST_SIZE) );
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\genealogy\genesvc\XRC4.h ===
#pragma once

#include <rc4.h>
#include <sha.h>
#include <xcrypt.h>

#define RC4_CONFOUNDER_LEN 8

//
// Header before encrypted data
//
typedef struct _RC4_SHA1_HEADER {
    UCHAR Checksum[XC_SERVICE_DIGEST_SIZE];
    UCHAR Confounder[RC4_CONFOUNDER_LEN];
} RC4_SHA1_HEADER, *PRC4_SHA1_HEADER;

void XcRC4Key( IN PUCHAR pbKeyStruct, IN ULONG dwKeyLength, IN PUCHAR pbKey );
void XcRC4Crypt( IN PUCHAR pbKeyStruct, IN ULONG dwInputLength, IN PUCHAR pbInput );

void XcHMAC( IN PBYTE pbKeyMaterial, IN ULONG cbKeyMaterial, IN PBYTE pbData, IN ULONG cbData, IN PBYTE pbData2, IN ULONG cbData2, OUT PBYTE HmacData );

void rc4HmacEncrypt( IN PUCHAR confounder, IN PUCHAR pbKey, IN ULONG cbKey, IN PUCHAR pbInput, IN ULONG cbInput, OUT PUCHAR pbHeader );
BOOL rc4HmacDecrypt( IN PUCHAR pbKey, IN ULONG cbKey, IN PUCHAR pbInput, IN ULONG cbInput, IN PUCHAR pbHeader );
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\genealogy\genesvc\Params.cpp ===
#include "stdinc.h"

CParams::CParams( void )
    : m_szDBName( NULL ),
      m_szMachineName( NULL ),
      m_szNCipherDisabled( NULL ),
      m_szInputPath( NULL ),
      m_szOutputPath( NULL )
{
}

CParams::~CParams( void )
{
    int iClose = 0;

    //
    // reset the db name and machine name and the flags
    //

    m_szDBName = NULL;
    m_szMachineName = NULL;
    m_szNCipherDisabled = NULL;
}

void CParams::SetString( LPSTR* pszString, LPSTR szVal )
{
    if ( NULL == *pszString )
    {
        *pszString = szVal;
    }
}

void CParams::SetDBName( LPSTR szName )
{
    SetString( &m_szDBName, szName );
}

void CParams::SetMachineName( LPSTR szName )
{
    SetString( &m_szMachineName, szName );
}

void CParams::SetNCipherDisabled( LPSTR szName )
{
    SetString( &m_szNCipherDisabled, szName );
}

void CParams::SetInputPath( LPSTR szPath )
{
    SetString( &m_szInputPath, szPath );
}

void CParams::SetOutputPath( LPSTR szPath )
{
    SetString( &m_szOutputPath, szPath );
}

HRESULT CParams::OpenFile( FILE** ppFile, LPCSTR szPath )
{
    HRESULT hr = S_OK;

    //
    // make sure file has not been open
    //

    if ( NULL == *ppFile )
    {
        *ppFile = fopen( szPath, "rb" );
		
		//
		// make sure the file could be opened
		//

		if ( NULL == *ppFile )
		{
			hr = HRESULT_FROM_WIN32( ERROR_FILE_NOT_FOUND );
			ERROR1( XEVENT_GENEALOGY_ERROR_OPEN_FILE_2, "could not open file %s\n", szPath );
		}
    }

    return hr;
}

HRESULT CParams::GetSettingString( LPCSTR szConfigFileName, LPCSTR szLookup, LPSTR* pszSetting )
{
    HRESULT hr = S_OK;
    LPSTR szRet = NULL;
    CHAR szSectionName[1024];
	CHAR szBuf[1024];
    LPSTR szValueName;

    memset(szSectionName, 0, sizeof(szSectionName));
    memset(szBuf, 0, sizeof(szBuf));

	//
	// split the setting name into section name and value name
	//

    strcpy_s(szSectionName, _countof(szSectionName), szLookup);
	szValueName = strchr(szSectionName, '.');

	if(szValueName == NULL)
	{
		hr = E_INVALIDARG;
        ERROR1( XEVENT_GENEALOGY_ERROR_GET_SETTING_1, "Invalid setting \"%s\".  Must be in the form \"<section>.<value>\"\n", szLookup );
	}

	if ( SUCCEEDED( hr ) )
	{
		*(szValueName++) = '\0';

		//
		// get the setting
		//

		GetPrivateProfileString(
			szSectionName, 
			szValueName, 
			NULL,
			szBuf,
			sizeof(szBuf),
			szConfigFileName);
	}

    //
    // get the string value
    //

    if ( SUCCEEDED( hr ) )
    {
        *pszSetting = _strdup(szBuf);

        //
        // make sure the string was not empty, if it was, make it NULL
        //

        if ( '\0' == **pszSetting )
        {
            free(*pszSetting);
            *pszSetting = NULL;
        }
    }

    return hr;
}

HRESULT CParams::SetStringFromSetting( LPCSTR szConfigFileName, LPCSTR szSetting, LPSTR* pszString )
{
    HRESULT hr = S_OK;
    LPSTR szVal = NULL;

    //
    // get the setting string
    //

    if ( SUCCEEDED( hr ) )
    {
        hr = GetSettingString( szConfigFileName, szSetting, &szVal );
    }

    //
    // set the internal string
    //

    if ( SUCCEEDED( hr ) && NULL != szVal )
    {
        SetString( pszString, szVal );
    }

    return hr;
}

HRESULT CParams::ProcessConfigFile( LPCSTR szConfigFileName )
{
    HRESULT hr = S_OK;

    //
    // get the db name
    //

    if ( SUCCEEDED( hr ) )
    {
        hr = SetStringFromSetting( szConfigFileName, "Genealogy.DB", &m_szDBName );
    }

    //
    // get the Machine name
    //

    if ( SUCCEEDED( hr ) )
    {
        hr = SetStringFromSetting( szConfigFileName, "Genealogy.Machine", &m_szMachineName );
    }

    //
    // get the verify value
    //

    if ( SUCCEEDED( hr ) )
    {
        hr = SetStringFromSetting( szConfigFileName, "Genealogy.NCipherDisabled", &m_szNCipherDisabled );
    }

    //
    // get the file input path
    //

    if ( SUCCEEDED( hr ) )
    {
        hr = SetStringFromSetting( szConfigFileName, "Genealogy.InputPath", &m_szInputPath );
    }

    //
    // get the file output path
    //

    if ( SUCCEEDED( hr ) )
    {
        hr = SetStringFromSetting( szConfigFileName, "Genealogy.OutputPath", &m_szOutputPath );
    }

    //
    // get the file archive path
    //

    if ( SUCCEEDED( hr ) )
    {
        hr = SetStringFromSetting( szConfigFileName, "Genealogy.ArchivePath", &m_szArchivePath );
    }

    return hr;
}

HRESULT CParams::InitResources( LPCSTR szConfigFileName )
{
    HRESULT hr;

    //
    // if a config file was entered, then process it.
    // we can only process it after the xmgmt init!
    //

    hr = ProcessConfigFile(szConfigFileName);

    return hr;
}


HRESULT CParams::LoadConfig(
    LPCSTR  szConfigFileName
    )
{
    HRESULT hr;

    //
    // now init the resources
    //

    hr = InitResources(szConfigFileName);

    return hr;
}

// EOF
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\genealogy\genesvc\PartNumberTable.h ===
///////////////////////////////////////////////////////////////////////////////
//
// Name: PartNumberTable.h
//
// Author: Darren Anderson (darrenan)
//
// Description: class to read in a part number csv file
//
///////////////////////////////////////////////////////////////////////////////

#pragma once

///////////////////////////////////////////////////////////////////////////////
//
// CDataFeed class - class used to abstract out importing of genealogy feeds
//
///////////////////////////////////////////////////////////////////////////////

typedef VOID (NTAPI * LOADPROGRESSCALLBACK) (VOID);

class CPartNumberInfo
{
public:

    CPartNumberInfo() : 
        m_cszPartNumber(""),
        m_fInEnv(0)
    {
    }

    CPartNumberInfo(LPCSTR szPartNumber, USHORT fInEnv = 0) : 
        m_cszPartNumber(szPartNumber),
        m_fInEnv(fInEnv)
    {
    }

    string  m_cszPartNumber;
    USHORT  m_fInEnv;    
};

extern bool operator<(const CPartNumberInfo& p1, const CPartNumberInfo& p2);

typedef set<CPartNumberInfo> PARTNUMBERS;

class CPartNumberTable
{
public:
    CPartNumberTable();
    ~CPartNumberTable(void);

    BOOL Load(LPCSTR szFileName, CODBWSession& ses);
    BOOL LoadFromDB(CODBWSession& ses, LOADPROGRESSCALLBACK fnCallback);

    BOOL Write(LPCSTR szFile, USHORT nEnvironment);

    BOOL Exists(LPCSTR szPartNumber);
    USHORT EnvMask(LPCSTR szPartNumber);

private:

    PARTNUMBERS     m_PartNumbers;
    CWSProcCache    m_SetPartNumberCache;
    CWSProcCache    m_SetPartNumberExCache;
    CWSProcCache    m_GetPartNumbersCache;

protected:
    LPSTR GetNextField(LPSTR szBuf, int& nCurPos);

    BOOL SetPartNumberInDB(CPartNumberInfo& partNumberInfo, CODBWSession& ses);
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\genealogy\genesvc\Params.h ===
///////////////////////////////////////////////////////////////////////////////
//
// Name: Params.h
//
// Author: Dan Rosenstein (danrose)
//
// Description: the interfrace for the CParams class
//
///////////////////////////////////////////////////////////////////////////////

#pragma once

///////////////////////////////////////////////////////////////////////////////
//
// CParams class - class used to parse command line parameters
//                 and set up the resources for the genealogy tool
//
///////////////////////////////////////////////////////////////////////////////

class CParams
{
public:

    //
    // the constructor and destructor for the params object
    //

    CParams( void );
    ~CParams( void );

    //
    // the argument parsing function
    //

    HRESULT LoadConfig( LPCSTR szConfigFilename );

    //
    // boolean accessors
    //

    BOOL NCipherDisabled( void ) { return (m_szNCipherDisabled != NULL && lstrcmpiA(m_szNCipherDisabled, "yes") == 0); };

    //
    // string accessors
    //

    LPSTR GetDBName     ( void ) { return m_szDBName;      }
    LPSTR GetMachineName( void ) { return m_szMachineName; }
    LPSTR GetInputPath  ( void ) { return m_szInputPath;   }
    LPSTR GetOutputPath ( void ) { return m_szOutputPath;  }
    LPSTR GetArchivePath( void ) { return m_szArchivePath; }

private:

    //
    // init the resources
    //

    HRESULT InitResources( LPCSTR szConfigFileName );

    //
    // helper to open a file
    //

    HRESULT OpenFile( FILE** ppFile, LPCSTR szPath );

    //
    // set a string based on a setting
    //

    HRESULT SetStringFromSetting( LPCSTR szConfigFileName, LPCSTR szSetting, LPSTR* pszString );

    //
    // get a config string
    //

    HRESULT GetSettingString( LPCSTR szConfigFileName, LPCSTR szLookup, LPSTR* pszSetting );

    //
    // set a string only if it is null originaly
    //

    void SetString( LPSTR* pszString, LPSTR szVal );

    //
    // set the machine, db name, config file name, ncipher disabled, drop path, environment
    //

    void SetDBName( LPSTR szName );
    void SetMachineName( LPSTR szName );
    void SetConfigFileName( LPSTR szName );
    void SetNCipherDisabled( LPSTR szName );
    void SetInputPath( LPSTR szName );
    void SetOutputPath( LPSTR szName );

    //
    // helper to process the config file
    //

    HRESULT ProcessConfigFile( LPCSTR szConfigFileName );

    //
    // the db name
    //

    LPSTR m_szDBName;

    //
    // the machine name
    //

    LPSTR m_szMachineName;

    //
    // the input path
    //

    LPSTR m_szInputPath;

    //
    // the output path
    //

    LPSTR m_szOutputPath;

    //
    // the archive path
    //

    LPSTR m_szArchivePath;

    //
    // nCipher disabled?
    //

    LPSTR m_szNCipherDisabled;

};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\genealogy\genesvc\PartNumberTable.cpp ===
#include "stdinc.h"
#include "partnumbertable.h"
#include "dbutil.h"

typedef struct tagPARTNUMBERINFO
{
    CHAR    szPartNumber[PART_NUMBER_LENGTH + 1];
    USHORT  nEnvironmentMask;
}
PARTNUMBERINFO;

//
// the part table binding
//

static DBBINDING partBind[] = { 
    WSBIND( 1, offsetof( PARTNUMBERINFO, szPartNumber ),     DBTYPE_STR, PART_NUMBER_LENGTH + 1 )
};


bool operator<(const CPartNumberInfo& p1, const CPartNumberInfo& p2) { return p1.m_cszPartNumber < p2.m_cszPartNumber; };

//
//  Trim white space characters off beginning and end of a string
//

char* trim(char* sz)
{
    char* szFront;
    char* szEnd;

    // scoot past any white space at the front
    for(szFront = sz; *szFront != NULL && isspace(*szFront); ++szFront);

    szEnd = szFront + strlen(szFront) - 1;

    while(isspace(*szEnd))
    {
        *szEnd = '\0';
        --szEnd;
    }

    return szFront;
}

//
//  Improvement on the standard strtok which returns empty strings when
//  two delimiters are right next to each other.
//

char* strtokz(char* sz, char* delim)
{
    char* szTok;
    char* szCur;

    static char* szNextStart = NULL;

    if(sz != NULL)
    {
        szTok = sz;
    }
    else
    {
        if(szNextStart == NULL)
            return NULL;

        szTok = szNextStart;
    }

    szCur = szTok;

    while(*szCur && strchr(delim, *szCur) == NULL) ++szCur;

    if(*szCur)
    {
        *szCur = '\0';
        szNextStart = szCur + 1;
    }
    else
        szNextStart = NULL;

    return szTok;
}

//
//  CPartNumberTable
//

CPartNumberTable::CPartNumberTable()
{
}

CPartNumberTable::~CPartNumberTable(void)
{
    m_PartNumbers.clear();
}

//
//  Load part numbers from a file.
//

BOOL CPartNumberTable::Load(
    LPCSTR          szFilename,
    CODBWSession&   ses
    )
{
    BOOL    bReturn;
    FILE*   pPartFile;
    CHAR    szLineBuf[512];
    int     nLine;
    int     nUpdated;
    int     nInserted;
    int     nDuplicate;
    int     nError = 0;

    //
    //  Open the file
    //

    pPartFile = fopen(szFilename, "r");
    if(pPartFile == NULL)
    {
        ERROR2(XEVENT_TOOLS_CONFIG_34, 
               "Attempt to open file \"%s\" failed with error code = 0x%08X.",
               szFilename,
               HRESULT_FROM_WIN32(GetLastError()));
        bReturn = FALSE;
        goto Cleanup;
    }

    //
    //  Read lines from the file
    //

    nLine = 0;
    nUpdated = 0;
    nInserted = 0;
    nDuplicate = 0;
    nError = 0;
    while(TRUE)
    {
        int                     nCurPos;
        int                     nCurField;
        BOOL                    bDone;
        LPSTR                   szTok;
        CPartNumberInfo         partNumberInfo;
        PARTNUMBERS::iterator   it;

        //
        //  Get the next line
        //

        if(fgets(szLineBuf, sizeof(szLineBuf), pPartFile) == NULL)
        {
            int nError = ferror(pPartFile);
            if(nError != 0)
            {
                ERROR3(XEVENT_GENEALOGY_ERROR_FILE_READ,
                       "Reading from \"%s\" failed on line %d with error %d.\r\n",
                       szFilename,
                       nLine,
                       nError);

                bReturn = FALSE;
                break;
            }

            if(feof(pPartFile))
            {
                bReturn = TRUE;
                break;
            }
        }

        //
        //  Process the line.  If the line begins with a comma, ignore it.
        //

        if(szLineBuf[0] == ',')
        {
            ++nLine;
            continue;
        }

        //
        //  Start reading tokens
        //

        nCurPos = 0;
        nCurField = 0;
        partNumberInfo.m_fInEnv = 0;
        bDone = FALSE;

        szTok = strtokz(trim(szLineBuf), ",");

        while(!bDone && szTok != NULL)
        {
            switch(nCurField)
            {
            case 0: // part number
                if(lstrlenA(szTok) == 0)
                    bDone = TRUE;
                else
                    partNumberInfo.m_cszPartNumber = szTok;
                break;

            case 1: // reference db?
                if(lstrcmpiA(szTok, "X") == 0)
                    partNumberInfo.m_fInEnv |= REF_MASK;
                break;

            case 2: // devnet?
                if(lstrcmpiA(szTok, "X") == 0)
                    partNumberInfo.m_fInEnv |= DEV_MASK;
                break;

            case 3: // testnet?
                if(lstrcmpiA(szTok, "X") == 0)
                    partNumberInfo.m_fInEnv |= TEST_MASK;
                break;

            case 4: // partnernet?
                if(lstrcmpiA(szTok, "X") == 0)
                    partNumberInfo.m_fInEnv |= PARTNER_MASK;
                break;

            case 5: // betanet?
                if(lstrcmpiA(szTok, "X") == 0)
                    partNumberInfo.m_fInEnv |= BETA_MASK;
                break;

            case 6: // certnet?
                if(lstrcmpiA(szTok, "X") == 0)
                    partNumberInfo.m_fInEnv |= CERT_MASK;
                break;

            case 7: // preprodnet?
                if(lstrcmpiA(szTok, "X") == 0)
                    partNumberInfo.m_fInEnv |= PREPROD_MASK;
                break;

            case 8: // prodnet?
                if(lstrcmpiA(szTok, "X") == 0)
                    partNumberInfo.m_fInEnv |= PROD_MASK;
                break;

            default:
                //  Done, we don't care about any other fields.
                bDone = TRUE;
                break;
            }

            ++nCurField;
            szTok = strtokz(NULL, ",");
        }

        // wrong number of fields on this line?
        if(nCurField != 1 && nCurField != 9)
        {
            ERROR2(XEVENT_TOOLS_COMM_45,
                   "Wrong number of fields on line %d of \"%s\".",
                   nLine,
                   szFilename);
            ++nError;
        }
        else
        {
            if(nCurField == 1)
                partNumberInfo.m_fInEnv = IGNORE_MASK;

            //
            //  New or existing record?
            //

            it = m_PartNumbers.find(partNumberInfo);
            if(it == m_PartNumbers.end())
            {
                //
                //  Make sure that the db has this part number
                //

                if(SetPartNumberInDB(partNumberInfo, ses))
                {
                    //
                    //  Insert the partnumber record into the map and the db
                    //  if it's a new record, or an existing one that has changed.
                    //

                    m_PartNumbers.insert(partNumberInfo);
                    ++nInserted;
                }
                else
                    ++nError;
            }
            else if(partNumberInfo.m_fInEnv != (*it).m_fInEnv)
            {
                if(SetPartNumberInDB(partNumberInfo, ses))
                {
                    (*it).m_fInEnv = partNumberInfo.m_fInEnv;
                    ++nUpdated;
                }
                else
                    ++nError;
            }
            else
                ++nDuplicate;
        }

        //
        //  Next line
        //

        ++nLine;
    }

    INFO5(XEVENT_GENEALOGY_INFO_UPDATE_COMPLETE_1,
          "Update of part numbers complete.\r\n"
          "\t%d part numbers processed.\r\n"
          "\t%d part numbers inserted.\r\n"
          "\t%d part numbers updated.\r\n"
          "\t%d part numbers were duplicates and ignored.\r\n"
          "\t%d part numbers were in error.",
          nLine,
          nInserted,
          nUpdated,
          nDuplicate,
          nError);

Cleanup:

    if(pPartFile != NULL)
        fclose(pPartFile);

    return bReturn;
}

//
//  Load part numbers from DB.  This is only called at service start,
//  and only if there is an output directory configured.
//

BOOL CPartNumberTable::LoadFromDB(
    CODBWSession&           ses,
    LOADPROGRESSCALLBACK    fnProgress
    )
{
    BOOL            bReturn;
    HRESULT         hr;
    DWORD           cRows;
    PARTNUMBERINFO  partNumberInfo;

    //
    //  Call stored procedure
    //

    hr = ses.CallProc(&m_GetPartNumbersCache, GET_PARTNUMBERS_SPROC_CALL_STRING);
    if(FAILED(hr))
    {
        ERROR2(XEVENT_TOOLS_CODE_44,
               "Error occurred while calling stored procedure \"%s\".  Error = 0x%08X.",
               GET_PARTNUMBERS_SPROC_CALL_STRING,
               hr);
        goto Cleanup;
    }

    //
    //  Bind to result set
    //

    hr = ses.SetBindings(partBind, PART_TABLE_BIND_SIZE);
    if(FAILED(hr))
    {
        ERROR1(XEVENT_TOOLS_CONFIG_35,
               "Failed to setup bindings to the part number table.  Error = 0x%08X.",
               hr);
        goto Cleanup;
    }

    //
    //  Process rows
    //

    cRows = 1;
    hr = ses.GetRows(&cRows, &partNumberInfo, sizeof(PARTNUMBERINFO));
    if(FAILED(hr))
    {
        ERROR1(XEVENT_TOOLS_COMM_46,
               "Error getting next row from part number table.  Error = 0x%08X.",
               hr);
        goto Cleanup;
    }

    while(cRows == 1)
    {
        CPartNumberInfo part(partNumberInfo.szPartNumber, partNumberInfo.nEnvironmentMask);
        
        m_PartNumbers.insert(part);

        //
        //  Inform caller about progress
        //

        if(fnProgress != NULL)
        {
            (*fnProgress)();
        }

        //
        //  Get next row
        //

        hr = ses.GetRows(&cRows, &partNumberInfo, sizeof(PARTNUMBERINFO));
        if(FAILED(hr))
        {
            ERROR1(XEVENT_TOOLS_COMM_47,
                "Error getting next row from part number table.  Error = 0x%08X.",
                hr);
            goto Cleanup;
        }
    }

    hr = S_OK;

Cleanup:

    if(FAILED(hr))
    {
        bReturn = FALSE;
        m_PartNumbers.clear();
    }
    else
        bReturn = TRUE;

    return bReturn;
}

//
//  Write the csv file for a specific environment to the specified file
//

BOOL CPartNumberTable::Write(
    LPCSTR  szFile,
    USHORT  nEnvironment
    )
{
    BOOL                    bReturn;
    PARTNUMBERS::iterator   it;
    FILE*                   pOutputFile;

    //
    //  Open the file for overwriting
    //

    pOutputFile = fopen(szFile, "w");
    if(pOutputFile == NULL)
    {
        HRESULT hr = HRESULT_FROM_WIN32(GetLastError());

        bReturn = FALSE;
        goto Cleanup;
    }

    //
    //  Write out all part numbers
    //

    for(it = m_PartNumbers.begin(); it != m_PartNumbers.end(); ++it)
    {
        if((*it).m_fInEnv & nEnvironment)
            fputs(((*it).m_cszPartNumber + "\n").c_str(), pOutputFile);
    }

    //                 
    //  Close the file 
    //                 
    
    fclose(pOutputFile);

    bReturn = TRUE;

Cleanup:

    return bReturn;
}

//
//  Does the given part number exist?
//

BOOL CPartNumberTable::Exists(LPCSTR szPartNumber)
{
    CPartNumberInfo partNumberInfo(szPartNumber);

    PARTNUMBERS::iterator it = m_PartNumbers.find(partNumberInfo);

    return (it != m_PartNumbers.end());
}

//
//  Get back the environment mask for a given part number
//

USHORT CPartNumberTable::EnvMask(LPCSTR szPartNumber)
{
    USHORT nEnvMask;

    CPartNumberInfo partNumberInfo(szPartNumber);

    PARTNUMBERS::iterator it = m_PartNumbers.find(partNumberInfo);

    if(it != m_PartNumbers.end())
        nEnvMask = (*it).m_fInEnv;
    else
        nEnvMask = 0xFFFF;

    return nEnvMask;
}

//
//  Add/update part number in DB
//

BOOL CPartNumberTable::SetPartNumberInDB(
    CPartNumberInfo&    partNumberInfo,
    CODBWSession&       ses
    )
{
    BOOL    bReturn;
    HRESULT hr;

    //  Update the part number
    if(partNumberInfo.m_fInEnv == IGNORE_MASK)
        hr = ses.CallProc(&m_SetPartNumberCache, 
                          UPDATE_PARTNUMBERS_SPROC_CALL_STRING, 
                          partNumberInfo.m_cszPartNumber.c_str());
    else
        hr = ses.CallProc(&m_SetPartNumberExCache, 
                          UPDATE_PARTNUMBERS_SPROC_CALL_STRING_EX, 
                          partNumberInfo.m_cszPartNumber.c_str(),
                          partNumberInfo.m_fInEnv);
    if(FAILED(hr))
    {
        ERROR2(XEVENT_TOOLS_CODE_45,
               "Failed to add part number to database.  Call to %s returned 0x%08X.",
               UPDATE_PARTNUMBERS_SPROC_CALL_STRING,
               hr);
        bReturn = FALSE;
        goto Cleanup;
    }
    
    bReturn = TRUE;

Cleanup:

    return bReturn;
}

// EOF
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\genealogy\genesvc\stdinc.h ===
///////////////////////////////////////////////////////////////////////////////
//
// Name: stdinc.h
//
// Author: Dan Rosenstein (danrose)
//
// Description: the common set of includes for the genealogy tool
//
///////////////////////////////////////////////////////////////////////////////

#pragma once

#undef UNICODE
#undef _UNICODE

#include <ATLComTime.h>
#include <windows.h>
#include <crtdbg.h>

//#include <winsockx.h> 
#include <wsockntp.h>
#include <xonlinep.h>
#include <cryptoHelper.h>

#include <rc4.h>
#include <sha.h>
#include <xcrypt.h>
#include <wincrypt.h>
#include <stdio.h>
#include <stdlib.h>
#include <assert.h>

#include <sql.h>
#include <sqlext.h>
#include <odbcss.h>

#include <OleDBWrapper.h>
#include <xeventids.h>

#include <set>
#include <string>
using namespace std;

#include "macros.h"
#include "constants.h"
#include "structs.h"
#include "params.h"
#include "dbutil.h"

#include "genealogy.h"
#include "partnumbertable.h"

#include "global.h"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\genealogy\genesvc\obj\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86_genesvc_none_12.4.56.0_none_bdf0ee7319d2bbaf
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86_genesvc_no-public-key_12.4.56.0_x-ww_6736a201
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=genesvc
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86_genesvc_no-public-key_12.4.56.0_x-ww_6736a201
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86_genesvc_no-public-key_12.4.56.0_x-ww_6736a201.manifest
XP_MANIFEST_PATH=manifests\x86_genesvc_no-public-key_12.4.56.0_x-ww_6736a201.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86_genesvc_no-public-key_12.4.56.0_x-ww_6736a201.cat
XP_CATALOG_PATH=manifests\x86_genesvc_no-public-key_12.4.56.0_x-ww_6736a201.cat
XP_PAYLOAD_PATH=x86_genesvc_no-public-key_12.4.56.0_x-ww_6736a201
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=genesvc,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\genealogy\VerifyGenealogy\base64.h ===
/*++

    Copyright (c) Microsoft Corporation

    Module Name:

        Base64.h

--*/

#ifndef __BASE64_H
#define __BASE64_H

#ifdef __cplusplus
extern "C" {
#endif

#define BASE64_ENCODE_BUFFER_SIZE( ulSrcSize ) (((((ulSrcSize) + 2) / 3) * 4) + 1)

BOOL WINAPI
Base64Encode(               
    const LPBYTE    pSrc,
    ULONG           ulSrcSize,
    LPSTR           pszDst
    );

#define BASE64_DECODE_BUFFER_SIZE( ulSrcSize ) (((ulSrcSize) / 4) * 3)

BOOL WINAPI
Base64Decode(
    LPCSTR      pszSrc,
    ULONG       ulSrcSize,
    LPBYTE      pDst,
    PULONG      pulDstSize
    );

#ifdef __cplusplus
}
#endif

#endif // __BASE64_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\genealogy\genesvc\objd\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86_genesvc_none_12.4.56.0_none_bdf0ee7319d2bbaf
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86_genesvc_no-public-key_12.4.56.0_x-ww_6736a201
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=genesvc
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86_genesvc_no-public-key_12.4.56.0_x-ww_6736a201
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86_genesvc_no-public-key_12.4.56.0_x-ww_6736a201.manifest
XP_MANIFEST_PATH=manifests\x86_genesvc_no-public-key_12.4.56.0_x-ww_6736a201.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86_genesvc_no-public-key_12.4.56.0_x-ww_6736a201.cat
XP_CATALOG_PATH=manifests\x86_genesvc_no-public-key_12.4.56.0_x-ww_6736a201.cat
XP_PAYLOAD_PATH=x86_genesvc_no-public-key_12.4.56.0_x-ww_6736a201
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=genesvc,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\gstool\makefile.inc ===
!include $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\gstool\obj\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("Microsoft(R) Xbox(TM)")]
[assembly:System.Reflection.AssemblyCopyright("Copyright (c) Microsoft Corporation. All rights reserved.")]
[assembly:System.Reflection.AssemblyCompany("Microsoft Corporation")]
[assembly:System.Reflection.AssemblyFileVersion("12.4.56.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\genealogy\VerifyGenealogy\Base64.cpp ===
/*++

    Copyright (c) Microsoft Corporation

    Module Name:

        Base64.cpp

    Abstract:

        Base64 encode/decode functions.

--*/

#include <windows.h>
#include <assert.h>
#include "Base64.h"

BYTE g_achBase64DecodeTable[256]={
    64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,
    64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,62,64,64,64,63,
    52,53,54,55,56,57,58,59,60,61,64,64,64,64,64,64,64,0,1,2,3,4,5,6,7,8,9,
    10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,64,64,64,64,64,64,26,27,
    28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,
    64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,
    64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,
    64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,
    64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,
    64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,
    64,64,64,64,64,64,64,64,64,64,64,64,64
};

CHAR g_achBase64EncodeTable[64] = {
    'A','B','C','D','E','F','G','H','I','J','K','L','M',
    'N','O','P','Q','R','S','T','U','V','W','X','Y','Z',
    'a','b','c','d','e','f','g','h','i','j','k','l','m',
    'n','o','p','q','r','s','t','u','v','w','x','y','z',
    '0','1','2','3','4','5','6','7','8','9','+','/'
};

BOOL WINAPI
Base64Decode(
    LPCSTR  pszSrc,
    ULONG   ulSrcSize,
    LPBYTE  pDst,
    PULONG  pulDstSize
    )

/*++

Routine Description:

    Base64Decode    This method decodes a Base-64 encoded chunk of binary data.

Arguments:

    pszSrc      Points to Base64-encoded string to decode.

    ulSrcSize   Length of the string pointed to by pszSrc, not including 
                terminating null character.

    pDst        Buffer to copy the decoded binary data into.  The size of this
                buffer must be at least BASE64_DECODE_BUFFER_SIZE(ulSrcSize)

    pulDstSize  On return contains the length in bytes of the decoded buffer.

Return Value:

     0 - Decode was successful.

--*/

{
    ULONG   ulIndex;
    ULONG   ulCurOut;
    DWORD   dwGroup;
    DWORD   dwCur;
    DWORD   dwPadSeen;
    CHAR    chCur;

    dwGroup  = 0;
    dwPadSeen = 0;
    ulCurOut = 0;

    if(ulSrcSize % 4 != 0)
        return FALSE;

    for(ulIndex = 0; ulIndex < ulSrcSize; ulIndex++)
    {
        chCur = pszSrc[ulIndex];
        if(chCur == '=')
        {
            dwPadSeen++;
            dwCur = 0;
        }
        else
        {
            dwCur = g_achBase64DecodeTable[chCur];
        }
        assert( dwCur != 64 );
        
        dwGroup |= (dwCur << (6 * (ulIndex & 0x3)));

        if((ulIndex & 0x3) == 0x3)
        {
            pDst[ulCurOut++] = (CHAR)( dwGroup        & 0xff);

            if(dwPadSeen <= 1)
            {
                pDst[ulCurOut++] = (CHAR)((dwGroup >>  8) & 0xff);

                if(dwPadSeen == 0)
                    pDst[ulCurOut++] = (CHAR)((dwGroup >> 16) & 0xff);
            }

            dwGroup = 0;
        }
    }

    *pulDstSize = ulCurOut;
    assert( ulCurOut <= BASE64_DECODE_BUFFER_SIZE(ulSrcSize) );
    
    return TRUE;
}

BOOL WINAPI
Base64Encode(
    const LPBYTE    pSrc,
    ULONG           ulSrcSize,
    LPSTR           pszDst
    )

/*++

Routine Description:

    Base64Encode    This method converts a buffer of arbitrary binary data into
                    a Base-64 encoded string.

Arguments:

    pSrc        Points to the buffer of bytes to encode.

    ulSrcSize   Number of bytes in pSrc to encode.

    pszDst      Buffer to copy the encoded output into.  The length of the buffer
                must be at least BASE64_ENCODE_BUFFER_SIZE(ulSrcSize).

Return Value:

     0 - Encoding successful.

--*/

{
    DWORD   dwGroup;
    ULONG   ulCurGroup = 0, ulIndex;

    for(ulIndex = 0; ulIndex < (ulSrcSize - (ulSrcSize % 3)); ulIndex += 3)
    {
        dwGroup = (pSrc[ulIndex+2] << 16) | (pSrc[ulIndex+1] << 8) | pSrc[ulIndex];

        pszDst[ulCurGroup++] = g_achBase64EncodeTable[  dwGroup        & 0x3f ];
        pszDst[ulCurGroup++] = g_achBase64EncodeTable[ (dwGroup >> 6)  & 0x3f ];
        pszDst[ulCurGroup++] = g_achBase64EncodeTable[ (dwGroup >> 12) & 0x3f ];
        pszDst[ulCurGroup++] = g_achBase64EncodeTable[ (dwGroup >> 18) & 0x3f ];
    }

    //  Do the end special case.
    switch(ulSrcSize % 3)
    {
    case 2:
        dwGroup = (pSrc[ulIndex+1]  << 8)| pSrc[ulIndex];

        pszDst[ulCurGroup++] = g_achBase64EncodeTable[  dwGroup        & 0x3f ];
        pszDst[ulCurGroup++] = g_achBase64EncodeTable[ (dwGroup >> 6)  & 0x3f ];
        pszDst[ulCurGroup++] = g_achBase64EncodeTable[ (dwGroup >> 12) & 0x3f ];
        pszDst[ulCurGroup++] = '=';

        break;

    case 1:
        dwGroup = pSrc[ulIndex];

        pszDst[ulCurGroup++] = g_achBase64EncodeTable[  dwGroup        & 0x3f ];
        pszDst[ulCurGroup++] = g_achBase64EncodeTable[ (dwGroup >> 6)  & 0x3f ];
        pszDst[ulCurGroup++] = '=';
        pszDst[ulCurGroup++] = '=';

        break;
    }

    //  Null terminate the string.
    pszDst[ulCurGroup] = 0; 
    assert( ulCurGroup < BASE64_ENCODE_BUFFER_SIZE(ulSrcSize) );
    
    return TRUE;
}

// EOF
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\genealogy\VerifyGenealogy\VerifyGenealogy.cpp ===
#include <windows.h>
#include <wincrypt.h>
#include <cryptkeysref.h>
#include <stdio.h>
#include <stdlib.h>

#include <OleDBWrapper.h>

#include <xcrypt.h>
#include <rc4.h>
#include <sha.h>
#include "base64.h"

static const DWORD E_BAD_VALIDATION = 0xDEADBEEF;

void
XcRC4Key(
    IN PUCHAR pbKeyStruct,
    IN ULONG dwKeyLength,
    IN PUCHAR pbKey
    )
{
    rc4_key((RC4_KEYSTRUCT*)pbKeyStruct, dwKeyLength, pbKey);
}
   
void
XcRC4Crypt(
    IN PUCHAR pbKeyStruct,
    IN ULONG dwInputLength,
    IN PUCHAR pbInput
    )
{
    rc4((RC4_KEYSTRUCT*)pbKeyStruct, dwInputLength, pbInput);
}
   
void
XcHMAC(
    IN PBYTE pbKeyMaterial,
    IN ULONG cbKeyMaterial,
    IN PBYTE pbData,
    IN ULONG cbData,
    IN PBYTE pbData2,
    IN ULONG cbData2,
    OUT PBYTE HmacData // length must be A_SHA_DIGEST_LEN
    )
{
#define HMAC_K_PADSIZE              64
#define HMAC_KI_XOR_FACTOR            ((DWORD)0x36363636)
#define HMAC_KO_XOR_FACTOR            ((DWORD)0x5C5C5C5C)
    BYTE Kipad[HMAC_K_PADSIZE];
    BYTE Kopad[HMAC_K_PADSIZE];
    BYTE HMACTmp[HMAC_K_PADSIZE+A_SHA_DIGEST_LEN];
    ULONG dwBlock;
    A_SHA_CTX shaHash;

    // truncate
    if (cbKeyMaterial > HMAC_K_PADSIZE)
        cbKeyMaterial = HMAC_K_PADSIZE;

    RtlZeroMemory(Kipad, HMAC_K_PADSIZE);
    RtlCopyMemory(Kipad, pbKeyMaterial, cbKeyMaterial);

    RtlZeroMemory(Kopad, HMAC_K_PADSIZE);
    RtlCopyMemory(Kopad, pbKeyMaterial, cbKeyMaterial);

    //
    // Kipad, Kopad are padded sMacKey. Now XOR across...
    //
    for(dwBlock=0; dwBlock<HMAC_K_PADSIZE/sizeof(DWORD); dwBlock++)
    {
        ((DWORD*)Kipad)[dwBlock] ^= HMAC_KI_XOR_FACTOR;
        ((DWORD*)Kopad)[dwBlock] ^= HMAC_KO_XOR_FACTOR;
    }

    //
    // prepend Kipad to data, Hash to get H1
    //

    A_SHAInit(&shaHash);
    A_SHAUpdate(&shaHash, Kipad, HMAC_K_PADSIZE);
    if (cbData != 0)
    {
        A_SHAUpdate(&shaHash, pbData, cbData);
    }
    if (cbData2 != 0)
    {
        A_SHAUpdate(&shaHash, pbData2, cbData2);
    }

    // Finish off the hash
    A_SHAFinal(&shaHash,HMACTmp+HMAC_K_PADSIZE);

    // prepend Kopad to H1, hash to get HMAC
    RtlCopyMemory(HMACTmp, Kopad, HMAC_K_PADSIZE);

    // final hash: output value into passed-in buffer
    A_SHAInit(&shaHash);
    A_SHAUpdate(&shaHash,HMACTmp, sizeof(HMACTmp));
    A_SHAFinal(&shaHash,HmacData);
}

#define RC4_CONFOUNDER_LEN 8

//
// Header before encrypted data
//
typedef struct _RC4_SHA1_HEADER {
    UCHAR Checksum[XC_SERVICE_DIGEST_SIZE];
    UCHAR Confounder[RC4_CONFOUNDER_LEN];
} RC4_SHA1_HEADER, *PRC4_SHA1_HEADER;

static void rc4HmacEncrypt(
    IN PUCHAR confounder, // RC4_CONFOUNDER_LEN bytes
    IN PUCHAR pbKey,
    IN ULONG cbKey,
    IN PUCHAR pbInput,
    IN ULONG cbInput,
    OUT PUCHAR pbHeader // XC_SERVICE_DIGEST_SIZE + RC4_CONFOUNDER_LEN bytes
    )
{
    PRC4_SHA1_HEADER CryptHeader = (PRC4_SHA1_HEADER) pbHeader;
    BYTE LocalKey[XC_SERVICE_DIGEST_SIZE];
    BYTE Rc4KeyStruct[XC_SERVICE_RC4_KEYSTRUCT_SIZE];

    //
    // Create the header - the confounder & checksum
    //
    RtlZeroMemory( CryptHeader->Checksum, XC_SERVICE_DIGEST_SIZE );
    RtlCopyMemory( CryptHeader->Confounder, confounder, RC4_CONFOUNDER_LEN );

    //
    // Checksum everything but the checksum
    //
    XcHMAC( pbKey, cbKey,
            CryptHeader->Confounder, RC4_CONFOUNDER_LEN,
            pbInput, cbInput,
            CryptHeader->Checksum );

    //
    // HMAC the checksum into the key
    //
    XcHMAC( pbKey, cbKey,
            CryptHeader->Checksum, XC_SERVICE_DIGEST_SIZE,
            NULL, 0,
            LocalKey );

    //
    // Use the generated key as the RC4 encryption key
    //
    XcRC4Key( Rc4KeyStruct, XC_SERVICE_DIGEST_SIZE, LocalKey );

    //
    // Encrypt everything but the checksum
    //
    XcRC4Crypt( Rc4KeyStruct, RC4_CONFOUNDER_LEN, CryptHeader->Confounder );
    XcRC4Crypt( Rc4KeyStruct, cbInput, pbInput );
}


static BOOL rc4HmacDecrypt(
    IN PUCHAR pbKey,
    IN ULONG cbKey,
    IN PUCHAR pbInput,
    IN ULONG cbInput,
    IN PUCHAR pbHeader // XC_SERVICE_DIGEST_SIZE + RC4_CONFOUNDER_LEN bytes
    )
{
    PRC4_SHA1_HEADER CryptHeader = (PRC4_SHA1_HEADER) pbHeader;
    RC4_SHA1_HEADER TempHeader;
    BYTE Confounder[RC4_CONFOUNDER_LEN];
    BYTE LocalKey[XC_SERVICE_DIGEST_SIZE];
    BYTE Rc4KeyStruct[XC_SERVICE_RC4_KEYSTRUCT_SIZE];

    RtlCopyMemory( TempHeader.Confounder, CryptHeader->Confounder, RC4_CONFOUNDER_LEN );

    //
    // HMAC the checksum into the key
    //
    XcHMAC( pbKey, cbKey,
            CryptHeader->Checksum, XC_SERVICE_DIGEST_SIZE,
            NULL, 0,
            LocalKey );

    //
    // Use the generated key as the RC4 encryption key
    //
    XcRC4Key( Rc4KeyStruct, XC_SERVICE_DIGEST_SIZE, LocalKey );

    //
    // Decrypt confounder and data
    //
    XcRC4Crypt( Rc4KeyStruct, RC4_CONFOUNDER_LEN, TempHeader.Confounder );
    XcRC4Crypt( Rc4KeyStruct, cbInput, pbInput );

    //
    // Now verify the checksum.
    //
    XcHMAC( pbKey, cbKey,
            TempHeader.Confounder, RC4_CONFOUNDER_LEN,
            pbInput, cbInput,
            TempHeader.Checksum );

    //
    // Decrypt is successful only if checksum matches
    //
    return ( RtlEqualMemory(
                TempHeader.Checksum,
                CryptHeader->Checksum,
                XC_SERVICE_DIGEST_SIZE) );
}

//
// OnlineGaming RowSet decleration
//

struct SOnlineGaming
{
    CHAR szSerialNumber[13];
    CHAR szPartNumber[10];
    CHAR szOnlineKey[173];
    CHAR szOnlineKeyVersion[5];
    CHAR szMacAddress[13];
    CHAR szGameRegion[9];
    CHAR szTVRegion[9];
    CHAR szIsActive[2];
};


void Usage( void )
{
    printf( "Usage:       VerifyGenealogy [-e] [eeprom_filename]\n" );
    printf( "\n" );
    printf( "Example 1:   VerifyGenealogy -e\n" );
    printf( "Description: Verify the entire genealogy database\n" );
    printf( "\n" );
    printf( "Example 2:   VeirfyGenealogy eeprom.dat\n" );
    printf( "Description: Verify the EEPROM data file against the genealogy database\n" );
    printf( "\n" );
}

int __cdecl main( int argc, char * argv[] )
{
	HRESULT hr = S_OK;
    HRESULT hrTemp = S_OK;
    size_t uiRead = 0;
    int iRet = 0;

    //
    // entry counters
    //

    DWORD dwBadEntries = 0;
    DWORD dwEntries = 0;

    //
    // flag to hold result
    //

    BOOL bResult = TRUE;

    //
    // the provider handle
    //

    HCRYPTPROV hProv = NULL;

    //
    // the key handle
    //

    HCRYPTKEY hPrvKey = NULL;

	//
	// the database access object
	//

    CODBWSession ses;

	//
	// the stored proc cache
	//

	CWSProcCache cache;
    
    //
    // the name of the eeprom data file
    //

    LPSTR szDataFile = NULL;
    FILE* pDataFile = NULL;

    //
    // the name and location of the database
    //

    WCHAR* wszDataBaseName = L"Genealogy";
    WCHAR* wszDataBaseMachine = L"XONTEGENESQLV01";

    //
    // the full DB name
    //

	WCHAR wszFullDBName[MAX_PATH];

    //
    // data from data file
    //

    BYTE abEEPROMData[300];
    CHAR szSerialNumber[13];
    LPBYTE pbSerialNumber = NULL;
    LPBYTE pbEncryptedData = NULL;

    //
    // decryped buffers
    //

    BYTE abDecodedBase64OnlineKey[256];

    //
    // the encrypted online data
    //

    PXBOX_ENCRYPTED_ONLINE_DATA pData = NULL;

    //
    // decrypted buffer length
    //

    DWORD dwSize = 0;

    //
    // create a online gaming struct
    //

    SOnlineGaming onlineGaming;
    ZeroMemory( &onlineGaming, sizeof( SOnlineGaming ) );

    //
    // Zero out the data and the string
    //

    ZeroMemory( abEEPROMData, sizeof( abEEPROMData ) );
    ZeroMemory( szSerialNumber, sizeof( szSerialNumber ) );

    //
    // set up the row bindings
    //

	static DBBINDING bind[] = { 
        WSBIND( 1, offsetof( SOnlineGaming, szSerialNumber ), DBTYPE_STR, 13 ),
        WSBIND( 2, offsetof( SOnlineGaming, szPartNumber ), DBTYPE_STR, 10 ),
        WSBIND( 3, offsetof( SOnlineGaming, szOnlineKey ), DBTYPE_STR, 173 ),
        WSBIND( 4, offsetof( SOnlineGaming, szOnlineKeyVersion ), DBTYPE_STR, 5 ),
        WSBIND( 5, offsetof( SOnlineGaming, szMacAddress ), DBTYPE_STR, 13 ),
        WSBIND( 6, offsetof( SOnlineGaming, szGameRegion ), DBTYPE_STR, 9 ),
        WSBIND( 7, offsetof( SOnlineGaming, szTVRegion ), DBTYPE_STR, 9 ),
        WSBIND( 8, offsetof( SOnlineGaming, szIsActive ), DBTYPE_STR, 2 )
    };

    //
    // the number of rows
    //

	DWORD cRows = 1;

    //
    // make sure number of params is good
    //

    if ( 2 != argc )
    {
        Usage();
        hr = E_FAIL;
    }

    //
    // a null data file name will mean do the whole database
    //

    else if ( 2 == strlen( argv[1] )&& 'E' == toupper( argv[1][1] ) )
    {
        szDataFile = NULL;
    }

    //
    // otherwise the param was the data file name
    //

    else
    {   
        szDataFile = argv[1];
    }

    //
    // open the data file
    //

    if ( SUCCEEDED( hr ) && NULL != szDataFile )
    {
        pDataFile = fopen( szDataFile, "rb" );

        //
        // make sure the file could be opened
        //

        if ( NULL == pDataFile )
		{
			hr = HRESULT_FROM_WIN32( ERROR_FILE_NOT_FOUND );
            printf( "Could not open file\n" );
		}
    }

    //
    // read the data from the data file
    //

    if ( SUCCEEDED( hr ) && NULL != pDataFile )
    {
        uiRead = fread( abEEPROMData, 1, 300, pDataFile );

        //
        // make sure the proper number of bytes were read from the file
        //

        if ( 300 != uiRead )
        {
            hr = E_FAIL;
            printf( "Wrong number of bytes read from data file\n" );
        }
    }

    //
    // set up the pointers
    //

    if ( SUCCEEDED( hr ) && NULL != pDataFile )
    {
        pbSerialNumber = abEEPROMData + 52;
        pbEncryptedData = abEEPROMData + 256;

        //
        // make the SN bytes into a string
        //

        iRet = sprintf( szSerialNumber, "%12s", pbSerialNumber );

        if ( 12 != iRet )
        {
            hr = E_FAIL;
            printf( "Wrong number of bytes in converting to string\n" );
        }
    }
   
	//
	// create the full DB init string
	//

	if ( SUCCEEDED( hr ) )
	{
		iRet = swprintf( wszFullDBName, 
			             L"Provider=SQLOLEDB; Initial Catalog=%s; Data Source=%s; Trusted_Connection=yes", 
				         wszDataBaseName,
						 wszDataBaseMachine );

		//
		// make sure the length of the new string is correct
		//

		if ( iRet != wcslen( wszDataBaseName ) + wcslen( wszDataBaseMachine ) + 73 )
		{
			hr = E_FAIL;
            printf( "Wrong number of bytes in DB name\n" );
		}
	}

    //
    // start com
    //

    if ( SUCCEEDED( hr ) )
    {
        hr = CoInitializeEx( NULL, COINIT_MULTITHREADED );

        if ( FAILED( hr ) )
        {
            printf( "Could not init COM\n" );
        }
    }

    //
    // get the crypto context
    //

    if ( SUCCEEDED( hr ) )
    {
        bResult = CryptAcquireContext( &hProv, "XboxOnlineKeyV1", "nCipher Enhanced Cryptographic Provider", PROV_RSA_FULL, CRYPT_MACHINE_KEYSET );
        hr = FALSE == bResult ? E_FAIL : S_OK;

        if ( FAILED( hr ) )
        {
            printf( "Could not acquire context\n" );
        }
    }

    //
    // get key
    //

    if ( SUCCEEDED( hr ) )
    {
        bResult = CryptGetUserKey( hProv, AT_KEYEXCHANGE, &hPrvKey );
        hr = FALSE == bResult ? E_FAIL : S_OK;

        if ( FAILED( hr ) )
        {
            printf( "Could not get user key\n" );
        }
    }

    //
    // Open the DB
    //

    if ( SUCCEEDED( hr ) ) 
	{
		hr = ses.InitializeEx( wszFullDBName );

        if ( FAILED( hr ) )
        {
            printf( "Could not open the DB\n" );
        }
	}

    //
    // call the stored proc
    //

    if ( SUCCEEDED( hr ) )
    {
        if ( NULL != pDataFile )
        {
            hr = ses.CallProc( &cache, L"{ %T = CALL dbo.p_get_online_key;1 ( %S ) }", szSerialNumber );
        }

        else
        {
            hr = ses.CallProc( &cache, L"{ %T = CALL dbo.p_get_all_data;1 }" );
        }

        if ( FAILED( hr ) )
        {
            printf( "Could not call stored proc\n" );
        }
    }

    //
    // setup the bindings
    //

	if ( SUCCEEDED( hr ) )
    {
        hr = ses.SetBindings( bind, 8 );

        if ( FAILED( hr ) )
        {
            printf( "Could not set bindings\n" );
        }
	}

    //
    // get the returned rows
    //

	while ( SUCCEEDED( hr ) )
    {
        hr = ses.GetRows( &cRows, &onlineGaming, sizeof( SOnlineGaming ) );

        if ( FAILED( hr ) )
        {
            printf( "Could not get rows\n" );
        }

        //
        // no rows returned
        //

        if ( 0 == cRows )
        {
            break;
        }

        //
        // verify the Serial number length
        //

        if ( SUCCEEDED( hr ) )
        {
            hr = 12 == strlen( onlineGaming.szSerialNumber ) ? S_OK : E_FAIL;

            if ( FAILED( hr ) )
            {
                printf( "Serial Number length was wrong. SN: %s, Length: %u\n", 
                        onlineGaming.szSerialNumber,
                        strlen( onlineGaming.szSerialNumber ) );

                hr = E_BAD_VALIDATION;
            }
        }

        //
        // check part number length
        //

        if ( SUCCEEDED( hr ) )
        {
            hr = 9 == strlen( onlineGaming.szPartNumber ) ? S_OK : E_FAIL;

            if ( FAILED( hr ) )
            {
                printf( "Part Number length was wrong. SN: %s, PN: %s, Length: %u\n", 
                        onlineGaming.szSerialNumber,
                        onlineGaming.szPartNumber,
                        strlen( onlineGaming.szPartNumber ) );

                hr = E_BAD_VALIDATION;
            }
        }

        //
        // verify the online key length
        //

        if ( SUCCEEDED( hr ) )
        {
            hr = 172 == strlen( onlineGaming.szOnlineKey ) ? S_OK : E_FAIL;

            if ( FAILED( hr ) )
            {
                printf( "Online key length was wrong. SN: %s, OK: %s, Length: %u\n", 
                        onlineGaming.szSerialNumber,
                        onlineGaming.szOnlineKey,
                        strlen( onlineGaming.szOnlineKey ) );

                hr = E_BAD_VALIDATION;
            }
        }

        //
        // verify the online key version length
        //

        if ( SUCCEEDED( hr ) )
        {
            hr = 4 == strlen( onlineGaming.szOnlineKeyVersion ) ? S_OK : E_FAIL;

            if ( FAILED( hr ) )
            {
                printf( "Online key version length was wrong. SN: %s, OKV: %s, Length: %u\n", 
                        onlineGaming.szSerialNumber,
                        onlineGaming.szOnlineKeyVersion,
                        strlen( onlineGaming.szOnlineKeyVersion ) );

                hr = E_BAD_VALIDATION;
            }
        }

        //
        // verify the mac address length
        //

        if ( SUCCEEDED( hr ) )
        {
            hr = 12 == strlen( onlineGaming.szMacAddress ) ? S_OK : E_FAIL;

            if ( FAILED( hr ) )
            {
                printf( "MAC address length was wrong. SN: %s, MAC: %s, Length: %u\n", 
                        onlineGaming.szSerialNumber,
                        onlineGaming.szMacAddress,
                        strlen( onlineGaming.szMacAddress ) );

                hr = E_BAD_VALIDATION;
            }
        }

        //
        // verify the game region length
        //

        if ( SUCCEEDED( hr ) )
        {
            hr = 8 == strlen( onlineGaming.szGameRegion ) ? S_OK : E_FAIL;

            if ( FAILED( hr ) )
            {
                printf( "game region length was wrong. SN: %s, GR: %s, Length: %u\n", 
                        onlineGaming.szSerialNumber,
                        onlineGaming.szGameRegion,
                        strlen( onlineGaming.szGameRegion ) );

                hr = E_BAD_VALIDATION;
            }
        }

        //
        // verify the tv region length
        //

        if ( SUCCEEDED( hr ) )
        {
            hr = 8 == strlen( onlineGaming.szTVRegion ) ? S_OK : E_FAIL;

            if ( FAILED( hr ) )
            {
                printf( "TV region length was wrong. SN: %s, TVR: %s, Length: %u\n", 
                        onlineGaming.szSerialNumber,
                        onlineGaming.szTVRegion,
                        strlen( onlineGaming.szTVRegion ) );

                hr = E_BAD_VALIDATION;
            }
        }
        //
        // verify the Is Active value length
        //

        if ( SUCCEEDED( hr ) )
        {
            hr = 1 == strlen( onlineGaming.szIsActive ) ? S_OK : E_FAIL;

            if ( FAILED( hr ) )
            {
                printf( "Is active length was wrong. SN: %s, IA: %s, Length: %u\n", 
                        onlineGaming.szSerialNumber,
                        onlineGaming.szIsActive,
                        strlen( onlineGaming.szIsActive ) );

                hr = E_BAD_VALIDATION;
            }
        }

        //
        // base 64 decode the online key
        //
        
        if ( SUCCEEDED( hr ) )
        {
            bResult = Base64Decode( onlineGaming.szOnlineKey, 172, abDecodedBase64OnlineKey, &dwSize );   
            hr = TRUE == bResult && ONLINE_KEY_PKENC_SIZE == dwSize ? S_OK : E_FAIL;

            if ( FAILED( hr ) )
            {
                printf( "Could not base 64 decode key. SN: %s\n", onlineGaming.szSerialNumber );

                hr = E_BAD_VALIDATION;
            }
        }

        //
        // decrypt the online key with the private key
        //

        if ( SUCCEEDED( hr ) )
        {
            bResult = CryptDecrypt( hPrvKey, NULL, TRUE, 0, abDecodedBase64OnlineKey, &dwSize );
            hr = TRUE == bResult && sizeof( XBOX_ENCRYPTED_ONLINE_DATA ) == dwSize ? S_OK : E_FAIL;

            if ( FAILED( hr ) )
            {
                printf( "Could not decrypt key. SN: %s\n", onlineGaming.szSerialNumber );

                hr = E_BAD_VALIDATION;
            }
        }

        //
        // cast the blob to a useful pointer, and use it
        //

        if ( SUCCEEDED( hr ) )
        {
            pData = (PXBOX_ENCRYPTED_ONLINE_DATA) abDecodedBase64OnlineKey;

            //
            // see if the decrypted serial number is the same as the clear text one
            //

            hr = 0 == memcmp( pData->XboxSerialNumber, onlineGaming.szSerialNumber, 12 ) ? S_OK : E_FAIL;

            if ( FAILED( hr ) )
            {
                printf( "Verification of serial numbers failed, External SN: %.12s, Internal SN: %.12s\n", 
                        onlineGaming.szSerialNumber, 
                        pData->XboxSerialNumber );

                hr = E_BAD_VALIDATION;
            }
        }

        //
        // verify the SN passes a checksum, wether there was a success or failure
        //

        hr = 0 == ( ( ( onlineGaming.szSerialNumber[0] - '0' ) +
                      ( onlineGaming.szSerialNumber[1] - '0' ) +
                      ( onlineGaming.szSerialNumber[2] - '0' ) +
                      ( onlineGaming.szSerialNumber[3] - '0' ) +
                      ( onlineGaming.szSerialNumber[4] - '0' ) +
                      ( onlineGaming.szSerialNumber[5] - '0' ) +
                      ( onlineGaming.szSerialNumber[6] - '0' ) ) % 7 ) ? hr : E_BAD_VALIDATION;

        if ( FAILED( hr ) )
        {
            printf( "PSS verification of EXTERNAL serial number failed, SN: %s\n", onlineGaming.szSerialNumber );
        }

        //
        // verify the internal SN passes the checksum, if there was a failure
        //

        if ( FAILED( hr ) )
        {

            hrTemp = 0 == ( ( ( pData->XboxSerialNumber[0] - '0' ) +
                              ( pData->XboxSerialNumber[1] - '0' ) +
                              ( pData->XboxSerialNumber[2] - '0' ) +
                              ( pData->XboxSerialNumber[3] - '0' ) +
                              ( pData->XboxSerialNumber[4] - '0' ) +
                              ( pData->XboxSerialNumber[5] - '0' ) +
                              ( pData->XboxSerialNumber[6] - '0' ) ) % 7 ) ? S_OK : E_BAD_VALIDATION;

            if ( FAILED( hrTemp ) )
            {
                printf( "PSS verification of INTERNAL serial number failed, SN: %.12s\n", pData->XboxSerialNumber );
            }
        }

        //
        // if either verify causes and error, use that
        //

        hr = FAILED( hrTemp ) ? hrTemp : hr;
        hrTemp = S_OK;

        //
        // increase the number of entries
        //

        if ( 0 == ( ++dwEntries % 1000 ) )
        {
            printf( "%u bad entires / %u rows validated\n", dwBadEntries, dwEntries );
        }

        //
        // if we got bad validation, increment counter
        //

        if ( E_BAD_VALIDATION == hr )
        {
            dwBadEntries++;

            hr = S_OK;
        }
    }

    //
    // see if no rows were returned
    //

    if ( SUCCEEDED( hr ) && NULL == pData )
    {
        hr = E_FAIL;

        printf( "No rows returned for Serail Number %s\n", szSerialNumber );
    }

    //
    // only print out values if verifying whole DB
    //
    
    if ( NULL == pDataFile )
    {
        printf( "%u bad entires / %u rows validated\n", dwBadEntries, dwEntries );
    }

    //
    // make sure the returned Serial Number is the same as the other 2
    //

    if ( SUCCEEDED( hr ) && NULL != pDataFile )
    {
        hr = 0 == memcmp( pData->XboxSerialNumber, szSerialNumber, 12 ) ? S_OK : E_FAIL;

        if ( FAILED( hr ) )
        {
            printf( "Second verification of serial numbers failed. SN: %s\n", onlineGaming.szSerialNumber );
        }
    }

    //
    // decrypt the blob using the online key
    //

    if ( SUCCEEDED( hr ) && NULL != pDataFile )
    {
        bResult = rc4HmacDecrypt( pData->OnlineKey, 
                                  sizeof( pData->OnlineKey ), 
                                  (LPBYTE)( pbEncryptedData + sizeof( RC4_SHA1_HEADER ) ), 
                                  16, 
                                  pbEncryptedData );

        hr = TRUE == bResult ? S_OK : E_FAIL;

        if ( FAILED( hr ) )
        {
            printf( "Could not decrypt data. SN: %s\n", onlineGaming.szSerialNumber );
        }
    }

    //
    // Zero out the sensative data
    //

    ZeroMemory( abEEPROMData, sizeof( abEEPROMData ) );
    ZeroMemory( abDecodedBase64OnlineKey, sizeof( abDecodedBase64OnlineKey ) );

    //
    // print out success or failure
    //

    if ( SUCCEEDED( hr ) && NULL != pDataFile )
    {
        printf( "SUCCESS: Data File %s validated with Genealogy DB.\n", szDataFile );
    }
    else if ( NULL != pDataFile )
    {
        printf( "FAILURE: Data File %s not validated with Genealogy DB.\nError code 0x%x.\n", szDataFile, hr );
    }

    //
    // close the data file
    //

    if ( NULL != pDataFile )
    {
        fclose( pDataFile );
    }

    //
    // destory the crypto context
    //

    CryptReleaseContext( hProv, 0 );

    //
    // kill COM
    //

    CoUninitialize();

    //
    // spit back the hr to the OS
    //

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\gstool\objd\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("Microsoft(R) Xbox(TM)")]
[assembly:System.Reflection.AssemblyCopyright("Copyright (c) Microsoft Corporation. All rights reserved.")]
[assembly:System.Reflection.AssemblyCompany("Microsoft Corporation")]
[assembly:System.Reflection.AssemblyFileVersion("12.4.56.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\gstool\obj\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=msil_gstool_none_12.4.56.0_none_ada97305ba84d627
ASSEMBLY_IDENTITY_XP_KEY_FORM=msil_gstool_no-public-key_12.4.56.0_x-ww_d99f9547
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=gstool
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=msil
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=msil_gstool_no-public-key_12.4.56.0_x-ww_d99f9547
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=msil_gstool_no-public-key_12.4.56.0_x-ww_d99f9547.manifest
XP_MANIFEST_PATH=manifests\msil_gstool_no-public-key_12.4.56.0_x-ww_d99f9547.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=msil_gstool_no-public-key_12.4.56.0_x-ww_d99f9547.cat
XP_CATALOG_PATH=manifests\msil_gstool_no-public-key_12.4.56.0_x-ww_d99f9547.cat
XP_PAYLOAD_PATH=msil_gstool_no-public-key_12.4.56.0_x-ww_d99f9547
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=gstool,processorArchitecture=msil,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\genealogy\UpdateGenealogy\UpdateGenealogy.cpp ===
#include <windows.h>
#include <stdio.h>
#include <stdlib.h>

#include <OleDBWrapper.h>
#include <xmgmt.h>

#include <vector>
using namespace std;

//
// macros for error expansion
//

#define ERROR0( nCode, szStr )                     \
{										           \
	printf( szStr );                               \
	XomNtEvent( nCode, szStr );                   \
}

#define ERROR1( nCode, szStr, param1 )             \
{										           \
	printf( szStr, param1 );                       \
	XomNtEvent( nCode, szStr, param1 );           \
}

#define ERROR2( nCode, szStr, param1, param2 )     \
{										           \
	printf( szStr, param1, param2 );               \
	XomNtEvent( nCode, szStr, param1, param2 );   \
}

#define INFO0( nCode, szStr )                      \
{										           \
	printf( szStr );                               \
	XomNtEvent( nCode, szStr );                   \
}

#define INFO1( nCode, szStr, param1 )              \
{										           \
	printf( szStr, param1 );                       \
	XomNtEvent( nCode, szStr, param1 );           \
}

#define INFO2( nCode, szStr, param1, param2 )      \
{										           \
	printf( szStr, param1, param2 );               \
	XomNtEvent( nCode, szStr, param1, param2 );   \
}

//
// constants
//

static const DWORD XBSERIAL_NUMBER_LENGTH = 12;
static const DWORD PART_NUMBER_LENGTH = 9;
static const DWORD ONLINE_KEY_LENGTH = 172;
static const DWORD ONLINE_KEY_VERSION_LENGTH = 4;
static const DWORD MAC_ADDRESS_LENGTH = 12;
static const DWORD GAME_REGION_CODE_LENGTH = 8;
static const DWORD TV_REGION_CODE_LENGTH = 8;
static const DWORD IS_ACTIVE_LENGTH = 1;
static const DWORD FEED_ROW_LENGTH = 300;
static const DWORD NUMBER_DATABASE_FIELDS = 8;
static const DWORD DB_INIT_STRING_CONST_LENGTH = 73;
static const DWORD NUM_EXPECTED_ARGS = 2;
static const DWORD HEADER_COMPARE_STRING_LENGTH = 12;
static const DWORD TITLE_ROW_VALUE = 0xFFFFFFFF;

//
// the text used to id a header row
//

static const LPSTR HEADER_COMPARE_STRING = "SerialNumber";

//
// the parse string
//

static const LPSTR PARSE_STRING = "%12s %9s %172s %4s %12s %8s %8s %1s";

//
// the db init string
//

static const WCHAR* DB_INIT_STRING = 
    L"Provider=SQLOLEDB; Initial Catalog=%s; Data Source=%s; Trusted_Connection=yes";

//
// the update genealogy sproc call
//

static const WCHAR* UPDATE_GENEALOGY_SPROC_CALL_STRING = 
    L"{ %T = CALL dbo.p_update_genealogy;1 ( %S, %S, %S, %S, %S, %S, %S, %S ) }";

//
// the get partumber sproc call
//

static const WCHAR* GET_PARTNUMBERS_SPROC_CALL_STRING = 
    L"{ %T = CALL dbo.p_get_partnumbers;1 }";

//
// the definition of the PartNumber row layout
//

struct SPartNumber
{
    CHAR szPartNumber[PART_NUMBER_LENGTH + 1];
};

int __cdecl main( int argc, char* argv[] )
{
	HRESULT hr = S_OK;
	int iRet = 0;
	size_t nBytes = 0;

	CHAR tChar = '\0';

	//
	// the number of entries in the database feed
	//

	DWORD dwCount = 0;

	//
	// the number of entries with bad data
	//

	DWORD dwBadCount = 0;

	//
	// the number of bytes read so far
	//

	DWORD dwRead = 0;

	//
	// the database access object
	//

    CODBWSession ses;

	//
	// the stored proc cache
	//

    CWSProcCache cache;
    CWSProcCache partCache;

	//
	// pointers to settings object
	//

	CXomSetting* pSettingPath = NULL;
	CXomSetting* pSettingFile = NULL;
	CXomSetting* pSettingBadDataPath = NULL;
	CXomSetting* pSettingBadDataFile = NULL;
	CXomSetting* pSettingDB = NULL;
	CXomSetting* pSettingMachine = NULL;

	//
	// the input and output file
	// 

	FILE* pInputFile = NULL;
	FILE* pOutputFile = NULL;

	//
	// place to hold the input file name
	//

	CHAR szInputFileName[MAX_PATH];

	//
	// place to hold the output file name
	//

	CHAR szOutputFileName[MAX_PATH];

	//
	// place to hold the line by line data
	//

	CHAR szRowData[FEED_ROW_LENGTH + 1];

	//
	// the data in the DB feed
	//

	CHAR szSerialNumber[XBSERIAL_NUMBER_LENGTH + 1];
	CHAR szPartNumber[PART_NUMBER_LENGTH + 1];
	CHAR szOnlineKey[ONLINE_KEY_LENGTH + 1];
	CHAR szOnlineKeyVersion[ONLINE_KEY_VERSION_LENGTH + 1];
	CHAR szMacAddress[MAC_ADDRESS_LENGTH + 1];
	CHAR szGameRegionCode[GAME_REGION_CODE_LENGTH + 1];
	CHAR szTvRegionCode[TV_REGION_CODE_LENGTH + 1];
	CHAR szIsActive[IS_ACTIVE_LENGTH + 1];

	//
	// the wide char version of the DB name and DB machine name
	//

	WCHAR wszDBName[MAX_PATH];
	WCHAR wszFullDBName[MAX_PATH];
	WCHAR wszMachineName[MAX_PATH];

    //
    // the vector to hold the part numbers
    //

    vector<LPCSTR> vPartNumbers;

    //
    // temp pointer used for vector insertion
    //

    LPSTR szTemp = NULL;

    //
    // the partNumber record
    //

    SPartNumber partNumber;

    //
    // set up the table bindings
    //

	static DBBINDING bind[] = { 
        WSBIND( 1, offsetof( SPartNumber, szPartNumber ), DBTYPE_STR, PART_NUMBER_LENGTH + 1 )
    };

    //
    // the number of rows
    //

	DWORD cRows = 1;

    //
    // a counter
    //

    DWORD i = 0;

    //
    // zero out the records
    //

    ZeroMemory( &partNumber, sizeof( SPartNumber ) );

	//
	// zero out the strings
	//

	ZeroMemory( szInputFileName, MAX_PATH );
	ZeroMemory( wszDBName, MAX_PATH * sizeof( WCHAR ) );
	ZeroMemory( wszMachineName, MAX_PATH * sizeof( WCHAR ) );

	//
	// make sure the params were correct
	//

	if ( NUM_EXPECTED_ARGS != argc )
	{
		printf( "\nIncorrect number of arguments\n\n" );
		printf( "Usage:   UpdateGenealogy <INI_FILE_NAME>\n" );
		printf( "Example: UpdateGenealogy ..\\..\\UpdateGenealogy.ini\n" );

		hr = E_INVALIDARG;
	}

	//
	// Initialize mgmt framework
	// 
	
	if ( SUCCEEDED( hr ) )
	{
		hr = g_xomcentral.Init( "UpdateGenealogy", argv[1] );

		if ( FAILED( hr ) )
		{
			ERROR1( , "Init Failed 0x%x", hr );
		}
	}

	//
	// State that app has started
	//

	if ( SUCCEEDED( hr ) )
	{
		INFO1( , 
               "Beginning update of Genealogy Database using %s\n", 
               argv[1] );
	}
	
	//
	// Get the database path
	//

	if ( SUCCEEDED( hr ) )
	{
		hr = g_xomcentral.GetSetting( "Genealogy.Path", &pSettingPath );

		if ( FAILED( hr ) )
		{
			ERROR1( , 
                    "Get Settings for Genealogy.Path Failed 0x%x\n", 
                    hr );
		}

	}

	//
	// get the file name
	//

	if ( SUCCEEDED( hr ) )
	{
		hr = g_xomcentral.GetSetting( "Genealogy.File", &pSettingFile );

		if ( FAILED( hr ) )
		{
			ERROR1( , 
                    "Get Settings for Genealogy.File 0x%x\n", 
                    hr );
		}

	}

	//
	// get the output path
	//

	if ( SUCCEEDED( hr ) )
	{
		hr = g_xomcentral.GetSetting( "Genealogy.BadPath", &pSettingBadDataPath );

		if ( FAILED( hr ) )
		{
			ERROR1( , 
                    "Get Settings for Genealogy.BadPath 0x%x\n", 
                    hr );
		}
	}

	//
	// get the output file name
	//

	if ( SUCCEEDED( hr ) )
	{
		hr = g_xomcentral.GetSetting( "Genealogy.BadFile", &pSettingBadDataFile );

		if ( FAILED( hr ) )
		{
			ERROR1( , 
                    "Get Settings for Genealogy.BadFile 0x%x\n", 
                    hr );
		}
	}

	//
	// get the db name
	//

	if ( SUCCEEDED( hr ) )
	{
		hr = g_xomcentral.GetSetting( "Genealogy.DB", &pSettingDB );

		if ( FAILED( hr ) )
		{
			ERROR1( , 
                    "Get Settings for Genealogy.DB 0x%x\n", 
                    hr );
		}

	}

	//
	// get the machine name
	//

	if ( SUCCEEDED( hr ) )
	{
		hr = g_xomcentral.GetSetting( "Genealogy.Machine", &pSettingMachine );

		if ( FAILED( hr ) )
		{
			ERROR1( , 
                    "Get Settings for Genealogy.Machine 0x%x\n", 
                    hr );
		}

	}

	//
	// convert the ansi db string to wchar
	//

	if ( SUCCEEDED( hr ) )
	{
		iRet = swprintf( wszDBName, L"%S", pSettingDB->GetStr() );

		//
		// make sure the strign was the correct length
		//

		if ( strlen( pSettingDB->GetStr() ) != iRet )
		{
			hr = E_FAIL;
			ERROR1( , 
                    "Conversion of DB name failed 0x%x\n", 
                    hr );
		}
	}

	//
	// convert the ansi machine string to wchar
	//

	if ( SUCCEEDED( hr ) )
	{
		iRet = swprintf( wszMachineName, L"%S", pSettingMachine->GetStr() );

		//
		// make sure the string was the correct length
		//

		if ( strlen( pSettingMachine->GetStr() ) != iRet )
		{
			hr = E_FAIL;
			ERROR1( , 
                    "Conversion of machine name failed 0x%x\n", 
                    hr );
		}
	}

	//
	// create the full DB init string
	//

	if ( SUCCEEDED( hr ) )
	{
		iRet = swprintf( wszFullDBName, 
			             DB_INIT_STRING, 
				         wszDBName,
						 wszMachineName );

		//
		// make sure the length of the new string is correct
		//

		if ( iRet != wcslen( wszDBName ) + wcslen( wszMachineName ) + DB_INIT_STRING_CONST_LENGTH )
		{
			hr = E_FAIL;
			ERROR1( , 
                    "Creation of full DB string failed 0x%x\n", 
                    hr );
		}
	}

	//
	// open the DB
	//

	if ( SUCCEEDED( hr ) ) 
	{
		hr = ses.InitializeEx( wszFullDBName );

		if ( FAILED( hr ) )
		{
			ERROR1( , 
                    "Opening of DB failed 0x%x\n", 
                    hr );
		}
		else
		{
			INFO0( , "Connected to database\n" );
		}
	}

	//
	// append the path
	//

	if ( SUCCEEDED( hr ) )
	{
		iRet = sprintf( szInputFileName, "%s\\%s", pSettingPath->GetStr(), pSettingFile->GetStr() );

		//
		// make sure the string print succeeded
		//

		if ( 0 == iRet )
		{
			hr = E_FAIL;
			ERROR1( , 
                    "Constructing file name failed 0x%x\n", 
                    hr );
		}
	}

	//
	// append the bad path
	//

	if ( SUCCEEDED( hr ) )
	{
		iRet = sprintf( szOutputFileName, "%s\\%s", pSettingBadDataPath->GetStr(), pSettingBadDataFile->GetStr() );

		//
		// make sure the string print succeeded
		//

		if ( 0 == iRet )
		{
			hr = E_FAIL;
			ERROR1( , 
                    "Constructing bad data file name failed 0x%x\n", 
                    hr );
		}
	}

	//
	// open the file
	//

	if ( SUCCEEDED( hr ) )
	{
		pInputFile = fopen( szInputFileName, "rb" );
		
		//
		// make sure the file could be opened
		//

		if ( NULL == pInputFile )
		{
			hr = HRESULT_FROM_WIN32( ERROR_FILE_NOT_FOUND );
			ERROR1( , 
                    "File Open failed 0x%x\n", 
                    hr );
		}
	}

	//
	// open the bad data file
	//

	if ( SUCCEEDED( hr ) ) 
	{
		pOutputFile = fopen( szOutputFileName, "wb" );

		//
		// make sure the file could be opened
		//

		if ( NULL == pOutputFile )
		{
			hr = HRESULT_FROM_WIN32( ERROR_FILE_NOT_FOUND );
			ERROR1( , 
                    "Bad data file open failed 0x%x\n", 
                    hr );
		}
	}

    //
    // get the stored part numbers by calling the stored proc
    //

    if ( SUCCEEDED( hr ) )
    {
        hr = ses.CallProc( &partCache, GET_PARTNUMBERS_SPROC_CALL_STRING );
        
        if ( FAILED( hr ) )
        {
            ERROR1( , 
                    "Could not call stored proc to get part numbers 0x%x\n", 
                    hr );
        }
    }

    //
    // setup the bindings
    //

	if ( SUCCEEDED( hr ) )
    {
        hr = ses.SetBindings( bind, 1 );

        if ( FAILED( hr ) )
        {
            ERROR1( , 
                    "Could not set up bindings 0x%x\n", 
                    hr );
        }
	}

    //
    // get the returned part numbers
    //

    while ( SUCCEEDED( hr ) )
    {
        //
        // get the rows 1 at a time
        //

        hr = ses.GetRows( &cRows, &partNumber, sizeof( SPartNumber ) );
        
        if ( FAILED( hr ) )
        {
            ERROR1( , 
                    "Could not get part number from DB 0x%x\n", 
                    hr );
            break;
        }

        //
        // see if we are done running through rows
        //

        if ( 0 == cRows )
        {
            break;
        }

        //
        // allocate somes space for the string
        //

        if ( SUCCEEDED( hr ) )
        {
            szTemp = new CHAR[PART_NUMBER_LENGTH + 1];
            hr = NULL == szTemp ? E_OUTOFMEMORY : S_OK;
            
            if ( FAILED( hr ) )
            {
                ERROR1( , 
                        "Could not allocate memory 0x%x\n", 
                        hr );
            }
        }

        //
        // copy over the string and insert it into the vector
        //

        if ( SUCCEEDED( hr ) )
        {
            strcpy( szTemp, partNumber.szPartNumber );
            vPartNumbers.push_back( szTemp );
        }
    }

	//
	// read data out of the file, 1 line at a time, 1 char at a time
	// this is definately slower than fscanfing all the strings at once,
	// but it allows for better error detection of ITG's data feeds
	//

	while ( SUCCEEDED( hr ) )
	{
		//
		// reset the number of bytes read
		//

		dwRead = 0;

		//
		// zero out the string buffer
		//

		ZeroMemory( szRowData, FEED_ROW_LENGTH + 1 );

		//
		// read from the file, byte by byte
		//

		do
		{
			nBytes = fread( szRowData + dwRead, sizeof( CHAR ), 1, pInputFile );
			dwRead++;

            //
            // if we've read enough data, check if this is a header row
            //

            if ( 0 != nBytes && 
                 HEADER_COMPARE_STRING_LENGTH == dwRead && 
                 0 == strcmp( szRowData, HEADER_COMPARE_STRING ) )
            {
                //
                // read until the \n is found or EOF is found
                //

                do
                {
                    nBytes = fread( szRowData, sizeof( CHAR ), 1, pInputFile );
                }
                while ( 0 != nBytes && '\n' != *szRowData );

                //
                // set the number of read bytes to TITLE_ROW_VALUE to signify title row
                //

                dwRead = TITLE_ROW_VALUE;

                break;
            }

		} 
		while ( 0 != nBytes && '\n' != szRowData[dwRead-1] && dwRead < FEED_ROW_LENGTH );

		//
		// bail if end was found. 
		//

		if ( 0 == nBytes )
		{
			break;
		}

		//
		// if we've made it here, then a line was consumed (even if it was bogus)
		//

		++dwCount;

        //
        // see if this was a title row
        //

        if ( TITLE_ROW_VALUE == dwRead )
        {
            //
            // drop a white ball in this case
            //

	        INFO1( XEVENT_TOOLS_COMM_48, 
                   "Title row encountered on line %u\n", 
                   dwCount ); 

            continue;
        }

		//
		// see if we encountered end of line to early 
		//

		if ( FEED_ROW_LENGTH < dwRead )
		{
			fprintf( pOutputFile, "%s\n", szRowData );

			dwBadCount++;
			ERROR1( , 
                    "Encountered EOL to early on line %u\n", 
                    dwCount ); 
			continue;
		}

		//
		// or too late
		//

		if ( FEED_ROW_LENGTH >= dwRead && '\n' != szRowData[dwRead-1] )
		{
			fprintf( pOutputFile, "%s\n", szRowData );

			dwBadCount++;
			ERROR1( , 
                    "Line %u is wrong length. Must stop parsing\n", 
                    dwCount );

			//
			// if the maximum number of chars was encountered before a return,
			// process the data until a return is found
			//

			if ( FEED_ROW_LENGTH == dwRead )
			{
				//
				// read 1 byte at a time to the end of line
				//

				do
				{
					nBytes = fread( szRowData, sizeof( CHAR ), 1, pInputFile );
				}
				while ( 0 != nBytes && '\n' != *szRowData );
			}

			//
			// goto next line in file
			//

			continue;
		}

		//
		// parse the strings out of the master string
		//

		iRet = sscanf( szRowData, 
					   PARSE_STRING, 
					   szSerialNumber, 
					   szPartNumber,
					   szOnlineKey,
					   szOnlineKeyVersion,
					   szMacAddress,
					   szGameRegionCode,
					   szTvRegionCode,
					   szIsActive );
		
		//
		// make sure the string parsed correctly
		//

		if ( EOF == iRet )
		{
			dwCount--;
			break;
		}

		//
		// make sure the EXACT number of bytes where read
		//

		if ( NUMBER_DATABASE_FIELDS != iRet )
		{
			fprintf( pOutputFile, "%s\n", szRowData );

			dwBadCount++;
			ERROR2( , 
                    "Number of database fields was wrong (%u) on line %u\n", 
                    iRet, 
                    dwCount );
			
			continue;
		}

		//
		// make sure we did not get bogus data
		//

		if ( 0 == iRet )
		{
			fprintf( pOutputFile, "%s\n", szRowData );

			dwBadCount++;
			ERROR1( , 
                    "Input file is malformed on line %u\n", 
                    dwCount );
			
			continue;
		}

		//
		// validate the strings
		//

		if ( XBSERIAL_NUMBER_LENGTH != strlen( szSerialNumber ) ||
			 PART_NUMBER_LENGTH != strlen( szPartNumber ) || 
			 ONLINE_KEY_LENGTH != strlen( szOnlineKey ) ||
			 ONLINE_KEY_VERSION_LENGTH != strlen( szOnlineKeyVersion ) ||
			 MAC_ADDRESS_LENGTH != strlen( szMacAddress ) ||
			 GAME_REGION_CODE_LENGTH != strlen( szGameRegionCode ) ||
			 TV_REGION_CODE_LENGTH != strlen( szTvRegionCode ) ||
			 IS_ACTIVE_LENGTH != strlen( szIsActive ) ||
             ( 0 != _stricmp( szIsActive, "0" ) &&
               0 != _stricmp( szIsActive, "1" ) ) )
		{
			fprintf( pOutputFile, "%s\n", szRowData );

			dwBadCount++;
			ERROR1( , 
                    "Validating data failed on line %u\n", 
                    dwCount );

			continue;
		}

        //
        // make sure this entry belongs in this DB
        //

        for ( i = 0; i < vPartNumbers.size() && SUCCEEDED( hr ); i++ )
        {
            //
            // check the string in the part number table against the part number read in
            //

            if ( 0 == strcmp( vPartNumbers[i], szPartNumber ) )   
            {
                //
		        // update the DB
		        //

			    hr = ses.CallProc( &cache,
							       UPDATE_GENEALOGY_SPROC_CALL_STRING,
							       szSerialNumber, 
							       szPartNumber,
							       szOnlineKey,
							       szOnlineKeyVersion,
							       szMacAddress,
							       szGameRegionCode,
							       szTvRegionCode,
							       szIsActive );


			    if ( FAILED( hr ) )
                {
                    ERROR1( , 
                            "Calling stored proc failed 0x%x\n", 
                            hr );
                }

                break;
            }
		}

        //
        // see if we went through the whole list
        //

        if ( SUCCEEDED( hr ) && i >= vPartNumbers.size() )
        {
            //
            // if we did, then we discarded this entry because it was not in the part table
            //

            dwBadCount++;
        }

		//
		// increment the count
		//

		if ( SUCCEEDED( hr ) )
		{
			if ( 0 == ( dwCount % 1000 ) )
			{
				printf( "processed %u records\n", dwCount );
			}
		}
	}

    //
    // destory all the strings within the vector
    //

    for ( i = 0; i < vPartNumbers.size(); i++ )
    {
        delete [] vPartNumbers[i];
    }

	//
	// close the file
	//

	if ( NULL != pInputFile )
	{
		fclose( pInputFile );
	}

	//
	// close the bad data file
	//

	if ( NULL != pOutputFile )
	{
		fclose( pOutputFile );
	}

	//
	// output a success
	//

	if ( SUCCEEDED( hr ) )
	{
		INFO2( XEVENT_GENEALOGY_INFO_UPDATE_COMPLETE_2, 
               "Update of Genealogy completed. %u entries processed, %u entries discarded\n", 
               dwCount, 
               dwBadCount );
	}

	//
	// close the mgmt framework
	//

	g_xomcentral.Term();

	//
	// and toss back the result as an int
	//

	return (int) hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\gstool\objd\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=msil_gstool_none_12.4.56.0_none_ada97305ba84d627
ASSEMBLY_IDENTITY_XP_KEY_FORM=msil_gstool_no-public-key_12.4.56.0_x-ww_d99f9547
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=gstool
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=msil
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=msil_gstool_no-public-key_12.4.56.0_x-ww_d99f9547
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=msil_gstool_no-public-key_12.4.56.0_x-ww_d99f9547.manifest
XP_MANIFEST_PATH=manifests\msil_gstool_no-public-key_12.4.56.0_x-ww_d99f9547.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=msil_gstool_no-public-key_12.4.56.0_x-ww_d99f9547.cat
XP_CATALOG_PATH=manifests\msil_gstool_no-public-key_12.4.56.0_x-ww_d99f9547.cat
XP_PAYLOAD_PATH=msil_gstool_no-public-key_12.4.56.0_x-ww_d99f9547
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=gstool,processorArchitecture=msil,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\iisrunner\console\exe\obj\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("DEPOT")]
[assembly:System.Reflection.AssemblyCopyright("")]
[assembly:System.Reflection.AssemblyCompany("")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\iisrunner\console\exe\objd\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("DEPOT")]
[assembly:System.Reflection.AssemblyCopyright("")]
[assembly:System.Reflection.AssemblyCompany("")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\gstool\test\Stress.cs ===
#define SKIP_XBANC_TITLE_CACHE_BUG //xb360cs bug 39557 - It's not feasible to flush this setting atm, so ReadSettings will return the stale value.  We'll skip those checks for now.

using ServerTestFramework;
using ServerTestFramework.Utilities;
using ServerTestFramework.Utilities.AsyncUtils;
using ServerTestFramework.Database;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.Achievement;

using System.Collections.Generic;
using System.Net;
using System;

using xonline.common.config;

namespace GSToolTests
{
    [TestGroup, TestTag("TakesALongTime"), TestFrequency("Regression"), TestCasePriority(3), EnvRequirement("Manual")]
    public class Stress: TestNode
    {
        public override void PreRun()
        {
            Util.Verbose=false;
        }

        public override void PostRun()
        {
            Util.Verbose=true;
        }

        //Gives a set of users all the achievements in the stress title and the 3 functional titles
        private static void GiveUsersAchievements(ulong basePuid, uint count)
        {
            uint servers=(uint)Global.XEnv.GetServerListByInterface(VirtualInterface.xstatsfd).Length;
            ParallelRunner.Run(GiveUsersAchievements_Thread, count, servers*4, basePuid, 0);
        }

        private static void GiveUsersAchievements_Thread(uint num, object obj)
        {
            ulong puid=(ulong)obj+num;

            for (int tryNum=0; tryNum<3; ++tryNum)
            {
                try
                {
                    //25 stress achievements
                    AchievementWD []stressAchList=new AchievementWD[25];
                    for (int i=1; i<=25; ++i)
                    {
                        stressAchList[i-1]=new AchievementWD((uint)i, (uint)i);
                    }
                    Util.SyncTitleAchievements(Util.TITLEF, puid, stressAchList, false);

                    //3 functional titles with 4 achievements each
                    Util.SyncTitleAchievements(Util.TITLE1, puid, new AchievementWD[]{new AchievementWD(1, 1), new AchievementWD(2, 2), new AchievementWD(3, 3), new AchievementWD(4, 4)}, false);
                    Util.SyncTitleAchievements(Util.TITLE2, puid, new AchievementWD[]{new AchievementWD(1, 1), new AchievementWD(2, 2), new AchievementWD(3, 3), new AchievementWD(4, 4)}, false);
                    Util.SyncTitleAchievements(Util.TITLE3, puid, new AchievementWD[]{new AchievementWD(1, 1), new AchievementWD(2, 2), new AchievementWD(3, 3), new AchievementWD(4, 4)}, false);
                    break;
                }
                catch (System.Exception e)
                {
                    Global.RO.Warn("Sync failed"+(tryNum<2?", will retry":"")+": "+e.Message);
                    if (tryNum==2)
                    {
                        throw;
                    }
                }
            }

            if (num%1000==999)
            {
                Global.RO.Debug("Sync'd "+(num+1)+" users...");
            }
        }

        //Verifies users are reset
        private static void VerifyUsersAreReset(ulong basePuid, uint count)
        {
            uint servers=(uint)Global.XEnv.GetServerListByInterface(VirtualInterface.xstatsfd).Length;
            ParallelRunner.Run(VerifyUsersAreReset_Thread, count, servers*4, basePuid, 0);
        }

        private static void VerifyUsersAreReset_Thread(uint num, object obj)
        {
            ulong puid=(ulong)obj+num;

            for (int tryNum=0; tryNum<3; ++tryNum)
            {
                try
                {
                    ValueCheck.Test("Guilty User's gamer type cheater bit", true, Util.IsGamerTypeCheater(Util.GetUserGamerType(puid)));
                    ValueCheck.Test("Guilty User's gamerscore", 0, Util.GetUserGamerscore(puid));
                    ValueCheck.Test("Guilty User's achievement count", 0, Util.GetUserAchievmentCount(puid));
                    break;
                }
                catch (UnexpectedTestResultException)
                {
                    throw;
                }
                catch (System.Exception e)
                {
                    Global.RO.Warn("Enum failed"+(tryNum<2?", will retry":"")+": "+e.Message);
                    if (tryNum==2)
                    {
                        throw;
                    }
                }
            }

            if (num%1000==999)
            {
                Global.RO.Debug("Enum'd "+(num+1)+" users...");
            }
        }

        //Verifies users are unreset
        private static void VerifyUsersAreUnreset(ulong basePuid, uint count)
        {
            uint servers=(uint)Global.XEnv.GetServerListByInterface(VirtualInterface.xstatsfd).Length;
            ParallelRunner.Run(VerifyUsersAreUnreset_Thread, count, servers*4, basePuid, 0);
        }

        private static void VerifyUsersAreUnreset_Thread(uint num, object obj)
        {
            ulong puid=(ulong)obj+num;

            for (int tryNum=0; tryNum<3; ++tryNum)
            {
                try
                {
                    ValueCheck.Test("Unreset User's gamer type cheater bit", false, Util.IsGamerTypeCheater(Util.GetUserGamerType(puid)));
                    ValueCheck.Test("Unreset User's gamerscore", 3658, Util.GetUserGamerscore(puid));
                    ValueCheck.Test("Unreset User's achievement count", 37, Util.GetUserAchievmentCount(puid));
                    break;
                }
                catch (UnexpectedTestResultException)
                {
                    throw;
                }
                catch (System.Exception e)
                {
                    Global.RO.Warn("Enum failed"+(tryNum<2?", will retry":"")+": "+e.Message);
                    if (tryNum==2)
                    {
                        throw;
                    }
                }
            }

            if (num%1000==999)
            {
                Global.RO.Debug("Enum'd "+(num+1)+" users...");
            }
        }

        //Verifies users are recalc'd
        private static void VerifyUsersAreRecalced(ulong basePuid, uint count)
        {
            uint servers=(uint)Global.XEnv.GetServerListByInterface(VirtualInterface.xstatsfd).Length;
            ParallelRunner.Run(VerifyUsersAreRecalced_Thread, count, servers*4, basePuid, 0);
        }

        private static void VerifyUsersAreRecalced_Thread(uint num, object obj)
        {
            ulong puid=(ulong)obj+num;

            for (int tryNum=0; tryNum<3; ++tryNum)
            {
                try
                {
                    ValueCheck.Test("Recalc'd User's gamerscore", 333+(325-4), Util.GetUserGamerscore(puid));
                    ValueCheck.Test("Recalc'd User's achievement count", 9+(25-1), Util.GetUserAchievmentCount(puid));
                    break;
                }
                catch (UnexpectedTestResultException)
                {
                    throw;
                }
                catch (System.Exception e)
                {
                    Global.RO.Warn("Enum failed"+(tryNum<2?", will retry":"")+": "+e.Message);
                    if (tryNum==2)
                    {
                        throw;
                    }
                }
            }

            if (num%1000==999)
            {
                Global.RO.Debug("Enum'd "+(num+1)+" users...");
            }
        }

        //Verifies users have the nxe watermark
        private static void VerifyUsersHaveNXEMark(ulong basePuid, uint count)
        {
            uint servers=(uint)Global.XEnv.GetServerListByInterface(VirtualInterface.xstatsfd).Length;
            ParallelRunner.Run(VerifyUsersHaveNXEMark_Thread, count, servers*4, basePuid, 0);
        }

        private static void VerifyUsersHaveNXEMark_Thread(uint num, object obj)
        {
            ulong puid=(ulong)obj+num;

            for (int tryNum=0; tryNum<3; ++tryNum)
            {
                try
                {
                    ValueCheck.Test("User's gamertype bits", 0x4, Util.GetUserGamerType(puid));
                    break;
                }
                catch (UnexpectedTestResultException)
                {
                    throw;
                }
                catch (System.Exception e)
                {
                    Global.RO.Warn("Reading gamer type failed"+(tryNum<2?", will retry":"")+": "+e.Message);
                    if (tryNum==2)
                    {
                        throw;
                    }
                }
            }

            if (num%1000==999)
            {
                Global.RO.Debug("checked "+(num+1)+" users...");
            }
        }

        // --

        [TestCase, Description("Resets a large number of users and verifies they were all reset")]
        [CompoundCase("100", 100)]
        [CompoundCase("10000", 10000)]
        public class Reset: TestNode
        {
            public override void Run()
            {
                int count=(int)MyValues[0];
                string fileName="temp\\gstooltest\\"+Parent.Name+"_"+Name+".txt";

                //create users and dump them into a file
                Global.RO.Debug("Creating users...");
                BulkUserSet userSet;
                UodbWS.CreateBulkUsers("GS", (uint)count, out userSet);

                using (System.IO.StreamWriter file=System.IO.File.CreateText(fileName))
                {
                    for (uint i=0; i<userSet.Count; ++i)
                    {
                        ulong puid=userSet.Base+i;
                        file.WriteLine("0x"+puid.ToString("X"));
                    }
                }

                UserEditor innocentUser=UserEditor.CreateNew();

                //add achievements
                Global.RO.Debug("Adding achievements...");
                GiveUsersAchievements(userSet.Base, userSet.Count);
                GiveUsersAchievements(innocentUser.Puid, 1);

                //run tool
                string output=Util.RunGSTool("-reset -verbose "+fileName, 10800);
                Util.VerifyOutputHasNoErrors(output);

                //verify all users
                Global.RO.Debug("Checking all users...");

                VerifyUsersAreReset(userSet.Base, userSet.Count);

                ValueCheck.Test("Innocent User's gamer type cheater bit", false, Util.IsGamerTypeCheater(Util.GetUserGamerType(innocentUser.Puid)));
                ValueCheck.Test("Innocent User's gamerscore", 3658, Util.GetUserGamerscore(innocentUser.Puid));
                ValueCheck.Test("Innocent User's achievement count", 37, Util.GetUserAchievmentCount(innocentUser.Puid));

                return TEST_RESULTS.PASSED;
            }
        }

        [TestCase, Description("Resets a large number of users and then unresets them")]
        [CompoundCase("100", 100)]
        [CompoundCase("10000", 10000)]
        public class Unreset: TestNode
        {
            public override void Run()
            {
                int count=(int)MyValues[0];
                string fileName="temp\\gstooltest\\"+Parent.Name+"_"+Name+".txt";

                //create users and dump them into a file
                Global.RO.Debug("Creating users...");
                BulkUserSet userSet;
                UodbWS.CreateBulkUsers("GS", (uint)count, out userSet);

                using (System.IO.StreamWriter file=System.IO.File.CreateText(fileName))
                {
                    for (uint i=0; i<userSet.Count; ++i)
                    {
                        ulong puid=userSet.Base+i;
                        file.WriteLine("0x"+puid.ToString("X"));
                    }
                }

                //add achievements
                Global.RO.Debug("Adding achievements...");
                GiveUsersAchievements(userSet.Base, userSet.Count);

                //run tool
                string output=Util.RunGSTool("-reset -verbose "+fileName, 10800);
                Util.VerifyOutputHasNoErrors(output);

                output=Util.RunGSTool("-unreset -verbose "+fileName, 10800);
                Util.VerifyOutputHasNoErrors(output);

                //verify all users
                Global.RO.Debug("Checking all users...");

                VerifyUsersAreUnreset(userSet.Base, userSet.Count);

                return TEST_RESULTS.PASSED;
            }
        }

        [TestCase, Description("Runs validate on a large set up users, where 99% are valid.")]
        [CompoundCase("100", 100)]
        [CompoundCase("10000", 10000)]
        public class Validate: TestNode
        {
            public override void Run()
            {
                int count=(int)MyValues[0];
                string fileName="temp\\gstooltest\\"+Parent.Name+"_"+Name+".txt";
                string fileNameOut="temp\\gstooltest\\"+Parent.Name+"_"+Name+"Out.txt";

                //create users and dump them into a file
                Global.RO.Debug("Creating users...");
                BulkUserSet userSet;
                UodbWS.CreateBulkUsers("GS", (uint)count, out userSet);

                int validCount=0;
                int invalidCount=0;
                using (System.IO.StreamWriter file=System.IO.File.CreateText(fileName))
                {
                    for (uint i=0; i<userSet.Count; ++i)
                    {
                        ulong puid=userSet.Base+i;
                        if (i%100==50) //1% are not actual users
                        {
                            ++invalidCount;
                            file.WriteLine("0x"+(puid|0x0000f00000000000).ToString("X"));
                        }
                        else //99% are valid
                        {
                            ++validCount;
                            file.WriteLine("0x"+puid.ToString("X"));
                        }
                    }
                }

                ActionValidate.SyncToXCache();

                //run tool
                string output=Util.RunGSTool("-validate -output "+fileNameOut+" "+fileName, 10800);
                Util.VerifyOutputHasNoErrors(output);

                //check each user in the output
                Global.RO.Debug("Verifying output...");
                {
                    ValueCheck.Test("Count of valid users in tool output", validCount, ActionValidate.GetValidUserCountFromOutput(output));

                    for (uint i=0; i<userSet.Count; ++i)
                    {
                        ulong puid=userSet.Base+i;
                        for (int tryNum=0; tryNum<3; ++tryNum)
                        {
                            try
                            {
                                if (i%100==50) //1% are not actual users
                                {
                                    ValueCheck.Test("User is in output file", false, ActionValidate.IsUserInOutputFile(fileNameOut, puid));
                                }
                                else //99% are valid
                                {
                                    ValueCheck.Test("User is in output file", true, ActionValidate.IsUserInOutputFile(fileNameOut, puid));
                                }
                                break;
                            }
                            catch (UnexpectedTestResultException)
                            {
                                throw;
                            }
                            catch (System.Exception e)
                            {
                                Global.RO.Warn("Exception while verifying"+(tryNum<2?", will retry":"")+": "+e.Message);
                                if (tryNum==2)
                                {
                                    throw;
                                }
                            }
                        }
                    }

                    ValueCheck.Test("Count of valid users in output file", validCount, ActionValidate.GetValidUserCountFromFile(fileNameOut));
                }

                return TEST_RESULTS.PASSED;
            }
        }

        [TestCase, Description("Recalcs a large number of users")]
        [CompoundCase("100", 100)]
        [CompoundCase("10000", 10000)]
        public class Recalc: TestNode
        {
            public override void Run()
            {
                int count=(int)MyValues[0];
                string fileName="temp\\gstooltest\\"+Parent.Name+"_"+Name+".txt";

                //create users and dump them into a file
                Global.RO.Debug("Creating users...");
                BulkUserSet userSet;
                UodbWS.CreateBulkUsers("GS", (uint)count, out userSet);

                using (System.IO.StreamWriter file=System.IO.File.CreateText(fileName))
                {
                    for (uint i=0; i<userSet.Count; ++i)
                    {
                        ulong puid=userSet.Base+i;
                        file.WriteLine("0x"+puid.ToString("X"));
                    }
                }

                UserEditor innocentUser=UserEditor.CreateNew();

                //add achievements
                Global.RO.Debug("Adding achievements...");
                GiveUsersAchievements(userSet.Base, userSet.Count);

                //delete the achievement #4 from all the users, for all the titles
                UodbWS.ExecuteSQLNonQuery("delete from t_achievements where bi_puid>="+(long)userSet.Base+" and bi_puid<"+(long)(userSet.Base+userSet.Count)+" and i_achievement_id=4", null);

                //run tool
                string output=Util.RunGSTool("-recalc "+fileName, 10800);
                Util.VerifyOutputHasNoErrors(output);

                //verify all users
                Global.RO.Debug("Checking all users...");
                VerifyUsersAreRecalced(userSet.Base, userSet.Count);

                return TEST_RESULTS.PASSED;
            }
        }

        [TestCase, Description("Sets a watermark in a large number of users")]
        [CompoundCase("100", 100)]
        [CompoundCase("10000", 10000)]
        public class Watermark: TestNode
        {
            public override void Run()
            {
                int count=(int)MyValues[0];
                string fileName="temp\\gstooltest\\"+Parent.Name+"_"+Name+".txt";

                //create users and dump them into a file
                Global.RO.Debug("Creating users...");
                BulkUserSet userSet;
                UodbWS.CreateBulkUsers("GS", (uint)count, out userSet);

                using (System.IO.StreamWriter file=System.IO.File.CreateText(fileName))
                {
                    for (uint i=0; i<userSet.Count; ++i)
                    {
                        ulong puid=userSet.Base+i;
                        file.WriteLine("0x"+puid.ToString("X"));
                    }
                }

                //run tool
                string output=Util.RunGSTool("-watermark -verbose -set -nxe "+fileName, 10800);
                Util.VerifyOutputHasNoErrors(output);

                //verify
                Global.RO.Debug("Verifying...");
               VerifyUsersHaveNXEMark(userSet.Base, userSet.Count);

                return TEST_RESULTS.PASSED;
            }
        }
    };
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\iisrunner\console\IisRunnerCmd.cs ===
using System;
using System.IO;
using System.Xml;
using System.Diagnostics;
using System.Text.RegularExpressions;
using System.Collections.Specialized;

using xonline.tools.iisrunner.core;
using xonline.common.xmlsequencer;

namespace xonline.tools.iisrunner.console
{
	/// <summary>
	/// Provides a command line interface to the core IisRunner functionality.
	/// </summary>
	class IisRunnerCmd
	{
        private string iisRunnerFilename = null;
        private StreamWriter logFile = null;
        private bool logToFile = false;
        private bool logToEvent = false;
        private NameValueCollection overrideVariables = new NameValueCollection();

		/// <summary>
		/// The main entry point for the application.
		/// </summary>
		[STAThread]
		static int Main(string[] args)
		{
            IisRunnerCmd theCmd = new IisRunnerCmd();
            theCmd.ParseCommandLine(args);
            int result = theCmd.RunIt();

            if (theCmd.logFile != null)
            {
                theCmd.logFile.Close();
            }

            return result;
		}

        /// <summary>
        /// Handles parsing of the command line arguments, setting member variables 
        /// based on the options and arguments specified.
        /// </summary>
        /// <param name="args">The arguments to process.</param>
        public void ParseCommandLine(string[] args)
        {
            int numberOfArgs = args.Length;
            Regex variableRegex = new Regex(
                @"^(?<name>[^=]+)=(?<value>.*)", 
                RegexOptions.Compiled | RegexOptions.IgnoreCase);

            for (int currentArgIndex = 0; currentArgIndex < numberOfArgs; currentArgIndex++)
            {
                string currentArg = args[currentArgIndex];
                if (currentArg == "/?")
                {
                    ShowUsageInfo();
                    Environment.Exit(0);
                }
                else if (string.Compare(currentArg, "/lf", true) == 0)
                {
                    logToFile = true;
                }
                else if (string.Compare(currentArg, "/le", true) == 0)
                {
                    logToEvent = true;
                }
                else if (currentArg.StartsWith("/"))
                {
                    Console.WriteLine("ERROR: Invalid argument or option - '" + currentArg + "'.");
                    Console.WriteLine("Type \"IisRunner /?\" for usage help.");
                    Environment.Exit(1);
                }
                else if (variableRegex.IsMatch(currentArg))
                {
                    Match myMatch = variableRegex.Match(currentArg);
                    overrideVariables.Set(myMatch.Groups["name"].Value, myMatch.Groups["value"].Value);
                }
                else
                {
                    if (iisRunnerFilename == null)
                    {
                        iisRunnerFilename = currentArg;
                    }
                    else
                    {
                        Console.WriteLine();
                        Console.WriteLine("Only one IisRunner input file can be specified on the command line. Second filename \"" + currentArg + "\" was encountered.");
                        Console.WriteLine("Type \"IisRunner /?\" for usage help.");
                        Environment.Exit(1);
                    }
                }
            }

            if (iisRunnerFilename == null)
            {
                Console.WriteLine();
                Console.WriteLine("ERROR: Required input file name not specified.");
                Console.WriteLine("Type \"IisRunner /?\" for usage help.");
                Environment.Exit(1);
            }
        }

        private void VerifyParameter(string currentArg, int currentArgIndex, int numberOfArgs)
        {
            if (currentArgIndex + 1 >= numberOfArgs)
            {
                Console.WriteLine("ERROR: Option " + currentArg + " requires a value to be specified.");
                Console.WriteLine("Type \"IisRunner /?\" for usage help."); 
                Environment.Exit(1);
            }
        }

        /// <summary>
        /// Displays information about this program and its command line agruments. 
        /// </summary>
        public void ShowUsageInfo()
        {
            Console.WriteLine();
            Console.WriteLine("IisRunner [/lf] [/le] [VARNAME=VALUE ...] inputfile");
            Console.WriteLine();
            Console.WriteLine("Description:");
            Console.WriteLine("    Executes IIS setup commands as specified by the IisRunner XML input file.");
            Console.WriteLine();
            Console.WriteLine("Parameter List:");
            Console.WriteLine("    /lf             Write messages to a log file (log file will have the");
            Console.WriteLine("                    same name as the runner file with a .log extension)");
            Console.WriteLine();
            Console.WriteLine("    /lf             Write start, stop and exceptions to the application log.");
            Console.WriteLine();
            Console.WriteLine("    VARNAME=VALUE   Specifies a variable name and its associated value");
            Console.WriteLine("                    to use when applying the configuration transform to");
            Console.WriteLine("                    the IisRunner XML input file. Any number of name/value");
            Console.WriteLine("                    definitions can be specified.");
            Console.WriteLine();
            Console.WriteLine("    inputfile       The filename of the XML input file to use.");
            Console.WriteLine();
            Console.WriteLine("  NOTE:  This tool returns an error level of 0 if all setup is successfully");
            Console.WriteLine("         executed, 1 if there are errors in the command line, or 2 if");
            Console.WriteLine("         there were problems processing the input XML or running the IIS setup");
            Console.WriteLine("         it defines.");
            Console.WriteLine();
            Console.WriteLine("Examples:");
            Console.WriteLine("    IisRunner www_xbox_com.xml");
            Console.WriteLine(@"    IisRunner SQLDATAPATH=h:\mssql\data");
            Console.WriteLine(@"              ""SQLLOGPATH=o:\mssql\log files\"" www_xbox_com.xml");
            Console.WriteLine();
 
        }

        /// <summary>
        /// Creates a IisRunnerStep object, configuring it based on the command line arguments,
        /// and executes it. 
        /// </summary>
        /// <returns>
        /// The errorlevel value that should be returned to the cmd environment.
        /// Returns 0 on success, 2 on failure. 
        ///</returns>
        public int RunIt()
        {
            string startMessage = String.Format("IisRunner started processing '{0}' at {1}", iisRunnerFilename, DateTime.Now.ToString());
            Console.WriteLine(startMessage);

            if (logFile != null)
            {
                logFile.WriteLine(startMessage);
            }

            WriteEvent(startMessage,EventLogEntryType.Information);

            try
            {
                XmlDocument xmlDoc = new XmlDocument();
                xmlDoc.Load(iisRunnerFilename);

                ConfigurationTransform transform = new ConfigurationTransform();
                transform.OverrideVariableCollection.Add(overrideVariables);
                transform.TransformDocument(xmlDoc);

                IisRunnerStep runner = new IisRunnerStep(xmlDoc.DocumentElement); // Path.GetFullPath(iisRunnerFilename));

                if (logToFile)
                {
                    runner.OnMessage += new MessageEventHandler(FileMessageLogger);
                }

                runner.OnMessage += new MessageEventHandler(ConsoleMessageLogger);
                
                runner.Validate();
                runner.Execute();

            }
            catch (Exception ex)
            {
                string errorMessage = String.Format("\r\nException encountered executing IisRunner: \r\n{0}", ex.ToString());

                Console.WriteLine(errorMessage);

                if (logFile != null)
                {
                    logFile.WriteLine(errorMessage);
                }

                WriteEvent(errorMessage, EventLogEntryType.Error);

                return 2;
            }

            string doneMessage = String.Format("IisRunner processing of '{0}' completed at {1}", iisRunnerFilename, DateTime.Now.ToString());

            Console.WriteLine(doneMessage);

            if (logFile != null)
            {
                logFile.WriteLine(doneMessage);
            }

            WriteEvent(doneMessage,EventLogEntryType.Information);

            return 0;
        }

        /// <summary>
        /// Event handler for IisRunnerStep's Message event which writes the message to the console.
        /// </summary>
        /// <param name="sender">The IisRunnerStep generating the event.</param>
        /// <param name="e">The MessageEventArgs sent by the event.</param>
        private void ConsoleMessageLogger(object sender, MessageEventArgs e)
        {
            Console.WriteLine(e.Message);
        }
        
        /// <summary>
        /// Event handler for IisRunnerStep's Message event which writes the message to a log file.
        /// </summary>
        /// <param name="sender">The IisRunnerStep generating the event.</param>
        /// <param name="e">The MessageEventArgs sent by the event.</param>
        private void FileMessageLogger(object sender, MessageEventArgs e)
        {
            if (logToFile)
            {
                if (logFile == null)
                {
                    string filename = Path.ChangeExtension(iisRunnerFilename, ".log");
                    logFile = new StreamWriter(filename, true);
                }

                logFile.WriteLine(e.Message);
            }
        }

        private void WriteEvent(string message, EventLogEntryType type)
        {
            if (logToEvent)
            {
                // Create the source, if it does not already exist.
                if(!EventLog.SourceExists("IisRunner"))
                {
                    EventLog.CreateEventSource("IisRunner", "Application");
                }
                
                // Create an EventLog instance and assign its source.
                EventLog myLog = new EventLog();
                myLog.Source = "IisRunner";

                // Write an informational entry to the event log.    
                myLog.WriteEntry(message, type);
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\gstool\main.cs ===
using System;
using System.IO;
using System.Collections;

using xonline.common.config;
using xonline.common.protocol;
using xonline.common.service;

using xonline.common.sql.webstore;
using xonline.server.stats.fd;

using Microsoft.Webstore.WstClient;

public class GamerscoreReset
{
    protected static void ShowUsage()
    {
//       1         2         3         4         5         6         7
//34567890123456789012345678901234567890123456789012345678901234567890123456789
        string helpText = @"
GSTOOL -- Xbox Live Gamerscore TOOL utility -- Microsoft (c) 2008

Usage:

    GSTOOL [options] <input.txt>

        where <input> is a line-delimited list of user ids

Options:

    -reset_achievements
                    Do not use this option without management approval.

                    Marks all achievements as un-earnable and sets the
                    gamerscore to zero.

    -reset_avatar_awards
                    Do not use this option without management approval.

                    Marks all game-awarded avatar assets as un-earnable.

    -unreset_achievements
                    Do not use this option without management approval.

                    Clears the un-earnable bit from all achievements and
                    recalcs the gamerscore. This command implies -unmarkcheater
                    and -recalc.

    -unreset_avatar_awards
                    Do not use this option without management approval.

                    Clears the un-earnable bit from all game-awarded avatar assets.

    -markcheater    Optional for use with the -reset command. Marks the profile
                    with the cheater bit

    -unmarkcheater  Removes the cheater bit from the profile. This works as a
                    stand alone option

    -recalc         Forces a recalculation of a users gamerscore.

    -u <Puid>       <Puid> is a user to operate on.

    -timeout <int>  Override the default timeout of 10 minutes for UODB SQL
                    commands. Setting this to 0 disables timeouts. This value
                    is in seconds.
";
        Console.WriteLine(helpText);
    }

    protected static ArrayList GetPlayedTitles(ulong userid)
    {
        ArrayList alTitles = new ArrayList();
        
        HResult hr = HResult.S_OK;
        EnumTitlesRequest actualReq = new EnumTitlesRequest();
        EnumTitlesResponse actualResp = new EnumTitlesResponse();
        XRLObject2 xrlObject = actualResp;

        actualReq.UserId = userid;
        actualReq.ForUserId = userid;
        actualReq.LocaleId = (ushort)Locales.en_US;
        actualReq.StartingIndex = 0;
        actualReq.MaxTitles = ushort.MaxValue;

        // this stuff is coming off the web, we don't have a machine id
        // or a user id, so we like about it.  pass zeroes for all that
        HTTPAuthData authData = new HTTPAuthData(0, 0, 0, 0, userid, XOn.XENON_DASH_TITLE_ID, (uint)XOService.Progress, 0);

        hr = XRLUtil.PostXrlRequest(VirtualInterface.progressfd_int, actualReq.Xrl, authData.GetBase64EncodedString(), actualReq, ref xrlObject);

        if (HResult.S_OK == hr)
        {
            foreach (UserTitle title in actualResp.Titles)
            {
                alTitles.Add(title.TitleId);
            }
        }

        return alTitles;
   }

    protected static void ResetDatabaseGamerscore(ulong userid)
    {
        // Add the cheater mark to the user's achievement
        using (WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITEONLY_COMMANDTYPE))
        {
            ws.ClearParameters();
            ws.StoredProc = "p_stats_reset_user_achievements";
            ws.Partition = ws.CalcPartition(userid);
            ws.AddParameter("@bi_user_puid", userid);
            ws.Command.CommandTimeout = _iCommandTimeout;

            ws.ExecuteNonQuery();
        }
    }

    protected static void UnresetDatabaseGamerscore(ulong userid)
    {
        // Clear the cheater mark on the user's achievements
        using (WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITEONLY_COMMANDTYPE))
        {
            ws.ClearParameters();
            ws.StoredProc = "p_stats_unreset_user_achievements";
            ws.Partition = ws.CalcPartition(userid);
            ws.AddParameter("@bi_user_puid", userid);
            ws.Command.CommandTimeout = _iCommandTimeout;

            ws.ExecuteNonQuery();
        }

        // Remove the cheater bit
        UnmarkCheater(userid);

        // Recalc the gamerscore
        RecalcDatabaseGamerscore(userid);
    }

    protected static void ResetDatabaseAvatarAssets(ulong userid)
    {
        // Add the cheater mark to the user's achievement
        using (WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITEONLY_COMMANDTYPE))
        {
            ws.ClearParameters();
            ws.StoredProc = "p_stats_reset_user_avatar_assets";
            ws.Partition = ws.CalcPartition(userid);
            ws.AddParameter("@bi_user_puid", userid);
            ws.Command.CommandTimeout = _iCommandTimeout;

            ws.ExecuteNonQuery();
        }
    }

    protected static void UnresetDatabaseAvatarAssets(ulong userid)
    {
        // Clear the cheater mark on the user's achievements
        using (WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITEONLY_COMMANDTYPE))
        {
            ws.ClearParameters();
            ws.StoredProc = "p_stats_unreset_user_avatar_assets";
            ws.Partition = ws.CalcPartition(userid);
            ws.AddParameter("@bi_user_puid", userid);
            ws.Command.CommandTimeout = _iCommandTimeout;

            ws.ExecuteNonQuery();
        }

        // Remove the cheater bit
        UnmarkCheater(userid);
    }

    protected static void RecalcDatabaseGamerscore(ulong userid)
    {
        // Recalc the users achievements and gamerscore for each title the
        // user has played
        ArrayList alTitles = GetPlayedTitles(userid);
        foreach (int title in alTitles)
        {
            Profile.RecalcGamerscore( userid, (uint) title );
        }
    }

    protected static void MarkCheater(ulong userid)
    {
        using (WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITEONLY_COMMANDTYPE))
        {
            ws.ClearParameters();
            ws.StoredProc = "p_stats_mark_user_as_cheater";
            ws.Partition = ws.CalcPartition(userid);
            ws.AddParameter("@bi_user_puid", userid);
            ws.Command.CommandTimeout = _iCommandTimeout;

            ws.ExecuteNonQuery();
        }
    }

    protected static void UnmarkCheater(ulong userid)
    {
        // Remove the cheater bit from the user's profile
        using (WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITEONLY_COMMANDTYPE))
        {
            ws.ClearParameters();
            ws.StoredProc = "p_stats_unmark_user_as_cheater";
            ws.Partition = ws.CalcPartition(userid);
            ws.AddParameter("@bi_user_puid", userid);
            ws.Command.CommandTimeout = _iCommandTimeout;

            ws.ExecuteNonQuery();
        }
    }

    protected static void RemoveCacheData(ulong userid)
    {
        ArrayList alTitles = GetPlayedTitles(userid);
        Acceleration xb = new Acceleration(Interface.ProfileCache);

        foreach (int title in alTitles)
        {
            xb.Remove(ProfileDefs.BuildCacheKey(ProfileDefs.XPROFILE_GAMERCARD_TITLE_CRED_EARNED, (uint)title, userid));
            xb.Remove(ProfileDefs.BuildCacheKey(ProfileDefs.XPROFILE_GAMERCARD_TITLE_ACHIEVEMENTS_EARNED, (uint)title, userid));
        }

        xb.Remove(ProfileDefs.BuildCacheKey(ProfileDefs.XPROFILE_GAMERCARD_CRED, XOn.XENON_DASH_TITLE_ID, userid));
        xb.Remove(ProfileDefs.BuildCacheKey(ProfileDefs.XPROFILE_GAMERCARD_ACHIEVEMENTS_EARNED, XOn.XENON_DASH_TITLE_ID, userid));
        xb.Remove(ProfileDefs.BuildCacheKey(ProfileDefs.XPROFILE_GAMER_TYPE, XOn.XENON_DASH_TITLE_ID, userid));
    }

    public static void Main(string[] args)
    {
        ArrayList users = new ArrayList();
        bool fCheater   = false;
        bool fUncheater = false;
        bool fResetAchievements = false;
        bool fUnresetAchievements = false;
        bool fResetAvatarAwards = false;
        bool fUnresetAvatarAwards = false;
        bool fRecalc    = false;
        string str;
        ulong userid;

        // Register some abort handler
        Console.TreatControlCAsInput = false;
        Console.CancelKeyPress += new ConsoleCancelEventHandler(OnCtrlC);

        // Parse the arguments
        for (int n = 0; n < args.Length; n++)
        {
            // Grab the current argument
            str =  args[n];

            // See if there is a switch
            if (str[0] == '-' || str[0] == '/')
            {
                string arg = str.ToLower().Substring(1);

                // What areguments have been specified?
                if (arg == "markcheater")
                {
                    if (fUncheater)
                    {
                        Console.WriteLine("-markcheater cannot be used with -unmarkcheater");
                        return;
                    }
                    fCheater = true;
                    continue;
                }
                if (arg == "unmarkcheater")
                {
                    if (fCheater)
                    {
                        Console.WriteLine("-unmarkcheater cannot be used with -markcheater");
                        return;
                    }
                    fUncheater = true;
                    continue;
                }
                if (arg == "unreset")
                {
                    Console.WriteLine("-unreset_achievements and/or -unreset_avatar_awards should be used instead of -unreset");
                    return;
                }
                if (arg == "unreset_achievements")
                {
                    if (fResetAchievements || fResetAvatarAwards || fRecalc)
                    {
                        Console.WriteLine("Unreset cannot be used with Reset or Recalc");
                        return;
                    }
                    fUnresetAchievements = true;
                    continue;
                }
                if (arg == "unreset_avatar_awards")
                {
                    if (fResetAchievements || fResetAvatarAwards || fRecalc)
                    {
                        Console.WriteLine("Unreset cannot be used with Reset or Recalc");
                        return;
                    }
                    fUnresetAvatarAwards = true;
                    continue;
                }
                if (arg == "reset")
                {
                    Console.WriteLine("-reset_achievements and/or -reset_avatar_awards should be used instead of -reset");
                    return;
                }
                if (arg == "reset_achievements")
                {
                    if (fUnresetAchievements || fUnresetAvatarAwards || fRecalc)
                    {
                        Console.WriteLine("Reset cannot be used with Unreset or Recalc");
                        return;
                    }
                    fResetAchievements = true;
                    continue;
                }
                if (arg == "reset_avatar_awards")
                {
                    if (fUnresetAchievements || fUnresetAvatarAwards || fRecalc)
                    {
                        Console.WriteLine("Reset cannot be used with Unreset or Recalc");
                        return;
                    }
                    fResetAvatarAwards = true;
                    continue;
                }
                if (arg == "recalc")
                {
                    if (fResetAchievements || fUnresetAchievements || fResetAvatarAwards || fUnresetAvatarAwards)
                    {
                        Console.WriteLine("Recalc cannot be used with Reset or Unreset");
                        return;
                    }
                    fRecalc = true;
                    continue;
                }
                if (arg == "u")
                {
                    if ((n+1) >= args.Length)
                    {
                        ShowUsage();
                        Console.WriteLine("Missing puid for -u");
                        return;
                    }

                    try
                    {
                        n = n + 1;
                        userid= UInt64.Parse(args[n]);
                        users.Add( userid );
                    }
                    catch (Exception e)
                    {
                        Console.WriteLine("FAILED processing -u " + args[n]);
                        Console.WriteLine("ERROR : " + e.ToString() );
                        return;
                    }
                    continue;
                }
                if (arg == "timeout")
                {
                    if ((n+1) >= args.Length)
                    {
                        ShowUsage();
                        Console.WriteLine("Missing timeout for -timeout");
                        return;
                    }
                    try
                    {
                        n = n + 1;
                        _iCommandTimeout= Int32.Parse(args[n]);
                    }
                    catch (Exception e)
                    {
                        Console.WriteLine("FAILED processing -timeout " + args[n]);
                        Console.WriteLine("ERROR : " + e.ToString() );
                        return;
                    }
                    continue;
                }
                if (arg == "?" || arg == "help")
                {
                    ShowUsage();
                    return;
                }
                ShowUsage();
                Console.WriteLine("ERROR: Unknown Argument '-" + arg + "'" );
                return;

            }

            // Process the file
            try
            {
                using (StreamReader sr = new StreamReader(str))
                {
                    string input;
                    while (_fAlive && ((input = sr.ReadLine()) != null))
                    {
                        try
                        {
                            userid = UInt64.Parse(input);
                            users.Add( userid );
                        }
                        catch (Exception e)
                        {
                            Console.WriteLine("FAILED processing " + input);
                            Console.WriteLine("ERROR : " + e.ToString());
                            return;
                        }
                    }
                }
            }
            catch (Exception e)
            {
                ShowUsage();
                Console.WriteLine("ERROR: The file <" + str + "> could not be read:");
                Console.WriteLine(e.ToString());
                return;
            }

        }

        // Make sure that we have some users to process data on
        if (users.Count == 0)
        {
            ShowUsage();
            Console.WriteLine("ERROR: No user ids to process");
            return;
        }

        // Loop over every user that we have
        foreach (ulong id in users)
        {
            if (_fAlive == false)
            {
                break;
            }
            userid = id;

            try
            {
                string gamertag;

                Console.Write(
                    "\r\nLooking up user: 0x" + userid.ToString("X") + "... "
                    );

                gamertag = XCache.LookupGamerTag(userid);
                if (XCache.IsInvalidGamertag(gamertag))
                {
                    throw new ApplicationException(
                        "userid not found by XCache."
                        );
                }
                Console.WriteLine("SUCCEEDED.  Gamertag = " + gamertag);

                if (fResetAchievements == true)
                {
                    Console.Write(
                        "Resetting database achievements and gamerscore for user 0x" +
                        id.ToString("X") +
                        "... "
                        );
                    ResetDatabaseGamerscore(userid);
                }
                if (fUnresetAchievements == true)
                {
                    Console.Write(
                        "Unresetting database achievements and gamerscore for user 0x" +
                        userid.ToString("X") +
                        "... "
                        );
                    UnresetDatabaseGamerscore(userid);
                }
                if (fResetAvatarAwards == true)
                {
                    Console.Write(
                        "Resetting database avatar assets for user 0x" +
                        id.ToString("X") +
                        "... "
                        );
                    ResetDatabaseAvatarAssets(userid);
                }
                if (fUnresetAvatarAwards == true)
                {
                    Console.Write(
                        "Unresetting database avatar assets for user 0x" +
                        userid.ToString("X") +
                        "... "
                        );
                    UnresetDatabaseAvatarAssets(userid);
                }
                if (fRecalc == true)
                {
                    Console.Write(
                        "Recalculating gamerscore for user 0x" +
                        userid.ToString("X") +
                        "... "
                        );
                    RecalcDatabaseGamerscore(userid);
                }
                if (fCheater == true)
                {
                    Console.Write(
                        "Marking user as cheater for user 0x" +
                        userid.ToString("X") +
                        "... "
                        );
                    MarkCheater(userid);
                }
                if (fUncheater == true)
                {
                    Console.Write(
                        "Unmarking user as cheater for user 0x" +
                        userid.ToString("X") +
                        "... "
                        );
                    UnmarkCheater(userid);
                }
                Console.WriteLine("SUCCEEDED.");

                Console.Write(
                    "Removing Cache entries for user 0x" +
                    userid.ToString("X") +
                    "... "
                    );
                RemoveCacheData(userid);
                Console.WriteLine("SUCCEEDED.");

            } catch (Exception e)
            {
                Console.WriteLine("FAILED: " + e.ToString());
                continue;
            }
        }
    }

    protected static void OnCtrlC(object sender, ConsoleCancelEventArgs args)
    {
        Console.WriteLine("\r\nOperation interrupted!  Aborting list processing...");
        _fAlive = false;
        args.Cancel = true;
    }

    protected static bool _fAlive = true;
    protected static int  _iCommandTimeout = 60 * 10; // 10 minute timeout
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\iisrunner\core\AccessStep.cs ===
using System;
using System.Xml;
using System.Management;

using xonline.common.wmi.iisv2;
using xonline.common.xmlsequencer;

namespace xonline.tools.iisrunner.core
{
    /// <summary>
    /// Handles configuration of IIS Metabase access settings.
    /// </summary>
    /// <remarks>
    /// <para>
    /// This step handles the <c>&lt;access&gt;</c> element in an IisRunner configuration file.
    /// It allows configuring file access permissions for the parent IIS object of the element.
    /// </para><para>
    /// The following table lists the attributes supported by the <c>&lt;access&gt;</c> element
    /// and a brief description of their meaning. For more information, see the IIS metebase 
    /// documentation at http://msdn.microsoft.com/library/default.asp?url=/library/en-us/iissdk/iis/ref_mb_dirbrowseflags.asp.
    /// </para>
    /// <para>
    /// All attributes default to false if not specified.
    /// </para>
    /// <list type="table">
    /// <listheader>
    ///     <term>Attribute</term>
    ///     <description>Description</description>
    /// </listheader>
    /// <item>
    ///     <term>read</term>
    ///     <description>A value of true indicates that the file or the contents of the folder may be read through Microsoft Internet Explorer.</description>
    /// </item>
    /// <item>
    ///     <term>write</term>
    ///     <description>A value of true indicates that users are allowed to upload files and their associated properties to the enabled directory on your server or to change content in a Write-enabled file. Write can be implemented only with a browser that supports the PUT feature of the HTTP 1.1 protocol standard.</description>
    /// </item>
    /// <item>
    ///     <term>source</term>
    ///     <description>A value of true indicates that users are allowed to access source code if either Read or Write permissions are set. Source code includes scripts in Microsoft  Active Server Pages (ASP) applications.</description>
    /// </item>
    /// <item>
    ///     <term>script</term>
    ///     <description>A value of true indicates that the file or the contents of the folder may be executed if they are script files or static content. A value of false only allows static files, such as HTML files, to be served.</description>
    /// </item>
    /// <item>
    ///     <term>execute</term>
    ///     <description>A value of true indicates that the file or the contents of the folder may be executed, regardless of file type.</description>
    /// </item>
    /// <item>
    ///     <term>noRemoteRead</term>
    ///     <description>A value of true indicates that remote requests to view files are denied; only requests from the same computer as the IIS server succeed if the AccessRead property is set to true. You cannot set AccessNoRemoteRead to false to enable remote requests, and set AccessRead to false to disable local requests.</description>
    /// </item>
    /// <item>
    ///     <term>noRemoteWrite</term>
    ///     <description>A value of true indicates that remote requests to create or change files are denied; only requests from the same computer as the IIS server succeed if the AccessWrite property is set to true. You cannot set AccessNoRemoteWrite to false to enable remote requests, and set AccessWrite to false to disable local requests.</description>
    /// </item>
    /// <item>
    ///     <term>noRemoteScript</term>
    ///     <description>A value of true indicates that remote requests to view dynamic content are denied; only requests from the same computer as the IIS server succeed if the AccessScript property is set to true. You cannot set AccessNoRemoteScript to false to enable remote requests, and set AccessScript to false to disable local requests.</description>
    /// </item>
    /// <item>
    ///     <term>noRemoteExecute</term>
    ///     <description>A value of true indicates that remote requests to execute applications are denied; only requests from the same computer as the IIS server succeed if the AccessExecute property is set to true. You cannot set AccessNoRemoteExecute to false to enable remote requests, and set AccessExecute to false to disable local requests.</description>
    /// </item>
    /// <item>
    ///     <term>noPhysicalDir</term>
    ///     <description>A value of true indicates that access to the physical path is not allowed.</description>
    /// </item>
    /// </list> 
    ///</remarks>
    [StepElement("Access")]
    public class AccessStep : Step
    {
        public AccessStep(XmlElement stepElement, StepContainer parent) : base(stepElement, parent)
        {
        }

        protected override void OnExecute()
        {
            base.OnExecute ();

            ManagementBaseObject directory = StepNavigation.GetAncestorDirectorySettingObject(this);

            int accessFlags = 0;

            if (String.Compare(BaseXmlElement.GetAttribute("execute"), "true", true) == 0)
            {
                accessFlags |= 0x00000004;
            }

            if (String.Compare(BaseXmlElement.GetAttribute("read"), "true", true) == 0)
            {
                accessFlags |= 0x00000001;
            }

            if (String.Compare(BaseXmlElement.GetAttribute("script"), "true", true) == 0)
            {
                accessFlags |= 0x00000200;
            }

            if (String.Compare(BaseXmlElement.GetAttribute("source"), "true", true) == 0)
            {
                accessFlags |= 0x00000010;
            }

            if (String.Compare(BaseXmlElement.GetAttribute("write"), "true", true) == 0)
            {
                accessFlags |= 0x00000002;
            }

            if (String.Compare(BaseXmlElement.GetAttribute("noPhysicalDir"), "true", true) == 0)
            {
                accessFlags |= 0x00008000;
            }

            if (String.Compare(BaseXmlElement.GetAttribute("noRemoteExecute"), "true", true) == 0)
            {
                accessFlags |= 0x00002000;
            }

            if (String.Compare(BaseXmlElement.GetAttribute("noRemoteRead"), "true", true) == 0)
            {
                accessFlags |= 0x00001000;
            }

            if (String.Compare(BaseXmlElement.GetAttribute("noRemoteScript"), "true", true) == 0)
            {
                accessFlags |= 0x00004000;
            }

            if (String.Compare(BaseXmlElement.GetAttribute("noRemoteWrite"), "true", true) == 0)
            {
                accessFlags |= 0x00000400;
            }

            // BUG: There appears to be a problem with the WMI provider. If accessFlags == 0
            // then the AccessFlags item never gets written to the metabase. Other values work fine.
            // I've spent too much time trying to solve this, so I'm moving on.

            directory["AccessFlags"] = accessFlags;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\iisrunner\core\ApplicationStep.cs ===
using System;
using System.Xml;
using System.Management;
using System.DirectoryServices;

using xonline.common.wmi.iisv2;
using xonline.common.xmlsequencer;

namespace xonline.tools.iisrunner.core
{
    /// <summary>
    /// Summary description for ApplicationStep.
    /// </summary>
    [StepElement("Application")]
    public class ApplicationStep : StepContainer
    {
        private ApplicationMode appMode = ApplicationMode.InProcess;
        private string poolName = null;
        private bool aspAllowSessionState = true;
        private int aspSessionTimeout = 20;

        public ApplicationStep(XmlElement stepElement, StepContainer parent) : base(stepElement, parent)
        {
            string modeText = stepElement.GetAttribute("mode");

            if (String.Compare(modeText, "InProcess", true) == 0)
            {
                appMode = ApplicationMode.InProcess;
            }
            else if (String.Compare(modeText, "OutOfProcess", true) == 0)
            {
                appMode = ApplicationMode.OutOfProcess;
            }
            else if (String.Compare(modeText, "Pooled", true) == 0)
            {
                appMode = ApplicationMode.Pooled;
            }
            else
            {
                throw new ArgumentException(stepElement.Name + " element requires a mode attribute which must be either InProcess, OutOfProcess, or Pooled.", "mode");
            }

            string szAspAllowSessionState = stepElement.GetAttribute("aspAllowSessionState");

            aspAllowSessionState = (szAspAllowSessionState.Length == 0 || szAspAllowSessionState.Equals("yes") || szAspAllowSessionState.Equals("true") || szAspAllowSessionState.Equals("on") || szAspAllowSessionState.Equals("1"));

            string szAspSessionTimeout = stepElement.GetAttribute("aspSessionTimeout");

            if (szAspSessionTimeout.Length == 0)
            {
                aspSessionTimeout = 20;
            }
            else
            {
                int iTimeout = Convert.ToInt32(szAspSessionTimeout);
                if (iTimeout < 0)
                {
                    iTimeout = 0;
                }

                aspSessionTimeout = iTimeout;
            }

            poolName = stepElement.GetAttribute("poolName");
        }

        protected override void OnExecute()
        {
            IApplicationHost appHost = StepNavigation.GetAncestorApplicationHost(this);
            appHost.CreateApplication(appMode, poolName);

            ManagementBaseObject appDir = StepNavigation.GetAncestorDirectorySettingObject(this);
            appDir["AspAllowSessionState"] = (aspAllowSessionState ? 1 : 0);
            appDir["AspSessionTimeout"] = aspSessionTimeout;

            // execute child steps after application is created
            base.OnExecute ();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\iisrunner\core\AuthenticationStep.cs ===
using System;
using System.Xml;
using System.Management;

using xonline.common.wmi.iisv2;
using xonline.common.xmlsequencer;

namespace xonline.tools.iisrunner.core
{
    /// <summary>
    /// Summary description for AuthenticationStep.
    /// </summary>
    [StepElement("Authentication")]
    public class AuthenticationStep : Step
    {
        public AuthenticationStep(XmlElement stepElement, StepContainer parent) : base(stepElement, parent)
        {
        }

        protected override void OnExecute()
        {
            base.OnExecute ();

            ManagementBaseObject directory = StepNavigation.GetAncestorDirectorySettingObject(this);

            int authFlags = 0;

            if (BaseXmlElement.GetAttribute("anonymous").ToLower() == "true")
            {
                authFlags |= 0x00000001;
            }

            if (BaseXmlElement.GetAttribute("basic").ToLower() == "true")
            {
                authFlags |= 0x00000002;
            }

            if (BaseXmlElement.GetAttribute("digest").ToLower() == "true")
            {
                authFlags |= 0x00000010;
            }

            if (BaseXmlElement.GetAttribute("windows").ToLower() == "true")
            {
                authFlags |= 0x00000004;
            }

            if (BaseXmlElement.GetAttribute("passport").ToLower() == "true")
            {
                authFlags |= 0x00000040;
            }

            directory["AuthFlags"] = authFlags;

            if (BaseXmlElement.GetAttribute("realm").Length > 0)
            {
                directory["Realm"] = BaseXmlElement.GetAttribute("realm");
            }

            if (BaseXmlElement.GetAttribute("defaultLogonDomain").Length > 0)
            {
                directory["DefaultLogonDomain"] = BaseXmlElement.GetAttribute("defaultLogonDomain");
            }

            if (BaseXmlElement.GetAttribute("anonymousUserPass").Length > 0)
            {
                directory["AnonymousUserPass"] = BaseXmlElement.GetAttribute("anonymousUserPass");
            }

            if (BaseXmlElement.GetAttribute("anonymousUserName").Length > 0)
            {
                directory["AnonymousUserName"] = BaseXmlElement.GetAttribute("anonymousUserName");
            }

            if (BaseXmlElement.GetAttribute("anonymousPasswordSync").Length > 0)
            {
                if (BaseXmlElement.GetAttribute("anonymousPasswordSync").ToLower() == "false")
                {
                    directory["AnonymousPasswordSync"] = false;
                }
                else
                {
                    directory["AnonymousPasswordSync"] = true;
                }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\iisrunner\core\ApplicationPoolStep.cs ===
using System;
using System.IO;
using System.Xml;
using System.Management;
using System.Data.SqlClient;

using xonline.common.wmi.iisv2;
using xonline.common.xmlsequencer;

namespace xonline.tools.iisrunner.core
{
	/// <summary>
	/// Summary description for WebSeverStep.
	/// </summary>
	[StepElement("ApplicationPool")]
	public class ApplicationPoolStep : StepContainer
	{
        private string name = null;
        private IIsApplicationPoolSetting applicationPoolSetting = null;

        /// <summary>
        /// 
        /// </summary>
        /// <param name="stepElement"></param>
        /// <param name="parent"></param>
        public ApplicationPoolStep(XmlElement stepElement, StepContainer parent) : base(stepElement, parent)
        {
            name = BaseXmlElement.GetAttribute("name");
            
            if (name.Length == 0)
            {
                throw new ArgumentException("The name attribute of the " + stepElement.Name + " element must be specified.", "name");
            }

        }

        /// <summary>
        /// 
        /// </summary>
       public string Name
        {
            get {return name;}
        }

        public IIsApplicationPoolSetting ApplicationPoolSetting
        {
            get {return applicationPoolSetting;}
        }

        /// <summary>
        /// 
        /// </summary>
        public IisRunnerStep IisRunnerStep
        {
            get 
            {
                if (!(Root is IisRunnerStep))
                {
                    throw new InvalidOperationException("The root step must be IisRunnerStep for ApplicationPoolSetup to function correctly."); 
                }
                return (IisRunnerStep) Root;
            }
        }

        protected override void OnExecute()
        {
            ManagementScope mScope = IisRunnerStep.IisManagementScope;

            string keyName = "W3SVC/AppPools/" + Name;

            applicationPoolSetting = GetApplicationPoolSetting(keyName);

            if (ApplicationPoolSetting == null)
            {
                Root.LogMessage(String.Format("Creating Application Pool {0}.", Name));

                applicationPoolSetting = IIsApplicationPoolSetting.CreateInstance();
                applicationPoolSetting.LateBoundObject["Name"]   = keyName;
            }

            // let contained steps execute
            base.OnExecute ();
        }

        protected override void OnAfterExecute()
        {
            ManagementScope mScope = IisRunnerStep.IisManagementScope;

            string keyName = "W3SVC/AppPools/" + Name;

            if (ApplicationPoolSetting != null)
            {
                ApplicationPoolSetting.CommitObject();
            }

            IIsApplicationPool applicationPool = new IIsApplicationPool(mScope, keyName);

            try
            {
                applicationPool.Start();
            }
            catch (System.Runtime.InteropServices.COMException)
            {
                Root.LogMessage("Couldn't start application pool " + Name + ".");
            }

            Root.LogMessage("Create of application pool complete");

            applicationPoolSetting = null;
            base.OnAfterExecute ();
        }

        private IIsApplicationPoolSetting GetApplicationPoolSetting(string keyName)
        {
            ManagementScope mScope = IisRunnerStep.IisManagementScope;
    
            IIsApplicationPoolSetting.IIsApplicationPoolSettingCollection sites = IIsApplicationPoolSetting.GetInstances();
    
            foreach(IIsApplicationPoolSetting site in sites)
            {
                if (String.Compare(site.Name, keyName, true) == 0)
                {
                    return site;
                }
            }
    
            return null;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\iisrunner\core\AppPoolIdentityStep.cs ===
using System;
using System.Xml;
using System.Management;
using System.DirectoryServices;

using xonline.common.wmi.iisv2;
using xonline.common.xmlsequencer;

namespace xonline.tools.iisrunner.core
{
    /// <summary>
    /// Summary description for AppPoolIdentityStep.
    /// </summary>
    [StepElement("AppPoolIdentity")]
    public class AppPoolIdentityStep : Step
    {
        enum AppPoolIdentityType
        {
            LocalSystem = 0,
            LocalService = 1,
            NetworkService = 2,
            SpecificUser = 3
        }

        private AppPoolIdentityType type = AppPoolIdentityType.LocalSystem;
        private string userName = null;
        private string userPass = null;

        public AppPoolIdentityStep(XmlElement stepElement, StepContainer parent) : base(stepElement, parent)
        {
            string poolType = stepElement.GetAttribute("type");

            if (String.Compare(poolType, "localsystem", true) == 0)
            {
                type = AppPoolIdentityType.LocalSystem;
            }
            else if (String.Compare(poolType, "localservice", true) == 0)
            {
                type = AppPoolIdentityType.LocalService;
            }
            else if (String.Compare(poolType, "networkservice", true) == 0)
            {
                type = AppPoolIdentityType.NetworkService;
            }
            else if (String.Compare(poolType, "user", true) == 0)
            {
                type = AppPoolIdentityType.SpecificUser;
            }
            else
            {
                throw new ArgumentException(stepElement.Name + " element requires a type attribute which must be either localsystem, localservice, networkservice, or user.", "type");
            }

            userName = stepElement.GetAttribute("userName");
            userPass = stepElement.GetAttribute("userPass");
        }

        protected override void OnExecute()
        {
            base.OnExecute ();

            ApplicationPoolStep appPoolStep = StepNavigation.GetApplicationPoolAncestorOfStep(this);
            ManagementBaseObject appPoolSetting = appPoolStep.ApplicationPoolSetting.LateBoundObject;

            appPoolSetting["AppPoolIdentityType"] = (int) this.type;

            if (userName.Length != 0)
            {
                if (type == AppPoolIdentityType.SpecificUser)
                {
                    AddUserToIisWpg(userName);
                }

                appPoolSetting["WAMUserName"] = userName;
            }

            if (userPass.Length != 0)
            {
                appPoolSetting["WAMUserPass"] = userPass;
            }
        }

        private void AddUserToIisWpg(string ImpersonateUser)
        {
            DirectoryEntry localMachine = new DirectoryEntry("WinNT://" + Environment.MachineName);
            DirectoryEntry group  = null;

            string ldapUser = ImpersonateUser.Replace('\\', '/');

            try
            {
                group = localMachine.Children.Find("IIS_IUSRS", "Group");
            }
            catch
            {
                throw new ApplicationException("Unable to find local group IIS_IUSRS");
            }
                
            try
            {
                group.Invoke("Add", new Object[] {"WinNT://" + ldapUser});     // E.G. WinNT://test/uodb_user
            }
            catch
            {
                // $REVIEW (michion): assume failures are from adding a user already present
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\iisrunner\core\AppPoolPerformanceStep.cs ===
using System;
using System.Xml;
using System.Management;
using System.DirectoryServices;

using xonline.common.wmi.iisv2;
using xonline.common.xmlsequencer;

namespace xonline.tools.iisrunner.core
{
    /// <summary>
    /// Summary description for AppPoolPerformanceStep.
    /// </summary>
    [StepElement("AppPoolPerformance")]
    public class AppPoolPerformanceStep : Step
    {

        public AppPoolPerformanceStep(XmlElement stepElement, StepContainer parent) : base(stepElement, parent)
        {
        }

        public int IdleTimeout
        {
            get
            {
                string configIdleTimeout = BaseXmlElement.GetAttribute("idleTimeout");
                if (configIdleTimeout.Length == 0)
                {
                    return 20;
                }

                return Convert.ToInt32(configIdleTimeout);
            }
        }

        public int RequestQueueLimit
        {
            get
            {
                string configValue = BaseXmlElement.GetAttribute("requestQueueLimit");
                if (configValue.Length == 0)
                {
                    return 4000;
                }

                return Convert.ToInt32(configValue);                
            }
        }

        public int MaxProcesses
        {
            get
            {
                string configValue = BaseXmlElement.GetAttribute("maxProcesses");
                if (configValue.Length == 0)
                {
                    return 1;
                }

                return Convert.ToInt32(configValue);                
            }
        }

        public int CpuLimit
        {
            get
            {
                string configValue = BaseXmlElement.GetAttribute("cpuLimit");
                if (configValue.Length == 0)
                {
                    return 0;
                }

                return Convert.ToInt32(configValue);                
            }
        }

        public int CpuResetInterval
        {
            get
            {
                string configValue = BaseXmlElement.GetAttribute("cpuResetInterval");
                if (configValue.Length == 0)
                {
                    return 5;
                }

                return Convert.ToInt32(configValue);                
            }
        }

        public int CpuAction
        {
            get
            {
                string configValue = BaseXmlElement.GetAttribute("cpuAction");
                if (configValue.Length == 0)
                {
                    return 0;
                }

                return Convert.ToInt32(configValue);                
            }
        }

        public int AppPoolQueueLength
        {
            get
            {
                string configValue = BaseXmlElement.GetAttribute("appPoolQueueLength");
                if (configValue.Length == 0)
                {
                    return 4000;
                }

                return Convert.ToInt32(configValue);                
            }
        }

        public int PeriodicRestartTime
        {
            get
            {
                string configValue = BaseXmlElement.GetAttribute("periodicRestartTime");
                if (configValue.Length == 0)
                {
                    return 1740;
                }

                return Convert.ToInt32(configValue);                
            }
        }

        public int PeriodicRestartMemory
        {
            get
            {
                string configValue = BaseXmlElement.GetAttribute("periodicRestartMemory");
                if (configValue.Length == 0)
                {
                    return 0;
                }

                return Convert.ToInt32(configValue);                
            }
        }

        public int PeriodicRestartPrivateMemory
        {
            get
            {
                string configValue = BaseXmlElement.GetAttribute("periodicRestartPrivateMemory");
                if (configValue.Length == 0)
                {
                    return 0;
                }

                return Convert.ToInt32(configValue);                
            }
        }

        public override void Validate()
        {
            int testValue;
            testValue = this.IdleTimeout;
            testValue = this.RequestQueueLimit;
            testValue = this.MaxProcesses;
            testValue = this.CpuLimit;
            testValue = this.CpuResetInterval;
            testValue = this.CpuAction;
            testValue = this.AppPoolQueueLength;
            testValue = this.PeriodicRestartTime;
            testValue = this.PeriodicRestartMemory;
            testValue = this.PeriodicRestartPrivateMemory;
        }

        protected override void OnExecute()
        {
            base.OnExecute ();

            ApplicationPoolStep appPoolStep = StepNavigation.GetApplicationPoolAncestorOfStep(this);
            ManagementBaseObject appPoolSetting = appPoolStep.ApplicationPoolSetting.LateBoundObject;

            appPoolSetting["IdleTimeout"] = this.IdleTimeout;
            appPoolSetting["AppPoolQueueLength"] = this.RequestQueueLimit;
            appPoolSetting["MaxProcesses"] = this.MaxProcesses;
            appPoolSetting["CPULimit"] = this.CpuLimit;
            appPoolSetting["CPUResetInterval"] = this.CpuResetInterval;
            appPoolSetting["CPUAction"] = this.CpuAction;
            appPoolSetting["AppPoolQueueLength"] = this.AppPoolQueueLength;
            appPoolSetting["PeriodicRestartTime"] = this.PeriodicRestartTime;
            appPoolSetting["PeriodicRestartMemory"] = this.PeriodicRestartMemory;
            appPoolSetting["PeriodicRestartPrivateMemory"] = this.PeriodicRestartPrivateMemory;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\iisrunner\core\DeleteApplicationPoolStep.cs ===
using System;
using System.Xml;
using Microsoft.Win32;
using System.Management;
using System.Data.SqlClient;

using xonline.common.wmi.iisv2;
using xonline.common.xmlsequencer;

namespace xonline.tools.iisrunner.core
{
    /// <summary>
    /// Summary description for DeleteApplicationPoolStep.
    /// </summary>
    [StepElement("DeleteApplicationPool")]
    public class DeleteApplicationPoolStep : Step
    {
        private string name = null;

        /// <summary>
        /// 
        /// </summary>
        /// <param name="stepElement"></param>
        /// <param name="parent"></param>
        public DeleteApplicationPoolStep(XmlElement stepElement, StepContainer parent) : base(stepElement, parent)
        {
            name = BaseXmlElement.GetAttribute("name");

            if (name.Length == 0)
            {
                throw new ArgumentException("The name attribute of the " + stepElement.Name + " element must be specified.", "name");
            }
        }

        public string Name
        {
            get { return name; }
        }

        public string KeyName
        {
            get {return "W3SVC/AppPools/" + Name;}
        }

        /// <summary>
        /// 
        /// </summary>
        public IisRunnerStep IisRunnerStep
        {
            get 
            {
                if (!(Root is IisRunnerStep))
                {
                    throw new InvalidOperationException("The root step must be IisRunnerStep for DeleteApplicationPoolStep to function correctly."); 
                }
                return (IisRunnerStep) Root;
            }
        }

        protected override void OnExecute()
        {
            base.OnExecute ();

            Root.LogMessage("Deleting application pool " + Name);

            ManagementScope mScope = IisRunnerStep.IisManagementScope;
            IIsApplicationPoolSetting appPoolSetting = new IIsApplicationPoolSetting(mScope, KeyName);

            try
            {
                appPoolSetting.Delete();
            }
            catch (System.IO.DirectoryNotFoundException)
            {
                // The app pool does not exist. Ignore the exception.
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\iisrunner\core\DeleteApplicationStep.cs ===
using System;
using System.Xml;
using System.Management;
using System.DirectoryServices;

using xonline.common.wmi.iisv2;
using xonline.common.xmlsequencer;

namespace xonline.tools.iisrunner.core
{
    /// <summary>
    /// Summary description for DeleteApplicationStep.
    /// </summary>
    [StepElement("DeleteApplication")]
    public class DeleteApplicationStep : Step
    {
        public DeleteApplicationStep(XmlElement stepElement, StepContainer parent) : base(stepElement, parent)
        {
        }

        protected override void OnExecute()
        {
            base.OnExecute ();

            IApplicationHost appHost = StepNavigation.GetAncestorApplicationHost(this);
            appHost.DeleteApplication();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\iisrunner\core\IApplicationPoolSetting.cs ===
[CODE: No readable text]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\iisrunner\core\CustomErrorsStep.cs ===
using System;
using System.Xml;
using System.Management;

using xonline.common.wmi.iisv2;
using xonline.common.xmlsequencer;

namespace xonline.tools.iisrunner.core
{
    /// <summary>
    /// Handles configuration of IIS Metabase access settings.
    /// </summary>
    /// <remarks>
    /// <para>
    /// This step handles the <c>&lt;CustomErrors&gt;</c> element in an IisRunner configuration file.
    /// It allows configuring custom errors for the parent IIS object of the element.
    /// </para><para>
    /// The following table lists the attributes supported by the <c>&lt;CustomErrors&gt;</c> element
    /// and a brief description of their meaning. For more information, see the IIS metabase 
    /// documentation at http://msdn.microsoft.com/library/default.asp?url=/library/en-us/iissdk/html/6a940e0e-4b75-4dc4-9606-8d98864333ce.asp.
    /// </para>
    /// <para>
    /// This step expects to have &lt;CustomError&gt; elements under it that define the specific custom errors. The expected attributes of
    /// these sub elements are:
    /// </para>
    /// <list type="table">
    /// <listheader>
    ///     <term>Attribute</term>
    ///     <description>Description</description>
    /// </listheader>
    /// <item>
    ///     <term>errorCode</term>
    ///     <description>This attribute specifies the HTTP error code, for example, "401". Error 401 is a server or DNS error.</description>
    /// </item>
    /// <item>
    ///     <term>errorSubCode</term>
    ///     <description>This attribute specifies the HTTP error subcode, for example, "5". Error 401-5 is a failure to authorize by an ISAPI or CGI application.</description>
    /// </item>
    /// <item>
    ///     <term>handlerType</term>
    ///     <description>This attribute The HandlerType property specifies whether the error page is a "FILE" or a "URL".</description>
    /// </item>
    /// <item>
    ///     <term>handlerLocation</term>
    ///     <description>
    ///     The handlerLocation attribute specifies the location of the error page. If handlerType is a file, then handlerLocation must be the 
    ///     absolute or relative path to the file. If HandlerType is a URL, then HandlerLocation must be the absolute or relative URL for the Web page.
    ///     </description>
    /// </item>
    /// </list> 
    ///</remarks>
    [StepElement("CustomErrors")]
    public class CustomErrorsStep : Step
    {
        public CustomErrorsStep(XmlElement stepElement, StepContainer parent) : base(stepElement, parent)
        {
        }

        public IisRunnerStep IisRunnerStep
        {
            get 
            {
                if (!(Root is IisRunnerStep))
                {
                    throw new InvalidOperationException("The root step must be IisRunnerStep for WebServerSetup to function correctly."); 
                }
                return (IisRunnerStep) Root;
            }
        }

        protected override void OnExecute()
        {
            base.OnExecute ();

            Root.LogMessage("Adding custom errors.");

            CustomError[] errors = GetCustomErrors();

            ManagementBaseObject directory = StepNavigation.GetAncestorDirectorySettingObject(this);
            ManagementBaseObject[] httpErrors = new ManagementBaseObject[errors.Length];

            for (int errorIndex = 0; errorIndex < httpErrors.Length; errorIndex++)
            {
                ManagementPath mPath = new ManagementPath();
                mPath.ClassName = "HttpError";
                mPath.NamespacePath = "root\\MicrosoftIISv2";

                httpErrors[errorIndex] = new ManagementClass(IisRunnerStep.IisManagementScope, mPath, null).CreateInstance();
                httpErrors[errorIndex]["HttpErrorCode"] = errors[errorIndex].ErrorCode;
                httpErrors[errorIndex]["HttpErrorSubcode"] = errors[errorIndex].ErrorSubcode;
                httpErrors[errorIndex]["HandlerType"] = errors[errorIndex].HandlerType;
                httpErrors[errorIndex]["HandlerLocation"] = errors[errorIndex].HandlerLocation;
            }

            directory["HttpErrors"] = httpErrors;
        }

        public override void Validate()
        {
            GetCustomErrors();
            base.Validate ();
        }

        private CustomError[] GetCustomErrors()
        {
            XmlNodeList errorNodes = BaseXmlElement.SelectNodes("sequencens:CustomError", Root.NamespaceManager);
            CustomError[] customErrors = new CustomError[errorNodes.Count];

            for (int i = 0; i < errorNodes.Count; i++)
            {
                XmlElement errorElement = (XmlElement) errorNodes[i];

                customErrors[i].ErrorCode = errorElement.GetAttribute("errorCode");
                if (customErrors[i].ErrorCode.Length == 0)
                {
                    throw new ArgumentException("CustomError node detected without required errorCode attribute.");
                }

                customErrors[i].ErrorSubcode = errorElement.GetAttribute("errorSubCode");
                if (customErrors[i].ErrorSubcode.Length == 0)
                {
                    throw new ArgumentException("CustomError node detected without required errorCodeSubcode attribute.");
                }

                customErrors[i].HandlerType = errorElement.GetAttribute("handlerType").ToUpper();
                if (customErrors[i].HandlerType.Length == 0)
                {
                    throw new ArgumentException("CustomError node detected without required handlerType attribute.");
                }

                if ((customErrors[i].HandlerType != "URL") && (customErrors[i].HandlerType != "FILE"))
                {
                    throw new ArgumentException("CustomError node detected with a handlerType attribute that does not match allowed values \"URL\" or \"FILE\".");
                }

                customErrors[i].HandlerLocation = errorElement.GetAttribute("handlerLocation");
                if (customErrors[i].HandlerLocation.Length == 0)
                {
                    throw new ArgumentException("CustomError node detected without required handlerLocation attribute.");
                }
            }

            return customErrors;
        }
    
        private struct CustomError
        {
            public string ErrorCode;
            public string ErrorSubcode;
            public string HandlerType;
            public string HandlerLocation;
        }
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\iisrunner\core\DeleteVirtualDirStep.cs ===
using System;
using System.Xml;
using Microsoft.Win32;
using System.Management;
using System.Data.SqlClient;

using xonline.common.wmi.iisv2;
using xonline.common.xmlsequencer;

namespace xonline.tools.iisrunner.core
{
    /// <summary>
    /// Summary description for DeleteVirtualDirStep.
    /// </summary>
    [StepElement("DeleteVirtualDir")]
    public class DeleteVirtualDirStep : Step
    {
        private string name = null;

        /// <summary>
        /// 
        /// </summary>
        /// <param name="stepElement"></param>
        /// <param name="parent"></param>
        public DeleteVirtualDirStep(XmlElement stepElement, StepContainer parent) : base(stepElement, parent)
        {
            name = BaseXmlElement.GetAttribute("name");

            if (!name.StartsWith("/"))
            {
                throw new ArgumentException("The name attribute of the " + stepElement.Name + " element must be specified and begin with a /.", "name");
            }

        }

        /// <summary>
        /// 
        /// </summary>
        public int SiteId
        {
            get { return StepNavigation.GetWebServerAncestorOfStep(this).SiteId; }
        }

        public string Name
        {
            get { return name; }
        }

        public string KeyName
        {
            get 
            {
                if (Name == "/")
                {
                    return "W3SVC/" + SiteId.ToString() + "/root";
                }
                else
                {
                    return "W3SVC/" + SiteId.ToString() + "/root" + Name;
                }
            }
        }

            /// <summary>
            /// 
            /// </summary>
            public IisRunnerStep IisRunnerStep
        {
            get 
            {
                if (!(Root is IisRunnerStep))
                {
                    throw new InvalidOperationException("The root step must be IisRunnerStep for DeleteWebVirtualDirectoryStep to function correctly."); 
                }
                return (IisRunnerStep) Root;
            }
        }

        protected override void OnExecute()
        {
            base.OnExecute ();

            Root.LogMessage("Deleting virtual directory at " + KeyName);

            ManagementScope mScope = IisRunnerStep.IisManagementScope;
            IIsWebVirtualDirSetting virtualDirSetting = new IIsWebVirtualDirSetting(mScope, KeyName);

            try
            {
                virtualDirSetting.Delete();
            }
            catch (System.IO.DirectoryNotFoundException)
            {
                // The vdir does not exist. Ignore the exception.
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\iisrunner\core\makefile.inc ===
!include $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\iisrunner\core\IApplicationHost.cs ===
using System;
using System.Management;

namespace xonline.tools.iisrunner.core
{
    public enum ApplicationMode
    {
        InProcess = 0,
        OutOfProcess = 1,
        Pooled = 2
    }

	/// <summary>
	/// Summary description for DirectorySettingStep.
	/// </summary>
    public interface IApplicationHost
	{
        void CreateApplication(ApplicationMode appMode, string appPoolName);
        void DeleteApplication();
        ManagementBaseObject DirectorySettingObject
        {
            get;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\iisrunner\core\FilterStep.cs ===
using System;
using System.IO;
using System.Xml;
using System.Management;
using System.Data.SqlClient;

using xonline.common.wmi.iisv2;
using xonline.common.xmlsequencer;

namespace xonline.tools.iisrunner.core
{
    [StepElement("Filter")]
    public class FilterStep : Step
    {
        private string _name = null;
        private string _path = null;

        public FilterStep(XmlElement stepElement, StepContainer parent) : base(stepElement, parent)
        {
            _name = BaseXmlElement.GetAttribute("name");
            _path = BaseXmlElement.GetAttribute("path");

            if (_name.Length == 0)
            {
                throw new ArgumentException("The name attribute of the filter element must be specified.", "name");
            }

            if (_path.Length == 0)
            {
                throw new ArgumentException("The path attribute of the filter element must be specified and must be a valid file system path.", "path");
            }
        }


        /// <summary>
        /// 
        /// </summary>
        public IisRunnerStep IisRunnerStep
        {
            get 
            {
                if (!(Root is IisRunnerStep))
                {
                    throw new InvalidOperationException("The root step must be IisRunnerStep for this step to function correctly."); 
                }
                return (IisRunnerStep) Root;
            }
        }

        protected override void OnExecute()
        {
            AddFilter(_name, _path);

            base.OnExecute ();
        }

        protected void AddFilter(string name, string path)
        {
            WebServerStep webserver = StepNavigation.GetWebServerAncestorOfStep(this);
            string folderPath = string.Format("W3SVC/{0}/Filters", webserver.SiteId);
            string filterPath = folderPath + "/" + name;

            Root.LogMessage(
                String.Format("Adding filter {0} ({1}).",
                name,
                path));

            //
            // append new filter to the end of load order
            //
            IIsFiltersSetting folder = new IIsFiltersSetting(folderPath);
            string loadOrder = folder.FilterLoadOrder;
            if (loadOrder.IndexOf(name) == -1)
            {
                if (loadOrder.Length > 0)
                {
                    loadOrder += ",";
                }

                loadOrder += name;

                folder.FilterLoadOrder = loadOrder;
            }

            //
            // create the new filter
            //
            IIsFilter filter = IIsFilter.CreateInstance();
            filter.LateBoundObject["Name"] = filterPath;
            filter.CommitObject();

            //
            // configure the new filter
            //
            IIsFilterSetting fs = new IIsFilterSetting(filterPath);
            fs.FilterPath = path;
            fs.FilterDescription = name;
            fs.FilterEnabled = true;
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\iisrunner\core\DeleteWebServerStep.cs ===
using System;
using System.Xml;
using Microsoft.Win32;
using System.Management;
using System.Data.SqlClient;

using xonline.common.wmi.iisv2;
using xonline.common.xmlsequencer;

namespace xonline.tools.iisrunner.core
{
	/// <summary>
	/// Summary description for DeleteDeleteWebServerStep.
	/// </summary>
	[StepElement("DeleteWebServer")]
	public class DeleteWebServerStep : Step
	{
        private int siteId = 0;

        /// <summary>
        /// 
        /// </summary>
        /// <param name="stepElement"></param>
        /// <param name="parent"></param>
		public DeleteWebServerStep(XmlElement stepElement, StepContainer parent) : base(stepElement, parent)
		{
            try
            {
                siteId = Convert.ToInt32(BaseXmlElement.GetAttribute("siteId"));
            }
            catch (FormatException)
            {
                throw new ArgumentOutOfRangeException("siteId", BaseXmlElement.GetAttribute("siteId"), "A numeric siteId attribute is required for a " + BaseXmlElement.Name + " element.");
            }
        }

        /// <summary>
        /// 
        /// </summary>
		public int SiteId
		{
            get { return siteId; }
		}

        /// <summary>
        /// 
        /// </summary>
        public IisRunnerStep IisRunnerStep
        {
            get 
            {
                if (!(Root is IisRunnerStep))
                {
                    throw new InvalidOperationException("The root step must be IisRunnerStep for DeleteWebServerStep to function correctly."); 
                }
                return (IisRunnerStep) Root;
            }
        }

        protected override void OnExecute()
        {
            base.OnExecute ();

            string keyName = "W3SVC/" + SiteId.ToString();
            Root.LogMessage("Deleting web server at " + keyName);

            ManagementScope mScope = IisRunnerStep.IisManagementScope;
            IIsWebServerSetting webServerSetting = new IIsWebServerSetting(mScope, keyName);

            try
            {
                webServerSetting.Delete();
            }
            catch (System.IO.DirectoryNotFoundException)
            {
                // The web server does not exist. Ignore the exception.
            }

            // If the site was registered with CMS, remove the EntryPoint information
            RegistryKey entryPoints = Registry.LocalMachine.OpenSubKey(@"SOFTWARE\NCompass\Resolution Content Server\Configuration\0\EntryPoints\", true);

            if (entryPoints != null)
            {
                entryPoints.DeleteSubKey(siteId.ToString(), false);
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\iisrunner\core\LoggingStep.cs ===
using System;
using System.Xml;
using System.Management;

using xonline.common.wmi.iisv2;
using xonline.common.xmlsequencer;

namespace xonline.tools.iisrunner.core
{
    /// <summary>
    /// Summary description for LoggingStep.
    /// </summary>
    [StepElement("Logging")]
    public class LoggingStep : Step
    {
        public LoggingStep(XmlElement stepElement, StepContainer parent) : base(stepElement, parent)
        {
        }

        protected override void OnExecute()
        {
            base.OnExecute ();

            IIsWebServerSetting webServer = StepNavigation.GetWebServerAncestorOfStep(this).WebServerSetting;

            string directory = BaseXmlElement.GetAttribute("directory");
            if (directory.Length > 0)
            {
                webServer.LogFileDirectory = directory;

                if (!System.IO.Directory.Exists(directory))
                {
                    System.IO.Directory.CreateDirectory(directory);
                }
            }

            if (String.Compare(BaseXmlElement.GetAttribute("localtimeRollover"), "true", true) == 0)
            {
                webServer.LogFileLocaltimeRollover = true;
            }
            else
            {
                webServer.LogFileLocaltimeRollover = false;
            }

            if (BaseXmlElement.GetAttribute("period").Length > 0)
            {
                webServer.LogFilePeriod = Convert.ToInt32(BaseXmlElement.GetAttribute("period"));
            }

            if (BaseXmlElement.GetAttribute("truncateSize").Length > 0)
            {
                webServer.LogFileTruncateSize = Convert.ToInt32(BaseXmlElement.GetAttribute("truncateSize"));
            }

            if (String.Compare(BaseXmlElement.GetAttribute("enabled"), "false", true) == 0)
            {
                webServer.LogType = 0;
            }
            else
            {
                webServer.LogType = 1;
            }

            webServer.LogPluginClsid = "{FF160663-DE82-11CF-BC0A-00AA006111E0}"; //W3C Extended Log File Format

            int extFileFlags = 0x0;

            if (String.Compare(BaseXmlElement.GetAttribute("extFileBytesRecv"), "true", true) == 0)
            {
                extFileFlags |= 0x2000;
            }

            if (String.Compare(BaseXmlElement.GetAttribute("extFileBytesSent"), "true", true) == 0)
            {
                extFileFlags |= 0x1000;
            }

            if (String.Compare(BaseXmlElement.GetAttribute("extFileClientIp"), "false", true) != 0)
            {
                extFileFlags |= 0x0004;
            }

            if (String.Compare(BaseXmlElement.GetAttribute("extFileComputerName"), "true", true) == 0)
            {
                extFileFlags |= 0x0020;
            }

            if (String.Compare(BaseXmlElement.GetAttribute("extFileCookie"), "true", true) == 0)
            {
                extFileFlags |= 0x20000;
            }

            if (String.Compare(BaseXmlElement.GetAttribute("extFileDate"), "false", true) != 0)
            {
                extFileFlags |= 0x0001;
            }

            if (String.Compare(BaseXmlElement.GetAttribute("extFileHost"), "true", true) == 0)
            {
                extFileFlags |= 0x00100000;
            }

            if (String.Compare(BaseXmlElement.GetAttribute("extFileHttpStatus"), "false", true) != 0)
            {
                extFileFlags |= 0x0400;
            }

            if (String.Compare(BaseXmlElement.GetAttribute("extFileHttpSubStatus"), "false", true) != 0)
            {
                extFileFlags |= 0x00200000;
            }

            if (String.Compare(BaseXmlElement.GetAttribute("extFileMethod"), "false", true) != 0)
            {
                extFileFlags |= 0x00000080;
            }

            if (String.Compare(BaseXmlElement.GetAttribute("extFileProtocolVersion"), "true", true) == 0)
            {
                extFileFlags |= 0x00080000;
            }

            if (String.Compare(BaseXmlElement.GetAttribute("extFileReferer"), "false", true) != 0)
            {
                extFileFlags |= 0x00040000;
            }

            if (String.Compare(BaseXmlElement.GetAttribute("extFileServerIp"), "true", true) == 0)
            {
                extFileFlags |= 0x00000040;
            }

            if (String.Compare(BaseXmlElement.GetAttribute("extFileServerPort"), "true", true) == 0)
            {
                extFileFlags |= 0x00008000;
            }

            if (String.Compare(BaseXmlElement.GetAttribute("extFileSiteName"), "true", true) == 0)
            {
                extFileFlags |= 0x00000010;
            }

            if (String.Compare(BaseXmlElement.GetAttribute("extFileTime"), "false", true) != 0)
            {
                extFileFlags |= 0x00000002;
            }

            if (String.Compare(BaseXmlElement.GetAttribute("extFileTimeTaken"), "true", true) == 0)
            {
                extFileFlags |= 0x00004000;
            }

            if (String.Compare(BaseXmlElement.GetAttribute("extFileUriQuery"), "false", true) != 0)
            {
                extFileFlags |= 0x00000200;
            }

            if (String.Compare(BaseXmlElement.GetAttribute("extFileUriStem"), "false", true) != 0)
            {
                extFileFlags |= 0x00000100;
            }

            if (String.Compare(BaseXmlElement.GetAttribute("extFileUserAgent"), "false", true) != 0)
            {
                extFileFlags |= 0x00010000;
            }

            if (String.Compare(BaseXmlElement.GetAttribute("extFileUserName"), "false", true) != 0)
            {
                extFileFlags |= 0x00000008;
            }

            if (String.Compare(BaseXmlElement.GetAttribute("extFileWin32Status"), "false", true) != 0)
            {
                extFileFlags |= 0x00000800;
            }

            webServer.LateBoundObject["LogExtFileFlags"] = extFileFlags;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\iisrunner\core\IisRunnerStep.cs ===
using System;
using System.IO;
using System.Xml;
using System.Management;

using xonline.common.xmlsequencer;

namespace xonline.tools.iisrunner.core
{
    public enum IisRunnerAction
    {
        Create,
        Modify,
        Delete
    }

	/// <summary>
	/// Provides the entry point for the IisRunner components.
	/// </summary>
	/// <remarks>
	///  This class provides the primary interface to process a IisRunner XML document. The IisRunner XML document defines 
	///  a sequential series of steps to configure IIS services, allowing the sequencing and intent of the setup actions
	///  to be seperated from the code that implements how to perform those actions.
    ///</remarks>
	public class IisRunnerStep : RootStepContainer
	{
        private ManagementScope iisManagementScope = null;

        /// <summary>
        /// Initializes a new instance of the IisRunnerStep class.
        /// </summary>
        /// <param name="stepElement">
        /// The IisRunner XmlElement that contains the attributes and steps (children elements) that define the 
        /// actions to take.
        /// </param>
        /// <exception cref="InvalidOperationException">The passed stepElement does not belong to the IisRunner namespace.</exception>
        /// <exception cref="ArgumentNullException">The passed stepElement was null.</exception>
		public IisRunnerStep(XmlElement stepElement) : base(stepElement)
		{
		}

        /// <summary>
        /// Gets the name of the XML namespace that all IisRunner elements must belong to.  
        /// </summary>
        public override string Namespace
        {
            get {return "http://www.xbox.com/iisrunner.xsd";}
        }

        public ManagementScope IisManagementScope
        {
            get
            {
                if (iisManagementScope == null)
                {
                    ConnectionOptions cnOpts = new ConnectionOptions();

                    iisManagementScope = new ManagementScope("\\\\"+ System.Environment.MachineName +"\\root\\MicrosoftIISv2", cnOpts);
                    iisManagementScope.Connect();
                }

                return iisManagementScope;
            }
        }
	
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\iisrunner\core\IDirectorySetting.cs ===
using System;
using System.Management;

namespace xonline.tools.iisrunner.core
{
	/// <summary>
	/// Summary description for DirectorySettingStep.
	/// </summary>
    interface IDirectorySetting
	{
        ManagementBaseObject DirectorySettingObject
        {
            get;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\iisrunner\core\HttpExpiresStep.cs ===
using System;
using System.Xml;
using System.Management;

using xonline.common.wmi.iisv2;
using xonline.common.xmlsequencer;

namespace xonline.tools.iisrunner.core
{
    /// <summary>
    /// Handles configuration of IIS Metabase HttpExpires settings.
    /// </summary>
    /// <remarks>
    /// <para>
    /// This step handles the <c>&lt;HttpExpires&gt;</c> element in an IisRunner configuration file.
    /// It allows configuring the Expires HTTP header sent for the parent Directory element.
    /// </para><para>
    /// The following table lists the attributes supported by the <c>&lt;HttpExpires&gt;</c> element
    /// and a brief description of their meaning. For more information, see the IIS metebase 
    /// documentation at http://msdn.microsoft.com/library/default.asp?url=/library/en-us/iissdk/html/91918b85-e053-4072-b93c-84afc4c0d56b.asp.
    /// </para>
    /// <para>
    /// Only one of the attributes can be specified, as they are mutually exclusive. Specify no attributes to set no expiration date.
    /// </para>
    /// <list type="table">
    /// <listheader>
    ///     <term>Attribute</term>
    ///     <description>Description</description>
    /// </listheader>
    /// <item>
    ///     <term>secondsUntilExpiration</term>
    ///     <description>The expires HTTP header will be dynamically set to the specified number of seconds past the requested time.</description>
    /// </item>
    /// <item>
    ///     <term>absoluteExpirationDate</term>
    ///     <description>A GMT date/time string (RFC1123 format is prefered). For example, Wed, 27 Jul 2005 07:00:00 GMT.</description>
    /// </item>
    /// </list> 
    ///</remarks>
    [StepElement("HttpExpires")]
    public class HttpExpiresStep : Step
    {
        public HttpExpiresStep(XmlElement stepElement, StepContainer parent) : base(stepElement, parent)
        {
        }

        protected override void OnExecute()
        {
            base.OnExecute ();

            ManagementBaseObject directory = StepNavigation.GetAncestorDirectorySettingObject(this);
            directory["HttpExpires"] = GetHttpExpiresString();
        }

        public override void Validate()
        {
            GetHttpExpiresString();
            base.Validate ();
        }

        private string GetHttpExpiresString()
        {
            string dynamic = BaseXmlElement.GetAttribute("secondsUntilExpiration");
            string absolute = BaseXmlElement.GetAttribute("absoluteExpirationDate");
            string httpExpires = "D, 0xFFFFFFFF";

            if ((dynamic.Length > 0) && (absolute.Length > 0))
            {
                throw new InvalidOperationException("Both secondsUntilExpiration and absoluteExpirationDate cannot be specified in the same HttpExpires step. Current step XML: " + BaseXmlElement.OuterXml);
            }

            if (dynamic.Length > 0)
            {
                int seconds = int.Parse(dynamic);
                httpExpires = string.Format("D, 0x{0:X8}", seconds);
            }

            if (absolute.Length > 0)
            {
                DateTime absoluteDate = DateTime.Parse(absolute);
                httpExpires = string.Format("S, {0:R}", absoluteDate);
            }

            return httpExpires;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\iisrunner\core\McmsApplicationStep.cs ===
using System;
using System.Xml;
using Microsoft.Win32;
using System.Management;
using System.DirectoryServices;

using xonline.common.wmi.iisv2;
using xonline.common.xmlsequencer;

namespace xonline.tools.iisrunner.core
{
    /// <summary>
    /// Summary description for McmsApplicationStep.
    /// </summary>
    [StepElement("McmsApplication")]
    public class McmsApplicationStep : Step
    {
        public McmsApplicationStep(XmlElement stepElement, StepContainer parent) : base(stepElement, parent)
        {
        }

        public IisRunnerStep IisRunnerStep
        {
            get 
            {
                if (!(Root is IisRunnerStep))
                {
                    throw new InvalidOperationException("The root step must be IisRunnerStep for WebServerSetup to function correctly."); 
                }
                return (IisRunnerStep) Root;
            }
        }

        public int ActiveCmsConfiguration
        {
            get
            {
                int activeCmsConfiguration = -1;

                try
                {
                    RegistryKey mcsmKey = Registry.LocalMachine.OpenSubKey(@"SOFTWARE\NCompass\Resolution Content Server\Configuration");
                    activeCmsConfiguration = (int) mcsmKey.GetValue("NextServerIndex") - 1;
                }
                catch (ArgumentException)
                {
                    activeCmsConfiguration = -1;
                }

                return activeCmsConfiguration;
            }
        }

        public string McmsRootPath
        {
            get
            {
                string mcmsRootPath = null;
                try
                {
                    RegistryKey mcmsKey = Registry.LocalMachine.OpenSubKey(@"SOFTWARE\NCompass\Resolution Content Server");
                    if (mcmsKey != null)
                    {
                        mcmsRootPath = (string) mcmsKey.GetValue("dir");
                    }
                }
                catch (ArgumentException) 
                {
                }
            
                return mcmsRootPath;
            }
        }
		
        public string McmsExeresPath
        {
            get
            {
                string mcmsExeresPath = null;

                try
                {
                    string keyName = String.Format(
                        @"SOFTWARE\NCompass\Resolution Content Server\Configuration\{0}\Local\Cache",
                        ActiveCmsConfiguration);

                    RegistryKey mcsmKey = Registry.LocalMachine.OpenSubKey(keyName);
                    mcmsExeresPath = (string) mcsmKey.GetValue("PhysicalExecPrefix");
                }
                catch (ArgumentException)
                {
                }

                return mcmsExeresPath;
            }
        }

        public string McmsRdonlyresPath
        {
            get
            {
                string mcmsRdonlyresPath = null;

                try
                {
                    string keyName = String.Format(
                        @"SOFTWARE\NCompass\Resolution Content Server\Configuration\{0}\Local\Cache",
                        ActiveCmsConfiguration);

                    RegistryKey mcsmKey = Registry.LocalMachine.OpenSubKey(keyName);
                    mcmsRdonlyresPath = (string) mcsmKey.GetValue("PhysicalReadPrefix");
                }
                catch (ArgumentException)
                {
                }

                return mcmsRdonlyresPath;
            }
        }

        protected override void OnExecute()
        {
            base.OnExecute ();

            bool readOnly = (String.Compare(BaseXmlElement.GetAttribute("readOnly"), "false") != 0);

            WebServerStep webServer = StepNavigation.GetWebServerAncestorOfStep(this);
            string rootKeyName = webServer.WebVirtualDirSetting.Name;

            if (ActiveCmsConfiguration == -1)
            {
                Root.LogMessage("MCMS is not installed. Skipping MCMS configuration for site " + rootKeyName + ".");
                return;
            }

            if (!readOnly)
            {
                CreateVirtualDir(rootKeyName + "/CMS", McmsRootPath + @"IIS_CMS", false);
                CreateVirtualDir(rootKeyName + "/webctrl_client", McmsRootPath + @"IIS_CMS\WebAuthor\Controls\webctrl_client", false);

                IIsWebVirtualDirSetting nr = CreateVirtualDir(rootKeyName + "/NR", McmsRootPath + @"IIS_NR", false);
                // Enable anonymous, basic, and NTLM authentication
                nr.LateBoundObject["AuthFlags"] = 0x00000007;
                nr.LateBoundObject["AccessFlags"] = 0x00000201;
                nr.LateBoundObject["DirBrowseFlags"] = 0x0000003e;
                nr.LateBoundObject["DontLog"] = false;
                nr.LateBoundObject["ContentIndexed"] = false;
                nr.CommitObject();

                IIsWebVirtualDirSetting mcms = CreateVirtualDir(rootKeyName + "/MCMS", McmsRootPath + @"MCMS", true);
                mcms.LateBoundObject["AuthFlags"] = 0x00000007;
                mcms.LateBoundObject["AccessFlags"] = 0x00000201;
                mcms.LateBoundObject["DirBrowseFlags"] = 0x0000003e;
                mcms.LateBoundObject["DontLog"] = false;
                mcms.LateBoundObject["ContentIndexed"] = false;
                mcms.CommitObject();

                CreateVirtualDir(rootKeyName + "/MCMS/CMS", McmsRootPath + @"IIS_CMS", false);
                CreateVirtualDir(rootKeyName + "/MCMS/SiteDeployment", McmsRootPath + @"MCMS\SiteDeployment", true);

                IIsWebVirtualDirSetting execres = CreateVirtualDir(rootKeyName + "/NR/ExeRes", McmsExeresPath, false);

                CreateWebDirectory(rootKeyName + "/NR/System", false);

                IIsWebDirectorySetting webDir = CreateWebDirectory(rootKeyName + "/NR/System/Access", false);
                webDir.LateBoundObject["AccessFlags"] = 0x00000200;
                webDir.CommitObject();
	
                webDir = CreateWebDirectory(rootKeyName + "/NR/System/ResUpload", true);
                webDir.LateBoundObject["AspMaxRequestEntityAllowed"] = 51200000;
                webDir.CommitObject();

                webDir = CreateWebDirectory(rootKeyName + "/NR/System/SDUpload", true);
                webDir.LateBoundObject["AspMaxRequestEntityAllowed"] = -198967296;
                webDir.CommitObject();

                // TODO: Figure out how to lock down the /NR/System/Staging
                // web directory to only allow access from the local machine.
                // For now, just disable it since we aren't using staging
                webDir = CreateWebDirectory(rootKeyName + "/NR/System/Staging", false);
                webDir.LateBoundObject["AccessFlags"] = 0x0;
                webDir.CommitObject();
            }
            else
            {
                CreateVirtualDir(rootKeyName + "/NR", McmsRootPath + @"IIS_NR_RO", false);
            }

            IIsWebVirtualDirSetting rdonlyres = CreateVirtualDir(rootKeyName + "/NR/RdOnlyRes", McmsRdonlyresPath, false);
            rdonlyres.DirBrowseFlags = 1073741824;
            rdonlyres.AccessFlags = 1;
            rdonlyres.ContentIndexed = false;
            // TODO: Figure out how to set the mime maps

            rdonlyres.CommitObject();

            // Register the site with CMS if installed
            RegistryKey entryPoints = Registry.LocalMachine.OpenSubKey(@"SOFTWARE\NCompass\Resolution Content Server\Configuration\0\EntryPoints", true);

            if (entryPoints != null)
            {
                RegistryKey entryPoint = entryPoints.CreateSubKey(webServer.SiteId.ToString());

                if (readOnly)
                {
                    entryPoint.SetValue("ReadOnlyServer", 1);
                }
                else
                {
                    entryPoint.SetValue("ReadOnlyServer", 0);
                }
            }
			
        }


        private IIsWebVirtualDirSetting CreateVirtualDir(string keyName, string path, bool createApplication)
        {
            ManagementScope mScope = IisRunnerStep.IisManagementScope;

            IIsWebVirtualDirSetting webVirtualDirSetting = WmiUtilities.FindWebVirtualDirSetting(mScope, keyName);

            if (webVirtualDirSetting == null)
            {
                IIsWebVirtualDir virtualDir = IIsWebVirtualDir.CreateInstance();
    
                virtualDir.LateBoundObject["Name"] = keyName;
                virtualDir.CommitObject();

                webVirtualDirSetting = WmiUtilities.FindWebVirtualDirSetting(mScope, keyName);
            }

            webVirtualDirSetting.Path0 = path;

            if (createApplication)
            {
                IIsWebVirtualDir virtualDir = new IIsWebVirtualDir(mScope, webVirtualDirSetting.Name);

                virtualDir.AppCreate2(2);

                while (keyName.EndsWith("/"))
                {
                    keyName = keyName.Substring(0, keyName.Length - 1);
                }

                string appName = keyName.Substring(keyName.LastIndexOf("/") + 1) + " Application";
                webVirtualDirSetting.AppFriendlyName = appName;
            }

            webVirtualDirSetting.CommitObject();
            return webVirtualDirSetting;
        }

        private IIsWebDirectorySetting CreateWebDirectory(string keyName, bool createApplication)
        {
            ManagementScope mScope = IisRunnerStep.IisManagementScope;

            IIsWebDirectorySetting webDirectorySetting = WmiUtilities.FindWebDirectorySetting(mScope, keyName);

            if (webDirectorySetting == null)
            {
                IIsWebDirectory webDirectory = IIsWebDirectory.CreateInstance();
    
                webDirectory.LateBoundObject["Name"] = keyName;
                webDirectory.CommitObject();

                webDirectorySetting = WmiUtilities.FindWebDirectorySetting(mScope, keyName);
            }

            if (createApplication)
            {
                IIsWebDirectory webDirectory = new IIsWebDirectory(mScope, webDirectorySetting.Name);

                webDirectory.AppCreate2(2);

                while (keyName.EndsWith("/"))
                {
                    keyName = keyName.Substring(0, keyName.Length - 1);
                }

                string appName = keyName.Substring(keyName.LastIndexOf("/") + 1) + " Application";
                webDirectorySetting.AppFriendlyName = appName;
            }

            webDirectorySetting.CommitObject();
            return webDirectorySetting;
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\iisrunner\core\PasswordChangeStep.cs ===
using System;
using System.Xml;
using System.Management;

using xonline.common.wmi.iisv2;
using xonline.common.xmlsequencer;

namespace xonline.tools.iisrunner.core
{
    /// <summary>
    /// Summary description for PasswordChangeStep.
    /// </summary>
    [StepElement("PasswordChange")]
    public class PasswordChangeStep : Step
    {
        public PasswordChangeStep(XmlElement stepElement, StepContainer parent) : base(stepElement, parent)
        {
        }

        protected override void OnExecute()
        {
            base.OnExecute ();

            WebServerStep webServer = StepNavigation.GetWebServerAncestorOfStep(this);
            ManagementBaseObject webServerBaseObject = webServer.WebServerSetting.LateBoundObject;

            int flags = 0;

            if (BaseXmlElement.GetAttribute("authAdvNotifyDisable").ToLower() == "true")
            {
                flags |= 0x00000004;
            }

            if (BaseXmlElement.GetAttribute("authChangeDisable").ToLower() == "true")
            {
                flags |= 0x00000002;
            }

            if (BaseXmlElement.GetAttribute("authChangeUnsecure").ToLower() == "true")
            {
                flags |= 0x00000001;
            }

            //webServerBaseObject["PasswordChangeFlags"] = flags;
            webServer.WebServerSetting.PasswordChangeFlags = flags;
            if (BaseXmlElement.GetAttribute("expirePrenotifyDays").Length > 0)
            {
                webServer.WebServerSetting.PasswordExpirePrenotifyDays = Convert.ToInt32(BaseXmlElement.GetAttribute("expirePrenotifyDays"));
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\iisrunner\core\MimeMapsStep.cs ===
using System;
using System.Xml;
using System.Management;

using xonline.common.wmi.iisv2;
using xonline.common.xmlsequencer;

namespace xonline.tools.iisrunner.core
{
    /// <summary>
    /// Handles configuration of IIS Metabase access settings.
    /// </summary>
    /// <remarks>
    /// <para>
    /// This step handles the <c>&lt;MimeMaps&gt;</c> element in an IisRunner configuration file.
    /// It allows configuring MIME elements for the parent IIS directory object (e.g. a directory or virtual directory) of the element.
    /// </para><para>
    /// The following table lists the attributes supported by the <c>&lt;MimeMaps&gt;</c> element
    /// and a brief description of their meaning. For more information, see the IIS metabase 
    /// documentation at http://msdn.microsoft.com/library/default.asp?url=/library/en-us/iissdk/html/b9b7a30c-5d24-4310-bb70-398c3129f6b3.asp.
    /// </para>
    /// <para>
    /// This step expects to have &lt;MimeMap&gt; elements under it that define the specific custom errors. The expected attributes of
    /// these sub elements are:
    /// </para>
    /// <list type="table">
    /// <listheader>
    ///     <term>Attribute</term>
    ///     <description>Description</description>
    /// </listheader>
    /// <item>
    ///     <term>extension</term>
    ///     <description>This attribute specifies the file extension to map to a MIME type.</description>
    /// </item>
    /// <item>
    ///     <term>type</term>
    ///     <description>This attribute specifies the MIME type to map to.</description>
    /// </item>
    /// </list> 
    ///</remarks>
    [StepElement("MimeMaps")]
    public class MimeMapsStep : Step
    {
        public MimeMapsStep(XmlElement stepElement, StepContainer parent) : base(stepElement, parent)
        {
        }

        public IisRunnerStep IisRunnerStep
        {
            get 
            {
                if (!(Root is IisRunnerStep))
                {
                    throw new InvalidOperationException("The root step must be IisRunnerStep for WebServerSetup to function correctly."); 
                }
                return (IisRunnerStep) Root;
            }
        }

        protected override void OnExecute()
        {
            base.OnExecute ();

            Root.LogMessage("Adding custom MimeMaps.");

            MimeMap[] maps = GetMimeMaps();

            ManagementBaseObject directory = StepNavigation.GetAncestorDirectorySettingObject(this);
            ManagementBaseObject[] mimeMaps = new ManagementBaseObject[maps.Length];

            for (int mapIndex = 0; mapIndex < maps.Length; mapIndex++)
            {
                ManagementPath mPath = new ManagementPath();
                mPath.ClassName = "MimeMap";
                mPath.NamespacePath = "root\\MicrosoftIISv2";

                mimeMaps[mapIndex] = new ManagementClass(IisRunnerStep.IisManagementScope, mPath, null).CreateInstance();
                mimeMaps[mapIndex]["Extension"] = maps[mapIndex].Extension;
                mimeMaps[mapIndex]["MimeType"] = maps[mapIndex].Type;
            }

            directory["MimeMap"] = mimeMaps;
        }

        public override void Validate()
        {
            GetMimeMaps();
            base.Validate ();
        }

        private MimeMap[] GetMimeMaps()
        {
            XmlNodeList mimeNodes = BaseXmlElement.SelectNodes("sequencens:MimeMap", Root.NamespaceManager);
            MimeMap[] mimeMaps = new MimeMap[mimeNodes.Count];

            for (int i = 0; i < mimeNodes.Count; i++)
            {
                XmlElement mapElement = (XmlElement) mimeNodes[i];

                mimeMaps[i].Extension = mapElement.GetAttribute("extension");
                if (mimeMaps[i].Extension.Length == 0)
                {
                    throw new ArgumentException("MimeMap node detected without required extension attribute.");
                }

                mimeMaps[i].Type = mapElement.GetAttribute("type");
                if (mimeMaps[i].Type.Length == 0)
                {
                    throw new ArgumentException("MimeMap node detected without required type attribute.");
                }
            }

            return mimeMaps;
        }
    
        private struct MimeMap
        {
            public string Extension;
            public string Type;
        }
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\iisrunner\core\ServerBindingStep.cs ===
using System;
using System.Xml;
using System.Management;

using xonline.common.wmi.iisv2;
using xonline.common.xmlsequencer;

namespace xonline.tools.iisrunner.core
{
    /// <summary>
    /// Adds additional server bindings to the parent Web Server.
    /// </summary>
    /// <remarks>
    /// <para>
    /// This step handles the <c>&lt;ServerBinding&gt;</c> element in an IisRunner configuration file.
    /// It allows adding additional server bindings to the parent web server.
    /// </para><para>
    /// The following table lists the attributes supported by the <c>&lt;ServerBinding&gt;</c> element
    /// and a brief description of their meaning. For more information, see the IIS metabase 
    /// documentation at http://msdn.microsoft.com/library/default.asp?url=/library/en-us/iissdk/html/3a4c46ee-a2be-413b-b56b-2717fa8ef3b7.asp.
    /// </para>
    /// <list type="table">
    /// <listheader>
    ///     <term>Attribute</term>
    ///     <description>Description</description>
    /// </listheader>
    /// <item>
    ///     <term>ip</term>
    ///     <description>The IP address to bind to. If this attribute is not specified, the binding will be for any IP address.</description>
    /// </item>
    /// <item>
    ///     <term>port</term>
    ///     <description>The port to bind to. This attribute is required.</description>
    /// </item>
    /// <item>
    ///     <term>hostname</term>
    ///     <description>Specifies a hostname that must be in the Host part of the HTTP header for this binding to be active. If this attribute is not specified, the binding will be for all hostnames.</description>
    /// </item>
    /// </list> 
    ///</remarks>
    [StepElement("ServerBinding")]
    public class ServerBindingStep : Step
    {
        public ServerBindingStep(XmlElement stepElement, StepContainer parent) : base(stepElement, parent)
        {
        }

        public string Hostname
        {
            get {return BaseXmlElement.GetAttribute("hostname");}
        }

        public string IpAddress
        {
            get {return BaseXmlElement.GetAttribute("ip");}
        }

        public string Port
        {
            get 
            {
                string port = BaseXmlElement.GetAttribute("port");

                if (port == null)
                {
                    throw new ArgumentException("The port attribute of the " + BaseXmlElement.Name + " element must be specified.", "name");
                }

                return port;
            }
        }


        public IisRunnerStep IisRunnerStep
        {
            get 
            {
                if (!(Root is IisRunnerStep))
                {
                    throw new InvalidOperationException("The root step must be IisRunnerStep for ServerBinding to function correctly."); 
                }
                return (IisRunnerStep) Root;
            }
        }

        protected override void OnExecute()
        {
            base.OnExecute ();

            Root.LogMessage(String.Format(
                "Adding additional binding - IP={0}, Port={1}, Hostname={2}.", 
                (IpAddress == null) ? "*" : IpAddress,
                Port,
                (Hostname == null) ? "*" : Hostname));

            // get the existing bindings
            WebServerStep server = StepNavigation.GetWebServerAncestorOfStep(this);
            IIsWebServerSetting serverSetting = server.WebServerSetting;

            // copy existing bindings
            ManagementBaseObject[] oldBindings = serverSetting.ServerBindings;
            ManagementBaseObject[] siteBindings = new ManagementBaseObject[oldBindings.Length + 1];

            for (int i = 0; i < oldBindings.Length; i++)
            {
                ServerBinding siteBinding = ServerBinding.CreateInstance();
                siteBinding.IP = oldBindings[i].Properties["IP"].Value.ToString();
                siteBinding.Hostname = oldBindings[i].Properties["Hostname"].Value.ToString();
                siteBinding.Port = oldBindings[i].Properties["Port"].Value.ToString();
                siteBindings[i] = siteBinding.LateBoundObject;				                
            }

            // add the new binding
            ServerBinding newBinding = ServerBinding.CreateInstance();
            newBinding.IP = IpAddress;
            newBinding.Hostname = Hostname;
            newBinding.Port = Port;
            siteBindings[siteBindings.Length - 1] = newBinding.LateBoundObject;				

            serverSetting.ServerBindings = siteBindings;
        }

        public override void Validate()
        {
            int port = Convert.ToInt32(Port);
            base.Validate ();
        }
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\iisrunner\core\ScriptMapsStep.cs ===
using System;
using System.Xml;
using System.Management;
using System.Collections;

using xonline.common.wmi.iisv2;
using xonline.common.xmlsequencer;

namespace xonline.tools.iisrunner.core
{
    /// <summary>
    /// Handles configuration of IIS Metabase access settings.
    /// </summary>
    /// <remarks>
    /// <para>
    /// This step handles the <c>&lt;ScriptMaps&gt;</c> element in an IisRunner configuration file.
    /// It allows configuring script maps for the parent ApplicationStep object of the element.
    /// </para><para>
    /// The following table lists the attributes supported by the <c>&lt;ScriptMaps&gt;</c> element
    /// and a brief description of their meaning. For more information, see the IIS metabase 
    /// documentation at http://msdn.microsoft.com/library/default.asp?url=/library/en-us/iissdk/html/fb2fc296-4716-4717-a4ea-6c495acc6d2c.asp?frame=true.
    /// </para>
    /// <para>
    /// Note that this step will completely replace the script map settings of the Application it applies to, so you need to include
    /// the full set of script maps, not just additional script maps you want defined.
    /// <para>
    /// This step expects to have &lt;ScriptMap&gt; elements under it that define the specific script map. The expected attributes of
    /// these sub elements are:
    /// </para>
    /// <list type="table">
    /// <listheader>
    ///     <term>Attribute</term>
    ///     <description>Description</description>
    /// </listheader>
    ///     <term>extension</term>
    ///     <description>This attribute specifies the file name extension, such as .htm.</description>
    /// </item>
    /// <item>
    ///     <term>scriptProcessor</term>
    ///     <description>the full path to the DLL that will handle requests for the specified extension type.</description>
    /// </item>
    /// <item>
    ///     <term>scriptEngine</term>
    ///     <description>If set to true, scripts are allowed to run in directories given Script permission. If this attribute is set to false, then the script can only be run in directories that are flagged for Execute permission. Default is true.</description>
    /// </item>
    /// <item>
    ///     <term>checkPathInfo</term>
    ///     <description>
    ///     If set to true, the server attempts to access the PATH_INFO portion of the URL, as a file, before starting the scripting engine. 
    ///     If the file can't be opened, or doesn't exist, an error is returned to the client. If set to false, this check is not performed.
    ///     Default value is false.
    ///     </description>
    /// </item>
    /// <item>
    ///     <term>includedVerbs</term>
    ///     <description>Comma separated list of verbs that this script map will process.</description>
    /// </item>
    /// </list> 
    ///</remarks>
    [StepElement("ScriptMaps")]
    public class ScriptMapsStep : Step
    {
        public ScriptMapsStep(XmlElement stepElement, StepContainer parent) : base(stepElement, parent)
        {
        }

        public IisRunnerStep IisRunnerStep
        {
            get 
            {
                if (!(Root is IisRunnerStep))
                {
                    throw new InvalidOperationException("The root step must be IisRunnerStep for WebServerSetup to function correctly."); 
                }

                return (IisRunnerStep) Root;
            }
        }

        protected override void OnExecute()
        {
            base.OnExecute ();

            Root.LogMessage("Adding script maps.");

            ScriptMap[] maps = GetScriptMaps();

            ManagementBaseObject directory = StepNavigation.GetAncestorApplicationHost(this).DirectorySettingObject;
            ManagementBaseObject[] scriptMaps = new ManagementBaseObject[maps.Length];

            for (int mapIndex = 0; mapIndex < scriptMaps.Length; mapIndex++)
            {
                ManagementPath mPath = new ManagementPath();
                mPath.ClassName = "ScriptMap";
                mPath.NamespacePath = "root\\MicrosoftIISv2";

                scriptMaps[mapIndex] = new ManagementClass(IisRunnerStep.IisManagementScope, mPath, null).CreateInstance();
                scriptMaps[mapIndex]["Extensions"] = maps[mapIndex].Extension;
                scriptMaps[mapIndex]["Flags"] = maps[mapIndex].Flags.ToString();
                scriptMaps[mapIndex]["IncludedVerbs"] = maps[mapIndex].IncludedVerbs;
                scriptMaps[mapIndex]["ScriptProcessor"] = maps[mapIndex].ScriptProcessor;
            }

            directory["ScriptMaps"] = scriptMaps;
        }

        public override void Validate()
        {
            if (!(this.Parent is ApplicationStep))
            {
                throw new InvalidOperationException("A <ScriptMaps> step must be an immediate child of an <Application> step.");
            }

            GetScriptMaps();
            base.Validate();
        }

        private ScriptMap[] GetScriptMaps()
        {
            XmlNodeList mapNodes = BaseXmlElement.SelectNodes("sequencens:ScriptMap", Root.NamespaceManager);
            ScriptMap[] scriptMaps = new ScriptMap[mapNodes.Count];

            for (int i = 0; i < mapNodes.Count; i++)
            {
                XmlElement mapElement = (XmlElement) mapNodes[i];

                scriptMaps[i].Extension = mapElement.GetAttribute("extension");
                if (scriptMaps[i].Extension.Length == 0)
                {
                    throw new ArgumentException("ScriptMap node detected without required extension attribute.");
                }

                scriptMaps[i].IncludedVerbs = mapElement.GetAttribute("includedVerbs").ToUpper();
                if (scriptMaps[i].IncludedVerbs.Length == 0)
                {
                    throw new ArgumentException("ScriptMap node detected without required includedVerbs attribute.");
                }

                scriptMaps[i].ScriptProcessor = mapElement.GetAttribute("scriptProcessor");
                if (scriptMaps[i].ScriptProcessor.Length == 0)
                {
                    throw new ArgumentException("ScriptMap node detected without required scriptProcessor attribute.");
                }

                scriptMaps[i].Flags = 0x1;

                string scriptEngine = mapElement.GetAttribute("scriptEngine");
                if (string.Compare(scriptEngine, "false", true) == 0)
                {
                    scriptMaps[i].Flags &= ~0x1;
                }

                string checkPathInfo = mapElement.GetAttribute("checkPathInfo");
                if (string.Compare(checkPathInfo, "true", true) == 0)
                {
                    scriptMaps[i].Flags &= 0x4;
                }
            }

            return scriptMaps;
        }
    
        private struct ScriptMap
        {
            public string Extension;
            public string ScriptProcessor;
            public int Flags;
            public string IncludedVerbs;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\iisrunner\core\VirtualDirStep.cs ===
using System;
using System.IO;
using System.Xml;
using System.Management;
using System.Data.SqlClient;

using xonline.common.wmi.iisv2;
using xonline.common.xmlsequencer;

namespace xonline.tools.iisrunner.core
{
	/// <summary>
	/// Summary description for WebSeverStep.
	/// </summary>
	[StepElement("VirtualDir")]
	public class VirtualDirStep : StepContainer, IDirectorySetting, IApplicationHost
	{
        private string name = null;
        private string path = null;
        private string keyName = null;
        private IIsWebVirtualDir virtualDir = null;
        private IIsWebVirtualDirSetting webVirtualDirSetting = null;

        /// <summary>
        /// 
        /// </summary>
        /// <param name="stepElement"></param>
        /// <param name="parent"></param>
		public VirtualDirStep(XmlElement stepElement, StepContainer parent) : base(stepElement, parent)
		{
            name = BaseXmlElement.GetAttribute("name");
            path = BaseXmlElement.GetAttribute("path");

            if (name.Length == 0)
            {
                throw new ArgumentException("The name attribute of the virtualDirectory element must be specified.", "name");
            }

            if (path.Length == 0)
            {
                throw new ArgumentException("The path attribute of the virtualDirectory element must be specified and must be a valid file system path.", "path");
            }
        }

        /// <summary>
        /// 
        /// </summary>
        public int SiteId
        {
            get { return StepNavigation.GetWebServerAncestorOfStep(this).SiteId; }
        }

        public string Name
        {
            get {return name;}
        }

        public string Path
        {
            get {return path;}
        }

        public string KeyName
        {
            get 
            {
                if (keyName == null)
                {
                    ManagementBaseObject directory = StepNavigation.GetAncestorDirectorySettingObject(this);

                    keyName = directory["Name"] + "/" + Name;
                }

                return keyName;
            }
        }

        public IIsWebVirtualDirSetting WebVirtualDirSetting
        {
            get {return webVirtualDirSetting;}
        }

        /// <summary>
        /// 
        /// </summary>
        public IisRunnerStep IisRunnerStep
        {
            get 
            {
                if (!(Root is IisRunnerStep))
                {
                    throw new InvalidOperationException("The root step must be IisRunnerStep for this step to function correctly."); 
                }
                return (IisRunnerStep) Root;
            }
        }

        protected override void OnExecute()
        {
            ManagementScope mScope = IisRunnerStep.IisManagementScope;

            webVirtualDirSetting = WmiUtilities.FindWebVirtualDirSetting(mScope, KeyName);

            if (WebVirtualDirSetting == null)
            {
                Root.LogMessage(
                    String.Format("Creating virtual directory {0} with its web files at {1}.",
                    Name,
                    Path));

                if (!Directory.Exists(Path))
                {
                    Directory.CreateDirectory(Path);
                }

                virtualDir = IIsWebVirtualDir.CreateInstance();
    
                virtualDir.LateBoundObject["Name"] = KeyName;
                virtualDir.CommitObject();

                webVirtualDirSetting = WmiUtilities.FindWebVirtualDirSetting(mScope, KeyName);
            }

            WebVirtualDirSetting.Path0 = Path;

            // let contained steps execute
            base.OnExecute ();
        }

        protected override void OnAfterExecute()
        {
            ManagementScope mScope = IisRunnerStep.IisManagementScope;

            if (WebVirtualDirSetting != null)
            {
                WebVirtualDirSetting.CommitObject();
            }

            webVirtualDirSetting = null;
            base.OnAfterExecute ();
        }


        #region IDirectorySetting Members

        /// <summary>
        /// Gets the ManagementBaseObject for the IIsWebVirtualDirSetting WMI interface for the root VDir
        /// defined for this VirtualDirStep.
        /// </summary>
        public ManagementBaseObject DirectorySettingObject
        {
            get
            {
                if (WebVirtualDirSetting == null)
                {
                    throw new InvalidOperationException("DirectorySettingsObject is only valid during the execute phase of this object.");
                }

                return WebVirtualDirSetting.LateBoundObject;
            }
        }

        #endregion

        #region IApplicationHost Members

        public void CreateApplication(ApplicationMode appMode, string appPoolName)
        {
            ManagementScope mScope = IisRunnerStep.IisManagementScope;

            if (WebVirtualDirSetting == null)
            {
                throw new InvalidOperationException("CreateApplication is only valid during the execute phase of this object.");
            }

            IIsWebVirtualDir virtualDir = new IIsWebVirtualDir(mScope, KeyName);

            if ((appPoolName == null) || (appPoolName.Length == 0))
            {
                virtualDir.AppCreate2((int) appMode);
            }
            else
            {
                virtualDir.AppCreate3((int) appMode, appPoolName, false);

                // Need to also set the WebVirtualDirSetting AppPoolId property
                // because it will overwrite the AppPoolId set by AppCreate3
                // when it the WebVirtualDirSetting object is later commited.

                WebVirtualDirSetting.LateBoundObject["AppPoolId"] = appPoolName;
            }

             WebVirtualDirSetting.LateBoundObject["AppFriendlyName"] = Name + " Application";
            
        }

        public void DeleteApplication()
        {
            ManagementScope mScope = IisRunnerStep.IisManagementScope;

            if (WebVirtualDirSetting == null)
            {
                throw new InvalidOperationException("DeleteApplication is only valid during the execute phase of this object.");
            }

            IIsWebVirtualDir virtualDir = new IIsWebVirtualDir(mScope, KeyName);

            virtualDir.AppDelete(false);
        }

        #endregion

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\iisrunner\core\SecureBindingStep.cs ===
using System;
using System.Xml;
using System.Management;
using System.Runtime.InteropServices;

using xonline.common.wmi.iisv2;
using xonline.common.xmlsequencer;
using xonline.common.service;
using xonline.common.config;

namespace xonline.tools.iisrunner.core
{
    /// <summary>
    /// Summary description for SSLCertStep.
    /// </summary>

    [StepElement("SecureBinding")]
    public class SecureBindingStep : Step
    {
        public SecureBindingStep(XmlElement stepElement, StepContainer parent) : base(stepElement, parent)
        {
        }

        public string IpAddress
        {
            get {return BaseXmlElement.GetAttribute("ip");}
        }

        public string Port
        {
            get 
            {
                string port = BaseXmlElement.GetAttribute("port");

                if (port == null || port.Length==0)
                {
                    port = "443";
                }

                return port;
            }
        }


        public IisRunnerStep IisRunnerStep
        {
            get 
            {
                if (!(Root is IisRunnerStep))
                {
                    throw new InvalidOperationException("The root step must be IisRunnerStep for SecureBinding to function correctly."); 
                }
                return (IisRunnerStep) Root;
            }
        }

        protected override void OnExecute()
        {
            base.OnExecute ();

            Root.LogMessage(String.Format(
                "Adding secure binding - IP={0}, Port={1}.", 
                (IpAddress == null) ? "*" : IpAddress,
                Port));

            WebServerStep server = StepNavigation.GetWebServerAncestorOfStep(this);

            server.SecureBinding = IpAddress + ":" + Port + ":";;
        }

        public override void Validate()
        {
            base.Validate ();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\iisrunner\core\StepNavigation.cs ===
using System;
using System.Management;

using xonline.common.xmlsequencer;

namespace xonline.tools.iisrunner.core
{
	/// <summary>
	/// Summary description for StepNavigation.
	/// </summary>
	public class StepNavigation
	{
        /// <summary>
        /// 
        /// </summary>
        /// <param name="startStep"></param>
        /// <returns></returns>
        static public WebServerStep GetWebServerAncestorOfStep(Step startStep)
        {
            Step currentStep = startStep.Parent;

            while (currentStep != null)
            {
                if (currentStep is WebServerStep)
                {
                    return (WebServerStep) currentStep;
                }

                currentStep = currentStep.Parent;
            }

            throw new InvalidOperationException("No WebServerStep present in the hierarchy above the passed step.");
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="startStep"></param>
        /// <returns></returns>
        static public ApplicationPoolStep GetApplicationPoolAncestorOfStep(Step startStep)
        {
            Step currentStep = startStep.Parent;

            while (currentStep != null)
            {
                if (currentStep is ApplicationPoolStep)
                {
                    return (ApplicationPoolStep) currentStep;
                }

                currentStep = currentStep.Parent;
            }

            throw new InvalidOperationException("No ApplicationPoolStep present in the hierarchy above the passed step.");
        }

        public static ManagementBaseObject GetAncestorDirectorySettingObject(Step startStep)
        {
            Step currentStep = startStep.Parent;

            while (currentStep != null)
            {
                if (currentStep is IDirectorySetting)
                {
                    return ((IDirectorySetting) currentStep).DirectorySettingObject;
                }

                currentStep = currentStep.Parent;
            }

            throw new InvalidOperationException("No step implementing IDirectorySetting present in the hierarchy above " + startStep.BaseXmlElement.OuterXml + ".");
            
        }

        public static IApplicationHost GetAncestorApplicationHost(Step startStep)
        {
            Step currentStep = startStep.Parent;

            while (currentStep != null)
            {
                if (currentStep is IApplicationHost)
                {
                    return (IApplicationHost) currentStep;
                }

                currentStep = currentStep.Parent;
            }

            throw new InvalidOperationException("No step implementing IApplicationHost present in the hierarchy above " + startStep.BaseXmlElement.OuterXml + ".");
            
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\iisrunner\core\WebDirectoryStep.cs ===
using System;
using System.IO;
using System.Xml;
using System.Management;
using System.Data.SqlClient;

using xonline.common.wmi.iisv2;
using xonline.common.xmlsequencer;

namespace xonline.tools.iisrunner.core
{
	/// <summary>
	/// Summary description for WebDirectoryStep.
	/// </summary>
	[StepElement("WebDirectory")]
	public class WebDirectoryStep : StepContainer, IDirectorySetting, IApplicationHost
	{
        private string name = null;
        private string keyName = null;
        private IIsWebDirectorySetting webDirectorySetting = null;

        /// <summary>
        /// 
        /// </summary>
        /// <param name="stepElement"></param>
        /// <param name="parent"></param>
		public WebDirectoryStep(XmlElement stepElement, StepContainer parent) : base(stepElement, parent)
		{
            name = BaseXmlElement.GetAttribute("name");

            if (name.Length == 0)
            {
                throw new ArgumentException("The name attribute of the " + BaseXmlElement.Name + " element must be specified.", "name");
            }
        }

        /// <summary>
        /// 
        /// </summary>
        public int SiteId
        {
            get { return StepNavigation.GetWebServerAncestorOfStep(this).SiteId; }
        }

        public string Name
        {
            get {return name;}
        }

        public string KeyName
        {
            get 
            {
                if (keyName == null)
                {
                    ManagementBaseObject directory = StepNavigation.GetAncestorDirectorySettingObject(this);

                    keyName = directory["Name"] + "/" + Name;
                }

                return keyName;
            }
        }

        public IIsWebDirectorySetting WebDirectorySetting
        {
            get {return webDirectorySetting;}
        }

        /// <summary>
        /// 
        /// </summary>
        public IisRunnerStep IisRunnerStep
        {
            get 
            {
                if (!(Root is IisRunnerStep))
                {
                    throw new InvalidOperationException("The root step must be IisRunnerStep for this step to function correctly."); 
                }
                return (IisRunnerStep) Root;
            }
        }

        protected override void OnExecute()
        {
            ManagementScope mScope = IisRunnerStep.IisManagementScope;

            webDirectorySetting = WmiUtilities.FindWebDirectorySetting(mScope, KeyName);

            if (WebDirectorySetting == null)
            {
                Root.LogMessage(String.Format("Creating web directory {0}.", Name));

                IIsWebDirectory directory = IIsWebDirectory.CreateInstance();
    
                directory.LateBoundObject["Name"] = KeyName;
                directory.CommitObject();

                webDirectorySetting = WmiUtilities.FindWebDirectorySetting(mScope, KeyName);
            }

            // create the directory if it doesn't exist

            string path = Name;
            Step pathStep = this.Parent;

            while (pathStep != null)
            {
                WebDirectoryStep wdStep = pathStep as WebDirectoryStep;
                VirtualDirStep vdStep = pathStep as VirtualDirStep;
                WebServerStep wsStep = pathStep as WebServerStep;

                if (wdStep != null)
                {
                    path = wdStep.Name + @"\" + path;
                }
                else if (vdStep != null)
                {
                    path = vdStep.Path + @"\" + path;
 
                    if (!Directory.Exists(path))
                    {
                        Directory.CreateDirectory(path);
                    }
                    break;
                }
                else if (wsStep != null)
                {
                    path = wsStep.WebrootPath + @"\" + path;

                    if (!Directory.Exists(path))
                    {
                        Directory.CreateDirectory(path);
                    }
                    break;
                }
                pathStep = pathStep.Parent;
            }

            // let contained steps execute
            base.OnExecute ();
        }

        protected override void OnAfterExecute()
        {
            ManagementScope mScope = IisRunnerStep.IisManagementScope;

            if (WebDirectorySetting != null)
            {
                WebDirectorySetting.CommitObject();
            }

            webDirectorySetting = null;
            base.OnAfterExecute ();
        }


        #region IDirectorySetting Members

        /// <summary>
        /// Gets the ManagementBaseObject for the IIsWebDirectorySetting WMI interface for the root VDir
        /// defined for this DirectoryStep.
        /// </summary>
        public ManagementBaseObject DirectorySettingObject
        {
            get
            {
                if (WebDirectorySetting == null)
                {
                    throw new InvalidOperationException("DirectorySettingsObject is only valid during the execute phase of this object.");
                }

                return WebDirectorySetting.LateBoundObject;
            }
        }

        #endregion

        #region IApplicationHost Members

        public void CreateApplication(ApplicationMode appMode, string appPoolName)
        {
            ManagementScope mScope = IisRunnerStep.IisManagementScope;

            if (WebDirectorySetting == null)
            {
                throw new InvalidOperationException("CreateApplication is only valid during the execute phase of this object.");
            }

            IIsWebDirectory virtualDir = new IIsWebDirectory(mScope, WebDirectorySetting.Name);

            if ((appPoolName == null) || (appPoolName.Length == 0))
            {
                virtualDir.AppCreate2((int) appMode);
            }
            else
            {
                virtualDir.AppCreate3((int) appMode, appPoolName, false);

                // Need to also set the WebVirtualDirSetting AppPoolId property
                // because it will overwrite the AppPoolId set by AppCreate3
                // when it the WebVirtualDirSetting object is later commited.

                WebDirectorySetting.LateBoundObject["AppPoolId"] = appPoolName;
            }

            WebDirectorySetting.LateBoundObject["AppFriendlyName"] = Name + " Application";
            
        }

        public void DeleteApplication()
        {
            ManagementScope mScope = IisRunnerStep.IisManagementScope;

            if (WebDirectorySetting == null)
            {
                throw new InvalidOperationException("DeleteApplication is only valid during the execute phase of this object.");
            }

            IIsWebDirectory virtualDir = new IIsWebDirectory(mScope, WebDirectorySetting.Name);

            virtualDir.AppDelete(false);
        }
        #endregion
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\iisrunner\core\SSLCertHashStep.cs ===
using System;
using System.Xml;
using System.Management;
using System.Runtime.InteropServices;

using xonline.common.wmi.iisv2;
using xonline.common.xmlsequencer;
using xonline.common.service;
using xonline.common.config;

namespace xonline.tools.iisrunner.core
{
    /// <summary>
    /// Summary description for SSLCertStep.
    /// </summary>

    [StepElement("SSLCertHash")]
    public class SSLCertHashStep : Step
    {
        public SSLCertHashStep(XmlElement stepElement, StepContainer parent) : base(stepElement, parent)
        {
        }

        public string CertName
        {
            get 
            {
                string certname = BaseXmlElement.GetAttribute("certname");

                if (certname == null)
                {
                    throw new ArgumentException("The SSLCert attribute of the " + BaseXmlElement.Name + " element must be specified.", "name");
                }

                return certname;
            }
        }

        public IisRunnerStep IisRunnerStep
        {
            get 
            {
                if (!(Root is IisRunnerStep))
                {
                    throw new InvalidOperationException("The root step must be IisRunnerStep for SSLCertHash to function correctly."); 
                }
                return (IisRunnerStep) Root;
            }
        }

        protected override void OnExecute()
        {
            base.OnExecute ();

            Root.LogMessage(String.Format(
                "Adding SSL server certificate, certname={0}.", 
                CertName));

            SSLCertConfig config = new SSLCertConfig(CertName);

            WebServerStep server = StepNavigation.GetWebServerAncestorOfStep(this);

            server.SSLCertHash = config.SSLCertHash;
        }

        public override void Validate()
        {
            base.Validate ();
        }
    }


    public class CertImpXAPI
    {
        #region Crypto API imports
  
        [DllImport("certimpx.dll", CharSet=CharSet.Unicode)] 
        public static extern string ImportCompletePFX(
            string  szCertPath,
            string  szCertPassword,
            bool    importClientCertInSystemStore
            );

        [DllImport("certimpx.dll", CharSet=CharSet.Unicode)] 
        public static extern string ImportCompleteSTL(
            string  szCertPath
            );

        [DllImport("certimpx.dll", CharSet=CharSet.Unicode)] 
        public static extern Int32  ImportCompleteP7B(
            string  szCertPath
            );

        #endregion    
    }

    public class SSLCertConfig
    {
        Byte[]      sslCertHash             = null;
        string      sslInfoIdentifier       = null;
        string      sslCertFilePath         = null;
        string      sslCertFilePassword     = null;

        public SSLCertConfig(string identifier)
        {
            sslInfoIdentifier = identifier;
        }

        public virtual string SSLInfoIdentifier
        {
            get
            {
                return sslInfoIdentifier;
            }
        }
    

        public virtual Byte[] SSLCertHash
        {
            get
            {
                string  szCertHash;

                if (sslCertHash == null)
                {
                    // Call our custom certimpx.dll to have the 
                    szCertHash = CertImpXAPI.ImportCompletePFX(SSLCertFilePath, SSLCertFilePassword, true);

                    if (szCertHash == null)
                    {
                        throw new ApplicationException("Unable to import SSL certificate from " + SSLCertFilePath);
                    }

                    sslCertHash = ByteConvert.FromString(szCertHash);
                }
										
                return sslCertHash;
            }
        }

      

        public virtual string SSLCertFilePath
        {
            get
            {
                if (sslCertFilePath == null)
                {
                    CSetupSecureResolver decoder = new CSetupSecureResolver();

                    sslCertFilePath = decoder.SSL_PFXFilePath(SSLInfoIdentifier);
                }
										
                return sslCertFilePath;
            }
        }

      
        public virtual string SSLCertFilePassword
        {
            get
            {

                if (sslCertFilePassword == null)
                {
                    CSetupSecureResolver decoder = new CSetupSecureResolver();

                    sslCertFilePassword = decoder.SSL_Secret(SSLInfoIdentifier);
                }
										
                return sslCertFilePassword;
            }
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\iisrunner\core\WmiUtilities.cs ===
using System;
using System.Management;

using xonline.common.wmi.iisv2;

namespace xonline.tools.iisrunner.core
{
	/// <summary>
	/// Summary description for WmiUtilities.
	/// </summary>
    public class WmiUtilities
    {
        public static IIsWebServerSetting FindWebServerSetting(ManagementScope mScope, string keyName)
        {
            IIsWebServerSetting.IIsWebServerSettingCollection items = IIsWebServerSetting.GetInstances(mScope, String.Format("Name=\"{0}\"", keyName));
    
            if (items.Count > 1)
            {
                throw new Exception("Multiple IIsWebServerSetting objects returned when only one was expected for key " + keyName + ".");
            }
            
            foreach (IIsWebServerSetting item in items)
            {
                return item;
            }

            return null;
        }
        
        public static IIsWebVirtualDirSetting FindWebVirtualDirSetting(ManagementScope mScope, string keyName)
        {
            IIsWebVirtualDirSetting.IIsWebVirtualDirSettingCollection items = IIsWebVirtualDirSetting.GetInstances(mScope, String.Format("Name=\"{0}\"", keyName));
    
            if (items.Count > 1)
            {
                throw new Exception("Multiple IIsWebVirtualDirSetting objects returned when only one was expected for key " + keyName + ".");
            }
            
            foreach (IIsWebVirtualDirSetting item in items)
            {
                return item;
            }

            return null;
        }

        public static IIsWebVirtualDir FindWebVirtualDir(ManagementScope mScope, string keyName)
        {
            IIsWebVirtualDir.IIsWebVirtualDirCollection items = IIsWebVirtualDir.GetInstances(mScope, String.Format("Name=\"{0}\"", keyName));
        
            if (items.Count > 1)
            {
                throw new Exception("Multiple IIsWebServerSetting objects returned when only one was expected for key " + keyName + ".");
            }
            
            foreach (IIsWebVirtualDir item in items)
            {
                return item;
            }
            return null;
        }


        public static IIsWebDirectorySetting FindWebDirectorySetting(ManagementScope mScope, string keyName)
        {
            IIsWebDirectorySetting.IIsWebDirectorySettingCollection items = IIsWebDirectorySetting.GetInstances(mScope, String.Format("Name=\"{0}\"", keyName));
    
            if (items.Count > 1)
            {
                throw new Exception("Multiple IIsWebDirectorySetting objects returned when only one was expected for key " + keyName + ".");
            }
            
            foreach (IIsWebDirectorySetting item in items)
            {
                return item;
            }

            return null;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\iisrunner\core\objd\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86__core_0_none_12.4.56.0_none_e91db01a1ac36ce1
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86__core_0_no-public-key_12.4.56.0_x-ww_c45deb65
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=_core_0
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86__core_0_no-public-key_12.4.56.0_x-ww_c45deb65
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86__core_0_no-public-key_12.4.56.0_x-ww_c45deb65.manifest
XP_MANIFEST_PATH=manifests\x86__core_0_no-public-key_12.4.56.0_x-ww_c45deb65.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86__core_0_no-public-key_12.4.56.0_x-ww_c45deb65.cat
XP_CATALOG_PATH=manifests\x86__core_0_no-public-key_12.4.56.0_x-ww_c45deb65.cat
XP_PAYLOAD_PATH=x86__core_0_no-public-key_12.4.56.0_x-ww_c45deb65
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=_core_0,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\iisrunner\installer\exe\obj\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("DEPOT")]
[assembly:System.Reflection.AssemblyCopyright("")]
[assembly:System.Reflection.AssemblyCompany("")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\iisrunner\core\obj\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86__core_0_none_12.4.56.0_none_e91db01a1ac36ce1
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86__core_0_no-public-key_12.4.56.0_x-ww_c45deb65
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=_core_0
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86__core_0_no-public-key_12.4.56.0_x-ww_c45deb65
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86__core_0_no-public-key_12.4.56.0_x-ww_c45deb65.manifest
XP_MANIFEST_PATH=manifests\x86__core_0_no-public-key_12.4.56.0_x-ww_c45deb65.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86__core_0_no-public-key_12.4.56.0_x-ww_c45deb65.cat
XP_CATALOG_PATH=manifests\x86__core_0_no-public-key_12.4.56.0_x-ww_c45deb65.cat
XP_PAYLOAD_PATH=x86__core_0_no-public-key_12.4.56.0_x-ww_c45deb65
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=_core_0,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\iisrunner\installer\exe\objd\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("DEPOT")]
[assembly:System.Reflection.AssemblyCopyright("")]
[assembly:System.Reflection.AssemblyCompany("")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\iisrunner\test\makefile.inc ===
!include $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\iisrunner\core\WebServerStep.cs ===
using System;
using System.IO;
using System.Xml;
using System.Management;
using System.DirectoryServices;
using System.ServiceProcess;
using System.Data.SqlClient;

using xonline.common.wmi.iisv2;
using xonline.common.xmlsequencer;

namespace xonline.tools.iisrunner.core
{
    /// <summary>
    /// Summary description for WebSeverStep.
    /// </summary>
    [StepElement("WebServer")]
    public class WebServerStep : StepContainer, IDirectorySetting, IApplicationHost
    {
        private int siteId = 0;
        private IIsWebServerSetting webServerSetting = null;
        private IIsWebVirtualDirSetting webVirtualDirSetting = null;

        /// <summary>
        /// 
        /// </summary>
        /// <param name="stepElement"></param>
        /// <param name="parent"></param>
        public WebServerStep(XmlElement stepElement, StepContainer parent) : base(stepElement, parent)
        {
            try
            {
                siteId = Convert.ToInt32(BaseXmlElement.GetAttribute("siteId"));
            }
            catch (FormatException)
            {
                throw new ArgumentOutOfRangeException("siteId", BaseXmlElement.GetAttribute("siteId"), "A numeric siteId attribute is required for a " + BaseXmlElement.Name + " element.");
            }
        }

        /// <summary>
        /// 
        /// </summary>
        public int SiteId
        {
            get { return siteId; }
        }

        public string SiteName
        {
            get {return BaseXmlElement.GetAttribute("name");}
        }

        public string Hostname
        {
            get {return BaseXmlElement.GetAttribute("hostname");}
        }

        public string IpAddress
        {
            get {return BaseXmlElement.GetAttribute("ip");}
        }

        public string Port
        {
            get {return BaseXmlElement.GetAttribute("port");}
        }

        public string WebrootPath
        {
            get {return BaseXmlElement.GetAttribute("webrootPath");}
        }

        public IIsWebServerSetting WebServerSetting
        {
            get {return webServerSetting;}
        }

        public IIsWebVirtualDirSetting WebVirtualDirSetting
        {
            get {return webVirtualDirSetting;}
        }

        public byte[] SSLCertHash
        {
            set
            {
                DirSvcObject.Invoke("Put", new object[] {"SSLCertHash", value});
                DirSvcObject.Properties["SSLStoreName"][0] = "my";
            }
        }

        public string SecureBinding
        {
            set
            {
                DirSvcObject.Properties["SecureBindings"].Clear();
                DirSvcObject.Properties["SecureBindings"].Add(value);
            }
            get
            {
                PropertyValueCollection bindings = DirSvcObject.Properties["SecureBindings"];
                return (bindings.Count==0)? string.Empty: (bindings[0] as string);
            }
        }

        protected DirectoryEntry DirSvcObject
        {
            get
            {
                if (_dirSvcObject==null)
                {
                    _dirSvcObject = new DirectoryEntry("IIS://localhost/w3svc/" + SiteId.ToString());
                }
                return _dirSvcObject;
            }
        }
        private DirectoryEntry _dirSvcObject = null;

        /// <summary>
        /// 
        /// </summary>
        public IisRunnerStep IisRunnerStep
        {
            get 
            {
                if (!(Root is IisRunnerStep))
                {
                    throw new InvalidOperationException("The root step must be IisRunnerStep for WebServerSetup to function correctly."); 
                }
                return (IisRunnerStep) Root;
            }
        }

        protected override void OnBeforeExecute()
        {
            base.OnBeforeExecute ();

            // We are sometimes getting the following error message in certain cases:
            // Win32: The service did not respond to the start or control request in a timely fashion.
            // If W3SVC is running, we don't get these errors. Since we always start W3SVC at the end of
            // this process anyway, and many of the steps will cause W3SVC to start, we're going to just
            // start the service now to make everything happy.

            ServiceController sc = new ServiceController("W3SVC");

            if (sc.Status == ServiceControllerStatus.Stopped)
            {
                Root.LogMessage("Starting W3SVC service.");

                sc.Start();

                try
                {
                    //wait 30 seconds for the service to start
                    sc.WaitForStatus(ServiceControllerStatus.Running, new TimeSpan(0, 0, 30));
                }
                catch(System.ServiceProcess.TimeoutException)
                {
                    Root.LogMessage(
                        "W3SVC service did not respond to the start command in a timely fashion. We'll attempt to still configure the metabase, but this may cause problems later in the process.");
                }
            }
        }

        protected override void OnExecute()
        {
            ManagementScope mScope = IisRunnerStep.IisManagementScope;

            string keyName = "W3SVC/" + SiteId.ToString();

            webServerSetting = WmiUtilities.FindWebServerSetting(mScope, keyName);

            if (WebServerSetting == null)
            {
                Root.LogMessage(
                    String.Format("Creating web server {0} with ID {1} at {2}:{3} with the webroot files at {4}.",
                    SiteName,
                    SiteId,
                    IpAddress,
                    Port,
                    WebrootPath
                    ));

                if (!Directory.Exists(WebrootPath))
                {
                    Directory.CreateDirectory(WebrootPath);
                }

                ManagementBaseObject[] siteBindings = new ManagementBaseObject[1];

                ServerBinding siteBinding = ServerBinding.CreateInstance();
                siteBinding.IP = IpAddress;
                siteBinding.Hostname = Hostname;
                siteBinding.Port = Port;
                siteBindings[0] = siteBinding.LateBoundObject;				

                IIsWebService webService = new IIsWebService(mScope, "W3SVC");
                webService.CreateNewSite(WebrootPath, siteBindings, SiteName, SiteId);

                webServerSetting = WmiUtilities.FindWebServerSetting(mScope, keyName);
            }

            webVirtualDirSetting = WmiUtilities.FindWebVirtualDirSetting(mScope, keyName + "/root");

            WebVirtualDirSetting.AppFriendlyName = SiteName + " Application";

            // let contained steps execute
            base.OnExecute ();
        }

        protected override void OnAfterExecute()
        {
            ManagementScope mScope = IisRunnerStep.IisManagementScope;

            string keyName = "W3SVC/" + SiteId.ToString();

            if (WebVirtualDirSetting != null)
            {
                WebVirtualDirSetting.CommitObject();
            }

            if (WebServerSetting != null)
            {
                WebServerSetting.CommitObject();
            }

            if (_dirSvcObject!=null)
            {
                _dirSvcObject.CommitChanges();
            }

            IIsWebServer webServer = new IIsWebServer(mScope, keyName);

            try
            {
                webServer.Start();
            }
            catch (System.Runtime.InteropServices.COMException ex)
            {
                Root.LogMessage("Couldn't start site " + SiteName + ". Consult IIS Manager to determine cause of error (probably due to this site's bindings conflicting with an existing site).");
                Root.LogMessage("Full exception information: " + ex.ToString());
            }

            Root.LogMessage("Create of web site complete");

            webServerSetting = null;
            base.OnAfterExecute ();
        }

        #region IDirectorySetting Members

        /// <summary>
        /// Gets the ManagementBaseObject for the IIsWebServerSetting WMI interface for the root VDir
        /// defined for this WebServerStep.
        /// </summary>
        public ManagementBaseObject DirectorySettingObject
        {
            get
            {
                if (WebVirtualDirSetting == null)
                {
                    throw new InvalidOperationException("DirectorySettingsObject is only valid during the execute phase of this object.");
                }

                return WebVirtualDirSetting.LateBoundObject;
            }
        }

        #endregion

        #region IApplicationHost Members

        public void CreateApplication(ApplicationMode appMode, string appPoolName)
        {
            ManagementScope mScope = IisRunnerStep.IisManagementScope;

            if (WebVirtualDirSetting == null)
            {
                throw new InvalidOperationException("CreateApplication is only valid during the execute phase of this object.");
            }

            IIsWebVirtualDir virtualDir = new IIsWebVirtualDir(mScope, WebVirtualDirSetting.Name);

            if ((appPoolName == null) || (appPoolName.Length == 0))
            {
                virtualDir.AppCreate2((int) appMode);
            }
            else
            {
                virtualDir.AppCreate3((int) appMode, appPoolName, false);

                // Need to also set the WebVirtualDirSetting AppPoolId property
                // because it will overwrite the AppPoolId set by AppCreate3
                // when it the WebVirtualDirSetting object is later commited.

                WebVirtualDirSetting.LateBoundObject["AppPoolId"] = appPoolName;
            }

            WebVirtualDirSetting.LateBoundObject["AppFriendlyName"] = SiteName + " Application";
            
        }

        public void DeleteApplication()
        {
            ManagementScope mScope = IisRunnerStep.IisManagementScope;

            if (WebVirtualDirSetting == null)
            {
                throw new InvalidOperationException("DeleteApplication is only valid during the execute phase of this object.");
            }

            IIsWebVirtualDir virtualDir = new IIsWebVirtualDir(mScope, WebVirtualDirSetting.Name);

            virtualDir.AppDelete(false);
        }
        #endregion

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\iisrunner\test\IisRunnerSuite.cs ===
using System;
using System.Xml;
using System.Collections;

using ServerTestFramework;
using xonline.common.diagnostics;

using xonline.tools.iisrunner.core;

namespace xonline.tools.iisrunner.test
{
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\iisrunner\test\obj\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("Microsoft(R) Xbox(TM)")]
[assembly:System.Reflection.AssemblyCopyright("Copyright (c) Microsoft Corporation. All rights reserved.")]
[assembly:System.Reflection.AssemblyCompany("Microsoft Corporation")]
[assembly:System.Reflection.AssemblyFileVersion("12.4.56.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\iisrunner\test\objd\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("Microsoft(R) Xbox(TM)")]
[assembly:System.Reflection.AssemblyCopyright("Copyright (c) Microsoft Corporation. All rights reserved.")]
[assembly:System.Reflection.AssemblyCompany("Microsoft Corporation")]
[assembly:System.Reflection.AssemblyFileVersion("12.4.56.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\iisrunner\test\IisRunnerStepDVT.cs ===
using System;
using System.IO;
using System.Xml;
using System.Data;
using System.Text;
using System.Reflection;
using System.Collections;
using System.Data.SqlClient;

using ServerTestFramework;
using xonline.common.diagnostics;
using xonline.tools.iisrunner.core;
using xonline.common.xmlsequencer;

namespace xonline.tools.iisrunner.test 
{
	[TestGroup, DVT]
	public class IisRunnerStepDVT : TestNode
	{    
    
		[TestCase]
		public void Constructor()
		{
			XmlDocument xmlDoc = new XmlDocument();
			xmlDoc.LoadXml("<IisRunner xmlns=\"http://www.xbox.com/iisrunner.xsd\" />");

			Console.WriteLine( "\t\tCheck good values");
			IisRunnerStep myRunner = new IisRunnerStep(xmlDoc.DocumentElement);
		}

        [TestCase]
        public void NotIisRunnerNamespace()
        {
            XmlDocument xmlDoc = new XmlDocument();
            xmlDoc.LoadXml("<IisRunner />");

            try
            {
                IisRunnerStep myRunner = new IisRunnerStep(xmlDoc.DocumentElement);
                throw new Exception("Expected InvalidOperationException not thrown.");
            }
            catch (InvalidOperationException) {}
        }

	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\iisrunner\test\obj\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=msil_xonline.tools.iisrunner.test_none_12.4.56.0_none_2a79f25f4cabef96
ASSEMBLY_IDENTITY_XP_KEY_FORM=msil_xonline.tools.iisrunner.test_no-public-key_12.4.56.0_x-ww_bc5ac036
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=xonline.tools.iisrunner.test
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=msil
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=msil_xonline.tools.iisrunner.test_no-public-key_12.4.56.0_x-ww_bc5ac036
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=msil_xonline.tools.iisrunner.test_no-public-key_12.4.56.0_x-ww_bc5ac036.manifest
XP_MANIFEST_PATH=manifests\msil_xonline.tools.iisrunner.test_no-public-key_12.4.56.0_x-ww_bc5ac036.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=msil_xonline.tools.iisrunner.test_no-public-key_12.4.56.0_x-ww_bc5ac036.cat
XP_CATALOG_PATH=manifests\msil_xonline.tools.iisrunner.test_no-public-key_12.4.56.0_x-ww_bc5ac036.cat
XP_PAYLOAD_PATH=msil_xonline.tools.iisrunner.test_no-public-key_12.4.56.0_x-ww_bc5ac036
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=xonline.tools.iisrunner.test,processorArchitecture=msil,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\iisrunner\installer\IisRunnerInstaller.cs ===
using System;
using System.IO;
using System.Xml;
using System.Collections;
using System.Diagnostics;
using System.ComponentModel;
using System.Configuration.Install;

using xonline.tools.iisrunner.core;
using xonline.common.xmlsequencer;

namespace xonline.tools.iisrunner.installer
{
	/// <summary>
	/// Summary description for IisRunnerInstaller.
	/// </summary>
	[RunInstaller(true)]
	public class IisRunnerInstaller : System.Configuration.Install.Installer
	{
        private System.Diagnostics.EventLog eventLog;
		/// <summary>
		/// Required designer variable.
		/// </summary>
		private System.ComponentModel.Container components = null;

		public IisRunnerInstaller()
		{
			// This call is required by the Designer.
			InitializeComponent();
		}

		/// <summary> 
		/// Clean up any resources being used.
		/// </summary>
		protected override void Dispose( bool disposing )
		{
			if( disposing )
			{
				if(components != null)
				{
					components.Dispose();
				}
			}
			base.Dispose( disposing );
		}

        public override void Install(IDictionary stateSaver)
        {
            base.Install (stateSaver);

            StartIisRunner("install");
        }

        public override void Commit(IDictionary savedState)
        {
            base.Commit (savedState);
        }

        public override void Uninstall(IDictionary savedState)
        {
            base.Uninstall (savedState);

            StartIisRunner("uninstall");
        }

        public override void Rollback(IDictionary savedState)
        {
            base.Rollback (savedState);

            StartIisRunner("rollback");
        }



        private void StartIisRunner(string installPhase)
        {
            string message = null;
            string iisRunnerFilename = Context.Parameters["runnerFile"];

            try
            {
                if ((iisRunnerFilename == null) || (iisRunnerFilename.Length == 0))
                {
                    throw new ArgumentException("The runnerFile parameter must be specified. It should contain the path to the IisRunner definition file.", "runnerFile");
                }

                message = String.Format("IisRunner started {0} of '{1}' at {2}", installPhase, iisRunnerFilename, DateTime.Now.ToString());
                eventLog.WriteEntry(message, EventLogEntryType.Information);
                Context.LogMessage(message);

                XmlDocument xmlDoc = new XmlDocument();
                xmlDoc.Load(iisRunnerFilename);

                ConfigurationTransform transform = new ConfigurationTransform();
                
                foreach (DictionaryEntry de in Context.Parameters)
                {
                    transform.OverrideVariableCollection.Set(de.Key.ToString(), de.Value.ToString());
                }
                transform.OverrideVariableCollection.Set("installphase", installPhase);

                transform.TransformDocument(xmlDoc);

                IisRunnerStep runner = new IisRunnerStep(xmlDoc.DocumentElement);
                runner.OnMessage += new MessageEventHandler(myRoot_OnMessage);

                runner.Validate();
                runner.Execute();
            }
            catch (Exception ex)
            {
                Context.LogMessage("ERROR: Exception encountered executing IisRunner. - " + ex.Message);
                Context.LogMessage(ex.ToString());

                message = string.Format("Exception encountered executing IisRunner: \r\n{0}", ex.ToString());
                eventLog.WriteEntry(message, EventLogEntryType.Error, 65000);
                throw;
            }

            message = String.Format("IisRunner {0} of '{1}' completed at {2}", installPhase, iisRunnerFilename, DateTime.Now.ToString());
            eventLog.WriteEntry(message, EventLogEntryType.Information);
            Context.LogMessage(message);
        }

        /// <summary>
        /// Event handler for IisRunnerStep's Message event which writes the message to the install context's log.
        /// </summary>
        /// <param name="sender">The IisRunnerStep generating the event.</param>
        /// <param name="e">The MessageEventArgs sent by the event.</param>
        private void myRoot_OnMessage(object sender, MessageEventArgs e)
        {
            Context.LogMessage(e.Message);
        }


		#region Component Designer generated code
		/// <summary>
		/// Required method for Designer support - do not modify
		/// the contents of this method with the code editor.
		/// </summary>
		private void InitializeComponent()
		{
            this.eventLog = new System.Diagnostics.EventLog();
            ((System.ComponentModel.ISupportInitialize)(this.eventLog)).BeginInit();
            // 
            // eventLog
            // 
            this.eventLog.Log = "Application";
            this.eventLog.Source = "IisRunner";
            ((System.ComponentModel.ISupportInitialize)(this.eventLog)).EndInit();

        }
		#endregion
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\iisrunner\test\objd\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=msil_xonline.tools.iisrunner.test_none_12.4.56.0_none_2a79f25f4cabef96
ASSEMBLY_IDENTITY_XP_KEY_FORM=msil_xonline.tools.iisrunner.test_no-public-key_12.4.56.0_x-ww_bc5ac036
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=xonline.tools.iisrunner.test
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=msil
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=msil_xonline.tools.iisrunner.test_no-public-key_12.4.56.0_x-ww_bc5ac036
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=msil_xonline.tools.iisrunner.test_no-public-key_12.4.56.0_x-ww_bc5ac036.manifest
XP_MANIFEST_PATH=manifests\msil_xonline.tools.iisrunner.test_no-public-key_12.4.56.0_x-ww_bc5ac036.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=msil_xonline.tools.iisrunner.test_no-public-key_12.4.56.0_x-ww_bc5ac036.cat
XP_CATALOG_PATH=manifests\msil_xonline.tools.iisrunner.test_no-public-key_12.4.56.0_x-ww_bc5ac036.cat
XP_PAYLOAD_PATH=msil_xonline.tools.iisrunner.test_no-public-key_12.4.56.0_x-ww_bc5ac036
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=xonline.tools.iisrunner.test,processorArchitecture=msil,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\InfrastructureProfiler\DeploymentProfiler\DeploymentProfileViewer\PieGraph.Designer.cs ===
﻿namespace DeploymentProfileViewer
{
    partial class PieGraph
    {
        /// <summary>
        /// Required designer variable.
        /// </summary>
        private System.ComponentModel.IContainer components = null;

        /// <summary>
        /// Clean up any resources being used.
        /// </summary>
        /// <param name="disposing">true if managed resources should be disposed; otherwise, false.</param>
        protected override void Dispose(bool disposing)
        {
            if (disposing && (components != null))
            {
                components.Dispose();
            }
            base.Dispose(disposing);
        }

        #region Windows Form Designer generated code

        /// <summary>
        /// Required method for Designer support - do not modify
        /// the contents of this method with the code editor.
        /// </summary>
        private void InitializeComponent()
        {
            this.components = new System.ComponentModel.Container();
            this.zedGraphControl1 = new ZedGraph.ZedGraphControl();
            this.SuspendLayout();
            // 
            // zedGraphControl1
            // 
            this.zedGraphControl1.Location = new System.Drawing.Point(12, 27);
            this.zedGraphControl1.Name = "zedGraphControl1";
            this.zedGraphControl1.ScrollGrace = 0;
            this.zedGraphControl1.ScrollMaxX = 0;
            this.zedGraphControl1.ScrollMaxY = 0;
            this.zedGraphControl1.ScrollMaxY2 = 0;
            this.zedGraphControl1.ScrollMinX = 0;
            this.zedGraphControl1.ScrollMinY = 0;
            this.zedGraphControl1.ScrollMinY2 = 0;
            this.zedGraphControl1.Size = new System.Drawing.Size(760, 525);
            this.zedGraphControl1.TabIndex = 0;
            // 
            // PieGraph
            // 
            this.AutoScaleDimensions = new System.Drawing.SizeF(6F, 13F);
            this.AutoScaleMode = System.Windows.Forms.AutoScaleMode.Font;
            this.ClientSize = new System.Drawing.Size(784, 564);
            this.Controls.Add(this.zedGraphControl1);
            this.Name = "PieGraph";
            this.Text = "Deployment Pie Graph";
            this.Load += new System.EventHandler(this.Form1_Load);
            this.Resize += new System.EventHandler(this.Form1_Resize);
            this.ResumeLayout(false);

        }

        #endregion

        private ZedGraph.ZedGraphControl zedGraphControl1;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\InfrastructureProfiler\DeploymentProfiler\DeploymentProfileViewer\PieGraph.cs ===
﻿using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Data;
using System.Drawing;
using System.Linq;
using System.Text;
using System.Windows.Forms;
using ZedGraph;

using XBLDeployment;

namespace DeploymentProfileViewer
{
    public partial class PieGraph : Form
    {
        XblDeploymentItemList itemList32Bit, itemList64Bit;

        public PieGraph()
        {
            InitializeComponent();
        }

        public void Initialize(XblDeploymentItemList list32, XblDeploymentItemList list64)
        {
            itemList32Bit = list32;
            itemList64Bit = list64;
        }

        private void Form1_Load(object sender, EventArgs e)
        {
            // Get a reference to the GraphPane instance in the ZedGraphControl
            GraphPane myPane = zedGraphControl1.GraphPane;

            // Set the titles and axis labels
            myPane.Title.Text = "Deployment Time Breakdown";

            // Add 32-Bit Time Slices
            TimeSpan prodbase32Bit = itemList32Bit.GetFilteredList("prodbase").Duration;
            TimeSpan upgrade32Bit = itemList32Bit.GetFilteredList("upgrade").Duration;
            TimeSpan msi32Bit = itemList32Bit.GetFilteredList(XblDeploymentType.Msi).Duration;
            TimeSpan remaining32Bit = itemList32Bit.Duration - prodbase32Bit - upgrade32Bit - msi32Bit;

            myPane.AddPieSlice(prodbase32Bit.TotalMinutes, Color.FromArgb(255, 0, 0), 0.0, "32-Bit ProdBase (" + prodbase32Bit.ToString() + ")");
            myPane.AddPieSlice(upgrade32Bit.TotalMinutes, Color.FromArgb(192, 0, 0), 0.0, "32-Bit Upgrade (" + upgrade32Bit.ToString() + ")");
            myPane.AddPieSlice(msi32Bit.TotalMinutes, Color.FromArgb(128, 0, 0), 0.0, "32-Bit MSIs (" + msi32Bit.ToString() + ")");
            myPane.AddPieSlice(remaining32Bit.TotalMinutes, Color.FromArgb(64, 0, 0), 0.0, "32-Bit Misc (" + remaining32Bit.ToString() + ")");

            TimeSpan prodbase64Bit = itemList64Bit.GetFilteredList("prodbase").Duration;
            TimeSpan upgrade64Bit = itemList64Bit.GetFilteredList("upgrade").Duration;
            TimeSpan msi64Bit = itemList64Bit.GetFilteredList(XblDeploymentType.Msi).Duration;
            TimeSpan remaining64Bit = itemList64Bit.Duration - prodbase64Bit - upgrade64Bit - msi64Bit;

            myPane.AddPieSlice(prodbase64Bit.TotalMinutes, Color.FromArgb(0, 0, 255), 0.0, "64-Bit ProdBase (" + prodbase64Bit.ToString() + ")");
            myPane.AddPieSlice(upgrade64Bit.TotalMinutes, Color.FromArgb(0, 0, 196), 0.0, "64-Bit Upgrade (" + upgrade64Bit.ToString() + ")");
            myPane.AddPieSlice(msi64Bit.TotalMinutes, Color.FromArgb(0, 0, 128), 0.0, "64-Bit MSIs (" + msi64Bit.ToString() + ")");
            myPane.AddPieSlice(remaining64Bit.TotalMinutes, Color.FromArgb(0, 0, 64), 0.0, "64-Bit Misc (" + remaining64Bit.ToString() + ")");

            // Fill the axis background with a gradient
            myPane.Chart.Fill = new Fill(Color.White, Color.LightGray, 45.0f);

            // Enable scrollbars if needed
            zedGraphControl1.IsShowHScrollBar = false;
            zedGraphControl1.IsShowVScrollBar = false;
            zedGraphControl1.IsAutoScrollRange = false;
            zedGraphControl1.IsScrollY2 = false;

            // Size the control to fit the window
            SetSize();

            // Tell ZedGraph to calculate the axis ranges
            // Note that you MUST call this after enabling IsAutoScrollRange, since AxisChange() sets
            // up the proper scrolling parameters
            zedGraphControl1.AxisChange();
            // Make sure the Graph gets redrawn
            zedGraphControl1.Invalidate();
        }

        private void Form1_Resize(object sender, EventArgs e)
        {
            SetSize();
        }

        private void SetSize()
        {
            zedGraphControl1.Location = new Point(10, 10);
            // Leave a small margin around the outside of the control
            zedGraphControl1.Size = new Size(this.ClientRectangle.Width - 20,
                    this.ClientRectangle.Height - 20);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\InfrastructureProfiler\DeploymentProfiler\DeploymentProfileViewer\MainForm.Designer.cs ===
﻿namespace DeploymentProfileViewer
{
    partial class MainForm
    {
        /// <summary>
        /// Required designer variable.
        /// </summary>
        private System.ComponentModel.IContainer components = null;

        /// <summary>
        /// Clean up any resources being used.
        /// </summary>
        /// <param name="disposing">true if managed resources should be disposed; otherwise, false.</param>
        protected override void Dispose(bool disposing)
        {
            if (disposing && (components != null))
            {
                components.Dispose();
            }
            base.Dispose(disposing);
        }

        #region Windows Form Designer generated code

        /// <summary>
        /// Required method for Designer support - do not modify
        /// the contents of this method with the code editor.
        /// </summary>
        private void InitializeComponent()
        {
            this.menuStrip1 = new System.Windows.Forms.MenuStrip();
            this.fileToolStripMenuItem = new System.Windows.Forms.ToolStripMenuItem();
            this.openSessionToolStripMenuItem = new System.Windows.Forms.ToolStripMenuItem();
            this.helpToolStripMenuItem = new System.Windows.Forms.ToolStripMenuItem();
            this.buttonTimeGraph = new System.Windows.Forms.Button();
            this.labelTopology = new System.Windows.Forms.Label();
            this.labelTopologyName = new System.Windows.Forms.Label();
            this.labelReleaseName = new System.Windows.Forms.Label();
            this.labelRelease = new System.Windows.Forms.Label();
            this.labelMachineName = new System.Windows.Forms.Label();
            this.label2 = new System.Windows.Forms.Label();
            this.labelTypeName = new System.Windows.Forms.Label();
            this.labelType = new System.Windows.Forms.Label();
            this.labelTotalDuration = new System.Windows.Forms.Label();
            this.labelTotal = new System.Windows.Forms.Label();
            this.buttonPieGraph = new System.Windows.Forms.Button();
            this.tabControl1 = new System.Windows.Forms.TabControl();
            this.tabPage1 = new System.Windows.Forms.TabPage();
            this.tabPage2 = new System.Windows.Forms.TabPage();
            this.labelMsi32Duration = new System.Windows.Forms.Label();
            this.labelMsi32 = new System.Windows.Forms.Label();
            this.labelUpgrade32Duration = new System.Windows.Forms.Label();
            this.labelUpgrade32 = new System.Windows.Forms.Label();
            this.labelProdBase32Duration = new System.Windows.Forms.Label();
            this.labelProdBase32 = new System.Windows.Forms.Label();
            this.webBrowser32Bit = new System.Windows.Forms.WebBrowser();
            this.labelTotal32Duration = new System.Windows.Forms.Label();
            this.labelTotal32 = new System.Windows.Forms.Label();
            this.labelMsi64Duration = new System.Windows.Forms.Label();
            this.labelMsi64 = new System.Windows.Forms.Label();
            this.labelUpgrade64Duration = new System.Windows.Forms.Label();
            this.labelUpgrade64 = new System.Windows.Forms.Label();
            this.labelProdBase64Duration = new System.Windows.Forms.Label();
            this.labelProdBase64 = new System.Windows.Forms.Label();
            this.webBrowser64Bit = new System.Windows.Forms.WebBrowser();
            this.labelTotal64Duration = new System.Windows.Forms.Label();
            this.labelTotal64 = new System.Windows.Forms.Label();
            this.saveProfilesToolStripMenuItem = new System.Windows.Forms.ToolStripMenuItem();
            this.menuStrip1.SuspendLayout();
            this.tabControl1.SuspendLayout();
            this.tabPage1.SuspendLayout();
            this.tabPage2.SuspendLayout();
            this.SuspendLayout();
            // 
            // menuStrip1
            // 
            this.menuStrip1.Items.AddRange(new System.Windows.Forms.ToolStripItem[] {
            this.fileToolStripMenuItem,
            this.helpToolStripMenuItem});
            this.menuStrip1.Location = new System.Drawing.Point(0, 0);
            this.menuStrip1.Name = "menuStrip1";
            this.menuStrip1.Size = new System.Drawing.Size(664, 24);
            this.menuStrip1.TabIndex = 0;
            this.menuStrip1.Text = "menuStrip1";
            // 
            // fileToolStripMenuItem
            // 
            this.fileToolStripMenuItem.DropDownItems.AddRange(new System.Windows.Forms.ToolStripItem[] {
            this.openSessionToolStripMenuItem,
            this.saveProfilesToolStripMenuItem});
            this.fileToolStripMenuItem.Name = "fileToolStripMenuItem";
            this.fileToolStripMenuItem.Size = new System.Drawing.Size(37, 20);
            this.fileToolStripMenuItem.Text = "File";
            // 
            // openSessionToolStripMenuItem
            // 
            this.openSessionToolStripMenuItem.Name = "openSessionToolStripMenuItem";
            this.openSessionToolStripMenuItem.Size = new System.Drawing.Size(196, 22);
            this.openSessionToolStripMenuItem.Text = "Open Session Directory";
            this.openSessionToolStripMenuItem.Click += new System.EventHandler(this.openSessionToolStripMenuItem_Click);
            // 
            // helpToolStripMenuItem
            // 
            this.helpToolStripMenuItem.Name = "helpToolStripMenuItem";
            this.helpToolStripMenuItem.Size = new System.Drawing.Size(44, 20);
            this.helpToolStripMenuItem.Text = "Help";
            // 
            // buttonTimeGraph
            // 
            this.buttonTimeGraph.Location = new System.Drawing.Point(545, 61);
            this.buttonTimeGraph.Name = "buttonTimeGraph";
            this.buttonTimeGraph.Size = new System.Drawing.Size(97, 23);
            this.buttonTimeGraph.TabIndex = 2;
            this.buttonTimeGraph.Text = "Time Graph";
            this.buttonTimeGraph.UseVisualStyleBackColor = true;
            this.buttonTimeGraph.Click += new System.EventHandler(this.buttonTimeGraph_Click);
            // 
            // labelTopology
            // 
            this.labelTopology.AutoSize = true;
            this.labelTopology.Font = new System.Drawing.Font("Microsoft Sans Serif", 8.25F, System.Drawing.FontStyle.Bold, System.Drawing.GraphicsUnit.Point, ((byte)(0)));
            this.labelTopology.Location = new System.Drawing.Point(12, 37);
            this.labelTopology.Name = "labelTopology";
            this.labelTopology.Size = new System.Drawing.Size(63, 13);
            this.labelTopology.TabIndex = 4;
            this.labelTopology.Text = "Topology:";
            // 
            // labelTopologyName
            // 
            this.labelTopologyName.AutoSize = true;
            this.labelTopologyName.Location = new System.Drawing.Point(81, 37);
            this.labelTopologyName.Name = "labelTopologyName";
            this.labelTopologyName.Size = new System.Drawing.Size(33, 13);
            this.labelTopologyName.TabIndex = 5;
            this.labelTopologyName.Text = "None";
            // 
            // labelReleaseName
            // 
            this.labelReleaseName.AutoSize = true;
            this.labelReleaseName.Location = new System.Drawing.Point(81, 56);
            this.labelReleaseName.Name = "labelReleaseName";
            this.labelReleaseName.Size = new System.Drawing.Size(33, 13);
            this.labelReleaseName.TabIndex = 7;
            this.labelReleaseName.Text = "None";
            // 
            // labelRelease
            // 
            this.labelRelease.AutoSize = true;
            this.labelRelease.Font = new System.Drawing.Font("Microsoft Sans Serif", 8.25F, System.Drawing.FontStyle.Bold, System.Drawing.GraphicsUnit.Point, ((byte)(0)));
            this.labelRelease.Location = new System.Drawing.Point(12, 56);
            this.labelRelease.Name = "labelRelease";
            this.labelRelease.Size = new System.Drawing.Size(57, 13);
            this.labelRelease.TabIndex = 6;
            this.labelRelease.Text = "Release:";
            // 
            // labelMachineName
            // 
            this.labelMachineName.AutoSize = true;
            this.labelMachineName.Location = new System.Drawing.Point(267, 56);
            this.labelMachineName.Name = "labelMachineName";
            this.labelMachineName.Size = new System.Drawing.Size(33, 13);
            this.labelMachineName.TabIndex = 11;
            this.labelMachineName.Text = "None";
            // 
            // label2
            // 
            this.label2.AutoSize = true;
            this.label2.Font = new System.Drawing.Font("Microsoft Sans Serif", 8.25F, System.Drawing.FontStyle.Bold, System.Drawing.GraphicsUnit.Point, ((byte)(0)));
            this.label2.Location = new System.Drawing.Point(204, 56);
            this.label2.Name = "label2";
            this.label2.Size = new System.Drawing.Size(59, 13);
            this.label2.TabIndex = 10;
            this.label2.Text = "Machine:";
            // 
            // labelTypeName
            // 
            this.labelTypeName.AutoSize = true;
            this.labelTypeName.Location = new System.Drawing.Point(267, 37);
            this.labelTypeName.Name = "labelTypeName";
            this.labelTypeName.Size = new System.Drawing.Size(33, 13);
            this.labelTypeName.TabIndex = 9;
            this.labelTypeName.Text = "None";
            // 
            // labelType
            // 
            this.labelType.AutoSize = true;
            this.labelType.Font = new System.Drawing.Font("Microsoft Sans Serif", 8.25F, System.Drawing.FontStyle.Bold, System.Drawing.GraphicsUnit.Point, ((byte)(0)));
            this.labelType.Location = new System.Drawing.Point(204, 37);
            this.labelType.Name = "labelType";
            this.labelType.Size = new System.Drawing.Size(39, 13);
            this.labelType.TabIndex = 8;
            this.labelType.Text = "Type:";
            // 
            // labelTotalDuration
            // 
            this.labelTotalDuration.AutoSize = true;
            this.labelTotalDuration.Location = new System.Drawing.Point(451, 37);
            this.labelTotalDuration.Name = "labelTotalDuration";
            this.labelTotalDuration.Size = new System.Drawing.Size(49, 13);
            this.labelTotalDuration.TabIndex = 13;
            this.labelTotalDuration.Text = "00:00:00";
            // 
            // labelTotal
            // 
            this.labelTotal.AutoSize = true;
            this.labelTotal.Font = new System.Drawing.Font("Microsoft Sans Serif", 8.25F, System.Drawing.FontStyle.Bold, System.Drawing.GraphicsUnit.Point, ((byte)(0)));
            this.labelTotal.Location = new System.Drawing.Point(353, 37);
            this.labelTotal.Name = "labelTotal";
            this.labelTotal.Size = new System.Drawing.Size(92, 13);
            this.labelTotal.TabIndex = 12;
            this.labelTotal.Text = "Total Duration:";
            // 
            // buttonPieGraph
            // 
            this.buttonPieGraph.Location = new System.Drawing.Point(545, 32);
            this.buttonPieGraph.Name = "buttonPieGraph";
            this.buttonPieGraph.Size = new System.Drawing.Size(97, 23);
            this.buttonPieGraph.TabIndex = 14;
            this.buttonPieGraph.Text = "Pie Graph";
            this.buttonPieGraph.UseVisualStyleBackColor = true;
            this.buttonPieGraph.Click += new System.EventHandler(this.buttonPieGraph_Click);
            // 
            // tabControl1
            // 
            this.tabControl1.Anchor = ((System.Windows.Forms.AnchorStyles)((((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Bottom)
                        | System.Windows.Forms.AnchorStyles.Left)
                        | System.Windows.Forms.AnchorStyles.Right)));
            this.tabControl1.Controls.Add(this.tabPage1);
            this.tabControl1.Controls.Add(this.tabPage2);
            this.tabControl1.Location = new System.Drawing.Point(12, 97);
            this.tabControl1.Name = "tabControl1";
            this.tabControl1.SelectedIndex = 0;
            this.tabControl1.Size = new System.Drawing.Size(640, 655);
            this.tabControl1.TabIndex = 15;
            // 
            // tabPage1
            // 
            this.tabPage1.Controls.Add(this.labelMsi32Duration);
            this.tabPage1.Controls.Add(this.labelMsi32);
            this.tabPage1.Controls.Add(this.labelUpgrade32Duration);
            this.tabPage1.Controls.Add(this.labelUpgrade32);
            this.tabPage1.Controls.Add(this.labelProdBase32Duration);
            this.tabPage1.Controls.Add(this.labelProdBase32);
            this.tabPage1.Controls.Add(this.webBrowser32Bit);
            this.tabPage1.Controls.Add(this.labelTotal32Duration);
            this.tabPage1.Controls.Add(this.labelTotal32);
            this.tabPage1.Location = new System.Drawing.Point(4, 22);
            this.tabPage1.Name = "tabPage1";
            this.tabPage1.Padding = new System.Windows.Forms.Padding(3);
            this.tabPage1.Size = new System.Drawing.Size(632, 629);
            this.tabPage1.TabIndex = 0;
            this.tabPage1.Text = "32-Bit Deployment";
            this.tabPage1.UseVisualStyleBackColor = true;
            // 
            // tabPage2
            // 
            this.tabPage2.Controls.Add(this.labelMsi64Duration);
            this.tabPage2.Controls.Add(this.labelMsi64);
            this.tabPage2.Controls.Add(this.labelUpgrade64Duration);
            this.tabPage2.Controls.Add(this.labelUpgrade64);
            this.tabPage2.Controls.Add(this.labelProdBase64Duration);
            this.tabPage2.Controls.Add(this.labelProdBase64);
            this.tabPage2.Controls.Add(this.webBrowser64Bit);
            this.tabPage2.Controls.Add(this.labelTotal64Duration);
            this.tabPage2.Controls.Add(this.labelTotal64);
            this.tabPage2.Location = new System.Drawing.Point(4, 22);
            this.tabPage2.Name = "tabPage2";
            this.tabPage2.Padding = new System.Windows.Forms.Padding(3);
            this.tabPage2.Size = new System.Drawing.Size(632, 629);
            this.tabPage2.TabIndex = 1;
            this.tabPage2.Text = "64-Bit Deployment";
            this.tabPage2.UseVisualStyleBackColor = true;
            // 
            // labelMsi32Duration
            // 
            this.labelMsi32Duration.AutoSize = true;
            this.labelMsi32Duration.Location = new System.Drawing.Point(536, 3);
            this.labelMsi32Duration.Name = "labelMsi32Duration";
            this.labelMsi32Duration.Size = new System.Drawing.Size(49, 13);
            this.labelMsi32Duration.TabIndex = 17;
            this.labelMsi32Duration.Text = "00:00:00";
            // 
            // labelMsi32
            // 
            this.labelMsi32.AutoSize = true;
            this.labelMsi32.Location = new System.Drawing.Point(461, 3);
            this.labelMsi32.Name = "labelMsi32";
            this.labelMsi32.Size = new System.Drawing.Size(69, 13);
            this.labelMsi32.TabIndex = 16;
            this.labelMsi32.Text = "Msi Duration:";
            // 
            // labelUpgrade32Duration
            // 
            this.labelUpgrade32Duration.AutoSize = true;
            this.labelUpgrade32Duration.Location = new System.Drawing.Point(406, 3);
            this.labelUpgrade32Duration.Name = "labelUpgrade32Duration";
            this.labelUpgrade32Duration.Size = new System.Drawing.Size(49, 13);
            this.labelUpgrade32Duration.TabIndex = 15;
            this.labelUpgrade32Duration.Text = "00:00:00";
            // 
            // labelUpgrade32
            // 
            this.labelUpgrade32.AutoSize = true;
            this.labelUpgrade32.Location = new System.Drawing.Point(310, 3);
            this.labelUpgrade32.Name = "labelUpgrade32";
            this.labelUpgrade32.Size = new System.Drawing.Size(94, 13);
            this.labelUpgrade32.TabIndex = 14;
            this.labelUpgrade32.Text = "Upgrade Duration:";
            // 
            // labelProdBase32Duration
            // 
            this.labelProdBase32Duration.AutoSize = true;
            this.labelProdBase32Duration.Location = new System.Drawing.Point(255, 3);
            this.labelProdBase32Duration.Name = "labelProdBase32Duration";
            this.labelProdBase32Duration.Size = new System.Drawing.Size(49, 13);
            this.labelProdBase32Duration.TabIndex = 13;
            this.labelProdBase32Duration.Text = "00:00:00";
            // 
            // labelProdBase32
            // 
            this.labelProdBase32.AutoSize = true;
            this.labelProdBase32.Location = new System.Drawing.Point(158, 3);
            this.labelProdBase32.Name = "labelProdBase32";
            this.labelProdBase32.Size = new System.Drawing.Size(99, 13);
            this.labelProdBase32.TabIndex = 12;
            this.labelProdBase32.Text = "ProdBase Duration:";
            // 
            // webBrowser32Bit
            // 
            this.webBrowser32Bit.Anchor = ((System.Windows.Forms.AnchorStyles)((((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Bottom)
                        | System.Windows.Forms.AnchorStyles.Left)
                        | System.Windows.Forms.AnchorStyles.Right)));
            this.webBrowser32Bit.Location = new System.Drawing.Point(5, 19);
            this.webBrowser32Bit.MinimumSize = new System.Drawing.Size(20, 20);
            this.webBrowser32Bit.Name = "webBrowser32Bit";
            this.webBrowser32Bit.Size = new System.Drawing.Size(621, 604);
            this.webBrowser32Bit.TabIndex = 11;
            // 
            // labelTotal32Duration
            // 
            this.labelTotal32Duration.AutoSize = true;
            this.labelTotal32Duration.Location = new System.Drawing.Point(89, 3);
            this.labelTotal32Duration.Name = "labelTotal32Duration";
            this.labelTotal32Duration.Size = new System.Drawing.Size(49, 13);
            this.labelTotal32Duration.TabIndex = 10;
            this.labelTotal32Duration.Text = "00:00:00";
            // 
            // labelTotal32
            // 
            this.labelTotal32.AutoSize = true;
            this.labelTotal32.Location = new System.Drawing.Point(6, 3);
            this.labelTotal32.Name = "labelTotal32";
            this.labelTotal32.Size = new System.Drawing.Size(77, 13);
            this.labelTotal32.TabIndex = 9;
            this.labelTotal32.Text = "Total Duration:";
            // 
            // labelMsi64Duration
            // 
            this.labelMsi64Duration.AutoSize = true;
            this.labelMsi64Duration.Location = new System.Drawing.Point(536, 3);
            this.labelMsi64Duration.Name = "labelMsi64Duration";
            this.labelMsi64Duration.Size = new System.Drawing.Size(49, 13);
            this.labelMsi64Duration.TabIndex = 21;
            this.labelMsi64Duration.Text = "00:00:00";
            // 
            // labelMsi64
            // 
            this.labelMsi64.AutoSize = true;
            this.labelMsi64.Location = new System.Drawing.Point(461, 3);
            this.labelMsi64.Name = "labelMsi64";
            this.labelMsi64.Size = new System.Drawing.Size(69, 13);
            this.labelMsi64.TabIndex = 20;
            this.labelMsi64.Text = "Msi Duration:";
            // 
            // labelUpgrade64Duration
            // 
            this.labelUpgrade64Duration.AutoSize = true;
            this.labelUpgrade64Duration.Location = new System.Drawing.Point(406, 3);
            this.labelUpgrade64Duration.Name = "labelUpgrade64Duration";
            this.labelUpgrade64Duration.Size = new System.Drawing.Size(49, 13);
            this.labelUpgrade64Duration.TabIndex = 19;
            this.labelUpgrade64Duration.Text = "00:00:00";
            // 
            // labelUpgrade64
            // 
            this.labelUpgrade64.AutoSize = true;
            this.labelUpgrade64.Location = new System.Drawing.Point(310, 3);
            this.labelUpgrade64.Name = "labelUpgrade64";
            this.labelUpgrade64.Size = new System.Drawing.Size(94, 13);
            this.labelUpgrade64.TabIndex = 18;
            this.labelUpgrade64.Text = "Upgrade Duration:";
            // 
            // labelProdBase64Duration
            // 
            this.labelProdBase64Duration.AutoSize = true;
            this.labelProdBase64Duration.Location = new System.Drawing.Point(255, 3);
            this.labelProdBase64Duration.Name = "labelProdBase64Duration";
            this.labelProdBase64Duration.Size = new System.Drawing.Size(49, 13);
            this.labelProdBase64Duration.TabIndex = 17;
            this.labelProdBase64Duration.Text = "00:00:00";
            // 
            // labelProdBase64
            // 
            this.labelProdBase64.AutoSize = true;
            this.labelProdBase64.Location = new System.Drawing.Point(158, 3);
            this.labelProdBase64.Name = "labelProdBase64";
            this.labelProdBase64.Size = new System.Drawing.Size(99, 13);
            this.labelProdBase64.TabIndex = 16;
            this.labelProdBase64.Text = "ProdBase Duration:";
            // 
            // webBrowser64Bit
            // 
            this.webBrowser64Bit.Anchor = ((System.Windows.Forms.AnchorStyles)((((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Bottom)
                        | System.Windows.Forms.AnchorStyles.Left)
                        | System.Windows.Forms.AnchorStyles.Right)));
            this.webBrowser64Bit.Location = new System.Drawing.Point(5, 19);
            this.webBrowser64Bit.MinimumSize = new System.Drawing.Size(20, 20);
            this.webBrowser64Bit.Name = "webBrowser64Bit";
            this.webBrowser64Bit.Size = new System.Drawing.Size(621, 604);
            this.webBrowser64Bit.TabIndex = 15;
            // 
            // labelTotal64Duration
            // 
            this.labelTotal64Duration.AutoSize = true;
            this.labelTotal64Duration.Location = new System.Drawing.Point(89, 3);
            this.labelTotal64Duration.Name = "labelTotal64Duration";
            this.labelTotal64Duration.Size = new System.Drawing.Size(49, 13);
            this.labelTotal64Duration.TabIndex = 14;
            this.labelTotal64Duration.Text = "00:00:00";
            // 
            // labelTotal64
            // 
            this.labelTotal64.AutoSize = true;
            this.labelTotal64.Location = new System.Drawing.Point(6, 3);
            this.labelTotal64.Name = "labelTotal64";
            this.labelTotal64.Size = new System.Drawing.Size(77, 13);
            this.labelTotal64.TabIndex = 13;
            this.labelTotal64.Text = "Total Duration:";
            // 
            // saveProfilesToolStripMenuItem
            // 
            this.saveProfilesToolStripMenuItem.Name = "saveProfilesToolStripMenuItem";
            this.saveProfilesToolStripMenuItem.ShortcutKeys = ((System.Windows.Forms.Keys)((System.Windows.Forms.Keys.Control | System.Windows.Forms.Keys.S)));
            this.saveProfilesToolStripMenuItem.Size = new System.Drawing.Size(196, 22);
            this.saveProfilesToolStripMenuItem.Text = "Save Profiles";
            this.saveProfilesToolStripMenuItem.Click += new System.EventHandler(this.saveProfilesToolStripMenuItem_Click);
            // 
            // MainForm
            // 
            this.AutoScaleDimensions = new System.Drawing.SizeF(6F, 13F);
            this.AutoScaleMode = System.Windows.Forms.AutoScaleMode.Font;
            this.ClientSize = new System.Drawing.Size(664, 764);
            this.Controls.Add(this.tabControl1);
            this.Controls.Add(this.buttonPieGraph);
            this.Controls.Add(this.labelTotalDuration);
            this.Controls.Add(this.labelTotal);
            this.Controls.Add(this.labelMachineName);
            this.Controls.Add(this.label2);
            this.Controls.Add(this.labelTypeName);
            this.Controls.Add(this.labelType);
            this.Controls.Add(this.labelReleaseName);
            this.Controls.Add(this.labelRelease);
            this.Controls.Add(this.labelTopologyName);
            this.Controls.Add(this.labelTopology);
            this.Controls.Add(this.buttonTimeGraph);
            this.Controls.Add(this.menuStrip1);
            this.MainMenuStrip = this.menuStrip1;
            this.Name = "MainForm";
            this.Text = "MainForm";
            this.menuStrip1.ResumeLayout(false);
            this.menuStrip1.PerformLayout();
            this.tabControl1.ResumeLayout(false);
            this.tabPage1.ResumeLayout(false);
            this.tabPage1.PerformLayout();
            this.tabPage2.ResumeLayout(false);
            this.tabPage2.PerformLayout();
            this.ResumeLayout(false);
            this.PerformLayout();

        }

        #endregion

        private System.Windows.Forms.MenuStrip menuStrip1;
        private System.Windows.Forms.ToolStripMenuItem fileToolStripMenuItem;
        private System.Windows.Forms.ToolStripMenuItem openSessionToolStripMenuItem;
        private System.Windows.Forms.ToolStripMenuItem helpToolStripMenuItem;
        private System.Windows.Forms.Button buttonTimeGraph;
        private System.Windows.Forms.Label labelTopology;
        private System.Windows.Forms.Label labelTopologyName;
        private System.Windows.Forms.Label labelReleaseName;
        private System.Windows.Forms.Label labelRelease;
        private System.Windows.Forms.Label labelMachineName;
        private System.Windows.Forms.Label label2;
        private System.Windows.Forms.Label labelTypeName;
        private System.Windows.Forms.Label labelType;
        private System.Windows.Forms.Label labelTotalDuration;
        private System.Windows.Forms.Label labelTotal;
        private System.Windows.Forms.Button buttonPieGraph;
        private System.Windows.Forms.TabControl tabControl1;
        private System.Windows.Forms.TabPage tabPage1;
        private System.Windows.Forms.TabPage tabPage2;
        private System.Windows.Forms.Label labelMsi32Duration;
        private System.Windows.Forms.Label labelMsi32;
        private System.Windows.Forms.Label labelUpgrade32Duration;
        private System.Windows.Forms.Label labelUpgrade32;
        private System.Windows.Forms.Label labelProdBase32Duration;
        private System.Windows.Forms.Label labelProdBase32;
        private System.Windows.Forms.WebBrowser webBrowser32Bit;
        private System.Windows.Forms.Label labelTotal32Duration;
        private System.Windows.Forms.Label labelTotal32;
        private System.Windows.Forms.Label labelMsi64Duration;
        private System.Windows.Forms.Label labelMsi64;
        private System.Windows.Forms.Label labelUpgrade64Duration;
        private System.Windows.Forms.Label labelUpgrade64;
        private System.Windows.Forms.Label labelProdBase64Duration;
        private System.Windows.Forms.Label labelProdBase64;
        private System.Windows.Forms.WebBrowser webBrowser64Bit;
        private System.Windows.Forms.Label labelTotal64Duration;
        private System.Windows.Forms.Label labelTotal64;
        private System.Windows.Forms.ToolStripMenuItem saveProfilesToolStripMenuItem;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\InfrastructureProfiler\DeploymentProfiler\DeploymentProfileViewer\Program.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Windows.Forms;

namespace DeploymentProfileViewer
{
    static class Program
    {
        /// <summary>
        /// The main entry point for the application.
        /// </summary>
        [STAThread]
        static void Main()
        {
            Application.EnableVisualStyles();
            Application.SetCompatibleTextRenderingDefault(false);
            Application.Run(new MainForm());
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\InfrastructureProfiler\DeploymentProfiler\DeploymentProfileViewer\MainForm.cs ===
﻿using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Data;
using System.Drawing;
using System.Linq;
using System.Text;
using System.IO;
using System.Xml;
using System.Reflection;
using System.Windows.Forms;

using XBLDeployment;

namespace DeploymentProfileViewer
{
    public partial class MainForm : Form
    {
        XblDeploymentItemList itemList32Bit = null, itemList64Bit = null;
        String topologyName;
        String releaseName;
        String deploymentType;
        String controlMachineName;

        public MainForm()
        {
            InitializeComponent();
        }

        private void LoadSessionPath(String sessionPath)
        {
            // --- Read Deployment XMLs ---
            XblDeploymentItemCollection deploymentList32Bit = XblDeploymentUtil.LoadDeploymentSession(Path.Combine(sessionPath, "Octopus32bit"), out topologyName, out releaseName, out deploymentType, out controlMachineName);
            XblDeploymentItemCollection deploymentList64Bit = XblDeploymentUtil.LoadDeploymentSession(Path.Combine(sessionPath, "Octopus64bit"), out topologyName, out releaseName, out deploymentType, out controlMachineName);

            if (deploymentList32Bit != null && deploymentList64Bit != null)
            {
                // --- Apply Filters ---
                itemList32Bit = deploymentList32Bit.GetChronologicalList();
                itemList64Bit = deploymentList64Bit.GetChronologicalList();

                // Set Form Objects
                labelTotal32Duration.Text = itemList32Bit.Duration.ToString();
                labelTotal64Duration.Text = itemList64Bit.Duration.ToString();
                labelTopologyName.Text = topologyName;
                labelReleaseName.Text = releaseName;
                labelTypeName.Text = deploymentType;
                labelMachineName.Text = controlMachineName;
                labelTotalDuration.Text = (itemList32Bit.Duration + itemList64Bit.Duration).ToString();

                labelProdBase32Duration.Text = itemList32Bit.GetFilteredList("prodbase").Duration.ToString();
                labelUpgrade32Duration.Text = itemList32Bit.GetFilteredList("upgrade").Duration.ToString();
                labelMsi32Duration.Text = itemList32Bit.GetFilteredList(XblDeploymentType.Msi).Duration.ToString();

                labelProdBase64Duration.Text = itemList64Bit.GetFilteredList("prodbase").Duration.ToString();
                labelUpgrade64Duration.Text = itemList64Bit.GetFilteredList("upgrade").Duration.ToString();
                labelMsi64Duration.Text = itemList64Bit.GetFilteredList(XblDeploymentType.Msi).Duration.ToString();

                // Write out the embedded profile.xslt file
                Stream s = Assembly.GetExecutingAssembly().GetManifestResourceStream("DeploymentProfileViewer.profile.xslt");
                XmlDocument summaryXsltFile = new XmlDocument();

                StreamReader reader = new StreamReader(s);
                summaryXsltFile.LoadXml(reader.ReadToEnd());
                reader.Close();

                String tempPath = Path.GetTempPath();
                summaryXsltFile.Save(Path.Combine(tempPath, "profile.xslt"));

                XblDeploymentUtil.SaveDeploymentProfile(itemList32Bit, Path.Combine(tempPath, "Profile32Bit.xml"), topologyName, releaseName, deploymentType, controlMachineName);
                XblDeploymentUtil.SaveDeploymentProfile(itemList64Bit, Path.Combine(tempPath, "Profile64Bit.xml"), topologyName, releaseName, deploymentType, controlMachineName);

                webBrowser32Bit.Navigate(Path.Combine(tempPath, "Profile32Bit.xml"));
                webBrowser64Bit.Navigate(Path.Combine(tempPath, "Profile64Bit.xml"));
            }
        }

        private void openSessionToolStripMenuItem_Click(object sender, EventArgs e)
        {
            // Open Directory Select
            OpenFileDialog fDialog = new OpenFileDialog();
            fDialog.Title = "Select a deploymentSession.xml in either 32/64-bit";
            fDialog.Filter = "XML Files|*.xml|All Files|*.*";
            fDialog.RestoreDirectory = true;

            if (fDialog.ShowDialog() == DialogResult.OK)
            {
                LoadSessionPath(Path.Combine(Path.GetFullPath(fDialog.FileName).Replace(fDialog.SafeFileName, ""), ".."));
            }
        }

        private void buttonTimeGraph_Click(object sender, EventArgs e)
        {
            if (itemList32Bit == null ||
                itemList64Bit == null)
            {
                MessageBox.Show("No Deployment Sessions Loaded", "Error");
            }
            else
            {
                TimeGraph timeGraph = new TimeGraph();
                timeGraph.Initialize(itemList32Bit, itemList64Bit);
                timeGraph.ShowDialog();
            }
        }

        private void buttonPieGraph_Click(object sender, EventArgs e)
        {
            if (itemList32Bit == null ||
                itemList64Bit == null)
            {
                MessageBox.Show("No Deployment Sessions Loaded", "Error");
            }
            else
            {
                PieGraph pieGraph = new PieGraph();
                pieGraph.Initialize(itemList32Bit, itemList64Bit);
                pieGraph.ShowDialog();
            }
        }

        private void saveProfilesToolStripMenuItem_Click(object sender, EventArgs e)
        {
            // Open Directory Select
            FolderBrowserDialog fbd = new FolderBrowserDialog();

            if (fbd.ShowDialog() == DialogResult.OK)
            {
                // Write out the embedded profile.xslt file
                Stream s = Assembly.GetExecutingAssembly().GetManifestResourceStream("DeploymentProfileViewer.profile.xslt");
                XmlDocument summaryXsltFile = new XmlDocument();

                StreamReader reader = new StreamReader(s);
                summaryXsltFile.LoadXml(reader.ReadToEnd());
                reader.Close();

                String tempPath = Path.GetTempPath();
                summaryXsltFile.Save(Path.Combine(fbd.SelectedPath, "profile.xslt"));

                XblDeploymentUtil.SaveDeploymentProfile(itemList32Bit, Path.Combine(fbd.SelectedPath, "Profile32Bit.xml"), topologyName, releaseName, deploymentType, controlMachineName);
                XblDeploymentUtil.SaveDeploymentProfile(itemList64Bit, Path.Combine(fbd.SelectedPath, "Profile64Bit.xml"), topologyName, releaseName, deploymentType, controlMachineName);
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\InfrastructureProfiler\DeploymentProfiler\DeploymentProfileViewer\TimeGraph.Designer.cs ===
﻿namespace DeploymentProfileViewer
{
    partial class TimeGraph
    {
        /// <summary>
        /// Required designer variable.
        /// </summary>
        private System.ComponentModel.IContainer components = null;

        /// <summary>
        /// Clean up any resources being used.
        /// </summary>
        /// <param name="disposing">true if managed resources should be disposed; otherwise, false.</param>
        protected override void Dispose(bool disposing)
        {
            if (disposing && (components != null))
            {
                components.Dispose();
            }
            base.Dispose(disposing);
        }

        #region Windows Form Designer generated code

        /// <summary>
        /// Required method for Designer support - do not modify
        /// the contents of this method with the code editor.
        /// </summary>
        private void InitializeComponent()
        {
            this.components = new System.ComponentModel.Container();
            this.zedGraphControl1 = new ZedGraph.ZedGraphControl();
            this.SuspendLayout();
            // 
            // zedGraphControl1
            // 
            this.zedGraphControl1.Location = new System.Drawing.Point(12, 27);
            this.zedGraphControl1.Name = "zedGraphControl1";
            this.zedGraphControl1.ScrollGrace = 0;
            this.zedGraphControl1.ScrollMaxX = 0;
            this.zedGraphControl1.ScrollMaxY = 0;
            this.zedGraphControl1.ScrollMaxY2 = 0;
            this.zedGraphControl1.ScrollMinX = 0;
            this.zedGraphControl1.ScrollMinY = 0;
            this.zedGraphControl1.ScrollMinY2 = 0;
            this.zedGraphControl1.Size = new System.Drawing.Size(760, 525);
            this.zedGraphControl1.TabIndex = 0;
            // 
            // TimeGraph
            // 
            this.AutoScaleDimensions = new System.Drawing.SizeF(6F, 13F);
            this.AutoScaleMode = System.Windows.Forms.AutoScaleMode.Font;
            this.ClientSize = new System.Drawing.Size(784, 564);
            this.Controls.Add(this.zedGraphControl1);
            this.Name = "TimeGraph";
            this.Text = "Deployment Time Graph";
            this.Load += new System.EventHandler(this.Form1_Load);
            this.Resize += new System.EventHandler(this.Form1_Resize);
            this.ResumeLayout(false);

        }

        #endregion

        private ZedGraph.ZedGraphControl zedGraphControl1;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\InfrastructureProfiler\DeploymentProfiler\DeploymentProfileViewer\Properties\AssemblyInfo.cs ===
﻿using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
[assembly: AssemblyTitle("DeploymentProfileViewer")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyCompany("Microsoft")]
[assembly: AssemblyProduct("DeploymentProfileViewer")]
[assembly: AssemblyCopyright("Copyright © Microsoft 2009")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]

// Setting ComVisible to false makes the types in this assembly not visible 
// to COM components.  If you need to access a type in this assembly from 
// COM, set the ComVisible attribute to true on that type.
[assembly: ComVisible(false)]

// The following GUID is for the ID of the typelib if this project is exposed to COM
[assembly: Guid("48e41232-1f11-4491-8b0d-6c86a3afe6b1")]

// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version 
//      Build Number
//      Revision
//
// You can specify all the values or you can default the Build and Revision Numbers 
// by using the '*' as shown below:
// [assembly: AssemblyVersion("1.0.*")]
[assembly: AssemblyVersion("1.0.0.0")]
[assembly: AssemblyFileVersion("1.0.0.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\InfrastructureProfiler\DeploymentProfiler\DeploymentProfileViewer\TimeGraph.cs ===
﻿using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Data;
using System.Drawing;
using System.Linq;
using System.Text;
using System.Windows.Forms;
using ZedGraph;

using XBLDeployment;

namespace DeploymentProfileViewer
{
    public partial class TimeGraph : Form
    {
        XblDeploymentItemList itemList32Bit, itemList64Bit;

        public TimeGraph()
        {
            InitializeComponent();
        }

        public void Initialize(XblDeploymentItemList list32, XblDeploymentItemList list64)
        {
            itemList32Bit = list32;
            itemList64Bit = list64;
        }

        private void Form1_Load(object sender, EventArgs e)
        {
            // Get a reference to the GraphPane instance in the ZedGraphControl
            GraphPane myPane = zedGraphControl1.GraphPane;

            // Set the titles and axis labels
            myPane.Title.Text = "Activity over Deployment Time";
            myPane.XAxis.Title.Text = "Time, Minutes";
            myPane.YAxis.Title.Text = "32-Bit, Seconds";
            myPane.Y2Axis.Title.Text = "64-Bit, Seconds";

            // Make up some data points based on the Sine function
            PointPairList list = new PointPairList();
            PointPairList list2 = new PointPairList();
            DateTime startTime32Bit = itemList32Bit.List[0].StartTime;
            foreach (XblDeploymentItem item in itemList32Bit.List)
            {
                TimeSpan timeSpan = item.StartTime - startTime32Bit;
                list.Add(timeSpan.TotalMinutes, item.Duration.TotalSeconds);
                timeSpan = item.EndTime - startTime32Bit;
                list.Add(timeSpan.TotalMinutes, item.Duration.TotalSeconds);
            }
            DateTime startTime64Bit = itemList64Bit.List[0].StartTime;
            foreach (XblDeploymentItem item in itemList64Bit.List)
            {
                TimeSpan timeSpan = item.StartTime - startTime64Bit;
                list2.Add(timeSpan.TotalMinutes, item.Duration.TotalSeconds);
                timeSpan = item.EndTime - startTime64Bit;
                list2.Add(timeSpan.TotalMinutes, item.Duration.TotalSeconds);
            }

            // Generate a red curve with diamond symbols, and "Alpha" in the legend
            LineItem myCurve = myPane.AddCurve("32-Bit",
                list, Color.Red, SymbolType.Diamond);
            // Fill the symbols with white
            myCurve.Symbol.Fill = new Fill(Color.White);

            // Generate a blue curve with circle symbols, and "Beta" in the legend
            myCurve = myPane.AddCurve("64-Bit",
                list2, Color.Blue, SymbolType.Circle);
            // Fill the symbols with white
            myCurve.Symbol.Fill = new Fill(Color.White);
            // Associate this curve with the Y2 axis
            myCurve.IsY2Axis = true;

            // Show the x axis grid
            myPane.XAxis.MajorGrid.IsVisible = true;

            // Make the Y axis scale red
            myPane.YAxis.Scale.FontSpec.FontColor = Color.Red;
            myPane.YAxis.Title.FontSpec.FontColor = Color.Red;
            // turn off the opposite tics so the Y tics don't show up on the Y2 axis
            myPane.YAxis.MajorTic.IsOpposite = false;
            myPane.YAxis.MinorTic.IsOpposite = false;
            // Don't display the Y zero line
            myPane.YAxis.MajorGrid.IsZeroLine = false;
            // Align the Y axis labels so they are flush to the axis
            myPane.YAxis.Scale.Align = AlignP.Inside;
            // Manually set the axis range
            myPane.YAxis.Scale.Min = 0;
            myPane.YAxis.Scale.Max = 300;

            // Enable the Y2 axis display
            myPane.Y2Axis.IsVisible = true;
            // Make the Y2 axis scale blue
            myPane.Y2Axis.Scale.FontSpec.FontColor = Color.Blue;
            myPane.Y2Axis.Title.FontSpec.FontColor = Color.Blue;
            // turn off the opposite tics so the Y2 tics don't show up on the Y axis
            myPane.Y2Axis.MajorTic.IsOpposite = false;
            myPane.Y2Axis.MinorTic.IsOpposite = false;
            // Display the Y2 axis grid lines
            myPane.Y2Axis.MajorGrid.IsVisible = true;
            // Align the Y2 axis labels so they are flush to the axis
            myPane.Y2Axis.Scale.Align = AlignP.Inside;

            // Fill the axis background with a gradient
            myPane.Chart.Fill = new Fill(Color.White, Color.LightGray, 45.0f);

            // Add a text box with instructions
            TextObj text = new TextObj(
                "Zoom: left mouse & drag\nPan: middle mouse & drag\nContext Menu: right mouse",
                0.05f, 0.95f, CoordType.ChartFraction, AlignH.Left, AlignV.Bottom);
            text.FontSpec.StringAlignment = StringAlignment.Near;
            myPane.GraphObjList.Add(text);

            // Enable scrollbars if needed
            zedGraphControl1.IsShowHScrollBar = true;
            zedGraphControl1.IsShowVScrollBar = true;
            zedGraphControl1.IsAutoScrollRange = true;
            zedGraphControl1.IsScrollY2 = true;

            // OPTIONAL: Show tooltips when the mouse hovers over a point
            zedGraphControl1.IsShowPointValues = true;
            zedGraphControl1.PointValueEvent += new ZedGraphControl.PointValueHandler(MyPointValueHandler);

            // OPTIONAL: Add a custom context menu item
            zedGraphControl1.ContextMenuBuilder += new ZedGraphControl.ContextMenuBuilderEventHandler(
                            MyContextMenuBuilder);

            // OPTIONAL: Handle the Zoom Event
            zedGraphControl1.ZoomEvent += new ZedGraphControl.ZoomEventHandler(MyZoomEvent);

            // Size the control to fit the window
            SetSize();

            // Tell ZedGraph to calculate the axis ranges
            // Note that you MUST call this after enabling IsAutoScrollRange, since AxisChange() sets
            // up the proper scrolling parameters
            zedGraphControl1.AxisChange();
            // Make sure the Graph gets redrawn
            zedGraphControl1.Invalidate();
        }

        private void Form1_Resize(object sender, EventArgs e)
        {
            SetSize();
        }

        private void SetSize()
        {
            zedGraphControl1.Location = new Point(10, 10);
            // Leave a small margin around the outside of the control
            zedGraphControl1.Size = new Size(this.ClientRectangle.Width - 20,
                    this.ClientRectangle.Height - 20);
        }

        /// <summary>
        /// Display customized tooltips when the mouse hovers over a point
        /// </summary>
        private string MyPointValueHandler(ZedGraphControl control, GraphPane pane,
                        CurveItem curve, int iPt)
        {
            // Get the PointPair that is under the mouse
            PointPair pt = curve[iPt];

            if (iPt % 2 > 0)
            {
                if (curve.Label.Text == "32-Bit")
                {
                    return itemList32Bit.List[iPt / 2].Name + " took " + pt.Y.ToString("f2") + " seconds ending at " + pt.X.ToString("f1") + " minutes";
                }
                else
                {
                    return itemList64Bit.List[iPt / 2].Name + " took " + pt.Y.ToString("f2") + " seconds ending at " + pt.X.ToString("f1") + " minutes";
                }
                //return curve.Label.Text + " took " + pt.Y.ToString("f2") + " seconds for a task ending at " + pt.X.ToString("f1") + " minutes";
            }
            else
            {
                if (curve.Label.Text == "32-Bit")
                {
                    return itemList32Bit.List[iPt / 2].Name + " took " + pt.Y.ToString("f2") + " seconds starting at " + pt.X.ToString("f1") + " minutes";
                }
                else
                {
                    return itemList64Bit.List[iPt / 2].Name + " took " + pt.Y.ToString("f2") + " seconds starting at " + pt.X.ToString("f1") + " minutes";
                }
                //return curve.Label.Text + " took " + pt.Y.ToString("f2") + " seconds for a task starting at " + pt.X.ToString("f1") + " minutes";
            }
        }

        /// <summary>
        /// Customize the context menu by adding a new item to the end of the menu
        /// </summary>
        private void MyContextMenuBuilder(ZedGraphControl control, ContextMenuStrip menuStrip,
                        Point mousePt, ZedGraphControl.ContextMenuObjectState objState)
        {
            ToolStripMenuItem item = new ToolStripMenuItem();
            item.Name = "add-beta";
            item.Tag = "add-beta";
            item.Text = "Add a new Beta Point";
            item.Click += new System.EventHandler(AddBetaPoint);

            menuStrip.Items.Add(item);
        }

        /// <summary>
        /// Handle the "Add New Beta Point" context menu item.  This finds the curve with
        /// the CurveItem.Label = "Beta", and adds a new point to it.
        /// </summary>
        private void AddBetaPoint(object sender, EventArgs args)
        {
            // Get a reference to the "Beta" curve IPointListEdit
            IPointListEdit ip = zedGraphControl1.GraphPane.CurveList["Beta"].Points as IPointListEdit;
            if (ip != null)
            {
                double x = ip.Count * 5.0;
                double y = Math.Sin(ip.Count * Math.PI / 15.0) * 16.0 * 13.5;
                ip.Add(x, y);
                zedGraphControl1.AxisChange();
                zedGraphControl1.Refresh();
            }
        }

        // Respond to a Zoom Event
        private void MyZoomEvent(ZedGraphControl control, ZoomState oldState,
                    ZoomState newState)
        {
            // Here we get notification everytime the user zooms
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\InfrastructureProfiler\DeploymentProfiler\DeploymentProfileViewer\Properties\Settings.Designer.cs ===
﻿//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:2.0.50727.1434
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace DeploymentProfileViewer.Properties
{


    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.VisualStudio.Editors.SettingsDesigner.SettingsSingleFileGenerator", "9.0.0.0")]
    internal sealed partial class Settings : global::System.Configuration.ApplicationSettingsBase
    {

        private static Settings defaultInstance = ((Settings)(global::System.Configuration.ApplicationSettingsBase.Synchronized(new Settings())));

        public static Settings Default
        {
            get
            {
                return defaultInstance;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\InfrastructureProfiler\DeploymentProfiler\DeploymentProfileViewer\Properties\Resources.Designer.cs ===
﻿//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:2.0.50727.1434
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace DeploymentProfileViewer.Properties
{


    /// <summary>
    ///   A strongly-typed resource class, for looking up localized strings, etc.
    /// </summary>
    // This class was auto-generated by the StronglyTypedResourceBuilder
    // class via a tool like ResGen or Visual Studio.
    // To add or remove a member, edit your .ResX file then rerun ResGen
    // with the /str option, or rebuild your VS project.
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "2.0.0.0")]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
    internal class Resources
    {

        private static global::System.Resources.ResourceManager resourceMan;

        private static global::System.Globalization.CultureInfo resourceCulture;

        [global::System.Diagnostics.CodeAnalysis.SuppressMessageAttribute("Microsoft.Performance", "CA1811:AvoidUncalledPrivateCode")]
        internal Resources()
        {
        }

        /// <summary>
        ///   Returns the cached ResourceManager instance used by this class.
        /// </summary>
        [global::System.ComponentModel.EditorBrowsableAttribute(global::System.ComponentModel.EditorBrowsableState.Advanced)]
        internal static global::System.Resources.ResourceManager ResourceManager
        {
            get
            {
                if ((resourceMan == null))
                {
                    global::System.Resources.ResourceManager temp = new global::System.Resources.ResourceManager("DeploymentProfileViewer.Properties.Resources", typeof(Resources).Assembly);
                    resourceMan = temp;
                }
                return resourceMan;
            }
        }

        /// <summary>
        ///   Overrides the current thread's CurrentUICulture property for all
        ///   resource lookups using this strongly typed resource class.
        /// </summary>
        [global::System.ComponentModel.EditorBrowsableAttribute(global::System.ComponentModel.EditorBrowsableState.Advanced)]
        internal static global::System.Globalization.CultureInfo Culture
        {
            get
            {
                return resourceCulture;
            }
            set
            {
                resourceCulture = value;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\InfrastructureProfiler\DeploymentProfiler\deploymentXmlProfile\XBLDeployment\XblDeploymentItem.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace XBLDeployment
{
    /// <summary>
    /// XBL Deployment Type
    /// </summary>
    public enum XblDeploymentType
    {
        Command,
        Msi,
    }

    public class XblDeploymentSubItem : IComparable<XblDeploymentSubItem>
    {
        public String Description
        {
            get;
            set;
        }
        public DateTime StartTime
        {
            get;
            set;
        }
        public DateTime EndTime
        {
            get;
            set;
        }

        public TimeSpan Duration
        {
            get { return EndTime - StartTime; }
        }

        public XblDeploymentSubItem(String description)
        {
            Description = description;
            StartTime = DateTime.Now;
            EndTime = DateTime.Now;
        }

        public override string ToString()
        {
            return String.Format("[{0}] {1}", StartTime, Description);
        }

        public int CompareTo(XblDeploymentSubItem other)
        {
            return StartTime.CompareTo(other.StartTime);
        }
    }

    /// <summary>
    /// XBL Deployment Item Class
    /// </summary>
    public class XblDeploymentItem : IComparable<XblDeploymentItem>
    {
        #region Properties

        public String Name
        {
            get;
            set;
        }
        public XblDeploymentType Type
        {
            get;
            set;
        }
        public String ServerName
        {
            get;
            set;
        }
        public DateTime StartTime
        {
            get;
            set;
        }
        public DateTime EndTime
        {
            get;
            set;
        }
        public List<XblDeploymentSubItem> DetailItemList
        {
            get;
            set;
        }

        public TimeSpan Duration
        {
            get { return EndTime - StartTime; }
        }

        #endregion

        public XblDeploymentItem(String name, XblDeploymentType type, String serverName)
        {
            Name = name;
            Type = type;
            StartTime = DateTime.Now;
            EndTime = DateTime.Now;
            ServerName = serverName;
            DetailItemList = new List<XblDeploymentSubItem>();
        }

        public override string ToString()
        {
            return Name;
        }

        public int CompareTo(XblDeploymentItem other)
        {
            return StartTime.CompareTo(other.StartTime);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\KickUser\makefile.inc ===
!include $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\InfrastructureProfiler\DeploymentProfiler\deploymentXmlProfile\Arguments.cs ===
﻿using System;
using System.Collections.Specialized;
using System.Text.RegularExpressions;

namespace deploymentXmlProfile
{
    /// <summary>
    /// Arguments class from http://www.codeproject.com/KB/recipes/command_line.aspx
    /// </summary>
    public class Arguments
    {
        // Variables
        private StringDictionary Parameters;

        // Constructor
        public Arguments(string[] Args)
        {
            Parameters = new StringDictionary();
            Regex Spliter = new Regex(@"^-{1,2}|^/|=|:",
                RegexOptions.IgnoreCase | RegexOptions.Compiled);

            Regex Remover = new Regex(@"^['""]?(.*?)['""]?$",
                RegexOptions.IgnoreCase | RegexOptions.Compiled);

            string Parameter = null;
            string[] Parts;

            // Valid parameters forms:
            // {-,/,--}param{ ,=,:}((",')value(",'))
            // Examples: 
            // -param1 value1 --param2 /param3:"Test-:-work" 
            //   /param4=happy -param5 '--=nice=--'
            foreach (string Txt in Args)
            {
                // Look for new parameters (-,/ or --) and a
                // possible enclosed value (=,:)
                Parts = Spliter.Split(Txt, 3);

                switch (Parts.Length)
                {
                    // Found a value (for the last parameter 
                    // found (space separator))
                    case 1:
                        if (Parameter != null)
                        {
                            if (!Parameters.ContainsKey(Parameter))
                            {
                                Parts[0] =
                                    Remover.Replace(Parts[0], "$1");

                                Parameters.Add(Parameter, Parts[0]);
                            }
                            Parameter = null;
                        }
                        // else Error: no parameter waiting for a value (skipped)
                        break;

                    // Found just a parameter
                    case 2:
                        // The last parameter is still waiting. 
                        // With no value, set it to true.
                        if (Parameter != null)
                        {
                            if (!Parameters.ContainsKey(Parameter))
                                Parameters.Add(Parameter, "true");
                        }
                        Parameter = Parts[1];
                        break;

                    // Parameter with enclosed value
                    case 3:
                        // The last parameter is still waiting. 
                        // With no value, set it to true.
                        if (Parameter != null)
                        {
                            if (!Parameters.ContainsKey(Parameter))
                                Parameters.Add(Parameter, "true");
                        }

                        Parameter = Parts[1];

                        // Remove possible enclosing characters (",')
                        if (!Parameters.ContainsKey(Parameter))
                        {
                            Parts[2] = Remover.Replace(Parts[2], "$1");
                            Parameters.Add(Parameter, Parts[2]);
                        }

                        Parameter = null;
                        break;
                }
            }
            // In case a parameter is still waiting
            if (Parameter != null)
            {
                if (!Parameters.ContainsKey(Parameter))
                    Parameters.Add(Parameter, "true");
            }
        }

        // Retrieve a parameter value if it exists 
        // (overriding C# indexer property)
        public string this[string Param]
        {
            get
            {
                return (Parameters[Param]);
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\InfrastructureProfiler\DeploymentProfiler\deploymentXmlProfile\Properties\AssemblyInfo.cs ===
﻿using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
[assembly: AssemblyTitle("deploymentXmlProfile")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyCompany("Microsoft")]
[assembly: AssemblyProduct("deploymentXmlProfile")]
[assembly: AssemblyCopyright("Copyright © Microsoft 2009")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]

// Setting ComVisible to false makes the types in this assembly not visible 
// to COM components.  If you need to access a type in this assembly from 
// COM, set the ComVisible attribute to true on that type.
[assembly: ComVisible(false)]

// The following GUID is for the ID of the typelib if this project is exposed to COM
[assembly: Guid("4c409fe6-8cbe-4d29-9ebe-172f587c397b")]

// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version 
//      Build Number
//      Revision
//
// You can specify all the values or you can default the Build and Revision Numbers 
// by using the '*' as shown below:
// [assembly: AssemblyVersion("1.0.*")]
[assembly: AssemblyVersion("1.0.0.0")]
[assembly: AssemblyFileVersion("1.0.0.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\InfrastructureProfiler\DeploymentProfiler\deploymentXmlProfile\XBLDeployment\XblDeploymentItemList.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace XBLDeployment
{
    public class XblDeploymentItemList
    {
        List<XblDeploymentItem> itemList;
        public TimeSpan Duration
        {
            get;
            set;
        }
        List<String> serverList;

        public XblDeploymentItemList(List<XblDeploymentItem> list)
        {
            itemList = list;
            Duration = TimeSpan.Zero;
            serverList = new List<String>();

            foreach (XblDeploymentItem item in list)
            {
                Duration = Duration.Add(item.Duration);
                if (!serverList.Contains(item.ServerName))
                {
                    serverList.Add(item.ServerName);
                }
                serverList.Sort();
            }
        }

        /// <summary>
        /// Returns XblDeploymentItemList of all items containing the name filter
        /// </summary>
        /// <param name="filter">Name filter to check for</param>
        /// <returns>New XblDeploymentItemList subset</returns>
        public XblDeploymentItemList GetFilteredList(String filter)
        {
            List<XblDeploymentItem> list = new List<XblDeploymentItem>();

            foreach (XblDeploymentItem item in itemList)
            {
                if (item.Name.Contains(filter))
                {
                    list.Add(item);
                }
            }

            return new XblDeploymentItemList(list);
        }

        /// <summary>
        /// Returns XblDeploymentItemList of all items containing the type filter
        /// </summary>
        /// <param name="filter">Type filter to check for</param>
        /// <returns>New XblDeploymentItemList subset</returns>
        public XblDeploymentItemList GetFilteredList(XblDeploymentType filter)
        {
            List<XblDeploymentItem> list = new List<XblDeploymentItem>();

            foreach (XblDeploymentItem item in itemList)
            {
                if (item.Type == filter)
                {
                    list.Add(item);
                }
            }

            return new XblDeploymentItemList(list);
        }

        /// <summary>
        /// Returns XblDeploymentItemList of all items for the specified server
        /// </summary>
        /// <param name="serverName">Server name to look for</param>
        /// <returns>New XblDeploymentItemList subset</returns>
        public XblDeploymentItemList GetServerFilteredList(String serverName)
        {
            List<XblDeploymentItem> list = new List<XblDeploymentItem>();

            foreach (XblDeploymentItem item in itemList)
            {
                if (item.ServerName.ToLower() == serverName.ToLower())
                {
                    list.Add(item);
                }
            }

            return new XblDeploymentItemList(list);
        }

        public List<XblDeploymentItem> List
        {
            get { return itemList; }
        }

        public List<String> ServerList
        {
            get { return serverList; }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\licensetransfer\exe\obj\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("DEPOT")]
[assembly:System.Reflection.AssemblyCopyright("")]
[assembly:System.Reflection.AssemblyCompany("")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\InfrastructureProfiler\DeploymentProfiler\deploymentXmlProfile\Program.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

using XBLDeployment;

namespace deploymentXmlProfile
{
    class Program
    {
        static void Main(string[] args)
        {
            // Parse arguments
            Arguments commandLine = new Arguments(args);

            if (commandLine["sessionDir"] == null ||
                commandLine["help"] != null)
            {
                // Print Usage
                Console.WriteLine("Usage: \n" + 
                                  @"\tdeploymentXmlProfile.exe -sessionDir=""dir"" [-out=""filename""] [-help] [-filter=""filterString""] [-type=""Command/Msi""] [-server=""serverName""]");
                return;
            }

            String outputXml = commandLine["out"] == null ? "out.xml" : commandLine["out"];

            String topologyName;
            String releaseName;
            String deploymentType;
            String controlMachineName;

            // --- Read Deployment XML ---
            XblDeploymentItemCollection deploymentList = XblDeploymentUtil.LoadDeploymentSession(commandLine["sessionDir"], out topologyName, out releaseName, out deploymentType, out controlMachineName);

            // --- Apply Filters ---
            XblDeploymentItemList itemList = deploymentList.GetChronologicalList();

            if (commandLine["filter"] != null)
            {
                itemList = itemList.GetFilteredList(commandLine["filter"]);
            }

            if (commandLine["type"] != null)
            {
                switch (commandLine["type"].ToLower())
                {
                    case "command":
                        itemList = itemList.GetFilteredList(XblDeploymentType.Command);
                        break;
                    case "msi":
                        itemList = itemList.GetFilteredList(XblDeploymentType.Msi);
                        break;
                    default:
                        throw new ArgumentException("Unrecognized Type Filter");
                }
            }

            if (commandLine["server"] != null)
            {
                itemList = itemList.GetServerFilteredList(commandLine["server"]);
            }

            // --- Write Out Durations ---
            XblDeploymentUtil.SaveDeploymentProfile(itemList, outputXml, topologyName, releaseName, deploymentType, controlMachineName);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\licensetransfer\exe\objd\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("DEPOT")]
[assembly:System.Reflection.AssemblyCopyright("")]
[assembly:System.Reflection.AssemblyCompany("")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\InfrastructureProfiler\DeploymentProfiler\deploymentXmlProfile\XBLDeployment\XblDeploymentUtil.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Xml;
using System.IO;
using System.Text.RegularExpressions;

namespace XBLDeployment
{
    public class XblDeploymentUtil
    {
        /// <summary>
        /// Loads a Deployment Session
        /// </summary>
        /// <param name="deploymentSessionPath">Deployment Session Path</param>
        /// <param name="topologyName">Topology String Output</param>
        /// <param name="releaseName">Release Name String Output</param>
        /// <param name="deploymentType">Deployment Type String Output</param>
        /// <param name="controlMachineName">Control Machine Name Output</param>
        public static XblDeploymentItemCollection LoadDeploymentSession(String deploymentSessionPath, out String topologyName, out String releaseName, out String deploymentType, out String controlMachineName)
        {
            String deploymentSessionXml = Path.Combine(deploymentSessionPath, "deploymentSession.xml");
            XblDeploymentItemCollection deploymentList = new XblDeploymentItemCollection();
            XmlDocument xmlDoc = new XmlDocument();
            try
            {
                xmlDoc.Load(deploymentSessionXml);
            }
            catch (DirectoryNotFoundException)
            {
                topologyName = "";
                releaseName = "";
                deploymentType = "";
                controlMachineName = "";
                return null;
            }

            XmlNode root = xmlDoc.DocumentElement;
            XmlNodeList nodeList;

            // Get Deployment Session Info
            nodeList = root.SelectNodes("/deploymentSession/deploymentInstanceConfiguration");

            topologyName = nodeList[0].Attributes["topologyName"].Value;
            releaseName = nodeList[0].Attributes["releaseName"].Value;
            deploymentType = nodeList[0].Attributes["DeploymentType"].Value;
            controlMachineName = nodeList[0].Attributes["controllerMachine"].Value;

            // Command Start Times
            nodeList = root.SelectNodes("/deploymentSession/commandStarted");
            foreach (XmlNode commandStart in nodeList)
            {
                String name = commandStart.Attributes["name"].Value;
                DateTime startTime = DateTime.Parse(commandStart.Attributes["timeStamp"].Value);
                String serverName = commandStart.Attributes["serverName"].Value;
                deploymentList[name] = new XblDeploymentItem(name, XblDeploymentType.Command, serverName);
                deploymentList[name].StartTime = startTime;
            }
            // Command End Times
            nodeList = root.SelectNodes("/deploymentSession/commandFinished");
            foreach (XmlNode commandEnd in nodeList)
            {
                String name = commandEnd.Attributes["name"].Value;
                DateTime endTime = DateTime.Parse(commandEnd.Attributes["timeStamp"].Value);
                deploymentList[name].EndTime = endTime;

                // Load SubItems from text log
                String logFile = Path.Combine(Path.Combine(deploymentSessionPath, commandEnd.Attributes["serverName"].Value), commandEnd.Attributes["mainLogFile"].Value);
                StreamReader textLog = new StreamReader(logFile);
                String line;
                XblDeploymentSubItem subItem = null;
                DateTime timestamp = DateTime.Now;
                while ((line = textLog.ReadLine()) != null)
                {
                    // Skip Verbose SQL command outputs
                    if (line.Contains("Verbose:"))
                    {
                        continue;
                    }
                    // Timestamped lines are more than 12-chars long
                    if (line.Length > 12 && DateTime.TryParse(line.Substring(0, 8), out timestamp))
                    {
                        if (subItem == null)
                        {
                            // First Item
                            String description = line.Substring(13, line.Length - 13);
                            subItem = new XblDeploymentSubItem(description);
                            subItem.StartTime = timestamp;
                        }
                        else
                        {
                            // Add where end time is the following object's start time
                            subItem.EndTime = timestamp;
                            deploymentList[name].DetailItemList.Add(subItem);
                            // Start the next item
                            String description = line.Substring(13, line.Length - 13);
                            subItem = new XblDeploymentSubItem(description);
                            subItem.StartTime = timestamp;
                        }
                    }
                }
                // Close out the last subItem
                if (subItem != null)
                {
                    subItem.EndTime = timestamp;
                    deploymentList[name].DetailItemList.Add(subItem);
                }
                textLog.Close();
            }

            // MSI Start Times
            nodeList = root.SelectNodes("/deploymentSession/msiStarted");
            foreach (XmlNode msiStart in nodeList)
            {
                String name = msiStart.Attributes["msiName"].Value;
                DateTime startTime = DateTime.Parse(msiStart.Attributes["timeStamp"].Value);
                String serverName = msiStart.Attributes["serverName"].Value;
                deploymentList[name] = new XblDeploymentItem(name, XblDeploymentType.Msi, serverName);
                deploymentList[name].StartTime = startTime;
            }
            // MSI End Times
            nodeList = root.SelectNodes("/deploymentSession/msiFinished");
            foreach (XmlNode msiEnd in nodeList)
            {
                String name = msiEnd.Attributes["msiName"].Value;
                DateTime endTime = DateTime.Parse(msiEnd.Attributes["timeStamp"].Value);
                deploymentList[name].EndTime = endTime;

                // Load SubItems from text log
                String logFile = Path.Combine(Path.Combine(deploymentSessionPath, msiEnd.Attributes["serverName"].Value), msiEnd.Attributes["logFile"].Value);
                StreamReader textLog = new StreamReader(logFile);
                String line;
                String installerLog = null;
                XblDeploymentSubItem subItem = null;
                
                // use milliseconds to allow order to be kept when sorting datetimes.  MSIs do not use the milliseconds field, so 
                // we'll fill that field with an order (and disallow anything from taking less than 1 ms).
                int orderMilliseconds = 0;
                while ((line = textLog.ReadLine()) != null)
                {
                    if (line.StartsWith("Action start"))
                    {
                        // Skip the overall install action
                        if (!line.EndsWith(": INSTALL."))
                        {
                            int lastColon = line.LastIndexOf(':');
                            String description = line.Substring(lastColon + 1, line.Length - lastColon - 1);
                            subItem = new XblDeploymentSubItem("MSI: " + description);
                            subItem.StartTime = DateTime.Parse(line.Substring(13, lastColon - 13));

                            // Tack on the ordering stamp
                            subItem.StartTime = subItem.StartTime.AddMilliseconds(orderMilliseconds ++);
                        }
                    }
                    else if (line.StartsWith("Action ended"))
                    {
                        // Skip the overall install action
                        if (!line.EndsWith(": INSTALL. Return value 1."))
                        {
                            int lastColon = line.LastIndexOf(':');
                            subItem.EndTime = DateTime.Parse(line.Substring(13, lastColon - 13));
                            subItem.EndTime = subItem.EndTime.AddMilliseconds(orderMilliseconds++);
                            deploymentList[name].DetailItemList.Add(subItem);
                        }
                    }
                    else if (line.Contains("InstallUtil.Install.LoggingMethod") && line.Contains("/LogFile="))
                    {
                        installerLog = line.Substring(line.IndexOf("/LogFile=") + 9);
                    }
                }
                textLog.Close();

                if (installerLog != null)
                {
                    using (StreamReader installerLogReader = new StreamReader(installerLog))
                    {
                        // \[(?<Day>\d\d)-(?<Month>\d\d)-(?<Year>\d\d\d\d) (?<Hour>\d\d):(?<Minute>\d\d):(?<Second>\d\d).(?<Fraction>\d\d\d)\] (?<Message>.*)
                        System.Text.RegularExpressions.Regex reExtractDate = new System.Text.RegularExpressions.Regex(
                            "\\[(?<Day>\\d\\d)-(?<Month>\\d\\d)-(?<Year>\\d\\d\\d\\d) (?<Hour>\\d\\d):(?<Minute>\\d\\d):(?<" +
                            "Second>\\d\\d).(?<Fraction>\\d\\d\\d)\\] (?<Message>.*)",
                            ((System.Text.RegularExpressions.RegexOptions.Compiled |
                            System.Text.RegularExpressions.RegexOptions.ExplicitCapture)
                            | System.Text.RegularExpressions.RegexOptions.IgnoreCase));

                        DateTime previousLine = DateTime.MinValue;
                        while ((line = installerLogReader.ReadLine()) != null)
                        {
                            Match match = reExtractDate.Match(line);

                            if (!match.Success)
                                continue;

                            // Parse the time as intended (this is broken)
                            //DateTime parsed = new DateTime(
                            //    Int32.Parse(match.Groups["Year"].Captures[0].Value),
                            //    Int32.Parse(match.Groups["Month"].Captures[0].Value),
                            //    Int32.Parse(match.Groups["Day"].Captures[0].Value),
                            //    Int32.Parse(match.Groups["Hour"].Captures[0].Value),
                            //    Int32.Parse(match.Groups["Minute"].Captures[0].Value),
                            //    Int32.Parse(match.Groups["Second"].Captures[0].Value),
                            //    Int32.Parse(match.Groups["Fraction"].Captures[0].Value));

                            // MSI timestamps are HH:mm:ss in local time. Installutil timestamps are 
                            // YYYY-MM-DD HH:mm:ss.fff in local time, so drop the date and parse it 
                            // as if it is an MSI time, allowing timing to be right (sort of).
                            TimeSpan parsedTime = new TimeSpan(0,
                                Int32.Parse(match.Groups["Hour"].Captures[0].Value),
                                Int32.Parse(match.Groups["Minute"].Captures[0].Value),
                                Int32.Parse(match.Groups["Second"].Captures[0].Value),
                                Int32.Parse(match.Groups["Fraction"].Captures[0].Value));
                            if (DateTime.Now.Hour > 12)
                            {
                                parsedTime=parsedTime.Add(new TimeSpan(12, 0, 0));
                            }

                            DateTime parsed = DateTime.Now.Date.Add(parsedTime);
                            String message = match.Groups["Message"].Captures[0].Value;

                            subItem = new XblDeploymentSubItem("InstallUtil: " + message);

                            subItem.StartTime = previousLine == DateTime.MinValue ? parsed : previousLine;
                            subItem.EndTime = parsed;
                            previousLine = parsed;

                            deploymentList[name].DetailItemList.Add(subItem);
                        }
                    }

                    deploymentList[name].DetailItemList.Sort();
                }
            }

            return deploymentList;
        }

        /// <summary>
        /// Saves a Deployment Profile
        /// </summary>
        /// <param name="deploymentList">Deployment Item List</param>
        /// <param name="outputXml">Output Filepath</param>
        /// <param name="topologyName">Topology Name String</param>
        /// <param name="releaseName">Release Name String</param>
        /// <param name="deploymentType">Deployment Type String</param>
        /// <param name="controlMachineName">Control Machine Name</param>
        public static void SaveDeploymentProfile(XblDeploymentItemList deploymentList, String outputXml, String topologyName, String releaseName, String deploymentType, String controlMachineName)
        {
            XmlDocument outDoc = new XmlDocument();

            XmlProcessingInstruction profilePI = outDoc.CreateProcessingInstruction("xml-stylesheet", "href='profile.xslt' type='text/xsl'");
            outDoc.AppendChild(profilePI);
            XmlNode outRoot = outDoc.CreateElement("DeploymentProfile");

            XmlAttribute topologyAttribute = outDoc.CreateAttribute("Topology");
            topologyAttribute.Value = topologyName;
            outRoot.Attributes.Append(topologyAttribute);
            XmlAttribute releaseAttribute = outDoc.CreateAttribute("Release");
            releaseAttribute.Value = releaseName;
            outRoot.Attributes.Append(releaseAttribute);
            XmlAttribute deploymentTypeAttribute = outDoc.CreateAttribute("Type");
            deploymentTypeAttribute.Value = deploymentType;
            outRoot.Attributes.Append(deploymentTypeAttribute);
            XmlAttribute controlMachineAttribute = outDoc.CreateAttribute("ControllerMachine");
            controlMachineAttribute.Value = controlMachineName;
            outRoot.Attributes.Append(controlMachineAttribute);

            XmlAttribute totalDurationAttribute = outDoc.CreateAttribute("TotalDuration");
            totalDurationAttribute.Value = deploymentList.Duration.ToString();
            outRoot.Attributes.Append(totalDurationAttribute);

            foreach (String server in deploymentList.ServerList)
            {
                XmlNode serverNode = outDoc.CreateElement("Server");
                XmlAttribute serverNameAttribute = outDoc.CreateAttribute("Name");
                serverNameAttribute.Value = server;
                serverNode.Attributes.Append(serverNameAttribute);

                XblDeploymentItemList serverList = deploymentList.GetServerFilteredList(server);
                foreach (XblDeploymentItem item in serverList.List)
                {
                    XmlNode node = outDoc.CreateElement("Action");
                    XmlAttribute nameAttribute = outDoc.CreateAttribute("Name");
                    nameAttribute.Value = item.Name;
                    node.Attributes.Append(nameAttribute);

                    XmlAttribute typeAttribute = outDoc.CreateAttribute("Type");
                    typeAttribute.Value = item.Type.ToString();
                    node.Attributes.Append(typeAttribute);

                    XmlAttribute durationAttribute = outDoc.CreateAttribute("Duration");
                    durationAttribute.Value = item.Duration.ToString();
                    node.Attributes.Append(durationAttribute);

                    // Add Action SubItem Break-downs
                    foreach (XblDeploymentSubItem subItem in item.DetailItemList)
                    {
                        XmlNode subNode = outDoc.CreateElement("SubAction");
                        XmlAttribute subDescAttribute = outDoc.CreateAttribute("Description");
                        subDescAttribute.Value = subItem.Description;
                        subNode.Attributes.Append(subDescAttribute);

                        XmlAttribute subStartTimeAttribute = outDoc.CreateAttribute("StartTime");
                        subStartTimeAttribute.Value = subItem.StartTime.ToString();
                        subNode.Attributes.Append(subStartTimeAttribute);

                        XmlAttribute subDurationAttribute = outDoc.CreateAttribute("Duration");
                        subDurationAttribute.Value = subItem.Duration.ToString();
                        subNode.Attributes.Append(subDurationAttribute);

                        node.AppendChild(subNode);
                    }

                    serverNode.AppendChild(node);
                }
                outRoot.AppendChild(serverNode);
            }
            outDoc.AppendChild(outRoot);
            outDoc.Save(outputXml);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\liveexec\exe\obj\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("DEPOT")]
[assembly:System.Reflection.AssemblyCopyright("")]
[assembly:System.Reflection.AssemblyCompany("")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\KickUser\KickUser.cs ===
using System;
using System.Diagnostics;
using System.IO;
using System.Net.Sockets;
using xonline.common.user;
using xonline.common.service;
using xonline.common.tools.console;

namespace xonline.tools.kickuser 
{
    class CKickUserApp  
    {
        static NamedArgParser   _args       = null;
        static StreamWriter     _log        = null;
        static FileStream       _fslog      = null;
        static EventLog         _eventlog   = null;
        static uint             _hr         = HResult.S_OK;

        static string []        _tags       = {
                                                "?"
                                                ,"serversA"
                                                ,"serversB"
                                                ,"port"
                                                ,"gamertag"
                                              };
        
        /// <summary>
        /// The main entry point for the application.
        /// </summary>
        [STAThread]
        static int Main(string[] rawArgs)
        {
            try
            {
                _args = new NamedArgParser(_tags);

                if (!_args.Parse(rawArgs))
                {
                    Help();
                    Exit();
                }
            
                //
                //  Help?
                //

                if ((_args.Count == 0) || ((_args.Count == 1) && (_args["?"] != null)))
                {
                    Help();
                    Exit();
                }

                string logName = DateTime.Now.ToString("MMddyyyy_HHmmss") + ".log";

                if (!Directory.Exists(Environment.CurrentDirectory + "\\logs"))
                {
                    Directory.CreateDirectory(Environment.CurrentDirectory + "\\logs");
                }

                logName = Environment.CurrentDirectory + "\\logs\\" + logName;
                _fslog = new FileStream(logName, FileMode.Create, FileAccess.Write);
                _log = new StreamWriter(_fslog);

                _log.WriteLine(Environment.CommandLine);

                //
                //  Setup _eventlog
                //

                _eventlog = new EventLog();
                _eventlog.Source = "KickUser";
                
                //
                //  Now start parsing commands and figuring out what we need to do
                //

                if( _args["gamertag"] == null ||
                    _args["serversA"] == null ||
                    _args["port"]     == null )
                {
                    Help();
                    Exit();
                }

                //
                //  Kick the user
                //

                kickUser(_args["gamertag"], _args["serversA"], _args["serversB"], _args["port"]);
                
            }
            catch (Exception e)
            {
                if(_hr != HResult.S_OK)
                    CKickUserApp.WriteLine("FAIL: " + e.Message);
            }
            finally
            {
                if (null != _log)
                {
                    _log.Close();
                }
                if(null != _fslog)
                {
                    _fslog.Close();
                }
                if(null != _eventlog)
                {
                    _eventlog.Close();
                }
            }        
                
            return (int)(_hr);
        }

        public static void Help()
        {
            CKickUserApp.WriteLine("KickUser");
            CKickUserApp.WriteLine("\t/gamertag:<gamertag>");
            CKickUserApp.WriteLine("\t/port:<port>");
            CKickUserApp.WriteLine("\t/serversA:<PresenceServerIP1> [ ;<PresenceServerIP2>;... ]");
            CKickUserApp.WriteLine("\t[ /serversB:<PresenceServerIP1> [ ;<PresenceServerIP2>;... ] ]");
        }

        public static void WriteLine(string s)
        {
            Console.WriteLine(s);
            if (_eventlog != null && s.IndexOf("FAIL") >= 0)
                _eventlog.WriteEntry(s, EventLogEntryType.Error);

            if (_log != null)
            {
                _log.WriteLine(s);
                _log.Flush();
            }
        }

        private static bool kickUser(string presAddr, int presPort, ulong puid)
        {
            try
            {
                CKickMsg kickMsg = new CKickMsg();
                kickMsg.qwUserID = puid;

                TcpClient client = new TcpClient(presAddr, presPort);

                NetworkStream stream = client.GetStream();

                kickMsg.WriteToStream(stream);

                stream.Close();
                client.Close();

                WriteLine("Kick message successfully sent to " + presAddr + ":" + presPort.ToString() + ".");

                return true;
            }
            catch(Exception e)
            {
                WriteLine("Sending kick message to " + presAddr + ":" + presPort.ToString() + " failed.  Error = \"" + e.Message + "\".");
                return false;
            }
        }

        /// <summary>
        /// If we're configured for failover, this method attempts to contact a presence server
        /// on either of its configured addresses.  Returns false if neither was successful.
        /// </summary>
        /// <param name="presAddrA"></param>
        /// <param name="presAddrB"></param>
        /// <param name="presPort"></param>
        /// <param name="puid"></param>
        /// <returns></returns>
        private static bool kickUserWithFailover(string presAddrA, string presAddrB, int presPort, ulong puid)
        {
            if(kickUser(presAddrA, presPort, puid))
                return true;

            if(kickUser(presAddrB, presPort, puid))
                return true;

            return false;
        }

        /// <summary>
        /// This function will send a kick message to each presence server.
        /// </summary>
        /// <param name="puid"></param>
        /// <returns></returns>
        private static void kickUser(
            string gamertag,
            string presA,
            string presB,
            string port
            )
        {
            if(presA == null)
                Exit(HResult.E_INVALIDARG, "FAIL: At least one presence server must be specified.");

            if(port == null)
                Exit(HResult.E_INVALIDARG, "FAIL: Presence server port number must be specified.");

            string [] presAddrsA = presA.Split(';');
            string [] presAddrsB = (presB == null ? null : presB.Split(';'));
            int nPort = Int32.Parse(port);

            if(presAddrsB != null && presAddrsA.Length != presAddrsB.Length)
                Exit(HResult.E_INVALIDARG, "FAIL: Failover list does not contain the same number of servers as the primary list.");

            //
            //  Lookup puid for username
            //
            
            User u = new User();

            try
            {
                _hr = u.LoadFromGamerTag(gamertag);
                if(HResult.Failed(_hr))
                    Exit(_hr, "User \"" + gamertag + "\" not found in database.");

                WriteLine("User \"" + gamertag + "\" found in database.");
            }
            catch(Exception e)
            {
                Exit(HResult.E_FAIL, e.Message);
            }

            //
            //  Kick the user
            //

            if(presAddrsB != null)
            {
                for(int iCurAddr = 0; iCurAddr < presAddrsA.Length; ++iCurAddr)
                {
                    kickUserWithFailover(presAddrsA[iCurAddr], presAddrsB[iCurAddr], nPort, u.Puid);
                }
            }
            else
            {
                foreach(string addr in presAddrsA)
                {
                    kickUser(addr, nPort, u.Puid);
                }
            }
        }

        private static void Exit()
        {
            Exit(_hr, "");
        }

        private static void Exit(uint hr, string cause)
        {
            _hr = hr;
            throw new ApplicationException(cause);
        }
    }

    /// <summary>
    /// This class embodies the hello and kick messages in one chunk of memory.
    /// </summary>
    internal class CKickMsg
    {
        //  BASE_MSG_HEADER
        public uint dwMsgType_hello   = 1000;
        public uint dwMsgLen_hello    = 4;
        public uint dwSeqNum_hello    = 0;
        public byte [] sgaddr_hello   = new byte [] { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 };

        //  P_HELLO_MSG
        public uint dwProtocolVersion = 0x00010000;

        //  BASE_MSG_HEADER
        public uint dwMsgType_kick    = 1023;
        public uint dwMsgLen_kick     = 12;
        public uint dwSeqNum_kick     = 0;
        public byte [] sgaddr_kick    = new byte [] { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 };

        //  P_KICK
        public ulong qwUserID         = 0;
        public uint fFlush            = 1;

        public void WriteToStream(NetworkStream stream)
        {
            byte [] bytes;

            bytes = BitConverter.GetBytes(dwMsgType_hello);
            stream.Write(bytes, 0, bytes.Length);

            bytes = BitConverter.GetBytes(dwMsgLen_hello);
            stream.Write(bytes, 0, bytes.Length);

            bytes = BitConverter.GetBytes(dwSeqNum_hello);
            stream.Write(bytes, 0, bytes.Length);
        
            stream.Write(sgaddr_hello, 0, sgaddr_hello.Length);
        
            bytes = BitConverter.GetBytes(dwProtocolVersion);
            stream.Write(bytes, 0, bytes.Length);
        
            bytes = BitConverter.GetBytes(dwMsgType_kick);
            stream.Write(bytes, 0, bytes.Length);
        
            bytes = BitConverter.GetBytes(dwMsgLen_kick);
            stream.Write(bytes, 0, bytes.Length);
        
            bytes = BitConverter.GetBytes(dwSeqNum_kick);
            stream.Write(bytes, 0, bytes.Length);
        
            stream.Write(sgaddr_hello, 0, sgaddr_kick.Length);
        
            bytes = BitConverter.GetBytes(qwUserID);
            stream.Write(bytes, 0, bytes.Length);
        
            bytes = BitConverter.GetBytes(fFlush);
            stream.Write(bytes, 0, bytes.Length);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\InfrastructureProfiler\DeploymentProfiler\deploymentXmlProfile\XBLDeployment\XblDeploymentItemCollection.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace XBLDeployment
{
    /// <summary>
    /// XBL Deployment Item Wrapper Class
    /// </summary>
    public class XblDeploymentItemCollection
    {
        Dictionary<String, XblDeploymentItem> xblItems;
        List<String> serverList;

        public XblDeploymentItemCollection()
        {
            xblItems = new Dictionary<String, XblDeploymentItem>();
            serverList = new List<String>();
        }

        /// <summary>
        /// Return the alphabetical list of Deployment Items sorted by name
        /// </summary>
        /// <returns>List of XblDeploymentItem objects</returns>
        public XblDeploymentItemList GetAlphabeticalList()
        {
            List<XblDeploymentItem> list = new List<XblDeploymentItem>(xblItems.Values);

            list.Sort(new Comparison<XblDeploymentItem>(sortByName));

            return new XblDeploymentItemList(list);
        }

        /// <summary>
        /// Return the chronological list of Deployment Items sorted by start timestamp
        /// </summary>
        /// <returns>List of XblDeploymentItem objects</returns>
        public XblDeploymentItemList GetChronologicalList()
        {
            List<XblDeploymentItem> list = new List<XblDeploymentItem>(xblItems.Values);

            list.Sort(new Comparison<XblDeploymentItem>(sortByStartTime));

            return new XblDeploymentItemList(list);
        }

        public List<String> ServerList
        {
            get { return serverList; }
        }

        /// <summary>
        /// Get/Set a specific XblDeploymentItem by name
        /// </summary>
        /// <param name="name">Name of item</param>
        /// <returns>XblDeploymentItem</returns>
        /// <remarks>If name does not exist, it will create a new item</remarks>
        public XblDeploymentItem this[String name]
        {
            get { return xblItems[name]; }
            set
            {
                if (xblItems.Keys.Contains(name))
                {
                    xblItems[name] = value;
                    if (!serverList.Contains(value.ServerName))
                    {
                        serverList.Add(value.ServerName);
                        serverList.Sort();
                    }
                }
                else
                {
                    xblItems.Add(name, value);
                }
            }
        }

        #region Private Methods
        
        int sortByName(XblDeploymentItem item1, XblDeploymentItem item2)
        {
            return item1.Name.CompareTo(item2.Name);
        }

        int sortByStartTime(XblDeploymentItem item1, XblDeploymentItem item2)
        {
            return item1.StartTime.CompareTo(item2.StartTime);
        }

        #endregion
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\liveexec\exe\objd\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("DEPOT")]
[assembly:System.Reflection.AssemblyCopyright("")]
[assembly:System.Reflection.AssemblyCompany("")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\LiveTest\ESearch\makefile.inc ===
!include $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\LiveTest\ESearch\App_Code\AssemblyInfo.cs ===
using System.Reflection;
using System.Runtime.CompilerServices;

//
// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
//
[assembly: AssemblyTitle("")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyCompany("")]
[assembly: AssemblyProduct("")]
[assembly: AssemblyCopyright("")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]		

//
// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version 
//      Build Number
//      Revision
//
// You can specify all the values or you can default the Revision and Build Numbers 
// by using the '*' as shown below:

[assembly: AssemblyVersion("1.0.*")]

//
// In order to sign your assembly you must specify a key to use. Refer to the 
// Microsoft .NET Framework documentation for more information on assembly signing.
//
// Use the attributes below to control which key is used for signing. 
//
// Notes: 
//   (*) If no key is specified, the assembly is not signed.
//   (*) KeyName refers to a key that has been installed in the Crypto Service
//       Provider (CSP) on your machine. KeyFile refers to a file which contains
//       a key.
//   (*) If the KeyFile and the KeyName values are both specified, the 
//       following processing occurs:
//       (1) If the KeyName can be found in the CSP, that key is used.
//       (2) If the KeyName does not exist and the KeyFile does exist, the key 
//           in the KeyFile is installed into the CSP and used.
//   (*) In order to create a KeyFile, you can use the sn.exe (Strong Name) utility.
//        When specifying the KeyFile, the location of the KeyFile should be
//        relative to the "project output directory". The location of the project output
//        directory is dependent on whether you are working with a local or web project.
//        For local projects, the project output directory is defined as
//       <Project Directory>\obj\<Configuration>. For example, if your KeyFile is
//       located in the project directory, you would specify the AssemblyKeyFile 
//       attribute as [assembly: AssemblyKeyFile("..\\..\\mykey.snk")]
//        For web projects, the project output directory is defined as
//       %HOMEPATH%\VSWebCache\<Machine Name>\<Project Directory>\obj\<Configuration>.
//   (*) Delay Signing is an advanced option - see the Microsoft .NET Framework
//       documentation for more information on this.
//
[assembly: AssemblyDelaySign(false)]
[assembly: AssemblyKeyFile("")]
[assembly: AssemblyKeyName("")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\LiveTest\ESearch\App_Code\Global.asax.cs ===
using System;
using System.Collections;
using System.ComponentModel;
using System.Web;
using System.Web.SessionState;

namespace Events 
{
	/// <summary>
	/// Summary description for Global.
	/// </summary>
	public class Global : System.Web.HttpApplication
	{
		/// <summary>
		/// Required designer variable.
		/// </summary>
		private System.ComponentModel.IContainer components = null;

		public Global()
		{
			InitializeComponent();
		}	
		
		protected void Application_Start(Object sender, EventArgs e)
		{

		}
 
		protected void Session_Start(Object sender, EventArgs e)
		{

		}

		protected void Application_BeginRequest(Object sender, EventArgs e)
		{

		}

		protected void Application_EndRequest(Object sender, EventArgs e)
		{

		}

		protected void Application_AuthenticateRequest(Object sender, EventArgs e)
		{

		}

		protected void Application_Error(Object sender, EventArgs e)
		{

		}

		protected void Session_End(Object sender, EventArgs e)
		{

		}

		protected void Application_End(Object sender, EventArgs e)
		{

		}
			
		#region Web Form Designer generated code
		/// <summary>
		/// Required method for Designer support - do not modify
		/// the contents of this method with the code editor.
		/// </summary>
		private void InitializeComponent()
		{    
			this.components = new System.ComponentModel.Container();
		}
		#endregion
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\licensetransfer\licensetransfer.cs ===
using System;
using System.Data;
using System.Data.SqlClient;
using System.Diagnostics;
using System.Globalization;
using System.IO;
using System.Net;
using System.Reflection;
using System.Security.Cryptography;
using System.Text.RegularExpressions;
using System.Xml;
using System.Xml.Schema;
using System.Xml.Serialization;

using Microsoft.Webstore.WstClient;

using xonline.common.config;
using xonline.common.machine;
using xonline.common.mgmt;
using xonline.common.protocol;
using xonline.common.service;
using xonline.common.sql.webstore;
using xonline.common.tools.console;
using xonline.common.user;

namespace xonline.tools.licensetransfer
{
    public class LicenseTransfer
    {

        public static void TransferGamertag(string gamertag, string consoleid)
        {
            if (gamertag == null || consoleid == null)
            {
                throw new Exception("You must supply userpuid, oldmachinepuid, and newmachinepuid parameters.");
            }

            //
            // Do not call sproc's directly. Call into marketplace to load a user object
            // from this gamertag and determine the xuid from that
            // 
            User u = new User();
            u.LoadFromGamerTag(gamertag);

            Puid userPuid = u.Puid;
            Puid machineId = MachinePuidUtil.GetXbox360MachineIdFromConsoleIdAndXuid(String.Format("Xe.{0}", consoleid), userPuid);

            using (WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITEONLY_COMMANDTYPE))
            {
                //
                // BUGBUG - This sproc seems to do the correct thing. Way better than just having
                // something that executes sql directly.
                // 
                ws.StoredProc = "dbo.p_user_license_transfer_support";
                ws.SetHashVal(userPuid);
                ws.AddParameter(ParamType.INPUT, "@bi_xuid", userPuid );
                ws.AddParameter(ParamType.INPUT, "@bi_destination_machine_puid", machineId );

                ws.ExecuteNonQuery();
            }

            Console.WriteLine("Content has been migrated successfully!");
        }

        static void Usage()
        {
            Console.WriteLine("Usage:");
            Console.WriteLine();
            Console.WriteLine("  licensetransfer -action:transfergamertag -gamertag:<gamertag> -consoleid:<consoleid>");
        }


        static int Main(string [] rawArgs)
        {
            int retCode = 0;
            NamedArgParser args = new NamedArgParser();
            args.Parse(rawArgs);

            /////////////////
            // Just to give time to attach in the debugger, if you don't have a VC# Project ready-made...
            string sleep = args["sleep"];
            if (sleep != null)
                System.Threading.Thread.Sleep(Convert.ToInt32(sleep));
            /////////////////                     
            
            string action = args["action"];
            if (action == null)
                action = "";

            try
            {
                switch(action.ToLower())
                {
                    case "transfergamertag":
                        TransferGamertag(args["gamertag"], args["consoleid"]);
                        break;

                    default:
                        Usage();
                        break;
                }
            }
            catch (Exception e)
            {
                Console.WriteLine(e.Message);
                retCode = -1;
            }

            /////////////////
            // Just to give time to view debug output...
            if (sleep != null)
                System.Threading.Thread.Sleep(Convert.ToInt32(sleep));
            /////////////////   
            
            return retCode;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\LiveTest\ESearchSetup\External\makefile.inc ===
!include $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\LiveTest\ESearchSetup\Internal\makefile.inc ===
!include $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\LiveTest\ESearch\Default.aspx.cs ===
using System;
using System.Configuration;
using System.Collections;
using System.ComponentModel;
using System.Xml;
using System.Data;
using System.Drawing;
using System.Web;
using System.Web.SessionState;
using System.Web.UI;
using System.Web.UI.WebControls;
using System.Web.UI.HtmlControls;
using System.Data.SqlClient;
using System.Globalization;


namespace Events
{
	/// <summary>
	/// Summary description for WebForm1.
	/// </summary>
    public partial class WebForm1 : System.Web.UI.Page
    {
        public int TimeOffset = 0; //to convert from GMT to PST
        public string TimeZoneText = "GMT";

        //stupid function because XETESTSQL001 does not use DST.
        protected void SetTimeVars()
        {
            Boolean IsDST = false;
            int year = DateTime.Now.Year;
            if (year == 2007)
            {
                if (DateTime.Now.DayOfYear >= 70 && DateTime.Now.DayOfYear < 308)
                    IsDST = true;
            }
            //leap year
            if (year == 2008)
            {
                if (DateTime.Now.DayOfYear >= 69 && DateTime.Now.DayOfYear < 307)
                    IsDST = true;
            }
            if (year == 2009)
            {
                if (DateTime.Now.DayOfYear >= 67 && DateTime.Now.DayOfYear < 305)
                    IsDST = true;
            }
            if (year == 2010)
            {
                if (DateTime.Now.DayOfYear >= 73 && DateTime.Now.DayOfYear < 311)
                    IsDST = true;
            }
            if (PSTRadioButton.Checked == true)
            {
                TimeZone time = TimeZone.CurrentTimeZone;
                DaylightTime temp = time.GetDaylightChanges(DateTime.Now.Year);
                if (IsDST) TimeOffset = -7;
                else TimeOffset = -8;
                TimeZoneText = "PST";
            }
            else
            {
                TimeOffset = 0;
                TimeZoneText = "GMT";
            }

        }

        private void LoadLinks()
        {
            try
            {
               ESearchLink.NavigateUrl = ConfigurationManager.AppSettings["ESearchLink"];
               GrapherLink.NavigateUrl = ConfigurationManager.AppSettings["GrapherLink"];
               PerfDADLink.NavigateUrl = ConfigurationManager.AppSettings["PerfDADLink"];
               RegressionLink.NavigateUrl = ConfigurationManager.AppSettings["RegressionLink"];
             
            }
            catch(Exception e)
            {
                System.Diagnostics.EventLog eventLog = new System.Diagnostics.EventLog("Application");
                eventLog.Source = "ESearch";
                eventLog.WriteEntry("Error loading links from web.config.\n" + e.ToString(), System.Diagnostics.EventLogEntryType.Error, (int)1);
                eventLog.Close();

                ESearchLink.Visible = false;
                GrapherLink.Visible = false;
                PerfDADLink.Visible = false;
                RegressionLink.Visible = false;
            }



        }

        protected void Page_Load(object sender, System.EventArgs e)
        {
            // Runs whenever a post back occurs
            /*string path = Request.PhysicalPath;
            path = path.Substring(0, path.LastIndexOf('\\') + 1);
            path += "ConfigXML\\";*/

            LoadLinks();
           
            //Set default button (what gets "clicked" when the user presses enter)
            //SetDefaultButtons();
            //deal with TIME RADIO BUTTONS
            SetTimeVars();

            if (!this.IsPostBack)
            {
                //happens only when the page is first loaded
               
                //sets the default environment to testnet (the dropdown box hasn't loaded yet)
                BuildEnvDropDown();
                EnvDropDown.SelectedIndex = 0;
                EventDB.SetEnvironment(EnvDropDown.SelectedValue, "");
                //EventDB.SetEnvironment("testnet", path);
                // NPDB.SetEnvironment("testnet");
                //serverlist is actually serviceslist
                ServerList.Items.Clear();
                ServerList.Items.Add(new ListItem("<All Services>", "All Services"));
                EventDB.GetServicesList(ServerList.Items);
                ServerList.SelectedIndex = 0;

                //string env = "TESTNET";
                //testNetTime.Text = env + " Time in " + TimeZoneText + ":  " + DateTime.Now.AddHours(TimeOffset);
                Form1.DefaultButton = Search.UniqueID;
            }
            else if (Request.Form.GetValues(0)[0].Equals("CopyButton"))
            {
                Form1.DefaultButton = Search.UniqueID;
                if (RSearch.Visible == false)
                {
                    Form1.DefaultButton = backtoResults.UniqueID;
                }
            }
            //DEAL WITH ENVIRONMENT SELECTION
            
            string env = EnvDropDown.SelectedValue;
            //EventDB.SetEnvironment(EnvDropDown.SelectedValue, path);
            //NPDB.SetEnvironment(EnvDropDown.SelectedValue);
            testNetTime.Text = env + " Time in " + TimeZoneText + ": " + DateTime.Now.AddHours(TimeOffset);
            NoResultsLabel.Text = "No Results Found";
        }

        private void BuildEnvDropDown()
        {
            EnvDropDown.Items.Clear();

            //load from the xml file
            /*string path = Request.PhysicalPath;
            path = path.Substring(0, path.LastIndexOf('\\') + 1);
            path += "ConfigXML\\ESearch.xml";
            try
            {
                XmlDocument ESearchXML = new XmlDocument();
                ESearchXML.Load(path);

                XmlNode ESearch = ESearchXML.SelectSingleNode("descendant::ESearch");

                XmlNode Environments = ESearch.SelectSingleNode("descendant::SupportedEnvironments");
                foreach (XmlNode envs in Environments.ChildNodes)
                {
                    EnvDropDown.Items.Add(new ListItem(envs.Attributes["Name"].Value, envs.Attributes["Name"].Value));
                }

                if (EnvDropDown.Items.Count == 0)
                    throw new XmlException("No Environments loaded for ESearch. Please edit the xml file in " + path + " to include supported evnironments");

            }*/
             try
            {
                string envList = ConfigurationManager.AppSettings["Environments"];
                if (envList == "")
                    throw new Exception("No Environments loaded for ESearch. Please edit web.config to include supported environments in the appSettings portion. Use this code: <add key=\"Environments\" value=\"env1,env3,env3\"/>");
                string[] envs = envList.Split(',');
                foreach (string env in envs)
                {
                    EnvDropDown.Items.Add(new ListItem(env, env));
                }
                if (EnvDropDown.Items.Count == 0)
                    throw new Exception("No Environments loaded for ESearch. Please edit web.config to include supported environments in the appSettings portion. Use this code: <add key=\"Environments\" value=\"env1,env3,env3\"/>");
            }
            catch (Exception e)
            {
                System.Diagnostics.EventLog eventLog = new System.Diagnostics.EventLog("Application");
                eventLog.Source = "ESearch";
                eventLog.WriteEntry("Error loading environments from web.config.\n" + e.ToString(), System.Diagnostics.EventLogEntryType.Error, (int)1);
                eventLog.Close();

                //reverting to defaults:
                EnvDropDown.Items.Add(new ListItem("Error", "Error"));
            }
        }

        #region Web Form Designer generated code
        override protected void OnInit(EventArgs e)
        {
            //
            // CODEGEN: This call is required by the ASP.NET Web Form Designer.
            //
            InitializeComponent();
            base.OnInit(e);
        }

        /// <summary>
        /// Required method for Designer support - do not modify
        /// the contents of this method with the code editor.
        /// </summary>
        private void InitializeComponent()
        {
            this.DataGrid1.PageIndexChanged += new System.Web.UI.WebControls.DataGridPageChangedEventHandler(this.DataGrid1_PageIndexChanged);
            this.DataGrid1.SortCommand += new System.Web.UI.WebControls.DataGridSortCommandEventHandler(this.DataGrid1_SortCommand);
            //this.ImageButton1.Click += new System.Web.UI.ImageClickEventHandler(this.ImageButton1_Click);
            //this.ImageButton2.Click += new System.Web.UI.ImageClickEventHandler(this.ImageButton2_Click);


        }
        #endregion

        //BUTTON CLICKED FUNCTIONS

        //the button next to the environment dropdown was clicked: means that the environment has changed
        protected void DropDownButton_Click(object sender, ImageClickEventArgs e)
        {
            string path = Request.PhysicalPath;
            path = path.Substring(0, path.LastIndexOf('\\') + 1);
            path += "ConfigXML\\";
            EventDB.SetEnvironment(EnvDropDown.SelectedValue, path);
            //NPDB.SetEnvironment(EnvDropDown.SelectedValue);

            //rebuild the dropdown services list on the RSearch panel (different environments have different services)
            ServerList.Items.Clear();
            ServerList.Items.Add(new ListItem("<All Services>", "All Services"));
            EventDB.GetServicesList(ServerList.Items);
            ServerList.SelectedIndex = 0;

            if (AdvSearchPanel.Visible == true)
            {
                //if the Advanced Search panel is viewable, rebuild environment specific objects
                //otherwise, they will rebuild when the panel becomes visible (the advsearch button is clicked)
                CheckBoxList1.Items.Clear();
                EventDB.GetServicesList(CheckBoxList1.Items);
                BuildMachineTree();
            }
            //if the results panel is visible, the results panel is no longer valid. return to original screen
            if (Results.Visible == true)
            {
                BackToMainPage();
            }
            SetDefaultButtons();
        }

        //the simple search button was clicked
        protected void Search_Click(object sender, System.EventArgs e)
        {
            //CopyButton.Visible = false;
            CopyButton2.Visible = false;
            DetailPanel.Visible = false;
            Results.Visible = true;
            DataGrid1.Visible = false;
            NoResultsLabel.Visible = false;
            Form1.DefaultButton = Search.UniqueID;
            //Regular search
            ArrayList tmp = EventDB.GetTableList();
            bool IsTop1000 = true;

            if (!CheckBox2.Checked)
                IsTop1000 = false;

            string query = QueryBuilder.GetReqularQuery(tb_contains.Text, ServerList.SelectedItem.Value, TypeList.SelectedItem.Value, IsTop1000, ((EventTB)tmp[0]).Name);
            DataView view = LoadData(query, null, ((EventTB)tmp[0]).Name);

            if (view.Count < 1000)
            {
                string query2 = QueryBuilder.GetReqularQuery(tb_contains.Text, ServerList.SelectedItem.Text, TypeList.SelectedItem.Text, IsTop1000, ((EventTB)tmp[1]).Name);
                view = LoadData(query2, view, ((EventTB)tmp[1]).Name);
            }

            if (view.Count == 0)
            {
                //no results returned in the query. Show the label that says so
                NoResultsLabel.Visible = true;
                return;
            }
            DataGrid1.DataSource = view;
            DataGrid1.CurrentPageIndex = 0;
            DataGrid1.CurrentPageIndex = 0;
            DataGrid1.DataBind();
            DataGrid1.Visible = true;
        }

        //the show advanced options button was clicked
        protected void AdvSearch_Click(object sender, System.EventArgs e)
        {
            AdvSearchPanel.Visible = true;
            AdvSearchPanelshort.Visible = true;
            DetailPanel.Visible = false;
            Results.Visible = false;
            RSearch.Visible = false;
            refine.Visible = false;
            ReQuery.Visible = false;
            backtoResults.Visible = false;
            CopyButton.Visible = false;
            CopyButton2.Visible = false;
            DateTime today = DateTime.Today;
            DateTime lowerd = today.AddDays(-3);
            calendarPopup1.UpperBoundDate = today;
            //calendarPopup1.LowerBoundDate= lowerd;
            Calendarpopup2.UpperBoundDate = today;
            //Calendarpopup2.LowerBoundDate= lowerd;
            initAdvtab();

        }
        //the advanced search button was clicked
        protected void AdvSearchBt_Click(object sender, System.EventArgs e)
        {
            AdvSearchPanel.Visible = false;
            RSearch.Visible = false;
            AdvSearchPanelshort.Visible = true;
            refine.Visible = true;
            ReQuery.Visible = true;
            Results.Visible = true;
            Form1.DefaultButton = refine.UniqueID;
            NoResultsLabel.Visible = false;
            DataGrid1.Visible = false;
            DetailPanel.Visible = false;
            backtoResults.Visible = false;


            ///Advance Search
            ArrayList tmp = EventDB.GetTableList();
            //make sure we use the correct tables.
            DataView view = null;
            try
            {
                if (CheckBox1.Checked == true)
                {
                    DateTime start = Calendarpopup2.SelectedDate.Date;
                    start = start.AddHours(Convert.ToInt32(Tbstarthh.Text));
                    start = start.AddMinutes(Convert.ToInt32(tbstartmm.Text));
                    //convert BACK to GMT if needed
                    start = start.AddHours(-TimeOffset);

                    DateTime end = calendarPopup1.SelectedDate.Date;
                    end = end.AddHours(Convert.ToInt32(Tbendhh.Text));
                    end = end.AddMinutes(Convert.ToInt32(tbendmm.Text));
                    //convert BACK to GMT if needed
                    end = end.AddHours(-TimeOffset);

                    for (int i = 0; i < tmp.Count; i++)
                    {
                        EventTB etb = (EventTB)tmp[i];
                        if (i == 0)
                            etb.EndTime = DateTime.Now;
                        if (DateTime.Compare(etb.stTime, end) <= 0 && DateTime.Compare(etb.EndTime, end) > 0)
                        {
                            for (; i < tmp.Count; i++)
                            {
                                etb = (EventTB)tmp[i];
                                if (DateTime.Compare(etb.EndTime, start) <= 0)
                                    break;
                                view = LoadData(BuildAdvQuery(etb.Name), view, etb.Name);
                            }
                        }
                    }


                }
                else
                {
                    int Durationinmin = Convert.ToInt32(TextBox1.Text);
                    DateTime current = DateTime.Now;
                    DateTime stRange = current.AddMinutes(-1 * Durationinmin);
                    for (int i = 0; i < tmp.Count; i++)
                    {
                        EventTB etb = (EventTB)tmp[i];
                        if (i > 0 && DateTime.Compare(etb.EndTime, stRange) <= 0)
                            break;
                        view = LoadData(BuildAdvQuery(etb.Name), view, etb.Name);

                    }
                }

                if (view.Count == 0)
                {
                    //no results returned in the query. Show the label that says so
                    NoResultsLabel.Visible = true;
                    return;
                }
                DataGrid1.PageSize = Convert.ToInt32(ddl_PageSize.SelectedItem.Value, 10);
                DataGrid1.DataSource = view;
                DataGrid1.CurrentPageIndex = 0;
                DataGrid1.CurrentPageIndex = 0;
                DataGrid1.DataBind();
                DataGrid1.Visible = true;
            }
            catch (Exception ex)
            {
                System.Diagnostics.EventLog eventLog = new System.Diagnostics.EventLog("Application");
                eventLog.Source = "ESearch";
                eventLog.WriteEntry("Error reading input from advanced search criteria page.\n" + ex.ToString(), System.Diagnostics.EventLogEntryType.Error, (int)1);
                eventLog.Close();
                NoResultsLabel.Visible = true;
                NoResultsLabel.Text = "Error in advanced search inputs";
            }
        }

        //the return to search button on the results panel was clicked
        protected void refine_Click(object sender, System.EventArgs e)
        {
            AdvSearchPanel.Visible = true;
            Form1.DefaultButton = AdvSearchBt.UniqueID;
            RSearch.Visible = false;
            AdvSearchPanelshort.Visible = true;
            refine.Visible = false;
            ReQuery.Visible = false;
            backtoResults.Visible = false;
            CopyButton.Visible = false;
            CopyButton2.Visible = false;
        }
        //the requery button on the results panel was clicked-- resends the query w/updated time
        protected void ReQuery_Click(object sender, System.EventArgs e)
        {
            AdvSearchPanel.Visible = false;
            RSearch.Visible = false;
            AdvSearchPanelshort.Visible = true;
            refine.Visible = true;
            ReQuery.Visible = true;
            Form1.DefaultButton = refine.UniqueID;
            Results.Visible = true;
            DataGrid1.Visible = false;
            NoResultsLabel.Visible = false;
            DetailPanel.Visible = false;
            backtoResults.Visible = false;
            CopyButton.Visible = false;

            ArrayList tmp = EventDB.GetTableList();
            ((EventTB)tmp[0]).EndTime = DateTime.Now;
            DataView view = null;
            try
            {
                if (CheckBox1.Checked == true)
                {
                    DateTime start = Calendarpopup2.SelectedDate.Date;
                    start = start.AddHours(Convert.ToInt32(Tbstarthh.Text));
                    start = start.AddMinutes(Convert.ToInt32(tbstartmm.Text));


                    DateTime end = calendarPopup1.SelectedDate.Date;
                    end = end.AddHours(Convert.ToInt32(Tbendhh.Text));
                    end = end.AddMinutes(Convert.ToInt32(tbendmm.Text));

                    for (int i = 0; i < tmp.Count; i++)
                    {
                        EventTB etb = (EventTB)tmp[i];
                        if (i == 0)
                            etb.EndTime = DateTime.Now;
                        if (DateTime.Compare(etb.stTime, end) <= 0 && DateTime.Compare(etb.EndTime, end) > 0)
                        {
                            for (; i < tmp.Count; i++)
                            {
                                etb = (EventTB)tmp[i];
                                if (DateTime.Compare(etb.EndTime, start) <= 0)
                                    break;
                                view = LoadData(BuildAdvQuery(etb.Name), view, etb.Name);
                            }
                        }
                    }


                }
                else
                {
                    int Durationinmin = Convert.ToInt32(TextBox1.Text);
                    DateTime current = DateTime.Now;
                    DateTime stRange = current.AddMinutes(-1 * Durationinmin);
                    for (int i = 0; i < tmp.Count; i++)
                    {
                        EventTB etb = (EventTB)tmp[i];
                        if (i > 0 && DateTime.Compare(etb.EndTime, stRange) <= 0)
                            break;
                        view = LoadData(BuildAdvQuery(etb.Name), view, etb.Name);

                    }
                }
                ///Advance Search

                if (view.Count == 0)
                {
                    //no results returned in the query. Show the label that says so
                    NoResultsLabel.Visible = true;
                    return;
                }
                DataGrid1.PageSize = Convert.ToInt32(ddl_PageSize.SelectedItem.Value, 10);
                DataGrid1.DataSource = view;
                DataGrid1.CurrentPageIndex = 0;
                DataGrid1.CurrentPageIndex = 0;
                DataGrid1.DataBind();
                DataGrid1.Visible = true;
            }
            catch (Exception ex)
            {
                System.Diagnostics.EventLog eventLog = new System.Diagnostics.EventLog("Application");
                eventLog.Source = "ESearch";
                eventLog.WriteEntry("Error reading input from advanced search criteria page.\n" + ex.ToString(), System.Diagnostics.EventLogEntryType.Error, (int)1);
                eventLog.Close();
                NoResultsLabel.Visible = true;
                NoResultsLabel.Text = "Error in advanced search inputs";
            }

        }
        //backtoresults button on the details page was clicked
        protected void backtoResults_Click(object sender, System.EventArgs e)
        {
            AdvSearchPanel.Visible = false;
            RSearch.Visible = false;
            AdvSearchPanelshort.Visible = true;
            refine.Visible = true;
            ReQuery.Visible = true;
            Results.Visible = true;
            Form1.DefaultButton = refine.UniqueID;
            NoResultsLabel.Visible = false;
            DetailPanel.Visible = false;
            backtoResults.Visible = false;
            CopyButton.Visible = false;
            //CopyButton2.Visible = false;
        }

        //check/uncheck all buttons above the machine tree
        protected void CheckAllButton_Click(object sender, EventArgs e)
        {
            while (MachineTree.CheckedNodes.Count != 0)
            {
                MachineTree.CheckedNodes[0].Checked = false;
            }
            foreach (TreeNode type in MachineTree.Nodes)
            {
                type.Checked = true;
                type.Expanded = false;
            }
        }
        protected void UncheckAllButton_Click(object sender, EventArgs e)
        {
            //hint: as soon as you uncheck a node, it is removed from CheckedNodes
            while (MachineTree.CheckedNodes.Count != 0)
            {
                MachineTree.CheckedNodes[0].Checked = false;
            }

        }


        protected void DataGrid1_SelectedIndexChanged(object sender, System.EventArgs e)
        {
            DetailPanel.Visible = true;
            backtoResults.Visible = true;
            Form1.DefaultButton = Search.UniqueID;
            if (RSearch.Visible == false)
            {
                Form1.DefaultButton = backtoResults.UniqueID;
            }
            Results.Visible = false;
            //DataGrid1.Visible = false;
            //NoResultsLabel.Visible = false;
            //determine which copy button to turn on
            if (RSearch.Visible == true)
            {
                CopyButton2.Visible = true;
            }
            else
            {
                CopyButton.Visible = true;
            }
            populateDetail();

        }

        private void DataGrid1_PageIndexChanged(object source, System.Web.UI.WebControls.DataGridPageChangedEventArgs e)
        {
            try
            {
                DataView dv = (DataView)Session["Dataview"];
                // Set CurrentPageIndex to the page the user clicked.
                DataGrid1.CurrentPageIndex = e.NewPageIndex;

                // Re-bind the data to refresh the DataGrid control. 
                DataGrid1.DataSource = dv;
                DataGrid1.DataBind();
                Form1.DefaultButton = Search.UniqueID;
                if (RSearch.Visible == false)
                {
                    Form1.DefaultButton = refine.UniqueID;
                }
            }
            catch (Exception)
            {
                //session expired, do something
                BackToMainPage();
            }
        }

        private void DataGrid1_SortCommand(object source, System.Web.UI.WebControls.DataGridSortCommandEventArgs e)
        {
            try
            {
                DataView dv = (DataView)Session["Dataview"];


                string sortorder = (string)Session["sortorder"];
                if (sortorder == "DESC")
                {
                    dv.Sort = "DateTime ASC";
                    Session.Add("sortorder", "ASC");
                }
                else
                {
                    dv.Sort = "DateTime DESC";
                    Session.Add("sortorder", "DESC");
                }
                // Re-bind the data to refresh the DataGrid control. 
                DataGrid1.DataSource = dv;
                DataGrid1.DataBind();
            }
            catch (Exception)
            {
                //the session expired, restart everthing.
                BackToMainPage();
            }
        }



        //private helper functions
        protected DataView LoadData(string mySelectQuery, DataView dvold, string tbname)
        {
            DataView dv = EventDB.GetResult(mySelectQuery, (dvold == null ? null : dvold.Table), tbname, TimeOffset);
            if (dv.Table.Rows.Count == 0)
            {
                //No results were returned in the query
            }
            dv.Sort = "DateTime DESC";
            Session.Add("Dataview", dv);
            Session.Add("sortorder", "DESC");
            Session.Add("currentPage", (int)0);

            return dv;

        }

        private string BuildAdvQuery(string tbname)
        {

            QueryData Qdata = new QueryData();
            try
            {

                //free text searching
                Qdata.AllWordstxt = AllWords.Text;
                Qdata.Atlestwords = Atlestwords.Text;
                Qdata.NoWords = NoWords.Text;

                //services
                for (int p = 0; p < CheckBoxList1.Items.Count; p++)
                {
                    if (CheckBoxList1.Items[p].Selected)
                        Qdata.vc_apps.Add(CheckBoxList1.Items[p].Text);
                }

                //event type
                for (int p = 0; p < CheckBoxList2.Items.Count; p++)
                {
                    if (CheckBoxList2.Items[p].Selected)
                        Qdata.Etypes.Add(CheckBoxList2.Items[p].Text);

                }

                //event time 
                if (CheckBox1.Checked == true)
                {
                    //use time range
                    Qdata.useDateRange = true;

                    DateTime start = Calendarpopup2.SelectedDate.Date;
                    start = start.AddHours(Convert.ToInt32(Tbstarthh.Text));
                    start = start.AddMinutes(Convert.ToInt32(tbstartmm.Text));
                    //convert back to GMT time
                    start = start.AddHours(-TimeOffset);
                    Qdata.start = start;

                    DateTime end = calendarPopup1.SelectedDate.Date;
                    end = end.AddHours(Convert.ToInt32(Tbendhh.Text));
                    end = end.AddMinutes(Convert.ToInt32(tbendmm.Text));
                    //convert back to GMT time
                    end = end.AddHours(-TimeOffset);
                    Qdata.end = end;


                }
                //otherwise use last 30 minutes
                else
                {
                    Qdata.useDateRange = false;
                    Qdata.Durationinmin = Convert.ToInt32(TextBox1.Text);
                }

                //trace through tree to find individually selected machine names 
                Qdata.AllChecked = true;
                foreach (TreeNode root in MachineTree.Nodes)
                {
                    //determine if an "allxxx" root node is selected
                    if (!root.Checked)
                    {
                        Qdata.AllChecked = false;
                        foreach (TreeNode leaf in root.ChildNodes)
                        {
                            if (leaf.Checked)
                            {
                                Qdata.CompNames.Add(leaf.Text.Trim());
                            }
                        }
                    }
                    else
                    {
                        foreach (TreeNode leaf in root.ChildNodes)
                        {
                            Qdata.CompNames.Add(leaf.Text.Trim());
                        }
                    }
                }

                /*foreach (ListItem item in Computernames.Items)
                {
                    if(item.Selected)
                        Qdata.CompNames.Add(item.Text.Trim());
                }*/
                //eventID
                Qdata.Events = tb_eventids.Text.Trim();
                //event title
                Qdata.titles = tb_Title.Text.Trim();
                //whether or not to exclude or include the ID or title
                Qdata.ExcludeEvents = excludeevents.Checked;
                Qdata.Excludetitles = excludetitle.Checked;
                //Qdata.gamertags=txgamertag.Text.Trim();
            }
            catch (Exception ex)
            {
                System.Diagnostics.EventLog eventLog = new System.Diagnostics.EventLog("Application");
                eventLog.Source = "ESearch";
                eventLog.WriteEntry("Error building advanced query.\n" + ex.ToString(), System.Diagnostics.EventLogEntryType.Error, (int)1);
                eventLog.Close();
            }


            //done gathering the info, ready to build the query!
            return QueryBuilder.GetAdvQuery(Qdata, tbname);

        }

        private void initAdvtab()
        {
            DateTime end = DateTime.Now.AddHours(TimeOffset);
            DateTime start = end.AddHours(-12);
            Calendarpopup2.SelectedDate = start;
            calendarPopup1.SelectedDate = end;

            Tbstarthh.Text = start.Hour < 10 ? "0" + start.Hour.ToString() : start.Hour.ToString();
            tbstartmm.Text = start.Minute < 10 ? "0" + start.Minute.ToString() : start.Minute.ToString();
            Tbendhh.Text = end.Hour < 10 ? "0" + end.Hour.ToString() : end.Hour.ToString();
            tbendmm.Text = end.Minute < 10 ? "0" + end.Minute.ToString() : end.Minute.ToString();

            DateTimeLabel.Text = "Enter Date and Time in " + TimeZoneText;
            Form1.DefaultButton = AdvSearchBt.UniqueID;
            //init environment specific objects
            CheckBoxList1.Items.Clear();
            EventDB.GetServicesList(CheckBoxList1.Items);
            BuildMachineTree();

        }

        private void populateDetail()
        {
            try
            {
                int reindex = (DataGrid1.CurrentPageIndex * DataGrid1.PageSize) + DataGrid1.SelectedIndex;

                DataView dv = (DataView)Session["Dataview"];

                if (reindex > dv.Count)
                {
                    return;
                }
                lbdate.Text = dv[reindex][3].ToString(); //date
                lbtime.Text = dv[reindex][4].ToString(); //time
                lbtype.Text = dv[reindex][2].ToString(); //type
                lbtitle.Text = dv[reindex][8].ToString();//title

                lbsource.Text = dv[reindex][5].ToString(); //source
                lbeventid.Text = dv[reindex][6].ToString(); //eventid
                lbcomputer.Text = dv[reindex][7].ToString(); //computer name
                //Label18.Text= "Occurrence Count Per Minute:-"+dv[reindex][10].ToString();
                string temp = (dv[reindex][10]).ToString();
                tb_Detail.Text = EventDB.GetEventDetail(dv[reindex][0].ToString(), temp);

                if (DataGrid1.CurrentPageIndex <= 0 && DataGrid1.SelectedIndex <= 0)
                    ImageButton1.Visible = false;
                else
                    ImageButton1.Visible = true;

                if (DataGrid1.CurrentPageIndex >= DataGrid1.PageCount && DataGrid1.SelectedIndex >= DataGrid1.PageSize)
                    ImageButton2.Visible = false;
                else
                    ImageButton2.Visible = true;
            }
            catch (Exception e)
            {
                //session expired. Restart
                BackToMainPage();
            }
            //tb_Detail.Text = EventDB.GetEventDetail((int)dv[reindex][0],(string)(dv[reindex][11]).ToString());
        }

        private void BuildMachineTree()
        {
            //TreeNodeCollection roots = new TreeNodeCollection();
            ListItemCollection serverNames;
            serverNames = new ListItemCollection();

            //getserverlist will handle errors
            EventDB.GetServerList(serverNames, EnvDropDown.SelectedValue);
            
            MachineTree.Nodes.Clear();

            //assume items in serverNames are sorted by server TYPE
            //items in serverNames are composed (TEXT=<server name>,VALUE=<server type>)
            string previousname = "";
            TreeNode serverTypeNode = null;
            foreach (ListItem item in serverNames)
            {
                if (!item.Value.Equals(previousname))
                {
                    //we have encountered a new server TYPE name, create a new "root" server type node
                    previousname = item.Value;
                    serverTypeNode = new TreeNode(item.Value, item.Value);
                    serverTypeNode.Checked = true;
                    serverTypeNode.ShowCheckBox = true;
                    serverTypeNode.SelectAction = TreeNodeSelectAction.Expand;
                    //add as root node
                    MachineTree.Nodes.Add(serverTypeNode);
                }

                //add this server name as a child to the root node
                TreeNode temp = new TreeNode(item.Text.Trim(), item.Text.Trim());
                temp.Checked = false;
                temp.ShowCheckBox = true;
                temp.SelectAction = TreeNodeSelectAction.None;
                if (serverTypeNode.ChildNodes.Count == 0)
                    serverTypeNode.ChildNodes.Add(temp);
                else
                {
                    //insert the node in it's sorted place, childnodes is already sorted
                    int index = 0;
                    Boolean placed = false;
                    foreach (TreeNode sorteditem in serverTypeNode.ChildNodes)
                    {
                        int sort = temp.Text.CompareTo(sorteditem.Text);
                        if (sort <= 0)
                        {
                            //insert before sorted item
                            serverTypeNode.ChildNodes.AddAt(index, temp);
                            placed = true;
                            break;
                        }
                        index++;
                    }
                    if (!placed)
                        serverTypeNode.ChildNodes.AddAt(index, temp);
                }
            }
        }

        private void SetDefaultButtons()
        {
            Form1.DefaultButton = Search.UniqueID;

            //if we're on the results screen and the regular search button isn't visible, make the back to advanced options the default button
            if (RSearch.Visible == false)
            {
                Form1.DefaultButton = refine.UniqueID;
            }
            //otherwise, if we're looking at the details of an event, make the default button the back to results button
            if (DetailPanel.Visible == true)
            {
                Form1.DefaultButton = backtoResults.UniqueID;
            }
            //if we're on the advanced panel screen, make the default button the advanced search button
            //if advanced search options is visible, change the label and time searching variables
            if (AdvSearchPanel.Visible == true)
            {
                DateTimeLabel.Text = "Enter Date and Time in " + TimeZoneText;
                Form1.DefaultButton = AdvSearchBt.UniqueID;
            }
        }

        private void BackToMainPage()
        {
            RSearch.Visible = true;
            AdvSearchPanel.Visible = false;
            AdvSearchPanelshort.Visible = false;
            refine.Visible = false;
            ReQuery.Visible = false;
            Results.Visible = false;
            DetailPanel.Visible = false;
            backtoResults.Visible = false;
            CopyButton.Visible = false;
            CopyButton2.Visible = false;
        }

        protected void ImageButton1_Click1(object sender, ImageClickEventArgs e)
        {
            //up, go to previous event on list

            if (DataGrid1.SelectedIndex - 1 < 0)
            {
                if (DataGrid1.CurrentPageIndex - 1 > 0)
                {
                    DataGrid1.CurrentPageIndex = DataGrid1.CurrentPageIndex - 1;
                    DataGrid1.SelectedIndex = DataGrid1.PageSize - 1;
                }
                else
                    return;
            }
            else
            {
                DataGrid1.SelectedIndex = DataGrid1.SelectedIndex - 1;
            }

            populateDetail();
        }
      
        protected void ImageButton2_Click1(object sender, ImageClickEventArgs e)
        {
            // Down, go to next event on list 

            if (DataGrid1.SelectedIndex + 1 >= DataGrid1.Items.Count)
            {

                if (DataGrid1.CurrentPageIndex + 1 < DataGrid1.PageCount)
                {
                    DataGrid1.CurrentPageIndex = DataGrid1.CurrentPageIndex + 1;
                    DataGrid1.SelectedIndex = 0;
                }
                else
                    return;
            }

            else
            {
                DataGrid1.SelectedIndex = DataGrid1.SelectedIndex + 1;
            }

            populateDetail();
        }
        
}

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\liveexec\LiveExec.cs ===
using System;
using System.Collections.Generic;
using System.Text;

using xonline.common.tools.console;
using xonline.common.config;
using System.Security.Cryptography.X509Certificates;
using System.ComponentModel;
using System.Runtime.InteropServices;
using System.IO;
using System.Diagnostics;
using System.Security;
using System.Threading;

namespace LiveExec
{
    [ApplicationName("LiveExec")]
    [ApplicationDescription("LiveExec is a command line tool for deploying and removing Xbox Live certificates from user and machine certificate stores.")]
    class LiveExecParams : CommandLineDefinition
    {
        [ParameterDescription("Name of the user account in SITE.XML to run under")]
        [ParameterRequired]
        public NamedParameter<String> User = null;

        [ParameterDescription("Name of the application to run")]
        [ParameterRequired]
        public PositionalParameter<String> Application = null;

        public ArgumentCollection Parameters = null;
    }

    public class LiveExec
    {
        private static LiveExecParams parameters;
        private static Semaphore streams;

        public static int Main(String[] args)
        {
            CSetupSecureResolver resolver;

            // Initialize Win32 impersonation
            resolver = new CSetupSecureResolver();

            try
            {
                // Parse the command line into LiveExecParams
                if (!ArgReflector.Parse(out parameters, args))
                {
                    ArgReflector.DisplayUsage(out parameters);
                    return -1;
                }

                // Construct the arguments
                StringBuilder arguments = new StringBuilder();
                if (parameters.Parameters.IsSet)
                {
                    foreach (String argument in parameters.Parameters.Value)
                    {
                        arguments.AppendFormat("\"{0}\" ", argument);
                    }
                }

                // Fetch the password
                IUserRole role = Config.GetUserRole(parameters.User.Value);
                SecureString password = new SecureString();
                foreach (Char c in resolver.UserSecret(role.Name).ToCharArray())
                    password.AppendChar(c);

                streams = new Semaphore(0, 2);

                ProcessStartInfo processStartInfo = new ProcessStartInfo();
                processStartInfo.FileName = parameters.Application.Value;
                processStartInfo.Arguments = arguments.ToString();
                processStartInfo.UseShellExecute = false;
                processStartInfo.Domain = role.Domainname;
                processStartInfo.UserName = role.Username;
                processStartInfo.Password = password;
                processStartInfo.WorkingDirectory = Directory.GetCurrentDirectory();
                processStartInfo.CreateNoWindow = false;
                processStartInfo.RedirectStandardError = true;
                processStartInfo.RedirectStandardOutput = true;

                Process process = new Process();
                process.StartInfo = processStartInfo;
                process.EnableRaisingEvents = true; 
                process.ErrorDataReceived += new DataReceivedEventHandler(process_ErrorDataReceived);
                process.OutputDataReceived += new DataReceivedEventHandler(process_OutputDataReceived);
                process.Start();
                process.BeginErrorReadLine();
                process.BeginOutputReadLine();

                process.WaitForExit();
                streams.WaitOne();
                streams.WaitOne();
                Console.WriteLine("Process Exit: " + process.ExitCode);

                return process.ExitCode;
            }
            catch (Exception ex)
            {
                Console.WriteLine("LiveExec failed with exception:");
                Console.WriteLine(ex.Message);
                Console.WriteLine(ex.StackTrace);

                return -1;
            }
        }

        static void process_OutputDataReceived(object sender, DataReceivedEventArgs e)
        {
            if (e.Data == null)
                streams.Release();
            else
                Console.Out.WriteLine(e.Data);
        }

        static void process_ErrorDataReceived(object sender, DataReceivedEventArgs e)
        {
            if (e.Data == null)
                streams.Release();
            else
                Console.Error.WriteLine(e.Data);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\LiveTest\ESearch\App_Code\NPDB.cs ===
using System;
using System.Data;
using System.Collections;
using System.ComponentModel;
using System.Data.SqlClient;
using System.Web.UI.WebControls;

namespace Events
{
    /// <summary>
    /// Class containing the interface to npdb.
    /// </summary>
    public class NPDB
    {
        public static string DataSource = "xenpdbsql001";
        public static string Database = "npdb";
        static string myConnString = "Data Source=" + DataSource + ";Initial Catalog=" + Database + ";persist security info=False;integrated security=SSPI";
        static string Environment = "funcnet";
		

        public NPDB()
        {
            //
            // TODO: Add constructor logic here
            //
        }

        //sets the class variables to connect to the environment in env
        /**** Will need to be updated when the environments in NPDB change ****/
        static public void SetEnvironment(string env)
        {
            Environment = env;

            if (env.Equals("argonet"))
            {
                DataSource = "xenpdbsql001";
                Database = "npdb";
            }
            if (env.Equals("bvtnet"))
            {
                DataSource = "10.20.3.201";
                Database = "npdb";
            }
            if (env.Equals("testnet"))
            {
                //this used to be FuncNet
                DataSource = "xenpdbsqlv01";
                Database = "npdb";
            }
            if (env.Equals("partnernet"))
            {
                DataSource = "xenpdbsql001";
                Database = "npdb";
            }
            if (env.Equals("qfenet"))
            {
                DataSource = "10.20.5.201";
                Database = "npdb";
            }
            if (env.Equals("stressnet"))
            {
                DataSource = "xenpdbsqlv01";
                Database = "npdb";
                //currently stressnet
            }
            myConnString = "Data Source=" + DataSource + ";Initial Catalog=" + Database + ";persist security info=False;integrated security=SSPI";
        }

        //returns in servernames a list of server names and corresponding types filtered by the class environment variables
        //returns 0 if everything went ok
        //returns 1 if we couldn't connect to npdb
        static public int GetServerList(ListItemCollection servernames)
        {
            int retval = 0;
            SqlConnection _EventCnt = null;
            try
            {
                //open a connection to the database specified in the database variable
                _EventCnt = new SqlConnection(myConnString);
                _EventCnt.Open();
                                
                //Query for the server names 
                string mySelectQuery = "select distinct vc_server, vc_server_type from dbo.t_servers where vc_environment = '" + Environment + "' and vc_server_state = 'online' order by vc_server_type";
                SqlCommand myCommand = new SqlCommand(mySelectQuery, _EventCnt);
                myCommand.CommandType = CommandType.Text;
                SqlDataReader myReader = myCommand.ExecuteReader(); 
                while (myReader.Read())
                {
                    //read and store server names
                    string name = myReader.GetString(0);
                    string type = myReader.GetString(1);
                    servernames.Add(new ListItem(name.Trim(), type.Trim()));
                }
                myReader.Close();

            }
            catch(Exception)
            {
                retval = 1;
                //somehow we cannot reach NPDB, return servernames unchanged.
            }
            finally
            {
                if (_EventCnt != null)
                {
                    _EventCnt.Close();
                    _EventCnt = null;
                }

            }
            return retval;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\LiveTest\ESearch\App_Code\EventDB.cs ===
using System;
using System.Data;
using System.Xml;
using System.Collections;
using System.Configuration;
using System.ComponentModel;
using System.Data.SqlClient;
using System.Web.UI.WebControls;


namespace Events
{
	/// <summary>
	/// Summary description for EventDB.
	/// </summary>
	/// 
	public class EventTB
	{
		public string Name;
		public DateTime stTime;
		public DateTime EndTime;
				
	}

	public class EventDB
	{

        static string myConnString = "";
        static string serverListConnString = "";
		
        public EventDB()
		{

		}

        static public void SetEnvironment(string env, string pathToXMLfolder)
        {
            try
            {
                myConnString = "";
                if (ConfigurationManager.ConnectionStrings[env + "EventSysDB"] == null)
                    throw new Exception("No connection string found for environment " + env + ". Please add a connection string to the web.config to name="+env+"EventSysDB");
            
                myConnString = ConfigurationManager.ConnectionStrings[env+"EventSysDB"].ToString();
                serverListConnString = myConnString; 
                if (ConfigurationManager.ConnectionStrings[env + "ServerNames"] != null)
                    serverListConnString = ConfigurationManager.ConnectionStrings[env + "ServerNames"].ToString();

                /*XmlDocument EventDBXML = new XmlDocument();
                pathToXMLfolder += "EventSysDB.xml";
                EventDBXML.Load(pathToXMLfolder);

                XmlNode eventSysDB = EventDBXML.SelectSingleNode("descendant::EventSysDB");

                XmlNode EnvironmentSettings = eventSysDB.SelectSingleNode("descendant::EnvironmentSettings");
                foreach (XmlNode envs in EnvironmentSettings.ChildNodes)
                {
                    if (env.ToLower() == envs.Attributes["Name"].Value.ToLower())
                    {
                        myConnString = envs.Attributes["ConnectionString"].Value;
                        if (envs.Attributes["CustomMachinesConnectionString"]  != null)
                            serverListConnString = envs.Attributes["CustomMachinesConnectionString"].Value;
                        else
                            serverListConnString = myConnString;
                        break;
                    }
                }
                
                if (myConnString == "")
                    throw new XmlException("No connection string found for environment " + env +". Please edit the xml file in "+pathToXMLfolder+" to include the correct connecting string.");
            
                if (serverListConnString == "")
                    serverListConnString = myConnString;*/
                
            }
            catch (Exception e)
            {
                System.Diagnostics.EventLog eventLog = new System.Diagnostics.EventLog("Application");
                eventLog.Source = "ESearch";
                eventLog.WriteEntry("Error loading settings from web.config\n" + e.ToString(), System.Diagnostics.EventLogEntryType.Error, (int)1);
                eventLog.Close();

                //reverting to defaults:
                
                myConnString = "Data Source=XEEVNTSQLW01;Initial Catalog=EventSysDB;persist security info=False;integrated security=SSPI";
                serverListConnString = myConnString;
            }
            /*if (env.Equals("argonet"))
            {
                DataSource = "xeevntsqlw01";
                Database = "EventSysDB";
            }
            if (env.Equals("bvtnet"))
            {
                DataSource = "xeevntsqlw01";
                Database = "EventSysDB";
            }
            if (env.Equals("testnet"))
            {
                DataSource = "fxevntsql001";
                Database = "EventSysDB";
            }
            if (env.Equals("partnernet"))
            {
                DataSource = "xeevntsqlw01";
                Database = "EventSysDB";
            }
            if (env.Equals("qfenet"))
            {
                DataSource = "xeevntsqlw01";
                Database = "EventSysDB";
            }
            if (env.Equals("stressnet"))
            {
                DataSource = "xeevntsqlw01";
                Database = "EventSysDB";
                //currently stressnet
            }*/

            //myConnString = "Data Source=" + DataSource + ";Initial Catalog=" + Database + ";persist security info=False;integrated security=SSPI";
        }
       
        static public void GetServerList(ListItemCollection servernames, string environment)
        {
            SqlConnection _EventCnt = null;
            try
            {
                //open a connection to the database specified in the connection string
                _EventCnt = new SqlConnection(serverListConnString);
                _EventCnt.Open();

                //Query for the server names 
                string mySelectQuery = "select distinct vc_server, vc_server_type from dbo.t_servers where vc_environment = '" + environment + "' and vc_server_state = 'online' order by vc_server_type";
                SqlCommand myCommand = new SqlCommand(mySelectQuery, _EventCnt);
                myCommand.CommandType = CommandType.Text;
                SqlDataReader myReader = myCommand.ExecuteReader();
                while (myReader.Read())
                {
                    //read and store server names
                    string name = myReader.GetString(0).Trim();
                    string type = myReader.GetString(1).Trim();
                    servernames.Add(new ListItem(name, type));
                }
                myReader.Close();

            }
            catch (Exception e)
            {
                
                System.Diagnostics.EventLog eventLog = new System.Diagnostics.EventLog("Application");
                eventLog.Source = "ESearch";
                eventLog.WriteEntry("Error loading supported servers from database using connection string \""+serverListConnString+"\".\n" + e.ToString(), System.Diagnostics.EventLogEntryType.Error, (int)1);
                eventLog.Close();
                //somehow we cannot reach NPDB, return servernames unchanged.
            }
            finally
            {
                if (_EventCnt != null)
                {
                    _EventCnt.Close();
                    _EventCnt = null;
                }

            }
            
        }
		static public int GetServicesList(ListItemCollection items)
		{
            int retval = 0;
			SqlConnection _EventCnt =null;
            try
            {

                string mySelectQuery = "select vc_app from dbo.t_Application group by vc_app";
                _EventCnt = new SqlConnection(myConnString);
                _EventCnt.Open();


                SqlCommand myCommand = new SqlCommand(mySelectQuery, _EventCnt);
                myCommand.CommandType = CommandType.Text;
                SqlDataReader myReader = myCommand.ExecuteReader();
                while (myReader.Read())
                {
                    string tmp = myReader.GetString(0);
                    items.Add(new ListItem(tmp.Trim(), tmp.Trim()));
                }
                myReader.Close();

            }
            catch (Exception ex)
            {
                //we could not connect to our database, return 1
                System.Diagnostics.EventLog eventLog = new System.Diagnostics.EventLog("Application");
                eventLog.Source = "ESearch";
                eventLog.WriteEntry("Error reading services from t_Application in EventSysDB using connection string \""+myConnString+"\".\n" + ex.ToString(), System.Diagnostics.EventLogEntryType.Error, (int)1);
                eventLog.Close();
                retval = 1;
            }
         	finally
			{
				if(_EventCnt!=null)
				{
					_EventCnt.Close();
					_EventCnt=null;
				}

			}
            return retval;
		}

		static public string GetEventDetail(string guid ,string tablename ) 
		{
			string detail = "";
			SqlConnection _EventCnt =null;
			try
			{
				
				string mySelectQuery = "select vc_description from "+tablename+" where uid_mom_guid=\'"+guid+"\'";
				_EventCnt= new SqlConnection(myConnString);
				_EventCnt.Open();


				SqlCommand myCommand = new SqlCommand(mySelectQuery, _EventCnt);
				myCommand.CommandType = CommandType.Text;
				detail = (string) myCommand.ExecuteScalar();
			}
            catch (Exception ex)
            {
                System.Diagnostics.EventLog eventLog = new System.Diagnostics.EventLog("Application");
                eventLog.Source = "ESearch";
                eventLog.WriteEntry("Error reading event detail (guid="+guid+")from "+tablename+" in EventSysDB using connection string \""+myConnString+"\".\n" + ex.ToString(), System.Diagnostics.EventLogEntryType.Error, (int)1);
                eventLog.Close();
                //we couldn't reach the database. return empty string.
            }
			finally
			{
				if(_EventCnt!=null)
				{
					_EventCnt.Close();
					_EventCnt=null;
				}

			}
            
			return detail;

		}

		static public DataView GetResult(string Query,DataTable dt,string tbname, int TimeOffset)
		{
			DataRow dr;
			if(dt==null)
			{
				dt = new DataTable();
				dt.Columns.Add(new DataColumn("Index", typeof(string)));
				dt.Columns.Add(new DataColumn("ImageType", typeof(string)));
				dt.Columns.Add(new DataColumn("Type", typeof(string)));
				dt.Columns.Add(new DataColumn("Date", typeof(string)));
				dt.Columns.Add(new DataColumn("Time", typeof(string)));
				dt.Columns.Add(new DataColumn("Source", typeof(string)));
				dt.Columns.Add(new DataColumn("Event", typeof(string)));
				dt.Columns.Add(new DataColumn("Computer", typeof(string)));
				dt.Columns.Add(new DataColumn("Title", typeof(string)));
				dt.Columns.Add(new DataColumn("DateTime", typeof(DateTime)));
				//dt.Columns.Add(new DataColumn("Occurrence", typeof(Int32)));
				dt.Columns.Add(new DataColumn("TableName", typeof(string)));
			}

		

			SqlConnection _EventCnt =null;
			try
			{
				_EventCnt= new SqlConnection(myConnString);
				_EventCnt.Open();


				SqlCommand myCommand = new SqlCommand(Query, _EventCnt);
				myCommand.CommandType = CommandType.Text;
                myCommand.CommandTimeout = 60*2; //two minutes
				SqlDataReader myReader = myCommand.ExecuteReader();
				while(myReader.Read()) 
				{
					dr = dt.NewRow();
					dr[0] = myReader.GetSqlGuid(0).ToString();
                                   short tmp = myReader.GetInt16(1);
					dr[1] = FormatURL(tmp);
					dr[2] = FormatText(tmp);
					dr[3] = myReader.GetDateTime(2).AddHours(TimeOffset).ToShortDateString();
					dr[4] = myReader.GetDateTime(2).AddHours(TimeOffset).ToShortTimeString();
					dr[5] = myReader.GetString(3);
					dr[6] = myReader.GetInt32(4);
					dr[7] = myReader.GetString(5);
					dr[8] = "0x"+myReader.GetInt32(6).ToString("x"); // title
					dr[9] =myReader.GetDateTime(2);
					//if(!myReader.GetSqlInt32(7).IsNull)
					//	dr[10] =myReader.GetInt32(7);
					//else
					//	dr[10] =0;

					//dr[11] =tbname;
                    dr[10] = tbname;
 
					dt.Rows.Add(dr);
				}
				myReader.Close();
                if (dt.Rows.Count == 0)
                {
                    //there were no rows created, meaning no results returned
                  
                }


			}
            catch (Exception ex)
            {
                System.Diagnostics.EventLog eventLog = new System.Diagnostics.EventLog("Application");
                eventLog.Source = "ESearch";
                eventLog.WriteEntry("Error reading results from "+tbname+" from EventSysDB using connection string "+myConnString+".\nQuery: "+Query+ "\n" + ex.ToString(), System.Diagnostics.EventLogEntryType.Error, (int)1);
                eventLog.Close();
                //we couldn't reach the database. return empty.
            }
			finally
			{
				if(_EventCnt!=null)
				{
					_EventCnt.Close();
					_EventCnt=null;
				}

			}
 
			return( new DataView(dt));

		}

		static public ArrayList GetTableList()
		{
			ArrayList tmp = new ArrayList();
			string Query = "SELECT [c_table_name], [dt_start_time], [dt_end_time] FROM [t_event_tables] order by dt_start_time desc";
			SqlConnection _EventCnt =null;
			try
			{
				_EventCnt= new SqlConnection(myConnString);
				_EventCnt.Open();


				SqlCommand myCommand = new SqlCommand(Query, _EventCnt);
				myCommand.CommandType = CommandType.Text;
				SqlDataReader myReader = myCommand.ExecuteReader();
				while(myReader.Read()) 
				{
					EventTB oeventtb = new EventTB();
					oeventtb.Name = myReader.GetString(0);
					if(!myReader.IsDBNull(1))
						oeventtb.stTime = myReader.GetDateTime(1);
					if(!myReader.IsDBNull(2))
						oeventtb.EndTime =myReader.GetDateTime(2);

					
					tmp.Add(oeventtb);
					
				}
				myReader.Close();


			}
            catch (Exception ex)
            {
                System.Diagnostics.EventLog eventLog = new System.Diagnostics.EventLog("Application");
                eventLog.Source = "ESearch";
                eventLog.WriteEntry("Error reading table list from EventSysDB using connection string " + myConnString + ".\n" + ex.ToString(), System.Diagnostics.EventLogEntryType.Error, (int)1);
                eventLog.Close();
                //we couldn't reach the database. return emptiness.
            }
			finally
			{
				if(_EventCnt!=null)
				{
					_EventCnt.Close();
					_EventCnt=null;
				}

			}
 
			return tmp;

		}

                static public string FormatText(short type)
                {
                    //<%#  DataBinder.Eval(Container.DataItem, "ImageType") %>
                    //string lower = type.ToLower().Trim();
                    string retval = null;
                    if (type == 1)
                        retval = "Error";
                    else if (type == 2)
                        retval = "Warning";
                    else if (type == 16)
                        retval = "Failure Audit";
                    else 
                        retval = "Info"; //info is 4

                    return retval;
                }

                static public string FormatURL(short type)
                {
                    //<%#  DataBinder.Eval(Container.DataItem, "ImageType") %>
                    string retval = null;
                    if(type == 1)
                        retval= "error.gif";
                    else if (type == 2)
                        retval = "warning.gif";
                    else if (type == 16)
                        retval = "failureaudit.jpg";
                    else
                        retval ="info.gif"; //info is 4

                    return retval;
                }

	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\LiveTest\PerfAdmin\PerfDAD\App_Code\AssemblyInfo.cs ===
using System.Reflection;
using System.Runtime.CompilerServices;

//
// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
//
[assembly: AssemblyTitle("")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyCompany("")]
[assembly: AssemblyProduct("")]
[assembly: AssemblyCopyright("")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]		

//
// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version 
//      Build Number
//      Revision
//
// You can specify all the values or you can default the Revision and Build Numbers 
// by using the '*' as shown below:

[assembly: AssemblyVersion("1.0.*")]

//
// In order to sign your assembly you must specify a key to use. Refer to the 
// Microsoft .NET Framework documentation for more information on assembly signing.
//
// Use the attributes below to control which key is used for signing. 
//
// Notes: 
//   (*) If no key is specified, the assembly is not signed.
//   (*) KeyName refers to a key that has been installed in the Crypto Service
//       Provider (CSP) on your machine. KeyFile refers to a file which contains
//       a key.
//   (*) If the KeyFile and the KeyName values are both specified, the 
//       following processing occurs:
//       (1) If the KeyName can be found in the CSP, that key is used.
//       (2) If the KeyName does not exist and the KeyFile does exist, the key 
//           in the KeyFile is installed into the CSP and used.
//   (*) In order to create a KeyFile, you can use the sn.exe (Strong Name) utility.
//        When specifying the KeyFile, the location of the KeyFile should be
//        relative to the "project output directory". The location of the project output
//        directory is dependent on whether you are working with a local or web project.
//        For local projects, the project output directory is defined as
//       <Project Directory>\obj\<Configuration>. For example, if your KeyFile is
//       located in the project directory, you would specify the AssemblyKeyFile 
//       attribute as [assembly: AssemblyKeyFile("..\\..\\mykey.snk")]
//        For web projects, the project output directory is defined as
//       %HOMEPATH%\VSWebCache\<Machine Name>\<Project Directory>\obj\<Configuration>.
//   (*) Delay Signing is an advanced option - see the Microsoft .NET Framework
//       documentation for more information on this.
//
[assembly: AssemblyDelaySign(false)]
[assembly: AssemblyKeyFile("")]
[assembly: AssemblyKeyName("")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\LiveTest\ESearch\App_Code\QueryBuilder.cs ===
using System;
using System.Collections;


namespace Events
{
	/// <summary>
	/// Summary description for QueryBuilder.
	/// </summary>
	
	public class QueryData
	{	
		public string AllWordstxt="";
		public string Atlestwords="";
		public string NoWords="";
		public ArrayList vc_apps= new ArrayList();
		public ArrayList Etypes= new ArrayList();
		public bool  useDateRange = false;
		public DateTime start;
		public DateTime end;
		public int Durationinmin;
		//outdated non-dynamic treeview system
        /*public bool AllIIS = false;
		public bool AllINH = false;
		public bool AllWBCA = false;
		public bool AllKDC	=false;
		public bool AllSG	=false;*/
        public bool AllChecked = false;
		public ArrayList CompNames = new ArrayList();
		public string Events="";
		public string titles="";
		public bool ExcludeEvents=false;
		public bool Excludetitles=false;
		public string gamertags;
	}
	public class QueryBuilder
	{

		static string  hexstr="0123456789abcdef";
		public QueryBuilder()
		{
			//
			// TODO: Add constructor logic here
			//
		}
		static public int getInt(string data)
		{
			int tmp=-1;
			data=data.ToLower();

			if(data.StartsWith("0x"))
			{
				// the value is in Hex 
				tmp=Convert.ToInt32(data,16);
			}
			else
			{
				// value is in desimal
				tmp=Convert.ToInt32(data,10);
			}
			


			return tmp;
		}

		static public ArrayList Parseids(string data)
		{

			// event id's
			ArrayList idList= new ArrayList();
			string txtdata= data.Trim();
			if(txtdata !=null && txtdata.Length>0)
			{
				string[] ids=txtdata.Split(new char[]{' ',',',';'});

				for(int l=0;l<ids.Length;l++)
				{
					string tmp = ids[l].Trim();
					if(tmp.Length>0)
					{
						try
						{
							idList.Add(getInt(tmp));
						}
						catch(System.Exception)
						{
							// ignore the exception...
						}
					}

				}
			}

			return idList;

		}

		static public bool isnumber(string data)
		{

			
			if(data.StartsWith("0x"))
			{
				for(int i=2;i<data.Length;i++)
				{
					if(hexstr.IndexOf(data[i])==-1)
						return false;
									
				}
			}
			else
			{
				for(int i=0;i<data.Length;i++)
				{
					if(!Char.IsNumber(data[i]))
						return false;
				}
			}

			return true;
		}
	
	/*	static public long getPUID(string data)
		{
			long tmp=-1;
			data=data.ToLower();


			if(isnumber(data))
			{
				if(data.StartsWith("0x"))
				{
					// the value is in Hex 
					tmp=Convert.ToInt64(data,16);
				}
				else
				{
					// value is in desimal
					tmp=Convert.ToInt64(data,10);
				}
			}
			else
			{
				// its a gamertag . use xcache to convert to puid.
				XCache tmpcache = new XCache();
				tmp = (long)tmpcache.LookupPUID(data);
			}
			


			return tmp;
		}*/

	/*	static public ArrayList ParseGamertagsorpuids(string data)
		{

			// event id's
			ArrayList idList= new ArrayList();
			string txtdata= data.Trim();
			if(txtdata !=null && txtdata.Length>0)
			{
				string[] ids=txtdata.Split(new char[]{' ',',',';'});

				for(int l=0;l<ids.Length;l++)
				{
					string tmp = ids[l].Trim();
					if(tmp.Length>0)
					{
						try
						{
							long puid  =getPUID(tmp);
							if(puid>0)
								idList.Add(puid);
						}
						catch(System.Exception e)
						{
							string tmpe = e.ToString();
							
							// ignore the exception...
						}
					}

				}
			}

			return idList;

		}*/


		static public string GetReqularQuery(string SearchTxt,string server, string Type ,bool IsTop1000, string tbname)
		{
			string mySelectQuery ="";
			
			if(IsTop1000)
				mySelectQuery = "select top 1000 uid_mom_guid, si_type, dt_time,vc_app,i_event_id,vc_server,i_title_id from  ";
			else 
				mySelectQuery = "select uid_mom_guid, si_type, dt_time,vc_app,i_event_id,vc_server,i_title_id from  ";

			mySelectQuery = mySelectQuery+ tbname +" WITH (NOLOCK) ";
			string whereclause = GetReqularClause(SearchTxt,server,Type );
			return mySelectQuery+whereclause;
		}

		static public string GetReqularClause(string SearchTxt,string server, string Type )
		{
			
			string Freetext= null;

			if(SearchTxt.Length>0)
			{
				string tcontains = SearchTxt.Trim();
				string [] array = tcontains.Split(new char[]{' '});
				ArrayList temp = new ArrayList();

				for(int i=0;i<array.Length;i++)
				{
					if(array[i].Trim()!="")
						temp.Add(array[i]);
				}

				bool IsLastWordSeparator =false;
				for(int i=0;i<temp.Count;i++)
				{
					string word = (string) temp[i];
					if(word.ToLower() !="or" && word.ToLower() !="and" )
					{
						if(i+1 <temp.Count)
						{
							string iplus1= (string)temp[i+1];
							if(iplus1.ToLower().Trim() !="and" && !IsLastWordSeparator )
								Freetext+= temp[i]+" or ";
							else
								Freetext+= temp[i]+" ";
						}
						else
							Freetext+= temp[i]+" ";

						IsLastWordSeparator= false;
					}
					else 
					{
						if(i>0)
						{
							if (word.ToLower() =="and")
							{
								if(i+1 <temp.Count)
								{
									string iplus1=  (string)temp[i+1];
									if(iplus1.ToLower().Trim() !="and" && iplus1.ToLower().Trim() !="or" )
										Freetext+= temp[i]+" ";
									
								}
							}

							IsLastWordSeparator= true;
						}
						
					}
					
				}

			}
			// build Query here 
			string mySelectQuery ="";
			if(server !="All Services")
			{
				mySelectQuery+="where vc_app='"+server+"' ";
				if(Freetext!=null && Freetext.Length>0)
					mySelectQuery+=" and contains(vc_description,'"+Freetext+"') ";
				if(Type !="Type")
				{
					if(Type.Trim() =="Error")
					{
						mySelectQuery+=" and si_type=1 ";
					}
					else if(Type.Trim() =="Warning")
					{
						mySelectQuery+=" and si_type=2 ";
					}
					else
					{
						mySelectQuery+=" and si_type=4 ";
					}
					
				}
				mySelectQuery+=" and dt_time > DATEADD(Hour,-12,getdate())";
			}
			else if(Type !="Type")
			{
				if(Type.Trim() =="Error")
				{
					mySelectQuery+=" where si_type=1 ";
				}
				else if(Type.Trim() =="Warning")
				{
					mySelectQuery+=" where si_type=2 ";
				}
				else
				{
					mySelectQuery+=" where si_type=4 ";
				}

				if(Freetext!=null  && Freetext.Length>0)
					mySelectQuery+=" and contains(vc_description,'"+Freetext+"') ";
				
				mySelectQuery+=" and dt_time > DATEADD(Hour,-12,getdate())";
				
			}
			else if(Freetext!=null && Freetext.Length>0)
			{
				mySelectQuery+=" where contains(vc_description,'"+Freetext+"') ";
				//mySelectQuery+=" and dt_time > DATEADD(Hour,-6,getdate())";
			}
			/*else
			{
				mySelectQuery+=" where dt_time > DATEADD(Hour,-6,getdate())";
			}
			*/

			

			mySelectQuery+=" order by dt_time DESC";

			return mySelectQuery;

		}



		static public string GetAdvQuery(QueryData qdata,string tbname)
		{
			string Query ="select uid_mom_guid, si_type, dt_time,vc_app,i_event_id,vc_server,i_title_id from "+tbname+" WITH (NOLOCK)";
			string contains=null;
			int containscount=0;
            
            //free-text search
			string[] _allwords =(qdata.AllWordstxt.Trim()).Split(new char[]{' '});
			string[] _anywords =(qdata.Atlestwords.Trim()).Split(new char[]{' '}); 
			string[] _nowords = (qdata.NoWords.Trim()).Split(new char[]{' '});

			for(int i=0; i<_allwords.Length;i++)
			{
				string temp=_allwords[i].ToLower();
				if(temp!="" && temp!="and" && temp!="or" && temp!="not")
				{
					if(containscount<=0)
						contains =temp;
					else
						contains+=" and "+temp;
					containscount++;
					

				}
			}

			for(int i=0; i<_anywords.Length;i++)
			{
				string temp=_anywords[i].ToLower();
				if(temp!="" && temp!="and" && temp!="or" && temp!="not")
				{
					if(containscount<=0)
						contains =temp;
					else
						contains+=" or "+temp;
					containscount++;
					

				}
			}

			for(int i=0; i<_nowords.Length;i++)
			{
				string temp=_nowords[i].ToLower();
				if(temp!="" && temp!="and" && temp!="or" && temp!="not")
				{
					if(containscount>0)
					{
						contains+=" and not "+temp;
						containscount++;
					}

				}
			}
			
            //services search
            string servires= null;
			int serviresidx=0;

			for (int p=0;p< qdata.vc_apps.Count;p++)
			{
				if(serviresidx<=0)
					servires = " vc_app='"+qdata.vc_apps[p]+"'";
				else
					servires +=" or vc_app='"+qdata.vc_apps[p]+"'";
					
				serviresidx++;
				
			}

            //event types search
			string types= null;
			int typesidx=0;

			for (int p=0; p<qdata.Etypes.Count;p++)
			{
				string dat = (string)qdata.Etypes[p];
				string val;
				if(dat =="Error")
				{
					val="1";
				}
				else if(dat =="Warning")
				{
					val="2";
				}
				else
				{
					val="4";
				}
				
				if(typesidx<=0)
					types = " si_type="+val;
				else
					types +=" or  si_type="+ val;
					
				typesidx++;
				
			}

			string timeserch=null;
			if(qdata.useDateRange)
			{

				// time search...
				
				DateTime start=qdata.start;
				DateTime end=qdata.end;
				
				if(DateTime.Compare(start ,end)>0)
					return "";
				else
				{
					timeserch="dt_time > '"+start.ToString("G")+"' and dt_time < '"+end.ToString("G")+"'";
				}
			}
			else
			{
				timeserch = "dt_time > DATEADD(Minute,-"+qdata.Durationinmin+",getdate())";

			}
            
            //Add Machine Server names
            string Compname = null;

            if (qdata.AllChecked == false)
            {
                bool IsfirstSelecteditem = true;
                
                //outdated non-dynamic server names system
                /*
                if (qdata.AllIIS)
                {
                    Compname = " vc_server like '%POOLIIS%' ";
                    IsfirstSelecteditem = false;
                }
                if (qdata.AllINH)
                {
                    if (IsfirstSelecteditem == true)
                    {
                        Compname = " vc_server like '%POOLINH%' ";
                        IsfirstSelecteditem = false;
                    }
                    else
                        Compname += " or vc_server like '%POOLINH%' ";

                }
                if (qdata.AllWBCA)
                {
                    if (IsfirstSelecteditem == true)
                    {
                        Compname = " vc_server like '%WBCA%' ";
                        IsfirstSelecteditem = false;
                    }
                    else
                        Compname += " or vc_server like '%WBCA%' ";
                }
                if (qdata.AllKDC)
                {
                    if (IsfirstSelecteditem == true)
                    {
                        Compname = " vc_server like '%XEXMACINH%' ";
                        IsfirstSelecteditem = false;
                    }
                    else
                        Compname += " or vc_server like '%XEXMACINH%' ";
                }
                if (qdata.AllSG)
                {
                    if (IsfirstSelecteditem == true)
                    {
                        Compname = " vc_server like '%XESECUINH%' ";
                        IsfirstSelecteditem = false;
                    }
                    else
                        Compname += " or vc_server like '%XESECUINH%' ";
                }
                */
                //this create a possible long query, but i currently can't think of any other way to
                //search by server type, since the names of the servers don't neccessarily have to have
                //and resemblance to the type, and they change frequently.
                foreach (string item in qdata.CompNames)
                {
                    if (IsfirstSelecteditem)
                    {
                        Compname = " vc_server='" + item.Trim() + "' ";
                        IsfirstSelecteditem = false;
                    }
                    else
                        Compname += " or vc_server='" + item.Trim() + "' ";

                }
            }

			// event id's

			ArrayList ids = Parseids(qdata.Events.Trim());
			string eventids=null;
			
			
			for(int l=0;l<ids.Count;l++)
			{
				if(l==0)
				{
					if(qdata.ExcludeEvents)
						eventids+="i_event_id <>'"+ids[l]+"'";
					else
						eventids+="i_event_id ='"+ids[l]+"'";
					
				}
				else
				{
					if(qdata.ExcludeEvents)
						eventids+=" and i_event_id <>'"+ids[l]+"'";
					else
						eventids+=" or i_event_id ='"+ids[l]+"'";
				}
			}

			// titleIDs
			ArrayList tids = Parseids(qdata.titles.Trim());
			string titleids=null;
			
			
			for(int l=0;l<tids.Count;l++)
			{
				if(l==0)
				{
					if(qdata.Excludetitles)
						titleids+="i_title_id <>'"+tids[l]+"'";
					else
						titleids+="i_title_id ='"+tids[l]+"'";
				}
				else
				{
					if(qdata.Excludetitles)
						titleids+=" and i_title_id <>'"+tids[l]+"'";
					else
						titleids+=" or i_title_id ='"+tids[l]+"'";
				}
			}

			// gamertags -NO LONGER SUPPORTED

			//	ArrayList puids = ParseGamertagsorpuids(qdata.gamertags.Trim());

			

			if(containscount >0 || serviresidx>0 ||typesidx>0 ||timeserch !=null || Compname!=null || eventids!=null)
			{
				Query +=" where ";
				if(containscount >0)
				{
					Query+= " contains(vc_description,'"+ contains+"')";
				}
				
				if(serviresidx>0)
				{
					if(containscount >0)
						Query+="and ("+servires+") ";
					else
						Query+=" ("+servires+") ";
				}
				
				if (typesidx>0)
				{
					if(containscount >0 || serviresidx>0 )
						Query+="and ("+types+") ";
					else
						Query+=" ("+types+") ";
				}
				
				if(timeserch !=null)
				{
					if(containscount >0 || serviresidx>0 ||typesidx>0)
						Query+="and "+timeserch;
					else
						Query+=" "+timeserch;

				}

				if(Compname!=null)
				{
					if(containscount >0 || serviresidx>0 ||typesidx>0 ||timeserch !=null)
						Query+="and ("+Compname+") ";
					else
						Query+=" ("+Compname+") ";
				}

				if(eventids !=null)
				{
					if(containscount >0 || serviresidx>0 ||typesidx>0 ||timeserch !=null||Compname!=null)
						Query+=" and ("+eventids+" )";
					else
						Query+=" "+eventids;
				}

				if(titleids!=null)
				{
					if(containscount >0 || serviresidx>0 ||typesidx>0 ||timeserch !=null||Compname!=null || eventids !=null)
						Query+=" and ("+titleids+")";
					else
						Query+=" "+titleids;
				}

			}
			
			

			return Query;

		}


	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\LiveTest\PerfAdmin\PerfDAD\App_Code\EventCodes.cs ===
namespace PerfAdmin
{
    public enum EventIds
    {
        PERFDAD_MOM_CONNECTION = 1,
        PERFDAD_MOM_RULE_CREATION_ERROR = 2,
        PERFDAD_MOM_COMPUTER_GROUP_ASSIGNMENT_ERROR = 3,
        PERFDAD_MOM_XML_ERROR = 4,
        PERFDAD_MOM_GENERIC_ERROR = 5,
        PERFDAD_PERFDB_CONNECTION = 6,
        PERFDAD_PERFDB_XML_ERROR = 7,
        PERFDAD_PERFDB_GENERIC_ERROR = 8
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\LiveTest\PerfAdmin\PerfDAD\CompGroupAdmin.aspx.cs ===
using System;
using System.Data;
using System.Configuration;
using System.Collections;
using System.Web;
using System.Web.Security;
using System.Web.UI;
using System.Web.UI.WebControls;
using System.Web.UI.WebControls.WebParts;
using System.Web.UI.HtmlControls;
namespace PerfAdmin
{
    public partial class WebForm1 : System.Web.UI.Page
    {
       
        protected void Page_Load(object sender, EventArgs e)
        {
            string path = Request.PhysicalPath;
            path = path.Substring(0, path.LastIndexOf('\\') + 1);
            path += "ConfigXML\\";
            PerfDB.InitSettings(path);
            MOMInterface.InitSettings(path);
            
            if (!this.IsPostBack)
            {
                MomLabel.Text = "MOM Server: " + MOMInterface.GetMOMServerName();
                GroupsListBox.Items.Clear();
                ListItemCollection CGs = new ListItemCollection();
                MOMInterface.GetComputerGroups(CGs);
                foreach (ListItem computer in CGs)
                {
                    ListItem temp = new ListItem(computer.Value, computer.Value);
                    if (!GroupsListBox.Items.Contains(temp))
                        GroupsListBox.Items.Add(temp);
                    PerfDB.SortListItemCollection(GroupsListBox.Items);
                }
                
                //MOMInterface.GetRuleGroups(RuleListBox.Items);
                //load the Computer Groups into GroupsListBox
                
            }
            if (ComputersListBox.Items.Count == 0)
            {
                ComputersListBox.Items.Add(new ListItem("No CompGroup selected", "1"));
            }
            if (RuleListBox.Items.Count == 0)
            {
                RuleListBox.Items.Add(new ListItem("No CompGroup selected", "1"));
            }

        }
        protected void GroupsListBox_SelectedIndexChanged(object sender, EventArgs e)
        {
            ComputersListBox.Items.Clear();
            MOMInterface.GetAssignedComputers(GroupsListBox.SelectedItem.Text, ComputersListBox.Items);
            RuleListBox.Items.Clear();
            MOMInterface.GetAssignedRuleGroups(GroupsListBox.SelectedItem.Text, RuleListBox.Items);
            if (RuleListBox.Items.Count == 0)
            {
                RuleListBox.Items.Add(new ListItem("None Assigned", "1"));
            }
        }
        
        protected void RefreshDBButton_Click(object sender, EventArgs e)
        {
            ListItemCollection map = new ListItemCollection();
            MOMInterface.GetComputerToComputerGroupMappingsFromMOMDB(map);
            PerfDB.RemakeComputerToComputerGroupTable(map);
        }
        /*protected void ComputersListBox_SelectedIndexChanged(object sender, EventArgs e)
        {
            ListItemCollection groups = new ListItemCollection();
            RuleListBox.Items.Clear();
            MOMInterface.GetAssignedRuleGroups(ComputersListBox.SelectedItem.Text, RuleListBox.Items);
        }*/
}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\LiveTest\PerfAdmin\PerfDAD\App_Code\Global.asax.cs ===
using System;
using System.Collections;
using System.ComponentModel;
using System.Web;
using System.Web.SessionState;

namespace PerfAdmin 
{
	/// <summary>
	/// Summary description for Global.
	/// </summary>
	public class Global : System.Web.HttpApplication
	{
		/// <summary>
		/// Required designer variable.
		/// </summary>
		private System.ComponentModel.IContainer components = null;

		public Global()
		{
			InitializeComponent();
		}	
		
		protected void Application_Start(Object sender, EventArgs e)
		{

		}
 
		protected void Session_Start(Object sender, EventArgs e)
		{

		}

		protected void Application_BeginRequest(Object sender, EventArgs e)
		{

		}

		protected void Application_EndRequest(Object sender, EventArgs e)
		{

		}

		protected void Application_AuthenticateRequest(Object sender, EventArgs e)
		{

		}

		protected void Application_Error(Object sender, EventArgs e)
		{

		}

		protected void Session_End(Object sender, EventArgs e)
		{

		}

		protected void Application_End(Object sender, EventArgs e)
		{

		}
			
		#region Web Form Designer generated code
		/// <summary>
		/// Required method for Designer support - do not modify
		/// the contents of this method with the code editor.
		/// </summary>
		private void InitializeComponent()
		{    
			this.components = new System.ComponentModel.Container();
		}
		#endregion
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\LiveTest\PerfAdmin\PerfDAD\CounterSet.aspx.cs ===
using System;
using System.Collections;
using System.Configuration;
using System.ComponentModel;
using System.Data;
using System.Drawing;
using System.Web;
using System.Web.SessionState;
using System.Web.UI;
using System.Web.UI.WebControls;
using System.Web.UI.HtmlControls;

namespace PerfAdmin
{
	/// <summary>
	/// Summary description for WebForm1.
	/// </summary>
    /// 
    
	public partial class WebForm1 : System.Web.UI.Page
	{
        protected DataTable CounterTable;
       

        private void BuildCounterTable(string id)
        {
            if (CounterTable == null)
            {
                CounterTable = new DataTable();
                CounterTable.Columns.Add(new DataColumn("Counter Name", typeof(string)));
                CounterTable.Columns.Add(new DataColumn("Instance Name", typeof(string)));
                CounterTable.Columns.Add(new DataColumn("Object", typeof(string)));
            }
            else
            {
                CounterTable.Rows.Clear();
            }
            PerfDB.GetAllCounterDetails(CounterTable, id);
            Session.Add("CounterTable", CounterTable);
            CounterDataGrid.DataSource = new DataView(CounterTable);
            CounterDataGrid.DataBind();
        }

        private void BuildMachineNameDropDown(string machinetype)
        {
            MachineNameDropDown.Items.Clear();
            MachineNameDropDown.Items.Add(new ListItem("<Select Server>", "-1"));

            ListItemCollection serverNames;
            serverNames = new ListItemCollection();
            PerfDB.GetAllComputers(serverNames);
            foreach (ListItem server in serverNames)
            {
                if (machinetype.Equals("<All Types>") || server.Value == machinetype)
                {
                    ListItem serverToAdd = new ListItem(server.Text, server.Text);
                    if (! MachineNameDropDown.Items.Contains(serverToAdd))
                    {
                        MachineNameDropDown.Items.Add(serverToAdd);
                    }
                }
               
            }
            PerfDB.SortListItemCollection(MachineNameDropDown.Items);
        }
        private void BuildMachineTypeDropDown()
        {
            MachineTypeDropDown.Items.Clear();
            MachineTypeDropDown.Items.Add(new ListItem("<All Types>","0"));
            
            ListItemCollection serverTypes;
            serverTypes = new ListItemCollection();
                       
            PerfDB.GetComputerGroups(serverTypes);
            PerfDB.SortListItemCollection(serverTypes);
            foreach (ListItem type in serverTypes)
            {
                MachineTypeDropDown.Items.Add(new ListItem(type.Text, type.Text));
            }


        }
        protected void BuildCounterSetDropDown()
        {
            //ListItemCollection CounterSetNames;
            //CounterSetNames = new ListItemCollection();
            CounterSetDropDownList.Items.Clear();
            PerfDB.GetCounterSetList2(CounterSetDropDownList.Items);
            PerfDB.SortListItemCollection(CounterSetDropDownList.Items);
            CounterSetDropDownList.Items.Insert(0, new ListItem("<Select Counter Set>", "-1"));
        }

        protected void SelectCounterSet(string name, string id)
        {
            CounterSetNameTextBox.Text = name;
            CounterDetailsPanel.Visible = true;
            //TreeviewDisplayPanel.Visible = false;

            //load the counters for that counterset
            BuildCounterTable(id);


        }

           private void LoadLinks()
        {
                try
                {
                   ESearchLink.NavigateUrl = ConfigurationManager.AppSettings["ESearchLink"];
                   GrapherLink.NavigateUrl = ConfigurationManager.AppSettings["GrapherLink"];
                   PerfDADLink.NavigateUrl = ConfigurationManager.AppSettings["PerfDADLink"];
                   RegressionLink.NavigateUrl = ConfigurationManager.AppSettings["RegressionLink"];
                 
                }
                catch(Exception e)
                {
                    System.Diagnostics.EventLog eventLog = new System.Diagnostics.EventLog("Application");
                    eventLog.Source = "PerfDAD";
                    eventLog.WriteEntry("Error loading links from web.config.\n" + e.ToString(), System.Diagnostics.EventLogEntryType.Error, (int)1);
                    eventLog.Close();

                    ESearchLink.Visible = false;
                    GrapherLink.Visible = false;
                    PerfDADLink.Visible = false;
                    RegressionLink.Visible = false;
                }
           }

      
        
                protected void Page_Load(object sender, System.EventArgs e)
                {
                    /*string path = Request.PhysicalPath;
                    path = path.Substring(0, path.LastIndexOf('\\') + 1);
                    path += "ConfigXML\\";*/
                    PerfDB.InitSettings("");
                    MOMInterface.InitSettings("");

                    LoadLinks();

                    if(! this.IsPostBack)
                    {        							
                        //this will be visible, build it!
                        BuildCounterSetDropDown();

                        if (Session["set"] != null)
                        {
                            string id = (string)Session["set"];
                            ListItem item = CounterSetDropDownList.Items.FindByValue(id);                    
                            if (item != null)
                            {
                                string name = item.Text;                        
                                CounterSetDropDownList.SelectedIndex = CounterSetDropDownList.Items.IndexOf(item);
                                ModifyCounterSetButton.Enabled = true;
                                SelectCounterSet(name, id);
                            }
                        }

                        //only need to do once
                        BuildMachineTypeDropDown();
                    }

                    EnvErrorLabel.Visible = false;
                }

		#region Web Form Designer generated code
		override protected void OnInit(EventArgs e)
		{
			//
			// CODEGEN: This call is required by the ASP.NET Web Form Designer.
			//
			InitializeComponent();
			base.OnInit(e);
		}
		
		/// <summary>
		/// Required method for Designer support - do not modify
		/// the contents of this method with the code editor.
		/// </summary>
		private void InitializeComponent()
		{    

		}
		#endregion

		
        //adds a new counter set to PerfDB database and CounterSets tree-view 
        protected void CreateCounterSet_Click(object sender, System.EventArgs e)
		{
            //add the new name to the database
            string id = PerfDB.CreateCounterSet("New CounterSet");
            if (id.Equals("-1")) //something went wrong
                return;

            //add the new name to the dropdown box
            CounterSetDropDownList.Items.Add(new ListItem("New CounterSet", id));
            CounterSetDropDownList.SelectedIndex = CounterSetDropDownList.Items.Count - 1;
            CounterSetDropDownList_SelectedIndexChanged(null, null);
		}
        //load the counters and instances
        protected void PerfObjectDropDown_SelectedIndexChanged(object sender, System.EventArgs e)
		{
            CounterNames.Items.Clear();
            InstanceNames.Items.Clear();
            
            System.Diagnostics.PerformanceCounter[] counters = null;
            //get the instances and the counters
            string[] Instances = XBlPerfCounters.GetInstances(MachineNameDropDown.SelectedItem.Text, PerfObjectDropDown.SelectedItem.Text, InstanceNames.Items);
            int retval = XBlPerfCounters.GetCounters(MachineNameDropDown.SelectedItem.Text, PerfObjectDropDown.SelectedItem.Text, Instances, CounterNames.Items, out counters);
            if (retval == -1)
            {
                CounterNames.Enabled = false;
                InstanceNames.Enabled = false;
            }
            else
            {
                //store the performance counters in the session variable
                Session["PerformanceCounters"] = counters;
                PerfDB.SortListItemCollection(CounterNames.Items);
                PerfDB.SortListItemCollection(InstanceNames.Items);
                CounterNames.Enabled = true;
                InstanceNames.Enabled = true;
                if (InstanceNames.Items.Count == 0)
                {
                    InstanceNames.Enabled = false;
                    //add a placeholder for cosmetic reasons
                    InstanceNames.Items.Add(new ListItem("No instances", "1"));
                }
            }
		}
        //add the selected counters/instances to the database and UI table
        protected void AddCounterButton_Click(object sender, EventArgs e)
        {
            int[] SelectedCounters = CounterNames.GetSelectedIndices();
            //pull the performance counters out of the session variable
            System.Diagnostics.PerformanceCounter[] counters = (System.Diagnostics.PerformanceCounter[])Session["PerformanceCounters"];
            if (SelectedCounters.Length == 0 || counters == null)
            {
                //we have no selected counters or no counters from the session variable
                return;
            }

            foreach (int Counteridx in SelectedCounters)
            {
                int countersIndex = Int32.Parse(CounterNames.Items[Counteridx].Value);
                if (InstanceNames.Items.Count != 0 && !InstanceNames.Items[0].Text.StartsWith("No instance"))
                {
                    int[] InstanceIdx = InstanceNames.GetSelectedIndices(); //add only the selected indicies
                    //get counter details from perfcounter, add to database
                    foreach (int idx in InstanceIdx)
                    {
                        //w3wp instances are special.
                        if (InstanceNames.Items[idx].Value.ToLower().Contains("w3wp"))
                        {
                            //collect ALL instances of this counter, since we can have the w3wp instance # change whenever the apppool recycles.
                            counters[countersIndex].InstanceName = "<All>";
                            //PerfDB.InsertCounterIntoSet(CounterSetDropDownList.SelectedItem.Value, PerfObjectDropDown.SelectedItem.Text, CounterNames.Items[Counteridx].Text, CounterNames.Items[Counteridx].Value, "<All>");
                            PerfDB.InsertCounterIntoSet(CounterSetDropDownList.SelectedItem.Value, counters[countersIndex]);
                        }
                        counters[countersIndex].InstanceName = InstanceNames.Items[idx].Text;
                        PerfDB.InsertCounterIntoSet(CounterSetDropDownList.SelectedItem.Value, counters[countersIndex]);
                        //PerfDB.InsertCounterIntoSet(CounterSetDropDownList.SelectedItem.Value, PerfObjectDropDown.SelectedItem.Text, CounterNames.Items[Counteridx].Text, CounterNames.Items[Counteridx].Value, InstanceNames.Items[idx].Text);
                    }
                }
                else //the instance name is "" (no instance)
                {
                    counters[countersIndex].InstanceName = "";
                    PerfDB.InsertCounterIntoSet(CounterSetDropDownList.SelectedItem.Value, counters[countersIndex]);
                    //PerfDB.InsertCounterIntoSet(CounterSetDropDownList.SelectedItem.Value, PerfObjectDropDown.SelectedItem.Text, CounterNames.Items[Counteridx].Text, CounterNames.Items[Counteridx].Value, "");
                }
            }
            //rebuild the countertable, after all the counters have been added to the database
            BuildCounterTable(CounterSetDropDownList.SelectedItem.Value);
        }
        
       

        protected void EnvDropDownButton_Click(object sender, ImageClickEventArgs e)
        {
            //the environment has changed. do something.
        }

        protected void CounterSetDropDownList_SelectedIndexChanged(object sender, EventArgs e)
        {
            //if selectedvalue == -1, then "select counter set" is selected
            if (!CounterSetDropDownList.SelectedValue.Equals("-1"))
            {
                SelectCounterSet(CounterSetDropDownList.SelectedItem.Text, CounterSetDropDownList.SelectedValue);
                ModifyCounterSetButton.Enabled = true;
                Session["set"] = CounterSetDropDownList.SelectedItem.Value;         

            }
            else
            {
                ModifyCounterSetButton.Enabled = false;
            }
            
        }
        protected void MachineNameDropDown_SelectedIndexChanged(object sender, EventArgs e)
        {
            //populate the categories drop down
            PerfObjectDropDown.Items.Clear();
            XBlPerfCounters.GetCategories(MachineNameDropDown.SelectedItem.Text, PerfObjectDropDown.Items);
            if (PerfObjectDropDown.Items.Count == 0)
            {
                //if there are no items, then we couldn't connect to the machine to get items.
                PerfObjectDropDown.Items.Add(new ListItem("Could not connect to machine.", "-500"));
                CounterNames.Items.Clear();
                InstanceNames.Items.Clear();
                CounterNames.Enabled = false;
                //add a placeholder for cosmetic reasons
                CounterNames.Items.Add(new ListItem("No counters loaded", "1"));
                InstanceNames.Enabled = false;
                //add a placeholder for cosmetic reasons
                InstanceNames.Items.Add(new ListItem("No instances loaded", "1"));
            }
            else
            {
                PerfObjectDropDown.SelectedIndex = 0;
                PerfObjectDropDown_SelectedIndexChanged(null, null);
            }
        }
        protected void MachineTypeDropDown_SelectedIndexChanged(object sender, EventArgs e)
        {
            //populate the machine name drop down
            PerfObjectDropDown.Items.Clear();
            BuildMachineNameDropDown(MachineTypeDropDown.SelectedItem.Text);
        }       
        protected void DoneButton_Click(object sender, EventArgs e)
        {
            //remove the admin panel
            CounterSetSelectPanel.Visible = true;
            CounterSetAdminPanel.Visible = false;

            //submit changes for approval
        }

        protected void CounterDataGrid_SelectedIndexChanged(object sender, EventArgs e)
        {
            //delete selected row
            //CounterDataGrid.SelectedIndex is the index
            //CounterDataGrid.SelectedItem is the row
            Object o = CounterDataGrid.SelectedItem;
            DataTable dt = (DataTable) Session["CounterTable"];
            DataRow r = dt.Rows[CounterDataGrid.SelectedIndex];
            PerfDB.RemoveCounter(r, CounterSetDropDownList.SelectedValue);

            //reload the counter table
            BuildCounterTable(CounterSetDropDownList.SelectedValue);

            //get rid of the selection
            CounterDataGrid.SelectedIndex = -1;

        }

        protected void CounterSetNameTextBox_TextChanged(object sender, EventArgs e)
        {
            string name = CounterSetNameTextBox.Text.Trim();
            string id = CounterSetDropDownList.SelectedValue;
            int index = 0;
            //update set name in the database with CounterSetDropDownList.SelectedValue;
                   
            PerfDB.UpdateCounterSetName(name,id);
            BuildCounterSetDropDown();
            //Building the counter set alphabatizes the names, so we have to find it
            foreach (ListItem item in CounterSetDropDownList.Items)
            {
                if (item.Text.Equals(name) && item.Value.Equals(id))
                {   
                    //we have found our item! index is correct
                    break;
                }
                index++;
            }
            CounterSetDropDownList.SelectedIndex = index;

        }
        //bring up the perfmon looking add counters form
        protected void ModifyCounterSetButton_Click(object sender, EventArgs e)
        {
            //make counterdetails and counteradmin panels visible
            CounterSetSelectPanel.Visible = false;
            CounterSetAdminPanel.Visible = true;
            //RELOAD THE AdminPanel PANEL!!
            int selectedmachineindex = MachineNameDropDown.SelectedIndex;
            BuildMachineNameDropDown(MachineTypeDropDown.SelectedItem.Text);
            MachineNameDropDown.SelectedIndex = selectedmachineindex;
            InstanceNames.Enabled = true;
            CounterNames.Enabled = true;
            
            if (CounterNames.Items.Count == 1 && CounterNames.Items[0].Text.StartsWith("No counter"))
            {
                CounterNames.Enabled = false;
            }
            else if (CounterNames.Items.Count == 0)
            {
                CounterNames.Enabled = false;
                //add a placeholder for cosmetic reasons
                CounterNames.Items.Add(new ListItem("No counters loaded", "1"));
            }
            
            if (InstanceNames.Items.Count == 1 && InstanceNames.Items[0].Text.StartsWith("No instance"))
            {
                InstanceNames.Enabled = false;
            }
            else if (InstanceNames.Items.Count == 0)
            {
                InstanceNames.Enabled = false;
                //add a placeholder for cosmetic reasons
                InstanceNames.Items.Add(new ListItem("No instances loaded", "1"));
            }
           
            
        }

        /*
        protected void BindCounterDetails()
        {
            DataTable dt = new DataTable();
            dt.Columns.Add(new DataColumn("Counter Name", typeof(string)));
            dt.Columns.Add(new DataColumn("Instance Name", typeof(string)));
            dt.Columns.Add(new DataColumn("Object", typeof(string)));
            dt.Columns.Add(new DataColumn("Computer", typeof(string)));
            DataRow dr = dt.NewRow();

            PerfDB.GetOneCounterDetails(dr, CounterSets.SelectedNode.Value);

            CounterDataGrid.DataSource = new DataView(dt);

            CounterDataGrid.DataBind();
        }
        protected void BuildCounterTree()
        {
            ListItemCollection CounterSetNames;
            CounterSetNames = new ListItemCollection();

            PerfDB.GetCounterSetList2(CounterSetNames);
            CounterSets.Nodes.Clear();

            //assume items in serverNames are sorted by server TYPE
            //items in serverNames are composed (TEXT=<server name>,VALUE=<server type>)

            //string previousname = "";
            TreeNode CounterSetNode = new TreeNode();
            foreach (ListItem root in CounterSetNames)
            {
                //add node as "root node in tree"
                CounterSetNode = new TreeNode(root.Text, root.Value);
                ListItemCollection CounterNames = new ListItemCollection();
                //find the counters that map to this counter set (root.Value)
                PerfDB.GetCountersFromCounterSet(CounterNames, root.Value);
                foreach (ListItem counter in CounterNames)
                {
                    TreeNode node = new TreeNode(counter.Text, counter.Value);
                    CounterSetNode.ChildNodes.Add(node);
                }
                CounterSets.Nodes.Add(CounterSetNode);
            }
        }
        //not such a good idea anymore.
        private void UpdateCounterTable(string countername, string instancename, string perfobject)
        {
            if (CounterTable == null) //we've got a problem.
            {
                BuildCounterTable(CounterSetDropDownList.SelectedItem.Value);
            }
            DataRow dr = CounterTable.NewRow();
            dr[0] = countername;
            dr[1] = instancename;
            dr[2] = perfobject;

            CounterTable.Rows.Add(dr);

            CounterDataGrid.DataSource = new DataView(CounterTable);
            CounterDataGrid.DataBind();

        }
        //NO LONGER NEEDED?
        protected void SelectCounter(string name, string id)
        {
            //RELOAD THE CounterDetails PANEL!!
            CounterSetAdminPanel.Visible = false;
            BindCounterDetails();
            CounterDataGrid.Visible = true;

        }
        //WHY?
        protected void CounterSets_TreeNodeCheckChanged(object sender, TreeNodeEventArgs e)
        {
            int i = 0;

        }
          
        protected void CounterSets_SelectedNodeChanged(object sender, EventArgs e)
        {
            if (CounterSets.SelectedNode.Depth == 1)
            {
                //a child node was selected, select the parent.
                SelectCounter(CounterSets.SelectedNode.Text, CounterSets.SelectedNode.Value);               
                //SelectCounterSet(CounterSets.SelectedNode.Parent.Text, CounterSets.SelectedNode.Parent.Value);
            }
            else if (CounterSets.SelectedNode.Depth == 0)
            {
                //A root node (Counter Set name) was selected.
                SelectCounterSet(CounterSets.SelectedNode.Text, CounterSets.SelectedNode.Value);               
            }
        }
         

        //what is button one?
        protected void Button1_Click(object sender, EventArgs e)
        {

            //CounterDetailsPanel.Visible = true;

            TreeNode node = CounterSets.SelectedNode;
            if (node != null)
            {
                while (node.Parent != null)
                    node = node.Parent;
                CounterSets.Nodes.Clear();
                //PerfDB.LoadCounter(node.Value, node);
                CounterSets.Nodes.Add(node);
                CounterSets.ShowCheckBoxes = TreeNodeTypes.Leaf;
            }

        }
        //what is button 2??
        protected void Button2_Click(object sender, EventArgs e)
        {
            //CounterDetailsPanel.Visible = false;

            //PerfDB.LoadCounterSets(CounterSets);
            CounterSets.ShowCheckBoxes = TreeNodeTypes.None;
        }*/



        protected void CounterDataGrid_SelectedIndexChanged1(object sender, EventArgs e)
        {

        }
}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\LiveTest\PerfAdmin\PerfDAD\MachineSet.aspx.cs ===
using System;
using System.Collections;
using System.Configuration;
using System.ComponentModel;
using System.Data;
using System.Drawing;
using System.Web;
using System.Web.SessionState;
using System.Web.UI;
using System.Web.UI.WebControls;
using System.Web.UI.HtmlControls;
using System.IO;

namespace PerfAdmin
{
	/// <summary>
	/// Summary description for MachineSet.
	/// </summary>
    public partial class MachineSet : System.Web.UI.Page
    {
        protected void ShipAllCounterSetsToMOM()
        {

        }

        protected void ShipCounterSetToMOM(string CounterSetID)
        {
            DataTable dt = new DataTable();
            dt.Columns.Add(new DataColumn("Object Name", typeof(string))); //0
            dt.Columns.Add(new DataColumn("Counter Name", typeof(string))); //1
            dt.Columns.Add(new DataColumn("Instance Name", typeof(string))); //2
            dt.Columns.Add(new DataColumn("Counter Type", typeof(string))); //3
            dt.Columns.Add(new DataColumn("Sample Unit", typeof(int))); //4
            dt.Columns.Add(new DataColumn("Sample Frequency", typeof(int))); //5
            dt.Columns.Add(new DataColumn("Computer Name", typeof(string))); //6
            dt.Columns.Add(new DataColumn("MOMEnabled", typeof(bool))); //7
            string results = "Beginning to ship counter set " + CounterSetID + "\n";
            ListItemCollection CGs = new ListItemCollection();
            //first check our table to see if we need to add any of these counters, get all counter details will do this
            PerfDB.GetAllCounterDetailsForShip(dt, CounterSetID);

            //load mom management pack
            string RuleGroupName = "PerfDAD - CounterSetID " + CounterSetID;
            Object MP = MOMInterface.LoadMOMMP(RuleGroupName);
            try
            {
                foreach (DataRow dr in dt.Rows)
                {
                    //don't add the w3wp instances, they are taken care of by the <All> instance, which should be here.
                    if (!((string)dr[2]).Contains("w3wp"))
                    {
                        results += MOMInterface.AddCounterRuleToMOM(MP, CounterSetID, (string)dr[6], (string)dr[0], (string)dr[1], (string)dr[2], (string)dr[3], (int)dr[4], (int)dr[5], (bool)dr[7]);
                        results += "\n";
                    }
                }

                PerfDB.GetComputerGroupsByAssignedCounterSet(CGs, CounterSetID);
                foreach (ListItem CG in CGs)
                {
                    results += MOMInterface.AssignRuleGroupToComputerGroup(MP, CounterSetID, CG.Text);
                    results += "\n";
                }
            }
            catch (Exception e)
            {
                System.Diagnostics.EventLog eventLog = new System.Diagnostics.EventLog("Application");
                eventLog.Source = "PerfDAD";
                eventLog.WriteEntry("Error adding rules or computer groups to MOM Management Pack. \nLog: " + results + "\n" + e.ToString(), System.Diagnostics.EventLogEntryType.Error, (int)PerfAdmin.EventIds.PERFDAD_MOM_GENERIC_ERROR);
                eventLog.Close();
                results += "Exception Error\n";
            }
            //MOMResultLabel.Text = results;
            MOMResultLabel.Visible = true;
            MOMResultLabel.Text = "Done";
            if (results.Contains("Error"))
            {
                MOMResultLabel.Text = "Fail";
            }
            else
            {
                //save the results to mom management pack only if no errors occured
                MOMInterface.SaveMOMMP(MP);
                //go through all the rows and list them in the database
                try
                {
                    foreach (DataRow dr in dt.Rows)
                    {
                        foreach (ListItem CG in CGs)
                        {
                            //don't add the w3wp instances, they are taken care of by the <All> instance, which should be here.
                            if (!((string)dr[2]).Contains("w3wp"))
                            {
                                string ruleName = MOMInterface.ConstructRuleName((string)dr[0], (string)dr[1], (string)dr[2], (int)dr[5], (int)dr[4]);

                                PerfDB.InsertExistingMOMCounterRules(ruleName, CG.Text, CounterSetID, (bool)dr[7]);
                            }
                        }
                    }
                }
                catch (Exception e)
                {
                    System.Diagnostics.EventLog eventLog = new System.Diagnostics.EventLog("Application");
                    eventLog.Source = "PerfDAD";
                    eventLog.WriteEntry("Error adding existing rules to PerfDB2.t_ExistingMOMCounterRules \n" + e.ToString(), System.Diagnostics.EventLogEntryType.Error, (int)PerfAdmin.EventIds.PERFDAD_PERFDB_GENERIC_ERROR);
                    eventLog.Close();
                }
            }

            //write out the log file to the same directory as machineset.aspx
            string path = Request.PhysicalPath;
            path = path.Substring(0, path.LastIndexOf('\\') + 1) + "MOMresults.txt";
            FileStream file = new FileStream(path, FileMode.Append, FileAccess.Write);
            StreamWriter writer = new StreamWriter(file);
            writer.WriteLine(results);
            writer.Close();
            file.Close();


        }

        protected void BuildAssignedComputerGroupsListBox(ListBox CGListBox)
        {
            //populate ComputerGroupListBox with the list of assigned computergroups
            CGListBox.Items.Clear();
            CGListBox.Enabled = true;
            RemoveButton.Enabled = true;
            PerfDB.GetComputerGroupsByAssignedCounterSet(CGListBox.Items, CounterSetListBox.SelectedItem.Value);
            foreach (ListItem item in CGListBox.Items)
            {
                if (item.Text.Length > 14)
                    item.Text = item.Text.Substring(item.Text.IndexOf('-') + 2);
            }
            if (CGListBox.Items.Count == 0)
            {
                CGListBox.Items.Add(new ListItem("None assigned", ""));
                RemoveButton.Enabled = false;
                CGListBox.Enabled = false;
            }

            PerfDB.SortListItemCollection(CGListBox.Items);
        }

        private void BuildNotAssignedComputerGroupsListBox()
        {
            NotAssignedGroupsListBox.Items.Clear();
            ListItemCollection serverTypes;
            serverTypes = new ListItemCollection();

            //NPDB.GetServerTypeList(serverTypes);
            PerfDB.GetComputerGroups(serverTypes);
            //MOMInterface.GetComputerGroups(serverTypes);

            //edit each computer group name to not show the extra stuff
            foreach (ListItem type in serverTypes)
            {
                if (type.Text.Contains("PerfDAD") && !type.Text.Contains("All Servers"))
                {
                    //format the returned string
                    type.Text = type.Text.Substring(type.Text.IndexOf('-') + 2);
                    bool add = true;
                    foreach (ListItem del in AssignedGroupsListBox.Items)
                    {
                        if (del.Text.Equals(type.Text))
                        {
                            add = false;
                        }
                    }
                    if (add) NotAssignedGroupsListBox.Items.Add(new ListItem(type.Text, type.Value));
                }
            }

            PerfDB.SortListItemCollection(NotAssignedGroupsListBox.Items);
        }

        private void LoadLinks()
        {
                try
                {
                   ESearchLink.NavigateUrl = ConfigurationManager.AppSettings["ESearchLink"];
                   GrapherLink.NavigateUrl = ConfigurationManager.AppSettings["GrapherLink"];
                   PerfDADLink.NavigateUrl = ConfigurationManager.AppSettings["PerfDADLink"];
                   RegressionLink.NavigateUrl = ConfigurationManager.AppSettings["RegressionLink"];
                 
                }
                catch(Exception e)
                {
                    System.Diagnostics.EventLog eventLog = new System.Diagnostics.EventLog("Application");
                    eventLog.Source = "PerfDAD";
                    eventLog.WriteEntry("Error loading links from web.config.\n" + e.ToString(), System.Diagnostics.EventLogEntryType.Error, (int)1);
                    eventLog.Close();

                    ESearchLink.Visible = false;
                    GrapherLink.Visible = false;
                    PerfDADLink.Visible = false;
                    RegressionLink.Visible = false;
                }
           }

        protected void Page_Load(object sender, System.EventArgs e)
        {
            /*
            string path = Request.PhysicalPath;
            path = path.Substring(0, path.LastIndexOf('\\') + 1);
            path += "ConfigXML\\";
            */
            PerfDB.InitSettings("");
            MOMInterface.InitSettings("");

            LoadLinks();

            // Put user code to initialize the page here
            if (!this.IsPostBack)
            {
                //build counterset list -- only happens once.
                CounterSetListBox.Items.Clear();
                PerfDB.GetCounterSetList2(CounterSetListBox.Items);
                PerfDB.SortListItemCollection(CounterSetListBox.Items);

                //select a counter set if one was selected by counterset.aspx
                if (Session["set"] != null)
                {
                    string id = (string)Session["set"];
                    ListItem item = CounterSetListBox.Items.FindByValue(id);
                    CounterSetListBox.SelectedIndex = CounterSetListBox.Items.IndexOf(item);
                    CounterSetListBox_SelectedIndexChanged(null, null);
                }
            }
          
            EnvErrorLabel.Visible = false;
            MOMResultLabel.Visible = false;

           
        }

        #region Web Form Designer generated code
        override protected void OnInit(EventArgs e)
        {
            //
            // CODEGEN: This call is required by the ASP.NET Web Form Designer.
            //
            InitializeComponent();
            base.OnInit(e);
        }

        /// <summary>
        /// Required method for Designer support - do not modify
        /// the contents of this method with the code editor.
        /// </summary>
        private void InitializeComponent()
        {

        }
        #endregion
        protected void CounterSetListBox_SelectedIndexChanged(object sender, EventArgs e)
        {
            //int[] CounterSetIdx = CounterSetListBox.GetSelectedIndices();
            //ModifyButton.Enabled = false;
            //if (CounterSetIdx.Length == 1)
            //{
            //populate ComputerGroupListBox with the list of assigned computergroups
            ModifyButton.Enabled = true;
            BuildAssignedComputerGroupsListBox(ComputerGroupListBox);
            ComputerGroupListBox.Enabled = false;
            Session["set"] = CounterSetListBox.SelectedItem.Value;
            //}
        }
        protected void ComputerGroupListBox_SelectedIndexChanged(object sender, EventArgs e)
        {
            //int[] idxs = ComputerGroupListBox.GetSelectedIndices();
            //int[] CounterSetIdx = CounterSetListBox.GetSelectedIndices();

            //DeleteButton.Enabled = false;
            //AssignedListBox.Items.Clear();

            //check if only one computer group is selected to populate assign box
            /*if (idxs.Length == 1)
            {
                //build Assigned List Box
                ListItemCollection CounterSets = new ListItemCollection();

                PerfDB.GetCounterSetAssignments(CounterSets, ComputerGroupListBox.SelectedItem.Text);

                foreach (ListItem item in CounterSets)
                    AssignedListBox.Items.Add(item);
                //enable remove button if there's items to remove
                if (AssignedListBox.Items.Count > 0)
                    DeleteButton.Enabled = true;
            } */
        }
        protected void EnvDropDownButton_Click(object sender, ImageClickEventArgs e)
        {
            //the environment has changed. do nothing.
        }
        /*
        protected void AssignButton_Click(object sender, EventArgs e)
        {
            int[] ComputerGroupIdx = ComputerGroupListBox.GetSelectedIndices();
            int[] CounterSetIdx = CounterSetListBox.GetSelectedIndices();
            
            //check for proper conditions
            if (ComputerGroupIdx.Length == 0 || CounterSetIdx.Length == 0)
                return;

            foreach (int CSI in CounterSetIdx)
            {
                foreach (int CGI in ComputerGroupIdx)
                {
                    //insert mapping into database
                    string CounterSetID = CounterSetListBox.Items[CSI].Value;
                    string CounterSetName = CounterSetListBox.Items[CSI].Text.Trim();
                    string ComputerGroup = ComputerGroupListBox.Items[CGI].Text.Trim();
                    PerfDB.CreateCounterSetAssignments(CounterSetID, CounterSetName, ComputerGroup);
                }
            }

            ComputerGroupListBox_SelectedIndexChanged(null, null);
        }*/

        //guaranteed that only one computer group is selected
        /*protected void DeleteButton_Click(object sender, EventArgs e)
        {
            int[] CounterSetIdx = AssignedListBox.GetSelectedIndices();
            int[] ComputerGroupIdx = ComputerGroupListBox.GetSelectedIndices();
            int CGI = ComputerGroupIdx[0];
            foreach (int CSI in CounterSetIdx)
            {
                string CounterSetID = AssignedListBox.Items[CSI].Value;
                string CounterSetName = AssignedListBox.Items[CSI].Text;
                string ComputerGroup = ComputerGroupListBox.Items[CGI].Text;
                PerfDB.DeleteCounterSetAssignments(CounterSetID, ComputerGroup);
            }

            //rebuild assign box 
            ComputerGroupListBox_SelectedIndexChanged(null, null);

        }*/
        protected void ModifyButton_Click(object sender, EventArgs e)
        {
            StatusPanel.Visible = false;
            ModifyAssignmentsPanel.Visible = true;
            CounterSetNameLabel.Text = CounterSetListBox.SelectedItem.Text;
            //build not assigned and assigned list boxes
            BuildAssignedComputerGroupsListBox(AssignedGroupsListBox);
            BuildNotAssignedComputerGroupsListBox();
        }


        protected void AddButton_Click(object sender, EventArgs e)
        {
            int[] ComputerGroupIdx = NotAssignedGroupsListBox.GetSelectedIndices();

            //check for proper conditions
            if (ComputerGroupIdx.Length == 0)
                return;

            foreach (int CGI in ComputerGroupIdx)
            {
                //insert mapping into database
                string CounterSetID = CounterSetListBox.SelectedItem.Value;
                string CounterSetName = CounterSetListBox.SelectedItem.Text.Trim();
                string ComputerGroup = NotAssignedGroupsListBox.Items[CGI].Value.Trim();
                PerfDB.CreateCounterSetAssignments(CounterSetID, CounterSetName, ComputerGroup);
            }
            //rebuild assign boxes
            BuildAssignedComputerGroupsListBox(AssignedGroupsListBox);
            BuildNotAssignedComputerGroupsListBox();


        }

        protected void RemoveButton_Click(object sender, EventArgs e)
        {
            int[] ComputerGroupIdx = AssignedGroupsListBox.GetSelectedIndices();

            //check for proper conditions
            if (ComputerGroupIdx.Length == 0)
                return;

            foreach (int CGI in ComputerGroupIdx)
            {
                string CounterSetID = CounterSetListBox.SelectedItem.Value;
                string CounterSetName = CounterSetListBox.SelectedItem.Text;
                string ComputerGroup = AssignedGroupsListBox.Items[CGI].Value;
                PerfDB.DeleteCounterSetAssignments(CounterSetID, ComputerGroup);
            }

            //rebuild assign boxes 
            BuildAssignedComputerGroupsListBox(AssignedGroupsListBox);
            BuildNotAssignedComputerGroupsListBox();
        }
        protected void DoneButton_Click(object sender, EventArgs e)
        {
            StatusPanel.Visible = true;
            ModifyAssignmentsPanel.Visible = false;

            BuildAssignedComputerGroupsListBox(ComputerGroupListBox);
            ComputerGroupListBox.Enabled = false;
        }
        protected void ShipButton_Click(object sender, EventArgs e)
        {
            ShipCounterSetToMOM(CounterSetListBox.SelectedItem.Value);

        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\LiveTest\PerfAdmin\PerfDAD\Grapher.aspx.cs ===
using System;
using System.Data;
using System.Configuration;
using System.Web;
using System.Web.Security;
using System.Web.UI;
using System.Web.UI.WebControls;
using System.Web.UI.WebControls.WebParts;
using System.Web.UI.HtmlControls;

using System.Drawing;
using System.Data.SqlClient;
using System.Collections.Generic;

using System.IO;

namespace PerfAdmin
{
    public class GraphXYPair : IComparable<GraphXYPair>
    {
        private float _y;
        private DateTime _x;

        public GraphXYPair(DateTime dateTime, float val)
        {
            _x = dateTime;
            _y = val;
        }

        public float y
        {
            get { return _y; }
            set { _y = value; }
        }

        public DateTime x
        {
            get { return _x; }
            set { _x = value; }
        }

        public int CompareTo(GraphXYPair other)
        {
            return _x.CompareTo(other.x);
        }

        public static bool operator <(GraphXYPair lhs, GraphXYPair rhs)
        {
            return lhs.x < rhs.x;
        }

        public static bool operator >(GraphXYPair lhs, GraphXYPair rhs)
        {
            return lhs.x > rhs.x;
        }
    }

    public class CounterLine
    {
        private List<GraphXYPair> _dataPoints = new List<GraphXYPair>();
        private bool _enabled = true;

        public CounterLine(List<GraphXYPair> dataPoints)
        {
            _dataPoints = dataPoints;
            _dataPoints.Sort();
        }

        public bool enabled
        {
            get { return enabled; }
            set { _enabled = value; }
        }

        public List<GraphXYPair> dataPoints
        {
            get { return _dataPoints; }
        }

        public bool FlashTest()
        {
            return false;
        }
    }

    public partial class WebForm1 : System.Web.UI.Page
    {
        private void LoadLinks()
        {
                try
                {
                   ESearchLink.NavigateUrl = ConfigurationManager.AppSettings["ESearchLink"];
                   GrapherLink.NavigateUrl = ConfigurationManager.AppSettings["GrapherLink"];
                   PerfDADLink.NavigateUrl = ConfigurationManager.AppSettings["PerfDADLink"];
                   RegressionLink.NavigateUrl = ConfigurationManager.AppSettings["RegressionLink"];
                 
                }
                catch(Exception e)
                {
                    System.Diagnostics.EventLog eventLog = new System.Diagnostics.EventLog("Application");
                    eventLog.Source = "Grapher";
                    eventLog.WriteEntry("Error loading links from web.config.\n" + e.ToString(), System.Diagnostics.EventLogEntryType.Error, (int)1);
                    eventLog.Close();

                    ESearchLink.Visible = false;
                    GrapherLink.Visible = false;
                    PerfDADLink.Visible = false;
                    RegressionLink.Visible = false;
                }
           }
        protected void Page_Load(object sender, EventArgs e)
        {
            LoadLinks();
        }

        ///// <summary>
        /////     BuildCounterSetDropDown collects a list of available counter
        /////     sets and adds them to the CounterSetDropDownList drop down list
        ///// </summary>
        ///// <returns>void</returns>
        //protected void BuildCounterSetDropDown()
        //{
        //    CounterSetDropDownList.Items.Clear();
        //    PerfDB.GetCounterSetList2(CounterSetDropDownList.Items);
        //    PerfDB.SortListItemCollection(CounterSetDropDownList.Items);
        //    CounterSetDropDownList.Items.Insert(0, new ListItem("<Select Counter Set>", "-1"));
        //}

        ///// <summary>
        /////     ApplyGraphDesign applies all desired visual settings to the
        /////     graph. This includes items such as size, color, axis type,
        /////     frame, working directory, etc.
        ///// </summary>
        ///// <returns>void</returns>
        //private void ApplyGraphDesign()
        //{
        //    // set up the directory
        //    Xceed.Chart.Server.GeneralSettings generalSettings = ChartServerControl1.ServerConfiguration.GeneralSettings;
        //    generalSettings.TempDirectory = "/XceedTemp";

        //    // add an image border
        //    ChartServerControl1.Background.FrameType = FrameType.Image;
        //    ImageFrame imageFrame = ChartServerControl1.Background.ImageFrame;
        //    imageFrame.SetPredefinedFrameStyle(PredefinedImageFrame.Thin);
        //    imageFrame.FillEffect.SetSolidColor(Color.Black);
        //    imageFrame.Border.Color = Color.White;
        //    imageFrame.BackgroundColor = Color.White;

        //    // set up background
        //    ChartServerControl1.Background.FillEffect.SetGradient(GradientStyle.Horizontal, GradientVariant.Variant1, Color.Ivory, Color.Orange);

        //    // set width, height, margins, and axis type
        //    Chart chart = (Chart)ChartServerControl1.Charts[0];
        //    chart.Width = 115;
        //    chart.Height = 70;
        //    chart.Margins = new RectangleF(0, 0, 100, 100);
        //    chart.Axis(StandardAxis.PrimaryX).ScaleMode = AxisScaleMode.DateTime;
        //    //chart.Axis(StandardAxis.PrimaryX).MajorGridLine.Pattern = LinePattern.Dot;
        //    chart.Axis(StandardAxis.PrimaryX).OuterTickLength = 1.5f;
        //    chart.Axis(StandardAxis.PrimaryX).MinorTickLength = 1;
        //    chart.Axis(StandardAxis.PrimaryX).StaggerTexts = true;

        //    Axis primaryX = chart.Axis(StandardAxis.PrimaryX);
        //    primaryX.DateTimeScale.AutoLabels = false;
        //    primaryX.DateTimeScale.MajorTickMode = MajorTickModeDateTime.IrregularSteps;
        //    primaryX.DateTimeScale.CustomSteps.Clear();
        //    primaryX.Labels.Clear();
        //}

        ///// <summary>
        /////     GatherOptions will collect all options from the various
        /////     textboxes, drop downs, calendars, etc on the webpage.
        ///// </summary>
        ///// <returns>void</returns>
        //private void GatherOptions()
        //{
        //    // Set the start and end times for the data currently being displayed
        //    _startDateTime = CalendarPopupStart.SelectedDate;

        //    DateTime selectedTime = TimePickerStart.SelectedTime;

        //    // We want the time to be kept on 30 minute intervals
        //    if (selectedTime.Minute < 30)
        //    {
        //        selectedTime = selectedTime.AddMinutes(-selectedTime.Minute);
        //    }
        //    else if(selectedTime.Minute > 30)
        //    {
        //        selectedTime = selectedTime.AddMinutes(30-selectedTime.Minute);
        //    }
        //    selectedTime = selectedTime.AddSeconds(-selectedTime.Second);

        //    // Now assign the selected date/time to the _startDateTime variable
        //    _startDateTime = _startDateTime.AddHours(selectedTime.Hour);
        //    _startDateTime = _startDateTime.AddMinutes(selectedTime.Minute);
        //    _startDateTime = _startDateTime.AddSeconds(selectedTime.Second);

        //    // Calculate the ending time of the graph based on the interval
        //    _endDateTime = _startDateTime.AddHours(Convert.ToDouble(IntervalList.SelectedItem.Value));
        //}

        ///// <summary>
        /////     GetCounterSetData will load all desired counters from their
        /////     respective servers.
        ///// </summary>
        ///// <returns>void</returns>
        //private void GetCounterSetData()
        //{
        //    TimeSpan span = new TimeSpan(0, 15, 0);
        //    DateTime dateTime = CalendarPopupStart.SelectedDate;
        //    List<GraphXYPair> dataPoints = new List<GraphXYPair>();
        //    for (Int32 i = 0; i < 96; ++i)
        //    {
        //        if (i < 48)
        //        {
        //            dataPoints.Add(new GraphXYPair(dateTime, i));
        //        }
        //        else
        //        {
        //            dataPoints.Add(new GraphXYPair(dateTime, 95-i));
        //        }
        //        dateTime += span;
        //    }
        //    _counters.Add(new CounterLine(dataPoints));

        //    dateTime = CalendarPopupStart.SelectedDate;
        //    List<GraphXYPair> dataPoints2 = new List<GraphXYPair>();
        //    for (Int32 i = 0; i < 96; ++i)
        //    {
        //        if (i < 48)
        //        {
        //            dataPoints2.Add(new GraphXYPair(dateTime, 47 - i));
        //        }
        //        else
        //        {
        //            dataPoints2.Add(new GraphXYPair(dateTime, i - 48));
        //        }
        //        dateTime += span;
        //    }
        //    _counters.Add(new CounterLine(dataPoints2));
        //}

        ///// <summary>
        /////     SetupAxes will determine the area of the graph which is
        /////     desired and set the axis labels and values to fit it
        ///// </summary>
        ///// <param name="chart">A reference to the chart</param>
        ///// <returns>void</returns>
        //private void SetupAxes()
        //{
        //    Chart chart = (Chart)ChartServerControl1.Charts[0];

        //    Axis primaryX = chart.Axis(StandardAxis.PrimaryX);
        //    Axis primaryY = chart.Axis(StandardAxis.PrimaryY);

        //    primaryX.Ruler.PagingMode = RulerPagingMode.FixedPageSize;

        //    // Currently 3 hours per page
        //    primaryX.Ruler.PageSize = _endDateTime.ToOADate() - _startDateTime.ToOADate();
        //                              //(new DateTime(2007, 1, 1, 3, 0, 0)).ToOADate() -
        //                              //(new DateTime(2007, 1, 1, 0, 0, 0)).ToOADate();
        //    primaryX.Ruler.CurrentPageMode = RulerCurrentPageMode.BeginValue;
        //    primaryX.Ruler.CurrentPageBeginValue = _startDateTime.ToOADate();//(new DateTime(2007, 1, 1, 2, 0, 0)).ToOADate();
        //    //primaryX.ValueFormatting.Format = Xceed.Chart.Utilities.ValueFormat.Time;

        //    CreateAxisLabels();

        //    float currMin = _minSelectedValue; // Calculated mininum value of displayed data
        //    float currMax = _maxSelectedValue; // Calculated maximum value of displayed data

        //    primaryY.Ruler.PagingMode = RulerPagingMode.FixedPageSize;
        //    primaryY.Ruler.PageSize = (int)(currMax - currMin);
        //    primaryY.Ruler.CurrentPageMode = RulerCurrentPageMode.BeginValue;
        //    primaryY.Ruler.CurrentPageBeginValue = currMin;
        //}

        //private void CreateAxisLabels()
        //{
        //    Chart chart = (Chart)ChartServerControl1.Charts[0];
        //    Axis primaryX = chart.Axis(StandardAxis.PrimaryX);
        //    Axis primaryY = chart.Axis(StandardAxis.PrimaryY);

        //    // X AXIS LABELS
        //    TimeSpan span = new TimeSpan(0, 0, 0);

        //    // We will see which interval the user has selected, and change
        //    // the span between the labels depending on it
        //    int intervalValue = Convert.ToInt32(IntervalList.SelectedItem.Value);
        //    if (intervalValue >= 6)
        //    {
        //        span = new TimeSpan(intervalValue/6, 0, 0);
        //    }
        //    else
        //    {
        //        span = new TimeSpan(0, Convert.ToInt32((Convert.ToDouble(intervalValue)/6.0)*60), 0);
        //    }
            
        //    // We now start at the desired start time and add the desired labels to the X axis
        //    DateTime dateTime = new DateTime(_startDateTime.Year, _startDateTime.Month, _startDateTime.Hour + 1, 0, 0, 0);
        //    for (Int32 i = 0; i <= /*_dataPoints.Count*/100; ++i) //*** WRONG ***
        //    {
        //         primaryX.Labels.Add(dateTime.ToShortTimeString());
        //         primaryX.DateTimeScale.CustomSteps.Add(span);

        //        dateTime += span;
        //    }

        //    // Y AXIS LABELS
        //    //float difference = (_maxSelectedValue - _minSelectedValue);

        //}

        ///// <summary>
        /////     FindMaxMinValues will find the minimum and maximum values for
        /////     the area currently being zoomed in on
        ///// </summary>
        ///// <returns>void</returns>
        //private void FindMaxMinValues()
        //{
        //    for (int i = 0; i < _counters.Count; ++i)
        //    {
        //        foreach (GraphXYPair point in _counters[i].dataPoints)
        //        //foreach (GraphXYPair point in _dataPoints)
        //        {
        //            // *** THIS CHECK IS ONLY TEMPORARY ***
        //            if (point.x < _startDateTime || point.x > _endDateTime)
        //            {
        //                continue;
        //            }

        //            // Calculate the min and max values for the selected area
        //            if (point.y > _maxSelectedValue)
        //            {
        //                _maxSelectedValue = point.y;
        //            }

        //            if (point.y < _minSelectedValue)
        //            {
        //                _minSelectedValue = point.y;
        //            }
        //        }
        //    }
        //}

        //protected void Button1_Click(object sender, EventArgs e)
        //{
        //    FileStream file = new FileStream(@"C:\PerfGrapher.txt", FileMode.Open, FileAccess.Write);

        //    StreamWriter sw = new StreamWriter(file);
        //    sw.Write("title=Huckleberry%20Finn&author=Cody%20Luitjens");
        //    sw.Close();

        //    file.Close();
        //}
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\LiveTest\PerfAdminSetup\makefile.inc ===
!include $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\LiveTest\PerfAdmin\PerfDAD\App_Code\PerfDB.cs ===
using System;
using System.Data;
using System.Xml;
using System.Web;
using System.Collections;
using System.Configuration;
using System.ComponentModel;
using System.Data.SqlClient;
using System.Web.UI.WebControls;

namespace PerfAdmin
{
	/// <summary>
	/// Summary description for PerfDB.
    /// 
    /// CounterDetails Table
    ///     SampleUnit Column: 
    ///         MOM_SAMPLE_UNIT_SECONDS = 0,
    ///         MOM_SAMPLE_UNIT_MINUTES = 1,
    ///         MOM_SAMPLE_UNIT_HOURS = 2,
    ///         MOM_SAMPLE_UNIT_DAYS = 3,
    /// 


	/// </summary>
	public class PerfDB
	{
        static string myConnString = "";
        //public static string set = ""; //part of hack to let counterset.aspx and machineset.aspx to talk to each other w/o using viewstate
	
		public PerfDB()
		{
		}

        static public void InitSettings(string pathToXMLfolder)
        {
            //find out the connection string for perfdb
            try
            {
                /*XmlDocument perfDBXml = new XmlDocument();
                 //System.Web.VirtualPathUtility.GetDirectory("/PerfAdmin/ConfigXML");
                pathToXMLfolder += "PerfDB.xml";
                perfDBXml.Load(pathToXMLfolder);
                XmlNode perfDB = perfDBXml.SelectSingleNode("descendant::PerfDB");
                myConnString = perfDB.SelectSingleNode("ConnectionString").InnerText;*/

                myConnString = "";
                if (ConfigurationManager.ConnectionStrings["PerfDB2"] == null)
                    throw new Exception("No connection string found for PerfDB2. Please add a connection string to web.config with name=PerfDB2");
            
                myConnString = ConfigurationManager.ConnectionStrings["PerfDB2"].ToString();
              
            }
            catch (Exception e)
            {
                System.Diagnostics.EventLog eventLog = new System.Diagnostics.EventLog("Application");
                eventLog.Source = "PerfDAD";
                eventLog.WriteEntry("Error loading settings from web.config.\n" + e.ToString(), System.Diagnostics.EventLogEntryType.Error, (int)PerfAdmin.EventIds.PERFDAD_PERFDB_XML_ERROR);
                eventLog.Close();

                //reverting to default:
                myConnString = "Data Source=xetestsql001;Initial Catalog=PerfDB2;persist security info=False;integrated security=SSPI;";
            }

        }
        
        //function to sort the list alphabetically by "text"
        static public void SortListItemCollection(ListItemCollection list)
        {
            if (list.Count == 0 || list.Count == 1) return;
            ListItemCollection UnSortedList = new ListItemCollection();
            foreach (ListItem item in list)
            {
                UnSortedList.Add(item);
            }
            list.Clear();
                        
            list.Add(UnSortedList[0]);
            UnSortedList.RemoveAt(0);

            foreach (ListItem item in UnSortedList)
            {
                int index = 0;
                Boolean placed = false;
                foreach (ListItem sorteditem in list)
                {
                    int sort = item.Text.CompareTo(sorteditem.Text);
                    if ( sort <= 0)
                    {
                        //insert before sorted item
                        list.Insert(index, item);
                        placed = true;
                        break;
                    }
                    index++;
                }
                if (!placed)
                    list.Insert(index, item);
            }
            
        }

        //updates the CounterSet table to change the counter set name given an ID
        static public void UpdateCounterSetName(string CounterSetName, string CounterSetID)
        {
            SqlConnection _EventCnt = null;
            try
            {
                //open a connection to the database specified in the database variable
                _EventCnt = new SqlConnection(myConnString);
                _EventCnt.Open();

                //Update for the CounterSetName names 
                string mySelectQuery = "update [PerfDB2].[dbo].[t_CounterSet] set CounterSet_Name = '"+CounterSetName+"' where CounterSet_ID = '" + CounterSetID + "'";
                SqlCommand myCommand = new SqlCommand(mySelectQuery, _EventCnt);
                myCommand.CommandType = CommandType.Text;
                myCommand.ExecuteReader();

            }
            catch (Exception e)
            {
                System.Diagnostics.EventLog eventLog = new System.Diagnostics.EventLog("Application");
                eventLog.Source = "PerfDAD";
                eventLog.WriteEntry("Error updating counter set name for CounterSetID " + CounterSetID + " from PerfDB. \n" + e.ToString(), System.Diagnostics.EventLogEntryType.Error, (int)PerfAdmin.EventIds.PERFDAD_PERFDB_GENERIC_ERROR);
                eventLog.Close();
            }
            finally
            {
                if (_EventCnt != null)
                {
                    _EventCnt.Close();
                    _EventCnt = null;
                }

            }

           

        }

        //pulls the counter set ID and names out of PerfDB, adds them to CounterSets
        //CounterSets.Text = <counter set name>
        //CounterSets.Value = <counter set ID>
        static public void GetCounterSetList2(ListItemCollection CounterSets)
        {
            SqlConnection _EventCnt = null;
            try
            {
                //open a connection to the database specified in the database variable
                _EventCnt = new SqlConnection(myConnString);
                _EventCnt.Open();

                //Query for the server names 
                string mySelectQuery = "select * from dbo.t_CounterSet";
                SqlCommand myCommand = new SqlCommand(mySelectQuery, _EventCnt);
                myCommand.CommandType = CommandType.Text;
                SqlDataReader myReader = myCommand.ExecuteReader();
                while (myReader.Read())
                {
                    //read and store counter set names
                    int id = myReader.GetInt32(0);
                    string name = myReader.GetString(1).Trim();
                    CounterSets.Add(new ListItem(name,id.ToString().Trim()));
                }

                myReader.Close();

            }
            catch (Exception e)
            {
                System.Diagnostics.EventLog eventLog = new System.Diagnostics.EventLog("Application");
                eventLog.Source = "PerfDAD";
                eventLog.WriteEntry("Error reading all counter sets from PerfDB. \n" + e.ToString(), System.Diagnostics.EventLogEntryType.Error, (int) PerfAdmin.EventIds.PERFDAD_PERFDB_GENERIC_ERROR);
                eventLog.Close();
            }
            finally
            {
                if (_EventCnt != null)
                {
                    _EventCnt.Close();
                    _EventCnt = null;
                }

            }

        }

        //pulls assignments given a computer group out of CounterSetAssignments table
        static public void GetCounterSetAssignments(ListItemCollection CounterSets, string machinename)
        {
            SqlConnection _EventCnt = null;
            try
            {
                //open a connection to the database specified in the database variable
                _EventCnt = new SqlConnection(myConnString);
                _EventCnt.Open();

                //Query for the server names 
                string mySelectQuery = "select CounterSetID, CounterSetName from dbo.t_CounterSetAssignments where ComputerGroupName = '"+machinename+"' and Enabled = '1'";
                SqlCommand myCommand = new SqlCommand(mySelectQuery, _EventCnt);
                myCommand.CommandType = CommandType.Text;
                SqlDataReader myReader = myCommand.ExecuteReader();
                while (myReader.Read())
                {
                    //read and store counter set names
                    int id = myReader.GetInt32(0);
                    string name = myReader.GetString(1).Trim();
                    CounterSets.Add(new ListItem(name, id.ToString()));
                }

                myReader.Close();

            }
            catch (Exception e)
            {
                System.Diagnostics.EventLog eventLog = new System.Diagnostics.EventLog("Application");
                eventLog.Source = "PerfDAD";
                eventLog.WriteEntry("Error reading counters sets assigned to ComputerGroup "+ machinename + " from PerfDB. \n" + e.ToString(), System.Diagnostics.EventLogEntryType.Error, (int) PerfAdmin.EventIds.PERFDAD_PERFDB_GENERIC_ERROR);
                eventLog.Close();
            }
            finally
            {
                if (_EventCnt != null)
                {
                    _EventCnt.Close();
                    _EventCnt = null;
                }

            }

        }
        
        //pulls out all the computer groups that have been assigned to given counterset
        public static void GetComputerGroupsByAssignedCounterSet(ListItemCollection ComputerGroupsItems, string CounterSetID)
        {
            SqlConnection _EventCnt = null;
            try
            {
                //open a connection to the database specified in the database variable
                _EventCnt = new SqlConnection(myConnString);
                _EventCnt.Open();

                //Query for the server names 
                string mySelectQuery = "select ComputerGroupName from dbo.t_CounterSetAssignments where CounterSetID = '"+CounterSetID+"' and Enabled = '1'";
                SqlCommand myCommand = new SqlCommand(mySelectQuery, _EventCnt);
                myCommand.CommandType = CommandType.Text;
                SqlDataReader myReader = myCommand.ExecuteReader();
                while (myReader.Read())
                {
                    //read computer groups
                    string name = myReader.GetString(0).Trim();
                    ComputerGroupsItems.Add(new ListItem(name, name));
                }

                myReader.Close();

            }
            catch (Exception e)
            {
                System.Diagnostics.EventLog eventLog = new System.Diagnostics.EventLog("Application");
                eventLog.Source = "PerfDAD";
                eventLog.WriteEntry("Error reading computer groups assigned to CounterSetID " + CounterSetID + " from PerfDB. \n" + e.ToString(), System.Diagnostics.EventLogEntryType.Error, (int) PerfAdmin.EventIds.PERFDAD_PERFDB_GENERIC_ERROR);
                eventLog.Close();
            }
            finally
            {
                if (_EventCnt != null)
                {
                    _EventCnt.Close();
                    _EventCnt = null;
                }

            }
            
        }
        //creates an assignment between countersets and computer groups
        //checks for duplicate assignments, and for "disabled" state -> makes it "enabled"
        static public void CreateCounterSetAssignments(string CounterSetID, string CounterSetName, string ComputerGroup)
        {
            SqlConnection _EventCnt = null;
            try
            {
                //open a connection to the database specified in the database variable
                _EventCnt = new SqlConnection(myConnString);
                _EventCnt.Open();
                //determine if this counterset already is assigned to this computergroup
                string mySelectQuery = "SELECT Enabled from [PerfDB2].[dbo].[t_CounterSetAssignments] where CounterSetID = '" + CounterSetID + "'  and ComputerGroupName ='" + ComputerGroup + "'";
                SqlCommand myCommand = new SqlCommand(mySelectQuery, _EventCnt);
                myCommand.CommandType = CommandType.Text;
                SqlDataReader myReader = myCommand.ExecuteReader();
                if (myReader.HasRows == false)
                {
                    //There is NO counterset assignment, so make one! 
                    myReader.Close();
                    mySelectQuery = "INSERT INTO [PerfDB2].[dbo].[t_CounterSetAssignments] VALUES ( '" + CounterSetID + "', '" + CounterSetName + "', '" + ComputerGroup + "', 1)";
                    myCommand = new SqlCommand(mySelectQuery, _EventCnt);
                    myCommand.CommandType = CommandType.Text;
                    myCommand.ExecuteScalar();
                }
                else
                {
                    myReader.Read();
                    Boolean enabled = myReader.GetBoolean(0);
                    if (enabled == false)
                    {
                        myReader.Close();

                        mySelectQuery = "update [PerfDB2].[dbo].[t_CounterSetAssignments] set Enabled = '1' where CounterSetID = '" + CounterSetID + "' and ComputerGroupName ='" + ComputerGroup + "'";
                        myCommand = new SqlCommand(mySelectQuery, _EventCnt);
                        myCommand.CommandType = CommandType.Text;
                        myCommand.ExecuteReader();
                    }
                }
                myReader.Close();
            }
            catch (Exception e)
            {
                System.Diagnostics.EventLog eventLog = new System.Diagnostics.EventLog("Application");
                eventLog.Source = "PerfDAD";
                eventLog.WriteEntry("Error creating counter set assignment of CounterSetID " + CounterSetID + " to Computer Group "+ComputerGroup+" in PerfDB. \n" + e.ToString(), System.Diagnostics.EventLogEntryType.Error, (int) PerfAdmin.EventIds.PERFDAD_PERFDB_GENERIC_ERROR);
                eventLog.Close();
            }
            finally
            {
                if (_EventCnt != null)
                {
                    _EventCnt.Close();
                    _EventCnt = null;
                }

            }

        }

		//Adds a new counterset to the database, returns the ID associated
        //return value of -1 means something went wrong
		static public string CreateCounterSet( string name)
		{
            string id = "-1";
			SqlConnection _EventCnt =null;
			try
			{
                _EventCnt = new SqlConnection(myConnString);
                _EventCnt.Open();
                
                //QUESTION: Do we allow duplicate counterset names? If not, TEST HERE

                //insert the new counterset name into the database
				string mySelectQuery = "INSERT INTO [PerfDB2].[dbo].[t_CounterSet]( [CounterSet_Name])";
				mySelectQuery +=" VALUES ( '"+name+"')";
				SqlCommand myCommand = new SqlCommand(mySelectQuery, _EventCnt);
				myCommand.CommandType = CommandType.Text;
				myCommand.ExecuteScalar();

                //extract the ID number that the database assigned the counter set (unknown how to calculate this server side)
                mySelectQuery = "SELECT CounterSet_ID FROM dbo.t_CounterSet WHERE CounterSet_Name = '"+name+"'";
                myCommand = new SqlCommand(mySelectQuery, _EventCnt);
                myCommand.CommandType = CommandType.Text;
                
                id = (string) Convert.ToString(myCommand.ExecuteScalar());
                
			}
            catch (Exception e)
            {
                System.Diagnostics.EventLog eventLog = new System.Diagnostics.EventLog("Application");
                eventLog.Source = "PerfDAD";
                eventLog.WriteEntry("Error creating counter set " + name + " in PerfDB. \n" + e.ToString(), System.Diagnostics.EventLogEntryType.Error, (int) PerfAdmin.EventIds.PERFDAD_PERFDB_GENERIC_ERROR);
                eventLog.Close();
            }
			finally
			{
				if(_EventCnt!=null)
				{
					_EventCnt.Close();
					_EventCnt=null;
				}

			}
            
            return id;
		}

        //remakes the t_ComputerGroupMap table by writing each listitem parameter into a row
        static public void RemakeComputerToComputerGroupTable(ListItemCollection CGs)
        {
            if ((CGs == null) || (CGs.Count == 0)) return;

            SqlConnection _EventCnt = null;
            try
            {
                _EventCnt = new SqlConnection(myConnString);
                _EventCnt.Open();
                //delete the old table
                string mySelectQuery = "truncate table t_ComputerGroupMap";
                SqlCommand myCommand = new SqlCommand(mySelectQuery, _EventCnt);
                myCommand.CommandType = CommandType.Text;
                myCommand.ExecuteScalar();
                foreach (ListItem item in CGs)
                {
                    //insert the new counterset name into the database
                    mySelectQuery = "INSERT INTO [PerfDB2].[dbo].[t_ComputerGroupMap]";
                    mySelectQuery += " VALUES ( '" + item.Value + "', '"+item.Text+"')";
                    myCommand = new SqlCommand(mySelectQuery, _EventCnt);
                    myCommand.CommandType = CommandType.Text;
                    myCommand.ExecuteScalar();
                }
            }
            catch (Exception e)
            {
                System.Diagnostics.EventLog eventLog = new System.Diagnostics.EventLog("Application");
                eventLog.Source = "PerfDAD";
                eventLog.WriteEntry("Error remaking t_ComputerGroupMap in PerfDB. \n" + e.ToString(), System.Diagnostics.EventLogEntryType.Error, (int) PerfAdmin.EventIds.PERFDAD_PERFDB_GENERIC_ERROR);
                eventLog.Close();
            }

            finally
            {
                if (_EventCnt != null)
                {
                    _EventCnt.Close();
                    _EventCnt = null;
                }

            }
        }
               
        //pull the counters out of PerfDB CounterDetails table that map to Counter Set id
        public static void GetAllCounterDetailsForShip(DataTable dt, string id)
        {
           
            SqlConnection _EventCnt = null;
            try
            {
                _EventCnt = new SqlConnection(myConnString);
                _EventCnt.Open();

                string mySelectQuery = "SELECT PerfObjectName, CounterName, InstanceName, CounterType, SampleUnit, SampleFrequency, MachineName, [Enabled] FROM dbo.t_CounterDetails";
                mySelectQuery += " WHERE CounterSetID=" + id;

                SqlCommand myCommand = new SqlCommand(mySelectQuery, _EventCnt);
                myCommand.CommandType = CommandType.Text;
                SqlDataReader myReader = myCommand.ExecuteReader();

                while (myReader.Read())
                {
                    if ((bool)myReader.GetBoolean(7) == false && (string) myReader.GetString(2).Trim() != "<All>")
                    {
                        //enabled must be true. we won't ship any disabled rules.
                        continue;
                    }
                    DataRow dr = dt.NewRow();
                    //ID myReader.GetInt32(0).ToString();
                    dr[0] = (string) myReader.GetString(0).Trim(); //perfobjname
                    dr[1] = (string) myReader.GetString(1).Trim();//countername
                    dr[2] = (string) myReader.GetString(2).Trim();//instancename
                    dr[3] = (string) myReader.GetString(3).Trim();//countertype
                    dr[4] = (int) myReader.GetInt32(4); //sampleunit
                    dr[5] = (int) myReader.GetDouble(5); //samplefrequency
                    dr[6] = (string) myReader.GetString(6).Trim(); //machinename
                    dr[7] = true;
                    string RuleName = MOMInterface.ConstructRuleName((string)dr[0], (string)dr[1], (string) dr[2], (int)dr[5], (int)dr[4]);
                    if (isCounterInExistingMOMCounterRules(RuleName, id))
                    {
                        //the rule is already collecting data. make this one as false (MOM won't collect again)
                        dr[7] = false;
                    }
                    dt.Rows.Add(dr);
                }
                myReader.Close();                               
            }
            catch (Exception e)
            {
                System.Diagnostics.EventLog eventLog = new System.Diagnostics.EventLog("Application");
                eventLog.Source = "PerfDAD";
                eventLog.WriteEntry("Error reading counters for CounterSetID "+id+" from PerfDB. \n"+ e.ToString(), System.Diagnostics.EventLogEntryType.Error, (int) PerfAdmin.EventIds.PERFDAD_PERFDB_GENERIC_ERROR);
                eventLog.Close();
            }
            finally
            {
                if (_EventCnt != null)
                {
                    _EventCnt.Close();
                    _EventCnt = null;
                }

            }
        }
        //checks the t_ExistingMOMCounterRules and t_CounterSetAssignments table on the rule name
        private static bool isCounterInExistingMOMCounterRules(string RuleName, string id)
        {
            SqlConnection _EventCnt = null;
            try
            {
                _EventCnt = new SqlConnection(myConnString);
                _EventCnt.Open();
                //give me the groups that are NOT assigned to this RULE but are assigned to the ID
                                
                //string mySelectQuery = "select [MOMEnabled] from t_ExistingMOMCounterRules EMR join t_CounterSetAssignments CSA on CSA.ComputerGroupName = EMR.ComputerGroupName where RuleName = '"+RuleName+"' and CounterSetID = '"+id+"' and CSA.Enabled = 'true'";
                string mySelectQuery = "select ComputerGroupName from t_CounterSetAssignments c where c.ComputerGroupName not in (select csa.ComputerGroupName from t_CounterSetAssignments csa join t_ExistingMOMCounterRules mcr on mcr.ComputerGroupName = csa.ComputerGroupName where csa.CounterSetID = '" + id + "' and mcr.RuleName = '" + RuleName + "') and c.CounterSetId = '" + id + "' and Enabled = 'True'";
                SqlCommand myCommand = new SqlCommand(mySelectQuery, _EventCnt);
                myCommand.CommandType = CommandType.Text;
                SqlDataReader myReader = myCommand.ExecuteReader();
                if (myReader.HasRows)
                {
                    string ComputerGroupsNeeded = "";
                    while (myReader.Read())
                    {
                        ComputerGroupsNeeded += myReader.GetString(0);
                    }
                    //right now this is an all or nothing thing
                    myReader.Close();
                    return false;
                }
                else 
                {
                    myReader.Close();
                    //see if it is the one holding the whole operation together (reshipped-should still be enabled)
                    mySelectQuery = "select [MOMEnabled] from t_ExistingMOMCounterRules where CounterSetID = '" + id + "' and RuleName = '" + RuleName+"'";
                    myCommand = new SqlCommand(mySelectQuery, _EventCnt);
                    myCommand.CommandType = CommandType.Text;
                    myReader = myCommand.ExecuteReader();
                    if (myReader.HasRows)
                    {
                        myReader.Read();
                        bool enabled = myReader.GetBoolean(0);
                        if (enabled) //we want this rule to still be enabled.
                        {
                            myReader.Close();
                            return false;
                        }
                    }
                    myReader.Close();
                    return true;
                }

            } //errors caught in calling functions
            finally
            {
                if (_EventCnt != null)
                {
                    _EventCnt.Close();
                    _EventCnt = null;
                }
            }
        
        }

        //let the caller handle possible exceptions
        public static void InsertExistingMOMCounterRules(string RuleName, string ComputerGroupName, string CounterSetID, bool MOMEnabled)
        {
            SqlConnection _EventCnt = null;
            try
            {
                _EventCnt = new SqlConnection(myConnString);
                _EventCnt.Open();
                string mySelectQuery = "select [MOMEnabled] from t_ExistingMOMCounterRules where ComputerGroupName = '"+ ComputerGroupName +"' and RuleName = '"+RuleName+"' and CounterSetID = '"+CounterSetID+"'";
                SqlCommand myCommand = new SqlCommand(mySelectQuery, _EventCnt);
                myCommand.CommandType = CommandType.Text;
                SqlDataReader myReader = myCommand.ExecuteReader();
                if (myReader.HasRows)
                {
                    myReader.Read();
                    bool enabled = myReader.GetBoolean(0);
                    if (enabled != MOMEnabled) //we need to update the row here.
                    {
                        myReader.Close();
                        mySelectQuery = "update t_ExistingMOMCounterRules set [MOMEnabled] = '"+MOMEnabled+"' where ComputerGroupName = '" + ComputerGroupName + "' and RuleName = '" + RuleName + "' and CounterSetID = '" + CounterSetID + "'";
                        myCommand = new SqlCommand(mySelectQuery, _EventCnt);
                        myCommand.CommandType = CommandType.Text;
                        myCommand.ExecuteReader();
                    }
                    //don't add a duplicate rule
                    return;
                }
                myReader.Close();

                //string mySelectQuery = "select [MOMEnabled] from t_ExistingMOMCounterRules EMR join t_CounterSetAssignments CSA on CSA.ComputerGroupName = EMR.ComputerGroupName where RuleName = '"+RuleName+"' and CounterSetID = '"+id+"' and CSA.Enabled = 'true'";
                mySelectQuery = "insert into t_ExistingMOMCounterRules values('" + RuleName + "', '" + ComputerGroupName + "', '"+CounterSetID+"', '"+MOMEnabled+"')";
                myCommand = new SqlCommand(mySelectQuery, _EventCnt);
                myCommand.CommandType = CommandType.Text;
                myCommand.ExecuteReader();
                myReader.Close();
            }
            finally
            {
                if (_EventCnt != null)
                {
                    _EventCnt.Close();
                    _EventCnt = null;
                }
            }

        }

        //pull the counters out of PerfDB CounterDetails table that map to Counter Set id for purposes of displaying onscreen
        public static void GetAllCounterDetails(DataTable dt, string id)
        {
            //Datatable dt looks like:
            // Counter Name | Instance Name | Object 
            //--------------------------------------------------

            SqlConnection _EventCnt = null;
            try
            {
                _EventCnt = new SqlConnection(myConnString);
                _EventCnt.Open();

                string mySelectQuery = "SELECT CounterName, InstanceName, PerfObjectName FROM dbo.t_CounterDetails";
                mySelectQuery += " WHERE Enabled='True' and CounterSetID=" + id;
                                
                SqlCommand myCommand = new SqlCommand(mySelectQuery, _EventCnt);
                myCommand.CommandType = CommandType.Text;
                SqlDataReader myReader = myCommand.ExecuteReader();
                
                while (myReader.Read())
                {
                    DataRow dr = dt.NewRow();
                   
                    dr[0] = myReader.GetString(0).Trim();
                    dr[1] = myReader.GetString(1).Trim();
                    dr[2] = myReader.GetString(2).Trim();

                    dt.Rows.Add(dr);
                }
                myReader.Close();
            }
            finally
            {
                if (_EventCnt != null)
                {
                    _EventCnt.Close();
                    _EventCnt = null;
                }

            }
        }

        //pulls all the distinct computer group names out of t_ComputerGroupMap
        public static void GetComputerGroups(ListItemCollection computerGroups)
        {
            SqlConnection _EventCnt = null;
            try
            {
                _EventCnt = new SqlConnection(myConnString);
                _EventCnt.Open();

                string mySelectQuery = "SELECT distinct ComputerGroupName FROM dbo.t_ComputerGroupMap";

                SqlCommand myCommand = new SqlCommand(mySelectQuery, _EventCnt);
                myCommand.CommandType = CommandType.Text;
                SqlDataReader myReader = myCommand.ExecuteReader();

                while (myReader.Read())
                {
                    string CGName = myReader.GetString(0).Trim();
                    computerGroups.Add(new ListItem(CGName,CGName));
                }
                myReader.Close();
            }
            catch (Exception e)
            {
                System.Diagnostics.EventLog eventLog = new System.Diagnostics.EventLog("Application");
                eventLog.Source = "PerfDAD";
                eventLog.WriteEntry("Error reading computer groups from t_ComputerGroupMap from PerfDB. \n" + e.ToString(), System.Diagnostics.EventLogEntryType.Error, (int) PerfAdmin.EventIds.PERFDAD_PERFDB_GENERIC_ERROR);
                eventLog.Close();
            }
            finally
            {
                if (_EventCnt != null)
                {
                    _EventCnt.Close();
                    _EventCnt = null;
                }

            }
        }
        //pulls all the distinct computer group names out of t_ComputerGroupMap
        public static void GetAllComputers(ListItemCollection computerGroups)
        {
            SqlConnection _EventCnt = null;
            try
            {
                _EventCnt = new SqlConnection(myConnString);
                _EventCnt.Open();

                string mySelectQuery = "SELECT * FROM dbo.t_ComputerGroupMap";

                SqlCommand myCommand = new SqlCommand(mySelectQuery, _EventCnt);
                myCommand.CommandType = CommandType.Text;
                SqlDataReader myReader = myCommand.ExecuteReader();

                while (myReader.Read())
                {
                    string group = myReader.GetString(0).Trim();
                    string name = myReader.GetString(1).Trim();
                    computerGroups.Add(new ListItem(name, group));
                }
                myReader.Close();
            }
            catch (Exception e)
            {
                System.Diagnostics.EventLog eventLog = new System.Diagnostics.EventLog("Application");
                eventLog.Source = "PerfDAD";
                eventLog.WriteEntry("Error reading computers and computer groups from t_ComputerGroupMap from PerfDB. \n" + e.ToString(), System.Diagnostics.EventLogEntryType.Error, (int)PerfAdmin.EventIds.PERFDAD_PERFDB_GENERIC_ERROR);
                eventLog.Close();
            }
            finally
            {
                if (_EventCnt != null)
                {
                    _EventCnt.Close();
                    _EventCnt = null;
                }

            }
        }


        //sets the enabled state to false in the CounterDetails table
        public static void RemoveCounter(DataRow dt, string id)
        {
            //Datatable dt looks like:
            // Counter Name | Instance Name | Object 
            //--------------------------------------------------

            SqlConnection _EventCnt = null;
            try
            {
                _EventCnt = new SqlConnection(myConnString);
                _EventCnt.Open();

                string mySelectQuery = "UPDATE dbo.t_CounterDetails SET Enabled = 'false'";
                mySelectQuery += " WHERE CounterSetID=" + id + " and CounterName = '"+dt[0]+"' and InstanceName = '"+dt[1]+"' and PerfObjectName = '"+dt[2]+"'";

                SqlCommand myCommand = new SqlCommand(mySelectQuery, _EventCnt);
                myCommand.CommandType = CommandType.Text;
                myCommand.ExecuteReader();

                
            }
            catch (Exception e)
            {
                System.Diagnostics.EventLog eventLog = new System.Diagnostics.EventLog("Application");
                eventLog.Source = "PerfDAD";
                eventLog.WriteEntry("Error removing a counter for CounterSetID " + id + " from PerfDB. \n" + e.ToString(), System.Diagnostics.EventLogEntryType.Error, (int) PerfAdmin.EventIds.PERFDAD_PERFDB_GENERIC_ERROR);
                eventLog.Close();
            }
            finally
            {
                if (_EventCnt != null)
                {
                    _EventCnt.Close();
                    _EventCnt = null;
                }

            }
        }

        //changes the state of the Set Assignment to disabled in PerfDB CounterSetAssignments table
        public static void DeleteCounterSetAssignments(string CounterSetID, string ComputerGroup)
        {
            SqlConnection _EventCnt = null;
            try
            {
                //open a connection to the database specified in the database variable
                _EventCnt = new SqlConnection(myConnString);
                _EventCnt.Open();
                
                //determine if this counterset already is assigned to this computergroup
                string mySelectQuery = "update [PerfDB2].[dbo].[t_CounterSetAssignments] set Enabled = '0' where CounterSetID = '" + CounterSetID + "' and ComputerGroupName ='" + ComputerGroup + "'";
                SqlCommand myCommand = new SqlCommand(mySelectQuery, _EventCnt);
                myCommand.CommandType = CommandType.Text;
                myCommand.ExecuteReader();
               
            }
            catch (Exception e)
            {
                System.Diagnostics.EventLog eventLog = new System.Diagnostics.EventLog("Application");
                eventLog.Source = "PerfDAD";
                eventLog.WriteEntry("Error removing counter set assignment for CounterSetID " + CounterSetID + " and Computer group " + ComputerGroup + " from PerfDB. \n" + e.ToString(), System.Diagnostics.EventLogEntryType.Error, (int)PerfAdmin.EventIds.PERFDAD_PERFDB_GENERIC_ERROR);
                eventLog.Close();
            }
            finally
            {
                if (_EventCnt != null)
                {
                    _EventCnt.Close();
                    _EventCnt = null;
                }

            }
            
        }

        public static void InsertCounterIntoSet(string CounterSetID, System.Diagnostics.PerformanceCounter counter)
        {
            SqlConnection _EventCnt = null;
            Boolean enabledToSet = true;
            if (counter.InstanceName.Equals("<All>"))
            {
                //we don't want to show this counter listing to the user.
                enabledToSet = false;
            }
            try
            {
                _EventCnt = new SqlConnection(myConnString);
                _EventCnt.Open();

                //determine if this counter already is assigned to this counterset
                string mySelectQuery = "SELECT Enabled from [PerfDB2].[dbo].[t_CounterDetails] where CounterSetID = '" + CounterSetID + "' and PerfObjectName ='" + counter.CategoryName + "' and CounterName = '" + counter.CounterName + "' and InstanceName ='" + counter.InstanceName + "' and CounterType ='" + counter.CounterType + "'";
                SqlCommand myCommand = new SqlCommand(mySelectQuery, _EventCnt);
                myCommand.CommandType = CommandType.Text;
                SqlDataReader myReader = myCommand.ExecuteReader();
                if (myReader.HasRows == false)
                {
                    //the counter does not exist in the table, so add it!
                    myReader.Close();
                    mySelectQuery = "INSERT INTO [PerfDB2].[dbo].[t_CounterDetails]( [CounterSetID],[PerfObjectName],[CounterName],[InstanceName],[CounterType],[MachineName],[SampleUnit],[SampleFrequency],[Enabled] )";
                    mySelectQuery += " VALUES ( '" + CounterSetID + "', '" + counter.CategoryName + "', '" + counter.CounterName + "', '" + counter.InstanceName + "', '" + counter.CounterType + "', '" + counter.MachineName + "', 1, 15, " + (enabledToSet ? "1" : "0") + ")";
                    myCommand = new SqlCommand(mySelectQuery, _EventCnt);
                    myCommand.CommandType = CommandType.Text;
                    myCommand.ExecuteScalar();
                }
                else if (enabledToSet)
                {
                    myReader.Read();
                    Boolean enabled = myReader.GetBoolean(0);
                    if (enabled == false)
                    {
                        myReader.Close();

                        mySelectQuery = "update [PerfDB2].[dbo].[t_CounterDetails] set Enabled = '" + (enabledToSet ? "1'" : "0'") + " where CounterSetID = '" + CounterSetID + "' and PerfObjectName ='" + counter.CategoryName + "' and CounterName = '" + counter.CounterName + "' and InstanceName ='" + counter.InstanceName + "' and CounterType ='" + counter.CounterType + "'";
                        myCommand = new SqlCommand(mySelectQuery, _EventCnt);
                        myCommand.CommandType = CommandType.Text;
                        myCommand.ExecuteReader();
                    }
                }
                myReader.Close();

            }
            catch (Exception e)
            {
                System.Diagnostics.EventLog eventLog = new System.Diagnostics.EventLog("Application");
                eventLog.Source = "PerfDAD";
                eventLog.WriteEntry("Error inserting a counter into counter set " + CounterSetID + " from PerfDB. \n" + e.ToString(), System.Diagnostics.EventLogEntryType.Error, (int) PerfAdmin.EventIds.PERFDAD_PERFDB_GENERIC_ERROR);
                eventLog.Close();
            }
            finally
            {
                if (_EventCnt != null)
                {
                    _EventCnt.Close();
                    _EventCnt = null;
                }
            }
        }






        /*
        //NOT USED
        
        
        //pulls counter data out of CounterTemp to create a row in CounterDetails with all counter info and mapping to CounterSet
        
        public static void InsertCounterIntoSet(string CounterSetID, string PerfObjectName, string CounterName, string CounterID, string InstanceName)
        {
            SqlConnection _EventCnt = null;
            Boolean enabledToSet = true;
            if (InstanceName.Equals("<All>"))
            {
                //we don't want to show this counter listing to the user.
                enabledToSet = false;
               
            }
            try
            {
                _EventCnt = new SqlConnection(myConnString);
                _EventCnt.Open();
             
                string CounterType = "";
                string MachineName = "";
                string mySelectQuery = "SELECT CounterType, MachineName FROM dbo.t_CounterTemp where CounterID = " + CounterID;
                SqlCommand myCommand = new SqlCommand(mySelectQuery, _EventCnt);
                myCommand.CommandType = CommandType.Text;
                SqlDataReader myReader = myCommand.ExecuteReader();
                while (myReader.Read()) //should only be one
                {
                    CounterType = myReader.GetString(0).Trim();
                    MachineName = myReader.GetString(1).Trim();
                }
                myReader.Close();

                //determine if this counterset already is assigned to this computergroup
                mySelectQuery = "SELECT Enabled from [PerfDB2].[dbo].[t_CounterDetails] where CounterSetID = '" + CounterSetID + "' and PerfObjectName ='" + PerfObjectName + "' and CounterName = '" + CounterName + "' and InstanceName ='" + InstanceName + "' and CounterType ='" + CounterType + "'";
                myCommand = new SqlCommand(mySelectQuery, _EventCnt);
                myCommand.CommandType = CommandType.Text;
                myReader = myCommand.ExecuteReader();
                if (myReader.HasRows == false)
                {
                    //There is NO counterset assignment, so make one! 
                    myReader.Close();
                    mySelectQuery = "INSERT INTO [PerfDB2].[dbo].[t_CounterDetails]( [CounterSetID],[PerfObjectName],[CounterName],[InstanceName],[CounterType],[MachineName],[SampleUnit],[SampleFrequency],[Enabled] )";
                    mySelectQuery += " VALUES ( '" + CounterSetID + "', '" + PerfObjectName + "', '" + CounterName + "', '" + InstanceName + "', '" + CounterType + "', '" + MachineName + "', 1, 15, " + (enabledToSet? "1":"0") + ")";
                    myCommand = new SqlCommand(mySelectQuery, _EventCnt);
                    myCommand.CommandType = CommandType.Text;
                    myCommand.ExecuteScalar();
                }
                else if (enabledToSet)
                {
                    myReader.Read();
                    Boolean enabled = myReader.GetBoolean(0);
                    if (enabled == false)
                    {
                        myReader.Close();

                        mySelectQuery = "update [PerfDB2].[dbo].[t_CounterDetails] set Enabled = '" + (enabledToSet ? "1'" : "0'") + " where CounterSetID = '" + CounterSetID + "' and PerfObjectName ='" + PerfObjectName + "' and CounterName = '" + CounterName + "' and InstanceName ='" + InstanceName + "' and CounterType ='" + CounterType + "'";
                        myCommand = new SqlCommand(mySelectQuery, _EventCnt);
                        myCommand.CommandType = CommandType.Text;
                        myCommand.ExecuteReader();
                    }
                }
                myReader.Close();

            }
            catch (Exception e)
            {
                System.Diagnostics.EventLog eventLog = new System.Diagnostics.EventLog("Application");
                eventLog.Source = "PerfDAD";
                eventLog.WriteEntry("Error inserting a counter into counter set "+CounterSetID +" from PerfDB. \n" + e.ToString(), System.Diagnostics.EventLogEntryType.Error, (int) PerfAdmin.EventIds.PERFDAD_PERFDB_GENERIC_ERROR);
                eventLog.Close();
            }
            finally
            {
                if (_EventCnt != null)
                {
                    _EventCnt.Close();
                    _EventCnt = null;
                }

            }
        }
         //deletes all the rows in the CounterTemp table
        
        public static void ClearCounterTemp()
        {
            SqlConnection _EventCnt = null;
            try
            {
                _EventCnt = new SqlConnection(myConnString);
                _EventCnt.Open();

                //insert the new counter into the database
                string mySelectQuery = "DELETE from t_CounterTemp";
                SqlCommand myCommand = new SqlCommand(mySelectQuery, _EventCnt);
                myCommand.CommandType = CommandType.Text;
                myCommand.ExecuteScalar();

            }
            finally
            {
                if (_EventCnt != null)
                {
                    _EventCnt.Close();
                    _EventCnt = null;
                }

            }
        }

        //inserts data about a counter into CounterTemp table
        
        public static void InsertCounterTemp(string CounterID, string categoryName, string CounterName, string InstanceName, string CounterType, string MachineName)
        {
            
            SqlConnection _EventCnt = null;
            try
            {
                _EventCnt = new SqlConnection(myConnString);
                _EventCnt.Open();

                //insert the new counter into the database
                string mySelectQuery = "INSERT INTO [PerfDB2].[dbo].[t_CounterTemp]( [CounterID],[PerfObjectName],[CounterName],[InstanceName],[CounterType],[MachineName] )";
                mySelectQuery += " VALUES ( '" + CounterID + "', '" + categoryName + "', '" + CounterName + "', '" + InstanceName + "', '" + CounterType + "', '"+MachineName+"')";
                SqlCommand myCommand = new SqlCommand(mySelectQuery, _EventCnt);
                myCommand.CommandType = CommandType.Text;
                myCommand.ExecuteScalar();

            }
            finally
            {
                if (_EventCnt != null)
                {
                    _EventCnt.Close();
                    _EventCnt = null;
                }

            }
                        
        }
        public static void GetOneCounterDetails(DataRow dr, string id)
        {
            SqlConnection _EventCnt = null;
            try
            {
                string mySelectQuery = "SELECT * FROM [PerfDB2].[dbo].[RealCounters] WHERE CounterID =" + id;


                _EventCnt = new SqlConnection(myConnString);
                _EventCnt.Open();


                SqlCommand myCommand = new SqlCommand(mySelectQuery, _EventCnt);
                myCommand.CommandType = CommandType.Text;
                SqlDataReader myReader = myCommand.ExecuteReader();
                while (myReader.Read())
                {
                    //returned table format:
                    //counterID, perfobjname, countername, instancename
                    dr[0] = myReader.GetString(2);
                    dr[1] = myReader.GetString(3);
                    dr[2] = myReader.GetString(1);
                    //dr[3] = myReader.GetString(5);        
                }
                myReader.Close();

            }
            finally
            {
                if (_EventCnt != null)
                {
                    _EventCnt.Close();
                    _EventCnt = null;
                }

            }

        }

        

        //NOT USED 
        static public Hashtable GetCounterSetList(ListItemCollection items)
        {
            Hashtable hash = new Hashtable();
            items.Clear();
            SqlConnection _EventCnt = null;
            try
            {

                string mySelectQuery = "SELECT cs.Counter_Set_ID, cs.Counter_Set_Name, st.Server_Type_Name FROM [CounterSet] cs";
                mySelectQuery += " inner join Server_Type st on cs.Default_Server_Type=st.Server_Type_ID";


                _EventCnt = new SqlConnection(myConnString);
                _EventCnt.Open();


                SqlCommand myCommand = new SqlCommand(mySelectQuery, _EventCnt);
                myCommand.CommandType = CommandType.Text;
                SqlDataReader myReader = myCommand.ExecuteReader();
                while (myReader.Read())
                {
                    int id = myReader.GetInt32(0);
                    string name = myReader.GetString(1);
                    ListItem item = new ListItem(name.Trim(), id.ToString());
                    items.Add(item);
                    hash.Add(item.Value, myReader.GetString(2).Trim());
                }
                myReader.Close();

            }
            finally
            {
                if (_EventCnt != null)
                {
                    _EventCnt.Close();
                    _EventCnt = null;
                }

            }
            return hash;
        }

        //NOT USED - pankajn code
        static public void GetServerTypeList(ListItemCollection items)
        {


            items.Clear();
            SqlConnection _EventCnt = null;
            try
            {
                string mySelectQuery = "SELECT [Server_Type_Name],[Default_Machine] FROM [PerfDB2].[dbo].[Server_Type]";


                _EventCnt = new SqlConnection(myConnString);
                _EventCnt.Open();


                SqlCommand myCommand = new SqlCommand(mySelectQuery, _EventCnt);
                myCommand.CommandType = CommandType.Text;
                SqlDataReader myReader = myCommand.ExecuteReader();
                while (myReader.Read())
                {
                    string sname = myReader.GetString(0);
                    string mname = myReader.GetString(1);
                    ListItem item = new ListItem(sname.Trim(), mname.Trim());
                    items.Add(item);

                }
                myReader.Close();

            }
            finally
            {
                if (_EventCnt != null)
                {
                    _EventCnt.Close();
                    _EventCnt = null;
                }

            }

        }

        //NOT USED
        static public void UpdateServerType(string CounterSetid, string Servertype)
        {
            SqlConnection _EventCnt = null;
            try
            {
                string mySelectQuery = "UPDATE [PerfDB2].[dbo].[CounterSet]";
                mySelectQuery += " SET [Default_Server_Type]=";
                mySelectQuery += " ( Select Server_Type_ID from Server_Type where Server_Type_Name ='" + Servertype + "' ) ";
                mySelectQuery += " WHERE Counter_Set_ID=" + CounterSetid;


                _EventCnt = new SqlConnection(myConnString);
                _EventCnt.Open();


                SqlCommand myCommand = new SqlCommand(mySelectQuery, _EventCnt);
                myCommand.CommandType = CommandType.Text;
                myCommand.ExecuteScalar();

            }
            finally
            {
                if (_EventCnt != null)
                {
                    _EventCnt.Close();
                    _EventCnt = null;
                }

            }
        }

        //NOT USED
        //pull the counters out of PerfDB that map to Counter Set ID id
        public static void GetCountersFromCounterSet(ListItemCollection counters, string id)
        {
            //counters.Text = <counter name>
            //counters.Value = <counter ID>

            SqlConnection _EventCnt = null;
            try
            {
                int[] CounterID = new int[100]; //HACK!
                _EventCnt = new SqlConnection(myConnString);
                _EventCnt.Open();

                string mySelectQuery = "SELECT RealCounterID FROM dbo.CounterInCSet";
                mySelectQuery += " WHERE CounterSetID=" + id;

                //CAN BE UBER SIMPLIFIED BY A JOIN??
                SqlCommand myCommand = new SqlCommand(mySelectQuery, _EventCnt);
                myCommand.CommandType = CommandType.Text;
                SqlDataReader myReader = myCommand.ExecuteReader();
                int i = 0;
                while (myReader.Read() && i < 99) //OTHER PART OF HACK!
                {
                    CounterID[i] = myReader.GetInt32(0);
                    i++;
                }
                myReader.Close();

                if (i > 0)
                {
                    for (int j = 0; j < i; j++)
                    {
                        mySelectQuery = "SELECT CounterName, CounterID FROM dbo.RealCounters where CounterID = " + CounterID[j];
                        myCommand = new SqlCommand(mySelectQuery, _EventCnt);
                        myCommand.CommandType = CommandType.Text;
                        myReader = myCommand.ExecuteReader();
                        while (myReader.Read())
                        {
                            ListItem temp = new ListItem(myReader.GetString(0), myReader.GetInt32(1).ToString());
                            counters.Add(temp);
                        }
                        myReader.Close();
                    }
                }



            }
            finally
            {
                if (_EventCnt != null)
                {
                    _EventCnt.Close();
                    _EventCnt = null;
                }

            }
        }
        */
      
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\LiveTest\PerfAdmin\PerfDAD\App_Code\PerfCounter.cs ===
using System;
using System.Collections;
using System.Diagnostics;
using System.Web.UI.WebControls;
using System.ComponentModel;
using System.Management;
using System.Text.RegularExpressions;


namespace PerfAdmin
{
	/// <summary>
	/// Summary description for PerfCounter.
	/// </summary>
	public class XBlPerfCounters
	{
		public XBlPerfCounters()
		{
			//
			// TODO: Add constructor logic here
			//
		}

		
		public static void GetCategories( string machinename, ListItemCollection CategoryList)
		{
            PerformanceCounterCategory[] categories = null;//new PerformanceCounterCategory[];
            //categories = new PerformanceCounterCategory();
            try
            {
                categories = PerformanceCounterCategory.GetCategories(machinename);

                CategoryList.Clear();
                foreach (PerformanceCounterCategory category in categories)
                {
                    ListItem item = new ListItem(category.CategoryName);
                    CategoryList.Add(item);
                }
                PerfDB.SortListItemCollection(CategoryList);
            }
            catch (Exception e)
            {

            }
			
		}

		public static int GetCounters(string machinename, string categoryName,string[] Instances, ListItemCollection ItemList, out PerformanceCounter[] counters)
		{
            //clear the out parameters
            counters = null;
            ItemList.Clear();

            PerformanceCounterCategory category = new PerformanceCounterCategory(categoryName);
            category.MachineName = machinename;
            //fix the null instance issue
            if (Instances.Length == 0)
            {
                Instances = new string[1];
                Instances[0] = "";
            }
            if (Instances[0].StartsWith("Error connecting"))
            {
                //counters will be null
                ItemList.Add(new ListItem("No counters exist", "-1"));
                return -1;
            }
            //we're going to store the counters for just one instance in the session variable, since we store the instance names in the instance list in counterset.cs
            //PerfDB.ClearCounterTemp();
            
            //we're going to alphabetize the counter names, so we need to store their original indexes
            int originalIndex = 0;
			foreach(string Instance in Instances)
		    {
                //find just one instance that exists.
				if(Instance.Equals("") || category.InstanceExists(Instance))
				{
					counters = category.GetCounters(Instance);
					foreach(PerformanceCounter Counter in counters)
					{
                        //PerfDB.InsertCounterTemp(ID.ToString(),categoryName,Counter.CounterName, Counter.InstanceName, Counter.CounterType.ToString(), machinename); 
						//ListItem item = new ListItem(Counter.CounterName,ID.ToString());
                        ListItem item = new ListItem(Counter.CounterName, originalIndex.ToString());
                        ItemList.Add(item);
                        originalIndex++;
					}
					break;                    
				}
			}
            
            if (counters == null || counters.Length == 0 || originalIndex == 0)
            {
                ItemList.Add(new ListItem("No counters exist", "-1"));
                return -1;

            }
            
            return 0;
			
		}

		public static string[] GetInstances(string machinename, string categoryName, ListItemCollection ItemList)
		{
			PerformanceCounterCategory category = new PerformanceCounterCategory(categoryName);
			 category.MachineName = machinename;
             string[] Instances = null;
             try
             {
                 ItemList.Clear();
                 Hashtable w3wpMap = null;
                 Instances = category.GetInstanceNames();
                 foreach (string Instance in Instances)
                 {
                     //determine if it is a "w3wp" instance name 
                     string DisplayName = Instance;
                     if (Instance.ToLower().Contains("w3wp"))
                     {
                         if (w3wpMap == null)
                         {
                             //time to create the mappings!
                             w3wpMap = new Hashtable();
                             CreateW3WPMappings(machinename, categoryName, w3wpMap);
                         }
                         
                         DisplayName = "w3wp "+(string) w3wpMap[Instance];
                     }
                     ListItem item = new ListItem(DisplayName, Instance);
                     ItemList.Add(item);
                 }
             }
            catch(Exception e)
            {
                Instances = new string[1];
                Instances[0] = "Error connecting to machine";
            }
            return Instances;
		}

        private static void CreateW3WPMappings(string machineName, string categoryName, Hashtable w3wpMap)
        {
            Hashtable processMap = new Hashtable(); //PID will map to a listitem of (AppPoolID, InstanceName)
            // The connection credentials - not needed if the logged in account has access
            ConnectionOptions oConnectionOptions = new ConnectionOptions();
            oConnectionOptions.Impersonation = ImpersonationLevel.Impersonate;

            // The scope
            string wmiScope = string.Format("\\\\{0}\\root\\cimv2", machineName);
            ManagementScope oScope = new ManagementScope(wmiScope, oConnectionOptions);

            // The query
            string[] SelectProperties = { "Name", "ProcessID", "CommandLine" };
            SelectQuery oQuery = new SelectQuery("Win32_Process", "Name=\"w3wp.exe\"", SelectProperties);

            // Run the query within the scope
            ManagementObjectSearcher oSearcher = new ManagementObjectSearcher(oScope, oQuery);

            try
            {
                foreach (ManagementObject oReturn in oSearcher.Get())
                {
                    string AppPoolID = ExtractAppPoolID(oReturn["CommandLine"].ToString());
                    int PID = int.Parse(oReturn["ProcessId"].ToString());
                    ListItem mapping = new ListItem(AppPoolID,PID.ToString());
                    processMap[PID] = mapping;
                }
            }
            catch (System.Runtime.InteropServices.COMException COMException)
            {
                string ErrorMsg = string.Format("Exception thrown\nCOM Error:\n{1}", COMException.ToString());
                //LogError(ErrorMsg);
                //throw (new LoggedException(COMException));
                return;
            }
            catch (System.Management.ManagementException WMIException)
            {
                string ErrorMsg = string.Format("Exception thrown\nWMI Error:\n{1}", WMIException.ToString());
                //LogError(ErrorMsg);
                //throw (new LoggedException(WMIException));
                return;
            }
            //processMap now holds PID to AppPoolID mapping. 

            //assign the counter name we're looking for depending on the categoryname
            string counterName = "ID Process";
            if (categoryName.Equals(".NET CLR Memory"))
            {
                counterName = "Process ID";
            }

            PerformanceCounterCategory PerfCat = new PerformanceCounterCategory(categoryName, machineName);

            // NOTE: This is an extremely expensive call
            string[] InstanceNames = PerfCat.GetInstanceNames();

            foreach (string InstanceName in InstanceNames)
            {
                if (InstanceName.StartsWith("w3wp"))
                {
                    // Win32 perf instance name
                    PerformanceCounter PC = new PerformanceCounter(categoryName, counterName, InstanceName, machineName);
                    int PID = int.Parse(PC.NextValue().ToString());
                    if (processMap.Contains(PID))
                    {
                        ListItem prevMapping = (ListItem) processMap[PID];
                        prevMapping.Value = InstanceName;
                        processMap[PID] = prevMapping;
                        w3wpMap[InstanceName] = prevMapping.Text;
                    }
                }
            }
            //now the processMap has PID to AppPoolID, InstanceName mapping
            //w3wpMap has InstanceNAme to AppPoolID
        }

        private static string ExtractAppPoolID(string commandLine)
        {
            // We're assuming app pool names consist of alphanumerics and dashes
            Regex r = new Regex("-ap \"(?<name>[^\"]*)\"", RegexOptions.IgnoreCase | RegexOptions.Compiled);
            Match m = r.Match(commandLine);
            if (!m.Success)
            {
                //LogError("ExtractAppPoolID failed: commandLine = " + commandLine);
                return ("");
            }
            return m.Result("${name}");
        }
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\LiveTest\PerfAdmin\PerfDAD\App_Code\MOMInterface.cs ===
using System;
using System.Xml;
using System.Data;
using System.Configuration;
using System.Web;
using System.Web.Security;
using System.Web.UI;
using System.Web.UI.WebControls;
using System.Web.UI.WebControls.WebParts;
using System.Web.UI.HtmlControls;
using System.Data.SqlClient;

using MOMMPSupportLib;


/// <summary>
/// Summary description for MOMInterface
/// </summary>
public class MOMInterface
{
    private static string _strMOMServerName = "fxevntsql001";
    private static string _strMOMDBName = "fxevntsql001";
    private static string _strTopRuleGroupName = "PerfDAD Performance Collection";
    private static MOMMPSupportLib.DBStorage _objMOMDB = new MOMMPSupportLib.DBStorage();
    private static string myConnString = "";
    private static string _ComputerGroupPrefix = "PerfDAD";
    static public void InitSettings(string pathToXMLfolder)
    {
        //find out the connection string for perfdb
        try
        {
            /*XmlDocument MOMXml = new XmlDocument();
            pathToXMLfolder += "MOMInterface.xml";
            MOMXml.Load(pathToXMLfolder);
            XmlNode momInterface = MOMXml.SelectSingleNode("descendant::MOMInterface");
            XmlNode OnePoint = momInterface.SelectSingleNode("descendant::OnePoint");
            _strMOMDBName = OnePoint.SelectSingleNode("DBServerName").InnerText;
            myConnString = OnePoint.SelectSingleNode("ConnectionString").InnerText;
            XmlNode dcam = momInterface.SelectSingleNode("descendant::DCAM");
            _strMOMServerName = dcam.SelectSingleNode("DBServerName").InnerText;

            _ComputerGroupPrefix = momInterface.SelectSingleNode("ComputerGroupPrefix").InnerText;*/

            if (ConfigurationManager.ConnectionStrings["OnePoint"] == null)
                    throw new Exception("No connection string found for OnePoint. Please add a connection string to web.config with name=OnePoint");
            
            myConnString = ConfigurationManager.ConnectionStrings["OnePoint"].ToString();
            _strMOMDBName = ConfigurationManager.AppSettings["OnePointServerName"];
            _strMOMServerName = ConfigurationManager.AppSettings["DCAMServerName"];
            _ComputerGroupPrefix = ConfigurationManager.AppSettings["ComputerGroupPrefix"];

            if (_strMOMServerName == "")
                    throw new Exception("No server name found for MOM DCAM. Please edit the web.config file to include this code with the correct MOMServerName: <add key=\"DCAMServerName\" value=\"MOMServerName\" />");

            if (_strMOMDBName == "")
                    throw new Exception("No OnePoint server name found. Please edit the web.config file to include the correct location of the OnePoint database: <add key=\"OnePointServerName\" value=\"OnePointServerName\" />");

                
        }
        catch (Exception e)
        {
            System.Diagnostics.EventLog eventLog = new System.Diagnostics.EventLog("Application");
            eventLog.Source = "PerfDAD";
            eventLog.WriteEntry("Error loading settings from web.config.\n" + e.ToString(), System.Diagnostics.EventLogEntryType.Error, (int)PerfAdmin.EventIds.PERFDAD_MOM_XML_ERROR);
            eventLog.Close();

            //reverting to defaults:
            _strMOMDBName = "fxevntsql001";
            _strMOMServerName = "fxevntsql001";
            myConnString = "Data Source=fxevntsql001;Initial Catalog=onepoint;persist security info=False;integrated security=SSPI";
        }

    }
    //**** used for shipping counter sets to MOM *****
    public static Object LoadMOMMP(string GroupName)
    {//PerfDAD - CounterSetID 26
        try
        {
            MOMMPSupportLib.ManagementPack objMP = new ManagementPackClass();
            objMP = _objMOMDB.LoadRuleGroup(_strMOMServerName, GroupName);
            objMP = _objMOMDB.Load(_strMOMServerName, objMP);
            return objMP;
        }
        catch (Exception e)
        {
            //error connecting to MOM server
            System.Diagnostics.EventLog eventLog = new System.Diagnostics.EventLog("Application");
            eventLog.Source = "PerfDAD";
            eventLog.WriteEntry("Error loading MOM Management Pack from " + _strMOMServerName + "\n" + e.ToString(), System.Diagnostics.EventLogEntryType.Error, (int)PerfAdmin.EventIds.PERFDAD_MOM_CONNECTION);
            eventLog.Close();
        }
        return null;
    }
    public static void SaveMOMMP(Object objMP)
    {
        //save the new additions to the MOM server
        try
        {
            _objMOMDB.Save(_strMOMServerName, (ManagementPack)objMP);

        }
        catch (Exception e)
        {
            //error connecting to MOM server
            System.Diagnostics.EventLog eventLog = new System.Diagnostics.EventLog("Application");
            eventLog.Source = "PerfDAD";
            eventLog.WriteEntry("Error saving MOM Management Pack to " + _strMOMServerName + "\n" + e.ToString(), System.Diagnostics.EventLogEntryType.Error, (int)PerfAdmin.EventIds.PERFDAD_MOM_GENERIC_ERROR);
            eventLog.Close();
        }
    }

    public static string ConstructRuleName(string strObjectName, string strCounterName, string strInstanceName, int intSampleFrequency, int intSampleUnits)
    {
        string name = "PerfDAD - " + strObjectName + "-" + strCounterName + "-" + strInstanceName + "-" + intSampleFrequency + "-" + intSampleUnits.ToString();
        return name;
    }
    public static string GetMOMServerName()
    {
        return _strMOMServerName;
    }

	public static string AssignRuleGroupToComputerGroup(Object MP, string CounterSetID, string ComputerGroupName)
    {
        if (MP == null)
        {
            return "Error connecting to MOM Server " + _strMOMServerName;
        }
        ManagementPack objMP = (ManagementPack)MP;
        
        string RuleSubGroupName = "PerfDAD - CounterSetID " + CounterSetID;
        IMOMRuleGroup objCounterSetGroup = GetRuleGroup(objMP, RuleSubGroupName, false);
        if (objCounterSetGroup == null)
        {
            System.Diagnostics.EventLog eventLog = new System.Diagnostics.EventLog("Application");
            eventLog.Source = "PerfDAD";
            eventLog.WriteEntry("When shipping Counter Set ID " + CounterSetID + ", error finding/creating top rule group " + RuleSubGroupName, System.Diagnostics.EventLogEntryType.Warning, (int)PerfAdmin.EventIds.PERFDAD_MOM_COMPUTER_GROUP_ASSIGNMENT_ERROR);
            eventLog.Close();
            return "Error finding/creating top rule group " + RuleSubGroupName;
        }
       
        //Find the computer group
        MOMMPSupportLib.ManagementPack objTempMP = _objMOMDB.LoadComputerRule(_strMOMServerName, "");

        IMOMComputerRule objComputerGroup = GetComputerGroup(objTempMP, ComputerGroupName);
        if (objComputerGroup == null)
        {
            System.Diagnostics.EventLog eventLog = new System.Diagnostics.EventLog("Application");
            eventLog.Source = "PerfDAD";
            eventLog.WriteEntry("When shipping Counter Set ID "+CounterSetID+", error finding computer group " + ComputerGroupName, System.Diagnostics.EventLogEntryType.Warning, (int)PerfAdmin.EventIds.PERFDAD_MOM_COMPUTER_GROUP_ASSIGNMENT_ERROR);
            eventLog.Close();

            return "Error finding computer group " + ComputerGroupName;
        }

        //now link them, if not already linked
        foreach (IMOMComputerRule assignedCG in objCounterSetGroup.ComputerRules)
        {
            if (assignedCG.Name == ComputerGroupName)
            {
                return "Counter set " + CounterSetID +" already assigned to " + ComputerGroupName;
            }
        }
        objCounterSetGroup.ComputerRules.Add(objComputerGroup);

        return "Done!";
    }

    public static string AddCounterRuleToMOM(Object MP, string CounterSetID, string ComputerName, string strObjectName, string strCounterName, string strInstanceName, string strCounterType, int intSampleUnits, int intSampleFrequency, bool MOMEnabled)
    {
        if (MP == null)
        {
            return "Error connecting to MOM Server " + _strMOMServerName;
        }
        ManagementPack objMP = (ManagementPack)MP;
        //get the MOM flavor of the Counter Type
        eCounterType objCounterType;
        int iCounterType = ConvertStringToECounterType(strCounterType);
        //check to make sure it's not a number already        
        if(iCounterType == -1 && !Int32.TryParse(strCounterType, out iCounterType)) 
        {
            Object tempObj = CovertStringToECounterType64(strCounterType);
            if (tempObj == null)
            {
                System.Diagnostics.EventLog eventLog = new System.Diagnostics.EventLog("Application");
                eventLog.Source = "PerfDAD";
                eventLog.WriteEntry("When shipping Counter Set ID " + CounterSetID + ", error Counter Type " + strCounterType + " is not supported.", System.Diagnostics.EventLogEntryType.Warning, (int)PerfAdmin.EventIds.PERFDAD_MOM_RULE_CREATION_ERROR);
                eventLog.Close();
                return "Error, Counter Type " + strCounterType + " is not supported";
            }
            objCounterType = (eCounterType)tempObj;
        }
        else
        {
            objCounterType = (eCounterType)iCounterType;
        }

        eSampleUnit objSampleUnits = (eSampleUnit)intSampleUnits;
        
        string RuleSubGroupName = "PerfDAD - CounterSetID " + CounterSetID;
        string RuleName = ConstructRuleName(strObjectName, strCounterName, strInstanceName, intSampleFrequency, intSampleUnits);
        string ProviderName = RuleName; //provider name is the same as the rule name
        IMOMRuleGroup objCounterSetGroup = GetRuleGroup(objMP, RuleSubGroupName, true);
        if (objCounterSetGroup == null)
        {
            System.Diagnostics.EventLog eventLog = new System.Diagnostics.EventLog("Application");
            eventLog.Source = "PerfDAD";
            eventLog.WriteEntry("When shipping Counter Set ID " + CounterSetID + ", error finding/creating top rule group " + _strTopRuleGroupName + ".", System.Diagnostics.EventLogEntryType.Warning, (int)PerfAdmin.EventIds.PERFDAD_MOM_RULE_CREATION_ERROR);
            eventLog.Close();
            return "Error finding/creating top rule group " + _strTopRuleGroupName;
        }
    
        //determine if a rule for this already exists
        IMOMProcRule existingRule = DoesRuleExist(objCounterSetGroup, RuleName);
        if (existingRule != null)
        {
            if (existingRule.IsEnabled != MOMEnabled)
            {
                existingRule.IsEnabled = MOMEnabled;
                return "Done changing existing "+RuleName+" IsEnabled to "+MOMEnabled;
            }
            return "Rule "+RuleName+" already exists";
        }
        //find the provider first
        IMOMProvider Provider = FindPerfProvider(ProviderName);
        if (Provider == null)
        {
            if (strInstanceName.Equals("<All>"))
            {
                //look for an instance name to use
                /*IMOMRuleGroup objGroupInstanceRef = GetRuleGroup(objMP, "PerfDAD W3WP Instance Caching/Mapping Response Rule", false);
                if (objGroupInstanceRef != null)
                {
                    //find the rule
                    IMOMNTPerformanceProvider objProvider = (IMOMNTPerformanceProvider)GetProviderAssociatedWithRule(objGroupInstanceRef, "PerfDAD W3WP Instance Caching/Mapping Rule");
                    strInstanceName = objProvider.InstanceName;
                }*/
                //unfortunately the instance in MOM is 'null'
                strInstanceName = null;

            }
            //we couldn't find the provider, so we need to create one!
            Provider = CreatePerfProvider(objMP, ProviderName, ComputerName, strObjectName, strCounterName, strInstanceName, objCounterType, objSampleUnits, intSampleFrequency);
        }
    
        //create the new rule!
        bool createResponse = false;
        if (strObjectName.Equals("Process") || strObjectName.Equals(".NET CLR Memory")) //we're currently collecting "all" instances, so checking for the object should be fine.
            createResponse = true;
        IMOMProcRule objNewRule = CreatePerfRule(RuleName, objCounterSetGroup, Provider, createResponse);
        if (objNewRule == null)
        {
            System.Diagnostics.EventLog eventLog = new System.Diagnostics.EventLog("Application");
            eventLog.Source = "PerfDAD";
            eventLog.WriteEntry("When shipping Counter Set ID " + CounterSetID + ", error creating performance rule " + RuleName + ".", System.Diagnostics.EventLogEntryType.Warning, (int)PerfAdmin.EventIds.PERFDAD_MOM_RULE_CREATION_ERROR);
            eventLog.Close();
            return "Error creating performance rule " + RuleName;
        }
        objNewRule.IsEnabled = MOMEnabled;
        
        return "Done!";
    }
    

    //**** used by compgroupadmin only *****
    //given a computer group name, stores list of assigned computers in AssignedComputers
    public static void GetAssignedComputers(string ComputerGroupName, ListItemCollection AssignedComputers)
    {
        ListItemCollection CGs = new ListItemCollection();
        GetComputerGroups(CGs);
        foreach (ListItem computer in CGs)
        {
            if (computer.Value == ComputerGroupName)
            {
                AssignedComputers.Add(new ListItem(computer.Text, computer.Text));
            }
            
        }
    }
    //not used
    public static string AddComputerToCompGroup(MOMMPSupportLib.ManagementPack objMP, string ComputerGroupName, string NewComputerName)
    {
        bool bFound = false;
        MOMMPSupportLib.IMOMComputerRule objComputerGroup = null;
        //look for the computer group
        foreach (MOMMPSupportLib.IMOMComputerRule objRule in objMP.AllComputerRules)
        {
            if (objRule.Name.ToLower().Equals(ComputerGroupName.ToLower()))
            {
                bFound = true;
                objComputerGroup = objRule;
                break;
            }
        }
        if (bFound)
        {
            //Add computers if computer doesn't already exist there
            if (!IsComputerInCompGroup(objComputerGroup, NewComputerName))
            {
                objComputerGroup.Includes.Add(NewComputerName);
            }
            else
            {
                return "Computer "+NewComputerName+" was already assigned to computer group "+ComputerGroupName;
            }
        }
        else
        {
            return "Error finding computer group " + ComputerGroupName;
        }
        return "Done!";
    }
    public static void GetComputerGroups(ListItemCollection CGs)
    {
        CGs.Clear();
        GetComputerToComputerGroupMappingsFromMOMDB(CGs);
    }
    public static void GetAssignedRuleGroups(string ComputerName, ListItemCollection groups)
    {
        GetRuleGroupToComputerGroupMappingFromMOMDB(ComputerName, groups);
    }
    public static void GetComputerToComputerGroupMappingsFromMOMDB(ListItemCollection CGs)
    {
        CGs.Clear();
        SqlConnection _EventCnt = null;
        try
        {
            _EventCnt = new SqlConnection(myConnString);
            _EventCnt.Open();

            string mySelectQuery = "select distinct [Computer], [Rule] from ComputerToComputerRuleView where [Rule] like '"+_ComputerGroupPrefix+"%'";
            SqlCommand myCommand = new SqlCommand(mySelectQuery, _EventCnt);
            myCommand.CommandType = CommandType.Text;
            SqlDataReader myReader = myCommand.ExecuteReader();
            while (myReader.Read())
            {
                //read and store server names
                string computerName = myReader.GetString(0);
                string computerGroup = myReader.GetString(1);
                CGs.Add(new ListItem(computerName.Trim(), computerGroup.Trim()));
            }

            myReader.Close();
        }
        catch (Exception e)
        {
            System.Diagnostics.EventLog eventLog = new System.Diagnostics.EventLog("Application");
            eventLog.Source = "PerfDAD";
            eventLog.WriteEntry("Error reading computer to computer group mappings from MOM Database. \n" + e.ToString(), System.Diagnostics.EventLogEntryType.Error, (int) PerfAdmin.EventIds.PERFDAD_MOM_CONNECTION);
            eventLog.Close();
        }
        finally
        {
            if (_EventCnt != null)
            {
                _EventCnt.Close();
                _EventCnt = null;
            }

        }
    }
    private static void GetRuleGroupToComputerGroupMappingFromMOMDB(string computerGroupName, ListItemCollection groups)
    {
        groups.Clear();
        SqlConnection _EventCnt = null;
        try
        {
            _EventCnt = new SqlConnection(myConnString);
            _EventCnt.Open();

            string mySelectQuery = "select distinct PR.ProcessRuleGroupName from ComputerRuleToProcessRuleGroup map ";
            mySelectQuery += "join ComputerRule CR on CR.idComputerRule = map.idComputerRule ";
            mySelectQuery += "join ProcessRuleMemberShipWithLevelView PR on PR.ProcessRuleGroupID = map.idProcessRule ";
            mySelectQuery += "where CR.Name = '"+computerGroupName+"'";
            SqlCommand myCommand = new SqlCommand(mySelectQuery, _EventCnt);
            myCommand.CommandType = CommandType.Text;
            SqlDataReader myReader = myCommand.ExecuteReader();
            while (myReader.Read())
            {
                //read and store server names
                string RuleGroupName = myReader.GetString(0);
                groups.Add(new ListItem(RuleGroupName.Trim(), RuleGroupName.Trim()));
            }

            myReader.Close();
        }
        catch (Exception e)
        {
            System.Diagnostics.EventLog eventLog = new System.Diagnostics.EventLog("Application");
            eventLog.Source = "PerfDAD";
            eventLog.WriteEntry("Error reading computer group to rule group mappings from MOM Database. \n" + e.ToString(), System.Diagnostics.EventLogEntryType.Error, (int)PerfAdmin.EventIds.PERFDAD_MOM_CONNECTION);
            eventLog.Close();
        }
        finally
        {
            if (_EventCnt != null)
            {
                _EventCnt.Close();
                _EventCnt = null;
            }

        }
    }
   

    //*** private helper functions used by MOM shipping code above *****
    private static void GetRuleGroups(MOMMPSupportLib.ManagementPack objMP, ListItemCollection RGs)
    {
        RGs.Clear();
        foreach (IMOMRuleGroup objGroup in objMP.TopRuleGroups)
        {
            RGs.Add(new ListItem(objGroup.Name, objGroup.Name));
        }
    }
    private static bool IsComputerInCompGroup(MOMMPSupportLib.IMOMComputerRule objComputerGroup, string NewComputerName)
    {
        foreach (object objComputer in objComputerGroup.Includes)
        {
            if (objComputer.GetType().ToString() == "System.String" && ((string)objComputer).ToLower() == NewComputerName.ToLower())
            {
                //The computer is already on the list
                return true;
                break;
            }
        }
        return false;
    }

    private static IMOMRuleGroup GetRuleGroup(MOMMPSupportLib.ManagementPack objMP, string strRuleGroup, bool bCreate)
    {
        IMOMRuleGroup objReturn = null;
        bool bFound = false;

        if (strRuleGroup != "" && strRuleGroup != null)
        {
            foreach (IMOMRuleGroup objGroup in objMP.TopRuleGroups)
            {
                if (objGroup.Name.ToLower() == strRuleGroup.ToLower())
                {
                    return objGroup;
                }
            }

            if (!bFound && bCreate)
            {
                //Create the root group
                objReturn = (IMOMRuleGroup)objMP.AllRuleGroups.AddNew();
                objReturn.Name = strRuleGroup;
                return objReturn;
            }
        }
        else
        {
            //rule group not found 
        }

        return null;
    }

    private static IMOMRuleGroup GetSubGroup(IMPCollection objRuleGroups, string strGroupName, bool bCreate)
    {
        bool bFound = false;
        IMOMRuleGroup objReturn = null;
        if (strGroupName == "")
        {
            return null;
        }
        foreach (IMOMRuleGroup objGroup in objRuleGroups)
        {
            if (objGroup.Name.ToLower().Equals(strGroupName.ToLower()))
            {
                return objGroup;
            }
        }
        if (bCreate)
        {
            //No rule group was found
            //Let's create one
            objReturn = (IMOMRuleGroup)objRuleGroups.AddNew();
            objReturn.Name = strGroupName;
            return objReturn;
        }
        return null;

    }

    private static IMOMComputerRule GetComputerGroup(MOMMPSupportLib.ManagementPack objMP, string ComputerGroup)
    {
        foreach (MOMMPSupportLib.IMOMComputerRule objRule in objMP.AllComputerRules)
        {
            if (objRule.Name.Equals(ComputerGroup))
                return objRule;
        }
        return null;
    }

    private static IMOMProcRule CreatePerfRule(string strRuleName, IMOMRuleGroup objRuleGroup, MOMMPSupportLib.IMOMProvider objProvider, bool bCreateResponse)
    {
        try
        {
            IMOMProcRule objNewRule = objRuleGroup.ProcessingRules.AddNew(eProcessingRuleType.MOM_MEASURE_RULE);
            objNewRule.Name = strRuleName;
            objNewRule.Provider = objProvider;
            objNewRule.IsEnabled = true;
            if (bCreateResponse)
            {
                IMOMResponseManagedCode objResponse = (IMOMResponseManagedCode)objNewRule.Response.AddNew(eResponseType.MOM_RESPONSE_MANAGEDCODE);
                objResponse.AssemblyName = "AppPoolTranslator, Version=1.0.0.2, Culture=neutral, PublicKeyToken=66d6672482984eb8";
                objResponse.MethodName = "TranslateAppPool";
                objResponse.IsMethodStatic = true;
                objResponse.TypeName = "XOC.MOMResponses.AppPoolTranslator";
                objResponse.Location = eResponseLocation.MOM_SERVER_RESPONSE;
                objResponse.TimeOut = 60; //is this seconds? or minutes?
                IMOMScriptParameter MomContext = objResponse.Parameters.AddNew("Microsoft.EnterpriseManagement.Mom.Runtime.Context");
                IMOMScriptParameter createCache = objResponse.Parameters.AddNew("System.Boolean");
                createCache.Value = "true";
                IMOMScriptParameter cacheTime = objResponse.Parameters.AddNew("System.Int32");
                cacheTime.Value = "900";
                IMOMScriptParameter appendNum = objResponse.Parameters.AddNew("System.Int32");
                appendNum.Value = "2";
                IMOMScriptParameter appendStr = objResponse.Parameters.AddNew("System.String");                
            }

            return objNewRule;
        }
        catch (Exception e)
        {
            throw new Exception("Exception encountered while creating new processing rule: " + e.Message, e);
        }
    }
    private static IMOMProcRule DoesRuleExist(IMOMRuleGroup objCounterSetGroup, string RuleName)
    {
        foreach (IMOMProcRule Rule in objCounterSetGroup.ProcessingRules)
        {
            if (Rule.Name.Equals(RuleName))
            {
                return Rule;
            }
        }
        return null;
    }

    private static IMOMProvider FindPerfProvider(string ProviderName)
    {
        //see if there is an existing provider for this rule by loading another management pack.
        try
        {
            ManagementPack objTempMP = _objMOMDB.LoadProvider(_strMOMServerName, ProviderName);

            foreach (MOMMPSupportLib.IMOMProvider objProvider in objTempMP.AllProviders)
            {
                if (objProvider.ProviderType == eProviderType.MOM_NT_PERFORMANCE_PROVIDER)
                {
                    //check the names to match
                    if (objProvider.Name.ToLower().Equals(ProviderName.ToLower()))
                        return objProvider;
                }
            }
        }
        catch (Exception e)
        {
            System.Diagnostics.EventLog eventLog = new System.Diagnostics.EventLog("Application");
            eventLog.Source = "PerfDAD";
            eventLog.WriteEntry("Error loading provider "+ProviderName+" from "+_strMOMServerName+" \n" + e.ToString(), System.Diagnostics.EventLogEntryType.Error, (int) PerfAdmin.EventIds.PERFDAD_MOM_GENERIC_ERROR);
            eventLog.Close();
        }

        return null;
    }

    private static IMOMProvider CreatePerfProvider(MOMMPSupportLib.ManagementPack objMP, string strProviderName, string strComputerName, string strObjectName, string strCounterName, string strInstanceName, eCounterType objCounterType, eSampleUnit objSampleUnits, int intSampleFrequency)
    {
        
        //we didn't find a matching provider, create one.
        MOMMPSupportLib.IMOMNTPerformanceProvider objNewProvider = (MOMMPSupportLib.IMOMNTPerformanceProvider)objMP.AllProviders.AddNew(eProviderType.MOM_NT_PERFORMANCE_PROVIDER);
        objNewProvider.Name = strProviderName;
        objNewProvider.Computer = strComputerName;
        objNewProvider.ObjectName = strObjectName;
        objNewProvider.CounterName = strCounterName;
        objNewProvider.InstanceName = strInstanceName;
        objNewProvider.CounterType = objCounterType;
        objNewProvider.SampleFrequency = intSampleFrequency;
        objNewProvider.SampleUnits = objSampleUnits;

        return objNewProvider;
    }
    
    private static int ConvertStringToECounterType(string strCounterType)
    {
        int RetVal = -1;

        switch (strCounterType)
        {
            case "NumberOfItemsHEX32":
                RetVal = (int)eCounterType.NumberOfItemsHEX32;
                break;
            case "NumberOfItemsHEX64":
                RetVal = -1;
                break;
            case "NumberOfItems32":
                RetVal = (int)eCounterType.NumberOfItems32;
                break;
            case "NumberOfItems64":
                RetVal = -1;
                break;
            case "CounterDelta32":
                RetVal = (int)eCounterType.DifferenceBetweenValues32;
                break;
            case "CounterDelta64":
                RetVal = -1;
                break;
            case "SampleCounter":
                RetVal = (int)eCounterType.Sampling;
                break;
            case "CountPerTimeInterval32":
                RetVal = (int)eCounterType.CountPerTimeInterval32;
                break;
            case "CountPerTimeInterval64":
                RetVal = -1;
                break;
            case "RateOfCountsPerSecond32":
                RetVal = (int)eCounterType.RateOfChangePerSecond32;
                break;
            case "RateOfCountsPerSecond64":
                RetVal = -1;
                break;
            case "RawFraction":
                RetVal = (int)eCounterType.RawFraction;
                break;
            case "CounterTimer":
                RetVal = (int)eCounterType.UsePercentage;
                break;
            case "Timer100Ns":
                RetVal = (int)eCounterType.UsePercentage100NS;
                break;
            case "SampleFraction":
                RetVal = (int)eCounterType.SamplingPercentage;
                break;
            case "CounterTimerInverse":
                RetVal = (int)eCounterType.UsePercentageInverse;
                break;
            case "Timer100NsInverse":
                RetVal = (int)eCounterType.UsePercentageInverse100NS;
                break;
            case "CounterMultiTimer":
                RetVal = (int)eCounterType.MultipleUsePercentage;
                break;
            case "CounterMultiTimer100Ns":
                RetVal = (int)eCounterType.MultipleUsePercentage100NS;
                break;
            case "CounterMultiTimerInverse":
                RetVal = (int)eCounterType.MultipleUsePercentageInverse;
                break;
            case "CounterMultiTimer100NsInverse":
                RetVal = (int)eCounterType.MultipleUsePercentageInverse100NS;
                break;
            case "AverageTimer32":
                RetVal = (int)eCounterType.AverageTimePerSecond32;
                break;
            case "ElapsedTime":
                RetVal = (int)eCounterType.ElapsedTime;
                break;
            case "AverageCount64":
                RetVal = -1;
                break;
            case "SampleBase":
                RetVal = (int)eCounterType.NumberOfSamplesTaken;
                break;
            case "AverageBase":
                RetVal = (int)eCounterType.NumberOfOperations;
                break;
            case "RawBase":
                RetVal = (int)eCounterType.RawBase;
                break;
            case "CounterMultiBase":
                RetVal = (int)eCounterType.MultipleUseNumberOfItems;
                break;
            default:
                RetVal = -1;
                break;
        }
        return RetVal;
    }

    private static Object CovertStringToECounterType64(string strCounterType)
    {
        //get the reference rule group
        MOMMPSupportLib.ManagementPack objMP = null;
        IMOMRuleGroup objGroup = null;
        try
        {
            objMP = new ManagementPack();
            objMP = _objMOMDB.LoadRuleGroup(_strMOMServerName, "PerfDAD Counter Type 64 Reference Group");
            objGroup = GetRuleGroup(objMP, "PerfDAD Counter Type 64 Reference Group", false);
            if (objGroup == null)
            {
                throw new Exception("Error finding RuleGroup \"PerfDAD Counter Type 64 Reference Group\""); // "Error finding 64 bit reference rule group PerfDAD Counter Type 64 Reference Group";
            }
        }
        catch (Exception e)
        {
            System.Diagnostics.EventLog eventLog = new System.Diagnostics.EventLog("Application");
            eventLog.Source = "PerfDAD";
            eventLog.WriteEntry("Error loading rule group \"PerfDAD Counter Type 64 Reference Group\" from " + _strMOMServerName + ". This group allows PerfDAD to convert 64 bit counter types into MOM's specific counter types, and PerfDAD cannot function without it. \n" + e.ToString(), System.Diagnostics.EventLogEntryType.Error, (int) PerfAdmin.EventIds.PERFDAD_MOM_GENERIC_ERROR);
            eventLog.Close();
            return null;
        }
        //load the provider from the rule group
        try
        {
            IMOMNTPerformanceProvider objProvider = (IMOMNTPerformanceProvider)GetProviderAssociatedWithRule(objGroup, "PerfDAD - ReferenceRule-" + strCounterType);
            if (objProvider == null)
            {
                throw new Exception(); // "Error finding 64 bit reference rule PerfDAD - ReferenceRule-" + strCounterType;
            }
            return objProvider.CounterType;
        }
        catch (Exception e)
        {
            System.Diagnostics.EventLog eventLog = new System.Diagnostics.EventLog("Application");
            eventLog.Source = "PerfDAD";
            eventLog.WriteEntry("Error loading provider PerfDAD - ReferenceRule-" + strCounterType+ " from " + _strMOMServerName + ". This group allows PerfDAD to convert 64 bit counters \n" + e.ToString(), System.Diagnostics.EventLogEntryType.Error, (int) PerfAdmin.EventIds.PERFDAD_MOM_GENERIC_ERROR);
            eventLog.Close();
            
        }
        return null;
       
    }
    
    private static IMOMProvider GetProviderAssociatedWithRule(IMOMRuleGroup objCounterSetGroup, string RuleName)
    {
        foreach (IMOMProcRule Rule in objCounterSetGroup.ProcessingRules)
        {
            if (Rule.Name.Equals(RuleName))
            {
                return Rule.Provider;
            }
        }
        return null;
    }


        /* public static string CreateComputerGroup(string ComputerGroupName)
           {
               //load management pack from mom server
               _objMP = _objMOMDB.Load(_strMOMServerName, _objMP);
               //look to see if computer group exists already
               foreach (MOMMPSupportLib.IMOMComputerRule objRule in _objMP.AllComputerRules)
               {
                   if (objRule.Name.ToLower().Equals(ComputerGroupName.ToLower()))
                   {
                       return "Computer Group " + ComputerGroupName + " already exists.";
                   }
               }
        
               IMOMComputerRule objComputerGroup = _objMP.AllComputerRules.AddNew();
               objComputerGroup.Name = ComputerGroupName;
       
               return "Done!";
           }*/




    
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\LiveTest\PerfDataSetup\makefile.inc ===
!include $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\loccategories\makefile.inc ===
!include $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\LiveTest\PerfData\App_Code\PerfDB.cs ===
using System;
using System.Data;
using System.Configuration;
using System.Xml;
using System.Web;
using System.Web.Security;
using System.Web.UI;
using System.Web.UI.WebControls;
using System.Web.UI.WebControls.WebParts;
using System.Web.UI.HtmlControls;
using System.Collections;
using System.ComponentModel;
using System.Data.SqlClient;

/// <summary>
/// Summary description for PerfDB
/// </summary>
public class PerfDB
{
    static string myConnString = "Data Source=xeperfsql001 ;Initial Catalog=perfdb2;persist security info=False;integrated security=SSPI";
	
    public PerfDB()
	{
		//
		// TODO: Add constructor logic here
		//
	}
    static public void InitSettings(string pathToXMLfolder)
    {
        //find out the connection string for perfdb
        try
        {
            /*XmlDocument perfDBXml = new XmlDocument();
            //System.Web.VirtualPathUtility.GetDirectory("/PerfAdmin/ConfigXML");
            pathToXMLfolder += "PerfDB.xml";
            perfDBXml.Load(pathToXMLfolder);
            XmlNode perfDB = perfDBXml.SelectSingleNode("descendant::PerfDB");
            myConnString = perfDB.SelectSingleNode("ConnectionString").InnerText;*/
             myConnString = "";
                if (ConfigurationManager.ConnectionStrings["PerfDB2"] == null)
                    throw new Exception("No connection string found for PerfDB2. Please add a connection string to web.config with name=PerfDB2");
            
                myConnString = ConfigurationManager.ConnectionStrings["PerfDB2"].ToString();

            
        }
        catch (Exception e)
        {
            System.Diagnostics.EventLog eventLog = new System.Diagnostics.EventLog("Application");
            eventLog.Source = "PerfData";
            eventLog.WriteEntry("Error loading settings from web.config.\n" + e.ToString(), System.Diagnostics.EventLogEntryType.Error,15);
            eventLog.Close();

            //reverting to default:
            myConnString = "Data Source=xeperfsql001 ;Initial Catalog=perfdb2;user id=PerfLogTool;password=PerfLogTool";
        }

    }

    static public string[] GetStings(ArrayList list)
    {
        string[] tmp = new string[list.Count];
        int i = 0;
        foreach (string item in list)
        {
            tmp[i++] = item;
        }
        return tmp;
    }

    static public string[] GetCounterSetList(string Reqid)
    {
        ArrayList CounterSetlist = new ArrayList();
        CounterSetlist.Add(Reqid);

        SqlConnection _EventCnt =null;
        try
        {

            string mySelectQuery  ="SELECT * FROM [t_CounterSet] cs order by CounterSet_Name";

            _EventCnt= new SqlConnection(myConnString);
            _EventCnt.Open();

            SqlCommand myCommand = new SqlCommand(mySelectQuery, _EventCnt);
            myCommand.CommandType = CommandType.Text;
            SqlDataReader myReader = myCommand.ExecuteReader();
            while(myReader.Read()) 
            {
                int id= myReader.GetInt32(0);
                string name=myReader.GetString(1);
                CounterSetlist.Add(name);
            }
            myReader.Close();

        }
        catch(Exception e)
        {
            System.Diagnostics.EventLog eventLog = new System.Diagnostics.EventLog("Application");
            eventLog.Source = "PerfData";
            eventLog.WriteEntry("Error retrieving counter set lists from database. \n Connection string="+myConnString+"\n" + e.ToString(), System.Diagnostics.EventLogEntryType.Error, 1);
            eventLog.Close();
        }
        finally
        {
            if(_EventCnt!=null)
            {
                _EventCnt.Close();
                _EventCnt=null;
            }
        }

        return PerfDB.GetStings(CounterSetlist);
    }


    static public string[] GetCounterinfo(string Reqid,string counterset)
    {
        ArrayList Counterlist = new ArrayList();
        Counterlist.Add(Reqid);

        SqlConnection _EventCnt = null;
        try
        {

            string mySelectQuery = "select cd.* from t_CounterDetails cd ";
            mySelectQuery += " inner join  t_CounterSet cs on cs.CounterSet_ID=cd.CounterSetID";
            mySelectQuery += " where CounterSet_Name ='" + counterset + "' and Enabled = 'true'";



            _EventCnt = new SqlConnection(myConnString);
            _EventCnt.Open();


            SqlCommand myCommand = new SqlCommand(mySelectQuery, _EventCnt);
            myCommand.CommandType = CommandType.Text;
            SqlDataReader myReader = myCommand.ExecuteReader();
            while (myReader.Read())
            {
                int id = myReader.GetInt32(0);
                string PerfObject = myReader.GetString(2);
                string CounterName = myReader.GetString(3);
                string Instance = myReader.GetString(4);
                //don't add the select few that we don't want to see
                if (!Instance.Equals("<All>"))
                {
                    Counterlist.Add(PerfObject + "+" + CounterName + "+" + Instance);
                }

            }
            myReader.Close();

        }
        catch(Exception e)
        {
            System.Diagnostics.EventLog eventLog = new System.Diagnostics.EventLog("Application");
            eventLog.Source = "PerfData";
            eventLog.WriteEntry("Error retrieving counter information for counter set "+counterset+" from database. \n Connection string="+myConnString+"\n" + e.ToString(), System.Diagnostics.EventLogEntryType.Error, 1);
            eventLog.Close();
        }
        finally
        {
            if (_EventCnt != null)
            {
                _EventCnt.Close();
                _EventCnt = null;
            }

        }

        return PerfDB.GetStings(Counterlist);
    }



     static public string[] GetComputers(string Reqid,string counterset)
    {
        ArrayList Complist = new ArrayList();
        Complist.Add(Reqid);

        SqlConnection _EventCnt = null;
        try
        {

            string mySelectQuery = "select ComputerName from t_ComputerGroupMap CG ";
            mySelectQuery += "join t_CounterSetAssignments CSA on CG.ComputerGroupName=CSA.ComputerGroupName ";
            mySelectQuery += "join t_CounterSet CS on CS.CounterSet_ID = CSA.CounterSetID ";
            mySelectQuery += "where CS.CounterSet_Name ='" + counterset + "'"; 
                        
            _EventCnt = new SqlConnection(myConnString);
            _EventCnt.Open();


            SqlCommand myCommand = new SqlCommand(mySelectQuery, _EventCnt);
            myCommand.CommandType = CommandType.Text;
            SqlDataReader myReader = myCommand.ExecuteReader();
            while (myReader.Read())
            {
                
                string Computer = myReader.GetString(0);
                //don't add duplicates, they are annoying.
                if (!Complist.Contains(Computer)) Complist.Add(Computer);

            }
            myReader.Close();

        }
         catch(Exception e)
        {
            System.Diagnostics.EventLog eventLog = new System.Diagnostics.EventLog("Application");
            eventLog.Source = "PerfData";
            eventLog.WriteEntry("Error retrieving machine information for counter set "+counterset+" from database. \n Connection string="+myConnString+"\n" + e.ToString(), System.Diagnostics.EventLogEntryType.Error, 1);
            eventLog.Close();
        }
        finally
        {
            if (_EventCnt != null)
            {
                _EventCnt.Close();
                _EventCnt = null;
            }

        }

        return PerfDB.GetStings(Complist);
    }



    static public int SetGraphInfo(string graphname, string counterset, string machine,string settings)
    {
        int NoRows = 0;
        ArrayList Complist = new ArrayList();
        

        SqlConnection _EventCnt = null;
        try
        {

            string mySelectQuery = "exec [p_SetGraphInfo]  '";
            mySelectQuery += graphname + "', '" + counterset + "','" + machine + "','" + settings + "'";
           
            
            _EventCnt = new SqlConnection(myConnString);
            _EventCnt.Open();


            SqlCommand myCommand = new SqlCommand(mySelectQuery, _EventCnt);
            myCommand.CommandType = CommandType.Text;
            NoRows=  myCommand.ExecuteNonQuery();
           
        }
         catch(Exception e)
        {
            System.Diagnostics.EventLog eventLog = new System.Diagnostics.EventLog("Application");
            eventLog.Source = "PerfData";
            eventLog.WriteEntry("Error executing stored proc p_SetGraphInfo in database. \n Connection string="+myConnString+"\n" + e.ToString(), System.Diagnostics.EventLogEntryType.Error, 1);
            eventLog.Close();
        }
        finally
        {
            if (_EventCnt != null)
            {
                _EventCnt.Close();
                _EventCnt = null;
            }

        }
        return NoRows;
    }


    static public string[] GetGraphInfo(string Reqid, string graphname)
    {
        ArrayList Countersetlist = new ArrayList();
        Countersetlist.Add(Reqid);

        SqlConnection _EventCnt = null;
        try
        {

            string mySelectQuery = " select GM.CounterSetName , GM.[ComputerName], GM.[Settings] FROM [PerfDB2].[dbo].[t_GraphMap] GM ";
            mySelectQuery += "join dbo.t_Graphs G on G.GraphID=GM.[GraphID] where G.GraphName='" + graphname + "'";



            _EventCnt = new SqlConnection(myConnString);
            _EventCnt.Open();


            SqlCommand myCommand = new SqlCommand(mySelectQuery, _EventCnt);
            myCommand.CommandType = CommandType.Text;
            SqlDataReader myReader = myCommand.ExecuteReader();
            while (myReader.Read())
            {
                
                string Counterset = myReader.GetString(0);
                string MachineName = myReader.GetString(1);
                string settings = myReader.GetString(2);
                Countersetlist.Add(Counterset + "+" + MachineName + "+" + settings);

            }
            myReader.Close();

        }
         catch(Exception e)
        {
            System.Diagnostics.EventLog eventLog = new System.Diagnostics.EventLog("Application");
            eventLog.Source = "PerfData";
            eventLog.WriteEntry("Error retrieving graph information for graph "+graphname+" from database. \n Connection string="+myConnString+"\n" + e.ToString(), System.Diagnostics.EventLogEntryType.Error, 1);
            eventLog.Close();
        }
        finally
        {
            if (_EventCnt != null)
            {
                _EventCnt.Close();
                _EventCnt = null;
            }

        }

        return PerfDB.GetStings(Countersetlist);
    }


    static public string[] GetGraphs(string Reqid )
    {
        ArrayList Graphlist = new ArrayList();
        Graphlist.Add(Reqid);

        SqlConnection _EventCnt = null;
        try
        {

            string mySelectQuery = " select * FROM [PerfDB2].[dbo].[t_Graphs] ";
           

            _EventCnt = new SqlConnection(myConnString);
            _EventCnt.Open();


            SqlCommand myCommand = new SqlCommand(mySelectQuery, _EventCnt);
            myCommand.CommandType = CommandType.Text;
            SqlDataReader myReader = myCommand.ExecuteReader();
            while (myReader.Read())
            {

               
                string GraphName = myReader.GetString(1);
                Graphlist.Add(GraphName);

            }
            myReader.Close();

        }
         catch(Exception e)
        {
            System.Diagnostics.EventLog eventLog = new System.Diagnostics.EventLog("Application");
            eventLog.Source = "PerfData";
            eventLog.WriteEntry("Error retrieving all graph information from database. \n Connection string="+myConnString+"\n" + e.ToString(), System.Diagnostics.EventLogEntryType.Error, 1);
            eventLog.Close();
        }
        finally
        {
            if (_EventCnt != null)
            {
                _EventCnt.Close();
                _EventCnt = null;
            }

        }

        return PerfDB.GetStings(Graphlist);
    }

    static public string[] ClearGraph(string Reqid,string graphname)
    {
        int rcount =0;
        ArrayList Graphlist = new ArrayList();
        Graphlist.Add(Reqid);

        SqlConnection _EventCnt = null;
        try
        {

            string mySelectQuery = " delete GM from [t_GraphMap] GM ";
            mySelectQuery += "inner join [t_Graphs] G on G.[GraphID]=GM.[GraphID]";
            mySelectQuery += " where G.[GraphName]= '" + graphname + "'";


            _EventCnt = new SqlConnection(myConnString);
            _EventCnt.Open();


            SqlCommand myCommand = new SqlCommand(mySelectQuery, _EventCnt);
            myCommand.CommandType = CommandType.Text;
            rcount = myCommand.ExecuteNonQuery();
            
        }
         catch(Exception e)
        {
            System.Diagnostics.EventLog eventLog = new System.Diagnostics.EventLog("Application");
            eventLog.Source = "PerfData";
            eventLog.WriteEntry("Error deleting graph "+graphname+" from database. \n Connection string="+myConnString+"\n" + e.ToString(), System.Diagnostics.EventLogEntryType.Error, 1);
            eventLog.Close();
        }
        finally
        {
            if (_EventCnt != null)
            {
                _EventCnt.Close();
                _EventCnt = null;
            }

        }

        return new string[] { Reqid, rcount.ToString() };
    }
    
    


	
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\LiveTest\PerfData\App_Code\MomDB.cs ===
using System;
using System.Data;
using System.Configuration;
using System.Xml;
using System.Web;
using System.Web.Security;
using System.Web.UI;
using System.Web.UI.WebControls;
using System.Web.UI.WebControls.WebParts;
using System.Web.UI.HtmlControls;
using System.Collections;
using System.Data.SqlClient;

/// <summary>
/// Summary description for MomDB
/// </summary>
public class MomDB
{

    static string myConnString = "Data Source=XEPERFSQL001 ;Initial Catalog=OnePoint;Integrated Security=SSPI;";
	
   
	public MomDB()
	{
		//
		// TODO: Add constructor logic here
		//
	}
    static public void InitSettings(string pathToXMLfolder)
    {
        //find out the connection string for perfdb
        try
        {
            XmlDocument MOMXml = new XmlDocument();
            pathToXMLfolder += "MomDB.xml";
            MOMXml.Load(pathToXMLfolder);
            XmlNode momInterface = MOMXml.SelectSingleNode("descendant::MomDB");
            XmlNode OnePoint = momInterface.SelectSingleNode("descendant::SystemCenterReporting");
            myConnString = OnePoint.SelectSingleNode("ConnectionString").InnerText;

             if (ConfigurationManager.ConnectionStrings["SystemCenterReporting"] == null)
                    throw new Exception("No connection string found for SystemCenterReporting. Please add a connection string to web.config with name=SystemCenterReporting");
            
            myConnString = ConfigurationManager.ConnectionStrings["SystemCenterReporting"].ToString();
        }
        catch (Exception e)
        {
            System.Diagnostics.EventLog eventLog = new System.Diagnostics.EventLog("Application");
            eventLog.Source = "PerfData";
            eventLog.WriteEntry("Error loading settings from web.config.\n" + e.ToString(), System.Diagnostics.EventLogEntryType.Error, 2);
            eventLog.Close();

            //reverting to defaults:
            myConnString = "Data Source=XETESTSQL001 ;Initial Catalog=SystemCenterReporting;Integrated Security=SSPI;";
        }

    }
    static public double[] Getdouble(ArrayList list)
    {
        double[] tmp = new double[list.Count];
        int i = 0;
        foreach (double item in list)
        {
            tmp[i++] = item;
        }
        return tmp;
    }

    static public string[] GetPoints(int reqid,string CompName,string ObjectName,string CounterName,string InstanceName,string StartDate, string EndDate)
    {
        string mySelectQuery = "select [SampledValue] ,TimeSampled from SDKPerformanceView with(nolock)  ";
        //check for the w3wp instance, which will need to be changed so we can pull the data out correctly
        if ((ObjectName.Equals("Process") || ObjectName.Equals(".NET CLR Memory")) && InstanceName.Contains("w3wp"))
        {
            InstanceName = InstanceName.Remove(0, 5);
            //the computer name will be appended to the performance object name
            mySelectQuery += " where PerformanceObjectName='" + ObjectName + "--" + CompName + "' ";
        }
        else
        {
            mySelectQuery += " where ComputerName='" + CompName + "' and PerformanceObjectName='" + ObjectName + "' ";
            
        }

        mySelectQuery += "and [PerformanceCounterName]='" + CounterName + "' ";
        
        if(InstanceName.Length != 0)
            mySelectQuery += "and  [PerformanceInstanceName]='" + InstanceName + "' ";
        
        mySelectQuery += "and  ([TimeSampled] >= '" + StartDate + "' and [TimeSampled] <= '" + EndDate +"') order by TimeSampled ";

        ArrayList Points = new ArrayList();
        Points.Add(reqid.ToString());

        SqlConnection _EventCnt = null;
        try
        {

            _EventCnt = new SqlConnection(myConnString);
            _EventCnt.Open();


            SqlCommand myCommand = new SqlCommand(mySelectQuery, _EventCnt);
            myCommand.CommandType = CommandType.Text;
            SqlDataReader myReader = myCommand.ExecuteReader();
            while (myReader.Read())
            {
                DateTime time = myReader.GetDateTime(1);
                double val = myReader.GetDouble(0);
                Points.Add(val.ToString()+"+"+time.ToString());

            }
            myReader.Close();

        }
        catch (Exception e)
        {
            System.Diagnostics.EventLog eventLog = new System.Diagnostics.EventLog("Application");
            eventLog.Source = "PerfData";
            eventLog.WriteEntry("Error retrieving points for requested counter. \n Query string = "+mySelectQuery+"\nConnection string="+myConnString+"\n" + e.ToString(), System.Diagnostics.EventLogEntryType.Error, 1);
            eventLog.Close();
        }
        finally
        {
            if (_EventCnt != null)
            {
                _EventCnt.Close();
                _EventCnt = null;
            }

        }
        return MomDB.GetStings(Points);
    }


    static public string[] GetStings(ArrayList list)
    {
        string[] tmp = new string[list.Count];
        int i = 0;
        foreach (string item in list)
        {
            tmp[i++] = item;
        }
        return tmp;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\LiveTest\PerfData\App_Code\Service.cs ===
using System;
using System.Web;
using System.Web.Services;
using System.Web.Services.Protocols;

[WebService(Namespace = "http://tempuri.org/")]
[WebServiceBinding(ConformsTo = WsiProfiles.BasicProfile1_1)]
public class Service : System.Web.Services.WebService
{
    public Service () {

        //Uncomment the following line if using designed components 
        //InitializeComponent(); 
    }

   
    [WebMethod]
    public string[] GetPoints(int Reqid, string PerfObject, string CounterName, string InstanceName, string MachineName, string StartDate, string EndDate)
    {
       
        MomDB.InitSettings("");

        return  MomDB.GetPoints(Reqid, MachineName, PerfObject, CounterName, InstanceName, StartDate, EndDate);

    }

    [WebMethod]
    public string[] GetCounterSets(string Reqid)
    {
        
        PerfDB.InitSettings("");
        return PerfDB.GetCounterSetList(Reqid);
    }

    [WebMethod]
    public string[] GetMachines(string Reqid,string CounterSet)
    {
       PerfDB.InitSettings("");
        return PerfDB.GetComputers(Reqid, CounterSet);
    }

    [WebMethod]
    public string[] GetCounterinfo(string Reqid,string CounterSet)
    {
        PerfDB.InitSettings("");
        return PerfDB.GetCounterinfo(Reqid,CounterSet);
    }

    [WebMethod]
    public string[] GetGraphs(string Reqid)
    {
        PerfDB.InitSettings("");
        return PerfDB.GetGraphs(Reqid);
    }

    [WebMethod]
    public string[] GetCounterSetsInGraphs(string Reqid,string Graph)
    {
        PerfDB.InitSettings("");
        return PerfDB.GetGraphInfo(Reqid, Graph);
    }

    [WebMethod]
    public string SetCounterSetsInGraphs(string Reqid,string GraphName,string CounterSet,string Machine,string Settings)
    {
        PerfDB.InitSettings("");
        PerfDB.SetGraphInfo(GraphName, CounterSet, Machine, Settings);
         return Reqid;
    }

    [WebMethod]
    public string[] ClearGraphs(string Reqid, string GraphName)
    {
       PerfDB.InitSettings("");
        return PerfDB.ClearGraph(Reqid,GraphName);
        
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\loccategories\common.cs ===
using System;
using System.Text;
using System.Collections;
using System.IO;
using System.Xml;

namespace xonline.tools.loccategories
{
    class Common
    {
        public static string GetAttribute(XmlNode node, string attribute)
        {
            string ret = String.Empty;
            XmlAttribute attr = node.Attributes[attribute];
            if (attr != null)
            {
                ret = attr.Value;
            }
            return ret;
        }
    }
    
    
    struct CategoryInfo
    {
        public string Id;
        public string Name;
    };
    
    struct LocaleLanguageMap
    {
        public string Lcid;
        public string Language;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\loccategories\obj\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("Microsoft(R) Xbox(TM)")]
[assembly:System.Reflection.AssemblyCopyright("Copyright (c) Microsoft Corporation. All rights reserved.")]
[assembly:System.Reflection.AssemblyCompany("Microsoft Corporation")]
[assembly:System.Reflection.AssemblyFileVersion("12.4.56.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\loccategories\objd\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("Microsoft(R) Xbox(TM)")]
[assembly:System.Reflection.AssemblyCopyright("Copyright (c) Microsoft Corporation. All rights reserved.")]
[assembly:System.Reflection.AssemblyCompany("Microsoft Corporation")]
[assembly:System.Reflection.AssemblyFileVersion("12.4.56.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\loccategories\loccategories.cs ===
using System;
using System.Text;
using System.Collections;
using System.IO;
using System.Xml;

namespace xonline.tools.loccategories
{
    class LocCategories
    {
        static void Usage()
        {
            Console.WriteLine("------------------------------------------------------------------");
            Console.WriteLine("loccategories -map MAP -xml XML -out OUTFILE -lmap LCIDOUT");
            Console.WriteLine("MAP    :   The XML file containing the locale-language mapping");
            Console.WriteLine("XML    :   The path to XML files containing category locale information");
            Console.WriteLine("       :   - These files ust be Categories_*.xml");
            Console.WriteLine("OUTFILE:   File to output category name xml to");
            Console.WriteLine("LCIDOUT:   File to output lcid mapping xml to");
            Console.WriteLine("------------------------------------------------------------------");
        }
        
        static XmlDocument GenerateLcidMapXml(MapInfo mapInfo)
        {
            int nRowsTotal = 0;
            
            // Create empty template XML to process
            XmlDocument retDoc = new XmlDocument();
            retDoc.LoadXml(
                "<database dbname=\"rawcatalogdb\" xmlns=\"http://www.xboxlive.com/dml\">" +
                    "<table name=\"CategoryLocaleMap\">" +
                        "<release name=\"upgrade\" installorder=\"1300\">" +
                            "<primarykey>" +
                                "<column>categoryId</column>" +
                                "<column>lcid</column>" +
                            "</primarykey>" +
                        "</release>" +
                    "</table>" +
                "</database>" +
                ""
                );
            
            // Make sure this file is saved as utf-8 if possible
            XmlDeclaration xmlDeclaration = retDoc.CreateXmlDeclaration("1.0", "utf-8", null);
            retDoc.InsertBefore(xmlDeclaration, retDoc.DocumentElement);
            
            // This xml has a namespace... so everything is harder. Create NS manager so we can actually work with
            // this xml document
            XmlNamespaceManager mgr = new XmlNamespaceManager(retDoc.NameTable);
            mgr.AddNamespace("dml", "http://www.xboxlive.com/dml");
            
            // Get the "release" node, which all "row" nodes are a child of
            XmlNode releaseNode = retDoc.SelectSingleNode("dml:database/dml:table/dml:release", mgr);
            
            // For each locale mapping, generate entries for all the category strings
            foreach (LocaleLanguageMap map in mapInfo.LocaleLanguageMaps)
            {
                CategoryInfo[] LangInfo = mapInfo.GetLanguageInfo(map.Language);
                if (LangInfo == null)
                {
                    Console.WriteLine("WARNING: language not found: {0}", map.Language);
                    continue;
                }
                //Console.WriteLine("Processing Map Lcid={0} Lang={1} - Generating {2} rows", map.Lcid, map.Language, LangInfo.Length);
                
                // Create one row entry for each category for this locale
                foreach (CategoryInfo catInfo in LangInfo)
                {
                    XmlElement rowNode = retDoc.CreateElement("row", "http://www.xboxlive.com/dml");
                    rowNode.SetAttribute("_override", "true");
                    {
                        XmlElement idNode = retDoc.CreateElement("categoryId", "http://www.xboxlive.com/dml");
                        XmlElement lcidNode = retDoc.CreateElement("lcid", "http://www.xboxlive.com/dml");
                        XmlElement lcidMapNode = retDoc.CreateElement("lcidMap", "http://www.xboxlive.com/dml");
                        
                        idNode.InnerText = catInfo.Id;
                        lcidNode.InnerText = map.Lcid;
                        lcidMapNode.InnerText = map.Lcid;
                        
                        rowNode.AppendChild(idNode);
                        rowNode.AppendChild(lcidNode);
                        rowNode.AppendChild(lcidMapNode);
                    }
                    releaseNode.AppendChild(rowNode);
                    nRowsTotal++;
                }
            }
            
            Console.WriteLine("Generated {0} rows(s).", nRowsTotal);
            return retDoc;
        }
        
        static XmlDocument GenerateOutputXml(MapInfo mapInfo)
        {
            int nRowsTotal = 0;
            
            // Create empty template XML to process
            XmlDocument retDoc = new XmlDocument();
            retDoc.LoadXml(
                "<database dbname=\"rawcatalogdb\" xmlns=\"http://www.xboxlive.com/dml\">" +
                    "<table name=\"CategoryLocale\">" +
                        "<release name=\"upgrade\" installorder=\"1200\">" +
                            "<primarykey>" +
                                "<column>categoryId</column>" +
                                "<column>lcid</column>" +
                            "</primarykey>" +
                        "</release>" +
                    "</table>" +
                "</database>" +
                ""
                );
            
            // Make sure this file is saved as utf-8 if possible
            XmlDeclaration xmlDeclaration = retDoc.CreateXmlDeclaration("1.0", "utf-8", null);
            retDoc.InsertBefore(xmlDeclaration, retDoc.DocumentElement);
            
            // This xml has a namespace... so everything is harder. Create NS manager so we can actually work with
            // this xml document
            XmlNamespaceManager mgr = new XmlNamespaceManager(retDoc.NameTable);
            mgr.AddNamespace("dml", "http://www.xboxlive.com/dml");
            
            // Get the "release" node, which all "row" nodes are a child of
            XmlNode releaseNode = retDoc.SelectSingleNode("dml:database/dml:table/dml:release", mgr);
            
            // For each locale mapping, generate entries for all the category strings
            foreach (LocaleLanguageMap map in mapInfo.LocaleLanguageMaps)
            {
                CategoryInfo[] LangInfo = mapInfo.GetLanguageInfo(map.Language);
                if (LangInfo == null)
                {
                    Console.WriteLine("WARNING: language not found: {0}", map.Language);
                    continue;
                }
                //Console.WriteLine("Processing Lcid={0} Lang={1} - Generating {2} rows", map.Lcid, map.Language, LangInfo.Length);
                
                // Create one row entry for each category for this locale
                foreach (CategoryInfo catInfo in LangInfo)
                {
                    XmlElement rowNode = retDoc.CreateElement("row", "http://www.xboxlive.com/dml");
                    rowNode.SetAttribute("_override", "true");
                    {
                        XmlElement idNode = retDoc.CreateElement("categoryId", "http://www.xboxlive.com/dml");
                        XmlElement lcidNode = retDoc.CreateElement("lcid", "http://www.xboxlive.com/dml");
                        XmlElement nameNode = retDoc.CreateElement("name", "http://www.xboxlive.com/dml");
                        
                        idNode.InnerText = catInfo.Id;
                        lcidNode.InnerText = map.Lcid;
                        nameNode.InnerText = String.Format( "N'{0}'", catInfo.Name.Replace( "'", "''" ));
                        
                        rowNode.AppendChild(idNode);
                        rowNode.AppendChild(lcidNode);
                        rowNode.AppendChild(nameNode);
                    }
                    releaseNode.AppendChild(rowNode);
                    nRowsTotal++;
                }
            }
            
            Console.WriteLine("Generated {0} rows(s).", nRowsTotal);
            return retDoc;
        }
        
        static int Main(string[] args)
        {
            string szMapPath = null;
            string szXMLPath = null;
            string szOutputFile = null;
            string szLcidMapFile = null;

            try
            {
                for (int i = 0; i < args.Length; i++)
                {
                    if (args[i] == "-map")
                    {
                        szMapPath = args[i + 1];
                        i = i + 1;
                    }

                    if (args[i] == "-xml")
                    {
                        szXMLPath = args[i + 1];
                        i = i + 1;
                    }

                    if (args[i] == "-out")
                    {
                        szOutputFile = args[i + 1];
                        i = i + 1;
                    }

                    if (args[i] == "-lmap")
                    {
                        szLcidMapFile = args[i + 1];
                        i = i + 1;
                    }

                    if (args[i] == "/?" || args[i] == "-help")
                    {
                        Usage();
                        return 1;
                    }
                }

                if (String.IsNullOrEmpty(szMapPath))
                {
                    throw new Exception("Locale map file not specified");
                }
                
                if (String.IsNullOrEmpty(szXMLPath))
                {
                    throw new Exception("Language XML files path not specified");
                }
                
                if (String.IsNullOrEmpty(szOutputFile) || String.IsNullOrEmpty(szLcidMapFile))
                {
                    throw new Exception("Must specify output files");
                }
                //
                // Read in the locale map information
                //
                
                MapInfo mapInfo = new MapInfo();
                if (!mapInfo.Load(szMapPath, szXMLPath))
                {
                    throw new Exception("Unable to get map info");
                }
                Console.WriteLine("Read in {0} maps", mapInfo.LocaleLanguageMaps.Length);
                
                //
                // Process category information for name map
                //
                Console.WriteLine("Generating localized category names...");
                
                // Get output stream for xml
                FileInfo output = new FileInfo(szOutputFile);
                if (output.Exists)
                {
                    Console.WriteLine("WARNING: overwriting output file: {0}", szOutputFile);
                }
                
                using (TextWriter sout = output.CreateText())
                {
                    // Create output XML for all mappings
                    XmlDocument xmlOut = GenerateOutputXml(mapInfo);
                    xmlOut.Save(sout);
                    sout.Close();
                }
                
                //
                // Process category information for map file
                //
                Console.WriteLine("Generating category Lcid maps...");
                
                // Get output stream for xml
                output = new FileInfo(szLcidMapFile);
                if (output.Exists)
                {
                    Console.WriteLine("WARNING: overwriting output file: {0}", szLcidMapFile);
                }
                
                using (TextWriter sout = output.CreateText())
                {
                    XmlDocument xmlOut = GenerateLcidMapXml(mapInfo);
                    xmlOut.Save(sout);
                    sout.Close();
                }
                
                Console.WriteLine("Done.");
                
                return 0;
            }
            catch (Exception ex)
            {
                Console.Error.WriteLine("LocCategories failed.");
                Console.Error.WriteLine(ex.ToString());

                return 1;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\loccategories\obj\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=msil_loccategories_none_12.4.56.0_none_72b451590bc1fc59
ASSEMBLY_IDENTITY_XP_KEY_FORM=msil_loccategories_no-public-key_12.4.56.0_x-ww_591c5a7f
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=loccategories
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=msil
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=msil_loccategories_no-public-key_12.4.56.0_x-ww_591c5a7f
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=msil_loccategories_no-public-key_12.4.56.0_x-ww_591c5a7f.manifest
XP_MANIFEST_PATH=manifests\msil_loccategories_no-public-key_12.4.56.0_x-ww_591c5a7f.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=msil_loccategories_no-public-key_12.4.56.0_x-ww_591c5a7f.cat
XP_CATALOG_PATH=manifests\msil_loccategories_no-public-key_12.4.56.0_x-ww_591c5a7f.cat
XP_PAYLOAD_PATH=msil_loccategories_no-public-key_12.4.56.0_x-ww_591c5a7f
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=loccategories,processorArchitecture=msil,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\logcollate\makefile.inc ===
!include $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\loccategories\objd\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=msil_loccategories_none_12.4.56.0_none_72b451590bc1fc59
ASSEMBLY_IDENTITY_XP_KEY_FORM=msil_loccategories_no-public-key_12.4.56.0_x-ww_591c5a7f
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=loccategories
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=msil
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=msil_loccategories_no-public-key_12.4.56.0_x-ww_591c5a7f
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=msil_loccategories_no-public-key_12.4.56.0_x-ww_591c5a7f.manifest
XP_MANIFEST_PATH=manifests\msil_loccategories_no-public-key_12.4.56.0_x-ww_591c5a7f.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=msil_loccategories_no-public-key_12.4.56.0_x-ww_591c5a7f.cat
XP_CATALOG_PATH=manifests\msil_loccategories_no-public-key_12.4.56.0_x-ww_591c5a7f.cat
XP_PAYLOAD_PATH=msil_loccategories_no-public-key_12.4.56.0_x-ww_591c5a7f
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=loccategories,processorArchitecture=msil,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\logcollate\exe\obj\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("DEPOT")]
[assembly:System.Reflection.AssemblyCopyright("")]
[assembly:System.Reflection.AssemblyCompany("")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\logcollate\exe\objd\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("DEPOT")]
[assembly:System.Reflection.AssemblyCopyright("")]
[assembly:System.Reflection.AssemblyCompany("")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\logcollate\LogParser.cs ===
using System;
using System.Collections;
using System.Collections.Generic;
using System.Text;
using System.IO;
using xonline.common.logline;

namespace xonline.common.logcollate
{
    class LogParser
    {
        protected LogResults m_logResults;
        protected LogLineUtil m_logLineUtil;


        private LogParser()
        {
            //Forcing Private so they have to pass in a results object for us to log to.
            m_logLineUtil = new LogLineUtil();
            m_logResults = new LogResults();
        }

        public LogParser(LogResults logResults)
        {
            if (logResults == null)
                throw new ArgumentNullException("logResults", "The LogResults Object cannot be null");
            m_logResults = logResults;
            m_logLineUtil = new LogLineUtil();
        }

        public void ParseFile(string logFilename)
        {
            using (StreamReader fileReader = File.OpenText(logFilename))
            {
                using (TextWriter errorConsole = Console.Error)
                {
                    string logLine = "";
                    ulong currentLineNum = 0;
                    LogLineClass parsedLogLine;
                    while ((logLine = fileReader.ReadLine()) != null)
                    {
                        currentLineNum++;
                        parsedLogLine = m_logLineUtil.ParseLogLine(logLine);

                        if (parsedLogLine != null)
                        {
                            m_logResults.AddResult(parsedLogLine.CallTime, parsedLogLine.ApiName, parsedLogLine);
                        }
                        else
                        {
                            errorConsole.WriteLine("Error parsing log at line: {0}", currentLineNum);
                        }
                    }
                    errorConsole.Close();
                }
                fileReader.Close();
            }
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\loccategories\mapinfo.cs ===
using System;
using System.Text;
using System.Collections;
using System.IO;
using System.Xml;

namespace xonline.tools.loccategories
{
    class MapInfo
    {
        private Hashtable languages;
        private LocaleLanguageMap[] localeLanguageMaps;
        
        public MapInfo()
        {
            languages = null;
            localeLanguageMaps = null;
        }
        
        public CategoryInfo[] GetLanguageInfo(string language)
        {
            if (languages != null && languages.ContainsKey(language))
            {
                return (CategoryInfo[])languages[language];
            }
            else
            {
                return null;
            }
        }
        
        public LocaleLanguageMap[] LocaleLanguageMaps
        {
            get
            {
                return localeLanguageMaps;
            }
        }
        
        public bool Load(string mapFileName, string languageFilesPath)
        {
            try
            {
                // load the map file
                XmlDocument domLocaleMap = new XmlDocument();
                domLocaleMap.Load(mapFileName);
                
                // Make sure the path to the language files exist
                DirectoryInfo locPath = new DirectoryInfo(languageFilesPath);
                if (!locPath.Exists)
                {
                    Console.Error.WriteLine("Xml path not found");
                }
                else
                {
                    // Load all the language files
                    if (GetLanguageFiles(domLocaleMap, locPath))
                    {
                        // Get the mappings we need to process
                        if (GetLocaleMap(domLocaleMap))
                        {
                            return true;
                        }
                    }
                }
            }
            catch (Exception ex)
            {
                Console.Error.WriteLine("LocCategories: loading map file settings failed.");
                Console.Error.WriteLine(ex.ToString());
            }
            return false;
        }
        
        private bool GetLocaleMap(XmlDocument domLocaleMap)
        {
            XmlNodeList localeMappings = domLocaleMap.SelectNodes("Maps/LocaleMap/Locale");
            if (null == localeMappings)
            {
                Console.Error.WriteLine("No category mappings found");
                return false;
            }
            
            localeLanguageMaps = new LocaleLanguageMap[localeMappings.Count];
            for(int i=0; i<localeMappings.Count; i++)
            {
                localeLanguageMaps[i] = new LocaleLanguageMap();
                localeLanguageMaps[i].Lcid = Common.GetAttribute(localeMappings[i], "id");
                localeLanguageMaps[i].Language = Common.GetAttribute(localeMappings[i], "language");
            }
            return true;
        }
        
        private bool GetLanguageFiles(XmlDocument domLocaleMap, DirectoryInfo dir)
        {
            languages = new Hashtable();
            
            // Find file list
            XmlNodeList LanguageFileList = domLocaleMap.SelectNodes("Maps/LanguageFiles/File");
            if (null == LanguageFileList)
            {
                Console.Error.WriteLine("No Language files specified");
                return false;
            }
            
            // Process each file
            foreach (XmlNode langFile in LanguageFileList)
            {
                string lang = Common.GetAttribute(langFile,"language");
                string fileName = langFile.InnerText;
                
                // Make sure this language has not been processed already
                if (languages.ContainsKey(lang))
                {
                    Console.Error.WriteLine("Multiple entries for language found");
                    return false;
                }
                
                // Find full path for this file
                FileInfo langFileInfo = new FileInfo(Path.Combine(dir.FullName,fileName));
                if (!langFileInfo.Exists)
                {
                    Console.Error.WriteLine("Language file does not exist!");
                    return false;
                }
                
                // Load category info for this language
                XmlDocument LangInfo = new XmlDocument();
                LangInfo.Load(langFileInfo.FullName);
                
                // Get list of all the category names
                XmlNodeList Categories = LangInfo.SelectNodes("Loc/name");
                if (Categories.Count == 0)
                {
                    Console.WriteLine("WARNING: No Category names in {0}", langFileInfo.Name);
                    continue;
                }
                
                // Copy appropiate information into an array for easier processing later
                ArrayList cats = new ArrayList();
                for(int i=0; i<Categories.Count; i++)
                {
                    // Make sure this string is supposed to be localized
                    if (!Common.GetAttribute(Categories[i], "localize").Equals("false"))
                    {
                        CategoryInfo catInfo = new CategoryInfo();
                        catInfo.Id = Common.GetAttribute(Categories[i], "categoryId");
                        catInfo.Name = Categories[i].InnerText;
                        cats.Add(catInfo);
                    }
                }
                
                CategoryInfo[] CategoryInfoArray = new CategoryInfo[cats.Count];
                for(int i=0; i<cats.Count; i++)
                {
                    CategoryInfoArray[i] = (CategoryInfo)cats[i];
                }
                
                // Save this language information
                //Console.WriteLine("Processed language {0}: {1} categories, {2} localized", lang, Categories.Count, cats.Count);
                languages.Add(lang,CategoryInfoArray);
            }
            return true;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\logview\exe\obj\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("DEPOT")]
[assembly:System.Reflection.AssemblyCopyright("")]
[assembly:System.Reflection.AssemblyCompany("")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\logcollate\logcollate.cs ===
using System;
using System.Collections.Generic;
using System.Text;
using System.IO;

namespace xonline.common.logcollate
{
    class LogCollator
    {
        LogCollator()
        {
        }

        static void Main(string[] args)
        {
            try
            {
                string inputFileName = "";
                string resultsFileName = "";
                LogParser logParser;
                LogResults logResults;

                if (ParseCommandLine(ref inputFileName, ref resultsFileName, args) == false)
                {
                    PrintUsage();
                }
                else
                {
                    logResults = new LogResults();
                    logParser = new LogParser(logResults);

                    DateTime startTime = DateTime.Now;
                    // Parse the file
                    logParser.ParseFile(inputFileName);

                    // Output Results
                    logResults.WriteResults(resultsFileName);
                    TimeSpan runTime = DateTime.Now - startTime;
                    Console.WriteLine("LogCollate completed in {0} second(s).", runTime.TotalSeconds);
                }
            }
            catch (Exception ex)
            {
                Console.WriteLine("Global Exception Caught:");
                Console.WriteLine("{0}", ex.ToString());
            }
        }

        static bool ParseCommandLine(ref string inFile, ref string outFile, string[] commandLine)
        {
            bool retVal = true;
            if (commandLine.Length != 2)
                return false;

            inFile = commandLine[0];
            if (!File.Exists(inFile))
            {
                Console.WriteLine("Input file {0} does not exist", inFile);
                retVal = false;
            }

            outFile = commandLine[1];
            if (File.Exists(outFile) && ((File.GetAttributes(outFile) & FileAttributes.ReadOnly) == FileAttributes.ReadOnly))
            {
                Console.WriteLine("Output file {0} is Read-Only", outFile);
                retVal = false;
            }

            return retVal;
        }

        static void PrintUsage()
        {
            Console.WriteLine("Usage:");
            Console.WriteLine("\tLogCollate.exe <AppLog1.txt> <ResultsFile.csv>");
            Console.WriteLine("\tLogCollate.exe /help - Display this message");
            Console.WriteLine();
            Console.WriteLine("\tAppLog1.txt - AppLog files you want parsed and collated");
            Console.WriteLine("\tResultsFile.csv - Output file where you want the collated results");
            Console.WriteLine();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\logcollate\LogResults.cs ===
using System;
using System.Collections.Generic;
using System.Text;
using System.IO;
using System.Xml;
using xonline.common.logline;

namespace xonline.common.logcollate
{
    class LogResults
    {
        protected DateTime m_StartTime;
        protected DateTime m_EndTime;
        protected ulong m_TotalCalls;
        protected Dictionary<string, APIInfo> m_APIList;

        public LogResults()
        {
            m_TotalCalls = 0;
            m_StartTime = DateTime.MinValue;
            m_EndTime = DateTime.MinValue;
            m_APIList = new Dictionary<string, APIInfo>();
        }

        public void AddResult(DateTime apitime, string apiname, LogLineClass parameters)
        {
            if ((apitime != null) && (apitime != DateTime.MinValue))
            {
                if ((m_StartTime == DateTime.MinValue) || (apitime.CompareTo(m_StartTime) < 0))
                {
                    m_StartTime = apitime;
                }
                if ((m_EndTime == DateTime.MinValue) || (apitime.CompareTo(m_EndTime) > 0))
                {
                    m_EndTime = apitime;
                }
            }

            if (m_APIList.ContainsKey(apiname))
            {
                m_APIList[apiname].CallCount++;

                // it won't let me just increment the current Call Count directly so I have to create a new one with an incremented value and assign it
                //APIInfo newApiInfo = new APIInfo();
                //newApiInfo.CallCount = m_APIList[apiname].CallCount + 1;
                //newApiInfo.ParameterSummary = "";

                //m_APIList[apiname] = newApiInfo;
            }
            else
            {
                APIInfo newApiInfo = new APIInfo();
                newApiInfo.CallCount = 1;
                newApiInfo.ParameterSummary = parameters;

                //Add will throw if the API already exists
                m_APIList.Add(apiname, newApiInfo);
            }
            m_TotalCalls++;
        }

        public void WriteResults(string resultsFilename)
        {
            if (File.Exists(resultsFilename))
            {
                File.Delete(resultsFilename);
            }

            using (StreamWriter sw = File.CreateText(resultsFilename))
            {
                // Write the Header line
                WriteResultsLine(sw, "API Name", "Total Calls", "TPS", "Ratio");
                WriteOverallResults(sw);
                WriteAPIResults(sw);
                sw.Close();
            }
        }

        protected void WriteOverallResults(StreamWriter fileStream)
        {
            string totalTPS = GetTPS(m_TotalCalls);
            string totalRatio = GetTransactionRatio(m_TotalCalls);
            WriteResultsLine(fileStream, "All", m_TotalCalls.ToString(), totalTPS, totalRatio);
        }

        protected void WriteAPIResults(StreamWriter fileStream)
        {
            foreach (KeyValuePair<string, APIInfo> apiEntry in m_APIList)
            {
                string apiTPS = GetTPS(apiEntry.Value.CallCount);
                string apiRatio = GetTransactionRatio(apiEntry.Value.CallCount);
                WriteResultsLine(fileStream, apiEntry.Key, apiEntry.Value.CallCount.ToString(), apiTPS, apiRatio);
            }
        }

        protected string GetTPS(ulong transactions)
        {
            string tpsstring = "";
            double totalseconds;
            TimeSpan totaltime = m_EndTime - m_StartTime;
            totalseconds = totaltime.TotalSeconds;

            if (totalseconds == 0)
            {
                tpsstring = "N/A";
            }
            else
            {
                double temptransactions = transactions;
                double tps = temptransactions / totalseconds;
                tpsstring = tps.ToString();
            }

            return tpsstring;
        }

        protected string GetTransactionRatio(ulong transactions)
        {
            string trstring = "";
            if (m_TotalCalls == 0)
            {
                trstring = "N/A";
            }
            else
            {
                double transactionratio = (double)transactions / (double)m_TotalCalls;
                trstring = transactionratio.ToString();
            }

            return trstring;
        }

        protected void WriteResultsLine(StreamWriter fileStream, string API, string TransactionCount, string TPS, string TransactionRatio)
        {
            fileStream.WriteLine("{0},{1},{2},{3}", CSVEncode(API), CSVEncode(TransactionCount), CSVEncode(TPS), CSVEncode(TransactionRatio));
        }

        protected string CSVEncode(string normalString)
        {
            string csvstring = normalString;
            bool needsquotes = false;

            // If it has leading or trailing space it needs to be quoted
            if ((normalString.Trim() != normalString) || (normalString.Contains(",") == true))
            {
                needsquotes = true;
            }
            // If it has a " we need to make it a ""
            if (normalString.Contains("\"") == true)
            {
                needsquotes = true;
                csvstring = csvstring.Replace("\"", "\"\"");
            }

            // If it has a need for quotes, do it now
            if (needsquotes == true)
            {
                csvstring = String.Format("\"{0}\"", csvstring);
            }

            return csvstring;
        }
    }

    public class APIInfo
    {
        public ulong CallCount;
        public LogLineClass ParameterSummary;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\logview\exe\objd\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("DEPOT")]
[assembly:System.Reflection.AssemblyCopyright("")]
[assembly:System.Reflection.AssemblyCompany("")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\MachineBan\console\BanClasses.cs ===
using System;
using System.Collections.Generic;
using System.Text;

namespace xonline.tools.machineban
{
    interface IBannable
    {
        void Ban();
        void UnBan();
        void LookUp();
        void Reset();

        List<string> GetBanObjectStrings();
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\MachineBan\console\makefile.inc ===
!include $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\MachineBan\console\MachineBan.cs ===
/*!----------------------------------------------------------------------------
Some notes on future code improvement:
    * I don't like the current error handling mechanism.  We do a lot of
      on-the-spot error handling instead of a designed error handling
      mechanism.  This is probably OK because this is a sufficiently
      simple program but if it gets much larger we will want to look at it.

    * A corollary to the first note, there also isn't a good definition
      of what error level this tool should set in the command window.
      If we want to use this tool in scripts we will want a more
      consistent story here.

    * This is not a terrible "object-oriented" design.  It's really just
      a bunch of static functions and frankly there's too much information
      sharing between some of the functions.  This could be redesigned
      but again I think it's fine for the current size of this program.
-----------------------------------------------------------------------------*/

using System;
using System.Collections.Generic;
using System.Data.SqlClient;
using System.Globalization;
using System.IO;
using System.Security.Cryptography;
using System.Text;
using System.Threading;
using System.Reflection;

using Microsoft.Webstore.WstClient;

using xonline.common.config;
using xonline.common.mgmt;
using xonline.common.service;
using xonline.common.sql.webstore;
using xonline.common.tools.console;

using xonline.server.xmachine.fd.soap;

namespace xonline.tools.machineban
{
    class CMachineBanApp
    {
        [STAThread]
        static int Main(string[] _args)
        {
            try
            {
               XomLoggingControl.Init();
            }
            catch (Exception e)
            {
                Console.WriteLine("Error!");
                Console.WriteLine(e.ToString());
                return -1;
            }

            try
            {
                if (!Configuration.Parse(_args))
                {
                    if (!Configuration.Help)
                        Console.Write("Invalid parameters!\n");

                    Help();
                    return -1;
                }

                //if we are just doing a check ready then we only perform
                //the checkready call and exit
                if (Configuration.CheckReady)
                {
                    if (!CheckReady())
                        return -1;

                    return 0;
                }

                // Get the list of machine puids to ban.  This is surprisingly complicated.
                // First, we allow this command to be invoked with a single machine id on
                // the command-line or with a list from a file.  Second, they might be
                // console ids instead of puids.  Finally, the puid may be a PC puid,
                // which takes special logic or the id could be a 5x5 token.  Amazing.
                // Also, we need to keep track of the tokenhashes themselves so we can
                // mark them as invalid or valid.
                List<InvalidRawID> invalidRawIds = null;
                List<IBannable> banObjects = null;
                GetBannables(out banObjects, out invalidRawIds);

                foreach (InvalidRawID badRawId in invalidRawIds)
                {
                    Console.WriteLine(String.Format(
                        "    {0:D5}: {1} - {2} ({3})",
                        0, //We keep this part of the output so the format remains consistant with the success lines
                        badRawId.RawId,
                        badRawId.Failure,
                        badRawId.Message
                        ));
                }

                bool banOnce = CallBannables(banObjects);

                if (!banOnce)
                {
                    Console.WriteLine("Nothing valid to ban/unban/lookup/reset");
                    return -1;
                }


            }
            catch (Exception e)
            {
                Console.WriteLine("Error!");
                Console.WriteLine(e.ToString());
                return -1;
            }
            finally
            {
                XomLoggingControl.Close();
            }

            return 0;
        }

        private static void GetBannables(out List<IBannable> banObjects, out List<InvalidRawID> invalidRawIds)
        {
            if (Configuration.ConsoleId == true)
            {
                MachineIdConvert.BannablesFromConsoleIds(out banObjects, out invalidRawIds);
            }
            else if (Configuration.FiveByFive == true)
            {
                MachineIdConvert.BannablesFromFiveByFives(out banObjects, out invalidRawIds);
            }
            else
            {
                MachineIdConvert.BannablesFromPuids(out banObjects, out invalidRawIds);
            }
        }

        private static bool CallBannables(IEnumerable<IBannable> banObjects)
        {
            bool banOnce = false;

            if (banObjects == null)
                return banOnce;

            foreach (IBannable banObj in banObjects)
            {
                banOnce = true;

                try
                {
                    if (Configuration.Ban)
                    {
                        banObj.Ban();

                        if (Configuration.Reset)
                            banObj.Reset();
                    }
                    else if (Configuration.UnBan)
                    {
                        banObj.UnBan();

                        if (Configuration.Reset)
                            banObj.Reset();
                    }
                    else if (Configuration.Lookup)
                    {
                        banObj.LookUp();
                    }
                    else if (Configuration.Reset)
                    {
                        banObj.Reset();
                    }
                    else
                    {
                        Console.WriteLine("Configuration not recognized, must be ban/unban/lookup/reset");
                        banOnce = false;
                        break;
                    }
                }
                catch(Exception e)
                {
                    List<string> banObjectStrings = banObj.GetBanObjectStrings();
                    int count = 0;
                    foreach (string failedBanObject in banObjectStrings)
                    {
                        Console.WriteLine(String.Format(
                            "    {0:D5}: {1} - 0x{2:X8} ({3})",
                            count,
                            failedBanObject,
                            HResult.E_FAIL,
                            e.Message
                            ));
                        ++count;
                    }

                    //this just applies to this batch, so only this batch fails
                    //continue processing any remaining batches.
                    continue;
                }
            }
            return banOnce;
        }

        private static bool CheckReady()
        {
            bool result = true;

            Console.WriteLine("\r\n=======================================");
            Console.WriteLine("\r\nM A C H I N E  B A N");
            Console.WriteLine("\r\nv " + Assembly.GetExecutingAssembly().GetName().Version.ToString());
            Console.WriteLine("\r\n=======================================");
            Console.WriteLine("\r\nExe location: " + Path.GetDirectoryName(Assembly.GetExecutingAssembly().Location));
            Console.WriteLine("\r\n===================");
            Console.WriteLine("Commencing Checks...");
            Console.Write("\r\n+Checking XMachine Connection...");

            try
            {
                XMachineSoapClient connection = new XMachineSoapClient();

                if (connection != null)
                {
                    Console.WriteLine("PASS");
                    Console.Write("\r\n+Calling XMachine Test Method...");

                    string testConnection = connection.TestConnection("Connection Successful");

                    if (!String.IsNullOrEmpty(testConnection))
                    {
                        Console.WriteLine("PASS");
                    }
                    else
                    {
                        Console.WriteLine("FAIL");
                        result = false;
                    }
                }
                else
                {
                    Console.WriteLine("FAIL");
                }
            }
            catch (Exception e)
            {
                Console.WriteLine("FAIL");
                Console.WriteLine(e.Message);
                result = false;
            }

            Console.WriteLine("\r\nChecks Completed.");

            return result;
        }

        private static void Help()
        {
            Console.WriteLine("MachineBan {commands} [options]");
            Console.WriteLine("/?  Displays this help message.");
            Console.WriteLine("");
            Console.WriteLine("    -- COMMANDS -- ");
            Console.WriteLine("");
            Console.WriteLine("{/ban:<id> | /unban:<id> | /lookup:<id> /reset:<id>}");
            Console.WriteLine("{/ban | /unban | /lookup | /reset} and {/file:<FileName>} ");
            Console.WriteLine("{/checkready }");
            Console.WriteLine("");
            Console.WriteLine("     /ban:<id>        Bans the specified console.");
            Console.WriteLine("     /unban:<id>      Unbans the specified console.");
            Console.WriteLine("     /lookup:<id>     Lookup the specified console bans.");
            Console.WriteLine("     /reset:<id>      Reset the machine key (Xbox360 only).");
            Console.WriteLine("     /file:<FileName> Use file instead of individual command line.");
            Console.WriteLine("                      Can only use one platform type in a file.");
            Console.WriteLine("                      One entry per line.");
            Console.WriteLine("     /checkready      Verify if this tool has access to necessary resources, and exit.");
            Console.WriteLine("");
            Console.WriteLine("    -- OPTIONS -- ");
            Console.WriteLine("");
            Console.WriteLine("[/fivebyfive | /consoleid]");
            Console.WriteLine("");
            Console.WriteLine("     /fivebyfive   Ids are 5x5 vouchers for panorama.  Bans are machine puids and vouchers.");
            Console.WriteLine("     /consoleid    Ids are console ids.  Bans are consoles ids and machine puids. (Xbox360 only).");
            Console.WriteLine("     (default)     Ids are machine puids.  Bans are only machine puids.");
            Console.WriteLine("");
            Console.WriteLine("{/ban:<id> | /ban /file:<FileName>} [/reason | /startdate | /enddate | /dateformat]");
            Console.WriteLine("");
            Console.WriteLine("     /reason       Override default banning reason (default: 0x8015190D).");
            Console.WriteLine("     /startdate    Override default startdate (default: Now).");
            Console.WriteLine("     /enddate      Override detault enddate (default: 9999-12-31).");
            Console.WriteLine("     /dateformat   Override default date format (default: 'yyyy-MM-dd').");
            Console.WriteLine("");
            Console.WriteLine("EXAMPLES: ");
            Console.WriteLine("     /checkready");
            Console.WriteLine("     /ban:0xFA00000000000000");
            Console.WriteLine("     /consoleid /ban:XE.111111111111");
            Console.WriteLine("     /fivebyfive /ban:ABCDE-ABCDE-ABCDE-ABCDE-ABCDE");
            Console.WriteLine("     /ban /file:MyMachineList.txt");
            Console.WriteLine("");
            Console.WriteLine("     /unban:0xFA00000000000000");
            Console.WriteLine("");
            Console.WriteLine("     /lookup:0xFA00000000000000");
            Console.WriteLine("");
            Console.WriteLine("     /reset:0xFA00000000000000");
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\MachineBan\console\BanMachinePuid.cs ===
using System;
using System.Collections;
using System.Collections.Generic;
using System.Data;
using System.Text;

using xonline.common.config;
using xonline.common.mgmt;
using xonline.common.service;
using xonline.common.sql.webstore;
using xonline.server.xmachine.fd.soap;

using Microsoft.Webstore.WstClient;

namespace xonline.tools.machineban
{
    class BanMachinePuid : IBannable
    {
        private HResult    ReasonCode = HResult.XONLINE_E_LOGON_XBOX_ACCOUNT_BANNED;
        private List<Puid> PuidList;
        private static int CurrentInstances = 0;
        private int        Instance;
        private static     HashSet<Puid> ProcessedPuidList = new HashSet<Puid>();

        internal BanMachinePuid()
        {
            PuidList = new List<Puid>();
            Instance = CurrentInstances++;
        }

        public void AddMachine(Puid puid)
        {
            if (PuidList.Contains(puid) == false)
            {
                PuidList.Add(puid);
            }
        }

        /// <summary>
        /// Public Interface to Ban all machine puids known to this instance
        /// </summary>
        public void Ban()
        {
            if (PuidList == null || PuidList.Count == 0)
            {
                return;
            }

            MachinePuidResult[] banResults = new MachinePuidResult[0];

            if (Configuration.BatchSize > 1) //redundant to have batch status when batch size is 1
            {
                Console.WriteLine(
                    String.Format(
                        "{0:D5} BanMachinePuid {1} Machines", 
                        Instance, 
                        PuidList.Count
                        )
                    );
            }

            //Check Process Table against PuidList
            List<Puid> verifiedPuidList = CheckProcessedPuidsInternal(PuidList);

            if (verifiedPuidList.Count == 0)
            {
                return;
            }

            // Turn the array list into an array
            ulong[] MachineList = Array.ConvertAll(verifiedPuidList.ToArray(), (u => (ulong)(u)));

            try
            {
                if (Configuration.Reason != HResult.S_OK)
                {
                    ReasonCode = Configuration.Reason;
                }

                XMachineSoapClient connection = new XMachineSoapClient();

                banResults = connection.BanMachinePuids(
                    MachineList,
                    ReasonCode,
                    Configuration.StartDate,
                    Configuration.EndDate
                    );
            }
            catch (Exception e)
            {
                Xom.NtEvent(
                    XEvent.Id.MB_BAN_FAILED,
                    "Failed to ban machines.\nMachineList = " + 
                    String.Join(
                        ",",
                        Array.ConvertAll(
                            PuidList.ToArray(),
                            ( u => u.ToString() )
                            )
                        ) +
                    "\nException = " + e.ToString()
                    );
                throw e;
            }

            for (int i = 0; i < banResults.Length; ++i)
            {
                //
                // Should we event on successfull ban? Seems to be something 
                // that might be worth keeping track off
                // 
                Console.WriteLine(
                    "    {0:D5}: {1} - {2}",
                    i,
                    (Puid) banResults[i].MachinePuid,
                    (HResult) banResults[i].Result
                    );
                if ( ( (HResult) banResults[i].Result).IsFailure())
                {
                    Xom.NtEvent(
                        XEvent.Id.MB_BAN_FAILED,
                        "Failed to ban machine = " + (Puid) banResults[i].MachinePuid +
                        "\n"
                        );
                }

                //add the procssed puid and result to the cache
                AddProcessedPuidInternal((Puid)banResults[i].MachinePuid);
            }
        }

        /// <summary>
        /// Public Interface to Unban all machine puids known to this instance
        /// </summary>
        public void UnBan()
        {
            if (PuidList == null || PuidList.Count == 0)
            {
                return;
            }

            MachinePuidResult[] banResults = new MachinePuidResult[0];

            if (Configuration.BatchSize > 1) //redundant to have batch status when batch size is 1
            {
                Console.WriteLine(
                    String.Format(
                        "{0:D5} UnbanMachinePuid {1} Machines", 
                        Instance, 
                        PuidList.Count
                        )
                    );
            }

            //Check Process Table against PuidList
            List<Puid> verifiedPuidList = CheckProcessedPuidsInternal(PuidList);

            if (verifiedPuidList.Count == 0)
            {
                return;
            }

            // Turn the array list into an array
            ulong[] MachineList = Array.ConvertAll(verifiedPuidList.ToArray(), (u => (ulong)(u)));

            try
            {
                if (Configuration.Reason != HResult.S_OK)
                {
                    ReasonCode = Configuration.Reason;
                }

                XMachineSoapClient connection = new XMachineSoapClient();

                banResults = connection.UnbanMachinePuids(
                    MachineList,
                    ReasonCode
                    );
            }
            catch (Exception e)
            {
                Xom.NtEvent(
                    XEvent.Id.MB_UNBAN_FAILED,
                    "Failed to unban machines.\nMachineList = " + 
                    String.Join(
                        ",",
                        Array.ConvertAll(
                            PuidList.ToArray(),
                            ( u => u.ToString() )
                            )
                        ) +
                    "\nException = " + e.ToString()
                    );
                throw e;
            }

            for (int i = 0; i < banResults.Length; ++i)
            {
                //
                // Should we event on successfull ban? Seems to be something 
                // that might be worth keeping track off
                // 
                Console.WriteLine(
                    "    {0:D5}: {1} - {2}",
                    i,
                    (Puid) banResults[i].MachinePuid,
                    (HResult) banResults[i].Result
                    );
                if ( ( (HResult) banResults[i].Result).IsFailure())
                {
                    Xom.NtEvent(
                        XEvent.Id.MB_UNBAN_FAILED,
                        "Failed to unban machine = " + (Puid) banResults[i].MachinePuid +
                        "\n"
                        );
                }

                //add the procssed puid and result to the cache
                AddProcessedPuidInternal((Puid)banResults[i].MachinePuid);
            }
        }

        public void LookUp()
        {
            if (PuidList == null || PuidList.Count == 0)
            {
                return;
            }

            MachineBanInfo[] machineBanInfo = new MachineBanInfo[0];

            if (Configuration.BatchSize > 1) //redundant to have batch status when batch size is 1
            {
                Console.WriteLine(
                    String.Format(
                        "{0:D5} LookupBanMachinePuid {1} Machines",
                        Instance,
                        PuidList.Count
                        )
                    );
            }

            // Turn the array list into an array
            ulong[] MachineList = Array.ConvertAll(PuidList.ToArray(), (u => (ulong)(u)));

            try
            {
                XMachineSoapClient connection = new XMachineSoapClient();

                machineBanInfo = connection.LookupMachineBansByMachinePuids(MachineList);
                               
                if (machineBanInfo.Length > 0)
                {
                    DisplayBanInfo(machineBanInfo);
                }
                else
                {
                    Console.WriteLine("Machine Puid Lookup returned no results.");
                }
            }
            catch (Exception e)
            {
                Console.WriteLine("Machine Puid Lookup failed.");
                throw e;
            }
        }

        public void DisplayBanInfo(MachineBanInfo[] machineBanInfo)
        {
            for (int i = 0; i < machineBanInfo.Length; ++i)
            {
                Console.WriteLine(
                    "    {0:D5}: {1} - {2} - {3} - {4}",
                    i,
                    (Puid)machineBanInfo[i].MachinePuid,
                    (HResult)machineBanInfo[i].ReasonCode,
                    (String)machineBanInfo[i].BanStart.ToString(),
                    (String)machineBanInfo[i].BanEnd.ToString()
                    );
            }
        }

        public void Reset()
        {
            if (PuidList == null || PuidList.Count == 0)
            {
                return;
            }

            //we have machinepuids but we have to convert them to 
            //consoleids first
            MachinePuidInfo[] machinePuidInfos = new MachinePuidInfo[0];

            if (Configuration.BatchSize > 1) //redundant to have batch status when batch size is 1
            {
                Console.WriteLine(
                    String.Format(
                        "{0:D5} ResetByMachinePuid {1} Machines - Getting ConsoleIds",
                        Instance,
                        PuidList.Count
                        )
                    );
            }

            // Turn the array list into an array
            ulong[] MachineList = Array.ConvertAll(PuidList.ToArray(), (u => (ulong)(u)));

            // Lookup console IDs from machine puids and print out any that are not valid
            XMachineSoapClient connection = new XMachineSoapClient();

            machinePuidInfos = connection.LookupConsoleIdsByMachinePuids(MachineList);

            foreach (ulong puidAttempted in MachineList)
            {
                bool found = false;
                foreach (MachinePuidInfo returnedInfo in machinePuidInfos)
                {
                    if (returnedInfo.MachinePuid == puidAttempted)
                    {
                        found = true;
                        break;
                    }
                }

                if (!found)
                {
                    Console.WriteLine(
                        "    {0:D5}: {1} - {2}",
                        0,
                        string.Format("0x{0:X16}", puidAttempted),
                        string.Format("0x{0:X8}", HResult.E_FAIL)
                        );
                }
            }

            // Do the reset on console IDs
            if (machinePuidInfos.Length > 0)
            {
                ResetConsoleIdsInternal(machinePuidInfos);
            }
        }

        //once we have the machine puid list return the console id equivalents
        //then we can go ahead and process the reset
        private void ResetConsoleIdsInternal(MachinePuidInfo [] machinePuidInfos)
        {
            ConsoleIdResult[] resultResetInfo = new ConsoleIdResult[0];

            if (Configuration.BatchSize > 1) //redundant to have batch status when batch size is 1
            {
                Console.WriteLine(
                    String.Format(
                        "{0:D5} ResetByConsoleId by MachinePuid {1} Machines",
                        Instance,
                        machinePuidInfos.Length
                        )
                    );
            }

            //pull out the string consoleids into a specific list
            List<string> ConsoleIds = new List<string>();

            for (int i = 0; i < machinePuidInfos.Length; ++i)
            {
                ConsoleIds.Add(machinePuidInfos[i].ConsoleId);
            }

            XMachineSoapClient connection = new XMachineSoapClient();

            resultResetInfo = connection.ResetMachinePasswordByConsoleIds(ConsoleIds.ToArray());

            DisplayResetInfo(resultResetInfo);
        }

        public void DisplayResetInfo(ConsoleIdResult[] resultResetInfo)
        {
            for (int i = 0; i < resultResetInfo.Length; ++i)
            {
                Console.WriteLine(
                    "    {0:D5}: {1} - {2}",
                    i,
                    PuidList[i].ToString(),
                    (HResult)resultResetInfo[i].Result
                    );
            }
        }

        public List<string> GetBanObjectStrings()
        {
            List<string> banObjectStrings = new List<string>();
            foreach (Puid puid in PuidList)
            {
                banObjectStrings.Add(puid.ToString());
            }

            return banObjectStrings;
        }

        private List<Puid> CheckProcessedPuidsInternal(List<Puid> checkPuidList)
        {
            List<Puid> cPuidList = new List<Puid>();

            if (ProcessedPuidList.Count == 0)
            {
                cPuidList = checkPuidList;
                return cPuidList;
            }

            //loop through puid list, if we have not processed
            //it before then add it back to the list otherwise
            //skip it
            foreach (Puid cPuid in checkPuidList)
            {
                if (!ProcessedPuidList.Contains(cPuid))
                {
                    cPuidList.Add(cPuid);
                }
            }

            return cPuidList;
        }

        private void AddProcessedPuidInternal(Puid pPruid)
        {
            if (pPruid == 0)
            {
                return;
            }

            if (!ProcessedPuidList.Contains(pPruid))
            {
                ProcessedPuidList.Add(pPruid);
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\MachineBan\console\exe\obj\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("DEPOT")]
[assembly:System.Reflection.AssemblyCopyright("")]
[assembly:System.Reflection.AssemblyCompany("")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\logview\MainForm.cs ===
using System;
using System.Drawing;
using System.Collections;
using System.ComponentModel;
using System.Windows.Forms;
using System.Data;

using xonline.common.logline;

namespace logview
{
    /// <summary>
    /// Summary description for MainForm.
    /// </summary>
    public class MainForm : System.Windows.Forms.Form
    {
        private System.Windows.Forms.RichTextBox rtbLogLines;
        private System.Windows.Forms.RichTextBox rtbExplanation;
        private System.Windows.Forms.Button btnExplain;
        private System.Windows.Forms.Button btnPaste;
        /// <summary>
        /// Required designer variable.
        /// </summary>
        private System.ComponentModel.Container components = null;
        private System.Windows.Forms.MainMenu mainMenu1;
        private System.Windows.Forms.MenuItem menuItem1;
        private System.Windows.Forms.MenuItem menuItem2;
        private System.Windows.Forms.MenuItem menuItem3;

        private LogLineUtil m_logLineUtil;

        public MainForm()
        {
            //
            // Required for Windows Form Designer support
            //
            InitializeComponent();

            //
            // TODO: Add any constructor code after InitializeComponent call
            //

            m_logLineUtil = new LogLineUtil();
        }

        /// <summary>
        /// Clean up any resources being used.
        /// </summary>
        protected override void Dispose( bool disposing )
        {
            if( disposing )
            {
                if (components != null) 
                {
                    components.Dispose();
                }
            }
            base.Dispose( disposing );
        }

        #region Windows Form Designer generated code
        /// <summary>
        /// Required method for Designer support - do not modify
        /// the contents of this method with the code editor.
        /// </summary>
        private void InitializeComponent()
        {
            this.rtbLogLines = new System.Windows.Forms.RichTextBox();
            this.rtbExplanation = new System.Windows.Forms.RichTextBox();
            this.btnExplain = new System.Windows.Forms.Button();
            this.btnPaste = new System.Windows.Forms.Button();
            this.mainMenu1 = new System.Windows.Forms.MainMenu();
            this.menuItem1 = new System.Windows.Forms.MenuItem();
            this.menuItem2 = new System.Windows.Forms.MenuItem();
            this.menuItem3 = new System.Windows.Forms.MenuItem();
            this.SuspendLayout();
            // 
            // rtbLogLines
            // 
            this.rtbLogLines.Anchor = ((System.Windows.Forms.AnchorStyles)(((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Left) 
                | System.Windows.Forms.AnchorStyles.Right)));
            this.rtbLogLines.Font = new System.Drawing.Font("Lucida Console", 8.25F, System.Drawing.FontStyle.Regular, System.Drawing.GraphicsUnit.Point, ((System.Byte)(0)));
            this.rtbLogLines.Location = new System.Drawing.Point(8, 8);
            this.rtbLogLines.Name = "rtbLogLines";
            this.rtbLogLines.Size = new System.Drawing.Size(592, 104);
            this.rtbLogLines.TabIndex = 0;
            this.rtbLogLines.Text = "";
            this.rtbLogLines.KeyDown += new System.Windows.Forms.KeyEventHandler(this.rtbLogLines_KeyDown);
            // 
            // rtbExplanation
            // 
            this.rtbExplanation.Anchor = ((System.Windows.Forms.AnchorStyles)((((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Bottom) 
                | System.Windows.Forms.AnchorStyles.Left) 
                | System.Windows.Forms.AnchorStyles.Right)));
            this.rtbExplanation.Font = new System.Drawing.Font("Lucida Console", 8.25F, System.Drawing.FontStyle.Regular, System.Drawing.GraphicsUnit.Point, ((System.Byte)(0)));
            this.rtbExplanation.Location = new System.Drawing.Point(8, 128);
            this.rtbExplanation.Name = "rtbExplanation";
            this.rtbExplanation.Size = new System.Drawing.Size(696, 280);
            this.rtbExplanation.TabIndex = 3;
            this.rtbExplanation.Text = "";
            this.rtbExplanation.WordWrap = false;
            // 
            // btnExplain
            // 
            this.btnExplain.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Right)));
            this.btnExplain.Location = new System.Drawing.Point(616, 80);
            this.btnExplain.Name = "btnExplain";
            this.btnExplain.Size = new System.Drawing.Size(88, 32);
            this.btnExplain.TabIndex = 1;
            this.btnExplain.Text = "Explain Line(s)";
            this.btnExplain.Click += new System.EventHandler(this.btnExplain_Click);
            // 
            // btnPaste
            // 
            this.btnPaste.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Right)));
            this.btnPaste.Location = new System.Drawing.Point(616, 8);
            this.btnPaste.Name = "btnPaste";
            this.btnPaste.Size = new System.Drawing.Size(88, 32);
            this.btnPaste.TabIndex = 2;
            this.btnPaste.Text = "Paste";
            this.btnPaste.Click += new System.EventHandler(this.btnPaste_Click);
            // 
            // mainMenu1
            // 
            this.mainMenu1.MenuItems.AddRange(new System.Windows.Forms.MenuItem[] {
                                                                                      this.menuItem1});
            // 
            // menuItem1
            // 
            this.menuItem1.Index = 0;
            this.menuItem1.MenuItems.AddRange(new System.Windows.Forms.MenuItem[] 
            {
                this.menuItem2,
                this.menuItem3
            });
            this.menuItem1.Text = "Help";
            // 
            // menuItem2
            // 
            this.menuItem2.Index = 0;
            this.menuItem2.Text = "Supported API List";
            this.menuItem2.Click += new System.EventHandler(this.menuItem2_Click);
            // 
            // menuItem3
            // 
            this.menuItem3.Index = 0;
            this.menuItem3.Text = "Paste example";
            this.menuItem3.Click += new System.EventHandler(this.menuItem3_Click);
            // 
            // MainForm
            // 
            this.AutoScaleBaseSize = new System.Drawing.Size(5, 13);
            this.ClientSize = new System.Drawing.Size(712, 413);
            this.Controls.Add(this.btnExplain);
            this.Controls.Add(this.btnPaste);
            this.Controls.Add(this.rtbExplanation);
            this.Controls.Add(this.rtbLogLines);
            this.Menu = this.mainMenu1;
            this.Name = "MainForm";
            this.Text = "LogView";
            this.ResumeLayout(false);

        }
        #endregion

        /// <summary>
        /// The main entry point for the application.
        /// </summary>
        [STAThread]
        static void Main() 
        {
            Application.Run(new MainForm());
        }

        private void btnExplain_Click(object sender, System.EventArgs e)
        {
            try
            {
                rtbExplanation.Text = m_logLineUtil.ExplainLogLine(rtbLogLines.Text);
            }
            catch (Exception ex)
            {
                rtbExplanation.Text = "error parsing logline: " + ex.ToString();
            }
        }

        private void btnPaste_Click(object sender, System.EventArgs e)
        {
            rtbLogLines.Clear();
            rtbLogLines.Paste();
            btnExplain_Click(sender, e);
        }

        private void menuItem2_Click(object sender, System.EventArgs e)
        {
            rtbExplanation.Text = "*** Supported APIs ***\n";

            ArrayList apis = new ArrayList(100);
            
            foreach (DictionaryEntry o in m_logLineUtil.Lines)
            {
                if (o.Value is ArrayList)
                {
                    foreach (LogLine l in (ArrayList) o.Value)
                    {
                        apis.Add(string.Format("{0}.{1}\n", l.component, l.api));
                    }
                }
                else
                {
                    LogLine l = (LogLine) o.Value;

                    apis.Add(string.Format("{0}.{1}\n", l.component, l.api));
                }
            }

            apis.Sort();

            foreach (string api in apis)
            {
                rtbExplanation.Text += api;
            }
        }

        private void menuItem3_Click(object sender, System.EventArgs e)
        {
            this.rtbLogLines.Text = "2006/10/10 23:20:22.127|PurchaseItem|Success|1210|53a9bbbd-9111-4b9b-9a0e-7d56da561aba|1f5ace99aed96e84|4|7378269-T-6-103-1033|MN   '   title 7378269  MN   '   artist 7378269 |80|74U-00001|Zune Music Track|0|5337487-A-6-103-1033|MN   '   title 5337487  MN   '   artist 5337487 |160|74U-00001|Zune Music Album|0|7834999-T-6-103-1033|MN   '   title 7834999  MN   '   artist 7834999 |80|74U-00001|Zune Music Track|0|7705917-A-6-103-1033|MN   '   title 7705917  MN   '   artist 7705917 |160|74U-00001|Zune Music Album|0|ecc7b465-3064-4e85-8d79-b4c84a5b27fe|53a9bbbd-9111-4b9b-9a0e-7d56da561aba|2006-10-10T23:20:20|10.20.2.81|12920|53a9bbbd-9111-4b9b-9a0e-7d56da561aba|1DCzqAAVaYAAA=|2006-10-10T16:18:55|1120|";
        }

        private void rtbLogLines_KeyDown(object sender, System.Windows.Forms.KeyEventArgs e)
        {
            if (e.KeyCode == Keys.Enter)
            {
                this.btnExplain_Click(sender, new EventArgs());
                e.Handled = true; // swallow ENTER
            }
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\MachineBan\console\BanConsoleIds.cs ===
using System;
using System.Collections;
using System.Collections.Generic;
using System.Data;
using System.Text;

using xonline.common.config;
using xonline.common.mgmt;
using xonline.common.service;
using xonline.common.sql.webstore;
using xonline.server.xmachine.fd.soap;

using Microsoft.Webstore.WstClient;

namespace xonline.tools.machineban
{
    class BanConsoleId : IBannable
    {
        private HResult      ReasonCode = HResult.XONLINE_E_LOGON_XBOX_ACCOUNT_BANNED;
        private List<String> ConsoleList;
        private static int   CurrentInstances = 0;
        private int          Instance;

        internal BanConsoleId()
        {
            ConsoleList = new List<String>();
            Instance    = CurrentInstances++;
        }

        public void AddConsole(String id)
        {
            if (ConsoleList.Contains(id) == false)
            {
                ConsoleList.Add(id);
            }
        }

        /// <summary>
        /// Public Interface to Ban all machine puids known to this instance
        /// </summary>
        public void Ban()
        {
            if (ConsoleList == null || ConsoleList.Count == 0)
            {
                return;
            }

            ConsoleIdResult[] banResults = new ConsoleIdResult[0];

            if (Configuration.BatchSize > 1) //redundant to have batch status when batch size is 1
            {
                Console.WriteLine(
                    String.Format(
                        "{0:D5} BanConsoleId {1} Machines", 
                        Instance, 
                        ConsoleList.Count
                        )
                    );
            }

            try
            {
                if (Configuration.Reason != HResult.S_OK)
                {
                    ReasonCode = Configuration.Reason;
                }

                XMachineSoapClient connection = new XMachineSoapClient();

                banResults = connection.BanConsoleIds(
                    ConsoleList.ToArray(),
                    ReasonCode,
                    Configuration.StartDate
                    );
            }
            catch (Exception e)
            {
                Xom.NtEvent(
                    XEvent.Id.MB_BAN_FAILED,
                    "Failed to ban consoles.\nConsoleList = " + 
                    String.Join(
                        ",",
                        ConsoleList.ToArray()
                        ) +
                    "\nException = " + e.ToString()
                    );
                throw e;
            }

            for (int i = 0; i < banResults.Length; ++i)
            {
                //
                // Should we event on successfull ban? Seems to be something 
                // that might be worth keeping track off
                // 
                Console.WriteLine(
                    "    {0:D5}: {1} - {2}",
                    i,
                    banResults[i].ConsoleId,
                    (HResult) banResults[i].Result
                    );
                if ( ( (HResult) banResults[i].Result).IsFailure())
                {
                    Xom.NtEvent(
                        XEvent.Id.MB_BAN_FAILED,
                        "Failed to ban console = " + banResults[i].ConsoleId +
                        "\n"
                        );
                }
            }
        }

        /// <summary>
        /// Public Interface to Unban all machine puids known to this instance
        /// </summary>
        public void UnBan()
        {
            if (ConsoleList == null || ConsoleList.Count == 0)
            {
                return;
            }

            ConsoleIdResult[] banResults = new ConsoleIdResult[0];

            if (Configuration.BatchSize > 1) //redundant to have batch status when batch size is 1
            {
                Console.WriteLine(
                    String.Format(
                        "{0:D5} UnbanMachinePuid {1} Machines", 
                        Instance, 
                        ConsoleList.Count
                        )
                    );
            }

            try
            {
                if (Configuration.Reason != HResult.S_OK)
                {
                    ReasonCode = Configuration.Reason;
                }

                XMachineSoapClient connection = new XMachineSoapClient();

                banResults = connection.UnbanConsoleIds(
                    ConsoleList.ToArray(),
                    ReasonCode
                    );
            }
            catch (Exception e)
            {
                Xom.NtEvent(
                    XEvent.Id.MB_UNBAN_FAILED,
                    "Failed to unban consoles.\nConsoleList = " + 
                    String.Join(
                        ",",
                        ConsoleList.ToArray()
                        ) +
                    "\nException = " + e.ToString()
                    );
                throw e;
            }

            for (int i = 0; i < banResults.Length; ++i)
            {
                //
                // Should we event on successfull ban? Seems to be something 
                // that might be worth keeping track off
                // 
                Console.WriteLine(
                    "    {0:D5}: {1} - {2}",
                    i,
                    banResults[i].ConsoleId,
                    (HResult) banResults[i].Result
                    );
                if ( ( (HResult) banResults[i].Result).IsFailure())
                {
                    Xom.NtEvent(
                        XEvent.Id.MB_UNBAN_FAILED,
                        "Failed to unban console = " + banResults[i].ConsoleId +
                        "\n"
                        );
                }
            }
        }

        public void LookUp()
        {
            if (ConsoleList == null || ConsoleList.Count == 0)
            {
                return;
            }

            ConsoleBanInfo[] consoleBanInfo = new ConsoleBanInfo[0];

            if (Configuration.BatchSize > 1) //redundant to have batch status when batch size is 1
            {
                Console.WriteLine(
                    String.Format(
                        "{0:D5} LookupBanConsoleId {1} Machines",
                        Instance,
                        ConsoleList.Count
                        )
                    );
            }

            XMachineSoapClient connection = new XMachineSoapClient();

            consoleBanInfo = connection.LookupConsoleBansByConsoleIds(ConsoleList.ToArray());

            if (consoleBanInfo.Length > 0)
            {
                DisplayBanInfo(consoleBanInfo);
            }
            else
            {
                Console.WriteLine("Console Id Lookup returned no results.");
            }
        }

        public void DisplayBanInfo(ConsoleBanInfo[] consoleBanInfo)
        {
            for (int i = 0; i < consoleBanInfo.Length; ++i)
            {
                Console.WriteLine(
                    "    {0:D5}: {1} - {2} - {3} - {4}",
                    i,
                    (String)consoleBanInfo[i].ConsoleId,
                    (HResult)consoleBanInfo[i].ReasonCode,
                    (String)consoleBanInfo[i].BanStart.ToString(),
                    (String)consoleBanInfo[i].BanEnd.ToString()
                    );
            }
        }

        public void Reset()
        {
            if (ConsoleList == null || ConsoleList.Count == 0)
            {
                return;
            }

            ConsoleIdResult[] resultResetInfo = new ConsoleIdResult[0];

            if (Configuration.BatchSize > 1) //redundant to have batch status when batch size is 1
            {
                Console.WriteLine(
                    String.Format(
                        "{0:D5} ResetByConsoleId {1} Machines",
                        Instance,
                        ConsoleList.Count
                        )
                    );
            }

            XMachineSoapClient connection = new XMachineSoapClient();

            resultResetInfo = connection.ResetMachinePasswordByConsoleIds(ConsoleList.ToArray());

            if (resultResetInfo.Length > 0)
            {
                DisplayResetInfo(resultResetInfo);
            }
            else
            {
                Console.WriteLine("Console Id Reset returned no results.");
            }
        }

        public void DisplayResetInfo(ConsoleIdResult[] resultResetInfo)
        {
            for (int i = 0; i < resultResetInfo.Length; ++i)
            {
                Console.WriteLine(
                    "    {0:D5}: {1} - {2}",
                    i,
                    (String)resultResetInfo[i].ConsoleId,
                    (HResult)resultResetInfo[i].Result
                    );
            }
        }

        public List<string> GetBanObjectStrings()
        {
            return ConsoleList;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\MachineBan\console\exe\objd\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("DEPOT")]
[assembly:System.Reflection.AssemblyCopyright("")]
[assembly:System.Reflection.AssemblyCompany("")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\MachineBan\console\BanTokenHash.cs ===
using System;
using System.Collections;
using System.Collections.Generic;
using System.Data;
using System.Text;

using xonline.common.config;
using xonline.common.mgmt;
using xonline.common.service;
using xonline.common.sql.webstore;
using xonline.server.xmachine.fd.soap;

using Microsoft.Webstore.WstClient;

namespace xonline.tools.machineban
{
    class BanTokenHash : IBannable
    {
        private HResult      ReasonCode = HResult.XONLINE_E_LOGON_XBOX_ACCOUNT_BANNED;
        private List<Byte[]> TokenList;
        private List<string> STokens;
        private static int   CurrentInstances = 0;
        private int          Instance;

        internal BanTokenHash()
        {
            TokenList = new List<Byte[]>();
            STokens   = new List<string>();
            Instance  = CurrentInstances++;
        }

        public void AddTokenHash(Byte[] VoucherHash, string sToken)
        {
            if (TokenList.Contains(VoucherHash) == false)
            {
                TokenList.Add(VoucherHash);
            }

            if (STokens.Contains(sToken) == false)
            {
                STokens.Add(sToken);
            }
        }

        /// <summary>
        /// Public Interface to Ban all machine puids known to this instance
        /// </summary>
        public void Ban()
        {
            if (TokenList == null || TokenList.Count == 0)
            {
                return;
            }

            PcTokenBanResult[] banResults = new PcTokenBanResult[0];
            if (Configuration.BatchSize > 1) //redundant to have batch status when batch size is 1
            {
                Console.WriteLine(
                    String.Format(
                        "{0:D5} BanTokenHash {1} Tokens", 
                        Instance, 
                        TokenList.Count
                        )
                    );
            }

            try
            {
                XMachineSoapClient connection = new XMachineSoapClient();

                banResults = connection.BanPcTokens(TokenList.ToArray());
            }
            catch (Exception e)
            {
                List<String> voucherList = new List<String>();

                foreach (Byte[] voucher in TokenList)
                {
                    voucherList.Add(
                        String.Join(
                            "",
                            Array.ConvertAll(
                                voucher,
                                ( u => u.ToString("X2") )
                                )
                            )
                        );
                }

                Xom.NtEvent(
                    XEvent.Id.MB_BAN_FAILED,
                    "Failed to ban tokens.\nTokenList = " + 
                    String.Join(
                        ",",
                        voucherList.ToArray()
                        ) +
                    "\nException = " + e.ToString()
                    );
                throw e;
            }

            for (int i = 0; i < banResults.Length; ++i)
            {
                string voucherString = String.Join(
                        "",
                        Array.ConvertAll(
                            banResults[i].VoucherHash,
                            ( u => u.ToString("X2") )
                            )
                        );
                HResult result = (HResult) banResults[i].Result;

                //
                // Should we event on successfull ban? Seems to be something 
                // that might be worth keeping track off
                // 
                Console.WriteLine(
                    "    {0:D5}: {1} - {2}",
                    i,
                    STokens[i],
                    result
                    );
                if (result.IsOk() == false)
                {
                    Xom.NtEvent(
                        XEvent.Id.MB_BAN_FAILED,
                        "Failed to ban token = " + voucherString +
                        "\n"
                        );
                }
            }
        }

        /// <summary>
        /// Public Interface to Unban all machine puids known to this instance
        /// </summary>
        public void UnBan()
        {
            if (TokenList == null || TokenList.Count == 0)
            {
                return;
            }

            PcTokenBanResult[] banResults = new PcTokenBanResult[0];

            if (Configuration.BatchSize > 1) //redundant to have batch status when batch size is 1
            {
                Console.WriteLine(
                    String.Format(
                        "{0:D5} UnbanTokenHash {1} Tokens", 
                        Instance, 
                        TokenList.Count
                        )
                    );
            }

            try
            {
                XMachineSoapClient connection = new XMachineSoapClient();

                banResults = connection.UnbanPcTokens(
                    TokenList.ToArray()
                    );
            }
            catch (Exception e)
            {
                List<String> voucherList = new List<String>();

                foreach (Byte[] voucher in TokenList)
                {
                    voucherList.Add(
                        String.Join(
                            "",
                            Array.ConvertAll(
                                voucher,
                                ( u => u.ToString("X2") )
                                )
                            )
                        );
                }

                Xom.NtEvent(
                    XEvent.Id.MB_BAN_FAILED,
                    "Failed to unban tokens.\nTokenList = " + 
                    String.Join(
                        ",",
                        voucherList.ToArray()
                        ) +
                    "\nException = " + e.ToString()
                    );
                throw e;
            }

            for (int i = 0; i < banResults.Length; ++i)
            {
                string voucherString = String.Join(
                        "",
                        Array.ConvertAll(
                            banResults[i].VoucherHash,
                            ( u => u.ToString("X2") )
                            )
                        );
                HResult result = (HResult) banResults[i].Result;

                //
                // Should we event on successfull ban? Seems to be something 
                // that might be worth keeping track off
                // 
                Console.WriteLine(
                    "    {0:D5}: {1} - {2}",
                    i,
                    STokens[i],
                    result
                    );
                if (result.IsOk() == false)
                {
                    Xom.NtEvent(
                        XEvent.Id.MB_UNBAN_FAILED,
                        "Failed to unban token = " + voucherString +
                        "\n"
                        );
                }
            }
        }

        public void LookUp()
        {
            //Not Implemented.
            Console.WriteLine("Lookup() Call in BanTokenHash is not implemented.");
        }

        public void Reset()
        {
            //Not Implemented.
            Console.WriteLine("ResetAccount() Call in BanTokenHash is not implemented.");
        }

        public List<string> GetBanObjectStrings()
        {
            return STokens;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\MachineBan\console\MachineIdConvert.cs ===
using System;
using System.Collections.Generic;
using System.Data;
using System.Globalization;
using System.Security.Cryptography;
using System.Text;

using xonline.common.config;
using xonline.common.service;
using xonline.common.sql.webstore;
using xonline.common.tools.console;
using xonline.common.mgmt;

using Microsoft.Webstore.WstClient;


namespace xonline.tools.machineban
{
    internal class InvalidRawID
    {
        public string RawId;
        public HResult Failure;
        public string Message;

        public InvalidRawID(string rawId, HResult failure, string message)
        {
            RawId = rawId;
            Failure = failure;
            Message = message;
        }
    };

    static class MachineIdConvert
    {
        internal static void BannablesFromConsoleIds(out List<IBannable> banObjects, out List<InvalidRawID> invalidRawIds)
        {
            banObjects                      = new List<IBannable>();
            BanConsoleId       current      = new BanConsoleId();
            int                count        = 0;
            invalidRawIds                   = new List<InvalidRawID>();

            banObjects.Add(current);

            //
            // Do all the work to take the raw ids and partition them into bannable
            // buckets. 
            // 
            // BUGBUG: Do we want to sort the puids by physical partitions in order
            // to optimize our UODB access?
            // 
            foreach (string rawid in Configuration.RawIdList) 
            {
                //
                // BUGBUG: This is a breaking change over what existed before.
                // The original machine ban took console ids without the XE.
                // prefix but this one will require it
                // 
                current.AddConsole( rawid );
                count++;

                //
                // BUGBUG: Make this a setting/command line that can be picked up.
                // 
                // IMPORTANT: Changing this value requires updating the entry in 
                // npdb.dbo.t_xrl_virtual_interface_mappings for the xrl
                // /xmachine/xmachine.asm/BanMachinePuids (and maybe others).
                // 
                // The rule of thumb is that every 2200 in i_max_content_length
                // allows for a batching of 25. So 100 PUIDs requires 8800 max
                // content length
                // 
                if (count >= Configuration.BatchSize) 
                {
                    current = new BanConsoleId();
                    banObjects.Add(current);
                    count = 0;
                }
            }
        }

        internal static void BannablesFromPuids(out List<IBannable> banObjects, out List<InvalidRawID> invalidRawIds)
        {
            banObjects                 = new List<IBannable>();
            BanMachinePuid     current = new BanMachinePuid();
            int                  count = 0;
            invalidRawIds              = new List<InvalidRawID>();

            banObjects.Add(current);

            //
            // Do all the work to take the raw ids and partition them into bannable
            // buckets. 
            // 
            // BUGBUG: Do we want to sort the puids by physical partitions in order
            // to optimize our UODB access?
            // 
            foreach (string rawid in Configuration.RawIdList) 
            {
                ulong puid = StringToPuid(rawid);
                if (puid == 0)
                {
                    invalidRawIds.Add(new InvalidRawID(rawid, HResult.E_FAIL, "RawId converted to puid 0 and so is ignored."));
                    continue;
                }

                current.AddMachine( puid );
                count++;

                //
                // BUGBUG: Make this a setting/command line that can be picked up.
                // 
                // IMPORTANT: Changing this value requires updating the entry in 
                // npdb.dbo.t_xrl_virtual_interface_mappings for the xrl
                // /xmachine/xmachine.asm/BanMachinePuids (and maybe others).
                // 
                // The rule of thumb is that every 2200 in i_max_content_length
                // allows for a batching of 25. So 100 PUIDs requires 8800 max
                // content length
                // 
                if (count >= Configuration.BatchSize) 
                {
                    current = new BanMachinePuid();
                    banObjects.Add(current);
                    count = 0;
                }
            }
        }

        internal static void BannablesFromFiveByFives(out List<IBannable> banObjects, out List<InvalidRawID> invalidRawIds)
        {
            banObjects                      = new List<IBannable>();
            BanTokenHash       current      = new BanTokenHash();
            int                count        = 0;
            invalidRawIds                   = new List<InvalidRawID>();

            banObjects.Add(current);

            foreach (string fivebyfive in Configuration.RawIdList)
            {
                byte[] tokenhash = TokenHashFromFiveByFive(fivebyfive);
                if (tokenhash == null || tokenhash.Length == 0)
                {
                    invalidRawIds.Add(new InvalidRawID(fivebyfive, HResult.E_FAIL, "RawId converted to a token hash of 0 length and so is ignored."));
                    continue;
                }

                current.AddTokenHash( tokenhash, fivebyfive );
                count++;

                //
                // BUGBUG: Make this a setting/command line that can be picked up.
                // 
                // IMPORTANT: Changing this value requires updating the entry in 
                // npdb.dbo.t_xrl_virtual_interface_mappings for the xrl
                // /xmachine/xmachine.asm/BanMachinePuids (and maybe others).
                // 
                // The rule of thumb is that every 2200 in i_max_content_length
                // allows for a batching of 25. So 100 PUIDs requires 8800 max
                // content length
                // 
                if (count >= Configuration.BatchSize) 
                {
                    current = new BanTokenHash();
                    banObjects.Add(current);
                    count = 0;
                }
            }
        }

        internal static byte[] TokenHashFromFiveByFive(string fivebyfive)
        {
            if (fivebyfive.Length != 29)
            {
                return null;
            }

            SHA1CryptoServiceProvider sha = new SHA1CryptoServiceProvider();
            UnicodeEncoding enc = new UnicodeEncoding();
            return sha.ComputeHash(enc.GetBytes(fivebyfive.ToUpper() + "\0"));
        }

        private static ulong StringToPuid(string puidStr)
        {
            try
            {
                if (puidStr.Substring(0, 2) == "0x")
                {
                    return UInt64.Parse(puidStr.Substring(2), NumberStyles.HexNumber);
                }
                else if (puidStr.Substring(0, 1) == "-")
                {
                    return (UInt64)Int64.Parse(puidStr);
                }
                else
                {
                    return UInt64.Parse(puidStr);
                }
            }
            catch (Exception)
            {
                return 0;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\MachineBan\console\MachineConfig.cs ===
using System;
using System.Collections.Generic;
using System.IO;
using System.Data;
using System.Globalization;
using xonline.common.service;
using xonline.common.tools.console;

namespace xonline.tools.machineban 
{
    class Configuration
    {
        static public bool Help
        {
            get { return _help; } 
        }

        static public uint BatchSize
        {
            get { return _batchSize; }
        }

        static public HResult Reason
        {
            get { return _reason; }
        }

        static public bool Lookup
        {
            get { return _lookup; }
        }

        static public bool Ban
        {
            get { return _ban; }
        }

        static public bool UnBan
        {
            get { return _unban; }
        }

        static public string FileName
        {
            get { return _fileName; }
        }

        static public bool ConsoleId
        {
            get { return _consoleId; }
        }

        static public bool MachinePuid
        {
            get { return _machinePuid; }
        }

        static public List<string> RawIdList
        {
            get { return _rawIdList; }
        }

        static public bool FiveByFive
        {
            get { return _fiveByFive; }
        }

        static public bool Reset
        {
            get { return _reset; }
        }

        static public bool CheckReady
        {
            get { return _checkready; }
        }

        static public DateTime StartDate
        {
            get { return _startdate; }
        }

        static public DateTime EndDate
        {
            get { return _enddate; }
        }

        static public string DateFormat
        {
            get { return _dateformat; }
        }

        static public bool Parse(string[] args)
        {
            // Parse arguments
            NamedArgParser parser = new NamedArgParser(
                new string[] {
                    "?",
                    "help",
                    "ban",
                    "unban",
                    "file",
                    "consoleid",
                    "fivebyfive",
                    "lookup",
                    "reason",
                    "batchsize",
                    "reset",
                    "checkready",
                    "startdate",
                    "enddate",
                    "dateformat"
                    });

            if(!parser.Parse(args))
                return false;

            // Process arguments
            if(parser["help"] != null ||
                parser["?"] != null)
            {
                _help = true;
                return false;
            }

            if (CheckValidArgs(parser) == false)
            {
                return false;
            }

            if (LoadupConfiguration(parser) == false)
            {
                return false;
            }

            return true;
        }

        private static bool CheckValidArgs(NamedArgParser args)
        {
            //nothing else is done if this command line switch is set
            if (args["checkready"] != null)
            {
                return true;
            }

            // Help is treated as invalid for these purposes--the return value
            // and display message is the same.
            if (args["?"] != null
                || (args["ban"] == null && args["unban"] == null && args["lookup"] == null && args["reset"] == null)
                )
            {
                return false;
            }
            else if (args["ban"] != null && args["unban"] != null)
            {
                Console.WriteLine("You can only use ban or unban--not both.");
                return false;
            }
            else if (args["fivebyfive"] != null && args["consoleid"] != null)
            {
                Console.WriteLine("You can only use consoleid or fivebyfive, not both.");
                return false;
            }
            else if ((args["reset"] != null) && (args["fivebyfive"] != null))
            {
                Console.WriteLine("When performing reset you must select consoleid or machinepuid.");
                return false;
            }
            else if ((args["lookup"] != null) && (args["fivebyfive"] != null))
            {
                Console.WriteLine("When performing lookup you can only use consoleid or machinepuid.");
                return false;
            }
            else if (args["lookup"] != null && (args["ban"] != null || args["unban"] != null || args["reset"] != null))
            {
                Console.WriteLine("When choosing lookup do not define ban/unban/reset in command line.");
                return false;
            }
            else if (args["ban"] != null && args["enddate"] != null && args["consoleid"] != null)
            {
                Console.WriteLine("When banning consoleids you can not define an end date.");
                return false;
            }
            else if (args["fivebyfive"] != null && (args["startdate"] != null || args["enddate"] != null))
            {
                Console.WriteLine("FiveByFive does not support defining a start or end date.");
                return false;
            }
            else if (args["fivebyfive"] != null && args["reason"] != null)
            {
                Console.WriteLine("FiveByFive does not support defining reason parameter.");
                return false;
            }
            else if (args["unban"] != null && (args["startdate"] != null || args["enddate"] != null))
            {
                Console.WriteLine("Unban does not support defining a start or end date.");
                return false;
            }
            else
            {
                return true;
            }
        }

        private static bool LoadupConfiguration(NamedArgParser parser)
        {
            //we do not handle or process anything if
            //this command switch is used
            if (parser["checkready"] != null)
            {
                _checkready = true;
                return true;
            }

            //check the type of identifiers to operate on
            if (parser["consoleid"] != null)
            {
                _consoleId = true;
            }
            else if (parser["fivebyfive"] != null)
            {
                _fiveByFive = true;
            }
            else
            {
                _machinePuid = true;
            }

            //
            if (parser["batchsize"] != null)
                _batchSize = Convert.ToUInt32(parser["batchsize"]);

            if (parser["reason"] != null)
            {
                uint uintResult = 0;

                if (!parser["reason"].StartsWith("0x"))
                {
                    Console.WriteLine("Command line parameter /reason:" + parser["Reason"] + " is not a valid hex number, should start with [0x].");
                    return false;
                }

                string hexNumWithoutPrefix = parser["reason"].Substring(2);

                if (UInt32.TryParse(hexNumWithoutPrefix, System.Globalization.NumberStyles.HexNumber, null, out uintResult))
                {
                    _reason = UInt32.Parse(hexNumWithoutPrefix, System.Globalization.NumberStyles.HexNumber);
                }
                else
                {
                    Console.WriteLine("Command line parameter /reason:" + parser["reason"] + " was not valid, should be valid hex number."); 
                    return false;
                }
            }

            if (parser["lookup"] != null)
            {
                _lookup = true;
            }

            //check if loading from a file or not
            if (parser["file"] != null)
            {
                _fileName = parser["file"];

                _rawIdList = LoadIdsFromFile();

                if (_rawIdList == null)
                    return false;

                if (parser["ban"] != null)
                    _ban = true;

                if (parser["unban"] != null)
                    _unban = true;

                if (parser["lookup"] != null)
                    _lookup = true;
            }
            else
            {
                //no file so just using the single id provided
                //after the command param chosen

                if (parser["ban"] != null)
                {
                    _rawIdList.Add(parser["ban"]);
                    _ban = true;
                }

                if (parser["unban"] != null)
                {
                    _rawIdList.Add(parser["unban"]);
                    _unban = true;
                }

                if (parser["lookup"] != null)
                {
                    _rawIdList.Add(parser["lookup"]);
                    _lookup = true;
                }

                if (parser["reset"] != null)
                {
                    _rawIdList.Add(parser["reset"]);
                }
            }

            if (parser["reset"] != null)
                _reset = true;

            //date format and overrides
            if (parser["dateformat"] != null)
            {
                _dateformat = parser["dateformat"];
            }

            if (parser["startdate"] != null)
            {
                if (!DateTime.TryParseExact(parser["startdate"], _dateformat, CultureInfo.InvariantCulture, DateTimeStyles.None, out _startdate))
                {
                    Console.WriteLine("Command line parameter /startdate:" + parser["startdate"] + " was not valid, should be formatted [" + _dateformat + "]");
                    return false;
                }
            }

            if (parser["enddate"] != null)
            {
                if (!DateTime.TryParseExact(parser["enddate"], _dateformat, CultureInfo.InvariantCulture, DateTimeStyles.None, out _enddate))
                {
                    Console.WriteLine("Command line parameter /enddate:" + parser["enddate"] + " was not valid, should be formatted [" + _dateformat + "]");
                    return false;
                }

                //check if enddate is prior to today
                if (_enddate < DateTime.Now.AddDays(-1))
                {
                    Console.WriteLine("Command line parameter /enddate less than today, should not be a past date");
                    return false;
                }
            }

            if (_enddate < _startdate)
            {
                Console.WriteLine("Date error, start date cannot be after the end date.");
                return false;
            }

            return true;
        }

        private static List<string> LoadIdsFromFile()
        {
            List<string> rawIdsFromFile = new List<string>();
            HashSet<string> uniqueIds = new HashSet<string>();

            if (!File.Exists(_fileName))
            {
                Console.WriteLine("Can't find " + _fileName);
                return null;
            }

            StreamReader reader = new StreamReader(_fileName);

            string line;
            while ((line = reader.ReadLine()) != null)
            {
                line = line.Trim();
                if (line.Length != 0)
                {
                    if (!uniqueIds.Contains(line))
                    {
                        uniqueIds.Add(line);
                        rawIdsFromFile.Add(line);
                    }
                }
            }
            reader.Close();

            return rawIdsFromFile;
        }

        static protected bool         _help                   = false;
        static protected uint         _batchSize              = 1;
        static protected HResult      _reason                 = HResult.S_OK;
        static protected bool         _lookup                 = false;
        static protected bool         _ban                    = false;
        static protected bool         _unban                  = false;
        static protected string       _fileName               = null;
        static protected bool         _consoleId              = false;
        static protected bool         _machinePuid            = false;
        static protected List<string> _rawIdList              = new List<string>();
        static protected bool         _fiveByFive             = false;
        static protected bool         _reset                  = false;
        static protected bool         _checkready             = false;
        static protected DateTime     _startdate              = DateTime.Now;
        static protected DateTime     _enddate                = DateTime.MaxValue;
        static protected string       _dateformat             = "yyyy-M-d";
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\MachineBan\test\BanConsoleId.cs ===
using ServerTestFramework;
using ServerTestFramework.Utilities;
using ServerTestFramework.Database;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.Auth;

using System.Collections.Generic;

namespace MachineBanTest
{
    [TestGroup, Description("Tests for banning console IDs. (/ban /consoleid).")]
    public class BanConsoleId: TestNode
    {
        public static void VerifyOutputStatus(string output, string []cids, uint []puidResults)
        {
            //find the status strings in the output
            List<string> stringsFound=new List<string>();

            string []outputLines=output.Replace("\r","").Split(new char[]{'\n'});
            foreach (string line in outputLines)
            {
                if (line.Contains(": ")) //one of the machine status rows
                {
                    int indexStart=line.IndexOf(":")+2;
                    int length=line.Length-indexStart;
                    if (line.Contains(" (")) //filter out the optional comment
                    {
                        length-=line.Length-line.IndexOf(" (");
                    }
                    stringsFound.Add(line.Substring(indexStart, length));
                }
            }

            //build a list of strings we expect
            List<string> stringsExpected=new List<string>();

            for (int i=0; i<cids.Length; ++i)
            {
                uint result=0;
                if (puidResults!=null)
                {
                    result=puidResults[i];
                }
                string line=string.Format("{0} - 0x{1:X8}", cids[i], result);
                stringsExpected.Add(line);
            }

            //compare
            ValueCheck.TestAllUnordered("Machine status output", stringsExpected, stringsFound);
        }

        // -----

        [TestCase, Description("Ban one console id for an already-created machine on the commandline.")]
        public void SingleExisting()
        {
            MachineEditor mach=MachineEditor.FromId(BanUtil.CreateMachine(MachineType.Xbox360));

            string output=BanUtil.RunMachineBan("/ban:"+mach.ConsoleId+" /consoleid");

            BanUtil.CheckOutputForBasicBadness(output);
            VerifyOutputStatus(output, new string[]{mach.ConsoleId}, null);

            BanUtil.VerifySingleMachineBan(mach.Id, 0x8015190D);
            BanUtil.VerifySingleConsoleBan(mach.ConsoleId, 0x8015190D);
        }

        [TestCase, Description("Ban one console id for a machine that hasn't yet been created on the commandline.")]
        public void SingleNonExisting()
        {
            string cid=MachineEditor.GenerateRandomConsoleID(MachineType.Xbox360);

            string output=BanUtil.RunMachineBan("/ban:"+cid+" /consoleid");

            BanUtil.CheckOutputForBasicBadness(output);
            VerifyOutputStatus(output, new string[]{cid}, null);

            BanUtil.VerifySingleConsoleBan(cid, 0x8015190D);
        }

        [TestCase, Description("Ban one console id for a machine that hasn't yet been created on the commandline.")]
        [CompoundCase("NoPrefix", "135246545656")]
        [CompoundCase("TooShort", "XE.13524654565")]
        [CompoundCase("TooLong", "XE.0135246545656")]
        [CompoundCase("BadChecksum", "XE.235246545659")]
        public void SingleInvalid(TestNode self)
        {
            string cid=(string)self.MyValues[0];

            string output=BanUtil.RunMachineBan("/ban:"+cid+" /consoleid");

            BanUtil.CheckOutputForBasicBadness(output);
            VerifyOutputStatus(output, new string[]{cid}, new uint[]{0x80004005}); //E_FAIL

            BanUtil.VerifyNoConsoleBan(cid);
        }

        [TestCase, Description("Ban a console ID for a platform that doesn't support console ID bans.")]
        [CompoundCase("Phone", "WM.111111111111")]
        [CompoundCase("PC", "PC.111111111111")]
        public void SingleUnsupportedPlatform(TestNode self)
        {
            string cid=(string)self.MyValues[0];

            string output=BanUtil.RunMachineBan("/ban:"+cid+" /consoleid");

            BanUtil.CheckOutputForBasicBadness(output);
            VerifyOutputStatus(output, new string[]{cid}, new uint[]{0x80004005}); //E_FAIL

            BanUtil.VerifyNoConsoleBan(cid);
        }

        [TestCase, Description("Ban one console id in a file.")]
        public void FileSingleExisting()
        {
            MachineEditor mach=MachineEditor.FromId(BanUtil.CreateMachine(MachineType.Xbox360));
            string filename=BanUtil.WriteTempFile(mach.ConsoleId);

            string output=BanUtil.RunMachineBan("/ban /consoleid /file:"+filename);

            BanUtil.CheckOutputForBasicBadness(output);
            VerifyOutputStatus(output, new string[]{mach.ConsoleId}, null);

            BanUtil.VerifySingleMachineBan(mach.Id, 0x8015190D);
            BanUtil.VerifySingleConsoleBan(mach.ConsoleId, 0x8015190D);
        }

        [TestCase, Description("Ban a mixture of valid and invalid console ids in a file.")]
        public void FileMultipleMixedInvalid()
        {
            MachineEditor mach0=MachineEditor.FromId(BanUtil.CreateMachine(MachineType.Xbox360));
            string bad0="XE.xxxxxxxxxxxx";
            string bad1="wtf";
            string bad2=mach0.ConsoleId+"TooLong";
            string bad3="XE.112233445561"; //bad checksum digit
            MachineEditor mach1=MachineEditor.FromId(BanUtil.CreateMachine(MachineType.Xbox360));
            string filename=BanUtil.WriteTempFile(new string[]{mach0.ConsoleId, bad0, bad1, bad2, bad3, mach1.ConsoleId});

            string output=BanUtil.RunMachineBan("/consoleid /ban /file:"+filename);

            BanUtil.CheckOutputForBasicBadness(output);
            VerifyOutputStatus(output, new string[]{mach0.ConsoleId, bad0,       bad1,       bad2,       bad3,       mach1.ConsoleId},
                                         new uint[]{0,               0x80004005, 0x80004005, 0x80004005, 0x80004005, 0});

            BanUtil.VerifySingleMachineBan(mach0.Id, 0x8015190D);
            BanUtil.VerifySingleMachineBan(mach1.Id, 0x8015190D);
            BanUtil.VerifySingleConsoleBan(mach0.ConsoleId, 0x8015190D);
            BanUtil.VerifySingleConsoleBan(mach1.ConsoleId, 0x8015190D);
        }

        [TestCase, Description("Ban multiple machines in batches of 100.")] //Note that /batchsize is intentionally not in the help text.  It should not normally be used except under direction of the product team, as it has different failure characteristics.
        [CompoundCase("{0}", 5)]
        [CompoundCase("{0}", 100)]
        [CompoundCase("{0}", 2109)] //2109 is just an arbitrarily large number not divisible by the batch size of 100
        public void FileMultipleBatch100(TestNode self)
        {
            Global.RO.Debug("Creating machines...");
            int count=(int)self.MyValues[0];
            ulong []machs=new ulong[count];
            string []consoles=new string[count];
            for (int i=0; i<count; ++i)
            {
                MachineEditor mach=MachineEditor.CreateNew(MachineType.Xbox360);
                machs[i]=mach.Id;
                consoles[i]=mach.ConsoleId;
                if (i%(count/5)==0)
                {
                    Global.RO.Debug((100*i/count)+"%...");
                }
            }

            string filename=BanUtil.WriteTempFile(consoles);

            string output=BanUtil.RunMachineBan("/consoleid /ban /file:"+filename+" /batchsize:100");

            BanUtil.CheckOutputForBasicBadness(output);
            VerifyOutputStatus(output, consoles, null);

            for (int i=0; i<count; ++i)
            {
                BanUtil.VerifySingleMachineBan(machs[i], 0x8015190D);
                BanUtil.VerifySingleConsoleBan(consoles[i], 0x8015190D);
            }
        }

        [TestCase, Description("Ban a single consoleid with a valid reason code.")]
        [CompoundCase("Hex", "0x8F000000", 0x8F000000)]
        public void SingleValidReason(TestNode self)
        {
            string reasonText=(string)self.MyValues[0];
            uint reasonValue=(uint)self.MyValues[1];

            MachineEditor mach=MachineEditor.FromId(BanUtil.CreateMachine(MachineType.Xbox360));

            string output=BanUtil.RunMachineBan("/consoleid /ban:"+mach.ConsoleId+" /reason:"+reasonText);

            BanUtil.CheckOutputForBasicBadness(output);
            VerifyOutputStatus(output, new string[]{mach.ConsoleId}, null);

            BanUtil.VerifySingleMachineBan(mach.Id, reasonValue);
            BanUtil.VerifySingleConsoleBan(mach.ConsoleId, reasonValue);
        }

        [TestCase, Description("Ban one machine specifying a start date in the default format.")]
        [CompoundCase("Past", -10)]
        [CompoundCase("Future", 10)]
        public void SingleStartDate(TestNode self)
        {
            int daysOffset=(int)self.MyValues[0];
            System.DateTime alteredNowDate=System.DateTime.UtcNow+new System.TimeSpan(daysOffset, 0, 0, 0);
            int year=alteredNowDate.Year;
            int month=alteredNowDate.Month;
            int day=alteredNowDate.Day;
            System.DateTime banDate=new System.DateTime(year, month, day);

            MachineEditor mach=MachineEditor.FromId(BanUtil.CreateMachine(MachineType.Xbox360));

            string output=BanUtil.RunMachineBan("/consoleid /ban:"+mach.ConsoleId+" /startdate:"+year+"-"+month+"-"+day);

            BanUtil.CheckOutputForBasicBadness(output);
            VerifyOutputStatus(output, new string[]{mach.ConsoleId}, null);

            BanUtil.VerifySingleMachineBan(mach.Id, 0x8015190D, banDate, System.DateTime.MaxValue);
            BanUtil.VerifySingleConsoleBan(mach.ConsoleId, 0x8015190D, banDate);
        }

        [TestCase, Description("Ban one machine specifying an end date in the default format.  You can't specify an end date for a console ban.")]
        public void SingleEndDate()
        {
            int daysOffset=100;
            System.DateTime alteredNowDate=System.DateTime.UtcNow+new System.TimeSpan(daysOffset, 0, 0, 0);
            int year=alteredNowDate.Year;
            int month=alteredNowDate.Month;
            int day=alteredNowDate.Day;
            System.DateTime banEndDate=new System.DateTime(year, month, day);

            MachineEditor mach=MachineEditor.FromId(BanUtil.CreateMachine(MachineType.Xbox360));

            string output=BanUtil.RunMachineBan("/ban:"+mach.ConsoleId+" /consoleid /enddate:"+year+"-"+month+"-"+day);
            if (!output.ToLower().Contains("invalid parameter"))
            {
                throw new UnexpectedTestResultException("Expected output to contain 'invalid parameter'");
            }

            BanUtil.VerifyNoMachineBan(mach.Id);
            BanUtil.VerifyNoConsoleBan(mach.ConsoleId);
        }

        [TestCase, Description("Ban one machine specifying /dateformat as well as a start.")]
        public void SingleDateFormat()
        {
            System.DateTime banStart=new System.DateTime(2011, 1, 1, 1, 1, 1);

            MachineEditor mach=MachineEditor.FromId(BanUtil.CreateMachine(MachineType.Xbox360));

            string output=BanUtil.RunMachineBan("/ban:"+mach.ConsoleId+" /dateformat:yyyy'-'MM'-'dd'*'HH'+'mm'+'ss /startdate:2011-01-01*01+01+01 /consoleid");

            BanUtil.CheckOutputForBasicBadness(output);
            VerifyOutputStatus(output, new string[]{mach.ConsoleId}, null);

            BanUtil.VerifySingleMachineBan(mach.Id, 0x8015190D, banStart, System.DateTime.MaxValue);
            BanUtil.VerifySingleConsoleBan(mach.ConsoleId, 0x8015190D, banStart);
        }

        [TestCase, Description("Pass an empty file in to ban.")]
        public void FileEmpty()
        {
            string filename=BanUtil.WriteTempFile("");
            string output=BanUtil.RunMachineBan("/ban /consoleid /file:"+filename);
            BanUtil.CheckOutputForBasicBadness(output);
        }

        [TestCase, Description("Ban one machine that is a duplicate console id.")]
        public void SingleDuplicateConsole(TestNode self)
        {
            MachineEditor mach0=MachineEditor.FromId(BanUtil.CreateMachine(MachineType.Xbox360));
            MachineEditor mach1=MachineEditor.CreateDuplicateXbox360(mach0.ConsoleId);
            Global.RO.Debug("Created duplicate machine: 0x{0:X}", mach1.Id);

            string output=BanUtil.RunMachineBan("/consoleid /ban:"+mach0.ConsoleId);

            BanUtil.CheckOutputForBasicBadness(output);
            VerifyOutputStatus(output, new string[]{mach0.ConsoleId}, null);

            BanUtil.VerifySingleMachineBan(mach0.Id, 0x8015190D);
            BanUtil.VerifySingleConsoleBan(mach0.ConsoleId, 0x8015190D);

            BanUtil.VerifySingleMachineBan(mach1.Id, 0x8015190D);
            BanUtil.VerifySingleConsoleBan(mach1.ConsoleId, 0x8015190D);
        }
    };
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\MachineBan\test\BanFiveByFive.cs ===
using ServerTestFramework;
using ServerTestFramework.Utilities;
using ServerTestFramework.Database;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.Auth;

using System.Collections.Generic;

namespace MachineBanTest
{
    [TestGroup, Description("Tests for banning PC vouchers (/ban /fivebyfive).")]
    public class BanFiveByFive: TestNode
    {
        public static void VerifyOutputStatus(string output, string []vouchers, uint []results)
        {
            //find the status strings in the output
            List<string> stringsFound=new List<string>();

            string []outputLines=output.Replace("\r","").Split(new char[]{'\n'});
            foreach (string line in outputLines)
            {
                if (line.Contains(": ")) //one of the machine status rows
                {
                    int indexStart=line.IndexOf(":")+2;
                    int length=line.Length-indexStart;
                    if (line.Contains(" (")) //filter out the optional comment
                    {
                        length-=line.Length-line.IndexOf(" (");
                    }
                    stringsFound.Add(line.Substring(indexStart, length));
                }
            }

            //build a list of strings we expect
            List<string> stringsExpected=new List<string>();

            for (int i=0; i<vouchers.Length; ++i)
            {
                uint result=0;
                if (results!=null)
                {
                    result=results[i];
                }
                string line=string.Format("{0} - 0x{1:X8}", vouchers[i], result);
                stringsExpected.Add(line);
            }

            //compare
            ValueCheck.TestAllUnordered("Voucher status output", stringsExpected, stringsFound);
        }

        // -----

        [TestCase, Description("Ban one on the commandline.")]
        [CompoundCase("NoMachines", 0)]
        [CompoundCase("OneMachine", 1)]
        [CompoundCase("TwoMachines", 2)]
        public void Single(TestNode self)
        {
            int machineCount=(int)self.MyValues[0];

            string voucher=BanUtil.CreateUnlimitedPCVoucher();

            MachineEditor []machs=new MachineEditor[machineCount];
            for (int i=0; i<machineCount; ++i)
            {
                machs[i]=MachineEditor.FromId(BanUtil.CreatePCMachine(voucher));
            }

            string output=BanUtil.RunMachineBan("/fivebyfive /ban:"+voucher);

            BanUtil.CheckOutputForBasicBadness(output);
            VerifyOutputStatus(output, new string[]{voucher}, null);

            BanUtil.VerifyVoucherBan(voucher);
            for (int i=0; i<machineCount; ++i)
            {
                BanUtil.VerifySingleMachineBan(machs[i].Id, 0x8015190D);
                BanUtil.VerifyNoConsoleBan(machs[i].ConsoleId);
            }
        }

        [TestCase, Description("Ban from a file.")]
        [CompoundCase("Single", 1)]
        [CompoundCase("Multiple", 10)]
        public void File(TestNode self)
        {
            int machineCount=(int)self.MyValues[0];

            string []vouchers=new string[machineCount];
            MachineEditor []machs=new MachineEditor[machineCount];
            for (int i=0; i<machineCount; ++i)
            {
                vouchers[i]=BanUtil.CreateUnlimitedPCVoucher();
                machs[i]=MachineEditor.FromId(BanUtil.CreatePCMachine(vouchers[i]));
            }
            string filename=BanUtil.WriteTempFile(vouchers);

            string output=BanUtil.RunMachineBan("/fivebyfive /ban /file:"+filename);

            BanUtil.CheckOutputForBasicBadness(output);
            VerifyOutputStatus(output, vouchers, null);

            for (int i=0; i<machineCount; ++i)
            {
                BanUtil.VerifyVoucherBan(vouchers[i]);
                BanUtil.VerifySingleMachineBan(machs[i].Id, 0x8015190D);
            }
        }

        [TestCase, Description("Ban a mixture of valid and invalid vouchers.")]
        public void FileMixedInvalid()
        {
            List<string> vouchers=new List<string>();
            List<MachineEditor> machs=new List<MachineEditor>();

            vouchers.Add(BanUtil.CreateUnlimitedPCVoucher());
            machs.Add(MachineEditor.FromId(BanUtil.CreatePCMachine(vouchers[vouchers.Count-1]))); //valid

            vouchers.Add("P1234-OEHHC-OCEUH-OCEUH-OEUHI-OCEUI"); //valid doesn't exist but valid
            vouchers.Add("x"); //not valid

            string notBannedVoucher=BanUtil.CreateUnlimitedPCVoucher();
            vouchers.Add(notBannedVoucher+"-ABCDE"); //too long

            vouchers.Add(BanUtil.CreateUnlimitedPCVoucher());
            machs.Add(MachineEditor.FromId(BanUtil.CreatePCMachine(vouchers[vouchers.Count-1]))); //valid

            string filename=BanUtil.WriteTempFile(vouchers);

            string output=BanUtil.RunMachineBan("/fivebyfive /ban /file:"+filename);

            BanUtil.CheckOutputForBasicBadness(output);
            VerifyOutputStatus(output, vouchers.ToArray(), new uint[]{0, 0x80004005, 0x80004005, 0x80004005, 0});

            foreach (MachineEditor mach in machs)
            {
                BanUtil.VerifySingleMachineBan(mach.Id, 0x8015190D);
            }
        }

        [TestCase, Description("Attempt to specify reason code, which isn't currently supported for PCs.")]
        public void SingleReason()
        {
            string voucher=BanUtil.CreateUnlimitedPCVoucher();
            MachineEditor mach=MachineEditor.FromId(BanUtil.CreatePCMachine(voucher));

            string output=BanUtil.RunMachineBan("/fivebyfive /ban:"+voucher+" /reason:0x80000000");
            if (!output.ToLower().Contains("invalid parameter"))
            {
                throw new UnexpectedTestResultException("Expected output to contain 'invalid parameter'");
            }

            BanUtil.VerifyNoVoucherBan(voucher);
            BanUtil.VerifyNoMachineBan(mach.Id);
        }

        [TestCase, Description("Attempt to ban specifying a start date, which isn't currently supported for PCs.")]
        public void SingleStartDate()
        {
            string voucher=BanUtil.CreateUnlimitedPCVoucher();
            MachineEditor mach=MachineEditor.FromId(BanUtil.CreatePCMachine(voucher));

            string output=BanUtil.RunMachineBan("/fivebyfive /ban:"+voucher+" /startdate:2020-10-13");
            if (!output.ToLower().Contains("invalid parameter"))
            {
                throw new UnexpectedTestResultException("Expected output to contain 'invalid parameter'");
            }

            BanUtil.VerifyNoVoucherBan(voucher);
            BanUtil.VerifyNoMachineBan(mach.Id);
        }

        [TestCase, Description("Attempt to ban specifying an end date, which isn't currently supported for PCs.")]
        public void SingleEndDate()
        {
            string voucher=BanUtil.CreateUnlimitedPCVoucher();
            MachineEditor mach=MachineEditor.FromId(BanUtil.CreatePCMachine(voucher));

            string output=BanUtil.RunMachineBan("/fivebyfive /ban:"+voucher+" /enddate:2020-10-13");
            if (!output.ToLower().Contains("invalid parameter"))
            {
                throw new UnexpectedTestResultException("Expected output to contain 'invalid parameter'");
            }

            BanUtil.VerifyNoVoucherBan(voucher);
            BanUtil.VerifyNoMachineBan(mach.Id);
        }
    };
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\MachineBan\test\BanPuid.cs ===
using ServerTestFramework;
using ServerTestFramework.Utilities;
using ServerTestFramework.Database;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.Auth;

using System.Collections.Generic;

namespace MachineBanTest
{
    [TestGroup, Description("Tests for banning machine puids (/ban).")]
    public class BanPuid: TestNode
    {
        public static void VerifyOutputStatus(string output, ulong []puids, uint []puidResults)
        {
            string []machineStrings=new string[puids.Length];
            for (int i=0; i<puids.Length; ++i)
            {
                machineStrings[i]=string.Format("0x{0:X16}", puids[i]);
            }

            VerifyOutputStatus(output, machineStrings, puidResults);
        }

        public static void VerifyOutputStatus(string output, string []machineStrings, uint []puidResults)
        {
            //find the status strings in the output
            List<string> stringsFound=new List<string>();

            string []outputLines=output.Replace("\r","").Split(new char[]{'\n'});
            foreach (string line in outputLines)
            {
                if (line.Contains(": ")) //one of the machine status rows
                {
                    int indexStart=line.IndexOf(":")+2;
                    int length=line.Length-indexStart;
                    if (line.Contains(" (")) //filter out the optional comment
                    {
                        length-=line.Length-line.IndexOf(" (");
                    }
                    stringsFound.Add(line.Substring(indexStart, length));
                }
            }

            //build a list of strings we expect
            List<string> stringsExpected=new List<string>();

            for (int i=0; i<machineStrings.Length; ++i)
            {
                uint result=0;
                if (puidResults!=null)
                {
                    result=puidResults[i];
                }
                string line=string.Format("{0} - 0x{1:X8}", machineStrings[i], result);
                stringsExpected.Add(line);
            }

            //compare
            ValueCheck.TestAllUnordered("Machine status output", stringsExpected, stringsFound);
        }

        // -----

        [TestCase, Description("Ban one machine in hex on the commandline.")]
        [CompoundCase("Xbox360", MachineType.Xbox360)]
        [CompoundCase("Phone", MachineType.Phone)]
        public void SingleHex(TestNode self)
        {
            MachineType mtype=(MachineType)self.MyValues[0];
            MachineEditor mach=MachineEditor.FromId(BanUtil.CreateMachine(mtype));

            string output=BanUtil.RunMachineBan("/ban:"+string.Format("0x{0:X16}", mach.Id));

            BanUtil.CheckOutputForBasicBadness(output);
            VerifyOutputStatus(output, new ulong[]{mach.Id}, null);

            BanUtil.VerifySingleMachineBan(mach.Id, 0x8015190D);
            BanUtil.VerifyNoConsoleBan(mach.ConsoleId);
        }

        [TestCase, Description("Ban one machine in hex on the commandline.")]
        public void SingleHexPc()
        {
            string voucher=BanUtil.CreateUnlimitedPCVoucher();
            MachineEditor mach=MachineEditor.FromId(BanUtil.CreatePCMachine(voucher));

            string output=BanUtil.RunMachineBan("/ban:"+string.Format("0x{0:X16}", mach.Id));

            BanUtil.CheckOutputForBasicBadness(output);
            VerifyOutputStatus(output, new ulong[]{mach.Id}, null);

            BanUtil.VerifySingleMachineBan(mach.Id, 0x8015190D);
            BanUtil.VerifyNoConsoleBan(mach.ConsoleId);
            BanUtil.VerifyVoucherBan(voucher);
        }

        [TestCase, Description("Ban one machine in unsigned decimal on the commandline.")]
        public void SinglePositiveDecimal()
        {
            MachineEditor mach=MachineEditor.FromId(BanUtil.CreateMachine(MachineType.Xbox360));

            string output=BanUtil.RunMachineBan("/ban:"+(ulong)mach.Id);

            BanUtil.CheckOutputForBasicBadness(output);
            VerifyOutputStatus(output, new ulong[]{mach.Id}, null);

            BanUtil.VerifySingleMachineBan(mach.Id, 0x8015190D);
            BanUtil.VerifyNoConsoleBan(mach.ConsoleId);
        }

        [TestCase, Description("Ban one machine in signed decimal on the commandline.")]
        public void SingleNegativeDecimal()
        {
            MachineEditor mach=MachineEditor.FromId(BanUtil.CreateMachine(MachineType.Xbox360));

            string output=BanUtil.RunMachineBan("/ban:"+(long)mach.Id);

            BanUtil.CheckOutputForBasicBadness(output);
            VerifyOutputStatus(output, new ulong[]{mach.Id}, null);

            BanUtil.VerifySingleMachineBan(mach.Id, 0x8015190D);
            BanUtil.VerifyNoConsoleBan(mach.ConsoleId);
        }

        [TestCase, Description("Ban one invalid machine id (platform type isn't real).")]
        public void SingleInvalidMachine()
        {
            ulong id=0x13;
            string output=BanUtil.RunMachineBan("/ban:"+string.Format("0x{0:X16}", id));

            BanUtil.CheckOutputForBasicBadness(output);
            VerifyOutputStatus(output, new ulong[]{id}, new uint[]{0x80004005}); //E_FAIL
        }

        [TestCase, Description("Ban one machine id that does not exist (but is in a valid range).")]
        public void SingleNonexistantMachine()
        {
            ulong id=0xfa00ffffffff1234;
            string output=BanUtil.RunMachineBan("/ban:"+string.Format("0x{0:X16}", id));

            BanUtil.CheckOutputForBasicBadness(output);
            VerifyOutputStatus(output, new ulong[]{id}, new uint[]{0x80004005}); //E_FAIL
        }

        [TestCase, Description("A single valid value in a file.")]
        [CompoundCase("Xbox360", MachineType.Xbox360)]
        [CompoundCase("Phone", MachineType.Phone)]
        public void FileSingleHex(TestNode self)
        {
            MachineType mtype=(MachineType)self.MyValues[0];
            MachineEditor mach=MachineEditor.FromId(BanUtil.CreateMachine(mtype));
            string filename=BanUtil.WriteTempFile(string.Format("0x{0:X16}", mach.Id));

            string output=BanUtil.RunMachineBan("/ban /file:"+filename);

            BanUtil.CheckOutputForBasicBadness(output);
            VerifyOutputStatus(output, new ulong[]{mach.Id}, null);

            BanUtil.VerifySingleMachineBan(mach.Id, 0x8015190D);
            BanUtil.VerifyNoConsoleBan(mach.ConsoleId);
        }

        [TestCase, Description("Ban one machine in hex from a file.")]
        public void FileSingleHexPc()
        {
            string voucher=BanUtil.CreateUnlimitedPCVoucher();
            MachineEditor mach=MachineEditor.FromId(BanUtil.CreatePCMachine(voucher));
            string filename=BanUtil.WriteTempFile(string.Format("0x{0:X16}", mach.Id));

            string output=BanUtil.RunMachineBan("/ban /file:"+filename);

            BanUtil.CheckOutputForBasicBadness(output);
            VerifyOutputStatus(output, new ulong[]{mach.Id}, null);

            BanUtil.VerifySingleMachineBan(mach.Id, 0x8015190D);
            BanUtil.VerifyNoConsoleBan(mach.ConsoleId);
            BanUtil.VerifyVoucherBan(voucher);
        }

        [TestCase, Description("Ban one machine in unsigned decimal from a file.")]
        public void FileSinglePositiveDecimal()
        {
            MachineEditor mach=MachineEditor.FromId(BanUtil.CreateMachine(MachineType.Xbox360));
            string filename=BanUtil.WriteTempFile(((ulong)mach.Id).ToString());

            string output=BanUtil.RunMachineBan("/ban /file:"+filename);

            BanUtil.CheckOutputForBasicBadness(output);
            VerifyOutputStatus(output, new ulong[]{mach.Id}, null);

            BanUtil.VerifySingleMachineBan(mach.Id, 0x8015190D);
            BanUtil.VerifyNoConsoleBan(mach.ConsoleId);
        }

        [TestCase, Description("Ban one machine in signed decimal from a file.")]
        public void FileSingleNegativeDecimal()
        {
            MachineEditor mach=MachineEditor.FromId(BanUtil.CreateMachine(MachineType.Xbox360));
            string filename=BanUtil.WriteTempFile(((long)mach.Id).ToString());

            string output=BanUtil.RunMachineBan("/file:"+filename+" /ban");

            BanUtil.CheckOutputForBasicBadness(output);
            VerifyOutputStatus(output, new ulong[]{mach.Id}, null);

            BanUtil.VerifySingleMachineBan(mach.Id, 0x8015190D);
            BanUtil.VerifyNoConsoleBan(mach.ConsoleId);
        }

        [TestCase, Description("Ban multiple machines from a file, formatted differently.")]
        public void FileMultipleDifferentFormats()
        {
            MachineEditor mach0=MachineEditor.FromId(BanUtil.CreateMachine(MachineType.Xbox360));
            MachineEditor mach1=MachineEditor.FromId(BanUtil.CreateMachine(MachineType.Xbox360));
            MachineEditor mach2=MachineEditor.FromId(BanUtil.CreateMachine(MachineType.Xbox360));
            string filename=BanUtil.WriteTempFile(new string[]{string.Format("0x{0:X16}", mach0.Id), ((ulong)mach1.Id).ToString(), ((long)mach2.Id).ToString()});

            string output=BanUtil.RunMachineBan("/ban /file:"+filename);

            BanUtil.CheckOutputForBasicBadness(output);
            VerifyOutputStatus(output, new ulong[]{mach0.Id, mach1.Id, mach2.Id}, null);

            BanUtil.VerifySingleMachineBan(mach0.Id, 0x8015190D);
            BanUtil.VerifySingleMachineBan(mach1.Id, 0x8015190D);
            BanUtil.VerifySingleMachineBan(mach2.Id, 0x8015190D);
            BanUtil.VerifyNoConsoleBan(mach0.ConsoleId);
            BanUtil.VerifyNoConsoleBan(mach1.ConsoleId);
            BanUtil.VerifyNoConsoleBan(mach2.ConsoleId);
        }

        [TestCase, Description("Ban multiple machines of different platforms from a file")]
        public void FileMultipleDifferentPlatforms()
        {
            List<MachineEditor> machs=new List<MachineEditor>();
            for (int i=0; i<8; ++i)
            {
                machs.Add(MachineEditor.FromId(BanUtil.CreateMachine(MachineType.Xbox360)));
            }
            machs.Add(MachineEditor.FromId(BanUtil.CreateMachine(MachineType.Phone)));
            machs.Add(MachineEditor.FromId(BanUtil.CreateMachine(MachineType.PC)));
            for (int i=0; i<8; ++i)
            {
                machs.Add(MachineEditor.FromId(BanUtil.CreateMachine(MachineType.Xbox360)));
            }

            string data="";
            foreach (MachineEditor mach in machs)
            {
                data+=mach.Id+"\r\n";;
            }

            string filename=BanUtil.WriteTempFile(data);

            string output=BanUtil.RunMachineBan("/ban /file:"+filename);

            BanUtil.CheckOutputForBasicBadness(output);
            ulong []puids=new ulong[machs.Count];
            for (int i=0; i<machs.Count; ++i)
            {
                puids[i]=machs[i].Id;
            }
            VerifyOutputStatus(output, puids, null);

            foreach (MachineEditor mach in machs)
            {
                BanUtil.VerifySingleMachineBan(mach.Id, 0x8015190D);
                BanUtil.VerifyNoConsoleBan(mach.ConsoleId);
            }
        }

        [TestCase, Description("Ban multiple machines from a file using only \\n as a line break.")]
        public void FileMultipleNoCRLineBreak()
        {
            MachineEditor mach0=MachineEditor.FromId(BanUtil.CreateMachine(MachineType.Xbox360));
            MachineEditor mach1=MachineEditor.FromId(BanUtil.CreateMachine(MachineType.Xbox360));
            string filename=BanUtil.WriteTempFile(mach0.Id+"\n"+mach1.Id);

            string output=BanUtil.RunMachineBan("/ban /file:"+filename);

            BanUtil.CheckOutputForBasicBadness(output);
            VerifyOutputStatus(output, new ulong[]{mach0.Id, mach1.Id}, null);

            BanUtil.VerifySingleMachineBan(mach0.Id, 0x8015190D);
            BanUtil.VerifySingleMachineBan(mach1.Id, 0x8015190D);
            BanUtil.VerifyNoConsoleBan(mach0.ConsoleId);
            BanUtil.VerifyNoConsoleBan(mach1.ConsoleId);
        }

        [TestCase, Description("Ban multiple machines from a file with default parameters")]
        [CompoundCase("PC 345", 345, MachineType.PC)]
        [CompoundCase("Xbox360 345", 345, MachineType.Xbox360)]
        [CompoundCase("Phone 345", 345, MachineType.Phone)]
        public void FileMultiple(TestNode self)
        {
            Global.RO.Debug("Creating machines...");
            int count=(int)self.MyValues[0];
            MachineType mtype=(MachineType)self.MyValues[1];
            ulong []machs=new ulong[count];
            for (int i=0; i<count; ++i)
            {
                machs[i]=BanUtil.CreateMachine(mtype);
                if (i%(count/5)==0)
                {
                    Global.RO.Debug((100*i/count)+"%...");
                }
            }

            string filename=BanUtil.WriteTempFile(machs);

            string output=BanUtil.RunMachineBan("/ban /file:"+filename);

            BanUtil.CheckOutputForBasicBadness(output);
            VerifyOutputStatus(output, machs, null);

            for (int i=0; i<count; ++i)
            {
                BanUtil.VerifySingleMachineBan(machs[i], 0x8015190D);
            }
        }

        [TestCase, Description("Ban multiple machines from a file with some invalid entries and one entry included twice.")]
        public void FileMultipleMixedInvalid()
        {
            MachineEditor mach0=MachineEditor.FromId(BanUtil.CreateMachine(MachineType.Xbox360));
            MachineEditor mach1=MachineEditor.FromId(BanUtil.CreateMachine(MachineType.Xbox360));
            string filename=BanUtil.WriteTempFile(new string[]{string.Format("0x{0:X16}", mach0.Id), "wtf", "0x-99999999999999999999999999", "7", mach0.Id.ToString(), string.Format("0x{0:X16}", mach1.Id)});

            string output=BanUtil.RunMachineBan("/ban /file:"+filename);

            BanUtil.CheckOutputForBasicBadness(output);
            VerifyOutputStatus(output,
                new string[]{
                    string.Format("0x{0:X16}", mach0.Id),
                    string.Format("0x{0:X16}", mach1.Id),
                    "wtf",
                    "0x-99999999999999999999999999",
                    "7"},
                new uint[]{
                    0,
                    0,
                    0x80004005,
                    0x80004005,
                    0x80004005});

            BanUtil.VerifySingleMachineBan(mach0.Id, 0x8015190D);
            BanUtil.VerifySingleMachineBan(mach1.Id, 0x8015190D);
            BanUtil.VerifyNoConsoleBan(mach0.ConsoleId);
            BanUtil.VerifyNoConsoleBan(mach1.ConsoleId);
        }

        [TestCase, Description("Ban multiple machines in batches of 100.")] //Note that /batchsize is intentionally not in the help text.  It should not normally be used except under direction of the product team, as it has different failure characteristics.
        [CompoundCase("{0}", 5)]
        [CompoundCase("{0}", 100)]
        [CompoundCase("{0}", 2109)] //2109 is just an arbitrarily large number not divisible by the batch size of 100
        public void FileMultipleBatch100(TestNode self)
        {
            Global.RO.Debug("Creating machines...");
            int count=(int)self.MyValues[0];
            ulong []machs=new ulong[count];
            for (int i=0; i<count; ++i)
            {
                machs[i]=MachineEditor.CreateNew(MachineType.Xbox360).Id;
                if (i%(count/5)==0)
                {
                    Global.RO.Debug((100*i/count)+"%...");
                }
            }

            string filename=BanUtil.WriteTempFile(machs);

            string output=BanUtil.RunMachineBan("/ban /file:"+filename+" /batchsize:100");

            BanUtil.CheckOutputForBasicBadness(output);
            VerifyOutputStatus(output, machs, null);

            for (int i=0; i<count; ++i)
            {
                BanUtil.VerifySingleMachineBan(machs[i], 0x8015190D);
            }
        }

        [TestCase, Description("Ban a single puid with a valid reason code.")]
        [CompoundCase("Hex", "0x8F000000", 0x8F000000)]
        public void SingleValidReason(TestNode self)
        {
            string reasonText=(string)self.MyValues[0];
            uint reasonValue=(uint)self.MyValues[1];

            MachineEditor mach=MachineEditor.FromId(BanUtil.CreateMachine(MachineType.Xbox360));

            string output=BanUtil.RunMachineBan("/ban:"+string.Format("0x{0:X16}", mach.Id)+" /reason:"+reasonText);

            BanUtil.CheckOutputForBasicBadness(output);
            VerifyOutputStatus(output, new ulong[]{mach.Id}, null);

            BanUtil.VerifySingleMachineBan(mach.Id, reasonValue);
            BanUtil.VerifyNoConsoleBan(mach.ConsoleId);
        }

        [TestCase, Description("Ban a single puid with an invalid reason code.")]
        [CompoundCase("NoHexPrefix", "8F000000")]
        [CompoundCase("NonErrorCore", "7")]
        [CompoundCase("Letters", "zfoorar")]
        [CompoundCase("PositiveDecimal", "2399141888")]
        [CompoundCase("NegativeDecimal", "-1895825408")] //value is valid but tool requires only hex
        public void SingleInvalidReason(TestNode self)
        {
            string reasonText=(string)self.MyValues[0];

            MachineEditor mach=MachineEditor.FromId(BanUtil.CreateMachine(MachineType.Xbox360));

            string output=BanUtil.RunMachineBan("/ban:"+string.Format("0x{0:X16}", mach.Id)+" /reason:"+reasonText);
            string expectedOutput="Command line parameter /reason:"+reasonText+" is not a valid hex number, should start with [0x].";
            if (!output.ToLower().Contains(expectedOutput.ToLower()))
            {
                throw new UnexpectedTestResultException("Expected output to contain: "+expectedOutput);
            }

            BanUtil.VerifyNoMachineBan(mach.Id);
            BanUtil.VerifyNoConsoleBan(mach.ConsoleId);
        }

        [TestCase, Description("Ban one machine specifying a start date in the default format.")]
        [CompoundCase("Past", -10)]
        [CompoundCase("Future", 10)]
        public void SingleStartDate(TestNode self)
        {
            int daysOffset=(int)self.MyValues[0];
            System.DateTime alteredNowDate=System.DateTime.UtcNow+new System.TimeSpan(daysOffset, 0, 0, 0);
            int year=alteredNowDate.Year;
            int month=alteredNowDate.Month;
            int day=alteredNowDate.Day;
            System.DateTime banDate=new System.DateTime(year, month, day);

            MachineEditor mach=MachineEditor.FromId(BanUtil.CreateMachine(MachineType.Xbox360));

            string output=BanUtil.RunMachineBan("/ban:"+string.Format("0x{0:X16}", mach.Id)+" /startdate:"+year+"-"+month+"-"+day);

            BanUtil.CheckOutputForBasicBadness(output);
            VerifyOutputStatus(output, new ulong[]{mach.Id}, null);

            BanUtil.VerifySingleMachineBan(mach.Id, 0x8015190D, banDate, System.DateTime.MaxValue);
            BanUtil.VerifyNoConsoleBan(mach.ConsoleId);
        }

        [TestCase, Description("Ban one machine specifying an end date in the default format.")]
        public void SingleEndDate()
        {
            int daysOffset=100;
            System.DateTime alteredNowDate=System.DateTime.UtcNow+new System.TimeSpan(daysOffset, 0, 0, 0);
            int year=alteredNowDate.Year;
            int month=alteredNowDate.Month;
            int day=alteredNowDate.Day;
            System.DateTime banEndDate=new System.DateTime(year, month, day);

            MachineEditor mach=MachineEditor.FromId(BanUtil.CreateMachine(MachineType.Xbox360));

            string output=BanUtil.RunMachineBan("/ban:"+string.Format("0x{0:X16}", mach.Id)+" /enddate:"+year+"-"+month+"-"+day);

            BanUtil.CheckOutputForBasicBadness(output);
            VerifyOutputStatus(output, new ulong[]{mach.Id}, null);

            BanUtil.VerifySingleMachineBan(mach.Id, 0x8015190D, System.DateTime.UtcNow, banEndDate);
            BanUtil.VerifyNoConsoleBan(mach.ConsoleId);
        }

        [TestCase, Description("Ban one machine specifying /dateformat as well as a start and end date.")]
        public void SingleDateFormat()
        {
            System.DateTime banStart=new System.DateTime(2011, 1, 1, 1, 1, 1);
            System.DateTime banEnd=new System.DateTime(2015, 12, 31, 23, 59, 59);

            MachineEditor mach=MachineEditor.FromId(BanUtil.CreateMachine(MachineType.Xbox360));

            string output=BanUtil.RunMachineBan("/ban:"+string.Format("0x{0:X16}", mach.Id)+" /dateformat:yyyy'-'MM'-'dd'*'HH'+'mm'+'ss /startdate:2011-01-01*01+01+01 /enddate:2015-12-31*23+59+59");

            BanUtil.CheckOutputForBasicBadness(output);
            VerifyOutputStatus(output, new ulong[]{mach.Id}, null);

            BanUtil.VerifySingleMachineBan(mach.Id, 0x8015190D, banStart, banEnd);
            BanUtil.VerifyNoConsoleBan(mach.ConsoleId);
        }

        [TestCase, Description("When one PC machine is banned all other machines associated with that voucher are banned.")]
        public void SinglePCMultipleMachinesFromVoucher()
        {
            string voucher=BanUtil.CreateUnlimitedPCVoucher();
            MachineEditor mach0=MachineEditor.FromId(BanUtil.CreatePCMachine(voucher));
            MachineEditor mach1=MachineEditor.FromId(BanUtil.CreatePCMachine(voucher));

            string output=BanUtil.RunMachineBan("/ban:"+string.Format("0x{0:X16}", mach0.Id));

            BanUtil.CheckOutputForBasicBadness(output);
            VerifyOutputStatus(output, new ulong[]{mach0.Id, mach1.Id}, null);

            BanUtil.VerifySingleMachineBan(mach0.Id, 0x8015190D);
            BanUtil.VerifyNoConsoleBan(mach0.ConsoleId);
            BanUtil.VerifySingleMachineBan(mach1.Id, 0x8015190D);
            BanUtil.VerifyNoConsoleBan(mach1.ConsoleId);
            BanUtil.VerifyVoucherBan(voucher);
        }

        [TestCase, Description("When one PC machine is banned all other machines associated with that voucher are banned exactly once even if both are passed.")]
        public void FileMultipleMachinesFromVoucher_BothInFile()
        {
            string voucher=BanUtil.CreateUnlimitedPCVoucher();
            MachineEditor mach0=MachineEditor.FromId(BanUtil.CreatePCMachine(voucher));
            MachineEditor mach1=MachineEditor.FromId(BanUtil.CreatePCMachine(voucher));

            string filename=BanUtil.WriteTempFile(new ulong[]{mach0.Id, mach1.Id});

            string output=BanUtil.RunMachineBan("/ban /file:"+filename);

            BanUtil.CheckOutputForBasicBadness(output);
            VerifyOutputStatus(output, new ulong[]{mach0.Id, mach1.Id}, null);

            BanUtil.VerifySingleMachineBan(mach0.Id, 0x8015190D);
            BanUtil.VerifyNoConsoleBan(mach0.ConsoleId);
            BanUtil.VerifySingleMachineBan(mach1.Id, 0x8015190D);
            BanUtil.VerifyNoConsoleBan(mach1.ConsoleId);
            BanUtil.VerifyVoucherBan(voucher);
        }

        [TestCase, Description("Pass an empty file in to ban.")]
        public void FileEmpty()
        {
            string filename=BanUtil.WriteTempFile("");
            string output=BanUtil.RunMachineBan("/ban /file:"+filename);
            BanUtil.CheckOutputForBasicBadness(output);
        }

        [TestCase, Description("Ban one machine that is a duplicate console id.")]
        public void SingleDuplicateConsole(TestNode self)
        {
            MachineEditor mach0=MachineEditor.FromId(BanUtil.CreateMachine(MachineType.Xbox360));
            MachineEditor mach1=MachineEditor.CreateDuplicateXbox360(mach0.ConsoleId);
            Global.RO.Debug("Created duplicate machine: 0x{0:X}", mach1.Id);

            string output=BanUtil.RunMachineBan("/ban:"+string.Format("0x{0:X16}", mach0.Id));

            BanUtil.CheckOutputForBasicBadness(output);
            VerifyOutputStatus(output, new ulong[]{mach0.Id}, null);

            BanUtil.VerifySingleMachineBan(mach0.Id, 0x8015190D);
            BanUtil.VerifyNoConsoleBan(mach0.ConsoleId);

            BanUtil.VerifyNoMachineBan(mach1.Id);
            BanUtil.VerifyNoConsoleBan(mach1.ConsoleId);
        }
    };
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\MachineBan\test\makefile.inc ===
!include $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\MachineBan\test\CheckReady.cs ===
//NOTE: These tests depend on the MachineBan directory also being built and binplaced

using ServerTestFramework;
using ServerTestFramework.Utilities;
using ServerTestFramework.Database;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.Auth;
using System.Runtime.InteropServices;

namespace MachineBanTest
{
    [TestGroup, Description("General Machine Ban Tests")]
    public class CheckReady: TestNode
    {
        [TestCase, Description("Pass the help paramter.")]
        public void Mainline()
        {
            string output=BanUtil.RunMachineBan("/checkready");
            BanUtil.CheckOutputForBasicBadness(output);
            if (output.ToLower().Contains("fail"))
            {
                throw new UnexpectedTestResultException("CheckReady reported failure.");
            }

            if (!output.ToLower().Contains("checks completed"))
            {
                throw new UnexpectedTestResultException("CheckReady never completed its checks.");
            }
        }
    };
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\MachineBan\test\General.cs ===
//NOTE: These tests depend on the MachineBan directory also being built and binplaced

using ServerTestFramework;
using ServerTestFramework.Utilities;
using ServerTestFramework.Database;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.Auth;
using System.Runtime.InteropServices;

namespace MachineBanTest
{
    [TestGroup, Description("General Machine Ban Tests")]
    public class General: TestNode
    {
        [TestCase, Description("Pass the help paramter.")]
        public void Help()
        {
            string output=BanUtil.RunMachineBan("/?");
            string []expectedTokens=new string[]{"/ban", "/unban", "/file", "/consoleid", "/fivebyfive", "/lookup", "/reason", "/startdate", "/enddate", "/dateformat", "/checkready"};
            foreach (string e in expectedTokens)
            {
                if (!output.Contains(e))
                {
                    throw new UnexpectedTestResultException("Expected help text to contain an entry for: "+e);
                }
            }
        }

        [TestCase, Description("Pass a parameter that doesn't exist")]
        [CompoundCase("BadWithBan", "/ban:0xfa00000000000000 /wtf")]
        [CompoundCase("BadOnly", "/badness")]
        public void BadParameter(TestNode self)
        {
            string param=(string)self.MyValues[0];

            string output=BanUtil.RunMachineBan(param);
            if (!output.ToLower().Contains("invalid parameter"))
            {
                throw new UnexpectedTestResultException("Expected output to contain: invalid parameter");
            }
        }
    };
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\MachineBan\test\LookupPuid.cs ===
using ServerTestFramework;
using ServerTestFramework.Utilities;
using ServerTestFramework.Database;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.Auth;

using System.Collections.Generic;

namespace MachineBanTest
{
    [TestGroup, Description("Tests for looking up machine puid bans (/lookup).")]
    public class LookupPuid: TestNode
    {
        public static void VerifyOutputStatus(string output, ulong []puids)
        {
            List<ulong> expectedPuids=new List<ulong>();
            List<uint> expectedReasons=new List<uint>();
            List<System.DateTime?> expectedStarts=new List<System.DateTime?>();
            List<System.DateTime?> expectedEnds=new List<System.DateTime?>();

            //lookup the actual bans in the db
            foreach (ulong puid in puids)
            {
                MachineEditor mach=MachineEditor.FromId(puid);
                foreach (MachineEditor.MachineBanStatus mban in mach.GetAllMachineBans())
                {
                    expectedPuids.Add(mban.MachineId);
                    expectedReasons.Add(unchecked((uint)mban.ReasonCode));
                    expectedStarts.Add(mban.StartDate);
                    expectedEnds.Add(mban.EndDate);
                }
            }

            VerifyOutputStatus(output, expectedPuids.ToArray(), expectedReasons.ToArray(), expectedStarts.ToArray(), expectedEnds.ToArray());
        }

        public static void VerifyOutputStatus(string output, ulong []puids, uint []expectedReasons, System.DateTime? []expectedStarts, System.DateTime? []expectedEnds)
        {
            string []machineStrings=new string[puids.Length];
            for (int i=0; i<puids.Length; ++i)
            {
                machineStrings[i]=string.Format("0x{0:X16}", puids[i]);
            }

            VerifyOutputStatus(output, machineStrings, expectedReasons, expectedStarts, expectedEnds);
        }

        public static void VerifyOutputStatus(string output, string []machineStrings, uint []expectedReasons, System.DateTime? []expectedStarts, System.DateTime? []expectedEnds)
        {
            //find the status strings in the output
            List<string> stringsFound=new List<string>();

            string []outputLines=output.Replace("\r","").Split(new char[]{'\n'});
            foreach (string line in outputLines)
            {
                if (line.Contains(": ")) //one of the machine status rows
                {
                    int indexStart=line.IndexOf(":")+2;
                    int length=line.Length-indexStart;
                    if (line.Contains(" (")) //filter out the optional comment
                    {
                        length-=line.Length-line.IndexOf(" (");
                    }
                    stringsFound.Add(line.Substring(indexStart, length));
                }
            }

            //build a list of strings we expect
            List<string> stringsExpected=new List<string>();

            if (!(expectedReasons==null || expectedStarts==null || expectedEnds==null))
            {
                for (int i=0; i<machineStrings.Length; ++i)
                {
                    if (expectedStarts[i]!=null)
                    {
                        string line=string.Format("{0} - 0x{1:X8} - ", machineStrings[i], expectedReasons[i])+expectedStarts[i].ToString()+" - "+expectedEnds[i].ToString();
                        stringsExpected.Add(line);
                    }
                    else
                    {
                        string line=string.Format("{0} - 0x{1:X8}", machineStrings[i], expectedReasons[i]);
                        stringsExpected.Add(line);
                    }
                }
            }

            //compare
            ValueCheck.TestAllUnordered("Machine status output", stringsExpected, stringsFound);

            //if none were expected, check for that message
            if (expectedReasons.Length==0)
            {
                if (!output.Contains("Machine Puid Lookup returned no results."))
                {
                    throw new UnexpectedTestResultException("Expected output to contain: Machine Puid Lookup returned no results.");
                }
            }
        }

        // -----

        [TestCase, Description("Lookup one machine that is machine banned in hex on the commandline.")]
        [CompoundCase("Xbox360", MachineType.Xbox360)]
        [CompoundCase("Phone", MachineType.Phone)]
        [CompoundCase("PC", MachineType.PC)]
        public void SingleHexMachineBanned(TestNode self)
        {
            MachineType mtype=(MachineType)self.MyValues[0];
            MachineEditor mach=MachineEditor.FromId(BanUtil.CreateMachine(mtype));
            mach.BanMachine(unchecked((int)0x8015190D), System.DateTime.UtcNow, System.DateTime.MaxValue);

            string output=BanUtil.RunMachineBan("/lookup:"+string.Format("0x{0:X16}", mach.Id));

            BanUtil.CheckOutputForBasicBadness(output);
            VerifyOutputStatus(output, new ulong[]{mach.Id});

            BanUtil.VerifySingleMachineBan(mach.Id, 0x8015190D);
            BanUtil.VerifyNoConsoleBan(mach.ConsoleId);
        }

        [TestCase, Description("Lookup one machine that is not banned in hex on the commandline.")]
        public void SingleNotBanned()
        {
            MachineEditor mach=MachineEditor.FromId(BanUtil.CreateMachine(MachineType.Xbox360));

            string output=BanUtil.RunMachineBan("/lookup:"+string.Format("0x{0:X16}", mach.Id));

            BanUtil.CheckOutputForBasicBadness(output);
            VerifyOutputStatus(output, new ulong[]{mach.Id});

            BanUtil.VerifyNoMachineBan(mach.Id);
            BanUtil.VerifyNoConsoleBan(mach.ConsoleId);
        }

        [TestCase, Description("Lookup one machine in unsigned decimal on the commandline.")]
        public void SinglePositiveDecimal()
        {
            MachineEditor mach=MachineEditor.FromId(BanUtil.CreateMachine(MachineType.Xbox360));
            mach.BanMachine(unchecked((int)0x8015190D), System.DateTime.UtcNow, System.DateTime.MaxValue);

            string output=BanUtil.RunMachineBan("/lookup:"+(ulong)mach.Id);

            BanUtil.CheckOutputForBasicBadness(output);
            VerifyOutputStatus(output, new ulong[]{mach.Id});
        }

        [TestCase, Description("Lookup one machine in signed decimal on the commandline.")]
        public void SingleNegativeDecimal()
        {
            MachineEditor mach=MachineEditor.FromId(BanUtil.CreateMachine(MachineType.Xbox360));
            mach.BanMachine(unchecked((int)0x8015190D), System.DateTime.UtcNow, System.DateTime.MaxValue);

            string output=BanUtil.RunMachineBan("/lookup:"+(long)mach.Id);

            BanUtil.CheckOutputForBasicBadness(output);
            VerifyOutputStatus(output, new ulong[]{mach.Id});
        }

        [TestCase, Description("Lookup one machine that has multiple bans in hex on the commandline.")]
        public void SingleMultipleBans()
        {
            MachineEditor mach=MachineEditor.FromId(BanUtil.CreateMachine(MachineType.Xbox360));
            mach.BanMachine(unchecked((int)0xFFFF0000), System.DateTime.UtcNow, System.DateTime.MaxValue);
            mach.BanMachine(unchecked((int)0xFFFF0001), System.DateTime.UtcNow, System.DateTime.UtcNow+new System.TimeSpan(10, 0, 0, 0));
            mach.BanMachine(unchecked((int)0xFFFF0002), System.DateTime.UtcNow+new System.TimeSpan(10, 0, 0, 0), System.DateTime.MaxValue);

            string output=BanUtil.RunMachineBan("/lookup:"+string.Format("0x{0:X16}", mach.Id));

            BanUtil.CheckOutputForBasicBadness(output);
            VerifyOutputStatus(output, new ulong[]{mach.Id});
        }

        [TestCase, Description("Lookup one invalid machine id (platform type isn't real).")]
        public void SingleInvalidMachine()
        {
            ulong id=0x13;
            string output=BanUtil.RunMachineBan("/lookup:"+string.Format("0x{0:X16}", id));

            BanUtil.CheckOutputForBasicBadness(output);
            VerifyOutputStatus(output, new ulong[]{id});
        }

        [TestCase, Description("Lookup one machine id that does not exist (but is in a valid range).")]
        public void SingleNonexistantMachine()
        {
            ulong id=0xfa00ffffffff1234;
            string output=BanUtil.RunMachineBan("/lookup:"+string.Format("0x{0:X16}", id));

            BanUtil.CheckOutputForBasicBadness(output);
            VerifyOutputStatus(output, new ulong[]{id});
        }

        [TestCase, Description("Lookup from a file.")]
        [CompoundCase("SingleMachineSingleBan", 1, 1)]
        [CompoundCase("MultipleMachinesSingleBans", 10, 1)]
        [CompoundCase("MultipleMachinesMultipleBans", 25, 5)]
        public void File(TestNode self)
        {
            int machineCount=(int)self.MyValues[0];
            int banCount=(int)self.MyValues[1];

            ulong []puids=new ulong[machineCount];
            MachineEditor []machs=new MachineEditor[machineCount];
            for (int i=0; i<machineCount; ++i)
            {
                machs[i]=MachineEditor.FromId(BanUtil.CreateMachine(MachineType.Xbox360));
                puids[i]=machs[i].Id;

                for (int x=0; x<banCount; ++x)
                {
                    machs[i].BanMachine(unchecked((int)(x+0x80000001)), System.DateTime.UtcNow, System.DateTime.MaxValue);
                }
            }
            string filename=BanUtil.WriteTempFile(puids);

            string output=BanUtil.RunMachineBan("/lookup /file:"+filename);

            BanUtil.CheckOutputForBasicBadness(output);
            VerifyOutputStatus(output, puids);
        }

        [TestCase, Description("Lookup multiple machines from a file with some invalid entries and one entry included twice.")]
        public void FileMultipleMixedInvalid()
        {
            System.DateTime banStart=System.DateTime.UtcNow;
            MachineEditor mach0=MachineEditor.FromId(BanUtil.CreateMachine(MachineType.Xbox360));
            mach0.BanMachine(unchecked((int)0x80150000), banStart, System.DateTime.MaxValue);
            MachineEditor mach1=MachineEditor.FromId(BanUtil.CreateMachine(MachineType.Xbox360));
            mach1.BanMachine(unchecked((int)0x80150001), banStart, System.DateTime.MaxValue);
            string filename=BanUtil.WriteTempFile(new string[]{string.Format("0x{0:X16}", mach0.Id), "wtf", "0x-99999999999999999999999999", "7", mach0.Id.ToString(), string.Format("0x{0:X16}", mach1.Id)});

            string output=BanUtil.RunMachineBan("/lookup /file:"+filename);

            BanUtil.CheckOutputForBasicBadness(output);
            VerifyOutputStatus(output,
                               new string[]{string.Format("0x{0:X16}", mach0.Id), string.Format("0x{0:X16}", mach0.Id), string.Format("0x{0:X16}", mach1.Id), "wtf", "0x-99999999999999999999999999", "7"},
                               new uint[]{0x80150000, 0x80150000, 0x80150001, 0x80004005, 0x80004005, 0x80004005},
                               new System.DateTime?[]{banStart, banStart, banStart, null, null, null},
                               new System.DateTime?[]{System.DateTime.MaxValue, System.DateTime.MaxValue, System.DateTime.MaxValue, null, null, null});
        }

        [TestCase, Description("Verify consoleid-only bans are not picked up.")]
        public void CheckConsoleIdBans()
        {
            MachineEditor mach=MachineEditor.FromId(BanUtil.CreateMachine(MachineType.Xbox360));
            ConsoleBanEditor.FromConsoleId(mach.ConsoleId).BanConsole(unchecked((int)0x8015190D), System.DateTime.UtcNow);

            string output=BanUtil.RunMachineBan("/lookup:"+string.Format("0x{0:X16}", mach.Id));

            BanUtil.CheckOutputForBasicBadness(output);
            VerifyOutputStatus(output, new ulong[]{mach.Id});
        }
    };
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\MachineBan\test\Suite.cs ===
using ServerTestFramework;

[assembly: RootNode(typeof(MachineBanTest.MachineBanTest))]

namespace MachineBanTest
{
    [TestGroup, Owner("LukeL"), TestFrequency("Regression"), TestCasePriority(1)]
    public class MachineBanTest: TestNode
    {
    };
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\MachineBan\test\ResetConsoleId.cs ===
using ServerTestFramework;
using ServerTestFramework.Utilities;
using ServerTestFramework.Database;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.Auth;

using System.Collections.Generic;

namespace MachineBanTest
{
    [TestGroup, Description("Tests for resetting machine keys (/reset /consoleid).")]
    public class ResetConsoleId: TestNode
    {
        public static void VerifyOutputStatus(string output, string []machineStrings, uint []puidResults)
        {
            //find the status strings in the output
            List<string> stringsFound=new List<string>();

            string []outputLines=output.Replace("\r","").Split(new char[]{'\n'});
            foreach (string line in outputLines)
            {
                if (line.Contains(": ")) //one of the machine status rows
                {
                    int indexStart=line.IndexOf(":")+2;
                    int length=line.Length-indexStart;
                    if (line.Contains(" (")) //filter out the optional comment
                    {
                        length-=line.Length-line.IndexOf(" (");
                    }
                    stringsFound.Add(line.Substring(indexStart, length));
                }
            }

            //build a list of strings we expect
            List<string> stringsExpected=new List<string>();

            for (int i=0; i<machineStrings.Length; ++i)
            {
                uint result=0;
                if (puidResults!=null)
                {
                    result=puidResults[i];
                }
                string line=string.Format("{0} - 0x{1:X8}", machineStrings[i], result);
                stringsExpected.Add(line);
            }

            //compare
            ValueCheck.TestAllUnordered("Machine status output", stringsExpected, stringsFound);
        }

        // -----

        [TestCase, Description("Reset one console on the commandline.")]
        public void Single()
        {
            MachineEditor mach=MachineEditor.FromId(BanUtil.CreateMachine(MachineType.Xbox360));
            BanUtil.MachineKeyState origKeyState=BanUtil.GetMachineKeyState(mach.Id);

            string output=BanUtil.RunMachineBan("/consoleid /reset:"+mach.ConsoleId);

            BanUtil.CheckOutputForBasicBadness(output);
            VerifyOutputStatus(output, new string[]{mach.ConsoleId}, null);

            BanUtil.VerifyNoMachineBan(mach.Id);
            BanUtil.VerifyNoConsoleBan(mach.ConsoleId);

            BanUtil.VerifyMachineKeyStateDifferent(mach.Id, origKeyState, BanUtil.GetMachineKeyState(mach.Id));
        }

        [TestCase, Description("Reset one machine for a platform where console IDs are not supported.")]
        [CompoundCase("Phone", MachineType.Phone)]
        [CompoundCase("PC", MachineType.PC)]
        public void UnsupportedPlatform(TestNode self)
        {
            MachineType mtype=(MachineType)self.MyValues[0];
            MachineEditor mach=MachineEditor.FromId(BanUtil.CreateMachine(mtype));
            BanUtil.MachineKeyState origKeyState=BanUtil.GetMachineKeyState(mach.Id);

            string output=BanUtil.RunMachineBan("/consoleid /reset:"+mach.ConsoleId);

            BanUtil.CheckOutputForBasicBadness(output);
            VerifyOutputStatus(output, new string[]{mach.ConsoleId}, new uint[]{0x80004005}); //E_FAIL

            BanUtil.VerifyMachineKeyStateSame(mach.Id, origKeyState, BanUtil.GetMachineKeyState(mach.Id));
        }

        [TestCase, Description("Reset one console id that does not exist (but is in a valid range).")]
        public void SingleNonexistantMachine()
        {
            string cid=MachineEditor.GenerateRandomConsoleID(MachineType.Xbox360);

            string output=BanUtil.RunMachineBan("/reset:"+cid+" /consoleid");

            BanUtil.CheckOutputForBasicBadness(output);
            VerifyOutputStatus(output, new string[]{cid}, new uint[]{0x80004005}); //E_FAIL
        }

        [TestCase, Description("Reset from a file.")]
        [CompoundCase("One", 1)]
        [CompoundCase("Multiple", 10)]
        public void File(TestNode self)
        {
            int machineCount=(int)self.MyValues[0];

            ulong []puids=new ulong[machineCount];
            string []cids=new string[machineCount];
            MachineEditor []machs=new MachineEditor[machineCount];
            BanUtil.MachineKeyState []origKeyState=new BanUtil.MachineKeyState[machineCount];
            for (int i=0; i<machineCount; ++i)
            {
                machs[i]=MachineEditor.FromId(BanUtil.CreateMachine(MachineType.Xbox360));
                cids[i]=machs[i].ConsoleId;
                puids[i]=machs[i].Id;
                origKeyState[i]=BanUtil.GetMachineKeyState(puids[i]);
            }
            string filename=BanUtil.WriteTempFile(cids);

            string output=BanUtil.RunMachineBan("/reset /consoleid /file:"+filename);

            BanUtil.CheckOutputForBasicBadness(output);
            VerifyOutputStatus(output, cids, null);

            for (int i=0; i<machineCount; ++i)
            {
                BanUtil.VerifyMachineKeyStateDifferent(puids[i], origKeyState[i], BanUtil.GetMachineKeyState(puids[i]));
            }
        }

        [TestCase, Description("Reset a mixture of valid and invalid console ids in a file.")]
        public void FileMultipleMixedInvalid()
        {
            MachineEditor mach0=MachineEditor.FromId(BanUtil.CreateMachine(MachineType.Xbox360));
            string bad0="XE.xxxxxxxxxxxx";
            string bad1="wtf";
            string bad2=mach0.ConsoleId+"TooLong";
            string bad3="XE.112233445561"; //bad checksum digit
            MachineEditor mach1=MachineEditor.FromId(BanUtil.CreateMachine(MachineType.Xbox360));
            string filename=BanUtil.WriteTempFile(new string[]{mach0.ConsoleId, bad0, bad1, bad2, bad3, mach1.ConsoleId});

            string output=BanUtil.RunMachineBan("/consoleid /reset /file:"+filename);

            BanUtil.CheckOutputForBasicBadness(output);
            VerifyOutputStatus(output,
                               new string[]{mach0.ConsoleId, mach1.ConsoleId, bad0, bad1, bad2, bad3},
                               new uint[]{0, 0, 0x80004005, 0x80004005, 0x80004005, 0x80004005});
        }
    };
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\MachineBan\test\LookupConsoleId.cs ===
using ServerTestFramework;
using ServerTestFramework.Utilities;
using ServerTestFramework.Database;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.Auth;

using System.Collections.Generic;

namespace MachineBanTest
{
    [TestGroup, Description("Tests for looking up console id bans (/lookup /consoleid).")]
    public class LookupConsoleId: TestNode
    {
        public static void VerifyOutputStatus(string output, string []cids)
        {
            List<string> expectedCids=new List<string>();
            List<uint> expectedReasons=new List<uint>();
            List<System.DateTime?> expectedStarts=new List<System.DateTime?>();

            //lookup the actual bans in the db
            foreach (string cid in cids)
            {
                ConsoleBanEditor cbe=ConsoleBanEditor.FromConsoleId(cid);
                foreach (ConsoleBanEditor.ConsoleBanStatus cban in cbe.GetAllConsoleBans())
                {
                    expectedCids.Add(cban.ConsoleId);
                    expectedReasons.Add(unchecked((uint)cban.ReasonCode));
                    expectedStarts.Add(cban.StartDate);
                }
            }

            VerifyOutputStatus(output, expectedCids.ToArray(), expectedReasons.ToArray(), expectedStarts.ToArray());
        }

        public static void VerifyOutputStatus(string output, string []machineStrings, uint []expectedReasons, System.DateTime? []expectedStarts)
        {
            //find the status strings in the output
            List<string> stringsFound=new List<string>();

            string []outputLines=output.Replace("\r","").Split(new char[]{'\n'});
            foreach (string line in outputLines)
            {
                if (line.Contains(": ")) //one of the machine status rows
                {
                    int indexStart=line.IndexOf(":")+2;
                    int length=line.Length-indexStart;
                    if (line.Contains(" (")) //filter out the optional comment
                    {
                        length-=line.Length-line.IndexOf(" (");
                    }
                    stringsFound.Add(line.Substring(indexStart, length));
                }
            }

            //build a list of strings we expect
            List<string> stringsExpected=new List<string>();

            if (!(expectedReasons==null || expectedStarts==null))
            {
                for (int i=0; i<machineStrings.Length; ++i)
                {
                    if (expectedStarts[i]!=null)
                    {
                        string line=string.Format("{0} - 0x{1:X8} - ", machineStrings[i], expectedReasons[i])+expectedStarts[i].ToString()+" - "+System.DateTime.MaxValue.ToString();
                        stringsExpected.Add(line);
                    }
                    else
                    {
                        string line=string.Format("{0} - 0x{1:X8}", machineStrings[i], expectedReasons[i]);
                        stringsExpected.Add(line);
                    }
                }
            }

            //compare
            ValueCheck.TestAllUnordered("Machine status output", stringsExpected, stringsFound);

            //if none were expected, check for that message
            if (expectedReasons.Length==0)
            {
                if (!output.Contains("Console Id Lookup returned no results."))
                {
                    throw new UnexpectedTestResultException("Expected output to contain: Console Id Lookup returned no results.");
                }
            }
        }

        // -----

        [TestCase, Description("Lookup one machine that is console banned on the commandline.")]
        public void SingleBanned()
        {
            MachineEditor mach=MachineEditor.FromId(BanUtil.CreateMachine(MachineType.Xbox360));
            ConsoleBanEditor.FromConsoleId(mach.ConsoleId).BanConsole(unchecked((int)0x8015190D), System.DateTime.UtcNow);

            string output=BanUtil.RunMachineBan("/consoleid /lookup:"+mach.ConsoleId);

            BanUtil.CheckOutputForBasicBadness(output);
            VerifyOutputStatus(output, new string[]{mach.ConsoleId});

            BanUtil.VerifyNoMachineBan(mach.Id);
            BanUtil.VerifySingleConsoleBan(mach.ConsoleId, 0x8015190D);
        }

        [TestCase, Description("Lookup one machine that is not banned on the commandline.")]
        public void SingleNotBanned()
        {
            MachineEditor mach=MachineEditor.FromId(BanUtil.CreateMachine(MachineType.Xbox360));

            string output=BanUtil.RunMachineBan("/lookup:"+mach.ConsoleId+" /consoleid");

            BanUtil.CheckOutputForBasicBadness(output);
            VerifyOutputStatus(output, new string[]{mach.ConsoleId});

            BanUtil.VerifyNoMachineBan(mach.Id);
            BanUtil.VerifyNoConsoleBan(mach.ConsoleId);
        }

        [TestCase, Description("Lookup one machine for a platform where console IDs are not supported.")]
        [CompoundCase("Phone", MachineType.Phone)]
        [CompoundCase("PC", MachineType.PC)]
        public void UnsupportedPlatform(TestNode self)
        {
            MachineType mtype=(MachineType)self.MyValues[0];
            MachineEditor mach=MachineEditor.FromId(BanUtil.CreateMachine(mtype));

            string output=BanUtil.RunMachineBan("/consoleid /lookup:"+mach.ConsoleId);
            BanUtil.CheckOutputForBasicBadness(output);
            VerifyOutputStatus(output, new string[]{mach.ConsoleId}, new uint[]{0x80004005}, new System.DateTime?[]{null}); //E_FAIL
        }

        [TestCase, Description("Lookup one machine that has multiple console bans on the commandline.")]
        public void SingleMultipleBans()
        {
            MachineEditor mach=MachineEditor.FromId(BanUtil.CreateMachine(MachineType.Xbox360));
            ConsoleBanEditor.FromConsoleId(mach.ConsoleId).BanConsole(unchecked((int)0xFFFF0001), System.DateTime.UtcNow);
            ConsoleBanEditor.FromConsoleId(mach.ConsoleId).BanConsole(unchecked((int)0xFFFF0002), System.DateTime.UtcNow+new System.TimeSpan(10, 0, 0, 0));
            ConsoleBanEditor.FromConsoleId(mach.ConsoleId).BanConsole(unchecked((int)0xFFFF0003), System.DateTime.UtcNow+new System.TimeSpan(20, 0, 0, 0));

            string output=BanUtil.RunMachineBan("/lookup:"+mach.ConsoleId+" /consoleid");

            BanUtil.CheckOutputForBasicBadness(output);
            VerifyOutputStatus(output, new string[]{mach.ConsoleId});
        }

        [TestCase, Description("Lookup one console id that does not exist (but is in a valid range).")]
        public void SingleNonexistantMachine()
        {
            string cid=MachineEditor.GenerateRandomConsoleID(MachineType.Xbox360);

            string output=BanUtil.RunMachineBan("/lookup:"+cid+" /consoleid");

            BanUtil.CheckOutputForBasicBadness(output);
            VerifyOutputStatus(output, new string[]{cid});
        }

        [TestCase, Description("Lookup from a file.")]
        [CompoundCase("SingleMachineSingleBan", 1, 1)]
        [CompoundCase("MultipleMachinesSingleBans", 10, 1)]
        [CompoundCase("MultipleMachinesMultipleBans", 25, 5)]
        public void File(TestNode self)
        {
            int machineCount=(int)self.MyValues[0];
            int banCount=(int)self.MyValues[1];

            string []cids=new string[machineCount];
            MachineEditor []machs=new MachineEditor[machineCount];
            for (int i=0; i<machineCount; ++i)
            {
                machs[i]=MachineEditor.FromId(BanUtil.CreateMachine(MachineType.Xbox360));
                cids[i]=machs[i].ConsoleId;

                for (int x=0; x<banCount; ++x)
                {
                    ConsoleBanEditor.FromConsoleId(machs[i].ConsoleId).BanConsole(unchecked((int)(x+0x80000001)), System.DateTime.UtcNow);
                }
            }
            string filename=BanUtil.WriteTempFile(cids);

            string output=BanUtil.RunMachineBan("/lookup /file:"+filename+" /consoleid");

            BanUtil.CheckOutputForBasicBadness(output);
            VerifyOutputStatus(output, cids);
        }

        [TestCase, Description("Lookup a mixture of valid and invalid console ids in a file.")]
        public void FileMultipleMixedInvalid()
        {
            System.DateTime banStart=System.DateTime.UtcNow;
            MachineEditor mach0=MachineEditor.FromId(BanUtil.CreateMachine(MachineType.Xbox360));
            ConsoleBanEditor.FromConsoleId(mach0.ConsoleId).BanConsole(unchecked((int)0x8015190D), banStart);
            string bad0="XE.xxxxxxxxxxxx";
            string bad1="wtf";
            string bad2=mach0.ConsoleId+"TooLong";
            string bad3="XE.112233445561"; //bad checksum digit
            MachineEditor mach1=MachineEditor.FromId(BanUtil.CreateMachine(MachineType.Xbox360));
            ConsoleBanEditor.FromConsoleId(mach1.ConsoleId).BanConsole(unchecked((int)0x8015190D), banStart);
            string filename=BanUtil.WriteTempFile(new string[]{mach0.ConsoleId, bad0, bad1, bad2, bad3, mach1.ConsoleId});

            string output=BanUtil.RunMachineBan("/consoleid /lookup /file:"+filename);

            BanUtil.CheckOutputForBasicBadness(output);
            VerifyOutputStatus(output,
                               new string[]{mach0.ConsoleId, mach1.ConsoleId, bad0, bad1, bad2, bad3},
                               new uint[]{0x8015190D, 0x8015190D, 0x80004005, 0x80004005, 0x80004005, 0x80004005},
                               new System.DateTime?[]{banStart, banStart, null, null, null, null});
        }

        [TestCase, Description("Verify machine-puid-only bans are not picked up.")]
        public void CheckMachineBans()
        {
            MachineEditor mach=MachineEditor.FromId(BanUtil.CreateMachine(MachineType.Xbox360));
            mach.BanMachine(unchecked((int)0x8015190D), System.DateTime.UtcNow, System.DateTime.MaxValue);

            string output=BanUtil.RunMachineBan("/consoleid /lookup:"+mach.ConsoleId);

            BanUtil.CheckOutputForBasicBadness(output);
            VerifyOutputStatus(output, new string[]{mach.ConsoleId});
        }
    };
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\MachineBan\test\UnbanFiveByFive.cs ===
using ServerTestFramework;
using ServerTestFramework.Utilities;
using ServerTestFramework.Database;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.Auth;

using System.Collections.Generic;

namespace MachineBanTest
{
    [TestGroup, Description("Tests for unbanning PC vouchers (/ban /fivebyfive).")]
    public class UnbanFiveByFive: TestNode
    {
        public static void VerifyOutputStatus(string output, string []vouchers, uint []results)
        {
            //find the status strings in the output
            List<string> stringsFound=new List<string>();

            string []outputLines=output.Replace("\r","").Split(new char[]{'\n'});
            foreach (string line in outputLines)
            {
                if (line.Contains(": ")) //one of the machine status rows
                {
                    int indexStart=line.IndexOf(":")+2;
                    int length=line.Length-indexStart;
                    if (line.Contains(" (")) //filter out the optional comment
                    {
                        length-=line.Length-line.IndexOf(" (");
                    }
                    stringsFound.Add(line.Substring(indexStart, length));
                }
            }

            //build a list of strings we expect
            List<string> stringsExpected=new List<string>();

            for (int i=0; i<vouchers.Length; ++i)
            {
                uint result=0;
                if (results!=null)
                {
                    result=results[i];
                }
                string line=string.Format("{0} - 0x{1:X8}", vouchers[i], result);
                stringsExpected.Add(line);
            }

            //compare
            ValueCheck.TestAllUnordered("Voucher status output", stringsExpected, stringsFound);
        }

        // -----

        [TestCase, Description("Unban one on the commandline.")]
        [CompoundCase("NoMachines", 0)]
        [CompoundCase("OneMachine", 1)]
        [CompoundCase("TwoMachines", 2)]
        public void Single(TestNode self)
        {
            int machineCount=(int)self.MyValues[0];

            string voucher=BanUtil.CreateUnlimitedPCVoucher();

            MachineEditor []machs=new MachineEditor[machineCount];
            for (int i=0; i<machineCount; ++i)
            {
                machs[i]=MachineEditor.FromId(BanUtil.CreatePCMachine(voucher));
            }

            BanUtil.RunMachineBan("/fivebyfive /ban:"+voucher);
            string output=BanUtil.RunMachineBan("/fivebyfive /unban:"+voucher);

            BanUtil.CheckOutputForBasicBadness(output);
            VerifyOutputStatus(output, new string[]{voucher}, null);

            BanUtil.VerifyNoVoucherBan(voucher);
            for (int i=0; i<machineCount; ++i)
            {
                BanUtil.VerifySingleMachineBan(machs[i].Id, 0x8015190D, System.DateTime.UtcNow, System.DateTime.UtcNow);
            }
        }

        [TestCase, Description("Unban from a file.")]
        [CompoundCase("Single", 1)]
        [CompoundCase("Multiple", 10)]
        public void File(TestNode self)
        {
            int machineCount=(int)self.MyValues[0];

            string []vouchers=new string[machineCount];
            MachineEditor []machs=new MachineEditor[machineCount];
            for (int i=0; i<machineCount; ++i)
            {
                vouchers[i]=BanUtil.CreateUnlimitedPCVoucher();
                machs[i]=MachineEditor.FromId(BanUtil.CreatePCMachine(vouchers[i]));
            }
            string filename=BanUtil.WriteTempFile(vouchers);

            BanUtil.RunMachineBan("/fivebyfive /ban /file:"+filename);
            string output=BanUtil.RunMachineBan("/fivebyfive /unban /file:"+filename);

            BanUtil.CheckOutputForBasicBadness(output);
            VerifyOutputStatus(output, vouchers, null);

            for (int i=0; i<machineCount; ++i)
            {
                BanUtil.VerifyNoVoucherBan(vouchers[i]);
                BanUtil.VerifySingleMachineBan(machs[i].Id, 0x8015190D, System.DateTime.UtcNow, System.DateTime.UtcNow);
            }
        }

        [TestCase, Description("Unban a mixture of valid and invalid vouchers.")]
        public void FileMixedInvalid()
        {
            List<string> vouchers=new List<string>();
            List<MachineEditor> machs=new List<MachineEditor>();

            vouchers.Add(BanUtil.CreateUnlimitedPCVoucher());
            machs.Add(MachineEditor.FromId(BanUtil.CreatePCMachine(vouchers[vouchers.Count-1]))); //valid
            BanUtil.RunMachineBan("/ban:"+machs[machs.Count-1].Id);

            vouchers.Add("P1234-OEHHC-OCEUH-OCEUH-OEUHI-OCEUI"); //valid doesn't exist but valid
            vouchers.Add("x"); //not valid

            string notBannedVoucher=BanUtil.CreateUnlimitedPCVoucher();
            vouchers.Add(notBannedVoucher+"-ABCDE"); //too long

            vouchers.Add(BanUtil.CreateUnlimitedPCVoucher());
            machs.Add(MachineEditor.FromId(BanUtil.CreatePCMachine(vouchers[vouchers.Count-1]))); //valid
            BanUtil.RunMachineBan("/ban:"+machs[machs.Count-1].Id);

            string filename=BanUtil.WriteTempFile(vouchers);

            string output=BanUtil.RunMachineBan("/fivebyfive /unban /file:"+filename);

            BanUtil.CheckOutputForBasicBadness(output);
            VerifyOutputStatus(output, vouchers.ToArray(), new uint[]{0, 0x80004005, 0x80004005, 0x80004005, 0});

            foreach (MachineEditor mach in machs)
            {
                BanUtil.VerifySingleMachineBan(mach.Id, 0x8015190D, System.DateTime.UtcNow, System.DateTime.UtcNow);
            }
        }

        [TestCase, Description("Attempt to specify reason code, which isn't currently supported for PCs.")]
        public void SingleReason()
        {
            string voucher=BanUtil.CreateUnlimitedPCVoucher();
            MachineEditor mach=MachineEditor.FromId(BanUtil.CreatePCMachine(voucher));

            string output=BanUtil.RunMachineBan("/fivebyfive /unban:"+voucher+" /reason:0x80000000");
            if (!output.ToLower().Contains("invalid parameter"))
            {
                throw new UnexpectedTestResultException("Expected output to contain 'invalid parameter'");
            }
        }

        [TestCase, Description("Attempt to unban specifying a start date, which isn't currently supported for PCs.")]
        public void SingleStartDate()
        {
            string voucher=BanUtil.CreateUnlimitedPCVoucher();
            MachineEditor mach=MachineEditor.FromId(BanUtil.CreatePCMachine(voucher));

            string output=BanUtil.RunMachineBan("/fivebyfive /unban:"+voucher+" /startdate:2020-10-13");
            if (!output.ToLower().Contains("invalid parameter"))
            {
                throw new UnexpectedTestResultException("Expected output to contain 'invalid parameter'");
            }
        }

        [TestCase, Description("Attempt to unban specifying an end date, which isn't currently supported for PCs.")]
        public void SingleEndDate()
        {
            string voucher=BanUtil.CreateUnlimitedPCVoucher();
            MachineEditor mach=MachineEditor.FromId(BanUtil.CreatePCMachine(voucher));

            string output=BanUtil.RunMachineBan("/fivebyfive /unban:"+voucher+" /enddate:2020-10-13");
            if (!output.ToLower().Contains("invalid parameter"))
            {
                throw new UnexpectedTestResultException("Expected output to contain 'invalid parameter'");
            }
        }
    };
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\MachineBan\test\obj\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("Microsoft(R) Xbox(TM)")]
[assembly:System.Reflection.AssemblyCopyright("Copyright (c) Microsoft Corporation. All rights reserved.")]
[assembly:System.Reflection.AssemblyCompany("Microsoft Corporation")]
[assembly:System.Reflection.AssemblyFileVersion("12.4.56.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\MachineBan\test\UnbanConsoleId.cs ===
using ServerTestFramework;
using ServerTestFramework.Utilities;
using ServerTestFramework.Database;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.Auth;

using System.Collections.Generic;

namespace MachineBanTest
{
    [TestGroup, Description("Tests for banning console IDs. (/ban /consoleid).")]
    public class UnbanConsoleId: TestNode
    {
        public static void VerifyOutputStatus(string output, string []cids, uint []puidResults)
        {
            //find the status strings in the output
            List<string> stringsFound=new List<string>();

            string []outputLines=output.Replace("\r","").Split(new char[]{'\n'});
            foreach (string line in outputLines)
            {
                if (line.Contains(": ")) //one of the machine status rows
                {
                    int indexStart=line.IndexOf(":")+2;
                    int length=line.Length-indexStart;
                    if (line.Contains(" (")) //filter out the optional comment
                    {
                        length-=line.Length-line.IndexOf(" (");
                    }
                    stringsFound.Add(line.Substring(indexStart, length));
                }
            }

            //build a list of strings we expect
            List<string> stringsExpected=new List<string>();

            for (int i=0; i<cids.Length; ++i)
            {
                uint result=0;
                if (puidResults!=null)
                {
                    result=puidResults[i];
                }
                string line=string.Format("{0} - 0x{1:X8}", cids[i], result);
                stringsExpected.Add(line);
            }

            //compare
            ValueCheck.TestAllUnordered("Machine status output", stringsExpected, stringsFound);
        }

        // -----

        [TestCase, Description("Unban one console id for an already-created machine on the commandline.")]
        public void SingleExisting()
        {
            MachineEditor mach=MachineEditor.FromId(BanUtil.CreateMachine(MachineType.Xbox360));

            BanUtil.RunMachineBan("/ban:"+mach.ConsoleId+" /consoleid");
            string output=BanUtil.RunMachineBan("/unban:"+mach.ConsoleId+" /consoleid");

            BanUtil.CheckOutputForBasicBadness(output);
            VerifyOutputStatus(output, new string[]{mach.ConsoleId}, null);

            BanUtil.VerifySingleMachineBan(mach.Id, 0x8015190D, System.DateTime.UtcNow, System.DateTime.UtcNow);
            BanUtil.VerifyNoConsoleBan(mach.ConsoleId);
        }

        [TestCase, Description("Unban one console id for a machine that hasn't yet been created on the commandline.")]
        public void SingleNonExisting()
        {
            string cid=MachineEditor.GenerateRandomConsoleID(MachineType.Xbox360);

            BanUtil.RunMachineBan("/ban:"+cid+" /consoleid");
            string output=BanUtil.RunMachineBan("/unban:"+cid+" /consoleid");

            BanUtil.CheckOutputForBasicBadness(output);
            VerifyOutputStatus(output, new string[]{cid}, null);

            BanUtil.VerifyNoConsoleBan(cid);
        }

        [TestCase, Description("Unban one console id for a machine that hasn't yet been created on the commandline.")]
        [CompoundCase("NoPrefix", "135246545656")]
        [CompoundCase("TooShort", "XE.13524654565")]
        [CompoundCase("TooLong", "XE.0135246545656")]
        [CompoundCase("BadChecksum", "XE.235246545659")]
        public void SingleInvalid(TestNode self)
        {
            string cid=(string)self.MyValues[0];

            string output=BanUtil.RunMachineBan("/unban:"+cid+" /consoleid");

            BanUtil.CheckOutputForBasicBadness(output);
            VerifyOutputStatus(output, new string[]{cid}, new uint[]{0x80004005}); //E_FAIL
        }

        [TestCase, Description("Unban a console ID for a platform that doesn't support console ID bans.")]
        [CompoundCase("Phone", "WM.111111111111")]
        [CompoundCase("PC", "PC.111111111111")]
        public void SingleUnsupportedPlatform(TestNode self)
        {
            string cid=(string)self.MyValues[0];

            string output=BanUtil.RunMachineBan("/unban:"+cid+" /consoleid");

            BanUtil.CheckOutputForBasicBadness(output);
            VerifyOutputStatus(output, new string[]{cid}, new uint[]{0x80004005}); //E_FAIL
        }

        [TestCase, Description("Unban one console id in a file.")]
        public void FileSingleExisting()
        {
            MachineEditor mach=MachineEditor.FromId(BanUtil.CreateMachine(MachineType.Xbox360));
            string filename=BanUtil.WriteTempFile(mach.ConsoleId);

            BanUtil.RunMachineBan("/ban /consoleid /file:"+filename);
            string output=BanUtil.RunMachineBan("/unban /consoleid /file:"+filename);

            BanUtil.CheckOutputForBasicBadness(output);
            VerifyOutputStatus(output, new string[]{mach.ConsoleId}, null);

            BanUtil.VerifySingleMachineBan(mach.Id, 0x8015190D, System.DateTime.UtcNow, System.DateTime.UtcNow);
            BanUtil.VerifyNoConsoleBan(mach.ConsoleId);
        }

        [TestCase, Description("Unban a mixture of valid and invalid console ids in a file.")]
        public void FileMultipleMixedInvalid()
        {
            MachineEditor mach0=MachineEditor.FromId(BanUtil.CreateMachine(MachineType.Xbox360));
            string bad0="XE.xxxxxxxxxxxx";
            string bad1="wtf";
            string bad2=mach0.ConsoleId+"TooLong";
            string bad3="XE.112233445561"; //bad checksum digit
            MachineEditor mach1=MachineEditor.FromId(BanUtil.CreateMachine(MachineType.Xbox360));
            string filename=BanUtil.WriteTempFile(new string[]{mach0.ConsoleId, bad0, bad1, bad2, bad3, mach1.ConsoleId});

            string output=BanUtil.RunMachineBan("/consoleid /unban /file:"+filename);

            BanUtil.CheckOutputForBasicBadness(output);
            VerifyOutputStatus(output, new string[]{mach0.ConsoleId, bad0,       bad1,       bad2,       bad3,       mach1.ConsoleId},
                                         new uint[]{0,               0x80004005, 0x80004005, 0x80004005, 0x80004005, 0});
        }

        [TestCase, Description("Unban a single consoleid with a valid reason code.")]
        public void SingleValidReason()
        {
            MachineEditor mach=MachineEditor.FromId(BanUtil.CreateMachine(MachineType.Xbox360));

            BanUtil.RunMachineBan("/consoleid /ban:"+mach.ConsoleId+" /reason:0xFF880000");
            string output=BanUtil.RunMachineBan("/consoleid /unban:"+mach.ConsoleId+" /reason:0xFF880000");

            BanUtil.CheckOutputForBasicBadness(output);
            VerifyOutputStatus(output, new string[]{mach.ConsoleId}, null);

            BanUtil.VerifySingleMachineBan(mach.Id, 0xFF880000, System.DateTime.UtcNow, System.DateTime.UtcNow);
            BanUtil.VerifyNoConsoleBan(mach.ConsoleId);
        }

        [TestCase, Description("Unban one machine specifying a start date in the default format.")]
        public void SingleStartDate()
        {
            MachineEditor mach=MachineEditor.FromId(BanUtil.CreateMachine(MachineType.Xbox360));

            BanUtil.RunMachineBan("/consoleid /ban:"+mach.ConsoleId);
            string output=BanUtil.RunMachineBan("/consoleid /unban:"+mach.ConsoleId+" /startdate:2020-10-13");
            if (!output.ToLower().Contains("invalid parameter"))
            {
                throw new UnexpectedTestResultException("Expected output to contain 'invalid parameter'");
            }

            BanUtil.VerifySingleMachineBan(mach.Id, 0x8015190D);
            BanUtil.VerifySingleConsoleBan(mach.ConsoleId, 0x8015190D);
        }

        [TestCase, Description("Unban one machine specifying an end date in the default format.  You can't specify an end date for a console ban.")]
        public void SingleEndDate()
        {
            MachineEditor mach=MachineEditor.FromId(BanUtil.CreateMachine(MachineType.Xbox360));

            BanUtil.RunMachineBan("/ban:"+mach.ConsoleId+" /consoleid");
            string output=BanUtil.RunMachineBan("/unban:"+mach.ConsoleId+" /consoleid /enddate:2020-10-13");
            if (!output.ToLower().Contains("invalid parameter"))
            {
                throw new UnexpectedTestResultException("Expected output to contain 'invalid parameter'");
            }

            BanUtil.VerifySingleMachineBan(mach.Id, 0x8015190D);
            BanUtil.VerifySingleConsoleBan(mach.ConsoleId, 0x8015190D);
        }
    };
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\MachineBan\test\objd\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("Microsoft(R) Xbox(TM)")]
[assembly:System.Reflection.AssemblyCopyright("Copyright (c) Microsoft Corporation. All rights reserved.")]
[assembly:System.Reflection.AssemblyCompany("Microsoft Corporation")]
[assembly:System.Reflection.AssemblyFileVersion("12.4.56.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\MachineBan\test\ResetPuid.cs ===
using ServerTestFramework;
using ServerTestFramework.Utilities;
using ServerTestFramework.Database;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.Auth;

using System.Collections.Generic;

namespace MachineBanTest
{
    [TestGroup, Description("Tests for reseting machine keys (/reset).")]
    public class ResetPuid: TestNode
    {
        public static void VerifyOutputStatus(string output, ulong []puids, uint []puidResults)
        {
            string []machineStrings=new string[puids.Length];
            for (int i=0; i<puids.Length; ++i)
            {
                machineStrings[i]=string.Format("0x{0:X16}", puids[i]);
            }

            VerifyOutputStatus(output, machineStrings, puidResults);
        }

        public static void VerifyOutputStatus(string output, string []machineStrings, uint []puidResults)
        {
            //find the status strings in the output
            List<string> stringsFound=new List<string>();

            string []outputLines=output.Replace("\r","").Split(new char[]{'\n'});
            foreach (string line in outputLines)
            {
                if (line.Contains(": ")) //one of the machine status rows
                {
                    int indexStart=line.IndexOf(":")+2;
                    int length=line.Length-indexStart;
                    if (line.Contains(" (")) //filter out the optional comment
                    {
                        length-=line.Length-line.IndexOf(" (");
                    }
                    stringsFound.Add(line.Substring(indexStart, length));
                }
            }

            //build a list of strings we expect
            List<string> stringsExpected=new List<string>();

            for (int i=0; i<machineStrings.Length; ++i)
            {
                uint result=0;
                if (puidResults!=null)
                {
                    result=puidResults[i];
                }
                string line=string.Format("{0} - 0x{1:X8}", machineStrings[i], result);
                stringsExpected.Add(line);
            }

            //compare
            ValueCheck.TestAllUnordered("Machine status output", stringsExpected, stringsFound);
        }

        // -----

        [TestCase, Description("Reset one machine that is machine banned in hex on the commandline.")]
        public void SingleHexMachine()
        {
            MachineEditor mach=MachineEditor.FromId(BanUtil.CreateMachine(MachineType.Xbox360));
            BanUtil.MachineKeyState origKeyState=BanUtil.GetMachineKeyState(mach.Id);

            string output=BanUtil.RunMachineBan("/reset:"+string.Format("0x{0:X16}", mach.Id));

            BanUtil.CheckOutputForBasicBadness(output);
            VerifyOutputStatus(output, new ulong[]{mach.Id}, null);

            BanUtil.VerifyNoMachineBan(mach.Id);
            BanUtil.VerifyNoConsoleBan(mach.ConsoleId);

            BanUtil.VerifyMachineKeyStateDifferent(mach.Id, origKeyState, BanUtil.GetMachineKeyState(mach.Id));
        }

        [TestCase, Description("Reset one machine in unsigned decimal on the commandline.")]
        public void SinglePositiveDecimal()
        {
            MachineEditor mach=MachineEditor.FromId(BanUtil.CreateMachine(MachineType.Xbox360));
            BanUtil.MachineKeyState origKeyState=BanUtil.GetMachineKeyState(mach.Id);

            string output=BanUtil.RunMachineBan("/reset:"+(ulong)mach.Id);

            BanUtil.CheckOutputForBasicBadness(output);
            VerifyOutputStatus(output, new ulong[]{mach.Id}, null);

            BanUtil.VerifyMachineKeyStateDifferent(mach.Id, origKeyState, BanUtil.GetMachineKeyState(mach.Id));
        }

        [TestCase, Description("Reset one machine in signed decimal on the commandline.")]
        public void SingleNegativeDecimal()
        {
            MachineEditor mach=MachineEditor.FromId(BanUtil.CreateMachine(MachineType.Xbox360));
            BanUtil.MachineKeyState origKeyState=BanUtil.GetMachineKeyState(mach.Id);

            string output=BanUtil.RunMachineBan("/reset:"+(long)mach.Id);

            BanUtil.CheckOutputForBasicBadness(output);
            VerifyOutputStatus(output, new ulong[]{mach.Id}, null);

            BanUtil.VerifyMachineKeyStateDifferent(mach.Id, origKeyState, BanUtil.GetMachineKeyState(mach.Id));
        }

        [TestCase, Description("Reset one machine from an unsupported platform.")]
        [CompoundCase("Phone", MachineType.Phone)]
        [CompoundCase("PC", MachineType.PC)]
        public void UnsupportedPlatform(TestNode self)
        {
            MachineType mtype=(MachineType)self.MyValues[0];
            MachineEditor mach=MachineEditor.FromId(BanUtil.CreateMachine(mtype));
            BanUtil.MachineKeyState origKeyState=BanUtil.GetMachineKeyState(mach.Id);

            string output=BanUtil.RunMachineBan("/reset:"+string.Format("0x{0:X16}", mach.Id));

            BanUtil.CheckOutputForBasicBadness(output);
            VerifyOutputStatus(output, new ulong[]{mach.Id}, new uint[]{0x80004005}); //E_FAIL

            BanUtil.VerifyMachineKeyStateSame(mach.Id, origKeyState, BanUtil.GetMachineKeyState(mach.Id));
        }

        [TestCase, Description("Reset one invalid machine id (platform type isn't real).")]
        public void SingleInvalidMachine()
        {
            ulong id=0x13;
            string output=BanUtil.RunMachineBan("/reset:"+string.Format("0x{0:X16}", id));

            BanUtil.CheckOutputForBasicBadness(output);
            VerifyOutputStatus(output, new ulong[]{id}, new uint[]{0x80004005}); //E_FAIL
        }

        [TestCase, Description("Reset one machine id that does not exist (but is in a valid range).")]
        public void SingleNonexistantMachine()
        {
            ulong id=0xfa00ffffffff1234;
            string output=BanUtil.RunMachineBan("/reset:"+string.Format("0x{0:X16}", id));

            BanUtil.CheckOutputForBasicBadness(output);
            VerifyOutputStatus(output, new ulong[]{id}, new uint[]{0x80004005}); //E_FAIL
        }

        [TestCase, Description("Reset from a file.")]
        [CompoundCase("One", 1)]
        [CompoundCase("Multiple", 10)]
        public void File(TestNode self)
        {
            int machineCount=(int)self.MyValues[0];

            ulong []puids=new ulong[machineCount];
            MachineEditor []machs=new MachineEditor[machineCount];
            BanUtil.MachineKeyState []origKeyState=new BanUtil.MachineKeyState[machineCount];
            for (int i=0; i<machineCount; ++i)
            {
                machs[i]=MachineEditor.FromId(BanUtil.CreateMachine(MachineType.Xbox360));
                puids[i]=machs[i].Id;
                origKeyState[i]=BanUtil.GetMachineKeyState(puids[i]);
            }
            string filename=BanUtil.WriteTempFile(puids);

            string output=BanUtil.RunMachineBan("/reset /file:"+filename);

            BanUtil.CheckOutputForBasicBadness(output);
            VerifyOutputStatus(output, puids, null);

            for (int i=0; i<machineCount; ++i)
            {
                BanUtil.VerifyMachineKeyStateDifferent(puids[i], origKeyState[i], BanUtil.GetMachineKeyState(puids[i]));
            }
        }

        [TestCase, Description("Reset multiple machines from a file with some invalid entries and one entry included twice.")]
        public void FileMultipleMixedInvalid()
        {
            MachineEditor mach0=MachineEditor.FromId(BanUtil.CreateMachine(MachineType.Xbox360));
            mach0.BanMachine(unchecked((int)0x80150000), System.DateTime.UtcNow, System.DateTime.MaxValue);
            MachineEditor mach1=MachineEditor.FromId(BanUtil.CreateMachine(MachineType.Xbox360));
            mach1.BanMachine(unchecked((int)0x80150001), System.DateTime.UtcNow, System.DateTime.MaxValue);
            string filename=BanUtil.WriteTempFile(new string[]{string.Format("0x{0:X16}", mach0.Id), "wtf", "0x-99999999999999999999999999", "7", "0xfa00f0f080804040", mach0.Id.ToString(), string.Format("0x{0:X16}", mach1.Id)});

            string output=BanUtil.RunMachineBan("/reset /file:"+filename);

            BanUtil.CheckOutputForBasicBadness(output);
            VerifyOutputStatus(output,
                               new string[]{string.Format("0x{0:X16}", mach0.Id), string.Format("0x{0:X16}", mach0.Id), string.Format("0x{0:X16}", mach1.Id),  "wtf", "0x-99999999999999999999999999", "7", "0xFA00F0F080804040"},
                               new uint[]{0, 0, 0, 0x80004005, 0x80004005, 0x80004005, 0x80004005});
        }
    };
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\MachineBan\test\UnbanPuid.cs ===
using ServerTestFramework;
using ServerTestFramework.Utilities;
using ServerTestFramework.Database;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.Auth;

using System.Collections.Generic;

namespace MachineBanTest
{
    [TestGroup, Description("Genela Machine Ban Tests")]
    public class UnbanPuid: TestNode
    {
        public static void VerifyOutputStatus(string output, ulong []puids, uint []puidResults)
        {
            string []machineStrings=new string[puids.Length];
            for (int i=0; i<puids.Length; ++i)
            {
                machineStrings[i]=string.Format("0x{0:X16}", puids[i]);
            }

            VerifyOutputStatus(output, machineStrings, puidResults);
        }

        public static void VerifyOutputStatus(string output, string []machineStrings, uint []puidResults)
        {
            //find the status strings in the output
            List<string> stringsFound=new List<string>();

            string []outputLines=output.Replace("\r","").Split(new char[]{'\n'});
            foreach (string line in outputLines)
            {
                if (line.Contains(": ")) //one of the machine status rows
                {
                    int indexStart=line.IndexOf(":")+2;
                    int length=line.Length-indexStart;
                    if (line.Contains(" (")) //filter out the optional comment
                    {
                        length-=line.Length-line.IndexOf(" (");
                    }
                    stringsFound.Add(line.Substring(indexStart, length));
                }
            }

            //build a list of strings we expect
            List<string> stringsExpected=new List<string>();

            for (int i=0; i<machineStrings.Length; ++i)
            {
                uint result=0;
                if (puidResults!=null)
                {
                    result=puidResults[i];
                }
                string line=string.Format("{0} - 0x{1:X8}", machineStrings[i], result);
                stringsExpected.Add(line);
            }

            //compare
            ValueCheck.TestAllUnordered("Machine status output", stringsExpected, stringsFound);
        }

        // -----

        [TestCase, Description("Unban one machine in hex on the commandline.")]
        [CompoundCase("Xbox360", MachineType.Xbox360)]
        [CompoundCase("Phone", MachineType.Phone)]
        public void SingleHex(TestNode self)
        {
            MachineType mtype=(MachineType)self.MyValues[0];
            MachineEditor mach=MachineEditor.FromId(BanUtil.CreateMachine(mtype));
            mach.BanMachine(unchecked((int)0x8015190D), System.DateTime.UtcNow, System.DateTime.MaxValue);

            string output=BanUtil.RunMachineBan("/unban:"+string.Format("0x{0:X16}", mach.Id));

            BanUtil.CheckOutputForBasicBadness(output);
            VerifyOutputStatus(output, new ulong[]{mach.Id}, null);

            BanUtil.VerifySingleMachineBan(mach.Id, 0x8015190D, System.DateTime.UtcNow, System.DateTime.UtcNow);
        }

        [TestCase, Description("Unban one machine in hex on the commandline.")]
        public void SingleHexPc()
        {
            string voucher=BanUtil.CreateUnlimitedPCVoucher();
            MachineEditor mach=MachineEditor.FromId(BanUtil.CreatePCMachine(voucher));

            BanUtil.RunMachineBan("/ban:"+string.Format("0x{0:X16}", mach.Id));
            string output=BanUtil.RunMachineBan("/unban:"+string.Format("0x{0:X16}", mach.Id));

            BanUtil.CheckOutputForBasicBadness(output);
            VerifyOutputStatus(output, new ulong[]{mach.Id}, null);

            BanUtil.VerifySingleMachineBan(mach.Id, 0x8015190D, System.DateTime.UtcNow, System.DateTime.UtcNow);
            BanUtil.VerifyNoVoucherBan(voucher);
        }

        [TestCase, Description("Unban one machine in unsigned decimal on the commandline.")]
        public void SinglePositiveDecimal()
        {
            MachineEditor mach=MachineEditor.FromId(BanUtil.CreateMachine(MachineType.Xbox360));
            mach.BanMachine(unchecked((int)0x8015190D), System.DateTime.UtcNow, System.DateTime.MaxValue);

            string output=BanUtil.RunMachineBan("/unban:"+(ulong)mach.Id);

            BanUtil.CheckOutputForBasicBadness(output);
            VerifyOutputStatus(output, new ulong[]{mach.Id}, null);

            BanUtil.VerifySingleMachineBan(mach.Id, 0x8015190D, System.DateTime.UtcNow, System.DateTime.UtcNow);
        }

        [TestCase, Description("Unban one machine in signed decimal on the commandline.")]
        public void SingleNegativeDecimal()
        {
            MachineEditor mach=MachineEditor.FromId(BanUtil.CreateMachine(MachineType.Xbox360));
            mach.BanMachine(unchecked((int)0x8015190D), System.DateTime.UtcNow, System.DateTime.MaxValue);

            string output=BanUtil.RunMachineBan("/unban:"+(long)mach.Id);

            BanUtil.CheckOutputForBasicBadness(output);
            VerifyOutputStatus(output, new ulong[]{mach.Id}, null);

            BanUtil.VerifySingleMachineBan(mach.Id, 0x8015190D, System.DateTime.UtcNow, System.DateTime.UtcNow);
        }

        [TestCase, Description("Unban one invalid machine id (platform type isn't real).")]
        public void SingleInvalidMachine()
        {
            ulong id=0x13;
            string output=BanUtil.RunMachineBan("/unban:"+string.Format("0x{0:X16}", id));

            BanUtil.CheckOutputForBasicBadness(output);
            VerifyOutputStatus(output, new ulong[]{id}, new uint[]{0x80004005}); //E_FAIL
        }

        [TestCase, Description("Unban one machine id that does not exist (but is in a valid range).")]
        public void SingleNonexistantMachine()
        {
            ulong id=0xfa00ffffffff1234;
            string output=BanUtil.RunMachineBan("/unban:"+string.Format("0x{0:X16}", id));

            BanUtil.CheckOutputForBasicBadness(output);
            VerifyOutputStatus(output, new ulong[]{id}, new uint[]{0x80004005}); //E_FAIL
        }

        [TestCase, Description("A single valid value in a file.")]
        [CompoundCase("Xbox360", MachineType.Xbox360)]
        [CompoundCase("Phone", MachineType.Phone)]
        public void FileSingleHex(TestNode self)
        {
            MachineType mtype=(MachineType)self.MyValues[0];
            MachineEditor mach=MachineEditor.FromId(BanUtil.CreateMachine(mtype));
            mach.BanMachine(unchecked((int)0x8015190D), System.DateTime.UtcNow, System.DateTime.MaxValue);
            string filename=BanUtil.WriteTempFile(string.Format("0x{0:X16}", mach.Id));

            string output=BanUtil.RunMachineBan("/unban /file:"+filename);

            BanUtil.CheckOutputForBasicBadness(output);
            VerifyOutputStatus(output, new ulong[]{mach.Id}, null);

            BanUtil.VerifySingleMachineBan(mach.Id, 0x8015190D, System.DateTime.UtcNow, System.DateTime.UtcNow);
        }

        [TestCase, Description("Unban one machine in hex from a file.")]
        public void FileSingleHexPc()
        {
            string voucher=BanUtil.CreateUnlimitedPCVoucher();
            MachineEditor mach=MachineEditor.FromId(BanUtil.CreatePCMachine(voucher));
            mach.BanMachine(unchecked((int)0x8015190D), System.DateTime.UtcNow, System.DateTime.MaxValue);
            string filename=BanUtil.WriteTempFile(string.Format("0x{0:X16}", mach.Id));

            string output=BanUtil.RunMachineBan("/unban /file:"+filename);

            BanUtil.CheckOutputForBasicBadness(output);
            VerifyOutputStatus(output, new ulong[]{mach.Id}, null);

            BanUtil.VerifySingleMachineBan(mach.Id, 0x8015190D, System.DateTime.UtcNow, System.DateTime.UtcNow);
            BanUtil.VerifyNoVoucherBan(voucher);
        }

        [TestCase, Description("Unban one machine in unsigned decimal from a file.")]
        public void FileSinglePositiveDecimal()
        {
            MachineEditor mach=MachineEditor.FromId(BanUtil.CreateMachine(MachineType.Xbox360));
            mach.BanMachine(unchecked((int)0x8015190D), System.DateTime.UtcNow, System.DateTime.MaxValue);
            string filename=BanUtil.WriteTempFile(((ulong)mach.Id).ToString());

            string output=BanUtil.RunMachineBan("/unban /file:"+filename);

            BanUtil.CheckOutputForBasicBadness(output);
            VerifyOutputStatus(output, new ulong[]{mach.Id}, null);

            BanUtil.VerifySingleMachineBan(mach.Id, 0x8015190D, System.DateTime.UtcNow, System.DateTime.UtcNow);
        }

        [TestCase, Description("Unban one machine in signed decimal from a file.")]
        public void FileSingleNegativeDecimal()
        {
            MachineEditor mach=MachineEditor.FromId(BanUtil.CreateMachine(MachineType.Xbox360));
            mach.BanMachine(unchecked((int)0x8015190D), System.DateTime.UtcNow, System.DateTime.MaxValue);
            string filename=BanUtil.WriteTempFile(((long)mach.Id).ToString());

            string output=BanUtil.RunMachineBan("/file:"+filename+" /unban");

            BanUtil.CheckOutputForBasicBadness(output);
            VerifyOutputStatus(output, new ulong[]{mach.Id}, null);

            BanUtil.VerifySingleMachineBan(mach.Id, 0x8015190D, System.DateTime.UtcNow, System.DateTime.UtcNow);
        }

        [TestCase, Description("Unban multiple machines from a file, formatted differently.")]
        public void FileMultipleDifferentFormats()
        {
            MachineEditor mach0=MachineEditor.FromId(BanUtil.CreateMachine(MachineType.Xbox360));
            MachineEditor mach1=MachineEditor.FromId(BanUtil.CreateMachine(MachineType.Xbox360));
            MachineEditor mach2=MachineEditor.FromId(BanUtil.CreateMachine(MachineType.Xbox360));
            mach0.BanMachine(unchecked((int)0x8015190D), System.DateTime.UtcNow, System.DateTime.MaxValue);
            mach1.BanMachine(unchecked((int)0x8015190D), System.DateTime.UtcNow, System.DateTime.MaxValue);
            mach2.BanMachine(unchecked((int)0x8015190D), System.DateTime.UtcNow, System.DateTime.MaxValue);
            string filename=BanUtil.WriteTempFile(new string[]{string.Format("0x{0:X16}", mach0.Id), ((ulong)mach1.Id).ToString(), ((long)mach2.Id).ToString()});

            string output=BanUtil.RunMachineBan("/unban /file:"+filename);

            BanUtil.CheckOutputForBasicBadness(output);
            VerifyOutputStatus(output, new ulong[]{mach0.Id, mach1.Id, mach2.Id}, null);

            BanUtil.VerifySingleMachineBan(mach0.Id, 0x8015190D, System.DateTime.UtcNow, System.DateTime.UtcNow);
            BanUtil.VerifySingleMachineBan(mach1.Id, 0x8015190D, System.DateTime.UtcNow, System.DateTime.UtcNow);
            BanUtil.VerifySingleMachineBan(mach2.Id, 0x8015190D, System.DateTime.UtcNow, System.DateTime.UtcNow);
        }

        [TestCase, Description("Unban multiple machines of different platforms from a file")]
        public void FileMultipleDifferentPlatforms()
        {
            List<MachineEditor> machs=new List<MachineEditor>();
            for (int i=0; i<8; ++i)
            {
                MachineEditor mach=MachineEditor.FromId(BanUtil.CreateMachine(MachineType.Xbox360));
                mach.BanMachine(unchecked((int)0x8015190D), System.DateTime.UtcNow, System.DateTime.MaxValue);
                machs.Add(mach);
            }
            machs.Add(MachineEditor.FromId(BanUtil.CreateMachine(MachineType.Phone)));
            machs[machs.Count-1].BanMachine(unchecked((int)0x8015190D), System.DateTime.UtcNow, System.DateTime.MaxValue);
            machs.Add(MachineEditor.FromId(BanUtil.CreateMachine(MachineType.PC)));
            machs[machs.Count-1].BanMachine(unchecked((int)0x8015190D), System.DateTime.UtcNow, System.DateTime.MaxValue);
            for (int i=0; i<8; ++i)
            {
                MachineEditor mach=MachineEditor.FromId(BanUtil.CreateMachine(MachineType.Xbox360));
                mach.BanMachine(unchecked((int)0x8015190D), System.DateTime.UtcNow, System.DateTime.MaxValue);
                machs.Add(mach);
            }

            string data="";
            foreach (MachineEditor mach in machs)
            {
                data+=mach.Id+"\r\n";;
            }

            string filename=BanUtil.WriteTempFile(data);

            string output=BanUtil.RunMachineBan("/unban /file:"+filename);

            BanUtil.CheckOutputForBasicBadness(output);
            ulong []puids=new ulong[machs.Count];
            for (int i=0; i<machs.Count; ++i)
            {
                puids[i]=machs[i].Id;
            }
            VerifyOutputStatus(output, puids, null);

            foreach (MachineEditor mach in machs)
            {
                BanUtil.VerifySingleMachineBan(mach.Id, 0x8015190D, System.DateTime.UtcNow, System.DateTime.UtcNow);
            }
        }

        [TestCase, Description("Unban multiple machines from a file with some invalid entries and one entry included twice.")]
        public void FileMultipleMixedInvalid()
        {
            MachineEditor mach0=MachineEditor.FromId(BanUtil.CreateMachine(MachineType.Xbox360));
            MachineEditor mach1=MachineEditor.FromId(BanUtil.CreateMachine(MachineType.Xbox360));
            mach0.BanMachine(unchecked((int)0x8015190D), System.DateTime.UtcNow, System.DateTime.MaxValue);
            mach1.BanMachine(unchecked((int)0x8015190D), System.DateTime.UtcNow, System.DateTime.MaxValue);
            string filename=BanUtil.WriteTempFile(new string[]{string.Format("0x{0:X16}", mach0.Id), "wtf", "0x-99999999999999999999999999", "7", mach0.Id.ToString(), string.Format("0x{0:X16}", mach1.Id)});

            string output=BanUtil.RunMachineBan("/unban /file:"+filename);

            BanUtil.CheckOutputForBasicBadness(output);
            VerifyOutputStatus(output,
                new string[]{
                    string.Format("0x{0:X16}", mach0.Id),
                    string.Format("0x{0:X16}", mach1.Id),
                    "wtf",
                    "0x-99999999999999999999999999",
                    "7"},
                new uint[]{
                    0,
                    0,
                    0x80004005,
                    0x80004005,
                    0x80004005});

            BanUtil.VerifySingleMachineBan(mach0.Id, 0x8015190D, System.DateTime.UtcNow, System.DateTime.UtcNow);
            BanUtil.VerifySingleMachineBan(mach1.Id, 0x8015190D, System.DateTime.UtcNow, System.DateTime.UtcNow);
        }

        [TestCase, Description("Unban a single puid with a valid reason code.")]
        public void SingleValidReason(TestNode self)
        {
            MachineEditor mach=MachineEditor.FromId(BanUtil.CreateMachine(MachineType.Xbox360));
            mach.BanMachine(unchecked((int)0x8F001234), System.DateTime.UtcNow, System.DateTime.MaxValue);

            string output=BanUtil.RunMachineBan("/unban:"+string.Format("0x{0:X16}", mach.Id)+" /reason:0x8F001234");

            BanUtil.CheckOutputForBasicBadness(output);
            VerifyOutputStatus(output, new ulong[]{mach.Id}, null);

            BanUtil.VerifySingleMachineBan(mach.Id, 0x8F001234, System.DateTime.UtcNow, System.DateTime.UtcNow);
        }

        [TestCase, Description("Unban one machine specifying a start date (which isn't valid for /unban).")]
        public void SingleStartDate(TestNode self)
        {
            MachineEditor mach=MachineEditor.FromId(BanUtil.CreateMachine(MachineType.Xbox360));
            mach.BanMachine(unchecked((int)0x8015190D), System.DateTime.UtcNow, System.DateTime.MaxValue);

            string output=BanUtil.RunMachineBan("/unban:"+string.Format("0x{0:X16}", mach.Id)+" /startdate:"+2020+"-"+05+"-"+06);
            if (!output.ToLower().Contains("invalid parameter"))
            {
                throw new UnexpectedTestResultException("Expected output to contain 'invalid parameter'");
            }

            BanUtil.VerifySingleMachineBan(mach.Id, 0x8015190D, System.DateTime.UtcNow, System.DateTime.MaxValue);
        }

        [TestCase, Description("Unban one machine specifying an end date in the default format.")]
        public void SingleEndDate()
        {
            MachineEditor mach=MachineEditor.FromId(BanUtil.CreateMachine(MachineType.Xbox360));
            mach.BanMachine(unchecked((int)0x8015190D), System.DateTime.UtcNow, System.DateTime.MaxValue);

            string output=BanUtil.RunMachineBan("/unban:"+string.Format("0x{0:X16}", mach.Id)+" /enddate:"+2020+"-"+05+"-"+06);
            if (!output.ToLower().Contains("invalid parameter"))
            {
                throw new UnexpectedTestResultException("Expected output to contain 'invalid parameter'");
            }

            BanUtil.VerifySingleMachineBan(mach.Id, 0x8015190D, System.DateTime.UtcNow, System.DateTime.MaxValue);
        }

        [TestCase, Description("When one PC machine is banned all other machines associated with that voucher are banned.")]
        public void SinglePCMultipleMachinesFromVoucher()
        {
            string voucher=BanUtil.CreateUnlimitedPCVoucher();
            MachineEditor mach0=MachineEditor.FromId(BanUtil.CreatePCMachine(voucher));
            MachineEditor mach1=MachineEditor.FromId(BanUtil.CreatePCMachine(voucher));

            BanUtil.RunMachineBan("/ban:"+string.Format("0x{0:X16}", mach0.Id));
            string output=BanUtil.RunMachineBan("/unban:"+string.Format("0x{0:X16}", mach0.Id));

            BanUtil.CheckOutputForBasicBadness(output);
            VerifyOutputStatus(output, new ulong[]{mach0.Id, mach1.Id}, null);

            BanUtil.VerifySingleMachineBan(mach0.Id, 0x8015190D, System.DateTime.UtcNow, System.DateTime.UtcNow);
            BanUtil.VerifySingleMachineBan(mach1.Id, 0x8015190D, System.DateTime.UtcNow, System.DateTime.UtcNow);
            BanUtil.VerifyNoVoucherBan(voucher);
        }
    };
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\MachineBan\test\obj\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=msil_machinebantest_none_12.4.56.0_none_e46cafb21725d679
ASSEMBLY_IDENTITY_XP_KEY_FORM=msil_machinebantest_no-public-key_12.4.56.0_x-ww_c29a973d
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=machinebantest
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=msil
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=msil_machinebantest_no-public-key_12.4.56.0_x-ww_c29a973d
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=msil_machinebantest_no-public-key_12.4.56.0_x-ww_c29a973d.manifest
XP_MANIFEST_PATH=manifests\msil_machinebantest_no-public-key_12.4.56.0_x-ww_c29a973d.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=msil_machinebantest_no-public-key_12.4.56.0_x-ww_c29a973d.cat
XP_CATALOG_PATH=manifests\msil_machinebantest_no-public-key_12.4.56.0_x-ww_c29a973d.cat
XP_PAYLOAD_PATH=msil_machinebantest_no-public-key_12.4.56.0_x-ww_c29a973d
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=machinebantest,processorArchitecture=msil,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\MachineBan\test\objd\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=msil_machinebantest_none_12.4.56.0_none_e46cafb21725d679
ASSEMBLY_IDENTITY_XP_KEY_FORM=msil_machinebantest_no-public-key_12.4.56.0_x-ww_c29a973d
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=machinebantest
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=msil
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=msil_machinebantest_no-public-key_12.4.56.0_x-ww_c29a973d
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=msil_machinebantest_no-public-key_12.4.56.0_x-ww_c29a973d.manifest
XP_MANIFEST_PATH=manifests\msil_machinebantest_no-public-key_12.4.56.0_x-ww_c29a973d.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=msil_machinebantest_no-public-key_12.4.56.0_x-ww_c29a973d.cat
XP_CATALOG_PATH=manifests\msil_machinebantest_no-public-key_12.4.56.0_x-ww_c29a973d.cat
XP_PAYLOAD_PATH=msil_machinebantest_no-public-key_12.4.56.0_x-ww_c29a973d
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=machinebantest,processorArchitecture=msil,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\MachineBan\test\Util.cs ===
using ServerTestFramework;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.Auth;
using ServerTestFramework.Utilities;
using ServerTestFramework.Database;
using System.IO;
using System.Text;

using xonline.common.config;

namespace MachineBanTest
{
    public static class BanUtil
    {
        const ulong PANORAMA_VOUCHER_OFFER_ID=0x585207D10FF00001;

        //runs machine ban tool with specific arguments, and returns the commandline output
        public static string RunMachineBan(string args)
        {
            return RunMachineBan(args, 120);
        }
        public static string RunMachineBan(string args, uint timeoutInS)
        {
            //run it, capturing the output
            ProcessWrapper pr=new ProcessWrapper("MachineBan","MachineBan.exe");
            pr.SetEnvironmentVariable("XBL_CONFIG_SERVER", Global.CurrentEnvironment.NpdbIp);
            pr.SetEnvironmentVariable("XBL_CONFIG_DATABASE", Global.CurrentEnvironment.NpdbName);
            pr.ExecutionTimeout=(int)timeoutInS;
            pr.EchoOutput=true;
            pr.Run(args);

            return pr.Output;
        }

        //throws an exception if was a common error in an output string from MachineBan.
        public static void CheckOutputForBasicBadness(string str)
        {
            if (str.Contains("Invalid parameters!"))
            {
                throw new UnexpectedTestResultException("Output contained unexpected string: Invalid parameters!");
            }

            if (str.Contains("-- OPTIONS --"))
            {
                throw new UnexpectedTestResultException("Output contained unexpected string: -- OPTIONS --");
            }

            if (str.Contains("System.Byte"))
            {
                throw new UnexpectedTestResultException("Output contained unexpected string: System.Byte");
            }

            if (str.Contains("Exception:"))
            {
                throw new UnexpectedTestResultException("output from machineban contained 'Exception:'");
            }

            if (str.Contains("Error!"))
            {
                throw new UnexpectedTestResultException("output from machineban contained 'Error!'");
            }
        }

        public static string CreateUnlimitedPCVoucher()
        {
            string voucher=TokendbWS.CreatePanoramaVoucher(-1);
            Global.RO.Debug("Created new unlimited use count PC voucher: "+voucher+"(Hash=0x"+Hexer.tohex(TokendbWS.GetHashForPanoramaVoucher(voucher))+")"); //CreatePanoramaVoucher already has debug output
            return voucher;
        }

        public static ulong CreatePCMachine(string voucher)
        {
            MachineEditor mach=MachineEditor.CreateOrUseExistingPCName(null, null, voucher, null, null);
            Global.RO.Debug("Created PC: MachineId=0x{0:X} ConsoleId={1} Voucher={2}(Hash=0x{3})", mach.Id, mach.ConsoleId, voucher, Hexer.tohex(TokendbWS.GetHashForPanoramaVoucher(voucher)));
            return mach.Id;
        }

        public static ulong CreateMachine(MachineType mtype)
        {
            if (mtype==MachineType.PC) //we don't want to use the default test voucher for PCs because we don't want that global test voucher to be banned
            {
                string voucher=CreateUnlimitedPCVoucher();
                return CreatePCMachine(voucher);
            }

            MachineEditor mach=MachineEditor.CreateNew(mtype);
            if (mtype==MachineType.Xbox360)
            {
                Global.RO.Debug("Created Xbox360: MachineId=0x{0:X} ConsoleId={1} CertHash=0x{2}", mach.Id, mach.ConsoleId, Hexer.tohex(mach.CertHash));
            }
            else
            {
                Global.RO.Debug("Created "+mtype+": MachineId=0x{0:X} ConsoleId={1}", mach.Id, mach.ConsoleId);
            }
            return mach.Id;
        }

        public static string WriteTempFile(string data)
        {
            Directory.CreateDirectory("tmp\\bantest\\");

            string fname="Tmp_"+ServerTestFramework.Core.Utilities.RandomEx.GlobalRandGen.GenerateRandomAlphaNumericString(10, 10)+".txt";
            string fullName="tmp\\bantest\\"+fname;

            FileStream f=new FileStream(fullName, FileMode.Create, FileAccess.Write);
            StreamWriter fwriter=new StreamWriter(f);
            fwriter.Write(data);
            fwriter.Close();
            f.Close();

            return fullName;
        }

        public static string WriteTempFile(System.Collections.IEnumerable datas)
        {
            string s="";
            foreach (object o in datas)
            {
                s+=""+o;
                s+="\r\n";
            }
            return WriteTempFile(s);
        }

        public static bool MachineBanStatusEquals1Minute(MachineEditor.MachineBanStatus left, MachineEditor.MachineBanStatus right)
        {
            return left.MachineId==right.MachineId &&
                left.ReasonCode==right.ReasonCode &&
                System.Math.Abs((left.StartDate-right.StartDate).TotalSeconds)<60 &&
                System.Math.Abs((left.EndDate-right.EndDate).TotalSeconds)<60 &&
                left.HashBucket==right.HashBucket;
        }

        public static void VerifyNoMachineBan(ulong machine)
        {
            MachineEditor.MachineBanStatus []actualMachineBans=MachineEditor.FromId(machine).GetAllMachineBans();
            MachineEditor.MachineBanStatus []expectedMachineBans=new MachineEditor.MachineBanStatus[0];
            ValueCheck.TestAllUnordered("MachineBan rows in DB", expectedMachineBans, actualMachineBans, MachineBanStatusEquals1Minute);
        }

        public static void VerifySingleMachineBan(ulong machine, uint reason)
        {
            MachineEditor.MachineBanStatus []actualMachineBans=MachineEditor.FromId(machine).GetAllMachineBans();
            MachineEditor.MachineBanStatus []expectedMachineBans=new MachineEditor.MachineBanStatus[]{new MachineEditor.MachineBanStatus(machine, unchecked((int)reason), System.DateTime.UtcNow, System.DateTime.MaxValue)};
            ValueCheck.TestAllUnordered("MachineBan rows in DB", expectedMachineBans, actualMachineBans, MachineBanStatusEquals1Minute);
        }

        public static void VerifySingleMachineBan(ulong machine, uint reason, System.DateTime banStart, System.DateTime banEnd)
        {
            MachineEditor.MachineBanStatus []actualMachineBans=MachineEditor.FromId(machine).GetAllMachineBans();
            MachineEditor.MachineBanStatus []expectedMachineBans=new MachineEditor.MachineBanStatus[]{new MachineEditor.MachineBanStatus(machine, unchecked((int)reason), banStart, banEnd)};
            ValueCheck.TestAllUnordered("MachineBan rows in DB", expectedMachineBans, actualMachineBans, MachineBanStatusEquals1Minute);
        }

        public static bool ConsoleBanStatusEquals1Minute(ConsoleBanEditor.ConsoleBanStatus left, ConsoleBanEditor.ConsoleBanStatus right)
        {
            return left.ConsoleId==right.ConsoleId &&
                left.ReasonCode==right.ReasonCode &&
                System.Math.Abs((left.StartDate-right.StartDate).TotalSeconds)<60 &&
                left.HashBucket==right.HashBucket;
        }

        public static void VerifyNoConsoleBan(string cid)
        {
            ConsoleBanEditor.ConsoleBanStatus []actualConsoleBanStatus=ConsoleBanEditor.FromConsoleId(cid).GetAllConsoleBans();
            ConsoleBanEditor.ConsoleBanStatus []expectedConsoleBanStatus=new ConsoleBanEditor.ConsoleBanStatus[0];
            ValueCheck.TestAllUnordered("ConsoleBan rows in DB", expectedConsoleBanStatus, actualConsoleBanStatus, ConsoleBanStatusEquals1Minute);
        }

        public static void VerifySingleConsoleBan(string cid, uint reason)
        {
            ConsoleBanEditor.ConsoleBanStatus []actualConsoleBanStatus=ConsoleBanEditor.FromConsoleId(cid).GetAllConsoleBans();
            ConsoleBanEditor.ConsoleBanStatus []expectedConsoleBanStatus=new ConsoleBanEditor.ConsoleBanStatus[]{new ConsoleBanEditor.ConsoleBanStatus(cid, unchecked((int)reason), System.DateTime.UtcNow)};
            ValueCheck.TestAllUnordered("ConsoleBan rows in DB", expectedConsoleBanStatus, actualConsoleBanStatus, ConsoleBanStatusEquals1Minute);
        }

        public static void VerifySingleConsoleBan(string cid, uint reason, System.DateTime banStart)
        {
            ConsoleBanEditor.ConsoleBanStatus []actualConsoleBanStatus=ConsoleBanEditor.FromConsoleId(cid).GetAllConsoleBans();
            ConsoleBanEditor.ConsoleBanStatus []expectedConsoleBanStatus=new ConsoleBanEditor.ConsoleBanStatus[]{new ConsoleBanEditor.ConsoleBanStatus(cid, unchecked((int)reason), banStart)};
            ValueCheck.TestAllUnordered("ConsoleBan rows in DB", expectedConsoleBanStatus, actualConsoleBanStatus, ConsoleBanStatusEquals1Minute);
        }

        public static void VerifyVoucherBan(string voucher)
        {
            byte []voucherHash=TokendbWS.GetHashForPanoramaVoucher(voucher);
            VoucherEditor ve=VoucherEditor.FromHash(voucherHash, PANORAMA_VOUCHER_OFFER_ID);
            ValueCheck.Test("Status of voucher hash 0x"+Hexer.tohex(voucherHash), 2, ve.Status); //0=active, 1=disabled, 2=banned
        }

        public static void VerifyNoVoucherBan(string voucher)
        {
            byte []voucherHash=TokendbWS.GetHashForPanoramaVoucher(voucher);
            VoucherEditor ve=VoucherEditor.FromHash(voucherHash, PANORAMA_VOUCHER_OFFER_ID);
            ValueCheck.Test("Status of voucher hash 0x"+Hexer.tohex(voucherHash), 0, ve.Status); //0=active, 1=disabled, 2=banned
        }

        public class MachineKeyState
        {
            public System.DateTime ResetDate;
            public byte []EncryptedKey;

            public override string ToString()
            {
                return "ResetDate("+ResetDate+") EncryptedKey("+Hexer.tohex(EncryptedKey)+")";
            }
        };

        public static MachineKeyState GetMachineKeyState(ulong puid)
        {
            MachineKeyState state=new MachineKeyState();

            MachineEditor mach=MachineEditor.FromId(puid);
            state.ResetDate=mach.ResetDate;
            state.EncryptedKey=mach.GetEncryptedKey();

            return state;
        }

        public static void VerifyMachineKeyStateSame(ulong puid, MachineKeyState expected, MachineKeyState got)
        {
            ValueCheck.Test("Machine KeyResetDate for 0x"+Hexer.tohex(puid), expected.ResetDate, got.ResetDate);
            ValueCheck.TestAll("Machine EncryptedKey for 0x"+Hexer.tohex(puid), expected.EncryptedKey, got.EncryptedKey);
        }

        public static void VerifyMachineKeyStateDifferent(ulong puid, MachineKeyState expectedNot, MachineKeyState got)
        {
            ValueCheck.TestDifferent("Machine KeyResetDate for 0x"+Hexer.tohex(puid), expectedNot.ResetDate, got.ResetDate);
            ValueCheck.TestNotAll("Machine EncryptedKey for 0x"+Hexer.tohex(puid), expectedNot.EncryptedKey, got.EncryptedKey);
        }
    };
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\MachineHelper\app\ActionCheckReady.cs ===
using System;
using System.Collections.Generic;
using System.IO;
using System.Text;
using System.Threading;
using System.Reflection;

using Microsoft.Webstore.WstClient;

using xonline.common.config;
using xonline.common.mgmt;
using xonline.common.service;
using xonline.common.sql.webstore;
using xonline.common.tools.console;

using xonline.server.xmachine.fd.soap;

namespace xonline.tools.machinehelper
{
    partial class MachineHelperApp
    {
        private static bool CheckReady()
        {
            bool result = true;

            Console.WriteLine("\r\n=======================================");
            Console.WriteLine("\r\nM A C H I N E    H E L P E R");
            Console.WriteLine("\r\nv " + Assembly.GetExecutingAssembly().GetName().Version.ToString());
            Console.WriteLine("\r\n=======================================");
            Console.WriteLine("\r\nExe location: " + Path.GetDirectoryName(Assembly.GetExecutingAssembly().Location));
            Console.WriteLine("\r\n===================");
            Console.WriteLine("Commencing Checks...");
            Console.Write("\r\n+Checking XMachine Connection...");

            try
            {
                XMachineSoapClient connection = new XMachineSoapClient();

                Console.WriteLine("PASS");
                Console.Write("\r\n+Calling XMachine Test Method...");

                string testConnection = connection.TestConnection("Connection Successful");

                if (!String.IsNullOrEmpty(testConnection))
                {
                    Console.WriteLine("PASS");
                }
                else
                {
                    Console.WriteLine("FAIL");
                    result = false;
                }
            }
            catch (Exception e)
            {
                Console.WriteLine("FAIL");
                Console.WriteLine(e.Message);
                result = false;
            }

            Console.WriteLine("\r\nChecks Completed.");

            return result;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\MachineHelper\app\ActionDumpOldBans.cs ===
//NOTE: This entire file will be deleted after the 2011 april XSR.  It only exists to assist with a one-time ban migration.

using System;
using System.Collections.Generic;
using System.Data.SqlClient;
using System.IO;
using System.Text;
using System.Threading;

using Microsoft.Webstore.WstClient;

using xonline.common.config;
using xonline.common.mgmt;
using xonline.common.service;
using xonline.common.sql.webstore;
using xonline.common.tools.console;

using xonline.server.xmachine.fd.soap;

namespace xonline.tools.machinehelper
{
    partial class MachineHelperApp
    {
        private static bool DumpOldBans()
        {
            bool result = true;
            result = DumpOldBansXbox360() && result;
            result = DumpOldBansPC() && result;
            return result;
        }

        private static bool DumpOldBansXbox360()
        {
            Console.WriteLine("Reading Xbox360 bans...");

            //set up the directory and files to store this in
            string basePath = System.IO.Path.Combine(Configuration.FileName, "Xbox360");
            System.IO.Directory.CreateDirectory(basePath);

            Dictionary<int, FileStream> fileStreams = new Dictionary<int, FileStream>();
            Dictionary<int, StreamWriter> writeStreams = new Dictionary<int, StreamWriter>();
            using (WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITETHENREAD_COMMANDTYPE))
            {
                for (int p=0; p<ws.PhysicalPartitions; ++p)
                {
                    string fileName = System.IO.Path.Combine(basePath, string.Format("Part{0:D4}.txt", p));
                    FileStream fs = System.IO.File.Open(fileName, FileMode.Create);
                    fileStreams[p] = fs;
                    writeStreams[p] = new StreamWriter(fs);
                }
            }

            try
            {
                //Normally we would have a sproc to do this.  However this only exists to assist with a one-time-only ban migration.
                using (WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITETHENREAD_COMMANDTYPE))
                {
                    for (int p=0; p<ws.PhysicalPartitions; ++p)
                    {
                        Console.WriteLine("Reading partition " + (p + 1) + " of "+ ws.PhysicalPartitions);

                        ws.ClearParameters();
                        ws.PhysicalPartition = p;
                        ws.CommandSql = "select vc_serial_num from t_machines where dt_blocked_date < getutcdate() and vc_serial_num like 'XE.%'";

                        using (WstDataReader reader = ws.Execute())
                        {
                            while (reader.Read())
                            {
                                string consoleId = (string)reader[0];
                                int physicalPartitionForConsoleId = ws.GetPhysicalPartition(ws.CalcPartition(consoleId));
                                writeStreams[physicalPartitionForConsoleId].Write(consoleId + "\r\n");
                            }
                        }
                    }
                }
            }
            finally
            {
                using (WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITETHENREAD_COMMANDTYPE))
                {
                    for (int p=0; p<ws.PhysicalPartitions; ++p)
                    {
                        writeStreams[p].Close();
                        fileStreams[p].Close();
                    }
                }
            }

            return true;
        }

        private static bool DumpOldBansPC()
        {
            Console.WriteLine("Reading PC bans...");

            //set up the directory and files to store this in
            string basePath = System.IO.Path.Combine(Configuration.FileName, "PC");
            System.IO.Directory.CreateDirectory(basePath);

            Dictionary<int, FileStream> fileStreams = new Dictionary<int, FileStream>();
            Dictionary<int, StreamWriter> writeStreams = new Dictionary<int, StreamWriter>();
            using (WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITETHENREAD_COMMANDTYPE))
            {
                for (int p=0; p<ws.PhysicalPartitions; ++p)
                {
                    string fileName = System.IO.Path.Combine(basePath, string.Format("Part{0:D4}.txt", p));
                    FileStream fs = System.IO.File.Open(fileName, FileMode.Create);
                    fileStreams[p] = fs;
                    writeStreams[p] = new StreamWriter(fs);
                }
            }

            try
            {
                //Normally we would have a sproc to do this.  However this only exists to assist with a one-time-only ban migration.
                using (WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITETHENREAD_COMMANDTYPE))
                {
                    for (int p=0; p<ws.PhysicalPartitions; ++p)
                    {
                        Console.WriteLine("Reading partition " + (p + 1) + " of "+ ws.PhysicalPartitions);

                        ws.ClearParameters();
                        ws.PhysicalPartition = p;
                        ws.CommandSql = "select bi_machine_puid from t_machines where dt_blocked_date < getutcdate() and vc_serial_num like 'PC.%'";

                        using (WstDataReader reader = ws.Execute())
                        {
                            while (reader.Read())
                            {
                                Puid puid = (Puid)(ulong)(long)reader[0];
                                writeStreams[p].Write(puid + "\r\n");
                            }
                        }
                    }
                }
            }
            finally
            {
                using (WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITETHENREAD_COMMANDTYPE))
                {
                    for (int p=0; p<ws.PhysicalPartitions; ++p)
                    {
                        writeStreams[p].Close();
                        fileStreams[p].Close();
                    }
                }
            }

            return true;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\MachineHelper\app\ActionLookupConsoleId.cs ===
using System;
using System.Collections.Generic;
using System.Data.SqlClient;
using System.IO;
using System.Text;
using System.Threading;

using Microsoft.Webstore.WstClient;

using xonline.common.config;
using xonline.common.mgmt;
using xonline.common.service;
using xonline.common.sql.webstore;
using xonline.common.tools.console;

using xonline.server.xmachine.fd.soap;

namespace xonline.tools.machinehelper
{
    partial class MachineHelperApp
    {
        private static byte[] ComputeSCode(byte []certHash)
        {
            //scode is the first 7 bytes of the certificate hash then a 1 byte checksum of the nibbles
            byte []scode = new byte[8];
            for (int digit=0; digit<7; ++digit)
            {
                scode[digit] = certHash[digit];
            }

            uint checksumLow = 0;
            uint checksumHigh = 0;
            for (int digit=0; digit<7; ++digit)
            {
                unchecked
                {
                    checksumLow += (uint)(scode[digit] & 0x0f);
                    checksumHigh += (uint)((scode[digit] & 0xf0) >> 4);
                }
            }

            scode[7] = (byte)((checksumLow & 0x0f) | ((checksumHigh & 0x0f) << 4));
            return scode;
        }

        private static string FormatSCode(byte []scodeBytes)
        {
            string scode = "";
            for (int segments=0; segments<4; ++segments)
            {
                if (scode.Length>0)
                {
                    scode += "-";
                }

                scode += string.Format("{0:X2}", scodeBytes[segments*2 + 0]);
                scode += string.Format("{0:X2}", scodeBytes[segments*2 + 1]);
            }
            return scode;
        }

        private static bool LookupConsoleId()
        {
            if (Configuration.RawIds.Count<=0)
            {
                return false;
            }

            XMachineSoapClient xmachine = new XMachineSoapClient();

            foreach (string rawId in Configuration.RawIds)
            {
                if (string.IsNullOrEmpty(rawId))
                {
                    continue;
                }

                string outcome = "SUCCESS";
                string result = "";
                try
                {
                    //right now we do individual lookups.  a future optimization would be to call in batches.
                   ConsoleIdInfo []ret = xmachine.LookupMachinePuidsByConsoleIds(new string[]{rawId});

                    foreach (ConsoleIdInfo cii in ret)
                    {
                        if (result.Length>0) //existing entry
                        {
                            result += ", ";
                        }

                        string ciiMachinePuid = string.Format("0x{0:X16}", cii.MachinePuid);
                        string ciiCertHash = string.Join("", Array.ConvertAll(cii.SecondaryIdentifier, (u => u.ToString("X2"))));
                        string ciiSCode = FormatSCode(ComputeSCode(cii.SecondaryIdentifier));
                        result += "(MachinePuid=" + ciiMachinePuid + " CertHash=0x" + ciiCertHash + " SCode=" + ciiSCode + ")";
                    }

                    if (ret.Length==0)
                    {
                        outcome="FAIL";
                    }
                }
                catch (System.Web.Services.Protocols.SoapException se) //only catch errors calling the API
                {
                    outcome = "FAIL (" + se.Message.Replace("\n", "  ") + ")";
                }
                finally
                {
                    Console.WriteLine(rawId + ": " + outcome + (result.Length>0 ? (": " + result) : ""));
                }
            }

            return true;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\MachineHelper\app\makefile.inc ===
!include $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\MachineHelper\app\objd\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("DEPOT")]
[assembly:System.Reflection.AssemblyCopyright("")]
[assembly:System.Reflection.AssemblyCompany("")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\MachineHelper\app\obj\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("DEPOT")]
[assembly:System.Reflection.AssemblyCopyright("")]
[assembly:System.Reflection.AssemblyCompany("")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\MachineHelper\app\Configuration.cs ===
using System;
using System.Collections.Generic;
using System.IO;
using System.Data;
using System.Globalization;
using xonline.common.service;
using xonline.common.tools.console;

namespace xonline.tools.machinehelper
{
    class Configuration
    {
        static public bool Help
        {
            get { return _help; }
        }

        static public bool LookupConsoleId
        {
            get { return _lookupConsoleId; }
        }

        static public bool LookupPuid
        {
            get { return _lookupPuid; }
        }

        static public bool CheckReady
        {
            get { return _checkReady; }
        }

        static public bool DumpOldBans //TO BE REMOVED AFTER THE APRIL XSR
        {
            get { return _dumpOldBans; }
        }

        static public string FileName
        {
            get { return _fileName; }
        }

        static public List<string> RawIds
        {
            get { return _rawIdList; }
        }

        static public bool Parse(string[] args)
        {
            // Parse arguments
            NamedArgParser parser = new NamedArgParser(
                new string[] {
                    "?",
                    "help",
                    "lookupconsoleid",
                    "lookuppuid",
                    "file",
                    "checkready",
                    "dumpoldbans" //TO BE REMOVED AFTER THE APRIL XSR
                    });

            if(!parser.Parse(args))
                return false;

            // Process arguments
            if(parser["help"]!=null || parser["?"]!=null)
            {
                _help = true;
                return false;
            }

            if (!CheckValidArgs(parser))
            {
                return false;
            }

            if (!LoadupConfiguration(parser))
            {
                return false;
            }

            return true;
        }

        private static bool CheckValidArgs(NamedArgParser args)
        {
            //there must always be exactly one of these arguments
            string []requiredUniqueArgs=new string[] {
                "?",
                "help",
                "lookupconsoleid",
                "lookuppuid",
                "checkready",
                "dumpoldbans" //TO BE REMOVED AFTER THE APRIL XSR
                };

            int uniquesFound = 0;
            foreach (string curArg in args.Keys)
            {
                foreach (string unique in requiredUniqueArgs)
                {
                    if (curArg.ToLower() == unique.ToLower())
                    {
                        ++uniquesFound;
                    }
                }
            }

            if (uniquesFound<1)
            {
                Console.WriteLine("A required argument is missing.");
                return false;
            }

            if (uniquesFound>1)
            {
                Console.WriteLine("Too many arguments.");
                return false;
            }

            return true;
        }

        private static bool LoadupConfiguration(NamedArgParser parser)
        {
            if (parser["?"]!=null || parser["help"]!=null)
            {
                _help = true;
                return true;
            }
            if (parser["checkready"] != null)
            {
                _checkReady = true;
                return true;
            }
            else if (parser["lookupconsoleid"] != null)
            {
                _rawIdList.Add(parser["lookupconsoleid"]);
                _lookupConsoleId = true;
            }
            else if (parser["lookuppuid"] != null)
            {
                _rawIdList.Add(parser["lookuppuid"]);
                _lookupPuid = true;
            }
            else if (parser["dumpoldbans"] != null)
            {
                _dumpOldBans = true;
                _fileName = parser["dumpoldbans"];
                return true;
            }

            if (parser["file"] != null)
            {
                _fileName = parser["file"];
                _rawIdList = LoadIdsFromFile();

                if (_rawIdList == null)
                    return false;
            }

            return true;
        }

        private static List<string> LoadIdsFromFile()
        {
            List<string> ids = new List<string>();

            if (!File.Exists(_fileName))
            {
                Console.WriteLine("Can't find " + _fileName);
                return null;
            }

            using (StreamReader reader = new StreamReader(_fileName))
            {
                string line;
                while ((line = reader.ReadLine()) != null)
                {
                    line = line.Trim();
                    if (line.Length != 0)
                    {
                        if (!ids.Contains(line))
                        {
                            ids.Add(line);
                        }
                    }
                }
            }

            return ids;
        }

        static protected bool   _help            = false;
        static protected bool   _lookupConsoleId = false;
        static protected bool   _lookupPuid      = false;
        static protected bool   _checkReady      = false;
        static protected bool   _dumpOldBans     = false; //TO BE REMOVED AFTER THE APRIL XSR
        static protected string _fileName        = null;
        static protected List<string> _rawIdList = new List<string>();
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\MachineHelper\test\makefile.inc ===
!include $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\MachineHelper\app\MachineHelper.cs ===
using System;
using System.Collections.Generic;
using System.Data.SqlClient;
using System.IO;
using System.Text;
using System.Threading;

using Microsoft.Webstore.WstClient;

using xonline.common.config;
using xonline.common.mgmt;
using xonline.common.service;
using xonline.common.sql.webstore;
using xonline.common.tools.console;

using xonline.server.xmachine.fd.soap;

namespace xonline.tools.machinehelper
{
    partial class MachineHelperApp
    {
        [STAThread]
        static int Main(string[] args)
        {
            //parse commandline and offer help
            try
            {
                if (!Configuration.Parse(args))
                {
                    if (!Configuration.Help)
                        Console.Write("Invalid parameters!\n");

                    Help();
                    return -1;
                }
            }
            catch (Exception e)
            {
                Console.WriteLine("Unexpected Error Parsing Args!");
                Console.WriteLine(e.ToString());
                return -1;
            }

            //perform action
            try
            {
                XomLoggingControl.Init();

                if (Configuration.CheckReady)
                {
                    if (!CheckReady())
                        return -1;
                }
                else if (Configuration.LookupConsoleId)
                {
                    if (!LookupConsoleId())
                        return -1;
                }
                else if (Configuration.LookupPuid)
                {
                    if (!LookupPuid())
                        return -1;
                }
                else if (Configuration.DumpOldBans) //TO BE REMOVED AFTER THE APRIL XSR
                {
                    if (!DumpOldBans())
                        return -1;
                }

            }
            catch (Exception e)
            {
                Console.WriteLine("Unexpected Error!");
                Console.WriteLine(e.ToString());
                return -1;
            }
            finally
            {
                XomLoggingControl.Close();
            }

            return 0;
        }

        private static void Help()
        {
            Console.WriteLine("MachineHelper {commands} [options]");
            Console.WriteLine("/?  Displays this help message.");
            Console.WriteLine("");
            Console.WriteLine("    -- COMMANDS -- ");
            Console.WriteLine("");
            Console.WriteLine("     /lookupconsoleid:<id>    Looks up all information on a specific console ID.");
            Console.WriteLine("     /lookuppuid:<id>         Looks up all information on a specific machine puid.");
            Console.WriteLine("     /checkready              Verifies this tool can access xmachine.");
            Console.WriteLine("     /dumpoldbans:<directory> Dumps legacy bans to a directory that can be used by MachineBan."); //TO BE REMOVED AFTER THE APRIL XSR
            Console.WriteLine("");
            Console.WriteLine("    -- OPTIONS -- ");
            Console.WriteLine("");
            Console.WriteLine("     /file:<FileName>       Use file instead of individual id on the command line.");
            Console.WriteLine("");
            Console.WriteLine("EXAMPLES: ");
            Console.WriteLine("     /lookuppuid:0xFA00000000000000");
            Console.WriteLine("     /lookupconsoleid:XE.111111111111");
            Console.WriteLine("     /lookupconsoleid /file:MyConsoleList.txt");
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\MachineHelper\app\ActionLookupPuid.cs ===
using System;
using System.Collections.Generic;
using System.Data.SqlClient;
using System.IO;
using System.Text;
using System.Threading;

using Microsoft.Webstore.WstClient;

using xonline.common.config;
using xonline.common.mgmt;
using xonline.common.service;
using xonline.common.sql.webstore;
using xonline.common.tools.console;

using xonline.server.xmachine.fd.soap;

namespace xonline.tools.machinehelper
{
    partial class MachineHelperApp
    {
        private static bool LookupPuid()
        {
            if (Configuration.RawIds.Count<=0)
            {
                return false;
            }

            XMachineSoapClient xmachine = new XMachineSoapClient();

            foreach (string rawId in Configuration.RawIds)
            {
                if (string.IsNullOrEmpty(rawId))
                {
                    continue;
                }

                string outcome = "SUCCESS";
                string result = "";
                try
                {
                    Puid puid;
                    if (!Puid.TryParse(rawId, out puid))
                    {
                        outcome = "FAIL (Invalid Puid)";
                        continue;
                    }

                    //right now we do individual lookups.  a future optimization would be to call in batches.
                    MachineInfo []ret = xmachine.LookupMachineInfoByMachinePuids(new ulong[]{puid});

                    foreach (MachineInfo mpi in ret)
                    {
                        if (result.Length>0) //existing entry
                        {
                            result += ", ";
                        }

                        string ciiCertHash = string.Join("", Array.ConvertAll(mpi.SecondaryIdentifier, (u => u.ToString("X2"))));
                        string ciiSCode = FormatSCode(ComputeSCode(mpi.SecondaryIdentifier));
                        result += "(ConsoleId=" + mpi.ConsoleId + " CertHash=0x" + ciiCertHash + " SCode=" + ciiSCode + ")";
                    }

                    if (ret.Length==0)
                    {
                        outcome="FAIL";
                    }
                }
                catch (System.Web.Services.Protocols.SoapException se) //only catch errors calling the API
                {
                    outcome = "FAIL (" + se.Message.Replace("\n", "  ") + ")";
                }
                finally
                {
                    Console.WriteLine(rawId + ": " + outcome + (result.Length>0 ? (": " + result) : ""));
                }
            }

            return true;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\MachineHelper\test\Suite.cs ===
using ServerTestFramework;

[assembly: RootNode(typeof(MachineHelperTest.MachineHelperTest))]

namespace MachineHelperTest
{
    [TestGroup, Owner("LukeL"), TestFrequency("Regression"), TestCasePriority(1)]
    public class MachineHelperTest: TestNode
    {
    };
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\MachineHelper\test\General.cs ===
using ServerTestFramework;
using ServerTestFramework.Utilities;
using ServerTestFramework.Database;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.Auth;
using System.Runtime.InteropServices;

namespace MachineHelperTest
{
    [TestGroup, Description("General MachineHelper Tests")]
    public class General: TestNode
    {
        [TestCase, Description("Pass the help paramter.")]
        public void Help()
        {
            string output=Util.RunMachineHelper("/?");
            string []expectedTokens=new string[]{"/lookupconsoleid", "/lookuppuid"};
            foreach (string e in expectedTokens)
            {
                if (!output.Contains(e))
                {
                    throw new UnexpectedTestResultException("Expected help text to contain an entry for: "+e);
                }
            }
        }
    };
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\MachineHelper\test\obj\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("Microsoft(R) Xbox(TM)")]
[assembly:System.Reflection.AssemblyCopyright("Copyright (c) Microsoft Corporation. All rights reserved.")]
[assembly:System.Reflection.AssemblyCompany("Microsoft Corporation")]
[assembly:System.Reflection.AssemblyFileVersion("12.4.56.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\MachineHelper\test\objd\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("Microsoft(R) Xbox(TM)")]
[assembly:System.Reflection.AssemblyCopyright("Copyright (c) Microsoft Corporation. All rights reserved.")]
[assembly:System.Reflection.AssemblyCompany("Microsoft Corporation")]
[assembly:System.Reflection.AssemblyFileVersion("12.4.56.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\MachineHelper\test\LookupConsoleId.cs ===
using ServerTestFramework;
using ServerTestFramework.Utilities;
using ServerTestFramework.Database;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.Auth;

using System.Collections.Generic;

namespace MachineHelperTest
{
    [TestGroup, Description("Tests for /lookupconsoleid")]
    public class LookupConsoleId: TestNode
    {
        private static byte[] ComputeSCode(byte []certHash)
        {
            //scode is the first 7 bytes of the certificate hash then a 1 byte checksum of the nibbles
            byte []scode = new byte[8];
            for (int digit=0; digit<7; ++digit)
            {
                scode[digit] = certHash[digit];
            }

            uint checksumLow = 0;
            uint checksumHigh = 0;
            for (int digit=0; digit<7; ++digit)
            {
                unchecked
                {
                    checksumLow += (uint)(scode[digit] & 0x0f);
                    checksumHigh += (uint)((scode[digit] & 0xf0) >> 4);
                }
            }

            scode[7] = (byte)((checksumLow & 0x0f) | ((checksumHigh & 0x0f) << 4));
            return scode;
        }

        private static string FormatSCode(byte []scodeBytes)
        {
            string scode = "";
            for (int segments=0; segments<4; ++segments)
            {
                if (scode.Length>0)
                {
                    scode += "-";
                }

                scode += string.Format("{0:X2}", scodeBytes[segments*2 + 0]);
                scode += string.Format("{0:X2}", scodeBytes[segments*2 + 1]);
            }
            return scode;
        }

        public class MachineEntry: System.IEquatable<MachineEntry>
        {
            public string PuidString;
            public string CertHashString;
            public string SCodeString;

            public override string ToString()
            {
                return "(MachinePuid="+PuidString+" CertHash="+CertHashString+" SCode="+SCodeString+")";
            }

            public MachineEntry(ulong puid, byte []certHash)
            {
                PuidString=string.Format("0x{0:X16}", puid);
                CertHashString="0x"+Hexer.tohex(certHash);
                SCodeString=FormatSCode(ComputeSCode(certHash));
            }

            public override bool Equals(object other)
            {
                if(!(other is MachineEntry))
                {
                    return false;
                }

                return Equals((MachineEntry)other);
            }

            public bool Equals(MachineEntry other)
            {
                return PuidString==other.PuidString &&
                    CertHashString==other.CertHashString &&
                    SCodeString==other.SCodeString;
            }

            public override int GetHashCode()
            {
                return PuidString.GetHashCode()^CertHashString.GetHashCode()^SCodeString.GetHashCode();
            }
        }

        public class StatusLine
        {
            public string ConsoleId;
            public string Result;
            public MachineEntry []Machines;

            public StatusLine(string cid, bool result, MachineEntry []machines)
            {
                ConsoleId=cid;
                Result=(result?"SUCCESS":"FAIL");
                Machines=machines;
            }
        }

        public static void VerifyOutputStatus(string output, StatusLine []expectedLines)
        {
            //first verify that the outputed list of console ids matches the expected list
            List<string> consolesFound=new List<string>();
            List<string> linesFound=new List<string>();

            string []outputLines=output.Replace("\r","").Split(new char[]{'\n'});
            foreach (string line in outputLines)
            {
                if (line.Contains(": ")) //one of the machine status rows
                {
                    consolesFound.Add(line.Substring(0, line.IndexOf(": ")));
                    linesFound.Add(line);
                }
            }

            List<string> consolesExpected=new List<string>();
            foreach (StatusLine sl in expectedLines)
            {
                consolesExpected.Add(sl.ConsoleId);
            }

            ValueCheck.TestAllUnordered("ConsoleIDs in output", consolesExpected, consolesFound);

            //now check each of the console id lines from the output for the correct details
            foreach (string line in linesFound)
            {
                foreach (StatusLine sl in expectedLines)
                {
                    if (line.StartsWith(sl.ConsoleId))
                    {
                        //check the result for this console id lookup
                        int firstSeperator=line.IndexOf(": ");
                        int secondSeperator=line.IndexOf(": ", firstSeperator+1);
                        int resultLength=(secondSeperator!=-1?secondSeperator:line.Length)-firstSeperator-2;
                        string result=line.Substring(firstSeperator+2, resultLength).Trim();

                        ValueCheck.Test("Result for "+sl.ConsoleId, sl.Result, result);

                        //check the lookup information
                        string info="";
                        if (secondSeperator!=-1)
                        {
                            info=line.Substring(secondSeperator+2);
                        }

                        List<string> foundMachineEntries=new List<string>();
                        string []infoPieces=info.Split(new char[]{','});
                        foreach (string infoPiece in infoPieces)
                        {
                            string infoPieceTrimmed=infoPiece.Trim();
                            if (infoPieceTrimmed.Length>0)
                            {
                                foundMachineEntries.Add(infoPieceTrimmed);
                            }
                        }

                        List<string> expectedMachineEntries=new List<string>();
                        if (sl.Machines!=null)
                        {
                            foreach (MachineEntry me in sl.Machines)
                            {
                                expectedMachineEntries.Add(me.ToString());
                            }
                        }

                        ValueCheck.TestAllUnordered("Machine Entries for "+sl.ConsoleId, expectedMachineEntries, foundMachineEntries);

                        break;
                    }
                }
            }
        }

        // -----

        [TestCase, Description("Lookup one on the commandline.")]
        [CompoundCase("Xbox360", MachineType.Xbox360)]
        [CompoundCase("Phone", MachineType.Phone)]
        [CompoundCase("PC", MachineType.PC)]
        public void Single(TestNode self)
        {
            MachineType mtype=(MachineType)self.MyValues[0];

            MachineEditor mach=MachineEditor.CreateNew(mtype);
            byte []machCertHash=mach.CertHash;
            if (machCertHash==null)
            {
                machCertHash=new byte[20];
            }

            string output=Util.RunMachineHelper("/lookupconsoleid:"+mach.ConsoleId);

            Util.CheckOutputForBasicBadness(output);
            VerifyOutputStatus(output, new StatusLine[]{new StatusLine(mach.ConsoleId, true, new MachineEntry[]{new MachineEntry(mach.Id, machCertHash)})});
        }

        [TestCase, Description("Lookup multiple at once.")]
        public void Multiple()
        {
            MachineEditor mach0=MachineEditor.CreateNew(MachineType.Xbox360);
            MachineEditor mach1=MachineEditor.CreateNew(MachineType.Xbox360);
            MachineEditor mach2=MachineEditor.CreateNew(MachineType.Xbox360);

            string filename=Util.WriteTempFile(new string[]{mach0.ConsoleId, mach1.ConsoleId, mach2.ConsoleId});

            string output=Util.RunMachineHelper("/lookupconsoleid /file:"+filename);

            Util.CheckOutputForBasicBadness(output);
            VerifyOutputStatus(output, new StatusLine[]{
                new StatusLine(mach0.ConsoleId, true, new MachineEntry[]{new MachineEntry(mach0.Id, mach0.CertHash)}),
                new StatusLine(mach1.ConsoleId, true, new MachineEntry[]{new MachineEntry(mach1.Id, mach1.CertHash)}),
                new StatusLine(mach2.ConsoleId, true, new MachineEntry[]{new MachineEntry(mach2.Id, mach2.CertHash)})
                });
        }

        [TestCase, Description("Lookup on a non-migrated xbox360 machine.")]
        public void LegacyXbox360()
        {
            MachineEditor mach=MachineEditor.CreateLegacyXbox360();

            string output=Util.RunMachineHelper("/lookupconsoleid:"+mach.ConsoleId);

            Util.CheckOutputForBasicBadness(output);
            VerifyOutputStatus(output, new StatusLine[]{new StatusLine(mach.ConsoleId, true, new MachineEntry[]{new MachineEntry(mach.Id, new byte[20])})});
        }

        [TestCase, Description("Lookup one console id that does not exist.")]
        public void SingleNonexistantMachine()
        {
            string cid=MachineEditor.GenerateRandomConsoleID(MachineType.Xbox360);

            string output=Util.RunMachineHelper("/lookupconsoleid:"+cid);

            Util.CheckOutputForBasicBadness(output);
            VerifyOutputStatus(output, new StatusLine[]{new StatusLine(cid, false, null)});
        }

        [TestCase]
        public void DuplicateConsole()
        {
            MachineEditor mach0=MachineEditor.CreateNew(MachineType.Xbox360);
            MachineEditor mach1=MachineEditor.CreateDuplicateXbox360(mach0.ConsoleId);

            string output=Util.RunMachineHelper("/lookupconsoleid:"+mach0.ConsoleId);

            Util.CheckOutputForBasicBadness(output);
            VerifyOutputStatus(output, new StatusLine[]{new StatusLine(mach0.ConsoleId, true, new MachineEntry[]{new MachineEntry(mach0.Id, mach0.CertHash), new MachineEntry(mach1.Id, mach1.CertHash)})});
        }
    };
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\MachineHelper\test\obj\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=msil_machinehelpertest_none_12.4.56.0_none_937bd02055608d2c
ASSEMBLY_IDENTITY_XP_KEY_FORM=msil_machinehelpertest_no-public-key_12.4.56.0_x-ww_9a4e4bca
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=machinehelpertest
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=msil
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=msil_machinehelpertest_no-public-key_12.4.56.0_x-ww_9a4e4bca
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=msil_machinehelpertest_no-public-key_12.4.56.0_x-ww_9a4e4bca.manifest
XP_MANIFEST_PATH=manifests\msil_machinehelpertest_no-public-key_12.4.56.0_x-ww_9a4e4bca.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=msil_machinehelpertest_no-public-key_12.4.56.0_x-ww_9a4e4bca.cat
XP_CATALOG_PATH=manifests\msil_machinehelpertest_no-public-key_12.4.56.0_x-ww_9a4e4bca.cat
XP_PAYLOAD_PATH=msil_machinehelpertest_no-public-key_12.4.56.0_x-ww_9a4e4bca
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=machinehelpertest,processorArchitecture=msil,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\MachineHelper\test\objd\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=msil_machinehelpertest_none_12.4.56.0_none_937bd02055608d2c
ASSEMBLY_IDENTITY_XP_KEY_FORM=msil_machinehelpertest_no-public-key_12.4.56.0_x-ww_9a4e4bca
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=machinehelpertest
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=msil
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=msil_machinehelpertest_no-public-key_12.4.56.0_x-ww_9a4e4bca
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=msil_machinehelpertest_no-public-key_12.4.56.0_x-ww_9a4e4bca.manifest
XP_MANIFEST_PATH=manifests\msil_machinehelpertest_no-public-key_12.4.56.0_x-ww_9a4e4bca.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=msil_machinehelpertest_no-public-key_12.4.56.0_x-ww_9a4e4bca.cat
XP_CATALOG_PATH=manifests\msil_machinehelpertest_no-public-key_12.4.56.0_x-ww_9a4e4bca.cat
XP_PAYLOAD_PATH=msil_machinehelpertest_no-public-key_12.4.56.0_x-ww_9a4e4bca
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=machinehelpertest,processorArchitecture=msil,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\MachineHelper\test\LookupPuid.cs ===
using ServerTestFramework;
using ServerTestFramework.Utilities;
using ServerTestFramework.Database;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.Auth;

using System.Collections.Generic;

namespace MachineHelperTest
{
    [TestGroup, Description("Tests for /lookuppuid")]
    public class LookupPuid: TestNode
    {
        private static byte[] ComputeSCode(byte []certHash)
        {
            //scode is the first 7 bytes of the certificate hash then a 1 byte checksum of the nibbles
            byte []scode = new byte[8];
            for (int digit=0; digit<7; ++digit)
            {
                scode[digit] = certHash[digit];
            }

            uint checksumLow = 0;
            uint checksumHigh = 0;
            for (int digit=0; digit<7; ++digit)
            {
                unchecked
                {
                    checksumLow += (uint)(scode[digit] & 0x0f);
                    checksumHigh += (uint)((scode[digit] & 0xf0) >> 4);
                }
            }

            scode[7] = (byte)((checksumLow & 0x0f) | ((checksumHigh & 0x0f) << 4));
            return scode;
        }

        private static string FormatSCode(byte []scodeBytes)
        {
            string scode = "";
            for (int segments=0; segments<4; ++segments)
            {
                if (scode.Length>0)
                {
                    scode += "-";
                }

                scode += string.Format("{0:X2}", scodeBytes[segments*2 + 0]);
                scode += string.Format("{0:X2}", scodeBytes[segments*2 + 1]);
            }
            return scode;
        }

        public class LookupResult
        {
            public string PuidString;
            public string ResultString;
            public string ConsoleId;
            public byte []CertHash;

            public LookupResult(ulong puid, bool result, string cid, byte []certHash)
            {
                PuidString=string.Format("0x{0:X16}", puid);
                ResultString=(result?"SUCCESS":"FAIL");
                ConsoleId=cid;
                CertHash=certHash;
            }

            public override string ToString()
            {
                string s=PuidString;
                s+=": ";
                s+=ResultString;
                if (ConsoleId!=null)
                {
                    s+=": ";
                    s+="(ConsoleId="+ConsoleId+" CertHash=0x"+Hexer.tohex(CertHash)+" SCode="+FormatSCode(ComputeSCode(CertHash))+")";
                }
                return s;
            }
        };

        public static void VerifyOutputStatus(string output, LookupResult []expectedResults)
        {
            //find all the status lines
            List<string> linesFound=new List<string>();

            string []outputLines=output.Replace("\r","").Split(new char[]{'\n'});
            foreach (string line in outputLines)
            {
                if (line.Contains(": ")) //one of the machine status rows
                {
                    linesFound.Add(line);
                }
            }

            //build the expected lines
            List<string> linesExpected=new List<string>();
            foreach (LookupResult lr in expectedResults)
            {
                linesExpected.Add(lr.ToString());
            }

            ValueCheck.TestAllUnordered("Status lines in output", linesExpected, linesFound);
        }

        // -----

        [TestCase, Description("Lookup one on the commandline.")]
        [CompoundCase("Xbox360", MachineType.Xbox360)]
        [CompoundCase("Phone", MachineType.Phone)]
        [CompoundCase("PC", MachineType.PC)]
        public void Single(TestNode self)
        {
            MachineType mtype=(MachineType)self.MyValues[0];
            MachineEditor mach=MachineEditor.CreateNew(mtype);

            string output=Util.RunMachineHelper("/lookuppuid:"+string.Format("0x{0:X16}", mach.Id));

            Util.CheckOutputForBasicBadness(output);
            VerifyOutputStatus(output, new LookupResult[]{new LookupResult(mach.Id, true, mach.ConsoleId, mach.CertHash??new byte[20])});
        }

        [TestCase, Description("Lookup multiple at once.")]
        public void Multiple()
        {
            MachineEditor mach0=MachineEditor.CreateNew(MachineType.Xbox360);
            MachineEditor mach1=MachineEditor.CreateNew(MachineType.Xbox360);
            MachineEditor mach2=MachineEditor.CreateNew(MachineType.Xbox360);

            //string filename=Util.WriteTempFile(new ulong[]{mach0.Id, mach1.Id, mach2.Id}); //Bug 188849: Puid.TryParse doesn't try very hard.  We should create a separate test for this later.
            string filename=Util.WriteTempFile(new string[]{string.Format("0x{0:X16}", mach0.Id), string.Format("0x{0:X16}", mach1.Id), string.Format("0x{0:X16}", mach2.Id)});

            string output=Util.RunMachineHelper("/lookuppuid /file:"+filename);

            Util.CheckOutputForBasicBadness(output);
            VerifyOutputStatus(output, new LookupResult[]{
                new LookupResult(mach0.Id, true, mach0.ConsoleId, mach0.CertHash),
                new LookupResult(mach1.Id, true, mach1.ConsoleId, mach1.CertHash),
                new LookupResult(mach2.Id, true, mach2.ConsoleId, mach2.CertHash)
                });
        }

        [TestCase, Description("Lookup on a non-migrated xbox360 machine.")]
        public void LegacyXbox360()
        {
            MachineEditor mach=MachineEditor.CreateLegacyXbox360();

            string output=Util.RunMachineHelper("/lookuppuid:"+string.Format("0x{0:X16}", mach.Id));

            Util.CheckOutputForBasicBadness(output);
            VerifyOutputStatus(output, new LookupResult[]{new LookupResult(mach.Id, true, mach.ConsoleId, new byte[20])});
        }

        [TestCase, Description("Lookup one machine that does not exist.")]
        public void SingleNonexistantMachine()
        {
            ulong puid=MachineEditor.AllocateMachinePuid(MachineType.Xbox360);

            string output=Util.RunMachineHelper("/lookuppuid:"+string.Format("0x{0:X16}", puid));

            Util.CheckOutputForBasicBadness(output);
            VerifyOutputStatus(output, new LookupResult[]{new LookupResult(puid, false, null, null)});
        }
    };
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\MachineHelper\test\Util.cs ===
using ServerTestFramework;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.Auth;
using ServerTestFramework.Utilities;
using ServerTestFramework.Database;
using System.IO;
using System.Text;

using xonline.common.config;

namespace MachineHelperTest
{
    public static class Util
    {

        //runs machine helper tool with specific arguments, and returns the commandline output
        public static string RunMachineHelper(string args)
        {
            return RunMachineHelper(args, 120);
        }
        public static string RunMachineHelper(string args, uint timeoutInS)
        {
            //run it, capturing the output
            ProcessWrapper pr=new ProcessWrapper("MachineHelper","MachineHelper.exe");
            pr.SetEnvironmentVariable("XBL_CONFIG_SERVER", Global.CurrentEnvironment.NpdbIp);
            pr.SetEnvironmentVariable("XBL_CONFIG_DATABASE", Global.CurrentEnvironment.NpdbName);
            pr.ExecutionTimeout=(int)timeoutInS;
            pr.EchoOutput=true;
            pr.Run(args);

            return pr.Output;
        }

        //throws an exception if was a common error in an output string from MachineHelper.
        public static void CheckOutputForBasicBadness(string str)
        {
            if (str.Contains("Invalid parameters!"))
            {
                throw new UnexpectedTestResultException("Output contained unexpected string: Invalid parameters!");
            }

            if (str.Contains("-- OPTIONS --"))
            {
                throw new UnexpectedTestResultException("Output contained unexpected string: -- OPTIONS --");
            }

            if (str.Contains("System.Byte"))
            {
                throw new UnexpectedTestResultException("Output contained unexpected string: System.Byte");
            }

            if (str.Contains("Exception:"))
            {
                throw new UnexpectedTestResultException("output from machinehelper contained 'Exception:'");
            }

            if (str.Contains("Error!"))
            {
                throw new UnexpectedTestResultException("output from machinehelper contained 'Error!'");
            }
        }

        public static string WriteTempFile(string data)
        {
            Directory.CreateDirectory("tmp\\machinehelpertest\\");

            string fname="Tmp_"+ServerTestFramework.Core.Utilities.RandomEx.GlobalRandGen.GenerateRandomAlphaNumericString(10, 10)+".txt";
            string fullName="tmp\\machinehelpertest\\"+fname;

            FileStream f=new FileStream(fullName, FileMode.Create, FileAccess.Write);
            StreamWriter fwriter=new StreamWriter(f);
            fwriter.Write(data);
            fwriter.Close();
            f.Close();

            return fullName;
        }

        public static string WriteTempFile(System.Collections.IEnumerable datas)
        {
            string s="";
            foreach (object o in datas)
            {
                s+=""+o;
                s+="\r\n";
            }
            return WriteTempFile(s);
        }
    };
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\MachineHelper\wp7\makefile.inc ===
!include $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\MachineHelper\wp7\obj\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("DEPOT")]
[assembly:System.Reflection.AssemblyCopyright("")]
[assembly:System.Reflection.AssemblyCompany("")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\MachineHelper\wp7\objd\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("DEPOT")]
[assembly:System.Reflection.AssemblyCopyright("")]
[assembly:System.Reflection.AssemblyCompany("")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\MachineHelper\wp7\Configuration.cs ===
using System;
using System.Collections.Generic;
using System.IO;
using System.Data;
using System.Globalization;
using xonline.common.service;
using xonline.common.tools.console;

namespace xonline.tools.machinehelper
{
    class Configuration
    {
        static public bool Help
        {
            get { return _help; }
        }

        static public bool AddWP7
        {
            get { return _addWP7; }
        }

        static public bool LookupWP7
        {
            get { return _lookupWP7; }
        }

        static public string FileName
        {
            get { return _fileName; }
        }

        static public List<string> RawIds
        {
            get { return _rawIdList; }
        }

        static public bool Parse(string[] args)
        {
            // Parse arguments
            NamedArgParser parser = new NamedArgParser(
                new string[] {
                    "?",
                    "help",
                    "add",
                    "lookup"
                    });

            if(!parser.Parse(args))
                return false;

            // Process arguments
            if(parser["help"]!=null || parser["?"]!=null)
            {
                _help = true;
                return false;
            }

            if (!CheckValidArgs(parser))
            {
                return false;
            }

            if (!LoadupConfiguration(parser))
            {
                return false;
            }

            return true;
        }

        private static bool CheckValidArgs(NamedArgParser args)
        {
            //there must always be exactly one of these arguments
            string []requiredUniqueArgs=new string[] {
                "?",
                "help",
                "add",
                "lookup"
                };

            int uniquesFound = 0;
            foreach (string curArg in args.Keys)
            {
                foreach (string unique in requiredUniqueArgs)
                {
                    if (curArg.ToLower() == unique.ToLower())
                    {
                        ++uniquesFound;
                    }
                }
            }

            if (uniquesFound<1)
            {
                Console.WriteLine("A required argument is missing.");
                return false;
            }

            if (uniquesFound>1)
            {
                Console.WriteLine("Too many arguments.");
                return false;
            }

            return true;
        }

        private static bool LoadupConfiguration(NamedArgParser parser)
        {
            if (parser["?"]!=null || parser["help"]!=null)
            {
                _help = true;
                return true;
            }
            else if (parser["add"] != null)
            {
                _rawIdList.Add(parser["add"]);
                _addWP7 = true;
            }
            else if (parser["lookup"] != null)
            {
                _rawIdList.Add(parser["lookup"]);
                _lookupWP7 = true;
            }

            if (parser["file"] != null)
            {
                _fileName = parser["file"];
                _rawIdList = LoadIdsFromFile();

                if (_rawIdList == null)
                    return false;
            }

            return true;
        }

        private static List<string> LoadIdsFromFile()
        {
            List<string> ids = new List<string>();

            if (!File.Exists(_fileName))
            {
                Console.WriteLine("Can't find " + _fileName);
                return null;
            }

            using (StreamReader reader = new StreamReader(_fileName))
            {
                string line;
                while ((line = reader.ReadLine()) != null)
                {
                    line = line.Trim();
                    if (line.Length != 0)
                    {
                        if (!ids.Contains(line))
                        {
                            ids.Add(line);
                        }
                    }
                }
            }

            return ids;
        }

        static protected bool   _help            = false;
        static protected bool   _addWP7          = false;
        static protected bool   _lookupWP7       = false;
        static protected string _fileName        = null;
        static protected List<string> _rawIdList = new List<string>();
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\MachineHelper\wp7\ActionAddWP7.cs ===
using System;

using xonline.server.sts.fd;

namespace xonline.tools.machinehelper
{
    partial class MachineHelperApp
    {
        private static bool AddWP7()
        {
            if (Configuration.RawIds.Count<=0)
            {
                return false;
            }

            foreach (string rawId in Configuration.RawIds)
            {
                if (string.IsNullOrEmpty(rawId))
                {
                    continue;
                }

                string outcome = "SUCCESS";
                string result = "";
                try
                {
                    IsBase64String(rawId);

                    ulong machinePuid = WMMachinesDB.CreateMachineAccount(rawId);

                    result += "(MachinePuid=" + machinePuid.ToString("X16") + ")";
                }
                catch (Exception e)
                {
                    outcome = "FAIL (" + e.Message.Replace("\n", "  ") + ")";
                }
                finally
                {
                    Console.WriteLine(rawId + ": " + outcome + (result.Length>0 ? (": " + result) : ""));
                }
            }

            return true;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\MachineHelper\wp7\ActionLookupWP7.cs ===
using System;

using xonline.server.sts.fd;

namespace xonline.tools.machinehelper
{
    partial class MachineHelperApp
    {
        private static bool LookupWP7()
        {
            if (Configuration.RawIds.Count <= 0)
            {
                return false;
            }

            foreach (string rawId in Configuration.RawIds)
            {
                if (string.IsNullOrEmpty(rawId))
                {
                    continue;
                }

                string outcome = "SUCCESS";
                string result = "";
                try
                {
                    IsBase64String(rawId);

                    ulong machinePuid = WMMachinesDB.GetMachinePuid(rawId);
                    if (0 == machinePuid)
                    {
                        outcome = "FAIL (Machine Not Found)";
                    }
                    else
                    {
                        result += "(MachinePuid=0x" + machinePuid.ToString("X16") + ")";
                    }
                }
                catch (Exception e)
                {
                    outcome = "FAIL (" + e.Message.Replace("\n", "  ") + ")";
                }
                finally
                {
                    Console.WriteLine(rawId + ": " + outcome + (result.Length > 0 ? (": " + result) : ""));
                }
            }

            return true;
        }

        // Verify this is a Base64EncodedString
        // return true on success, will throw and exception otherwise
        private static bool IsBase64String(string rawId)
        {
            if (string.IsNullOrEmpty(rawId))
                return false;

            // Undo the character substitution done on the phone
            string encodedId = rawId.Replace("-", "+");
            string base64 = encodedId.Replace("_", "/");

            // Pad out string to a multiple of 4, padding is removed by the phone
            while (0 != base64.Length % 4)
            {
                base64 += "=";
            }
            Console.WriteLine(base64);

            byte[] id = Convert.FromBase64String(base64);

            return true;
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\manicopy\obj\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("DEPOT")]
[assembly:System.Reflection.AssemblyCopyright("")]
[assembly:System.Reflection.AssemblyCompany("")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\manicopy\objd\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("DEPOT")]
[assembly:System.Reflection.AssemblyCopyright("")]
[assembly:System.Reflection.AssemblyCompany("")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\MachineHelper\wp7\WMMachinesdb.cs ===
//
// Machinesdb.cs
// Copyright (c) Microsoft Corporation. All Rights Reserved.
//

using System;
using System.Collections;
using System.Data;
using System.Data.SqlClient;
using System.IO;
using System.Text;
using System.Transactions;
using System.Web;

using Microsoft.Webstore.WstClient;

using xonline.common.config;
using xonline.common.mgmt;
//using xonline.common.protocol;
using xonline.common.service;
using xonline.common.sql.webstore;

[assembly: XomAreaDefinition(XomAreaName.sts)]
    
namespace xonline.server.sts.fd
{
    internal class WMMachinesDB
    {
        private const string MOBILE_PREFIX = "WM.";

        // -------------------------------------------------------------------------------
        // Implementation public
        // -------------------------------------------------------------------------------

        public static ulong CreateMachineAccount( string deviceId )
        {
            ulong machinePuid       = WMMachinesDB.GetPuid();

            using (TransactionScope ts = new TransactionScope())
            {
                using (WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITEONLY_COMMANDTYPE))
                {
                    // insert the machine into t_machines
                    ws.ClearParameters();
                    ws.StoredProc = "dbo.p_xmacs_insertmachine";
                    ws.SetHashVal(machinePuid);

                    ws.AddParameter("@serialnum", MOBILE_PREFIX + machinePuid.ToString("X16").Substring(4));
                    ws.AddParameter("@machinepuid", machinePuid);
                    ws.AddParameter("@si_hash_bucket", ws.Partition);

                    ws.ExecuteNonQuery();

                    // insert the machine into t_wm_machines
                    ws.ClearParameters();
                    ws.StoredProc = "dbo.p_wm_insert_machine";
                    ws.SetHashVal(deviceId);

                    ws.AddParameter("@vc_WMDevice_id", deviceId);
                    ws.AddParameter("@bi_machine_puid", machinePuid);
                    ws.AddParameter("@si_hash_bucket", ws.Partition);

                    ws.ExecuteNonQuery();
                }
                ts.Complete();
            }
            
            return machinePuid;
        }
        
        public static ulong GetMachinePuid( string deviceId )
        {
            ulong machinePuid       = 0;
            WstConnection   conn    = null;
            WstCommand      cmd     = null;
            WstDataReader   dataset = null;

            try
            {
                conn = new WstConnection(ConfigUtil.UodbWebstoreApp);
                conn.Open();

                cmd = conn.CreateCommand();
                cmd.CommandType = CommandType.StoredProcedure;
                cmd.CommandText = "dbo.p_wm_get_machines";
                cmd.WstFailoverMode = WstFailoverMode.PrimaryThenSecondary;
                cmd.PartitionType   = WstPartitionType.Logical;
                cmd.Partition       = WSClient.GetHashPartition( deviceId, ConfigUtil.UodbWebstoreApp);
                cmd.Parameters.Add("@vc_WMDevice_id", SqlDbType.NVarChar, 64).Value = deviceId;

                dataset = cmd.ExecuteReader();

                if (dataset.Read())
                {
                    machinePuid = (ulong) dataset.GetInt64(0);
                }
            }
            finally
            {
                if (null!=dataset)
                    dataset.Close();
                if (null!=conn)
                    conn.Close();
            }

            return machinePuid;
        }


        // -------------------------------------------------------------------------------
        // Implementation private
        // -------------------------------------------------------------------------------

        private static ulong GetPuid()
        {
            int blockSize = 1;
            int bucket = Config.GetIntSetting(Setting.puidmgr_userPuidBucket);

            using (SqlConnection conn = new SqlConnection(ConfigUtil.NpdbConnectionString))
            {
                conn.Open();

                using (SqlCommand cmd = conn.CreateCommand())
                {
                    cmd.CommandText = "dbo.p_puid_get_next_id";
                    cmd.CommandType = CommandType.StoredProcedure;

                    SqlParameter ret = cmd.CreateParameter();
                    ret.Direction = ParameterDirection.ReturnValue;
                    cmd.Parameters.Add(ret);

                    cmd.Parameters.Add("@i_bucket_id", SqlDbType.Int).Value = bucket;
                    cmd.Parameters.Add("@i_req_block_size", SqlDbType.Int).Value = blockSize;
                    cmd.Parameters.Add("@bi_base", SqlDbType.BigInt).Value = unchecked((long)XOn.XboxId.MobileMachineBase);

                    SqlParameter puidParam = cmd.CreateParameter();
                    puidParam.Direction = ParameterDirection.Output;
                    puidParam.DbType = DbType.Int64;
                    puidParam.ParameterName = "@bi_next_id";
                    cmd.Parameters.Add(puidParam);

                    cmd.ExecuteNonQuery();

                    int retVal = (int) ret.Value;

                    // log the result information.
                    Xom.Trace(XomAreaName.puidmgr, LogLevel.L_INFO, "PUID acquistion from NPDB returned :  RETVAL:  " + retVal + "\nBucket = " + bucket + "\nBlock Size = " + blockSize );

                    if (retVal == 0)
                    {
                        return (ulong) ((long) puidParam.Value);
                    }
                    else
                    {
                        throw new XRLException( HResult.XONLINE_E_DATABASE_RESULT_ERROR, XEvent.Id.COMMON_CODE_180, "Failed to attain PUID block from NPDB.  Please investigate. RETVAL:  " + retVal );
                    }
                }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\manicopy\manicopy.cs ===
using System;
using System.Collections;
using System.IO;
using System.Xml;
using System.Xml.XPath;
using System.Collections.Specialized;
using System.Text;

using xonline.common.service;
using xonline.common.tools.console;

namespace xonline.tools.manicopy.bin
{
    public class manicopy
    {
        static NamedArgParser _parsedArgs;
        static bool _ignoreMissingFiles = false;

        public static void Main(string[] args)
        {
            try
            {
                string[] options = new string[] { "m", "d", "v", "a", "u", "q" };
                string filetext;
                
                if (args.Length == 0)
                {
                    //                          1    1    2    2    3    3    4    4    5    5    6    6    7    7    8
                    //                 ----5----0----5----0----5----0----5----0----5----0----5----0----5----0----5----0
                    Console.WriteLine("Usage: manicopy -m:<manifest.xml> -d:<destination> -v:<version>");
                    Console.WriteLine("                 [-a:<wst app>] [-u] [-q]");
                    Console.WriteLine("    <manifest.xml>: the webstore xml file listing the sql sources.");
                    Console.WriteLine("    <destination>: directory to copy the files to.");
                    Console.WriteLine("    <version>: build version number to inject into the files.");
                    Console.WriteLine("    <webstore app>: the name of the webstore application.");
                    Console.WriteLine("    -u  Upgrade mode, don't error out on missing files.");
                    Console.WriteLine("    -q  QFE manifest generation only, don't attempt to copy any files.");
                    Console.WriteLine("        ");
                    Console.WriteLine("");
                    Console.WriteLine("This tool copies the list of files contained in the provided manifest ");
                    Console.WriteLine("file to a given directory.");
                    return;
                }
                
                // parse arguments
                //
                _parsedArgs = new NamedArgParser(options);
                if (!_parsedArgs.Parse(args))
                {
                    Console.WriteLine("Invalid argument: " + _parsedArgs.InvalidArgText);
                    return;
                }

                if (_parsedArgs["u"] != null)
                {
                    _ignoreMissingFiles = true;
                }

                Console.WriteLine("Building " + _parsedArgs["m"] + " :");
                string manipath = Path.GetDirectoryName(_parsedArgs["m"]);
                            
                // copy the manifest file
                // 
                Console.WriteLine("    " + Path.Combine(manipath, _parsedArgs["m"]) + " => " + _parsedArgs["d"]);
                filetext = LoadFile(_parsedArgs["m"]);
                filetext = DoTextReplacements(filetext);
                SaveFile(filetext, _parsedArgs["m"]);

                if (_parsedArgs["q"] != null)
                {
                    // QFE manifest generation, don't copy extra files
                    return;
                }

                // copy the list of files in the manifest
                //
                
                // webstore requires the xsd file to be present.  However, this craps out the
                // XPath reader.  So remove it before trying to parse.
                filetext = filetext.Replace(" xmlns=\"urn:WebstoreManifestSchema.xsd\"", "");
                StringCollection files = GetFileList(filetext);
                
                foreach (string file in files)
                {
                    string filePath = Path.Combine(manipath, file);

                    if (File.Exists(filePath))
                    {
                        Console.WriteLine("    " + Path.Combine(manipath, file) + " => " + _parsedArgs["d"]);

                        filetext = LoadFile(Path.Combine(manipath, file));
                        filetext = DoTextReplacements(filetext);
                        SaveFile(filetext, file);
                    }
                    else if (!_ignoreMissingFiles)
                    {
                        throw new FileNotFoundException(filePath);
                    }
                }
            }
            catch(Exception e)
            {
                Console.WriteLine("manicopy : error MCP0000 : " + e.ToString());
            }    
            
                                                                                       
        }
        
        public static string DoTextReplacements(string filetext)
        {
            string ver = _parsedArgs["v"];
            if (ver != null)
            {
                filetext = filetext.Replace("<<BUILDNUMBER>>", ver);
                filetext = filetext.Replace("{BUILDNUMBER}", ver);
            }
            
            string app = _parsedArgs["a"];
            if (app != null)
            {
                filetext = filetext.Replace("<<WSTAPPNAME>>", app);
                filetext = filetext.Replace("{WSTAPPNAME}", app);
            }
            
            return filetext;
        }        
    
        public static StringCollection GetFileList(string xml)
        {
            StringCollection files = new StringCollection();
            XPathNodeIterator sourceFileNodes;
            
            XPathDocument doc = new XPathDocument(new StringReader(xml));                                  
            XPathNavigator root = doc.CreateNavigator();
            
            // webstore format
            sourceFileNodes = root.Select("//SourceFile");
            while(sourceFileNodes.MoveNext())
            {
                files.Add(sourceFileNodes.Current.Value.Trim());
            }

            // sqlrunner format
            sourceFileNodes = root.Select("//sqlScript");
            while(sourceFileNodes.MoveNext())
            {
                files.Add(sourceFileNodes.Current.GetAttribute("src", "").Trim());
            }

            if (files.Count == 0)
            {
                throw new Exception("No source file nodes!!");
            }
            
            
            return files;
        }
        
        public static string LoadFile(string filename)
        {
            using (StreamReader reader = new StreamReader(filename, true))
            {
                return reader.ReadToEnd();
            }
        }
        
        public static void SaveFile(string filetext, string filename)
        {
            string destdir = _parsedArgs["d"];
            string destfile = Path.Combine(destdir, filename);
            
            Directory.CreateDirectory(Path.GetDirectoryName(destfile));
            
            using (StreamWriter writer = new StreamWriter(destfile, false, Encoding.Unicode))
            {
                writer.Write(filetext);
            }
        }    
            
            
    }
    
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\MachineHelper\wp7\MachineHelper.cs ===
using System;
using System.Collections.Generic;
using System.Data.SqlClient;
using System.IO;
using System.Text;
using System.Threading;

using Microsoft.Webstore.WstClient;

using xonline.common.config;
using xonline.common.mgmt;
using xonline.common.service;
using xonline.common.sql.webstore;
using xonline.common.tools.console;

using xonline.server.xmachine.fd.soap;

namespace xonline.tools.machinehelper
{
    partial class MachineHelperApp
    {
        [STAThread]
        static int Main(string[] args)
        {
            //parse commandline and offer help
            try
            {
                if (!Configuration.Parse(args))
                {
                    if (!Configuration.Help)
                        Console.Write("Invalid parameters!\n");

                    Help();
                    return -1;
                }
            }
            catch (Exception e)
            {
                Console.WriteLine("Unexpected Error Parsing Args!");
                Console.WriteLine(e.ToString());
                return -1;
            }

            //perform action
            try
            {
                XomLoggingControl.Init();

                if (Configuration.AddWP7)
                {
                    if (!AddWP7())
                        return -1;
                }
                else if (Configuration.LookupWP7)
                {
                    if (!LookupWP7())
                        return -1;
                }
            }
            catch (Exception e)
            {
                Console.WriteLine("Unexpected Error!");
                Console.WriteLine(e.ToString());
                return -1;
            }
            finally
            {
                XomLoggingControl.Close();
            }

            return 0;
        }

        private static void Help()
        {
            Console.WriteLine("MachineWP7Helper {commands} [options]");
            Console.WriteLine("/?  Displays this help message.");
            Console.WriteLine("");
            Console.WriteLine("    -- COMMANDS -- ");
            Console.WriteLine("");
            Console.WriteLine("     /add:<id>       Adds a WP7 device to t_machines and t_wm_machines.");
            Console.WriteLine("     /lookup:<id>    Looks up a machine puid.");
            Console.WriteLine("");
            Console.WriteLine("    -- OPTIONS -- ");
            Console.WriteLine("");
            Console.WriteLine("     /file:<FileName>       Use file instead of individual id on the command line.");
            Console.WriteLine("");
            Console.WriteLine("    -- FIELDS -- ");
            Console.WriteLine("");
            Console.WriteLine("     <Id>       This is the WP7 certificate subject device id hash.");
            Console.WriteLine("                eg CN = urn:qp-ac-hash:<Id>.");
            Console.WriteLine("");
            Console.WriteLine("EXAMPLES: ");
            Console.WriteLine("     /add:2CVIfNWSzOr-aVLGLnunBFyLF8mNiR6DOUqYbxcXDr4");
            Console.WriteLine("     /lookup:2CVIfNWSzOr-aVLGLnunBFyLF8mNiR6DOUqYbxcXDr4");
            Console.WriteLine("     /lookup /file:MyConsoleList.txt");
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\ManifestEdit\objd\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("DEPOT")]
[assembly:System.Reflection.AssemblyCopyright("")]
[assembly:System.Reflection.AssemblyCompany("")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\MatchStress\Client.cpp ===
#include "precomp.h"

CAtlList<CClient*>          CClient::s_ClientList;
HANDLE                      CClient::s_hTimerQueue = NULL;
HANDLE                      CClient::s_hShutDownComplete = NULL;
LONG                        CClient::s_lRunningClients = 0;
CComPtr<IXMatchStorage>     CClient::s_piStorage;
CClient::TITLE_ATTRIBUTES   CClient::s_titleAttributes;
CClient::SEARCH_PARAMETERS  CClient::s_searchParameters;

const CComBSTR  g_cbstrValue(L"value");
const CComBSTR  g_cbstrProb(L"prob");
const CComBSTR  g_cbstrTitleID(L"title_id");
const CComBSTR  g_cbstrAttributeID(L"attribute_id");
const CComBSTR  g_cbstrType(L"type");
const CComBSTR  g_cbstrMin(L"min");
const CComBSTR  g_cbstrMax(L"max");
const CComBSTR  g_cbstrCount(L"count");
const CComBSTR  g_cbstrProcIndex(L"procedure_index");
const CComBSTR  g_cbstrMaxLocalUsers(L"maxlocalusers");
const CComBSTR  g_cbstrPublic(L"public");
const CComBSTR  g_cbstrPrivate(L"private");

//
//  Timer queue callback function, calls right back into CClient
//

VOID CALLBACK TimerCallback(
    PVOID lpParameter,        // thread data
    BOOLEAN TimerOrWaitFired  // reason
    )
{
    ((CClient*)lpParameter)->Callback();
}

//
//  Utility functions
//

#define TOHEX(c) ((L'0' <= c && c <= L'9') ? (c + L'0') : ((L'a' <= c && c <= L'f') ? (c - L'a' + 10) : 0))

HRESULT StringToBlob(
    LPCWSTR szString,
    LPBYTE& pBlob,
    ULONG&  ulBlobLen
    )
{
    LPCWSTR szCur = szString;
    ULONG   ulCur = 0;

    //
    //  If first two characters are '0x' or '0X', skip them
    //

    if(_wcsnicmp(szCur, L"0x", 2) == 0)
    {
        szCur += 2;
        --ulBlobLen;
    }

    //
    //  Now for each pair of characters, convert to byte and put into buffer
    //  If either character is '\0', then we're done, no embedded nulls please.
    //

    while(*szCur != L'\0' && *(szCur + 1) != L'\0')
    {
        pBlob[ulCur] = (TOHEX(tolower(*szCur)) << 4) | TOHEX(tolower(*(szCur + 1)));
        szCur += 2;
        ++ulCur;
    }

    return S_OK;
}

HRESULT GetIntAttribute(
    IXMLDOMElement* piElement, 
    BSTR            bstrAttrName,
    ULONGLONG&      qwAttrValue
    )
{
    HRESULT                 hr;
    CComVariant             vValue;
    
    hr = piElement->getAttribute(bstrAttrName, &vValue);
    if(FAILED(hr))
        goto Cleanup;

    qwAttrValue = (ULONGLONG)_wtoi64(vValue.bstrVal); // specifying base = 0 causes the radix to be 
                                                      // specified by the initial characters
    hr = S_OK;

Cleanup:

    return hr;
}

HRESULT GetUlongAttribute(
    IXMLDOMElement* piElement, 
    BSTR            bstrAttrName,
    ULONG&          ulAttrValue
    )
{
    HRESULT                 hr;
    CComVariant             vValue;
    LPWSTR                  szEnd;
    
    hr = piElement->getAttribute(bstrAttrName, &vValue);
    if(FAILED(hr))
        goto Cleanup;

    ulAttrValue = wcstoul(vValue.bstrVal, &szEnd, 0); // specifying base = 0 causes the radix to be 
                                                      // specified by the initial characters
    if(szEnd == vValue.bstrVal)
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    hr = S_OK;

Cleanup:

    return hr;
}

HRESULT GetStringAttribute(
    IXMLDOMElement* piElement, 
    BSTR            bstrAttrName,
    LPSTR&          szAttrValue
    )
{
    HRESULT                 hr;
    CComVariant             vValue;
    LPWSTR                  szEnd;
    
    USES_CONVERSION;

    hr = piElement->getAttribute(bstrAttrName, &vValue);
    if(FAILED(hr))
        goto Cleanup;

    szAttrValue = _strdup(W2A(vValue.bstrVal));
    hr = S_OK;

Cleanup:

    return hr;
}

HRESULT GetBlobAttribute(
    IXMLDOMElement* piElement, 
    BSTR            bstrAttrName,
    LPBYTE&         pAttrValue,
    ULONG&          ulAttrLen
    )
{
    HRESULT                 hr;
    CComVariant             vValue;
    LPWSTR                  szEnd;
    
    hr = piElement->getAttribute(bstrAttrName, &vValue);
    if(hr != S_OK)
        goto Cleanup;

    ulAttrLen = SysStringLen(vValue.bstrVal) >> 1;
    pAttrValue = (LPBYTE)malloc(ulAttrLen);
    if(pAttrValue == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    hr = StringToBlob(vValue.bstrVal, pAttrValue, ulAttrLen);

Cleanup:

    return hr;
}

HRESULT GetListElement(
    IXMLDOMNodeList*    piList,
    LONG                lIndex,
    IXMLDOMElement**    ppiElement
    )
{
    HRESULT                 hr;
    CComPtr<IXMLDOMNode>    piNode;

    hr = piList->get_item(lIndex, &piNode);
    if(FAILED(hr))
        goto Cleanup;

    hr = piNode->QueryInterface(ppiElement);

Cleanup:

    return hr;
}

//
//  Constructor
//

CClient::CClient(
    ULONG   ulTitleID,
    ULONG   ulProcIndex,
    ULONG   ulMaxLocalUsers,
    ULONG   ulPublicMax,
    ULONG   ulPrivateMax
    ) : m_bHosting(false),
        m_hTimer(NULL),
        m_State(DO_SEARCH),
        m_ulTitleID(ulTitleID),
        m_ulProcIndex(ulProcIndex),
        m_ulMaxSearchResults(50),
        m_pHost(NULL),
        m_ulPublicMax(ulPublicMax),
        m_ulPrivateMax(ulPrivateMax),
        m_ulPublicFilled(0),
        m_ulPrivateFilled(0)
{
    memset(&m_Addr, 0, sizeof(XNADDR));
    m_Addr.ina.S_un.S_addr = (ULONG)this;

    memset(&m_SessionID, 0, sizeof(XNKID));
    memset(&m_SessionKey, 0, sizeof(XNKEY));

    //
    //  Generate the number of local users
    //

    BYTE b;
    GenRandom(&b, 1);
    m_ulNumUsers = b % ulMaxLocalUsers;

    //
    //  Initialize slot counts.
    //

    ATLASSERT(m_ulNumUsers <= m_ulPublicMax + m_ulPrivateMax);

    if(m_ulNumUsers > m_ulPublicMax)
    {
        m_ulPublicFilled = m_ulPublicMax;
        m_ulPrivateFilled = m_ulPublicMax - m_ulNumUsers;
    }
    else
    {
        m_ulPublicFilled = m_ulNumUsers;
    }

    m_csPlayers.Init();
}

CClient::~CClient(void)
{
}

//
//  Start this client
//

HRESULT CClient::Start()
{
    PostTimedEvent(0);

    InterlockedIncrement(&s_lRunningClients);

    return S_OK;
}

//
//  Stop this client
//

HRESULT CClient::Stop()
{
    //
    //  Cancel any outstanding timer event.
    //
    
    CancelTimerQueueTimer(s_hTimerQueue, m_hTimer);

    //
    //  If we're currently hosting a session, delete it
    //

    if(m_bHosting)
    {
        s_piStorage->DeleteSession(m_SessionID, m_ulTitleID);
    }

    //
    //  Decrement count of running clients
    //

    if(InterlockedDecrement(&s_lRunningClients) == 0)
        SetEvent(s_hShutDownComplete);

    return S_OK;
}

//
//  Client calls this to join the session
//

HRESULT CClient::Join(
    CClient*    pClient,
    ULONG       ulPublic,
    ULONG       ulPrivate
    )
{
    HRESULT hr;
    CLIENT client;

    m_csPlayers.Lock();

    if(!m_bHosting)
    {
        hr = S_FALSE;
        goto Cleanup;
    }

    //
    //  Is there enough space for this client?
    //

    if((ulPublic > m_ulPublicMax - m_ulPublicFilled) ||
       (ulPrivate > m_ulPrivateMax - m_ulPrivateFilled))
    {
        hr = S_FALSE;
        goto Cleanup;
    }

    client.m_pClient = pClient;
    client.m_ulPublic = ulPublic;
    client.m_ulPrivate = ulPrivate;

    m_Clients.SetAt(pClient, client);

    m_ulPublicFilled += ulPublic;
    m_ulPrivateFilled += ulPrivate;

Cleanup:

    m_csPlayers.Unlock();

    return hr;
}

//
//  Client calls this to leave the session
//

HRESULT CClient::Leave(
    CClient*    pClient
    )
{
    HRESULT         hr;
    CLIENTS::CPair* pPair;

    m_csPlayers.Lock();

    if(!m_bHosting)
    {
        hr = S_FALSE;
        goto Cleanup;
    }

    pPair = m_Clients.Lookup(pClient);
    if(pPair == NULL)
    {
        hr = S_FALSE;
        goto Cleanup;
    }

    m_ulPublicFilled -= pPair->m_value.m_ulPublic;
    m_ulPrivateFilled -= pPair->m_value.m_ulPrivate;

    m_Clients.RemoveKey(pClient);

Cleanup:

    m_csPlayers.Unlock();

    return hr;
}

//
//  Called when a game host is kicking us out of the session.
//

HRESULT CClient::Evict()
{
    m_State = DO_SEARCH;
    memset(&m_SessionID, 0, sizeof(XNKID));

    CancelTimedEvent();
    PostTimedEvent(0);

    return S_OK;
}

//
//  Timer queue callback
//

void CClient::Callback()
{
    switch(m_State)
    {
    case DO_SEARCH:
        DoSearch();
        break;

    case DO_IN_GAME:
        DoInGame();
        break;

    case DO_HOST:
        DoHostSession();
        break;

    case DO_UPDATE:
        DoUpdateSession();
        break;

    case DO_DELETE:
        DoDeleteSession();
        break;

    default:
        break;
    }
}

//
//  Queue up a timed event
//

HRESULT CClient::PostTimedEvent(
    DWORD   dwTime
    )
{
    HRESULT hr;

    if(!CreateTimerQueueTimer(&m_hTimer, s_hTimerQueue, TimerCallback, (PVOID)this, dwTime, 0, 0))
    {
        DWORD dwError = GetLastError();
        hr = HRESULT_FROM_WIN32(dwError);
        goto Cleanup;
    }

    hr = S_OK;

Cleanup:

    return hr;
}

//
//  Cancel the current event
//

HRESULT CClient::CancelTimedEvent()
{
    if(m_hTimer != NULL)
    {
        CancelTimerQueueTimer(s_hTimerQueue, m_hTimer);
        m_hTimer = NULL;
    }

    return S_OK;
}

//
//  Search for sessions
//

HRESULT CClient::DoSearch()
{
    HRESULT                         hr;
    XSearchInfo                     SearchInfo(m_Addr);
    PXMATCH_SEARCH                  pSearch;
    PXMATCH_SEARCHRESULT_INTERNAL   pResults = NULL;
    DWORD                           cbResults;
    ULONG                           ulMaxResults;
    ULONG                           ulNumResults;
    ULONG                           ulCurResult;
    PXMATCH_SEARCHRESULT_INTERNAL   pCurResult;
    PXMATCH_SEARCHRESULT_INTERNAL*  ppResultsSorted = NULL;
    XNKID*                          pSessionUpdateList;
    ULONG                           ulResultNum;
    ULONG                           ulCurrentWorstRank = 0;
    ULONG                           ulNumResultsSelected = 0;
    XNADDR                          ZeroAddr;

    memset(&ZeroAddr, 0, sizeof(XNADDR));

    SearchInfo.SetTitleID(m_ulTitleID);
    SearchInfo.SetNumUsers(m_ulNumUsers);
    SearchInfo.SetProcIndex(m_ulProcIndex);

    SearchInfo.GetSearch(pSearch);
    hr = s_piStorage->PerformGameSearch(m_ulNumUsers, 
                                        (LPBYTE)pSearch, 
                                        pSearch->dwMessageLength, 
                                        m_Addr.inaOnline.S_un.S_addr, 
                                        (LPBYTE*)&pResults, 
                                        &cbResults,
                                        &ulMaxResults);
    if(FAILED(hr))
        goto Cleanup;

    if(cbResults == 0)
    {
        hr = DoHostSession();
        goto Cleanup;
    }

    //
    //  Pick the best N sessions, emulating the restriction process done on the front doors
    //  
    
    //  compute number of results in the buffer
    pCurResult = pResults;
    ulNumResults = 0;
    while((DWORD)((LPBYTE)pCurResult - (LPBYTE)pResults) < cbResults)
    {
        ++ulNumResults;
        pCurResult = (PXMATCH_SEARCHRESULT_INTERNAL)((LPBYTE)pCurResult + pCurResult->ulResultLen);
    }

    //  allocate buffer for pointers
    ppResultsSorted = (PXMATCH_SEARCHRESULT_INTERNAL *)malloc(((ulNumResults >= ulMaxResults) ? ulMaxResults : ulNumResults) * sizeof(PXMATCH_SEARCHRESULT_INTERNAL));
    if(ppResultsSorted == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    pCurResult = pResults;
    for(ulResultNum = 0; ulResultNum < ulNumResults; ++ulResultNum)
    {
        //
        //  If this result has all zeroes for host address, then it is a dead xbox
        //  or an xbox with a dead cs.  Don't return this session to the caller.
        //

        if(memcmp(&ZeroAddr, &(pCurResult->SearchResult.HostAddress), sizeof(XNADDR)) == 0)
        {
            //
            //  Next result
            //

            pCurResult = (PXMATCH_SEARCHRESULT_INTERNAL)((LPBYTE)pCurResult + pCurResult->ulResultLen);
            continue;
        }

        //
        //  If we don't have ulMaxResults results yet, just tack this result on to the bottom.
        //

        if(ulNumResultsSelected < ulMaxResults)
        {
            ppResultsSorted[ulNumResultsSelected++] = pCurResult;

            if(pCurResult->ulRank > ulCurrentWorstRank)
                ulCurrentWorstRank = pCurResult->ulRank;
        }
        else
        {
            //
            //  If the following comparison is FALSE, then 
            //  this result does not end up in the final set.
            //

            if(pCurResult->ulRank < ulCurrentWorstRank)
            {
                //
                //  Need to do three things here:
                //  1.  Remove item with the current worst rank.
                //  2.  Move items below the one being removed up one slot, and put new result at bottom.
                //  3.  Compute the new current worst ranking.
                //
                //  We do all three of these in one loop.
                //

                ULONG ulRemoveIndex = 0xFFFFFFFF;
                ULONG ulNewWorstRank = pCurResult->ulRank; // eliminates one extra compare after the loop.
                ULONG ulCurResult;

                for(ulCurResult = 0; ulCurResult < ulMaxResults; ++ulCurResult)
                {
                    //
                    //  If we have already identified the one to remove, then move this one up.
                    //

                    if(ulRemoveIndex != 0xFFFFFFFF)
                        ppResultsSorted[ulCurResult - 1] = ppResultsSorted[ulCurResult];

                    //
                    //  Is this the one to remove?
                    //

                    if(ppResultsSorted[ulCurResult]->ulRank == ulCurrentWorstRank &&
                    ulRemoveIndex == 0xFFFFFFFF)
                    {
                        ulRemoveIndex = ulCurResult;
                    }

                    //
                    //  If this item's rank is worse than the one being added (it
                    //  might be tied with the one being removed) then update 
                    //  the new current worst appropriately.
                    //

                    else if(ppResultsSorted[ulCurResult]->ulRank > ulNewWorstRank)
                        ulNewWorstRank = ppResultsSorted[ulCurResult]->ulRank;
                }

                ulCurrentWorstRank = ulNewWorstRank;

                //
                //  Add the new item to the bottom of the list and add this
                //  item's length to the total.
                //

                ppResultsSorted[ulMaxResults - 1] = pCurResult;
            }
        }

        //
        //  Next result
        //

        pCurResult = (PXMATCH_SEARCHRESULT_INTERNAL)((LPBYTE)pCurResult + pCurResult->ulResultLen);
    }

    //
    //  We now have the restricted session list, update probablity for them
    //

    pSessionUpdateList = new XNKID[ulNumResultsSelected];
    if(pSessionUpdateList == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    for(ulCurResult = 0; ulCurResult < ulNumResultsSelected; ++ulCurResult)
    {
        pSessionUpdateList[ulCurResult] = ppResultsSorted[ulCurResult]->SearchResult.SessionID;
    }

    hr = s_piStorage->UpdateSessionProbs(m_ulTitleID, (LPBYTE)pSessionUpdateList, sizeof(XNKID) * ulNumResultsSelected);
    
    delete [] pSessionUpdateList;

    //
    //  Finally, go through our final list and try to join a session
    //

    for(ulCurResult = 0; ulCurResult < ulNumResultsSelected; ++ulCurResult)
    {
        CClient* pClient = (CClient*)(ppResultsSorted[ulCurResult]->SearchResult.HostAddress.ina.S_un.S_addr);
        if(!IsBadReadPtr(pClient, sizeof(CClient*)))
        {
            hr = pClient->Join(this, m_ulNumUsers, 0);
            if(hr == S_FALSE)
                continue;

            m_pHost = (CClient*)(ppResultsSorted[ulCurResult]->SearchResult.HostAddress.ina.S_un.S_addr);
            m_State = DO_IN_GAME;
            break;
        }
    }

    //
    //  Couldn't join a session, host a new one
    //

    if(m_State == DO_SEARCH)
        hr = DoHostSession();

Cleanup:

    if(ppResultsSorted != NULL)
        free(ppResultsSorted);

    if(pResults != NULL)
        CoTaskMemFree(pResults);

    PostTimedEvent(0);

    return hr;
}

//
//  Client in a game
//

HRESULT CClient::DoInGame()
{
    BYTE b;

    GenRandom(&b, 1);

    if(b < 25)
    {
        if(!IsBadReadPtr(m_pHost, sizeof(CClient*)))
            m_pHost->Leave(this);
        m_pHost = NULL;
        m_State = DO_SEARCH;
    }

    PostTimedEvent(0);

    return S_OK;
}

//
//  Add attributes to a session
//

HRESULT CClient::SetAttributes()
{
    HRESULT                     hr;
    TITLE_ATTRIBUTES::CPair*    pPair;
    PATTRIBUTE_LIST             pAttrList;
    POSITION                    pos;

    pAttrList = (s_titleAttributes.Lookup(m_ulTitleID))->m_value;

    pos = pAttrList->GetHeadPosition();
    while(pos != NULL)
    {
        ATTRIBUTE attr = pAttrList->GetAt(pos);
        
        switch(attr.m_attrType)
        {
        case INT_CONST:
            hr = s_piStorage->SetIntAttribute(
                                attr.m_ulAttributeID, 
                                m_ulTitleID, 
                                attr.m_value.u_qwConstValue, 
                                m_SessionID, 0, 0);
            if(FAILED(hr))
                goto Cleanup;
            break;

        case INT_ENUM:
        case STR_ENUM:
        case BLOB_ENUM:
            {
                ULONG ulProbability;
                ULONG ulProbabilitySum = 0;
                ULONG ulCurMember;

                GenRandom((LPBYTE)&ulProbability, sizeof(ULONG));
                ulProbability %= attr.m_value.u_enumValue.m_ulProbabilityTotal;

                for(ulCurMember = 0; ulCurMember < attr.m_value.u_enumValue.m_ulNumMembers; ++ulCurMember)
                {
                    if(ulProbability < (ulProbabilitySum + attr.m_value.u_enumValue.m_pMembers[ulCurMember].m_ulProbability))
                    {
                        switch(attr.m_attrType)
                        {
                        case INT_ENUM:
                            hr = s_piStorage->SetIntAttribute(
                                                attr.m_ulAttributeID, 
                                                m_ulTitleID, 
                                                attr.m_value.u_enumValue.m_pMembers[ulCurMember].m_value.u_qwValue, 
                                                m_SessionID, 0, 0);
                            break;

                        case STR_ENUM:
                            hr = s_piStorage->SetStringAttribute(
                                attr.m_ulAttributeID,
                                m_ulTitleID,
                                attr.m_value.u_enumValue.m_pMembers[ulCurMember].m_value.u_szValue,
                                m_SessionID, 0, 0);
                            break;

                        case BLOB_ENUM:
                            hr = s_piStorage->SetBlobAttribute(
                                attr.m_ulAttributeID,
                                m_ulTitleID,
                                attr.m_value.u_enumValue.m_pMembers[ulCurMember].m_value.u_blobValue.m_pValue,
                                attr.m_value.u_enumValue.m_pMembers[ulCurMember].m_value.u_blobValue.m_ulValueLen,
                                m_SessionID, 0, 0);
                            break;
                        }

                        if(FAILED(hr))
                            goto Cleanup;

                        break;
                    }

                    ulProbabilitySum += attr.m_value.u_enumValue.m_pMembers[ulCurMember].m_ulProbability;
                }

                break;
            }

        case INT_RANGE:
            {
                ULONGLONG qwRangeSize = attr.m_value.u_intRangeValue.m_qwMax - attr.m_value.u_intRangeValue.m_qwMin + 1;
                ULONGLONG qwProb;

                GenRandom((LPBYTE)&qwProb, sizeof(ULONGLONG));

                hr = s_piStorage->SetIntAttribute(
                    attr.m_ulAttributeID,
                    m_ulTitleID,
                    attr.m_value.u_intRangeValue.m_qwMin + (qwRangeSize % qwProb),
                    m_SessionID, 0, 0);
                if(FAILED(hr))
                    goto Cleanup;
                break;
            }

        case STR_CONST:
            hr = s_piStorage->SetStringAttribute(
                attr.m_ulAttributeID, 
                m_ulTitleID,
                attr.m_value.u_szConstValue,
                m_SessionID, 0, 0);
            if(FAILED(hr))
                goto Cleanup;
            break;

        case BLOB_CONST:
            hr = s_piStorage->SetBlobAttribute(
                attr.m_ulAttributeID,
                m_ulTitleID,
                attr.m_value.u_blobConstValue.m_pConstValue,
                attr.m_value.u_blobConstValue.m_ulValueLen,
                m_SessionID, 0, 0);
            if(FAILED(hr))
                goto Cleanup;
            break;

        default:
            ATLASSERT(FALSE);
            break;
        }

        pAttrList->GetNext(pos);
    }

Cleanup:

    return hr;
}

//
//  Host a session
//

HRESULT CClient::DoHostSession()
{
    HRESULT         hr;
    POSITION        pos;
    PATTRIBUTE_LIST pAttrList;

    //
    //  Get the session ID and generate a new key
    //

    hr = s_piStorage->GetSessionID(0, &m_SessionID);
    if(FAILED(hr))
        goto Cleanup;

    GenRandom((LPBYTE)&m_SessionKey, sizeof(XNKEY));

    //
    //  Set initial slot counts
    //

    ATLASSERT(m_ulNumUsers <= m_ulPublicMax + m_ulPrivateMax);

    if(m_ulPublicMax > m_ulNumUsers)
    {
        m_ulPublicFilled = m_ulNumUsers;
        m_ulPrivateFilled = 0;
    }
    else
    {
        m_ulPublicFilled = m_ulPublicMax;
        m_ulPrivateFilled = m_ulNumUsers - m_ulPublicMax;
    }

    //
    //  First insert the session
    //

    hr = s_piStorage->InsertSession(
        m_SessionID, 
        m_ulTitleID,
        m_Addr,
        m_SessionKey,
        m_ulPublicMax - m_ulPublicFilled,
        m_ulPrivateMax - m_ulPrivateFilled,
        m_ulPublicFilled,
        m_ulPrivateFilled);
    if(FAILED(hr))
        goto Cleanup;

    //
    //  Now insert the attributes
    //
    
    hr = SetAttributes();
    if(FAILED(hr))
        goto Cleanup;

    //
    //  Schedule next event
    //

    m_State = DO_UPDATE;
    PostTimedEvent(0);

Cleanup:

    if(FAILED(hr))
    {
        s_piStorage->DeleteSession(m_SessionID, m_ulTitleID);
        memset(&m_SessionID, 0, sizeof(XNKID));
        memset(&m_SessionKey, 0, sizeof(XNKEY));
    }
    else
        m_bHosting = true;

    return hr;
}

//
//  Update the session
//

HRESULT CClient::DoUpdateSession()
{
    HRESULT         hr;
    XSessionInfo    session(m_Addr);
    BYTE            b;

    //
    //  Update the session
    //

    hr = s_piStorage->UpdateSession(
                        m_SessionID,
                        m_ulTitleID,
                        m_Addr,
                        m_ulPublicMax - m_ulPublicFilled,
                        m_ulPrivateMax - m_ulPrivateFilled,
                        m_ulPublicFilled,
                        m_ulPrivateFilled);
    if(FAILED(hr))
        goto Cleanup;

    //
    //  Set the attributes
    //

    hr = SetAttributes();
    if(FAILED(hr))
        goto Cleanup;

    //
    //  Schedule the next event
    //

    GenRandom(&b, 1);
    if(b < 25)
        m_State = DO_DELETE;
    PostTimedEvent(0);

Cleanup:

    return hr;
}

//
//  Delete the session
//

HRESULT CClient::DoDeleteSession()
{
    HRESULT     hr;
    POSITION    pos;

    m_csPlayers.Lock();

    m_bHosting = false;
    hr = s_piStorage->DeleteSession(m_SessionID, m_ulTitleID);
    
    //
    //  Evict all users currently in the game
    //

    for(pos = m_Clients.GetStartPosition(); pos != NULL; m_Clients.GetNext(pos))
    {
        CLIENT client = m_Clients.GetAt(pos)->m_value;

        if(!IsBadReadPtr(client.m_pClient, sizeof(CClient*)))
            client.m_pClient->Evict();
    }

    m_Clients.RemoveAll();

    m_State = DO_SEARCH;
    PostTimedEvent(0);
    hr = S_OK;

    m_csPlayers.Unlock();

    return hr;
}

//
//  Load all clients from the XML configuration
//

HRESULT CClient::Load(
    LPCSTR  szClientConfigFile,
    LPCSTR  szStorageConfigFile
    )
{
    HRESULT                     hr;
    CLSID                       clsidDOMDocument;
    CComPtr<IXGlobalService>    piService;
    CComPtr<IXMLDOMDocument>    piXMLConfig;
    CComPtr<IXMLDOMElement>     piRootElement;
    CComPtr<IXMLDOMNodeList>    piRootChildren;
    CComVariant                 vConfig(szClientConfigFile);
    LONG                        lNumChildren;
    LONG                        lCurrentChild;
    VARIANT_BOOL                bSuccess;

    //
    //  Create the DOM object
    //

    hr = CLSIDFromProgID(L"Msxml2.DOMDocument.3.0", &clsidDOMDocument);
    if(FAILED(hr))
        goto Cleanup;

    hr = piXMLConfig.CoCreateInstance(clsidDOMDocument);
    if(FAILED(hr))
        goto Cleanup;

    //
    //  Create and initialize the storage object
    //

    hr = CoCreateInstance(CLSID_XMatchStorage, NULL, CLSCTX_SERVER, IID_IXMatchStorage, (void**)&s_piStorage);
    if(FAILED(hr))
        goto Cleanup;

    //
    //  Load the client config file
    //

    hr = piXMLConfig->load(vConfig, &bSuccess);
    if(FAILED(hr))
        goto Cleanup;

    if(!bSuccess)
    {
        // TODO
    }

    //
    //  Initialize the storage object
    //

    hr = s_piStorage->QueryInterface(&piService);
    if(FAILED(hr))
        goto Cleanup;

    hr = piService->Initialize(CComBSTR(szStorageConfigFile), NULL);
    if(FAILED(hr))
        goto Cleanup;

    //
    //  Load clients for each title in the document
    //

    hr = piXMLConfig->get_documentElement(&piRootElement);
    if(FAILED(hr))
        goto Cleanup;

    hr = piRootElement->get_childNodes(&piRootChildren);
    if(FAILED(hr))
        goto Cleanup;

    hr = piRootChildren->get_length(&lNumChildren);
    if(FAILED(hr))
        goto Cleanup;

    for(lCurrentChild = 0; lCurrentChild < lNumChildren; ++lCurrentChild)
    {
        CComPtr<IXMLDOMNode>    piChild;
        DOMNodeType             nodeType;
        CComBSTR                cbstrNodeName;

        hr = piRootChildren->get_item(lCurrentChild, &piChild);
        if(FAILED(hr))
            goto Cleanup;

        hr = piChild->get_nodeType(&nodeType);
        if(FAILED(hr))
            goto Cleanup;

        hr = piChild->get_nodeName(&cbstrNodeName);
        if(FAILED(hr))
            goto Cleanup;

        if(nodeType == NODE_ELEMENT &&
           lstrcmpiW(cbstrNodeName, L"title") == 0)
        {
            CComPtr<IXMLDOMElement> piChildElement;

            hr = piChild->QueryInterface(&piChildElement);
            if(FAILED(hr))
                goto Cleanup;

            hr = LoadTitle(piChildElement);
            if(FAILED(hr))
                goto Cleanup;
        }
    }

    hr = S_OK;

Cleanup:

    return hr;
}

//
//  Load all clients for a specific title id
//

HRESULT CClient::LoadTitle(
    IXMLDOMElement* piTitle
    )
{
    HRESULT                     hr;
    ULONG                       ulTitleID;
    CComVariant                 vAttr;
    CComPtr<IXMLDOMNode>        piAttributesNode;
    CComPtr<IXMLDOMElement>     piAttributes;
    CComPtr<IXMLDOMNodeList>    piClientsList;
    PATTRIBUTE_LIST             pattrList;
    LONG                        lNumClientTypes;
    LONG                        lCurClientType;

    //
    //  Extract the title id
    //

    hr = GetUlongAttribute(piTitle, g_cbstrTitleID, ulTitleID);
    if(FAILED(hr))
        goto Cleanup;

    //
    //  Now read in all the attributes for this title id
    //

    hr = piTitle->selectSingleNode(CComBSTR(L"attributes"), &piAttributesNode);
    if(FAILED(hr))
        goto Cleanup;

    hr = piAttributesNode->QueryInterface(&piAttributes);
    if(FAILED(hr))
        goto Cleanup;

    pattrList = new ATTRIBUTE_LIST;
    if(pattrList == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    hr = LoadAttributes(piAttributes, *pattrList);
    if(FAILED(hr))
        goto Cleanup;

    s_titleAttributes.SetAt(ulTitleID, pattrList);

    //
    //  Next determine how many clients to create with these settings
    //

    hr = piTitle->selectNodes(CComBSTR(L"clients"), &piClientsList);
    if(FAILED(hr))
        goto Cleanup;

    hr = piClientsList->get_length(&lNumClientTypes);
    if(FAILED(hr))
        goto Cleanup;

    for(lCurClientType = 0; lCurClientType < lNumClientTypes; ++lCurClientType)
    {
        CComPtr<IXMLDOMElement> piClientsElement;
        ULONG                   ulNumClients;
        ULONG                   ulProcedureIndex;
        ULONG                   ulMaxLocalUsers;
        ULONG                   ulPublicMax;
        ULONG                   ulPrivateMax;
        ULONG                   ulCurClient;

        hr = GetListElement(piClientsList, lCurClientType, &piClientsElement);
        if(FAILED(hr))
            goto Cleanup;

        hr = GetUlongAttribute(piClientsElement, g_cbstrCount, ulNumClients);
        if(FAILED(hr))
            goto Cleanup;

        hr = GetUlongAttribute(piClientsElement, g_cbstrProcIndex, ulProcedureIndex);
        if(FAILED(hr))
            goto Cleanup;

        hr = GetUlongAttribute(piClientsElement, g_cbstrMaxLocalUsers, ulMaxLocalUsers);
        if(FAILED(hr))
            goto Cleanup;

        hr = GetUlongAttribute(piClientsElement, g_cbstrPublic, ulPublicMax);
        if(FAILED(hr))
            goto Cleanup;

        hr = GetUlongAttribute(piClientsElement, g_cbstrPrivate, ulPrivateMax);
        if(FAILED(hr))
            goto Cleanup;

        for(ulCurClient = 0; ulCurClient < ulNumClients; ++ulCurClient)
        {
            CClient* pClient = new CClient(ulTitleID, ulProcedureIndex, ulMaxLocalUsers, ulPublicMax, ulPrivateMax);
            if(pClient == NULL)
            {
                hr = E_OUTOFMEMORY;
                goto Cleanup;
            }

            s_ClientList.AddTail(pClient);
        }            
    }


Cleanup:

    return hr;
}

//
//  Load all attributes for a single title
//

HRESULT CClient::LoadAttributes(
    IXMLDOMElement* piAttributesNode,
    ATTRIBUTE_LIST& attrList
    )
{
    HRESULT                     hr;
    CComPtr<IXMLDOMNodeList>    piAttributeList;
    LONG                        lNumAttributes;
    LONG                        lCurAttribute;

    hr = piAttributesNode->selectNodes(CComBSTR(L"attribute"), &piAttributeList);
    if(FAILED(hr))
        goto Cleanup;

    hr = piAttributeList->get_length(&lNumAttributes);
    if(FAILED(hr))
        goto Cleanup;

    for(lCurAttribute = 0; lCurAttribute < lNumAttributes; ++lCurAttribute)
    {
        CComPtr<IXMLDOMElement> piCurElement;
        ATTRIBUTE               attr;

        hr = GetListElement(piAttributeList, lCurAttribute, &piCurElement);
        if(FAILED(hr))
            goto Cleanup;

        hr = LoadAttribute(piCurElement, attr);
        if(FAILED(hr))
            goto Cleanup;

        attrList.AddTail(attr);
    }

Cleanup:

    return hr;
}

//
//  Load a single attribute
//

HRESULT CClient::LoadAttribute(
    IXMLDOMElement* piAttribute,
    ATTRIBUTE&      attr
    )
{
    HRESULT         hr;
    CComVariant     vId;
    CComVariant     vType;

    hr = GetUlongAttribute(
            piAttribute, 
            g_cbstrAttributeID, 
            attr.m_ulAttributeID);
    if(FAILED(hr))
        goto Cleanup;

    hr = GetUlongAttribute(
            piAttribute, 
            g_cbstrType, 
            (ULONG&)attr.m_attrType);
    if(FAILED(hr))
        goto Cleanup;

    switch(attr.m_attrType)
    {
    case INT_CONST:
        hr = GetIntAttribute(
                piAttribute, 
                g_cbstrValue, 
                attr.m_value.u_qwConstValue);
        if(FAILED(hr))
            goto Cleanup;
        break;

    case INT_ENUM:
    case STR_ENUM:
    case BLOB_ENUM:
        hr = LoadEnumMembers(piAttribute, attr);
        if(FAILED(hr))
            goto Cleanup;
        break;

    case INT_RANGE:
        hr = GetIntAttribute(
                piAttribute,
                g_cbstrMin,
                attr.m_value.u_intRangeValue.m_qwMin);
        if(FAILED(hr))
            goto Cleanup;

        hr = GetIntAttribute(
                piAttribute,
                g_cbstrMax,
                attr.m_value.u_intRangeValue.m_qwMax);
        if(FAILED(hr))
            goto Cleanup;

        break;

    case STR_CONST:
        hr = GetStringAttribute(
                piAttribute, 
                g_cbstrValue, 
                attr.m_value.u_szConstValue);
        if(FAILED(hr))
            goto Cleanup;
        break;

        break;

    case BLOB_CONST:
        hr = GetBlobAttribute(
                piAttribute, 
                g_cbstrValue, 
                attr.m_value.u_blobConstValue.m_pConstValue, 
                attr.m_value.u_blobConstValue.m_ulValueLen);
        break;

    default:
        break;
    }

    hr = S_OK;

Cleanup:

    return hr;
}

HRESULT CClient::LoadEnumMembers(
    IXMLDOMElement* piElement,
    ATTRIBUTE&      attr
    )
{
    HRESULT                     hr;
    CComPtr<IXMLDOMNodeList>    piMemberList;
    LONG                        lNumMembers;
    LONG                        lCurMember;

    if(attr.m_attrType != INT_ENUM && 
       attr.m_attrType != STR_ENUM && 
       attr.m_attrType != BLOB_ENUM)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    hr = piElement->selectNodes(CComBSTR(L"member"), &piMemberList);
    if(FAILED(hr))
        goto Cleanup;

    hr = piMemberList->get_length(&lNumMembers);
    if(FAILED(hr))
        goto Cleanup;

    attr.m_value.u_enumValue.m_ulNumMembers = lNumMembers;
    attr.m_value.u_enumValue.m_ulProbabilityTotal = 0;

    attr.m_value.u_enumValue.m_pMembers = (PATTRIBUTE_ENUM)malloc(sizeof(ATTRIBUTE_ENUM) * lNumMembers);
    if(attr.m_value.u_enumValue.m_pMembers == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    for(lCurMember = 0; lCurMember < lNumMembers; ++lCurMember)
    {
        CComPtr<IXMLDOMElement> piMember;

        hr = GetListElement(piMemberList, lCurMember, &piMember);
        if(FAILED(hr))
            goto Cleanup;
    
        hr = GetUlongAttribute(
            piMember, 
            g_cbstrProb, 
            attr.m_value.u_enumValue.m_pMembers[lCurMember].m_ulProbability);
        if(FAILED(hr))
            goto Cleanup;

        attr.m_value.u_enumValue.m_ulProbabilityTotal += attr.m_value.u_enumValue.m_pMembers[lCurMember].m_ulProbability;

        switch(attr.m_attrType)
        {
        case INT_ENUM:
            hr = GetIntAttribute(
                piMember, 
                g_cbstrValue,
                attr.m_value.u_enumValue.m_pMembers[lCurMember].m_value.u_qwValue);
            if(FAILED(hr))
                goto Cleanup;
            break;

        case STR_ENUM:
            hr = GetStringAttribute(
                piMember,
                g_cbstrValue,
                attr.m_value.u_enumValue.m_pMembers[lCurMember].m_value.u_szValue);
            if(FAILED(hr))
                goto Cleanup;
            break;

        case BLOB_ENUM:
            hr = GetBlobAttribute(
                piMember,
                g_cbstrValue,
                attr.m_value.u_enumValue.m_pMembers[lCurMember].m_value.u_blobValue.m_pValue,
                attr.m_value.u_enumValue.m_pMembers[lCurMember].m_value.u_blobValue.m_ulValueLen);
            if(FAILED(hr))
                goto Cleanup;
            break;
        }
    }

Cleanup:

    return hr;
}

//
//  Start all clients.  This function blocks until all clients are shutdown.
//

HRESULT CClient::Run()
{
    HRESULT                     hr;
    POSITION                    pos;
    CComPtr<IXGlobalService>    piService;

    //
    //  Create timer queue
    //

    s_hTimerQueue = CreateTimerQueue();
    if(s_hTimerQueue == NULL)
    {
        DWORD dwError = GetLastError();
        hr = HRESULT_FROM_WIN32(dwError);
        goto Cleanup;
    }

    //
    //  Create shutting down event
    //

    s_hShutDownComplete = CreateEvent(NULL, TRUE, FALSE, NULL);
    if(s_hShutDownComplete == NULL)
    {
        DWORD dwError = GetLastError();
        hr = HRESULT_FROM_WIN32(dwError);
        goto Cleanup;
    }

    //
    //  Start all clients
    //

    for(pos = s_ClientList.GetHeadPosition(); pos != NULL;)
    {
        s_ClientList.GetNext(pos)->Start();
    }

    //
    //  Wait for execution to end
    //

    WaitForSingleObject(s_hShutDownComplete, INFINITE);

    hr = S_OK;

Cleanup:

    return hr;
}

//
//  Stop all clients.
//

HRESULT CClient::StopAll()
{
    POSITION pos;

    //
    //  Tell each client to stop
    //

    for(pos = s_ClientList.GetHeadPosition(); pos != NULL;)
    {
        CClient* pClient = s_ClientList.GetNext(pos);
        pClient->Stop();
    }

    return S_OK;
}

HRESULT CClient::Unload()
{
    HRESULT                     hr;
    POSITION                    pos;
    CComPtr<IXGlobalService>    piService;

    //
    //  Clean up clients
    //

    pos = s_ClientList.GetHeadPosition();
    while(pos != NULL)
    {
        CClient* pClient = s_ClientList.RemoveHead();
        delete pClient;
        pos = s_ClientList.GetHeadPosition();
    }

    //
    //  Clean up data in statics (title attributes and search parameters)
    //

    pos = s_titleAttributes.GetStartPosition();
    while(pos != NULL)
    {
        POSITION attrPos;
        PATTRIBUTE_LIST attrList = s_titleAttributes.GetValueAt(pos);

        attrList->RemoveAll();
        delete attrList;

        s_titleAttributes.RemoveAtPos(pos);

        pos = s_titleAttributes.GetStartPosition();
    }

    pos = s_searchParameters.GetStartPosition();
    while(pos != NULL)
    {
        POSITION searchPos;
        PATTRIBUTE_LIST paramList = s_searchParameters.GetValueAt(pos);

        paramList->RemoveAll();
        delete paramList;

        s_searchParameters.RemoveAtPos(pos);

        pos = s_searchParameters.GetStartPosition();
    }

    //
    //  Shutdown storage object
    //

    hr = s_piStorage->QueryInterface(&piService);
    if(FAILED(hr))
        goto Cleanup;

    hr = piService->Shutdown();
    if(FAILED(hr))
        goto Cleanup;

    piService = NULL;
    s_piStorage = NULL;

    hr = S_OK;

Cleanup:

    return hr;
}

// EOF
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\MatchStress\MatchStress.cpp ===
#include "precomp.h"
#include "xservice_i.c"
#include "xstorage_i.c"

HCRYPTPROV g_hProv = NULL;

void Usage()
{
    printf("matchstress <clientconfig> <storageconfig>\r\n");
}

BOOL WINAPI HandlerRoutine(
    DWORD dwCtrlType   //  control signal type
)
{
    HRESULT hr;

    printf("Stopping...\r\n");

    hr = CClient::StopAll(); // this should cause all clients to stop and CClient::Run to return

    return TRUE;
}

BOOL GenRandom(
    LPBYTE  p,
    ULONG   cb
    )
{
    return CryptGenRandom(g_hProv, cb, p);
}

void _cdecl main(int argc, char** argv)
{
    HRESULT                     hr;

    if(argc != 3)
    {
        Usage();
        goto Cleanup;
    }

    //
    //  Initialize crypto context for random number generation
    //

    if(!CryptAcquireContext(&g_hProv, NULL, NULL, PROV_RSA_FULL, 0))
    {
        DWORD dwError = GetLastError();
        hr = HRESULT_FROM_WIN32(dwError);
        printf("Failed to acquire cryptographic context for random number generation. Error = %08X.\r\n", hr);
    }

    //
    //  Set the console control handler routine
    //

    if(!SetConsoleCtrlHandler(HandlerRoutine, TRUE))
    {
        DWORD dwError = GetLastError();
        hr = HRESULT_FROM_WIN32(dwError);
        printf("Failed to set control handler. Error = %08X.\r\n", hr);
    }

    //
    //  Initialize COM
    //

    hr = CoInitializeEx(NULL, COINIT_MULTITHREADED);
    if(FAILED(hr))
    {
        printf("Failed to initialize COM.  hr = 0x%08X.\r\n", hr);
        goto Cleanup;
    }

    //
    //  Initialize logging
    //

    
    //
    //  Load from config files
    //

    printf("Loading configuration...\r\n");

    hr = CClient::Load(argv[1], argv[2]);
    if(FAILED(hr))
        goto Cleanup;

    printf("Running stress...\r\n");

    hr = CClient::Run();
    if(FAILED(hr))
        goto Cleanup;

    printf("Stopped.  Now exiting...\r\n");

    hr = CClient::Unload();
    if(FAILED(hr))
        goto Cleanup;

Cleanup:

    if(g_hProv != NULL)

    CoUninitialize();

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\MatchStress\Client.h ===
#pragma once

class CClient
{
    friend void TimerCallback(PVOID, BOOLEAN);

    typedef enum tagCLIENT_STATE
    {
        DO_SEARCH = 0,
        DO_IN_GAME,
        DO_HOST,
        DO_UPDATE,
        DO_DELETE
    }
    CLIENT_STATE;

    typedef enum tagATTRIBUTE_TYPE
    {
        INT_CONST   = 0,
        INT_ENUM    = 1,
        INT_RANGE   = 2,
        STR_CONST   = 100,
        STR_ENUM    = 101,
        BLOB_CONST  = 200,
        BLOB_ENUM   = 201
    }
    ATTRIBUTE_TYPE;

    //  Structure that describes an element of an int, string or blob enum
    typedef struct tagATTRIBUTE_ENUM
    {
        union
        {
            ULONGLONG   u_qwValue;
            LPSTR       u_szValue;

            struct
            {
                LPBYTE      m_pValue;
                ULONG       m_ulValueLen;
            } u_blobValue;
        } m_value;

        ULONG m_ulProbability;
    }
    ATTRIBUTE_ENUM, *PATTRIBUTE_ENUM;

    //  Structure that describes a single attribute or search parameter
    struct ATTRIBUTE
    {
        ULONG           m_ulAttributeID;
        ATTRIBUTE_TYPE  m_attrType;

        union
        {
            ULONGLONG u_qwConstValue;

            struct
            {
                ULONGLONG   m_qwMin;
                ULONGLONG   m_qwMax;
            } u_intRangeValue;

            struct
            {
                ULONG           m_ulNumMembers;
                ULONG           m_ulProbabilityTotal;
                PATTRIBUTE_ENUM m_pMembers;
            } u_enumValue;

            LPSTR u_szConstValue;

            struct
            {
                LPBYTE m_pConstValue;
                ULONG m_ulValueLen;
            } u_blobConstValue;

        } m_value;
    };
    typedef ATTRIBUTE* PATTRIBUTE;

    //  Describes a single client xbox attached to the session
    struct CLIENT
    {
        CClient*    m_pClient;
        ULONG       m_ulPublic;
        ULONG       m_ulPrivate;
    };
    typedef CLIENT* PCLIENT;

    //  List used to hold attributes or search parameters
    typedef CAtlList<ATTRIBUTE> ATTRIBUTE_LIST, *PATTRIBUTE_LIST;

    //  List of session attributes keyed on title id
    typedef CAtlMap<ULONG, PATTRIBUTE_LIST> TITLE_ATTRIBUTES, *PTITLE_ATTRIBUTES;

    //  List of search parameters keyed on title id + procedure index
    typedef CAtlMap<ULARGE_INTEGER, PATTRIBUTE_LIST> SEARCH_PARAMETERS, *PSEARCH_PARAMETERS;

    //  List used to hold clients attached to the session
    typedef CAtlMap<CClient*, CLIENT> CLIENTS, *PCLIENTS;

public:
    CClient(ULONG, ULONG, ULONG, ULONG, ULONG);
    ~CClient(void);

    HRESULT Start();
    HRESULT Stop();

    HRESULT Join(CClient* pClient, ULONG ulPublic, ULONG ulPrivate);    // join a session
    HRESULT Leave(CClient* pClient);                                    // leave a session
    HRESULT Evict();                                                    // kick a client out of a session

    static HRESULT Load(LPCSTR szClientConfigFile, LPCSTR szStorageConfigFile);
    static HRESULT Run();
    static HRESULT StopAll();
    static HRESULT Unload();

protected:

    void Callback(void);
    HRESULT PostTimedEvent(DWORD dwTime);
    HRESULT CancelTimedEvent(void);

    HRESULT SetAttributes(void);

    HRESULT DoSearch();
    HRESULT DoInGame();
    HRESULT DoHostSession();
    HRESULT DoUpdateSession();
    HRESULT DoDeleteSession();

    static HRESULT LoadTitle(IXMLDOMElement* piTitleNode);
    static HRESULT LoadAttributes(IXMLDOMElement* piAttributesNode, ATTRIBUTE_LIST& attributes);
    static HRESULT LoadAttribute(IXMLDOMElement* piAttributeNode, ATTRIBUTE& attribute);
    static HRESULT LoadEnumMembers(IXMLDOMElement* piElement, ATTRIBUTE& attr);
    static HRESULT LoadIntRange(IXMLDOMElement* piElement, ATTRIBUTE& attr);
    static HRESULT LoadClients(ULONG ulTitleID, ATTRIBUTE_LIST& pAttributes, IXMLDOMElement* piClientsNode);

    bool            m_bHosting;
    HANDLE          m_hTimer;
    CLIENT_STATE    m_State;
    ULONG           m_ulTitleID;
    ULONG           m_ulProcIndex;
    ULONG           m_ulMaxSearchResults;
    XNADDR          m_Addr;
    CClient*        m_pHost; // only used when NOT hosting
    XNKID           m_SessionID;
    XNKEY           m_SessionKey;
    ULONG           m_ulNumUsers;
    ULONG           m_ulPublicMax;
    ULONG           m_ulPrivateMax;
    ULONG           m_ulPublicFilled;
    ULONG           m_ulPrivateFilled;
    CLIENTS         m_Clients;
    
    CComCriticalSection m_csPlayers;

    static CAtlList<CClient*>       s_ClientList;
    static HANDLE                   s_hTimerQueue;
    static HANDLE                   s_hShutDownComplete;
    static LONG                     s_lRunningClients;
    static CComPtr<IXMatchStorage>  s_piStorage;
    static TITLE_ATTRIBUTES         s_titleAttributes;
    static SEARCH_PARAMETERS        s_searchParameters;
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\MatchStress\precomp.h ===
#ifndef __PRECOMP_H
#define __PRECOMP_H
#pragma once

#include <atlbase.h>
#include <atlcoll.h>
#include <stdio.h>
#include <time.h>
#include <wincrypt.h>

#include <wsockntp.h>
#include <xonlinep.h>
#include <xservice.h>
#include <xstorage.h>

#include "sessioninfo.h"
#include "searchinfo.h"
#include "client.h"

//
//  String helper macros
//

#define REQUIRED_BUFFER(sz) WideCharToMultiByte(CP_UTF8,0,sz,-1,NULL,0,NULL,NULL)
#define W2UTF8(src,dst,n) WideCharToMultiByte(CP_UTF8,0,src,-1,dst,n,NULL,NULL)

//
//  Helper functions
//

extern BOOL GenRandom(LPBYTE, ULONG);

#endif // __PRECOMP_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\ManifestEdit\Manifest.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.IO;
using System.Xml;

namespace ManifestEdit
{
    /// <summary>
    /// Class representing a manifest
    /// </summary>
    public partial class Manifest
    {
        public const string WebstoreManifestNamespace = "urn:WebstoreManifestSchema.xsd";

        string _manifestFilePath;        
        XmlNamespaceManager _nsmgr;
        XmlDocument _manifestXmlDoc;
        Dictionary<string, XmlNode> _sqlObjectTypeNodes = new Dictionary<string,XmlNode>();

        /// <summary>
        /// Creates instance and loads manifest xml into memory
        /// </summary>
        /// <param name="manifestFilePath"></param>
        public Manifest(string manifestFilePath)
        {
            _manifestFilePath = manifestFilePath;
            Load(manifestFilePath);
        }

        private void Load(string manifestFilePath)
        {
            // Load manifest xml into memory
            _manifestXmlDoc = new XmlDocument();
            _manifestXmlDoc.Load(manifestFilePath);

            // Create the Webstore namespace for XPath reference
            _nsmgr = new XmlNamespaceManager(_manifestXmlDoc.NameTable);
            _nsmgr.AddNamespace("ws", WebstoreManifestNamespace);
        }

        /// <summary>
        /// Writes result xml into file
        /// </summary>
        /// <param name="outFilePath"></param>
        public void Save(string outFilePath)
        {
            string outDir = Path.GetDirectoryName(outFilePath);

            if (!String.IsNullOrEmpty(outDir))
            {
                Directory.CreateDirectory(outDir);
            }

            _manifestXmlDoc.Save(outFilePath);
        }

        /// <summary>
        /// Writes result xml into file
        /// </summary>
        /// <param name="outFilePath"></param>
        public void Save()
        {            
            _manifestXmlDoc.Save(_manifestFilePath);
        }

        /// <summary>
        /// Replaces the manifest version with the one passed in
        /// </summary>
        /// <param name="version"></param>
        public void SetVersion(string version)
        {
            XmlNode versionNode = _manifestXmlDoc.SelectSingleNode("//ws:Webstore/ws:Manifest/ws:Version", _nsmgr);
            versionNode.InnerText = version;
        }

        /// <summary>
        /// Add a script to the scripts section for the source file
        /// </summary>
        /// <param name="sourceFile"></param>
        /// <param name="installOrder"></param>
        /// <param name="setupStep"></param>
        /// <param name="upgradeOnly"></param>
        public void AddScript(string sourceFile, string installOrder, string setupStep, bool upgradeOnly)
        {
            // Skip this if the source file already exists in the manifest
            if (SourceFileExistsInManifest(sourceFile))
            {
                return;
            }

            // Create the <Script> section and add it to the manifest
            XmlNode scriptNode = CreateManifestElement("Script");
            scriptNode.Attributes.Append(_manifestXmlDoc.CreateAttribute("Name"));

            // Build the script name by the source file name, use the directory.sourceFileName convention
            string sourceDirectory = Path.GetDirectoryName(sourceFile);
            sourceDirectory = sourceDirectory.Substring(sourceDirectory.LastIndexOf(Path.DirectorySeparatorChar) + 1);
            scriptNode.Attributes["Name"].Value = sourceDirectory + '.' + Path.GetFileNameWithoutExtension(sourceFile);

            // Add the child elements
            scriptNode.AppendChild(CreateManifestElement("SourceFile", sourceFile));
            scriptNode.AppendChild(CreateManifestElement("InstallOrder", installOrder));
            scriptNode.AppendChild(CreateManifestElement("SetupStep", setupStep));
            scriptNode.AppendChild(CreateManifestElement("UpgradeOnly", upgradeOnly));

            // Add node to <Scripts> section in manifest
            ScriptsNode.AppendChild(scriptNode);
        }

        public void ClearScripts()
        {
            ScriptsNode.RemoveAll();
        }

        /// <summary>
        /// Finds the SqlObject node by name and removes it from manifest
        /// </summary>
        /// <param name="sqlObjectType"></param>
        /// <param name="sqlObject"></param>
        public void RemoveSqlObject(string sqlObjectType, string sqlObject)
        {
            if (sqlObject != null)
            {
                sqlObject = sqlObject.Trim();

                if (!String.IsNullOrEmpty(sqlObject))
                {
                    XmlNode sqlObjectNode = GetSqlObjectNode(sqlObjectType, sqlObject);
                    if (sqlObjectNode != null)
                    {
                        XmlNode sqlObjectTypeNode = GetSqlObjectTypeNode(sqlObjectType);
                        if (sqlObjectTypeNode != null)
                        {
                            sqlObjectTypeNode.RemoveChild(sqlObjectNode);
                        }
                    }
                    else
                    {
                        throw new SqlObjectNotFoundException(String.Format("SQL Object {0} not found in manifest", sqlObject));
                    }
                }
            }
        }

        /// <summary>
        /// Returns all child nodes of SqlObjects
        /// </summary>
        /// <returns></returns>
        public string[] GetAllSqlObjects()
        {
            List<string> sqlObjects = new List<string>();

            XmlNode sqlObjectNode = _manifestXmlDoc.SelectSingleNode("//ws:Webstore/ws:Manifest/ws:SqlObjects", _nsmgr);

            foreach (XmlNode node in sqlObjectNode.ChildNodes)
            {
                if (!node.Name.Equals("MinSQLVersion"))
                {
                    sqlObjects.Add(node.Name);
                }
            }

            return sqlObjects.ToArray<string>();
        }

        /// <summary>
        /// Get a particular node under SqlObjects
        /// </summary>
        /// <param name="sqlObjectType"></param>
        /// <returns></returns>
        private XmlNode GetSqlObjectTypeNode(string sqlObjectType)
        {
            if (!_sqlObjectTypeNodes.ContainsKey(sqlObjectType))
            {
                string sqlObjectTypeXPath = "//ws:Webstore/ws:Manifest/ws:SqlObjects/ws:" + sqlObjectType;

                _sqlObjectTypeNodes[sqlObjectType] = _manifestXmlDoc.SelectSingleNode(sqlObjectTypeXPath, _nsmgr);

                if (_sqlObjectTypeNodes[sqlObjectType] == null)
                {
                    throw new Exception(String.Format("Could not find SQL Object node by XPath {0}.", sqlObjectTypeXPath));
                }
            }

            return _sqlObjectTypeNodes[sqlObjectType];
        }

        /// <summary>
        /// Returns the Sql Object node based on the type (Table) and the object name (t_achievements)
        /// </summary>
        /// <param name="sqlObjectType"></param>
        /// <param name="sqlObject"></param>
        /// <returns></returns>
        private XmlNode GetSqlObjectNode(string sqlObjectType, string sqlObject)
        {
            XmlNode sqlObjectTypeNode = GetSqlObjectTypeNode(sqlObjectType);

            if (sqlObjectTypeNode != null)
            {
                string sqlObjectTypeName = sqlObjectTypeNode.FirstChild.Name;
                string xpath = String.Format("ws:" + sqlObjectTypeName + "[@Name='{0}']", sqlObject);

                return sqlObjectTypeNode.SelectSingleNode(xpath, _nsmgr);
            }
            else
            {
                return null;
            }
        }

        private XmlNode ScriptsNode
        {
            get
            {                
                return GetSqlObjectTypeNode("Scripts");
            }
        }

        private bool SourceFileExistsInManifest(string sourceFile)
        {
            foreach (XmlNode scriptNode in ScriptsNode.ChildNodes)
            {
                XmlNode sourceFileNode = scriptNode["SourceFile"];
                if (sourceFileNode != null && sourceFileNode.InnerText == sourceFile)
                {
                    return true;
                }
            }

            return false;
        }

        private XmlNode CreateManifestElement(string name)
        {
            return _manifestXmlDoc.CreateElement(name, WebstoreManifestNamespace);
        }

        private XmlNode CreateManifestElement(string name, string value)
        {
            XmlNode node = _manifestXmlDoc.CreateElement(name, WebstoreManifestNamespace);
            node.InnerText = value;

            return node;
        }

        private XmlNode CreateManifestElement(string name, bool value)
        {
            XmlNode node = _manifestXmlDoc.CreateElement(name, WebstoreManifestNamespace);

            // Boolean values in manifest must be lower case
            node.InnerText = value.ToString().ToLower();

            return node;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\MatchStress\SearchInfo.h ===
// Copyright (c) Microsoft Corporation.  All rights reserved

#ifndef __SEARCHINFO_H
#define __SEARCHINFO_H
#pragma once

//
//  Attribute
//

typedef struct
{
    DWORD   dwType;
    DWORD   dwLen;

    union
    {
        ULONGLONG   qwVal;
        LPSTR       strVal;
        LPBYTE      pVal;
    } val;
} PARAM, *PPARAM;

typedef CAtlArray<PARAM> XPARAMARRAY;

//
//  This class contains all client-side session information.
//

class XSearchInfo
{
public:

    XSearchInfo(XNADDR&);
    ~XSearchInfo();

    void AppendIntParam(ULONGLONG qwParamValue);
    void AppendStringParam(LPCWSTR szParamValue);
    void AppendBlobParam(DWORD dwParamLen, LPBYTE pParamValue);
    void AppendNullParam(void);

    void SetTitleID(DWORD dwTitleID);
    void SetProcIndex(DWORD dwProcIndex);
    void SetNumUsers(DWORD dwNumUsers);
    void SetAddress(XNADDR& Addr);

    void GetSearch(PXMATCH_SEARCH& pSearch);

protected:

    XMATCH_SEARCH   m_Search;  
    XPARAMARRAY     m_Params;
};

#endif // __SEARCHINFO_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\MatchStress\SearchInfo.cpp ===
// Copyright (c) Microsoft Corporation.  All rights reserved

#include "precomp.h"

extern void GetRandomAddress(XNADDR&);

XSearchInfo::XSearchInfo(XNADDR& clientAddress)
{
    ZeroMemory(&m_Search, sizeof(XMATCH_SEARCH));

    m_Search.ClientAddress = clientAddress;
}

XSearchInfo::~XSearchInfo()
{
    //
    //  Clear ATTRIBUTE map and free up any memory
    //

    for(DWORD dwIndex = 0; dwIndex < m_Params.GetCount(); ++dwIndex)
    {
        PARAM param = m_Params[dwIndex];

        switch(param.dwType)
        {
        case X_ATTRIBUTE_DATATYPE_INTEGER:
            break;

        case X_ATTRIBUTE_DATATYPE_STRING:
            free(param.val.strVal);
            break;

        case X_ATTRIBUTE_DATATYPE_BLOB:
            free(param.val.pVal);
            break;

        default:
            ATLASSERT("Invalid parameter type.");
            break;
        }
    }

    m_Params.RemoveAll();
}

void XSearchInfo::AppendIntParam(
    ULONGLONG   qwParamValue
    )
{
    PARAM param;

    param.dwType = X_ATTRIBUTE_DATATYPE_INTEGER;
    param.dwLen = sizeof(param.val.qwVal);
    param.val.qwVal = qwParamValue;

    m_Params.Add(param);
}

void XSearchInfo::AppendStringParam(
    LPCWSTR      szParamValue
    )
{
    PARAM param;

    param.dwType = X_ATTRIBUTE_DATATYPE_STRING;
    param.dwLen = REQUIRED_BUFFER(szParamValue) + sizeof(USHORT);
    param.val.strVal = (LPSTR)malloc(param.dwLen);
    W2UTF8(szParamValue, param.val.strVal, param.dwLen);

    m_Params.Add(param);
}

void XSearchInfo::AppendBlobParam(
    DWORD       dwParamLen,
    LPBYTE      pParamValue
    )
{
    PARAM param;

    param.dwType = X_ATTRIBUTE_DATATYPE_BLOB;
    param.dwLen = dwParamLen + sizeof(USHORT);
    param.val.pVal = (LPBYTE)malloc(dwParamLen);
    if(pParamValue != NULL)
        CopyMemory(param.val.pVal, pParamValue, dwParamLen);

    m_Params.Add(param);
}

void XSearchInfo::AppendNullParam()
{
    PARAM param;

    param.dwType = X_ATTRIBUTE_DATATYPE_NULL;
    param.dwLen = 0;

    m_Params.Add(param);
}

void XSearchInfo::SetTitleID(
    DWORD       dwTitleID
    )
{
    m_Search.dwTitleID = dwTitleID;
}

void XSearchInfo::SetProcIndex(
    DWORD       dwProcIndex
    )
{
    m_Search.dwProcedureIndex = dwProcIndex;
}

void XSearchInfo::SetNumUsers(
    DWORD   dwNumUsers
    )
{
    m_Search.dwNumUsers = dwNumUsers;
}

void XSearchInfo::SetAddress(
    XNADDR& Addr
    )
{
    m_Search.ClientAddress = Addr;
}

//
//  Format all ATTRIBUTEs and session info into a buffer suitable for
//  sending to the matchmaking server.  Caller is responsible for calling
//  free() on the returned pointer.
//

void XSearchInfo::GetSearch(
    PXMATCH_SEARCH& pSearch
    )
{
    DWORD dwIndex;

    //
    //  First we need to calculate the necessary buffer length which is
    //
    //      sizeof(XMATCH_SEARCH) + (sizeof(DWORD) * N * 2) + sizeof(PARAMS)
    //
    //  Where sizeof(PARAMS) includes space for length prefix in case of string/blob
    //  parameters
    //

    DWORD dwRequiredBuffer = sizeof(XMATCH_SEARCH) + (m_Params.GetCount() * sizeof(DWORD) * 2);

    for(dwIndex = 0; dwIndex < m_Params.GetCount(); ++dwIndex)
    {
        PARAM param = m_Params[dwIndex];

        dwRequiredBuffer += param.dwLen;
    }

    //
    //  Allocate the buffer, copy the base structure and put in the ATTRIBUTEs.
    //

    pSearch = (PXMATCH_SEARCH)malloc(dwRequiredBuffer);

    CopyMemory(pSearch, &m_Search, sizeof(XMATCH_SEARCH));
    pSearch->dwMessageLength = dwRequiredBuffer;
    pSearch->dwNumParameters = m_Params.GetCount();

    //
    //  Fill in ATTRIBUTEs and offsets
    //

    LPDWORD lpdwOffsets = (LPDWORD)((LPBYTE)pSearch + sizeof(XMATCH_SEARCH));
    DWORD dwCurrentOffset = 0;
    LPBYTE pParamPos = (LPBYTE)pSearch + sizeof(XMATCH_SEARCH) + (sizeof(DWORD) * m_Params.GetCount());
    for(dwIndex = 0; dwIndex < m_Params.GetCount(); ++dwIndex)
    {
        PARAM param = m_Params[dwIndex];

        lpdwOffsets[dwCurrentOffset++] = (pParamPos - (LPBYTE)pSearch);

        *(LPDWORD)pParamPos = param.dwType;
        pParamPos += sizeof(param.dwType);

        switch(param.dwType)
        {
        case X_ATTRIBUTE_DATATYPE_INTEGER:
            *(PULONGLONG)pParamPos = param.val.qwVal;

            break;

        case X_ATTRIBUTE_DATATYPE_STRING:
            *(PUSHORT)pParamPos = (USHORT)(param.dwLen - sizeof(USHORT));
            lstrcpyA((LPSTR)(pParamPos + sizeof(USHORT)), param.val.strVal);

            break;

        case X_ATTRIBUTE_DATATYPE_BLOB:
            *(PUSHORT)pParamPos = (USHORT)(param.dwLen - sizeof(USHORT));
            CopyMemory(pParamPos + sizeof(USHORT), param.val.pVal, param.dwLen - sizeof(USHORT));

            break;
        }

        pParamPos += param.dwLen;
    }
}

// EOF
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\MatchStress\SessionInfo.cpp ===
// Copyright (c) Microsoft Corporation.  All rights reserved

#include "precomp.h"

extern void GetRandomAddress(XNADDR&);

XUID g_xuidNull = { 0, 0 };

XSessionInfo::XSessionInfo(XNADDR& hostAddress) : m_bDeleteSession(false)
{
    SGADDR*     pSGAddr = (SGADDR*)(m_Session.HostAddress.abOnline);

    ZeroMemory(&m_Session, sizeof(XMATCH_SESSION));
    
    m_Session.HostAddress = hostAddress;
}

XSessionInfo::~XSessionInfo()
{
    //
    //  Clear attribute map and free up any memory
    //

    while(m_AttrMap.GetCount() != 0)
    {
        POSITION pos;
        ATTRIBUTE attr;

        pos = m_AttrMap.GetStartPosition();
        attr = m_AttrMap.GetValueAt(pos);

        switch(attr.dwAttributeID & X_ATTRIBUTE_DATATYPE_MASK)
        {
        case X_ATTRIBUTE_DATATYPE_STRING:
            free(attr.val.strVal);
            break;

        case X_ATTRIBUTE_DATATYPE_BLOB:
            free(attr.val.pVal);
            break;
        }

        m_AttrMap.RemoveAtPos(pos);
    }
}

void XSessionInfo::AddIntAttribute(
    DWORD       dwAttributeID,
    ULONGLONG   qwAttributeValue
    )
{
    AddIntAttribute(dwAttributeID, g_xuidNull, qwAttributeValue);
}

void XSessionInfo::AddIntAttribute(
    DWORD       dwAttributeID,
    XUID        UserID,
    ULONGLONG   qwAttributeValue
    )
{
    ATTRIBUTE attr;

    ATLASSERT((dwAttributeID & X_ATTRIBUTE_DATATYPE_MASK) == X_ATTRIBUTE_DATATYPE_INTEGER);

    attr.dwAttributeID = dwAttributeID;
    attr.UserID = UserID;
    attr.ulLen = sizeof(ULONGLONG);
    if((dwAttributeID & X_ATTRIBUTE_TYPE_MASK) == X_ATTRIBUTE_TYPE_USER)
        attr.ulLen += sizeof(XUID);

    attr.val.qwVal = qwAttributeValue;

    m_AttrMap.SetAt(attr, attr);
}

void XSessionInfo::AddStringAttribute(
    DWORD       dwAttributeID,
    LPCWSTR     szAttributeValue
    )
{
    AddStringAttribute(dwAttributeID, g_xuidNull, szAttributeValue);
}

void XSessionInfo::AddStringAttribute(
    DWORD       dwAttributeID,
    XUID        UserID,
    LPCWSTR     szAttributeValue
    )
{
    ATTRIBUTE attr;
    ATTRIBUTE attrExists;

    ATLASSERT((dwAttributeID & X_ATTRIBUTE_DATATYPE_MASK) == X_ATTRIBUTE_DATATYPE_STRING);

    attr.dwAttributeID = dwAttributeID;
    attr.UserID = UserID;
    attr.ulLen = REQUIRED_BUFFER(szAttributeValue) + sizeof(USHORT);
    if((dwAttributeID & X_ATTRIBUTE_TYPE_MASK) == X_ATTRIBUTE_TYPE_USER)
        attr.ulLen += sizeof(XUID);

    attr.val.strVal = (LPSTR)malloc(attr.ulLen);
    W2UTF8(szAttributeValue, attr.val.strVal, attr.ulLen);

    if(m_AttrMap.Lookup(attr, attrExists))
        free(attrExists.val.strVal);
    
    m_AttrMap.SetAt(attr, attr);
}


void XSessionInfo::AddBlobAttribute(
    DWORD       dwAttributeID,
    DWORD       dwAttributeLen,
    LPBYTE      pAttributeValue
    )
{
    AddBlobAttribute(dwAttributeID, g_xuidNull, dwAttributeLen, pAttributeValue);
}

void XSessionInfo::AddBlobAttribute(
    DWORD       dwAttributeID,
    XUID        UserID,
    DWORD       dwAttributeLen,
    LPBYTE      pAttributeValue
    )
{
    ATTRIBUTE attr;
    ATTRIBUTE attrExists;

    ATLASSERT((dwAttributeID & X_ATTRIBUTE_DATATYPE_MASK) == X_ATTRIBUTE_DATATYPE_BLOB);

    attr.dwAttributeID = dwAttributeID;
    attr.UserID = UserID;
    attr.ulLen = dwAttributeLen + sizeof(USHORT);
    if((dwAttributeID & X_ATTRIBUTE_TYPE_MASK) == X_ATTRIBUTE_TYPE_USER)
        attr.ulLen += sizeof(XUID);

    attr.val.pVal = (LPBYTE)malloc(dwAttributeLen);
    CopyMemory(attr.val.pVal, pAttributeValue, dwAttributeLen);

    if(m_AttrMap.Lookup(attr, attrExists))
        free(attrExists.val.pVal);
    
    m_AttrMap.SetAt(attr, attr);
}

void XSessionInfo::SetTitleID(
    DWORD       dwTitleID
    )
{
    m_Session.dwTitleID = dwTitleID;
}

void XSessionInfo::SetSessionID(
    ULONGLONG   qwSessionID
    )
{
    CopyMemory(&m_Session.SessionID, &qwSessionID, sizeof(XNKID));
}

void XSessionInfo::SetPublicOpen(
    DWORD       dwPublicOpen
    )
{
    m_Session.dwPublicOpen = dwPublicOpen;
}

void XSessionInfo::SetPrivateOpen(
    DWORD       dwPrivateOpen
    )
{
    m_Session.dwPrivateOpen = dwPrivateOpen;
}

void XSessionInfo::SetPublicFilled(
    DWORD       dwPublicFilled
    )
{
    m_Session.dwPublicFilled = dwPublicFilled;
}

void XSessionInfo::SetPrivateFilled(
    DWORD       dwPrivateFilled
    )
{
    m_Session.dwPrivateFilled = dwPrivateFilled;
}

void XSessionInfo::SetHostAddress(
    XNADDR&     HostAddress)
{
    m_Session.HostAddress = HostAddress;
}

//
//  Format all attributes and session info into a buffer suitable for
//  sending to the matchmaking server.  Caller is responsible for calling
//  free() on the returned pointer.
//

void XSessionInfo::GetSession(
    PXMATCH_SESSION&    pSession
    )
{
    POSITION pos;

    if(!m_bDeleteSession)
    {
        //
        //  First we need to calculate the necessary buffer length which is
        //
        //      sizeof(XMATCH_SESSION) + (sizeof(DWORD) * N * 2) + sizeof(ATTRIBUTES)
        //
        //  Where sizeof(ATTRIBUTES) includes space for length prefix in case of string/blob
        //  attributes
        //

        DWORD   dwRequiredBuffer = sizeof(XMATCH_SESSION) + (m_AttrMap.GetCount() * sizeof(DWORD) * 2);

        for(pos = m_AttrMap.GetStartPosition(); pos != NULL; m_AttrMap.GetNext(pos))
        {
            ATTRIBUTE attr = m_AttrMap.GetValueAt(pos);

            dwRequiredBuffer += attr.ulLen;
        }

        //
        //  Allocate the buffer, copy the base structure and put in the attributes.
        //

        pSession = (PXMATCH_SESSION)malloc(dwRequiredBuffer);

        CopyMemory(pSession, &m_Session, sizeof(XMATCH_SESSION));
        pSession->dwMessageLength = dwRequiredBuffer;
        pSession->dwNumAttributes = m_AttrMap.GetCount();

        //
        //  Fill in attributes and offsets
        //

        LPDWORD lpdwOffsets = (LPDWORD)((LPBYTE)pSession + sizeof(XMATCH_SESSION));
        DWORD dwCurrentOffset = 0;
        LPBYTE pAttrPos = (LPBYTE)pSession + sizeof(XMATCH_SESSION) + (sizeof(DWORD) * m_AttrMap.GetCount());
        for(pos = m_AttrMap.GetStartPosition(); pos != NULL; m_AttrMap.GetNext(pos))
        {
            // get the next attribute
            ATTRIBUTE attr = m_AttrMap.GetValueAt(pos);

            // set the offset for this attribute
            lpdwOffsets[dwCurrentOffset++] = (pAttrPos - (LPBYTE)pSession);

            // set the attribute id for this attribute and bump the pointer
            *(LPDWORD)pAttrPos = attr.dwAttributeID;
            pAttrPos += sizeof(DWORD);

            // if it's a user attribute set the user PUID and bump the pointer
            if((attr.dwAttributeID & X_ATTRIBUTE_TYPE_MASK) == X_ATTRIBUTE_TYPE_USER)
            {
                *(XUID*)pAttrPos = attr.UserID;
                pAttrPos += sizeof(XUID);
            }

            // now set the attribute value
            switch(attr.dwAttributeID & X_ATTRIBUTE_DATATYPE_MASK)
            {
            case X_ATTRIBUTE_DATATYPE_INTEGER:
                *(PULONGLONG)pAttrPos = attr.val.qwVal;
                break;

            case X_ATTRIBUTE_DATATYPE_STRING:
                {
                    ULONG ulAttrValueLen = attr.ulLen - sizeof(USHORT);
                    if((attr.dwAttributeID & X_ATTRIBUTE_TYPE_MASK) == X_ATTRIBUTE_TYPE_USER)
                        ulAttrValueLen -= sizeof(XUID);

                    *(PUSHORT)pAttrPos = (USHORT)(ulAttrValueLen & 0xFFFF);
                    CopyMemory(pAttrPos + sizeof(USHORT), attr.val.strVal, ulAttrValueLen);
                }
                break;

            case X_ATTRIBUTE_DATATYPE_BLOB:
                {
                    ULONG ulAttrValueLen = attr.ulLen - sizeof(USHORT);
                    if((attr.dwAttributeID & X_ATTRIBUTE_TYPE_MASK) == X_ATTRIBUTE_TYPE_USER)
                        ulAttrValueLen -= sizeof(XUID);

                    *(PUSHORT)pAttrPos = (USHORT)(ulAttrValueLen & 0xFFFF);
                    CopyMemory(pAttrPos + sizeof(USHORT), attr.val.pVal, ulAttrValueLen);
                }
                break;
            }

            if((attr.dwAttributeID & X_ATTRIBUTE_TYPE_MASK) == X_ATTRIBUTE_TYPE_USER)
                pAttrPos += attr.ulLen - sizeof(XUID);
            else
                pAttrPos += attr.ulLen;
        }
    }
    else
    {
        //
        //  Allocate the buffer, copy the base structure and put in the attributes.
        //

        pSession = (PXMATCH_SESSION)malloc(sizeof(XMATCH_SESSION_DELETE));

        CopyMemory(pSession, &m_Session, sizeof(XMATCH_SESSION_DELETE));
        pSession->dwMessageLength = sizeof(XMATCH_SESSION_DELETE);
    }
}


void XSessionInfo::GetSGAddr(
    SGADDR&    sgaddr
    )
{
    SGADDR* pSGAddr = (SGADDR*)(m_Session.HostAddress.abOnline);
    sgaddr = *pSGAddr;
}

void XSessionInfo::GetSGIP(
    IN_ADDR& sgip
    )
{
    SGADDR* pSGAddr = (SGADDR*)(m_Session.HostAddress.abOnline);
    sgip = pSGAddr->inaSg;
}

void XSessionInfo::SetDelete(
    bool bDelete
    )
{
    m_bDeleteSession = bDelete;
}

bool XSessionInfo::GetDelete(void)
{
    return m_bDeleteSession;
}

XSessionInfo::operator PXMATCH_SESSION(void)
{
    PXMATCH_SESSION pSession;
    GetSession(pSession);
    return pSession;
}
    

// EOF
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\ManifestEdit\ManifestOperations.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.IO;
using System.Xml;

namespace ManifestEdit
{
    public class SqlObjectNotFoundException : Exception
    {
        public SqlObjectNotFoundException() : base() { }
        public SqlObjectNotFoundException(string message) : base(message) { }
    }

    public class ManifestOperations
    {
        public ManifestOperations(string manifestFilePath)
        {
            Manifest = new Manifest(manifestFilePath);
        }

        public ManifestOperations(Manifest manifest)
        {
            Manifest = manifest;
        }

        /// <summary>
        /// Goes through all files in the directory and adds them to the manifest scripts section
        /// </summary>
        /// <param name="scriptsPath"></param>
        public void AddScriptsFromDirectory(string scriptsPath)
        {
            if (Directory.Exists(scriptsPath))
            {
                string[] scriptFiles = Directory.GetFiles(scriptsPath);

                foreach (string scriptFile in scriptFiles)
                {
                    AddScriptUpgradeAfterTables(scriptFile);
                }
            }
        }

        /// <summary>
        /// Add a script to the scripts section for the source file
        /// </summary>
        /// <param name="sourceFile"></param>
        public void AddScriptUpgradeAfterTables(string sourceFile)
        {
            AddScriptUpgradeAfterTables(sourceFile, "9999");
        }

        /// <summary>
        /// Add a script to the scripts section for the source file
        /// </summary>
        /// <param name="sourceFile"></param>
        /// <param name="installOrder"></param>
        public void AddScriptUpgradeAfterTables(string sourceFile, string installOrder)
        {
            Manifest.AddScript(sourceFile, installOrder, "AfterTables", true);
        }

        /// <summary>
        /// Removes SqlObjects line by line in files inside the directory
        /// 
        /// Files are named by convention based on the name of the SqlObjects
        /// 
        /// e.g. Under SqlObjects, the object types are:
        ///         Tables - tables.txt
        ///         Triggers - triggers.txt
        ///         Sprocs - sprocs.txt
        ///         Functions - functions.txt
        ///         Scripts - scripts.txt
        /// </summary>
        /// <param name="dir"></param>
        public void RemoveSqlObjectsFromDir(string dir)
        {
            string[] sqlObjects = Manifest.GetAllSqlObjects();

            foreach (string sqlObject in sqlObjects)
            {
                string sqlObjectFilePath = Path.Combine(dir, sqlObject + ".txt");

                if (File.Exists(sqlObjectFilePath))
                {
                    RemoveSqlObjectsFileList(sqlObject, sqlObjectFilePath);
                }
            }
        }

        /// <summary>
        /// Removes all SqlObjects specified in the file line by line
        /// </summary>
        /// <param name="sqlObjectType"></param>
        /// <param name="sqlObjectFilePath"></param>
        public void RemoveSqlObjectsFileList(string sqlObjectType, string sqlObjectFilePath)
        {
            RemoveSqlObjects(sqlObjectType, File.ReadAllLines(sqlObjectFilePath));
        }

        /// <summary>
        /// Removes all SqlObjects specified in array
        /// </summary>
        /// <param name="sqlObjectType"></param>
        /// <param name="sqlObjects"></param>
        public void RemoveSqlObjects(string sqlObjectType, string[] sqlObjects)
        {
            foreach (string sqlObject in sqlObjects)
            {
                Manifest.RemoveSqlObject(sqlObjectType, sqlObject);
            }
        }

        public Manifest Manifest
        {
            get;
            private set;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\MatchStress\SessionInfo.h ===
// Copyright (c) Microsoft Corporation.  All rights reserved

#ifndef __SESSIONINFO_H
#define __SESSIONINFO_H
#pragma once

//
//  Attribute
//

typedef struct
{
    DWORD       dwAttributeID;
    XUID        UserID;
    ULONG       ulLen;

    union
    {
        ULONGLONG   qwVal;
        LPSTR       strVal;
        LPBYTE      pVal;
    } val;
} ATTRIBUTE, *PATTRIBUTE;

//
//  Map class for holding attributes
//

template<>
class CElementTraits< ATTRIBUTE > :
	public CElementTraitsBase< T >
{
public:
	static ULONG Hash( INARGTYPE attr )
	{
        return( attr.dwAttributeID ^ 
                (DWORD)(attr.UserID.qwUserID & 0x00000000FFFFFFFF ) ^ 
                (DWORD)((attr.UserID.qwUserID & 0xFFFFFFFF00000000) >> 32) ^
                attr.UserID.dwUserFlags);
	}

  	static bool CompareElements( INARGTYPE attr1, INARGTYPE attr2 )
	{
        return (attr1.dwAttributeID == attr2.dwAttributeID &&
                attr1.UserID.qwUserID == attr2.UserID.qwUserID &&
                attr1.UserID.dwUserFlags == attr2.UserID.dwUserFlags);
	}

};

typedef CAtlMap<ATTRIBUTE, ATTRIBUTE> XATTRMAP;

//
//  This class contains all client-side session information.
//

class XSessionInfo
{
public:

    XSessionInfo(XNADDR&);
    ~XSessionInfo();

    void AddIntAttribute(DWORD dwAttributeID, ULONGLONG qwAttributeValue);
    void AddStringAttribute(DWORD dwAttributeID, LPCWSTR szAttributeValue);
    void AddBlobAttribute(DWORD dwAttributeID, DWORD dwAttributeLen, LPBYTE pAttributeValue);

    void AddIntAttribute(DWORD dwAttributeID, XUID UserID, ULONGLONG qwAttributeValue);
    void AddStringAttribute(DWORD dwAttributeID, XUID UserID, LPCWSTR szAttributeValue);
    void AddBlobAttribute(DWORD dwAttributeID, XUID UserID, DWORD dwAttributeLen, LPBYTE pAttributeValue);

    void SetTitleID(DWORD dwTitleID);
    void SetSessionID(ULONGLONG qwSessionID);
    void SetPublicOpen(DWORD dwPublicOpen);
    void SetPrivateOpen(DWORD dwPrivateOpen);
    void SetPublicFilled(DWORD dwPublicFilled);
    void SetPrivateFilled(DWORD dwPrivateFilled);
    void SetHostAddress(XNADDR& HostAddress);

    void GetSession(PXMATCH_SESSION& pSession);
    void GetSGAddr(SGADDR& sgaddr);
    void GetSGIP(IN_ADDR& sgip);

    void SetDelete(bool);
    bool GetDelete(void);

    operator PXMATCH_SESSION(void);

protected:

    bool            m_bDeleteSession;
    XMATCH_SESSION  m_Session;  
    XATTRMAP        m_AttrMap;
};

#endif // __SESSIONINFO_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\mcmsrunner\core\makefile.inc ===
!include $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\mcmsrunner\console\makefile.inc ===
!include $(INETROOT)\build\makefile.inc


#
# special case to work around lack of static linking.
# not using cspp because:
# 1) they are not using the logging service
# 2) some originals are in locations that can't be cspp'd
#

$(_OBJ_DIR)\Tlog.cs : $(BASEDIR)\private\tools\xboxcom\toollib\Tlog.cs
    copy /y $? $@

$(_OBJ_DIR)\HtmlUtl.cs : $(BASEDIR)\private\tools\xboxcom\toollib\HtmlUtl.cs
    copy /y $? $@

$(_OBJ_DIR)\DirList.cs : $(BASEDIR)\private\tools\xboxcom\toollib\Dirlist.cs
    copy /y $? $@

$(_OBJ_DIR)\ImportPosting.cs : $(BASEDIR)\private\tools\xboxcom\XmlToCms\ImportPosting.cs
    copy /y $? $@
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\ManifestEdit\Program.cs ===
﻿using System;
using System.Collections.Generic;
using System.Text;
using System.IO;

using xonline.common.tools.console;

namespace ManifestEdit
{
    public class Program
    {
        static NamedArgParser _parsedArgs;

        public static int Main(string[] args)
        {
            try
            {
                if (!ParseArgs(args))
                {
                    return 0;
                }

                string manifestFilePath = _parsedArgs["m"];
                string outputFilePath = _parsedArgs["o"];
                string dropDir = _parsedArgs["dropdir"];
                string scriptsDir = _parsedArgs["scriptsdir"];
                string manifestVersion = _parsedArgs["v"];

                ManifestOperations manifestOperations = new ManifestOperations(manifestFilePath);

                if (!String.IsNullOrEmpty(manifestVersion))
                {
                    manifestOperations.Manifest.SetVersion(manifestVersion);
                }

                if (!String.IsNullOrEmpty(dropDir))
                {
                    manifestOperations.RemoveSqlObjectsFromDir(dropDir);
                }

                if (!String.IsNullOrEmpty(scriptsDir))
                {
                    manifestOperations.Manifest.ClearScripts();
                    manifestOperations.AddScriptsFromDirectory(scriptsDir);
                }

                if (String.IsNullOrEmpty(outputFilePath))
                {
                    manifestOperations.Manifest.Save();
                }
                else
                {
                    manifestOperations.Manifest.Save(outputFilePath);
                }
            }
            catch (SqlObjectNotFoundException e)
            {
                Console.WriteLine();
                Console.WriteLine("Error: {0}", e.Message);
                return 1;
            }

            catch (Exception e)
            {
                Console.WriteLine();
                Console.WriteLine("Exception: {0}", e.Message);
                Console.WriteLine("Stack Trace: {0}", e.StackTrace);
                return 1;
            }

            return 0;
        }

        private static bool ParseArgs(string[] args)
        {
            string[] options = new string[] { "m", "o", "v", "dropdir", "scriptsdir" };

            if (args.Length == 0)
            {
                PrintUsage();
                return false;
            }

            _parsedArgs = new NamedArgParser(options);
            if (!_parsedArgs.Parse(args))
            {
                Console.WriteLine("Invalid argument: " + _parsedArgs.InvalidArgText);
                PrintUsage();
                return false;
            }

            return true;
        }

        private static void PrintUsage()
        {
            Console.WriteLine(
//  0    1    1    2    2    3    3    4    4    5    5    6    6    7    7    8
//--5----0----5----0----5----0----5----0----5----0----5----0----5----0----5----0
@"
Usage: ManifestEdit -m:<manifest.xml> -o:<outputfile.xml>  -v:<version>
                    -dropdir:<DropFromManifestDir> -scriptsdir:<ScriptsDir>
 
  <manifest.xml>:        The source manifest webstore xml to edit

  <outputfile.xml>:      Output manifest xml file, if NOT specified, it will edit
                           the manifest file in place.

  <version>:             Build version number to inject into the files.

  <DropFromManifestDir>: Directory containing files with list of SqlObjects
                           to be removed.
                         Files should be named as the group node to be removed.
                         e.g. tables.txt
                              triggers.txt
                              sprocs.txt
                              views.txt
                              functions.txt
                              scripts.txt
                              securityroles.txt
                              jobs.txt
                         Files should contain an item name per row                       

  <scriptsdir>:          Scripts directory to add scripts into manifest
 
 
  This tool removes items from the manifest file as specified from the
  DropFromManifestDir directory and adds script files found in the scriptsdir
  directory.
");
            return;     
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\mcmsrunner\console\McmsRunnerCmd.cs ===
using System;
using System.IO;
using System.Xml;
using System.Text.RegularExpressions;
using System.Collections.Specialized;

using xonline.tools.mcmsrunner.core;
using xonline.common.xmlsequencer;

namespace xonline.tools.mcmsrunner.console
{
	/// <summary>
	/// Provides a command line interface to the core McmsRunner functionality.
	/// </summary>
	class McmsRunnerCmd
	{
        private string mcmsRunnerFilename = null;
        private NameValueCollection overrideVariables = new NameValueCollection();

		/// <summary>
		/// The main entry point for the application.
		/// </summary>
		[STAThread]
		static int Main(string[] args)
		{
            McmsRunnerCmd theCmd = new McmsRunnerCmd();
            theCmd.ParseCommandLine(args);
            return theCmd.RunIt();
		}

        /// <summary>
        /// Handles parsing of the command line arguments, setting member variables 
        /// based on the options and arguments specified.
        /// </summary>
        /// <param name="args">The arguments to process.</param>
        public void ParseCommandLine(string[] args)
        {
            int numberOfArgs = args.Length;
            Regex variableRegex = new Regex(
                @"^(?<name>[^=]+)=(?<value>.*)", 
                RegexOptions.Compiled | RegexOptions.IgnoreCase);

            for (int currentArgIndex = 0; currentArgIndex < numberOfArgs; currentArgIndex++)
            {
                string currentArg = args[currentArgIndex];
                if (currentArg == "/?")
                {
                    ShowUsageInfo();
                    Environment.Exit(0);
                }
                else if (currentArg.StartsWith("/"))
                {
                    Console.WriteLine("ERROR: Invalid argument or option - '" + currentArg + "'.");
                    Console.WriteLine("Type \"McmsRunner /?\" for usage help.");
                    Environment.Exit(1);
                }
                else if (variableRegex.IsMatch(currentArg))
                {
                    Match myMatch = variableRegex.Match(currentArg);
                    overrideVariables.Set(myMatch.Groups["name"].Value, myMatch.Groups["value"].Value);
                }
                else
                {
                    if (mcmsRunnerFilename == null)
                    {
                        mcmsRunnerFilename = currentArg;
                    }
                    else
                    {
                        Console.WriteLine();
                        Console.WriteLine("Only one McmsRunner input file can be specified on the command line. Second filename \"" + currentArg + "\" was encountered.");
                        Console.WriteLine("Type \"McmsRunner /?\" for usage help.");
                        Environment.Exit(1);
                    }
                }
            }

            if (mcmsRunnerFilename == null)
            {
                Console.WriteLine();
                Console.WriteLine("ERROR: Required input file name not specified.");
                Console.WriteLine("Type \"McmsRunner /?\" for usage help.");
                Environment.Exit(1);
            }
        }

        private void VerifyParameter(string currentArg, int currentArgIndex, int numberOfArgs)
        {
            if (currentArgIndex + 1 >= numberOfArgs)
            {
                Console.WriteLine("ERROR: Option " + currentArg + " requires a value to be specified.");
                Console.WriteLine("Type \"McmsRunner /?\" for usage help."); 
                Environment.Exit(1);
            }
        }

        /// <summary>
        /// Displays information about this program and its command line agruments. 
        /// </summary>
        public void ShowUsageInfo()
        {
            Console.WriteLine();
            Console.WriteLine("McmsRunner [VARNAME=VALUE ...] inputfile");
            Console.WriteLine();
            Console.WriteLine("Description:");
            Console.WriteLine("    Executes IIS setup commands as specified by the McmsRunner XML input file.");
            Console.WriteLine();
            Console.WriteLine("Parameter List:");
            Console.WriteLine("    VARNAME=VALUE   Specifies a variable name and its associated value");
            Console.WriteLine("                    to use when applying the configuration transform to");
            Console.WriteLine("                    the McmsRunner XML input file. Any number of name/value");
            Console.WriteLine("                    definitions can be specified.");
            Console.WriteLine();
            Console.WriteLine("    inputfile       The filename of the XML input file to use.");
            Console.WriteLine();
            Console.WriteLine("  NOTE:  This tool returns an error level of 0 if all setup is successfully");
            Console.WriteLine("         executed, 1 if there are errors in the command line, or 2 if");
            Console.WriteLine("         there were problems processing the input XML or running the IIS setup");
            Console.WriteLine("         it defines.");
            Console.WriteLine();
            Console.WriteLine("Examples:");
            Console.WriteLine("    McmsRunner www_xbox_com.xml");
            Console.WriteLine(@"    McmsRunner SQLDATAPATH=h:\mssql\data");
            Console.WriteLine(@"              ""SQLLOGPATH=o:\mssql\log files\"" www_xbox_com.xml");
            Console.WriteLine();
 
        }

        /// <summary>
        /// Creates a McmsRunnerStep object, configuring it based on the command line arguments,
        /// and executes it. 
        /// </summary>
        /// <returns>
        /// The errorlevel value that should be returned to the cmd environment.
        /// Returns 0 on success, 2 on failure. 
        ///</returns>
        public int RunIt()
        {
            Console.WriteLine();
            Console.WriteLine("McmsRunner started processing '" + mcmsRunnerFilename + "' at " + DateTime.Now.ToString());
            Console.WriteLine();

            try
            {
                XmlDocument xmlDoc = new XmlDocument();
                xmlDoc.Load(mcmsRunnerFilename);

                ConfigurationTransform transform = new ConfigurationTransform();
                transform.OverrideVariableCollection.Add(overrideVariables);
                transform.TransformDocument(xmlDoc);

                McmsRunnerStep runner = new McmsRunnerStep(xmlDoc.DocumentElement); // Path.GetFullPath(mcmsRunnerFilename));
                runner.OnMessage += new MessageEventHandler(myRoot_OnMessage);

                runner.Validate();
                runner.Execute();
            }
            catch (Exception ex)
            {
                Console.WriteLine();
                Console.WriteLine();
                Console.WriteLine("ERROR: Exception encountered executing McmsRunner. - " + ex.Message);
                Console.WriteLine();
                Console.WriteLine();
                Console.WriteLine(ex.ToString());
                return 2;
            }

            Console.WriteLine();
            Console.WriteLine("McmsRunner processing of '" + mcmsRunnerFilename + "' completed at " + DateTime.Now.ToString());
            Console.WriteLine();
            return 0;
        }

        /// <summary>
        /// Event handler for McmsRunnerStep's Message event which writes the message to the console.
        /// </summary>
        /// <param name="sender">The McmsRunnerStep generating the event.</param>
        /// <param name="e">The MessageEventArgs sent by the event.</param>
        private void myRoot_OnMessage(object sender, MessageEventArgs e)
        {
            Console.WriteLine(e.Message);
        }
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\mcmsrunner\core\McmsRunnerStep.cs ===
using System;
using System.IO;
using System.Xml;
using System.Management;

using Microsoft.ContentManagement.Publishing;
using xonline.common.xmlsequencer;

namespace xonline.tools.mcmsrunner.core
{
	/// <summary>
	/// Provides the entry point for the McmsRunner components.
	/// </summary>
	/// <remarks>
	///  This class provides the primary interface to process a McmsRunner XML document. The McmsRunner XML document defines 
	///  a sequential series of steps to configure MCMS templates and other MCMS objects.
	///  It allows the sequencing and intent of the setup actions
	///  to be seperated from the code that implements how to perform those actions.
    ///</remarks>
	public class McmsRunnerStep : RootStepContainer
	{
        private CmsApplicationContext cmsContext = null;

        /// <summary>
        /// Initializes a new instance of the McmsRunnerStep class.
        /// </summary>
        /// <param name="stepElement">
        /// The McmsRunner XmlElement that contains the attributes and steps (children elements) that define the 
        /// actions to take.
        /// </param>
        /// <exception cref="InvalidOperationException">The passed stepElement does not belong to the McmsRunner namespace.</exception>
        /// <exception cref="ArgumentNullException">The passed stepElement was null.</exception>
		public McmsRunnerStep(XmlElement stepElement) : base(stepElement)
		{
		}

        /// <summary>
        /// Gets the name of the XML namespace that all McmsRunner elements must belong to.  
        /// </summary>
        public override string Namespace
        {
            get {return "http://www.xbox.com/mcmsrunner.xsd";}
        }

        public CmsApplicationContext CmsContext
        {
            get
            {
                if (cmsContext == null)
                {
                    cmsContext = new CmsApplicationContext();
                    cmsContext.AuthenticateAsCurrentUser(PublishingMode.Update);
                }

                return cmsContext;
            }
        }
	
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\mcmsrunner\core\StepNavigation.cs ===
using System;
using System.Management;

using xonline.common.xmlsequencer;

namespace xonline.tools.mcmsrunner.core
{
	/// <summary>
	/// Summary description for StepNavigation.
	/// </summary>
	public class StepNavigation
	{
        /// <summary>
        /// 
        /// </summary>
        /// <param name="startStep"></param>
        /// <returns></returns>
        static public TemplateGalleryStep GetTemplateGalleryAncestorOfStep(Step startStep)
        {
            Step currentStep = startStep.Parent;

            while (currentStep != null)
            {
                if (currentStep is TemplateGalleryStep)
                {
                    return (TemplateGalleryStep) currentStep;
                }

                currentStep = currentStep.Parent;
            }

            throw new InvalidOperationException("No TemplateGalleryStep present in the hierarchy above the passed step.");
        }

        static public TemplateStep GetTemplateAncestorOfStep(Step startStep)
        {
            Step currentStep = startStep.Parent;

            while (currentStep != null)
            {
                if (currentStep is TemplateStep)
                {
                    return (TemplateStep) currentStep;
                }

                currentStep = currentStep.Parent;
            }

            throw new InvalidOperationException("No TemplateStep present in the hierarchy above the passed step.");
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\mcmsrunner\core\ImportPostingStep.cs ===
using System;
using System.IO;
using System.Xml;
using System.Management;
using System.Data.SqlClient;

using Microsoft.ContentManagement.Publishing;
using xonline.common.xmlsequencer;
using xonline.tools.xboxcom.XmlToCms;
using xonline.tools.xboxcom.toollib;

namespace xonline.tools.mcmsrunner.core
{
    /// <summary>
    ///		runner of posting import step
    /// </summary>
    [StepElement("ImportPosting")]
    public class ImportPostingStep : StepContainer
    {
        private string _srcPath = null;
        protected bool _approve = false;
        protected bool _overwrite = false;

        public ImportPostingStep(XmlElement stepElement, StepContainer parent) : base(stepElement, parent)
        {
            _srcPath = BaseXmlElement.GetAttribute("from");
            _approve = BaseXmlElement.GetAttribute("approve") == "yes";
            _overwrite = BaseXmlElement.GetAttribute("overwrite") == "yes";

            if (_srcPath.Length == 0)
            {
                throw new ArgumentException("The from attribute of the " + BaseXmlElement.Name + " element must be specified.", "from");
            }
        }

        /// <summary>
        /// 
        /// </summary>
        public McmsRunnerStep McmsRunnerStep
        {
            get 
            {
                if (!(Root is McmsRunnerStep))
                {
                    throw new InvalidOperationException("The root step must be McmsRunnerStep for this step to function correctly."); 
                }
                return (McmsRunnerStep) Root;
            }
        }

        protected override void OnExecute()
        {
            TLog.Hooks += new TLog.LogHook(LogForwarder);
            (new PostingImporter()).ImportDir(_srcPath, _overwrite, _approve);

            // let contained steps execute
            base.OnExecute ();
        }

        private bool LogForwarder(string logText)
        {
            Root.LogMessage(logText);
            return false;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\mcmsrunner\core\ImagePlaceholderDefinitionStep.cs ===
using System;
using System.IO;
using System.Xml;
using System.Management;
using System.Data.SqlClient;

using Microsoft.ContentManagement.Publishing;
using Microsoft.ContentManagement.Publishing.Extensions.Placeholders;
using xonline.common.xmlsequencer;

namespace xonline.tools.mcmsrunner.core
{
	/// <summary>
	/// Summary description for TemplateStep.
	/// </summary>
	[StepElement("ImagePlaceholderDefinition")]
    public class ImagePlaceholderDefinitionStep : Step
	{
        /// <summary>
        /// 
        /// </summary>
        /// <param name="stepElement"></param>
        /// <param name="parent"></param>
		public ImagePlaceholderDefinitionStep(XmlElement stepElement, StepContainer parent) : base(stepElement, parent)
		{
            if (Name.Length == 0)
            {
                throw new ArgumentException("The name attribute of the " + BaseXmlElement.Name + " element must be specified.", "name");
            }
        }

       public string Name
        {
            get {return BaseXmlElement.GetAttribute("name");}
        }

        public string Description
        {
            get {return BaseXmlElement.GetAttribute("description");}
        }

        public bool AllowHyperlinks
        {
            get {return !(String.Compare(BaseXmlElement.GetAttribute("allowHyperlinks"), "false", true) == 0);}
        }

        public bool MustUseResourceGallery
        {
            get {return (String.Compare(BaseXmlElement.GetAttribute("mustUseResourceGallery"), "true", true) == 0);}
        }

        /// <summary>
        /// 
        /// </summary>
        public McmsRunnerStep McmsRunnerStep
        {
            get 
            {
                if (!(Root is McmsRunnerStep))
                {
                    throw new InvalidOperationException("The root step must be McmsRunnerStep for this step to function correctly."); 
                }
                return (McmsRunnerStep) Root;
            }
        }

        protected override void OnExecute()
        {
            CmsApplicationContext cmsContext = McmsRunnerStep.CmsContext;

            TemplateStep templateStep = StepNavigation.GetTemplateAncestorOfStep(this);
            Template template = templateStep.Template;

            ImagePlaceholderDefinition definition = (ImagePlaceholderDefinition) template.PlaceholderDefinitions[Name];
            
            // if we still have a null definition at this point, create a new one
            if (definition == null)
            {
                Root.LogMessage(String.Format("Creating ImagePlaceholderDefinition {0}.", Name));
                definition = (ImagePlaceholderDefinition) template.CreatePlaceholderDefinition(typeof(ImagePlaceholderDefinition));
                definition.Name = Name;
                templateStep.Dirty = true;
            }

            if (definition.Description != Description)
            {
                definition.Description = Description;
                templateStep.Dirty = true;
            }

            if (AllowHyperlinks != definition.AllowHyperlinks)
            {
                definition.AllowHyperlinks = AllowHyperlinks;
                templateStep.Dirty = true;
            }
            
            if (MustUseResourceGallery != definition.MustUseResourceGallery)
            {
                definition.MustUseResourceGallery = MustUseResourceGallery;
                templateStep.Dirty = true;
            }
            
            base.OnExecute ();

        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\mcmsrunner\core\HtmlPlaceholderDefinitionStep.cs ===
using System;
using System.IO;
using System.Xml;
using System.Management;
using System.Data.SqlClient;

using Microsoft.ContentManagement.Publishing;
using Microsoft.ContentManagement.Publishing.Extensions.Placeholders;
using xonline.common.xmlsequencer;

namespace xonline.tools.mcmsrunner.core
{
	/// <summary>
	/// Summary description for TemplateStep.
	/// </summary>
    [StepElement("HtmlPlaceholderDefinition")]
    public class HtmlPlaceholderDefinitionStep : Step
	{
        /// <summary>
        /// 
        /// </summary>
        /// <param name="stepElement"></param>
        /// <param name="parent"></param>
		public HtmlPlaceholderDefinitionStep(XmlElement stepElement, StepContainer parent) : base(stepElement, parent)
		{
            if (Name.Length == 0)
            {
                throw new ArgumentException("The name attribute of the " + BaseXmlElement.Name + " element must be specified.", "name");
            }
        }

       public string Name
        {
            get {return BaseXmlElement.GetAttribute("name");}
        }

        public string Description
        {
            get {return BaseXmlElement.GetAttribute("description");}
        }

        public bool AllowAttachments
        {
            get {return !(String.Compare(BaseXmlElement.GetAttribute("allowAttachments"), "false", true) == 0);}
        }

        public bool AllowHyperlinks
        {
            get {return !(String.Compare(BaseXmlElement.GetAttribute("allowHyperlinks"), "false", true) == 0);}
        }

        public bool AllowImages
        {
            get {return !(String.Compare(BaseXmlElement.GetAttribute("allowImages"), "false", true) == 0);}
        }

        public bool AllowLineBreaks
        {
            get {return !(String.Compare(BaseXmlElement.GetAttribute("allowLineBreaks"), "false", true) == 0);}
        }

        public HtmlPlaceholderDefinition.SourceFormatting Formatting
        {
            get
            {
                string attributeValue = BaseXmlElement.GetAttribute("formatting");
                
                if (attributeValue.Length == 0)
                {
                    return HtmlPlaceholderDefinition.SourceFormatting.NoFormatting;
                }

                foreach (HtmlPlaceholderDefinition.SourceFormatting setting in Enum.GetValues(typeof(HtmlPlaceholderDefinition.SourceFormatting))) 
                {
                    if (String.Compare(setting.ToString(), attributeValue, true) == 0) 
                    {
                        return setting;
                    }
                }

                throw new ArgumentOutOfRangeException("formatting", attributeValue, "The value in the formatting attribute of  <" + BaseXmlElement.Name + "> must match a member of the HtmlPlaceholderDefinition.SourceFormatting enumeration.");
            }
        }

        public bool MustUseResourceGallery
        {
            get {return (String.Compare(BaseXmlElement.GetAttribute("mustUseResourceGallery"), "true", true) == 0);}
        }

        public bool UseGeneratedIcon
        {
            get {return (String.Compare(BaseXmlElement.GetAttribute("useGeneratedIcon"), "true", true) == 0);}
        }
                   
        /// <summary>
        /// 
        /// </summary>
        public McmsRunnerStep McmsRunnerStep
        {
            get 
            {
                if (!(Root is McmsRunnerStep))
                {
                    throw new InvalidOperationException("The root step must be McmsRunnerStep for this step to function correctly."); 
                }
                return (McmsRunnerStep) Root;
            }
        }

        protected override void OnExecute()
        {
            CmsApplicationContext cmsContext = McmsRunnerStep.CmsContext;

            TemplateStep templateStep = StepNavigation.GetTemplateAncestorOfStep(this);
            Template template = templateStep.Template;

            HtmlPlaceholderDefinition definition = (HtmlPlaceholderDefinition) template.PlaceholderDefinitions[Name];
            
            // if we still have a null definition at this point, create a new one
            if (definition == null)
            {
                Root.LogMessage(String.Format("Creating HtmlPlaceholderDefinition {0}.", Name));
                definition = (HtmlPlaceholderDefinition) template.CreatePlaceholderDefinition(typeof(HtmlPlaceholderDefinition));
                definition.Name = Name;
                templateStep.Dirty = true;
            }

            if (definition.Description != Description)
            {
                definition.Description = Description;
                templateStep.Dirty = true;
            }

            if (AllowAttachments != definition.AllowAttachments)
            {
                definition.AllowAttachments = AllowAttachments;
                templateStep.Dirty = true;
            }
            
            if (AllowHyperlinks != definition.AllowHyperlinks)
            {
                definition.AllowHyperlinks = AllowHyperlinks;
                templateStep.Dirty = true;
            }
            
            if (AllowImages != definition.AllowImages)
            {
                definition.AllowImages = AllowImages;
                templateStep.Dirty = true;
            }
            
            if (AllowLineBreaks != definition.AllowLineBreaks)
            {
                definition.AllowLineBreaks = AllowLineBreaks;
                templateStep.Dirty = true;
            }
            
            if (Formatting != definition.Formatting)
            {
                definition.Formatting = Formatting;
                templateStep.Dirty = true;
            }
            
            if (MustUseResourceGallery != definition.MustUseResourceGallery)
            {
                definition.MustUseResourceGallery = MustUseResourceGallery;
                templateStep.Dirty = true;
            }
            
            if (UseGeneratedIcon != definition.UseGeneratedIcon)
            {
                definition.UseGeneratedIcon = UseGeneratedIcon;
                templateStep.Dirty = true;
            }
            
            base.OnExecute ();

        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\mcmsrunner\core\TemplateGalleryStep.cs ===
using System;
using System.IO;
using System.Xml;
using System.Management;
using System.Data.SqlClient;

using Microsoft.ContentManagement.Publishing;
using xonline.common.xmlsequencer;

namespace xonline.tools.mcmsrunner.core
{
	/// <summary>
	/// Summary description for TemplateGalleryStep.
	/// </summary>
    [StepElement("TemplateGallery")]
    public class TemplateGalleryStep : StepContainer
	{
        private string name = null;
        private bool dirty = false;
        private TemplateGallery templateGallery = null;

        /// <summary>
        /// 
        /// </summary>
        /// <param name="stepElement"></param>
        /// <param name="parent"></param>
		public TemplateGalleryStep(XmlElement stepElement, StepContainer parent) : base(stepElement, parent)
		{
            name = BaseXmlElement.GetAttribute("name");

            if (name.Length == 0)
            {
                throw new ArgumentException("The name attribute of the " + BaseXmlElement.Name + " element must be specified.", "name");
            }
        }

       public string Name
        {
            get {return name;}
        }

        public string Description
        {
            get {return BaseXmlElement.GetAttribute("description");}
        }

        public bool Dirty
        {
            get {return dirty;}
            set {dirty = value;}
        }

            public TemplateGallery TemplateGallery
        {
            get {return templateGallery;}
        }

        /// <summary>
        /// 
        /// </summary>
        public McmsRunnerStep McmsRunnerStep
        {
            get 
            {
                if (!(Root is McmsRunnerStep))
                {
                    throw new InvalidOperationException("The root step must be McmsRunnerStep for this step to function correctly."); 
                }
                return (McmsRunnerStep) Root;
            }
        }

        protected override void OnExecute()
        {
            CmsApplicationContext cmsContext = McmsRunnerStep.CmsContext;

            TemplateGalleryStep parentGalleryStep = null;

            try
            {
                parentGalleryStep = StepNavigation.GetTemplateGalleryAncestorOfStep(this);
            }
            catch (InvalidOperationException)
            {
                parentGalleryStep = null;
            }

            if (parentGalleryStep == null)
            {
                if (Name.ToLower() == "templates")
                {
                    templateGallery = cmsContext.RootTemplateGallery;
                }
                else
                {
                    throw new InvalidOperationException("The root-most " + BaseXmlElement.Name + " element's name attribute must be set to 'Templates', not '" + Name + "'.");
                }
            }
            else
            {
                templateGallery = parentGalleryStep.TemplateGallery.TemplateGalleries[Name];
            }

            // if we still have a null template Gallery at this point, create a new one
            if (TemplateGallery == null)
            {
                Root.LogMessage(String.Format("Creating template gallery {0}.", Name));
                templateGallery = parentGalleryStep.TemplateGallery.CreateTemplateGallery();
                TemplateGallery.Name = Name;
                Dirty = true;
            }

            if (Description.Length > 0)
            {
                if (TemplateGallery.Description != Description)
                {
                    TemplateGallery.Description = Description;
                    Dirty = true;
                }
            }

            if (Dirty)
            {
                cmsContext.CommitAll();
                Dirty = false;
            }

            // let contained steps execute
            base.OnExecute ();
        }

        protected override void OnAfterExecute()
        {
            CmsApplicationContext cmsContext = McmsRunnerStep.CmsContext;

            if (Dirty)
            {
                cmsContext.CommitAll();
                Dirty = false;
            }

            templateGallery = null;
            base.OnAfterExecute ();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\mcmsrunner\installer\makefile.inc ===
!include $(INETROOT)\build\makefile.inc

#
# special case to work around lack of static linking.
# not using cspp because:
# 1) they are not using the logging service
# 2) some originals are in locations that can't be cspp'd
#

$(_OBJ_DIR)\Tlog.cs : $(BASEDIR)\private\tools\xboxcom\toollib\Tlog.cs
    copy /y $? $@

$(_OBJ_DIR)\HtmlUtl.cs : $(BASEDIR)\private\tools\xboxcom\toollib\HtmlUtl.cs
    copy /y $? $@

$(_OBJ_DIR)\DirList.cs : $(BASEDIR)\private\tools\xboxcom\toollib\Dirlist.cs
    copy /y $? $@

$(_OBJ_DIR)\ImportPosting.cs : $(BASEDIR)\private\tools\xboxcom\XmlToCms\ImportPosting.cs
    copy /y $? $@
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\mcmsrunner\core\TemplateStep.cs ===
using System;
using System.IO;
using System.Xml;
using System.Management;
using System.Data.SqlClient;

using Microsoft.ContentManagement.Publishing;
using xonline.common.xmlsequencer;

namespace xonline.tools.mcmsrunner.core
{
	/// <summary>
	/// Summary description for TemplateStep.
	/// </summary>
    [StepElement("Template")]
    public class TemplateStep : StepContainer
	{
        private string name = null;
        private bool dirty = false;
        private Template template = null;

        /// <summary>
        /// 
        /// </summary>
        /// <param name="stepElement"></param>
        /// <param name="parent"></param>
		public TemplateStep(XmlElement stepElement, StepContainer parent) : base(stepElement, parent)
		{
            name = BaseXmlElement.GetAttribute("name");

            if (name.Length == 0)
            {
                throw new ArgumentException("The name attribute of the " + BaseXmlElement.Name + " element must be specified.", "name");
            }
        }

       public string Name
        {
            get {return name;}
        }

        public string Description
        {
            get {return BaseXmlElement.GetAttribute("description");}
        }

        public string SourceFile
        {
            get {return BaseXmlElement.GetAttribute("sourceFile");}
        }

        public bool Dirty
        {
            get {return dirty;}
            set {dirty = value;}
        }

        public Template Template
        {
            get {return template;}
        }

        /// <summary>
        /// 
        /// </summary>
        public McmsRunnerStep McmsRunnerStep
        {
            get 
            {
                if (!(Root is McmsRunnerStep))
                {
                    throw new InvalidOperationException("The root step must be McmsRunnerStep for this step to function correctly."); 
                }
                return (McmsRunnerStep) Root;
            }
        }

        protected override void OnExecute()
        {
            CmsApplicationContext cmsContext = McmsRunnerStep.CmsContext;

            TemplateGallery parentGallery = StepNavigation.GetTemplateGalleryAncestorOfStep(this).TemplateGallery;
            template = parentGallery.Templates[Name];
            
            // if we still have a null template at this point, create a new one
            if (Template == null)
            {
                Root.LogMessage(String.Format("Creating template {0}.", Name));
                template = parentGallery.CreateTemplate();
                Template.Name = Name;
                Dirty = true;
            }

            if (Template.Description != Description)
            {
                Template.Description = Description;
                Dirty = true;
            }

            if (Template.SourceFile != SourceFile)
            {
                Template.SourceFile = SourceFile;
                Dirty = true;
            }
            
            // let contained steps execute
            base.OnExecute ();

        }

        protected override void OnAfterExecute()
        {
            CmsApplicationContext cmsContext = McmsRunnerStep.CmsContext;

            if (Dirty)
            {
                template.Submit();
                cmsContext.CommitAll();
                Dirty = false;
            }

            template = null;
            base.OnAfterExecute ();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\mcmsrunner\core\XmlPlaceholderDefinitionStep.cs ===
using System;
using System.IO;
using System.Xml;
using System.Management;
using System.Data.SqlClient;

using Microsoft.ContentManagement.Publishing;
using Microsoft.ContentManagement.Publishing.Extensions.Placeholders;
using xonline.common.xmlsequencer;

namespace xonline.tools.mcmsrunner.core
{
	/// <summary>
	/// Summary description for TemplateStep.
	/// </summary>
	[StepElement("XmlPlaceholderDefinition")]
    public class XmlPlaceholderDefinitionStep : Step
	{
        /// <summary>
        /// 
        /// </summary>
        /// <param name="stepElement"></param>
        /// <param name="parent"></param>
		public XmlPlaceholderDefinitionStep(XmlElement stepElement, StepContainer parent) : base(stepElement, parent)
		{
            if (Name.Length == 0)
            {
                throw new ArgumentException("The name attribute of the " + BaseXmlElement.Name + " element must be specified.", "name");
            }
        }

       public string Name
        {
            get {return BaseXmlElement.GetAttribute("name");}
        }

        public string Description
        {
            get {return BaseXmlElement.GetAttribute("description");}
        }

        public bool CheckForValidity
        {
            get {return (String.Compare(BaseXmlElement.GetAttribute("checkForValidity"), "true", true) == 0);}
        }

        public bool CheckForWellFormedness
        {
            get {return !(String.Compare(BaseXmlElement.GetAttribute("checkForWellFormedness"), "false", true) == 0);}
        }

        public bool ManageCmsUrls
        {
            get {return !(String.Compare(BaseXmlElement.GetAttribute("manageCmsUrls"), "false", true) == 0);}
        }

        public string XsdUrl
        {
            get {return BaseXmlElement.GetAttribute("xsdUrl");}
        }
                   
        /// <summary>
        /// 
        /// </summary>
        public McmsRunnerStep McmsRunnerStep
        {
            get 
            {
                if (!(Root is McmsRunnerStep))
                {
                    throw new InvalidOperationException("The root step must be McmsRunnerStep for this step to function correctly."); 
                }
                return (McmsRunnerStep) Root;
            }
        }

        protected override void OnExecute()
        {
            CmsApplicationContext cmsContext = McmsRunnerStep.CmsContext;

            TemplateStep templateStep = StepNavigation.GetTemplateAncestorOfStep(this);
            Template template = templateStep.Template;

            XmlPlaceholderDefinition definition = (XmlPlaceholderDefinition) template.PlaceholderDefinitions[Name];
            
            // if we still have a null definition at this point, create a new one
            if (definition == null)
            {
                Root.LogMessage(String.Format("Creating XmlPlaceholderDefinition {0}.", Name));
                definition = (XmlPlaceholderDefinition) template.CreatePlaceholderDefinition(typeof(XmlPlaceholderDefinition));
                definition.Name = Name;
                templateStep.Dirty = true;
            }

            if (definition.Description != Description)
            {
                definition.Description = Description;
                templateStep.Dirty = true;
            }

            if (CheckForValidity != definition.CheckForValidity)
            {
                definition.CheckForValidity = CheckForValidity;
                templateStep.Dirty = true;
            }
            
            if (CheckForWellFormedness != definition.CheckForWellFormedness)
            {
                definition.CheckForWellFormedness = CheckForWellFormedness;
                templateStep.Dirty = true;
            }
            
            if (ManageCmsUrls != definition.ManageCmsUrls)
            {
                definition.ManageCmsUrls = ManageCmsUrls;
                templateStep.Dirty = true;
            }
            
            if (XsdUrl != definition.XsdUrl)
            {
                definition.XsdUrl = XsdUrl;
                templateStep.Dirty = true;
            }
                        
            base.OnExecute ();

        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\mcmsrunner\test\McmsRunnerSuite.cs ===
using System;
using System.Xml;
using System.Collections;

using ServerTestFramework;
using xonline.common.diagnostics;

using xonline.tools.mcmsrunner.core;

namespace xonline.tools.mcmsrunner.test
{
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\Mgmt\makefile.inc ===
!include $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\mcmsrunner\test\makefile.inc ===
!include $(INETROOT)\build\makefile.inc

#
# special case to work around lack of static linking.
# not using cspp because:
# 1) they are not using the logging service
# 2) some originals are in locations that can't be cspp'd
#

$(_OBJ_DIR)\Tlog.cs : $(BASEDIR)\private\tools\xboxcom\toollib\Tlog.cs
    copy /y $? $@

$(_OBJ_DIR)\HtmlUtl.cs : $(BASEDIR)\private\tools\xboxcom\toollib\HtmlUtl.cs
    copy /y $? $@

$(_OBJ_DIR)\DirList.cs : $(BASEDIR)\private\tools\xboxcom\toollib\Dirlist.cs
    copy /y $? $@

$(_OBJ_DIR)\ImportPosting.cs : $(BASEDIR)\private\tools\xboxcom\XmlToCms\ImportPosting.cs
    copy /y $? $@
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\mcmsrunner\test\McmsRunnerStepDVT.cs ===
using System;
using System.IO;
using System.Xml;
using System.Data;
using System.Text;
using System.Reflection;
using System.Collections;
using System.Data.SqlClient;

using ServerTestFramework;
using xonline.common.diagnostics;
using xonline.tools.mcmsrunner.core;
using xonline.common.xmlsequencer;

namespace xonline.tools.mcmsrunner.test 
{
	[TestGroup, DVT]
	public class McmsRunnerStepDVT : TestNode
	{    
    
		[TestCase]
		public void Constructor()
		{
			XmlDocument xmlDoc = new XmlDocument();
			xmlDoc.LoadXml("<McmsRunner xmlns=\"http://www.xbox.com/mcmsrunner.xsd\" />");

			Console.WriteLine( "\t\tCheck good values");
			McmsRunnerStep myRunner = new McmsRunnerStep(xmlDoc.DocumentElement);
		}

        [TestCase]
        public void NotMcmsRunnerNamespace()
        {
            XmlDocument xmlDoc = new XmlDocument();
            xmlDoc.LoadXml("<McmsRunner />");

            try
            {
                McmsRunnerStep myRunner = new McmsRunnerStep(xmlDoc.DocumentElement);
                throw new Exception("Expected InvalidOperationException not thrown.");
            }
            catch (InvalidOperationException) {}
        }

	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\Mgmt\Common.cs ===
using System;
using xonline.tools.framework;
using xonline.common.service;
using xonline.common.mgmt;

[assembly: XomAreaDefinition(XomAreaName.tmrlog)]

namespace xonline.tools.mgmt 
{
    public class CommonConst
    {
        public enum TaskType 
        {
            UnknownType = 0, PropNewTitle = 1, PropContentDownload = 2, PropStatsFile =3, 
            PropMatchFile=4, PropAutoUpdate =5, RemoveContent=6 
        }

        public enum State { Completed = 0, Failed = 1, InQueue = 2, InvalidTitle = 3, InvalidPackage = 4, ProcessingNow = 5 };        
    }

    public class CTmrLog: CLog
    {
        
        override protected void WriteLine(int iLevel, string s)
        {
            Xom.Log(XomAreaName.tmrlog, s );
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\Mgmt\projectInstaller.cs ===
//-----------------------------------------------------------------------
//  This file is part of the Microsoft .NET SDK Code Samples.
// 
//  Copyright (C) Microsoft Corporation.  All rights reserved.
// 
//This source code is intended only as a supplement to Microsoft
//Development Tools and/or on-line documentation.  See these other
//materials for detailed information regarding Microsoft code samples.
// 
//THIS CODE AND INFORMATION ARE PROVIDED AS IS WITHOUT WARRANTY OF ANY
//KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
//PARTICULAR PURPOSE.
//-----------------------------------------------------------------------

using System;
using System.Collections;
using System.Configuration.Install;
using System.ServiceProcess;
using System.ComponentModel;

[RunInstallerAttribute(true)]
public class ProjectInstaller: Installer{

	private ServiceInstaller serviceInstaller;
	private ServiceProcessInstaller processInstaller;

	public ProjectInstaller(){

		processInstaller = new ServiceProcessInstaller();
    	serviceInstaller = new ServiceInstaller();

		// Service will run under system account
	//	processInstaller.Account = ServiceAccount.LocalSystem;

		// Service will have Start Type of Manual
        serviceInstaller.StartType = ServiceStartMode.Manual;

		serviceInstaller.ServiceName = "ToolsMgmt";

    	Installers.Add(serviceInstaller);
    	Installers.Add(processInstaller);
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\mcmsrunner\installer\McmsRunnerInstaller.cs ===
using System;
using System.IO;
using System.Xml;
using System.Collections;
using System.Diagnostics;
using System.ComponentModel;
using System.Configuration.Install;

using xonline.tools.mcmsrunner.core;
using xonline.common.xmlsequencer;

namespace xonline.tools.mcmsrunner.installer
{
	/// <summary>
	/// Summary description for McmsRunnerInstaller.
	/// </summary>
	[RunInstaller(true)]
	public class McmsRunnerInstaller : System.Configuration.Install.Installer
	{
        private System.Diagnostics.EventLog eventLog;
		/// <summary>
		/// Required designer variable.
		/// </summary>
		private System.ComponentModel.Container components = null;

		public McmsRunnerInstaller()
		{
			// This call is required by the Designer.
			InitializeComponent();
		}

		/// <summary> 
		/// Clean up any resources being used.
		/// </summary>
		protected override void Dispose( bool disposing )
		{
			if( disposing )
			{
				if(components != null)
				{
					components.Dispose();
				}
			}
			base.Dispose( disposing );
		}

        public override void Install(IDictionary stateSaver)
        {
            base.Install (stateSaver);

            StartMcmsRunner("install");
        }

        public override void Uninstall(IDictionary savedState)
        {
            base.Uninstall (savedState);

            StartMcmsRunner("uninstall");
        }

        public override void Rollback(IDictionary savedState)
        {
            base.Rollback (savedState);

            StartMcmsRunner("rollback");
        }



        private void StartMcmsRunner(string installPhase)
        {
            string message = null;
            string mcmsRunnerFilename = Context.Parameters["runnerFile"];

            try
            {
                if ((mcmsRunnerFilename == null) || (mcmsRunnerFilename.Length == 0))
                {
                    throw new ArgumentException("The runnerFile parameter must be specified. It should contain the path to the McmsRunner definition file.", "runnerFile");
                }

                message = String.Format("McmsRunner started {0} of '{1}' at {2}", installPhase, mcmsRunnerFilename, DateTime.Now.ToString());
                eventLog.WriteEntry(message, EventLogEntryType.Information);
                Context.LogMessage(message);

                XmlDocument xmlDoc = new XmlDocument();
                xmlDoc.Load(mcmsRunnerFilename);

                ConfigurationTransform transform = new ConfigurationTransform();
                
                foreach (DictionaryEntry de in Context.Parameters)
                {
                    transform.OverrideVariableCollection.Set(de.Key.ToString(), de.Value.ToString());
                }
                transform.OverrideVariableCollection.Set("installphase", installPhase);

                transform.TransformDocument(xmlDoc);

                McmsRunnerStep runner = new McmsRunnerStep(xmlDoc.DocumentElement);
                runner.OnMessage += new MessageEventHandler(myRoot_OnMessage);

                runner.Validate();
                runner.Execute();
            }
            catch (Exception ex)
            {
                Context.LogMessage("ERROR: Exception encountered executing McmsRunner. - " + ex.Message);
                Context.LogMessage(ex.ToString());

                message = string.Format("Exception encountered executing McmsRunner: \r\n{0}", ex.ToString());
                eventLog.WriteEntry(message, EventLogEntryType.Error, 65000);
                throw;
            }

            message = String.Format("McmsRunner {0} of '{1}' completed at {2}", installPhase, mcmsRunnerFilename, DateTime.Now.ToString());
            eventLog.WriteEntry(message, EventLogEntryType.Information);
            Context.LogMessage(message);
        }

        /// <summary>
        /// Event handler for McmsRunnerStep's Message event which writes the message to the install context's log.
        /// </summary>
        /// <param name="sender">The McmsRunnerStep generating the event.</param>
        /// <param name="e">The MessageEventArgs sent by the event.</param>
        private void myRoot_OnMessage(object sender, MessageEventArgs e)
        {
            Context.LogMessage(e.Message);
        }


		#region Component Designer generated code
		/// <summary>
		/// Required method for Designer support - do not modify
		/// the contents of this method with the code editor.
		/// </summary>
		private void InitializeComponent()
		{
            this.eventLog = new System.Diagnostics.EventLog();
            ((System.ComponentModel.ISupportInitialize)(this.eventLog)).BeginInit();
            // 
            // eventLog
            // 
            this.eventLog.Log = "Application";
            this.eventLog.Source = "McmsRunner";
            ((System.ComponentModel.ISupportInitialize)(this.eventLog)).EndInit();

        }
		#endregion
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\Mgmt\MgmtUtil.cs ===
using Microsoft.Webstore.WstClient;

using System;
using System.IO;
using System.Data.SqlClient;
using System.Data;

using xonline.common.config;
using xonline.common.service;
using xonline.common.mgmt;
using xonline.tools.framework;

using TaskType = xonline.tools.mgmt.CommonConst.TaskType;
using State = xonline.tools.mgmt.CommonConst.State;

namespace xonline.tools.mgmt 
{
    public struct JobStateInfo
    {
        public uint _jobId;
        public uint _status;
        public uint _hresult;
        public string _logFile;
        public new string ToString()
        {
            string log = _jobId.ToString("X8") + "|"+_status.ToString("X8")+"|"+
                _hresult.ToString("X8") + "|"+_logFile;
            return log;
        }
    }
    public class JobParams
    {
        public uint _jobId;
        public uint _titleId;
        public virtual new string ToString()
        {
            string log = _jobId.ToString("X8") + "|"+_titleId.ToString("X8");
            return log;
        }
    }

    public class StatsJobParams: JobParams
    {
        public string _fileLocation;
        public string _fileName;
        public virtual new string ToString()
        {
            string log = base.ToString()+ "|" +_fileLocation + "|" + _fileName;
            return log;
        }
    }

    public class MatchJobParams: JobParams
    {
        public string _fileLocation;
        public string _fileName;
        public virtual new string ToString()
        {
            string log = base.ToString()+ _fileLocation;
            return log;
        }

    }

    public class AutoUpdateJobParams : StatsJobParams
    {
        public uint _XLastCRC; 
        public uint _version;
        public uint _packageId;
        
        public virtual new string ToString()
        {
            string log = base.ToString()+ "|"+ _XLastCRC.ToString("X8") + "|"+
                _version.ToString("X8")+"|"+_packageId.ToString("X8");
            return log;
        }
    }

    public class RemoveContentJobParams : JobParams
    {
        public uint _offerId;
        public virtual new string ToString()
        {
            string log = base.ToString()+ "|"+ _offerId.ToString("X8");
            return log;
        } 
    }

    public class ContentDownloadJobParams : StatsJobParams
    {
        public uint _offerId;
        public virtual new string ToString()
        {
            string log = base.ToString()+ "|"+ _offerId.ToString("X8");
            return log;
        }
    }

    public class DbHelper
    {
        public JobParams GetNextJob(out TaskType task) 
        {
            SqlConnection sqlCnt = null;
            SqlCommand sqlCmd = null;
            SqlDataReader sqlReader = null;
            JobParams job = null;
            task = TaskType.UnknownType;

            try
            {
                // Open connection
                sqlCnt = new SqlConnection(ConfigUtil.ToolsdbConnectionString);
                sqlCnt.Open();

                // Execute stored procedure
                sqlCmd = new SqlCommand("p_toolsdb_get_job", sqlCnt);
                sqlCmd.CommandType = CommandType.StoredProcedure;

                sqlReader = sqlCmd.ExecuteReader();
                
                if ( sqlReader.Read() && !sqlReader.IsDBNull(0) )
                {
                    task = (TaskType) sqlReader.GetInt32(0);
                    uint _jobId = (uint)sqlReader.GetInt32(1);
                    uint titleId = (uint)sqlReader.GetInt32(2);
                    string fileName = sqlReader.IsDBNull(3)? null : sqlReader.GetString(3);
                    string fileLocation = sqlReader.IsDBNull(4)? null : sqlReader.GetString(4);

                    switch ( task )
                    {
                        case TaskType.PropNewTitle:
                            job = new JobParams();
                            break;
                        case TaskType.PropContentDownload:                            
                            ContentDownloadJobParams jobCont = new ContentDownloadJobParams();
                            jobCont._fileLocation = fileLocation; 
                            jobCont._fileName = fileName;
                            jobCont._offerId = sqlReader.IsDBNull(5)? 0 : ((uint) Convert.ToInt32(sqlReader.GetString(5)));
                            if ( 0 == jobCont._offerId  )
                            {
                                task = TaskType.UnknownType; 
                                Xom.Trace(XomAreaName.ToolsSrv, LogLevel.L_ERROR, "Invalid content download request. Job = " + jobCont.ToString() );
                            }

                            job = jobCont;
                            break;
                        case TaskType.PropStatsFile:                        
                            StatsJobParams jobStats = new StatsJobParams();
                                                                 
                            jobStats._fileLocation = fileLocation;                            
                            jobStats._fileName = fileName;

                            job = jobStats;
                            break;
                                                    
                        case TaskType.PropMatchFile:
                            MatchJobParams jobMatch = new MatchJobParams();
                            jobMatch._fileLocation = fileLocation;
                            jobMatch._fileName = fileName;

                            job = jobMatch;
                            break;

                        case TaskType.PropAutoUpdate:
                            AutoUpdateJobParams jobAutoUp = new AutoUpdateJobParams();

                            jobAutoUp._fileLocation = fileLocation;
                            jobAutoUp._fileName = fileName;

                            jobAutoUp._XLastCRC = sqlReader.IsDBNull(6)? 0 : ((uint) Convert.ToInt32(sqlReader.GetString(6)));
                            jobAutoUp._version =  sqlReader.IsDBNull(7)? 0 : ((uint) Convert.ToInt32(sqlReader.GetString(7)));
                            jobAutoUp._packageId = sqlReader.IsDBNull(8)? 0 : ((uint) Convert.ToInt32(sqlReader.GetString(8)));
                            if ( 0 == jobAutoUp._XLastCRC || 0 == jobAutoUp._version || 0 == jobAutoUp._packageId )
                            {
                                task = TaskType.UnknownType; 
                                Xom.Trace(XomAreaName.ToolsSrv, LogLevel.L_ERROR, "Invalid autoupdate request. Job = " + jobAutoUp.ToString() );
                            }

                            break;
                        case TaskType.RemoveContent:
                            break;
                    }
                    job._jobId = _jobId;
                    job._titleId = titleId;

                    if ( fileLocation == null || fileLocation.Length == 0 ||
                        fileName == null || fileName.Length == 0 )
                    {
                        task = TaskType.UnknownType;                             
                        Xom.Trace(XomAreaName.ToolsSrv, LogLevel.L_ERROR, "Invalid filename or/and fileLocation. Job = " + job.ToString() );
                    }                                            
                }
            }
            catch ( Exception e )
            {
                if(sqlCnt != null)
                {
                    sqlCnt.Close();
                    sqlCnt = null;
                }
                
                job = null;
              Xom.NtEvent( XEvent.Id.TOOLS_COMM_50, " Request (p_toolsdb_get_job) to ToolsDB failed. ConnectionString = " + ConfigUtil.ToolsdbConnectionString + ". Exception " + e.Message );
            }
            finally
            {
                // Release Sql objects
                if(sqlReader != null)
                {
                    sqlReader.Close();
                    sqlReader = null;
                }                               
            }

            return job;
        }

        public void CancelInterruptedJobs()
        {
            
            SqlConnection sqlCnt = null;
            SqlCommand sqlCmd = null;
            SqlDataReader sqlReader = null;
            
            try
            {
                // Open connection
                sqlCnt = new SqlConnection(ConfigUtil.ToolsdbConnectionString);
                sqlCnt.Open();

                // Execute stored procedure
                sqlCmd = new SqlCommand("p_toolsdb_cancel_job", sqlCnt);
                sqlCmd.CommandType = CommandType.StoredProcedure;

                sqlReader = sqlCmd.ExecuteReader();
                if ( sqlReader.RecordsAffected > 0 )
                {
                  Xom.NtEvent( XEvent.Id.TOOLSSRV_TASKS_CANCELED, sqlReader.RecordsAffected + " tasks are in invalid state. Manual cleanup required. Check all the jobs with hresult = 0x" + HResult.TOOLS_SERVER_E_INTERRUPTED_TASK.ToString("X8") );
                }

            }
            catch( Exception e )
            {
                if(sqlCnt != null)
                {
                    sqlCnt.Close();
                    sqlCnt = null;
                }
                                
              Xom.NtEvent( XEvent.Id.TOOLS_COMM_51, " Request (p_toolsdb_cancel_job) to ToolsDB failed. ConnectionString = " + ConfigUtil.ToolsdbConnectionString + ". Exception " + e.Message );
            }
            finally
            {
                // Release Sql objects
                if(sqlReader != null)
                {
                    sqlReader.Close();
                    sqlReader = null;
                }                               
            }
        }
        public void SetJobState(JobStateInfo job) 
        {
            SqlConnection sqlCnt = null;
            SqlCommand sqlCmd = null;
            SqlDataReader sqlReader = null;
           
            try
            {
                // Open connection
                sqlCnt = new SqlConnection(ConfigUtil.ToolsdbConnectionString);
                sqlCnt.Open();

                // Execute stored procedure
                sqlCmd = new SqlCommand( "p_toolsdb_complete_job", sqlCnt );
                sqlCmd.Parameters.Add( "@i_job_status", SqlDbType.Int ).Value = (int) job._status;
                sqlCmd.Parameters.Add( "@i_job_id", SqlDbType.Int ).Value = (int) job._jobId;
                sqlCmd.Parameters.Add( "@i_job_result", SqlDbType.Int ).Value = (int) job._hresult;
                sqlCmd.Parameters.Add( "@vc_log_file", SqlDbType.NVarChar).Value = job._logFile; 

                sqlCmd.CommandType = CommandType.StoredProcedure;

                sqlReader = sqlCmd.ExecuteReader();
            }
            catch ( Exception e )
            {
                if(sqlCnt != null)
                {
                    sqlCnt.Close();
                    sqlCnt = null;
                }
                
              Xom.NtEvent( XEvent.Id.TOOLS_COMM_52, " Request (p_toolsdb_get_job) to ToolsDB failed. ConnectionString = " + ConfigUtil.ToolsdbConnectionString + ". Exception " + e.Message );
                
            }
            finally
            {
                // Release Sql objects
                if(sqlReader != null)
                {
                    sqlReader.Close();
                    sqlReader = null;
                }
                Xom.Trace(XomAreaName.ToolsSrv, LogLevel.L_LOW, "SetJobState: " + job.ToString() );
            }
        }
    }    
    
    interface ITaskHandler
    {
        JobStateInfo DoTask (JobParams p);
    }

    public class StatsTaskHandler : ITaskHandler
    {
        public JobStateInfo DoTask (JobParams p)
        {                          
            ToolsmgmtServiceCounter.Counters.PropStatsFileRequestsTotal.Increment();                
            
            StatsJobParams statsJob = (StatsJobParams) p;
            JobStateInfo state = new JobStateInfo();
            state._jobId = p._jobId;

            try
            {
                CTmrLog log = new CTmrLog();
                CRepository rep = new CRepository( SourceDepotClient.sdPort, SourceDepotClient.sdClient, log );
                CTitleId tid = new CTitleId ( statsJob._titleId ); 
                if (!rep.TitleExists(tid) )
                {
                    throw new Exception("Title does not exist");
                }
            }
            catch (Exception e)
            {
                Xom.Trace(XomAreaName.ToolsSrv, LogLevel.L_ERROR, "Cannot verify titleId. Exception caught: " + e.Message );
                state._hresult = HResult.TOOLS_SERVER_E_INVALID_TITLE_ID;
                goto Cleanup;
            }
            
            string sdFullFileName = null;
            Xom.Trace(XomAreaName.ToolsSrv, LogLevel.L_LOW, "Stats task executing: " + statsJob.ToString());  
            try
            {
                sdFullFileName = SourceDepotClient.SubmitFile ( statsJob._fileName, statsJob._fileLocation, statsJob._titleId, out state._hresult );
            }
            catch ( Exception e )
            {                
                Xom.Trace(XomAreaName.ToolsSrv, LogLevel.L_ERROR, "Failed to submit a file into repository. Exception: "+e.Message + , Inner exception: " +e.InnerException );
                state._hresult = HResult.TOOLS_SERVER_E_SD_SUBMIT_FAILED;                             
                goto Cleanup;
            }            
            
            
            try
            {
                CTmrLog log = new CTmrLog();
                CRepository rep = new CRepository( SourceDepotClient.sdPort, SourceDepotClient.sdClient, log );
                CTitleId tid = new CTitleId ( statsJob._titleId );            
                CXsc xsc = new CXsc ( sdFullFileName, log );
                int lbCount = 0;
                CXscSubmit.Submit ( tid, xsc, rep, false, out lbCount, log );

            }
            catch
            {
                state._hresult = HResult.TOOLS_SERVER_E_TMR_STATS;
                goto Cleanup;
            }

Cleanup:            
            if ( state._hresult != 0 )
            {
                state._status =(uint) State.Failed;
                ToolsmgmtServiceCounter.Counters.PropStatsFileFailedRequestsTotal.Increment();
            }

            return state;
        }
    }

    public class AddTitleTaskHandler : ITaskHandler
    {
        public JobStateInfo DoTask (JobParams p)
        {
            ToolsmgmtServiceCounter.Counters.PropNewTitleRequestsTotal.Increment();      

            JobStateInfo state = new JobStateInfo();
            state._jobId = p._jobId;
            state._hresult = 0;
            return state;
        }
    }

    public class SourceDepotClient
    {
        static SourceDepotClient ()
        {
            _sdPort = Config.GetSetting(Setting.toolsmgmt_SDPort);
            _sdClient = Config.GetSetting(Setting.toolsmgmt_SDClient);
            _sdFilePrefix = Config.GetSetting(Setting.toolsmgmt_filePrefix);
            
            _sd = new SDClient ( _sdClient, _sdPort );
        }

        static public string SubmitFile ( string fileName, string fileLocation, uint titleId, out uint hresult )
        {
            hresult = 0;
            string sdPath = _sd.Root + titleId.ToString("X8") + @"\"+_sdFilePrefix + @"\" ;
            string fullFileName = sdPath + fileName;
            bool isNewFile = false;

            byte [] data = null;
            FileInfo fi1 = new FileInfo( fileLocation );
            if ( fi1.Exists )
            {
                data = new byte[fi1.Length];
                FileStream fsr = new FileStream( fileLocation, FileMode.Open, FileAccess.Read);
                fsr.Read ( data, 0, (int)fi1.Length);
            }
            else
            {
                hresult = HResult.TOOLS_SERVER_E_FILE_NOT_FOUND;
                return null;
            }

            try
            {
                _sd.Edit ( fullFileName );
            }
            catch ( SDClientException e )
            {
                isNewFile = true;
                Xom.Trace(XomAreaName.ToolsSrv, LogLevel.L_ERROR, "Failed to sd edit " + fileName + " exception: " + e.Message );
            }

            Xom.Trace(XomAreaName.ToolsSrv, LogLevel.L_LOW, "SubmitFile: updating repository file = " + fileName + " from location = " + fileLocation + " path = " + sdPath + (isNewFile? ". New file":". File already exists in sd"));
            if (!Directory.Exists( sdPath )) 
            {
                Directory.CreateDirectory(sdPath);
            }
            
            if (File.Exists(fullFileName)) 
            {
                File.Delete(fullFileName);
            }

            // Create the file.
            using (FileStream fs = File.Create( fullFileName )) 
            {
                if ( data != null )
                {
                    fs.Write(data, 0, data.Length);
                }
            }

            if ( isNewFile )
            {
                try
                {
                    _sd.Add ( fullFileName );
                }
                catch ( SDClientException e )
                {
                    hresult = HResult.TOOLS_SERVER_E_SD_ADD_FAILED;
                    Xom.Trace(XomAreaName.ToolsSrv, LogLevel.L_ERROR, "Failed to sd add " + fileName + "exception : " + e.Message );
                    throw e;
                }
            }

            try
            {
                _sd.Submit ( fullFileName, null );
            }
            catch ( SDClientException e )
            {
                Xom.Trace(XomAreaName.ToolsSrv, LogLevel.L_ERROR, "Failed to sd submit. Reverting the changes " + fullFileName + " exception : " + e.Message );
                hresult = HResult.TOOLS_SERVER_E_SD_SUBMIT_FAILED;
                _sd.Revert ( fullFileName );
                throw e;
            }
            return fullFileName;
        }

        static public string sdPort   // the Name property
        {
            get 
            {
                return _sdPort; 
            }
        }

        static public string sdClient
        {
            get
            {
                return _sdClient;
            }
        }
 
        static private string     _sdPort;
        static private string     _sdClient;
        static private string     _sdFilePrefix;
        static private SDClient   _sd;
        

    }

    public class TmrHelper
    {
        static TmrHelper()
        {
            string sdPort = Config.GetSetting(Setting.toolsmgmt_SDPort);
            string sdClient = Config.GetSetting(Setting.toolsmgmt_SDClient);
            CTmrLog log = new CTmrLog();
            CRepository rep = new CRepository( sdPort, sdClient, log );
            
            _tmr = new CTitleMgr( rep, "", "", log );
        }

        public bool Lock()
        {
            string outLock = null;
            try
            {
                return _tmr.Lock( false, out outLock );
            }
            catch ( Exception e )
            {
                Xom.Trace(XomAreaName.ToolsSrv, LogLevel.L_ERROR, " TmrHelper::Lock failed, exception thrown : " + e.Message );                
            }
            return false;
        }

        public void UnLock()
        {
            try
            {
                _tmr.Unlock();
            }
            catch ( Exception e )
            {
              Xom.NtEvent( XEvent.Id.TOOLSSRV_TMR_FILE_UNLOCK_FAILED, "Failed to unlock title manager file. Exception: " + e.Message );
            }
        }

        static private CTitleMgr _tmr;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\Mgmt\PerfCounters.cs ===
using System;
using System.Threading;
using System.Diagnostics;
using xonline.common.service;
using xonline.common.mgmt;

namespace xonline.tools.mgmt 
{
    [XomPerformanceCounterCategoryAttr( "Toolsmgmt Service", "Xbox Live: Tools management service" )]

    public class ToolsmgmtServiceCounter : XomPerformanceCounterCategory
    {
        // PropNewTitle
        [XomPerformanceCounterAttr(
             "PropNewTitle requests total", 
             "Total PropNewTitle requests processed by the server.", 
             PerformanceCounterType.NumberOfItems32)]
        public PerformanceCounter PropNewTitleRequestsTotal;

        [XomPerformanceCounterAttr(
             "PropNewTitle failed requests total", 
             "Total failed PropNewTitle requests processed by the server.", 
             PerformanceCounterType.NumberOfItems32)]
        public PerformanceCounter PropNewTitleFailedRequestsTotal;

        // PropMatchFile
        [XomPerformanceCounterAttr(
             "PropMatchFile requests total", 
             "Total PropMatchFile requests processed by the server.", 
             PerformanceCounterType.NumberOfItems32)]
        public PerformanceCounter PropMatchFileRequestsTotal;

        [XomPerformanceCounterAttr(
             "PropMatchFile failed requests total", 
             "Total failed PropMatchFile processed by the server.", 
             PerformanceCounterType.NumberOfItems32)]
        public PerformanceCounter PropMatchFileFailedRequestsTotal;

        // PropStatsFile
        [XomPerformanceCounterAttr(
             "PropStatsFile requests total", 
             "Total PropStatsFile requests processed by the server.", 
             PerformanceCounterType.NumberOfItems32)]
        public PerformanceCounter PropStatsFileRequestsTotal;

        [XomPerformanceCounterAttr(
             "PropStatsFile failed requests total", 
             "Total failed PropStatsFile requests processed by the server.", 
             PerformanceCounterType.NumberOfItems32)]
        public PerformanceCounter PropStatsFileFailedRequestsTotal;

        // ContentDownloadFileInfo
        [XomPerformanceCounterAttr(
             "PropContentDownload requests total", 
             "Total PropContentDownload requests processed by the server.", 
             PerformanceCounterType.NumberOfItems32)]
        public PerformanceCounter PropContentDownloadRequestsTotal;

        [XomPerformanceCounterAttr(
             "PropContentDownload failed requests total", 
             "Total failed PropContentDownload requests processed by the server.", 
             PerformanceCounterType.NumberOfItems32)]
        public PerformanceCounter PropContentDownloadFailedRequestsTotal;

        //RemoveContent
        [XomPerformanceCounterAttr(
             "RemoveContent requests total", 
             "Total RemoveContent requests processed by the server.", 
             PerformanceCounterType.NumberOfItems32)]
        public PerformanceCounter RemoveContentRequestsTotal;

        [XomPerformanceCounterAttr(
             "RemoveContent failed requests total", 
             "Total failed RemoveContent requests processed by the server.", 
             PerformanceCounterType.NumberOfItems32)]
        public PerformanceCounter RemoveContentFailedRequestsTotal;

        // PropAutoUpdate
        [XomPerformanceCounterAttr(
             "PropAutoUpdate requests total", 
             "Total PropAutoUpdate requests processed by the server", 
             PerformanceCounterType.NumberOfItems32)]
        public PerformanceCounter PropAutoUpdateRequestsTotal;

        [XomPerformanceCounterAttr(
             "PropAutoUpdate failed requests total", 
             "Total failed PropAutoUpdate requests processed by the server.", 
             PerformanceCounterType.NumberOfItems32)]
        public PerformanceCounter PropAutoUpdateFailedRequestsTotal;

        // GetPropHistory
        [XomPerformanceCounterAttr(
             "GetPropHistory requests total", 
             "Total GetPropHistory requests processed by the server.", 
             PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter GetPropHistoryRequestsTotal;


        public virtual ToolsmgmtServiceCounter this[string instanceName]
        {
            get
            {
                return (ToolsmgmtServiceCounter) GetInstance(instanceName);
            }
        }

        static public ToolsmgmtServiceCounter Counters = new ToolsmgmtServiceCounter();
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\Mgmt\Scheduler.cs ===
using System;
using System.Security.Principal;
using System.Threading;

using xonline.common.config;
using xonline.common.service;
using xonline.common.mgmt;

using TaskType = xonline.tools.mgmt.CommonConst.TaskType;
using State = xonline.tools.mgmt.CommonConst.State;

namespace xonline.tools.mgmt 
{
    public class Scheduler
    {

        public void Initialize()
        {
            _dbHelper = new DbHelper();
            _tmr = new TmrHelper();

            CleanupJobs();

            WindowsIdentity id = WindowsIdentity.GetCurrent();
            ThreadPool.QueueUserWorkItem(new WaitCallback(ProcessJobs), id);
            Xom.Trace(XomAreaName.ToolsSrv, LogLevel.L_LOW, "Creating a callback" );
        }

        public void Shutdown()
        {
        }

        private static void ProcessJobs(object o)
        {   
            _pollingIntervalSec = Convert.ToUInt32 (Config.GetSetting(Setting.toolsmgmt_pollingInterval));
            ProcessJobs();
            WindowsIdentity id = ( WindowsIdentity )o;
            ResetTimer(id);
        }

        private static void ResetTimer(WindowsIdentity id)
        {
            try
            {                
                if (_timer == null)
                {
                    _timer = new System.Threading.Timer(new TimerCallback(ProcessJobs), id, _pollingIntervalSec * 1000, Timeout.Infinite);
                }
                else
                {
                    _timer.Change(_pollingIntervalSec * 1000, Timeout.Infinite);
                }
            }
            catch (Exception )
            {
            }
        }

        private static void CleanupJobs()
        {
            _dbHelper.CancelInterruptedJobs();
        }

        private static void ProcessJobs()
        {
            Xom.Trace(XomAreaName.ToolsSrv, LogLevel.L_LOW, "Checking for jobs. Time = " + DateTime.Now );
            TaskType task;
            JobStateInfo info = new JobStateInfo();
            ITaskHandler handle = null;

            if (!_tmr.Lock())
            {
              Xom.NtEvent( XEvent.Id.TOOLSSRV_TMR_FILE_LOCK_FAILED, "Cannot obtain title manager file lock. Processing suspended till next polling." );
            }

            JobParams param = null;
            while (  (param = _dbHelper.GetNextJob(out task))!= null )
            {
                handle = null;
                Xom.Trace(XomAreaName.ToolsSrv, LogLevel.L_LOW, "Processing next job: " + param.ToString() );
                info._jobId = param._jobId;
                switch (task)
                {
                    case TaskType.PropNewTitle:
                        handle = new AddTitleTaskHandler();
                        break;
                    case TaskType.PropContentDownload:
                        break;
                    case TaskType.PropStatsFile:
                        handle = new StatsTaskHandler();
                        break;
                    case TaskType.PropMatchFile:
                        break;
                    case TaskType.PropAutoUpdate:
                        break;
                    case TaskType.RemoveContent:
                        break;
                    case TaskType.UnknownType:
                        info._status =(uint) State.Failed;
                        break;
                }
                try
                {
                    if ( handle != null )
                    {
                        info = handle.DoTask(param);                
                    }
                }
                catch ( Exception e )
                {
                    Xom.Trace(XomAreaName.ToolsSrv, LogLevel.L_ERROR, "Exception caught : " + e.Message );
                    info._status =(uint) State.Failed;
                }

                _dbHelper.SetJobState(info);

                LogJob( param, info );
                
            }
            _tmr.UnLock();
        }
        private static void LogJob ( JobParams param, JobStateInfo info )
        {
            if ( param is StatsJobParams )
            {
                StatsJobParams st = (StatsJobParams) param;
                Xom.Log(XomAreaName.ToolsSrvLog, "TOOLSSRVSTATS|"+ st.ToString() + "|" + info.ToString());
            }
            else if ( param is MatchJobParams )
            {
                MatchJobParams mt = (MatchJobParams) param;
                Xom.Log(XomAreaName.ToolsSrvLog, "TOOLSSRVMTCH|"+ mt.ToString() + "|" + info.ToString());
            }
            else if ( param is AutoUpdateJobParams )
            {
                AutoUpdateJobParams ap = (AutoUpdateJobParams) param;
                Xom.Log(XomAreaName.ToolsSrvLog, "TOOLSSRVAUTOUP|"+ ap.ToString() + "|" + info.ToString());
            }
            else if ( param is ContentDownloadJobParams )
            {
                ContentDownloadJobParams ct = (ContentDownloadJobParams) param;
                Xom.Log(XomAreaName.ToolsSrvLog, "TOOLSSRVCONT|"+ ct.ToString() + "|" + info.ToString());
            }
            else if ( param is RemoveContentJobParams )
            {
                RemoveContentJobParams rt = (RemoveContentJobParams) param;
                Xom.Log(XomAreaName.ToolsSrvLog, "TOOLSSRVRMVCONT|"+ rt.ToString() + "|" + info.ToString());
            }
        }
        private static Timer _timer = null;
        private static DbHelper _dbHelper;
        private static uint _pollingIntervalSec;
        private static TmrHelper _tmr;
        
    } 
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\Mgmt\Service.cs ===
using System;

using System.Collections;
using System.ComponentModel;
using System.Data;
using System.Diagnostics;
using System.ServiceProcess;
using xonline.common.mgmt;
using xonline.common.service;

using System.Threading;
[assembly: XomAreaDefinition(XomAreaName.ToolsSrvLog)]
[assembly: XomAreaDefinition(XomAreaName.ToolsSrv)]




namespace xonline.tools.mgmt 
{
    public class Management : System.ServiceProcess.ServiceBase
    {
        /// <summary> 
        /// Required designer variable.
        /// </summary>
        private System.ComponentModel.Container components = null;

        public Management()
        {
            // This call is required by the Windows.Forms Component Designer.
            InitializeComponent();

            // TODO: Add any initialization after the InitComponent call
        }

    
        /// <summary> 
        /// Required method for Designer support - do not modify 
        /// the contents of this method with the code editor.
        /// </summary>
        private void InitializeComponent()
        {
            // 
            // Management
            // 
            this.ServiceName = "ToolsMgmt";

        }

        /// <summary>
        /// Clean up any resources being used.
        /// </summary>
        protected override void Dispose( bool disposing )
        {
            if( disposing )
            {
                if (components != null) 
                {
                    components.Dispose();
                }
            }
            base.Dispose( disposing );
        }

        /// <summary>
        /// Set things in motion so your service can do its work.
        /// </summary>
        protected override void OnStart(string[] args)
        {
            InitService();
         }
 
        /// <summary>
        /// Stop this service.
        /// </summary>
        protected override void OnStop()
        {
            Xom.Trace(XomAreaName.ToolsSrv, LogLevel.L_LOW, "OnStop: shutting down");
            scheduler.Shutdown();
          Xom.NtEvent( XEvent.Id.TOOLSSRV_SHUTDOWN_COMPLETED, "Tools service has been shutdown" );
        }

        private void InitService()
        {
            XomLoggingControl.Init();
            
            scheduler = new Scheduler();
            scheduler.Initialize();
          Xom.NtEvent( XEvent.Id.TOOLSSRV_STARTUP_COMPLETED, "Tools service has been started" );
        }

        private Scheduler scheduler;
    }
    public class CmdLineManagement
    {
        public CmdLineManagement(string[] args)
        {
            _args = new string[args.Length];
            _args = args;

        }
        public void Run()
        {
            XomLoggingControl.Init();
            
            Scheduler scheduler = new Scheduler();
            scheduler.Initialize();
            Console.WriteLine ( "Running in console app mode. Press any key to terminate the run");

            string line = Console.ReadLine ();           
            Console.WriteLine ( "You chose to terminate the program. Come back soon." );
            
        }
        private string[] _args;

    }

    public class Startup
    {

        // The main entry point for the process
        static void Main(string[] args)
        {
            if (args.Length > 0 && args[0] == "-console")
            {
                RunInCommandLineMode(args);
            }
            else
            {

                Xom.Trace(XomAreaName.ToolsSrv, LogLevel.L_LOW, "Starting management service");
                System.ServiceProcess.ServiceBase.Run(new Management());
            }
        }

        // to run application as a command line exe change the sources file
        // to include UMTYPE=console instead of UMTYPE=windows
        static private void RunInCommandLineMode(string[] args)
        {
            CmdLineManagement cmd = new CmdLineManagement( args );
            cmd.Run();
        }

    }

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\MigrateUser\obj\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("DEPOT")]
[assembly:System.Reflection.AssemblyCopyright("")]
[assembly:System.Reflection.AssemblyCompany("")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\MigrateUser\objd\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("DEPOT")]
[assembly:System.Reflection.AssemblyCopyright("")]
[assembly:System.Reflection.AssemblyCompany("")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\Mgmt\SDClient.cs ===
using System;
using SourceDepotClient;
using System.Collections;
using System.Text;
using System.Threading;
using System.Security.Principal;
using xonline.common.service;

namespace xonline.tools.mgmt 
{
  class SDClient 
    {
        public SDClient( string sdClient, string sdPort )
        {
            _client = sdClient;
            _port = sdPort;

            SDConnectionClass sd = new SDConnectionClass();
            sd.Port = _port;
            sd.Client = _client;
            SDResults res = sd.Run("info",true,true);
            res.WaitUntilFinished();
            
            SDCommandOutputs outputs = res.InfoOutput;
            _root = GetOutParam ( outputs, "Client root: " );      
            
            if ( _root == null )
            {            
                throw new SDClientException ( _client, _port, "Source depot client root could not be found" );
            }
            _root += @"\";
        
        }
        
        public void Revert ( string fileName )
        {
            RunCommand ( fileName, "revert" );
        }
        public void Add ( string fileName )
        {
            RunCommand ( fileName, "add" );
        }

        public void Edit ( string fileName )
        {
            RunCommand ( fileName, "edit" );
        }

        public void Submit ( string fileName, string comment )
        {
            if ( comment == null || comment.Length == 0 )
            {
                comment = "AutoComment";
            }
            string command = "submit -C " + comment;
            
            RunCommand ( fileName, command );
        }

        public string Root
        {
            get { return _root; }
        }

        private void CheckResult ( SDResults res )
        {
            StringBuilder sb = new StringBuilder();    
            SDCommandOutputs outputs = res.ErrorOutput;
            sb.Append ( "Errors\n" );
            sb.Append ( outputs.Count > 0? "":"\tNone\n" );

            foreach (SDCommandOutput output in outputs)
            {
                sb.Append ("\t");
                sb.Append( output.Message );
                sb.Append ("\n");
            }

            outputs = res.WarningOutput;
            sb.Append ( "Warnings\n" );
            sb.Append ( outputs.Count > 0? "":"\tNone\n" );
            foreach (SDCommandOutput output in outputs)
            {
                sb.Append ("\t");
                sb.Append( output.Message );
                sb.Append ("\n");
            }
            
            outputs = res.InfoOutput;
            sb.Append( "Info\n" ); 
            sb.Append ( outputs.Count > 0? "":"\tNone\n" );
            foreach (SDCommandOutput output in outputs)
            {
                sb.Append ( "\t" );
                sb.Append( output.Message );
                sb.Append ( "\n" );
            }
            
            if ( res.ErrorOutput.Count > 0 || res.WarningOutput.Count > 0 )
            {
                throw new SDClientException ( _client, _port, sb.ToString () );
            }
        }

        private void RunCommand ( string fileName, string command )
        {
            SDConnectionClass sd = new SDConnectionClass();
  
            string fullFileName = fileName;
            if ( String.Compare (fileName.Substring( 0, _root.Length ), _root ) != 0 )
            {
                fullFileName = _root + fileName;
            }
            sd.Port = _port;
            sd.Client = _client;
            sd.AddArg( fullFileName );
            
            SDResults res = sd.Run(command ,true, true);
            res.WaitUntilFinished();
            try
            {
                CheckResult ( res );
            }
            catch ( Exception e )
            {
                throw e;
            }
            finally
            {
                sd.Disconnect();
            }
        }

        private string GetOutParam ( SDCommandOutputs outputs, string token )
        {
            string val = null;
            foreach (SDCommandOutput output in outputs)
            {
                val = output.Message;
                if ( String.Compare( val.Substring(0, token.Length), token) == 0 )
                {
                    val = val.Substring(token.Length);                    
                    break;
                }
            }
            return val;
        }

        static private string _client;
        static private string _port;
        static private string _root;
    }

    public class SDClientException : ApplicationException
    {
        public SDClientException ( string client, string port, string res ): base(
            String.Format("Failed to perform a source depot operation:\n---------------\nClient={0}\nPort={1}\n{2}---------------\n",
            client, port, res ))
        {}
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\MigrateOptInFlags\App\MigrateOptInFlags.cs ===
﻿//------------------------------------------------------------------------------
// Copyright (c) Microsoft Corporation.  All rights reserved.
//------------------------------------------------------------------------------
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;
using Microsoft.Webstore.WstClient;
using xonline.common.config;
using xonline.common.sql.webstore;

/// SUMMARY:
/// 
/// Tool used to migrate marketing opt-in flags from LynxProfileDB
/// to UODB.  A separate process generated a list of XUIDs to opt-in
/// for Xbox marketing.  That list is passed as a newline-delimited
/// file to this tool.  Those are found in respective UODB partitions
/// and f_ms_opt_in is set to 1.
/// 
/// Rollback is available as a command line switch and takes the same
/// input file, setting the flag to 0.
/// 
namespace MigrateOptInFlags
{
    static class MigrateOptInFlags
    {
        const string paramNameRollback = "-rollback";
        const string paramNameCautious = "-cautious";
        // To put a cap on the size of a SQL statement, need the max size of a
        // PUID parameter: "'puid', "
        static int xuidSize = UInt64.MaxValue.ToString().Length + 4;
        const int sqlBatchCount = 10000;

        static void Main( string[] args )
        {
            int totalRowsAffected = 0;
            int totalPartitionsAffected = 0;
            bool optIn = true;
            string fileName;
            bool rollback = false;
            bool cautious = false;

            // Collect map of UODB physical partition => Sorted list of user xuids
            // Sort the keys to cluster together for the eventual sql update statement.
            // The values in the sorted list are null, only the keys are used
            Dictionary<int, SortedList<ulong, object>> userPartitionMap = new Dictionary<int, SortedList<ulong, object>>();

            if ( !ParseArgs( args, out fileName, ref rollback, ref cautious ) )
            {
                Console.WriteLine( "Usage:\n\tMigrateOptInFlags <filename> [{0}] [{1}]",
                    paramNameRollback,
                    paramNameCautious );
                return;
            }

            if ( rollback )
            {
                optIn = false;
            }

            using ( WSClient ws = new WSClient( ConfigUtil.UodbWebstoreApp, CmdType.WRITEONLY_COMMANDTYPE ) )
            {
                GetUserPartitionMap( ws, userPartitionMap, fileName );

                PrintUserPartitionMap( userPartitionMap );

                if ( cautious )
                {
                    Console.WriteLine( "Press <Enter> to continue" );
                    Console.ReadLine();
                }

                foreach ( int bucket in userPartitionMap.Keys )
                {
                    int rowsAffected = UpdateUODB( ws, bucket, userPartitionMap[bucket], optIn );
                    Console.WriteLine( "Physical partition {0:D3}... Changed {1:D5} rows", bucket, rowsAffected );
                    totalRowsAffected += rowsAffected;
                    totalPartitionsAffected++;
                }

                Console.WriteLine( "{0} rows affected across {1} physical partitions", totalRowsAffected, totalPartitionsAffected );
            }
        }

        /// <summary>
        /// UpdateUODB
        /// 
        /// Take a sorted list of XUIDs (as ulongs) and update those in one UODB partition.
        /// This uses string concatenation to create a SQL statement, which should be used
        /// with great caution.  At this point, the inputs are stored in ulong, so the risk
        /// of injection is very low.
        /// </summary>
        /// <param name="ws"></param>
        /// <param name="bucket"></param>
        /// <param name="xuidList"></param>
        /// <param name="optIn"></param>
        /// <returns></returns>
        static int UpdateUODB( WSClient ws, int bucket, SortedList<ulong, object> xuidList, bool optIn )
        {
            int rowsAffected = 0;
            StringBuilder sb = new StringBuilder();
            List<string> sqlInputLists = new List<string>();

            // Format XUIDs into long but manageable "'x', 'y', 'z'..." strings
            foreach ( ulong optInXuid in xuidList.Keys )
            {
                sb.AppendFormat( "'{0}', ", optInXuid );
                if ( sb.Length > xuidSize * sqlBatchCount )
                {
                    sqlInputLists.Add( sb.Remove( sb.Length - 2, 2 ).ToString() );
                    sb.Length = 0;
                }
            }
            if ( sb.Length > 0 )
            {
                sqlInputLists.Add( sb.Remove( sb.Length - 2, 2 ).ToString() );
            }

            // Execute all the updates against the partition
            foreach ( string sqlInputList in sqlInputLists )
            {
                string sqlCmd = String.Format(
                    "update t_users set f_ms_opt_in='{0}' where not f_ms_opt_in='{0}' and bi_user_puid in ({1})",
                    optIn ? "1" : "0",
                    sqlInputList );

                ws.ClearParameters();
                ws.PartitionType = WstPartitionType.Physical;
                ws.PhysicalPartition = bucket;
                ws.CommandSql = sqlCmd;
                try
                {
                    // since a new trigger will update the changedtime, each row is affected twice
                    rowsAffected += ws.ExecuteNonQuery() / 2;
                }
                catch ( Exception ex )
                {
                    Console.WriteLine( "ExecuteNonQuery failed: {0}", ex );
                    return rowsAffected;
                }
            }
            return rowsAffected;
        }

        static void PrintUserPartitionMap( Dictionary<int, SortedList<ulong, object>> userPartitionMap )
        {
            StringBuilder sb = new StringBuilder();
            Console.WriteLine( "P:N  -- Physical partition P will have up to N records updated:" );

            int iKey = 1;
            foreach ( int bucket in userPartitionMap.Keys )
            {
                sb.AppendFormat( "{0:D3}:{1:D6} # ", bucket, userPartitionMap[bucket].Count );
                if ( ( iKey ) % 5 == 0 )
                {
                    Console.WriteLine( sb.ToString() );
                    sb.Length = 0;
                }
                iKey++;
            }
            if ( sb.Length > 0 )
            {
                Console.WriteLine( sb.ToString() );
            }
        }

        static void GetUserPartitionMap( WSClient ws, Dictionary<int, SortedList<ulong, object>> userPartitionMap, string fileName )
        {
            using ( StreamReader sr = File.OpenText( fileName ) )
            {
                string xuidFromFile;
                while ( ( xuidFromFile = sr.ReadLine() ) != null )
                {
                    string trimmedXuid = xuidFromFile.Trim();
                    if ( !string.IsNullOrEmpty( trimmedXuid ) )
                    {
                        ulong xuidNum;
                        if (!ulong.TryParse( trimmedXuid, out xuidNum ))
                        {
                            Console.WriteLine( "Input file has bad value: '{0}'", xuidFromFile );
                            continue;
                        }

                        if ( xuidNum > 0 )
                        {
                            int physPart = ws.GetPhysicalPartition( ws.CalcPartition( xuidNum ) );
                            if ( !userPartitionMap.ContainsKey( physPart ) )
                            {
                                userPartitionMap[physPart] = new SortedList<ulong, object>();
                            }
                            // Insert the XUID as a key in the sorted list.  Value is unused
                            userPartitionMap[physPart][xuidNum] = null;
                        }
                    }
                }
            }
        }

        static bool ParseArgs( string[] args, out string fileName, ref bool rollback, ref bool cautious )
        {
            fileName = null;

            for ( int i = 0; i < args.Length; ++i )
            {
                if ( args[i].Equals( paramNameRollback, StringComparison.InvariantCultureIgnoreCase ) )
                {
                    rollback = true;
                }
                else if ( args[i].Equals( paramNameCautious, StringComparison.InvariantCultureIgnoreCase ) )
                {
                    cautious = true;
                }
                else if ( fileName == null )
                {
                    fileName = args[i];
                }
                else
                {
                    return false;
                }
            }
            return ( fileName != null );
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\MiniMaestro\HealthChecks\AboutBox.cs ===
﻿using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Drawing;
using System.Linq;
using System.Reflection;
using System.Windows.Forms;

namespace HealthChecks
{
    partial class AboutBox : Form
    {
        public AboutBox()
        {
            InitializeComponent();
            this.Text = String.Format("About {0} Tool", AssemblyTitle);
            this.labelProductName.Text = AssemblyProduct;
            this.labelVersion.Text = String.Format("Version {0}", AssemblyVersion);
            this.labelCopyright.Text = AssemblyCopyright;
            this.labelCompanyName.Text = AssemblyCompany;
            //this.textBoxDescription.Text = AssemblyDescription;
        }

        #region Assembly Attribute Accessors

        public string AssemblyTitle
        {
            get
            {
                object[] attributes = Assembly.GetExecutingAssembly().GetCustomAttributes(typeof(AssemblyTitleAttribute), false);
                if (attributes.Length > 0)
                {
                    AssemblyTitleAttribute titleAttribute = (AssemblyTitleAttribute)attributes[0];
                    if (titleAttribute.Title != "")
                    {
                        return titleAttribute.Title;
                    }
                }
                return System.IO.Path.GetFileNameWithoutExtension(Assembly.GetExecutingAssembly().CodeBase);
            }
        }

        public string AssemblyVersion
        {
            get
            {
                return Assembly.GetExecutingAssembly().GetName().Version.ToString();
            }
        }

        public string AssemblyDescription
        {
            get
            {
                object[] attributes = Assembly.GetExecutingAssembly().GetCustomAttributes(typeof(AssemblyDescriptionAttribute), false);
                if (attributes.Length == 0)
                {
                    return "";
                }
                return ((AssemblyDescriptionAttribute)attributes[0]).Description;
            }
        }

        public string AssemblyProduct
        {
            get
            {
                object[] attributes = Assembly.GetExecutingAssembly().GetCustomAttributes(typeof(AssemblyProductAttribute), false);
                if (attributes.Length == 0)
                {
                    return "";
                }
                return ((AssemblyProductAttribute)attributes[0]).Product;
            }
        }

        public string AssemblyCopyright
        {
            get
            {
                object[] attributes = Assembly.GetExecutingAssembly().GetCustomAttributes(typeof(AssemblyCopyrightAttribute), false);
                if (attributes.Length == 0)
                {
                    return "";
                }
                return ((AssemblyCopyrightAttribute)attributes[0]).Copyright;
            }
        }

        public string AssemblyCompany
        {
            get
            {
                object[] attributes = Assembly.GetExecutingAssembly().GetCustomAttributes(typeof(AssemblyCompanyAttribute), false);
                if (attributes.Length == 0)
                {
                    return "";
                }
                return ((AssemblyCompanyAttribute)attributes[0]).Company;
            }
        }
        #endregion
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\MigrateOptInFlagsValidate\App\MigrateOptInFlagsValidate.cs ===
﻿using System;
using System.Collections.Generic;
using System.IO;
using System.Text;
using Microsoft.Webstore.WstClient;
using xonline.common.config;
using xonline.common.sql.webstore;
using System.Data.SqlClient;
using System.Diagnostics;


namespace MigrateOptInFlagsValidate
{
    //In case STF not present, this will be a tool to test HCP migration with 4 test cases;
    //This tool is closely coupled with MigrateOptInFlags, and very likely only used for once;
    //For any detailed information, please look into tool MigrateOptInFlags or talk to fejiang.
    class MigrateOptInFlagsValidate
    {
        static string[] testCases = new string[4]{"MigrationSucceed",
                                    "RollbackSucceed",
                                    "MigrationIntegrity",
                                    "RollbackIntegrity"};

        static void Main(string[] args)
        {
            string fileName, progName, testCase;
            if (!ParseArgs(args, out progName, out fileName, out testCase))
            {
                Console.WriteLine("Usage:\n\tMigrateOptInFlagsValidate <migration script name> <filename> <test case name>");
                Console.WriteLine("Usage:\n\tTest case names include 'MigrationSucceed', 'RollbackSucceed','MigrationIntegrity', and 'RollbackIntegrity'.");
                return;
            }

            Dictionary<string, Action<string, string>> actionDic = new Dictionary<string, Action<string, string>>();
            actionDic.Add(testCases[0], MigrationSucceedTest);
            actionDic.Add(testCases[1], RollbackSucceedTest);
            actionDic.Add(testCases[2], MigrationIntegrityTest);
            actionDic.Add(testCases[3], RollbackIntegrityTest);

            if (actionDic[testCase] != null )
            {
                actionDic[testCase](progName, fileName);
            }
            else
            {
                DisplayMessage("Can't find specified test case.");
                return;
            }
            return;
        }

        private static void MigrationSucceedTest(string progName, string fileName)
        {
            Dictionary<ulong, bool> dic = LoadUpUserList(fileName);
            RunMigrationScript(progName, fileName);
            ValidateMigration(dic);
        }
        private static void RollbackSucceedTest(string progName, string fileName)
        {
            Dictionary<ulong, bool> dic = LoadUpUserList(fileName);
            RunRollBackScript(progName, fileName);
            ValidateRollBack(dic);
        }
        private static void MigrationIntegrityTest(string progName, string fileName)
        {
            DateTime time = DateTime.UtcNow;
            Dictionary<ulong, bool> dic = LoadUpUserList(fileName);
            RunMigrationScript(progName, fileName);
            ValidateMigration(dic);
            FindExtraUpdatedUsers(dic, time, (byte)1);
        }
        private static void RollbackIntegrityTest(string progName, string fileName)
        {
            DateTime time = DateTime.UtcNow;
            Dictionary<ulong, bool> dic = LoadUpUserList(fileName);
            RunRollBackScript(progName, fileName);
            ValidateRollBack(dic);
            FindExtraUpdatedUsers(dic, time, (byte)0);
        }
        //Wrapper to make code portable to a standalone exe file out of STF in case needed;
        private static void DisplayMessage(string msg)
        {
            Console.WriteLine(msg);
        }

        private static void DisplayMessageSameLine(string msg, int i)
        {
            Console.WriteLine(msg + " " + i.ToString());
        }

        private static void DisplayWarning(string msg)
        {
            Console.ForegroundColor = ConsoleColor.Yellow;
            Console.WriteLine(msg);
            Console.ResetColor();
        }

        private static ulong ConvertStringToUlong(string str)
        {
            ulong result;
            try
            {
                result = Convert.ToUInt64(str);
                return result;

            }
            catch (OverflowException)
            {
                throw new Exception(string.Format("{0} is outside the range of the UInt64 type.", str));
            }
            catch (FormatException)
            {
                throw new Exception(string.Format("The {0} value '{1}' is not in a recognizable format.",
                                  str.GetType().Name, str));
            }
        }

        private static List<T> GetSortedKeys<T, U>(Dictionary<T, U> table)
        {
            List<T> keys = new List<T>(table.Keys);
            keys.Sort();
            return keys;
        }

        private static Dictionary<ulong, bool> LoadUpUserList(string filePath)
        {
            Dictionary<ulong, bool> dic = new Dictionary<ulong, bool>();
            try
            {
                using (StreamReader sr = new StreamReader(filePath))
                {
                    string line;
                    // Read and display lines from the file until the end of 
                    // the file is reached.
                    while ((line = sr.ReadLine()) != null)
                    {
                        ulong userPuid = ConvertStringToUlong(line);
                        if (!dic.ContainsKey(userPuid))
                        {
                            dic.Add(userPuid, true);
                        }
                    }
                    DisplayMessageSameLine("Total users read-in is ", dic.Keys.Count);
                }
            }
            catch (Exception e)
            {
                // Let the user know what went wrong.
                DisplayMessage(e.Message);
                throw new Exception("The file could not be read.");
            }
            return dic;
        }

        //Run migration script
        private static void RunMigrationScript(string scriptPath, string filePath)
        {
            RunScript(scriptPath, filePath);
        }

        //Run rollback script
        private static void RunRollBackScript(string scriptPath, string filePath)
        {
            RunScript(scriptPath, filePath + " -rollback");
        }


        private static void RunScript(string prog, string arg)
        {
            ProcessStartInfo psi = new ProcessStartInfo(prog);
            {
                psi.RedirectStandardOutput = true;
                psi.Arguments = arg;
                psi.WindowStyle = System.Diagnostics.ProcessWindowStyle.Hidden;
                psi.UseShellExecute = false;
            };
            System.Diagnostics.Process proc = System.Diagnostics.Process.Start(psi);

            using (System.IO.StreamReader sr = proc.StandardOutput)
            {
                string line;
                // Read and display lines from the file until the end of 
                // the file is reached.
                while ((line = sr.ReadLine()) != null)
                {
                    DisplayMessage(line);
                }
            }
            proc.WaitForExit(2000);
        }
  
        private static void ValidateEmailSetting(List<string> list, bool expectedValue)
        {
            foreach (string str in list)
            {
                string sql = "SELECT bi_user_puid, f_ms_opt_in  FROM dbo.t_users where bi_user_puid in " + "(" + str + ")";

                using (WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITETHENREAD_COMMANDTYPE))
                {
                    for (int p = 0; p < ws.PhysicalPartitions; p++)
                    {
                        ws.ClearParameters();
                        ws.PhysicalPartition = p;
                        ws.CommandSql = sql;

                        using (WstDataReader r = ws.Execute())
                        {
                            while (r.Read())
                            {
                                ulong retInt = (ulong)r.GetInt64(0);
                                byte flag = (byte)r.GetByte(1);

                                if (flag != (byte)1 && flag != (byte)0)
                                    DisplayWarning(string.Format("User 0X{0:X} email setting is not 1 or 0, please look into it.", retInt));

                                bool val = (flag == (byte)1) ? true : false;

                                if (val ^ expectedValue)
                                    DisplayWarning(string.Format("User 0X{0:X} email setting is not expected value {1}.", retInt, expectedValue.ToString()));
                            }
                        }
                    }
                }
            }
        }
        //Find out users that are not supposed to be updated;
        //Due to the nature of t_users table(dt_change_datetime doesn't reflect the time of email setting change), 
        //test using this method work in exclusive env, as Xblob, and test manually;
        //After making sure no transaction noise, thsi test can also be run in ANS and ATN;
        private static bool FindExtraUpdatedUsers(Dictionary<ulong, bool> dic, DateTime startTime, byte flagOptIn)
        {
            int failCount = 0;
                string sql = "SELECT bi_user_puid, f_ms_opt_in  FROM dbo.t_users where dt_Change_datetime >= '" + startTime.ToString() + "'";

            using (WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITETHENREAD_COMMANDTYPE))
            {
                for (int p = 0; p < ws.PhysicalPartitions; p++)
                {
                    ws.ClearParameters();
                    ws.PhysicalPartition = p;
                    ws.CommandSql = sql;

                    using (WstDataReader r = ws.Execute())
                    {
                        while (r.Read())
                        {
                            ulong retInt = (ulong)r.GetInt64(0);
                            byte flag = (byte)r.GetByte(1);
                            if (!dic.ContainsKey(retInt) && flag == flagOptIn)
                            {
                                failCount++;
                                DisplayWarning(string.Format("Find user {0} with flag {1}; expected to be unchanged after {2}", retInt, flag, startTime.ToString()));
                            }
                        }

                        r.Close();
                    }
                }
            }

            return failCount > 0 ? true : false;
        }

        //Validate migration success;
        private static void ValidateMigration(Dictionary<ulong, bool> dic)
        {
            DisplayMessage("Validating migration result, please wait ...");
            List<string> listOfULong = ConstructSQLQueryString(dic);
            ValidateEmailSetting(listOfULong, true);
            DisplayMessage("Validating migration finished");
        }

        //Validate all users in the list have email setting flag as 0;
        private static void ValidateRollBack(Dictionary<ulong, bool> dic)
        {
            DisplayMessage("Validating rollback result, please wait ...");
            List<string> listOfULong = ConstructSQLQueryString(dic);
            ValidateEmailSetting(listOfULong, false);

            DisplayMessage("Validating rollback finished");
        }

        private static List<string> ConstructSQLQueryString(Dictionary<ulong, bool> dic)
        {
            int sqlBatchSize = 2000;

            List<ulong> keys = GetSortedKeys(dic);
            List<string> sqlInputLists = new List<string>();

            int i = 0;

            while (i < keys.Count)
            {
                int ix = 0;
                StringBuilder sb = new StringBuilder();
                while (ix < sqlBatchSize && i < keys.Count)
                {
                    sb.AppendFormat("'{0}', ", keys[i]);
                    i++;
                    ix++;
                }
                string str = sb.Remove(sb.Length - 2, 2).ToString();
                sqlInputLists.Add(str);
            }

            return sqlInputLists;
        }

        private static bool ParseArgs(string[] args, out string progName, out string fileName, out string testCase)
        {
            if (args.Length != 3)
            {
                progName = null;
                fileName = null;
                testCase = null;

                return false;
            }


            progName = args[0];
            fileName = args[1];
            testCase = args[2];

            if (!File.Exists(progName) || !File.Exists(fileName))
            {
                DisplayWarning("Migration program file or user list file can't be found.");
                return false;
            }

            return (testCase != null);
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\MiniMaestro\HealthChecks\FormHealth.cs ===
﻿using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Data;
using System.Drawing;
using System.Linq;
using System.Text;
using System.Net;
using System.Xml;
using System.Windows.Forms;
using System.IO;
using System.Threading;
using System.Reflection;

namespace HealthChecks
{
    public partial class FormHealthCheck : Form
    {
        static String configFilename = "hcv.config";
        const int configFileSchemaVersion = 1;

        String summaryXml = "";
        String healthDirectory = "";

        List<HealthCheck> currentSystemHealthChecks = new List<HealthCheck>();
        List<ListViewItem> currentSystemHealthChecksItems = new List<ListViewItem>();
        List<ListViewItem> currentServerHealthItems = new List<ListViewItem>();
        Font currentFont;

        HealthChecksManager healthManager;
        int currentHealthCheck = 0;

        public FormHealthCheck()
        {
            InitializeComponent();
            Initialize();
        }

        void Initialize()
        {
            currentFont = new Font("Lucida Console", 8.25F, FontStyle.Regular, GraphicsUnit.Point, ((byte)(0)));
            listViewServers.Font = currentFont;
            listViewComponents.Font = currentFont;
            healthManager = new HealthChecksManager();
            tabControlTabs.SelectedIndex = 1;
            // Start at Server-Wide
            comboBoxComponent.Enabled = false;
            comboBoxPort.Enabled = false;
            textBoxUrl.Enabled = false;
        }

        public void Run(String[] args)
        {
            String npdbServer = "";
            String serverName = "";

            // Process Argument Flags
            for (int n = 0; n < args.Length; n += 2)
            {
                switch (args[n])
                {
                    case "-npdb":
                        npdbServer = args[n + 1];
                        break;
                    case "-server":
                        serverName = args[n + 1];
                        break;
                    case "-summary":
                        summaryXml = args[n + 1];
                        break;
                    case "-output":
                        healthDirectory = args[n + 1];
                        break;
                    default:
                        MessageBox.Show("Unrecognized Argument: " + args[n], "Error");
                        break;
                }
            }
            loadConfig(npdbServer, serverName);

            if (summaryXml != "" || healthDirectory != "")
            {
                currentHealthCheck = 0;
                currentSystemHealthChecks[currentHealthCheck].RequestHealthCheck();
                timerServerWideCheck.Enabled = true;
                progressBar.Value = 0;
            }

            this.ShowDialog();
        }

        private Boolean loadHealthChecksFromServer(String npdbServer)
        {
            if (healthManager.LoadHealthChecks(npdbServer))
            {
                comboBoxServer.Items.Clear();
                comboBoxServer.Items.Add("All Servers");
                listViewServers.Items.Clear();
                currentServerHealthItems.Clear();
                foreach (String server in healthManager.HealthCheckList.Keys)
                {
                    comboBoxServer.Items.Add(server);
                    currentServerHealthItems.Add(listViewServers.Items.Add(server));
                }
                comboBoxServer.SelectedIndex = 0;
                foreach (ListViewItem serverHealthItem in currentServerHealthItems)
                {
                    serverHealthItem.UseItemStyleForSubItems = false;
                    serverHealthItem.SubItems.Add("0", Color.Green, Color.White, currentFont);
                    serverHealthItem.SubItems.Add("0", Color.Green, Color.White, currentFont);
                    serverHealthItem.SubItems.Add("0", Color.Green, Color.White, currentFont);
                    serverHealthItem.SubItems.Add("0 of 0", Color.Green, Color.White, currentFont);
                }
                //foreach (ListViewItem serverHealthItem in currentServerHealthItems)
                //{
                //    foreach (HCService service in healthManager.HealthCheckList[server].Values)
                //    {
                //        comboBoxComponent.Items.Add(service);
                //        foreach (int port in service.Ports)
                //        {
                //            currentSystemHealthChecks.Add(service[port]);
                //            ListViewItem currentItem = listViewComponents.Items.Add(service.Name);
                //            currentItem.Font = listViewComponents.Font;
                //            currentItem.ForeColor = Color.DimGray;
                //            currentItem.SubItems.Add(service[port].URL);
                //            currentItem.SubItems.Add("Unknown");
                //            currentSystemHealthChecksItems.Add(currentItem);
                //        }
                //    }
                //}

                return true;
            }

            return false;
        }

        /// <summary>
        /// Updates URL in TextBox
        /// </summary>
        private void updateURL()
        {
            if (comboBoxServer.SelectedItem != null &&
                comboBoxPort.SelectedItem != null &&
                comboBoxComponent.SelectedItem != null)
            {
                textBoxUrl.Text = ((HCService)comboBoxComponent.SelectedItem)[(int)comboBoxPort.SelectedItem].URL;
            }
        }

        /// <summary>
        /// Loads UI configurations from the config file
        /// </summary>
        private void loadConfig(String npdb, String server)
        {
            if (npdb != "")
            {
                textBoxServer.Text = npdb;
                // Load HealthChecks
                if (loadHealthChecksFromServer(textBoxServer.Text))
                {
                    if (server != "")
                    {
                        comboBoxServer.SelectedItem = server;
                    }
                }
                return;
            }
            else if (File.Exists(configFilename))
            {
                TextReader textRead = new StreamReader(configFilename);
                int configVersion = 0;
                if (int.TryParse(textRead.ReadLine(), out configVersion))
                {
                    if (configFileSchemaVersion == configVersion)
                    {
                        textBoxServer.Text = textRead.ReadLine();
                        // Load HealthChecks
                        if (loadHealthChecksFromServer(textBoxServer.Text))
                        {
                            comboBoxServer.SelectedIndex = int.Parse(textRead.ReadLine());
                            comboBoxComponent.SelectedIndex = int.Parse(textRead.ReadLine());
                            comboBoxPort.SelectedIndex = int.Parse(textRead.ReadLine());
                        }
                    }
                }
                textRead.Close();

                return;
            }

            loadHealthChecksFromServer(textBoxServer.Text);
        }

        /// <summary>
        /// Writes out UI configurations to the config file
        /// </summary>
        private void saveConfig()
        {
            StreamWriter streamWriter = File.CreateText(configFilename);
            streamWriter.WriteLine(configFileSchemaVersion);
            streamWriter.WriteLine(textBoxServer.Text);
            streamWriter.WriteLine(comboBoxServer.SelectedIndex);
            streamWriter.WriteLine(comboBoxComponent.SelectedIndex);
            streamWriter.WriteLine(comboBoxPort.SelectedIndex);
            streamWriter.Close();
        }

        /// <summary>
        /// Writes out the summary XML file
        /// </summary>
        /// <param name="filename">filename</param>
        private void saveSummary(String filename)
        {
            // Write out the embedded summary.xslt file
            Stream s = Assembly.GetExecutingAssembly().GetManifestResourceStream("HealthChecks.summary.xslt");
            XmlDocument summaryXsltFile = new XmlDocument();

            StreamReader reader = new StreamReader(s);
            summaryXsltFile.LoadXml(reader.ReadToEnd());
            reader.Close();

            summaryXsltFile.Save(Path.Combine(Path.GetDirectoryName(filename), "summary.xslt"));

            // Write out the Summary XML
            XmlDocument xmlDoc = new XmlDocument();

            XmlProcessingInstruction summaryPI = xmlDoc.CreateProcessingInstruction("xml-stylesheet", "href='summary.xslt' type='text/xsl'");
            xmlDoc.AppendChild(summaryPI);
            // Create Root Node
            XmlNode rootNode = xmlDoc.CreateElement("HealthCheckResults");
            XmlAttribute healthCheckVersionAttribute = xmlDoc.CreateAttribute("HealthCheckViewerVersion");
            healthCheckVersionAttribute.Value = Application.ProductVersion;
            rootNode.Attributes.Append(healthCheckVersionAttribute);

            XmlNode serverNode = xmlDoc.CreateElement("Server");
            XmlAttribute serverNameAttribute = xmlDoc.CreateAttribute("Name");
            serverNameAttribute.Value = (String)comboBoxServer.SelectedItem;
            serverNode.Attributes.Append(serverNameAttribute);

            if ((String)comboBoxServer.SelectedItem == "All Servers")
            {
                foreach (String server in healthManager.HealthCheckList.Keys)
                {
                    foreach (HCService service in healthManager.HealthCheckList[server].Values)
                    {
                        XmlNode componentNode = xmlDoc.CreateElement("Component");
                        XmlAttribute componentNameAttribute = xmlDoc.CreateAttribute("Name");
                        componentNameAttribute.Value = service.Name;
                        componentNode.Attributes.Append(componentNameAttribute);

                        foreach (int port in service.Ports)
                        {
                            HealthCheck hc = service[port];

                            XmlNode portNode = xmlDoc.CreateElement("Port");
                            XmlAttribute portAttribute = xmlDoc.CreateAttribute("Number");
                            portAttribute.Value = port.ToString();
                            portNode.Attributes.Append(portAttribute);

                            XmlNode urlNode = xmlDoc.CreateElement("Url");
                            urlNode.InnerText = hc.URL;
                            portNode.AppendChild(urlNode);

                            XmlNode statusNode = xmlDoc.CreateElement("Status");
                            statusNode.InnerText = hc.Status.ToString();
                            portNode.AppendChild(statusNode);

                            if (hc.Result != "")
                            {
                                // TODO: Attach link to full result XML
                            }

                            componentNode.AppendChild(portNode);
                        }

                        serverNode.AppendChild(componentNode);
                    }
                }
            }
            else
            {
                foreach (HCService service in healthManager.HealthCheckList[(String)comboBoxServer.SelectedItem].Values)
                {
                    XmlNode componentNode = xmlDoc.CreateElement("Component");
                    XmlAttribute componentNameAttribute = xmlDoc.CreateAttribute("Name");
                    componentNameAttribute.Value = service.Name;
                    componentNode.Attributes.Append(componentNameAttribute);

                    foreach (int port in service.Ports)
                    {
                        HealthCheck hc = service[port];

                        XmlNode portNode = xmlDoc.CreateElement("Port");
                        XmlAttribute portAttribute = xmlDoc.CreateAttribute("Number");
                        portAttribute.Value = port.ToString();
                        portNode.Attributes.Append(portAttribute);

                        XmlNode urlNode = xmlDoc.CreateElement("Url");
                        urlNode.InnerText = hc.URL;
                        portNode.AppendChild(urlNode);

                        XmlNode statusNode = xmlDoc.CreateElement("Status");
                        statusNode.InnerText = hc.Status.ToString();
                        portNode.AppendChild(statusNode);

                        if (hc.Result != "")
                        {
                            // TODO: Attach link to full result XML
                        }

                        componentNode.AppendChild(portNode);
                    }

                    serverNode.AppendChild(componentNode);
                }
            }
            rootNode.AppendChild(serverNode);

            xmlDoc.AppendChild(rootNode);
            xmlDoc.Save(filename);
        }

        /// <summary>
        /// Save All HealthCheck Results to a Directory
        /// </summary>
        /// <param name="directory">Directory</param>
        private void saveAllResults(String directory)
        {
            Boolean xsltSaved = false;

            if ((String)comboBoxServer.SelectedItem == "All Servers")
            {
                foreach (String server in healthManager.HealthCheckList.Keys)
                {
                    foreach (HCService service in healthManager.HealthCheckList[server].Values)
                    {
                        foreach (int port in service.Ports)
                        {
                            HealthCheck hc = service[port];
                            if (hc.Result != "")
                            {
                                if (!xsltSaved)
                                {
                                    // Request the XSLT file
                                    StringBuilder xsltFile = new StringBuilder();
                                    byte[] buf = new Byte[8192];
                                    HttpWebRequest request = (HttpWebRequest)WebRequest.Create(hc.URL + "?xsl=Default");
                                    HttpWebResponse response = (HttpWebResponse)request.GetResponse();

                                    Stream responseStream = response.GetResponseStream();
                                    String tempString = null;
                                    int count = 0;
                                    do
                                    {
                                        count = responseStream.Read(buf, 0, buf.Length);

                                        if (count != 0)
                                        {
                                            tempString = Encoding.ASCII.GetString(buf, 0, count);
                                            xsltFile.Append(tempString);
                                        }
                                    }
                                    while (count > 0);

                                    File.WriteAllText(Path.Combine(directory, "health.xslt"), xsltFile.ToString());
                                    xsltSaved = true;
                                }
                                XmlDocument xmlDoc = new XmlDocument();
                                xmlDoc.LoadXml(hc.Result);
                                xmlDoc.InnerXml = xmlDoc.InnerXml.Replace("href='health.ashx?xsl=Default'", "href='health.xslt'");
                                xmlDoc.Save(Path.Combine(directory, server + "_" + service.Name + "_" + port + ".xml"));
                            }
                        }
                    }
                }
            }
            else
            {
                foreach (HCService service in healthManager.HealthCheckList[(String)comboBoxServer.SelectedItem].Values)
                {
                    foreach (int port in service.Ports)
                    {
                        HealthCheck hc = service[port];
                        if (hc.Result != "")
                        {
                            if (!xsltSaved)
                            {
                                // Request the XSLT file
                                StringBuilder xsltFile = new StringBuilder();
                                byte[] buf = new Byte[8192];
                                HttpWebRequest request = (HttpWebRequest)WebRequest.Create(hc.URL + "?xsl=Default");
                                HttpWebResponse response = (HttpWebResponse)request.GetResponse();

                                Stream responseStream = response.GetResponseStream();
                                String tempString = null;
                                int count = 0;
                                do
                                {
                                    count = responseStream.Read(buf, 0, buf.Length);

                                    if (count != 0)
                                    {
                                        tempString = Encoding.ASCII.GetString(buf, 0, count);
                                        xsltFile.Append(tempString);
                                    }
                                }
                                while (count > 0);

                                File.WriteAllText(Path.Combine(directory, "health.xslt"), xsltFile.ToString());
                                xsltSaved = true;
                            }
                            XmlDocument xmlDoc = new XmlDocument();
                            xmlDoc.LoadXml(hc.Result);
                            xmlDoc.InnerXml = xmlDoc.InnerXml.Replace("href='health.ashx?xsl=Default'", "href='health.xslt'");
                            xmlDoc.Save(Path.Combine(directory, (String)comboBoxServer.SelectedItem + "_" + service.Name + "_" + port + ".xml"));
                        }
                    }
                }
            }
        }

        private void updateSummaryTotal(HealthCheckStatus status, int n)
        {
            // Run through each health item in the listview and find the one that matches the server name
            String serverName = HCService.ParseServerName(currentSystemHealthChecks[n].URL);
            foreach (ListViewItem serverHealthItem in currentServerHealthItems)
            {
                if (serverHealthItem.Text == serverName)
                {
                    // Retrieve the current R, Y, G counts and then update them according to the status
                    int currentRedCount = int.Parse(serverHealthItem.SubItems[1].Text);
                    int currentYellowCount = int.Parse(serverHealthItem.SubItems[2].Text);
                    int currentGreenCount = int.Parse(serverHealthItem.SubItems[3].Text);

                    switch (status)
                    {
                        case HealthCheckStatus.Good:
                            currentGreenCount++;
                            break;
                        case HealthCheckStatus.Ok:
                            currentYellowCount++;
                            break;
                        case HealthCheckStatus.Failed:
                            currentRedCount++;
                            break;
                        case HealthCheckStatus.NotFound:
                            currentRedCount++;
                            break;
                        case HealthCheckStatus.NoConnection:
                            currentRedCount++;
                            break;
                        case HealthCheckStatus.Unknown:
                            currentRedCount++;
                            break;
                        default:
                            currentRedCount++;
                            break;
                    }

                    serverHealthItem.SubItems[1].Text = currentRedCount.ToString();
                    serverHealthItem.SubItems[2].Text = currentYellowCount.ToString();
                    serverHealthItem.SubItems[3].Text = currentGreenCount.ToString();
                    int totalCount = currentRedCount + currentYellowCount + currentGreenCount;

                    serverHealthItem.SubItems[4].Text = currentGreenCount.ToString() + " of " + totalCount.ToString();
                    if (serverHealthItem.SubItems[1].Text != "0")
                    {
                        // Total should be Red
                        serverHealthItem.SubItems[4].ForeColor = Color.Red;
                    }
                    else if (serverHealthItem.SubItems[2].Text != "0")
                    {
                        // Total should be Yellow
                        serverHealthItem.SubItems[4].ForeColor = Color.Yellow;
                    }
                    else
                    {
                        // Total should be Green
                        serverHealthItem.SubItems[4].ForeColor = Color.Green;
                    }
                }
            }
        }

        #region Event Handlers

        private void comboBoxServer_SelectedIndexChanged(object sender, EventArgs e)
        {
            // Load All Components in currently selected server to the ComboBox and ListView
            comboBoxComponent.Items.Clear();
            listViewComponents.Items.Clear();
            currentSystemHealthChecks.Clear();
            currentSystemHealthChecksItems.Clear();
            if ((String)comboBoxServer.SelectedItem == "All Servers")
            {
                foreach (String server in healthManager.HealthCheckList.Keys)
                {
                    foreach (HCService service in healthManager.HealthCheckList[server].Values)
                    {
                        comboBoxComponent.Items.Add(service);
                        foreach (int port in service.Ports)
                        {
                            currentSystemHealthChecks.Add(service[port]);
                            ListViewItem currentItem = listViewComponents.Items.Add(service.Name);
                            currentItem.Font = listViewComponents.Font;
                            currentItem.ForeColor = Color.DimGray;
                            currentItem.SubItems.Add(service[port].URL);
                            currentItem.SubItems.Add("Unknown");
                            currentSystemHealthChecksItems.Add(currentItem);
                        }
                    }
                }
            }
            else
            {
                foreach (HCService service in healthManager.HealthCheckList[(String)comboBoxServer.SelectedItem].Values)
                {
                    comboBoxComponent.Items.Add(service);
                    foreach (int port in service.Ports)
                    {
                        currentSystemHealthChecks.Add(service[port]);
                        ListViewItem currentItem = listViewComponents.Items.Add(service.Name);
                        currentItem.Font = listViewComponents.Font;
                        currentItem.ForeColor = Color.DimGray;
                        currentItem.SubItems.Add(service[port].URL);
                        currentItem.SubItems.Add("Unknown");
                        currentSystemHealthChecksItems.Add(currentItem);
                    }
                }
            }
            comboBoxComponent.SelectedIndex = 0;
        }

        private void comboBoxComponent_SelectedIndexChanged(object sender, EventArgs e)
        {
            HCService currentService = (HCService)comboBoxComponent.SelectedItem;
            comboBoxPort.Items.Clear();
            foreach (int port in currentService.Ports)
            {
                comboBoxPort.Items.Add(port);
            }
            comboBoxPort.SelectedIndex = 0;

            updateURL();
        }

        private void comboBoxPort_SelectedIndexChanged(object sender, EventArgs e)
        {
            updateURL();
        }

        private void buttonRefresh_Click(object sender, EventArgs e)
        {
            switch (tabControlTabs.SelectedIndex)
            {
                case 0:
                    webBrowser.Navigate(textBoxUrl.Text);
                    timerSingleComponentCheck.Enabled = true;
                    progressBar.Value = 0;
                    break;
                case 1:
                    currentHealthCheck = 0;
                    currentSystemHealthChecks[currentHealthCheck].RequestHealthCheck();
                    timerServerWideCheck.Enabled = true;
                    progressBar.Value = 0;
                    break;
            }
        }

        private void timerSingleComponentCheck_Tick(object sender, EventArgs e)
        {
            switch (tabControlTabs.SelectedIndex)
            {
                case 0:
                    if (webBrowser.ReadyState != WebBrowserReadyState.Complete)
                    {
                        progressBar.Value = (progressBar.Value + 1) % 100;
                    }
                    else
                    {
                        progressBar.Value = 100;
                        timerSingleComponentCheck.Enabled = false;
                    }
                    break;
                default:
                    if (webBrowser.ReadyState == WebBrowserReadyState.Complete)
                    {
                        timerSingleComponentCheck.Enabled = false;
                    }
                    break;
            }
        }

        private void timerServerWideCheck_Tick(object sender, EventArgs e)
        {
            // Loop through all of the current HealthChecks and update status
            //    if non are waiting for response, then we can disable this timer again
            int numberCompleted = 0;
            for (int n = 0; n < currentSystemHealthChecks.Count; n++)
            {
                if (!currentSystemHealthChecks[n].IsWaitingForResponse)
                {
                    if (n == currentHealthCheck)
                    {
                        // TODO: Make it more than 1 request at a time (but not all healthchecks at once)
                        //foreach (HealthCheck hc in currentSystemHealthChecks)
                        //{
                        currentHealthCheck++;
                        if (currentHealthCheck < currentSystemHealthChecks.Count)
                        {
                            currentSystemHealthChecks[currentHealthCheck].RequestHealthCheck();
                        }
                        //}
                    }

                    // Update the status text and the summary totals only if it has not been updated already
                    switch (currentSystemHealthChecks[n].Status)
                    {
                        case HealthCheckStatus.Good:
                            if (currentSystemHealthChecksItems[n].SubItems[2].Text != "Good")
                            {
                                currentSystemHealthChecksItems[n].SubItems[2].Text = "Good";
                                currentSystemHealthChecksItems[n].ForeColor = Color.Green;
                                updateSummaryTotal(currentSystemHealthChecks[n].Status, n);
                            }
                            break;
                        case HealthCheckStatus.Ok:
                            if (currentSystemHealthChecksItems[n].SubItems[2].Text != "Ok")
                            {
                                currentSystemHealthChecksItems[n].SubItems[2].Text = "Ok";
                                currentSystemHealthChecksItems[n].ForeColor = Color.DarkKhaki;
                                updateSummaryTotal(currentSystemHealthChecks[n].Status, n);
                            }
                            break;
                        case HealthCheckStatus.Failed:
                            if (currentSystemHealthChecksItems[n].SubItems[2].Text != "Failed")
                            {
                                currentSystemHealthChecksItems[n].SubItems[2].Text = "Failed";
                                currentSystemHealthChecksItems[n].ForeColor = Color.Red;
                                updateSummaryTotal(currentSystemHealthChecks[n].Status, n);
                            }
                            break;
                        case HealthCheckStatus.NotFound:
                            if (currentSystemHealthChecksItems[n].SubItems[2].Text != "404 Not Found")
                            {
                                currentSystemHealthChecksItems[n].SubItems[2].Text = "404 Not Found";
                                currentSystemHealthChecksItems[n].ForeColor = Color.Brown;
                                updateSummaryTotal(currentSystemHealthChecks[n].Status, n);
                            }
                            break;
                        case HealthCheckStatus.NoConnection:
                            if (currentSystemHealthChecksItems[n].SubItems[2].Text != "No Connection")
                            {
                                currentSystemHealthChecksItems[n].SubItems[2].Text = "No Connection";
                                currentSystemHealthChecksItems[n].ForeColor = Color.DarkGray;
                                updateSummaryTotal(currentSystemHealthChecks[n].Status, n);
                            }
                            break;
                        case HealthCheckStatus.Unknown:
                            if (currentSystemHealthChecksItems[n].SubItems[2].Text != "Unknown")
                            {
                                currentSystemHealthChecksItems[n].SubItems[2].Text = "Unknown";
                                currentSystemHealthChecksItems[n].ForeColor = Color.DimGray;
                                updateSummaryTotal(currentSystemHealthChecks[n].Status, n);
                            }
                            break;
                        default:
                            if (currentSystemHealthChecksItems[n].SubItems[2].Text != "Unrecognized")
                            {
                                currentSystemHealthChecksItems[n].SubItems[2].Text = "Unrecognized";
                                currentSystemHealthChecksItems[n].ForeColor = Color.Black;
                                updateSummaryTotal(currentSystemHealthChecks[n].Status, n);
                            }
                            break;
                    }
                    numberCompleted++;
                }
                else
                {
                    if (currentSystemHealthChecksItems[n].SubItems[2].Text != "Waiting...")
                    {
                        currentSystemHealthChecksItems[n].SubItems[2].Text = "Waiting...";
                        currentSystemHealthChecksItems[n].ForeColor = Color.DimGray;
                    }
                }
            }

            //if (numberCompleted < currentSystemHealthChecks.Count)
            if (currentHealthCheck < currentSystemHealthChecksItems.Count)
            {
                // Update Progress Bar
                progressBar.Value = (100 * currentHealthCheck) / currentSystemHealthChecks.Count;
            }
            else
            {
                // Completed all HealthChecks
                if (summaryXml != "")
                {
                    saveSummary(summaryXml);
                    summaryXml = "";
                }

                if (healthDirectory != "")
                {
                    saveAllResults(healthDirectory);
                    healthDirectory = "";
                }

                switch (tabControlTabs.SelectedIndex)
                {
                    case 1:
                        // Finished!
                        progressBar.Value = 100;
                        timerServerWideCheck.Enabled = false;
                        break;
                    default:
                        timerServerWideCheck.Enabled = false;
                        break;
                }
            }
        }

        private void exitToolStripMenuItem_Click(object sender, EventArgs e)
        {
            this.Close();
        }

        private void FormHealthCheck_FormClosing(object sender, FormClosingEventArgs e)
        {
            saveConfig();
        }

        private void textBoxServer_Leave(object sender, EventArgs e)
        {
            try
            {
                if (textBoxServer.Text.ToLower() != healthManager.NpdbServer.ToLower())
                {
                    loadHealthChecksFromServer(textBoxServer.Text);
                }
            }
            catch (Exception ex)
            {
                MessageBox.Show("Error", "Failed to Load HealthChecks: " + ex.Message);
            }
        }

        private void tabControlTabs_SelectedIndexChanged(object sender, EventArgs e)
        {
            switch (tabControlTabs.SelectedIndex)
            {
                case 0:
                    // Switched to Component-Specific
                    comboBoxComponent.Enabled = true;
                    comboBoxPort.Enabled = true;
                    textBoxUrl.Enabled = true;
                    break;
                case 1:
                    // Switched to Server-Wide
                    comboBoxComponent.Enabled = false;
                    comboBoxPort.Enabled = false;
                    textBoxUrl.Enabled = false;
                    break;
            }
        }

        private void listViewComponents_DoubleClick(object sender, EventArgs e)
        {
            String component = listViewComponents.SelectedItems[0].SubItems[0].Text;
            String url = listViewComponents.SelectedItems[0].SubItems[1].Text;
            int portNumber = HCService.ParsePortNumber(url);

            tabControlTabs.SelectedIndex = 0;
            comboBoxComponent.SelectedItem = healthManager.HealthCheckList[HCService.ParseServerName(url)][component];
            comboBoxPort.SelectedItem = portNumber;

            // Navigate to HealthCheck
            webBrowser.Navigate(textBoxUrl.Text);
            timerSingleComponentCheck.Enabled = true;
            progressBar.Value = 0;
        }

        private void aboutToolStripMenuItem_Click(object sender, EventArgs e)
        {
            AboutBox aboutBox = new AboutBox();
            aboutBox.ShowDialog();
        }

        private void saveResultsSummaryToolStripMenuItem_Click(object sender, EventArgs e)
        {
            SaveFileDialog sfd = new SaveFileDialog();
            sfd.Filter = "Summary XML|*.xml";
            sfd.AddExtension = true;
            sfd.RestoreDirectory = true;
            sfd.Title = "Save Results Summary File";
            if (sfd.ShowDialog() == DialogResult.OK)
            {
                saveSummary(sfd.FileName);
                MessageBox.Show("Saved Successfully!", "Message");
            }
        }

        private void saveAllResultsToDirectoryToolStripMenuItem_Click(object sender, EventArgs e)
        {
            FolderBrowserDialog fbd = new FolderBrowserDialog();

            if (fbd.ShowDialog() == DialogResult.OK)
            {
                if (healthManager.HealthCheckList != null)
                {
                    // Save out the XMLs
                    saveAllResults(fbd.SelectedPath);
                    MessageBox.Show("Saved Successfully!", "Message");
                }
                else
                {
                    MessageBox.Show("No HealthChecks were hit", "Error");
                }
            }
        }

        #endregion
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\MigrateUser\MigrateUserTool.cs ===
/*
 * MigrateUserTool.cs
 *
 * Xbox Live Operations / MigrateUser tool
 *
 * Copyright (c) Microsoft Corporation. All Rights Reserved.
 *
 */

using System;                               // Exception
using System.IO;                            // StreamWriter
using xonline.common.tools.console;         // NamedArgParser
using xonline.common.billing.migrateuser;   // MigrateUser

/* issues:
 * 
 * Doesn't migrate friends or owner live accounts.
 * guaranteed to NOT work if environments have different schema
 * not certain that we have *all* data for a user in uodb
 * bad at "migrating" partner data (passport, billing...)
 * 
 * */

namespace xonline.tools.migrateusertool
{
    public class MigrateUserTool
    {
        #region constants
        public const string ARG_ACTION = "action";
            public const string ACTION_READ = "read";
            public const string ACTION_WRITE = "write";
            public const string ACTION_COPY = "copy";
            public const string ACTION_UTIL = "util";       // undocumented
        public const string ARG_ENSURE = "ensure";          // undocumented
        public const string ARG_GAMERTAG = "gamertag";
        public const string ARG_NEWGAMERTAG = "newGamertag";
        public const string ARG_FILE = "file";
        public const string ARG_HELP_1 = "help";
        public const string ARG_HELP_2 = "?";

        public static readonly string[] ARGS = {ARG_ACTION,
                                                ARG_ENSURE,
                                                ARG_GAMERTAG,
                                                ARG_NEWGAMERTAG,
                                                ARG_FILE,
                                                ARG_HELP_1,
                                                ARG_HELP_2  };
        #endregion

        private class MigrateUserCommand
        {
            public enum CommandType
            {
                Help,
                Read,
                Write,
                Copy,
                Util,
            }

            public readonly CommandType Command = CommandType.Help;
            public readonly string ErrorText = "";
            public readonly string oldGamertag = "";
            public readonly string newGamertag = "";
            public readonly string File = "";
            public readonly bool Ensure = false;

            public MigrateUserCommand(CommandType c)
                : this(c, "", "", false)
            { }

            public MigrateUserCommand(CommandType c, string str1)
                : this(c, str1, "", false)
            { }

            public MigrateUserCommand(CommandType c, string str1, string str2)
                : this(c, str1, str2, false)
            { }

            public MigrateUserCommand(CommandType c, string str1, string str2, bool flag)
            {
                Command = c;

                switch (c)
                {
                    case CommandType.Help:
                        ErrorText = str1;
                        break;

                    case CommandType.Read:
                        oldGamertag = str1;
                        File = str2;
                        Ensure = flag;
                        break;

                    case CommandType.Write:
                        newGamertag = str1;
                        File = str2;
                        break;

                    case CommandType.Copy:
                        oldGamertag = str1;
                        newGamertag = str2;
                        Ensure = flag;
                        break;

                    case CommandType.Util:
                        oldGamertag = str1;
                        break;
                }
            }
        }

        public static void Main(string[] args)
        {
            MigrateUserCommand userCommand = ParseCommandline(args);

            try
            {
                switch (userCommand.Command)
                {
                    case MigrateUserCommand.CommandType.Help:
                        Help(userCommand.ErrorText);
                        break;

                    case MigrateUserCommand.CommandType.Read:
                        Read(userCommand.oldGamertag, userCommand.File, userCommand.Ensure);
                        break;

                    case MigrateUserCommand.CommandType.Write:
                        Write(userCommand.newGamertag, userCommand.File);
                        break;

                    case MigrateUserCommand.CommandType.Copy:
                        Copy(userCommand.oldGamertag, userCommand.newGamertag, userCommand.Ensure);
                        break;

                    case MigrateUserCommand.CommandType.Util:
                        MigrateUser.FindAllInstancesOfUser(userCommand.oldGamertag);
                        break;
                }
            }
            catch (Exception)
            {
                // MigrateUser already printed out any error message to the screen,
                // returning an exception is more useful to support WebMethods than this exe.
                return;
            }
        }

        private static void Copy(string oldGamertag, string newGamertag, bool ensure)
        {
            string userEmail = "", userPassword = "";
            MigrateUser.Copy(oldGamertag, ref newGamertag, ensure, ref userEmail, ref userPassword);
        }

        private static void Write(string newGamertag, string file)
        {
            string userDataXML = "";

            try
            {
                using (StreamReader reader = new StreamReader(file))
                {
                    userDataXML = reader.ReadToEnd();
                }
            }
            catch (Exception e)
            {
                MigrateUser.PrintError("Failed to write xml to file: " + e.Message);
                return;
            }

            string userEmail = "", userPassword = "";
            MigrateUser.Write(ref newGamertag, userDataXML, ref userEmail, ref userPassword);
        }

        private static void Read(string gamertag, string file, bool ensure)
        {
            string userDataXML = MigrateUser.Read(gamertag, ensure);

            try
            {
                using (StreamWriter writer = new StreamWriter(file))
                {
                    writer.Write(userDataXML);
                }
            }
            catch (Exception e)
            {
                MigrateUser.PrintError("Failed to write xml to file: " + e.Message);
                return;
            }
        }

        private static void Help(string errorText)
        {
            MigrateUser.PrintError(errorText);

            MigrateUser.Print(@"
    -- USAGE OPTIONS --

    MigrateUser.exe /" + ARG_ACTION + ":" + ACTION_READ + @" /" + ARG_FILE + @":<fileName> /" + ARG_GAMERTAG + @":<gamertag>

    MigrateUser.exe /" + ARG_ACTION + ":" + ACTION_WRITE + @" /" + ARG_FILE + @":<fileName> [ /" + ARG_GAMERTAG + @":<gamertag> ]

    MigrateUser.exe /" + ARG_ACTION + ":" + ACTION_COPY + @" /" + ARG_GAMERTAG + @":<gamertag> /" + ARG_NEWGAMERTAG + @":<gamertag>

    MigrateUser.exe [ /" + ARG_HELP_1 + @" | /" + ARG_HELP_2 + @" ]

    -- ARGUMENTS --

    /" + ARG_ACTION + ":" + ACTION_READ + @"
        specified action is to read a users data out of the service and save a copy to a file
    
    /" + ARG_ACTION + ":" + ACTION_WRITE + @"
        specified action is to write a users data to the service
    
    /" + ARG_ACTION + ":" + ACTION_COPY + @"
        specified action is to copy an existing user in the current environment

    /" + ARG_GAMERTAG + @":<gamertag>
        specifies the gamertag of the user. if used with /" + ARG_ACTION + ":" + ACTION_READ + @" or /" + ARG_ACTION + ":" + ACTION_COPY + @", specifies what user to read. if used with /" + ARG_ACTION + ":" + ACTION_WRITE + @", renames the user to that gamertag during the write. If this isn't provided for /" + ARG_ACTION + ":" + ACTION_WRITE + @", then a random gamertag is generated.

    /" + ARG_NEWGAMERTAG + @":<gamertag>
        specifies the gamertag of the newly copied user. Used only with /" + ARG_ACTION + ":" + ACTION_COPY + @" to specify the gamertag of the new user. If this isn't provided, then a random gamertag is generated.

    /" + ARG_FILE + @":<fileName>
        specifies the input/output file.

    [ /" + ARG_HELP_1 + @" | /" + ARG_HELP_2 + @" ]
        displays this message.

    -- EXAMPLES --

    MigrateUser.exe /" + ARG_ACTION + ":" + ACTION_READ + @" /" + ARG_GAMERTAG + @":gamertagInWeirdState /" + ARG_FILE + @":C:\UserMigrations\gamertagInWeirdState.txt

    MigrateUser.exe /" + ARG_ACTION + ":" + ACTION_WRITE + @" /" + ARG_GAMERTAG + @":TestUser001 /" + ARG_FILE + @":C:\UserMigrations\gamertagInWeirdState.txt

    MigrateUser.exe /" + ARG_ACTION + ":" + ACTION_COPY + @" /" + ARG_GAMERTAG + @":TestUser /" + ARG_NEWGAMERTAG + @":CopyOfTestUser
");
        }

        private static MigrateUserCommand ParseCommandline(string[] args)
        {
            if (args.Length == 0)
            {
                return new MigrateUserCommand(MigrateUserCommand.CommandType.Help, "No parameters detected!");
            }

            try
            {
                NamedArgParser argParser = new NamedArgParser(ARGS);

                if (!argParser.Parse(args))
                {
                    return new MigrateUserCommand(MigrateUserCommand.CommandType.Help, "Unable to parse commands: " + argParser.InvalidArgText);
                }

                if (argParser[ARG_HELP_1] != null || argParser[ARG_HELP_2] != null)
                {
                    return new MigrateUserCommand(MigrateUserCommand.CommandType.Help);
                }

                if (argParser[ARG_ACTION] == null)
                {
                    return new MigrateUserCommand(MigrateUserCommand.CommandType.Help, "No /" + ARG_ACTION + " flag found!");
                }

                if (argParser[ARG_ACTION].Length == 0)
                {
                    return new MigrateUserCommand(MigrateUserCommand.CommandType.Help, "The action flag /" + ARG_ACTION + " requires an action to be specified.");
                }

                switch(argParser[ARG_ACTION])
                {
                    case ACTION_READ:
                        {
                            if (argParser[ARG_GAMERTAG] == null)
                            {
                                return new MigrateUserCommand(MigrateUserCommand.CommandType.Help, "/" + ARG_ACTION + ":" + ACTION_READ + " requires /" + ARG_GAMERTAG + ":<gamertag>");
                            }
                            else if (argParser[ARG_GAMERTAG].Length == 0)
                            {
                                return new MigrateUserCommand(MigrateUserCommand.CommandType.Help, "/" + ARG_GAMERTAG + " requires ':<gamertag>'");
                            }
                            else if (argParser[ARG_FILE] == null)
                            {
                                return new MigrateUserCommand(MigrateUserCommand.CommandType.Help, "/" + ARG_ACTION + ":" + ACTION_READ + " requires /" + ARG_FILE + ":<fileName>");
                            }
                            else if (argParser[ARG_FILE].Length == 0)
                            {
                                return new MigrateUserCommand(MigrateUserCommand.CommandType.Help, "/" + ARG_FILE + " requires ':<fileName>'");
                            }

                            return new MigrateUserCommand(  MigrateUserCommand.CommandType.Read,
                                                            argParser[ARG_GAMERTAG].Trim(),
                                                            argParser[ARG_FILE].Trim(),
                                                            argParser[ARG_ENSURE] != null);
                        }

                    case ACTION_WRITE:
                        {
                            string newGamertag = "";
                            if (argParser[ARG_FILE] == null)
                            {
                                return new MigrateUserCommand(MigrateUserCommand.CommandType.Help, "/" + ARG_ACTION + ":" + ACTION_WRITE + " requires /" + ARG_FILE + ":<fileName>");
                            }
                            else if (argParser[ARG_FILE].Length == 0)
                            {
                                return new MigrateUserCommand(MigrateUserCommand.CommandType.Help, "/" + ARG_FILE + " requires ':<fileName>'");
                            }
                            if (argParser[ARG_GAMERTAG] != null)
                            {
                                if (argParser[ARG_GAMERTAG].Length == 0)
                                {
                                    return new MigrateUserCommand(MigrateUserCommand.CommandType.Help, "/" + ARG_GAMERTAG + " requires ':<gamertag>'");
                                }

                                newGamertag = argParser[ARG_GAMERTAG].Trim();
                            }

                            return new MigrateUserCommand(  MigrateUserCommand.CommandType.Write,
                                                            newGamertag,
                                                            argParser[ARG_FILE].Trim());
                        }

                    case ACTION_COPY:
                        {
                            string newGamertag = "";
                            if (argParser[ARG_GAMERTAG] == null)
                            {
                                return new MigrateUserCommand(MigrateUserCommand.CommandType.Help, "/" + ARG_ACTION + ":" + ACTION_COPY + " requires /" + ARG_GAMERTAG + ":<gamertag>");
                            }
                            else if (argParser[ARG_GAMERTAG].Length == 0)
                            {
                                return new MigrateUserCommand(MigrateUserCommand.CommandType.Help, "/" + ARG_GAMERTAG + " requires ':<gamertag>'");
                            }
                            if (argParser[ARG_NEWGAMERTAG] != null)
                            {
                                if (argParser[ARG_NEWGAMERTAG].Length == 0)
                                {
                                    return new MigrateUserCommand(MigrateUserCommand.CommandType.Help, "/" + ARG_NEWGAMERTAG + " requires ':<gamertag>'");
                                }

                                newGamertag = argParser[ARG_NEWGAMERTAG].Trim();
                            }

                            return new MigrateUserCommand(MigrateUserCommand.CommandType.Copy,
                                                            argParser[ARG_GAMERTAG].Trim(),
                                                            newGamertag,
                                                            argParser[ARG_ENSURE] != null);
                        }

                    case ACTION_UTIL:
                        {
                            if (argParser[ARG_GAMERTAG] == null)
                            {
                                return new MigrateUserCommand(MigrateUserCommand.CommandType.Help, "/" + ARG_ACTION + ":" + ACTION_UTIL + " requires /" + ARG_GAMERTAG + ":<gamertag>");
                            }
                            else if (argParser[ARG_GAMERTAG].Length == 0)
                            {
                                return new MigrateUserCommand(MigrateUserCommand.CommandType.Help, "/" + ARG_GAMERTAG + " requires ':<gamertag>'");
                            }

                            return new MigrateUserCommand(  MigrateUserCommand.CommandType.Util,
                                                            argParser[ARG_GAMERTAG].Trim());
                        }

                    default:
                        {
                            return new MigrateUserCommand(MigrateUserCommand.CommandType.Help, "Unrecognized action: '" + argParser[ARG_ACTION] + "'");
                        }
                }
            }
            catch (ArgumentException e)
            {
                return new MigrateUserCommand(MigrateUserCommand.CommandType.Help, e.Message);
            }
            catch (Exception e)
            {
                return new MigrateUserCommand(MigrateUserCommand.CommandType.Help, "Caught exception!  " + e.ToString());
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\MiniMaestro\HealthChecks\AboutBox.Designer.cs ===
﻿namespace HealthChecks
{
    partial class AboutBox
    {
        /// <summary>
        /// Required designer variable.
        /// </summary>
        private System.ComponentModel.IContainer components = null;

        /// <summary>
        /// Clean up any resources being used.
        /// </summary>
        protected override void Dispose(bool disposing)
        {
            if (disposing && (components != null))
            {
                components.Dispose();
            }
            base.Dispose(disposing);
        }

        #region Windows Form Designer generated code

        /// <summary>
        /// Required method for Designer support - do not modify
        /// the contents of this method with the code editor.
        /// </summary>
        private void InitializeComponent()
        {
            System.ComponentModel.ComponentResourceManager resources = new System.ComponentModel.ComponentResourceManager(typeof(AboutBox));
            this.tableLayoutPanel = new System.Windows.Forms.TableLayoutPanel();
            this.logoPictureBox = new System.Windows.Forms.PictureBox();
            this.labelProductName = new System.Windows.Forms.Label();
            this.labelVersion = new System.Windows.Forms.Label();
            this.labelCopyright = new System.Windows.Forms.Label();
            this.labelCompanyName = new System.Windows.Forms.Label();
            this.textBoxDescription = new System.Windows.Forms.TextBox();
            this.okButton = new System.Windows.Forms.Button();
            this.tableLayoutPanel.SuspendLayout();
            ((System.ComponentModel.ISupportInitialize)(this.logoPictureBox)).BeginInit();
            this.SuspendLayout();
            // 
            // tableLayoutPanel
            // 
            this.tableLayoutPanel.ColumnCount = 2;
            this.tableLayoutPanel.ColumnStyles.Add(new System.Windows.Forms.ColumnStyle(System.Windows.Forms.SizeType.Percent, 33F));
            this.tableLayoutPanel.ColumnStyles.Add(new System.Windows.Forms.ColumnStyle(System.Windows.Forms.SizeType.Percent, 67F));
            this.tableLayoutPanel.Controls.Add(this.logoPictureBox, 0, 0);
            this.tableLayoutPanel.Controls.Add(this.labelProductName, 1, 0);
            this.tableLayoutPanel.Controls.Add(this.labelVersion, 1, 1);
            this.tableLayoutPanel.Controls.Add(this.labelCopyright, 1, 2);
            this.tableLayoutPanel.Controls.Add(this.labelCompanyName, 1, 3);
            this.tableLayoutPanel.Controls.Add(this.textBoxDescription, 1, 4);
            this.tableLayoutPanel.Controls.Add(this.okButton, 1, 5);
            this.tableLayoutPanel.Dock = System.Windows.Forms.DockStyle.Fill;
            this.tableLayoutPanel.Location = new System.Drawing.Point(9, 9);
            this.tableLayoutPanel.Name = "tableLayoutPanel";
            this.tableLayoutPanel.RowCount = 6;
            this.tableLayoutPanel.RowStyles.Add(new System.Windows.Forms.RowStyle(System.Windows.Forms.SizeType.Percent, 10F));
            this.tableLayoutPanel.RowStyles.Add(new System.Windows.Forms.RowStyle(System.Windows.Forms.SizeType.Percent, 10F));
            this.tableLayoutPanel.RowStyles.Add(new System.Windows.Forms.RowStyle(System.Windows.Forms.SizeType.Percent, 10F));
            this.tableLayoutPanel.RowStyles.Add(new System.Windows.Forms.RowStyle(System.Windows.Forms.SizeType.Percent, 10F));
            this.tableLayoutPanel.RowStyles.Add(new System.Windows.Forms.RowStyle(System.Windows.Forms.SizeType.Percent, 50F));
            this.tableLayoutPanel.RowStyles.Add(new System.Windows.Forms.RowStyle(System.Windows.Forms.SizeType.Percent, 10F));
            this.tableLayoutPanel.Size = new System.Drawing.Size(417, 265);
            this.tableLayoutPanel.TabIndex = 0;
            // 
            // logoPictureBox
            // 
            this.logoPictureBox.Dock = System.Windows.Forms.DockStyle.Fill;
            this.logoPictureBox.Image = ((System.Drawing.Image)(resources.GetObject("logoPictureBox.Image")));
            this.logoPictureBox.Location = new System.Drawing.Point(3, 3);
            this.logoPictureBox.Name = "logoPictureBox";
            this.tableLayoutPanel.SetRowSpan(this.logoPictureBox, 6);
            this.logoPictureBox.Size = new System.Drawing.Size(131, 259);
            this.logoPictureBox.SizeMode = System.Windows.Forms.PictureBoxSizeMode.StretchImage;
            this.logoPictureBox.TabIndex = 12;
            this.logoPictureBox.TabStop = false;
            // 
            // labelProductName
            // 
            this.labelProductName.Dock = System.Windows.Forms.DockStyle.Fill;
            this.labelProductName.Location = new System.Drawing.Point(143, 0);
            this.labelProductName.Margin = new System.Windows.Forms.Padding(6, 0, 3, 0);
            this.labelProductName.MaximumSize = new System.Drawing.Size(0, 17);
            this.labelProductName.Name = "labelProductName";
            this.labelProductName.Size = new System.Drawing.Size(271, 17);
            this.labelProductName.TabIndex = 19;
            this.labelProductName.Text = "Product Name";
            this.labelProductName.TextAlign = System.Drawing.ContentAlignment.MiddleLeft;
            // 
            // labelVersion
            // 
            this.labelVersion.Dock = System.Windows.Forms.DockStyle.Fill;
            this.labelVersion.Location = new System.Drawing.Point(143, 26);
            this.labelVersion.Margin = new System.Windows.Forms.Padding(6, 0, 3, 0);
            this.labelVersion.MaximumSize = new System.Drawing.Size(0, 17);
            this.labelVersion.Name = "labelVersion";
            this.labelVersion.Size = new System.Drawing.Size(271, 17);
            this.labelVersion.TabIndex = 0;
            this.labelVersion.Text = "Version";
            this.labelVersion.TextAlign = System.Drawing.ContentAlignment.MiddleLeft;
            // 
            // labelCopyright
            // 
            this.labelCopyright.Dock = System.Windows.Forms.DockStyle.Fill;
            this.labelCopyright.Location = new System.Drawing.Point(143, 52);
            this.labelCopyright.Margin = new System.Windows.Forms.Padding(6, 0, 3, 0);
            this.labelCopyright.MaximumSize = new System.Drawing.Size(0, 17);
            this.labelCopyright.Name = "labelCopyright";
            this.labelCopyright.Size = new System.Drawing.Size(271, 17);
            this.labelCopyright.TabIndex = 21;
            this.labelCopyright.Text = "Copyright";
            this.labelCopyright.TextAlign = System.Drawing.ContentAlignment.MiddleLeft;
            // 
            // labelCompanyName
            // 
            this.labelCompanyName.Dock = System.Windows.Forms.DockStyle.Fill;
            this.labelCompanyName.Location = new System.Drawing.Point(143, 78);
            this.labelCompanyName.Margin = new System.Windows.Forms.Padding(6, 0, 3, 0);
            this.labelCompanyName.MaximumSize = new System.Drawing.Size(0, 17);
            this.labelCompanyName.Name = "labelCompanyName";
            this.labelCompanyName.Size = new System.Drawing.Size(271, 17);
            this.labelCompanyName.TabIndex = 22;
            this.labelCompanyName.Text = "Company Name";
            this.labelCompanyName.TextAlign = System.Drawing.ContentAlignment.MiddleLeft;
            // 
            // textBoxDescription
            // 
            this.textBoxDescription.Dock = System.Windows.Forms.DockStyle.Fill;
            this.textBoxDescription.Location = new System.Drawing.Point(143, 107);
            this.textBoxDescription.Margin = new System.Windows.Forms.Padding(6, 3, 3, 3);
            this.textBoxDescription.Multiline = true;
            this.textBoxDescription.Name = "textBoxDescription";
            this.textBoxDescription.ReadOnly = true;
            this.textBoxDescription.ScrollBars = System.Windows.Forms.ScrollBars.Both;
            this.textBoxDescription.Size = new System.Drawing.Size(271, 126);
            this.textBoxDescription.TabIndex = 23;
            this.textBoxDescription.TabStop = false;
            this.textBoxDescription.Text = "HealthCheck Viewer Tool\r\n\r\nOptional Flags:\r\n-npdb npdbserver\r\n-server servername\r" +
                "\n-summary output.xml\r\n-output healthDir";
            // 
            // okButton
            // 
            this.okButton.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Right)));
            this.okButton.DialogResult = System.Windows.Forms.DialogResult.Cancel;
            this.okButton.Location = new System.Drawing.Point(339, 239);
            this.okButton.Name = "okButton";
            this.okButton.Size = new System.Drawing.Size(75, 23);
            this.okButton.TabIndex = 24;
            this.okButton.Text = "&OK";
            // 
            // AboutBox
            // 
            this.AcceptButton = this.okButton;
            this.AutoScaleDimensions = new System.Drawing.SizeF(6F, 13F);
            this.AutoScaleMode = System.Windows.Forms.AutoScaleMode.Font;
            this.ClientSize = new System.Drawing.Size(435, 283);
            this.Controls.Add(this.tableLayoutPanel);
            this.FormBorderStyle = System.Windows.Forms.FormBorderStyle.FixedDialog;
            this.MaximizeBox = false;
            this.MinimizeBox = false;
            this.Name = "AboutBox";
            this.Padding = new System.Windows.Forms.Padding(9);
            this.ShowIcon = false;
            this.ShowInTaskbar = false;
            this.StartPosition = System.Windows.Forms.FormStartPosition.CenterParent;
            this.Text = "AboutBox";
            this.tableLayoutPanel.ResumeLayout(false);
            this.tableLayoutPanel.PerformLayout();
            ((System.ComponentModel.ISupportInitialize)(this.logoPictureBox)).EndInit();
            this.ResumeLayout(false);

        }

        #endregion

        private System.Windows.Forms.TableLayoutPanel tableLayoutPanel;
        private System.Windows.Forms.PictureBox logoPictureBox;
        private System.Windows.Forms.Label labelProductName;
        private System.Windows.Forms.Label labelVersion;
        private System.Windows.Forms.Label labelCopyright;
        private System.Windows.Forms.Label labelCompanyName;
        private System.Windows.Forms.TextBox textBoxDescription;
        private System.Windows.Forms.Button okButton;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\MiniMaestro\HealthChecks\objd\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("DEPOT")]
[assembly:System.Reflection.AssemblyCopyright("")]
[assembly:System.Reflection.AssemblyCompany("")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\MiniMaestro\HealthChecks\HealthCheck.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.IO;
using System.Net;
using System.Threading;

namespace HealthChecks
{
    public enum HealthCheckStatus
    {
        Unknown,
        Failed,
        Ok,
        Good,
        Unrecognized,
        NotFound,
        NoConnection,
        TimedOut,
    }

    public class HealthCheck
    {
        String healthURL = "";
        String serverName = "";
        int portNumber = -1;
        HttpWebRequest request = null;
        Boolean waitingOnResponse = false;
        DateTime requestTimestamp = DateTime.MinValue;
        String resultXML = "";
        HealthCheckStatus healthStatus = HealthCheckStatus.Unknown;

        public HealthCheck(String url)
        {
            healthURL = url;
            serverName = HCService.ParseServerName(url);
            portNumber = HCService.ParsePortNumber(url);
        }

        #region Utility Functions

        /// <summary>
        /// Requests this HealthCheck
        /// </summary>
        public void RequestHealthCheck()
        {
            request = (HttpWebRequest)WebRequest.Create(healthURL);

            IAsyncResult result = request.BeginGetResponse(new AsyncCallback(getHealthCheckResponse), null);

            ThreadPool.RegisterWaitForSingleObject(
                result.AsyncWaitHandle,
                new WaitOrTimerCallback(ScanTimeoutCallback), null,
                (30 * 1000),  // 30 second timeout
                true);

            healthStatus = HealthCheckStatus.Unknown;
            waitingOnResponse = true;
        }

        public override string ToString()
        {
            return healthURL;
        }

        #endregion

        #region Private Methods

        /// <summary>
        /// HealthCheck Response Handler
        /// </summary>
        /// <param name="result">Asynchronous Result Object</param>
        private void getHealthCheckResponse(IAsyncResult result)
        {
            StringBuilder healthXML = new StringBuilder();
            byte[] buf = new byte[8192];

            try
            {
                // get the Response
                HttpWebResponse response = (HttpWebResponse)request.EndGetResponse(result);
                // process the response...
                Stream resStream = response.GetResponseStream();

                string tempString = null;
                int count = 0;
                do
                {
                    // fill the buffer with data
                    count = resStream.Read(buf, 0, buf.Length);

                    // make sure we read some data
                    if (count != 0)
                    {
                        // translate from bytes to ASCII text
                        tempString = Encoding.ASCII.GetString(buf, 0, count);

                        // continue building the string
                        healthXML.Append(tempString);
                    }
                }
                while (count > 0);

                resultXML = healthXML.ToString();

                // Set status
                requestTimestamp = DateTime.Now;
                if (resultXML.Contains(@"Server=""" + serverName + @""" HealthStatus=""Green"""))
                {
                    healthStatus = HealthCheckStatus.Good;
                }
                else if (resultXML.Contains(@"Server=""" + serverName + @""" HealthStatus=""Yellow"""))
                {
                    healthStatus = HealthCheckStatus.Ok;
                }
                else if (resultXML.Contains(@"Server=""" + serverName + @""" HealthStatus=""Red"""))
                {
                    healthStatus = HealthCheckStatus.Failed;
                }
                else
                {
                    healthStatus = HealthCheckStatus.Unrecognized;
                }
            }
            catch (WebException ex)
            {
                // Set status
                resultXML = "";
                requestTimestamp = DateTime.Now;
                switch (ex.Status)
                {
                    case WebExceptionStatus.ConnectFailure:
                        healthStatus = HealthCheckStatus.NoConnection;
                        break;
                    case WebExceptionStatus.ProtocolError:
                        healthStatus = HealthCheckStatus.NotFound;
                        // TODO: Add more support here!
                        break;
                    default:
                        healthStatus = HealthCheckStatus.Unrecognized;
                        break;
                }
            }

            waitingOnResponse = false;
        }

        /// <summary>
        /// Timeout Callback
        /// </summary>
        /// <param name="state"></param>
        /// <param name="timedOut"></param>
        private void ScanTimeoutCallback(object state, bool timedOut)
        {
            if (timedOut)
            {
                request.Abort();
                // Set status
                requestTimestamp = DateTime.Now;
                healthStatus = HealthCheckStatus.TimedOut;

                waitingOnResponse = false;
            }
        }

        #endregion

        #region Properties

        public String URL
        {
            get { return healthURL; }
        }

        public HealthCheckStatus Status
        {
            get { return healthStatus; }
        }

        public String Result
        {
            get { return resultXML; }
        }

        public Boolean IsWaitingForResponse
        {
            get { return waitingOnResponse; }
        }

        #endregion
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\MiniMaestro\HealthChecks\FormHealth.Designer.cs ===
﻿namespace HealthChecks
{
    partial class FormHealthCheck
    {
        /// <summary>
        /// Required designer variable.
        /// </summary>
        private System.ComponentModel.IContainer components = null;

        /// <summary>
        /// Clean up any resources being used.
        /// </summary>
        /// <param name="disposing">true if managed resources should be disposed; otherwise, false.</param>
        protected override void Dispose(bool disposing)
        {
            if (disposing && (components != null))
            {
                components.Dispose();
            }
            base.Dispose(disposing);
        }

        #region Windows Form Designer generated code

        /// <summary>
        /// Required method for Designer support - do not modify
        /// the contents of this method with the code editor.
        /// </summary>
        private void InitializeComponent()
        {
            this.components = new System.ComponentModel.Container();
            this.groupBoxHealthCheck = new System.Windows.Forms.GroupBox();
            this.webBrowser = new System.Windows.Forms.WebBrowser();
            this.menuStrip = new System.Windows.Forms.MenuStrip();
            this.fileToolStripMenuItem = new System.Windows.Forms.ToolStripMenuItem();
            this.saveResultsSummaryToolStripMenuItem = new System.Windows.Forms.ToolStripMenuItem();
            this.saveAllResultsToDirectoryToolStripMenuItem = new System.Windows.Forms.ToolStripMenuItem();
            this.exitToolStripMenuItem = new System.Windows.Forms.ToolStripMenuItem();
            this.helpToolStripMenuItem = new System.Windows.Forms.ToolStripMenuItem();
            this.aboutToolStripMenuItem = new System.Windows.Forms.ToolStripMenuItem();
            this.labelServer = new System.Windows.Forms.Label();
            this.textBoxServer = new System.Windows.Forms.TextBox();
            this.comboBoxComponent = new System.Windows.Forms.ComboBox();
            this.labelComponent = new System.Windows.Forms.Label();
            this.buttonRefresh = new System.Windows.Forms.Button();
            this.comboBoxPort = new System.Windows.Forms.ComboBox();
            this.labelPort = new System.Windows.Forms.Label();
            this.textBoxUrl = new System.Windows.Forms.TextBox();
            this.labelUrl = new System.Windows.Forms.Label();
            this.timerSingleComponentCheck = new System.Windows.Forms.Timer(this.components);
            this.progressBar = new System.Windows.Forms.ProgressBar();
            this.label1 = new System.Windows.Forms.Label();
            this.comboBoxServer = new System.Windows.Forms.ComboBox();
            this.tabControlTabs = new System.Windows.Forms.TabControl();
            this.tabPageSingleComponent = new System.Windows.Forms.TabPage();
            this.tabPageServerWide = new System.Windows.Forms.TabPage();
            this.groupBoxResults = new System.Windows.Forms.GroupBox();
            this.listViewComponents = new System.Windows.Forms.ListView();
            this.columnHeaderComponent = new System.Windows.Forms.ColumnHeader();
            this.columnHeaderURL = new System.Windows.Forms.ColumnHeader();
            this.columnHeaderStatus = new System.Windows.Forms.ColumnHeader();
            this.timerServerWideCheck = new System.Windows.Forms.Timer(this.components);
            this.pictureBox1 = new System.Windows.Forms.PictureBox();
            this.tabPage1 = new System.Windows.Forms.TabPage();
            this.groupBoxSummary = new System.Windows.Forms.GroupBox();
            this.listViewServers = new System.Windows.Forms.ListView();
            this.columnHeader1 = new System.Windows.Forms.ColumnHeader();
            this.columnHeader2 = new System.Windows.Forms.ColumnHeader();
            this.columnHeader3 = new System.Windows.Forms.ColumnHeader();
            this.columnHeader4 = new System.Windows.Forms.ColumnHeader();
            this.columnHeader5 = new System.Windows.Forms.ColumnHeader();
            this.groupBoxHealthCheck.SuspendLayout();
            this.menuStrip.SuspendLayout();
            this.tabControlTabs.SuspendLayout();
            this.tabPageSingleComponent.SuspendLayout();
            this.tabPageServerWide.SuspendLayout();
            this.groupBoxResults.SuspendLayout();
            ((System.ComponentModel.ISupportInitialize)(this.pictureBox1)).BeginInit();
            this.tabPage1.SuspendLayout();
            this.groupBoxSummary.SuspendLayout();
            this.SuspendLayout();
            // 
            // groupBoxHealthCheck
            // 
            this.groupBoxHealthCheck.Anchor = ((System.Windows.Forms.AnchorStyles)((((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Bottom)
                        | System.Windows.Forms.AnchorStyles.Left)
                        | System.Windows.Forms.AnchorStyles.Right)));
            this.groupBoxHealthCheck.Controls.Add(this.webBrowser);
            this.groupBoxHealthCheck.Location = new System.Drawing.Point(6, 6);
            this.groupBoxHealthCheck.Name = "groupBoxHealthCheck";
            this.groupBoxHealthCheck.Size = new System.Drawing.Size(580, 410);
            this.groupBoxHealthCheck.TabIndex = 0;
            this.groupBoxHealthCheck.TabStop = false;
            this.groupBoxHealthCheck.Text = "Health";
            // 
            // webBrowser
            // 
            this.webBrowser.Dock = System.Windows.Forms.DockStyle.Fill;
            this.webBrowser.Location = new System.Drawing.Point(3, 16);
            this.webBrowser.MinimumSize = new System.Drawing.Size(20, 20);
            this.webBrowser.Name = "webBrowser";
            this.webBrowser.Size = new System.Drawing.Size(574, 391);
            this.webBrowser.TabIndex = 0;
            // 
            // menuStrip
            // 
            this.menuStrip.Items.AddRange(new System.Windows.Forms.ToolStripItem[] {
            this.fileToolStripMenuItem,
            this.helpToolStripMenuItem});
            this.menuStrip.Location = new System.Drawing.Point(0, 0);
            this.menuStrip.Name = "menuStrip";
            this.menuStrip.Size = new System.Drawing.Size(624, 24);
            this.menuStrip.TabIndex = 1;
            this.menuStrip.Text = "menuStrip1";
            // 
            // fileToolStripMenuItem
            // 
            this.fileToolStripMenuItem.DropDownItems.AddRange(new System.Windows.Forms.ToolStripItem[] {
            this.saveResultsSummaryToolStripMenuItem,
            this.saveAllResultsToDirectoryToolStripMenuItem,
            this.exitToolStripMenuItem});
            this.fileToolStripMenuItem.Name = "fileToolStripMenuItem";
            this.fileToolStripMenuItem.Size = new System.Drawing.Size(37, 20);
            this.fileToolStripMenuItem.Text = "File";
            // 
            // saveResultsSummaryToolStripMenuItem
            // 
            this.saveResultsSummaryToolStripMenuItem.Name = "saveResultsSummaryToolStripMenuItem";
            this.saveResultsSummaryToolStripMenuItem.Size = new System.Drawing.Size(223, 22);
            this.saveResultsSummaryToolStripMenuItem.Text = "Save Results Summary XML";
            this.saveResultsSummaryToolStripMenuItem.Click += new System.EventHandler(this.saveResultsSummaryToolStripMenuItem_Click);
            // 
            // saveAllResultsToDirectoryToolStripMenuItem
            // 
            this.saveAllResultsToDirectoryToolStripMenuItem.Name = "saveAllResultsToDirectoryToolStripMenuItem";
            this.saveAllResultsToDirectoryToolStripMenuItem.Size = new System.Drawing.Size(223, 22);
            this.saveAllResultsToDirectoryToolStripMenuItem.Text = "Save All Results To Directory";
            this.saveAllResultsToDirectoryToolStripMenuItem.Click += new System.EventHandler(this.saveAllResultsToDirectoryToolStripMenuItem_Click);
            // 
            // exitToolStripMenuItem
            // 
            this.exitToolStripMenuItem.Name = "exitToolStripMenuItem";
            this.exitToolStripMenuItem.ShortcutKeys = ((System.Windows.Forms.Keys)((System.Windows.Forms.Keys.Alt | System.Windows.Forms.Keys.F4)));
            this.exitToolStripMenuItem.Size = new System.Drawing.Size(223, 22);
            this.exitToolStripMenuItem.Text = "Exit";
            this.exitToolStripMenuItem.Click += new System.EventHandler(this.exitToolStripMenuItem_Click);
            // 
            // helpToolStripMenuItem
            // 
            this.helpToolStripMenuItem.DropDownItems.AddRange(new System.Windows.Forms.ToolStripItem[] {
            this.aboutToolStripMenuItem});
            this.helpToolStripMenuItem.Name = "helpToolStripMenuItem";
            this.helpToolStripMenuItem.Size = new System.Drawing.Size(44, 20);
            this.helpToolStripMenuItem.Text = "Help";
            // 
            // aboutToolStripMenuItem
            // 
            this.aboutToolStripMenuItem.Name = "aboutToolStripMenuItem";
            this.aboutToolStripMenuItem.Size = new System.Drawing.Size(107, 22);
            this.aboutToolStripMenuItem.Text = "About";
            this.aboutToolStripMenuItem.Click += new System.EventHandler(this.aboutToolStripMenuItem_Click);
            // 
            // labelServer
            // 
            this.labelServer.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Right)));
            this.labelServer.AutoSize = true;
            this.labelServer.Location = new System.Drawing.Point(174, 30);
            this.labelServer.Name = "labelServer";
            this.labelServer.Size = new System.Drawing.Size(40, 13);
            this.labelServer.TabIndex = 2;
            this.labelServer.Text = "NPDB:";
            // 
            // textBoxServer
            // 
            this.textBoxServer.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Right)));
            this.textBoxServer.Location = new System.Drawing.Point(220, 27);
            this.textBoxServer.Name = "textBoxServer";
            this.textBoxServer.Size = new System.Drawing.Size(80, 20);
            this.textBoxServer.TabIndex = 3;
            this.textBoxServer.Text = "localhost";
            this.textBoxServer.Leave += new System.EventHandler(this.textBoxServer_Leave);
            // 
            // comboBoxComponent
            // 
            this.comboBoxComponent.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Right)));
            this.comboBoxComponent.FormattingEnabled = true;
            this.comboBoxComponent.Location = new System.Drawing.Point(244, 53);
            this.comboBoxComponent.Name = "comboBoxComponent";
            this.comboBoxComponent.Size = new System.Drawing.Size(103, 21);
            this.comboBoxComponent.TabIndex = 5;
            this.comboBoxComponent.SelectedIndexChanged += new System.EventHandler(this.comboBoxComponent_SelectedIndexChanged);
            // 
            // labelComponent
            // 
            this.labelComponent.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Right)));
            this.labelComponent.AutoSize = true;
            this.labelComponent.Location = new System.Drawing.Point(174, 56);
            this.labelComponent.Name = "labelComponent";
            this.labelComponent.Size = new System.Drawing.Size(64, 13);
            this.labelComponent.TabIndex = 6;
            this.labelComponent.Text = "Component:";
            // 
            // buttonRefresh
            // 
            this.buttonRefresh.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Right)));
            this.buttonRefresh.Location = new System.Drawing.Point(492, 27);
            this.buttonRefresh.Name = "buttonRefresh";
            this.buttonRefresh.Size = new System.Drawing.Size(117, 48);
            this.buttonRefresh.TabIndex = 7;
            this.buttonRefresh.Text = "Refresh";
            this.buttonRefresh.UseVisualStyleBackColor = true;
            this.buttonRefresh.Click += new System.EventHandler(this.buttonRefresh_Click);
            // 
            // comboBoxPort
            // 
            this.comboBoxPort.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Right)));
            this.comboBoxPort.FormattingEnabled = true;
            this.comboBoxPort.Location = new System.Drawing.Point(412, 53);
            this.comboBoxPort.Name = "comboBoxPort";
            this.comboBoxPort.Size = new System.Drawing.Size(74, 21);
            this.comboBoxPort.TabIndex = 8;
            this.comboBoxPort.SelectedIndexChanged += new System.EventHandler(this.comboBoxPort_SelectedIndexChanged);
            // 
            // labelPort
            // 
            this.labelPort.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Right)));
            this.labelPort.AutoSize = true;
            this.labelPort.Location = new System.Drawing.Point(377, 56);
            this.labelPort.Name = "labelPort";
            this.labelPort.Size = new System.Drawing.Size(29, 13);
            this.labelPort.TabIndex = 9;
            this.labelPort.Text = "Port:";
            // 
            // textBoxUrl
            // 
            this.textBoxUrl.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Right)));
            this.textBoxUrl.Location = new System.Drawing.Point(203, 78);
            this.textBoxUrl.Name = "textBoxUrl";
            this.textBoxUrl.Size = new System.Drawing.Size(283, 20);
            this.textBoxUrl.TabIndex = 10;
            // 
            // labelUrl
            // 
            this.labelUrl.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Right)));
            this.labelUrl.AutoSize = true;
            this.labelUrl.Location = new System.Drawing.Point(174, 81);
            this.labelUrl.Name = "labelUrl";
            this.labelUrl.Size = new System.Drawing.Size(23, 13);
            this.labelUrl.TabIndex = 11;
            this.labelUrl.Text = "Url:";
            // 
            // timerSingleComponentCheck
            // 
            this.timerSingleComponentCheck.Interval = 50;
            this.timerSingleComponentCheck.Tick += new System.EventHandler(this.timerSingleComponentCheck_Tick);
            // 
            // progressBar
            // 
            this.progressBar.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Right)));
            this.progressBar.Location = new System.Drawing.Point(492, 78);
            this.progressBar.Name = "progressBar";
            this.progressBar.Size = new System.Drawing.Size(117, 20);
            this.progressBar.Style = System.Windows.Forms.ProgressBarStyle.Marquee;
            this.progressBar.TabIndex = 12;
            // 
            // label1
            // 
            this.label1.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Right)));
            this.label1.AutoSize = true;
            this.label1.Location = new System.Drawing.Point(306, 30);
            this.label1.Name = "label1";
            this.label1.Size = new System.Drawing.Size(41, 13);
            this.label1.TabIndex = 14;
            this.label1.Text = "Server:";
            // 
            // comboBoxServer
            // 
            this.comboBoxServer.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Right)));
            this.comboBoxServer.FormattingEnabled = true;
            this.comboBoxServer.Location = new System.Drawing.Point(353, 27);
            this.comboBoxServer.Name = "comboBoxServer";
            this.comboBoxServer.Size = new System.Drawing.Size(133, 21);
            this.comboBoxServer.TabIndex = 15;
            this.comboBoxServer.SelectedIndexChanged += new System.EventHandler(this.comboBoxServer_SelectedIndexChanged);
            // 
            // tabControlTabs
            // 
            this.tabControlTabs.Anchor = ((System.Windows.Forms.AnchorStyles)((((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Bottom)
                        | System.Windows.Forms.AnchorStyles.Left)
                        | System.Windows.Forms.AnchorStyles.Right)));
            this.tabControlTabs.Controls.Add(this.tabPageSingleComponent);
            this.tabControlTabs.Controls.Add(this.tabPageServerWide);
            this.tabControlTabs.Controls.Add(this.tabPage1);
            this.tabControlTabs.Location = new System.Drawing.Point(12, 104);
            this.tabControlTabs.Name = "tabControlTabs";
            this.tabControlTabs.SelectedIndex = 0;
            this.tabControlTabs.Size = new System.Drawing.Size(600, 448);
            this.tabControlTabs.TabIndex = 1;
            this.tabControlTabs.SelectedIndexChanged += new System.EventHandler(this.tabControlTabs_SelectedIndexChanged);
            // 
            // tabPageSingleComponent
            // 
            this.tabPageSingleComponent.Controls.Add(this.groupBoxHealthCheck);
            this.tabPageSingleComponent.Location = new System.Drawing.Point(4, 22);
            this.tabPageSingleComponent.Name = "tabPageSingleComponent";
            this.tabPageSingleComponent.Padding = new System.Windows.Forms.Padding(3);
            this.tabPageSingleComponent.Size = new System.Drawing.Size(592, 422);
            this.tabPageSingleComponent.TabIndex = 0;
            this.tabPageSingleComponent.Text = "Single Component Check";
            this.tabPageSingleComponent.UseVisualStyleBackColor = true;
            // 
            // tabPageServerWide
            // 
            this.tabPageServerWide.Controls.Add(this.groupBoxResults);
            this.tabPageServerWide.Location = new System.Drawing.Point(4, 22);
            this.tabPageServerWide.Name = "tabPageServerWide";
            this.tabPageServerWide.Padding = new System.Windows.Forms.Padding(3);
            this.tabPageServerWide.Size = new System.Drawing.Size(592, 422);
            this.tabPageServerWide.TabIndex = 1;
            this.tabPageServerWide.Text = "Server-Wide Check";
            this.tabPageServerWide.UseVisualStyleBackColor = true;
            // 
            // groupBoxResults
            // 
            this.groupBoxResults.Anchor = ((System.Windows.Forms.AnchorStyles)((((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Bottom)
                        | System.Windows.Forms.AnchorStyles.Left)
                        | System.Windows.Forms.AnchorStyles.Right)));
            this.groupBoxResults.Controls.Add(this.listViewComponents);
            this.groupBoxResults.Location = new System.Drawing.Point(7, 7);
            this.groupBoxResults.Name = "groupBoxResults";
            this.groupBoxResults.Size = new System.Drawing.Size(579, 409);
            this.groupBoxResults.TabIndex = 0;
            this.groupBoxResults.TabStop = false;
            this.groupBoxResults.Text = "Results";
            // 
            // listViewComponents
            // 
            this.listViewComponents.Anchor = ((System.Windows.Forms.AnchorStyles)((((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Bottom)
                        | System.Windows.Forms.AnchorStyles.Left)
                        | System.Windows.Forms.AnchorStyles.Right)));
            this.listViewComponents.Columns.AddRange(new System.Windows.Forms.ColumnHeader[] {
            this.columnHeaderComponent,
            this.columnHeaderURL,
            this.columnHeaderStatus});
            this.listViewComponents.FullRowSelect = true;
            this.listViewComponents.GridLines = true;
            this.listViewComponents.Location = new System.Drawing.Point(7, 20);
            this.listViewComponents.MultiSelect = false;
            this.listViewComponents.Name = "listViewComponents";
            this.listViewComponents.Size = new System.Drawing.Size(566, 383);
            this.listViewComponents.TabIndex = 0;
            this.listViewComponents.UseCompatibleStateImageBehavior = false;
            this.listViewComponents.View = System.Windows.Forms.View.Details;
            this.listViewComponents.DoubleClick += new System.EventHandler(this.listViewComponents_DoubleClick);
            // 
            // columnHeaderComponent
            // 
            this.columnHeaderComponent.Text = "Component";
            this.columnHeaderComponent.Width = 100;
            // 
            // columnHeaderURL
            // 
            this.columnHeaderURL.Text = "URL";
            this.columnHeaderURL.Width = 370;
            // 
            // columnHeaderStatus
            // 
            this.columnHeaderStatus.Text = "Status";
            this.columnHeaderStatus.Width = 75;
            // 
            // timerServerWideCheck
            // 
            this.timerServerWideCheck.Interval = 300;
            this.timerServerWideCheck.Tick += new System.EventHandler(this.timerServerWideCheck_Tick);
            // 
            // pictureBox1
            // 
            this.pictureBox1.BorderStyle = System.Windows.Forms.BorderStyle.FixedSingle;
            this.pictureBox1.Image = global::HealthChecks.Properties.Resources.XboxLiveLogo;
            this.pictureBox1.Location = new System.Drawing.Point(12, 27);
            this.pictureBox1.Name = "pictureBox1";
            this.pictureBox1.Size = new System.Drawing.Size(156, 67);
            this.pictureBox1.TabIndex = 13;
            this.pictureBox1.TabStop = false;
            // 
            // tabPage1
            // 
            this.tabPage1.Controls.Add(this.groupBoxSummary);
            this.tabPage1.Location = new System.Drawing.Point(4, 22);
            this.tabPage1.Name = "tabPage1";
            this.tabPage1.Padding = new System.Windows.Forms.Padding(3);
            this.tabPage1.Size = new System.Drawing.Size(592, 422);
            this.tabPage1.TabIndex = 2;
            this.tabPage1.Text = "Servers Summary";
            this.tabPage1.UseVisualStyleBackColor = true;
            // 
            // groupBoxSummary
            // 
            this.groupBoxSummary.Anchor = ((System.Windows.Forms.AnchorStyles)((((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Bottom)
                        | System.Windows.Forms.AnchorStyles.Left)
                        | System.Windows.Forms.AnchorStyles.Right)));
            this.groupBoxSummary.Controls.Add(this.listViewServers);
            this.groupBoxSummary.Location = new System.Drawing.Point(7, 7);
            this.groupBoxSummary.Name = "groupBoxSummary";
            this.groupBoxSummary.Size = new System.Drawing.Size(579, 409);
            this.groupBoxSummary.TabIndex = 1;
            this.groupBoxSummary.TabStop = false;
            this.groupBoxSummary.Text = "Summary";
            // 
            // listViewServers
            // 
            this.listViewServers.Anchor = ((System.Windows.Forms.AnchorStyles)((((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Bottom)
                        | System.Windows.Forms.AnchorStyles.Left)
                        | System.Windows.Forms.AnchorStyles.Right)));
            this.listViewServers.Columns.AddRange(new System.Windows.Forms.ColumnHeader[] {
            this.columnHeader1,
            this.columnHeader2,
            this.columnHeader3,
            this.columnHeader4,
            this.columnHeader5});
            this.listViewServers.FullRowSelect = true;
            this.listViewServers.GridLines = true;
            this.listViewServers.Location = new System.Drawing.Point(7, 20);
            this.listViewServers.MultiSelect = false;
            this.listViewServers.Name = "listViewServers";
            this.listViewServers.Size = new System.Drawing.Size(566, 383);
            this.listViewServers.TabIndex = 0;
            this.listViewServers.UseCompatibleStateImageBehavior = false;
            this.listViewServers.View = System.Windows.Forms.View.Details;
            // 
            // columnHeader1
            // 
            this.columnHeader1.Text = "Server";
            this.columnHeader1.Width = 162;
            // 
            // columnHeader2
            // 
            this.columnHeader2.Text = "Red";
            this.columnHeader2.TextAlign = System.Windows.Forms.HorizontalAlignment.Center;
            this.columnHeader2.Width = 100;
            // 
            // columnHeader3
            // 
            this.columnHeader3.Text = "Yellow";
            this.columnHeader3.TextAlign = System.Windows.Forms.HorizontalAlignment.Center;
            this.columnHeader3.Width = 100;
            // 
            // columnHeader4
            // 
            this.columnHeader4.Text = "Green";
            this.columnHeader4.TextAlign = System.Windows.Forms.HorizontalAlignment.Center;
            this.columnHeader4.Width = 100;
            // 
            // columnHeader5
            // 
            this.columnHeader5.Text = "Total";
            this.columnHeader5.TextAlign = System.Windows.Forms.HorizontalAlignment.Center;
            this.columnHeader5.Width = 100;
            // 
            // FormHealthCheck
            // 
            this.AutoScaleDimensions = new System.Drawing.SizeF(6F, 13F);
            this.AutoScaleMode = System.Windows.Forms.AutoScaleMode.Font;
            this.ClientSize = new System.Drawing.Size(624, 564);
            this.Controls.Add(this.tabControlTabs);
            this.Controls.Add(this.comboBoxServer);
            this.Controls.Add(this.label1);
            this.Controls.Add(this.pictureBox1);
            this.Controls.Add(this.progressBar);
            this.Controls.Add(this.labelUrl);
            this.Controls.Add(this.textBoxUrl);
            this.Controls.Add(this.labelPort);
            this.Controls.Add(this.comboBoxPort);
            this.Controls.Add(this.buttonRefresh);
            this.Controls.Add(this.labelComponent);
            this.Controls.Add(this.comboBoxComponent);
            this.Controls.Add(this.textBoxServer);
            this.Controls.Add(this.labelServer);
            this.Controls.Add(this.menuStrip);
            this.MainMenuStrip = this.menuStrip;
            this.MinimumSize = new System.Drawing.Size(615, 600);
            this.Name = "FormHealthCheck";
            this.Text = "Xbox LIVE - HealthCheck Viewer";
            this.FormClosing += new System.Windows.Forms.FormClosingEventHandler(this.FormHealthCheck_FormClosing);
            this.groupBoxHealthCheck.ResumeLayout(false);
            this.menuStrip.ResumeLayout(false);
            this.menuStrip.PerformLayout();
            this.tabControlTabs.ResumeLayout(false);
            this.tabPageSingleComponent.ResumeLayout(false);
            this.tabPageServerWide.ResumeLayout(false);
            this.groupBoxResults.ResumeLayout(false);
            ((System.ComponentModel.ISupportInitialize)(this.pictureBox1)).EndInit();
            this.tabPage1.ResumeLayout(false);
            this.groupBoxSummary.ResumeLayout(false);
            this.ResumeLayout(false);
            this.PerformLayout();

        }

        #endregion

        private System.Windows.Forms.GroupBox groupBoxHealthCheck;
        private System.Windows.Forms.WebBrowser webBrowser;
        private System.Windows.Forms.MenuStrip menuStrip;
        private System.Windows.Forms.ToolStripMenuItem fileToolStripMenuItem;
        private System.Windows.Forms.ToolStripMenuItem exitToolStripMenuItem;
        private System.Windows.Forms.Label labelServer;
        private System.Windows.Forms.TextBox textBoxServer;
        private System.Windows.Forms.ComboBox comboBoxComponent;
        private System.Windows.Forms.Label labelComponent;
        private System.Windows.Forms.Button buttonRefresh;
        private System.Windows.Forms.ComboBox comboBoxPort;
        private System.Windows.Forms.Label labelPort;
        private System.Windows.Forms.TextBox textBoxUrl;
        private System.Windows.Forms.Label labelUrl;
        private System.Windows.Forms.Timer timerSingleComponentCheck;
        private System.Windows.Forms.ProgressBar progressBar;
        private System.Windows.Forms.PictureBox pictureBox1;
        private System.Windows.Forms.Label label1;
        private System.Windows.Forms.ComboBox comboBoxServer;
        private System.Windows.Forms.TabControl tabControlTabs;
        private System.Windows.Forms.TabPage tabPageSingleComponent;
        private System.Windows.Forms.TabPage tabPageServerWide;
        private System.Windows.Forms.GroupBox groupBoxResults;
        private System.Windows.Forms.ListView listViewComponents;
        private System.Windows.Forms.ColumnHeader columnHeaderComponent;
        private System.Windows.Forms.ColumnHeader columnHeaderURL;
        private System.Windows.Forms.ColumnHeader columnHeaderStatus;
        private System.Windows.Forms.Timer timerServerWideCheck;
        private System.Windows.Forms.ToolStripMenuItem helpToolStripMenuItem;
        private System.Windows.Forms.ToolStripMenuItem aboutToolStripMenuItem;
        private System.Windows.Forms.ToolStripMenuItem saveResultsSummaryToolStripMenuItem;
        private System.Windows.Forms.ToolStripMenuItem saveAllResultsToDirectoryToolStripMenuItem;
        private System.Windows.Forms.TabPage tabPage1;
        private System.Windows.Forms.GroupBox groupBoxSummary;
        private System.Windows.Forms.ListView listViewServers;
        private System.Windows.Forms.ColumnHeader columnHeader1;
        private System.Windows.Forms.ColumnHeader columnHeader2;
        private System.Windows.Forms.ColumnHeader columnHeader3;
        private System.Windows.Forms.ColumnHeader columnHeader4;
        private System.Windows.Forms.ColumnHeader columnHeader5;

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\MiniMaestro\HealthChecks\HealthChecksManager.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Data.SqlClient;
using System.Windows.Forms;
using System.Data;

namespace HealthChecks
{
    public class HealthChecksManager
    {
        String currentNPDBServer = "localhost"; // Default is localhost

        // Dictionary of <Server, <Component, HealthChecks>>
        Dictionary<String, Dictionary<String, HCService>> healthList = null;

        public HealthChecksManager()
        {}

        #region Utility Functions

        /// <summary>
        /// Looks up healthchecks in NPDB and loads them into the health list
        /// </summary>
        /// <param name="npdbServer">name of NPDB server</param>
        /// <returns>true on success, false otherwise</returns>
        public Boolean LoadHealthChecks(String npdbServer)
        {
            healthList = new Dictionary<String, Dictionary<String, HCService>>(StringComparer.CurrentCultureIgnoreCase);

            currentNPDBServer = npdbServer;
            // - Load HealthChecks -
            try
            {
                using (SqlConnection cxn = new SqlConnection(NpdbConnectionString))
                {
                    cxn.Open();

                    SqlCommand sqlCommand = cxn.CreateCommand();
                    sqlCommand.CommandTimeout = 120;

                    // TODO: Change back to NPDB
                    sqlCommand.CommandText = "USE [NPDB]";
                    sqlCommand.ExecuteNonQuery();

                    sqlCommand.CommandType = CommandType.StoredProcedure;
                    sqlCommand.CommandText = "p_config_get_server_healthchecks";
                    using (SqlDataReader reader = sqlCommand.ExecuteReader())
                    {
                        while (reader.Read())
                        {
                            String healthUrl = (String)reader[0];
                            String component = (String)reader[1];
                            String server = (String)reader[2];

                            if (healthList.ContainsKey(server))
                            {
                                // Contains Server Name
                                if (healthList[server].ContainsKey(component))
                                {
                                    // Contains Component, add additional URL
                                    healthList[server][component].AddURL(healthUrl);
                                }
                                else
                                {
                                    // New Component
                                    healthList[server].Add(component, new HCService(component, healthUrl));
                                }
                            }
                            else
                            {
                                // New Server Name
                                healthList.Add(server, new Dictionary<String, HCService>(StringComparer.CurrentCultureIgnoreCase));
                                healthList[server].Add(component, new HCService(component, healthUrl));
                            }
                        }
                        reader.Close();
                    }

                    cxn.Close();
                }
            }
            catch (SqlException ex)
            {
                MessageBox.Show("Warning! Failed to Load HealthChecks: " + ex.Message, "Error");
                return false;
            }
            return true;
        }

        #endregion

        #region Properties

        /// <summary>
        /// NPDB Connection String for SQL
        /// </summary>
        public String NpdbConnectionString
        {
            get
            {
                return "Data Source=" + currentNPDBServer + ";Initial Catalog=npdb;Trusted_Connection=yes";
            }
        }

        /// <summary>
        /// NPDB Server Name
        /// </summary>
        public String NpdbServer
        {
            get
            {
                return currentNPDBServer;
            }

            set
            {
                LoadHealthChecks(value);
            }
        }

        /// <summary>
        /// List of HealthCheck Service Objects
        /// </summary>
        public Dictionary<String, Dictionary<String, HCService>> HealthCheckList
        {
            get { return healthList; }
        }

        #endregion
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\MiniMaestro\HealthChecks\Program.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Windows.Forms;

namespace HealthChecks
{
    static class Program
    {
        /// <summary>
        /// The main entry point for the application.
        /// </summary>
        [STAThread]
        static void Main(String[] args)
        {
            Application.EnableVisualStyles();
            Application.SetCompatibleTextRenderingDefault(false);
            FormHealthCheck healthcheckWindow = new FormHealthCheck();

            // Run HealthCheck
            healthcheckWindow.Run(args);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\MiniMaestro\HealthChecks\HCService.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace HealthChecks
{
    public class HCService
    {
        String serviceName = "Undefined";
        // Dictionary of <portNum, HealthURL>
        Dictionary<int, HealthCheck> healthUrls;

        public HCService(String name, params String[] urls)
        {
            serviceName = name;
            healthUrls = new Dictionary<int, HealthCheck>();
            foreach (String url in urls)
            {
                AddURL(url);
            }
        }

        #region Utility Functions

        public void AddURL(String url)
        {
            healthUrls.Add(ParsePortNumber(url), new HealthCheck(url));
        }

        public static String ParseServerName(String url)
        {
            String replacedString = url.Replace("http://", "");
            replacedString = replacedString.Replace("https://", "");
            int serverEnd = replacedString.IndexOf(':');

            return replacedString.Substring(0, serverEnd);
        }

        public static int ParsePortNumber(String url)
        {
            String replacedString = url.Replace("http://", "");
            replacedString = replacedString.Replace("https://", "");
            int portStart = replacedString.IndexOf(':');
            int portEnd = replacedString.IndexOf('/');

            return int.Parse(replacedString.Substring(portStart + 1, portEnd - portStart - 1));
        }

        public override string ToString()
        {
            return serviceName;
        }

        #endregion

        #region Properties

        public String Name
        {
            get { return serviceName; }
        }

        public HealthCheck this[int port]
        {
            get { return healthUrls[port]; }
            set { healthUrls[port] = value; }
        }

        public int[] Ports
        {
            get { return healthUrls.Keys.ToArray(); }
        }

        // This property is broken
        //public String[] HealthURLs
        //{
        //    get { return healthUrls.Values.ToArray(); }
        //}

        #endregion
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\MiniMaestro\HealthChecks\Properties\AssemblyInfo.cs ===
﻿using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
[assembly: AssemblyTitle("HealthChecks")]
[assembly: AssemblyDescription("HealthCheck Viewer Tool")]
//[assembly: AssemblyConfiguration("")]
//[assembly: AssemblyCompany("Xbox Live Foundation")]
//[assembly: AssemblyProduct("HealthCheckViewer")]
//[assembly: AssemblyCopyright("Copyright © Microsoft 2009")]
//[assembly: AssemblyTrademark("")]
//[assembly: AssemblyCulture("")]

// Setting ComVisible to false makes the types in this assembly not visible 
// to COM components.  If you need to access a type in this assembly from 
// COM, set the ComVisible attribute to true on that type.
//[assembly: ComVisible(false)]

// The following GUID is for the ID of the typelib if this project is exposed to COM
//[assembly: Guid("f6a4de91-d526-4412-b65f-be21ee10f20f")]

// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version 
//      Build Number
//      Revision
//
// You can specify all the values or you can default the Build and Revision Numbers 
// by using the '*' as shown below:
// [assembly: AssemblyVersion("1.0.*")]
//[assembly: AssemblyVersion("1.1.0.0")]
//[assembly: AssemblyFileVersion("1.1.0.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\MiniMaestro\HealthChecks\Properties\Resources.Designer.cs ===
﻿//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:2.0.50727.1434
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace HealthChecks.Properties {
    using System;
    
    
    /// <summary>
    ///   A strongly-typed resource class, for looking up localized strings, etc.
    /// </summary>
    // This class was auto-generated by the StronglyTypedResourceBuilder
    // class via a tool like ResGen or Visual Studio.
    // To add or remove a member, edit your .ResX file then rerun ResGen
    // with the /str option, or rebuild your VS project.
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "2.0.0.0")]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
    internal class Resources {
        
        private static global::System.Resources.ResourceManager resourceMan;
        
        private static global::System.Globalization.CultureInfo resourceCulture;
        
        [global::System.Diagnostics.CodeAnalysis.SuppressMessageAttribute("Microsoft.Performance", "CA1811:AvoidUncalledPrivateCode")]
        internal Resources() {
        }
        
        /// <summary>
        ///   Returns the cached ResourceManager instance used by this class.
        /// </summary>
        [global::System.ComponentModel.EditorBrowsableAttribute(global::System.ComponentModel.EditorBrowsableState.Advanced)]
        internal static global::System.Resources.ResourceManager ResourceManager {
            get {
                if (object.ReferenceEquals(resourceMan, null)) {
                    global::System.Resources.ResourceManager temp = new global::System.Resources.ResourceManager("HealthChecks.Properties.Resources", typeof(Resources).Assembly);
                    resourceMan = temp;
                }
                return resourceMan;
            }
        }
        
        /// <summary>
        ///   Overrides the current thread's CurrentUICulture property for all
        ///   resource lookups using this strongly typed resource class.
        /// </summary>
        [global::System.ComponentModel.EditorBrowsableAttribute(global::System.ComponentModel.EditorBrowsableState.Advanced)]
        internal static global::System.Globalization.CultureInfo Culture {
            get {
                return resourceCulture;
            }
            set {
                resourceCulture = value;
            }
        }
        
        internal static System.Drawing.Bitmap XboxLiveLogo {
            get {
                object obj = ResourceManager.GetObject("XboxLiveLogo", resourceCulture);
                return ((System.Drawing.Bitmap)(obj));
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\MiniMaestro\HealthChecks\Properties\Settings.Designer.cs ===
﻿//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:2.0.50727.1434
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace HealthChecks.Properties
{


    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.VisualStudio.Editors.SettingsDesigner.SettingsSingleFileGenerator", "9.0.0.0")]
    internal sealed partial class Settings : global::System.Configuration.ApplicationSettingsBase
    {

        private static Settings defaultInstance = ((Settings)(global::System.Configuration.ApplicationSettingsBase.Synchronized(new Settings())));

        public static Settings Default
        {
            get
            {
                return defaultInstance;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\MiniMaestro\MiniMaestro\JobBase.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace MiniMaestro
{
    public class JobBase
    {
        protected List<TaskBase> taskList;
        protected Util util;
        protected Boolean started = false;
        protected Boolean finished = false;
        private int currentTaskIndex = 0;

        public JobBase(Util ut)
        {
            taskList = new List<TaskBase>();
            util = ut;
            started = false;
            finished = false;
        }

        public virtual void Step()
        {
            if (currentTaskIndex < taskList.Count)
            {
                // Set Started Flag
                if (!started)
                {
                    started = true;
                }

                // Process one task
                TaskBase currentTask = taskList[currentTaskIndex];
                
                currentTask.Run();

                // Move to next Task if Run() was successful
                currentTaskIndex++;
            }
            else
            {
                // Set Finished Flag
                finished = true;
            }
        }

        public virtual void Skip()
        {
            if (currentTaskIndex < taskList.Count)
            {
                // Set Started Flag
                if (!started)
                {
                    started = true;
                }

                // Skip to next Task
                currentTaskIndex++;
            }
            else
            {
                // Set Finished Flag
                finished = true;
            }
        }

        public String CurrentTaskDescription
        {
            get
            {
                if (currentTaskIndex < taskList.Count)
                {
                    return taskList[currentTaskIndex].Description;
                }
                else
                {
                    throw new IndexOutOfRangeException("No Additional Tasks");
                }
            }
        }

        public virtual String Description
        {
            get { return "Empty"; }
        }

        public virtual String Name
        {
            get { return "Empty"; }
        }

        public int Progress
        {
            get
            {
                if (taskList.Count > 0)
                {
                    return (100 * currentTaskIndex) / taskList.Count;
                }
                else
                {
                    return 0;
                }
            }
        }

        public int NumCompletedTasks
        {
            get { return currentTaskIndex; }
        }

        public int TotalTasks
        {
            get { return taskList.Count; }
        }

        public Boolean Started
        {
            get { return started; }
        }

        public Boolean Finished
        {
            get { return finished; }
        }

        public virtual string this[string property]
        {
            get { throw new IndexOutOfRangeException(String.Format("Property {0} not found", property)); }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\MiniMaestro\MiniMaestro\TaskBase.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace MiniMaestro
{
    public abstract class TaskBase
    {
        protected JobBase parentJob = null;
        protected Util util = null;

        protected TaskBase(JobBase parent, Util ut)
        {
            parentJob = parent;
            util = ut;
        }

        public abstract void Run();

        public virtual String Description
        {
            get { return "Missing Task Description"; }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\MiniMaestro\MiniMaestro\MaestroWindow.cs ===
﻿using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Data;
using System.Drawing;
using System.Linq;
using System.Text;
using System.Windows.Forms;
using System.IO;
using MiniMaestro.Jobs;

namespace MiniMaestro
{
    public partial class MaestroWindow : Form
    {
        List<JobBase> jobList = new List<JobBase>();
        int currentJobIndex = 0;
        Boolean infoLoaded = false;
        Util util = null;
        int numSkippedTasks = 0;

        public MaestroWindow()
        {
            InitializeComponent();
            Initialize();
        }

        void Initialize()
        {
            outputText.BackColor = Color.Black;
            outputText.ForeColor = Color.LightGray;
            outputText.WordWrap = false;
            outputText.Font = new Font("Lucida Console", 8.25F, FontStyle.Regular, GraphicsUnit.Point, ((byte)(0)));
            outputText.ReadOnly = true;
            outputText.Enabled = true;
            outputText.HideSelection = false;
            outputText.ShortcutsEnabled = true;

            util = new Util(outputText);
        }

        public void Run(String[] args)
        {
            String assemblyVersion = this.GetType().Assembly.GetName().Version.ToString();
#if BASEIMAGE
            Text = "Xbox LIVE - MiniMaestro for Base Images v" + assemblyVersion;
            labelIP.Visible = false;
            textBoxOldIP.Visible = false;
            //textBoxNewIP.Visible = false;
            util.WriteLine("Info", TextType.Remark, "MiniMaestro for Base Images v" + assemblyVersion);
#else
            Text = "Xbox LIVE - MiniMaestro v" + assemblyVersion;
            util.WriteLine("Info", TextType.Remark, "MiniMaestro v" + assemblyVersion);
#endif
            Boolean initialized = util.Initialize(args);
            if (initialized)
            {
                util.WriteLine("MiniMaestro", TextType.Info, "Version " + assemblyVersion);
                util.WriteLine("MiniMaestro", TextType.Info, "Log File: " + util.LogFile);
                util.WriteLine("MiniMaestro", TextType.Info, "Preparing to transform Xblob...");
                if (!util.FlagForceRead)
                {
                    util.WriteLine("MiniMaestro", TextType.Remark, "Program may hang temporarily if SQL is misconfigured or non-existent.");
                    util.WriteLine("MiniMaestro", TextType.Remark, "Set the [-ForceRead] Flag to skip search for old machine info");
                }

                numSkippedTasks = 0;
                jobTimer.Enabled = true;
                TopMost = true;
            }
            this.ShowDialog();
        }

        #region Events

        private void jobTimer_Tick(object sender, EventArgs e)
        {
            if (infoLoaded)
            {
                try
                {
                    if (currentJobIndex < jobList.Count)
                    {
                        JobBase currentJob = jobList[currentJobIndex];

                        if (!currentJob.Started)
                        {
                            util.WriteLine("MiniMaestro", TextType.Good, "Starting Job: " + currentJob.Name);
                            util.WriteLine(currentJob.Name, TextType.Status, currentJob.Description);
                        }

                        currentJob.Step();

                        // Check if job is finished
                        if (currentJob.Finished)
                        {
                            util.WriteLine("MiniMaestro", TextType.Good, "Completed Job: " + currentJob.Name);
                            // Move to next job in the list
                            currentJobIndex++;
                        }

                        // Update Progress Bar
                        UpdateProgressBar();
                    }
                    else
                    {
                        util.WriteLine("MiniMaestro", TextType.Good, "All Jobs Successful!");
                        util.WriteLine("MiniMaestro", TextType.Info, "Log File: " + util.LogFile);
                        util.WriteLine("MiniMaestro", TextType.Good, "It is safe to close this program now.");
                        util.WriteLine("MiniMaestro", TextType.Warning, "Please Reboot your machine.");
                        TopMost = false;
                        buttonPause.Enabled = false;
                        jobTimer.Enabled = false;

                        // Display "Done. Reboot?" MessageBox
                        if (MessageBox.Show("Reboot Now?", "MiniMaestro Completed", MessageBoxButtons.YesNo) == DialogResult.Yes)
                        {
                            System.Diagnostics.Process.Start("ShutDown", "/r /t 0");
                        }
                    }
                }
                catch (Exception ex)
                {
                    util.WriteLine("MiniMaestro", TextType.Error, ex.Message);
                    buttonPause.Text = "Resume";
                    buttonSkip.Enabled = true;
                    jobTimer.Enabled = false;
                }
            }
            else
            {
                // - Load Info if not loaded -
                try
                {
                    util.RetrieveInfo();
                }
                catch (Exception ex)
                {
                    util.WriteLine("MiniMaestro", TextType.Error, "Error Retrieving Old Machine Info: " + ex.Message);
                    buttonPause.Text = "Resume";
                    buttonSkip.Enabled = true;
                    jobTimer.Enabled = false;
                }

                textBoxOldMachineName.Text = util.OldMachineName;
                textBoxNewMachineName.Text = util.NewMachineName;
                textBoxNewIP.Text = util.NewIPAddress;
#if !BASEIMAGE
                textBoxOldIP.Text = util.OldIPAddress;
#endif

#if BASEIMAGE
                util.WriteLine("MiniMaestro", TextType.Status, "Creating Full List of Jobs...");
                jobList.Add(new RegistrySetting(util));
                jobList.Add(new RenameSQL(util));
                jobList.Add(new RenameWebstore(util));
                jobList.Add(new RestartSQL(util));
                jobList.Add(new EnableCodesign(util));
#else
                if (util.FlagPreImage)
                {
                    util.WriteLine("MiniMaestro", TextType.Status, "Creating List of Jobs for PreImage Steps..");
                    jobList.Add(new PreimageServiceConfig(util));
                    /*
                     * - Support Stopping and Disabling Services -
                     * 
                     * sc config mssqlserver start= auto
                     * sc config sqlserveragent start= auto
                     * sc config mssqlserverolapservice start= auto
                     * sc config msdtsserver100 start= auto
                     * sc config reportserver start= auto
                     * sc config sqlwriter start= auto
                     * sc config wstservice start= auto
                     */
                }
                else if (util.FlagUpdateIP)
                {
                    util.WriteLine("MiniMaestro", TextType.Status, "Creating List of Jobs for IP Change...");
                    jobList.Add(new UpdateNPDB(util));
                    jobList.Add(new XblCfg(util));
                    jobList.Add(new XBLCredentials(util));
                    jobList.Add(new RenameIISUsers(util));
                }
                else
                {
                    util.WriteLine("MiniMaestro", TextType.Status, "Creating Full List of Jobs...");
                    jobList.Add(new RegistrySetting(util));
                    jobList.Add(new RenameSQL(util));
                    jobList.Add(new SQLLoginUpdate(util));
                    jobList.Add(new RenameWebstore(util));
                    if (!util.FlagSkipWstAccounts)
                    {
                        jobList.Add(new WstAccountsUpdate(util));
                    }
                    jobList.Add(new RestartSQL(util));
                    jobList.Add(new UpdateNPDB(util));
                    jobList.Add(new XblCfg(util));
                    jobList.Add(new XBLCredentials(util));
                    jobList.Add(new RenameIISUsers(util));
                    jobList.Add(new EnableCodesign(util));
                    jobList.Add(new UpdateVelocity(util));
                }
#endif

                infoLoaded = true;
                buttonPause.Enabled = true;
            }
        }

        private void UpdateProgressBar()
        {
            int completedTasks = numSkippedTasks, totalTasks = 0;
            foreach (JobBase job in jobList)
            {
                completedTasks += job.NumCompletedTasks;
                totalTasks += job.TotalTasks;
            }
            progressBar.Value = (100 * completedTasks) / totalTasks;
        }

        private void buttonPause_Click(object sender, EventArgs e)
        {
            if (jobTimer.Enabled)
            {
                TopMost = false;
                buttonPause.Text = "Resume";
                util.WriteLine("MiniMaestro", TextType.Warning, "Job Paused...");
                buttonSkip.Enabled = true;
                jobTimer.Enabled = false;
            }
            else
            {
                TopMost = true;
                buttonPause.Text = "Pause";
                util.WriteLine("MiniMaestro", TextType.Status, "Resuming...");
                buttonSkip.Enabled = false;
                jobTimer.Enabled = true;
            }
        }

        #endregion

        private void buttonSkip_Click(object sender, EventArgs e)
        {
            if (currentJobIndex < jobList.Count)
            {
                JobBase currentJob = jobList[currentJobIndex];

                numSkippedTasks++;
                String taskDescription = currentJob.CurrentTaskDescription;
                currentJob.Skip();

                util.WriteLine("MiniMaestro", TextType.Warning, "Task Skipped inside " + currentJob.Name + ": " + taskDescription);
                util.WriteLine("MiniMaestro", TextType.Status, "Next Task: " + currentJob.CurrentTaskDescription);

                // Update Progress Bar
                UpdateProgressBar();

                // Check if job is finished
                if (currentJob.Finished)
                {
                    util.WriteLine("MiniMaestro", TextType.Good, "Completed Job: " + currentJob.Name);
                    // Move to next job in the list
                    currentJobIndex++;

                    JobBase nextJob = jobList[currentJobIndex];

                    util.WriteLine("MiniMaestro", TextType.Status, "Next Job: " + nextJob.Name);
                }
                
                // Notify User to Click Resume
                util.WriteLine("MiniMaestro", TextType.Remark, "Press Resume to Continue");
            }
            else
            {
                buttonSkip.Enabled = false;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\MiniMaestro\MiniMaestro\Jobs\EnableCodesign.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using MiniMaestro.Tasks;

namespace MiniMaestro.Jobs
{
    public class EnableCodesign : JobBase
    {
        public EnableCodesign(Util ut)
            : base(ut)
        {
            // Add Tasks
            taskList.Add(new EnaCod_BCDEdit(this, ut));
        }

        public override String Description
        {
            get { return "Enabling Codesign"; }
        }
        
        public override String Name
        {
            get { return "EnableCodesign"; }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\tools\MiniMaestro\MiniMaestro\MaestroWindow.Designer.cs ===
﻿namespace MiniMaestro
{
    partial class MaestroWindow
    {
        /// <summary>
        /// Required designer variable.
        /// </summary>
        private System.ComponentModel.IContainer components = null;

        /// <summary>
        /// Clean up any resources being used.
        /// </summary>
        /// <param name="disposing">true if managed resources should be disposed; otherwise, false.</param>
        protected override void Dispose(bool disposing)
        {
            if (disposing && (components != null))
            {
                components.Dispose();
            }
            base.Dispose(disposing);
        }

        #region Windows Form Designer generated code

        /// <summary>
        /// Required method for Designer support - do not modify
        /// the contents of this method with the code editor.
        /// </summary>
        private void InitializeComponent()
        {
            this.components = new System.ComponentModel.Container();
            System.ComponentModel.ComponentResourceManager resources = new System.ComponentModel.ComponentResourceManager(typeof(MaestroWindow));
            this.outputText = new System.Windows.Forms.RichTextBox();
            this.groupBoxProgress = new System.Windows.Forms.GroupBox();
            this.progressBar = new System.Windows.Forms.ProgressBar();
            this.textBoxOldMachineName = new System.Windows.Forms.TextBox();
            this.label1 = new System.Windows.Forms.Label();
            this.labelIP = new System.Windows.Forms.Label();
            this.textBoxOldIP = new System.Windows.Forms.TextBox();
            this.label3 = new System.Windows.Forms.Label();
            this.textBoxNewIP = new System.Windows.Forms.TextBox();
            this.textBoxNewMachineName = new System.Windows.Forms.TextBox();
            this.jobTimer = new System.Windows.Forms.Timer(this.components);
            this.buttonPause = new System.Windows.Forms.Button();
            this.buttonSkip = new System.Windows.Forms.Button();
            this.pictureBoxLogo = new System.Windows.Forms.PictureBox();
            this.groupBoxProgress.SuspendLayout();
            ((System.ComponentModel.ISupportInitialize)(this.pictureBoxLogo)).BeginInit();
            this.SuspendLayout();
            // 
            // outputText
            // 
            this.outputText.Anchor = ((System.Windows.Forms.AnchorStyles)((((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Bottom)
                        | System.Windows.Forms.AnchorStyles.Left)
                        | System.Windows.Forms.AnchorStyles.Right)));
            this.outputText.Location = new System.Drawing.Point(1, 108);
            this.outputText.Name = "outputText";
            this.outputText.Size = new System.Drawing.Size(622, 335);
            this.outputText.TabIndex = 0;
            this.outputText.Text = "";
            // 
            // groupBoxProgress
            // 
            this.groupBoxProgress.Anchor = ((System.Windows.Forms.AnchorStyles)(((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Left)
                        | System.Windows.Forms.AnchorStyles.Right)));
            this.groupBoxProgress.Controls.Add(this.progressBar);
            this.groupBoxProgress.Location = new System.Drawing.Point(186, 58);
            this.groupBoxProgress.Name = "groupBoxProgress";
            this.groupBoxProgress.Size = new System.Drawing.Size(426, 44);
            this.groupBoxProgress.TabIndex = 1;
            this.groupBoxProgress.TabStop = false;
            this.groupBoxProgress.Text = "Progress";
            // 
            // progressBar
            // 
            this.progressBar.Anchor = ((System.Windows.Forms.AnchorStyles)(((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Left)
                        | System.Windows.Forms.AnchorStyles.Right)));
            this.progressBar.Location = new System.Drawing.Point(6, 15);
            this.progressBar.Name = "progressBar";
            this.progressBar.Size = new System.Drawing.Size(414, 23);
            this.progressBar.TabIndex = 0;
            // 
            // textBoxOldMachineName
            // 
            this.textBoxOldMachineName.Enabled = false;
            this.textBoxOldMachineName.Location = new System.Drawing.Point(271, 6);
            this.textBoxOldMachineName.Name = "textBoxOldMachineName";
            this.textBoxOldMachineName.Size = new System.Drawing.Size(106, 20);
            this.textBoxOldMachineName.TabIndex = 3;
            // 
            // label1
            // 
            this.label1.AutoSize = true;
            this.label1.Location = new System.Drawing.Point(183, 9);
            this.label1.Name = "label1";
            this.label1.Size = new System.Drawing.Size(82, 13);
            this.label1.TabIndex = 4;
            this.label1.Text = "Machine Name:";
            // 
            // labelIP
            // 
            this.labelIP.AutoSize = true;
            this.labelIP.Location = new System.Drawing.Point(183, 35);
            this.labelIP.Name = "labelIP";
            this.labelIP.Size = new System.Drawing.Size(61, 13);
            this.labelIP.TabIndex = 6;
            this.labelIP.Text = "IP Address:";
            // 
            // textBoxOldIP
            // 
            this.textBoxOldIP.Enabled = false;
            this.textBoxOldIP.Location = new System.Drawing.Point(271, 32);
            this.textBoxOldIP.Name = "textBoxOldIP";
            this.textBoxOldIP.Size = new System.Drawing.Size(106, 20);
            this.textBoxOldIP.TabIndex = 5;
            // 
            // label3
            // 
            this.label3.AutoSize = true;
            this.label3.Location = new System.Drawing.Point(384, 22);
            this.label3.Name = "label3";
            this.label3.Size = new System.Drawing.Size(16, 13);
            this.label3.TabIndex = 7;
            this.label3.Text = "->";
            // 
            // textBoxNewIP
            // 
            this.textBoxNewIP.Enabled = false;
            this.textBoxNewIP.Location = new System.Drawing.Point(407, 32);
            this.textBoxNewIP.Name = "textBoxNewIP";
            this.textBoxNewIP.Size = new System.Drawing.Size(106, 20);
            this.textBoxNewIP.TabIndex = 9;
            // 
            // textBoxNewMachineName
            // 
            this.textBoxNewMachineName.Enabled = false;
            this.textBoxNewMachineName.Location = new System.Drawing.Point(407, 6);
            this.textBoxNewMachineName.Name = "textBoxNewMachineName";
            this.textBoxNewMachineName.Size = new System.Drawing.Size(106, 20);
            this.textBoxNewMachineName.TabIndex = 8;
            // 
            // jobTimer
            // 
            this.jobTimer.Interval = 60;
            this.jobTimer.Tick += new System.EventHandler(this.jobTimer_Tick);
            // 
            // buttonPause
            // 
            this.buttonPause.Enabled = false;
            this.buttonPause.Location = new System.Drawing.Point(528, 32);
            this.buttonPause.Name = "buttonPause";
            this.buttonPause.Size = new System.Drawing.Size(78, 26);
            this.buttonPause.TabIndex = 10;
            this.buttonPause.Text = "Pause";
            this.buttonPause.UseVisualStyleBackColor = true;
            this.buttonPause.Click += new System.EventHandler(this.buttonPause_Click);
            // 
            // buttonSkip
            // 
            this.buttonSkip.Enabled = false;
            this.buttonSkip.Location = new System.Drawing.Point(528, 2);
            this.buttonSkip.Name = "buttonSkip";
            this.buttonSkip.Size = new System.Drawing.Size(78, 26);
            this.buttonSkip.TabIndex = 11;
            this.buttonSkip.Text = "Skip";
            this.buttonSkip.UseVisualStyleBackColor = true;
            this.buttonSkip.Click += new System.EventHandler(this.buttonSkip_Click);
            // 
            // pictureBoxLogo
            // 
            this.pictureBoxLogo.BorderStyle = System.Windows.Forms.BorderStyle.FixedSingle;
            this.pictureBoxLogo.Image = global::MiniMaestro.Properties.Resources.XboxLiveMiniMaestro;
            this.pictureBoxLogo.Location = new System.Drawing.Point(12, 12);
            this.pictureBoxLogo.Name = "pictureBoxLogo";
            this.pictureBoxLogo.Size = new System.Drawing.Size(157, 65);
            this.pictureBoxLogo.TabIndex = 12;
            this.pictureBoxLogo.TabStop = false;
            // 
            // MaestroWindow
            // 
            this.AutoScaleDimensions = new System.Drawing.SizeF(6F, 13F);
            this.AutoScaleMode = System.Windows.Forms.AutoScaleMode.Font;
            this.ClientSize = new System.Drawing.Size(624, 444);
            this.Controls.Add(this.pictureBoxLogo);
            this.Controls.Add(this.buttonSkip);
            this.Controls.Add(this.buttonPause);
            this.Controls.Add(this.textBoxNewIP);
            this.Controls.Add(this.textBoxNewMachineName);
            this.Controls.Add(this.label3);
            this.Controls.Add(this.labelIP);
            this.Controls.Add(this.textBoxOldIP);
            this.Controls.Add(this.label1);
            this.Controls.Add(this.textBoxOldMachineName);
            this.Controls.Add(this.groupBoxProgress);
            this.Controls.Add(this.outputText);
            this.Icon = ((System.Drawing.Icon)(resources.GetObject("$this.Icon")));
            this.Name = "MaestroWindow";
            this.Text = "Xbox LIVE - MiniMaestro";
            this.groupBoxProgress.ResumeLayout(false);
            ((System.ComponentModel.ISupportInitialize)(this.pictureBoxLogo)).EndInit();
            this.ResumeLayout(false);
            this.PerformLayou