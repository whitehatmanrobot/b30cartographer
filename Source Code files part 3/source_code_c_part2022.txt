mmary>
        public class PreauthPCAccountCreationRequest2: AsnBytes, IGetPreauthNumber
        {
            public byte   []EncryptedSessionKey; //should always be 256 bytes.  The session key is encrypted with the xmacs public key.
            public ushort   EncDataLen;          //Length of the encrypted data portion
            public byte   []EncData;             //Bytes of the encrypted data

            public PreauthPCAccountCreationRequest2_EncPart EncryptedPart=new PreauthPCAccountCreationRequest2_EncPart(); //representation of EncData
            public byte []RawSessionKey; //Not directly part of the request but required.  Session key is used to encrypt EncData.  This is also encrypted with the xmacs public key and stored in EncryptedSessionKey.
            public bool UseTestXmacsPublicKey; //If true uses the test key.  Else uses the retail key.

            //sets all fields to new valid defaults for a specific console ID (which must start with XE.).  If session key is not specified, one is calculated from the console ID.
            public void SetDefaults(byte []sessionKey, ulong pcId, byte []passportTicket, byte []sponsorToken, bool useTestKey)
            {
                UseTestXmacsPublicKey=useTestKey;
                RawSessionKey=sessionKey;

                if (RawSessionKey==null)
                {
                    RawSessionKey=new byte[16];
                    ServerTestFramework.Utilities.RandomEx.GlobalRandGen.NextBytes(RawSessionKey);
                }

                EncryptedPart.SetDefaults(pcId, passportTicket, sponsorToken);
            }

            //Decrypts the encrypted part
            public void Decrypt()
            {
                throw new System.Exception("TODO: implement this.");
            }

            //Encrypts the encrypted part and stores everything in Bytes
            public void Encrypt()
            {
                //Encrypt the session key with the xmacs public key
                if (UseTestXmacsPublicKey)
                {
                    EncryptedSessionKey=XmacsKeys.EncryptWithTestKey(RawSessionKey);
                }
                else
                {
                    EncryptedSessionKey=XmacsKeys.EncryptWithRealKey(RawSessionKey);
                }

                //encrypt the encrypted part and store it
                EncryptedPart.EncryptionKey=RawSessionKey;
                EncryptedPart.Encrypt();
                EncryptedPart.RecalculateLengths(true);

                RepackEncryptedPartAndAllBytes();
            }

            //stores all structures back into Bytes as they currently are in this structure and the encrypted bytes part of the substructure.  This does not re-perform any encryption and only re-evaluates the length of the encrypted data blob.
            public void RepackEncryptedPartAndAllBytes()
            {
                EncData=EncryptedPart.GetBytes();
                EncDataLen=(EncData.Length>65535?(ushort)65535:(ushort)EncData.Length);

                RepackAllBytes();
            }

            //stores all structures back into Bytes as they currently are in this structure.  This does not re-perform any encryption or re-evaluate any lengths.
            public void RepackAllBytes()
            {
                byte []rawBytes=new byte[256+2+EncData.Length];
                System.Array.Copy(EncryptedSessionKey, 0, rawBytes, 0, 256);
                System.Array.Copy(System.BitConverter.GetBytes(EncDataLen), 0, rawBytes, 256, 2);
                System.Array.Copy(EncData, 0, rawBytes, 256+2, EncData.Length);

                Bytes=rawBytes;
            }

            //
            public override long SetBytes(byte []data, long dataStart, long dataLength)
            {
                //set into base
                long ret=base.SetBytes(data, dataStart, dataLength);

                //also copy the unencrypted portion out
                System.Array.Copy(data, dataStart+0, EncryptedSessionKey, 0, 256);
                EncDataLen=System.BitConverter.ToUInt16(data, (int)dataStart+256);
                EncData=new byte[EncDataLen];
                System.Array.Copy(data, dataStart+256+2, EncData, 0, EncDataLen);

                return ret;
            }

            public override string ToString()
            {
                if (EncryptedPart.PassportTicket==null) //prolly not set yet
                    return base.ToString();

                string s="PreauthPCAccountCreationRequest2:";
                if (EncryptedPart!=null) //print out encrypted part
                {
                    s+="\n"+EncryptedPart.ToString();
                }
                else //not decrypted, so just print out the EncData
                {
                    s+="\nPAPCMacReq2 EncDataLen: "+EncDataLen;
                    s+="\nPAPCMacReq2 EncData: "+EncData.Length+" bytes of data";
                }

                return s;
            }

            public int GetPreauthNumber()
            {
                return 220;
            }
        }

        /// <summary> Encrypted portion of the PreauthPCAccountCreationRequest2 preauth. </summary>
        public class PreauthPCAccountCreationRequest2_EncPart: EncryptedData, IContainsEncryptedBytes
        {
            public ulong  AuthTime;          //the current time, as a windows 64 bit time value
            public ulong  PcId;              //Random value generated by the PC for this specific machine account
            public ushort PassportTicketLen; //Length of the passport ticket bytes
            public ushort SponsorTokenLen;   //length of SponsorToken
            public byte []PassportTicket;    //Bytes of the passport ticket
            public byte []SponsorToken;      //5x5.  up to 41 bytes.  or exactly 41 bytes?

            //key used to encrypted the data
            public byte []EncryptionKey;

            //
            public PreauthPCAccountCreationRequest2_EncPart()
            {
                //set key type and version for encrypted data structure
                Type.Int64=0x17;
                Version=null;
            }

            public void SetDefaults(ulong pcId, byte []passportTicket, byte []sponsorToken)
            {
                AuthTime=(ulong)System.DateTime.UtcNow.ToFileTimeUtc();
                PcId=pcId;
                PassportTicket=passportTicket;
                PassportTicketLen=(ushort)PassportTicket.Length;
                SponsorToken=sponsorToken;
                SponsorTokenLen=(ushort)SponsorToken.Length;
            }

            //Decrypts EncryptedData's Data.Bytes and stores the result in the above fields
            public void Decrypt()
            {
                throw new System.Exception("TODO: implement this.");
            }

            //Encrypts the above fields (packed by calling GetInnerBytes) and stores the result in EncryptedData's Data.Bytes
            public void Encrypt()
            {
                byte []encPartBytes=GetInnerBytes();
                EncryptedBytes.Bytes=KdcCrypto.RC4HMACEncrypt(encPartBytes, EncryptionKey, KdcCrypto.PA_PC_ACCOUNT_CREATION_SALT);
            }

            //Encrypts rawBytes and stores them in EncryptedData's Data.Bytes
            public void Encrypt(byte []rawBytes)
            {
                EncryptedBytes.Bytes=KdcCrypto.RC4HMACEncrypt(rawBytes, EncryptionKey, KdcCrypto.PA_PC_ACCOUNT_CREATION_SALT);
            }

            public byte[] GetInnerBytes()
            {
                byte []encPartBytes=new byte[8+8+2+2+PassportTicket.Length+SponsorToken.Length];
                System.Array.Copy(System.BitConverter.GetBytes(AuthTime), 0, encPartBytes, 0, 8);
                System.Array.Copy(System.BitConverter.GetBytes(PcId), 0, encPartBytes, 8, 8);
                System.Array.Copy(System.BitConverter.GetBytes(PassportTicketLen), 0, encPartBytes, 16, 2);
                System.Array.Copy(System.BitConverter.GetBytes(SponsorTokenLen), 0, encPartBytes, 18, 2);
                System.Array.Copy(PassportTicket, 0, encPartBytes, 20, PassportTicket.Length);
                System.Array.Copy(SponsorToken, 0, encPartBytes, 20+PassportTicket.Length, SponsorToken.Length);
                return encPartBytes;
            }

            public void SetInnerBytes(byte []data)
            {
                throw new System.Exception("TODO: implement this.");
            }

            public override string ToString()
            {
                string s="";
                s+="PAPCMacReq2Enc AuthTime="+AuthTime+" ("+System.DateTime.FromFileTimeUtc((long)AuthTime)+")";
                s+="\nPAPCMacReq2Enc PcId: "+PcId;
                s+="\nPAPCMacReq2Enc PassportTicketLen: "+PassportTicketLen;
                s+="\nPAPCMacReq2Enc SponsorTokenLen: "+SponsorTokenLen;
                s+="\nPAPCMacReq2Enc PassportTicket: "+PassportTicket.Length+" bytes of data";
                s+="\nPAPCMacReq2Enc SponsorToken: 0x"+ServerTestFramework.Utilities.Hexer.tohex(SponsorToken)+" ("+ServerTestFramework.Utilities.ByteEncoding.Instance.GetString(SponsorToken)+")";
                return s;
            }
        }

        /// <summary> PADATA_PC_ACCOUNT_CREATION(212) Reply.  Response to a PC machine account request.  Note that the preauth number is the same number as the Request. </summary>
        public class PreauthPCAccountCreationReply: EncryptedData, IGetPreauthNumber
        {
            public ulong   MachineId;
            public byte  []MachineKey; //array of length 16

            //Decrypts EncryptedData's Data.Bytes and stores the result in the above fields
            public void Decrypt(byte []key)
            {
                //decrypt
                byte []rawBytes=KdcCrypto.RC4HMACDecrypt(EncryptedBytes.Bytes, key, KdcCrypto.PA_PC_ACCOUNT_CREATION_REP_SALT);

                //parse
                MachineId=System.BitConverter.ToUInt64(rawBytes, 0);
                MachineKey=new byte[rawBytes.Length-8];
                System.Array.Copy(rawBytes, 8, MachineKey, 0, rawBytes.Length-8);
            }

            //Encrypts the above fields and stores the result in EncryptedData's Data.Bytes
            public void Encrypt(byte []key)
            {
                throw new System.Exception("TODO: Implement this.");
            }

            public override string ToString()
            {
                if (MachineKey==null) //not decrypted yet
                {
                    return base.ToString();
                }

                string s="PreauthPCAccountCreationReply:";
                s+="\nPAPCMacRep MachineId: 0x"+MachineId.ToString("X");
                s+="\nPAPCMacRep MachineKey: 0x"+ServerTestFramework.Utilities.Hexer.tohex(MachineKey);
                return s;
            }

            public int GetPreauthNumber()
            {
                return 212;
            }
        }

        /// <summary> PADATA_PASSPORT_AUTHENTICATION(213) Request.  Request to authenicate a passport user.  Note that the preauth number is the same number as the Response. </summary>
        public class PreauthPassportAuthenticationRequest: AsnBytes, IGetPreauthNumber
        {
            public ulong    PCNOnce;            //NOnce for the PC preauth (unrelated to the NOnce in the kerberos request)
            public ushort   PassportTicketLen;  //Length of the passport ticket bytes
            public byte   []PassportTicket;     //Bytes of the passport ticket

            //Decrypts Bytes and stores it in the above fields.  Note that since this isn't encrypted, we really just store the bytes.
            public void Decrypt(byte []key)
            {
                throw new System.Exception("TODO: implement this.");
            }

            //Encrypts the above fields and stores it in Bytes.  Note that since this isn't encrypted, we really just store the bytes.
            public void Encrypt(byte []key)
            {
                //pack this struct into the bytes
                byte []rawBytes=new byte[10+PassportTicket.Length];
                System.Array.Copy(System.BitConverter.GetBytes(PCNOnce), 0, rawBytes, 0, 8);
                System.Array.Copy(System.BitConverter.GetBytes(PassportTicketLen), 0, rawBytes, 8, 2);
                System.Array.Copy(PassportTicket, 0, rawBytes, 10, PassportTicket.Length);

                //encrypt and store it
                Bytes=rawBytes;
            }

            public override string ToString()
            {
                if (PassportTicket==null) //prolly not set yet
                    return base.ToString();

                string s="PreauthPassportAuthenticationRequest:";
                s+="\nPAPPAuthReq PCNOnce: "+PCNOnce;
                s+="\nPAPPAuthReq PassportTicketLen: "+PassportTicketLen;
                s+="\nPAPPAuthReq PassportTicket: "+PassportTicket.Length+" bytes of data";

                return s;
            }

            public int GetPreauthNumber()
            {
                return 213;
            }
        }

        /// <summary> PADATA_PASSPORT_AUTHENTICATION(213) Reply.  Response to a passport authentication request.  Note that the preauth number is the same number as the Request. </summary>
        public class PreauthPassportAuthenticationReply: EncryptedData, IGetPreauthNumber
        {
            ulong  UserId;        //xbox live user id
            byte []GamertagBytes; //array of length 16.  xbox live gamertag

            public string Gamertag
            {
                get { return ServerTestFramework.Utilities.ByteEncoding.Instance.GetString(GamertagBytes).Replace("\0",""); }
            }

            //Decrypts EncryptedData's Data.Bytes and stores the result in the above fields
            public void Decrypt(byte []key)
            {
                //decrypt
                byte []rawBytes=KdcCrypto.RC4HMACDecrypt(EncryptedBytes.Bytes, key, KdcCrypto.PA_PASSPORT_AUTHENTICATION_SALT);

                //parse
                UserId=System.BitConverter.ToUInt64(rawBytes, 0);
                GamertagBytes=new byte[rawBytes.Length-8];
                System.Array.Copy(rawBytes, 8, GamertagBytes, 0, rawBytes.Length-8);
            }

            //Encrypts the above fields and stores the result in EncryptedData's Data.Bytes
            public void Encrypt(byte []key)
            {
                throw new System.Exception("TODO: Implement this.");
            }

            public override string ToString()
            {
                if (GamertagBytes==null) //not decrypted yet
                {
                    return base.ToString();
                }

                string s="PreauthPassportAuthenticationReply:";
                s+="\nPAPPAuthRep UserId: 0x"+UserId.ToString("X");
                s+="\nPAPPAuthRep Gamertag: "+Gamertag;
                return s;
            }

            public int GetPreauthNumber()
            {
                return 213;
            }
        }

        /// <summary> PADATA_ENCRYPTED_PASSPORT_AUTHENTICATION(218) - Encrypted passport ticket authentication.  This us used by the Askdc. </summary>
        public class PreauthEncryptedPassport: EncryptedData, IGetPreauthNumber, IContainsEncryptedBytes
        {
            public ushort PassportTicketLength;
            public byte []PassportTicket;

            //key used for encryption and decryption.
            public byte []EncryptionKey;

            //Encrypts the ticket and sets it to the EncryptedBytes member of the base EncryptedData.
            public void Encrypt()
            {
                //pack this struct into the bytes
                byte []bytes=GetInnerBytes();

                //encrypt it and store
                EncryptedBytes.Bytes=KdcCrypto.RC4HMACEncrypt(bytes, EncryptionKey, KdcCrypto.PA_PASSPORT_AUTHENTICATION_SALT);
            }

            //Decrypts the Data member of the base EncryptedData and stores it in Timestamp.
            public void Decrypt()
            {
                //decrypt
                byte []bytes=KdcCrypto.RC4HMACDecrypt(EncryptedBytes.Bytes, EncryptionKey, KdcCrypto.PA_PASSPORT_AUTHENTICATION_SALT);

                //set the members from the bytes
                SetInnerBytes(bytes);
            }

            public byte[] GetInnerBytes()
            {
                byte []rawBytes=new byte[2+PassportTicket.Length];
                System.Array.Copy(System.BitConverter.GetBytes(PassportTicketLength), 0, rawBytes, 0, 2);
                System.Array.Copy(PassportTicket, 0, rawBytes, 2, PassportTicket.Length);
                return rawBytes;
            }

            public void SetInnerBytes(byte []data)
            {
                PassportTicketLength=System.BitConverter.ToUInt16(data, 0);

                PassportTicket=new byte[data.Length-2];
                System.Array.Copy(data, 2, PassportTicket, 0, data.Length-2);
            }

            //
            public PreauthEncryptedPassport()
            {
                Type.Int64=0x17; //rc4 hmac
                Version=null; //we don't normally include this field
            }

            public int GetPreauthNumber()
            {
                return 218;
            }

            public override string ToString()
            {
                if (PassportTicket==null) //prolly not set yet
                    return base.ToString();

                string s="PreauthEncryptedPassport:";
                s+="\nPEP Enc PassportTicketLen: "+PassportTicketLength;
                s+="\nPEP Enc PassportTicket: "+PassportTicket.Length+" bytes of data";

                return s;
            }
        };

        /// <summary> PADATA_XBOX_ECHO(205) - Echo response preauth for the askdc. </summary>
        public class PreauthXboxEcho: AsnBytes, IGetPreauthNumber, IContainsEncryptedBytes
        {
            public ulong  Timestamp; //64 bit windows time value
            public uint   Ipv4;      //ipv4 version of the IP from which the request originated
            public byte []Random;    //3 bytes: random values to mix up the final encrypted data
            public byte   Checksum;  //sum of the bytes in the rest of the struct, mod 256

            //Key used to encrypt the data
            public byte []EncryptionKey;

            //Decrypts Bytes and stores the result in the above fields
            public void Decrypt()
            {
                //decrypt
                byte []data=new byte[Bytes.Length];
                System.Array.Copy(Bytes, data, Bytes.Length);

                try
                {
                    AuthClientBase.XcCrypt2(AuthClientBase.XC_SERVICE_AES256_CIPHER, AuthClientBase.XC_SERVICE_DECRYPT,
                        EncryptionKey, (uint)EncryptionKey.Length,
                        new byte[16], 16,
                        data, (uint)data.Length,
                        new byte[0], 0);
                }
                finally
                {
                    AuthClientBase.SpewKerbclientDebug();
                }

                //map
                SetInnerBytes(data);
            }

            //Encrypts the above fields and stores the result in Bytes
            public void Encrypt()
            {
                byte []data=GetInnerBytes();
                try
                {
                    AuthClientBase.XcCrypt2(AuthClientBase.XC_SERVICE_AES256_CIPHER, AuthClientBase.XC_SERVICE_ENCRYPT,
                        EncryptionKey, (uint)EncryptionKey.Length,
                        new byte[16], 16,
                        data, (uint)data.Length,
                        new byte[0], 0);
                }
                finally
                {
                    AuthClientBase.SpewKerbclientDebug();
                }

                Bytes=data;
            }

            public byte[] GetInnerBytes()
            {
                byte []data=new byte[16];

                System.Array.Copy(System.BitConverter.GetBytes(Timestamp), 0, data, 0, 8);
                System.Array.Copy(System.BitConverter.GetBytes(Ipv4), 0, data, 8, 4);
                System.Array.Copy(Random, 0, data, 12, 3);
                data[15]=Checksum;

                return data;
            }

            public void SetInnerBytes(byte []data)
            {
                Timestamp=System.BitConverter.ToUInt64(data, 0);
                Ipv4=System.BitConverter.ToUInt32(data, 8);
                Random=new byte[3];
                System.Array.Copy(data, 12, Random, 0, 3);
                Checksum=data[15];
            }

            public override string ToString()
            {
                if (Random==null) //prolly not decrypted yet
                    return base.ToString();
                else
                    return "PreauthXboxEcho: Timestamp="+Timestamp+"("+System.DateTime.FromFileTimeUtc((long)Timestamp)+") Ipv4="+Ipv4+" Random=0x"+ServerTestFramework.Utilities.Hexer.tohex(Random)+" Checksum="+Checksum;
            }

            public int GetPreauthNumber()
            {
                return 205;
            }
        };

        /// <summary> PADATA_XBOX_SERVICE_REQUEST2(201) - Xbox1 service request. </summary>
        public class PreauthXboxServiceRequest1: EncryptedData, IGetPreauthNumber, IContainsEncryptedBytes
        {
            public ushort           RequestVersion;            //normally 1
            public ushort           RequestSize;               //size of this struct, normally 108
            public ushort           ClientVersionMajor;
            public ushort           ClientVersionMinor;
            public ushort           ClientVersionBuild;
            public ushort           ClientVersionQFE;
            public uint             TitleID;                   //upper 16 bits is publisher ID portion
            public uint             TitleVersion;
            public uint             TitleRegion;
            public ulong          []UserIDs;                   //should be an array of length 4, with 0's for unused entries.
            public uint             NumServices;               //total number of services requested
            public uint           []DwordServiceIDs;           //should be an array of length 12, with 0's for unused entries.

            //Key an nonce used to encrypt the data
            public byte []EncryptionKey;
            public uint EncryptionNOnce;

            //
            public PreauthXboxServiceRequest1()
            {
                //set key type and version for encrypted data structure
                Type.Int64=0x17;
                Version=null;
            }

            //Decrypts EncryptedData's Data.Bytes and stores the result in the above fields
            public void Decrypt()
            {
                throw new System.Exception("TODO: implement this.");
            }

            //Encrypts the above fields and stores the result in EncryptedData's Data.Bytes
            public void Encrypt()
            {
                byte []rawBytes=GetInnerBytes();
                EncryptedBytes.Bytes=KdcCrypto.RC4HMACEncryptUsingNonce(rawBytes, EncryptionKey, EncryptionNOnce, KdcCrypto.PA_XBOX_SERVICE_REQUEST_SALT);
            }

            public byte[] GetInnerBytes()
            {
                byte []rawBytes=new byte[108];
                System.Array.Copy(System.BitConverter.GetBytes(RequestVersion), 0, rawBytes, 0, 2);
                System.Array.Copy(System.BitConverter.GetBytes(RequestSize), 0, rawBytes, 2, 2);
                System.Array.Copy(System.BitConverter.GetBytes(ClientVersionMajor), 0, rawBytes, 4, 2);
                System.Array.Copy(System.BitConverter.GetBytes(ClientVersionMinor), 0, rawBytes, 6, 2);
                System.Array.Copy(System.BitConverter.GetBytes(ClientVersionBuild), 0, rawBytes, 8, 2);
                System.Array.Copy(System.BitConverter.GetBytes(ClientVersionQFE), 0, rawBytes, 10, 2);
                System.Array.Copy(System.BitConverter.GetBytes(TitleID), 0, rawBytes, 12, 4);
                System.Array.Copy(System.BitConverter.GetBytes(TitleVersion), 0, rawBytes, 16, 4);
                System.Array.Copy(System.BitConverter.GetBytes(TitleRegion), 0, rawBytes, 20, 4);
                for (int i=0; i<4; ++i)
                {
                    System.Array.Copy(System.BitConverter.GetBytes(UserIDs[i]), 0, rawBytes, 24+i*8, 8);
                }
                System.Array.Copy(System.BitConverter.GetBytes(NumServices), 0, rawBytes, 56, 4);
                for (int i=0; i<12; ++i)
                {
                    System.Array.Copy(System.BitConverter.GetBytes(DwordServiceIDs[i]), 0, rawBytes, 60+i*4, 4);
                }
                return rawBytes;
            }

            public void SetInnerBytes(byte []data)
            {
                throw new System.Exception("TODO: implement this.");
            }

            public override string ToString()
            {
                if (UserIDs==null) //prolly not decrypted yet
                    return base.ToString();

                string s="PreauthXboxServiceRequest1:";
                s+="\nPAXboxSR1 RequestVersion: "+RequestVersion;
                s+="\nPAXboxSR1 RequestSize: "+RequestSize;
                s+="\nPAXboxSR1 ClientVersionMajor: "+ClientVersionMajor;
                s+="\nPAXboxSR1 ClientVersionMinor: "+ClientVersionMinor;
                s+="\nPAXboxSR1 ClientVersionBuild: "+ClientVersionBuild;
                s+="\nPAXboxSR1 ClientVersionQFE: "+ClientVersionQFE;
                s+="\nPAXboxSR1 TitleID: "+TitleID+" (0x"+string.Format("{0:X8}",TitleID)+")";
                s+="\nPAXboxSR1 TitleVersion: "+TitleVersion;
                s+="\nPAXboxSR1 TitleRegion: "+TitleRegion;
                s+="\nPAXboxSR1 UserIDs: ";
                for (int i=0; i<4; ++i)
                {
                    if (i>=1) s+=", ";
                    s+=string.Format("0x{0:X16}", UserIDs[i]);
                }
                s+="\nPAXboxSR1 NumServices: "+NumServices;
                s+="\nPAXboxSR1 DwordServiceIDs: ";
                for (int i=0; i<12; ++i)
                {
                    if (i>=1) s+=", ";
                    s+=DwordServiceIDs[i];
                }

                return s;
            }

            public int GetPreauthNumber()
            {
                return 201;
            }
        };

        /// <summary> PADATA_XBOX_SERVICE_REQUEST2(201) - Xbox1 service request that supports more services. </summary>
        public class PreauthXboxServiceRequest2: EncryptedData, IGetPreauthNumber, IContainsEncryptedBytes
        {
            public ushort           RequestVersion;            //normally 2
            public ushort           RequestSize;               //size of this struct, normally 108
            public ushort           ClientVersionMajor;
            public ushort           ClientVersionMinor;
            public ushort           ClientVersionBuild;
            public ushort           ClientVersionQFE;
            public uint             TitleID;                   //upper 16 bits is publisher ID portion
            public uint             TitleVersion;
            public uint             TitleRegion;
            public ulong          []UserIDs;                   //should be an array of length 4, with 0's for unused entries.
            public uint             NumServices;               //total number of services requested
            public byte           []ByteServiceIDs;            //should be an array of length 12, with 0's for unused entries.
            public uint           []Reserved0;                 //should be 5 dwords padding.  used to make this length match v1
            public uint           []DwordServiceIDs;           //should be an array of length 4, with 0's for unused entries.

            //Key an nonce used to encrypt the data
            public byte []EncryptionKey;
            public uint EncryptionNOnce;

            //
            public PreauthXboxServiceRequest2()
            {
                //set key type and version for encrypted data structure
                Type.Int64=0x17;
                Version=null;
            }

            //Decrypts EncryptedData's Data.Bytes and stores the result in the above fields
            public void Decrypt()
            {
                throw new System.Exception("TODO: implement this.");
            }

            //Encrypts the above fields and stores the result in EncryptedData's Data.Bytes
            public void Encrypt()
            {
                byte []rawBytes=GetInnerBytes();
                EncryptedBytes.Bytes=KdcCrypto.RC4HMACEncryptUsingNonce(rawBytes, EncryptionKey, EncryptionNOnce, KdcCrypto.PA_XBOX_SERVICE_REQUEST_SALT);
            }

            public byte[] GetInnerBytes()
            {
                byte []rawBytes=new byte[108];
                System.Array.Copy(System.BitConverter.GetBytes(RequestVersion), 0, rawBytes, 0, 2);
                System.Array.Copy(System.BitConverter.GetBytes(RequestSize), 0, rawBytes, 2, 2);
                System.Array.Copy(System.BitConverter.GetBytes(ClientVersionMajor), 0, rawBytes, 4, 2);
                System.Array.Copy(System.BitConverter.GetBytes(ClientVersionMinor), 0, rawBytes, 6, 2);
                System.Array.Copy(System.BitConverter.GetBytes(ClientVersionBuild), 0, rawBytes, 8, 2);
                System.Array.Copy(System.BitConverter.GetBytes(ClientVersionQFE), 0, rawBytes, 10, 2);
                System.Array.Copy(System.BitConverter.GetBytes(TitleID), 0, rawBytes, 12, 4);
                System.Array.Copy(System.BitConverter.GetBytes(TitleVersion), 0, rawBytes, 16, 4);
                System.Array.Copy(System.BitConverter.GetBytes(TitleRegion), 0, rawBytes, 20, 4);
                for (int i=0; i<4; ++i)
                {
                    System.Array.Copy(System.BitConverter.GetBytes(UserIDs[i]), 0, rawBytes, 24+i*8, 8);
                }
                System.Array.Copy(System.BitConverter.GetBytes(NumServices), 0, rawBytes, 56, 4);
                for (int i=0; i<12; ++i)
                {
                    rawBytes[60+i]=ByteServiceIDs[i];
                }
                for (int i=0; i<5; ++i)
                {
                    System.Array.Copy(System.BitConverter.GetBytes(Reserved0[i]), 0, rawBytes, 72+i*4, 4);
                }
                for (int i=0; i<4; ++i)
                {
                    System.Array.Copy(System.BitConverter.GetBytes(DwordServiceIDs[i]), 0, rawBytes, 92+i*4, 4);
                }
                return rawBytes;
            }

            public void SetInnerBytes(byte []data)
            {
                throw new System.Exception("TODO: implement this.");
            }

            public override string ToString()
            {
                if (UserIDs==null) //prolly not decrypted yet
                    return base.ToString();

                string s="PreauthXboxServiceRequest2:";
                s+="\nPAXboxSR2 RequestVersion: "+RequestVersion;
                s+="\nPAXboxSR2 RequestSize: "+RequestSize;
                s+="\nPAXboxSR2 ClientVersionMajor: "+ClientVersionMajor;
                s+="\nPAXboxSR2 ClientVersionMinor: "+ClientVersionMinor;
                s+="\nPAXboxSR2 ClientVersionBuild: "+ClientVersionBuild;
                s+="\nPAXboxSR2 ClientVersionQFE: "+ClientVersionQFE;
                s+="\nPAXboxSR2 TitleID: "+TitleID+" (0x"+string.Format("{0:X8}",TitleID)+")";
                s+="\nPAXboxSR2 TitleVersion: "+TitleVersion;
                s+="\nPAXboxSR2 TitleRegion: "+TitleRegion;
                s+="\nPAXboxSR2 UserIDs: ";
                for (int i=0; i<4; ++i)
                {
                    if (i>=1) s+=", ";
                    s+=string.Format("0x{0:X16}", UserIDs[i]);
                }
                s+="\nPAXboxSR2 NumServices: "+NumServices;
                s+="\nPAXboxSR2 ByteServiceIDs: ";
                for (int i=0; i<12; ++i)
                {
                    if (i>=1) s+=", ";
                    s+=ByteServiceIDs[i];
                }
                s+="\nPAXboxSR2 Reserved0: ";
                for (int i=0; i<5; ++i)
                {
                    if (i>=1) s+=", ";
                    s+=Reserved0[i];
                }
                s+="\nPAXboxSR2 DwordServiceIDs: ";
                for (int i=0; i<4; ++i)
                {
                    if (i>=1) s+=", ";
                    s+=DwordServiceIDs[i];
                }

                return s;
            }

            public int GetPreauthNumber()
            {
                return 201;
            }
        };

        /// <summary> Access to fields common to all of the different xenon service request preauths.  This is purely to make validation simpler. </summary>
        public abstract class PreauthXenonServiceRequestBase: EncryptedData, IGetPreauthNumber, IContainsEncryptedBytes
        {
            //common fields
            public ushort           RequestVersion;            //normally 4 for preauth 210 and 5 for preauth 214

            public ushort           ClientVersionMajor;
            public ushort           ClientVersionMinor;
            public ushort           ClientVersionBuild;
            public ushort           ClientVersionQFE;
            public uint             FlashVersion;              //format is 0xMmbbbbqq, where M=major m=minor bbbb=build qq=qfe
            public uint             TitleID;                   //upper 16 bits is publisher ID portion
            public uint             TitleVersion;
            public uint             TitleRegion;
            public uint             ConsoleRegion;
            public uint             MediaID;
            public ushort           LanguageID;
            public ushort           AutoDiscoverServices;      //normally either 0 or 1
            public ulong          []UserIDs;                   //should be an array of length 4, with 0's for unused entries.

            public uint           []DwordServiceIDs;           //should be an array of length 4, with 0's for unused entries

            //Key an nonce used to encrypt the data
            public byte []EncryptionKey;
            public uint EncryptionNOnce;

            //required inherited interfaces
            public abstract int GetPreauthNumber();
            public abstract void Decrypt();
            public abstract void Encrypt();
            public abstract byte[] GetInnerBytes();
            public abstract void SetInnerBytes(byte []data);

            //manipulate byte services for the request
            public abstract byte[] GetRequestedByteServices();
            public abstract void SetRequestedByteServices(byte []services);
        };

        /// <summary> PADATA_XENON_SERVICE_REQUEST2(210) - Original Xbox360/PC service request. </summary>
        public class PreauthXenonServiceRequest2: PreauthXenonServiceRequestBase
        {
            public ushort           RequestSize;               //size of this struct, normally 124
            public ushort           NumByteServices;           //number of used entries in ByteServiceIDs
            public ushort           NumDwordServices;          //number of used entries in DwordServiceIDs
            public byte           []ByteServiceIDs;            //should be an array of length 32, with 0's for unused entries.

            //manipulate byte services for the request
            public override byte[] GetRequestedByteServices()
            {
                return ByteServiceIDs;
            }

            public override void SetRequestedByteServices(byte []services)
            {
                ByteServiceIDs=(byte[])services.Clone();
            }

            //
            public PreauthXenonServiceRequest2()
            {
                //set key type and version for encrypted data structure
                Type.Int64=0x17;
                Version=null;
            }

            //Decrypts EncryptedData's Data.Bytes and stores the result in the above fields
            public override void Decrypt()
            {
                byte []rawBytes=KdcCrypto.RC4HMACDecryptUsingNonce(EncryptedBytes.Bytes, EncryptionKey, EncryptionNOnce, KdcCrypto.PA_XBOX_SERVICE_REQUEST_SALT);
                SetInnerBytes(rawBytes);
            }

            //Encrypts the above fields and stores the result in EncryptedData's Data.Bytes
            public override void Encrypt()
            {
                byte []rawBytes=GetInnerBytes();
                EncryptedBytes.Bytes=KdcCrypto.RC4HMACEncryptUsingNonce(rawBytes, EncryptionKey, EncryptionNOnce, KdcCrypto.PA_XBOX_SERVICE_REQUEST_SALT);
            }

            public override byte[] GetInnerBytes()
            {
                byte []rawBytes=new byte[124];
                System.Array.Copy(System.BitConverter.GetBytes(RequestVersion), 0, rawBytes, 0, 2);
                System.Array.Copy(System.BitConverter.GetBytes(RequestSize), 0, rawBytes, 2, 2);
                System.Array.Copy(System.BitConverter.GetBytes(ClientVersionMajor), 0, rawBytes, 4, 2);
                System.Array.Copy(System.BitConverter.GetBytes(ClientVersionMinor), 0, rawBytes, 6, 2);
                System.Array.Copy(System.BitConverter.GetBytes(ClientVersionBuild), 0, rawBytes, 8, 2);
                System.Array.Copy(System.BitConverter.GetBytes(ClientVersionQFE), 0, rawBytes, 10, 2);
                System.Array.Copy(System.BitConverter.GetBytes(FlashVersion), 0, rawBytes, 12, 4);
                System.Array.Copy(System.BitConverter.GetBytes(TitleID), 0, rawBytes, 16, 4);
                System.Array.Copy(System.BitConverter.GetBytes(TitleVersion), 0, rawBytes, 20, 4);
                System.Array.Copy(System.BitConverter.GetBytes(TitleRegion), 0, rawBytes, 24, 4);
                System.Array.Copy(System.BitConverter.GetBytes(ConsoleRegion), 0, rawBytes, 28, 4);
                System.Array.Copy(System.BitConverter.GetBytes(MediaID), 0, rawBytes, 32, 4);
                System.Array.Copy(System.BitConverter.GetBytes(LanguageID), 0, rawBytes, 36, 2);
                System.Array.Copy(System.BitConverter.GetBytes(AutoDiscoverServices), 0, rawBytes, 38, 2);
                for (int i=0; i<4; ++i)
                {
                    System.Array.Copy(System.BitConverter.GetBytes(UserIDs[i]), 0, rawBytes, 40+i*8, 8);
                }
                System.Array.Copy(System.BitConverter.GetBytes(NumByteServices), 0, rawBytes, 72, 2);
                System.Array.Copy(System.BitConverter.GetBytes(NumDwordServices), 0, rawBytes, 74, 2);
                for (int i=0; i<32; ++i)
                {
                    rawBytes[76+i]=ByteServiceIDs[i];
                }
                for (int i=0; i<4; ++i)
                {
                    System.Array.Copy(System.BitConverter.GetBytes(DwordServiceIDs[i]), 0, rawBytes, 108+i*4, 4);
                }

                return rawBytes;
            }

            public override void SetInnerBytes(byte []data)
            {
                RequestVersion=System.BitConverter.ToUInt16(data, 0);
                RequestSize=System.BitConverter.ToUInt16(data, 2);
                ClientVersionMajor=System.BitConverter.ToUInt16(data, 4);
                ClientVersionMinor=System.BitConverter.ToUInt16(data, 6);
                ClientVersionBuild=System.BitConverter.ToUInt16(data, 8);
                ClientVersionQFE=System.BitConverter.ToUInt16(data, 10);
                FlashVersion=System.BitConverter.ToUInt32(data, 12);
                TitleID=System.BitConverter.ToUInt32(data, 16);
                TitleVersion=System.BitConverter.ToUInt32(data, 20);
                TitleRegion=System.BitConverter.ToUInt32(data, 24);
                ConsoleRegion=System.BitConverter.ToUInt32(data, 28);
                MediaID=System.BitConverter.ToUInt32(data, 32);
                LanguageID=System.BitConverter.ToUInt16(data, 36);
                AutoDiscoverServices=System.BitConverter.ToUInt16(data, 38);
                for (int i=0; i<4; ++i)
                {
                    UserIDs[i]=System.BitConverter.ToUInt64(data, 40+i*8);
                }
                NumByteServices=System.BitConverter.ToUInt16(data, 72);
                NumDwordServices=System.BitConverter.ToUInt16(data, 74);
                for (int i=0; i<32; ++i)
                {
                    ByteServiceIDs[i]=data[76+i];
                }
                for (int i=0; i<4; ++i)
                {
                    DwordServiceIDs[i]=System.BitConverter.ToUInt32(data, 108+i*4);
                }
            }

            public override string ToString()
            {
                if (UserIDs==null) //prolly not decrypted yet
                    return base.ToString();

                string s="PreauthXenonServiceRequest2:";
                s+="\nPAXenonSR2 Version: "+RequestVersion;
                s+="\nPAXenonSR2 RequestSize: "+RequestSize;
                s+="\nPAXenonSR2 ClientVersionMajor: "+ClientVersionMajor;
                s+="\nPAXenonSR2 ClientVersionMinor: "+ClientVersionMinor;
                s+="\nPAXenonSR2 ClientVersionBuild: "+ClientVersionBuild;
                s+="\nPAXenonSR2 ClientVersionQFE: "+ClientVersionQFE;
                s+="\nPAXenonSR2 FlashVersion: "+FlashVersion+" ("+((FlashVersion&0xf0000000)>>28)+"."+((FlashVersion&0x0f000000)>>24)+"."+((FlashVersion&0x00ffff00)>>8)+"."+(FlashVersion&0x000000ff)+")";
                s+="\nPAXenonSR2 TitleID: "+TitleID+" (0x"+string.Format("{0:X8}",TitleID)+")";
                s+="\nPAXenonSR2 TitleVersion: "+TitleVersion;
                s+="\nPAXenonSR2 TitleRegion: "+TitleRegion;
                s+="\nPAXenonSR2 ConsoleRegion: "+ConsoleRegion;
                s+="\nPAXenonSR2 MediaID: "+MediaID;
                s+="\nPAXenonSR2 LanguageID: "+LanguageID;
                s+="\nPAXenonSR2 AutoDiscoverServices: "+AutoDiscoverServices;
                s+="\nPAXenonSR2 UserIDs: ";
                for (int i=0; i<4; ++i)
                {
                    if (i>=1) s+=", ";
                    s+=string.Format("0x{0:X16}", UserIDs[i]);
                }
                s+="\nPAXenonSR2 NumByteServices: "+NumByteServices;
                s+="\nPAXenonSR2 NumDwordServices: "+NumDwordServices;
                s+="\nPAXenonSR2 ByteServiceIDs: ";
                for (int i=0; i<32; ++i)
                {
                    if (i>=1) s+=", ";
                    s+=ByteServiceIDs[i];
                }
                s+="\nPAXenonSR2 DwordServiceIDs: ";
                for (int i=0; i<4; ++i)
                {
                    if (i>=1) s+=", ";
                    s+=DwordServiceIDs[i];
                }

                return s;
            }

            public override int GetPreauthNumber()
            {
                return 210;
            }
        };

        /// <summary> PADATA_XENON_SERVICE_REQUEST3(214) - Updated Xbox360/PC service request that supports 128 services. </summary>
        public class PreauthXenonServiceRequest3: PreauthXenonServiceRequestBase
        {
            public byte           []ByteServiceBits;           //should be an array of length 16, 1 bit per service
            public uint           []ReservedForUserPinsLater;  //should be an array of length 4, zero'd out
            public ulong            FlowToken;

            //manipulate byte services for the request
            public override byte[] GetRequestedByteServices()
            {
                System.Collections.Generic.List<byte> services=new System.Collections.Generic.List<byte>();
                for (byte b=0; b<128; ++b)
                {
                    if (GetByteServiceBit(b))
                    {
                        services.Add(b);
                    }
                }

                return services.ToArray();
            }

            public override void SetRequestedByteServices(byte []services)
            {
                ByteServiceBits=new byte[16];
                foreach (byte b in services)
                {
                    SetByteServiceBit(b, true);
                }
            }

            public bool GetByteServiceBit(int service)
            {
                if (service>=128)
                {
                    throw new System.Exception("XenonServiceRequest3 can only represent byte services in the range of 0-127");
                }

                //TODO: is this little endian or big endian?
                int byt=service/8;
                int bit=service%8;

                return 0!=(ByteServiceBits[byt]&(1<<bit));
            }

            public void SetByteServiceBit(int service, bool value)
            {
                if (service>=128)
                {
                    throw new System.Exception("XenonServiceRequest3 can only represent byte services in the range of 0-127");
                }

                //TODO: is this little endian or big endian?
                int byt=service/8;
                int bit=service%8;

                if (value)
                {
                    ByteServiceBits[byt]|=(byte)(1<<bit);
                }
                else
                {
                    ByteServiceBits[byt]&=(byte)~(1<<bit);
                }
            }

            //
            public PreauthXenonServiceRequest3()
            {
                //set key type and version for encrypted data structure
                Type.Int64=0x17;
                Version=null;
            }

            //Decrypts EncryptedData's Data.Bytes and stores the result in the above fields
            public override void Decrypt()
            {
                byte []rawBytes=KdcCrypto.RC4HMACDecryptUsingNonce(EncryptedBytes.Bytes, EncryptionKey, EncryptionNOnce, KdcCrypto.PA_XBOX_SERVICE_REQUEST_SALT);
                SetInnerBytes(rawBytes);
            }

            //Encrypts the above fields and stores the result in EncryptedData's Data.Bytes
            public override void Encrypt()
            {
                byte []rawBytes=GetInnerBytes();
                EncryptedBytes.Bytes=KdcCrypto.RC4HMACEncryptUsingNonce(rawBytes, EncryptionKey, EncryptionNOnce, KdcCrypto.PA_XBOX_SERVICE_REQUEST_SALT);
            }

            public override byte[] GetInnerBytes()
            {
                byte []rawBytes=new byte[126];
                System.Array.Copy(System.BitConverter.GetBytes(RequestVersion), 0, rawBytes, 0, 2);
                System.Array.Copy(System.BitConverter.GetBytes(ClientVersionMajor), 0, rawBytes, 2, 2);
                System.Array.Copy(System.BitConverter.GetBytes(ClientVersionMinor), 0, rawBytes, 4, 2);
                System.Array.Copy(System.BitConverter.GetBytes(ClientVersionBuild), 0, rawBytes, 6, 2);
                System.Array.Copy(System.BitConverter.GetBytes(ClientVersionQFE), 0, rawBytes, 8, 2);
                System.Array.Copy(System.BitConverter.GetBytes(FlashVersion), 0, rawBytes, 10, 4);
                System.Array.Copy(System.BitConverter.GetBytes(TitleID), 0, rawBytes, 14, 4);
                System.Array.Copy(System.BitConverter.GetBytes(TitleVersion), 0, rawBytes, 18, 4);
                System.Array.Copy(System.BitConverter.GetBytes(TitleRegion), 0, rawBytes, 22, 4);
                System.Array.Copy(System.BitConverter.GetBytes(ConsoleRegion), 0, rawBytes, 26, 4);
                System.Array.Copy(System.BitConverter.GetBytes(MediaID), 0, rawBytes, 30, 4);
                System.Array.Copy(System.BitConverter.GetBytes(LanguageID), 0, rawBytes, 34, 2);
                System.Array.Copy(System.BitConverter.GetBytes(AutoDiscoverServices), 0, rawBytes, 36, 2);
                for (int i=0; i<4; ++i)
                {
                    System.Array.Copy(System.BitConverter.GetBytes(UserIDs[i]), 0, rawBytes, 38+i*8, 8);
                }
                System.Array.Copy(ByteServiceBits, 0, rawBytes, 70, 16);
                for (int i=0; i<4; ++i)
                {
                    System.Array.Copy(System.BitConverter.GetBytes(DwordServiceIDs[i]), 0, rawBytes, 86+i*4, 4);
                }
                for (int i=0; i<4; ++i)
                {
                    System.Array.Copy(System.BitConverter.GetBytes(ReservedForUserPinsLater[i]), 0, rawBytes, 102+i*4, 4);
                }
                System.Array.Copy(System.BitConverter.GetBytes(FlowToken), 0, rawBytes, 118, 8);

                return rawBytes;
            }

            public override void SetInnerBytes(byte []data)
            {
                RequestVersion=System.BitConverter.ToUInt16(data, 0);
                ClientVersionMajor=System.BitConverter.ToUInt16(data, 2);
                ClientVersionMinor=System.BitConverter.ToUInt16(data, 4);
                ClientVersionBuild=System.BitConverter.ToUInt16(data, 6);
                ClientVersionQFE=System.BitConverter.ToUInt16(data, 8);
                FlashVersion=System.BitConverter.ToUInt32(data, 10);
                TitleID=System.BitConverter.ToUInt32(data, 14);
                TitleVersion=System.BitConverter.ToUInt32(data, 18);
                TitleRegion=System.BitConverter.ToUInt32(data, 22);
                ConsoleRegion=System.BitConverter.ToUInt32(data, 26);
                MediaID=System.BitConverter.ToUInt32(data, 30);
                LanguageID=System.BitConverter.ToUInt16(data, 34);
                AutoDiscoverServices=System.BitConverter.ToUInt16(data, 36);
                for (int i=0; i<4; ++i)
                {
                    UserIDs[i]=System.BitConverter.ToUInt64(data, 38+i*8);
                }
                System.Array.Copy(data, 70, ByteServiceBits, 0, 16);
                for (int i=0; i<4; ++i)
                {
                    DwordServiceIDs[i]=System.BitConverter.ToUInt32(data, 86+i*4);
                }
                for (int i=0; i<4; ++i)
                {
                    ReservedForUserPinsLater[i]=System.BitConverter.ToUInt32(data, 102+i*4);
                }
                FlowToken=System.BitConverter.ToUInt64(data, 118);
            }

            public override string ToString()
            {
                if (UserIDs==null) //prolly not decrypted yet
                    return base.ToString();

                string s="PreauthXenonServiceRequest3:";
                s+="\nPAXenonSR3 Version: "+RequestVersion;
                s+="\nPAXenonSR3 ClientVersionMajor: "+ClientVersionMajor;
                s+="\nPAXenonSR3 ClientVersionMinor: "+ClientVersionMinor;
                s+="\nPAXenonSR3 ClientVersionBuild: "+ClientVersionBuild;
                s+="\nPAXenonSR3 ClientVersionQFE: "+ClientVersionQFE;
                s+="\nPAXenonSR3 FlashVersion: "+FlashVersion+" ("+((FlashVersion&0xf0000000)>>28)+"."+((FlashVersion&0x0f000000)>>24)+"."+((FlashVersion&0x00ffff00)>>8)+"."+(FlashVersion&0x000000ff)+")";
                s+="\nPAXenonSR3 TitleID: "+TitleID+" (0x"+string.Format("{0:X8}",TitleID)+")";
                s+="\nPAXenonSR3 TitleVersion: "+TitleVersion;
                s+="\nPAXenonSR3 TitleRegion: "+TitleRegion;
                s+="\nPAXenonSR3 ConsoleRegion: "+ConsoleRegion;
                s+="\nPAXenonSR3 MediaID: "+MediaID;
                s+="\nPAXenonSR3 LanguageID: "+LanguageID;
                s+="\nPAXenonSR3 AutoDiscoverServices: "+AutoDiscoverServices;
                s+="\nPAXenonSR3 UserIDs: ";
                for (int i=0; i<4; ++i)
                {
                    if (i>=1) s+=", ";
                    s+=string.Format("0x{0:X16}", UserIDs[i]);
                }
                s+="\nPAXenonSR3 ByteServiceIDs: ";
                bool isFirstAddedEntry=false;
                for (int i=0; i<128; ++i)
                {
                    if (GetByteServiceBit(i))
                    {
                        if (isFirstAddedEntry) s+=", ";
                        isFirstAddedEntry=true;
                        s+=i;
                    }
                }
                s+="\nPAXenonSR3 DwordServiceIDs: ";
                for (int i=0; i<4; ++i)
                {
                    if (i>=1) s+=", ";
                    s+=DwordServiceIDs[i];
                }
                s+="\nPAXenonSR3 Reserved(for UserPin later): ";
                for (int i=0; i<4; ++i)
                {
                    if (i>=1) s+=", ";
                    s+=ReservedForUserPinsLater[i];
                }
                s+="\nPAXenonSR3 FlowToken: "+string.Format("0x{0:X}", FlowToken);

                return s;
            }

            public override int GetPreauthNumber()
            {
                return 214;
            }
        };

        /// <summary> PADATA_XBOX_SERVICE_ADDRESS(202) - Site and service information returned by xkdc for xbox1.  This is a dummy base class used to create the correct derived class based on the contents. </summary>
        public class PreauthXboxServiceAddress: AsnBytes, IGetPreauthNumber
        {
            private uint internalDecryptedNumServices=0;
            private byte []internalDecryptedBytes;

            //The data in the struct is held inside of an EncryptedData structure
            public Kerberos.EncryptedData DataContainer;

            //Creates either PreauthXboxServiceAddress1 or PreauthXboxServiceAddress2
            public PreauthXboxServiceAddress DecryptAndCreateSpecific(byte []key, uint nonce)
            {
                //Decrypt and extract the number of services contained
                Decrypt(key, nonce);

                //now create the appropriate type
                PreauthXboxServiceAddress addy;
                if (internalDecryptedNumServices<=12) //v1
                {
                    addy=new PreauthXboxServiceAddress1();
                }
                else //v2
                {
                    addy=new PreauthXboxServiceAddress2();
                }

                addy.Bytes=Bytes;
                addy.SetFieldsFromBytes(internalDecryptedBytes);
                return addy;
            }

            //Decrypts Bytes using a key and a specific nonce as part of the salt, and creates the specific type to return.
            public void Decrypt(byte []key, uint nonce)
            {
                //the first part is not encrypted, it is an ASN EncryptedData.  Pull that out.
                long bytesUsed;
                AsnValueBase asnValues=Compound.AsnValueParser.Parse(Bytes, 0, Bytes.Length, out bytesUsed);
                DataContainer=Kerberos.EncryptedData.CreateFromAsn((Compound.TagLengthValue)asnValues);

                if (DataContainer.EncryptedBytes.Bytes.Length!=224+KdcCrypto.HmacCryptoOverhead)
                {
                    throw new KerberosAsnException("Unable to decrypt PreauthXboxServiceAddress: Expected "+(224+KdcCrypto.HmacCryptoOverhead)+" bytes of encrypted data but there are "+DataContainer.EncryptedBytes.Bytes.Length);
                }

                //decrypt the encrypted bytes
                internalDecryptedBytes=KdcCrypto.RC4HMACDecryptUsingNonce(DataContainer.EncryptedBytes.Bytes, key, nonce, KdcCrypto.PA_XBOX_SERVICE_ADDRESS_SALT);
                SetFieldsFromBytes(internalDecryptedBytes);
            }

            public virtual void SetFieldsFromBytes(byte []data)
            {
                internalDecryptedNumServices=System.BitConverter.ToUInt32(data, 76);
            }

            //returns whether the encrypted data has been properly decrypted and set
            public virtual bool IsValid()
            {
                return false;
            }

            public int GetPreauthNumber()
            {
                return 202;
            }
        }

        /// <summary> PADATA_XBOX_SERVICE_ADDRESS(202) - Site and service information.  This is returned by xkdc for xbox1. </summary>
        public class PreauthXboxServiceAddress1: PreauthXboxServiceAddress
        {
            //Unencrypted data below.  The asn encrypted data container is stored in Bytes.
            public uint     Hr;                    //overall hresult for the request
            public uint   []HrUser;                //array of 4 hresults, one for each user
            public uint   []UserFlags;             //array of 4 dword flags, one for each user
            public uint     BwLimit;               //bandwidth throttling mechanism that's not currently used
            public uint   []Reserved0;             //array of 8 dwords
            public uint     SiteIP;                //packed IP address of the site
            public uint     NumServices;           //number of actual services returned
            public XboxServiceResult           []DwordServiceResult; //array of 12 results

            public struct XboxServiceResult
            {
                public uint   ServiceID;
                public uint   Hr;
                public ushort ServicePort;
                public ushort Reserved0;

                public static XboxServiceResult FromBytes(byte []bytes, int offset)
                {
                    XboxServiceResult me=new XboxServiceResult();
                    me.ServiceID=System.BitConverter.ToUInt32(bytes, offset);
                    me.Hr=System.BitConverter.ToUInt32(bytes, offset+4);
                    me.ServicePort=System.BitConverter.ToUInt16(bytes, offset+8);
                    me.Reserved0=System.BitConverter.ToUInt16(bytes, offset+10);
                    return me;
                }
            };

            //convenient way to get the IP as a string
            public string GetSiteIPString()
            {
                return ""+(SiteIP&0xff)+"."+((SiteIP&(0xff00))>>8)+"."+((SiteIP&(0xff0000))>>16)+"."+((SiteIP&(0xff000000))>>24);
            }

            //Stores a blob of bytes into the above fields.
            public override void SetFieldsFromBytes(byte []data)
            {
                Hr=System.BitConverter.ToUInt32(data, 0);
                HrUser=new uint[4];
                for (int i=0; i<4; ++i)
                    HrUser[i]=System.BitConverter.ToUInt32(data, 4+i*4);
                UserFlags=new uint[4];
                for (int i=0; i<4; ++i)
                    UserFlags[i]=System.BitConverter.ToUInt32(data, 20+i*4);
                BwLimit=System.BitConverter.ToUInt32(data, 36);
                Reserved0=new uint[8];
                for (int i=0; i<8; ++i)
                    Reserved0[i]=System.BitConverter.ToUInt32(data, 40+i*4);
                SiteIP=System.BitConverter.ToUInt32(data, 72);
                NumServices=System.BitConverter.ToUInt32(data, 76);
                DwordServiceResult=new XboxServiceResult[12];
                for (int i=0; i<12; ++i)
                    DwordServiceResult[i]=XboxServiceResult.FromBytes(data, 80+i*12);
            }

            //sets relevent fields into the generic xkdc output
            public void SetIntoGenericXkdcOutput(XkdcGenericReplyOutput xkdcOutput)
            {
                xkdcOutput.Hr=Hr;
                xkdcOutput.HrUser=HrUser;
                xkdcOutput.UserFlags=UserFlags;
                xkdcOutput.SiteIP=GetSiteIPString();
                xkdcOutput.UserPrivileges=new uint[12]; //xbox1 doesn't have privileges

                System.Collections.Generic.List<XkdcGenericReplyOutput.ServiceResult> resultsList=new System.Collections.Generic.List<XkdcGenericReplyOutput.ServiceResult>();
                if (DwordServiceResult!=null)
                {
                    for (int i=0; i<DwordServiceResult.Length; ++i)
                    {
                        if (DwordServiceResult[i].ServiceID!=0 || DwordServiceResult[i].Hr!=0 || DwordServiceResult[i].ServicePort!=0)
                        {
                            XkdcGenericReplyOutput.ServiceResult r=new XkdcGenericReplyOutput.ServiceResult();
                            r.Service=DwordServiceResult[i].ServiceID;
                            r.Hr=DwordServiceResult[i].Hr;
                            r.Port=DwordServiceResult[i].ServicePort;
                            resultsList.Add(r);
                        }
                    }
                }
                xkdcOutput.ServiceResults=resultsList.ToArray();
                xkdcOutput.UserBanExpireTime=new ulong[4]; //xbox1 doesn't have ban expiration times
            }

            //returns whether the encrypted data has been properly decrypted and set
            public override bool IsValid()
            {
                return HrUser!=null;
            }

            //
            public override string ToString()
            {
                if (!IsValid())
                    return base.ToString();
                else
                {
                    string s="PreauthXboxServiceAddress1:";
                    s+="\nPAXboxSA1 Hr: 0x"+Hr.ToString("X");
                    s+="\nPAXboxSA1 HrUser: [0]=0x"+HrUser[0].ToString("X")+"  [1]=0x"+HrUser[1].ToString("X")+"  [2]=0x"+HrUser[2].ToString("X")+"  [3]=0x"+HrUser[3].ToString("X");
                    s+="\nPAXboxSA1 UserFlags: [0]=0x"+UserFlags[0].ToString("X")+"  [1]=0x"+UserFlags[1].ToString("X")+"  [2]=0x"+UserFlags[2].ToString("X")+"  [3]=0x"+UserFlags[3].ToString("X");
                    s+="\nPAXboxSA1 BwLimit: "+BwLimit;
                    s+="\nPAXboxSA1 SiteIP: "+GetSiteIPString();
                    s+="\nPAXboxSA1 NumServices: "+NumServices;
                    s+="\nPAXboxSA1 DwordServiceResult: ";
                    bool firstDsr=true;
                    for (int dsr=0; dsr<4; ++dsr)
                    {
                        if (DwordServiceResult[dsr].ServiceID!=0 || DwordServiceResult[dsr].Hr!=0 || DwordServiceResult[dsr].ServicePort!=0 || DwordServiceResult[dsr].Reserved0!=0)
                        {
                            if (!firstDsr) s+=", ";
                            firstDsr=false;
                            s+="(Service="+DwordServiceResult[dsr].ServiceID+" Hr=0x"+DwordServiceResult[dsr].Hr.ToString("X")+" Port="+DwordServiceResult[dsr].ServicePort+" Reserved="+DwordServiceResult[dsr].Reserved0+")";
                        }
                    }
                    return s;
                }
            }
        };

        /// <summary> PADATA_XBOX_SERVICE_ADDRESS(202) - Site and service information.  This is returned by xkdc for xbox1. </summary>
        public class PreauthXboxServiceAddress2: PreauthXboxServiceAddress
        {
            //Unencrypted data below.  The asn encrypted data container is stored in Bytes.
            public uint     Hr;                    //overall hresult for the request
            public uint   []HrUser;                //array of 4 hresults, one for each user
            public uint   []UserFlags;             //array of 4 dword flags, one for each user
            public uint     BwLimit;               //bandwidth throttling mechanism that's not currently used
            public uint   []Reserved0;             //array of 8 dwords
            public uint     SiteIP;                //packed IP address of the site
            public uint     NumServices;           //number of actual services returned
            public XboxSingleByteServiceResult                    []ByteServiceResult;  //array of 12 results
            public PreauthXboxServiceAddress1.XboxServiceResult   []DwordServiceResult; //array of 4 results

            public struct XboxSingleByteServiceResult
            {
                public byte   ServiceID;
                public byte   Reserved;
                public ushort ServicePort;
                public uint   Result;

                public static XboxSingleByteServiceResult FromBytes(byte []bytes, int offset)
                {
                    XboxSingleByteServiceResult me=new XboxSingleByteServiceResult();
                    me.ServiceID=bytes[offset];
                    me.Reserved=bytes[offset+1];
                    me.ServicePort=System.BitConverter.ToUInt16(bytes, offset+2);
                    me.Result=System.BitConverter.ToUInt32(bytes, offset+4);
                    return me;
                }
            };

            //convenient way to get the IP as a string
            public string GetSiteIPString()
            {
                return ""+(SiteIP&0xff)+"."+((SiteIP&(0xff00))>>8)+"."+((SiteIP&(0xff0000))>>16)+"."+((SiteIP&(0xff000000))>>24);
            }

            //Stores a blob of bytes into the above fields.
            public override void SetFieldsFromBytes(byte []data)
            {
                Hr=System.BitConverter.ToUInt32(data, 0);
                HrUser=new uint[4];
                for (int i=0; i<4; ++i)
                    HrUser[i]=System.BitConverter.ToUInt32(data, 4+i*4);
                UserFlags=new uint[4];
                for (int i=0; i<4; ++i)
                    UserFlags[i]=System.BitConverter.ToUInt32(data, 20+i*4);
                BwLimit=System.BitConverter.ToUInt32(data, 36);
                Reserved0=new uint[8];
                for (int i=0; i<8; ++i)
                    Reserved0[i]=System.BitConverter.ToUInt32(data, 40+i*4);
                SiteIP=System.BitConverter.ToUInt32(data, 72);
                NumServices=System.BitConverter.ToUInt32(data, 76);
                ByteServiceResult=new XboxSingleByteServiceResult[12];
                for (int i=0; i<12; ++i)
                    ByteServiceResult[i]=XboxSingleByteServiceResult.FromBytes(data, 80+i*8);
                DwordServiceResult=new PreauthXboxServiceAddress1.XboxServiceResult[4];
                for (int i=0; i<4; ++i)
                    DwordServiceResult[i]=PreauthXboxServiceAddress1.XboxServiceResult.FromBytes(data, 176+i*12);
            }

            //sets relevent fields into the generic xkdc output
            public void SetIntoGenericXkdcOutput(XkdcGenericReplyOutput xkdcOutput)
            {
                xkdcOutput.Hr=Hr;
                xkdcOutput.HrUser=HrUser;
                xkdcOutput.UserFlags=UserFlags;
                xkdcOutput.SiteIP=GetSiteIPString();
                xkdcOutput.UserPrivileges=new uint[12]; //xbox1 doesn't have privileges

                System.Collections.Generic.List<XkdcGenericReplyOutput.ServiceResult> resultsList=new System.Collections.Generic.List<XkdcGenericReplyOutput.ServiceResult>();
                if (ByteServiceResult!=null)
                {
                    for (int i=0; i<ByteServiceResult.Length; ++i)
                    {
                        if (ByteServiceResult[i].ServiceID!=0 || ByteServiceResult[i].Result!=0 || ByteServiceResult[i].ServicePort!=0)
                        {
                            XkdcGenericReplyOutput.ServiceResult r=new XkdcGenericReplyOutput.ServiceResult();
                            r.Service=ByteServiceResult[i].ServiceID;
                            r.Hr=ByteServiceResult[i].Result;
                            r.Port=ByteServiceResult[i].ServicePort;
                            resultsList.Add(r);
                        }
                    }
                }
                if (DwordServiceResult!=null)
                {
                    for (int i=0; i<DwordServiceResult.Length; ++i)
                    {
                        if (DwordServiceResult[i].ServiceID!=0 || DwordServiceResult[i].Hr!=0 || DwordServiceResult[i].ServicePort!=0)
                        {
                            XkdcGenericReplyOutput.ServiceResult r=new XkdcGenericReplyOutput.ServiceResult();
                            r.Service=DwordServiceResult[i].ServiceID;
                            r.Hr=DwordServiceResult[i].Hr;
                            r.Port=DwordServiceResult[i].ServicePort;
                            resultsList.Add(r);
                        }
                    }
                }
                xkdcOutput.ServiceResults=resultsList.ToArray();
                xkdcOutput.UserBanExpireTime=new ulong[4]; //xbox1 doesn't have ban expiration times
            }

            //returns whether the encrypted data has been properly decrypted and set
            public override bool IsValid()
            {
                return HrUser!=null;
            }

            //
            public override string ToString()
            {
                if (!IsValid()) //prolly not decrypted yet
                    return base.ToString();
                else
                {
                    string s="PreauthXboxServiceAddress2:";
                    s+="\nPAXboxSA2 Hr: 0x"+Hr.ToString("X");
                    s+="\nPAXboxSA2 HrUser: [0]=0x"+HrUser[0].ToString("X")+"  [1]=0x"+HrUser[1].ToString("X")+"  [2]=0x"+HrUser[2].ToString("X")+"  [3]=0x"+HrUser[3].ToString("X");
                    s+="\nPAXboxSA2 UserFlags: [0]=0x"+UserFlags[0].ToString("X")+"  [1]=0x"+UserFlags[1].ToString("X")+"  [2]=0x"+UserFlags[2].ToString("X")+"  [3]=0x"+UserFlags[3].ToString("X");
                    s+="\nPAXboxSA2 BwLimit: "+BwLimit;
                    s+="\nPAXboxSA2 SiteIP: "+GetSiteIPString();
                    s+="\nPAXboxSA2 NumServices: "+NumServices;
                    s+="\nPAXboxSA2 ByteServiceResult: ";
                    bool firstBsr=true;
                    for (int bsr=0; bsr<12; ++bsr)
                    {
                        if (ByteServiceResult[bsr].ServiceID!=0 || ByteServiceResult[bsr].Reserved!=0 || ByteServiceResult[bsr].ServicePort!=0 || ByteServiceResult[bsr].Result!=0)
                        {
                            if (!firstBsr) s+=", ";
                            firstBsr=false;
                            s+="(Service="+ByteServiceResult[bsr].ServiceID+" Reserved="+ByteServiceResult[bsr].Reserved+" Port="+ByteServiceResult[bsr].ServicePort+" Result="+ByteServiceResult[bsr].Result+")";
                        }
                    }
                    s+="\nPAXboxSA2 DwordServiceResult: ";
                    bool firstDsr=true;
                    for (int dsr=0; dsr<4; ++dsr)
                    {
                        if (DwordServiceResult[dsr].ServiceID!=0 || DwordServiceResult[dsr].Hr!=0 || DwordServiceResult[dsr].ServicePort!=0 || DwordServiceResult[dsr].Reserved0!=0)
                        {
                            if (!firstDsr) s+=", ";
                            firstDsr=false;
                            s+="(Service="+DwordServiceResult[dsr].ServiceID+" Hr=0x"+DwordServiceResult[dsr].Hr.ToString("X")+" Port="+DwordServiceResult[dsr].ServicePort+" Reserved="+DwordServiceResult[dsr].Reserved0+")";
                        }
                    }
                    return s;
                }
            }
        };

        /// <summary> Possible responses for requests for byte services. Note that the numeric values here corresponde to XenonServiceAddress3's meanings. </summary>
        public enum ByteServiceResultValue
        {
            Granted=0,
            OtherSite=1,
            Denied=2,
            Invalid=3
        };

        /// <summary> Fields and methods common to the different xenon service address preauths. </summary>
        public abstract class PreauthXenonServiceAddressBase: AsnBytes, IGetPreauthNumber
        {
            //Unencrypted data below.  The asn encrypted data container is stored in Bytes.  These are fields common to both of the different preauths.
            public uint     Hr;                    //overall hresult for the request
            public uint   []HrUser;                //array of 4 hresults, one for each user
            public uint   []UserFlags;             //array of 4 dword flags, one for each user
            public uint     SiteIP;                //packed IP address of the site
            public XenonServiceResult           []DwordServiceResult; //array of 4 results
            public uint     LiveTitleId;           //title id
            public XboxServiceAlternateTitleID  []AltLiveTitleIds;    //array of 4 alt IDs

            public abstract int GetExpectedSize();

            //The data above (and the preauth-specific data) is held inside of an EncryptedData structure
            public Kerberos.EncryptedData DataContainer;

            //convenient way to get the IP as a string
            public string GetSiteIPString()
            {
                return ""+(SiteIP&0xff)+"."+((SiteIP&(0xff00))>>8)+"."+((SiteIP&(0xff0000))>>16)+"."+((SiteIP&(0xff000000))>>24);
            }

            //convenient way to get a specific privilege bit for a user from the dword arrays
            public abstract bool GetUserPrivilegeBit(int user, int bit);

            //Gets the result for a specific byte service
            public abstract ByteServiceResultValue GetByteServiceResult(int service);

             //Decrypts Bytes using a key and a specific nonce and stores it in the unencrypted fields.
            public void Decrypt(byte[] key, uint nonce)
            {
                //the first part is not encrypted, it is an ASN EncryptedData.  Pull that out.
                long bytesUsed;
                AsnValueBase asnValues = Compound.AsnValueParser.Parse(Bytes, 0, Bytes.Length, out bytesUsed);
                DataContainer = Kerberos.EncryptedData.CreateFromAsn((Compound.TagLengthValue)asnValues);

                int expectedEncryptedSize=GetExpectedSize()+KdcCrypto.HmacCryptoOverhead;
                if (DataContainer.EncryptedBytes.Bytes.Length!=expectedEncryptedSize)
                {
                    throw new KerberosAsnException("Unable to decrypt PreauthXenonServiceAddress: Expected " + expectedEncryptedSize + " bytes of encrypted data but there are " + DataContainer.EncryptedBytes.Bytes.Length);
                }

                //decrypt the encrypted bytes
                byte[] decryptedBytes = KdcCrypto.RC4HMACDecryptUsingNonce(DataContainer.EncryptedBytes.Bytes, key, nonce, KdcCrypto.PA_XBOX_SERVICE_ADDRESS_SALT);

                //store the decrypted bytes into the unencrypted fields
                ReadDecryptedBytes(new System.IO.BinaryReader(new System.IO.MemoryStream(decryptedBytes)));
            }

            //copied raw bytes into the unencrypted version of the fields
            protected abstract void ReadDecryptedBytes(System.IO.BinaryReader reader);

            public abstract void SetIntoGenericXkdcOutput(XkdcGenericReplyOutput xkdcOutput);

            //returns whether the encrypted data has been properly decrypted and set
            public bool IsValid()
            {
                return HrUser!=null;
            }

            public abstract int GetPreauthNumber();
        };

        /// <summary> PADATA_XENON_SERVICE_ADDRESS2(211) - Site, service, and privilege information.  This is returned by xkdc in response to a XenonServiceRequest2. </summary>
        public class PreauthXenonServiceAddress2: PreauthXenonServiceAddressBase
        {
            //Unencrypted data below.  The asn encrypted data container is stored in Bytes.
            public uint     BwLimit;               //bandwidth throttling mechanism that's not currently used
            public uint   []UserPrivileges;        //4 (1 for each user) blobs of 256 bits, of privileges (stored as 8 dwords each)
            public ushort   NumServices;           //number of actual services returned
            public XenonSingleByteServiceResult []ByteServiceResult;  //array of 32 results

            public override int GetExpectedSize()
            {
                return 354;
            }

            //convenient way to get a specific privilege bit for a user from the dword arrays
            public override bool GetUserPrivilegeBit(int user, int bit)
            {
                int dword=bit/32;
                int subbit=bit%32;
                return (UserPrivileges[user*8+dword]&(1<<subbit))!=0;
            }

            public override ByteServiceResultValue GetByteServiceResult(int service)
            {
                if (service==0)
                {
                    return ByteServiceResultValue.Invalid;
                }

                for (int i=0; i<32; ++i)
                {
                    if (ByteServiceResult[i].ServiceID==service)
                    {
                        return (ByteServiceResultValue)ByteServiceResult[i].Result;
                    }
                }

                return ByteServiceResultValue.Invalid;
            }

            protected override void ReadDecryptedBytes(System.IO.BinaryReader reader)
            {
                //store fields
                Hr = reader.ReadUInt32();
                HrUser = new uint[4];
                for (int i = 0; i < 4; ++i)
                    HrUser[i] = reader.ReadUInt32();
                UserFlags = new uint[4];
                for (int i = 0; i < 4; ++i)
                    UserFlags[i] = reader.ReadUInt32();
                BwLimit = reader.ReadUInt32();
                SiteIP = reader.ReadUInt32();
                UserPrivileges = new uint[32];
                for (int i = 0; i < 32; ++i)
                    UserPrivileges[i]=reader.ReadUInt32();
                NumServices = reader.ReadUInt16();
                ByteServiceResult = new XenonSingleByteServiceResult[32];
                for (int i = 0; i < 32; ++i)
                    ByteServiceResult[i] = XenonSingleByteServiceResult.FromStream(reader);
                DwordServiceResult = new XenonServiceResult[4];
                for (int i = 0; i < 4; ++i)
                    DwordServiceResult[i] = XenonServiceResult.FromStream(reader);
                LiveTitleId = reader.ReadUInt32();
                AltLiveTitleIds = new XboxServiceAlternateTitleID[4];
                for (int i = 0; i < 4; ++i)
                    AltLiveTitleIds[i] = XboxServiceAlternateTitleID.FromStream(reader);
            }

            //sets relevent fields into the generic xkdc output
            public override void SetIntoGenericXkdcOutput(XkdcGenericReplyOutput xkdcOutput)
            {
                xkdcOutput.Hr=Hr;
                xkdcOutput.HrUser=HrUser;
                xkdcOutput.UserFlags=UserFlags;
                xkdcOutput.SiteIP=GetSiteIPString();

                xkdcOutput.UserPrivileges=new uint[4*3];
                xkdcOutput.MachinePrivileges=0;
                for (int i=0; i<4; ++i) //each user
                {
                    System.Array.Copy(UserPrivileges, i*8+5, xkdcOutput.UserPrivileges, i*3, 3);
                    xkdcOutput.MachinePrivileges|=UserPrivileges[i*8+4];
                }

                System.Collections.Generic.List<XkdcGenericReplyOutput.ServiceResult> resultsList=new System.Collections.Generic.List<XkdcGenericReplyOutput.ServiceResult>();
                if (ByteServiceResult!=null)
                {
                    for (int i=0; i<ByteServiceResult.Length; ++i)
                    {
                        if (ByteServiceResult[i].ServiceID!=0 || ByteServiceResult[i].Result!=0 || ByteServiceResult[i].ServicePort!=0)
                        {
                            XkdcGenericReplyOutput.ServiceResult r=new XkdcGenericReplyOutput.ServiceResult();
                            r.Service=ByteServiceResult[i].ServiceID;
                            r.Hr=ByteServiceResult[i].Result;
                            r.Port=ByteServiceResult[i].ServicePort;
                            resultsList.Add(r);
                        }
                    }
                }
                if (DwordServiceResult!=null)
                {
                    for (int i=0; i<DwordServiceResult.Length; ++i)
                    {
                        if (DwordServiceResult[i].ServiceID!=0 || DwordServiceResult[i].Result!=0 || DwordServiceResult[i].ServicePort!=0)
                        {
                            XkdcGenericReplyOutput.ServiceResult r=new XkdcGenericReplyOutput.ServiceResult();
                            r.Service=DwordServiceResult[i].ServiceID;
                            r.Hr=DwordServiceResult[i].Result;
                            r.Port=DwordServiceResult[i].ServicePort;
                            resultsList.Add(r);
                        }
                    }
                }
                xkdcOutput.ServiceResults=resultsList.ToArray();

                xkdcOutput.FlowToken=0;
                xkdcOutput.UserBanExpireTime=new ulong[4]; //service address2 doesn't have ban expiration times
            }

            //
            public override int GetPreauthNumber()
            {
                return 211;
            }

            public override string ToString()
            {
                if (HrUser==null) //prolly not decrypted yet
                    return base.ToString();
                else
                {
                    string s="PreauthXenonServiceAddress2:";
                    s+="\nPAXenonSA2 Hr: 0x"+Hr.ToString("X");
                    s+="\nPAXenonSA2 HrUser: [0]=0x"+HrUser[0].ToString("X")+"  [1]=0x"+HrUser[1].ToString("X")+"  [2]=0x"+HrUser[2].ToString("X")+"  [3]=0x"+HrUser[3].ToString("X");
                    s+="\nPAXenonSA2 UserFlags: [0]=0x"+UserFlags[0].ToString("X")+"  [1]=0x"+UserFlags[1].ToString("X")+"  [2]=0x"+UserFlags[2].ToString("X")+"  [3]=0x"+UserFlags[3].ToString("X");
                    s+="\nPAXenonSA2 BwLimit: "+BwLimit;
                    s+="\nPAXenonSA2 SiteIP: "+GetSiteIPString();
                    for (int u=0; u<4; ++u)
                    {
                        s+="\nPAXenonSA2 UserPrivileges["+u+"]: ";
                        bool first=true;
                        for (int p=0; p<256; ++p)
                        {
                            if (GetUserPrivilegeBit(u, p))
                            {
                                if (!first) s+=", ";
                                first=false;
                                s+=p.ToString();
                            }
                        }
                    }
                    s+="\nPAXenonSA2 NumServices: "+NumServices;
                    s+="\nPAXenonSA2 ByteServiceResult: ";
                    bool firstBsr=true;
                    for (int bsr=0; bsr<32; ++bsr)
                    {
                        if (ByteServiceResult[bsr].ServiceID!=0 || ByteServiceResult[bsr].ServicePort!=0 || ByteServiceResult[bsr].Result!=0)
                        {
                            if (!firstBsr) s+=", ";
                            firstBsr=false;
                            s+="(Service="+ByteServiceResult[bsr].ServiceID+" Port="+ByteServiceResult[bsr].ServicePort+" Result="+ByteServiceResult[bsr].Result+")";
                        }
                    }
                    s+="\nPAXenonSA2 DwordServiceResult: ";
                    bool firstDsr=true;
                    for (int dsr=0; dsr<4; ++dsr)
                    {
                        if (DwordServiceResult[dsr].ServiceID!=0 || DwordServiceResult[dsr].ServicePort!=0 || DwordServiceResult[dsr].Result!=0)
                        {
                            if (!firstDsr) s+=", ";
                            firstDsr=false;
                            s+="(Service="+DwordServiceResult[dsr].ServiceID+" Port="+DwordServiceResult[dsr].ServicePort+" Result="+DwordServiceResult[dsr].Result+")";
                        }
                    }
                    s+="\nPAXenonSA2 LiveTitleId: 0x"+LiveTitleId.ToString("X");
                    s+="\nPAXenonSA2 AltLiveTitleIds: ";
                    bool firstAt=true;
                    for (int at=0; at<4; ++at)
                    {
                        if (AltLiveTitleIds[at].ServiceID!=0 || AltLiveTitleIds[at].AltTitleID!=0)
                        {
                            if (!firstAt) s+=", ";
                            firstAt=false;
                            s+="(ServiceID="+AltLiveTitleIds[at].ServiceID+" AltTitleID=0x"+AltLiveTitleIds[at].AltTitleID.ToString("X")+")";
                        }
                    }
                    return s;
                }
            }
        };

        /// <summary> PADATA_XENON_SERVICE_ADDRESS3(215) - Site, service, and privilege information.  This is returned by xkdc in response to a XenonServiceRequest3. </summary>
        public class PreauthXenonServiceAddress3: PreauthXenonServiceAddressBase
        {
            //Unencrypted data below.  The asn encrypted data container is stored in Bytes.
            public uint   []UserPrivileges;        //4 (1 for each user) blobs of 96 bits, of privileges (stored as 3 dwords each)
            public uint     MachinePrivileges;     //privileges for the machine itself
            public byte   []ByteServiceBits;       //array of 32 bytes, 2 bits per service
            public ulong    FlowToken;

            public override int GetExpectedSize()
            {
                return 184;
            }

            //convenient way to get a specific privilege bit for a user from the dword arrays
            public override bool GetUserPrivilegeBit(int user, int bit)
            {
                if (bit<160)
                {
                    throw new System.Exception("XenonServiceAddress3 does not have a representation of user priveleges below 160.");
                }

                int dword=(bit/32)-5;
                int subbit=bit%32;
                return (UserPrivileges[user*3+dword]&(1<<subbit))!=0;
            }

            //convenient way to get a specific machine privilege
            public bool GetMachinePrivilegeBit(int bit)
            {
                if (bit<128 || bit>=160)
                {
                    throw new System.Exception("Machine priveleges only exist in the range 128-160.");
                }

                int subbit=bit%32;
                return (MachinePrivileges&(1<<subbit))!=0;
            }

            public override ByteServiceResultValue GetByteServiceResult(int service)
            {
                //TODO: big endian or little endian?
                int byt=service/4;
                int bit=(service%4)*2;

                return (ByteServiceResultValue)((ByteServiceBits[byt]>>bit)&0x3);
            }

            protected override void ReadDecryptedBytes(System.IO.BinaryReader reader)
            {
                //store fields
                Hr = reader.ReadUInt32();
                HrUser = new uint[4];
                for (int i = 0; i < 4; ++i)
                    HrUser[i] = reader.ReadUInt32();
                UserFlags = new uint[4];
                for (int i = 0; i < 4; ++i)
                    UserFlags[i] = reader.ReadUInt32();
                SiteIP = reader.ReadUInt32();
                UserPrivileges = new uint[4*3];
                for (int i = 0; i < 12; ++i)
                    UserPrivileges[i]=reader.ReadUInt32();
                MachinePrivileges = reader.ReadUInt32();
                ByteServiceBits = reader.ReadBytes(32);
                DwordServiceResult = new XenonServiceResult[4];
                for (int i = 0; i < 4; ++i)
                    DwordServiceResult[i] = XenonServiceResult.FromStream(reader);
                LiveTitleId = reader.ReadUInt32();
                AltLiveTitleIds = new XboxServiceAlternateTitleID[4];
                for (int i = 0; i < 4; ++i)
                    AltLiveTitleIds[i] = XboxServiceAlternateTitleID.FromStream(reader);
                FlowToken = reader.ReadUInt64();
            }

            //sets relevent fields into the generic xkdc output
            public override void SetIntoGenericXkdcOutput(XkdcGenericReplyOutput xkdcOutput)
            {
                xkdcOutput.Hr=Hr;
                xkdcOutput.HrUser=HrUser;
                xkdcOutput.UserFlags=UserFlags;
                xkdcOutput.SiteIP=GetSiteIPString();

                xkdcOutput.UserPrivileges=UserPrivileges;
                xkdcOutput.MachinePrivileges=MachinePrivileges;

                System.Collections.Generic.List<XkdcGenericReplyOutput.ServiceResult> resultsList=new System.Collections.Generic.List<XkdcGenericReplyOutput.ServiceResult>();
                if (ByteServiceBits!=null)
                {
                    for (int i=0; i<128; ++i)
                    {
                        ByteServiceResultValue result=GetByteServiceResult(i);
                        if (result!=ByteServiceResultValue.Invalid)
                        {
                            XkdcGenericReplyOutput.ServiceResult r=new XkdcGenericReplyOutput.ServiceResult();
                            r.Service=(uint)i;
                            r.Hr=(uint)result;
                            r.Port=(result==0?(ushort)i:(ushort)0); //set port to 0 if it failed to mirror older preauth behaviour
                            resultsList.Add(r);
                        }
                    }
                }
                if (DwordServiceResult!=null)
                {
                    for (int i=0; i<DwordServiceResult.Length; ++i)
                    {
                        if (DwordServiceResult[i].ServiceID!=0 || DwordServiceResult[i].Result!=0 || DwordServiceResult[i].ServicePort!=0)
                        {
                            XkdcGenericReplyOutput.ServiceResult r=new XkdcGenericReplyOutput.ServiceResult();
                            r.Service=DwordServiceResult[i].ServiceID;
                            r.Hr=DwordServiceResult[i].Result;
                            r.Port=DwordServiceResult[i].ServicePort;
                            resultsList.Add(r);
                        }
                    }
                }
                xkdcOutput.ServiceResults=resultsList.ToArray();

                xkdcOutput.FlowToken=FlowToken;
                xkdcOutput.UserBanExpireTime=new ulong[4]; //service address3 doesn't have ban expiration times
            }

            //
            public override int GetPreauthNumber()
            {
                return 215;
            }

            public override string ToString()
            {
                if (HrUser==null) //prolly not decrypted yet
                    return base.ToString();
                else
                {
                    string s="PreauthXenonServiceAddress3:";
                    s+="\nPAXenonSA3 Hr: 0x"+Hr.ToString("X");
                    s+="\nPAXenonSA3 HrUser: [0]=0x"+HrUser[0].ToString("X")+"  [1]=0x"+HrUser[1].ToString("X")+"  [2]=0x"+HrUser[2].ToString("X")+"  [3]=0x"+HrUser[3].ToString("X");
                    s+="\nPAXenonSA3 UserFlags: [0]=0x"+UserFlags[0].ToString("X")+"  [1]=0x"+UserFlags[1].ToString("X")+"  [2]=0x"+UserFlags[2].ToString("X")+"  [3]=0x"+UserFlags[3].ToString("X");
                    s+="\nPAXenonSA3 SiteIP: "+GetSiteIPString();
                    for (int u=0; u<4; ++u)
                    {
                        s+="\nPAXenonSA3 UserPrivileges["+u+"]: ";
                        bool first=true;
                        for (int p=160; p<256; ++p)
                        {
                            if (GetUserPrivilegeBit(u, p))
                            {
                                if (!first) s+=", ";
                                first=false;
                                s+=p.ToString();
                            }
                        }
                    }
                    {
                        s+="\nPAXenonSA3 MachinePrivileges: ";
                        bool first=true;
                        for (int p=128; p<160; ++p)
                        {
                            if (GetMachinePrivilegeBit(p))
                            {
                                if (!first) s+=", ";
                                first=false;
                                s+=p.ToString();
                            }
                        }
                    }
                    s+="\nPAXenonSA3 ByteServiceResult: ";
                    bool firstBsr=true;
                    for (int bsr=0; bsr<128; ++bsr)
                    {
                        ByteServiceResultValue result=GetByteServiceResult(bsr);
                        if (result!=ByteServiceResultValue.Invalid)
                        {
                            if (!firstBsr) s+=", ";
                            firstBsr=false;
                            s+=bsr+"="+result;
                        }
                    }
                    s+="\nPAXenonSA3 DwordServiceResult: ";
                    bool firstDsr=true;
                    for (int dsr=0; dsr<4; ++dsr)
                    {
                        if (DwordServiceResult[dsr].ServiceID!=0 || DwordServiceResult[dsr].ServicePort!=0 || DwordServiceResult[dsr].Result!=0)
                        {
                            if (!firstDsr) s+=", ";
                            firstDsr=false;
                            s+="(Service="+DwordServiceResult[dsr].ServiceID+" Port="+DwordServiceResult[dsr].ServicePort+" Result="+DwordServiceResult[dsr].Result+")";
                        }
                    }
                    s+="\nPAXenonSA3 LiveTitleId: 0x"+LiveTitleId.ToString("X");
                    s+="\nPAXenonSA3 AltLiveTitleIds: ";
                    bool firstAt=true;
                    for (int at=0; at<4; ++at)
                    {
                        if (AltLiveTitleIds[at].ServiceID!=0 || AltLiveTitleIds[at].AltTitleID!=0)
                        {
                            if (!firstAt) s+=", ";
                            firstAt=false;
                            s+="(ServiceID="+AltLiveTitleIds[at].ServiceID+" AltTitleID=0x"+AltLiveTitleIds[at].AltTitleID.ToString("X")+")";
                        }
                    }
                    s+="\nPAXenonSA3 FlowToken: "+string.Format("0x{0:X}", FlowToken);
                    return s;
                }
            }
        };

        /// <summary> XENON_SERVICE_ADDRESS_FAILURE (217) - Failure information returned in response to a XenonServiceRequest3 when the version is >=6 and the overall Hr is not success. </summary>
        public class PreauthXenonServiceAddressFailure: EncryptedData, IGetPreauthNumber, IContainsEncryptedBytes
        {
            //Unencrypted data below.  The asn encrypted data container is stored in Bytes.
            public uint Hr;                    //overall HResult for the request
            public uint []HrUser;              //array of 4 hresults, one for each user
            public ulong ConsoleBanExpireTime; //64-bit windows format timestamp for when the console ban expires, or 0 if not banned.
            public ulong []UserBanExpireTime;  //array of 64-bit windows format timestamps for when the each user's ban expires, or 0 if not banned.

            //Key used to encrypt and decrypt
            public byte []Key;
            public uint KeyNonce;

            public int GetExpectedSize()
            {
                return 60;
            }

            public void Encrypt()
            {
                byte []rawBytes=GetInnerBytes();
                EncryptedBytes.Bytes=KdcCrypto.RC4HMACEncryptUsingNonce(EncryptedBytes.Bytes, Key, KeyNonce, KdcCrypto.PA_XBOX_SERVICE_ADDRESS_SALT);
            }

            public void Decrypt()
            {
                byte []rawBytes=KdcCrypto.RC4HMACDecryptUsingNonce(EncryptedBytes.Bytes, Key, KeyNonce, KdcCrypto.PA_XBOX_SERVICE_ADDRESS_SALT);
                SetInnerBytes(rawBytes);
            }

            public byte[] GetInnerBytes()
            {
                byte []data=new byte[GetExpectedSize()];
                System.Array.Copy(System.BitConverter.GetBytes(Hr), 0, data, 0, 4);
                for (int i=0; i<4; ++i)
                    System.Array.Copy(System.BitConverter.GetBytes(HrUser[i]), 0, data, 4+i*4, 4);
                System.Array.Copy(System.BitConverter.GetBytes(ConsoleBanExpireTime), 0, data, 20, 8);
                for (int i=0; i<4; ++i)
                    System.Array.Copy(System.BitConverter.GetBytes(UserBanExpireTime[i]), 0, data, 28+i*8, 8);
                return data;
            }

            public void SetInnerBytes(byte []data)
            {
                Hr=System.BitConverter.ToUInt32(data, 0);
                HrUser=new uint[4];
                for (int i=0; i<4; ++i)
                    HrUser[i]=System.BitConverter.ToUInt32(data, 4+i*4);
                ConsoleBanExpireTime=System.BitConverter.ToUInt64(data, 20);
                UserBanExpireTime=new ulong[4];
                for (int i=0; i<4; ++i)
                    UserBanExpireTime[i]=System.BitConverter.ToUInt64(data, 28+i*8);
            }

            public void SetIntoGenericXkdcOutput(XkdcGenericReplyOutput xkdcOutput)
            {
                xkdcOutput.Hr=Hr;
                xkdcOutput.HrUser=HrUser;
                xkdcOutput.UserFlags=new uint[4]; //failure doesn't have user flags
                xkdcOutput.SiteIP="";
                xkdcOutput.UserPrivileges=new uint[12]; //failure doesn't have privileges
                xkdcOutput.ServiceResults=new XkdcGenericReplyOutput.ServiceResult[0]; //failure doesn't have services
                xkdcOutput.ConsoleBanExpireTime=ConsoleBanExpireTime;
                xkdcOutput.UserBanExpireTime=UserBanExpireTime;
            }

            public int GetPreauthNumber()
            {
                return 217;
            }

            //returns whether the unencrypted data has been properly decrypted and set
            public bool IsValid()
            {
                return HrUser!=null;
            }

            public override string ToString()
            {
                if (!IsValid()) //prolly not decrypted yet
                    return base.ToString();
                else
                {
                    string s="PreauthXenonServiceFailure:";
                    s+="\nPAXenonSAF Hr: 0x"+Hr.ToString("X");
                    s+="\nPAXenonSAF HrUser: [0]=0x"+HrUser[0].ToString("X")+"  [1]=0x"+HrUser[1].ToString("X")+"  [2]=0x"+HrUser[2].ToString("X")+"  [3]=0x"+HrUser[3].ToString("X");
                    s+="\nPAXenonSAF ConsoleBanExpireTime:"+ConsoleBanExpireTime+"("+System.DateTime.FromFileTimeUtc(unchecked((long)ConsoleBanExpireTime))+")";
                    s+="\nPAXenonSAF UserBanExpireTime: [0]="+UserBanExpireTime[0]+"("+System.DateTime.FromFileTimeUtc(unchecked((long)UserBanExpireTime[0]))+") [1]="+UserBanExpireTime[1]+"("+System.DateTime.FromFileTimeUtc(unchecked((long)UserBanExpireTime[1]))+") [2]="+UserBanExpireTime[2]+"("+System.DateTime.FromFileTimeUtc(unchecked((long)UserBanExpireTime[2]))+") [3]="+UserBanExpireTime[3]+"("+System.DateTime.FromFileTimeUtc(unchecked((long)UserBanExpireTime[3]))+")";
                    return s;
                }
            }
        };

        /// <summary> PADATA_COMPOUND_IDENTITY(130) - A sequence of tickets, obtained from the Askdc and passed back into the Askdc. </summary>
        public class PreauthCompoundIdentity: AsnValueBase, IGetPreauthNumber
        {
            public Kerberos.Ticket []Tickets
            {
                get { return tickets; }
                set
                {
                    tickets=value;
                    Sequence.Values=tickets;
                }
            }
            private Kerberos.Ticket []tickets;

            //glue
            public Compound.TagLengthValue SequenceTag=new Compound.TagLengthValue();
            public Compound.Sequence Sequence=new Compound.Sequence();

            //
            public PreauthCompoundIdentity()
            {
                SequenceTag.Tag=Sequence.GetDefaultTag();
                SequenceTag.Value=Sequence;
            }

            public override void AppendBytesTo(System.IO.MemoryStream byteList)
            {
                SequenceTag.AppendBytesTo(byteList);
            }

            public override long ProcessLengths(bool updateLengthFields, bool updateNestedStructures)
            {
                return SequenceTag.ProcessLengths(updateLengthFields, updateNestedStructures);
            }

            public int GetPreauthNumber()
            {
                return 130;
            }

            public override string ToString()
            {
                string s="PreauthCompoundIdentity: Tickets Count="+(Tickets==null?"0":Tickets.Length.ToString());

                if (Tickets!=null)
                {
                    for (int i=0; i<Tickets.Length; ++i)
                    {
                        s+="\nPreauthCompoundIdentity Ticket 0:\n"+Tickets[i];
                    }
                }

                return s;
            }
        };

        /// <summary> A preauth with any number that holds bytes, used for negative tests for preauths we don't know how to generate. </summary>
        public class PreauthDummyPlaceholder: AsnBytes, IGetPreauthNumber
        {
            public int PreauthNumber=0;

            public PreauthDummyPlaceholder()
            {
                Bytes=new byte[1];
            }

            public int GetPreauthNumber()
            {
                return PreauthNumber;
            }
        }

        #region Shared structs

        public struct XenonSingleByteServiceResult
        {
            public byte ServiceID;
            public ushort ServicePort;
            public byte Result;        // XENON_SERVICE_STATUS_*

            public static XenonSingleByteServiceResult FromBytes(byte[] bytes, int offset)
            {
                XenonSingleByteServiceResult me = new XenonSingleByteServiceResult();
                me.ServiceID = bytes[offset];
                me.ServicePort = System.BitConverter.ToUInt16(bytes, offset + 1);
                me.Result = bytes[offset + 3];
                return me;
            }

            public static XenonSingleByteServiceResult FromStream(System.IO.BinaryReader reader)
            {
                XenonSingleByteServiceResult me = new XenonSingleByteServiceResult();
                me.ServiceID = reader.ReadByte();
                me.ServicePort = reader.ReadUInt16();
                me.Result = reader.ReadByte();
                return me;
            }
        };

        public struct XenonServiceResult
        {
            public uint ServiceID;
            public ushort ServicePort;
            public byte Result;        // XENON_SERVICE_STATUS_*

            public static XenonServiceResult FromBytes(byte[] bytes, int offset)
            {
                XenonServiceResult me = new XenonServiceResult();
                me.ServiceID = System.BitConverter.ToUInt32(bytes, offset);
                me.ServicePort = System.BitConverter.ToUInt16(bytes, offset + 4);
                me.Result = bytes[offset + 6];
                return me;
            }

            public static XenonServiceResult FromStream(System.IO.BinaryReader reader)
            {
                XenonServiceResult me = new XenonServiceResult();
                me.ServiceID = reader.ReadUInt32();
                me.ServicePort = reader.ReadUInt16();
                me.Result = reader.ReadByte();
                return me;
            }
        };

        public struct XboxServiceAlternateTitleID
        {
            public byte ServiceID;
            public uint AltTitleID;

            public static XboxServiceAlternateTitleID FromBytes(byte[] bytes, int offset)
            {
                XboxServiceAlternateTitleID me = new XboxServiceAlternateTitleID();
                me.ServiceID = bytes[offset];
                me.AltTitleID = System.BitConverter.ToUInt32(bytes, offset + 1);
                return me;
            }

            public static XboxServiceAlternateTitleID FromStream(System.IO.BinaryReader reader)
            {
                XboxServiceAlternateTitleID me = new XboxServiceAlternateTitleID();
                me.ServiceID = reader.ReadByte();
                me.AltTitleID = reader.ReadUInt32();
                return me;
            }
        };

        #endregion Shared structs
    }; //class Kerberos

    //common helpers
    public class PreauthHelpers
    {
        /// <summary> Attempts to create a specific preauth type from a generic preauth. </summary>
        public static Kerberos.Preauth CreateSpecificPreauth(Kerberos.Preauth genericPA)
        {
            int paNum=(int)genericPA.Type.Int64;

            Kerberos.Preauth pa;
            if (paNum==202)
            {
                pa=new Kerberos.Preauth<Kerberos.PreauthXboxServiceAddress>(); //assign a generic one for now, the specific one will be re-assigned over later after the blob is decrypted so the type can be determined
            }
            else if (paNum==203)
            {
                pa=new Kerberos.Preauth<Kerberos.PreauthXboxAccountCreation>();
            }
            else if (paNum==211)
            {
                pa=new Kerberos.Preauth<Kerberos.PreauthXenonServiceAddress2>();
            }
            else if (paNum==212)
            {
                pa=new Kerberos.Preauth<Kerberos.PreauthPCAccountCreationReply>();
            }
            else if (paNum==213)
            {
                pa=new Kerberos.Preauth<Kerberos.PreauthPassportAuthenticationReply>();
            }
            else if (paNum == 215)
            {
                pa = new Kerberos.Preauth<Kerberos.PreauthXenonServiceAddress3>();
            }
            else if (paNum == 217)
            {
                pa = new Kerberos.Preauth<Kerberos.PreauthXenonServiceAddressFailure>();
            }
            else
            {
                Global.RO.Warn("CreateSpecificPreauth: Don't know how to create a preauth of type "+paNum+" so leaving it generic.");
                return genericPA;
            }

            pa.Type=genericPA.Type;
            pa.Data.SetBytes(genericPA.Data.GetBytes());
            return pa;
        }

        /// <summary> Creates a preauth of the specific type.  If the preauth is unknown or not enough information was provided to generate it, a dummy preauth will be created. </summary>
        public static Kerberos.Preauth GenerateDefaultPreauth(int preauthNumber, byte []sessionKey, System.DateTime requestTime, string principalName, Kerberos.Ticket tgtTicket, uint nonce, uint titleId, uint titleVersion, uint flashVersion, ulong pcNonce, PassportTicket plainPassport, PassportTicket encPassport, ConsoleCertificate consoleCert, bool includePac, byte []echoPreauthBytes)
        {
            if (preauthNumber==1 && tgtTicket!=null) //PADATA_TGS_REQ
            {
                Kerberos.Preauth<Kerberos.PreauthTgsRequest> pa=new Kerberos.Preauth<Kerberos.PreauthTgsRequest>();
                pa.Data.Ticket=tgtTicket;
                Kerberos.Authenticator auth=new Kerberos.Authenticator();
                auth.Realm.String="PASSPORT.NET";
                auth.ClientName.Type.Int64=2;
                auth.ClientName.Names=new Compound.TagLengthValue<Raw.GeneralString>[2];
                auth.ClientName.Names[0]=new Compound.TagLengthValue<Raw.GeneralString>();
                auth.ClientName.Names[0].Value.String=principalName;
                auth.ClientName.Names[1]=new Compound.TagLengthValue<Raw.GeneralString>();
                auth.ClientName.Names[1].Value.String="PASSPORT.NET";
                Kerberos.Time ktime=new Kerberos.Time();
                ktime.DateTime=requestTime;
                auth.ClientTime=ktime;
                auth.ClientTimeMicroseconds.Int64=requestTime.Millisecond*1000;
                auth.SequenceNumber.Int64=nonce; //we DO follow the standard here
                auth.RecalculateLengths(true);
                pa.Data.EncryptedAuthenticator.Authenticator=auth;
                pa.Data.EncryptedAuthenticator.RecalculateLengths(true);
                pa.Data.EncryptedAuthenticator.EncryptionKey=sessionKey;
                pa.Data.EncryptedAuthenticator.Encrypt();
                return pa;
            }

            if (preauthNumber==2) //PADATA_ENC_TIMESTAMP
            {
                Kerberos.Preauth<Kerberos.PreauthEncryptedTimestamp> pa=new Kerberos.Preauth<Kerberos.PreauthEncryptedTimestamp>();
                pa.Data.SetTimestamp(requestTime);
                pa.Data.EncryptionKey=sessionKey;
                pa.Data.Encrypt();
                return pa;
            }

            if (preauthNumber==130 && tgtTicket!=null) //PADATA_COMPOUND_IDENTITY
            {
                Kerberos.Preauth<Kerberos.PreauthCompoundIdentity> pa=new Kerberos.Preauth<Kerberos.PreauthCompoundIdentity>();
                pa.Data.Tickets=new Kerberos.Ticket[]{tgtTicket};
                return pa;
            }

            if (preauthNumber==131) //PADATA_PAC_REQUEST_EX
            {
                //This used to be used by our kdc and allowed the client to tell the server to include the pac authdata.  Now our server completely ignores it and always does the right thing.
                Kerberos.Preauth<Kerberos.PreauthPacRequestEx> pa=new Kerberos.Preauth<Kerberos.PreauthPacRequestEx>();
                if (includePac)
                {
                    pa.Data.IncludePac.Bool=true;
                    pa.Data.Sections=new Compound.TagLengthValue<Raw.Integer>[2];
                    pa.Data.Sections[0]=new Compound.TagLengthValue<Raw.Integer>();
                    pa.Data.Sections[0].Value.Int64=13;
                    pa.Data.Sections[1]=new Compound.TagLengthValue<Raw.Integer>();
                    pa.Data.Sections[1].Value.Int64=14;
                }
                else
                {
                    pa.Data.IncludePac.Bool=false;
                }
                return pa;
            }

            if (preauthNumber==204) //PADATA_XBOX_PPA
            {
                Kerberos.Preauth<Kerberos.PreauthXboxPPA> pa=new Kerberos.Preauth<Kerberos.PreauthXboxPPA>();
                pa.Data.CurrentTime=(ulong)requestTime.ToFileTimeUtc();
                pa.Data.CalculatePPA(principalName, sessionKey, pa.Data.CurrentTime);
                return pa;
            }

            if (preauthNumber==205 && echoPreauthBytes!=null) //PADATA_XBOX_ECHO
            {
                Kerberos.Preauth<Kerberos.PreauthXboxEcho> pa=new Kerberos.Preauth<Kerberos.PreauthXboxEcho>();
                pa.Data.Bytes=echoPreauthBytes;
                return pa;
            }

            if (preauthNumber==206) //PADATA_XBOX_CLIENT_VERSION
            {
                Kerberos.Preauth<Kerberos.PreauthXboxClientVersion> pa=new Kerberos.Preauth<Kerberos.PreauthXboxClientVersion>();
                pa.Data.SetVersion(flashVersion, titleId, titleVersion);
                pa.Data.EncryptionKey=sessionKey;
                pa.Data.EncryptionNOnce=nonce;
                pa.Data.Sign();
                return pa;
            }

            if (preauthNumber==213) //PADATA_PASSPORT_AUTHENTICATION
            {
                Kerberos.Preauth<Kerberos.PreauthPassportAuthenticationRequest> pa=new Kerberos.Preauth<Kerberos.PreauthPassportAuthenticationRequest>();
                pa.Data.PCNOnce=pcNonce;
                if (plainPassport!=null)
                {
                    pa.Data.PassportTicket=plainPassport.Bytes;
                    pa.Data.PassportTicketLen=(ushort)plainPassport.Bytes.Length;
                }
                else //put something empty there
                {
                    Global.RO.Warn("GenerateDefaultPreauth: no ticket provided for PADATA_PASSPORT_AUTHENTICATION, so generating dummy data.");
                    pa.Data.PassportTicket=new byte[400];
                    pa.Data.PassportTicketLen=400;
                }
                pa.Data.Encrypt(null); //not really encrypting here, Key is not used
                return pa;
            }

            if (preauthNumber==216) //PADATA_XENON_PPA
            {
                Kerberos.Preauth<Kerberos.PreauthXenonPPA> pa=new Kerberos.Preauth<Kerberos.PreauthXenonPPA>();
                if (consoleCert!=null)
                {
                    pa.Data.CalculateHash(consoleCert);
                }
                else //just give them something blank of the right size
                {
                    pa.Data.CertificateHash=new byte[20];
                }
                return pa;
            }

            if (preauthNumber==218) //PADATA_ENCRYPTED_PASSPORT_AUTHENTICATION
            {
                Kerberos.Preauth<Kerberos.PreauthEncryptedPassport> pa=new Kerberos.Preauth<Kerberos.PreauthEncryptedPassport>();
                if (encPassport!=null)
                {
                    pa.Data.PassportTicket=encPassport.Bytes;
                    pa.Data.PassportTicketLength=(ushort)encPassport.Bytes.Length;
                }
                else //put something empty there
                {
                    Global.RO.Warn("GenerateDefaultPreauth: no ticket provided for PADATA_ENCRYPTED_PASSPORT_AUTHENTICATION, so generating dummy data.");
                    pa.Data.PassportTicket=new byte[300];
                    pa.Data.PassportTicketLength=300;
                }
                pa.Data.EncryptionKey=sessionKey;
                pa.Data.Encrypt();
                return pa;
            }

            Global.RO.Warn("GenerateDefaultPreauth: "+preauthNumber+" not handled, so generating a dummy preauth.");
            Kerberos.Preauth<Kerberos.PreauthDummyPlaceholder> dummy=new Kerberos.Preauth<Kerberos.PreauthDummyPlaceholder>();
            dummy.Data.PreauthNumber=preauthNumber;
            dummy.Type.Int64=dummy.Data.GetPreauthNumber();
            return dummy;
        }
    }; //class PreauthHelpers
} //namespace ServerTestFramework.LiveService.Auth.Asn
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\Auth\KDC\KerberosReply.cs ===
using System.Collections.Generic;
using ServerTestFramework.LiveService.Auth.Asn;

namespace ServerTestFramework.LiveService.Auth
{
    /// <summary> Represents a kerberos reply (rfc 4120). </summary>
    public partial class KerberosReply
    {
        public Raw.Integer            Version;               //tag 0             //normally always 5
        public Raw.Integer            MessageType;           //tag 1             //11=as 13=tgs
        public Kerberos.Preauth     []Preauths;              //tag 2 (optional)  //TODO: we need to parse these into the specific preauths still...
        public Raw.GeneralString      ClientRealm;           //tag 3
        public Kerberos.PrincipalName ClientName;            //tag 4
        public Kerberos.Ticket        Ticket;                //tag 5
        public Kerberos.EncryptedData EncryptedData;         //tag 6             //contains the KerberosReplyBody

        //This can be set by calling DecryptBody.  It holds the decrypted version of the encrypted portion of the reply.
        public KerberosReplyBody      Body;
    };

    /// <summary> Portion of the reply contained within the EncryptedData field of a KerberosReply. </summary>
    public partial class KerberosReplyBody
    {
        public Kerberos.EncryptionKey Key;                   //tag 0
        public Kerberos.LastRequest   LastRequest;           //tag 1
        public Raw.Integer            NOnce;                 //tag 2             //SIGNED 32 bit integer range.  Note that the standard says UNSIGNED, but our kerberos server has a long-standing bug in that it expects values in the range of a signed integer instead of an unsigned integer.
        public Kerberos.Time          KeyExpiration;         //tag 3  (optional)
        public Kerberos.KerberosFlags TicketFlags;           //tag 4
        public Kerberos.Time          AuthTime;              //tag 5
        public Kerberos.Time          StartTime;             //tag 6  (optional)
        public Kerberos.Time          EndTime;               //tag 7
        public Kerberos.Time          FinalRenewalTime;      //tag 8  (optional)
        public Raw.GeneralString      ServerRealm;           //tag 9
        public Kerberos.PrincipalName ServerName;            //tag 10
        public HostAddress            ClientAddress;         //tag 11 (optional) //TODO:
    };

    //functions in KerberosReply
    public partial class KerberosReply
    {
        /// <summary> Walks through an asn tree containing a kerberos reply and creates a KerberosReply using the data from the tree.  This does not validate the presence of all fields.  This also does not decrypt anything. </summary>
        public static ReplyType CreateFromAsn<ReplyType>(AsnValueBase asnTree) where ReplyType:KerberosReply, new()
        {
            //Extract the overall application tag for a reply and its sequence
            Compound.ExplicitTagLengthValue mainAppTag=asnTree as Compound.ExplicitTagLengthValue;
            Compound.Sequence mainAppSequence;
            if (mainAppTag==null)
            {
                throw new KerberosAsnException("Overall kdc reply is not contained within an ASN explicit tag.");
            }

            ulong mainAppTagNumber=mainAppTag.ExplicitTag.Number;
            if (!(mainAppTagNumber==11 || mainAppTagNumber==13) || mainAppTag.ExplicitTag.Class!=TagClasses.Application || !mainAppTag.ExplicitTag.Constructed) //11=as 13=tgs
            {
                //if the reply is a kerberos error, parse that out instead
                if (mainAppTagNumber==30)
                {
                    try
                    {
                        KerberosError error=KerberosError.CreateFromAsn(asnTree);
                        throw new KerberosErrorException(error, "Failed to parse Kerberos Reply because it was a Kerberos Error instead.");
                    }
                    catch (KerberosErrorException)
                    {
                        throw;
                    }
                    catch (System.Exception e)
                    {
                        throw new KerberosAsnException("Overall kdc reply was a kerberos error, and there was an exception parsing it: "+e);
                    }
                }

                throw new KerberosAsnException("Overall kdc reply has the wrong explicit tag: "+mainAppTag.ExplicitTag.ToString());
            }

            if (mainAppTag.ValueTag.CompareTo((new Compound.Sequence()).GetDefaultTag())!=0)
            {
                throw new KerberosAsnException("Overall kdc reply has the wrong value tag: "+mainAppTag.ValueTag.ToString());
            }

            mainAppSequence=(Compound.Sequence)mainAppTag.Value;

            //step through the main sequence
            ReplyType reply=new ReplyType();
            long lastTagNumber=-1;
            foreach (AsnValueBase seqEntry in mainAppSequence.Values)
            {
                Compound.ExplicitTagLengthValue tag=seqEntry as Compound.ExplicitTagLengthValue;
                if (tag==null)
                {
                    throw new KerberosAsnException("The main sequence in the overall kdc reply has an entry that is not explicitely tagged.");
                }

                ulong tagNumber=tag.ExplicitTag.Number;
                if ((long)tagNumber<=lastTagNumber)
                {
                    throw new KerberosAsnException("Tag numbers are out of order in kdc reply's main sequence.");
                }

                //match the tag number and process it
                if (tagNumber==0) //version
                {
                    KerberosReplyHelpers.VerifyTag((new Raw.Integer()).GetDefaultTag(), tag.ValueTag);
                    reply.Version=(Raw.Integer)tag.Value;
                }
                else if (tagNumber==1) //message type
                {
                    KerberosReplyHelpers.VerifyTag((new Raw.Integer()).GetDefaultTag(), tag.ValueTag);
                    reply.MessageType=(Raw.Integer)tag.Value;
                }
                else if (tagNumber==2) //preauths
                {
                    KerberosReplyHelpers.VerifyTag((new Compound.Sequence()).GetDefaultTag(), tag.ValueTag);
                    Compound.Sequence paSequence=(Compound.Sequence)tag.Value;

                    reply.Preauths=new Kerberos.Preauth[paSequence.Values.Length];
                    for (int i=0; i<reply.Preauths.Length; ++i)
                    {
                        Compound.TagLengthValue paTag=(Compound.TagLengthValue)paSequence.Values[i];
                        Kerberos.Preauth genericPA=Kerberos.Preauth.CreateFromAsn(paTag);
                        reply.Preauths[i]=PreauthHelpers.CreateSpecificPreauth(genericPA);
                    }
                }
                else if (tagNumber==3) //client realm
                {
                    KerberosReplyHelpers.VerifyTag((new Raw.GeneralString()).GetDefaultTag(), tag.ValueTag);
                    reply.ClientRealm=(Raw.GeneralString)tag.Value;
                }
                else if (tagNumber==4) //client name
                {
                    reply.ClientName=Kerberos.PrincipalName.CreateFromAsn(tag.GetValueTagLengthValue());
                }
                else if (tagNumber==5) //ticket
                {
                    reply.Ticket=Kerberos.Ticket.CreateFromAsn(tag.GetValueTagLengthValue());
                }
                else if (tagNumber==6) //encrypted data
                {
                    reply.EncryptedData=Kerberos.EncryptedData.CreateFromAsn(tag.GetValueTagLengthValue());
                }
                else
                {
                    Global.RO.Warn("Unhandled tag number in KerberosReply: "+tagNumber);
                }
            }

            reply.AfterCreatefromAsn();
            return reply;
        }

        /// <summary> Decrypts the contents of EncryptedData and stores it in Body. </summary>
        public void DecryptBody(byte []key)
        {
            if (EncryptedData==null)
            {
                throw new KerberosAsnException("There is no encrypted data in the reply.");
            }

            //pick salt type then decrypt it
            uint saltType;
            //BUG: our server incorrectly always uses the TGS salt, even in the AS case.
            saltType=KdcCrypto.TGS_REP_SALT;
            /*int messageType=(int)(MessageType.Int64);
            if (messageType==11) //as
            {
                saltType=KdcCrypto.AS_REP_SALT;
            }
            else if (messageType==13) //tgs
            {
                saltType=KdcCrypto.TGS_REP_SALT;
            }
            else
            {
                Global.RO.Warn("Unknown message type("+messageType+") during DecryptReply, so using AS salt");
                saltType=KdcCrypto.AS_REP_SALT;
            }*/

            byte []decryptedBytes=KdcCrypto.RC4HMACDecrypt(EncryptedData.EncryptedBytes.Bytes, key, saltType);

            //parse it to asn and fill in the encrypted reply
            long bytesUsed;
            AsnValueBase bodyAsn=Compound.AsnValueParser.Parse(decryptedBytes, 0, decryptedBytes.Length, out bytesUsed);
            if (bytesUsed!=(long)decryptedBytes.Length)
            {
                throw new KerberosAsnException("Not all bytes in an encrypted reply were used.");
            }

            Body=KerberosReplyBody.CreateFromAsn(bodyAsn);
        }

        //used by derived classes, called after a reply has been build from asn
        protected virtual void AfterCreatefromAsn()
        {
        }

        //
        public override string ToString()
        {
            string s="";

            s+="Version: "+Version;
            s+="\nMessageType: "+MessageType;
            s+="\nPreauths: ";
            if (Preauths!=null)
            {
                foreach (Kerberos.Preauth pa in Preauths)
                {
                    s+="\n"+pa.ToString();
                }
            }
            s+="\nClientRealm: "+ClientRealm;
            s+="\nClientName: "+ClientName;

            if (Ticket==null)
            {
                s+="\nTicket: ";
            }
            else
            {
                s+="\n"+Ticket;
            }

            if (EncryptedData==null || Body==null)
            {
                s+="\nEncryptedData: "+EncryptedData;
            }
            else
            {
                s+="\n"+Body;
            }

            return s;
        }
    }; //KerberosReply

    public partial class KerberosReplyBody
    {
        /// <summary> Walks through an asn tree containing a kerberos reply body and creates a KerberosReplyBody using the data from the tree.  This does not validate the presence of all fields. </summary>
        public static KerberosReplyBody CreateFromAsn(AsnValueBase asnTree)
        {
            //Extract the overall application tag for a body and its sequence
            Compound.ExplicitTagLengthValue mainBodyTag=asnTree as Compound.ExplicitTagLengthValue;
            Compound.Sequence mainBodySequence;
            if (mainBodyTag==null)
            {
                throw new KerberosAsnException("Kdc reply body is not contained within an ASN explicit tag.");
            }

            ulong mainBodyTagNumber=mainBodyTag.ExplicitTag.Number;
            if (!(mainBodyTagNumber==25 || mainBodyTagNumber==26) || mainBodyTag.ExplicitTag.Class!=TagClasses.Application || !mainBodyTag.ExplicitTag.Constructed) //25=as 26=tgs
            {
                throw new KerberosAsnException("Kdc reply body has the wrong explicit tag: "+mainBodyTag.ExplicitTag);
            }

            if (mainBodyTag.ValueTag.CompareTo((new Compound.Sequence()).GetDefaultTag())!=0)
            {
                throw new KerberosAsnException("Kdc reply body has the wrong value tag: "+mainBodyTag.ValueTag.ToString());
            }

            mainBodySequence=(Compound.Sequence)mainBodyTag.Value;

            //step through the body sequence
            KerberosReplyBody body=new KerberosReplyBody();

            long lastTagNumber=-1;
            foreach (AsnValueBase seqEntry in mainBodySequence.Values)
            {
                Compound.ExplicitTagLengthValue tag=seqEntry as Compound.ExplicitTagLengthValue;
                if (tag==null)
                {
                    throw new KerberosAsnException("The main sequence in the kdc reply body has an entry that is not explicitely tagged.");
                }

                ulong tagNumber=tag.ExplicitTag.Number;
                if ((long)tagNumber<=lastTagNumber)
                {
                    throw new KerberosAsnException("Tag numbers are out of order in kdc reply body's main sequence.");
                }

                //match the tag number and process it
                if (tagNumber==0) //encryption key
                {
                    body.Key=Kerberos.EncryptionKey.CreateFromAsn(tag.GetValueTagLengthValue());
                }
                else if (tagNumber==1) //last request
                {
                    body.LastRequest=Kerberos.LastRequest.CreateFromAsn(tag.GetValueTagLengthValue());
                }
                else if (tagNumber==2) //nonce
                {
                    KerberosReplyHelpers.VerifyTag((new Raw.Integer()).GetDefaultTag(), tag.ValueTag);
                    body.NOnce=(Raw.Integer)tag.Value;
                }
                else if (tagNumber==3) //key expiration
                {
                    KerberosReplyHelpers.VerifyTag((new Raw.GeneralizedTime()).GetDefaultTag(), tag.ValueTag);
                    body.KeyExpiration=new Kerberos.Time((Raw.GeneralizedTime)tag.Value);
                }
                else if (tagNumber==4) //flags
                {
                    KerberosReplyHelpers.VerifyTag((new Raw.BitString()).GetDefaultTag(), tag.ValueTag);
                    body.TicketFlags=new Kerberos.KerberosFlags((Raw.BitString)tag.Value);
                }
                else if (tagNumber==5) //auth time
                {
                    KerberosReplyHelpers.VerifyTag((new Raw.GeneralizedTime()).GetDefaultTag(), tag.ValueTag);
                    body.AuthTime=new Kerberos.Time((Raw.GeneralizedTime)tag.Value);
                }
                else if (tagNumber==6) //start time
                {
                    KerberosReplyHelpers.VerifyTag((new Raw.GeneralizedTime()).GetDefaultTag(), tag.ValueTag);
                    body.StartTime=new Kerberos.Time((Raw.GeneralizedTime)tag.Value);
                }
                else if (tagNumber==7) //end time
                {
                    KerberosReplyHelpers.VerifyTag((new Raw.GeneralizedTime()).GetDefaultTag(), tag.ValueTag);
                    body.EndTime=new Kerberos.Time((Raw.GeneralizedTime)tag.Value);
                }
                else if (tagNumber==8) //renew until
                {
                    KerberosReplyHelpers.VerifyTag((new Raw.GeneralizedTime()).GetDefaultTag(), tag.ValueTag);
                    body.FinalRenewalTime=new Kerberos.Time((Raw.GeneralizedTime)tag.Value);
                }
                else if (tagNumber==9) //server realm
                {
                    KerberosReplyHelpers.VerifyTag((new Raw.GeneralString()).GetDefaultTag(), tag.ValueTag);
                    body.ServerRealm=(Raw.GeneralString)tag.Value;
                }
                else if (tagNumber==10) //server name
                {
                    body.ServerName=Kerberos.PrincipalName.CreateFromAsn(tag.GetValueTagLengthValue());
                }
                else if (tagNumber==11) //client address
                {
                    //TODO:
                    body.ClientAddress=new HostAddress();
                }
                else
                {
                    Global.RO.Warn("Unhandled tag number in KerberosReplyBody: "+tagNumber);
                }
            }

            return body;
        }

        //
        public override string ToString()
        {
            string s="";
            s+="EncBody Key: "+Key;
            s+="\nEncBody LastRequest: "+LastRequest;
            s+="\nEncBody NOnce: "+NOnce;
            s+="\nEncBody KeyExpiration: "+KeyExpiration;
            s+="\nEncBody TicketFlags: "+TicketFlags;
            s+="\nEncBody AuthTime: "+AuthTime;
            s+="\nEncBody StartTime: "+StartTime;
            s+="\nEncBody EndTime: "+EndTime;
            s+="\nEncBody FinalRenewalTime: "+FinalRenewalTime;
            s+="\nEncBody ServerRealm: "+ServerRealm;
            s+="\nEncBody ServerName: "+ServerName;
            s+="\nEncBody ClientAddress: "+ClientAddress;
            return s;
        }
    }; //KerberosReplyBody

    /// <summary> Helpers used in mapping asn trees to replies. </summary>
    public class KerberosReplyHelpers
    {
        public static void VerifyTag(Raw.Tag expect, Raw.Tag got)
        {
            if (expect.CompareTo(got)!=0)
            {
                throw new KerberosAsnException("ASN tag mismatch.  Expected("+expect+") Got("+got+")");
            }
        }
    };
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\Auth\KDC\AsnKerberos.cs ===
using System.IO;

namespace ServerTestFramework.LiveService.Auth.Asn
{
    /// <summary> Thrown for kerberos asn related errors. </summary>
    public class KerberosAsnException: AsnException
    {
        public KerberosAsnException() {}
        public KerberosAsnException(string msg): base(msg) {}
        public KerberosAsnException(string msg, System.Exception e): base(msg, e) {}
    };

    /// <summary> Kerberos-specific ASN encodings. </summary>
    public partial class Kerberos
    {
        /// <summary> A bitstring for kerberos flags.  The standard says this value must contain AT LEAST 32 bits.  It will normally contain exactly 32 bits.  Proper DER encoding will only encode as many bits as needed (truncating trailing 0's in excess of the first 32 bits) (the implementation here does not enforce this). This is a raw value. </summary>
        public class KerberosFlags: Raw.BitString
        {
            public bool Forwardable
            {
                get { return GetBit(1); }
                set { SetBit(1, value); }
            }
            public bool Forwarded
            {
                get { return GetBit(2); }
                set { SetBit(2, value); }
            }
            public bool Proxiable
            {
                get { return GetBit(3); }
                set { SetBit(3, value); }
            }
            public bool Proxied
            {
                get { return GetBit(4); }
                set { SetBit(4, value); }
            }
            public bool AllowPostdate
            {
                get { return GetBit(5); }
                set { SetBit(5, value); }
            }
            public bool Postdated
            {
                get { return GetBit(6); }
                set { SetBit(6, value); }
            }
            public bool Invalid
            {
                get { return GetBit(7); }
                set { SetBit(7, value); }
            }
            public bool Renewable
            {
                get { return GetBit(8); }
                set { SetBit(8, value); }
            }
            public bool Initial
            {
                get { return GetBit(9); }
                set { SetBit(9, value); }
            }
            public bool Preauthenticate
            {
                get { return GetBit(10); }
                set { SetBit(10, value); }
            }
            public bool HardwareAuthentication
            {
                get { return GetBit(11); }
                set { SetBit(11, value); }
            }
            public bool TransistedPolicyChecked
            {
                get { return GetBit(12); }
                set { SetBit(12, value); }
            }
            public bool OkAsDelegate
            {
                get { return GetBit(13); }
                set { SetBit(13, value); }
            }
            public bool Canonicalize
            {
                get { return GetBit(15); }
                set { SetBit(15, value); }
            }
            public bool DisableTransistedCheck
            {
                get { return GetBit(26); }
                set { SetBit(26, value); }
            }
            public bool RenewableOk
            {
                get { return GetBit(27); }
                set { SetBit(27, value); }
            }
            public bool EncryptedTKTInSessionkey
            {
                get { return GetBit(28); }
                set { SetBit(28, value); }
            }
            public bool Renew
            {
                get { return GetBit(30); }
                set { SetBit(30, value); }
            }
            public bool Validate
            {
                get { return GetBit(31); }
                set { SetBit(31, value); }
            }

            //
            public override string ToString()
            {
                string s="";
                if (Forwardable) s+="Forwardable ";
                if (Forwarded) s+="Forwarded ";
                if (Proxiable) s+="Proxiable ";
                if (Proxied) s+="Proxied ";
                if (AllowPostdate) s+="AllowPostdate ";
                if (Postdated) s+="Postdated ";
                if (Invalid) s+="Invalid ";
                if (Renewable) s+="Renewable ";
                if (Initial) s+="Initial ";
                if (Preauthenticate) s+="Preauthenticate ";
                if (HardwareAuthentication) s+="HardwareAuthentication ";
                if (TransistedPolicyChecked) s+="TransistedPolicyChecked ";
                if (OkAsDelegate) s+="OkAsDelegate ";
                if (Canonicalize) s+="Canonicalize ";
                if (DisableTransistedCheck) s+="DisableTransistedCheck ";
                if (RenewableOk) s+="RenewableOk ";
                if (EncryptedTKTInSessionkey) s+="EncryptedTKTInSessionkey ";
                if (Renew) s+="Renew ";
                if (Validate) s+="Validate ";
                s+="("+base.ToString()+")";
                return s;
            }

            public KerberosFlags()
            {
                Count=32;
            }

            public KerberosFlags(Raw.BitString rawbase)
            {
                Bytes=rawbase.Bytes;
            }
        };

        /// <summary> A bitstring for ap option flags.  The standard says this value must contain AT LEAST 32 bits.  It will normally contain exactly 32 bits.</summary>
        public class APOptions: Raw.BitString
        {
            public bool UseSessionKey
            {
                get { return GetBit(1); }
                set { SetBit(1, value); }
            }
            public bool MutualAuthRequired
            {
                get { return GetBit(2); }
                set { SetBit(2, value); }
            }

            //
            public override string ToString()
            {
                string s="";
                if (UseSessionKey) s+="UseSessionKey ";
                if (MutualAuthRequired) s+="MutualAuthRequired ";
                s+="("+base.ToString()+")";
                return s;
            }

            public APOptions()
            {
                Count=32;
            }

            public APOptions(Raw.BitString rawbase)
            {
                Bytes=rawbase.Bytes;
            }
        };

        /// <summary> A sequence of name type and names. This is a tagged value and keeps itself linked together. </summary>
        public class PrincipalName: Compound.TagLengthValue
        {
            //Values used for the name
            public Raw.Integer Type                                    //tag 0
            {
                get { return type; }
                set
                {
                    type=value;
                    TypeTag.Value=value;
                    OverallSequence.Values[0]=(value==null?null:TypeTag);
                }
            }
            private Raw.Integer type=new Raw.Integer();

            public Compound.TagLengthValue<Raw.GeneralString> []Names  //tag 1
            {
                get { return names; }
                set
                {
                    names=value;
                    NameSequence.Values=value;
                    NameSequenceTag.Value=NameSequence;
                    OverallSequence.Values[1]=(value==null?null:NameSequenceTag);
                }
            }
            private Compound.TagLengthValue<Raw.GeneralString> []names=new Compound.TagLengthValue<Raw.GeneralString>[0];

            //Glue used to hold the values
            public Compound.Sequence OverallSequence=new Compound.Sequence();
            public Compound.ExplicitTagLengthValue TypeTag=new Compound.ExplicitTagLengthValue();             //tag 0
            public Compound.ExplicitTagLengthValue NameSequenceTag=new Compound.ExplicitTagLengthValue();     //tag 1
            public Compound.Sequence NameSequence=new Compound.Sequence();

            //
            public PrincipalName()
            {
                Tag=OverallSequence.GetDefaultTag();
                Value=OverallSequence;

                OverallSequence.Values=new AsnValueBase[2];
                OverallSequence.Values[0]=TypeTag;
                OverallSequence.Values[1]=NameSequenceTag;

                TypeTag.ExplicitTag=new Raw.Tag(0, TagClasses.Context, true);
                TypeTag.ValueTag=Type.GetDefaultTag();
                TypeTag.Value=Type;

                NameSequenceTag.ExplicitTag=new Raw.Tag(1, TagClasses.Context, true);
                NameSequenceTag.ValueTag=NameSequence.GetDefaultTag();
                NameSequenceTag.Value=NameSequence;

                NameSequence.Values=names;
            }

            //loads from an asn tag containing the sequence containing everything
            public static PrincipalName CreateFromAsn(Compound.TagLengthValue tag)
            {
                if (tag.Tag.CompareTo((new Compound.Sequence()).GetDefaultTag())!=0)
                {
                    throw new KerberosAsnException("PrincipalName tag does not contain a sequence.");
                }

                Compound.Sequence seq=(Compound.Sequence)tag.Value;

                //copy parts out of sequence
                PrincipalName pn=new PrincipalName();
                pn.Type=null;
                pn.Names=null;

                pn.OverallSequence=seq;
                pn.SetFrom(tag);

                foreach (AsnValueBase val in seq.Values)
                {
                    Compound.ExplicitTagLengthValue expTag=(Compound.ExplicitTagLengthValue)val;
                    ulong expTagNumber=expTag.ExplicitTag.Number;
                    if (expTagNumber==0) //Type
                    {
                        pn.TypeTag=expTag;
                        pn.Type=(Raw.Integer)expTag.Value;
                    }
                    else if (expTagNumber==1) //Names
                    {
                        pn.NameSequenceTag=expTag;
                        Compound.Sequence nameSeq=(Compound.Sequence)expTag.Value;
                        pn.Names=new Compound.TagLengthValue<Raw.GeneralString>[nameSeq.Values.Length];
                        for (int i=0; i<nameSeq.Values.Length; ++i)
                        {
                            Compound.TagLengthValue nameTag=(Compound.TagLengthValue)nameSeq.Values[i];
                            pn.Names[i]=new Compound.TagLengthValue<Raw.GeneralString>();
                            pn.Names[i].Tag=nameTag.Tag;
                            pn.Names[i].Length=nameTag.Length;
                            pn.Names[i].Value=(Raw.GeneralString)nameTag.Value;
                        }
                    }
                    else
                    {
                        Global.RO.Warn("Unknown explicit tag found while parsing principal: "+expTag);
                    }
                }

                return pn;
            }

            public override string ToString()
            {
                string s="PrincipalType("+Type+")";
                if (Names!=null)
                {
                    foreach (Compound.TagLengthValue<Raw.GeneralString> tlv in Names)
                    {
                        if (tlv!=null)
                        {
                            s+=" Name("+tlv.Value+")";
                        }
                    }
                }
                return s;
            }
        };

        /// <summary> Kerberos Time.  This is identical to GeneralizedTime, except that fractional seconds are always omitted. This is a raw value. </summary>
        public class Time: Raw.GeneralizedTime
        {
            public new System.DateTime DateTime
            {
                get
                {
                    System.DateTime dt=base.DateTime;
                    return dt.AddMilliseconds(-dt.Millisecond);
                }

                set
                {
                    base.DateTime=value.AddMilliseconds(-value.Millisecond);
                }
            }

            public Time()
            {
            }

            public Time(Raw.GeneralizedTime rawtime)
            {
                Bytes=rawtime.Bytes;
            }
        };

        /// <summary> Encryption key. This is a tagged value and keeps itself linked together. </summary>
        public class EncryptionKey: CommonTypeDataSequence
        {
            //public Raw.Integer Type      //tag 0
            public Raw.OctetString Key     //tag 1
            {
                get { return Data; }
                set { Data=value; }
            }

            protected new Raw.OctetString Data //hide base
            {
                get { return base.Data; }
                set { base.Data=value; }
            }

            public static EncryptionKey CreateFromAsn(Compound.TagLengthValue tag)
            {
                return CommonTypeDataSequence.CreateFromAsn<EncryptionKey>(tag);
            }

            public override string ToString()
            {
                return "Type("+Type+") Key("+(Key==null?"":"0x"+ServerTestFramework.Utilities.Hexer.tohex(Key.Bytes))+")";
            }
        };

        /// <summary> The class can encrypt or decrypt the data it contains. </summary>
        public interface IEncryptable
        {
            void Encrypt();
            void Decrypt();
        };

        /// <summary> Exposes the asn tree inside of an encrypted structure. </summary>
        public interface IContainsEncryptedAsn: IEncryptable
        {
            AsnValueBase GetInnerAsn();
        };

        /// <summary> Exposes the raw bytes inside of an encrypted structure. </summary>
        public interface IContainsEncryptedBytes: IEncryptable
        {
            byte[] GetInnerBytes();
            void SetInnerBytes(byte []data);
        };

        /// <summary> Encrypted data. This is a tagged value and keeps itself linked together.  It is suggested that any derived classes implement either IContainsEncryptedAsn or IContainsEncryptedBytes so that encrypted data may be fuzzed. </summary>
        public class EncryptedData: Compound.TagLengthValue
        {
            //Values to be encoded
            public Raw.Integer Type      //tag 0
            {
                get { return type; }
                set
                {
                    type=value;
                    TypeTag.Value=value;
                    Sequence.Values[0]=(value==null?null:TypeTag);
                }
            }
            private Raw.Integer type=new Raw.Integer();

            public Raw.Integer Version   //tag 1 (optional)
            {
                get { return version; }
                set
                {
                    version=value;
                    VersionTag.Value=value;
                    Sequence.Values[1]=(value==null?null:VersionTag);
                }
            }
            private Raw.Integer version=null;

            public Raw.OctetString EncryptedBytes  //tag 2
            {
                get { return encryptedBytes; }
                set
                {
                    encryptedBytes=value;
                    EncryptedBytesTag.Value=value;
                    Sequence.Values[2]=(value==null?null:EncryptedBytesTag);
                }
            }
            private Raw.OctetString encryptedBytes=new Raw.OctetString();

            //glue holding this sequence together
            public Compound.Sequence Sequence=new Compound.Sequence();
            public Compound.ExplicitTagLengthValue TypeTag=new Compound.ExplicitTagLengthValue();    //tag 0
            public Compound.ExplicitTagLengthValue VersionTag=new Compound.ExplicitTagLengthValue(); //tag 1
            public Compound.ExplicitTagLengthValue EncryptedBytesTag=new Compound.ExplicitTagLengthValue();    //tag 2

            //
            public EncryptedData()
            {
                Tag=Sequence.GetDefaultTag();
                Value=Sequence;

                Sequence.Values=new AsnValueBase[3];
                Sequence.Values[0]=TypeTag;
                Sequence.Values[1]=null;
                Sequence.Values[2]=EncryptedBytesTag;

                TypeTag.ExplicitTag=new Raw.Tag(0, TagClasses.Context, true);
                TypeTag.ValueTag=Type.GetDefaultTag();
                TypeTag.Value=Type;
                Type.Int64=23; //type we use for about everything

                VersionTag.ExplicitTag=new Raw.Tag(1, TagClasses.Context, true);
                VersionTag.ValueTag=Type.GetDefaultTag();
                VersionTag.Value=Version;

                EncryptedBytesTag.ExplicitTag=new Raw.Tag(2, TagClasses.Context, true);
                EncryptedBytesTag.ValueTag=EncryptedBytes.GetDefaultTag();
                EncryptedBytesTag.Value=EncryptedBytes;
            }

            public override string ToString()
            {
                return "Type("+Type+") Version("+Version+") EncBytes("+(EncryptedBytes==null?"":EncryptedBytes.GetLength()+" bytes")+")";
            }

            //loads from an asn tag containing the sequence containing everything
            public static EncryptedData CreateFromAsn(Compound.TagLengthValue tag)
            {
                EncryptedData enc=new EncryptedData();
                enc.SetFromAsn(tag);
                return enc;
            }

            public void SetFromAsn(Compound.TagLengthValue tag)
            {
                if (tag.Tag.CompareTo((new Compound.Sequence()).GetDefaultTag())!=0)
                {
                    throw new KerberosAsnException("EncryptedData tag does not contain a sequence.");
                }

                Compound.Sequence seq=(Compound.Sequence)tag.Value;

                //copy parts out of sequence
                SetFrom(tag);
                Sequence=new Compound.Sequence();
                Sequence.Values=new AsnValueBase[3];
                Value=Sequence;

                Type=null;
                Version=null;
                EncryptedBytes=null;

                foreach (AsnValueBase val in seq.Values)
                {
                    Compound.ExplicitTagLengthValue expTag=(Compound.ExplicitTagLengthValue)val;
                    ulong expTagNumber=expTag.ExplicitTag.Number;
                    if (expTagNumber==0) //Type
                    {
                        TypeTag=expTag;
                        Type=(Raw.Integer)expTag.Value;
                    }
                    else if (expTagNumber==1) //Version
                    {
                        VersionTag=expTag;
                        Version=(Raw.Integer)expTag.Value;
                    }
                    else if (expTagNumber==2) //Data
                    {
                        EncryptedBytesTag=expTag;
                        EncryptedBytes=(Raw.OctetString)expTag.Value;
                    }
                    else
                    {
                        Global.RO.Warn("Unknown explicit tag found while parsing EncryptedData: "+expTag);
                    }
                }
            }

            public override long SetBytes(byte []bytes, long dataStart, long dataLength)
            {
                long ret=base.SetBytes(bytes, dataStart, dataLength);

                //pull our parts out
                Type=null;
                Version=null;
                EncryptedBytes=null;

                Sequence=(Compound.Sequence)Value;

                foreach (AsnValueBase v in Sequence.Values)
                {
                    Compound.ExplicitTagLengthValue tlv=(Compound.ExplicitTagLengthValue)v;
                    int tlvExpTagNumber=(int)tlv.ExplicitTag.Number;

                    if (tlvExpTagNumber==0) //type
                    {
                        TypeTag=tlv;
                    }
                    else if (tlvExpTagNumber==1) //version
                    {
                        VersionTag=tlv;
                    }
                    else if (tlvExpTagNumber==2) //data
                    {
                        EncryptedBytesTag=tlv;
                    }
                }

                type=(Raw.Integer)TypeTag.Value;
                version=(Raw.Integer)VersionTag.Value;
                encryptedBytes=(Raw.OctetString)EncryptedBytesTag.Value;

                return ret;
            }
        };

        /// <summary> The time(s) of a last request. This is a tagged value. </summary>
        public class LastRequest //: Compound.TagLengthValue
        {
            //individual last request entry
            public class LastRequestEntry
            {
                public Raw.Integer Type;      //tag 0
                public Time Time;             //tag 1
            };

            //list of last requests
            public LastRequestEntry []LastRequests;

            //
            public override string ToString()
            {
                string s="";
                bool first=true;
                foreach (LastRequestEntry e in LastRequests)
                {
                    if (!first) s+=", ";
                    s+="LastRequest(Type="+e.Type+" Time="+e.Time+")";
                    first=false;
                }
                return s;
            }

            //loads from an asn tag containing the sequence containing everything
            public static LastRequest CreateFromAsn(Compound.TagLengthValue tag)
            {
                if (tag.Tag.CompareTo((new Compound.Sequence()).GetDefaultTag())!=0)
                {
                    throw new KerberosAsnException("LastRequest tag does not contain a sequence.");
                }

                Compound.Sequence listSeq=(Compound.Sequence)tag.Value;

                //go through the list of last requests
                LastRequest req=new LastRequest();
                req.LastRequests=new LastRequestEntry[listSeq.Values.Length];
                for (int listInd=0; listInd<listSeq.Values.Length; ++listInd)
                {
                    Compound.TagLengthValue seqTlv=(Compound.TagLengthValue)listSeq.Values[listInd];
                    Compound.Sequence seq=(Compound.Sequence)seqTlv.Value;

                    //copy parts out of inner sequence
                    LastRequestEntry ent=new LastRequestEntry();
                    ent.Type=null;
                    ent.Time=null;
                    foreach (AsnValueBase val in seq.Values)
                    {
                        Compound.ExplicitTagLengthValue expTag=(Compound.ExplicitTagLengthValue)val;
                        ulong expTagNumber=expTag.ExplicitTag.Number;
                        if (expTagNumber==0) //Type
                        {
                            ent.Type=(Raw.Integer)expTag.Value;
                        }
                        else if (expTagNumber==1) //Time
                        {
                            ent.Time=new Time((Raw.GeneralizedTime)expTag.Value);
                        }
                        else
                        {
                            Global.RO.Warn("Unknown explicit tag found while parsing LastRequest: "+expTag);
                        }

                        req.LastRequests[listInd]=ent;
                    }
                }

                return req;
            }
        };

        /// <summary> A kerberos ticket. This is a tagged value and keeps itself linked together. </summary>
        public class Ticket: Compound.TagLengthValue
        {
            //Values to be encoded
            public Raw.Integer Version            //tag 0
            {
                get { return version; }
                set
                {
                    version=value;
                    VersionTag.Value=value;
                    Sequence.Values[0]=(value==null?null:VersionTag);
                }
            }
            private Raw.Integer version=new Raw.Integer();

            public Raw.GeneralString Realm        //tag 1
            {
                get { return realm; }
                set
                {
                    realm=value;
                    RealmTag.Value=value;
                    Sequence.Values[1]=(value==null?null:RealmTag);
                }
            }
            private Raw.GeneralString realm=new Raw.GeneralString();

            public PrincipalName ServerName       //tag 2
            {
                get { return serverName; }
                set
                {
                    serverName=value;
                    ServerNameTag.SetValueTagLengthValue(value);
                    Sequence.Values[2]=(value==null?null:ServerNameTag);
                }
            }
            private PrincipalName serverName=new PrincipalName();

            public EncryptedTicketBody EncryptedBody  //tag 3
            {
                get { return encryptedBody; }
                set
                {
                    encryptedBody=value;
                    EncryptedBodyTag.SetValueTagLengthValue(value);
                    Sequence.Values[3]=(value==null?null:EncryptedBodyTag);
                }
            }
            private EncryptedTicketBody encryptedBody=new EncryptedTicketBody();

            //glue holding this all together
            public Compound.TagLengthValue SequenceTag=new Compound.TagLengthValue();
            public Compound.Sequence Sequence=new Compound.Sequence();

            public Compound.ExplicitTagLengthValue VersionTag=new Compound.ExplicitTagLengthValue();         //tag 0
            public Compound.ExplicitTagLengthValue RealmTag=new Compound.ExplicitTagLengthValue();           //tag 1
            public Compound.ExplicitTagLengthValue ServerNameTag=new Compound.ExplicitTagLengthValue();      //tag 2
            public Compound.ExplicitTagLengthValue EncryptedBodyTag=new Compound.ExplicitTagLengthValue();   //tag 3

            //
            public Ticket()
            {
                Tag=new Raw.Tag(1, TagClasses.Application, true);
                Value=SequenceTag;

                SequenceTag.Tag=Sequence.GetDefaultTag();
                SequenceTag.Value=Sequence;

                Sequence.Values=new AsnValueBase[4];
                Sequence.Values[0]=VersionTag;
                Sequence.Values[1]=RealmTag;
                Sequence.Values[2]=ServerNameTag;
                Sequence.Values[3]=EncryptedBodyTag;

                VersionTag.ExplicitTag=new Raw.Tag(0, TagClasses.Context, true);
                VersionTag.ValueTag=Version.GetDefaultTag();
                VersionTag.Value=Version;

                RealmTag.ExplicitTag=new Raw.Tag(1, TagClasses.Context, true);
                RealmTag.ValueTag=Realm.GetDefaultTag();
                RealmTag.Value=Realm;

                ServerNameTag.ExplicitTag=new Raw.Tag(2, TagClasses.Context, true);
                ServerNameTag.SetValueTagLengthValue(ServerName);

                EncryptedBodyTag.ExplicitTag=new Raw.Tag(3, TagClasses.Context, true);
                EncryptedBodyTag.SetValueTagLengthValue(EncryptedBody);
            }

            //
            public override string ToString()
            {
                string s="";
                s+="Ticket Version: "+Version;
                s+="\nTicket Realm: "+Realm;
                s+="\nTicket ServerName: "+ServerName;
                s+="\nTicket EncryptedBody:\n"+EncryptedBody;

                return s;
            }

            //Loads from an asn tag containing the sequence containing everything.  This does not attempt to decrypt the ticket body.
            public static Ticket CreateFromAsn(Compound.TagLengthValue tag)
            {
                if (tag.Tag.CompareTo(new Raw.Tag(1, TagClasses.Application, true))!=0)
                {
                    throw new KerberosAsnException("Tag is wrong for a ticket: "+tag);
                }

                Compound.TagLengthValue seqTag=(Compound.TagLengthValue)tag.Value;
                Compound.Sequence seq=(Compound.Sequence)seqTag.Value;

                //copy parts to top level glue and values
                Ticket t=new Ticket();

                t.SetFrom(tag);

                t.SequenceTag=seqTag;
                t.Sequence=seq;

                //copy parts out of sequence
                foreach (AsnValueBase val in seq.Values)
                {
                    Compound.ExplicitTagLengthValue expTag=(Compound.ExplicitTagLengthValue)val;
                    ulong expTagNumber=expTag.ExplicitTag.Number;
                    if (expTagNumber==0) //Version
                    {
                        t.VersionTag=expTag;
                        t.Version=(Raw.Integer)expTag.Value;
                    }
                    else if (expTagNumber==1) //Realm
                    {
                        t.RealmTag=expTag;
                        t.Realm=(Raw.GeneralString)expTag.Value;
                    }
                    else if (expTagNumber==2) //ServerName
                    {
                        t.ServerNameTag=expTag;
                        t.ServerName=PrincipalName.CreateFromAsn(expTag.GetValueTagLengthValue());
                    }
                    else if (expTagNumber==3) //EncryptedData
                    {
                        t.EncryptedBodyTag=expTag;
                        EncryptedTicketBody etb=new EncryptedTicketBody();
                        etb.SetFromAsn(expTag.GetValueTagLengthValue());
                        t.EncryptedBody=etb;
                    }
                    else
                    {
                        Global.RO.Warn("Unknown explicit tag found while parsing Ticket: "+expTag);
                    }
                }

                return t;
            }
        };

        /// <summary> The body of kerberos ticket, which is encrypted when stored inside a ticket. This keeps itself linked together. </summary>
        public class EncryptedTicketBody: EncryptedData, IContainsEncryptedAsn
        {
            //data used to build the request
            public KerberosFlags      TicketFlags       //tag 0
            {
                get { return ticketFlags; }
                set
                {
                    ticketFlags=value;
                    TicketFlagsTag.Value=ticketFlags;
                    OverallSequence.Values[0]=(value==null?null:TicketFlagsTag);
                }
            }
            private KerberosFlags ticketFlags;

            public EncryptionKey      Key               //tag 1
            {
                get { return key; }
                set
                {
                    key=value;
                    KeyTag.SetValueTagLengthValue(key);
                    OverallSequence.Values[1]=(value==null?null:KeyTag);
                }
            }
            private EncryptionKey      key;

            public Raw.GeneralString  ClientRealm       //tag 2
            {
                get { return clientRealm; }
                set
                {
                    clientRealm=value;
                    ClientRealmTag.Value=clientRealm;
                    OverallSequence.Values[2]=(value==null?null:ClientRealmTag);
                }
            }
            private Raw.GeneralString  clientRealm;

            public PrincipalName      ClientName        //tag 3
            {
                get { return clientName; }
                set
                {
                    clientName=value;
                    ClientNameTag.SetValueTagLengthValue(clientName);
                    OverallSequence.Values[3]=(value==null?null:ClientNameTag);
                }
            }
            private PrincipalName      clientName;

            public TransitedEncoding  Transite          //tag 4
            {
                get { return transite; }
                set
                {
                    transite=value;
                    TransiteTag.SetValueTagLengthValue(transite);
                    OverallSequence.Values[4]=(value==null?null:TransiteTag);
                }
            }
            private TransitedEncoding  transite;

            public Time               AuthTime          //tag 5
            {
                get { return authTime; }
                set
                {
                    authTime=value;
                    AuthTimeTag.Value=authTime;
                    OverallSequence.Values[5]=(value==null?null:AuthTimeTag);
                }
            }
            private Time               authTime;

            public Time               StartTime         //tag 6  (optional)
            {
                get { return startTime; }
                set
                {
                    startTime=value;
                    StartTimeTag.Value=startTime;
                    OverallSequence.Values[6]=(value==null?null:StartTimeTag);
                }
            }
            private Time               startTime;

            public Time               EndTime           //tag 7
            {
                get { return endTime; }
                set
                {
                    endTime=value;
                    EndTimeTag.Value=endTime;
                    OverallSequence.Values[7]=(value==null?null:EndTimeTag);
                }
            }
            private Time               endTime;

            public Time               FinalRenewalTime  //tag 8  (optional)
            {
                get { return finalRenewalTime; }
                set
                {
                    finalRenewalTime=value;
                    FinalRenewalTimeTag.Value=finalRenewalTime;
                    OverallSequence.Values[8]=(value==null?null:FinalRenewalTimeTag);
                }
            }
            private Time               finalRenewalTime;

            public HostAddress        ClientAddress     //tag 9  (optional)  //TODO
            {
                get { return clientAddress; }
                set
                {
                    clientAddress=value;
                    ClientAddressTag.Value=clientAddress;
                    OverallSequence.Values[9]=(value==null?null:ClientAddressTag);
                }
            }
            private HostAddress        clientAddress;

            public AuthorizationData  AuthorizationData //tag 10 (optional)
            {
                get { return authorizationData; }
                set
                {
                    authorizationData=value;
                    AuthorizationDataTag.SetValueTagLengthValue(authorizationData);
                    OverallSequence.Values[10]=(value==null?null:AuthorizationDataTag);
                }
            }
            private AuthorizationData  authorizationData;

            //asn glue (TLVs and Sequences) that connect the above data into a hierarchy
            public Compound.ExplicitTagLengthValue OverallTag=new Compound.ExplicitTagLengthValue();
            public Compound.Sequence OverallSequence=new Compound.Sequence();
            public Compound.ExplicitTagLengthValue TicketFlagsTag=new Compound.ExplicitTagLengthValue();
            public Compound.ExplicitTagLengthValue KeyTag=new Compound.ExplicitTagLengthValue();
            public Compound.ExplicitTagLengthValue ClientRealmTag=new Compound.ExplicitTagLengthValue();
            public Compound.ExplicitTagLengthValue ClientNameTag=new Compound.ExplicitTagLengthValue();
            public Compound.ExplicitTagLengthValue TransiteTag=new Compound.ExplicitTagLengthValue();
            public Compound.ExplicitTagLengthValue AuthTimeTag=new Compound.ExplicitTagLengthValue();
            public Compound.ExplicitTagLengthValue StartTimeTag=new Compound.ExplicitTagLengthValue();
            public Compound.ExplicitTagLengthValue EndTimeTag=new Compound.ExplicitTagLengthValue();
            public Compound.ExplicitTagLengthValue FinalRenewalTimeTag=new Compound.ExplicitTagLengthValue();
            public Compound.ExplicitTagLengthValue ClientAddressTag=new Compound.ExplicitTagLengthValue();
            public Compound.ExplicitTagLengthValue AuthorizationDataTag=new Compound.ExplicitTagLengthValue();

            //Key used to encrypt and decrypt the ticket
            public byte []EncryptionKey;

            public EncryptedTicketBody()
            {
                OverallTag.ExplicitTag=new Raw.Tag(3, TagClasses.Application, true);
                OverallTag.ValueTag=new Raw.Tag(16, TagClasses.Universal, true);
                OverallTag.Value=OverallSequence;

                OverallSequence.Values=new AsnValueBase[11];

                TicketFlagsTag.ExplicitTag=new Raw.Tag(0, TagClasses.Context, true);
                TicketFlagsTag.ValueTag=(new KerberosFlags()).GetDefaultTag();

                KeyTag.ExplicitTag=new Raw.Tag(1, TagClasses.Context, true);
                KeyTag.ValueTag=new Raw.Tag(0x10, TagClasses.Universal, false);

                ClientRealmTag.ExplicitTag=new Raw.Tag(2, TagClasses.Context, true);
                ClientRealmTag.ValueTag=(new Raw.GeneralString()).GetDefaultTag();

                ClientNameTag.ExplicitTag=new Raw.Tag(3, TagClasses.Context, true);
                ClientNameTag.ValueTag=new Raw.Tag(0x10, TagClasses.Universal, false);

                TransiteTag.ExplicitTag=new Raw.Tag(4, TagClasses.Context, true);
                TransiteTag.ValueTag=new Raw.Tag(0x10, TagClasses.Universal, false);

                AuthTimeTag.ExplicitTag=new Raw.Tag(5, TagClasses.Context, true);
                AuthTimeTag.ValueTag=(new Time()).GetDefaultTag();

                StartTimeTag.ExplicitTag=new Raw.Tag(6, TagClasses.Context, true);
                StartTimeTag.ValueTag=(new Time()).GetDefaultTag();

                EndTimeTag.ExplicitTag=new Raw.Tag(7, TagClasses.Context, true);
                EndTimeTag.ValueTag=(new Time()).GetDefaultTag();

                FinalRenewalTimeTag.ExplicitTag=new Raw.Tag(8, TagClasses.Context, true);
                FinalRenewalTimeTag.ValueTag=(new Time()).GetDefaultTag();

                ClientAddressTag.ExplicitTag=new Raw.Tag(9, TagClasses.Context, true);
                ClientAddressTag.ValueTag=new Raw.Tag(0x10, TagClasses.Universal, false); //TODO

                AuthorizationDataTag.ExplicitTag=new Raw.Tag(10, TagClasses.Context, true);
                AuthorizationDataTag.ValueTag=new Raw.Tag(0x10, TagClasses.Universal, false);
            }

            public void Encrypt()
            {
                byte []rawBytes=OverallTag.GetBytes();
                EncryptedBytes.Bytes=KdcCrypto.RC4HMACEncrypt(rawBytes, EncryptionKey, KdcCrypto.TICKET_SALT);
            }

            public void Decrypt()
            {
                //decrypt and parse
                byte []decryptedBytes;
                decryptedBytes=KdcCrypto.RC4HMACDecrypt(EncryptedBytes.Bytes, EncryptionKey, KdcCrypto.TICKET_SALT);

                long bytesUsed;
                AsnValueBase bodyAsn=Compound.AsnValueParser.Parse(decryptedBytes, 0, decryptedBytes.Length, out bytesUsed);
                if (bytesUsed!=(long)decryptedBytes.Length)
                {
                    throw new KerberosAsnException("Not all bytes in an encrypted ticket body were used.");
                }

                //set
                Compound.ExplicitTagLengthValue bodyTlv=(Compound.ExplicitTagLengthValue)bodyAsn;
                SetInnerAsn(bodyTlv);
            }

            public AsnValueBase GetInnerAsn()
            {
                return OverallTag;
            }

            //Loads values from an asn tag containing the sequence containing everything.
            public void SetInnerAsn(AsnValueBase asn)
            {
                Compound.ExplicitTagLengthValue outterTag=asn as Compound.ExplicitTagLengthValue;
                if (outterTag==null)
                {
                    throw new KerberosAsnException("EncryptedTicketBody must start with an explicit tag-length-value.");
                }

                if (outterTag.ExplicitTag.CompareTo(new Raw.Tag(3, TagClasses.Application, true))!=0)
                {
                    throw new KerberosAsnException("Application Tag is wrong for encrypted ticket body: "+outterTag.ExplicitTag);
                }

                if (outterTag.ValueTag.CompareTo(new Raw.Tag(16, TagClasses.Universal, true))!=0)
                {
                    throw new KerberosAsnException("Value Tag is wrong for encrypted ticket body: "+outterTag.ValueTag);
                }

                Compound.Sequence seq=(Compound.Sequence)outterTag.Value;

                //copy the parts
                OverallSequence=new Compound.Sequence();
                OverallSequence.Values=new AsnValueBase[11];
                OverallTag.SetFrom(outterTag);

                TicketFlags=null;
                Key=null;
                ClientRealm=null;
                ClientName=null;
                Transite=null;
                AuthTime=null;
                StartTime=null;
                EndTime=null;
                FinalRenewalTime=null;
                ClientAddress=null;
                AuthorizationData=null;

                foreach (AsnValueBase val in seq.Values)
                {
                    Compound.ExplicitTagLengthValue expTag=(Compound.ExplicitTagLengthValue)val;
                    ulong expTagNumber=expTag.ExplicitTag.Number;
                    if (expTagNumber==0) //Ticket Flags
                    {
                        TicketFlagsTag=expTag;
                        TicketFlags=new KerberosFlags((Raw.BitString)expTag.Value);
                    }
                    else if (expTagNumber==1) //Key
                    {
                        KeyTag=expTag;
                        Key=Kerberos.EncryptionKey.CreateFromAsn(expTag.GetValueTagLengthValue());
                    }
                    else if (expTagNumber==2) //Client Realm
                    {
                        ClientRealmTag=expTag;
                        ClientRealm=(Raw.GeneralString)expTag.Value;
                    }
                    else if (expTagNumber==3) //Client Name
                    {
                        ClientNameTag=expTag;
                        ClientName=PrincipalName.CreateFromAsn(expTag.GetValueTagLengthValue());
                    }
                    else if (expTagNumber==4) //Transisted
                    {
                        TransiteTag=expTag;
                        Transite=TransitedEncoding.CreateFromAsn(expTag.GetValueTagLengthValue());
                    }
                    else if (expTagNumber==5) //Auth Time
                    {
                        AuthTimeTag=expTag;
                        AuthTime=new Time((Raw.GeneralizedTime)expTag.Value);
                    }
                    else if (expTagNumber==6) //Start Time
                    {
                        StartTimeTag=expTag;
                        StartTime=new Time((Raw.GeneralizedTime)expTag.Value);
                    }
                    else if (expTagNumber==7) //End Time
                    {
                        EndTimeTag=expTag;
                        EndTime=new Time((Raw.GeneralizedTime)expTag.Value);
                    }
                    else if (expTagNumber==8) //Final Renewal Time
                    {
                        FinalRenewalTimeTag=expTag;
                        FinalRenewalTime=new Time((Raw.GeneralizedTime)expTag.Value);
                    }
                    else if (expTagNumber==9) //Client Address
                    {
                        //TODO:
                        ClientAddress=new HostAddress();
                    }
                    else if (expTagNumber==10) //Authorization Data
                    {
                        AuthorizationDataTag=expTag;
                        AuthorizationData=AuthorizationData.CreateFromAsn(expTag.GetValueTagLengthValue());
                    }
                    else
                    {
                        Global.RO.Warn("Unknown explicit tag found while parsing EncryptedTicketBody: "+expTag);
                    }
                }
            }

            //
            public override string ToString()
            {
                if (ClientName==null) //not decrypted
                {
                    return base.ToString();
                }

                string s="";
                s+="EncTicket TicketFlags: "+TicketFlags;
                s+="\nEncTicket Key: "+Key;
                s+="\nEncTicket ClientRealm: "+ClientRealm;
                s+="\nEncTicket ClientName: "+ClientName;
                s+="\nEncTicket Transited: "+Transite;
                s+="\nEncTicket AuthTime: "+AuthTime;
                s+="\nEncTicket StartTime: "+StartTime;
                s+="\nEncTicket EndTime: "+EndTime;
                s+="\nEncTicket FinalRenewalTime: "+FinalRenewalTime;
                s+="\nEncTicket ClientAddress: "+ClientAddress;
                s+="\nEncTicket AuthorizationData: "+AuthorizationData;

               return s;
            }
        };

        /// <summary> Data about previous realm authentication. This is a tagged value and keeps itself linked together. </summary>
        public class TransitedEncoding: CommonTypeDataSequence
        {
            public static TransitedEncoding CreateFromAsn(Compound.TagLengthValue tag)
            {
                return CommonTypeDataSequence.CreateFromAsn<TransitedEncoding>(tag);
            }

            public override string ToString()
            {
                string s="";
                s+="Type("+Type+") ";
                //the contents here is normally just a string... so let's pretend.
                Raw.GeneralString gs=new Raw.GeneralString();
                gs.Bytes=Data.Bytes;
                s+="Contents("+(Data==null?"":gs.String)+")";
                return s;
            }
        };

        /// <summary> A kerberos Authenticator structure. </summary>
        public class Authenticator: Compound.ExplicitTagLengthValue
        {
            //values present in this structure
            public Raw.Integer Version    //tag 0      //normally 5
            {
                get { return version; }
                set
                {
                    version=value;
                    VersionTag.Value=value;
                    MainSequence.Values[0]=(value==null?null:VersionTag);
                }
            }
            private Raw.Integer version=new Raw.Integer();

            public Raw.GeneralString Realm //tag 1
            {
                get { return realm; }
                set
                {
                    realm=value;
                    RealmTag.Value=value;
                    MainSequence.Values[1]=(value==null?null:RealmTag);
                }
            }
            private Raw.GeneralString realm=new Raw.GeneralString();

            public PrincipalName ClientName //tag 2
            {
                get { return clientName; }
                set
                {
                    clientName=value;
                    ClientNameTag.SetValueTagLengthValue(value);
                    MainSequence.Values[2]=(value==null?null:ClientNameTag);
                }
            }
            private PrincipalName clientName=new PrincipalName();

            public Checksum Checksum //tag 3 (optional)
            {
                get { return checksum; }
                set
                {
                    checksum=value;
                    ChecksumTag.Value=value;
                    MainSequence.Values[3]=(value==null?null:ChecksumTag);
                }
            }
            private Checksum checksum=null;

            public Raw.Integer ClientTimeMicroseconds    //tag 4
            {
                get { return clientTimeMicroseconds; }
                set
                {
                    clientTimeMicroseconds=value;
                    ClientTimeMicrosecondsTag.Value=value;
                    MainSequence.Values[4]=(value==null?null:ClientTimeMicrosecondsTag);
                }
            }
            private Raw.Integer clientTimeMicroseconds=new Raw.Integer();

            public Raw.GeneralizedTime ClientTime    //tag 5
            {
                get { return clientTime; }
                set
                {
                    clientTime=value;
                    ClientTimeTag.Value=value;
                    MainSequence.Values[5]=(value==null?null:ClientTimeTag);
                }
            }
            private Raw.GeneralizedTime clientTime=new Raw.GeneralizedTime();

            public EncryptionKey SubKey //tag 6 (optional)
            {
                get { return subKey; }
                set
                {
                    subKey=value;
                    SubKeyTag.Value=value;
                    MainSequence.Values[6]=(value==null?null:SubKeyTag);
                }
            }
            public EncryptionKey subKey;

            public Raw.Integer SequenceNumber    //tag 7 (optional)
            {
                get { return sequenceNumber; }
                set
                {
                    sequenceNumber=value;
                    SequenceNumberTag.Value=value;
                    MainSequence.Values[7]=(value==null?null:SequenceNumberTag);
                }
            }
            private Raw.Integer sequenceNumber=new Raw.Integer();

            public AuthorizationData AuthorizationData  //tag 8 (optional)
            {
                get { return authorizationData; }
                set
                {
                    authorizationData=value;
                    AuthorizationDataTag.SetValueTagLengthValue(value);
                    MainSequence.Values[8]=(value==null?null:AuthorizationDataTag);
                }
            }
            private AuthorizationData authorizationData=null;

            //glue used to hold the above data together
            public Compound.Sequence MainSequence=new Compound.Sequence();
            public Compound.ExplicitTagLengthValue VersionTag=new Compound.ExplicitTagLengthValue();
            public Compound.ExplicitTagLengthValue RealmTag=new Compound.ExplicitTagLengthValue();
            public Compound.ExplicitTagLengthValue ClientNameTag=new Compound.ExplicitTagLengthValue();
            public Compound.ExplicitTagLengthValue ChecksumTag=new Compound.ExplicitTagLengthValue();
            public Compound.ExplicitTagLengthValue ClientTimeMicrosecondsTag=new Compound.ExplicitTagLengthValue();
            public Compound.ExplicitTagLengthValue ClientTimeTag=new Compound.ExplicitTagLengthValue();
            public Compound.ExplicitTagLengthValue SubKeyTag=new Compound.ExplicitTagLengthValue();
            public Compound.ExplicitTagLengthValue SequenceNumberTag=new Compound.ExplicitTagLengthValue();
            public Compound.ExplicitTagLengthValue AuthorizationDataTag=new Compound.ExplicitTagLengthValue();

            //
            public Authenticator()
            {
                ExplicitTag=new Raw.Tag(2, TagClasses.Application, true);
                ValueTag=MainSequence.GetDefaultTag();
                Value=MainSequence;

                version.Int64=5;

                MainSequence.Values=new AsnValueBase[9];
                MainSequence.Values[0]=VersionTag;
                MainSequence.Values[1]=RealmTag;
                MainSequence.Values[2]=ClientNameTag;
                MainSequence.Values[3]=null;
                MainSequence.Values[4]=ClientTimeMicrosecondsTag;
                MainSequence.Values[5]=ClientTimeTag;
                MainSequence.Values[6]=null;
                MainSequence.Values[7]=SequenceNumberTag;
                MainSequence.Values[8]=null;

                VersionTag.ExplicitTag=new Raw.Tag(0, TagClasses.Context, true);
                VersionTag.ValueTag=version.GetDefaultTag();
                VersionTag.Value=version;

                RealmTag.ExplicitTag=new Raw.Tag(1, TagClasses.Context, true);
                RealmTag.ValueTag=realm.GetDefaultTag();
                RealmTag.Value=realm;

                ClientNameTag.ExplicitTag=new Raw.Tag(2, TagClasses.Context, true);
                ClientNameTag.SetValueTagLengthValue(clientName);

                ChecksumTag.ExplicitTag=new Raw.Tag(3, TagClasses.Context, true);
                ChecksumTag.ValueTag=(new Compound.Sequence()).GetDefaultTag();

                ClientTimeMicrosecondsTag.ExplicitTag=new Raw.Tag(4, TagClasses.Context, true);
                ClientTimeMicrosecondsTag.ValueTag=clientTimeMicroseconds.GetDefaultTag();
                ClientTimeMicrosecondsTag.Value=clientTimeMicroseconds;

                ClientTimeTag.ExplicitTag=new Raw.Tag(5, TagClasses.Context, true);
                ClientTimeTag.ValueTag=clientTime.GetDefaultTag();
                ClientTimeTag.Value=clientTime;

                SubKeyTag.ExplicitTag=new Raw.Tag(6, TagClasses.Context, true);
                SubKeyTag.ValueTag=(new Compound.Sequence()).GetDefaultTag();

                SequenceNumberTag.ExplicitTag=new Raw.Tag(7, TagClasses.Context, true);
                SequenceNumberTag.ValueTag=sequenceNumber.GetDefaultTag();
                SequenceNumberTag.Value=sequenceNumber;

                AuthorizationDataTag.ExplicitTag=new Raw.Tag(8, TagClasses.Context, true);
                AuthorizationDataTag.ValueTag=(new Compound.Sequence()).GetDefaultTag();
            }

            //loads from an asn tag containing the sequence containing everything
            public static Authenticator CreateFromAsn(Compound.ExplicitTagLengthValue tag)
            {
                if (tag.ValueTag.CompareTo((new Compound.Sequence()).GetDefaultTag())!=0)
                {
                    throw new KerberosAsnException("Authenticator tag does not contain a sequence.");
                }

                Compound.Sequence seq=(Compound.Sequence)tag.Value;

                //copy parts out of sequence
                Authenticator auth=new Authenticator();
                auth.Version=null;
                auth.Realm=null;
                auth.ClientName=null;
                auth.Checksum=null;
                auth.ClientTimeMicroseconds=null;
                auth.ClientTime=null;
                auth.SubKey=null;
                auth.SequenceNumber=null;
                auth.AuthorizationData=null;

                auth.MainSequence=new Compound.Sequence();
                auth.MainSequence.Values=new AsnValueBase[9];
                auth.SetFrom(tag);
                auth.Value=auth.MainSequence;

                foreach (AsnValueBase val in seq.Values)
                {
                    Compound.ExplicitTagLengthValue expTag=(Compound.ExplicitTagLengthValue)val;
                    ulong expTagNumber=expTag.ExplicitTag.Number;
                    if (expTagNumber==0) //Version
                    {
                        auth.VersionTag=expTag;
                        auth.Version=(Raw.Integer)expTag.Value;
                    }
                    else if (expTagNumber==1) //Realm
                    {
                        auth.RealmTag=expTag;
                        auth.Realm=(Raw.GeneralString)expTag.Value;
                    }
                    else if (expTagNumber==2) //ClientName
                    {
                        auth.ClientNameTag=expTag;
                        auth.ClientName=PrincipalName.CreateFromAsn(expTag.GetValueTagLengthValue());
                    }
                    else if (expTagNumber==3) //Checksum
                    {
                        auth.ChecksumTag=expTag;
                        auth.Checksum=(Checksum)Checksum.CreateFromAsn(expTag.GetValueTagLengthValue());
                    }
                    else if (expTagNumber==4) //ClientTimeMicroseconds
                    {
                        auth.ClientTimeMicrosecondsTag=expTag;
                        auth.ClientTimeMicroseconds=(Raw.Integer)expTag.Value;
                    }
                    else if (expTagNumber==5) //ClientTime
                    {
                        auth.ClientTimeTag=expTag;
                        auth.ClientTime=(Raw.GeneralizedTime)expTag.Value;
                    }
                    else if (expTagNumber==6) //SubKey
                    {
                        auth.SubKeyTag=expTag;
                        auth.SubKey=Kerberos.EncryptionKey.CreateFromAsn(expTag.GetValueTagLengthValue());
                    }
                    else if (expTagNumber==7) //SequenceNumber
                    {
                        auth.SequenceNumberTag=expTag;
                        auth.SequenceNumber=(Raw.Integer)expTag.Value;
                    }
                    else if (expTagNumber==8) //AuthorizationData
                    {
                        auth.AuthorizationDataTag=expTag;
                        auth.AuthorizationData=Kerberos.AuthorizationData.CreateFromAsn(expTag.GetValueTagLengthValue());
                    }
                    else
                    {
                        Global.RO.Warn("Unknown explicit tag found while parsing authenticator: "+expTag);
                    }
                }

                return auth;
            }

            public override string ToString()
            {
                string s="";
                s+="Authenticator Version: "+Version;
                s+="\nAuthenticator Realm: "+Realm;
                s+="\nAuthenticator ClientName: "+ClientName;
                s+="\nAuthenticator Checksum: "+Checksum;
                s+="\nAuthenticator ClientTimeMicroseconds: "+ClientTimeMicroseconds;
                s+="\nAuthenticator ClientTime: "+ClientTime;
                s+="\nAuthenticator SubKey: "+SubKey;
                s+="\nAuthenticator SequenceNumber: "+SequenceNumber;
                s+="\nAuthenticator AuthorizationData: "+AuthorizationData;
                return s;
            }
        };

        /// <summary> A kerberos Authenticator structure, encrypted. </summary>
        public class EncryptedAuthenticator: EncryptedData, IContainsEncryptedAsn
        {
            //The authenticator
            public Authenticator Authenticator;

            //encryption key used to encrypt and decrypt
            public byte []EncryptionKey;

            public void Decrypt()
            {
                byte []asnBytes=KdcCrypto.RC4HMACDecrypt(EncryptedBytes.Bytes, EncryptionKey, KdcCrypto.TGS_REQ_AP_REQ_AUTH_SALT);

                long bytesUsed;
                AsnValueBase asn=Compound.AsnValueParser.Parse(asnBytes, 0, asnBytes.Length, out bytesUsed);
                if (bytesUsed!=(long)asnBytes.Length)
                {
                    throw new KerberosAsnException("Not all bytes in an encrypted authenticator were used.");
                }

                Compound.ExplicitTagLengthValue etlv=(Compound.ExplicitTagLengthValue)asn;
                Authenticator=Kerberos.Authenticator.CreateFromAsn(etlv);
            }

            //encrypts Authenticator to EncryptedAuthenticator
            public void Encrypt()
            {
                byte []rawBytes=Authenticator.GetBytes();
                EncryptedBytes.Bytes=KdcCrypto.RC4HMACEncrypt(rawBytes, EncryptionKey, KdcCrypto.TGS_REQ_AP_REQ_AUTH_SALT);
            }

            public AsnValueBase GetInnerAsn()
            {
                return Authenticator;
            }

            public override string ToString()
            {
                if (Authenticator==null) //not decrypted or set
                {
                    return base.ToString();
                }

                return Authenticator.ToString();
            }
        };

        /// <summary> Authorization Data.  This is used as part of an authenticator, or inside the encrypted part of a ticket for the service to return data back to itself. </summary>
        public class AuthorizationData: Compound.TagLengthValue
        {
            public Compound.Sequence List //this is a sequence of CommonTypeDataSequence
            {
                get { return list; }
                set
                {
                    Value=value;
                    list=value;
                }
            }
            private Compound.Sequence list=new Compound.Sequence();

            //
            public AuthorizationData()
            {
                Tag=list.GetDefaultTag();
                Value=list;
            }

            public static AuthorizationData CreateFromAsn(Compound.TagLengthValue tag)
            {
                //check outter sequence tag
                if (tag.Tag.CompareTo((new Compound.Sequence()).GetDefaultTag())!=0)
                {
                    throw new KerberosAsnException("Tag does not contain a sequence to parse an AuthorizationData from.");
                }

                Compound.Sequence seq=(Compound.Sequence)tag.Value;

                //parse each one as CommonTypeDataSequence
                AuthorizationData ad=new AuthorizationData();
                ad.List.Values=new CommonTypeDataSequence[seq.Values.Length];

                ad.SetFrom(tag);
                ad.Value=ad.List;

                for (int i=0; i<seq.Values.Length; ++i)
                {
                    Compound.TagLengthValue tlv=(Compound.TagLengthValue)seq.Values[i];
                    ad.List.Values[i]=CommonTypeDataSequence.CreateFromAsn<CommonTypeDataSequence>(tlv);
                }

                return ad;
            }

            public override string ToString()
            {
                string s="";
                if (list!=null)
                {
                    foreach (AsnValueBase vb in list.Values)
                    {
                        s+="\nAD "+vb;
                    }
                }

                return s;
            }
        };

        /// <summary> A checksum. </summary>
        public class Checksum: CommonTypeDataSequence
        {
            public static Checksum CreateFromAsn(Compound.TagLengthValue tag)
            {
                return CommonTypeDataSequence.CreateFromAsn<Checksum>(tag);
            }
        };

        /// <summary> A sequencey with tag 0 for an integer Type and tag 1 for octet string Data.  This construct is a recurring theme, so this is just a common base class. </summary>
        public class CommonTypeDataSequence: Compound.TagLengthValue
        {
            //Values to be encoded
            public Raw.Integer Type      //tag 0
            {
                get { return type; }
                set
                {
                    type=value;
                    TypeTag.Value=value;
                    Sequence.Values[0]=(value==null?null:TypeTag);
                }
            }
            private Raw.Integer type=new Raw.Integer();

            public Raw.OctetString Data  //tag 1
            {
                get { return data; }
                set
                {
                    data=value;
                    DataTag.Value=value;
                    Sequence.Values[1]=(value==null?null:DataTag);
                }
            }
            private Raw.OctetString data=new Raw.OctetString();

            //glue holding this sequence together
            public Compound.Sequence Sequence=new Compound.Sequence();
            public Compound.ExplicitTagLengthValue TypeTag=new Compound.ExplicitTagLengthValue();    //tag 0
            public Compound.ExplicitTagLengthValue DataTag=new Compound.ExplicitTagLengthValue();    //tag 1

            //
            public CommonTypeDataSequence()
            {
                Tag=Sequence.GetDefaultTag();
                Value=Sequence;

                Sequence.Values=new AsnValueBase[2];
                Sequence.Values[0]=TypeTag;
                Sequence.Values[1]=DataTag;

                TypeTag.ExplicitTag=new Raw.Tag(0, TagClasses.Context, true);
                TypeTag.ValueTag=Type.GetDefaultTag();
                TypeTag.Value=Type;

                DataTag.ExplicitTag=new Raw.Tag(1, TagClasses.Context, true);
                DataTag.ValueTag=Data.GetDefaultTag();
                DataTag.Value=Data;
            }

            public override string ToString()
            {
                string s="";
                s+="Type("+Type+") ";
                s+="Data("+Data+")";
                return s;
            }

            //loads from an asn tag containing the sequence containing everything
            public static CommonTypeDataSequenceType CreateFromAsn<CommonTypeDataSequenceType>(Compound.TagLengthValue tag) where CommonTypeDataSequenceType:CommonTypeDataSequence, new()
            {
                CommonTypeDataSequenceType ctds=new CommonTypeDataSequenceType();
                ctds.SetFromAsn(tag);
                return ctds;
            }

            public void SetFromAsn(Compound.TagLengthValue tag)
            {
                if (tag.Tag.CompareTo((new Compound.Sequence()).GetDefaultTag())!=0)
                {
                    throw new KerberosAsnException("Tag does not contain a sequence to parse a CommonTypeDataSequence from.");
                }

                Compound.Sequence seq=(Compound.Sequence)tag.Value;

                //copy the parts out
                SetFrom(tag);
                Sequence=new Compound.Sequence();
                Sequence.Values=new AsnValueBase[2];
                Value=Sequence;

                Type=null;
                Data=null;

                foreach (AsnValueBase val in seq.Values)
                {
                    Compound.ExplicitTagLengthValue expTag=(Compound.ExplicitTagLengthValue)val;
                    ulong expTagNumber=expTag.ExplicitTag.Number;
                    if (expTagNumber==0) //Type
                    {
                        TypeTag=expTag;
                        Type=(Raw.Integer)expTag.Value;
                    }
                    else if (expTagNumber==1) //Data
                    {
                        DataTag=expTag;
                        Data=(Raw.OctetString)expTag.Value;
                    }
                    else
                    {
                        Global.RO.Warn("Unknown explicit tag found while parsing CommonTypeDataSequence: "+expTag);
                    }
                }
            }
        };
    }; //class Kerberos
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\Auth\KDC\KdcCrypto.cs ===
using System.Security.Cryptography;

namespace ServerTestFramework.LiveService.Auth
{
    public class XmacsKeys
    {
        static XmacsKeys()
        {
            AuthClientBase.InitializeKerbClient();
        }

        /// <summary> Encrypts data using the default xmacs public key. </summary>
        public static byte[] Encrypt(byte[] data)
        {
            if (XmacsClient.UseXmacsTestKey())
            {
                return EncryptWithTestKey(data);
            }
            else
            {
                return EncryptWithRealKey(data);
            }
        }

        /// <summary> Encrypts data using the test xmacs public key. </summary>
        public static byte[] EncryptWithTestKey(byte[] data)
        {
            byte []outBuff=new byte[256];
            System.Array.Copy(data, 0, outBuff, 0, data.Length);

            uint encDataUsed=(uint)data.Length;
            kcl_EncryptWithXmacsTestKey(outBuff, ref encDataUsed, (uint)outBuff.Length);

            if ((int)encDataUsed!=outBuff.Length)
            {
                throw new System.Exception("Encrypted data is a different length than the buffer. (Should this ever happen?)");
            }

            return outBuff;
        }

        /// <summary> Encrypts data using the real xmacs public key. </summary>
        public static byte[] EncryptWithRealKey(byte[] data)
        {
            byte []outBuff=new byte[256];
            System.Array.Copy(data, 0, outBuff, 0, data.Length);

            uint encDataUsed=(uint)data.Length;
            kcl_EncryptWithXmacsKey(outBuff, ref encDataUsed, (uint)outBuff.Length);

            if ((int)encDataUsed!=outBuff.Length)
            {
                throw new System.Exception("Encrypted data is a different length than the buffer. (Should this ever happen?)");
            }

            return outBuff;
        }

        //kerbclient calls (return value is pointless, .NET throws if nonzero)
        [System.Runtime.InteropServices.DllImport("kerbclient2.dll", EntryPoint="kcl_EncryptWithXmacsTestKey", PreserveSig=false)]
        private static extern uint kcl_EncryptWithXmacsTestKey(
            byte[]   pbMessage,
            ref uint cbMessage,
            uint     pbMessageMaxSize);

        [System.Runtime.InteropServices.DllImport("kerbclient2.dll", EntryPoint="kcl_EncryptWithXmacsKey", PreserveSig=false)]
        private static extern uint kcl_EncryptWithXmacsKey(
            byte[]   pbMessage,
            ref uint cbMessage,
            uint     pbMessageMaxSize);
    };

    public class ConsoleKeys
    {
        static ConsoleKeys()
        {
            AuthClientBase.InitializeKerbClient();
        }

        /// <summary> Does a SHA1 hash on certificateData (must be a XE_CONSOLE_CERTIFICATE), and generates a signature from that using the xenon test master signing key. </summary>
        public static byte[] GenerateCertificateSignature(byte[] data)
        {
            byte []outBuff=new byte[256];
            uint buffUsed=(uint)outBuff.Length;
            kcl_GenerateConsoleCertificateSignature(data, outBuff, ref buffUsed);

            if ((int)buffUsed!=outBuff.Length)
            {
                throw new System.Exception("Signature data is a different length than the buffer. (Should this ever happen?)");
            }

            return outBuff;
        }

        /// <summary> Signs data from a sha1 hash using the common test xenon console key and returns it. </summary>
        public static byte[] SignHashWithConsoleKey(byte[] shaHashedData)
        {
            byte []outBuff=new byte[128];
            uint buffUsed=(uint)outBuff.Length;
            kcl_SignHashWithConsoleKey(shaHashedData, (uint)shaHashedData.Length, outBuff, ref buffUsed);

            if ((int)buffUsed!=outBuff.Length)
            {
                throw new System.Exception("Signature data is a different length than the buffer. (Should this ever happen?)");
            }

            return outBuff;
        }

        /// <summary> Signs data from a sha1 hash using a specific xenon console key and returns it. </summary>
        public static byte[] SignHashWithConsoleCspBlob(byte[] shaHashedData, byte []rsaCspBlob)
        {
            byte []outBuff=new byte[128];
            uint buffUsed=(uint)outBuff.Length;
            kcl_SignHashWithConsoleCspBlob(shaHashedData, (uint)shaHashedData.Length, rsaCspBlob, (uint)rsaCspBlob.Length, outBuff, ref buffUsed);

            if ((int)buffUsed!=outBuff.Length)
            {
                throw new System.Exception("Signature data is a different length than the buffer. (Should this ever happen?)");
            }

            return outBuff;
        }

        /// <summary> Generates a csp blob representing a new public/private console key pair that is used in the xenon console certificate. </summary>
        public static byte[] GenerateConsoleKeyPairCspBlob(out byte []exponent, out byte []modulus)
        {
            byte []outBuff=new byte[2048];
            uint buffUsed=(uint)outBuff.Length;

            exponent=new byte[4];
            modulus=new byte[128];
            kcl_GenerateConsoleKeyPairCspBlob(outBuff, ref buffUsed, exponent, modulus);

            System.Array.Resize(ref outBuff, (int)buffUsed);

            return outBuff;
        }

        //kerbclient calls (return value is pointless, .NET throws if nonzero)
        [System.Runtime.InteropServices.DllImport("kerbclient2.dll", EntryPoint="kcl_GenerateConsoleCertificateSignature", PreserveSig=false)]
        private static extern uint kcl_GenerateConsoleCertificateSignature(
            byte []pCertificate,
            byte []pSignatureBuffer,
            ref uint signatureBufferLength);

        [System.Runtime.InteropServices.DllImport("kerbclient2.dll", EntryPoint="kcl_SignHashWithConsoleKey", PreserveSig=false)]
        private static extern uint kcl_SignHashWithConsoleKey(
            byte []pbSha1,
            uint cbSha1,
            byte []pbSignature,
            ref uint pcbSignature);

        [System.Runtime.InteropServices.DllImport("kerbclient2.dll", EntryPoint="kcl_SignHashWithConsoleCspBlob", PreserveSig=false)]
        private static extern uint kcl_SignHashWithConsoleCspBlob(
            byte []pbSha1,
            uint cbSha1,
            byte []pbCspBlob,
            uint cbCspBlob,
            byte []pbSignature,
            ref uint pcbSignature);

        [System.Runtime.InteropServices.DllImport("kerbclient2.dll", EntryPoint="kcl_GenerateConsoleKeyPairCspBlob", PreserveSig=false)]
        private static extern uint kcl_GenerateConsoleKeyPairCspBlob(
            byte []pbCspBlob,
            ref uint pcbCspBlob,
            byte []pbPublicKeyExponent,
            byte []pbPublicKeyModulus);
    };

    public class KdcCrypto
    {
        static KdcCrypto()
        {
            AuthClientBase.InitializeKerbClient();
        }

        public const uint TIMESTAMP_SALT                  = 1;
        public const uint TICKET_SALT                     = 2;
        public const uint AS_REP_SALT                     = 3;
        public const uint TGS_REQ_SESSKEY_SALT            = 4;
        public const uint TGS_REQ_SUBKEY_SALT             = 5;
        public const uint TGS_REQ_AP_REQ_AUTH_CKSUM_SALT  = 6;
        public const uint TGS_REQ_AP_REQ_AUTH_SALT        = 7;
        public const uint TGS_REP_SALT                    = 8;
        public const uint TGS_REP_SUBKEY_SALT             = 9;
        public const uint AP_REQ_AUTH_CKSUM_SALT          = 10;
        public const uint AP_REQ_AUTH_SALT                = 11;
        public const uint AP_REP_SALT                     = 12;
        public const uint PRIV_SALT                       = 13;
        public const uint CRED_SALT                       = 14;
        public const uint SAFE_SALT                       = 15;
        public const uint NON_SALT                        = 16;
        public const uint NON_CKSUM_SALT                  = 17;
        public const uint ERROR_SALT                      = 18;
        public const uint KDC_ISSUED_CKSUM_SALT           = 19;
        public const uint MANDATORY_TKT_EXT_CKSUM_SALT    = 20;
        public const uint AUTH_DATA_TKT_EXT_CKSUM_SALT    = 21;
        public const uint PA_COMPOUND_IDENTITY_SALT       = 1024;
        public const uint KDC_REQ_NONCE_CKSUM_SALT        = 1026;
        public const uint PA_CLIENT_VER_SALT              = 1027;
        public const uint PA_XBOX_SERVICE_REQUEST_SALT    = 1201;
        public const uint PA_XBOX_SERVICE_ADDRESS_SALT    = 1202;
        public const uint PA_XBOX_ACCOUNT_CREATION_SALT   = 1203;
        public const uint PA_PC_ACCOUNT_CREATION_SALT     = 1204;
        public const uint PA_PC_ACCOUNT_CREATION_REP_SALT = 1205;
        public const uint PA_PASSPORT_AUTHENTICATION_SALT = 1206;

        public const int HmacCryptoOverhead = 24; //24 bytes of overhead for encryption/checksum

        /// <summary> Encrypts data using "rc4 hmac". </summary>
        public static byte[] RC4HMACEncrypt(byte []data, byte []key, uint saltType)
        {
            byte []outBuff=new byte[data.Length+HmacCryptoOverhead];
            uint outBuffSize=(uint)outBuff.Length;
            kcl_RC4HmacEncrypt(key, (uint)key.Length, saltType, data, (uint)data.Length, outBuff, ref outBuffSize);

            if ((int)outBuffSize!=outBuff.Length)
            {
                throw new System.Exception("Output data is a different length than the passed in buffer. (Should this ever happen?)");
            }

            return outBuff;
        }

        /// <summary> Decrypts data using "rc4 hmac", key and salt. </summary>
        public static byte[] RC4HMACDecrypt(byte []data, byte []key, uint saltType)
        {
            byte []outBuff=new byte[data.Length-HmacCryptoOverhead];
            uint outBuffSize=(uint)outBuff.Length;
            kcl_RC4HmacDecrypt(key, (uint)key.Length, saltType, data, (uint)data.Length, outBuff, ref outBuffSize);

            if ((int)outBuffSize!=outBuff.Length)
            {
                throw new System.Exception("Output data is a different length than the passed in buffer. (Should this ever happen?)");
            }

            return outBuff;
        }

        /// <summary> Decrypts data using a key, salt, and an nonce. </summary>
        public static byte[] RC4HMACDecryptUsingNonce(byte []data, byte []key, uint nonce, uint saltType)
        {
            byte []outBuff=new byte[data.Length-HmacCryptoOverhead];
            uint outBuffSize=(uint)outBuff.Length;
            kcl_RC4HMacDecryptUsingNonceAndKey(outBuff, ref outBuffSize, data, (uint)data.Length,  key, (uint)key.Length, nonce, saltType);

            if ((int)outBuffSize!=outBuff.Length)
            {
                throw new System.Exception("Output data is a different length than the passed in buffer. (Should this ever happen?)");
            }

            return outBuff;
        }

        /// <summary> Encrypts data using a key, salt, and an nonce. </summary>
        public static byte[] RC4HMACEncryptUsingNonce(byte []data, byte []key, uint nonce, uint saltType)
        {
            byte []outBuff=new byte[data.Length+HmacCryptoOverhead];
            uint outBuffSize=(uint)outBuff.Length;
            kcl_RC4HMacEncryptUsingNonceAndKey(outBuff, ref outBuffSize, data, (uint)data.Length,  key, (uint)key.Length, nonce, saltType);

            if ((int)outBuffSize!=outBuff.Length)
            {
                throw new System.Exception("Output data is a different length than the passed in buffer. (Should this ever happen?)");
            }

            return outBuff;
        }

        /// <summary> Generates a signature, using a key and an nonce. </summary>
        public static byte[] GenerateHMAC4SignatureUsingNonceAndKey(byte []data, byte []key, uint nonce)
        {
            byte []sig=new byte[20];
            kcl_GenerateSignatureUsingNonceAndKey(sig, (uint)sig.Length, data, (uint)data.Length, key, (uint)key.Length, nonce);
            return sig;
        }

        /// <summary> Computes a compound identity key used for the askdc when the compound identity preauth is present. </summary>
        public static byte[] ComputeCompoundIdentityKey(byte []clientKey, byte []sessionKey)
        {
            byte []outBuff=new byte[16];
            uint outBuffSize=(uint)outBuff.Length;
            kcl_ComputeCompoundIdentityKey(clientKey, (uint)clientKey.Length, sessionKey, (uint)sessionKey.Length, outBuff, ref outBuffSize);

            if ((int)outBuffSize!=outBuff.Length)
            {
                throw new System.Exception("Output data is a different length than the passed in buffer. (Should this ever happen?)");
            }

            return outBuff;
        }

        /// <summary> Computes a principal key used to encrypt the pc account creation preauth, from the passport ticket session key and the pc nonce. </summary>
        public static byte[] ComputePCPrincipalKey(byte []sessionKey, ulong pcNOnce)
        {
            byte []nonceBytes=System.BitConverter.GetBytes(pcNOnce);

            byte []outBuff=new byte[16];
            uint outBuffSize=(uint)outBuff.Length;
            kcl_ComputePCPrincipalKey(sessionKey, (uint)sessionKey.Length, nonceBytes, (uint)nonceBytes.Length, outBuff, ref outBuffSize);

            if ((int)outBuffSize!=outBuff.Length)
            {
                throw new System.Exception("Output data is a different length than the passed in buffer. (Should this ever happen?)");
            }

            return outBuff;
        }

        // --

        //kerbclient calls (return value is pointless, .NET throws if nonzero)
        [System.Runtime.InteropServices.DllImport("kerbclient2.dll", EntryPoint="kcl_RC4HmacEncrypt", PreserveSig=false)]
        private static extern uint kcl_RC4HmacEncrypt(
            byte[] pbKey,
            uint KeySize,
            uint MessageType,
            byte []pbInput,
            uint cbInput,
            byte[] pbOutput,
            ref uint pcbOutput);

        [System.Runtime.InteropServices.DllImport("kerbclient2.dll", EntryPoint="kcl_RC4HmacDecrypt", PreserveSig=false)]
        private static extern uint kcl_RC4HmacDecrypt(
            byte[] pbKey,
            uint KeySize,
            uint MessageType,
            byte []pbInput,
            uint cbInput,
            byte[] pbOutput,
            ref uint pcbOutput);

        [System.Runtime.InteropServices.DllImport("kerbclient2.dll", EntryPoint="kcl_RC4HMacEncryptUsingNonceAndKey", PreserveSig=false)]
        private static extern uint kcl_RC4HMacEncryptUsingNonceAndKey(
            byte[] outData,
            ref uint inoutDataLength,
            byte[] data,
            uint dataLength,
            byte[] keyBytes,
            uint keyLength,
            uint nonce,
            uint messageType);

        [System.Runtime.InteropServices.DllImport("kerbclient2.dll", EntryPoint="kcl_RC4HMacDecryptUsingNonceAndKey", PreserveSig=false)]
        private static extern uint kcl_RC4HMacDecryptUsingNonceAndKey(
            byte[] outData,
            ref uint inoutDataLength,
            byte[] data,
            uint dataLength,
            byte[] keyBytes,
            uint keyLength,
            uint nonce,
            uint messageType);

        [System.Runtime.InteropServices.DllImport("kerbclient2.dll", EntryPoint="kcl_GenerateSignatureUsingNonceAndKey", PreserveSig=false)]
        private static extern uint kcl_GenerateSignatureUsingNonceAndKey(
            byte[] outSignature,
            uint outSignatureLength,
            byte[] data,
            uint dataLength,
            byte[] keyBytes,
            uint keyLength,
            uint nonce);

        [System.Runtime.InteropServices.DllImport("kerbclient2.dll", EntryPoint="kcl_ComputeCompoundIdentityKey", PreserveSig=false)]
        private static extern uint kcl_ComputeCompoundIdentityKey(
            byte []pbClientKey,
            uint cbClientKey,
            byte []pbSessionKey,
            uint cbSessionKey,
            byte []pbCompoundKey,
            ref uint pcbCompoundKey);

        [System.Runtime.InteropServices.DllImport("kerbclient2.dll", EntryPoint="kcl_ComputePCPrincipalKey", PreserveSig=false)]
        private static extern uint kcl_ComputePCPrincipalKey(
            byte []pbSessionKey,
            uint cbSessionKey,
            byte []pbPCNonce,
            uint cbPCNOnce,
            byte []pbPrincipalKey,
            ref uint pcbPrincipalKey);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\Auth\KDC\KerberosRequest.cs ===
using System.Collections.Generic;
using ServerTestFramework.LiveService.Auth.Asn;

namespace ServerTestFramework.LiveService.Auth
{
    public class HostAddress: AsnBytes
    { //todo...
    };

    /// <summary> Represents a kerberos request (rfc 4120). </summary>
    public class KerberosRequest: Compound.ExplicitTagLengthValue
    {
        // -- data used to build the request

        //KDC Request (contains these and the body below)
        public Raw.Integer            Version;               //request tag 1            //normally always 5
        public Raw.Integer            MessageType;           //request tag 2            //10=as 12=tgs
        public Kerberos.Preauth     []Preauths;              //request tag 3 (optional)

        //KDC Request Body                                   //request tag 4
        public Kerberos.KerberosFlags Options;               //body tag 0
        public Kerberos.PrincipalName ClientName;            //body tag 1
        public Raw.GeneralString      Realm;                 //body tag 2
        public Kerberos.PrincipalName ServerName;            //body tag 3    (optional)
        public Kerberos.Time          FromTime;              //body tag 4    (optional)
        public Kerberos.Time          UntilTime;             //body tag 5
        public Kerberos.Time          FinalRenewalTime;      //body tag 6    (optional)
        public Raw.Integer            NOnce;                 //body tag 7               //SIGNED 32 bit integer range.  Note that the standard says UNSIGNED, but our kerberos server has a long-standing bug in that it expects values in the range of a signed integer instead of an unsigned integer.
        public Raw.Integer          []EncryptionTypes;       //body tag 8
        public HostAddress            HostAddress;           //body tag 9    (optional) //TODO:
        public Kerberos.EncryptedData EncryptedData;         //body tag 10   (optional)
        public Kerberos.Ticket      []Tickets;               //body tag 11   (optional)

        // -- asn glue (TLVs and Sequences) that connect the above data into a hierarchy

        public Compound.Sequence               RequestSequence;      //overall sequence inside the app tag

        public Compound.ExplicitTagLengthValue VersionTag;           //request tag 1
        public Compound.ExplicitTagLengthValue MessageTypeTag;       //request tag 2
        public Compound.ExplicitTagLengthValue PreauthsTag;          //request tag 3
        public Compound.Sequence               PreauthsSequence;

        public Compound.ExplicitTagLengthValue BodyTag;              //request tag 4
        public Compound.Sequence               BodySequence;

        public Compound.ExplicitTagLengthValue OptionsTag;           //body tag 0
        public Compound.ExplicitTagLengthValue ClientNameTag;        //body tag 1
        public Compound.ExplicitTagLengthValue RealmTag;             //body tag 2
        public Compound.ExplicitTagLengthValue ServerNameTag;        //body tag 3
        public Compound.ExplicitTagLengthValue FromTimeTag;          //body tag 4
        public Compound.ExplicitTagLengthValue UntilTimeTag;         //body tag 5
        public Compound.ExplicitTagLengthValue FinalRenewalTimeTag;  //body tag 6
        public Compound.ExplicitTagLengthValue NOnceTag;             //body tag 7
        public Compound.ExplicitTagLengthValue EncryptionTypesTag;   //body tag 8
        public Compound.Sequence               EncryptionTypesSequence;
        public Compound.TagLengthValue       []EncryptionTypeValueTags;
        //public Compound.ExplicitTagLengthValue HostAddressTag;     //body tag 9 //TODO
        public Compound.ExplicitTagLengthValue EncryptedDataTag;     //body tag 10
        public Compound.ExplicitTagLengthValue TicketsTag;           //body tag 11
        public Compound.Sequence               TicketsSequence;

        /// <summary> Creates the above glue components and links all data into a hierarchy then updates length fields.  After this call, GetBytes can be called to produce the actual request to send. </summary>
        public void ConstructRequest()
        {
            //clear all glue
            RequestSequence=null;

            VersionTag=null;
            MessageTypeTag=null;
            PreauthsTag=null;
            PreauthsSequence=null;

            BodyTag=null;
            BodySequence=null;

            OptionsTag=null;
            ClientNameTag=null;
            RealmTag=null;
            ServerNameTag=null;
            FromTimeTag=null;
            UntilTimeTag=null;
            FinalRenewalTimeTag=null;
            NOnceTag=null;
            EncryptionTypesTag=null;
            EncryptionTypesSequence=null;
            EncryptionTypeValueTags=null;
            EncryptedDataTag=null;
            TicketsTag=null;
            TicketsSequence=null;

            //construct glue for components that exist and explicitely tag them... we don't connect them at this point, just create them all
            this.ExplicitTag=new Raw.Tag(10, TagClasses.Application, true);
            RequestSequence=new Compound.Sequence();

            if (Version!=null)
            {
                VersionTag=new Compound.ExplicitTagLengthValue();
                VersionTag.ExplicitTag=new Raw.Tag(1, TagClasses.Context, true);
            }

            if (MessageType!=null)
            {
                MessageTypeTag=new Compound.ExplicitTagLengthValue();
                MessageTypeTag.ExplicitTag=new Raw.Tag(2, TagClasses.Context, true);
            }

            if (Preauths!=null)
            {
                PreauthsTag=new Compound.ExplicitTagLengthValue();
                PreauthsTag.ExplicitTag=new Raw.Tag(3, TagClasses.Context, true);
                PreauthsSequence=new Compound.Sequence();
            }

            BodyTag=new Compound.ExplicitTagLengthValue();
            BodyTag.ExplicitTag=new Raw.Tag(4, TagClasses.Context, true);
            BodySequence=new Compound.Sequence();

            if (Options!=null)
            {
                OptionsTag=new Compound.ExplicitTagLengthValue();
                OptionsTag.ExplicitTag=new Raw.Tag(0, TagClasses.Context, true);
            }

            if (ClientName!=null)
            {
                ClientNameTag=new Compound.ExplicitTagLengthValue();
                ClientNameTag.ExplicitTag=new Raw.Tag(1, TagClasses.Context, true);
            }

            if (Realm!=null)
            {
                RealmTag=new Compound.ExplicitTagLengthValue();
                RealmTag.ExplicitTag=new Raw.Tag(2, TagClasses.Context, true);
            }

            if (ServerName!=null)
            {
                ServerNameTag=new Compound.ExplicitTagLengthValue();
                ServerNameTag.ExplicitTag=new Raw.Tag(3, TagClasses.Context, true);
            }

            if (FromTime!=null)
            {
                FromTimeTag=new Compound.ExplicitTagLengthValue();
                FromTimeTag.ExplicitTag=new Raw.Tag(4, TagClasses.Context, true);
            }

            if (UntilTime!=null)
            {
                UntilTimeTag=new Compound.ExplicitTagLengthValue();
                UntilTimeTag.ExplicitTag=new Raw.Tag(5, TagClasses.Context, true);
            }

            if (FinalRenewalTime!=null)
            {
                FinalRenewalTimeTag=new Compound.ExplicitTagLengthValue();
                FinalRenewalTimeTag.ExplicitTag=new Raw.Tag(6, TagClasses.Context, true);
            }

            if (NOnce!=null)
            {
                NOnceTag=new Compound.ExplicitTagLengthValue();
                NOnceTag.ExplicitTag=new Raw.Tag(7, TagClasses.Context, true);
            }

            if (EncryptionTypes!=null)
            {
                EncryptionTypesTag=new Compound.ExplicitTagLengthValue();
                EncryptionTypesTag.ExplicitTag=new Raw.Tag(8, TagClasses.Context, true);
                EncryptionTypesSequence=new Compound.Sequence();
                EncryptionTypeValueTags=new Compound.TagLengthValue[EncryptionTypes.Length];
                for (int i=0; i<EncryptionTypeValueTags.Length; ++i)
                {
                    EncryptionTypeValueTags[i]=new Compound.TagLengthValue();
                }
            }

            if (EncryptedData!=null)
            {
                EncryptedDataTag=new Compound.ExplicitTagLengthValue();
                EncryptedDataTag.ExplicitTag=new Raw.Tag(10, TagClasses.Context, true);
            }

            if (Tickets!=null)
            {
                TicketsTag=new Compound.ExplicitTagLengthValue();
                TicketsTag.ExplicitTag=new Raw.Tag(11, TagClasses.Context, true);
                TicketsSequence=new Compound.Sequence();
            }

            //link data/glue together and recalculate lengths
            Relink();
            RecalculateLengths();
        }

        /// <summary> Links the glue and data into a hierarchy. </summary>
        public void Relink()
        {
            //the outter request container is a sequence
            this.ValueTag=RequestSequence.GetDefaultTag();
            this.Value=RequestSequence;

            //store the parts of the sequence
            List<AsnValueBase> requestSequence=new List<AsnValueBase>();
            {
                if (VersionTag!=null)
                {
                    VersionTag.ValueTag=Version.GetDefaultTag();
                    VersionTag.Value=Version;
                    requestSequence.Add(VersionTag);
                }

                if (MessageTypeTag!=null)
                {
                    MessageTypeTag.ValueTag=MessageType.GetDefaultTag();
                    MessageTypeTag.Value=MessageType;
                    requestSequence.Add(MessageTypeTag);
                }

                if (PreauthsTag!=null)
                {
                    PreauthsTag.ValueTag=PreauthsSequence.GetDefaultTag();
                    PreauthsTag.Value=PreauthsSequence;
                    PreauthsSequence.Values=Preauths;
                    requestSequence.Add(PreauthsTag);
                }

                if (BodyTag!=null)
                {
                    BodyTag.ValueTag=BodySequence.GetDefaultTag();
                    BodyTag.Value=BodySequence;

                    //store the parts of the body
                    List<AsnValueBase> bodySequence=new List<AsnValueBase>();
                    {
                        if (OptionsTag!=null)
                        {
                            OptionsTag.ValueTag=Options.GetDefaultTag();
                            OptionsTag.Value=Options;
                            bodySequence.Add(OptionsTag);
                        }

                        if (ClientNameTag!=null)
                        {
                            ClientNameTag.SetValueTagLengthValue(ClientName);
                            bodySequence.Add(ClientNameTag);
                        }

                        if (RealmTag!=null)
                        {
                            RealmTag.ValueTag=Realm.GetDefaultTag();
                            RealmTag.Value=Realm;
                            bodySequence.Add(RealmTag);
                        }

                        if (ServerNameTag!=null)
                        {
                            ServerNameTag.SetValueTagLengthValue(ServerName);
                            bodySequence.Add(ServerNameTag);
                        }

                        if (FromTimeTag!=null)
                        {
                            FromTimeTag.ValueTag=FromTime.GetDefaultTag();
                            FromTimeTag.Value=FromTime;
                            bodySequence.Add(FromTimeTag);
                        }

                        if (UntilTimeTag!=null)
                        {
                            UntilTimeTag.ValueTag=UntilTime.GetDefaultTag();
                            UntilTimeTag.Value=UntilTime;
                            bodySequence.Add(UntilTimeTag);
                        }

                        if (FinalRenewalTimeTag!=null)
                        {
                            FinalRenewalTimeTag.ValueTag=FinalRenewalTime.GetDefaultTag();
                            FinalRenewalTimeTag.Value=FinalRenewalTime;
                            bodySequence.Add(FinalRenewalTimeTag);
                        }

                        if (NOnceTag!=null)
                        {
                            NOnceTag.ValueTag=NOnce.GetDefaultTag();
                            NOnceTag.Value=NOnce;
                            bodySequence.Add(NOnceTag);
                        }

                        if (EncryptionTypesTag!=null)
                        {
                            EncryptionTypesTag.ValueTag=EncryptionTypesSequence.GetDefaultTag();
                            EncryptionTypesTag.Value=EncryptionTypesSequence;

                            for (int i=0; i<EncryptionTypes.Length; ++i)
                            {
                                EncryptionTypeValueTags[i].Tag=EncryptionTypes[i].GetDefaultTag();
                                EncryptionTypeValueTags[i].Value=EncryptionTypes[i];
                            }

                            EncryptionTypesSequence.Values=EncryptionTypeValueTags;

                            bodySequence.Add(EncryptionTypesTag);
                        }

                        if (EncryptedDataTag!=null)
                        {
                            EncryptedDataTag.SetValueTagLengthValue(EncryptedData);
                            bodySequence.Add(EncryptedDataTag);
                        }

                        if (TicketsTag!=null)
                        {
                            TicketsTag.ValueTag=TicketsSequence.GetDefaultTag();
                            TicketsTag.Value=TicketsSequence;
                            TicketsSequence.Values=new AsnValueBase[Tickets.Length];
                            for (int i=0; i<Tickets.Length; ++i)
                            {
                                TicketsSequence.Values[i]=Tickets[i];
                            }
                        }
                    }
                    BodySequence.Values=bodySequence.ToArray();

                    requestSequence.Add(BodyTag);
                }
            }
            RequestSequence.Values=requestSequence.ToArray();
        }

        /// <summary> Recalculates all lengths fields in the hierarchy. </summary>
        public void RecalculateLengths()
        {
            RecalculateLengths(true);
        }

        //
        public override string ToString()
        {
            string s="";

            s+="Version: "+Version;
            s+="\nMessageType: "+MessageType;
            s+="\nPreauths: ";
            if (Preauths!=null)
            {
                foreach (Kerberos.Preauth pa in Preauths)
                {
                    if (pa!=null)
                    {
                        s+="\n"+pa.ToString();
                    }
                }
            }
            s+="\nOptions: "+Options;
            s+="\nClientName: "+ClientName;
            s+="\nRealm: "+Realm;
            s+="\nServerName: "+ServerName;
            s+="\nFromTime: "+FromTime;
            s+="\nUntilTime: "+UntilTime;
            s+="\nFinalRenewalTime: "+FinalRenewalTime;
            s+="\nNOnce: "+NOnce;
            s+="\nEncryptionTypes: ";
            if (EncryptionTypes!=null)
            {
                bool first=true;
                foreach (Raw.Integer i in EncryptionTypes)
                {
                    if (!first) s+=", ";
                    s+=i;
                    first=false;
                }
            }
            s+="\nHostAddress: "+HostAddress;
            s+="\nEncryptedData: "+EncryptedData;
            s+="\nTickets: ";
            if (Tickets!=null)
            {
                foreach (Kerberos.Ticket t in Tickets)
                {
                    s+=t+"\n";
                }
            }

            return s;
        }
    };

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\Auth\KDC\SimpleKdcClient.cs ===
using ServerTestFramework.LiveService.Auth.Asn;

namespace ServerTestFramework.LiveService.Auth
{
    /// <summary> Allows you to set a few basic properties then perform all the steps needed to get an Xkdc ticket without knowing how the KDC works. </summary>
    public class SimpleKdcClient
    {
        //Input:
        public KdcUser []Users=null; //This may be set with up to 4 users to authenticate.
        public System.Nullable<uint> TitleID; //Title id to get a ticket for.  If not set, the platform's dash title will be used.
        public uint []Services=null; //List of services to request.  If null, autodiscover (or some defaults in the case of xbox1) will be used.

        //Input/Output:
        public XmacsGenericReplyOutput Machine=null; //If set, this existing machine will be authenticated, rather than creating a new machine.  If a new machine is created this will be set.

        //Output:
        public XkdcGenericReplyOutput []XkdcOutputs; //Tickets, keys, and other information back from the xkdc for each site.

        //Whether to throw an exception if an xkdc reply is not a kerberos error, but the overall hr result from the xbox preauth indicates failure.
        public bool XkdcThrowOnOverallHRFailure=true;

        // --

        protected KdcClient kdc;

        //
        public SimpleKdcClient(AuthContext.ClientTypes initialClientType)
        {
            kdc=new KdcClient(initialClientType);
        }

        /// <summary> Creates a machine account with xmacs, authenticates all users and the machine with askdc, then gets one or more tickets from the xkdc. </summary>
        public void Execute()
        {
            //clear anything old and set client settings
            kdc.ClearXmacs();
            kdc.ClearAskdc();
            kdc.ClearXkdc();
            XkdcOutputs=null;

            kdc.XkdcThrowOnOverallHRFailure=XkdcThrowOnOverallHRFailure;

            //do xmacs
            if (Machine==null)
            {
                kdc.ExecuteXmacs(true);
                Machine=kdc.XmacsOutput;
            }
            else
            {
                kdc.XmacsOutput=Machine;
            }

            //do askdc
            if (Users!=null && Users.Length>0)
            {
                if (Users.Length<=4)
                {
                    foreach (KdcUser user in Users)
                    {
                        kdc.CreateAskdcUserRequest(user);
                        kdc.ExecuteAskdc(true);
                    }
                }
                else //(Users.Length>4)
                {
                    throw new KdcClientException("Only 4 users may be authenticated.");
                }
            }

            kdc.CreateAskdcMachineRequest();
            kdc.ExecuteAskdc(true);

            //do xkdc
            kdc.CreateXkdcRequest();

            if (TitleID!=null)
            {
                kdc.XkdcRequest.Input.TitleID=(uint)TitleID;
            }

            if (Services!=null)
            {
                kdc.XkdcRequest.Input.AutoDiscoverServices=0;
                kdc.XkdcRequest.Input.Services=Services;
            }

            System.Collections.Generic.List<XkdcGenericReplyOutput> xkdcOut=new System.Collections.Generic.List<XkdcGenericReplyOutput>();
            kdc.ExecuteXkdc(true);
            xkdcOut.Add(kdc.XkdcOutput);

            while (kdc.XkdcResultHasMoreSites())
            {
                kdc.SetXkdcRequestForNextSite();
                kdc.ExecuteXkdc(true);
                xkdcOut.Add(kdc.XkdcOutput);
            }

            XkdcOutputs=xkdcOut.ToArray();
        }
    };
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\Auth\KDC\UserUtils.cs ===
using ServerTestFramework.LiveService.Auth.Asn;

namespace ServerTestFramework.LiveService.Auth
{
    /// <summary> Holds a passport ticket and associated session key (if any) </summary>
    public class PassportTicket
    {
        public byte []Bytes; //Bytes of the passport ticket
        public byte []Key;   //Session key for the passport ticket

        public PassportTicket()
        {
        }

        public PassportTicket(byte []ticketBytes, byte []ticketSessionKey)
        {
            Bytes=ticketBytes;
            Key=ticketSessionKey;
        }

        public PassportTicket Clone()
        {
            PassportTicket copy=new PassportTicket();

            copy.Bytes=(byte[])Bytes.Clone();
            copy.Key=(byte[])Key.Clone();

            return copy;
        }
    };

    /// <summary> Utility to create a passport user and/or get a passport ticket. </summary>
    public class PassportAuth
    {
        public string UserName;     //Passport user name
        public string Password;     //Passport user password
        public ulong  Puid;         //passport puid

        public bool   EncryptForPanoramaByDefault=false; //TODO: After panorama switches to using the new preauth, we should change this to true.

        private System.Collections.Generic.Dictionary<string, PassportTicket> tickets=new System.Collections.Generic.Dictionary<string, PassportTicket>();

        /// <summary> Creates a passport user through uacs and populates the UserName and Password fields. </summary>
        public void CreateUser()
        {
            ServerTestFramework.LiveService.UserAccount.UacsCommon uc=new ServerTestFramework.LiveService.UserAccount.UacsCommon();
            ServerTestFramework.LiveService.UserAccount.UacsCommon.PassportUser ppu=null;
            for (int i=0; i<10; ++i)
            {
                try
                {
                    ppu=uc.CreatePassportUser();
                    break;
                }
                catch (System.Exception e)
                {
                    if (i==9) throw;
                    Global.RO.Debug("CreatePassportUser failed(will retry) on try "+(i+1)+" of 10 :"+e.Message);
                }
            }

            UserName=ppu.MemberName;
            Password=ppu.Password;
            Puid=ppu.PassportPuid;
        }

        /// <summary> Clears all cached passport tickets. </summary>
        public void ClearTickets()
        {
            tickets=new System.Collections.Generic.Dictionary<string, PassportTicket>();
        }

        /// <summary> Retrieves a passport ticket for the specific policy (from cache if able, else hits passport).  If no username/password has been set a user will be created. </summary>
        public PassportTicket GetTicket(string policy, AuthClientBase.PassportSite rpsSiteToUse)
        {
            return GetTicket(policy, AuthClientBase.GetPassportSite(rpsSiteToUse));
        }

        /// <summary> Retrieves a passport ticket for the specific policy (from cache if able, else hits passport).  If no username/password has been set a user will be created. </summary>
        public PassportTicket GetTicket(string policy, string rpsSite)
        {
            if (UserName==null || Password==null)
            {
                CreateUser();
            }

            string key=MakeKeyFromParams(policy, rpsSite);

            if (tickets.ContainsKey(key))
            {
                return tickets[key];
            }

            PassportTicket newTicket=new PassportTicket();
            AuthClientBase.GetPassportTicket(UserName, Password, out newTicket.Bytes, out newTicket.Key, policy, rpsSite);
            tickets[key]=newTicket;
            return newTicket;
        }

        /// <summary> Returns a cached ticket if there is one, without preference for which ticket type it is. </summary>
        public PassportTicket GetRandomCachedTicket()
        {
            foreach (System.Collections.Generic.KeyValuePair<string, PassportTicket> pairs in tickets)
            {
                return pairs.Value;
            }

            return null;
        }

        /// <summary> Returns whether there is a cached ticket for the specific policy. </summary>
        public bool HasCachedTicket(string policy, AuthClientBase.PassportSite rpsSiteToUse)
        {
            return HasCachedTicket(policy, AuthClientBase.GetPassportSite(rpsSiteToUse));
        }

        /// <summary> Returns whether there is a cached ticket for the specific policy. </summary>
        public bool HasCachedTicket(string policy, string rpsSite)
        {
            string key=MakeKeyFromParams(policy, rpsSite);

            foreach (System.Collections.Generic.KeyValuePair<string, PassportTicket> pairs in tickets)
            {
                if (pairs.Key==key)
                {
                    return true;
                }
            }

            return false;
        }

        /// <summary> Stores a ticket in the cache for a user for a policy. </summary>
        public void SetTicket(string policy, AuthClientBase.PassportSite rpsSiteToUse, PassportTicket ticket)
        {
            SetTicket(policy, AuthClientBase.GetPassportSite(rpsSiteToUse), ticket);
        }

        /// <summary> Stores a ticket in the cache for a user for a policy. </summary>
        public void SetTicket(string policy, string rpsSite, PassportTicket ticket)
        {
            string key=MakeKeyFromParams(policy, rpsSite);
            tickets[key]=ticket;
        }

        /*
        Our KDC isn't accepting these tickets for some reason.  Additionally they have a different size than real tickets, so aren't suitable for most KDC testing.  Perhaps someday we will revisit this.
        /// <summary> Populates the class with fields from ticket parameters and synthesizes a passport ticket.  If ticketParams is null a default will be generated. </summary>
        public void LoadAndSynthesizeTicket(ServerTestFramework.LiveService.Auth.RPSTicketGen.TicketParameters ticketParams)
        {
            if (ticketParams==null)
            {
                ticketParams=new ServerTestFramework.LiveService.Auth.RPSTicketGen.TicketParameters();
                ticketParams.Puid=unchecked((long)ServerTestFramework.Core.Utilities.RandomEx.GlobalRandGen.NextUlong());
            }

            UserName=ticketParams.MemberName;
            Password="NotReal";
            Puid=unchecked((ulong)ticketParams.Puid);

            ServerTestFramework.LiveService.Auth.RPSTicketGen.TicketGen.GenerateTicketBytes(ticketParams, out Ticket, out TicketKey);
        }*/

        private static string MakeKeyFromParams(string policy, string rpsSite)
        {
            return policy+"\0"+rpsSite;
        }

        private static void MakeParamsFromKey(string key, out string policy, out string rpsSite)
        {
            int splitter=key.IndexOf("\0");
            policy=key.Substring(0, splitter);
            rpsSite=key.Substring(splitter+1);
        }

        public PassportAuth Clone()
        {
            PassportAuth copy=new PassportAuth();

            copy.UserName=UserName;
            copy.Password=Password;
            copy.Puid=Puid;
            copy.EncryptForPanoramaByDefault=EncryptForPanoramaByDefault;

            foreach (string key in tickets.Keys)
            {
                string policy, rpsSite;
                MakeParamsFromKey(key, out policy, out rpsSite);

                copy.SetTicket(policy, rpsSite, tickets[key].Clone());
            }

            return copy;
        }
    };

    /// <summary> Minimal amount of information needed to authenticate a user with the KDC. </summary>
    public class KdcUser
    {
        public ulong         UserID;
        public string        Gamertag;
        public byte        []XenonKey; //Xbox360 users require this. 16 bytes
        public byte        []XboxKey;  //Xbox1 users require this. 16 bytes
        public PassportAuth  Passport; //PC users require this

        /// <summary> Creates an xbox user and creates a passport and links them. </summary>
        public void CreateUser()
        {
            CreateUser(false);
        }

        /// <summary> Creates a user with a specific name, and optionally creates a passport for them. </summary>
        public void CreateOrUseExisting(string gamertag, bool hasPassport)
        {
            //create xbox user
            ServerTestFramework.Database.UserEditor xbu=ServerTestFramework.Database.UserEditor.CreateOrUseExistingGamerTag(gamertag);
            UserID=xbu.Puid;
            Gamertag=xbu.Gamertag;
            XboxKey=xbu.XboxKey;
            XenonKey=xbu.XenonKey;

            //create and link passport
            if (hasPassport)
            {
                LinkPassport(null);
            }
        }

        /// <summary> Uses an existing user with a specific name. </summary>
        public void UseExisting(string gamertag)
        {
            ServerTestFramework.Database.UserEditor xbu=ServerTestFramework.Database.UserEditor.FromGamerTag(gamertag);
            UserID=xbu.Puid;
            Gamertag=xbu.Gamertag;
            XboxKey=xbu.XboxKey;
            XenonKey=xbu.XenonKey;
        }

        /// <summary> Uses an existing user with a specific name. </summary>
        public void UseExisting(ulong puid)
        {
            ServerTestFramework.Database.UserEditor xbu = ServerTestFramework.Database.UserEditor.FromPuid(puid);
            UserID = xbu.Puid;
            Gamertag = xbu.Gamertag;
            XboxKey = xbu.XboxKey;
            XenonKey = xbu.XenonKey;
        }

        /// <summary> Creates an xbox user with a random name, and optionally creates a passport and links them. </summary>
        public void CreateUser(bool hasPassport)
        {
            //create xbox user
            ServerTestFramework.Database.UserEditor xbu=ServerTestFramework.Database.UserEditor.CreateNew();
            UserID=xbu.Puid;
            Gamertag=xbu.Gamertag;
            XboxKey=xbu.XboxKey;
            XenonKey=xbu.XenonKey;

            //create and link passport
            if (hasPassport)
            {
                LinkPassport(null);
            }
        }

        /// <summary> </summary>
        public void SetFakeUser(string gamertag, bool genPassport)
        {
            UserID=1;
            Gamertag=gamertag;
            XenonKey=new byte[16];
            XboxKey=XenonKey;

            if (genPassport)
            {
                Passport=new PassportAuth();
                Passport.CreateUser();
            }
        }

        /// <summary> Links this user to a passport.  If pp is null, a new one will be created. </summary>
        public void LinkPassport(PassportAuth pp)
        {
            if (pp==null)
            {
                pp=new PassportAuth();
                pp.CreateUser();
            }

            Passport=pp;

            ServerTestFramework.Database.UserEditor xbu=ServerTestFramework.Database.UserEditor.FromPuid(UserID);
            xbu.LinkPassport(Passport.Puid);
        }

        /*
        Our KDC isn't accepting these tickets for some reason.  Additionally they have a different size than real tickets, so aren't suitable for most KDC testing.  Perhaps someday we will revisit this.
        /// <summary> Generates a synthesized passport ticket and links the user to that passport.  If ticketParams is null a default will be created. </summary>
        public void LinkSynthesizedTicket(ServerTestFramework.LiveService.Auth.RPSTicketGen.TicketParameters ticketParams)
        {
            if (Passport==null)
            {
                Passport=new PassportAuth();
            }

            Passport.LoadAndSynthesizeTicket(ticketParams);

            ServerTestFramework.Database.UserEditor xbu=ServerTestFramework.Database.UserEditor.FromPuid(UserID);
            xbu.LinkPassport(Passport.Puid);
        }*/

        public KdcUser Clone()
        {
            KdcUser copy=new KdcUser();
            copy.UserID=UserID;
            copy.Gamertag=Gamertag;
            copy.XenonKey=(byte[])XenonKey.Clone();
            copy.XboxKey=(byte[])XboxKey.Clone();
            copy.Passport=Passport.Clone();
            return copy;
        }
    };
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\Auth\KDC\RequestInterfaces.cs ===
using ServerTestFramework.LiveService.Auth.Asn;

namespace ServerTestFramework.LiveService.Auth
{
    /// <summary> These fields are used when SetRequest is called, to populate the relevent portions of the base KerberosRequest.  This contains fields for all platforms, though not all platforms use all fields. </summary>
    public abstract class RequestInputCommon
    {
        /// <summary> If this is null, the default preauths will be used.  If this is not null then only these preauths will be included in the request.  If needed, preauths containing nonsense will be generated to satisfy this list. </summary>
        public System.Collections.Generic.LinkedList<int> PreauthsToGenerate=null;

        /// <summary> Retrieves a list of preauths that will be generated by default.  Note that this may vary based on the current input parameters. </summary>
        public abstract System.Collections.Generic.LinkedList<int> GetDefaultPreauthsToGenerate();

        /// <summary> Holds all the specific preauths generated for this request. </summary>
        public Kerberos.Preauth []Preauths;

        /// <summary> Clears all preauths that have been generated. </summary>
        public void ClearPreauths()
        {
            Preauths=null;
        }

        /// <summary> Creates all the preauths required for the request, based on the other input fields. </summary>
        public abstract void GeneratePreauths();

        /// <summary> Finds a preauth of the specific number. </summary>
        public T FindPreauth<T>(int paNumber) where T:Kerberos.Preauth
        {
            if (Preauths!=null)
            {
                foreach (Kerberos.Preauth pa in Preauths)
                {
                    if (pa!=null && pa.Type!=null && pa.Type.Int64==paNumber)
                    {
                        return (T)pa;
                    }
                }
            }

            return default(T);
        }

        /// <summary> Finds a preauth of the specific type. </summary>
        public T FindPreauth<T>() where T:Kerberos.Preauth
        {
            if (Preauths!=null)
            {
                foreach (Kerberos.Preauth pa in Preauths)
                {
                    if (pa!=null && pa is T)
                    {
                        return (T)pa;
                    }
                }
            }

            return default(T);
        }

        /// <summary> Sets the request time. </summary>
        public abstract void SetRequestTime(System.DateTime newTime);

        /// <summary> Gets the current requset time. </summary>
        public abstract System.DateTime GetRequestTime();

        /// <summary> Sets a new random nonce. </summary>
        public abstract void SetRandomNOnce();

        /// <summary> Gets the current nonce. </summary>
        public abstract uint GetNOnce();

        /// <summary> Sets new nonces and updates the request time to the current time (or a time greater than the last request if the same), to prepare to resend a request because a packed was lost. </summary>
        public void PrepareForResend()
        {
            SetRandomNOnce();

            System.DateTime prevReqTime=GetRequestTime();
            System.DateTime newReqTime=System.DateTime.UtcNow;
            if (prevReqTime==newReqTime)
            {
                newReqTime=newReqTime.AddMilliseconds(1);
            }
            SetRequestTime(newReqTime);
        }
    };

    /// <summary> Common interface for our kerberos requests, to set the higher level input into the base KerberosRequest. </summary>
    public abstract class KerberosRequestWithInput: KerberosRequest
    {
        /// <summary> Data used to populate the base KerberosRequest. </summary>
        public RequestInputCommon Input;

        /// <summary> Sets all the appropriate fields in a KerberosRequest based on Input. </summary>
        public abstract void SetRequest();
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\Auth\KDC\XkdcXbox360.cs ===
using ServerTestFramework.LiveService.Auth.Asn;

namespace ServerTestFramework.LiveService.Auth
{
    /// <summary> These fields are used when SetRequest is called, to populate the relevent portions of the KerberosRequest.  This is a subset of everything in the request, but should contain all the most common stuff we want to trivially play with. </summary>
    public class XkdcXbox360RequestInput: XkdcGenericRequestInput
    {
        //Ticket                  tgt ticket from the askdc
        //ConsoleId               Console ID of the machine, in the form of XE.123456789012
        //Key                     16 byte key chosen by the service, returned in the encrypted body of an Askdc reply
        //Realm                   Normally XBOX.COM
        //ServerNames             Normally sg and S#, where # is the site number
        //RequestTime             Time that the request was made
        //NOnce                   Value unique to this particular request

        //ClientMajorVersion
        //ClientMinorVersion
        //ClientBuildVersion
        //ClientQFEVersion
        //FlashVersion            format is 0xMmbbbbqq, where M=major m=minor bbbb=build qq=qfe
        //TitleID
        //TitleVersion
        //TitleRegion
        //ConsoleRegion
        //MediaID
        //LanguageID
        //AutoDiscoverServices    normally either 0 or 1
        //UserIDs                 up to 4 users
        //Services                there is room for 128 byte services and 4 dword services right now
        //UserPINs
        //FlowToken
        //XenonPreauthVersion     if not null, overrides which xenon service request preauth to use (may be either 4 or 5)
        //ServiceRequestVersion   if not null, overrides the default service request version placed into the service request preauth

        /// <summary> Retrieves a list of preauths that will be generated by default.  Note that this may vary based on the current input parameters. </summary>
        public override System.Collections.Generic.LinkedList<int> GetDefaultPreauthsToGenerate()
        {
            System.Collections.Generic.LinkedList<int> defaultPreauths=new System.Collections.Generic.LinkedList<int>();

            uint xenonSRPreauthToUse=5; //default to 5 for xbox360
            if (XenonPreauthVersion!=null)
            {
                if (XenonPreauthVersion==4)
                {
                    xenonSRPreauthToUse=4;
                }
                else if (XenonPreauthVersion==5)
                {
                    xenonSRPreauthToUse=5;
                }
                else
                {
                    Global.RO.Warn("Invalid xkdc xenon service request preauth version override specified: "+XenonPreauthVersion);
                }
            }

            if (xenonSRPreauthToUse==4)
            {
                defaultPreauths.AddLast(210); //PADATA_XENON_SERVICE_REQUEST2
            }
            else //5
            {
                defaultPreauths.AddLast(214); //PADATA_XENON_SERVICE_REQUEST3
            }

            defaultPreauths.AddLast(206); //PADATA_XBOX_CLIENT_VERSION
            defaultPreauths.AddLast(1); //PADATA_TGS_REQ

            return defaultPreauths;
        }

        /// <summary> Creates all the preauths required for the request, based on the other input fields. </summary>
        public override void GeneratePreauths()
        {
            ClearPreauths();

            System.Collections.Generic.IEnumerable<int> preauthsToAdd=PreauthsToGenerate;
            if (preauthsToAdd==null)
            {
                preauthsToAdd=GetDefaultPreauthsToGenerate();
            }

            System.Collections.Generic.List<Kerberos.Preauth> preauths=new System.Collections.Generic.List<Kerberos.Preauth>();
            foreach (int paNumber in preauthsToAdd)
            {
                if (paNumber==210) //PADATA_XENON_SERVICE_REQUEST2
                {
                    Kerberos.Preauth<Kerberos.PreauthXenonServiceRequest2> pa=new Kerberos.Preauth<Kerberos.PreauthXenonServiceRequest2>();
                    PopulateServiceRequest(pa.Data);
                    pa.Data.EncryptionKey=Key;
                    pa.Data.EncryptionNOnce=NOnce;
                    pa.Data.Encrypt();
                    preauths.Add(pa);
                }
                else if (paNumber==214) //PADATA_XENON_SERVICE_REQUEST3
                {
                    Kerberos.Preauth<Kerberos.PreauthXenonServiceRequest3> pa=new Kerberos.Preauth<Kerberos.PreauthXenonServiceRequest3>();
                    PopulateServiceRequest(pa.Data);
                    pa.Data.EncryptionKey=Key;
                    pa.Data.EncryptionNOnce=NOnce;
                    pa.Data.Encrypt();
                    preauths.Add(pa);
                }
                else
                {
                    Kerberos.Preauth pa=PreauthHelpers.GenerateDefaultPreauth(paNumber, Key, RequestTime, ConsoleId, Ticket, NOnce, 0xfffe07d1, 0x12345678, 0x9abcdef0, 0, null, null, null, false, null);
                    preauths.Add(pa);
                }
            }

            Preauths=preauths.ToArray();
        }

        public void PopulateServiceRequest(Kerberos.PreauthXenonServiceRequest2 data)
        {
            data.RequestVersion = ServiceRequestVersion ?? 4;
            data.RequestSize = 124;
            data.ClientVersionMajor = ClientMajorVersion;
            data.ClientVersionMinor = ClientMinorVersion;
            data.ClientVersionBuild = ClientBuildVersion;
            data.ClientVersionQFE = ClientQFEVersion;
            data.FlashVersion = FlashVersion;
            data.TitleID = TitleID;
            data.TitleVersion = TitleVersion;
            data.TitleRegion = TitleRegion;
            data.ConsoleRegion = ConsoleRegion;
            data.MediaID = MediaID;
            data.LanguageID = LanguageID;
            data.AutoDiscoverServices = AutoDiscoverServices;
            data.UserIDs = new ulong[4];
            for (int i = 0; i < (UserIDs.Length <= 4 ? UserIDs.Length : 4); ++i)
            {
                data.UserIDs[i] = UserIDs[i];
            }
            ushort numByteServices = 0;
            ushort numDwordServices = 0;
            data.ByteServiceIDs = new byte[32];
            data.DwordServiceIDs = new uint[4];
            foreach (uint service in Services)
            {
                if (service < 256 && numByteServices < 32) //put in a byte slot if it's a byte and there's room
                {
                    data.ByteServiceIDs[numByteServices] = (byte)service;
                    ++numByteServices;
                }
                else if (numDwordServices < 4) //put in a dword slot
                {
                    data.DwordServiceIDs[numDwordServices] = service;
                    ++numDwordServices;
                }
                else
                {
                    throw new System.Exception("PreauthXenonServiceRequest2 cannot hold all " + Services.Length + " of the services requested.  Cannot find a slot for service " + service);
                }
            }
            data.NumByteServices = numByteServices;
            data.NumDwordServices = numDwordServices;
        }

        public void PopulateServiceRequest(Kerberos.PreauthXenonServiceRequest3 data)
        {
            data.RequestVersion = ServiceRequestVersion ?? 5;
            data.ClientVersionMajor = ClientMajorVersion;
            data.ClientVersionMinor = ClientMinorVersion;
            data.ClientVersionBuild = ClientBuildVersion;
            data.ClientVersionQFE = ClientQFEVersion;
            data.FlashVersion = FlashVersion;
            data.TitleID = TitleID;
            data.TitleVersion = TitleVersion;
            data.TitleRegion = TitleRegion;
            data.ConsoleRegion = ConsoleRegion;
            data.MediaID = MediaID;
            data.LanguageID = LanguageID;
            data.AutoDiscoverServices = AutoDiscoverServices;
            data.UserIDs = new ulong[4];
            for (int i = 0; i < (UserIDs.Length <= 4 ? UserIDs.Length : 4); ++i)
            {
                data.UserIDs[i] = UserIDs[i];
            }
            ushort numByteServices = 0;
            ushort numDwordServices = 0;
            data.ByteServiceBits = new byte[16];
            data.DwordServiceIDs = new uint[4];
            foreach (uint service in Services)
            {
                if (service < 256 && numByteServices < 128) //put in a byte slot if it's a byte and there's room
                {
                    data.SetByteServiceBit((int)service, true);
                    ++numByteServices;
                }
                else if (numDwordServices < 4) //put in a dword slot
                {
                    data.DwordServiceIDs[numDwordServices] = service;
                    ++numDwordServices;
                }
                else
                {
                    throw new System.Exception("PreauthXenonServiceRequest3 cannot hold all " + Services.Length + " of the services requested.  Cannot find a slot for service " + service);
                }
            }

            data.ReservedForUserPinsLater=new uint[4];
            if (UserPINs!=null)
            {
                for (int i=0; i<4 && i<UserPINs.Length; ++i)
                {
                    data.ReservedForUserPinsLater[i]=UserPINs[i];
                }
            }

            data.FlowToken=FlowToken;
        }

        /// <summary> Sets defaults for a new xkdc request. </summary>
        public override void SetDefaults(AskdcGenericReplyOutput askdcOutput)
        {
            ConsoleId=askdcOutput.ConsoleOrUserName;
            Key=askdcOutput.SessionKey;
            SetDefaults(ConsoleId, Key, askdcOutput.Ticket);

            UserIDs=askdcOutput.UserIds;
            if (UserIDs==null)
            {
                UserIDs=new ulong[0];
            }
        }

        /// <summary> Sets defaults for a request. ConsoleId should be of the form: XE.012345678901.  If the key is not specifcied, it is calculated based on the consoleId. </summary>
        public void SetDefaults(string consoleId, byte []key, Kerberos.Ticket tgtTicket)
        {
            ConsoleId=consoleId;
            Key=key;
            Ticket=tgtTicket;

            //generate a key from the console id, in a way that can be easily reproduced by other code later
            if (Key==null)
            {
                Key=AuthContext.CalculateKeyFromGamertag(ConsoleId, true);
            }

            SetDefaultBasics();

            //sr2
            ClientMajorVersion=15;
            ClientMinorVersion=15;
            ClientBuildVersion=65535;
            ClientQFEVersion=255;
            FlashVersion=0xffffffff;
            TitleID=0xfffe07d1;
            TitleVersion=0;
            TitleRegion=0;
            ConsoleRegion=0;
            MediaID=0;
            LanguageID=1;
            AutoDiscoverServices=1;
            UserIDs=new ulong[0];
            UserPINs=new uint[0];

            SetServices(null);
        }

        /// <summary> Gets the service request version that will be used based on the current state. </summary>
        public override ushort GetServiceRequestVersion()
        {
            uint preauthVersionThatWillBeUsed=5; //default to 5 for xbox360
            if (XenonPreauthVersion!=null)
            {
                preauthVersionThatWillBeUsed=(uint)XenonPreauthVersion;
            }

            if (ServiceRequestVersion!=null)
            {
                preauthVersionThatWillBeUsed=(ushort)ServiceRequestVersion;
            }

            return (ushort)preauthVersionThatWillBeUsed;
        }
    };

    public class XkdcXbox360Request: XkdcGenericRequest
    {
        public XkdcXbox360Request()
        {
            base.Input = new XkdcXbox360RequestInput();
        }

        /// <summary>
        /// Exposes the request input as the correct type of the current platform.
        /// </summary>
        public new XkdcXbox360RequestInput Input { get { return (XkdcXbox360RequestInput)base.Input; } }

        /// <summary> Sets all the appropriate fields in a KerberosRequest based on Input. </summary>
        public override void SetRequest()
        {
            //put preauths into the request
            Preauths=Input.Preauths;

            //fill in the request body
            Version=new Raw.Integer();
            Version.Int64=5;

            MessageType=new Raw.Integer();
            MessageType.Int64=12;

            Options=new Kerberos.KerberosFlags();
            Options.Canonicalize=true;

            Realm=new Raw.GeneralString();
            Realm.String=Input.Realm;

            ServerName=new Kerberos.PrincipalName();
            ServerName.Type.Int64=2;
            ServerName.Names=new Compound.TagLengthValue<Raw.GeneralString>[Input.ServerNames.Length];
            for (int i=0; i<Input.ServerNames.Length; ++i)
            {
                ServerName.Names[i]=new Compound.TagLengthValue<Raw.GeneralString>();
                ServerName.Names[i].Value.String=Input.ServerNames[i];
            }

            UntilTime=new Kerberos.Time();
            UntilTime.DateTime=new System.DateTime(2037, 09, 13, 02, 48, 05); //the day the world ends?  I hope not.

            NOnce=new Raw.Integer();
            NOnce.Int64=unchecked((int)Input.NOnce); //we deviate from the standard here, as our nonce uses the range of a signed 32 bit int rather than unsigned

            EncryptionTypes=new Raw.Integer[1];
            EncryptionTypes[0]=new Raw.Integer();
            EncryptionTypes[0].Int64=0x17;
        }
    };

    public class XkdcXbox360Reply: XkdcGenericReply
    {
        //Preauths potentially present in a valid xbox360 xkdc response
        public Kerberos.Preauth<Kerberos.PreauthXenonServiceAddress2> PreauthXenonServiceAddress2;
        public Kerberos.Preauth<Kerberos.PreauthXenonServiceAddress3> PreauthXenonServiceAddress3;
        public Kerberos.Preauth<Kerberos.PreauthXenonServiceAddressFailure> PreauthXenonServiceAddressFailure;

        /// <summary> Decrypts the body, tickets, and preauths.  If a key is not supplied, that step is skipped.  This also populates some of the generic Output member.  Returns true only if everything possible was fully decrypted. </summary>
        public override bool Decrypt(byte []sessionKey, byte []ticketKey, uint nonce)
        {
            bool failures=!base.Decrypt(sessionKey, ticketKey, nonce);

            if (PreauthXenonServiceAddress2!=null && sessionKey!=null)
            {
                try
                {
                    PreauthXenonServiceAddress2.Data.Decrypt(sessionKey, nonce);
                }
                catch (System.Exception e)
                {
                    Global.RO.Warn("Failed to decrypt PreauthXenonServiceAddress2 of a "+GetType().ToString()+": "+e.Message);
                    failures=true;
                }

                if (PreauthXenonServiceAddress2.Data.IsValid())
                {
                    PreauthXenonServiceAddress2.Data.SetIntoGenericXkdcOutput(Output);
                }
            }

            if (PreauthXenonServiceAddress3!=null && sessionKey!=null)
            {
                try
                {
                    PreauthXenonServiceAddress3.Data.Decrypt(sessionKey, nonce);
                }
                catch (System.Exception e)
                {
                    Global.RO.Warn("Failed to decrypt PreauthXenonServiceAddress3 of a "+GetType().ToString()+": "+e.Message);
                    failures=true;
                }

                if (PreauthXenonServiceAddress3.Data.IsValid())
                {
                    PreauthXenonServiceAddress3.Data.SetIntoGenericXkdcOutput(Output);
                }
            }

            if (PreauthXenonServiceAddressFailure!=null && sessionKey!=null)
            {
                try
                {
                    PreauthXenonServiceAddressFailure.Data.Key=sessionKey;
                    PreauthXenonServiceAddressFailure.Data.KeyNonce=nonce;
                    PreauthXenonServiceAddressFailure.Data.Decrypt();
                }
                catch (System.Exception e)
                {
                    Global.RO.Warn("Failed to decrypt PreauthXenonServiceAddressFailure of a "+GetType().ToString()+": "+e.Message);
                    failures=true;
                }

                if (PreauthXenonServiceAddressFailure.Data.IsValid())
                {
                    PreauthXenonServiceAddressFailure.Data.SetIntoGenericXkdcOutput(Output);
                }
            }

            //if we could not decrypt the service address just clear the output to prevent anyone from trying to use default data in the struct
            if (!((PreauthXenonServiceAddress2!=null && PreauthXenonServiceAddress2.Data.IsValid()) || (PreauthXenonServiceAddress3!=null && PreauthXenonServiceAddress3.Data.IsValid()) || (PreauthXenonServiceAddressFailure!=null && PreauthXenonServiceAddressFailure.Data.IsValid())))
            {
                Output=null;
            }

            return !failures;
        }

        //called after a reply has been build from asn
        protected override void AfterCreatefromAsn()
        {
            base.AfterCreatefromAsn();

            //find our preauths to store locally for more convenient access
            if (Preauths!=null)
            {
                foreach (Kerberos.Preauth pa in Preauths)
                {
                    if (pa is Kerberos.Preauth<Kerberos.PreauthXenonServiceAddress3>)
                    {
                        PreauthXenonServiceAddress3=(Kerberos.Preauth<Kerberos.PreauthXenonServiceAddress3>)pa;
                    }
                    else if (pa is Kerberos.Preauth<Kerberos.PreauthXenonServiceAddress2>)
                    {
                        PreauthXenonServiceAddress2=(Kerberos.Preauth<Kerberos.PreauthXenonServiceAddress2>)pa;
                    }
                    else if (pa is Kerberos.Preauth<Kerberos.PreauthXenonServiceAddressFailure>)
                    {
                        ReplyWasServiceAddressFailure=true;
                        PreauthXenonServiceAddressFailure=(Kerberos.Preauth<Kerberos.PreauthXenonServiceAddressFailure>)pa;
                    }
                }
            }
        }

        /// <summary> Verifies that various basic fields common to all xbox360 xkdc replies are correct. </summary>
        public override void VerifyBasics()
        {
            base.VerifyBasics();

            int addressPreauthCount=0;
            if (PreauthXenonServiceAddress3!=null)
            {
                ++addressPreauthCount;
            }
            if (PreauthXenonServiceAddress2!=null)
            {
                ++addressPreauthCount;
            }
            if (PreauthXenonServiceAddressFailure!=null)
            {
                ++addressPreauthCount;
            }

            if (addressPreauthCount>1)
            {
                throw new UnexpectedTestResultException(addressPreauthCount+" Address-Type preauths were found in the response.  Only 1 is expected.");
            }
        }
    };
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\Auth\KDC\XkdcPC.cs ===
using ServerTestFramework.LiveService.Auth.Asn;

namespace ServerTestFramework.LiveService.Auth
{
    /// <summary> These fields are used when SetRequest is called, to populate the relevent portions of the KerberosRequest.  This is a subset of everything in the request, but should contain all the most common stuff we want to trivially play with. </summary>
    public class XkdcPCRequestInput: XkdcGenericRequestInput
    {
        //Ticket                  tgt ticket from the askdc
        //ConsoleId               Console ID of the machine, in the form of PC.123456789012
        //Key                     16 byte key chosen by the service, returned in the encrypted body of an Askdc reply
        //Realm                   Normally XBOX.COM
        //ServerNames             Normally sg and S#, where # is the site number
        //RequestTime             Time that the request was made
        //NOnce                   Value unique to this particular request

        //ClientMajorVersion
        //ClientMinorVersion
        //ClientBuildVersion
        //ClientQFEVersion
        //FlashVersion            format is 0xMmbbbbqq, where M=major m=minor bbbb=build qq=qfe
        //TitleID
        //TitleVersion
        //TitleRegion
        //ConsoleRegion
        //MediaID
        //LanguageID
        //AutoDiscoverServices    normally either 0 or 1
        //UserIDs                 up to 4 users
        //Services                there is room for 128 byte services and 4 dword services right now
        //UserPINs
        //FlowToken
        //XenonPreauthVersion     overrides which xenon service request preauth to use (may be either 4 or 5)
        //ServiceRequestVersion   if not null, overrides the default service request version placed into the service request preauth

        /// <summary> Retrieves a list of preauths that will be generated by default.  Note that this may vary based on the current input parameters. </summary>
        public override System.Collections.Generic.LinkedList<int> GetDefaultPreauthsToGenerate()
        {
            System.Collections.Generic.LinkedList<int> defaultPreauths=new System.Collections.Generic.LinkedList<int>();

            uint xenonSRPreauthToUse=4; //default to 4 for PC until their client is updated to use 5
            if (XenonPreauthVersion!=null)
            {
                if (XenonPreauthVersion==4)
                {
                    xenonSRPreauthToUse=4;
                }
                else if (XenonPreauthVersion==5)
                {
                    xenonSRPreauthToUse=5;
                }
                else
                {
                    Global.RO.Warn("Invalid xkdc xenon service request preauth version override specified: "+XenonPreauthVersion);
                }
            }

            if (xenonSRPreauthToUse==4)
            {
                defaultPreauths.AddLast(210); //PADATA_XENON_SERVICE_REQUEST2
            }
            else //5
            {
                defaultPreauths.AddLast(214); //PADATA_XENON_SERVICE_REQUEST3
            }

            defaultPreauths.AddLast(206); //PADATA_XBOX_CLIENT_VERSION
            defaultPreauths.AddLast(1); //PADATA_TGS_REQ

            return defaultPreauths;
        }

        /// <summary> Creates all the preauths required for the request, based on the other input fields. </summary>
        public override void GeneratePreauths()
        {
            ClearPreauths();

            System.Collections.Generic.IEnumerable<int> preauthsToAdd=PreauthsToGenerate;
            if (preauthsToAdd==null)
            {
                preauthsToAdd=GetDefaultPreauthsToGenerate();
            }

            System.Collections.Generic.List<Kerberos.Preauth> preauths=new System.Collections.Generic.List<Kerberos.Preauth>();
            foreach (int paNumber in preauthsToAdd)
            {
                if (paNumber==210) //PADATA_XENON_SERVICE_REQUEST2
                {
                    Kerberos.Preauth<Kerberos.PreauthXenonServiceRequest2> pa=new Kerberos.Preauth<Kerberos.PreauthXenonServiceRequest2>();
                    PopulateServiceRequest(pa.Data);
                    pa.Data.EncryptionKey=Key;
                    pa.Data.EncryptionNOnce=NOnce;
                    pa.Data.Encrypt();
                    preauths.Add(pa);
                }
                else if (paNumber==214) //PADATA_XENON_SERVICE_REQUEST3
                {
                    Kerberos.Preauth<Kerberos.PreauthXenonServiceRequest3> pa=new Kerberos.Preauth<Kerberos.PreauthXenonServiceRequest3>();
                    PopulateServiceRequest(pa.Data);
                    pa.Data.EncryptionKey=Key;
                    pa.Data.EncryptionNOnce=NOnce;
                    pa.Data.Encrypt();
                    preauths.Add(pa);
                }
                else
                {
                    Kerberos.Preauth pa=PreauthHelpers.GenerateDefaultPreauth(paNumber, Key, RequestTime, ConsoleId, Ticket, NOnce, 0x585207d1, 0x12345678, 0x9abcdef0, 0, null, null, null, false, null);
                    preauths.Add(pa);
                }
            }

            Preauths=preauths.ToArray();
        }

        public void PopulateServiceRequest(Kerberos.PreauthXenonServiceRequest2 data)
        {
            data.RequestVersion = ServiceRequestVersion ?? 4;
            data.RequestSize = 124;
            data.ClientVersionMajor = ClientMajorVersion;
            data.ClientVersionMinor = ClientMinorVersion;
            data.ClientVersionBuild = ClientBuildVersion;
            data.ClientVersionQFE = ClientQFEVersion;
            data.FlashVersion = FlashVersion;
            data.TitleID = TitleID;
            data.TitleVersion = TitleVersion;
            data.TitleRegion = TitleRegion;
            data.ConsoleRegion = ConsoleRegion;
            data.MediaID = MediaID;
            data.LanguageID = LanguageID;
            data.AutoDiscoverServices = AutoDiscoverServices;
            data.UserIDs = new ulong[4];
            for (int i = 0; i < (UserIDs.Length <= 4 ? UserIDs.Length : 4); ++i)
            {
                data.UserIDs[i] = UserIDs[i];
            }
            ushort numByteServices = 0;
            ushort numDwordServices = 0;
            data.ByteServiceIDs = new byte[32];
            data.DwordServiceIDs = new uint[4];
            foreach (uint service in Services)
            {
                if (service < 256 && numByteServices < 32) //put in a byte slot if it's a byte and there's room
                {
                    data.ByteServiceIDs[numByteServices] = (byte)service;
                    ++numByteServices;
                }
                else if (numDwordServices < 4) //put in a dword slot
                {
                    data.DwordServiceIDs[numDwordServices] = service;
                    ++numDwordServices;
                }
                else
                {
                    throw new System.Exception("PreauthXenonServiceRequest2 cannot hold all " + Services.Length + " of the services requested.  Cannot find a slot for service " + service);
                }
            }
            data.NumByteServices = numByteServices;
            data.NumDwordServices = numDwordServices;
        }

        public void PopulateServiceRequest(Kerberos.PreauthXenonServiceRequest3 data)
        {
            data.RequestVersion = ServiceRequestVersion ?? 5;
            data.ClientVersionMajor = ClientMajorVersion;
            data.ClientVersionMinor = ClientMinorVersion;
            data.ClientVersionBuild = ClientBuildVersion;
            data.ClientVersionQFE = ClientQFEVersion;
            data.FlashVersion = FlashVersion;
            data.TitleID = TitleID;
            data.TitleVersion = TitleVersion;
            data.TitleRegion = TitleRegion;
            data.ConsoleRegion = ConsoleRegion;
            data.MediaID = MediaID;
            data.LanguageID = LanguageID;
            data.AutoDiscoverServices = AutoDiscoverServices;
            data.UserIDs = new ulong[4];
            for (int i = 0; i < (UserIDs.Length <= 4 ? UserIDs.Length : 4); ++i)
            {
                data.UserIDs[i] = UserIDs[i];
            }
            ushort numByteServices = 0;
            ushort numDwordServices = 0;
            data.ByteServiceBits = new byte[16];
            data.DwordServiceIDs = new uint[4];
            foreach (uint service in Services)
            {
                if (service < 256 && numByteServices < 128) //put in a byte slot if it's a byte and there's room
                {
                    data.SetByteServiceBit((int)service, true);
                    ++numByteServices;
                }
                else if (numDwordServices < 4) //put in a dword slot
                {
                    data.DwordServiceIDs[numDwordServices] = service;
                    ++numDwordServices;
                }
                else
                {
                    throw new System.Exception("PreauthXenonServiceRequest3 cannot hold all " + Services.Length + " of the services requested.  Cannot find a slot for service " + service);
                }
            }

            data.ReservedForUserPinsLater=new uint[4];
            if (UserPINs!=null)
            {
                for (int i=0; i<4 && i<UserPINs.Length; ++i)
                {
                    data.ReservedForUserPinsLater[i]=UserPINs[i];
                }
            }

            data.FlowToken=FlowToken;
        }

        /// <summary> Sets defaults for a new xkdc request. </summary>
        public override void SetDefaults(AskdcGenericReplyOutput askdcOutput)
        {
            ConsoleId=askdcOutput.ConsoleOrUserName;
            if (ConsoleId.EndsWith("@XBOX.COM")) //strip @XBOX.COM off
            {
                ConsoleId=ConsoleId.Substring(0, ConsoleId.Length-9);
            }

            Key=askdcOutput.SessionKey;
            SetDefaults(ConsoleId, Key, askdcOutput.Ticket);

            UserIDs=askdcOutput.UserIds;
            if (UserIDs==null)
            {
                UserIDs=new ulong[0];
            }
        }

        /// <summary> Sets defaults for a request. ConsoleId should be of the form: PC.012345678901.  If the key is not specifcied, it is calculated based on the consoleId. </summary>
        public void SetDefaults(string consoleId, byte []key, Kerberos.Ticket tgtTicket)
        {
            ConsoleId=consoleId;
            Key=key;
            Ticket=tgtTicket;

            //generate a key from the console id, in a way that can be easily reproduced by other code later
            if (Key==null)
            {
                Key=AuthContext.CalculateKeyFromGamertag(ConsoleId, true);
            }

            SetDefaultBasics();

            //sr2
            ClientMajorVersion=15;
            ClientMinorVersion=15;
            ClientBuildVersion=65535;
            ClientQFEVersion=255;
            FlashVersion=0xffffffff;
            TitleID=0x585207d1;
            TitleVersion=0;
            TitleRegion=0;
            ConsoleRegion=0;
            MediaID=0;
            LanguageID=1;
            AutoDiscoverServices=1;
            UserIDs=new ulong[0];

            SetServices(null);
        }

        /// <summary> Gets the service request version that will be used based on the current state. </summary>
        public override ushort GetServiceRequestVersion()
        {
            uint preauthVersionThatWillBeUsed=4; //default to 4 for PC until their client is updated to use 5
            if (XenonPreauthVersion!=null)
            {
                preauthVersionThatWillBeUsed=(uint)XenonPreauthVersion;
            }

            if (ServiceRequestVersion!=null)
            {
                preauthVersionThatWillBeUsed=(ushort)ServiceRequestVersion;
            }

            return (ushort)preauthVersionThatWillBeUsed;
        }
    };

    public class XkdcPCRequest: XkdcGenericRequest
    {
        public XkdcPCRequest()
        {
            ((KerberosRequestWithInput)this).Input=new XkdcPCRequestInput();
        }

        /// <summary> Casts the base Input as input for the current platform. </summary>
        public new XkdcPCRequestInput Input { get { return (XkdcPCRequestInput)base.Input; } }

        /// <summary> Sets all the appropriate fields in a KerberosRequest based on Input. </summary>
        public override void SetRequest()
        {
            //put preauths into the request
            Preauths=Input.Preauths;

            //fill in the request body
            Version=new Raw.Integer();
            Version.Int64=5;

            MessageType=new Raw.Integer();
            MessageType.Int64=12;

            Options=new Kerberos.KerberosFlags();
            Options.Canonicalize=true;

            Realm=new Raw.GeneralString();
            Realm.String=Input.Realm;

            ServerName=new Kerberos.PrincipalName();
            ServerName.Type.Int64=2;
            ServerName.Names=new Compound.TagLengthValue<Raw.GeneralString>[Input.ServerNames.Length];
            for (int i=0; i<Input.ServerNames.Length; ++i)
            {
                ServerName.Names[i]=new Compound.TagLengthValue<Raw.GeneralString>();
                ServerName.Names[i].Value.String=Input.ServerNames[i];
            }

            UntilTime=new Kerberos.Time();
            UntilTime.DateTime=new System.DateTime(2037, 09, 13, 02, 48, 05); //the day the world ends?  I hope not.

            NOnce=new Raw.Integer();
            NOnce.Int64=unchecked((int)Input.NOnce); //we deviate from the standard here, as our nonce uses the range of a signed 32 bit int rather than unsigned

            EncryptionTypes=new Raw.Integer[1];
            EncryptionTypes[0]=new Raw.Integer();
            EncryptionTypes[0].Int64=0x17;
        }
    };

    public class XkdcPCReply: XkdcGenericReply
    {
        //Preauths potentially present in a valid pc xkdc response
        public Kerberos.Preauth<Kerberos.PreauthXenonServiceAddress2> PreauthXenonServiceAddress2;
        public Kerberos.Preauth<Kerberos.PreauthXenonServiceAddress3> PreauthXenonServiceAddress3;
        public Kerberos.Preauth<Kerberos.PreauthXenonServiceAddressFailure> PreauthXenonServiceAddressFailure;

        /// <summary> Decrypts the body, tickets, and preauths.  If a key is not supplied, that step is skipped.  This also populates some of the generic Output member.  Returns true only if everything possible was fully decrypted. </summary>
        public override bool Decrypt(byte []sessionKey, byte []ticketKey, uint nonce)
        {
            bool failures=!base.Decrypt(sessionKey, ticketKey, nonce);

            if (PreauthXenonServiceAddress2!=null && sessionKey!=null)
            {
                try
                {
                    PreauthXenonServiceAddress2.Data.Decrypt(sessionKey, nonce);
                }
                catch (System.Exception e)
                {
                    Global.RO.Warn("Failed to decrypt PreauthXenonServiceAddress2 of a "+GetType().ToString()+": "+e.Message);
                    failures=true;
                }

                if (PreauthXenonServiceAddress2.Data.IsValid())
                {
                    PreauthXenonServiceAddress2.Data.SetIntoGenericXkdcOutput(Output);
                }
            }

            if (PreauthXenonServiceAddress3!=null && sessionKey!=null)
            {
                try
                {
                    PreauthXenonServiceAddress3.Data.Decrypt(sessionKey, nonce);
                }
                catch (System.Exception e)
                {
                    Global.RO.Warn("Failed to decrypt PreauthXenonServiceAddress3 of a "+GetType().ToString()+": "+e.Message);
                    failures=true;
                }

                if (PreauthXenonServiceAddress3.Data.IsValid())
                {
                    PreauthXenonServiceAddress3.Data.SetIntoGenericXkdcOutput(Output);
                }
            }

            if (PreauthXenonServiceAddressFailure!=null && sessionKey!=null)
            {
                try
                {
                    PreauthXenonServiceAddressFailure.Data.Key=sessionKey;
                    PreauthXenonServiceAddressFailure.Data.KeyNonce=nonce;
                    PreauthXenonServiceAddressFailure.Data.Decrypt();
                }
                catch (System.Exception e)
                {
                    Global.RO.Warn("Failed to decrypt PreauthXenonServiceAddressFailure of a "+GetType().ToString()+": "+e.Message);
                    failures=true;
                }

                if (PreauthXenonServiceAddressFailure.Data.IsValid())
                {
                    PreauthXenonServiceAddressFailure.Data.SetIntoGenericXkdcOutput(Output);
                }
            }

            //if we could not decrypt the service address just clear the output to prevent anyone from trying to use default data in the struct
            if (!((PreauthXenonServiceAddress2!=null && PreauthXenonServiceAddress2.Data.IsValid()) || (PreauthXenonServiceAddress3!=null && PreauthXenonServiceAddress3.Data.IsValid()) || (PreauthXenonServiceAddressFailure!=null && PreauthXenonServiceAddressFailure.Data.IsValid())))
            {
                Output=null;
            }

            return !failures;
        }

        //called after a reply has been build from asn
        protected override void AfterCreatefromAsn()
        {
            base.AfterCreatefromAsn();

            //find our preauths to store locally for more convenient access
            if (Preauths!=null)
            {
                foreach (Kerberos.Preauth pa in Preauths)
                {
                    if (pa is Kerberos.Preauth<Kerberos.PreauthXenonServiceAddress3>)
                    {
                        PreauthXenonServiceAddress3=(Kerberos.Preauth<Kerberos.PreauthXenonServiceAddress3>)pa;
                    }
                    else if (pa is Kerberos.Preauth<Kerberos.PreauthXenonServiceAddress2>)
                    {
                        PreauthXenonServiceAddress2=(Kerberos.Preauth<Kerberos.PreauthXenonServiceAddress2>)pa;
                    }
                    else if (pa is Kerberos.Preauth<Kerberos.PreauthXenonServiceAddressFailure>)
                    {
                        ReplyWasServiceAddressFailure=true;
                        PreauthXenonServiceAddressFailure=(Kerberos.Preauth<Kerberos.PreauthXenonServiceAddressFailure>)pa;
                    }
                }
            }
        }

        /// <summary> Verifies that various basic fields common to all pc xkdc replies are correct. </summary>
        public override void VerifyBasics()
        {
            base.VerifyBasics();

            int addressPreauthCount=0;
            if (PreauthXenonServiceAddress3!=null)
            {
                ++addressPreauthCount;
            }
            if (PreauthXenonServiceAddress2!=null)
            {
                ++addressPreauthCount;
            }
            if (PreauthXenonServiceAddressFailure!=null)
            {
                ++addressPreauthCount;
            }

            if (addressPreauthCount>1)
            {
                throw new UnexpectedTestResultException(addressPreauthCount+" Address-Type preauths were found in the response.  Only 1 is expected.");
            }
        }
    };
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\Auth\KDC\XkdcGeneric.cs ===
using ServerTestFramework.LiveService.Auth.Asn;

namespace ServerTestFramework.LiveService.Auth
{
    /// <summary> These fields are used when SetRequest is called, to populate the relevent portions of the KerberosRequest.  This is a subset of everything in the request, but should contain all the most common stuff we want to trivially play with. </summary>
    public abstract class XkdcGenericRequestInput: RequestInputCommon
    {
        //See platform-specific file for details.        Used by:
        public Kerberos.Ticket Ticket;                // All
        public string          ConsoleId;             // All
        public byte          []Key;                   // All
        public string          Realm;                 // All
        public string        []ServerNames;           // All
        public System.DateTime RequestTime;           // All
        public uint            NOnce;                 // All

        public ushort          ClientMajorVersion;    // All
        public ushort          ClientMinorVersion;    // All
        public ushort          ClientBuildVersion;    // All
        public ushort          ClientQFEVersion;      // All
        public uint            FlashVersion;          // Xbox360, PC
        public uint            TitleID;               // All
        public uint            TitleVersion;          // All
        public uint            TitleRegion;           // All
        public uint            ConsoleRegion;         // Xbox360, PC
        public uint            MediaID;               // Xbox360, PC
        public ushort          LanguageID;            // Xbox360, PC
        public ushort          AutoDiscoverServices;  // Xbox360, PC
        public ulong         []UserIDs;               // All
        public uint          []Services;              // All
        public uint          []UserPINs;              // Xbox360, PC
        public ulong           FlowToken;             // Xbox360, PC
        public uint?           XenonPreauthVersion;   // Xbox360, PC
        public ushort?         ServiceRequestVersion; // Xbox360, PC

        /// <summary> Sets Services and updates ServerNames accordingly.  If serviceList is null, it will be an autodiscover request. </summary>
        public virtual void SetServices(uint []serviceList)
        {
            Services=serviceList;
            ServerNames=new string[2]{"sg","S0"};
            if (Services==null)
            {
                Services=new uint[0];
                AutoDiscoverServices=1;
            }
            else if (Services.Length>0)
            {
                AutoDiscoverServices=0;
                ServerNames=new string[2]{"sg","S"+Services[0]};
            }
        }

        /// <summary> Sets defaults for a new xkdc request. </summary>
        public abstract void SetDefaults(AskdcGenericReplyOutput askdcOutput);

        //set stuff common to the different types of xkdc requests
        protected void SetDefaultBasics()
        {
            Realm="XBOX.COM";
            RequestTime=System.DateTime.UtcNow;
            SetRandomNOnce();
        }

        /// <summary> Sets the request time. </summary>
        public override void SetRequestTime(System.DateTime newTime)
        {
            RequestTime=newTime;
        }

        /// <summary> Gets the current requset time. </summary>
        public override System.DateTime GetRequestTime()
        {
            return RequestTime;
        }

        /// <summary> Sets a new random nonce. </summary>
        public override void SetRandomNOnce()
        {
            NOnce=unchecked((uint)ServerTestFramework.Core.Utilities.RandomEx.GlobalRandGen.NextUlong());
        }

        /// <summary> Gets the current nonce. </summary>
        public override uint GetNOnce()
        {
            return NOnce;
        }

        /// <summary>
        /// Copy all of the properties from this input object onto another.
        /// </summary>
        /// <param name="input">The input object to copy </param>
        public void CopyTo(XkdcGenericRequestInput input)
        {
            input.Ticket = Ticket;
            input.ConsoleId = ConsoleId;
            input.Key = Key;
            input.Realm = Realm;
            input.ServerNames = ServerNames;
            input.RequestTime = RequestTime;
            input.NOnce = NOnce;

            input.ClientMajorVersion = ClientMajorVersion;
            input.ClientMinorVersion = ClientMinorVersion;
            input.ClientBuildVersion = ClientBuildVersion;
            input.ClientQFEVersion = ClientQFEVersion;
            input.FlashVersion = FlashVersion;
            input.TitleID = TitleID;
            input.TitleVersion = TitleVersion;
            input.TitleRegion = TitleRegion;
            input.ConsoleRegion = ConsoleRegion;
            input.MediaID = MediaID;
            input.LanguageID = LanguageID;
            input.AutoDiscoverServices = AutoDiscoverServices;
            input.UserIDs = UserIDs;
            input.Services = Services;
            input.UserPINs = UserPINs;
            input.FlowToken = FlowToken;
            input.XenonPreauthVersion = XenonPreauthVersion;
        }

        /// <summary> Gets the service request version that will be used based on the current state. </summary>
        public abstract ushort GetServiceRequestVersion();
    }

    public abstract class XkdcGenericRequest : KerberosRequestWithInput
    {
        /// <summary>
        /// Data used to populate the base KerberosRequest.
        /// </summary>
        public new XkdcGenericRequestInput Input
        {
            get { return (XkdcGenericRequestInput)base.Input; }
            set { base.Input = value; }
        }

        /// <summary> Creates an xmacs request object for a specific platform. </summary>
        public static XkdcGenericRequest CreateForClientType(AuthContext.ClientTypes clientType)
        {
            if (clientType==AuthContext.ClientTypes.Xenon) //xbox360
            {
                return new XkdcXbox360Request();
            }
            else if (clientType==AuthContext.ClientTypes.Panorama) //PC
            {
                return new XkdcPCRequest();
            }
            else if (clientType==AuthContext.ClientTypes.Xbox || clientType==AuthContext.ClientTypes.XenonBackCompat) //xbox1
            {
                return new XkdcXbox1Request();
            }
            else
            {
                throw new System.Exception("Unknown client type: "+clientType);
            }
        }
    }

    /// <summary> Summarized and reformatted subset of the output from xkdc.  This contains everything needed to sign into the sg. </summary>
    public class XkdcGenericReplyOutput
    {
        public Kerberos.Ticket Ticket;               //Ticket that can be presented to the SG
        public byte          []SessionKey;           //Session key to talk to the SG
        public uint            Hr=0xffffffff;        //overall hresult for the request - initialize to an invalid value to prevent misinterpretation if it never gets set
        public uint          []HrUser;               //array of 4 hresults, one for each user
        public uint          []UserFlags;            //array of 4 dword flags, one for each user
        public string        []ServiceName;          //name of the service.  this is normally similar to "sg" and "site1"
        public string          SiteIP;               //IP address of the site
        public uint          []UserPrivileges;       //4 (1 for each user) blobs of 96 bits, of privileges (stored as 3 dwords each)
        public uint            MachinePrivileges;    //privileges for the machine
        public ServiceResult []ServiceResults;       //list of services returned and their status
        public ulong           FlowToken;            //Identifies a session for 1 or more users
        public ulong           ConsoleBanExpireTime; //windows filetime that a console ban expires
        public ulong         []UserBanExpireTime;    //array of 4 windows filetimes that a user ban expires

        public XboxAuthDataBase XboxAuthData;        //only available if we were able to decrypt the portion of the ticket encrypted with the secret service key

        //generic service result capable of storing all types of services
        public struct ServiceResult
        {
            public uint   Service;
            public uint   Hr;
            public ushort Port;

            public ServiceResult(uint service, uint hr, ushort port)
            {
                Service=service;
                Hr=hr;
                Port=port;
            }
        }

        //convenient way to get a specific privilege bit for a user from the dword arrays
        public bool GetUserPrivilegeBit(int user, int bit)
        {
            if (bit<160)
            {
                throw new System.Exception("User priveleges do not exist below 160.");
            }

            int dword=(bit/32)-5;
            int subbit=bit%32;
            return (UserPrivileges[user*3+dword]&(1<<subbit))!=0;
        }

        //convenient way to get a specific machine privilege
        public bool GetMachinePrivilegeBit(int bit)
        {
            if (bit<128 || bit>=160)
            {
                throw new System.Exception("Machine priveleges only exist in the range 128-160.");
            }

            int subbit=bit%32;
            return (MachinePrivileges&(1<<subbit))!=0;
        }

        //convenient way to get the ban expiration dates as a .net datetime
        public System.DateTime GetConvertedConsoleBanExpireTime()
        {
            return System.DateTime.FromFileTimeUtc(unchecked((long)ConsoleBanExpireTime));
        }

        public System.DateTime GetConvertedUserBanExpireTime(int userIndex)
        {
            return System.DateTime.FromFileTimeUtc(unchecked((long)UserBanExpireTime[userIndex]));
        }
    }

    public class XkdcGenericReply: KerberosReply
    {
        //common output from xkdc
        public XkdcGenericReplyOutput Output;
        public bool ReplyWasServiceAddressFailure=false;

        /// <summary> Decrypts the body, tickets, and preauths.  If a key is not supplied, that step is skipped.  This also populates some of the generic Output member.  Returns true only if everything possible was fully decrypted. </summary>
        public virtual bool Decrypt(byte []sessionKey, byte []ticketKey, uint nonce)
        {
            bool failures=false;

            if (sessionKey!=null)
            {
                try
                {
                    DecryptBody(sessionKey);
                }
                catch (System.Exception e)
                {
                    Global.RO.Warn("Failed to decrypt body of a "+GetType().ToString()+" with session key: "+e.Message);
                    failures=true;
                }

                if (Body!=null)
                {
                    //we only have output if we successfully decrypted the response
                    Output=new XkdcGenericReplyOutput();
                    Output.Ticket=Ticket;
                    Output.SessionKey=Body.Key.Key.Bytes;
                    Output.ServiceName=new string[Body.ServerName.Names.Length];
                    for (int i=0; i<Body.ServerName.Names.Length; ++i)
                    {
                        Output.ServiceName[i]=Body.ServerName.Names[i].Value.ToString();
                    }
                }
            }

            if (Ticket!=null && ticketKey!=null)
            {
                bool decryptedTicket=false;
                try
                {
                    Ticket.EncryptedBody.EncryptionKey=ticketKey;
                    Ticket.EncryptedBody.Decrypt(); //The XKDC will encrypt the ticket with a random key if the request failed according to the preauth in the response
                    decryptedTicket=true;
                }
                catch (System.Exception e)
                {
                    Global.RO.Warn("Failed to decrypt ticket of a "+GetType().ToString()+" with ticket key: "+e.Message);
                    failures=true;
                }

                if (decryptedTicket && Ticket.EncryptedBody.AuthorizationData!=null)
                {
                    for (int i=0; i<Ticket.EncryptedBody.AuthorizationData.List.Values.Length; ++i)
                    {
                        //translate into typed authdata if we can
                        Kerberos.CommonTypeDataSequence authData=AuthDataBuilder.CreateFrom((Kerberos.CommonTypeDataSequence)Ticket.EncryptedBody.AuthorizationData.List.Values[i]);
                        Ticket.EncryptedBody.AuthorizationData.List.Values[i]=authData;

                        //store xbox authdata is a convenient location
                        if (Output!=null && authData is XboxAuthDataBase)
                        {
                            Output.XboxAuthData=(XboxAuthDataBase)authData;
                        }
                    }
                }
            }

            return !failures;
        }

        /// <summary> Verifies that various basic fields common to all xkdc replies are correct. </summary>
        public virtual void VerifyBasics()
        {
            ServerTestFramework.Utilities.ValueCheck.Test("XkdcReply Version", 5, Version.Int64);
            ServerTestFramework.Utilities.ValueCheck.Test("XkdcReply MessageType", 13, MessageType.Int64);
            ServerTestFramework.Utilities.ValueCheck.Test("XkdcReply ClientRealm", "PASSPORT.NET", ClientRealm.String);

            if (Body!=null)
            {
                ServerTestFramework.Utilities.ValueCheck.Test("XkdcReply EncryptedBody ServerRealm", "XBOX.COM", Body.ServerRealm.String);
                ServerTestFramework.Utilities.ValueCheck.Test("XkdcReply EncryptedBody ServerName Count", 2, Body.ServerName.Names.Length);
                ServerTestFramework.Utilities.ValueCheck.Test("XkdcReply EncryptedBody ServerName[0]", "sg", Body.ServerName.Names[0].Value.String);
            }
        }

        /// <summary> Calls the base CreateFromAsn for a specific platform.
        public static XkdcGenericReply CreateFromAsnForClientType(AsnValueBase asn, AuthContext.ClientTypes clientType)
        {
            if (clientType==AuthContext.ClientTypes.Xenon) //xbox360
            {
                return XkdcXbox360Reply.CreateFromAsn<XkdcXbox360Reply>(asn);
            }
            else if (clientType==AuthContext.ClientTypes.Panorama) //PC
            {
                return XkdcPCReply.CreateFromAsn<XkdcPCReply>(asn);
            }
            else if (clientType==AuthContext.ClientTypes.Xbox || clientType==AuthContext.ClientTypes.XenonBackCompat) //xbox1
            {
                return XkdcXbox1Reply.CreateFromAsn<XkdcXbox1Reply>(asn);
            }
            else
            {
                throw new System.Exception("Unknown client type: "+clientType);
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\Auth\KDC\XmacsGeneric.cs ===
using ServerTestFramework.LiveService.Auth.Asn;

namespace ServerTestFramework.LiveService.Auth
{
    /// <summary> These fields are used when SetRequest is called, to populate the relevent portions of the base KerberosRequest.  This contains fields for all platforms, though not all platforms use all fields. </summary>
    public abstract class XmacsGenericRequestInput: RequestInputCommon
    {
        //See platform-specific file for details.        Used by:
        public string                ConsoleId;           // All
        public byte                []Key;                 // All
        public string                Realm;               // All
        public string              []ServerNames;         // All
        public System.DateTime       RequestTime;         // All
        public uint                  NOnce;               // All
        public uint                  ConsoleType;         // Xbox360
        public System.Nullable<bool> UseTestKey;          // Xbox360, PC
        public ulong                 PCNOnce;             // PC
        public ulong                 PcId;                // PC
        public string                SponsorToken;        // PC
        public PassportTicket        PlainPassport;       // PC
        public PassportTicket        EncryptedPassport;   // PC
        public ConsoleCertificate    ConsoleCert;         // Xbox360
        public string                ConsoleSerialNumber; // Xbox360

        /// <summary> Sets values for a random new machine.  </summary>
        public virtual void SetDefaults()
        {
            //set realm and service
            Realm="MACS.XBOX.COM";
            ServerNames=new string[2]{"krbtgt","XBOX.COM"};

            //use current time
            RequestTime=System.DateTime.UtcNow;

            //random nonce
            SetRandomNOnce();
        }

        /// <summary> Sets defaults to reset an already-created machine. </summary>
        public abstract void SetResetDefaults(XmacsGenericRequestInput prevMachineInput);

        /// <summary> Gets the current requset time. </summary>
        public override System.DateTime GetRequestTime()
        {
            return RequestTime;
        }

        /// <summary> Sets the request time. </summary>
        public override void SetRequestTime(System.DateTime newTime)
        {
            RequestTime=newTime;
        }

        /// <summary> Sets a new random nonce. </summary>
        public override void SetRandomNOnce()
        {
            NOnce=unchecked((uint)ServerTestFramework.Core.Utilities.RandomEx.GlobalRandGen.NextUlong());
        }

        /// <summary> Gets the current nonce. </summary>
        public override uint GetNOnce()
        {
            return NOnce;
        }
    };

    /// <summary> Used to build an Generic Xmacs Request. </summary>
    public abstract class XmacsGenericRequest: KerberosRequestWithInput
    {
        /// <summary> Data used to populate the base KerberosRequest. </summary>
        public new XmacsGenericRequestInput Input { get { return (XmacsGenericRequestInput)base.Input; } }

        /// <summary> Creates an xmacs request object for a specific platform. </summary>
        public static XmacsGenericRequest CreateForClientType(AuthContext.ClientTypes clientType)
        {
            if (clientType==AuthContext.ClientTypes.Xenon || clientType==AuthContext.ClientTypes.XenonBackCompat) //xbox360
            {
                return new XmacsXbox360Request();
            }
            else if (clientType==AuthContext.ClientTypes.Panorama) //PC
            {
                return new XmacsPCRequest();
            }
            else if (clientType==AuthContext.ClientTypes.Xbox) //xbox1
            {
                return new XmacsXbox1Request();
            }
            else
            {
                throw new System.Exception("Unknown client type: "+clientType);
            }
        }
    };

    /// <summary> Output from xmacs needed for use by askdc. </summary>
    public class XmacsGenericReplyOutput
    {
        public ulong  MachineId;
        public string ConsoleId;
        public byte []MachineKey;

        public void PopulateFromDatabase(ServerTestFramework.Database.MachineEditor dbMachine)
        {
            MachineId=dbMachine.Id;
            ConsoleId=dbMachine.GetDecoratedConsoleId();
            MachineKey=dbMachine.CalculateKey();
        }
    };

    /// <summary> Used to parse an Generic Xmacs Reply. </summary>
    public class XmacsGenericReply: KerberosReply
    {
        //common output from xmacs
        public XmacsGenericReplyOutput Output;

        /// <summary> Decrypts the body, tickets, and preauths.  If a key is not supplied, that step is skipped.  This also populates the generic Output member.  Returns true only if everything possible was fully decrypted. </summary>
        public virtual bool Decrypt(byte []sessionKey, byte []ticketKey, uint nonce)
        {
            bool failures=false;

            if (sessionKey!=null)
            {
                try
                {
                    DecryptBody(sessionKey);
                }
                catch (System.Exception e)
                {
                    Global.RO.Warn("Failed to decrypt body of a "+GetType().ToString()+" with session key: "+e.Message);
                    failures=true;
                }
            }

            if (Ticket!=null && ticketKey!=null)
            {
                bool decryptedTicket=false;
                try
                {
                    Ticket.EncryptedBody.EncryptionKey=ticketKey;
                    Ticket.EncryptedBody.Decrypt();
                    decryptedTicket=true;
                }
                catch (System.Exception e)
                {
                    Global.RO.Warn("Failed to decrypt ticket of a "+GetType().ToString()+" with ticket key: "+e.Message);
                    failures=true;
                }

                if (decryptedTicket && Ticket.EncryptedBody.AuthorizationData!=null)
                {
                    for (int i=0; i<Ticket.EncryptedBody.AuthorizationData.List.Values.Length; ++i)
                    {
                        Kerberos.CommonTypeDataSequence ctds=(Kerberos.CommonTypeDataSequence)Ticket.EncryptedBody.AuthorizationData.List.Values[i];
                        if (ctds.Type.Int64==1) //this is windows server pac auth data
                        {
                            Ticket.EncryptedBody.AuthorizationData.List.Values[i]=WindowsPacAuthData.Create(ctds);
                        }
                    }
                }
            }

            return !failures;
        }

        /// <summary> Verifies that various basic fields common to all xmacs replies are correct. </summary>
        public void VerifyBasics()
        {
            ServerTestFramework.Utilities.ValueCheck.Test("XmacsReply Version", 5, Version.Int64);
            ServerTestFramework.Utilities.ValueCheck.Test("XmacsReply MessageType", 11, MessageType.Int64);
            ServerTestFramework.Utilities.ValueCheck.Test("XmacsReply ClientRealm", "MACS.XBOX.COM", ClientRealm.String);

            if (Body!=null)
            {
                ServerTestFramework.Utilities.ValueCheck.Test("XmacsReply EncryptedBody ServerRealm", "MACS.XBOX.COM", Body.ServerRealm.String);
                ServerTestFramework.Utilities.ValueCheck.Test("XmacsReply EncryptedBody ServerName Count", 2, Body.ServerName.Names.Length);
                ServerTestFramework.Utilities.ValueCheck.Test("XmacsReply EncryptedBody ServerName[0]", "krbtgt", Body.ServerName.Names[0].Value.String);
                ServerTestFramework.Utilities.ValueCheck.Test("XmacsReply EncryptedBody ServerName[1]", "XBOX.COM", Body.ServerName.Names[1].Value.String);
            }
        }

        /// <summary> Calls the base CreateFromAsn for a specific platform.
        public static XmacsGenericReply CreateFromAsnForClientType(AsnValueBase asn, AuthContext.ClientTypes clientType)
        {
            if (clientType==AuthContext.ClientTypes.Xenon || clientType==AuthContext.ClientTypes.XenonBackCompat) //xbox360
            {
                return XmacsXbox360Reply.CreateFromAsn<XmacsXbox360Reply>(asn);
            }
            else if (clientType==AuthContext.ClientTypes.Panorama) //PC
            {
                return XmacsPCReply.CreateFromAsn<XmacsPCReply>(asn);
            }
            else if (clientType==AuthContext.ClientTypes.Xbox) //xbox1
            {
                return XmacsXbox1Reply.CreateFromAsn<XmacsXbox1Reply>(asn);
            }
            else
            {
                throw new System.Exception("Unknown client type: "+clientType);
            }
        }
    };
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\Auth\KDC\XmacsXbox360.cs ===
using ServerTestFramework.LiveService.Auth.Asn;

namespace ServerTestFramework.LiveService.Auth
{
    /// <summary> These fields are used when SetRequest is called, to populate the relevent portions of the base KerberosRequest.  This is a subset of everything in the request, but should contain all the most common stuff we want to trivially play with in tests. </summary>
    public class XmacsXbox360RequestInput: XmacsGenericRequestInput
    {
        //ConsoleId     Console ID of the machine, in the form of XE.123456789012 (note that this gets sent in both the PreauthXenonMacRequest and the request body)
        //Key           16 byte key chosen by the client
        //Realm         Normally MACS.XBOX.COM
        //ServerNames   Normally krbtgt and MACS.XBOX.COM
        //RequestTime   Time that the request was made
        //NOnce         Value unique to this particular request
        //ConsoleType   Stored in the console certificate
        //UseTestKey    Whether to use the test or the real xmacs public key
        //ConsoleCert   If not null, this certificate will be used rather than generating a certificate from the other parameters
        //ConsoleSerialNumber If present, XenonMacRequest2 will be used instead of XenonMacRequest.  This will be converted to a 12 byte array.

        /// <summary> Retrieves a list of preauths that will be generated by default.  Note that this may vary based on the current input parameters. </summary>
        public override System.Collections.Generic.LinkedList<int> GetDefaultPreauthsToGenerate()
        {
            System.Collections.Generic.LinkedList<int> defaultPreauths=new System.Collections.Generic.LinkedList<int>();

            if (ConsoleSerialNumber!=null)
            {
                defaultPreauths.AddLast(219); //PADATA_XENON_MAC_REQUEST2
            }
            else
            {
                defaultPreauths.AddLast(209); //PADATA_XENON_MAC_REQUEST
            }

            defaultPreauths.AddLast(206); //PADATA_XBOX_CLIENT_VERSION
            defaultPreauths.AddLast(2); //PADATA_ENC_TIMESTAMP

            if (ConsoleSerialNumber==null) //include the old preauth for old requests by default
            {
                defaultPreauths.AddLast(131); //PADATA_PAC_REQUEST_EX
            }

            return defaultPreauths;
        }

        /// <summary> Creates all the preauths required for the request based on the other input fields. </summary>
        public override void GeneratePreauths()
        {
            ClearPreauths();

            System.Collections.Generic.IEnumerable<int> preauthsToAdd=PreauthsToGenerate;
            if (preauthsToAdd==null)
            {
                preauthsToAdd=GetDefaultPreauthsToGenerate();
            }

            System.Collections.Generic.List<Kerberos.Preauth> preauths=new System.Collections.Generic.List<Kerberos.Preauth>();
            foreach (int paNumber in preauthsToAdd)
            {
                if (paNumber==219) //PADATA_XENON_MAC_REQUEST2
                {
                    Kerberos.Preauth<Kerberos.PreauthXenonMacRequest2> pa=new Kerberos.Preauth<Kerberos.PreauthXenonMacRequest2>();
                    pa.Data.SetDefaults(ConsoleId, Key, ConsoleType, UseTestKey==null?XmacsClient.UseXmacsTestKey():(bool)UseTestKey, ConsoleSerialNumber);
                    if (ConsoleCert!=null)
                    {
                        pa.Data.Certificate=ConsoleCert;
                        pa.Data.Sign();
                    }
                    preauths.Add(pa);
                }
                else if (paNumber==209) //PADATA_XENON_MAC_REQUEST
                {
                    Kerberos.Preauth<Kerberos.PreauthXenonMacRequest> pa=new Kerberos.Preauth<Kerberos.PreauthXenonMacRequest>();
                    pa.Data.SetDefaults(ConsoleId, Key, ConsoleType, UseTestKey==null?XmacsClient.UseXmacsTestKey():(bool)UseTestKey);
                    if (ConsoleCert!=null)
                    {
                        pa.Data.Certificate=ConsoleCert;
                        pa.Data.Sign();
                    }
                    preauths.Add(pa);
                }
                else
                {
                    Kerberos.Preauth pa=PreauthHelpers.GenerateDefaultPreauth(paNumber, Key, RequestTime, ConsoleId, null, NOnce, 0xfffe07d1, 0x12345678, 0x9abcdef0, PCNOnce, PlainPassport, EncryptedPassport, ConsoleCert, true, null);
                    preauths.Add(pa);
                }
            }

            Preauths=preauths.ToArray();
        }

        /// <summary> Sets values for a random new machine. </summary>
        public override void SetDefaults()
        {
            SetDefaults(null, null);
        }

        /// <summary> Sets values for a machine.  If consoleId is null, a random valid consoleId is made up.  If key is null, a key will be calculated from consoleId.  For valid cases, consoleId should be of the form "XE.012345678901". </summary>
        public void SetDefaults(string consoleId, byte []key)
        {
            ConsoleId=consoleId;
            Key=key;

            //generate a random console id
            if (ConsoleId==null)
            {
                //the id itself
                ConsoleId="XE.";
                ulong cidValue=1+ServerTestFramework.Core.Utilities.RandomEx.GlobalRandGen.NextUlong()%0xffffffffe; //36 bits max
                string cidString=cidValue.ToString("d11");
                ConsoleId+=cidString;

                //the checksum digit
                int sum=0;
                for (int i=0; i<11; ++i)
                {
                    int digit=(int)(cidString[i]-'0');
                    sum+=digit;
                }
                ConsoleId+=(string)((char)(((byte)'0')+sum%10)).ToString();
            }

            //generate a key from the console id, in a way that can be easily reproduced by other code later
            if (Key==null)
            {
                Key=AuthContext.CalculateKeyFromGamertag(ConsoleId, true);
            }

            //retail
            ConsoleType=ConsoleCertificate.CONSOLE_TYPE_RETAIL;

            //serial number
            if (ConsoleSerialNumber==null)
            {
                ConsoleSerialNumber=Kerberos.PreauthXenonMacRequest2.GenerateRandomConsoleSerialNumber();
            }

            //set basics
            base.SetDefaults();
        }

        /// <summary> Sets defaults to reset an already-created machine. </summary>
        public override void SetResetDefaults(XmacsGenericRequestInput prevMachineInput)
        {
            SetDefaults();
            ConsoleId=prevMachineInput.ConsoleId;
            Key=prevMachineInput.Key;
            UseTestKey=prevMachineInput.UseTestKey;
        }

        /// <summary> Finds the certificate from within one of the xenon mac preauths, if any exist. </summary>
        public ConsoleCertificate FindConsoleCertificateInPreauths()
        {
            Kerberos.Preauth<Kerberos.PreauthXenonMacRequest> mac1=FindPreauth<Kerberos.Preauth<Kerberos.PreauthXenonMacRequest>>(209); //PADATA_XENON_MAC_REQUEST
            if (mac1!=null)
            {
                return mac1.Data.Certificate;
            }

            Kerberos.Preauth<Kerberos.PreauthXenonMacRequest2> mac2=FindPreauth<Kerberos.Preauth<Kerberos.PreauthXenonMacRequest2>>(219); //PADATA_XENON_MAC_REQUEST2
            if (mac2!=null)
            {
                return mac2.Data.Certificate;
            }

            return null;
        }
    };

    /// <summary> Used to build an Xbox360 Xmacs Request. </summary>
    public class XmacsXbox360Request: XmacsGenericRequest
    {
        public XmacsXbox360Request()
        {
            ((KerberosRequestWithInput)this).Input=new XmacsXbox360RequestInput();
        }

        /// <summary> Casts the base Input as input for the current platform. </summary>
        public new XmacsXbox360RequestInput Input { get { return (XmacsXbox360RequestInput)base.Input; } }

        /// <summary> Sets all the appropriate fields in a KerberosRequest based on Input. </summary>
        public override void SetRequest()
        {
            //put preauths into the request
            Preauths=Input.Preauths;

            //fill in the request body
            Version=new Raw.Integer();
            Version.Int64=5;

            MessageType=new Raw.Integer();
            MessageType.Int64=10;

            Options=new Kerberos.KerberosFlags();
            Options.Canonicalize=true;

            ClientName=new Kerberos.PrincipalName();
            ClientName.Type.Int64=10;
            ClientName.Names=new Compound.TagLengthValue<Raw.GeneralString>[1];
            ClientName.Names[0]=new Compound.TagLengthValue<Raw.GeneralString>();
            ClientName.Names[0].Value.String=Input.ConsoleId;

            Realm=new Raw.GeneralString();
            Realm.String=Input.Realm;

            ServerName=new Kerberos.PrincipalName();
            ServerName.Type.Int64=2;
            ServerName.Names=new Compound.TagLengthValue<Raw.GeneralString>[Input.ServerNames.Length];
            for (int i=0; i<Input.ServerNames.Length; ++i)
            {
                ServerName.Names[i]=new Compound.TagLengthValue<Raw.GeneralString>();
                ServerName.Names[i].Value.String=Input.ServerNames[i];
            }

            UntilTime=new Kerberos.Time();
            UntilTime.DateTime=new System.DateTime(2037, 09, 13, 02, 48, 05); //the day the world ends?  I hope not.

            NOnce=new Raw.Integer();
            NOnce.Int64=unchecked((int)Input.NOnce); //we deviate from the standard here, as our nonce uses the range of a signed 32 bit int rather than unsigned

            EncryptionTypes=new Raw.Integer[1];
            EncryptionTypes[0]=new Raw.Integer();
            EncryptionTypes[0].Int64=0x17;
        }
    };

    /// <summary> Used to parse an Xbox360 Xmacs Reply. </summary>
    public class XmacsXbox360Reply: XmacsGenericReply
    {
        //Preauths present in a valid xbox360 xmacs response
        public Kerberos.Preauth<Kerberos.PreauthXboxAccountCreation>    PreauthXboxAccountCreation;

        /// <summary> Decrypts the body, tickets, and preauths.  If a key is not supplied, that step is skipped.  This also populates the generic Output member. </summary>
        public override bool Decrypt(byte []sessionKey, byte []ticketKey, uint nonce)
        {
            bool failures=!base.Decrypt(sessionKey, ticketKey, nonce);

            if (PreauthXboxAccountCreation!=null && sessionKey!=null)
            {
                try
                {
                    PreauthXboxAccountCreation.Data.Decrypt(sessionKey, nonce);

                    Output=new XmacsGenericReplyOutput();
                    Output.MachineId=PreauthXboxAccountCreation.Data.MachineId;
                    Output.ConsoleId=PreauthXboxAccountCreation.Data.ConsoleId;
                    Output.MachineKey=PreauthXboxAccountCreation.Data.Key;
                }
                catch (System.Exception e)
                {
                    Global.RO.Warn("Failed to decrypt PreauthXboxAccountCreation of a "+GetType().ToString()+" with session key and nonce "+nonce+": "+e.Message);
                    failures=true;
                }
            }

            return !failures;
        }

        //called after a reply has been build from asn
        protected override void AfterCreatefromAsn()
        {
            //find our preauths to store locally for more convenient access
            if (Preauths!=null)
            {
                foreach (Kerberos.Preauth pa in Preauths)
                {
                    if (pa is Kerberos.Preauth<Kerberos.PreauthXboxAccountCreation>)
                    {
                        PreauthXboxAccountCreation=(Kerberos.Preauth<Kerberos.PreauthXboxAccountCreation>)pa;
                    }
                }
            }
        }
    };
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\Auth\KDC\XkdcXbox1.cs ===
using ServerTestFramework.LiveService.Auth.Asn;

namespace ServerTestFramework.LiveService.Auth
{
    /// <summary> These fields are used when SetRequest is called, to populate the relevent portions of the KerberosRequest.  This is a subset of everything in the request, but should contain all the most common stuff we want to trivially play with. </summary>
    public class XkdcXbox1RequestInput: XkdcGenericRequestInput
    {
        //Ticket                  tgt ticket from the askdc
        //ConsoleId               Console ID of the machine, in the form of SN.123456789012
        //Key                     16 byte key chosen by the service, returned in the encrypted body of an Askdc reply
        //Realm                   Normally XBOX.COM
        //ServerNames             Normally sg and S#, where # is the site number
        //RequestTime             Time that the request was made
        //NOnce                   Value unique to this particular request

        //ClientMajorVersion
        //ClientMinorVersion
        //ClientBuildVersion
        //ClientQFEVersion
        //TitleID
        //TitleVersion
        //TitleRegion
        //UserIDs                 up to 4 users
        //Services                SR1 has room for 12 services. SR2 has room for 12 byte services and 4 dword services

        /// <summary> Retrieves a list of preauths that will be generated by default.  Note that this may vary based on the current input parameters. </summary>
        public override System.Collections.Generic.LinkedList<int> GetDefaultPreauthsToGenerate()
        {
            System.Collections.Generic.LinkedList<int> defaultPreauths=new System.Collections.Generic.LinkedList<int>();

            defaultPreauths.AddLast(201); //PADATA_XBOX_SERVICE_REQUEST
            defaultPreauths.AddLast(206); //PADATA_XBOX_CLIENT_VERSION
            defaultPreauths.AddLast(1); //PADATA_TGS_REQ
            defaultPreauths.AddLast(131); //PADATA_PAC_REQUEST_EX

            return defaultPreauths;
        }

        /// <summary> Creates all the preauths required for the request, based on the other input fields. </summary>
        public override void GeneratePreauths()
        {
            ClearPreauths();

            System.Collections.Generic.IEnumerable<int> preauthsToAdd=PreauthsToGenerate;
            if (preauthsToAdd==null)
            {
                preauthsToAdd=GetDefaultPreauthsToGenerate();
            }

            System.Collections.Generic.List<Kerberos.Preauth> preauths=new System.Collections.Generic.List<Kerberos.Preauth>();
            foreach (int paNumber in preauthsToAdd)
            {
                if (paNumber==201) //PADATA_XBOX_SERVICE_REQUEST
                {
                    if (Services.Length>12)
                    {
                        Kerberos.Preauth<Kerberos.PreauthXboxServiceRequest2> pa=new Kerberos.Preauth<Kerberos.PreauthXboxServiceRequest2>();
                        pa.Data.RequestVersion=2;
                        pa.Data.RequestSize=108;
                        pa.Data.ClientVersionMajor=ClientMajorVersion;
                        pa.Data.ClientVersionMinor=ClientMinorVersion;
                        pa.Data.ClientVersionBuild=ClientBuildVersion;
                        pa.Data.ClientVersionQFE=ClientQFEVersion;
                        pa.Data.TitleID=TitleID;
                        pa.Data.TitleVersion=TitleVersion;
                        pa.Data.TitleRegion=TitleRegion;
                        pa.Data.UserIDs=new ulong[4];
                        for (int i=0; i<(UserIDs.Length<=4?UserIDs.Length:4); ++i)
                        {
                            pa.Data.UserIDs[i]=UserIDs[i];
                        }
                        pa.Data.Reserved0=new uint[5];
                        ushort numByteServices=0;
                        ushort numDwordServices=0;
                        pa.Data.ByteServiceIDs=new byte[12];
                        pa.Data.DwordServiceIDs=new uint[4];
                        foreach (uint service in Services)
                        {
                            if (service<256 && numByteServices<12) //put in a byte slot if it's a byte and there's room
                            {
                                pa.Data.ByteServiceIDs[numByteServices]=(byte)service;
                                ++numByteServices;
                            }
                            else if (numDwordServices<4) //put in a dword slot
                            {
                                pa.Data.DwordServiceIDs[numDwordServices]=service;
                                ++numDwordServices;
                            }
                            else
                            {
                                throw new System.Exception("PreauthXboxServiceRequest2 cannot hold all "+Services.Length+" of the services requested.  Cannot find a slot for service "+service);
                            }
                        }
                        pa.Data.NumServices=(uint)Services.Length;
                        pa.Data.EncryptionKey=Key;
                        pa.Data.EncryptionNOnce=NOnce;
                        pa.Data.Encrypt();
                        preauths.Add(pa);
                    }
                    else //use SR1
                    {
                        Kerberos.Preauth<Kerberos.PreauthXboxServiceRequest1> pa=new Kerberos.Preauth<Kerberos.PreauthXboxServiceRequest1>();
                        pa.Data.RequestVersion=1;
                        pa.Data.RequestSize=108;
                        pa.Data.ClientVersionMajor=ClientMajorVersion;
                        pa.Data.ClientVersionMinor=ClientMinorVersion;
                        pa.Data.ClientVersionBuild=ClientBuildVersion;
                        pa.Data.ClientVersionQFE=ClientQFEVersion;
                        pa.Data.TitleID=TitleID;
                        pa.Data.TitleVersion=TitleVersion;
                        pa.Data.TitleRegion=TitleRegion;
                        pa.Data.UserIDs=new ulong[4];
                        for (int i=0; i<(UserIDs.Length<=4?UserIDs.Length:4); ++i)
                        {
                            pa.Data.UserIDs[i]=UserIDs[i];
                        }
                        ushort numDwordServices=0;
                        pa.Data.DwordServiceIDs=new uint[12];
                        foreach (uint service in Services)
                        {
                            if (numDwordServices<12) //put in a dword slot
                            {
                                pa.Data.DwordServiceIDs[numDwordServices]=service;
                                ++numDwordServices;
                            }
                            else
                            {
                                throw new System.Exception("PreauthXboxServiceRequest1 cannot hold all "+Services.Length+" of the services requested (it can only hold 12).");
                            }
                        }
                        pa.Data.NumServices=(uint)Services.Length;
                        pa.Data.EncryptionKey=Key;
                        pa.Data.EncryptionNOnce=NOnce;
                        pa.Data.Encrypt();
                        preauths.Add(pa);
                    }
                }
                else
                {
                    Kerberos.Preauth pa=PreauthHelpers.GenerateDefaultPreauth(paNumber, Key, RequestTime, ConsoleId, Ticket, NOnce, 0xfffe0000, 0x12345678, 0x9abcdef0, 0, null, null, null, false, null);
                    preauths.Add(pa);
                }
            }

            Preauths=preauths.ToArray();
        }

        /// <summary> Sets defaults for a new xkdc request. </summary>
        public override void SetDefaults(AskdcGenericReplyOutput askdcOutput)
        {
            ConsoleId=askdcOutput.ConsoleOrUserName;
            Key=askdcOutput.SessionKey;
            SetDefaults(ConsoleId, Key, askdcOutput.Ticket);

            UserIDs=askdcOutput.UserIds;
            if (UserIDs==null)
            {
                UserIDs=new ulong[0];
            }
        }

        /// <summary> Sets defaults for a request. ConsoleId should be of the form: SN.012345678901.  If the key is not specifcied, it is calculated based on the consoleId. </summary>
        public void SetDefaults(string consoleId, byte []key, Kerberos.Ticket tgtTicket)
        {
            ConsoleId=consoleId;
            Key=key;
            Ticket=tgtTicket;

            //generate a key from the console id, in a way that can be easily reproduced by other code later
            if (Key==null)
            {
                Key=AuthContext.CalculateKeyFromGamertag(ConsoleId, true);
            }

            SetDefaultBasics();

            //sr2
            ClientMajorVersion=15;
            ClientMinorVersion=15;
            ClientBuildVersion=65535;
            ClientQFEVersion=255;
            TitleID=0xfffe0000;
            TitleVersion=0;
            TitleRegion=0;
            UserIDs=new ulong[0];

            SetServices(null);
        }

        /// <summary> Sets Services and updates ServerNames accordingly.  If serviceList is null, it will be an autodiscover request. </summary>
        public override void SetServices(uint []serviceList)
        {
            Services=serviceList;
            if (Services==null)
            {
                //xbox1 doesn't do autodiscover, so default to all the common services (except auto-update) we can based on whether there is a user in this reque
                bool anyUsers=false;
                if (UserIDs!=null)
                {
                    foreach (ulong u in UserIDs)
                    {
                        if (u!=0)
                        {
                            anyUsers=true;
                            break;
                        }
                    }
                }

                if (anyUsers) //common services
                {
                    Services=new uint[16] {1, 2, 4, 5, 6, 7, 9, 11, 12, 14, 15, 16, 17, 18, 19, 20};
                }
                else //machine-only services
                {
                    Services=new uint[9] {2, 4, 5, 7, 9, 11, 12, 18, 20};
                }
            }

            ServerNames=new string[2]{"sg","S0"};
            if (Services.Length>0)
            {
                AutoDiscoverServices=0;
                ServerNames=new string[2]{"sg","S"+Services[0]};
            }
        }

        /// <summary> Gets the service request version that will be used based on the current state. </summary>
        public override ushort GetServiceRequestVersion()
        {
            if (Services.Length>12)
            {
                return 2;
            }

            return 1;
        }
    };

    public class XkdcXbox1Request: XkdcGenericRequest
    {
        public XkdcXbox1Request()
        {
            ((KerberosRequestWithInput)this).Input=new XkdcXbox1RequestInput();
        }

        /// <summary> Casts the base Input as input for the current platform. </summary>
        public new XkdcXbox1RequestInput Input { get { return (XkdcXbox1RequestInput)base.Input; } }

        /// <summary> Sets all the appropriate fields in a KerberosRequest based on Input. </summary>
        public override void SetRequest()
        {
            //put preauths into the request
            Preauths=Input.Preauths;

            //fill in the request body
            Version=new Raw.Integer();
            Version.Int64=5;

            MessageType=new Raw.Integer();
            MessageType.Int64=12;

            Options=new Kerberos.KerberosFlags();
            Options.Canonicalize=true;

            Realm=new Raw.GeneralString();
            Realm.String=Input.Realm;

            ServerName=new Kerberos.PrincipalName();
            ServerName.Type.Int64=2;
            ServerName.Names=new Compound.TagLengthValue<Raw.GeneralString>[Input.ServerNames.Length];
            for (int i=0; i<Input.ServerNames.Length; ++i)
            {
                ServerName.Names[i]=new Compound.TagLengthValue<Raw.GeneralString>();
                ServerName.Names[i].Value.String=Input.ServerNames[i];
            }

            UntilTime=new Kerberos.Time();
            UntilTime.DateTime=new System.DateTime(2037, 09, 13, 02, 48, 05); //the day the world ends?  I hope not.

            NOnce=new Raw.Integer();
            NOnce.Int64=unchecked((int)Input.NOnce); //we deviate from the standard here, as our nonce uses the range of a signed 32 bit int rather than unsigned

            EncryptionTypes=new Raw.Integer[1];
            EncryptionTypes[0]=new Raw.Integer();
            EncryptionTypes[0].Int64=0x17;
        }
    };

    public class XkdcXbox1Reply: XkdcGenericReply
    {
        //Preauths present in a valid xbox1 xkdc response.  Only one of either PreauthXboxServiceAddress1 or PreauthXboxServiceAddress2 should be present.
        public Kerberos.Preauth<Kerberos.PreauthXboxServiceAddress1>    PreauthXboxServiceAddress1;
        public Kerberos.Preauth<Kerberos.PreauthXboxServiceAddress2>    PreauthXboxServiceAddress2;

        //used as intermediate step to hold the base sa preauth before decryption
        private Kerberos.Preauth<Kerberos.PreauthXboxServiceAddress>    paXboxServiceAddressBase;
        private int paServiceAddressIndex=-1;

        /// <summary> Decrypts the body, tickets, and preauths.  If a key is not supplied, that step is skipped.  This also populates some of the generic Output member.  Returns true only if everything possible was fully decrypted. </summary>
        public override bool Decrypt(byte []sessionKey, byte []ticketKey, uint nonce)
        {
            bool failures=!base.Decrypt(sessionKey, ticketKey, nonce);

            if (paXboxServiceAddressBase!=null && sessionKey!=null)
            {
                Kerberos.PreauthXboxServiceAddress rawBase=null;
                try
                {
                    rawBase=paXboxServiceAddressBase.Data.DecryptAndCreateSpecific(sessionKey, nonce);
                }
                catch (System.Exception e)
                {
                    Global.RO.Warn("Failed to decrypt PreauthXboxServiceAddress of a "+GetType().ToString()+": "+e.Message);
                    failures=true;
                }

                if (rawBase!=null)
                {
                    if (rawBase is Kerberos.PreauthXboxServiceAddress1) //v1
                    {
                        PreauthXboxServiceAddress1=new Kerberos.Preauth<Kerberos.PreauthXboxServiceAddress1>();
                        PreauthXboxServiceAddress1.Type=paXboxServiceAddressBase.Type;
                        PreauthXboxServiceAddress1.Data=(Kerberos.PreauthXboxServiceAddress1)rawBase;
                        if (paServiceAddressIndex!=-1)
                        {
                            Preauths[paServiceAddressIndex]=PreauthXboxServiceAddress1; //copy specific type back over the generic one
                        }

                        PreauthXboxServiceAddress1.Data.SetIntoGenericXkdcOutput(Output);
                    }
                    else //v2
                    {
                        PreauthXboxServiceAddress2=new Kerberos.Preauth<Kerberos.PreauthXboxServiceAddress2>();
                        PreauthXboxServiceAddress2.Type=paXboxServiceAddressBase.Type;
                        PreauthXboxServiceAddress2.Data=(Kerberos.PreauthXboxServiceAddress2)rawBase;
                        if (paServiceAddressIndex!=-1)
                        {
                            Preauths[paServiceAddressIndex]=PreauthXboxServiceAddress2; //copy specific type back over the generic one
                        }

                        PreauthXboxServiceAddress2.Data.SetIntoGenericXkdcOutput(Output);
                    }
                }
            }

            //if we could not decrypt the service address just clear the output to prevent anyone from trying to use default data in the struct
            if (!((PreauthXboxServiceAddress1!=null && PreauthXboxServiceAddress1.Data.IsValid()) || (PreauthXboxServiceAddress2!=null && PreauthXboxServiceAddress2.Data.IsValid())))
            {
                Output=null;
            }

            return !failures;
        }

        //called after a reply has been build from asn
        protected override void AfterCreatefromAsn()
        {
            base.AfterCreatefromAsn();

            //find our preauths to store locally for more convenient access
            if (Preauths!=null)
            {
                int ind=0;
                foreach (Kerberos.Preauth pa in Preauths)
                {
                    if (pa is Kerberos.Preauth<Kerberos.PreauthXboxServiceAddress>)
                    {
                        paXboxServiceAddressBase=(Kerberos.Preauth<Kerberos.PreauthXboxServiceAddress>)pa;
                        paServiceAddressIndex=ind;
                    }
                    ++ind;
                }
            }
        }
    };
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\Auth\KDC\XmacsPC.cs ===
using ServerTestFramework.LiveService.Auth.Asn;

namespace ServerTestFramework.LiveService.Auth
{
    /// <summary> These fields are used when SetRequest is called, to populate the relevent portions of the base KerberosRequest.  This is a subset of everything in the request, but should contain all the most common stuff we want to trivially play with in tests. </summary>
    public class XmacsPCRequestInput: XmacsGenericRequestInput
    {
        //ConsoleId         Normally PC.@XBOX.COM
        //Key               The Principal Key, computed from the passport ticket session key and the pc nonce
        //Realm             Normally MACS.XBOX.COM
        //ServerNames       Normally krbtgt and XBOX.COM
        //RequestTime       Time that the request was made
        //NOnce             Value unique to this particular request
        //PCNOnce           NOnce for the PC preauth (unrelated to the NOnce in the kerberos request)
        //PcId              Random value generated by the PC for this specific machine account
        //SponsorToken      5x5 voucher
        //PlainPassport     Passport ticket information.  If present then include the old unencrypted passport ticket preauth.
        //EncryptedPassport Passport ticket information.  If present then include the new encrypted passport ticket preauth.

        //common pc vouchers
        public const string UNLIMITED_TEST_TOKEN="PPPPP-PPPPP-PPPPP-PPPPP-PPPPP";
        public const string LIMITED_MACHINE_TOKEN="#############################";

        /// <summary> Retrieves a list of preauths that will be generated by default.  Note that this may vary based on the current input parameters. </summary>
        public override System.Collections.Generic.LinkedList<int> GetDefaultPreauthsToGenerate()
        {
            System.Collections.Generic.LinkedList<int> defaultPreauths=new System.Collections.Generic.LinkedList<int>();

            defaultPreauths.AddLast(2); //PADATA_ENC_TIMESTAMP

            if (PlainPassport!=null)
            {
                defaultPreauths.AddLast(212); //PADATA_PC_ACCOUNT_CREATION
            }
            if (EncryptedPassport!=null)
            {
                defaultPreauths.AddLast(220); //PADATA_PC_ACCOUNT_CREATION2
            }

            return defaultPreauths;
        }

        /// <summary> Creates all the preauths required for the request, based on the other input fields. </summary>
        public override void GeneratePreauths()
        {
            ClearPreauths();

            //get a passport ticket if needed
            //TODO: Once panorama switches their released client to use the new preauth, we should default to the new preauth as well.
            if (PlainPassport==null && EncryptedPassport==null)
            {
                PassportAuth tempPassport=new PassportAuth();
                tempPassport.CreateUser();
                PlainPassport=tempPassport.GetTicket("MBI_KEY_OLD", AuthClientBase.PassportSite.KdcPanorama);
            }

            //compute a principal key if needed
            if (Key==null)
            {
                if (PlainPassport!=null)
                {
                    //old preauth is based off the ticket key
                    Key=KdcCrypto.ComputePCPrincipalKey(PlainPassport.Key, PCNOnce);
                }
                else if (EncryptedPassport!=null)
                {
                    //new preauth is randomly generated by the client
                    Key=new byte[16];
                    ServerTestFramework.Utilities.RandomEx.GlobalRandGen.NextBytes(Key);
                }
            }

            //
            System.Collections.Generic.IEnumerable<int> preauthsToAdd=PreauthsToGenerate;
            if (preauthsToAdd==null)
            {
                preauthsToAdd=GetDefaultPreauthsToGenerate();
            }

            System.Collections.Generic.List<Kerberos.Preauth> preauths=new System.Collections.Generic.List<Kerberos.Preauth>();
            foreach (int paNumber in preauthsToAdd)
            {
                if (paNumber==212) //PADATA_PC_ACCOUNT_CREATION
                {
                    byte []voucherBytes=ServerTestFramework.Utilities.ByteEncoding.Instance.GetBytes(SponsorToken);

                    Kerberos.Preauth<Kerberos.PreauthPCAccountCreationRequest> pa=new Kerberos.Preauth<Kerberos.PreauthPCAccountCreationRequest>();
                    pa.Data.PCNOnce=PCNOnce;
                    pa.Data.PassportTicket=PlainPassport.Bytes;
                    pa.Data.PassportTicketLen=(ushort)PlainPassport.Bytes.Length;
                    pa.Data.EncryptedPart.PcId=PcId;
                    pa.Data.EncryptedPart.SponsorToken=voucherBytes;
                    pa.Data.EncryptedPart.SponsorTokenLen=(ushort)voucherBytes.Length;
                    pa.Data.Encrypt(Key);
                    preauths.Add(pa);
                }
                else if (paNumber==220) //PADATA_PC_ACCOUNT_CREATION2
                {
                    byte []voucherBytes=ServerTestFramework.Utilities.ByteEncoding.Instance.GetBytes(SponsorToken);

                    Kerberos.Preauth<Kerberos.PreauthPCAccountCreationRequest2> pa=new Kerberos.Preauth<Kerberos.PreauthPCAccountCreationRequest2>();
                    pa.Data.SetDefaults(Key, PcId, EncryptedPassport.Bytes, voucherBytes, UseTestKey==null?XmacsClient.UseXmacsTestKey():(bool)UseTestKey);
                    pa.Data.Encrypt();
                    preauths.Add(pa);
                }
                else
                {
                    Kerberos.Preauth pa=PreauthHelpers.GenerateDefaultPreauth(paNumber, Key, RequestTime, ConsoleId, null, NOnce, 0x585207d1, 0x12345678, 0x9abcdef0, PCNOnce, PlainPassport, EncryptedPassport, ConsoleCert, true, null);
                    preauths.Add(pa);
                }
            }

            Preauths=preauths.ToArray();
        }

        /// <summary> Sets values for a random new machine. </summary>
        public override void SetDefaults()
        {
            //TODO: Once panorama switches their released client to use the new preauth, we should default to the new preauth as well.
            SetDefaultsPlainPassport(null, null, null);
        }

        /// <summary> Sets values for a machine.  If pcId is null, a random pcId is generated.  If key is null, a key will be calculated from pcId.  If sponsor5x5 is null the pc test voucher is used. </summary>
        public void SetDefaultsPlainPassport(System.Nullable<ulong> pcId, string sponsor5x5, PassportAuth passport)
        {
            SponsorToken=sponsor5x5;

            //get passport info if needed
            if (passport==null)
            {
                passport=new PassportAuth();
            }

            if (passport.HasCachedTicket("MBI_KEY_OLD", AuthClientBase.PassportSite.KdcPanorama))
            {
                PlainPassport=passport.GetTicket("MBI_KEY_OLD", AuthClientBase.PassportSite.KdcPanorama);
            }

            //generate a random pcId not specified
            if (pcId==null)
            {
                pcId=ServerTestFramework.Core.Utilities.RandomEx.GlobalRandGen.NextUlong();
            }

            PcId=(ulong)pcId;

            //use test PC voucher if not specified
            if (SponsorToken==null)
            {
                SponsorToken=UNLIMITED_TEST_TOKEN;
            }

            //client name
            ConsoleId="PC.@XBOX.COM";

            //generate random nonces
            PCNOnce=ServerTestFramework.Core.Utilities.RandomEx.GlobalRandGen.NextUlong();

            //set basics
            base.SetDefaults();
        }

        /// <summary> Sets values for a machine.  If pcId is null, a random pcId is generated.  If key is null, a key will be calculated from pcId.  If sponsor5x5 is null the pc test voucher is used. </summary>
        public void SetDefaultsEncryptedPassport(System.Nullable<ulong> pcId, string sponsor5x5, PassportAuth passport)
        {
            SponsorToken=sponsor5x5;

            //get passport info if needed
            if (passport==null)
            {
                passport=new PassportAuth();
            }

            if (passport.HasCachedTicket("MBI", AuthClientBase.PassportSite.KdcPanorama))
            {
                PlainPassport=passport.GetTicket("MBI", AuthClientBase.PassportSite.KdcPanorama);
            }

            //generate a random pcId not specified
            if (pcId==null)
            {
                pcId=ServerTestFramework.Core.Utilities.RandomEx.GlobalRandGen.NextUlong();
            }

            PcId=(ulong)pcId;

            //use test PC voucher if not specified
            if (SponsorToken==null)
            {
                SponsorToken=UNLIMITED_TEST_TOKEN;
            }

            //client name
            ConsoleId="PC.@XBOX.COM";

            //generate random nonces
            PCNOnce=ServerTestFramework.Core.Utilities.RandomEx.GlobalRandGen.NextUlong();

            //set basics
            base.SetDefaults();
        }

        /// <summary> Sets defaults to reset an already-created machine. </summary>
        public override void SetResetDefaults(XmacsGenericRequestInput prevMachineInput)
        {
            SetDefaults();
            PcId=prevMachineInput.PcId;
            SponsorToken=prevMachineInput.SponsorToken;
            PlainPassport=prevMachineInput.PlainPassport;
            EncryptedPassport=prevMachineInput.EncryptedPassport;
        }
    };

    /// <summary> Used to build an PC Xmacs Request. </summary>
    public class XmacsPCRequest: XmacsGenericRequest
    {
        public XmacsPCRequest()
        {
            ((KerberosRequestWithInput)this).Input=new XmacsPCRequestInput();
        }

        /// <summary> Casts the base Input as input for the current platform. </summary>
        public new XmacsPCRequestInput Input { get { return (XmacsPCRequestInput)base.Input; } }

        /// <summary> Sets all the appropriate fields in a KerberosRequest based on Input. </summary>
        public override void SetRequest()
        {
            //put preauths into the request
            Preauths=Input.Preauths;

            //fill in the request body
            Version=new Raw.Integer();
            Version.Int64=5;

            MessageType=new Raw.Integer();
            MessageType.Int64=10;

            Options=new Kerberos.KerberosFlags();
            Options.Canonicalize=true;

            ClientName=new Kerberos.PrincipalName();
            ClientName.Type.Int64=10;
            ClientName.Names=new Compound.TagLengthValue<Raw.GeneralString>[1];
            ClientName.Names[0]=new Compound.TagLengthValue<Raw.GeneralString>();
            ClientName.Names[0].Value.String=Input.ConsoleId;

            Realm=new Raw.GeneralString();
            Realm.String=Input.Realm;

            ServerName=new Kerberos.PrincipalName();
            ServerName.Type.Int64=2;
            ServerName.Names=new Compound.TagLengthValue<Raw.GeneralString>[Input.ServerNames.Length];
            for (int i=0; i<Input.ServerNames.Length; ++i)
            {
                ServerName.Names[i]=new Compound.TagLengthValue<Raw.GeneralString>();
                ServerName.Names[i].Value.String=Input.ServerNames[i];
            }

            UntilTime=new Kerberos.Time();
            UntilTime.DateTime=new System.DateTime(2037, 09, 13, 02, 48, 05); //the day the world ends?  I hope not.

            NOnce=new Raw.Integer();
            NOnce.Int64=unchecked((int)Input.NOnce); //we deviate from the standard here, as our nonce uses the range of a signed 32 bit int rather than unsigned

            EncryptionTypes=new Raw.Integer[1];
            EncryptionTypes[0]=new Raw.Integer();
            EncryptionTypes[0].Int64=0x17;
        }
    };

    /// <summary> Used to parse an PC Xmacs Reply. </summary>
    public class XmacsPCReply: XmacsGenericReply
    {
        //Preauths present in a valid pc xmacs response
        public Kerberos.Preauth<Kerberos.PreauthPCAccountCreationReply>    PreauthPCAccountCreationReply;

        /// <summary> Decrypts the body, tickets, and preauths.  If a key is not supplied, that step is skipped.  This also populates the generic Output member. </summary>
        public override bool Decrypt(byte []principalKey, byte []ticketKey, uint nonce)
        {
            bool failures=!base.Decrypt(principalKey, ticketKey, nonce);

            if (PreauthPCAccountCreationReply!=null && principalKey!=null)
            {
                try
                {
                    PreauthPCAccountCreationReply.Data.Decrypt(principalKey);

                    Output=new XmacsGenericReplyOutput();
                    Output.MachineId=PreauthPCAccountCreationReply.Data.MachineId;
                    Output.ConsoleId=AskdcPCRequestInput.CalculateClientNameFromMachineID(Output.MachineId).Substring(0, 15); //we compute this since it's not part of the actual reply
                    Output.MachineKey=PreauthPCAccountCreationReply.Data.MachineKey;
                }
                catch (System.Exception e)
                {
                    Global.RO.Warn("Failed to decrypt PreauthPCAccountCreationReply of a "+GetType().ToString()+" with principal key: "+e.Message);
                    failures=true;
                }
            }

            return !failures;
        }

        //called after a reply has been build from asn
        protected override void AfterCreatefromAsn()
        {
            //find our preauths to store locally for more convenient access
            if (Preauths!=null)
            {
                foreach (Kerberos.Preauth pa in Preauths)
                {
                    if (pa is Kerberos.Preauth<Kerberos.PreauthPCAccountCreationReply>)
                    {
                        PreauthPCAccountCreationReply=(Kerberos.Preauth<Kerberos.PreauthPCAccountCreationReply>)pa;
                    }
                }
            }
        }
    };
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\Auth\KDC\XmacsXbox1.cs ===
using ServerTestFramework.LiveService.Auth.Asn;

namespace ServerTestFramework.LiveService.Auth
{
    /// <summary> These fields are used when SetRequest is called, to populate the relevent portions of the base KerberosRequest.  This is a subset of everything in the request, but should contain all the most common stuff we want to trivially play with in tests. </summary>
    public class XmacsXbox1RequestInput: XmacsGenericRequestInput
    {
        //ConsoleId     Console ID of the machine, in the form of 123456789012 (note that this gets sent in both the PreauthXenonMacRequest and the request body)
        //Key           16 byte key chosen by the client
        //Realm         Normally MACS.XBOX.COM
        //ServerNames   Normally krbtgt and MACS.XBOX.COM
        //RequestTime   Time that the request was made
        //NOnce         Value unique to this particular request

        /// <summary> Retrieves a list of preauths that will be generated by default.  Note that this may vary based on the current input parameters. </summary>
        public override System.Collections.Generic.LinkedList<int> GetDefaultPreauthsToGenerate()
        {
            System.Collections.Generic.LinkedList<int> defaultPreauths=new System.Collections.Generic.LinkedList<int>();

            defaultPreauths.AddLast(204); //PADATA_XBOX_PPA
            defaultPreauths.AddLast(206); //PADATA_XBOX_CLIENT_VERSION
            defaultPreauths.AddLast(2); //PADATA_ENC_TIMESTAMP
            defaultPreauths.AddLast(131); //PADATA_PAC_REQUEST_EX

            return defaultPreauths;
        }

        /// <summary> Creates all the preauths required for the request, based on the other input fields. </summary>
        public override void GeneratePreauths()
        {
            ClearPreauths();

            System.Collections.Generic.IEnumerable<int> preauthsToAdd=PreauthsToGenerate;
            if (preauthsToAdd==null)
            {
                preauthsToAdd=GetDefaultPreauthsToGenerate();
            }

            System.Collections.Generic.List<Kerberos.Preauth> preauths=new System.Collections.Generic.List<Kerberos.Preauth>();
            foreach (int paNumber in preauthsToAdd)
            {
                Kerberos.Preauth pa=PreauthHelpers.GenerateDefaultPreauth(paNumber, Key, RequestTime, ConsoleId, null, NOnce, 0xfffe0000, 0x12345678, 0x9abcdef0, PCNOnce, PlainPassport, EncryptedPassport, ConsoleCert, true, null);
                preauths.Add(pa);
            }

            Preauths=preauths.ToArray();
        }

        /// <summary> Sets values for a random new machine. </summary>
        public override void SetDefaults()
        {
            SetDefaults(null, null);
        }

        /// <summary> Sets values for a machine.  If consoleId is null, a random valid consoleId is made up.  If key is null, a key will be calculated from consoleId.  For valid cases, consoleId should be of the form "XE.012345678901". </summary>
        public void SetDefaults(string consoleId, byte []key)
        {
            ConsoleId=consoleId;
            Key=key;

            //generate a random console id
            if (ConsoleId==null)
            {
                ConsoleId=GenerateRandomDevkitConsoleID();
            }

            bool isDevKit=false;
            if (ConsoleId.Length>=9 && ConsoleId[8]=='9' && ConsoleId[9]=='9')
            {
                isDevKit=true;
            }

            //generate a key from the console id, in a way that can be easily reproduced by other code later
            if (Key==null)
            {
                if (isDevKit) //devkits all use the same hardcoded key
                {
                    Key=ServerTestFramework.Utilities.Hexer.unhex("0xB274D292FE16A0175870DB617B02D0AD");
                }
                else
                {
                    Key=AuthContext.CalculateKeyFromGamertag(ConsoleId, false);
                }
            }

            //set basics
            base.SetDefaults();
        }

        /// <summary> Sets defaults to reset an already-created machine. </summary>
        public override void SetResetDefaults(XmacsGenericRequestInput prevMachineInput)
        {
            SetDefaults();
            ConsoleId=prevMachineInput.ConsoleId;
            Key=prevMachineInput.Key;
        }

        /// <summary> Generates a random console id for a dev kit, which will hit the special dev kit genealogy entry.  </summary>
        public static string GenerateRandomDevkitConsoleID()
        {
            //the id itself
            ulong cidValue=1+ServerTestFramework.Core.Utilities.RandomEx.GlobalRandGen.NextUlong()%0xffffffffe; //36 bits max
            System.Text.StringBuilder cidString=new System.Text.StringBuilder(cidValue.ToString("d12"));

            //special dev kit digits
            cidString[8]='9';
            cidString[9]='9';

            //there is no checksum digit for xbox1
            return cidString.ToString();
        }
    };

    /// <summary> Used to build an Xbox1 Xmacs Request. </summary>
    public class XmacsXbox1Request: XmacsGenericRequest
    {
        public XmacsXbox1Request()
        {
            ((KerberosRequestWithInput)this).Input=new XmacsXbox1RequestInput();
        }

        /// <summary> Casts the base Input as input for the current platform. </summary>
        public new XmacsXbox1RequestInput Input { get { return (XmacsXbox1RequestInput)base.Input; } }

        /// <summary> Sets all the appropriate fields in a KerberosRequest based on Input. </summary>
        public override void SetRequest()
        {
            //put preauths into the request
            Preauths=Input.Preauths;

            //fill in the request body
            Version=new Raw.Integer();
            Version.Int64=5;

            MessageType=new Raw.Integer();
            MessageType.Int64=10;

            Options=new Kerberos.KerberosFlags();
            Options.Canonicalize=true;

            ClientName=new Kerberos.PrincipalName();
            ClientName.Type.Int64=10;
            ClientName.Names=new Compound.TagLengthValue<Raw.GeneralString>[1];
            ClientName.Names[0]=new Compound.TagLengthValue<Raw.GeneralString>();
            ClientName.Names[0].Value.String=Input.ConsoleId;

            Realm=new Raw.GeneralString();
            Realm.String=Input.Realm;

            ServerName=new Kerberos.PrincipalName();
            ServerName.Type.Int64=2;
            ServerName.Names=new Compound.TagLengthValue<Raw.GeneralString>[Input.ServerNames.Length];
            for (int i=0; i<Input.ServerNames.Length; ++i)
            {
                ServerName.Names[i]=new Compound.TagLengthValue<Raw.GeneralString>();
                ServerName.Names[i].Value.String=Input.ServerNames[i];
            }

            UntilTime=new Kerberos.Time();
            UntilTime.DateTime=new System.DateTime(2037, 09, 13, 02, 48, 05); //the day the world ends?  I hope not.

            NOnce=new Raw.Integer();
            NOnce.Int64=unchecked((int)Input.NOnce); //we deviate from the standard here, as our nonce uses the range of a signed 32 bit int rather than unsigned

            EncryptionTypes=new Raw.Integer[1];
            EncryptionTypes[0]=new Raw.Integer();
            EncryptionTypes[0].Int64=0x17;
        }
    };

    /// <summary> Used to parse an Xbox1 Xmacs Reply. </summary>
    public class XmacsXbox1Reply: XmacsGenericReply
    {
        //Preauths present in a valid xbox1 xmacs response
        public Kerberos.Preauth<Kerberos.PreauthXboxAccountCreation>    PreauthXboxAccountCreation;

        /// <summary> Decrypts the body, tickets, and preauths.  If a key is not supplied, that step is skipped.  This also populates the generic Output member. </summary>
        public override bool Decrypt(byte []sessionKey, byte []ticketKey, uint nonce)
        {
            bool failures=!base.Decrypt(sessionKey, ticketKey, nonce);

            if (PreauthXboxAccountCreation!=null && sessionKey!=null)
            {
                try
                {
                    PreauthXboxAccountCreation.Data.Decrypt(sessionKey, nonce);

                    Output=new XmacsGenericReplyOutput();
                    Output.MachineId=PreauthXboxAccountCreation.Data.MachineId;
                    Output.ConsoleId=PreauthXboxAccountCreation.Data.ConsoleId;
                    Output.MachineKey=PreauthXboxAccountCreation.Data.Key;
                }
                catch (System.Exception e)
                {
                    Global.RO.Warn("Failed to decrypt PreauthXboxAccountCreation of a "+GetType().ToString()+" with session key and nonce "+nonce+": "+e.Message);
                    failures=true;
                }
            }

            return !failures;
        }

        //called after a reply has been build from asn
        protected override void AfterCreatefromAsn()
        {
            //find our preauths to store locally for more convenient access
            if (Preauths!=null)
            {
                foreach (Kerberos.Preauth pa in Preauths)
                {
                    if (pa is Kerberos.Preauth<Kerberos.PreauthXboxAccountCreation>)
                    {
                        PreauthXboxAccountCreation=(Kerberos.Preauth<Kerberos.PreauthXboxAccountCreation>)pa;
                    }
                }
            }
        }
    };
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\Billing\ContentOfferLoader.cs ===
using System;
using System.Collections;
using System.Data;
using System.Text;

using ServerTestFramework.Database;
using xonline.common.config;

using Microsoft.Webstore.WstClient;
using xonline.common.sql.webstore;

namespace ServerTestFramework.LiveService.Billing
{
    /// <summary>
    /// this is a static utility class that loads content offers
    /// </summary>
    public class ContentOfferLoader
    {
#if false
        private const uint BASE_TITLE_ID = 3003000;
        private const uint NUMBER_OF_TITLES = 4;

        // ctor
        public ContentOfferLoader() 
        {

        }

        protected static string[] ServerConnectionStrings()
        {
            ArrayList servers = new ArrayList();

            // for xenon content we need to save it into
            // a) UODB and
            foreach (CUODB server in m_UODBs)
            {
                servers.Add(server.Connection.ConnectionString);
            }
            // b) ProductDB. Xbox.com is separated from Live. It is safe to remove.
            //servers.Add(ConfigUtil.ProductdbConnectionString);
            
            return (string[])(servers.ToArray(typeof(String)));
        }

        private static bool TestOffersExist()
        {
            foreach (string connectionString in ServerConnectionStrings())
            {
                // Data is partitioned by user puid
                SqlCommand command = new SqlCommand();
                SqlConnection conn = new SqlConnection(connectionString);
                conn.Open();
                command.Connection = conn;
                command.CommandType = CommandType.Text;
                command.CommandText = "select count(*) from t_titles where i_title_id >= " + BASE_TITLE_ID + " and i_title_id < " + (BASE_TITLE_ID + NUMBER_OF_TITLES);
        
                SqlDataReader dr = command.ExecuteReader(CommandBehavior.SingleRow);
                while (dr.Read())
                {
                    if (dr.GetInt32(0) < NUMBER_OF_TITLES-1 /*dash counts as 1*/)
                        return false;
                }
                conn.Close();
            }
            return true;
        }


        public static void CreateRandomOffers(bool force)
        {
            Random random = new Random(42);

            // check to see if we've already created these offers
            if (!force && (TestOffersExist() == true))
            {
                Global.RO.Info("CreateRandomOffers() - Offers already exist.");
                return;
            }

            Global.RO.Info("Creating titles and offers. This may take a few minutes...");

            // Create NUMBER_OF_TITLES different titles
            for (int title_number = 0; title_number < NUMBER_OF_TITLES; ++title_number)
            {

                // we need a title that is the dashboard
                uint title_id = 0;
                bool dash = false;
                if (title_number == (NUMBER_OF_TITLES - 1))
                {
                    Global.RO.Info("Creating offers for the dashboard. (title " + (title_number + 1).ToString() + "/" + NUMBER_OF_TITLES.ToString() + ")");
                    dash = true;
                    title_id = 0xfffe000;    // dash
                }
                else
                {
                    Global.RO.Info("Creating offers for title " + (title_number + 1).ToString() + "/" + NUMBER_OF_TITLES.ToString());
                    title_id = BASE_TITLE_ID + (uint)title_number;
                }

                // Insert the title
                InsertTitle(title_id);

                // Insert title ratings
                RatingSystems rating_systems = RatingSystems.GetRatingSystems();
                for (int i = 0; i < rating_systems.Count; i++)
                {
                    int random_rating_index = random.Next(rating_systems[i].Ratings.Count);
                    InsertTitleRating(title_id, (byte)rating_systems[i].Id, (byte)rating_systems[i].Ratings[random_rating_index].Id);
                }


                // Now create 50 offers per title
                for (int offer_number = 0; offer_number < 50; ++offer_number)
                {
                    ulong offer_id = ((ulong)title_id << 32) + (ulong)offer_number;

                    // Clean the offer
                    CleanOffers(offer_id);

                    int package_size = random.Next(5000000) + 1000;
                    int install_size = package_size + random.Next(5000000);
                    int bit_filter = random.Next(0xfffffff);

                    int offer_type = (int)OfferingTypeEnum.Content;
                    string friendly_name = "Content Offer " + offer_number;

                    if (dash && random.NextDouble() > 0.25) // 75% of dash offers will be non-content offers
                    {
                        if (random.NextDouble() > 0.5)
                        {
                            offer_type = (int)OfferingTypeEnum.PointsBundle;
                            friendly_name = "Points Bundle Offer " + offer_number;
                        }
                        else
                        {
                            offer_type = (int)OfferingTypeEnum.GamertagChange;
                            friendly_name = "Gamertag Change Offer " + offer_number;
                        }
                    }

                    // Add the offer
                    AddOffer(title_id, offer_id, package_size, install_size, bit_filter, offer_type, friendly_name);

                    int payment_type = (int)PaymentTypeEnum.Points;
                    switch (offer_type)        // this switch statement looks like overkill.. I know :(
                    {
                        case (int)OfferingTypeEnum.Content:
                            payment_type = (int)PaymentTypeEnum.Points;
                            break;
                        case (int)OfferingTypeEnum.PointsBundle:
                            payment_type = (int)PaymentTypeEnum.Token;
                            break;
                        case (int)OfferingTypeEnum.GamertagChange:
                            payment_type = (int)PaymentTypeEnum.Points;
                            break;
                        default:
                            payment_type = (int)PaymentTypeEnum.Points;
                            break;
                    }


                    Countries supported_countries = new Countries();

                    // Add the offer to 8 regions
                    for (int region_number = 0; region_number < 8; ++region_number)
                    {
                        byte country_id = (byte)supported_countries[random.Next(supported_countries.Count)].Id;

                        // get all cultures for the selected country.
                        TestCultures cultures = TestCultures.GetCountryCultures(country_id);
                        for (int i = 0; i < cultures.Count; ++i)
                        {
                            string name = string.Format("Offer {0} For Title {1}, {2}", offer_number, title_id.ToString("x8"), cultures[i].FriendlyName);
                            string sell_text = string.Format("Offer Sell Text {0}, for {1}", offer_number, cultures[i].FriendlyName);

                            AddOfferCultureDetails(offer_id, cultures[i].CultureId, name, sell_text);
                        }

                        DateTime start_date = new DateTime(2002, 11, 15);
                        DateTime end_date = start_date.AddYears(50);

                        if (random.NextDouble() < 0.15)
                        {
                            // 15% of the start dates should fall after today's date
                            start_date = start_date.AddYears(20);
                        }
                        else
                        {
                            // 15% of the end dates (of those where the start dates weren't affected) should fall before today's date
                            if (random.NextDouble() < 0.15) end_date = DateTime.UtcNow.AddYears(-1);
                        }


                        bool multiple_payment_types = false;
                        // 15% of content offers will be allow credit card payment
                        if (offer_type == (int)OfferingTypeEnum.Content && random.NextDouble() < 0.15)
                            multiple_payment_types = true;

                        for (int tier_required = 3; tier_required <= 6; tier_required += 3)
                        {
                            // 75% of offers will only be for silver subscribers
                            if (tier_required == 3 && random.NextDouble() > 0.25)
                                continue;

                            // Adding this line would make the results non-deterministic
                            // 50% of offers available to bronze users will have an early silver start date
                            // if (tier_required == 6 && random.NextDouble() < 0.5)
                            //    start_date = start_date.AddMonths(-(random.Next(3) + 1));

                            string boid;
                            int price_whole;
                            int price_fractional;
                            if (payment_type == (int)PaymentTypeEnum.CreditCard)
                            {
                                price_whole = random.Next(9) * 2 + 2;
                                price_fractional = random.Next(10) * 10;
                                boid = title_id.ToString("X").PadLeft(8, '0') + "-0000-0000-0000-" + offer_number.ToString("X").PadLeft(12, '0');
                            }
                            else
                            {
                                price_whole = random.Next(50) * 100;
                                price_fractional = 0;
                                boid = "";
                            }
                            byte offer_details = 0;

                            AddOfferRegion(offer_id, country_id, tier_required, payment_type, start_date, end_date, boid, price_whole, price_fractional, offer_details);

                            if (multiple_payment_types)
                            {
                                price_whole = random.Next(9) * 2 + 2;
                                price_fractional = random.Next(10) * 10;

                                AddOfferRegion(offer_id, country_id, tier_required, (int)PaymentTypeEnum.CreditCard, start_date, end_date, boid, price_whole, price_fractional, offer_details);
                            }
                        }
                    }
                }
            }
        } 


        public static void DummyPurchaseItem(ulong userPuid, ulong offerId)
        {
            string sql = "INSERT INTO dbo.t_subscriptions (bi_primary_puid, bi_offer_id, i_puid_is_machine, ";
            sql +=       "i_instances, dt_start_date, dt_end_date, i_subscription_status_id, vc_svc_instance_id, ";
            sql +=       "i_transaction_flags, si_hash_bucket, dt_Change_datetime) ";
            sql +=       "VALUES (";
            sql +=       string.Format("0x{0:x}", userPuid) + ", ";
            sql +=       string.Format("0x{0:x}", offerId) + ", ";
            sql +=       "0, 1, getutcdate(), '12/31/9999', 1, 0, 0x4, 0, getutcdate())";

            // need to change one partition only because there is the User Puid
            UodbWS.ExecuteSQLNonQuery(sql, userPuid);
        }
#endif

        // Played titles
        public static void CleanUserPlayedTitle(uint titleId)
        {
            string sql = "delete from dbo.t_xmsg_user_titles where i_title_id = " + ((int)titleId).ToString();

            // all physical partitions
            using (WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITEONLY_COMMANDTYPE))
            {
                for (int p = 0; p < ws.PhysicalPartitions; p++)
                {
                    ws.ClearParameters();
                    ws.PhysicalPartition = p;
                    ws.CommandSql = sql;

                    ws.Command.CommandTimeout = 120;   // make it two minutes
                    ws.ExecuteNonQuery();
                }
            }

            System.Threading.Thread.Sleep(50);
        }

        public static void AddUserPlayedTitle(ulong puid, uint title, DateTime lastplayed)
        {
            using (WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITEONLY_COMMANDTYPE))
            {
                ws.PartitionType = WstPartitionType.Logical;
                ws.SetHashVal(puid);

                string sql = "insert into dbo.t_xmsg_user_titles(bi_user_puid, i_title_id, i_flags, dt_last_logon, i_sequence, i_creds, i_achievements, si_hash_bucket, dt_change_datetime)";
                sql += "values (" + puid + ", " + (int)title + ", 0x00010000, '" + lastplayed.ToString() + "', 0, 0, 0, " + ws.Partition + ", getutcdate())";
                ws.CommandSql = sql;

                ws.ExecuteNonQuery();
            }

            System.Threading.Thread.Sleep(50);
        }

        // consumables
        public static void InsertOfferAsset(ulong offerId, uint titleId, Asset asset)
        {
            string sql = "exec dbo.p_svc_insert_offer_consumables " + (int)titleId + ", " + (long)offerId + ", " + (int)asset.AssetID + ", " + asset.Quantity;
            
            // all physical partition
            UodbWS.ExecuteSQLNonQuery(sql, null);
        }

        // preview offer
        public static void AddPreviewOffer(ulong offerId, ulong previewOfferId)
        {
            string sql = "insert into dbo.t_offer_relations (bi_offer_id, bi_related_offer_id, i_relation_type_id) values (" + (long)offerId + ", " + (long)previewOfferId + ", 6)";

            // all physical partitions
            object ret = UodbWS.ExecuteSQLNonQuery(sql, null);
            if (ret == null || (int)ret != UodbWS.WstPhysicalPartitionCount())
                throw new UnexpectedTestResultException("SQL failed: " + sql);
        }

        public static void CleanGenre(uint genreId)
        {
            string sql = "select i_title_id from dbo.t_title_genres where i_genre_id = " + genreId;
            ArrayList titles = new ArrayList(4);

            // get all titles for this genre
            using (WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITETHENREAD_COMMANDTYPE))
            {
                ws.PartitionType = WstPartitionType.Logical;
                ws.Partition = WstCommand.AnyPartition;
                ws.CommandSql = sql;

                using (WstDataReader r = ws.Execute())
                {
                    while (r.Read())
                    {
                        titles.Add((uint)r.GetInt32(0));
                    }

                    r.Close();
                }
            }

            // clean each title
            foreach (uint titleId in titles)
            {
                CleanTitle(titleId);
            }
        }

        public static void CleanTitle(uint titleId)
        {
            // remove data from related tables first
            string sql = "delete from dbo.t_title_genres where i_title_id = " + ((int)titleId).ToString();
            UodbWS.ExecuteSQLNonQuery(sql, null); // all physical partitions

            sql = "delete from dbo.t_user_title_enumeration_times where i_title_id = " + ((int)titleId).ToString();
            UodbWS.ExecuteSQLNonQuery(sql, null); // all physical partitions

            sql = "delete from dbo.t_title_trust_constants where i_title_id = " + ((int)titleId).ToString();
            UodbWS.ExecuteSQLNonQuery(sql, null); // all physical partitions

            sql = "delete from dbo.t_title_culture_details where i_title_id = " + ((int)titleId).ToString();
            UodbWS.ExecuteSQLNonQuery(sql, null); // all physical partitions

            sql = "delete from dbo.t_title_ratings where i_title_id = " + ((int)titleId).ToString();
            UodbWS.ExecuteSQLNonQuery(sql, null); // all physical partitions

            sql = "DELETE FROM dbo.t_alternate_titleids where i_title_id = " + ((int)titleId).ToString();
            UodbWS.ExecuteSQLNonQuery(sql, null); // all physical partitions

            sql = "DELETE FROM dbo.t_title_associated_offers where i_title_id = " + ((int)titleId).ToString();
            UodbWS.ExecuteSQLNonQuery(sql, null); // all physical partitions

            // clean user has played titles. The table is big and it takes too long to execute
            //command.CommandText = "DELETE FROM dbo.t_xmsg_user_titles where i_title_id = " + titleId.ToString();
            //command.ExecuteNonQuery();

            // clean voucher. This should be in p_svc_clean_offers
            //sql = "delete from dbo.t_vouchers where bi_offer_id in (select bi_offer_id from t_title_offers where i_title_id = " + ((int)titleId).ToString() + ")";
            //TokendbWS.ExecuteSQLNonQuery(sql, null); // all physical partitions

            ulong ret = 0;
            string tempsql = "select bi_offer_id from t_title_offers where i_title_id = " + ((int)titleId).ToString();

            using (WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITETHENREAD_COMMANDTYPE))
            {
                ws.PartitionType = WstPartitionType.Logical;
                ws.Partition = WstCommand.AnyPartition;
                ws.CommandSql = tempsql;

                using (WstDataReader myDataReader = ws.Execute())
                {
                    while (myDataReader.Read())
                    {
                        ret = (ulong)myDataReader.GetInt64(0);
                        // clean voucher. This should be in p_svc_clean_offers
                        sql = "delete from dbo.t_vouchers where bi_offer_id = " + string.Format("0x{0:x}", ret);
                        TokendbWS.ExecuteSQLNonQuery(sql, null); // all physical partitions

                        // clean dmp transaction. This should be in p_svc_clean_offers
                        sql = "delete from dbo.t_dmp_purchase_transaction_offers where bi_offer_id = " + string.Format("0x{0:x}", ret);
                        UserCommercedbWS.ExecuteSQLNonQuery(sql, null); // all physical partitions

                        // clean scs transaction. This should be in p_svc_clean_offers
                        sql = "delete from dbo.t_scs_purchaseitem_transactions where bi_offer_id = " + string.Format("0x{0:x}", ret);
                        UserCommercedbWS.ExecuteSQLNonQuery(sql, null); // all physical partitions
                    }
                    myDataReader.Close();
                }
            }


            // clean offer asset. This should be in p_svc_clean_offers
            sql = "delete from dbo.t_offer_consumables where bi_offer_id in (select bi_offer_id from t_title_offers where i_title_id = " + ((int)titleId).ToString() + ")";
            UodbWS.ExecuteSQLNonQuery(sql, null); // all physical partitions

            // clean user has purchased assets
            sql = "delete from dbo.t_user_assets where i_title_id = " + string.Format("0x{0:x}", ((int)titleId));
            UserCommercedbWS.ExecuteSQLNonQuery(sql, null); // all physical partitions

            // clean user last access time for title categories
            sql = "delete from dbo.t_user_title_enumeration_times where i_title_id = " + string.Format("0x{0:x}", ((int)titleId));
            UodbWS.ExecuteSQLNonQuery(sql, null); // all physical partitions

            using (WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITEONLY_COMMANDTYPE))
            {
                for (int p = 0; p < ws.PhysicalPartitions; p++)
                {
                    ws.ClearParameters();
                    ws.PhysicalPartition = p;
                    ws.StoredProc = "dbo.p_svc_clean_titles";

                    ws.AddParameter(ParamType.RETVAL, "@ret", 0);
                    ws.AddParameter("@i_title_id", titleId);

                    ws.Command.CommandTimeout = 120;   // make it two minutes
                    ws.ExecuteNonQuery();

                    uint hr = (uint)ws.GetIntParameter("@ret");
                    if (HResult.Failed(hr))
                    {
                        throw new UnexpectedTestResultException(ws.GetCallSignature() + " failed with hr = 0x" + hr.ToString("x"));
                    }
                }
            }
        }

        public static void InsertTitle(uint titleId)
        {
            InsertTitle(titleId, 2); // xenon title
        }
        
        public static void InsertTitle(uint titleId, byte consoleType)
        {
            using (WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITEONLY_COMMANDTYPE))
            {
                for (int p = 0; p < ws.PhysicalPartitions; p++)
                {
                    ws.ClearParameters();
                    ws.PhysicalPartition = p;
                    ws.StoredProc = "dbo.p_svc_insert_titles";

                    ws.AddParameter(ParamType.RETVAL, "@ret", 0);
                    ws.AddParameter("@i_title_id", titleId);
                    ws.AddParameter("@i_initial_version", 0);
                    ws.AddParameter("@ti_console_type_id", consoleType);    // 0 == xbox1, 1==xboxcom, 2 == xenon, 3==Marketplace

                    ws.ExecuteNonQuery();

                    uint hr = (uint)ws.GetIntParameter("@ret");
                    if (HResult.Failed(hr))
                    {
                        throw new UnexpectedTestResultException(ws.GetCallSignature() + " failed with hr = 0x" + hr.ToString("x"));
                    }
                }
            }
        }

        public static void InsertTitleRating(uint titleId, byte ratingSystemId, byte ratingId)
        {
            using (WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITEONLY_COMMANDTYPE))
            {
                for (int p = 0; p < ws.PhysicalPartitions; p++)
                {
                    ws.ClearParameters();
                    ws.PhysicalPartition = p;
                    ws.StoredProc = "dbo.p_svc_insert_title_rating";

                    ws.AddParameter(ParamType.RETVAL, "@ret", 0);
                    ws.AddParameter("@i_title_id", titleId);
                    ws.AddParameter("@i_rating_system_id", ratingSystemId);
                    ws.AddParameter("@i_rating_id", ratingId);

                    ws.ExecuteNonQuery();

                    uint hr = (uint)ws.GetIntParameter("@ret");
                    if (HResult.Failed(hr))
                    {
                        throw new UnexpectedTestResultException(ws.GetCallSignature() + " failed with hr = 0x" + hr.ToString("x"));
                    }
                }
            }
        }

        public static void InsertTitleCultureDetails(uint titleId, int cultureId, string name, string sellText,
            string publisher, string developer, string genre)
        {
            using (WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITEONLY_COMMANDTYPE))
            {
                for (int p = 0; p < ws.PhysicalPartitions; p++)
                {
                    ws.ClearParameters();
                    ws.PhysicalPartition = p;
                    ws.StoredProc = "dbo.p_svc_insert_title_culture_details";

                    ws.AddParameter(ParamType.RETVAL, "@ret", 0);
                    ws.AddParameter("@i_title_id", titleId);
                    ws.AddParameter("@i_culture_id", cultureId);
                    ws.AddParameter("@vc_name", name);
                    ws.AddParameter("@vc_sell_text", sellText);
                    ws.AddParameter("@vc_publisher", publisher);
                    ws.AddParameter("@vc_developer", developer);
                    ws.AddParameter("@vc_genre", genre);

                    ws.ExecuteNonQuery();

                    uint hr = (uint)ws.GetIntParameter("@ret");
                    if (HResult.Failed(hr))
                    {
                        throw new UnexpectedTestResultException(ws.GetCallSignature() + " failed with hr = 0x" + hr.ToString("x"));
                    }
                }
            }
        }

        
        public static void CleanEnumerationTimes(uint titleId)
        {
            string sql = "delete from dbo.t_user_title_enumeration_times where i_title_id = " + string.Format("0x{0:x}", titleId);

            // all physical partitions
            UodbWS.ExecuteSQLNonQuery(sql, null);
        }

        public static void CleanOffers(ulong offerId)
        {
            // clean subscriptions
            string sql = "delete from dbo.t_subscriptions where bi_offer_id = " + string.Format("0x{0:x}", offerId);
            UodbWS.ExecuteSQLNonQuery(sql, null); // all physical partitions

            // clean dmp transaction
            sql = "delete from dbo.t_dmp_purchase_transaction_offers where bi_offer_id = " + string.Format("0x{0:x}", offerId);
            UserCommercedbWS.ExecuteSQLNonQuery(sql, null); // all physical partitions

            // clean scs transaction
            sql = "delete from dbo.t_scs_purchaseitem_transactions where bi_offer_id = " + string.Format("0x{0:x}", offerId);
            UserCommercedbWS.ExecuteSQLNonQuery(sql, null); // all physical partitions

            // clean voucher. This should be in p_svc_clean_offers
            sql = "delete from dbo.t_vouchers where bi_offer_id = " + string.Format("0x{0:x}", offerId);
            TokendbWS.ExecuteSQLNonQuery(sql, null); // all physical partitions

            // clean offer asset. This should be in p_svc_clean_offers
            sql = "delete from dbo.t_offer_consumables where bi_offer_id = " + string.Format("0x{0:x}", offerId);
            UodbWS.ExecuteSQLNonQuery(sql, null); // all physical partitions

            using (WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITEONLY_COMMANDTYPE))
            {
                for (int p = 0; p < ws.PhysicalPartitions; p++)
                {
                    ws.ClearParameters();
                    ws.PhysicalPartition = p;
                    ws.StoredProc = "dbo.p_svc_clean_offers";

                    ws.AddParameter(ParamType.RETVAL, "@ret", 0);
                    ws.AddParameter("@bi_offer_id", offerId);

                    ws.Command.CommandTimeout = 120;   // make it two minutes
                    ws.ExecuteNonQuery();

                    uint hr = (uint)ws.GetIntParameter("@ret");
                    if (HResult.Failed(hr))
                    {
                        throw new UnexpectedTestResultException(ws.GetCallSignature() + " failed with hr = 0x" + hr.ToString("x"));
                    }
                }
            }
        }

        public static void AddOffer(uint titleId, ulong offerId, int packageSize, int installSize, int bitFilter,
            int offerType, string friendlyName, bool IsXenonOffer, byte[] ContentId)
        {
            AddOffer( titleId, offerId, packageSize, installSize, bitFilter, offerType, friendlyName, IsXenonOffer,ContentId,(int)OfferPolicies.PerMachineRights,0);
        }

        public static void AddOffer(uint titleId, ulong offerId, int packageSize, int installSize, int bitFilter,
            int offerType, string friendlyName, bool IsXenonOffer, byte[] ContentId, int policyflags, int licensebits)
        {
            byte consoleTypeId = (byte)(IsXenonOffer ? 2 : 0);

            AddOffer( titleId, offerId, packageSize, installSize, bitFilter,
             offerType, friendlyName, consoleTypeId, ContentId, policyflags, licensebits,
             0, 0, "00000000-0000-0000-0000-000000000000", 0, DateTime.UtcNow.AddYears(-2), DateTime.UtcNow.AddYears(2));
        }

        public static void AddOffer(uint titleId, ulong offerId, int packageSize, int installSize, int bitFilter,
            int offerType, string friendlyName, byte consoleTypeId, byte[] ContentId, int policyflags, int licensebits,
            int esrbId, byte cancelable, string billingSvcComp, int offerFrequencyId, DateTime startDate, DateTime endDate)
        {
            byte [] symKey = new byte[16];
            byte [] publicKey = new byte[284];

            using (WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITEONLY_COMMANDTYPE))
            {
                for (int p = 0; p < ws.PhysicalPartitions; p++)
                {
                    ws.ClearParameters();
                    ws.PhysicalPartition = p;
                    ws.StoredProc = "dbo.p_svc_insert_offers";

                    ws.AddParameter(ParamType.RETVAL, "@ret", 0);
                    ws.AddParameter("@i_title_id", titleId);
                    ws.AddParameter("@bi_offer_id", offerId);
                    ws.AddParameter("@i_ESRB_id", esrbId);
                    ws.AddParameter("@b_cancelable", cancelable);
                    ws.AddParameter("@i_package_size", packageSize);
                    ws.AddParameter("@i_install_size", installSize);
                    ws.AddParameter("@vb_sym_key", symKey);
                    ws.AddParameter("@i_bitfilter", bitFilter);
                    ws.AddParameter("@vc_billing_svc_component_id", billingSvcComp);
                    ws.AddParameter("@i_offer_type_id", offerType);
                    ws.AddParameter("@i_offer_frequency_id", offerFrequencyId);
                    ws.AddParameter("@dt_start_date", startDate);
                    ws.AddParameter("@dt_end_date", endDate);
                    ws.AddParameter("@vc_friendly_name", friendlyName);
                    ws.AddParameter("@vb_public_key", publicKey);
                    ws.AddParameter("@i_policy_flags", policyflags);
                    ws.AddParameter("@ti_console_type_id", consoleTypeId);
                    ws.AddParameter("@i_license_bits", licensebits);
                    if (ContentId != null)
                    {
                        ws.AddParameter("@b_content_id", ContentId);
                    }

                    ws.ExecuteNonQuery();

                    uint hr = (uint)ws.GetIntParameter("@ret");
                    if (HResult.Failed(hr))
                    {
                        throw new UnexpectedTestResultException(ws.GetCallSignature() + " failed with hr = 0x" + hr.ToString("x"));
                    }
                }
            }
        }

        public static void AddOffer(uint titleId, ulong offerId, int packageSize, int installSize, int bitFilter,
            int offerType, string friendlyName)
        {
            AddOffer(titleId, offerId, packageSize, installSize, bitFilter, offerType, friendlyName, false);
        }
        
        public static void AddOffer(uint titleId, ulong offerId, int packageSize, int installSize, int bitFilter,
            int offerType, string friendlyName, bool IsXenonOffer)
        {
            AddOffer(titleId, offerId, packageSize, installSize, bitFilter, offerType, friendlyName, IsXenonOffer, null);
        }


        public static void AddOfferRegion(ulong offerId, byte countryId, int tierRequired, int paymentType, DateTime startDate, 
            DateTime endDate, string boid, int priceWhole, int priceFractional, ushort offerDetails)
        {
            using (WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITEONLY_COMMANDTYPE))
            {
                for (int p = 0; p < ws.PhysicalPartitions; p++)
                {
                    ws.ClearParameters();
                    ws.PhysicalPartition = p;
                    ws.StoredProc = "dbo.p_svc_insert_offer_regions_xenon";

                    ws.AddParameter(ParamType.RETVAL, "@ret", 0);
                    ws.AddParameter("@bi_offer_id", offerId);
                    ws.AddParameter("@ti_country_id", countryId);
                    ws.AddParameter("@i_tier_required", tierRequired);
                    ws.AddParameter("@i_payment_type_id", paymentType);
                    ws.AddParameter("@dt_start_date", startDate);
                    ws.AddParameter("@dt_end_date", endDate);
                    ws.AddParameter("@vc_billing_offer_id", boid);
                    ws.AddParameter("@i_price_whole", priceWhole);
                    ws.AddParameter("@i_price_fractional", priceFractional);
                    ws.AddParameter("@si_specific_offer_details", offerDetails);

                    ws.ExecuteNonQuery();

                    uint hr = (uint)ws.GetIntParameter("@ret");
                    if (HResult.Failed(hr))
                    {
                        throw new UnexpectedTestResultException(ws.GetCallSignature() + " failed with hr = 0x" + hr.ToString("x"));
                    }
                }
            }
        }

        public static void AddOfferCultureDetails(ulong offerId, int culture, string name, string sellText)
        {
            using (WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITEONLY_COMMANDTYPE))
            {
                for (int p = 0; p < ws.PhysicalPartitions; p++)
                {
                    ws.ClearParameters();
                    ws.PhysicalPartition = p;
                    ws.StoredProc = "dbo.p_svc_insert_offer_culture_details";

                    ws.AddParameter(ParamType.RETVAL, "@ret", 0);
                    ws.AddParameter("@bi_offer_id", offerId);
                    ws.AddParameter("@i_culture_id", culture);
                    ws.AddParameter("@vc_name", name);
                    ws.AddParameter("@vc_sell_text", sellText);

                    ws.ExecuteNonQuery();

                    uint hr = (uint)ws.GetIntParameter("@ret");
                    if (HResult.Failed(hr))
                    {
                        throw new UnexpectedTestResultException(ws.GetCallSignature() + " failed with hr = 0x" + hr.ToString("x"));
                    }
                }
            }
        }


        public static void AddLiveSubscriptionOffer(uint titleID, uint tierID, ulong offerID, int bitFilter,
            int offerType, string friendlyName, bool cancelable, string billingComponentID, uint policyFlags,
                                                    ushort globalOfferDetails, int consoleTypeId)
        {
            InsertSubscription2(titleID, offerID, bitFilter, offerType, friendlyName, cancelable,
                                billingComponentID, policyFlags, globalOfferDetails, consoleTypeId);

            InsertBaseOffer(offerID, tierID);
        }

        public static void AddGameSubscriptionOffer(uint titleID, ulong offerID, int bitFilter,
            int offerType, string friendlyName, bool cancelable, string billingComponentID, uint policyFlags,
                                                    ushort globalOfferDetails, int consoleTypeId)
        {
            InsertSubscription2(titleID, offerID, bitFilter, offerType, friendlyName, cancelable,
                                billingComponentID, policyFlags, globalOfferDetails, consoleTypeId);
        }

        public static void InsertSubscription(uint titleId, ulong offerId, int bitFilter,
            int offerType, string friendlyName, bool cancelable, string billingComponentID, 
                                              uint policyFlags, ushort globalOfferDetails, int consoleTypeId)
        {
            byte [] symKey = new byte[16];
            byte [] publicKey = new byte[284];
            string svcComponentId = "00000000-0000-0000-0000-000000000000";

            using (WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITEONLY_COMMANDTYPE))
            {
                for (int p = 0; p < ws.PhysicalPartitions; p++)
                {
                    ws.ClearParameters();
                    ws.PhysicalPartition = p;
                    ws.StoredProc = "dbo.p_svc_insert_subscriptions";

                    ws.AddParameter(ParamType.RETVAL, "@ret", 0);
                    ws.AddParameter("@i_title_id", titleId);
                    ws.AddParameter("@bi_offer_id", offerId);
                    ws.AddParameter("@i_ESRB_id", 0);
                    ws.AddParameter("@b_cancelable", 0);
                    ws.AddParameter("@i_package_size", 0);
                    ws.AddParameter("@i_install_size", 0);
                    ws.AddParameter("@vb_sym_key", symKey);
                    ws.AddParameter("@i_bitfilter", bitFilter);
                    ws.AddParameter("@vc_billing_svc_component_id", svcComponentId);
                    ws.AddParameter("@i_offer_type_id", offerType);
                    ws.AddParameter("@i_offer_frequency_id", 0);
                    ws.AddParameter("@dt_start_date", new DateTime(2201, 11, 15));
                    ws.AddParameter("@dt_end_date", new DateTime(3000, 12, 31));
                    ws.AddParameter("@vc_friendly_name", friendlyName);
                    ws.AddParameter("@vb_public_key", publicKey);
                    ws.AddParameter("@i_policy_flags", (int)OfferPolicies.PerMachineRights);
                    ws.AddParameter("@si_global_offer_details", globalOfferDetails);
                    ws.AddParameter("@ti_console_type_id", consoleTypeId);

                    ws.ExecuteNonQuery();

                    uint hr = (uint)ws.GetIntParameter("@ret");
                    if (HResult.Failed(hr))
                    {
                        throw new UnexpectedTestResultException(ws.GetCallSignature() + " failed with hr = 0x" + hr.ToString("x"));
                    }
                }
            }
        }

        public static void InsertSubscription2(uint titleId, ulong offerId, int bitFilter,
            int offerType, string friendlyName, bool cancelable, string billingComponentID, 
                                               uint policyFlags, ushort globalOfferDetails, int consoleTypeId)
        {
            byte [] symKey = new byte[16];
            byte [] publicKey = new byte[284];
            string sql = "exec dbo.p_svc_insert_subscriptions ";
            sql += "@i_title_id=" + string.Format("0x{0:x}", titleId) + ", ";
            sql += "@bi_offer_id=" + string.Format("0x{0:x}", offerId) + ", ";
            sql += "@i_ESRB_id=" + (0).ToString() + ", ";
            sql += "@b_cancelable=" + (0).ToString() + ", ";
            sql += "@i_package_size=" + (0).ToString() + ", ";
            sql += "@i_install_size=" + (0).ToString() + ", ";
            sql += "@vb_sym_key=0, ";
            sql += "@i_bitfilter=" + bitFilter.ToString() + ", ";
            sql += "@vc_billing_svc_component_id='00000000-0000-0000-0000-000000000000', ";
            sql += "@i_offer_type_id=" + offerType.ToString() + ", ";
            sql += "@i_offer_frequency_id=" + (0).ToString() + ", ";
            sql += "@dt_start_date='" + (new DateTime(2001, 11, 15)).ToString() + "', ";
            sql += "@dt_end_date='" + (new DateTime(3000, 12, 31)).ToString() + "', ";
            sql += "@vc_friendly_name='" + friendlyName.Replace("'", "''") + "', ";
            sql += "@vb_public_key=0, ";
            sql += "@i_policy_flags=" + ((byte)(OfferPolicies.PerMachineRights)).ToString() + ", ";
            sql += "@si_global_offer_details=" + globalOfferDetails.ToString() + ", ";
            sql += "@ti_console_type_id=" + consoleTypeId.ToString() + "";

            // all physical partitions
            UodbWS.ExecuteSQLNonQuery(sql, null);
        }

        
        public static void InsertBaseOffer(ulong offerID, uint tierID)
        {
            using (WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITEONLY_COMMANDTYPE))
            {
                for (int p = 0; p < ws.PhysicalPartitions; p++)
                {
                    ws.ClearParameters();
                    ws.PhysicalPartition = p;
                    ws.StoredProc = "dbo.p_svc_insert_base_offer";

                    ws.AddParameter(ParamType.RETVAL, "@ret", 0);
                    ws.AddParameter("@bi_offer_id", offerID);
                    ws.AddParameter("@i_tier_id", tierID);

                    ws.ExecuteNonQuery();

                    uint hr = (uint)ws.GetIntParameter("@ret");
                    if (HResult.Failed(hr))
                    {
                        throw new UnexpectedTestResultException(ws.GetCallSignature() + " failed with hr = 0x" + hr.ToString("x"));
                    }
                }
            }
        }


        public static void InsertOfferRelation(ulong offerID, ulong relatedOfferID, int relationType, int convertMode)
        {
            using (WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITEONLY_COMMANDTYPE))
            {
                for (int p = 0; p < ws.PhysicalPartitions; p++)
                {
                    ws.ClearParameters();
                    ws.PhysicalPartition = p;
                    ws.StoredProc = "dbo.p_svc_insert_offer_relations";

                    ws.AddParameter(ParamType.RETVAL, "@ret", 0);
                    ws.AddParameter("@bi_offer_id", offerID);
                    ws.AddParameter("@bi_related_offer_id", relatedOfferID);
                    ws.AddParameter("@i_relation_type_id", relationType);
                    ws.AddParameter("@i_convert_mode", convertMode);

                    ws.ExecuteNonQuery();

                    uint hr = (uint)ws.GetIntParameter("@ret");
                    if (HResult.Failed(hr))
                    {
                        throw new UnexpectedTestResultException(ws.GetCallSignature() + " failed with hr = 0x" + hr.ToString("x"));
                    }
                }
            }
        }


        public static void AddOfferSku(int skuId, OfferingSKUType skuType, string sku, string friendlyName)
        {
            using (WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITEONLY_COMMANDTYPE))
            {
                for (int p = 0; p < ws.PhysicalPartitions; p++)
                {
                    ws.ClearParameters();
                    ws.PhysicalPartition = p;
                    ws.StoredProc = "dbo.p_svc_insert_offer_sku";

                    ws.AddParameter(ParamType.RETVAL, "@ret", 0);
                    ws.AddParameter("@i_sku_id", skuId);
                    ws.AddParameter("@i_sku_type_id", (int)skuType);
                    ws.AddParameter("@vc_sku", sku);
                    ws.AddParameter("@vc_friendly_name", friendlyName);

                    ws.ExecuteNonQuery();

                    uint hr = (uint)ws.GetIntParameter("@ret");
                    if (HResult.Failed(hr))
                    {
                        throw new UnexpectedTestResultException(ws.GetCallSignature() + " failed with hr = 0x" + hr.ToString("x"));
                    }
                }
            }
        }

        public static void AddDmpOfferDetails(ulong offerId, int revenueSkuId, int categoryId, int campaignId)
        {
            using (WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITEONLY_COMMANDTYPE))
            {
                for (int p = 0; p < ws.PhysicalPartitions; p++)
                {
                    ws.ClearParameters();
                    ws.PhysicalPartition = p;
                    ws.StoredProc = "dbo.p_svc_insert_dmp_offer_details";

                    ws.AddParameter(ParamType.RETVAL, "@ret", 0);
                    ws.AddParameter("@bi_offer_id", offerId);
                    ws.AddParameter("@i_revenue_sku_id", revenueSkuId);
                    ws.AddParameter("@i_category_id", categoryId);
                    ws.AddParameter("@i_campaign_id", campaignId);

                    ws.ExecuteNonQuery();

                    uint hr = (uint)ws.GetIntParameter("@ret");
                    if (HResult.Failed(hr))
                    {
                        throw new UnexpectedTestResultException(ws.GetCallSignature() + " failed with hr = 0x" + hr.ToString("x"));
                    }
                }
            }
        }

        // Scs offers are different from dmp offers. PCF files are needed on SCG side.
        public static void AddScsOfferDetails(ulong offerId, int campaignId)
        {
            using (WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITEONLY_COMMANDTYPE))
            {
                for (int p = 0; p < ws.PhysicalPartitions; p++)
                {
                    ws.ClearParameters();
                    ws.PhysicalPartition = p;
                    ws.StoredProc = "dbo.p_svc_insert_offer_scs_item_details";

                    ws.AddParameter(ParamType.RETVAL, "@ret", 0);
                    ws.AddParameter("@bi_offer_id", offerId);
                    ws.AddParameter("@i_campaign_id", campaignId);

                    ws.ExecuteNonQuery();

                    uint hr = (uint)ws.GetIntParameter("@ret");
                    if (HResult.Failed(hr))
                    {
                        throw new UnexpectedTestResultException(ws.GetCallSignature() + " failed with hr = 0x" + hr.ToString("x"));
                    }
                }
            }
        }


        public static void AddOfferCategoryCultureDetails(int categoryId, int cultureId, string categoryName)
        {
            using (WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITEONLY_COMMANDTYPE))
            {
                for (int p = 0; p < ws.PhysicalPartitions; p++)
                {
                    ws.ClearParameters();
                    ws.PhysicalPartition = p;
                    ws.StoredProc = "dbo.p_svc_insert_offer_category_culture_details";

                    ws.AddParameter(ParamType.RETVAL, "@ret", 0);
                    ws.AddParameter("@i_category_id", categoryId);
                    ws.AddParameter("@i_culture_id", cultureId);
                    ws.AddParameter("@vc_category_name", categoryName);

                    ws.ExecuteNonQuery();

                    uint hr = (uint)ws.GetIntParameter("@ret");
                    if (HResult.Failed(hr))
                    {
                        throw new UnexpectedTestResultException(ws.GetCallSignature() + " failed with hr = 0x" + hr.ToString("x"));
                    }
                }
            }
        }

        
        public static void AddOfferCampaign(int campaignId, string friendlyName)
        {
            using (WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITEONLY_COMMANDTYPE))
            {
                for (int p = 0; p < ws.PhysicalPartitions; p++)
                {
                    ws.ClearParameters();
                    ws.PhysicalPartition = p;
                    ws.StoredProc = "dbo.p_svc_insert_offer_campaign";

                    ws.AddParameter(ParamType.RETVAL, "@ret", 0);
                    ws.AddParameter("@i_campaign_id", campaignId);
                    ws.AddParameter("@vc_friendly_name", friendlyName);

                    ws.ExecuteNonQuery();

                    uint hr = (uint)ws.GetIntParameter("@ret");
                    if (HResult.Failed(hr))
                    {
                        throw new UnexpectedTestResultException(ws.GetCallSignature() + " failed with hr = 0x" + hr.ToString("x"));
                    }
                }
            }
        }

        public static string ByteString(byte[] byteArray)
        {
            string toString = "";
            for (int i = 0; i < byteArray.GetLength(0); i++)
            {
                toString = toString + byteArray[i].ToString("X2");
            }
            return toString;
        }

        public static void CleanContent(byte[] contentId)
        {
            string content = ByteString(contentId);
            string sql = "DELETE FROM dbo.t_offer_content_details WHERE b_content_id = 0x" + content + " DELETE FROM dbo.t_content_locations WHERE b_content_id = 0x" + content + " DELETE FROM dbo.t_content WHERE b_content_id = 0x" + content;

            // all physical partitions
            UodbWS.ExecuteSQLNonQuery(sql, null);
        }

        public static void AddContent(byte[] contentId, int installSize, int packageSize, byte[] symKey, byte[] publicKey)
        {
            using (WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITEONLY_COMMANDTYPE))
            {
                for (int p = 0; p < ws.PhysicalPartitions; p++)
                {
                    ws.ClearParameters();
                    ws.PhysicalPartition = p;
                    ws.StoredProc = "dbo.p_svc_insert_content";

                    ws.AddParameter(ParamType.RETVAL, "@ret", 0);
                    ws.AddParameter("@b_content_id", contentId);
                    ws.AddParameter("@i_install_size", installSize);
                    ws.AddParameter("@i_package_size", packageSize);
                    ws.AddParameter("@vb_sym_key", symKey);
                    ws.AddParameter("@vb_public_key", publicKey);

                    ws.ExecuteNonQuery();

                    uint hr = (uint)ws.GetIntParameter("@ret");
                    if (HResult.Failed(hr))
                    {
                        throw new UnexpectedTestResultException(ws.GetCallSignature() + " failed with hr = 0x" + hr.ToString("x"));
                    }
                }
            }
        }

        public static void AddContentLocations(byte[] contentId, int locationRank, string xrl)
        {
            using (WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITEONLY_COMMANDTYPE))
            {
                for (int p = 0; p < ws.PhysicalPartitions; p++)
                {
                    ws.ClearParameters();
                    ws.PhysicalPartition = p;
                    ws.StoredProc = "dbo.p_svc_insert_content_locations";

                    ws.AddParameter(ParamType.RETVAL, "@ret", 0);
                    ws.AddParameter("@b_content_id", contentId);
                    ws.AddParameter("@i_location_rank", locationRank);
                    ws.AddParameter("@vc_XRL", xrl);

                    ws.ExecuteNonQuery();

                    uint hr = (uint)ws.GetIntParameter("@ret");
                    if (HResult.Failed(hr))
                    {
                        throw new UnexpectedTestResultException(ws.GetCallSignature() + " failed with hr = 0x" + hr.ToString("x"));
                    }
                }
            }
        }

        // will check if it is already existing first.
        public static void GrantContentLicense(ulong userPuid, ulong machinePuid, ulong offerId)
        {
            if (!UodbWS.UserHasLicense(userPuid, offerId))
                GrantContentLicense(userPuid, machinePuid, new ulong[] { offerId });
        }

        public static void GrantContentLicense(ulong userPuid, ulong machinePuid, ulong[] offerIds)
        {
            // need to change one partition only because there is the User Puid
            StringBuilder offerXml = new StringBuilder();
            foreach (ulong offerId in offerIds)
            {
                offerXml.Append(string.Format("<o>{0}</o>", (long)offerId));
            }

            using (WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITEONLY_COMMANDTYPE))
            {
                ws.PartitionType = WstPartitionType.Logical;
                ws.StoredProc = "dbo.p_xbos_grant_offer_licenses_and_assets";
                ws.SetHashVal(userPuid);

                ws.AddParameter(ParamType.RETVAL, "@ret", 0);
                ws.AddParameter("@bi_user_puid", userPuid);
                ws.AddParameter("@bi_machine_puid", machinePuid);
                ws.AddParameter("@xml_offers", offerXml.ToString());
                ws.AddParameter("@si_hash_bucket", ws.Partition);

                ws.ExecuteNonQuery();

                uint hr = (uint)ws.GetIntParameter("@ret");
                if (HResult.Failed(hr))
                {
                    throw new UnexpectedTestResultException(ws.GetCallSignature() + " failed with hr = 0x" + hr.ToString("x"));
                }
            }
        }
/* Removing obslete function
        public static void GrantVideoLicense(ulong userPuid, ulong machinePuid, System.Guid wmid, System.Guid wmidPC, uint videoType)
        {
            GrantVideoLicense(userPuid, machinePuid, wmid.ToString(), wmidPC.ToString(), videoType);
        }

        // will check if it is already existing first.
        public static void GrantVideoLicense(ulong userPuid, ulong machinePuid, string wmid, string wmidPC, uint videoType)
        {
            string sql = "select bi_user_puid from t_user_video_licenses_console where bi_user_puid = 0x" + userPuid.ToString("x") + " and uid_wmid = '" + wmid + "'";

            object ret = UodbWS.ExecuteSQLScalar(sql, userPuid);
            if (ret == null)
            {
                StringBuilder wmidXml = new StringBuilder();
                StringBuilder wmid2Xml = new StringBuilder();

                wmidXml.Append(string.Format("<w>{0}</w>", wmid));
                wmid2Xml.Append(string.Format("<w>{0}</w>", wmidPC));

                using (WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITEONLY_COMMANDTYPE))
                {
                    ws.PartitionType = WstPartitionType.Logical;
                    ws.StoredProc = "dbo.p_xbos_grant_video_licenses";
                    ws.SetHashVal(userPuid);

                    ws.AddParameter(ParamType.RETVAL, "@ret", 0);
                    ws.AddParameter("@bi_user_puid", userPuid);
                    ws.AddParameter("@bi_machine_puid", machinePuid);
                    ws.AddParameter("@xml_console_wmids", wmidXml.ToString());
                    ws.AddParameter("@xml_pc_wmids", wmid2Xml.ToString());
                    ws.AddParameter("@i_video_type_id", videoType);
                    ws.AddParameter("@si_hash_bucket", ws.Partition);

                    ws.ExecuteNonQuery();

                    uint hr = (uint)ws.GetIntParameter("@ret");
                    if (HResult.Failed(hr))
                    {
                        throw new UnexpectedTestResultException(ws.GetCallSignature() + " failed with hr = 0x" + hr.ToString("x"));
                    }
                }
            }
        }
*/
        public static void GrantPpvVideoLicense(ulong userPuid, ulong machinePuid, string wmid, uint videoType) 
        {
            GrantPpvVideoLicense(userPuid, machinePuid, wmid, videoType, false);
        }
        
        public static void GrantPpvVideoLicense(ulong userPuid, ulong machinePuid, string wmid, uint videoType, bool acknowledged)
        {
            string sql = "select bi_user_puid from t_user_ppv_licenses where bi_user_puid = 0x" + userPuid.ToString("x") + " and uid_wmid = '" + wmid + "'";

            object ret = UodbWS.ExecuteSQLScalar(sql, userPuid);
            if (ret == null)
            {
                StringBuilder wmidXml = new StringBuilder();

                wmidXml.Append(string.Format("<w expirationHours=\"48\" viewHours=\"24\" viewCount=\"1\">{0}</w>", wmid));

                using (WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITEONLY_COMMANDTYPE))
                {
                    ws.PartitionType = WstPartitionType.Logical;
                    ws.StoredProc = "dbo.p_xbos_grant_user_ppv_licenses";
                    ws.SetHashVal(userPuid);

                    ws.AddParameter(ParamType.RETVAL, "@ret", 0);
                    ws.AddParameter("@bi_user_puid", userPuid);
                    ws.AddParameter("@bi_machine_puid", machinePuid);
                    ws.AddParameter("@xml_console_wmids", wmidXml.ToString());
                    ws.AddParameter("@i_video_type_id", videoType);
                    ws.AddParameter("@si_hash_bucket", ws.Partition);

                    ws.ExecuteNonQuery();

                    uint hr = (uint)ws.GetIntParameter("@ret");
                    if (HResult.Failed(hr))
                    {
                        throw new UnexpectedTestResultException(ws.GetCallSignature() + " failed with hr = 0x" + hr.ToString("x"));
                    }

                    if (acknowledged) 
                    {
                        ws.ClearParameters();
                        ws.StoredProc = "dbo.p_xbos_acknowledge_user_ppv_license";
                        ws.SetHashVal(userPuid);
                        ws.AddParameter(ParamType.RETVAL, "@ret", 0);
                        ws.AddParameter("@bi_user_puid", userPuid);
                        ws.AddParameter("@uid_wmid", wmid);
                        ws.AddParameter("@i_video_type_id", videoType);
                        
                        ws.ExecuteNonQuery();
                        
                        hr = (uint)ws.GetIntParameter("@ret");
                        if (HResult.Failed(hr))
                        {
                            throw new UnexpectedTestResultException(ws.GetCallSignature() + " failed with hr = 0x" + hr.ToString("x"));
                        }
                    }
                    
                }
            }
        }

        public static void AddTitleGenre(uint titleId, uint genreId)
        {
            using (WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITEONLY_COMMANDTYPE))
            {
                for (int p = 0; p < ws.PhysicalPartitions; p++)
                {
                    ws.ClearParameters();
                    ws.PhysicalPartition = p;
                    ws.StoredProc = "dbo.p_svc_insert_title_genre";

                    ws.AddParameter(ParamType.RETVAL, "@ret", 0);
                    ws.AddParameter("@i_title_id", titleId);
                    ws.AddParameter("@i_genre_id", genreId);

                    ws.ExecuteNonQuery();

                    uint hr = (uint)ws.GetIntParameter("@ret");
                    if (HResult.Failed(hr))
                    {
                        throw new UnexpectedTestResultException(ws.GetCallSignature() + " failed with hr = 0x" + hr.ToString("x"));
                    }
                }
            }
        }

        /// <summary>
        /// Update/change the policy flags for an offer
        /// </summary>
        /// <param name="offerId"></param>
        /// <param name="policyFlags"></param>
        public static void UpdateOfferPolicyFlags(ulong offerId, uint policyFlags)
        {
            string sql = "update t_offers set i_policy_flags = " + policyFlags + " where bi_offer_id = " + string.Format("0x{0:x}", offerId);

            // all physical partitions
            UodbWS.ExecuteSQLNonQuery(sql, null); 
        }

        ///
        /// Associated offers
        ///

        public static bool IsAssociatedOfferExists(uint titleId, ulong offerId)
        {
            string sql = string.Format("select count(*) from t_title_associated_offers where bi_offer_id = 0x{0:X} and i_title_id = 0x{1:X}", offerId, titleId);
            bool retBool = false;

            // any partition
            object ret = UodbWS.ExecuteSQLScalar(sql, null);
            if (ret != null)
            {
                if ((int)ret > 0)
                    retBool = true;
            }
            else
                throw new UnexpectedTestResultException("SQL failed: " + sql);

            return retBool;
        }

        public static void InsertAssociatedOffer(uint titleId, ulong offerId)
        {
            if (!IsAssociatedOfferExists(titleId, offerId))
            {
                string sql = string.Format("insert into t_title_associated_offers (i_title_id, bi_offer_id) values (0x{0:X}, 0x{1:X})", titleId, offerId);

                // all physical partitions
                object ret = UodbWS.ExecuteSQLNonQuery(sql, null);
                if (ret == null || (int)ret != UodbWS.WstPhysicalPartitionCount())
                    throw new UnexpectedTestResultException("SQL failed: " + sql);
            }
        }

        public static void DeleteAssociatedOffer(uint titleId, ulong offerId)
        {
            if (IsAssociatedOfferExists(titleId, offerId))
            {
                string sql = string.Format("delete from t_title_associated_offers where bi_offer_id = 0x{0:X} and i_title_id = 0x{1:X}", offerId, titleId);

                // all physical partitions
                object ret = UodbWS.ExecuteSQLNonQuery(sql, null);
                if (ret == null || (int)ret != UodbWS.WstPhysicalPartitionCount())
                    throw new UnexpectedTestResultException("SQL failed: " + sql);
            }
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\Auth\RPSTicketGen\TicketParameters.cs ===
u s i n g   S y s t e m ; 
 
 
 
 u s i n g   R P S E m u l a t o r ; 
 
 
 
 n a m e s p a c e   S e r v e r T e s t F r a m e w o r k . L i v e S e r v i c e . A u t h . R P S T i c k e t G e n 
 
 { 
 
 
 
 / / /   < s u m m a r y > 
 
 / / /   C o m m o n l y   u s e d   t i c k e t   p a r a m e t e r s . 
 
 / / /   h t t p : / / p 2 . l i v e - i n t . c o m / R P S / R P S D e f a u l t . a s p x 
 
 / / /   c a n   p r o v i d e   g r e a t   i n s i g h t   t o   t h e s e   m e m b e r s . 
 
 / / /   
 
 / / /   T o   c r e a t e   a   t i c k e t   f r o m   t h e   d e f a u l t s ,   y o u   r e a l l y   o n l y   n e e d   t o   s e t : 
 
 / / /   P u i d 
 
 / / /   C I d 
 
 / / /   S i t e I d 
 
 / / /   
 
 / / /   B u t   I   l i k e   t o   s e t   M e m b e r N a m e   a s   w e l l . 
 
 / / /   < / s u m m a r y > 
 
 p u b l i c   c l a s s   T i c k e t P a r a m e t e r s 
 
 { 
 
         # r e g i o n   T y p e s 
 
 
 
         p u b l i c   e n u m   G e n d e r E n u m 
 
         { 
 
                 M a l e , 
 
                 F e m a l e 
 
         } 
 
 
 
         / / /   < s u m m a r y > 
 
         / / /   U s e d   t o   d e t e r m i n e   w h i c h   c e r t i f i c a t e   t o   e n c r y p t   t h e   t i c k e t   w i t h . 
 
         / / /   < / s u m m a r y > 
 
         p u b l i c   e n u m   E n v i r o n m e n t E n u m 
 
         { 
 
                 X b l o b , 
 
                 I n t R p s , 
 
                 I n t X b o x C o m 
 
         } 
 
 
 
         / / /   < s u m m a r y > 
 
         / / /   D e l e g a t i o n   t i c k e t   v s   s t a n d a r d   t i c k e t 
 
         / / /   < / s u m m a r y > 
 
         p u b l i c   e n u m   P a s s p o r t T i c k e t T y p e 
 
         { 
 
                 C o m p a c t   =   0 , 
 
                 D e l e g a t i o n   =   1 
 
         } 
 
 
 
         # e n d r e g i o n 
 
 
 
         # r e g i o n   C o m p a c t P r o f i l e   P r o p e r t i e s 
 
 
 
         / / /   < s u m m a r y > B i r t h d a y   v a l u e   i s   n o t   u n d e r s t o o d . < / s u m m a r y > 
 
         p u b l i c   u i n t   B i r t h d a y   {   g e t ;   s e t ;   } 
 
         / / /   < s u m m a r y > B i r t h d a y P r e c i s i o n   v a l u e   i s   n o t   u n d e r s t o o d ,   b u t   2   s e e m s   t o   b e   a   c o m m o n   v a l u e . < / s u m m a r y > 
 
         p u b l i c   b y t e   B i r t h d a y P r e c i s i o n   {   g e t ;   s e t ;   } 
 
         / / /   < s u m m a r y > T w o   l e t t e r   c o u n t r y   c o d e ,   e x .   " U S " . < / s u m m a r y > 
 
         p u b l i c   s t r i n g   C o u n t r y C o d e   {   g e t ;   s e t ;   } 
 
         / / /   < s u m m a r y > C a n   b e   t h e   e m a i l   a d d r e s s   o f   t h e   a c c o u n t . < / s u m m a r y > 
 
         p u b l i c   s t r i n g   D i s p l a y N a m e   {   g e t ;   s e t ;   } 
 
         p u b l i c   s t r i n g   F i r s t N a m e   {   g e t ;   s e t ;   } 
 
         p u b l i c   u i n t   F l a g s   {   g e t ;   s e t ;   } 
 
         p u b l i c   G e n d e r E n u m   G e n d e r   {   g e t ;   s e t ;   } 
 
         / / /   < s u m m a r y > S t a n d a r d   l a n g u a g e   c o d e ,   e x   1 0 3 3 . < / s u m m a r y > 
 
         p u b l i c   u s h o r t   L a n g u a g e P r e f e r e n c e   {   g e t ;   s e t ;   } 
 
         p u b l i c   s t r i n g   L a s t N a m e   {   g e t ;   s e t ;   } 
 
         p u b l i c   s t r i n g   O c c u p a t i o n   {   g e t ;   s e t ;   } 
 
         p u b l i c   s t r i n g   P o s t a l C o d e   {   g e t ;   s e t ;   } 
 
         p u b l i c   l o n g   P u i d   {   g e t ;   s e t ;   } 
 
         / / /   < s u m m a r y > R e g i o n   i s   n o t   u n d e r s t o o d . < / s u m m a r y > 
 
         p u b l i c   u i n t   R e g i o n   {   g e t ;   s e t ;   } 
 
         p u b l i c   u s h o r t   T i m e z o n e   {   g e t ;   s e t ;   } 
 
         p u b l i c   u i n t   V e r s i o n   {   g e t ;   s e t ;   } 
 
 
 
         # e n d r e g i o n 
 
 
 
         # r e g i o n   U s e f u l   T i c k e t   P r o p e r t i e s 
 
 
 
         / / /   < s u m m a r y > S i m i l a r   t o   t h e   e m a i l   a d d r e s s . < / s u m m a r y > 
 
         p u b l i c   s t r i n g   M e m b e r N a m e   {   g e t ;   s e t ;   } 
 
         p u b l i c   u i n t   S i t e I d   {   g e t ;   s e t ;   } 
 
         p u b l i c   u i n t   A u t h F l a g s   {   g e t ;   s e t ;   } 
 
         p u b l i c   l o n g   C I d   {   g e t ;   s e t ;   } 
 
         p u b l i c   D a t e T i m e   A u t h I n s t a n t   {   g e t ;   s e t ;   } 
 
         p u b l i c   D a t e T i m e   I s s u e I n s t a n t   {   g e t ;   s e t ;   } 
 
         p u b l i c   u i n t   C e r t i f i c a t e V e r s i o n   {   g e t ;   s e t ;   } 
 
         p u b l i c   D a t e T i m e   N o t A f t e r   {   g e t ;   s e t ;   } 
 
         p u b l i c   D a t e T i m e   N o t B e f o r e   {   g e t ;   s e t ;   } 
 
 
 
         p u b l i c   E n v i r o n m e n t E n u m   E n v i r o n m e n t   {   g e t ;   s e t ;   } 
 
 
 
         p u b l i c   P a s s p o r t T i c k e t T y p e   T i c k e t T y p e   {   g e t ;   s e t ;   } 
 
         p u b l i c   s t r i n g   O f f e r D o t A c t i o n   {   g e t ;   s e t ;   } 
 
 
 
         # e n d r e g i o n 
 
 
 
         # r e g i o n   U s e d   f o r   d e l e g a t i o n   t o k e n s   o n l y 
 
 
 
         p u b l i c   l o n g   A p p I d   {   g e t ;   s e t ;   } 
 
         p u b l i c   D a t e T i m e   E x p i r e T i m e   {   g e t ;   s e t ;   } 
 
 
 
         # e n d r e g i o n 
 
 
 
         p u b l i c   T i c k e t P a r a m e t e r s   ( ) 
 
         { 
 
                 S e t D e f a u l t s ( ) ; 
 
         } 
 
 
 
         p u b l i c   v i r t u a l   v o i d   S e t D e f a u l t s   ( ) 
 
         { 
 
                 D a t e T i m e   n o w   =   D a t e T i m e . N o w ; 
 
 
 
                 B i r t h d a y   =   1 8 2 6 4 ; 
 
                 B i r t h d a y P r e c i s i o n   =   2 ; 
 
                 C o u n t r y C o d e   =   " U S " ; 
 
                 D i s p l a y N a m e   =   " D i s p l a y N a m e " ; 
 
                 F i r s t N a m e   =   " F i r s t " ; 
 
                 F l a g s   =   1 0 7 3 7 4 2 4 0 0 ; 
 
                 G e n d e r   =   G e n d e r E n u m . M a l e ; 
 
                 L a n g u a g e P r e f e r e n c e   =   1 0 3 3 ; 
 
                 L a s t N a m e   =   " L a s t " ; 
 
                 O c c u p a t i o n   =   " T e s t   s u b j e c t " ; 
 
                 P o s t a l C o d e   =   " 9 8 0 5 2 " ; 
 
                 P u i d   =   0 ; 
 
                 R e g i o n   =   3 5 8 4 1 ; 
 
                 T i m e z o n e   =   0 ; 
 
                 V e r s i o n   =   1 ; 
 
 
 
                 M e m b e r N a m e   =   " M e m b e r N a m e @ l i v e - i n t . c o m " ; 
 
                 S i t e I d   =   0 ; 
 
                 A u t h F l a g s   =   8 1 9 3 ; 
 
                 C I d   =   0 ; 
 
                 A u t h I n s t a n t   =   n o w ; 
 
                 I s s u e I n s t a n t   =   n o w ; 
 
                 C e r t i f i c a t e V e r s i o n   =   4 5 ; 
 
                 N o t A f t e r   =   n o w . A d d D a y s ( 1 4 ) ; 
 
                 N o t B e f o r e   =   n o w ; 
 
                 E x p i r e T i m e   =   n o w . A d d D a y s ( 1 4 ) ; 
 
 
 
                 E n v i r o n m e n t   =   E n v i r o n m e n t E n u m . X b l o b ; 
 
         } 
 
 } 
 
 
 
 / / /   < s u m m a r y > 
 
 / / /   E x t e n d e d   t i c k e t   p a r a m e t e r s . 
 
 / / /   N o t   c u r r e n t l y   i m p l e m e n t e d . 
 
 / / /   < / s u m m a r y > 
 
 p u b l i c   c l a s s   E x t e n d e d T i c k e t P a r a m e t e r s   :   T i c k e t P a r a m e t e r s 
 
 { 
 
         # r e g i o n   C o m p a c t P r o f i l e   P r o p e r t i e s 
 
 
 
         p u b l i c   u i n t   B e t a S t a t e   {   g e t ;   s e t ;   } 
 
         p u b l i c   s t r i n g   P o d   {   g e t ;   s e t ;   } 
 
         p u b l i c   s t r i n g   R e v I P _ C o u n t r y   {   g e t ;   s e t ;   } 
 
 
 
         # e n d r e g i o n 
 
 
 
         # r e g i o n   C o m p a c t T i c k e t 8 7   P r o p e r t i e s 
 
 
 
         p u b l i c   u i n t   A l i a s V e r s i o n   {   g e t ;   s e t ;   } 
 
         p u b l i c   s t r i n g   C l i e n t I P   {   g e t ;   s e t ;   } 
 
         p u b l i c   b y t e   C r e d e n t i a l C l a s s   {   g e t ;   s e t ;   } 
 
         p u b l i c   l o n g   D e v i c e I D   {   g e t ;   s e t ;   } 
 
         p u b l i c   b y t e   R e p u t a t i o n B y t e 1   {   g e t ;   s e t ;   } 
 
 
 
         # e n d r e g i o n 
 
 
 
         # r e g i o n   C o m p a c t T i c k e t 8 2   P r o p e r t i e s 
 
 
 
         p u b l i c   s t r i n g   A u d i e n c e   {   g e t ;   s e t ;   } 
 
         p u b l i c   b y t e   A u t h M e t h o d   {   g e t ;   s e t ;   } 
 
         p u b l i c   u i n t   L i n k I d H i g h   {   g e t ;   s e t ;   } 
 
         p u b l i c   u i n t   L i n k I d L o w   {   g e t ;   s e t ;   } 
 
         p u b l i c   u i n t   L i n k I d T i m e s t a m p   {   g e t ;   s e t ;   } 
 
         p u b l i c   R P S V e r s i o n   R P S V e r s i o n   {   g e t ;   s e t ;   } 
 
 
 
         # e n d r e g i o n 
 
 } 
 
 
 
 } 
 
 
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\Billing\Filters.cs ===
using System;
using System.Collections;
using System.Collections.Generic;
using StringPair = System.Collections.Generic.KeyValuePair<string, string>;

namespace ServerTestFramework.LiveService.Billing.WebBilling
{
    public class DownloadHistoryFilter : FilterBase
    {
        /// <summary>
        /// Required.
        /// </summary>
        [WebRequestParam("methodName", WebRequestParamType.StandAlone, Requirement.Required)]
        public String methodName = "DownloadHistory";

        /// <summary>
        /// Required.
        /// </summary>
        [WebRequestParam("Locale", WebRequestParamType.NameValuePair, Requirement.Required)]
        public String Locale;

        /// <summary>
        /// Required.
        /// </summary>
        [WebRequestParam("LegalLocale", WebRequestParamType.NameValuePair, Requirement.Required)]
        public String LegalLocale;

        /// <summary>
        /// Required.
        /// </summary>
        [WebRequestParam("Store", WebRequestParamType.NameValuePair, Requirement.Required)]
        public Int32 Store;

        /// <summary>
        /// Required.
        /// </summary>
        [WebRequestParam("PageSize", WebRequestParamType.NameValuePair, Requirement.Required)]
        public Int32 PageSize;

        /// <summary>
        /// Required.
        /// </summary>
        [WebRequestParam("PageNum", WebRequestParamType.NameValuePair, Requirement.Required)]
        public Int32 PageNum;

        /// <summary>
        /// Required.
        /// </summary>
        [WebRequestParam("DetailView", WebRequestParamType.NameValuePair, Requirement.Required)]
        public Int32 DetailView;

        /// <summary>
        /// Required.
        /// Up to 64 MediaTypes may be specified.
        /// </summary>
        [WebRequestParam("MediaTypes", WebRequestParamType.NameValuePair, Requirement.Required)]
        public List<Int32> MediaTypes;

        /// <summary>
        /// Required.
        /// Up to 64 Actions may be specified.
        /// </summary>
        [WebRequestParam("Actions", WebRequestParamType.NameValuePair, Requirement.Required)]
        public List<Int32> Actions;

        /// <summary>
        /// Optional.
        /// </summary>
        [WebRequestParam("OrderBy", WebRequestParamType.NameValuePair, Requirement.Optional, "-1")]
        public Int32 OrderBy = -1;

        /// <summary>
        /// Optional.
        /// </summary>
        [WebRequestParam("OrderDirection", WebRequestParamType.NameValuePair, Requirement.Optional, "-1")]
        public Int32 OrderDirection = -1;
    }

    public class PurchaseHistoryFilter : FilterBase
    {
        /// <summary>
        /// Required.
        /// </summary>
        [WebRequestParam("methodName", WebRequestParamType.StandAlone, Requirement.Required)]
        public String methodName = "PurchaseHistory";

        /// <summary>
        /// Required.
        /// </summary>
        [WebRequestParam("Locale", WebRequestParamType.NameValuePair, Requirement.Required)]
        public String Locale;

        /// <summary>
        /// Required.
        /// </summary>
        [WebRequestParam("LegalLocale", WebRequestParamType.NameValuePair, Requirement.Required)]
        public String LegalLocale;

        /// <summary>
        /// Required.
        /// </summary>
        [WebRequestParam("Store", WebRequestParamType.NameValuePair, Requirement.Required)]
        public Int32 Store;

        /// <summary>
        /// Required.
        /// </summary>
        [WebRequestParam("PageSize", WebRequestParamType.NameValuePair, Requirement.Required)]
        public Int32 PageSize;

        /// <summary>
        /// Required.
        /// </summary>
        [WebRequestParam("PageNum", WebRequestParamType.NameValuePair, Requirement.Required)]
        public Int32 PageNum;

        /// <summary>
        /// Required.
        /// </summary>
        [WebRequestParam("DetailView", WebRequestParamType.NameValuePair, Requirement.Required)]
        public Int32 DetailView;

        /// <summary>
        /// Optional.
        /// Up to 256 MediaIds may be specified.
        /// </summary>
        [WebRequestParam("OfferIds", WebRequestParamType.NameValuePair, Requirement.Optional, null)]
        public List<Guid> OfferIds;

        /// <summary>
        /// Required.
        /// Up to 64 MediaTypes may be specified.
        /// </summary>
        [WebRequestParam("MediaTypes", WebRequestParamType.NameValuePair, Requirement.Required)]
        public List<Int32> MediaTypes;

        /// <summary>
        /// Optional.
        /// </summary>
        [WebRequestParam("OrderBy", WebRequestParamType.NameValuePair, Requirement.Optional, "-1")]
        public Int32 OrderBy = -1;

        /// <summary>
        /// Optional.
        /// </summary>
        [WebRequestParam("OrderDirection", WebRequestParamType.NameValuePair, Requirement.Optional, "-1")]
        public Int32 OrderDirection = -1;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\Billing\BillingWebRequest.cs ===
using System;
using System.Collections.Generic;
using System.Net;
using System.Reflection;
using System.Text;
using StringPair = System.Collections.Generic.KeyValuePair<string, string>;

using xonline.common.service;

namespace ServerTestFramework.LiveService.Billing.WebBilling
{
    public abstract class BillingWebRequest : FilterWebRequest
    {
        public const string BILLING_BASE_URL = "/xbos/billing.asmx/";
        public const string HISTORY_BASE_URL = "/xbos/history.asmx/";

        public static class BillingOperation
        {
            public static readonly string PurchaseOffers = "PurchaseOffers";
            public static readonly string PurchaseMediaOffers = "PurchaseMediaOffers";
            public static readonly string GetPurchaseStatus = "GetPurchaseStatus";
            public static readonly string Query = "Query";
            public static readonly string Execute = "Execute";
        }

        public static class HistoryMethod
        {
            public static readonly string PurchaseHistory = "PurchaseHistory";
            public static readonly string DownloadHistory = "DownloadHistory";
        }

        public BillingWebRequest(string basePath, string operation)
            : base(basePath, operation)
        {
        }

        public BillingWebRequest(String basePath, String operation, FilterBase filter)
            : base(basePath, operation, filter)
        {
        }
                
        public bool SendRequest(ulong passportPuid)
        {
            if (Headers == null)
            {
                Headers = new WebHeaderCollection();
            }

            ServerTestFramework.LiveService.FakeAAInfoNameSpace.FakeAAInfo fAAInfo = new ServerTestFramework.LiveService.FakeAAInfoNameSpace.FakeAAInfo(passportPuid);
            Headers.Add(XHttpHdr.AUTHZ, fAAInfo.ConvertToHttpHeaderValue());

            return SendRequest();
        }

        public override bool SendRequest()
        {
            return SendRequest(Global.XEnv.GetVirtualInterface(xonline.common.config.Interface.xbos_billing_offering));
        }
    }

    public class PurchaseOffersWebRequest : BillingWebRequest
    {
        [WebRequestParam("userPuid", WebRequestParamType.StandAlone)]
        public ulong UserPuid;
        [WebRequestParam("machinePuid", WebRequestParamType.StandAlone)]
        public ulong MachinePuid;
        [WebRequestParam("ipAddress", WebRequestParamType.StandAlone)]
        public string IPAddress;
        [WebRequestParam("offerIds", WebRequestParamType.StandAlone)]
        public Guid[] OfferIds;
        [WebRequestParam("expectedPrices", WebRequestParamType.StandAlone)]
        public uint[] ExpectedPrices;
        [WebRequestParam("paymentType", WebRequestParamType.StandAlone)]
        public uint PaymentType;
        [WebRequestParam("paymentInstrumentId", WebRequestParamType.StandAlone)]
        public string PaymentInstrumentId;
        [WebRequestParam("billingToken", WebRequestParamType.StandAlone)]
        public string BillingToken;
        [WebRequestParam("storeId", WebRequestParamType.StandAlone)]
        public uint StoreId = 2;

        public PurchaseOffersWebRequest()
            : base(BILLING_BASE_URL, BillingOperation.PurchaseOffers)
        {
            this.UseSSL = true;
        }
    }

    public class PurchaseMediaOffersWebRequest : BillingWebRequest
    {
        [WebRequestParam("userPuid", WebRequestParamType.StandAlone)]
        public ulong UserPuid;
        [WebRequestParam("machinePuid", WebRequestParamType.StandAlone)]
        public ulong MachinePuid;
        [WebRequestParam("offerIds", WebRequestParamType.StandAlone)]
        public Guid[] OfferIds;
        [WebRequestParam("mediaTypes", WebRequestParamType.StandAlone)]
        public int[] MediaTypes;
        [WebRequestParam("expectedPrices", WebRequestParamType.StandAlone)]
        public uint[] ExpectedPrices;
        [WebRequestParam("paymentType", WebRequestParamType.StandAlone)]
        public uint PaymentType;
        [WebRequestParam("paymentInstrumentId", WebRequestParamType.StandAlone)]
        public string PaymentInstrumentId;
        [WebRequestParam("billingToken", WebRequestParamType.StandAlone)]
        public string BillingToken;
        [WebRequestParam("storeId", WebRequestParamType.StandAlone)]
        public uint StoreId = 2;

        public PurchaseMediaOffersWebRequest()
            : base(BILLING_BASE_URL, BillingOperation.PurchaseMediaOffers)
        {
            this.UseSSL = true;
        }
    }

    public class PurchaseHistoryWebRequest : BillingWebRequest
    {
        [WebRequestParam("userPuid", WebRequestParamType.StandAlone)]
        public ulong UserPuid;
        [WebRequestParam("machinePuid", WebRequestParamType.StandAlone)]
        public ulong MachinePuid;
        [WebRequestParam("methodName", WebRequestParamType.StandAlone)]
        public string MethodName;

        public PurchaseHistoryWebRequest()
            : base(HISTORY_BASE_URL, BillingOperation.Query)
        {
            MethodName = HistoryMethod.PurchaseHistory;
            this.UseSSL = true;
        }

        public PurchaseHistoryFilter Filter
        {
            get { return baseFilter as PurchaseHistoryFilter; }
        }

        [Obsolete("This method is obsolete in favor of directly passing the filter", true)]
        public PurchaseHistoryWebRequest(ulong userPuid, ulong machinePuid, List<StringPair> filterList)
            : this()
        {
            UserPuid = userPuid;
            MachinePuid = machinePuid;

            System.Collections.Hashtable t = new System.Collections.Hashtable();
            foreach (StringPair pair in filterList)
            {
                t.Add(pair.Key, pair.Value);
            }

            baseFilter = new PurchaseHistoryFilter();
            baseFilter.BuildFilter(t);            
        }

        public PurchaseHistoryWebRequest(ulong userPuid, ulong machinePuid, PurchaseHistoryFilter filter)
            : this()
        {
            UserPuid = userPuid;
            MachinePuid = machinePuid;

            this.baseFilter = filter;
        }
    }
    
    public class BillingWebResponse : WebResponseBase
    {
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\Auth\RPSTicketGen\TicketGen.cs ===
u s i n g   S y s t e m ; 
 
 u s i n g   S y s t e m . C o l l e c t i o n s . G e n e r i c ; 
 
 
 
 u s i n g   R P S E m u l a t o r ; 
 
 
 
 n a m e s p a c e   S e r v e r T e s t F r a m e w o r k . L i v e S e r v i c e . A u t h . R P S T i c k e t G e n 
 
 { 
 
 
 
 p u b l i c   s t a t i c   c l a s s   T i c k e t G e n 
 
 { 
 
         s t a t i c   T i c k e t G e n   ( ) 
 
         { 
 
                 L o a d e r . I n i t ( ) ; 
 
         } 
 
 
 
         # r e g i o n   P u b l i c   H e l p e r s 
 
 
 
         p u b l i c   s t a t i c   l o n g   C o m p u t e C I d   ( l o n g   p u i d ,   D a t e T i m e   p u i d C r e a t i o n ) 
 
         { 
 
                 / /   s o   n o t   a   m e m b e r   f u n c t i o n . . . 
 
                 r e t u r n   ( n e w   C o m p a c t T i c k e t 8 7 ( ) ) . G e t C I D F r o m P u i d ( p u i d ,   p u i d C r e a t i o n ) ; 
 
         } 
 
 
 
         # e n d r e g i o n 
 
 
 
         # r e g i o n   T i c k e t   G e n 
 
 
 
         p u b l i c   s t a t i c   s t r i n g   G e n e r a t e T i c k e t   ( T i c k e t P a r a m e t e r s   t i c k e t P a r a m s ) 
 
         { 
 
                 s t r i n g   t i c k e t ; 
 
                 L o a d e r . S e t P a r t n e r C e r t i f i c a t e ( t i c k e t P a r a m s . E n v i r o n m e n t ) ; 
 
                 i f   ( t i c k e t P a r a m s . T i c k e t T y p e   = =   T i c k e t P a r a m e t e r s . P a s s p o r t T i c k e t T y p e . C o m p a c t ) 
 
                 { 
 
                         C o m p a c t P r o f i l e   c p   =   C o p y P a r a m e t e r s T o P r o f i l e ( t i c k e t P a r a m s ) ; 
 
                         C o m p a c t T i c k e t 8 7   c p 8 7   =   C o p y P a r a m e t e r s T o T i c k e t 8 7 ( t i c k e t P a r a m s ) ; 
 
                         c p 8 7 . P r o f i l e   =   c p ; 
 
 
 
                         t i c k e t   =   n e w   s t r i n g ( c p 8 7 . G e t E n c r y p t e d D a t a B a s e 6 4 ( ) ) ; 
 
                 } 
 
                 e l s e 
 
                 { 
 
                         D e l e g a t i o n C o m p a c t T i c k e t 8 5   d c t 8 5   =   C o p y P a r a m e t e r s T o D e l e g a t i o n T i c k e t 8 5 ( t i c k e t P a r a m s ) ;                         
 
                         t i c k e t   =   n e w   s t r i n g ( d c t 8 5 . G e t E n c r y p t e d D a t a B a s e 6 4 ( ) ) ; 
 
                 } 
 
                 r e t u r n   t i c k e t ; 
 
         } 
 
 
 
         p u b l i c   s t a t i c   v o i d   G e n e r a t e T i c k e t B y t e s   ( T i c k e t P a r a m e t e r s   t i c k e t P a r a m s ,   o u t   b y t e [ ]   t i c k e t B y t e s ,   o u t   b y t e [ ]   s e s s i o n K e y ) 
 
         { 
 
                 L o a d e r . S e t P a r t n e r C e r t i f i c a t e ( t i c k e t P a r a m s . E n v i r o n m e n t ) ; 
 
 
 
                 t i c k e t B y t e s   =   n u l l ; 
 
                 s e s s i o n K e y   =   n u l l ; 
 
 
 
                 C o m p a c t P r o f i l e   c p   =   C o p y P a r a m e t e r s T o P r o f i l e ( t i c k e t P a r a m s ) ; 
 
                 C o m p a c t T i c k e t 8 7   c p 8 7   =   C o p y P a r a m e t e r s T o T i c k e t 8 7 ( t i c k e t P a r a m s ) ; 
 
                 c p 8 7 . P r o f i l e   =   c p ; 
 
 
 
                 t i c k e t B y t e s   =   c p 8 7 . G e t E n c r y p t e d D a t a ( ) ; 
 
                 s e s s i o n K e y   =   c p 8 7 . S e s s i o n K e y ; 
 
         } 
 
 
 
         # e n d r e g i o n 
 
 
 
         # r e g i o n   P r i v a t e   H e l p e r s 
 
 
 
         p r i v a t e   s t a t i c   C o m p a c t P r o f i l e   C o p y P a r a m e t e r s T o P r o f i l e   ( T i c k e t P a r a m e t e r s   t i c k e t P a r a m s ) 
 
         { 
 
                 C o m p a c t P r o f i l e   c p   =   n e w   C o m p a c t P r o f i l e ( ) ; 
 
 
 
                 c p . B i r t h d a y   =   t i c k e t P a r a m s . B i r t h d a y ; 
 
                 c p . B i r t h d a y P r e c i s i o n   =   t i c k e t P a r a m s . B i r t h d a y P r e c i s i o n ; 
 
                 c p . C o u n t r y C o d e   =   t i c k e t P a r a m s . C o u n t r y C o d e ; 
 
                 c p . D i s p l a y N a m e   =   t i c k e t P a r a m s . D i s p l a y N a m e ; 
 
                 c p . F i r s t n a m e   =   t i c k e t P a r a m s . F i r s t N a m e ; 
 
                 c p . F l a g s   =   t i c k e t P a r a m s . F l a g s ; 
 
                 c p . G e n d e r   =   ( t i c k e t P a r a m s . G e n d e r   = =   T i c k e t P a r a m e t e r s . G e n d e r E n u m . M a l e   ?   ' m '   :   ' f ' ) ; 
 
                 c p . L a n g u a g e P r e f e r e n c e   =   t i c k e t P a r a m s . L a n g u a g e P r e f e r e n c e ; 
 
                 c p . L a s t n a m e   =   t i c k e t P a r a m s . L a s t N a m e ; 
 
                 c p . O c c u p a t i o n   =   t i c k e t P a r a m s . O c c u p a t i o n ; 
 
                 c p . P o s t a l C o d e   =   t i c k e t P a r a m s . P o s t a l C o d e ; 
 
                 c p . P u i d   =   t i c k e t P a r a m s . P u i d ; 
 
                 c p . R e g i o n   =   t i c k e t P a r a m s . R e g i o n ; 
 
                 c p . T i m e z o n e   =   t i c k e t P a r a m s . T i m e z o n e ; 
 
                 c p . V e r s i o n   =   t i c k e t P a r a m s . V e r s i o n ; 
 
 
 
                 r e t u r n   c p ; 
 
         } 
 
 
 
         p r i v a t e   s t a t i c   C o m p a c t T i c k e t 8 7   C o p y P a r a m e t e r s T o T i c k e t 8 7   ( T i c k e t P a r a m e t e r s   t i c k e t P a r a m s ) 
 
         { 
 
                 C o m p a c t T i c k e t 8 7   c p 8 7   =   n e w   C o m p a c t T i c k e t 8 7 ( ) ; 
 
 
 
                 c p 8 7 . M e m b e r N a m e   =   t i c k e t P a r a m s . M e m b e r N a m e ; 
 
                 c p 8 7 . P u i d   =   t i c k e t P a r a m s . P u i d ; 
 
                 c p 8 7 . T a r g e t I d   =   t i c k e t P a r a m s . S i t e I d ; 
 
                 c p 8 7 . A u t h F l a g s   =   t i c k e t P a r a m s . A u t h F l a g s ; 
 
                 c p 8 7 . C i d   =   t i c k e t P a r a m s . C I d ; 
 
                 c p 8 7 . A u t h I n s t a n t   =   t i c k e t P a r a m s . A u t h I n s t a n t ; 
 
                 c p 8 7 . I s s u e I n s t a n t   =   t i c k e t P a r a m s . I s s u e I n s t a n t ; 
 
                 c p 8 7 . C e r t i f i c a t e V e r s i o n   =   t i c k e t P a r a m s . C e r t i f i c a t e V e r s i o n ; 
 
                 c p 8 7 . N o t A f t e r   =   R P S U t i l i t i e s . D a t e T i m e T o U n i x T i m e ( t i c k e t P a r a m s . N o t A f t e r ) ; 
 
                 c p 8 7 . N o t B e f o r e   =   R P S U t i l i t i e s . D a t e T i m e T o U n i x T i m e ( t i c k e t P a r a m s . N o t B e f o r e ) ; 
 
 
 
                 r e t u r n   c p 8 7 ; 
 
         } 
 
 
 
         p r i v a t e   s t a t i c   D e l e g a t i o n C o m p a c t T i c k e t 8 5   C o p y P a r a m e t e r s T o D e l e g a t i o n T i c k e t 8 5 ( T i c k e t P a r a m e t e r s   t i c k e t P a r a m s ) 
 
         { 
 
                 D e l e g a t i o n C o m p a c t T i c k e t 8 5   d c t 8 5   =   n e w   D e l e g a t i o n C o m p a c t T i c k e t 8 5 ( ) ; 
 
 
 
                 d c t 8 5 . M e m b e r N a m e   =   t i c k e t P a r a m s . M e m b e r N a m e ; 
 
                 d c t 8 5 . P u i d   =   t i c k e t P a r a m s . P u i d ; 
 
                 d c t 8 5 . T a r g e t I d   =   t i c k e t P a r a m s . S i t e I d ; 
 
                 d c t 8 5 . C i d   =   t i c k e t P a r a m s . C I d ; 
 
                 d c t 8 5 . A u t h I n s t a n t   =   t i c k e t P a r a m s . A u t h I n s t a n t ; 
 
                 d c t 8 5 . I s s u e I n s t a n t   =   t i c k e t P a r a m s . I s s u e I n s t a n t ; 
 
                 d c t 8 5 . C e r t i f i c a t e V e r s i o n   =   t i c k e t P a r a m s . C e r t i f i c a t e V e r s i o n ; 
 
                 d c t 8 5 . P e r m i s s i o n s   =   G e t P e r m i s s i o n s ( t i c k e t P a r a m s . O f f e r D o t A c t i o n ) ; 
 
                 d c t 8 5 . A p p i d   =   t i c k e t P a r a m s . A p p I d ; 
 
                 d c t 8 5 . E x p i r y T i m e   =   R P S U t i l i t i e s . D a t e T i m e T o U n i x T i m e ( t i c k e t P a r a m s . E x p i r e T i m e ) ; 
 
 
 
                 r e t u r n   d c t 8 5 ; 
 
         } 
 
 
 
         p r i v a t e   s t a t i c   u s h o r t   G e t O f f e r A c t i o n H a s h ( s t r i n g   o f f e r D o t A c t i o n N a m e ) 
 
         { 
 
                 u i n t   n H a s h   =   0 ; 
 
                 o f f e r D o t A c t i o n N a m e   =   o f f e r D o t A c t i o n N a m e . T o L o w e r ( ) ; 
 
                 i n t   n L e n g t h   =   o f f e r D o t A c t i o n N a m e . L e n g t h ; 
 
                 f o r   ( i n t   i = 0 ;   i < n L e n g t h ;   + + i ) 
 
                 { 
 
                         n H a s h   =   ( u i n t ) ( ( n H a s h < < 5 )   +   n H a s h   +   ( i n t ) o f f e r D o t A c t i o n N a m e [ i ] ) ; 
 
                 } 
 
 
 
                 u s h o r t   w H a s h   =   ( u s h o r t ) ( n H a s h & 0 x f f f f ) ; 
 
                 w H a s h   ^ =   ( u s h o r t ) ( ( n H a s h > > 1 6 ) & 0 x f f f f ) ; 
 
                 r e t u r n   w H a s h ; 
 
         } 
 
 
 
         p r i v a t e   s t a t i c   b y t e [ ]   G e t P e r m i s s i o n s ( s t r i n g   o f f e r A c t i o n N a m e )         
 
         { 
 
                 L i s t < b y t e >   b y t e s   =   n e w   L i s t < b y t e > ( ) ; 
 
                 b y t e s . A d d ( s i z e o f ( b y t e )   +   s i z e o f ( s h o r t )   +   s i z e o f ( b y t e ) ) ;   / / E l e m e n t   s i z e 
 
                 b y t e s . A d d R a n g e ( B i t C o n v e r t e r . G e t B y t e s ( G e t O f f e r A c t i o n H a s h ( o f f e r A c t i o n N a m e ) ) ) ;   / / O f f e r a c t i o n   h a s h 
 
                 b y t e s . A d d ( ( b y t e ) 0 ) ;   / / O p t i o n   m a s k 
 
                 / / b y t e s . A d d R a n g e ( B i t C o n v e r t e r . G e t B y t e s ( ( u l o n g ) 0 ) ) ;   / / 
 
 
 
                 r e t u r n   b y t e s . T o A r r a y ( ) ; 
 
         } 
 
         # e n d r e g i o n 
 
 } 
 
 
 
 } 
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\Auth\RPSTicketGen\Loader.cs ===
u s i n g   S y s t e m ; 
 
 u s i n g   S y s t e m . I O ; 
 
 u s i n g   S y s t e m . R e f l e c t i o n ; 
 
 u s i n g   S y s t e m . S e c u r i t y . C r y p t o g r a p h y . X 5 0 9 C e r t i f i c a t e s ; 
 
 u s i n g   S y s t e m . T e x t ; 
 
 
 
 n a m e s p a c e   S e r v e r T e s t F r a m e w o r k . L i v e S e r v i c e . A u t h . R P S T i c k e t G e n 
 
 { 
 
 
 
 / / /   < s u m m a r y > 
 
 / / /   D e p l o y s   o u r   c o n t a i n e d   r e s o u r c e s   t o   a   t e m p   l o c a t i o n   a n d   l o a d s   t h e m   w h e n   n e e d e d . 
 
 / / /   < / s u m m a r y > 
 
 p u b l i c   s t a t i c   c l a s s   L o a d e r 
 
 { 
 
         p u b l i c   s t a t i c   v o i d   I n i t   ( ) 
 
         { 
 
                 A p p D o m a i n . C u r r e n t D o m a i n . A s s e m b l y R e s o l v e   + =   F i n d A s s e m ; 
 
                 S e t C e r t i f i c a t e s ( ) ; 
 
         } 
 
 
 
         p r i v a t e   c o n s t   s t r i n g   R e s o u r c e B a s e   =   " A u t h . R P S T i c k e t G e n . " ; 
 
 
 
         p u b l i c   s t a t i c   A s s e m b l y   F i n d A s s e m   ( o b j e c t   s e n d e r ,   R e s o l v e E v e n t A r g s   a r g s ) 
 
         { 
 
                 s t r i n g   s i m p l e N a m e   =   n e w   A s s e m b l y N a m e ( a r g s . N a m e ) . N a m e ; 
 
 
 
                 i f   ( s i m p l e N a m e   = =   " R P S E m u l a t o r " ) 
 
                 { 
 
                         b y t e [ ]   d l l B y t e s   =   G e t R e s o u r c e ( " R P S E m u l a t o r . d l l " ) ; 
 
                         A s s e m b l y   a n s   =   A s s e m b l y . L o a d ( d l l B y t e s ) ; 
 
 
 
                         / /   r e m o v e   o u r s e l f   f r o m   t h e   r e s o l v e   e v e n t ,   t h i s   a p p d o m a i n   i s   d o n e 
 
                         A p p D o m a i n . C u r r e n t D o m a i n . A s s e m b l y R e s o l v e   - =   F i n d A s s e m ; 
 
 
 
                         r e t u r n   a n s ; 
 
                 } 
 
 
 
                 r e t u r n   n u l l ; 
 
         } 
 
 
 
         p r i v a t e   s t a t i c   v o i d   S e t C e r t i f i c a t e s   ( ) 
 
         { 
 
                 / /   I n   o r d e r   f o r   t h e s e   t o   w o r k ,   a   v e r y   s t r a i g h t f o r w a r d   s e t   w a s   a d d e d   t o   t h e s e   p r o p e r t i e s 
 
                 / /   T h e s e   p r o p e r t i e s   w e r e   i n   u t i l i t i e s \ R P S U t i l i t i e s . c s   6 / 2 0 1 0 
 
 
 
                 / / p u b l i c   s t a t i c   X 5 0 9 C e r t i f i c a t e 2   P a r t n e r C e r t i f i c a t e 
 
                 / / { 
 
                 / /         s e t 
 
                 / /         { 
 
                 / /                 p a r t n e r C e r t i f i c a t e   =   v a l u e ; 
 
                 / /         } 
 
                 / /         . . . 
 
                 / / } 
 
 
 
                 / / p u b l i c   s t a t i c   X 5 0 9 C e r t i f i c a t e 2   R P S C e r t i f i c a t e 
 
                 / / { 
 
                 / /         s e t 
 
                 / /         { 
 
                 / /                 r p s C e r t i f i c a t e   =   v a l u e ; 
 
                 / /         } 
 
                 / /         . . . 
 
                 / / } 
 
 
 
                 b y t e [ ]   r p s C e r t B y t e s   =   G e t R e s o u r c e ( " s t s . p f x " ) ; 
 
                 R P S E m u l a t o r . R P S U t i l i t i e s . R P S C e r t i f i c a t e   =   n e w   X 5 0 9 C e r t i f i c a t e 2 ( r p s C e r t B y t e s ,   " h o m e r r o c k s " ) ; 
 
 
 
                 _ e n v   =   T i c k e t P a r a m e t e r s . E n v i r o n m e n t E n u m . X b l o b ; 
 
                 b y t e [ ]   p a r t n e r C e r t B y t e s   =   G e t R e s o u r c e ( " R P S D E K . x b o x l i v e . c o m . c e r " ) ; 
 
                 R P S E m u l a t o r . R P S U t i l i t i e s . P a r t n e r C e r t i f i c a t e   =   n e w   X 5 0 9 C e r t i f i c a t e 2 ( p a r t n e r C e r t B y t e s ) ; 
 
         } 
 
 
 
         p r i v a t e   s t a t i c   T i c k e t P a r a m e t e r s . E n v i r o n m e n t E n u m   _ e n v ; 
 
 
 
         p u b l i c   s t a t i c   v o i d   S e t P a r t n e r C e r t i f i c a t e   ( T i c k e t P a r a m e t e r s . E n v i r o n m e n t E n u m   e n v i r o n m e n t ) 
 
         { 
 
                 i f   ( e n v i r o n m e n t   = =   _ e n v ) 
 
                 { 
 
                         r e t u r n ; 
 
                 } 
 
 
 
                 _ e n v   =   e n v i r o n m e n t ; 
 
 
 
                 s w i t c h   ( _ e n v ) 
 
                 { 
 
                         c a s e   T i c k e t P a r a m e t e r s . E n v i r o n m e n t E n u m . X b l o b : 
 
                                 { 
 
                                         R P S E m u l a t o r . R P S U t i l i t i e s . P a r t n e r C e r t i f i c a t e   =   n e w   X 5 0 9 C e r t i f i c a t e 2 ( G e t R e s o u r c e ( " R P S D E K . x b o x l i v e . c o m . c e r " ) ) ; 
 
                                 } 
 
                                 b r e a k ; 
 
 
 
                         c a s e   T i c k e t P a r a m e t e r s . E n v i r o n m e n t E n u m . I n t R p s : 
 
                                 { 
 
                                         R P S E m u l a t o r . R P S U t i l i t i e s . P a r t n e r C e r t i f i c a t e   =   n e w   X 5 0 9 C e r t i f i c a t e 2 ( G e t R e s o u r c e ( " i n t - r p s . x b o x l i v e . c o m . c e r " ) ) ; 
 
                                 } 
 
                                 b r e a k ; 
 
 
 
                         c a s e   T i c k e t P a r a m e t e r s . E n v i r o n m e n t E n u m . I n t X b o x C o m : 
 
                                 { 
 
                                         R P S E m u l a t o r . R P S U t i l i t i e s . P a r t n e r C e r t i f i c a t e   =   n e w   X 5 0 9 C e r t i f i c a t e 2 ( G e t R e s o u r c e ( " i n t - r p s . x b o x . c o m . c e r " ) ) ; 
 
                                 } 
 
                                 b r e a k ; 
 
                 } 
 
         } 
 
 
 
         p r i v a t e   s t a t i c   b y t e [ ]   G e t R e s o u r c e   ( s t r i n g   f i l e N a m e ) 
 
         { 
 
                 u s i n g   ( S t r e a m   s t r e a m   =   A s s e m b l y . G e t E x e c u t i n g A s s e m b l y ( ) . G e t M a n i f e s t R e s o u r c e S t r e a m ( R e s o u r c e B a s e   +   f i l e N a m e ) ) 
 
                 { 
 
                         b y t e [ ]   b y t e s   =   n e w   b y t e [ s t r e a m . L e n g t h ] ; 
 
                         s t r e a m . R e a d ( b y t e s ,   0 ,   b y t e s . L e n g t h ) ; 
 
                         r e t u r n   b y t e s ; 
 
                 } 
 
         } 
 
 } 
 
 
 
 } 
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\Billing\SharedBillingStructures.cs ===
using System;
using System.Collections.Generic;
using System.Net;
using System.Text;

using xonline.common.config;
using xonline.common.service;

namespace ServerTestFramework.LiveService.Billing
{
    // In this file we store any structures which may be shared between
    // XRLs. This makes it easier if we need to change structures.

    public class BasicContentInfo : XRLPayload
    {
        static ushort UserHasPurchased          = 0x0001;
        static ushort UserHasViewed             = 0x0002;
        static ushort IsUnrestricted            = 0x0004;
        static ushort IsRecentContent      = 0x0008;

        public BasicContentInfo()
        {
            ResponseFlags = 0;
        }

        public ulong OfferID;

        [WireInfo(MinSchemaVersion = "2.0")]
        public ulong PreviewOfferID;

        public ushort OfferNameLength;
        [WireInfo(SizeParam="OfferNameLength")]
        public string OfferName;
        public uint OfferType;
        [WireInfo(ArraySize=(int)XOn.XONLINE_CONTENT_ID_LEN)]
        public byte[] ContentId;
        
        [WireInfo(MinSchemaVersion = "2.0")]
        public uint LicenseMask;

        public uint TitleID;
        public uint TitleCategory;
        public ushort TitleNameLength;
        [WireInfo(SizeParam="TitleNameLength")]
        public string TitleName;
        public byte TierRequired;
        public ushort GameRating;
        public ushort ResponseFlags; // userHasPurchased, userHasViewed
        public uint PackageSize;
        public uint InstallSize;
        public int SellTextLength;
        [WireInfo(SizeParam="SellTextLength")]
        public string SellText;

        [WireInfo(MinSchemaVersion = "2.0")]
        public uint AssetID;

        [WireInfo(MinSchemaVersion = "2.0")]
        public uint PurchaseQuantity;

        public byte PricesLength;
        [WireInfo(SizeParam="PricesLength")]
        public OfferPrice[] Prices;
        
        public bool userHasPurchased
        {
            get
            {
                return IsFlagSet(UserHasPurchased, ResponseFlags);
            }
            set
            {
                SetFlag(UserHasPurchased, value, ref ResponseFlags);
            }
        }

        public bool userHasViewed
        {
            get
            {
                return IsFlagSet(UserHasViewed, ResponseFlags);
            }
            set
            {
                SetFlag(UserHasViewed, value, ref ResponseFlags);
            }
        }

        public bool isUnrestricted
        {
            get
            {
                return IsFlagSet(IsUnrestricted, ResponseFlags);
            }
            set
            {
                SetFlag(IsUnrestricted, value, ref ResponseFlags);
            }
        }

        public bool isRecentContent
        {
            get
            {
                return IsFlagSet(IsRecentContent, ResponseFlags);
            }
            set
            {
                SetFlag(IsRecentContent, value, ref ResponseFlags);
            }
        }
    }


    public class OfferPrice : XRLPayload
    {
        public uint PaymentType;
        public byte TaxType;
        public int WholePrice;
        public int FractionalPrice;
        public ushort PriceTextLength;
        [WireInfo(SizeParam="PriceTextLength")]
        public string PriceText;
    }


    public class BasicSubscriptionInfo : XRLPayload
    {
        static ushort UserIsSubscribed          = 0x0001;
        static ushort UserHasCancelled          = 0x0002;

        
        public BasicSubscriptionInfo()
        {
            ResponseFlags = 0;
        }


        public ulong OfferID;
        public ushort OfferNameLength;
        [WireInfo(SizeParam="OfferNameLength")]
        public string OfferName;
        public uint OfferType;
        public byte RelationType;
        public byte ConvertMode;
        public ushort InstanceIDLength;
        [WireInfo(SizeParam="InstanceIDLength")]
        public string InstanceID;
        public uint TitleID;
        public uint TitleCategory;
        public ushort TitleNameLength;
        [WireInfo(SizeParam="TitleNameLength")]
        public string TitleName;
        public ushort GameRating;
        public byte Duration;
        public byte Frequency;
        public byte TierProvided;
        public byte TierRequired;
        public int SellTextLength;
        [WireInfo(SizeParam="SellTextLength")]
        public string SellText;
        public ulong RelatedOfferID;
        public ushort ResponseFlags; // userIsSubscribed | userHasCancelled

        public byte PricesLength;
        [WireInfo(SizeParam="PricesLength")]
        public OfferPrice [] Prices;

        public bool userIsSubscribed
        {
            get
            {
                return IsFlagSet(UserIsSubscribed, ResponseFlags);
            }
            set
            {
                SetFlag(UserIsSubscribed, value, ref ResponseFlags);
            }
        }

        public bool userHasCancelled
        {
            get
            {
                return IsFlagSet(UserHasCancelled, ResponseFlags);
            }
            set
            {
                SetFlag(UserHasCancelled, value, ref ResponseFlags);
            }
        }
    }  


    public class Asset : WireData
    {
        public uint AssetID;
        public int Quantity;	// signed quantity, may be negative during Consume

        public Asset()
        {
            AssetID = uint.MaxValue;
            Quantity = int.MinValue;
        }

        public Asset(uint assetID, int q)
        {
            AssetID = assetID;
            Quantity = q;
        }

        public Asset Clone()
        {
            Asset newAsset = new Asset();
            newAsset.AssetID = this.AssetID;
            newAsset.Quantity = this.Quantity;
            return newAsset;
        }
    }

    public class XRLBasicContentHistoryInfo : XRLPayload
    {
        static ushort IsAcquirable              = 0x0001;
        static ushort IsUnrestricted            = 0x0002;

        public XRLBasicContentHistoryInfo()
        {
            ResponseFlags = 0;
        }

        public ulong OfferID;

        public ushort OfferNameLength;
        [WireInfo(SizeParam="OfferNameLength")]
        public string OfferName;
        public uint OfferType;

        public uint TitleID;
        public ushort TitleNameLength;
        [WireInfo(SizeParam="TitleNameLength")]
        public string TitleName;
        public ushort ResponseFlags; // isAcquirable, isUnrestricted

        public XRLWMID wmid; // WMIS Guid/Type structure (movie/tv episode/tv season) 
        
        [WireInfo(MinSchemaVersion = "3.0")]
        public bool licenseAcknowledged;
        [WireInfo(MinSchemaVersion = "3.0")]
        public DateTime licenseExpiration;
        [WireInfo(MinSchemaVersion = "3.0")]
        public bool licensedOnMachine;

        public bool isAcquirable
        {
            get
            {
                return IsFlagSet(IsAcquirable, ResponseFlags);
            }
            set
            {
                SetFlag(IsAcquirable, value, ref ResponseFlags);
            }
        }

        public bool isUnrestricted
        {
            get
            {
                return IsFlagSet(IsUnrestricted, ResponseFlags);
            }
            set
            {
                SetFlag(IsUnrestricted, value, ref ResponseFlags);
            }
        }
    }

    public class GeoSourceData
    {
        public uint Result = 0;
        public bool UserGeoExempt = false;
        public byte Country = 103;
        public ushort Language = 1;
        public string IpAddress = "65.52.241.145";    // US ip address
        public bool OfferGeoPolicyFlag = false;
        public bool NpdbGeoEnabled = true;
        public bool NpdbAllowAccessOnNulls = true;
        public bool NpdbAllowAccessOnExceptions = true;
        //public bool VideoPreview = false;

        public override string ToString()
        {
            StringBuilder msg = new StringBuilder();
            msg.Append("GeoSourceData details:\n");
            msg.Append("\tResult = " + Result);
            msg.Append("\n\tUserGeoExempt = " + UserGeoExempt);
            msg.Append("\n\tCountry = " + Country);
            msg.Append("\n\tLanguage = " + Language);
            msg.Append("\n\tIPAddress = " + IpAddress);
            msg.Append("\n\tOfferGeoPolicyFlag = " + OfferGeoPolicyFlag);
            msg.Append("\n\tNpdbGeoEnabled = " + NpdbGeoEnabled);
            msg.Append("\n\tNpdbAllowAccessOnNulls = " + NpdbAllowAccessOnNulls);
            msg.Append("\n\tNpdbAllowAccessOnExceptions = " + NpdbAllowAccessOnExceptions);
            //msg.Append("\n\tVideoPreview = " + VideoPreview);

            return msg.ToString();
        }

        public static uint GetIpAddressUInt(string ipAddress)
        {
            // handle the ip address
            IPAddress ip = IPAddress.Parse(ipAddress);
            byte[] addrBytes = ip.GetAddressBytes();
            //int addr = (addrBytes[0] << 24) | (addrBytes[1] << 16) | (addrBytes[2] << 8) | addrBytes[3];
            uint addr =
                ((uint)addrBytes[3] << 24) |
                ((uint)addrBytes[2] << 16) |
                ((uint)addrBytes[1] << 8) |
                ((uint)addrBytes[0] << 0);

            return addr;
        }

        public static List<GeoSourceData> GetGeoSourceData(string[] sourceArray)
        {
            string delimiter = "|";
            List<GeoSourceData> sourceList = new List<GeoSourceData>();

            foreach (string line in sourceArray)
            {
                string[] lines = line.Split(delimiter.ToCharArray());
                GeoSourceData source = new GeoSourceData();
                int i = 0;
                source.Result = Convert.ToUInt32(lines[i++]);
                source.UserGeoExempt = Convert.ToBoolean(Convert.ToInt32((lines[i++])));
                source.Country = Convert.ToByte(lines[i++]);
                source.IpAddress = (lines[i++]);
                source.OfferGeoPolicyFlag = Convert.ToBoolean(Convert.ToInt32((lines[i++])));
                source.NpdbGeoEnabled = Convert.ToBoolean(Convert.ToInt32((lines[i++])));
                source.NpdbAllowAccessOnNulls = Convert.ToBoolean(Convert.ToInt32((lines[i++])));
                source.NpdbAllowAccessOnExceptions = Convert.ToBoolean(Convert.ToInt32((lines[i++])));
                //source.VideoPreview = Convert.ToBoolean(Convert.ToInt32((lines[i++])));

                sourceList.Add(source);
            }
            return sourceList;
        }
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\Billing\VideoCommon.cs ===
using System;
using System.Collections;
using System.Collections.Generic;
using System.Runtime.InteropServices;
using System.Runtime.CompilerServices;
using System.Text;
using ServerTestFramework;
using ServerTestFramework.Database;
using ServerTestFramework.LiveService.UserAccount;
using ServerTestFramework.Utilities;

namespace ServerTestFramework.LiveService.Billing
{
    public enum XboxUserType
    {
        Xbox1,
        XboxCom,
        XenonSilver,
        XenonGold,
        Argo,
        None
    }

    public enum XboxMachineType
    {
        Xbox,
        Xbox360,
        SameAsUser,
        None
    }

    public class VideoChallenge
    {
        const int maxBlockLength = 3000;
        string challenge = null;

        public VideoChallenge(string challenge)
        {
            this.challenge = challenge;
        }

        public static implicit operator XRLXeWmdrmChallengeBlock[](VideoChallenge c)
        {
            return c.ToChallengeBlocks();
        } 

        public XRLXeWmdrmChallengeBlock[] ToChallengeBlocks()
        {
            if(String.IsNullOrEmpty(this.challenge)) throw new ArgumentException("cannot be null or empty","challenge");

            List<XRLXeWmdrmChallengeBlock> result = new List<XRLXeWmdrmChallengeBlock>();
            byte[] challengeBytes = Encoding.Unicode.GetBytes(this.challenge);

            int index  = 0;
            while(challengeBytes.Length > index)
            {
                XRLXeWmdrmChallengeBlock block = new XRLXeWmdrmChallengeBlock();
                block.challengeBlockLength = (ushort)((challengeBytes.Length - index) < maxBlockLength ? challengeBytes.Length - index : maxBlockLength);
                block.challengeBlock = new byte[block.challengeBlockLength];
                Array.Copy(challengeBytes,index,block.challengeBlock,0,block.challengeBlockLength);
                result.Add(block);
                index += maxBlockLength;
            }
            return result.ToArray();
        }

        public override string ToString()
        {
            return this.challenge;
        }
    }

    public class VideoLicense
    {
        string license = null;
        public VideoLicense(string license)
        {
            this.license = license;
        }

    }

    public class VideoClientException : Exception
    {
        public VideoClientException(string message)
            : base(message)
        {
        }


        public VideoClientException(uint hresult, string message)
            : base(message)
        {
            base.HResult = (int)hresult;
        }

        public uint ErrorCode
        {
            get { return (uint)base.HResult; }
        }
    }

    public class VideoClient
    {
        private ulong userId;
        private ulong machineId;
        private byte countryId;
        private ushort languageId;

        // emulator support
        private string alternateDmpUrl;
        private string alternateBillingUrl;
        
        public ulong UserId
        {
            get { return this.userId; }
            set { this.userId = value; }
        }

        public ulong MachineId
        {
            get { return this.machineId; }
            set { this.machineId = value; }
        }

        public byte CountryId
        {
            get { return this.countryId; }
            set { this.countryId = value; }
        }

        public ushort LanguageId
        {
            get { return this.languageId; }
            set { this.languageId = value; }
        }

        public string AlternateDmpUrl 
        {
            get { return this.alternateDmpUrl; }
            set { this.alternateDmpUrl = value; }
        }

        public string AlternateBillingUrl
        {
            get { return this.alternateBillingUrl; }
            set { this.alternateBillingUrl = value; }
        }

        private void AddAlternateUrls(XRLPayload request) 
        {
            if(!String.IsNullOrEmpty(this.alternateDmpUrl))
            {
                request.CustomHeader += this.alternateDmpUrl;
            }

            if (!string.IsNullOrEmpty(this.alternateBillingUrl))
            {
                request.CustomHeader += this.alternateBillingUrl;
            }
        }
        
        
        public VideoClient(XeUser user)
            : this(user.UserPuid,user.MachinePuid,user.CountryId,user.LanguageId)
        {
        }

        public VideoClient(ulong userId, ulong machineId, byte countryId, ushort languageId)
        {
            this.userId = userId;
            this.machineId = machineId;
            this.countryId = countryId;
            this.languageId = languageId;
        }

        public string AcquireLicense(XRLWMID wmid, out string license)
        {
            return this.AcquireLicense(wmid,"",out license);
        }

        public string AcquireLicense(XRLWMID wmid, string challenge, out string license)
        {
            return AcquireLicense(wmid, challenge, 0, 0, out license);
        }

        public string AcquireLicense(XRLWMID wmid, string challenge, uint ipUInt, uint errorCode, out string license)
        {
            return AcquireLicense(wmid, new VideoChallenge(challenge), ipUInt, errorCode, out license);
        }

        public string AcquireLicense(XRLWMID wmid, VideoChallenge challenge, out string license)
        {
            return AcquireLicense(wmid, challenge, 0, 0, out license);
        }

        public string AcquireLicense(XRLWMID wmid, VideoChallenge challenge, uint ipUInt, uint errorCode, out string license)
        {
            license = String.Empty;

            XRLXeAcquireVideoLicenseRequest request = new XRLXeAcquireVideoLicenseRequest();
            request.userPuid = this.userId;
            request.countryID = this.countryId;
            request.machinePuid = this.machineId;
            request.wmid = wmid;

            if(challenge != null)
            {
                request.challengeBlocks = challenge;
                request.challengeBlockCount = (ushort)request.challengeBlocks.Length;
            }
            
            AddAlternateUrls(request);
            
            // enable manual slot 
            if (ipUInt > 0)
            {
                request.ManualPopulateSlot();
                request.Slot.ipaI = ipUInt;
                request.Slot.ipportI = 0xffff;
            }

            XRLXeAcquireVideoLicenseResponse response = null;
            bool ret = request.Execute(out response);
            if (errorCode != 0)
            {
                if (ret)
                    throw new UnexpectedTestResultException("XRLXeAcquireVideoLicenseRequest should have failed.");
                ValueCheck.TestHR ("request.XErr", errorCode, request.XErr);
            }
            else
            {
                if (!ret)
                    throw new UnexpectedTestResultException("XRLXeAcquireVideoLicenseRequest failed: " + request.GetDumpString());
                ValueCheck.TestHR("request.XErr", HResult.S_OK, request.XErr);

                license = LicenseBlocksToString(response.licenseBlocks);
                return response.contentURL;
            }

            license = null;
            return null;
        }

        public void AcknowledgeLicenseDelivery(XRLWMID wmid)
        {
            AcknowledgeLicenseDelivery(wmid, 0);
        }
        
        public void AcknowledgeLicenseDelivery(XRLWMID wmid, uint errorCode)
        {
            XRLXeAcknowledgeLicenseDeliveryRequest request = new XRLXeAcknowledgeLicenseDeliveryRequest();
            request.userPuid = this.userId;
            request.machinePuid = this.machineId;
            request.wmid = wmid;

            XRLXeAcknowledgeLicenseDeliveryResponse response = null;
            bool ret = request.Execute(out response);
            if (errorCode != 0)
            {
                if (ret)
                    throw new UnexpectedTestResultException("XRLXeAcknowledgeLicenseDeliveryRequest should have failed.");
                ValueCheck.TestHR ("request.XErr", errorCode, request.XErr);
            }
            else
            {
                if (!ret)
                    throw new UnexpectedTestResultException("XRLXeAcknowledgeLicenseDeliveryRequest failed: " + request.GetDumpString());
                ValueCheck.TestHR("request.XErr", HResult.S_OK, request.XErr);
            }
        }

        public string AcquireContentUrl(XRLWMID wmid)
        {
            return AcquireContentUrl(wmid, 0, 0);
        }

        public string AcquireContentUrl(XRLWMID wmid, uint ipUInt, uint errorCode)
        {
            XRLXeAcquireVideoContentURLRequest request = new XRLXeAcquireVideoContentURLRequest();
            request.userPuid = this.userId;
            request.machinePuid = this.machineId;
            request.countryID = this.countryId;
            request.languageID = this.languageId;
            request.wmid = wmid;

            AddAlternateUrls(request);
            
           // enable manual slot 
            if (ipUInt > 0)
            {
                request.ManualPopulateSlot();   
                request.Slot.ipaI = ipUInt;
                request.Slot.ipportI = 0xffff;
            }

            XRLXeAcquireVideoContentURLResponse response = null;
            bool ret = request.Execute(out response);

            if (errorCode != 0)
            {
                if (ret)
                    throw new UnexpectedTestResultException("XRLXeAcquireVideoContentURLRequest should have failed.");
                if (request.XErr != errorCode)
                    throw new UnexpectedTestResultException(String.Format("XRLXeAcquireVideoContentURLRequest returned unexpected error XErr=0x{0:X}, expected XErr=0x{1:X}", request.XErr, errorCode));
            }
            else
            {
                if (!ret)
                    throw new UnexpectedTestResultException("XRLXeAcquireVideoContentURLRequest failed: " + request.GetDumpString());
                if (request.XErr != HResult.S_OK)
                    throw new UnexpectedTestResultException(String.Format("XRLXeAcquireVideoContentURLRequest returned XErr=0x{0:x}", request.XErr));

                return response.contentURL;
            }

            return null;
        }

        public XRLWMID[] Purchase(XRLWMID wmid, uint expectedPrice)
        {
            return this.Purchase(wmid,expectedPrice,(uint)PaymentTypeEnum.Points);
        }

        public XRLWMID[] Purchase(XRLWMID wmid, uint expectedPrice, uint paymentType)
        {
            return Purchase(wmid, expectedPrice, paymentType, 0, 0);
        }

        public XRLWMID[] Purchase(XRLWMID wmid, uint expectedPrice, uint paymentType, uint ipUInt, uint errorCode)
        {
            XRLXeOfferPurchaseVideoRequest request = new XRLXeOfferPurchaseVideoRequest();
            request.userPuid = this.userId;
            request.machinePuid = this.machineId;
            request.wmid = wmid;
            request.expectedPrice = expectedPrice;
            
            AddAlternateUrls(request);

            // enable manual slot 
            if (ipUInt > 0)
            {
                request.ManualPopulateSlot();
                request.Slot.ipaI = ipUInt;
                request.Slot.ipportI = 0xffff;
            }

            XRLXeOfferPurchaseVideoResponse response = null;
            bool ret = request.Execute(out response);

            if (errorCode != 0)
            {
                if (ret)
                    throw new UnexpectedTestResultException("XRLXeOfferPurchaseVideoRequest should have failed.");
                if (request.XErr != errorCode)
                    throw new UnexpectedTestResultException(String.Format("XRLXeOfferPurchaseVideoRequest returned unexpected error XErr=0x{0:X}, expected XErr=0x{1:X}", request.XErr, errorCode));
            }
            else
            {
                if (!ret)
                {
                    if (request.XErr != HResult.S_OK)
                    {
                        Global.RO.Error(String.Format("XRLXeOfferPurchaseVideoRequest returned XErr=0x{0:x}", request.XErr));
                        throw new VideoClientException(request.XErr, "XRLXeOfferPurchaseVideoRequest. Execute returned a failed HRESULT : " + request.XErr.ToString("x"));
                    }
                    Global.RO.Error("XRLXeOfferPurchaseVideoRequest failed: " + request.GetDumpString());
                    throw new VideoClientException("XRLXeOfferPurchaseVideoRequest.Execute failed");
                }
                if (request.XErr != HResult.S_OK)
                {
                    Global.RO.Error(String.Format("XRLXeOfferPurchaseVideoRequest returned XErr=0x{0:x}", request.XErr));
                    throw new VideoClientException(request.XErr, "XRLXeOfferPurchaseVideoRequest. Execute returned a failed HRESULT : " + request.XErr.ToString("x"));
                }

                return response.wmids;
            }

            return null;
        }

        public static string LicenseBlocksToString(XRLXeWmdrmLicenseBlock[] licenseBlocks)
        {
            StringBuilder sb = new StringBuilder();

            foreach(XRLXeWmdrmLicenseBlock block in licenseBlocks)
            {
                sb.Append(Encoding.ASCII.GetString(block.licenseBlock));
            }

            return sb.ToString();
        } 
    }


    public class VideoTestUtil
    {
        public static XeUser CreateUser(XboxUserType userType)
        {
            switch(userType)
            {
                case XboxUserType.Xbox1:
                case XboxUserType.XboxCom:
                case XboxUserType.XenonSilver:
                    return XbosUser.XenonSilverUser();
                case XboxUserType.XenonGold:
                    return XbosUser.XenonGoldUser();
                case XboxUserType.Argo:
                    return new ArgoUser();
                case XboxUserType.None:
                    break;
            }
            throw new ArgumentException("Invalid user type");
        }

        public static void AddConsoleId(ulong machineId)
        {
            XbosWS.AddConsoleId(machineId,"XE.111111111111");
        }

        public static void AddConsoleId(ulong machineId, string serialNo)
        {
            XbosWS.AddConsoleId(machineId, serialNo);
        }
    }

    public class WMInterop
    {
        public static string GetChallenge()
        {
            RMGetLicense rm = new RMGetLicense();
            return rm.GetSystemInfo(); 
        }
    }

    [ComImport, TypeLibType(0x1040), Guid("9EA69F99-F8FF-415E-8B90-35D6DFAF160E")]
    internal interface IRMGetLicense
    {
        [MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime), DispId(0x60020000)]
        void GetLicenseFromURL([In, MarshalAs(UnmanagedType.BStr)] string bstrXMLDoc, [In, MarshalAs(UnmanagedType.BStr)] string bstrURL);

        [return: MarshalAs(UnmanagedType.BStr)]
        [MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime), DispId(0x60020001)]
        string GetSystemInfo();

        [MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime), DispId(0x60020002)]
        void StoreLicense([In, MarshalAs(UnmanagedType.BStr)] string bstrXMLDoc);

        [return: MarshalAs(UnmanagedType.BStr)]
        [MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime), DispId(0x60020003)]
        string GetDRMVersion();

        [return: MarshalAs(UnmanagedType.BStr)]
        [MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime), DispId(0x60020004)]
        string GetDRMSecurityVersion();

        [MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime), DispId(0x60020005)]
        void GetLicenseFromURLAsync([In, MarshalAs(UnmanagedType.BStr)] string bstrXMLDoc, [In, MarshalAs(UnmanagedType.BStr)] string bstrURL);

        [MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime), DispId(0x60020006)]
        void GetAsyncCallStatus([In, Out, MarshalAs(UnmanagedType.Struct)] ref object pvarStatus, [In, Out, MarshalAs(UnmanagedType.Struct)] ref object pvarHResult);
    }

    [ComImport, Guid("9EA69F99-F8FF-415E-8B90-35D6DFAF160E"), CoClass(typeof(RMGetLicenseClass))]
    internal interface RMGetLicense : IRMGetLicense
    {
    }

    [ComImport, ClassInterface(ClassInterfaceType.None), Guid("A9FC132B-096D-460B-B7D5-1DB0FAE0C062"), TypeLibType(2)]
    internal class RMGetLicenseClass : IRMGetLicense, RMGetLicense
    {
        // Methods
        [MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime), DispId(0x60020006)]
        public virtual extern void GetAsyncCallStatus([In, Out, MarshalAs(UnmanagedType.Struct)] ref object pvarStatus, [In, Out, MarshalAs(UnmanagedType.Struct)] ref object pvarHResult);
        [return: MarshalAs(UnmanagedType.BStr)]
        [MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime), DispId(0x60020004)]
        public virtual extern string GetDRMSecurityVersion();
        [return: MarshalAs(UnmanagedType.BStr)]
        [MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime), DispId(0x60020003)]
        public virtual extern string GetDRMVersion();
        [MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime), DispId(0x60020000)]
        public virtual extern void GetLicenseFromURL([In, MarshalAs(UnmanagedType.BStr)] string bstrXMLDoc, [In, MarshalAs(UnmanagedType.BStr)] string bstrURL);
        [MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime), DispId(0x60020005)]
        public virtual extern void GetLicenseFromURLAsync([In, MarshalAs(UnmanagedType.BStr)] string bstrXMLDoc, [In, MarshalAs(UnmanagedType.BStr)] string bstrURL);
        [return: MarshalAs(UnmanagedType.BStr)]
        [MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime), DispId(0x60020001)]
        public virtual extern string GetSystemInfo();
        [MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime), DispId(0x60020002)]
        public virtual extern void StoreLicense([In, MarshalAs(UnmanagedType.BStr)] string bstrXMLDoc);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\Billing\PostRequest.cs ===
using System;
using System.Net;


namespace ServerTestFramework.LiveService.Billing.WebBilling
{
    /// <summary>
    /// This class will be used to post the webrequest to corresponding interface
    /// </summary>
    public class PostRequest
    {
        public static bool UseFakeAA = true;
	    public PostRequest()
	    {

	    }

        public static uint SendRequest(ulong passportPuid, IPEndPoint endPoint, WebHeaderCollection headers, WebRequestBase request, WebResponseBase response)
        {
            System.Net.WebClient wbclient = new System.Net.WebClient();
            string xErr;
            byte[] respData;
            uint hr = 0;

            //convert the request to an array of bytes.
            byte[] sendData = (byte[])request;

            //build the url         
            string url = "http://" + endPoint.Address.ToString() + ":" + endPoint.Port.ToString() + request.GetRelativeUrl();
            Global.RO.Info("URL: " + url);

            if (headers == null)
            {
                headers = new System.Net.WebHeaderCollection();
            }

            ServerTestFramework.LiveService.FakeAAInfoNameSpace.FakeAAInfo  fAAInfo = new ServerTestFramework.LiveService.FakeAAInfoNameSpace.FakeAAInfo (passportPuid);
            //Add the FakeAAInfo to the request header
            headers.Add(xonline.common.service.XHttpHdr.AUTHZ, fAAInfo.ConvertToHttpHeaderValue());
            wbclient.Headers.Add(headers);
            wbclient.Headers.Add("User-Agent", "Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 5.1)");
            try
            {
                respData = wbclient.UploadData(url, request.GetHttpMethod(), sendData);
                xErr = wbclient.ResponseHeaders["X-Err"];
                if (xErr != null)
                {
                    if (xErr.StartsWith("0x") || xErr.StartsWith("0X")) xErr = xErr.Substring(2);
                    hr = Convert.ToUInt32(xErr, 16);
                }
            }
            catch (System.Net.WebException e)
            {
                HttpWebResponse httpResp = (HttpWebResponse)e.Response;
                HttpStatusCode status = HttpStatusCode.BadRequest;
                string respDesc = "SendRequest failed. But no response data is available.";
                if (httpResp != null)
                {
                    status = httpResp.StatusCode;
                    respDesc = httpResp.StatusDescription;

                    // get the X-Err header from response
                    xErr = httpResp.Headers["X-Err"];
                    if (xErr != null)
                    {
                        if (xErr.StartsWith("0x") || xErr.StartsWith("0X")) xErr = xErr.Substring(2);
                        hr = Convert.ToUInt32(xErr, 16);
                    }

                    if (httpResp.ContentLength > 0)
                    {
                        long contentLen = httpResp.ContentLength;
                        System.IO.Stream stream1 = httpResp.GetResponseStream();
                        System.Text.Encoding encode = System.Text.Encoding.GetEncoding("utf-8");
                        // Pipes the stream to a higher level stream reader with the required encoding format. 
                        System.IO.StreamReader readStream = new System.IO.StreamReader(stream1, encode);
                        char[] read = new char[contentLen];
                        int count = readStream.Read(read, 0, read.Length);
                        //respData = Encoding.UTF8.GetString(read);
                        String str = new String(read, 0, count);
                        respDesc = str;
                    }
                }

                throw new ServerTestFramework.XErrException(hr, url + status + e.Message, e);
            }
            if (response != null && respData != null && respData.Length != 0)
            {
                System.IO.BinaryReader reader = new System.IO.BinaryReader(new System.IO.MemoryStream(respData));
                response.ReadFromRequest(reader, (System.Text.UTF8Encoding)System.Text.Encoding.UTF8, respData.Length, null);
            }
            return hr;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\Billing\Offer.cs ===
using System;
using System.Collections;
using ServerTestFramework;
using ServerTestFramework.Database;
using ServerTestFramework.Utilities;
using ServerTestFramework.LiveService.UserAccount;
using ServerTestFramework.LiveService.Billing.License;
using ServerTestFramework.LiveService.Billing.WebService2;
using xonline.common.service;

namespace ServerTestFramework.LiveService.Billing
{
    [Flags]
    public enum PaymentTypeEnum : uint
    {
        CreditCard = 0x00000001,
        Token      = 0x00000002,
        Points     = 0x00000004,
        Wholesale  = 0x00000008,
        Untrusted   = 0x00010000,
        All = CreditCard | Token | Points | Wholesale,
        NoTokens = All & ~Token,
    };

    public enum TierEnum : uint
    {
        NewUser = 0,
        Silver = 3,
        Gold = 6,
        FamilyGold = 9,
        All = 15     // for test only
    };

    public enum StoreEnum : uint
    {
        Xbox = 1,
        Zune = 2,
        PC = 3,
        Zest = 4,
        Mobile = 5
    }

    [Flags]
    public enum OfferingTypeEnum : uint
    {
        Subscription            = 0x00000001,
        Content                 = 0x00000002,
        Renewal                 = 0x00000004,
        PointsBundle            = 0x00000008,
        GamertagChange          = 0x00000010,
        GameDemo                = 0x00000020,
        GameTrailer             = 0x00000040,
        Theme                   = 0x00000080,
        Gameplay                = 0x00000100,
        FullGame                = 0x00000200,
        PromoPoints             = 0x00000400,
        Tile                    = 0x00000800,
        Trial                   = 0x00001000,
        Arcade                  = 0x00002000,
        Video                   = 0x00004000,
        MusicNetMTV             = 0x00008000, // MusicNet offers are not tracked by Xbox Live.  No offer should ever actually have this offer type.  It is used only for implementing the purchase and history flow for music.
        GameConsumable          = 0x00010000,
        SyncCastWMIS            = 0x00020000, // SyncCast/WMIS offers are not tracked by Xbox Live.  No offer should ever actually have this offer type.  It is used only for implementing the purchase and history flow for video.
        PcAccountCreation = 0x00040000,
        ArcadeTrial            = 0x00400000,  // for testing only
        Xbox1Game           = 0x00800000,  // for testing only
        XNACommunityGame = 0x00080000, // Special InGameContentEnumerate value for XNA Launcher to enum XNA Games
        AllContent              =
            Content | GameDemo | GameTrailer | Theme | FullGame | Tile | Arcade | Video | GameConsumable,
        All                     =
            Subscription | Content | Renewal | PointsBundle | GamertagChange | GameDemo | GameTrailer |
            Theme | Gameplay | FullGame | PromoPoints | Tile | Trial | Arcade | Video | GameConsumable,
    };

    public enum TaxTypeEnum : byte
    {
        NoTax = 0,
        Default = 1,
        GST = 2,
        VAT = 3,
        TaxNotApplicable = 4
    }

    public enum OfferingFrequencyEnum : byte
    {
        OneTimeCharge = 0,
        Monthly = 1,
        Quarterly = 2,
        BiAnnually = 3,
        Annually = 4
    }

    public enum OfferingRelationTypeEnum : byte
    {
        Invalid = 1,
        Base = 0,
        Renewal = 3,
        Trial = 4,
        Xbox1ToXenon = 5
    }

    public enum OfferingConvertMode : byte
    {
        Convert = 0,
        Renew = 1,
        Invalid = 2
    }

    [Flags]
    public enum OfferPolicies : uint
    {
        PerUserRights = 0x001,
        PerMachineRights = 0x002,
        Unrestricted = 0x004,
        OnlyPurchaseOnce = 0x100,
        RequiresVoucher = 0x200,
        DoNotEnumerate = 0x400,
        TrialOffer = 0x800,
        RequiresGeoFencing = 0x1000,
    }

    public enum OfferingSKUType : byte
    {
        RevenueSKU = 1,
        PromotionalSKU = 2
    }

    public enum DMPTransactionStatus : int
    {
        NoStatus = -1,        // no status id found
        Pending = 1,          // this state is used while making the call to SCS
        Success = 2,          // the API call succeeded
        Failed = 3,             // the API call failed
        Timeout = 4,          // the API call resulted in a timeout, so we don't know what happened in SCS
        Canceled = 5,        // the API call was cancelled successfully
        CancelFailed = 6,   // the API call succeeded and later a cancel attempt was made, but that failed
        RetryFailed = 7,     // a retry attempt was made, but it failed (eg SCS::PurchaseItem)
        MusicPurchasePending = 8,    // points have been deducted, now we are going to call MusicNet
        MusicPurchaseTimeout = 9,    // points have been deducted, but the MusicNet call timed out
        MusicPurchaseFailed = 10,    // points have been deducted, but the MusicNet call failed

        FailFast = 21, // for server testing only
        Stress = 22,  // for server testing only
        LongWaitTimeout = 23, // used by emulator to cause timeout by wait a long time
    }



    public enum QueueState :int
    {
        NoState = 3,
        SubscriptionBilling = 1,
        SubscriptionFulfillment = 2
    }

    [Flags]
    public enum QueryFlagsEnum : ushort
    {
        QueryForNew = 0x0001,
        QueryForRenewals = 0x0002,
        QueryForCurrent = 0x0004,
        QueryForExpired = 0x0008,
        QueryForSuspended = 0x0010,
    };

    // from Xbox1
    public enum RatingsEnum
    {
        ESRB_eCEarlyChildhood = (0 << 8) | 1,
        ESRB_EEveryone = (0 << 8) | 2,
        ESRB_E1010 = (0 << 8) | 3,
        ESRB_TTeen = (0 << 8) | 4,
        ESRB_MMature = (0 << 8) | 5,
        ESRB_AOAdultOriented = (0 << 8) | 6,
        ESRB_RPRatingPending = (0 << 8) | 7,
        PEGI_Ages3 = (1 << 8) | 11,
        PEGI_Ages7 = (1 << 8) | 12,
        PEGI_Ages12 = (1 << 8) | 13,
        PEGI_Ages16 = (1 << 8) | 14,
        PEGI_Ages18 = (1 << 8) | 15,
        PEGIFinland_Ages3 = (2 << 8) | 21,
        PEGIFinland_Ages7 = (2 << 8) | 22,
        PEGIFinland_Ages11 = (2 << 8) | 23,
        PEGIFinland_Ages15 = (2 << 8) | 24,
        PEGIFinland_Ages18 = (2 << 8) | 25,
        PEGIPortugal_Ages4 = (3 << 8) | 31,
        PEGIPortugal_Ages6 = (3 << 8) | 32,
        PEGIPortugal_Ages12 = (3 << 8) | 33,
        PEGIPortugal_Ages16 = (3 << 8) | 34,
        PEGIPortugal_Ages18 = (3 << 8) | 35,
        CERO_AllAges = (4 << 8) | 41,
        CERO_12 = (4 << 8) | 42,
        CERO_15 = (4 << 8) | 43,
        CERO_18 = (4 << 8) | 44,
        CERO_Standard = (4 << 8) | 45,
        USK_Releasedwithoutagerestriction = (5 << 8) | 51,
        USK_Releasedstartingfrom6years = (5 << 8) | 52,
        USK_Releasedstartingfrom12years = (5 << 8) | 53,
        USK_Releasedstartingfrom16years = (5 << 8) | 54,
        USK_Noyouthrelease = (5 << 8) | 55,
        KMRB_All = (6 << 8) | 61,
        KMRB_12year = (6 << 8) | 62,
        KMRB_15year = (6 << 8) | 63,
        KMRB_18year = (6 << 8) | 64,
        KMRB_Restricted = (6 << 8) | 65,
        OFLC_AU_G_General = (7 << 8) | 71,
        OFLC_AU_G8_Suitableforchildren8yearsandover = (7 << 8) | 72,
        OFLC_AU_M15_Recommendedformatureaudiences15yearsandover = (7 << 8) | 73,
        OFLC_AU_MA15_Recommendedformatureaudiences15yearsandoverwithlegalrestrictions = (7 << 8) | 74,
        OFLC_AU_RC_RefusedClassification = (7 << 8) | 75,
        OFLC_NZ_Unrestricted = (8 << 8) | 81,
        OFLC_NZ_R13 = (8 << 8) | 82,
        OFLC_NZ_R16 = (8 << 8) | 83,
        OFLC_NZ_R18 = (8 << 8) | 84,
        OFLC_NZ_R18Violence = (8 << 8) | 85,
        OFLC_NZ_RC_RefusedClassification = (8 << 8) | 86,
        All = (9 << 8) | 91,
        OlderThan12 = (9 << 8) | 92,
        OlderThan14 = (9 << 8) | 93,
        OlderThan16 = (9 << 8) | 94,
        OlderThan18 = (9 << 8) | 95,
    }

    /// <summary>
    /// Genre class to add some new genres to both Game and Media
    /// </summary>
    public class XbosGenre
    {
        public static int[] _genreIDs = { 186000000, 187000000, 187010000, 187010100, 187010200, 187010300, 187010400, 187020000, 187030000, 187040000, 187050000, 187060000,
            586000000, 587000000, 587010000, 587020000, 587030000, 587040000, 587050000, 587060000, 587070000, 587080000, 587030100, 587030200 };
        public static int[] _genreIDs1 = { 186000000, 187000000, 187010000, 187010100, 187010200, 187010300, 187010400, 187020000, 187030000, 187040000, 187050000, 187060000 };
        public static int[] _genreIDs5 = { 586000000, 587000000, 587010000, 587020000, 587030000, 587040000, 587050000, 587060000, 587070000, 587080000, 587030100, 587030200 };

        public static int[] _cultureIDs = { 1033, 2057, 3076 };
        public static string[] _cultureNames = { "Xbos Test US-EN ", "Xbos Test UK-EN ", "Xbos Test HK-CH\u00F3 " };

        public static string[] _sqlGenres = {
            "exec [dbo].[p_pcat_AddGenre] @genreId=186000000, @productTypeId=1, @parentGenreId=NULL, @genreName=N'XbosTest Root86', @resourceName=N'STRING_GENRE_86'",
            "exec [dbo].[p_pcat_AddGenre] @genreId=187000000, @productTypeId=1, @parentGenreId=NULL, @genreName=N'XbosTest Root87', @resourceName=N'STRING_GENRE_87'",
            "exec [dbo].[p_pcat_AddGenre] @genreId=187010000, @productTypeId=1, @parentGenreId=187000000, @genreName=N'XbosTest 87-01', @resourceName=N'STRING_GENRE_87-01'",
            "exec [dbo].[p_pcat_AddGenre] @genreId=187010100, @productTypeId=1, @parentGenreId=187010000, @genreName=N'XbosTest 87-01-01', @resourceName=N'STRING_GENRE_87-01-01'",
            "exec [dbo].[p_pcat_AddGenre] @genreId=187010200, @productTypeId=1, @parentGenreId=187010000, @genreName=N'XbosTest 87-01-02', @resourceName=N'STRING_GENRE_87-01-02'",
            "exec [dbo].[p_pcat_AddGenre] @genreId=187010300, @productTypeId=1, @parentGenreId=187010000, @genreName=N'XbosTest 87-01-03', @resourceName=N'STRING_GENRE_87-01-03'",
            "exec [dbo].[p_pcat_AddGenre] @genreId=187010400, @productTypeId=1, @parentGenreId=187010000, @genreName=N'XbosTest 87-01-04', @resourceName=N'STRING_GENRE_87-01-04'",
            "exec [dbo].[p_pcat_AddGenre] @genreId=187020000, @productTypeId=1, @parentGenreId=187000000, @genreName=N'XbosTest 87-02', @resourceName=N'STRING_GENRE_87-02'",
            "exec [dbo].[p_pcat_AddGenre] @genreId=187030000, @productTypeId=1, @parentGenreId=187000000, @genreName=N'XbosTest 87-03', @resourceName=N'STRING_GENRE_87-03'",
            "exec [dbo].[p_pcat_AddGenre] @genreId=187040000, @productTypeId=1, @parentGenreId=187000000, @genreName=N'XbosTest 87-04', @resourceName=N'STRING_GENRE_87-04'",
            "exec [dbo].[p_pcat_AddGenre] @genreId=187050000, @productTypeId=1, @parentGenreId=187000000, @genreName=N'XbosTest 87-05', @resourceName=N'STRING_GENRE_87-05'",
            "exec [dbo].[p_pcat_AddGenre] @genreId=187060000, @productTypeId=1, @parentGenreId=187000000, @genreName=N'XbosTest 87-06', @resourceName=N'STRING_GENRE_87-06'",

            "exec [dbo].[p_pcat_AddGenre] @genreId=586000000, @productTypeId=5, @parentGenreId=NULL, @genreName=N'XbosTest Root86 5-Marketplace', @resourceName=N'STRING_GENRE_M5_86'",
            "exec [dbo].[p_pcat_AddGenre] @genreId=587000000, @productTypeId=5, @parentGenreId=NULL, @genreName=N'XbosTest Root87 5-Marketplace', @resourceName=N'STRING_GENRE_M5_87'",
            "exec [dbo].[p_pcat_AddGenre] @genreId=587010000, @productTypeId=5, @parentGenreId=587000000, @genreName=N'XbosTest M5-87-01', @resourceName=N'STRING_GENRE_M5_87-01'",
            "exec [dbo].[p_pcat_AddGenre] @genreId=587020000, @productTypeId=5, @parentGenreId=587000000, @genreName=N'XbosTest M5-87-02', @resourceName=N'STRING_GENRE_M5_87-02'",
            "exec [dbo].[p_pcat_AddGenre] @genreId=587030000, @productTypeId=5, @parentGenreId=587000000, @genreName=N'XbosTest M5-87-03', @resourceName=N'STRING_GENRE_M5_87-03'",
            "exec [dbo].[p_pcat_AddGenre] @genreId=587030100, @productTypeId=5, @parentGenreId=587030000, @genreName=N'XbosTest M5-87-03-01', @resourceName=N'STRING_GENRE_M5_87-03-01'",
            "exec [dbo].[p_pcat_AddGenre] @genreId=587030200, @productTypeId=5, @parentGenreId=587030000, @genreName=N'XbosTest M5-87-03-02', @resourceName=N'STRING_GENRE_M5_87-03-02'",
            "exec [dbo].[p_pcat_AddGenre] @genreId=587040000, @productTypeId=5, @parentGenreId=587000000, @genreName=N'XbosTest M5-87-04', @resourceName=N'STRING_GENRE_M5_87-04'",
            "exec [dbo].[p_pcat_AddGenre] @genreId=587050000, @productTypeId=5, @parentGenreId=587000000, @genreName=N'XbosTest M5-87-05', @resourceName=N'STRING_GENRE_M5_87-05'",
            "exec [dbo].[p_pcat_AddGenre] @genreId=587060000, @productTypeId=5, @parentGenreId=587000000, @genreName=N'XbosTest M5-87-06', @resourceName=N'STRING_GENRE_M5_87-06'",
            "exec [dbo].[p_pcat_AddGenre] @genreId=587070000, @productTypeId=5, @parentGenreId=587000000, @genreName=N'XbosTest M5-87-07', @resourceName=N'STRING_GENRE_M5_87-07'",
            "exec [dbo].[p_pcat_AddGenre] @genreId=587080000, @productTypeId=5, @parentGenreId=587000000, @genreName=N'XbosTest M5-87-08', @resourceName=N'STRING_GENRE_M5_87-08'",
        };

        // the two sp will take care of existing genres
        public static void InitGenres()
        {
            int iRet = 0;
            string sql = "";

            // main genres
            for (int i = 0; i < _sqlGenres.Length; i++)
            {
                iRet = UodbWS.ExecuteSQLNonQuery(_sqlGenres[i], null);  // all physical partitions
            }

            // localized genre names
            for (int iCul = 0; iCul < _cultureIDs.Length; iCul++)
            {
                for (int i = 0; i < _genreIDs.Length; i++)
                {
                    sql = "exec [dbo].[p_svc_insert_genre_localized_text] @genreId=" + _genreIDs[i].ToString() + ", @cultureId=" + _cultureIDs[iCul] + ", @genreName=N'" + _cultureNames[iCul] + _genreIDs[i].ToString() + "'";
                    UodbWS.ExecuteSQLNonQuery(sql, null); // all physical partitions
                }
            }
        }

        public static void CreateTitleOffer(uint genreId, uint titleId, byte ratingId, int numOffers)
        {
            CreateTitleOffer(genreId, titleId, ratingId, numOffers, 2);
        }

        public static void CreateTitleOffer(uint genreId, uint titleId, byte ratingId, int numOffers, byte consoleTypeId)
        {
            XbosTitle title = new XbosTitle();
            title.GenreId = genreId;
            title.TitleId = titleId;
            title.RatingSystemId = 0; // US
            title.RatingId = ratingId;
            title.ConsoleTypeId = consoleTypeId;
            title.Create();
            title.AddOffer(numOffers);
        }

        public static void CreateTitleOffer(uint genreId, uint titleId, byte ratingId, int[] offerTypes, int[] numOffers)
        {
            XbosTitle title = new XbosTitle();
            title.GenreId = genreId;
            title.TitleId = titleId;
            title.RatingSystemId = 0;   // US
            title.RatingId = ratingId;
            title.Create();
            for (int i = 0; i < offerTypes.GetLength(0); i++)
            {
                title.AddOffer(numOffers[i], offerTypes[i]);
            }
        }
    }

    /// <summary>
    /// Title class for Uodb loading purpose
    /// </summary>
    public class XbosTitle
    {
        public bool CleanTitle = true;

        public ArrayList Offers;
        public ArrayList AssociatedOffers;
        private ulong _lastOfferId;

        private int cultureId;  // can be calculated from CountryId and LanguageId
        private byte ratingId;  // can be calculated from RatingSystemId and RatingRank

        public byte CountryId;      // optional
        public ushort LanguageId;   // optional
        public byte RatingSystemId; // optional, can get from CountryId
        public byte RatingRank;     // optional
        public uint TitleId;
        public byte ConsoleTypeId;
        public uint GenreId;
        public string Name = "";
        public string SellText = "";
        public string Publisher = "";
        public string Developer = "";
        public string GenreText = "";

        public byte[] CountryIds;   // for game rating
        public byte[] RatingSystemIds;
        public byte[] RatingRanks;

        public int[] CultureIds;
        public string[] Names;
        public string[] SellTexts;
        public string[] Publishers;
        public string[] Developers;
        public string[] GenreTexts;

        // for GetTitleDetails/EnumerateTitles
        public bool SubscriptionContent;
        public bool ThemeContent;
        public bool DemoContent;
        public bool TrailerContent;
        public bool Played;

        public bool NewContentExists;
        public uint PurchaseContentCount;
        public uint TotalContentCount;

        public int CultureId
        {
            get { return cultureId; }
            set { cultureId = value; }
        }

        public byte RatingId
        {
            get { return ratingId; }
            set { ratingId = value; }
        }

        public ulong NextOfferId()
        {
            return _lastOfferId + (ulong)XbosOffer.RandGen.Next(1, int.MaxValue);
        }

        // set all default values
        public XbosTitle()
        {
            SetDefaults();
        }

        public XbosTitle(uint titleId)
            : this(titleId, true)
        {
        }

        public XbosTitle(uint titleId, bool cleanTitle)
        {
            SetDefaults();
            TitleId = titleId;
            CleanTitle = cleanTitle;
        }

        public XbosTitle(uint titleId, uint genreId)
            : this(titleId, genreId, true)
        {
        }

        public XbosTitle(uint titleId, uint genreId, bool cleanTitle)
        {
            SetDefaults();
            TitleId = titleId;
            GenreId = genreId;
            CleanTitle = cleanTitle;
        }

        public void ClearFlags()
        {
            SubscriptionContent = false;
            ThemeContent = false;
            DemoContent = false;
            TrailerContent = false;
            Played = false;

            NewContentExists = false;
            PurchaseContentCount = 0;
            TotalContentCount = 0;
        }

        private void SetDefaults()
        {
            Offers = new ArrayList(4);          // init size is 4
            AssociatedOffers = new ArrayList(4);// init size is 4

            cultureId = 1033;   // en-US, can be calculated from CountryId and LanguageId
            ratingId = 2;       // ESRB - E (Everyone), can be calculated from RatingSystemId and RatingRank

            CountryId = 0;      // optional
            LanguageId = 0;     // optional
            RatingSystemId = 0; // can get from CountryId
            RatingRank = 2;         // optional
            TitleId = 0x60340000;   // Xbos test titles starting point
            ConsoleTypeId = 2;      // xenon, // 0 - xbox1, 1 - xbox.com, 2 - Xenon, 3 - marketplace only
            GenreId = 503000000;    // media - gaming community videos

            CountryIds = new byte[XbosWS.TotalLiveCountryCount];
            RatingSystemIds = new byte[XbosWS.TotalLiveCountryCount];
            RatingRanks = new byte[XbosWS.TotalLiveCountryCount];

            CultureIds = new int[XbosWS.TotalLiveCultureCount];
            Names = new string[XbosWS.TotalLiveCultureCount];
            SellTexts = new string[XbosWS.TotalLiveCultureCount];
            Publishers = new string[XbosWS.TotalLiveCultureCount];
            Developers = new string[XbosWS.TotalLiveCultureCount];
            GenreTexts = new string[XbosWS.TotalLiveCultureCount];

            ClearFlags();
        }

        private void InitStrings()
        {
            Name = (Name.Length != 0) ? Name : string.Format("Xbos Test Title 0x{0:X} ({1})", TitleId, cultureId);
            SellText = (SellText.Length != 0) ? SellText : string.Format("Xbos Test Sell Text 0x{0:X} ({1})", TitleId, cultureId);
            Publisher = (Publisher.Length != 0) ? Publisher : string.Format("Xbos Test Publisher 0x{0:X} ({1})", TitleId, cultureId);
            Developer = (Developer.Length != 0) ? Developer : string.Format("Xbos Test Developer 0x{0:X} ({1})", TitleId, cultureId);
            GenreText = (GenreText.Length != 0) ? GenreText : string.Format("Xbos Test Genre 0x{0:X} ({1})", TitleId, cultureId);
        }

        public bool Create()
        {
            int i;
            bool addTitle = true;

            // prepare for the offer id
            _lastOfferId = TitleId;
            _lastOfferId = _lastOfferId << 32;

            // fail if no valid culture found
            if (CountryId != 0 && LanguageId != 0)
            {
                if ((cultureId = CountryLanguage.GetCultureId(CountryId, LanguageId)) == -1)
                    return false;
            }

            // calculate ratingId
            if (ratingId == XbosWS.RATING_ID_NONE)
                ratingId = XbosWS.GetRatingId(RatingSystemId, RatingRank);

            InitStrings();
            if (CultureIds[0] == 0)
            {
                CultureIds[0] = cultureId;
            }

            // if title already exists, just skip and do nothing
            if (!CleanTitle)
            {
                if (XbosWS.DoesTitleExist(TitleId))
                    addTitle = false;
            }

            if (addTitle)
            {
                ContentOfferLoader.CleanTitle(TitleId);
            }
            // p_svc_insert_titles checks the existing title first
            ContentOfferLoader.InsertTitle(TitleId, ConsoleTypeId);
            // p_svc_insert_title_genre will always check if the genre/title pair already exists first
            ContentOfferLoader.AddTitleGenre(TitleId, GenreId);
            ContentOfferLoader.InsertTitleRating(TitleId, RatingSystemId, ratingId);

            // different countries have different game rating
            for (i = 0; i < CountryIds.GetLength(0) && CountryIds[i] != 0; i++)
            {
                RatingSystemIds[i] = XbosWS.GetRatingSystemIdFromCountry(CountryIds[i]);
                if (RatingSystemIds[i] != XbosWS.RATING_SYS_NONE)
                {
                    if (RatingRanks[i] == 0)
                    {
                        RatingRanks[i] = 4; // 4 is a valid rating in most rating system (except rating system 3 and 11)
                        // now Portugal and South Africa are live supported country. Some speical treatment
                        if (RatingSystemIds[i] == 3)    // Protugal
                            RatingRanks[i] = 3;
                        else if (RatingSystemIds[i] == 11)  // South Africa
                            RatingRanks[i] = 6;
                    }

                    byte tempRatingId = XbosWS.GetRatingId(RatingSystemIds[i], RatingRanks[i]);
                    // p_svc_insert_title_rating will always check if the rating already exists first
                    ContentOfferLoader.InsertTitleRating(TitleId, RatingSystemIds[i], tempRatingId);
                }
                else
                    RatingRanks[i] = XbosWS.RATING_ID_NONE;
            }

            // all live supported cultures
            for (i = 0; i < CultureIds.GetLength(0) && CultureIds[i] != 0; i++)
            {
                Names[i] = string.Format("Xbos Test Title 0x{0:X} ({1})", TitleId, CultureIds[i]);
                SellTexts[i] = string.Format("Xbos Test Sell Text 0x{0:X} ({1})", TitleId, CultureIds[i]);
                Publishers[i] = string.Format("Xbos Test Publisher 0x{0:X} ({1})", TitleId, CultureIds[i]);
                Developers[i] = string.Format("Xbos Test Developer 0x{0:X} ({1})", TitleId, CultureIds[i]);
                GenreTexts[i] = string.Format("Xbos Test Genre 0x{0:X} ({1})", TitleId, CultureIds[i]);

                // p_svc_insert_title_culture_details will always check if the culture already exists first
                ContentOfferLoader.InsertTitleCultureDetails(TitleId, CultureIds[i], Names[i], SellTexts[i], Publishers[i], Developers[i], GenreTexts[i]);
            }

            return true;
        }

        public bool CreateWithOneOffer()
        {
            bool ret = Create();
            if (ret)
                ret = AddOffer();
            return ret;
        }

        // use this method only when you need to add more offers to the same content
        // in other words, don't use this method to add the first offer to this content
        public bool AddOffer(XbosContent content)
        {
            // add content and offer
            ulong offerId1;
            offerId1 = NextOfferId();
            if (CleanTitle)
            {
                // clean content too if no offer refers to this content
                ContentOfferLoader.CleanOffers(offerId1);
            }
            XbosOffer offer1 = new XbosOffer(this, offerId1);
            offer1.CleanOffer = CleanTitle;
            offer1.Create(content);

            return true;
        }

        public bool AddOffer()
        {
            return AddOffer(1);
        }

        public bool AddOffer(int numOffers)
        {
            return AddOffer(numOffers, (int)OfferingTypeEnum.Content);
        }

        public bool AddOffer(int numOffers, int offerType)
        {
            return AddOffer(numOffers, offerType, DateTime.UtcNow.AddYears(-2), DateTime.UtcNow.AddYears(2));
        }

        public bool AddOffer(int numOffers, int offerType, DateTime startDate, DateTime endDate)
        {
            // add content and offer
            ulong offerId1;
            for (int i = 0; i < numOffers; i++)
            {
                offerId1 = NextOfferId();
                XbosOffer offer1 = new XbosOffer(this, offerId1);
                offer1.CleanOffer = CleanTitle;
                offer1.RegionStartDate = startDate;
                offer1.RegionEndDate = endDate;
                offer1.OfferType = offerType;
                offer1.CreateWithContent();
            }

            return true;
        }

        public bool AddAssociatedOffer(XbosOffer offer)
        {
            ContentOfferLoader.InsertAssociatedOffer(TitleId, offer.OfferId);
            AssociatedOffers.Add(offer);
            return true;
        }

        public void TitleHasPlayed(ulong userPuid)
        {
            ContentOfferLoader.AddUserPlayedTitle(userPuid, TitleId, DateTime.UtcNow.AddMonths(-2));
            this.Played = true;
        }
    }

    /// <summary>
    /// Offer class for Uodb loading purpose
    /// Cannot guarantee that the offer id is unique in the title
    /// </summary>
    public class XbosOffer
    {
        public static ServerTestFramework.Utilities.RandomEx RandGen = new ServerTestFramework.Utilities.RandomEx();

        public class OfferRegion
        {
            public int PaymentType = (int)PaymentTypeEnum.Points;
            public int PriceWhole = RandGen.Next(1, 300);     // for free offer, have to be set explicitly
            public int PriceFractional = 0;
            public ushort OfferDetails = 0;

            public OfferRegion()
            {
            }

            public OfferRegion(int paymentType, int wholePrice)
            {
                PaymentType = paymentType;
                PriceWhole = wholePrice;
            }

            public void Clone(OfferRegion other)
            {
                this.PaymentType = other.PaymentType;
                this.PriceWhole = other.PriceWhole;
                this.PriceFractional = other.PriceFractional;
                this.OfferDetails = other.OfferDetails;
            }
        }

        public static string OFFER_VOUCHER_CODE = "T0000-00000-00000-00000-00000";
        public static string OFFER_VOUCHER_HASH = "31FAE513EF0964A1BE6A4CF10FFE929C29730921";

        public static string OFFER_VOUCHER_CODE2 = "T0000-00000-00000-00000-00001";
        public static string OFFER_VOUCHER_HASH2 = "A7029A3A657D845A8EDAE1A9949A25DF56800451";

        public XbosContent OfferContent;    // note: the same content can be shared by multiple offers
        public XbosTitle offerTitle = null;

        public bool CleanOffer = true;

        // from title
        public uint TitleId;
        public int CultureId;
        public byte CountryId;

        public int[] CultureIds;
        public string[] Names;
        public string[] SellTexts;
        public byte[] CountryIds;

        public ulong OfferId;
        public int PackageSize;
        public int InstallSize;
        public int BitFilter;
        public int OfferType;
        public string FriendlyName = "";
        public byte ConsoleTypeId;  // now, the offer level console type is not used. It is only at title level
        public int PolicyFlags;
        public int LicenseBits;
        public int ESRBId;
        public byte Cancelable;
        public string BillingSvcComp;
        public int OfferFrequecyId;
        public DateTime OfferStartDate;
        public DateTime OfferEndDate;
        public string Name = "";
        public string SellText = "";

        public int TierRequired;
        public DateTime RegionStartDate;
        public DateTime RegionEndDate;
        public string Boid;
        public int VoucherUseCount;
        public ArrayList OfferRegions = new ArrayList(1);

        // for ContenteDetails and ContentEnumerate
        public bool HasPurchased;
        public bool UserHasViewed;
        public byte TierReturned;
        public bool IsRecentContent;

        // in-game and consumable
        public ulong PreviewOfferId;
        public Asset OfferAsset;

        public XbosOffer(XbosTitle title)
        {
            SetDefaults();
            offerTitle = title;
            TitleId = title.TitleId;
            CultureId = title.CultureId;
            OfferId = title.NextOfferId();
        }

        public XbosOffer(XbosTitle title, ulong offerId)
        {
            SetDefaults();
            offerTitle = title;
            TitleId = title.TitleId;
            CultureId = title.CultureId;
            OfferId = offerId;
        }

        public XbosOffer(uint titleId, ulong offerId)
        {
            SetDefaults();
            TitleId = titleId;
            OfferId = offerId;
        }

        public XbosOffer(uint titleId, int cultureId, ulong offerId)
        {
            SetDefaults();
            TitleId = titleId;
            CultureId = cultureId;
            OfferId = offerId;
        }

        public void ClearFlags()
        {
            HasPurchased = false;
            UserHasViewed = false;
            TierReturned = 3;
            IsRecentContent = false;
        }

        public void SetDefaults()
        {
            OfferId = TitleId;
            OfferId = (OfferId << 32) + (ulong)RandGen.Next(1, int.MaxValue);
            CultureId = 1033;
            CountryId = 103;

            CultureIds = new int[XbosWS.TotalLiveCultureCount];
            Names = new string[XbosWS.TotalLiveCultureCount];
            SellTexts = new string[XbosWS.TotalLiveCultureCount];
            CountryIds = new byte[XbosWS.TotalLiveCountryCount];

            OfferContent = new XbosContent();
            PackageSize = OfferContent.PackageSize;
            InstallSize = OfferContent.InstallSize;

            BitFilter = 1;
            OfferType = (int)OfferingTypeEnum.Content;
            ConsoleTypeId = 2; // 0 - xbox1, 1 - xbox.com, 2 - Xenon, 3 - marketplace only
            PolicyFlags = (int)OfferPolicies.PerMachineRights | (int)OfferPolicies.PerUserRights;
            LicenseBits = 0;
            ESRBId = 0;
            Cancelable = 0;
            BillingSvcComp = "00000000-0000-0000-0000-000000000000";
            OfferFrequecyId = 0;
            OfferStartDate = DateTime.UtcNow.AddYears(-2);
            OfferEndDate = DateTime.UtcNow.AddYears(2);

            TierRequired = 9;   // default will be both tier 3 and 6
            RegionStartDate = DateTime.UtcNow.AddYears(-2);
            RegionEndDate = DateTime.UtcNow.AddYears(2);
            Boid = "";
            VoucherUseCount = -1;   // unlimited use

            ClearFlags();

            // in-game and consumable
            PreviewOfferId = 0;
            // Asset constructor default values are uint.MaxValue and int.MinValue. But for an offer is not consumable,
            // the default values are zeros. So later the default values will be set to zeros for non-consumable offers.
            OfferAsset = new Asset();

            // by default, only the first OfferRegion is used.
            OfferRegion region = new OfferRegion();
            OfferRegions.Add(region);
        }

        // one offer, one content. The content will be creatd for you.
        public bool CreateWithContent()
        {
            return CreateWithContent(null, null);
        }

        public bool CreateWithContent(byte[] contentId, string contentXrl)
        {
            if (CleanOffer)
            {
                // clean content too if no offer refers to this content
                ContentOfferLoader.CleanOffers(OfferId);
            }

            // create the content for this offer
            if (contentId != null)
                OfferContent.Create(contentId, contentXrl);
            else
                OfferContent.Create();

            return Create();
        }

        // need a content already created
        // don't do CleanOffers here because it may delete the content
        public bool Create(XbosContent content)
        {
            OfferContent = content;
            PackageSize = content.PackageSize;
            InstallSize = content.InstallSize;
            return Create();
        }

        private bool Create()
        {
            // get the countryId from cultureId if CountryId is default value and CultureId is not default value
            if (CountryId == 103 && CultureId != 1033)
                CountryId = XbosWS.GetLiveCountryIdFromCulture(CultureId);

            FriendlyName = (FriendlyName.Length != 0) ? FriendlyName : string.Format("Xbos Test Offer 0x{0:X}", OfferId);
            Name = (Name.Length != 0) ? Name : string.Format("Xbos Testoffer 0x{0:X} ({1})", OfferId, CultureId);
            SellText = (SellText.Length != 0) ? SellText : string.Format("Xbos Testoffer SellText 0x{0:X} ({1})", OfferId, CultureId);

            // prepare some returned values
            if (this.TierRequired == (int)TierEnum.Gold)
                this.TierReturned = (byte)this.TierRequired;

            // add asset to this offer, need to generate the assetId somehow
            // and change OfferType to consumables. AssetID = uint.MaxValue means not an asset
            // also allow quantity is 0 or some negative numbers ??
            if (OfferAsset.AssetID == uint.MaxValue && OfferAsset.Quantity > int.MinValue)
            {
                if (this.offerTitle != null)
                    OfferAsset.AssetID = (uint)(this.offerTitle.Offers.Count + 1);
                else
                    OfferAsset.AssetID = (uint)(OfferId & 0xFFFFFFFF);
            }
            if (OfferAsset.AssetID < uint.MaxValue && OfferAsset.Quantity > int.MinValue)
            {
                OfferType = (int)OfferingTypeEnum.GameConsumable;
            }

            // for testing purpose, don't change the policy flag to unrestricted
            /*
            // for free offers, the policyflag should be unrestricted excepte for Ipod download (free, per machine)
            bool free = true;
            foreach (OfferRegion region in OfferRegions)
            {
                if (region.PriceWhole != 0 || region.PriceFractional != 0)
                {
                    free = false;
                    break;
                }
            }
            // don't make it Unrestricted if it is PerMachine license (for IPod download)
            if (this.PolicyFlags != (int)OfferPolicies.PerMachineRights && free)
                this.PolicyFlags = (int)OfferPolicies.Unrestricted;
            */

            ContentOfferLoader.AddOffer(TitleId, OfferId, PackageSize, InstallSize, BitFilter, OfferType, FriendlyName, ConsoleTypeId,
                OfferContent.ContentId, PolicyFlags, LicenseBits, ESRBId, Cancelable, BillingSvcComp, OfferFrequecyId, OfferStartDate, OfferEndDate);

            // different cultures for this offer
            if (CultureIds[0] == 0)
            {
                CultureIds[0] = CultureId;
            }
            for (int j = 0; j < CultureIds.GetLength(0) && CultureIds[j] != 0; j++)
            {
                Names[j] = string.Format("Xbos Testoffer 0x{0:X} ({1})", OfferId, CultureIds[j]);
                SellTexts[j] = string.Format("Xbos Testoffer SellText 0x{0:X} ({1})", OfferId, CultureIds[j]);
                ContentOfferLoader.AddOfferCultureDetails(OfferId, CultureIds[j], Names[j], SellTexts[j]);
            }

            // different countried(regions) for this offer
            if (CountryIds[0] == 0)
            {
                CountryIds[0] = CountryId;
            }
            if (TierRequired == (int)TierEnum.Silver || TierRequired == (int)TierEnum.Gold)
            {
                AddOfferRegion(TierRequired, RegionStartDate);
            }
            else if (TierRequired == (int)TierEnum.All) // all defined tiers (Silver, Gold, FamilyGold)
            {
                AddOfferRegion(3, RegionStartDate);
                AddOfferRegion(6, RegionStartDate);
                AddOfferRegion(9, RegionStartDate);
            }

            int CONTENT_REVENUE_SKU_ID = 5001; // using test SKU
            int OFFER_CAMPAIGN = 55; // using test Campaign
            // add Sku Id and Campaign if not existing
            ContentOfferLoader.AddOfferSku((int)CONTENT_REVENUE_SKU_ID, OfferingSKUType.RevenueSKU, "XBX-00005", "Test SKU");
            ContentOfferLoader.AddOfferCampaign((int)OFFER_CAMPAIGN, "Test campaign");
            ContentOfferLoader.AddDmpOfferDetails(OfferId, CONTENT_REVENUE_SKU_ID, 2, OFFER_CAMPAIGN);

            // add a voucher code when any payment type is token
            foreach (OfferRegion region in OfferRegions)
            {
                if ((region.PaymentType & (int)PaymentTypeEnum.Token) != 0)
                {
                    // remove existing one first, use count -1 means unlimited
                    TokendbWS.AddVoucherForOffer(OFFER_VOUCHER_HASH, OfferId, VoucherUseCount, 0, 2);
                    break;
                }
            }

            // add preview offer
            if (PreviewOfferId > 0)
                ContentOfferLoader.AddPreviewOffer(OfferId, PreviewOfferId);

            // add asset to this offer
            if (OfferAsset.AssetID < uint.MaxValue && OfferAsset.Quantity > int.MinValue)
            {
                ContentOfferLoader.InsertOfferAsset(this.OfferId, this.TitleId, this.OfferAsset);
            }
            else
            {
                // have to make them to zeros because XeContentDetails and XeContentEnumerate are expecting that
                OfferAsset.AssetID = 0;
                OfferAsset.Quantity = 0;
            }

            // finally add this offer to Title Offers array
            if (this.offerTitle != null)
                this.offerTitle.Offers.Add(this);

            Global.RO.Info("##### Offer 0x" + OfferId.ToString("X") + " created ####");
            return true;
        }

        public void AddOfferRegion(int tierRequired, DateTime regionStartDate)
        {
            for (int i = 0; i < OfferRegions.Count && OfferRegions[i] != null; i++)
            {
                for (int j = 0; j < CountryIds.GetLength(0) && CountryIds[j] != 0; j++)
                {
                    ContentOfferLoader.AddOfferRegion(OfferId, CountryIds[j], tierRequired, ((OfferRegion)OfferRegions[i]).PaymentType, regionStartDate, RegionEndDate,
                        Boid, ((OfferRegion)OfferRegions[i]).PriceWhole, ((OfferRegion)OfferRegions[i]).PriceFractional, ((OfferRegion)OfferRegions[i]).OfferDetails);
                }
            }
        }

        public void UserHasPurchased(ulong userPuid, ulong machinePuid)
        {
            ContentOfferLoader.GrantContentLicense(userPuid, machinePuid, this.OfferId);
            this.HasPurchased = true;
        }

        /////////////////////////////////////////////////////////////////////////
        // some static functions

        public static void PurchaseAsset(ulong userPuid, ulong offerId)
        {
            ContentOfferLoader.GrantContentLicense(userPuid, XbosUser.DefaultMachinePuid, offerId);
        }

        public static void ConsumeAsset(ulong userPuid, ulong machinePuid, uint titleId, Asset[] assets)
        {
            XRLXeAssetConsume request = new XRLXeAssetConsume();
            request.UserPuid = userPuid;
            request.MachinePuid = machinePuid;
            request.TitleId = titleId;
            request.Assets = assets;

            if (!request.Execute())
                throw new UnexpectedTestResultException("XRLXeAssetConsume failed: " + request.GetDumpString());
        }

        public static Asset[] EnumerateAsset(ulong userPuid, ulong machinePuid, uint titleId)
        {
            XRLXeAssetEnumerate request = new XRLXeAssetEnumerate();
            XRLXeAssetEnumerateResponse response = new XRLXeAssetEnumerateResponse();
            request.UserPuid = userPuid;
            request.MachinePuid = machinePuid;
            request.TitleId = titleId;

            if (!request.Execute(out response))
                throw new UnexpectedTestResultException("XRLXeAssetEnumerate failed: " + request.GetDumpString());
            if (request.XErr != HResult.S_OK)
                throw new UnexpectedTestResultException(String.Format("XRLXeAssetEnumerate returned XErr=0x{0:x}", request.XErr));

            return response.Package.Assets;
        }

        public static XRLXeContentEnumerateResponse2 EnumerateContent(ulong userPuid, uint titleId)
        {
            XRLXeContentEnumerate2 request = new XRLXeContentEnumerate2();
            XRLXeContentEnumerateResponse2 response = new XRLXeContentEnumerateResponse2();

            request.UserPuid = userPuid;
            request.TierRequired = UodbWS.GetUserTier(userPuid);
            request.TitleID = titleId;
            request.SchemaVersion = WireData.MakeSchemaVersion(2, 0);

            if (!request.Execute(out response))
                throw new UnexpectedTestResultException("XRLXeContentEnumerate2 failed: " + request.GetDumpString());
            if (request.XErr != HResult.S_OK)
                throw new UnexpectedTestResultException(String.Format("XRLXeContentEnumerate2 returned XErr=0x{0:x}", request.XErr));

            return response;
        }

        public static XRLInGameContentEnumerateResponse InGameEnumerateContent(ulong userPuid, uint titleId)
        {
            XRLInGameContentEnumerate request = new XRLInGameContentEnumerate();
            XRLInGameContentEnumerateResponse response = new XRLInGameContentEnumerateResponse();

            request.UserPuid = userPuid;
            request.TierRequired = UodbWS.GetUserTier(userPuid);
            request.TitleID = titleId;
            request.SchemaVersion = WireData.MakeSchemaVersion(2, 0);

            if (!request.Execute(out response))
                throw new UnexpectedTestResultException("XRLInGameContentEnumerate failed: " + request.GetDumpString());
            if (request.XErr != HResult.S_OK)
                throw new UnexpectedTestResultException(String.Format("XRLInGameContentEnumerate returned XErr=0x{0:x}", request.XErr));

            return response;
        }

        public static XRLXeContentHistoryEnumerateResponse EnumerateContentHistory(ulong userPuid, ulong machinePuid)
        {
            XRLXeContentHistoryEnumerate request = new XRLXeContentHistoryEnumerate();
            XRLXeContentHistoryEnumerateResponse response = new XRLXeContentHistoryEnumerateResponse();

            request.UserPuid = userPuid;
            request.MachinePuid = machinePuid;
            request.SchemaVersion = WireData.MakeSchemaVersion(3, 0);

            if (!request.Execute(out response))
                throw new UnexpectedTestResultException("XRLXeContentHistoryEnumerate failed: " + request.GetDumpString());
            if (request.XErr != HResult.S_OK)
                throw new UnexpectedTestResultException(String.Format("XRLXeContentHistoryEnumerate returned XErr=0x{0:x}", request.XErr));

            return response;
        }

        public static XRLXeOfferingVerifyTokenResponse OfferingVerifyToken(byte country, string token)
        {
            XRLXeOfferingVerifyToken request = new XRLXeOfferingVerifyToken();
            XRLXeOfferingVerifyTokenResponse response = new XRLXeOfferingVerifyTokenResponse();
            request.CountryId = country;
            request.Voucher = token;

            if (!request.Execute(out response))
                throw new UnexpectedTestResultException("XRLXeOfferingVerifyToken failed: " + request.GetDumpString());
            if (request.XErr != HResult.S_OK)
                throw new UnexpectedTestResultException(String.Format("XRLXeOfferingVerifyToken returned XErr=0x{0:x}", request.XErr));

            return response;
        }

        public static XRLXeVerifyTokenResponse VerifyToken(ulong userPuid, ulong machinePuid, string token, uint storeId)
        {
            XRLXeVerifyToken request = new XRLXeVerifyToken();
            XRLXeVerifyTokenResponse response = new XRLXeVerifyTokenResponse();
            request.UserPuid = userPuid;
            request.MachinePuid = machinePuid;
            request.BillingToken = token;
            request.StoreId = storeId;

            if (!request.Execute(out response))
                throw new UnexpectedTestResultException("XRLXeVerifyToken failed: " + request.GetDumpString());
            if (request.XErr != HResult.S_OK)
                throw new UnexpectedTestResultException(String.Format("XRLXeVerifyToken returned XErr=0x{0:x}", request.XErr));

            return response;
        }

        // The console id is stored in the database using the following
        // format: XE.DDDDDDDDDDDC where Ds are decimal digits and C
        // is the checksum of the decimal digits. The binary version
        // of the console id, which is what we're interested in, uses 5
        // bytes: 4 bytes and one nible for the decimal digits and the
        // remainining nibble for the checksum.
        public static UInt64 ConvertConsoleIdFromDecimalStringToUInt64(string str)
        {
            byte digit;
            char c;

            // Remove prefix and trailing spaces
            str = str.Trim().ToUpper();

            if (str.Length != 15 ||
              !str.StartsWith("XE."))
            {
                throw new Exception("Invalid console-id: " + str);
            }

            str = str.Remove(0, 3);

            // Convert significant digits
            UInt64 consoleId = 0;
            UInt32 checksum = 0;

            for (int i = 0; i < str.Length - 1; i++)
            {
                c = str[i];

                if (c < '0' || c > '9')
                    throw new Exception("Invalid console-id: " + str);

                digit = (byte)(c - '0');
                consoleId = (consoleId * 10) + digit;
                checksum += digit;
            }

            // Verify id range
            if (consoleId == 0 || consoleId > 0x0FFFFFFFFF)
                throw new Exception("Invalid console-id: " + str);

            // Verify checksum
            checksum %= 10;
            digit = (byte)(str[str.Length - 1] - '0');
            if ((byte)checksum != digit)
                throw new Exception("Invalid console-id: " + str);

            // Build console id by incorporating the checksum nibble and
            // applying the console-id mask

            consoleId = ((consoleId << 4) | checksum) | XOn.XboxId.XenonConsoleBase;

            return consoleId;
        }

        public static byte GetConsoleIdLastDigit(string str)
        {
            byte digit;
            char c;

            // Remove prefix and trailing spaces
            str = str.Trim().ToUpper();

            if (str.Length != 14 ||
              !str.StartsWith("XE."))
            {
                throw new Exception("Invalid console-id: " + str);
            }

            str = str.Remove(0, 3);

            // Convert significant digits
            UInt64 consoleId = 0;
            UInt32 checksum = 0;

            for (int i = 0; i < str.Length; i++)
            {
                c = str[i];

                if (c < '0' || c > '9')
                    throw new Exception("Invalid console-id: " + str);

                digit = (byte)(c - '0');
                consoleId = (consoleId * 10) + digit;
                checksum += digit;
            }

            // Verify id range
            if (consoleId == 0 || consoleId > 0x0FFFFFFFFF)
                throw new Exception("Invalid console-id: " + str);

            // Verify checksum
            checksum %= 10;
            digit = (byte)checksum;

            return digit;
        }

        public static XRLXeContentRefreshLicenseResponse ContentRefreshLicense(ulong userPuid, ulong machinePuid, ContentLicense license)
        {
            XRLXeContentRefreshLicense request = new XRLXeContentRefreshLicense();
            XRLXeContentRefreshLicenseResponse response = new XRLXeContentRefreshLicenseResponse();

            request.UserId = userPuid;
            request.MachineId = machinePuid;
            request.License = license.ToArray();

            if (!request.Execute(out response))
                throw new UnexpectedTestResultException("XRLXeContentRefreshLicense execute failed: " + request.GetDumpString());
            if (request.XErr != HResult.S_OK)
                throw new UnexpectedTestResultException(String.Format("XRLXeContentRefreshLicense returned XErr=0x{0:x}", request.XErr));

            return response;
        }

        public static bool FindMatchMachineLicense(ulong userPuid, ulong machinePuid, string consoleId, byte[] contentId)
        {
            ulong licenseeId = ContentLicense.RevertByteOrder(ConvertConsoleIdFromDecimalStringToUInt64(consoleId));

            ContentLicense license = new ContentLicense();
            license.body.ContentId = contentId;
            XRLXeContentRefreshLicenseResponse response = ContentRefreshLicense(userPuid, machinePuid, license);

            license.ReadBytes(response.License);
            int count = license.body.GetUsedLicenseeCount();
            bool found = false;
            for (int i = 0; i < count; i++)
            {
                if (licenseeId == license.body.licensees[i].licenseeId)
                {
                    found = true;
                    break;
                }
            }

            return found;
        }

        public static void ContentUpdateAccessTimes(ulong userPuid, uint titleId, uint titleCategories)
        {
            XRLXeContentUpdateAccessTimes updateAccess = new XRLXeContentUpdateAccessTimes();
            updateAccess.UserPuid = userPuid;
            updateAccess.TitleCategories = titleCategories;
            updateAccess.TitleID = titleId;
            if (!updateAccess.Execute())
                throw new UnexpectedTestResultException("XRLXeContentUpdateAccessTimes failed: " + updateAccess.GetDumpString());
            if (updateAccess.XErr != HResult.S_OK)
                throw new UnexpectedTestResultException(String.Format("XRLXeContentUpdateAccessTimes returned XErr=0x{0:x}", updateAccess.XErr));
        }

        public static void OfferPurchase(ulong offerid, XeUser user)
        {
            OfferPurchase(offerid, user, (uint)PaymentTypeEnum.Points);
        }

        public static void OfferPurchase(ulong[] offerIds, XeUser user)
        {
            OfferPurchase(offerIds, user, (uint)PaymentTypeEnum.Points, "", "");
        }

        public static void OfferPurchase(ulong offerid, XeUser user, uint paymentType)
        {
            OfferPurchase(offerid, user, paymentType, "", "");
        }

        public static void OfferPurchase(ulong offerid, XeUser user, uint paymentType, string token, string paymentIntrumentId)
        {
            OfferPurchase(new ulong[] { offerid }, user, paymentType, token, paymentIntrumentId);
        }

        public static void OfferPurchase(ulong[] offerIds, XeUser user, uint paymentType, string token, string paymentIntrumentId)
        {
            OfferPurchase(offerIds, user, paymentType, token, paymentIntrumentId, HResult.S_OK, null);
        }

        public static void OfferPurchase(ulong[] offerIds, XeUser user, uint paymentType, string token, string paymentIntrumentId, uint expectedHR, string customeHeader)
        {
            XRLXeOfferPurchase purchaseRequest = new XRLXeOfferPurchase();
            purchaseRequest.UserPuid = user.UserPuid;
            purchaseRequest.CountryID = user.CountryId;
            purchaseRequest.LanguageID = user.LanguageId;
            purchaseRequest.Tier = (byte)UodbWS.GetUserTier(user.UserPuid);
            purchaseRequest.MachinePuid = user.MachinePuid;
            purchaseRequest.OfferID = 0;
            purchaseRequest.OfferIDs = offerIds;
            purchaseRequest.PaymentType = paymentType;
            purchaseRequest.BillingToken = token;
            purchaseRequest.PaymentInstrumentID = paymentIntrumentId;

            OfferPurchase(purchaseRequest, expectedHR, customeHeader);
        }
        
        public static void OfferPurchase(ulong offerid, XblUser user)
        {
            OfferPurchase(offerid, user, (uint)PaymentTypeEnum.Points);
        }

        public static void OfferPurchase(ulong offerid, XblUser user, uint paymentType)
        {
            OfferPurchase(offerid, user, paymentType, "", "");
        }

        public static void OfferPurchase(ulong offerid, XblUser user, uint paymentType, string token, string paymentIntrumentId)
        {
            OfferPurchase(offerid, user, paymentType, token, paymentIntrumentId, 1);
        }

        public static void OfferPurchase(ulong offerid, XblUser user, uint paymentType, string token, string paymentIntrumentId, ushort languageId)
        {
            OfferPurchase(new ulong[] { offerid }, user, paymentType, token, paymentIntrumentId, languageId);
        }

        public static void OfferPurchase(ulong[] offerIDs, XblUser user)
        {
            OfferPurchase(offerIDs, user, (uint)PaymentTypeEnum.Points, "", "", 1);
        }

        public static void OfferPurchase(ulong[] offerIDs, XblUser user, uint paymentType, string token, string paymentIntrumentId, ushort languageId)
        {
            OfferPurchase(offerIDs, user, paymentType, token, paymentIntrumentId, languageId, HResult.S_OK, null);
        }

        public static void OfferPurchase(ulong[] offerIDs, XblUser user, uint paymentType, string token, string paymentIntrumentId, ushort languageId, uint expectedHR, string customHeader)
        {
            UacsCommon2 uacs = new UacsCommon2();
            XRLXeOfferPurchase purchaseRequest = new XRLXeOfferPurchase();
            purchaseRequest.UserPuid = user.Puid;
            purchaseRequest.CountryID = (byte)uacs.GetBillingInfo(user).CountryId;
            purchaseRequest.LanguageID = languageId;
            purchaseRequest.Tier = (byte)UodbWS.GetUserTier(user.Puid);
            purchaseRequest.MachinePuid = XbosUser.DefaultMachinePuid;
            purchaseRequest.OfferID = 0;
            purchaseRequest.OfferIDs = offerIDs;
            purchaseRequest.PaymentType = paymentType;
            purchaseRequest.BillingToken = token;
            purchaseRequest.PaymentInstrumentID = paymentIntrumentId;

            OfferPurchase(purchaseRequest, expectedHR, customHeader);
        }
        
        public static void OfferPurchase(XRLXeOfferPurchase purchaseRequest, uint expectedHR, string customHeader)
        {
            // set custom header for BIF
            if (!string.IsNullOrEmpty(customHeader))
                purchaseRequest.CustomHeader += customHeader;

            if (expectedHR == HResult.S_OK)
            {
                if (!purchaseRequest.Execute())
                    throw new UnexpectedTestResultException("XRLXeOfferPurchase failed: " + purchaseRequest.GetDumpString());
                if (purchaseRequest.XErr != HResult.S_OK)
                    throw new UnexpectedTestResultException(String.Format("XRLXeOfferPurchase returned XErr=0x{0:x}", purchaseRequest.XErr));
            }
            else
            {
                if (purchaseRequest.Execute())
                    throw new UnexpectedTestResultException("Expect XRLXeOfferPurchase to fail: " + purchaseRequest.GetDumpString());
                if (purchaseRequest.XErr != expectedHR)
                    throw new UnexpectedTestResultException(String.Format("XRLXeOfferPurchase returned XErr=0x{0:x} but was expecting 0x{1:x}", purchaseRequest.XErr, expectedHR));
            }
        }
        
        public static void XePurchaseMediaOffer(ulong userPuid, uint storeId, OfferMediaTypeExpectedPrice[] offers,
            uint paymentType, string piId, string billingToken)
        {
            XePurchaseMediaOffer(userPuid, storeId, offers, paymentType, piId, billingToken, null, HResult.S_OK, null);
        }

        public static void XePurchaseMediaOffer(ulong userPuid, uint storeId, OfferMediaTypeExpectedPrice[] offers, 
            uint paymentType, string piId, string billingToken, SubscriptionPurchaseInfo subInfo, uint errorCode, string customHeader)
        {
            XRLPurchaseMediaOffers request = new XRLPurchaseMediaOffers();

            request.UserPuid = userPuid;
            request.Offers = offers;
            request.PaymentType = paymentType;
            request.PaymentInstrumentID = piId;
            request.BillingToken = billingToken;
            request.StoreId = storeId;
            if (subInfo != null)
                request.SubscriptionPurchaseInfo = subInfo;

            // set custom header for BIF
            if (!string.IsNullOrEmpty(customHeader))
                request.CustomHeader += customHeader;

            Global.RO.Info("");
            Global.RO.Info("XePurchaseMediaOffer: userPuid = 0x" + userPuid.ToString("x"));
            bool result = request.Execute();

            if (errorCode > HResult.S_OK)
            {
                Global.RO.Info("Expecting error = 0x" + errorCode.ToString("X") + ", error returned = 0x" + request.XErr.ToString("X"));
                ValueCheck.IsFalse(result, "Request should fail, HResult = 0x" + errorCode.ToString("x"));
                ValueCheck.TestHR("request.XErr", errorCode, request.XErr);
            }
            else
            {
                Global.RO.Info("Request XErr code returned = 0x" + request.XErr.ToString("X"));
                ValueCheck.IsTrue(result, "Request should succeed");
                ValueCheck.TestHR("request.XErr", HResult.S_OK, request.XErr);
            }
        }

        public static void PurchaseCCSubscription(XeUser user, string paymentInstrument, Guid offerId, uint priceWhole, uint priceFractional, int mediaTypeId, uint timeExtendedInMonths)
        {
            Global.RO.Info("user 0x{0:X} purchase offer {1}", user.UserPuid, offerId);

            //OfferMediaExpected Price
            OfferMediaTypeExpectedPrice[] Offers = new OfferMediaTypeExpectedPrice[1];
            Offers[0] = new OfferMediaTypeExpectedPrice();
            Offers[0].ExpectedPriceFractional = priceFractional;
            Offers[0].ExpectedPriceWhole = priceWhole;
            Offers[0].OfferId = offerId;
            Offers[0].MediaTypeId = mediaTypeId;

            SubscriptionPurchaseInfo subInfo = new SubscriptionPurchaseInfo();
            subInfo.subscriptionTimeExtendedInMonths = timeExtendedInMonths;

            XbosOffer.XePurchaseMediaOffer(user.UserPuid, (uint)StoreEnum.Xbox, Offers, (uint)PaymentTypeEnum.CreditCard, paymentInstrument, null, subInfo, HResult.S_OK, null);
        }

        public static void OfferingCancel(ulong userPuid, ulong offerId)
        {
            XRLOfferingCancel cancel = new XRLOfferingCancel();
            cancel.userPuid = userPuid;
            cancel.offeringId = offerId;
            if (!cancel.Execute())
            {
                throw new UnexpectedTestResultException("Failed to cancel: " + cancel.GetDumpString());
            }
            ValueCheck.TestHR("Offering Cancel request.XErr", HResult.S_OK, cancel.XErr);
        }

        public static void PurchaseFreeGamerTagGeneral(ulong xuid)
        {
            ServerTestFramework.LiveService.Billing.WebService2.SvcProviderWrapper Provider= new ServerTestFramework.LiveService.Billing.WebService2.SvcProviderWrapper();

            Guid  offerId = XbosWS.EMSOfferInfo.OfferIdToOfferingGuid(Offers.GetBaseOfferId(Offers.BaseOffers.FreeGamertagChange));
            //ulong offerId = Offers.GetBaseOfferId(Offers.BaseOffers.FreeGamertagChange);
            ulong machinePuid = UacsCommon.CreateWM7MachineUid();

            RandomEx rnd = new RandomEx();
            string gamertag = rnd.GenerateRandomString("XEN", 15);
            string token = "";
            
            uint  hr  = Provider.PurchaseGamertag(xuid, machinePuid, offerId, ServerTestFramework.LiveService.Billing.WebService2.PaymentTypeEnum.Points, gamertag, token);

            if (hr != HResult.S_OK) 
                throw new UnexpectedTestResultException(String.Format("PurchaseGamertag returned {0}", hr) );

            Global.RO.Info("Purchased Free Gamertag.");
        }

        public static uint GetPointsBalance(ulong userPuid)
        {
            XRLXeGetPointsBalance request = new XRLXeGetPointsBalance();
            XRLXeGetPointsBalanceResponse response = new XRLXeGetPointsBalanceResponse();
            request.userPuid = userPuid;

            if (!request.Execute(out response))
                throw new Exception("XRLXeGetPointsBalance failed: " + request.GetDumpString());
            if (request.XErr != HResult.S_OK)
                throw new Exception(String.Format("XRLXeGetPointsBalance returned XErr=0x{0:x}", request.XErr));

            return response.PointsBalance;
        }

        public static int RewardUSUser1600Points(XblUser user)
        {
            GetPointsBalance(user.Puid);
            OfferPurchase(Offers.GetPointsOfferId(Offers.PointsOffers.PP1600), user,
                (uint)PaymentTypeEnum.Token, Offers.GetPointsOfferVoucherCode(Offers.PointsOffers.PP1600), "");
            return 1600;
        }

        public static int RewardUSUser4000Points(XblUser user)
        {
            GetPointsBalance(user.Puid);
            OfferPurchase(Offers.GetPointsOfferId(Offers.PointsOffers.PP4000), user,
                (uint)PaymentTypeEnum.Token, Offers.GetPointsOfferVoucherCode(Offers.PointsOffers.PP4000), "");
            return 4000;
        }

        public static int RewardUSUser1600Points(XeUser user)
        {
            GetPointsBalance(user.UserPuid);
            OfferPurchase(Offers.GetPointsOfferId(Offers.PointsOffers.PP1600), user,
                (uint)PaymentTypeEnum.Token, Offers.GetPointsOfferVoucherCode(Offers.PointsOffers.PP1600), "");
            return 1600;
        }

        public static int RewardUSUser4000Points(XeUser user)
        {
            GetPointsBalance(user.UserPuid);
            OfferPurchase(Offers.GetPointsOfferId(Offers.PointsOffers.PP4000), user,
                (uint)PaymentTypeEnum.Token, Offers.GetPointsOfferVoucherCode(Offers.PointsOffers.PP4000), "");
            return 4000;
        }

        public static uint IncreaseUSUserPointsBalance(XblUser user, int pointsDesired)
        {
            string piVisa = AddPaymentInstrumentVisa(user.Puid, 103);

            Offers.PointsOffers [] pointsOffers =
            {
                Offers.PointsOffers.CC5000US,
                Offers.PointsOffers.CC5000US,
                Offers.PointsOffers.CC2000US
            };

            uint [] offerValues =
            {
                5000,
                5000,
                2000
            };

            uint balance = GetPointsBalance(user.Puid);

            int i = 0;
            while (balance < pointsDesired && i < pointsOffers.Length)
            {
                OfferPurchase(Offers.GetPointsOfferId(pointsOffers[i]), user,
                    (uint)PaymentTypeEnum.CreditCard, "", piVisa);

                balance += offerValues[i];
                i++;
            }

            // NOTE: we may exit the loop before reaching pointsDesired--there is a cap on
            // points balance that we abide by

            return GetPointsBalance(user.Puid);
        }

        public static string AddPaymentInstrumentVisa(ulong userPuid, byte country)
        {
            return AddPaymentInstrumentVisa(userPuid, country, HResult.S_OK, false);
        }

        // return null as the PaymentInstrumentId if there is an expection
        //
        public static string AddPaymentInstrumentVisa(ulong userPuid, byte country, uint errorCode, bool injectTimeout)
        {
            XRLXeAddPaymentInstrument request = new XRLXeAddPaymentInstrument();
            XRLXeAddPaymentInstrumentResponse response = new XRLXeAddPaymentInstrumentResponse();

            request.UserPuid = userPuid;
            request.AddressInfo = new AddressInfoData();
            request.AddressInfo.SetDefaultAddress((XeUser.Country)country);
            if (injectTimeout)
                request.CustomHeader = "InjectedScsError:AddPaymentInstrument:10\r\n";

            Global.RO.Info("");
            Global.RO.Info("AddPaymentInstrumentVisa: userPuid = 0x" + userPuid.ToString("x") + ", country = " + country);
            bool result = request.Execute(out response);

            if (errorCode > HResult.S_OK)
            {
                ValueCheck.IsFalse(result, "Request should fail, HResult = 0x" + errorCode.ToString("x"));
                ValueCheck.TestHR("request.XErr", errorCode, request.XErr);
                return null;
            }
            else
            {
                ValueCheck.IsTrue(result, "Request should succeed");
                ValueCheck.TestHR("request.XErr", HResult.S_OK, request.XErr);
                return response.PaymentInstrumentId;
            }
        }

        // return null as the PaymentInstrumentId if there is an expection
        //
        public static string AddPIDirectDebit(ulong userPuid, byte country, uint errorCode, string customHeader)
        {
            XRLXeAddPaymentInstrument request = new XRLXeAddPaymentInstrument();
            XRLXeAddPaymentInstrumentResponse response = new XRLXeAddPaymentInstrumentResponse();

            request.UserPuid = userPuid;
            request.AddressInfo = new AddressInfoData();
            request.AddressInfo.SetDefaultAddress((XeUser.Country)country);

            request.PaymentInstrumentType = (byte)XRLXeAddPaymentInstrument.PaymentInstrumentTypeEnum.DirectDebit;
            DirectDebitRandomizer dd = new DirectDebitRandomizer(Enum.GetName(typeof(XeUser.Country), country));
            dd.Randomize();
            request.DirectDebitInfo = new DirectDebitInfoData();
            request.DirectDebitInfo.AccountHolderName = "Tommy Lee";
            request.DirectDebitInfo.AccountNumber = dd.AccountNumber;
            request.DirectDebitInfo.BankCode = dd.BankCode;
            request.DirectDebitInfo.BranchCode = dd.BranchCode;
            request.DirectDebitInfo.CheckDigits = dd.CheckDigits;

            // set custom header for BIF
            if (!string.IsNullOrEmpty(customHeader))
                request.CustomHeader += customHeader;

            Global.RO.Info("");
            Global.RO.Info("AddPIDirectDebit: userPuid = 0x" + userPuid.ToString("x") + ", country = " + country);
            bool result = request.Execute(out response);

            if (errorCode > HResult.S_OK)
            {
                ValueCheck.IsFalse(result, "Request should fail, HResult = 0x" + errorCode.ToString("x"));
                ValueCheck.TestHR("request.XErr", errorCode, request.XErr);
                return null;
            }
            else
            {
                ValueCheck.IsTrue(result, "Request should succeed");
                ValueCheck.TestHR("request.XErr", HResult.S_OK, request.XErr);
                return response.PaymentInstrumentId;
            }
        }

        // Purchase points bundle offer using credit card.
        // If no payment instrument id is specified, a new payment instrument is added and is returned in the method call
        public static string PurchasePointsBundleCC(ulong userPuid, byte countryId, ushort languageId,
            string customHeader, uint hresult, string paymentInstrumentId, byte piCountry, Offers.PointsOffers pointsOffer, uint schemaVer)
        {
            if (string.IsNullOrEmpty(paymentInstrumentId))
                paymentInstrumentId = XbosOffer.AddPaymentInstrumentVisa(userPuid, piCountry);

            XRLXeOfferPurchase request = new XRLXeOfferPurchase();

            if (schemaVer != 0)
                request.SchemaVersion = schemaVer;

            request.UserPuid = userPuid;
            request.OfferID = Offers.GetPointsOfferId(pointsOffer);
            request.LanguageID = languageId;
            request.CountryID = countryId;
            request.Tier = (byte)UodbWS.GetUserTier(userPuid);
            request.PaymentType = (uint)PaymentTypeEnum.CreditCard;
            request.PaymentInstrumentID = paymentInstrumentId;
            if (!string.IsNullOrEmpty(customHeader))
                request.CustomHeader = customHeader;

            if (hresult != 0)
            {
                if (request.Execute())
                    throw new UnexpectedTestResultException("Expect XRLXeOfferPurchase to fail.");
                if (request.XErr != hresult)
                    throw new UnexpectedTestResultException(String.Format("XRLXeOfferPurchase returned XErr=0x{0:x}, but was expecting 0x{1:x}", request.XErr, hresult));
            }
            else
            {
                if (!request.Execute())
                    throw new UnexpectedTestResultException("XRLXeOfferPurchase failed: " + request.GetDumpString());
                if (request.XErr != HResult.S_OK)
                    throw new UnexpectedTestResultException(String.Format("XRLXeOfferPurchase returned XErr=0x{0:x}", request.XErr));
            }
            return paymentInstrumentId;
        }

        // add points using token for different countries
        public static int PurchasePoints(XeUser user, byte countryId)
        {
            int points = 0;
            XeUser.Country country = (XeUser.Country)countryId;
            switch (country)
            {
                case XeUser.Country.US:
                    XbosOffer.OfferPurchase(Offers.GetPointsOfferId(Offers.PointsOffers.PP1600), user,
                        (uint)PaymentTypeEnum.Token, Offers.GetPointsOfferVoucherCode(Offers.PointsOffers.PP1600), "");
                    points = 1600;
                    break;
                case XeUser.Country.AT:
                    XbosOffer.OfferPurchase(Offers.GetPointsOfferId(Offers.PointsOffers.PP2100), user,
                        (uint)PaymentTypeEnum.Token, Offers.GetPointsOfferVoucherCode(Offers.PointsOffers.PP2100), "");
                    points = 2100;
                    break;
                case XeUser.Country.AU:
                    XbosOffer.OfferPurchase(Offers.GetPointsOfferId(Offers.PointsOffers.PP1500), user,
                        (uint)PaymentTypeEnum.Token, Offers.GetPointsOfferVoucherCode(Offers.PointsOffers.PP1500), "");
                    points = 1500;
                    break;
                case XeUser.Country.BE:
                    XbosOffer.OfferPurchase(Offers.GetPointsOfferId(Offers.PointsOffers.PP2100), user,
                        (uint)PaymentTypeEnum.Token, Offers.GetPointsOfferVoucherCode(Offers.PointsOffers.PP2100), "");
                    points = 2100;
                    break;
                case XeUser.Country.CA:
                    XbosOffer.OfferPurchase(Offers.GetPointsOfferId(Offers.PointsOffers.PP1250), user,
                        (uint)PaymentTypeEnum.Token, Offers.GetPointsOfferVoucherCode(Offers.PointsOffers.PP1250), "");
                    points = 1250;
                    break;
                case XeUser.Country.CH:
                    XbosOffer.OfferPurchase(Offers.GetPointsOfferId(Offers.PointsOffers.PP2100), user,
                        (uint)PaymentTypeEnum.Token, Offers.GetPointsOfferVoucherCode(Offers.PointsOffers.PP2100), "");
                    points = 2100;
                    break;
                case XeUser.Country.DE:
                    XbosOffer.OfferPurchase(Offers.GetPointsOfferId(Offers.PointsOffers.PP2100), user,
                        (uint)PaymentTypeEnum.Token, Offers.GetPointsOfferVoucherCode(Offers.PointsOffers.PP2100), "");
                    points = 2100;
                    break;
                case XeUser.Country.DK:
                    XbosOffer.OfferPurchase(Offers.GetPointsOfferId(Offers.PointsOffers.PP2100), user,
                        (uint)PaymentTypeEnum.Token, Offers.GetPointsOfferVoucherCode(Offers.PointsOffers.PP2100), "");
                    points = 2100;
                    break;
                case XeUser.Country.ES:
                    XbosOffer.OfferPurchase(Offers.GetPointsOfferId(Offers.PointsOffers.PP2100), user,
                        (uint)PaymentTypeEnum.Token, Offers.GetPointsOfferVoucherCode(Offers.PointsOffers.PP2100), "");
                    points = 2100;
                    break;
                case XeUser.Country.FI:
                    XbosOffer.OfferPurchase(Offers.GetPointsOfferId(Offers.PointsOffers.PP2100), user,
                        (uint)PaymentTypeEnum.Token, Offers.GetPointsOfferVoucherCode(Offers.PointsOffers.PP2100), "");
                    points = 2100;
                    break;
                case XeUser.Country.FR:
                    XbosOffer.OfferPurchase(Offers.GetPointsOfferId(Offers.PointsOffers.PP2100), user,
                        (uint)PaymentTypeEnum.Token, Offers.GetPointsOfferVoucherCode(Offers.PointsOffers.PP2100), "");
                    points = 2100;
                    break;
                case XeUser.Country.HK:
                    XbosOffer.OfferPurchase(Offers.GetPointsOfferId(Offers.PointsOffers.PP1600), user,
                        (uint)PaymentTypeEnum.Token, Offers.GetPointsOfferVoucherCode(Offers.PointsOffers.PP1600), "");
                    points = 1600;
                    break;
                case XeUser.Country.IE:
                    XbosOffer.OfferPurchase(Offers.GetPointsOfferId(Offers.PointsOffers.PP2100), user,
                        (uint)PaymentTypeEnum.Token, Offers.GetPointsOfferVoucherCode(Offers.PointsOffers.PP2100), "");
                    points = 2100;
                    break;
                case XeUser.Country.IN:
                    XbosOffer.OfferPurchase(Offers.GetPointsOfferId(Offers.PointsOffers.PP1600), user,
                        (uint)PaymentTypeEnum.Token, Offers.GetPointsOfferVoucherCode(Offers.PointsOffers.PP1600), "");
                    points = 1600;
                    break;
                case XeUser.Country.IT:
                    XbosOffer.OfferPurchase(Offers.GetPointsOfferId(Offers.PointsOffers.PP2100), user,
                        (uint)PaymentTypeEnum.Token, Offers.GetPointsOfferVoucherCode(Offers.PointsOffers.PP2100), "");
                    points = 2100;
                    break;
                case XeUser.Country.JP:
                    XbosOffer.OfferPurchase(Offers.GetPointsOfferId(Offers.PointsOffers.PP3500), user,
                        (uint)PaymentTypeEnum.Token, Offers.GetPointsOfferVoucherCode(Offers.PointsOffers.PP3500), "");
                    points = 3500;
                    break;
                case XeUser.Country.KR:
                    XbosOffer.OfferPurchase(Offers.GetPointsOfferId(Offers.PointsOffers.PP1600), user,
                        (uint)PaymentTypeEnum.Token, Offers.GetPointsOfferVoucherCode(Offers.PointsOffers.PP1600), "");
                    points = 1600;
                    break;
                case XeUser.Country.MX:
                    XbosOffer.OfferPurchase(Offers.GetPointsOfferId(Offers.PointsOffers.PP1500), user,
                        (uint)PaymentTypeEnum.Token, Offers.GetPointsOfferVoucherCode(Offers.PointsOffers.PP1500), "");
                    points = 1500;
                    break;
                case XeUser.Country.NL:
                    XbosOffer.OfferPurchase(Offers.GetPointsOfferId(Offers.PointsOffers.PP2100), user,
                        (uint)PaymentTypeEnum.Token, Offers.GetPointsOfferVoucherCode(Offers.PointsOffers.PP2100), "");
                    points = 2100;
                    break;
                case XeUser.Country.NO:
                    XbosOffer.OfferPurchase(Offers.GetPointsOfferId(Offers.PointsOffers.PP2100), user,
                        (uint)PaymentTypeEnum.Token, Offers.GetPointsOfferVoucherCode(Offers.PointsOffers.PP2100), "");
                    points = 2100;
                    break;
                case XeUser.Country.NZ:
                    XbosOffer.OfferPurchase(Offers.GetPointsOfferId(Offers.PointsOffers.PP1500), user,
                        (uint)PaymentTypeEnum.Token, Offers.GetPointsOfferVoucherCode(Offers.PointsOffers.PP1500), "");
                    points = 1500;
                    break;
                case XeUser.Country.PT: // portugal
                    XbosOffer.OfferPurchase(Offers.GetPointsOfferId(Offers.PointsOffers.PP2100), user,
                        (uint)PaymentTypeEnum.Token, Offers.GetPointsOfferVoucherCode(Offers.PointsOffers.PP2100), "");
                    points = 2100;
                    break;
                case XeUser.Country.SE:
                    XbosOffer.OfferPurchase(Offers.GetPointsOfferId(Offers.PointsOffers.PP2100), user,
                        (uint)PaymentTypeEnum.Token, Offers.GetPointsOfferVoucherCode(Offers.PointsOffers.PP2100), "");
                    points = 2100;
                    break;
                case XeUser.Country.SG:
                    XbosOffer.OfferPurchase(Offers.GetPointsOfferId(Offers.PointsOffers.PP1600), user,
                        (uint)PaymentTypeEnum.Token, Offers.GetPointsOfferVoucherCode(Offers.PointsOffers.PP1600), "");
                    points = 1600;
                    break;
                case XeUser.Country.TW:
                    XbosOffer.OfferPurchase(Offers.GetPointsOfferId(Offers.PointsOffers.PP1600), user,
                        (uint)PaymentTypeEnum.Token, Offers.GetPointsOfferVoucherCode(Offers.PointsOffers.PP1600), "");
                    points = 1600;
                    break;
                case XeUser.Country.GB:
                    XbosOffer.OfferPurchase(Offers.GetPointsOfferId(Offers.PointsOffers.PP2100), user,
                        (uint)PaymentTypeEnum.Token, Offers.GetPointsOfferVoucherCode(Offers.PointsOffers.PP2100), "");
                    points = 2100;
                    break;
                default:
                    // for the other countries, purchase 500 points using CC
                    // do twice, so we get 1000 points
                    Global.RO.Info("Add 1000 pts by purchasing CC 500 pts twice.");
                    string pi = XbosOffer.PurchasePointsBundleCC(user.UserPuid, user.CountryId, user.LanguageId, null, 
                        HResult.S_OK, null, user.CountryId, Offers.PointsOffers.CC500US, 0);
                    XbosOffer.PurchasePointsBundleCC(user.UserPuid, user.CountryId, user.LanguageId, null,
                        HResult.S_OK, pi, user.CountryId, Offers.PointsOffers.CC500US, 0);
                    points = 1000;
                    break;
            }
            Global.RO.Info("PurchasePoints " + points + " for country: " + countryId);
            return points;
        }
    }

    public class XbosContentReferralLocation
    {
        public ushort Rank = 1;   // 1 based
        public string Xrl = "http://www.example.com/xbosdownload.xui";
    }

    /// <summary>
    /// Content class for Uodb loading purpose
    /// </summary>
    public class XbosContent
    {

        public byte[] ContentId;
        public byte[] SymKey;
        public byte[] PublicKey;
        public XbosContentReferralLocation[] Locations;
        public int PackageSize;
        public int InstallSize;

        public XbosContent(byte[] contentId, string contentXrl)
        {
            SetDefaults();
            contentId.CopyTo(this.ContentId, 0);
            this.Locations[0].Xrl = contentXrl;
        }

        public XbosContent()
        {
            SetDefaults();
        }

        private void SetDefaults()
        {
            Random r = new Random((int)DateTime.UtcNow.Ticks);
            ContentId = new byte[20];
            SymKey = new byte[16];
            PublicKey = new byte[284];
            r.NextBytes(ContentId);
            r.NextBytes(SymKey);
            r.NextBytes(PublicKey);
            Locations = new XbosContentReferralLocation[1];
            Locations[0] = new XbosContentReferralLocation();
            Locations[0].Xrl = Locations[0].Xrl + "?0x" + ContentOfferLoader.ByteString(ContentId); // make contentId part of the Xrl
            PackageSize = 2000;
            InstallSize = 1000;
        }

        public bool Create(byte[] contentId, string contentXrl)
        {
            contentId.CopyTo(this.ContentId, 0);
            this.Locations[0].Xrl = contentXrl;
            return Create();
        }

        public bool Create()
        {
            ContentOfferLoader.AddContent(ContentId, InstallSize, PackageSize, SymKey, PublicKey);
            for (int i = 0; i < Locations.GetLength(0); i++)
            {
                ContentOfferLoader.AddContentLocations(ContentId, Locations[i].Rank, Locations[i].Xrl);
            }
            return true;
        }
    }



    /// <summary>
    /// Subscription class for loading as well as knowing the expected output of
    /// requests.  Subscriptions are non-content offers--similar but less complex.
    /// One day the two should inherit from each other.
    ///
    /// This code has NOT BEEN TESTED yet.  It is put on hold while other items take precedence.
    /// </summary>
    public class XbosSubscription
    {
        public uint TitleId;
        public uint TierId;
        public ulong OfferId;
        public int BitFilter;
        public int OfferType;
        public string FriendlyName;
        public bool Cancelable;
        public string BillingComponentID;
        public uint PolicyFlags;
        public ushort GlobalOfferDetails;


        public int [] Countries = {103}; //used in setting regions.  To make a different set, modify
        public ArrayList Regions;        //this and call SetDefaultRegions.



        public int [] CultureIds = {1033}; //used in setting Cultures.  To make a different set, modify
        public ArrayList Cultures;         //this and call SetDefaultCultures.

        public class OfferCultureDetail {
            public int CultureId;
            public string Name;
            public string SellText;

            public OfferCultureDetail(int CultureId) {
                this.CultureId = CultureId;
                this.Name = "Xbos Subscription Test--" + "_" + CultureId; //would be nice to work
                                                                          //OfferId into this string
                this.SellText = this.Name + "_SellText";
            }

            public OfferCultureDetail(int CultureId, string Name, string SellText) {
                this.CultureId = CultureId;
                this.Name = Name;
                this.SellText = SellText;
            }

            public void AddToDB(ulong GivenOfferId) {
                ContentOfferLoader.AddOfferCultureDetails(GivenOfferId, CultureId, Name, SellText);
            }
        }


        public class SubscriptionOfferRegion {
            public byte CountryId = 103;
            public int TierRequired = 0;
            public int PaymentType = (int)PaymentTypeEnum.CreditCard;
            public DateTime StartDate = DateTime.UtcNow.AddYears(-2);
            public DateTime EndDate = DateTime.UtcNow.AddYears(2);
            public string Boid = "";
            public int PriceWhole = 0;
            public int PriceFractional = 0;
            public ushort OfferDetails = 0;

            public SubscriptionOfferRegion() {
            }

            public void AddToDB(ulong OfferId) {

                ContentOfferLoader.AddOfferRegion(OfferId, CountryId, TierRequired, PaymentType,
                                                  StartDate, EndDate, Boid, PriceWhole,
                                                  PriceFractional, OfferDetails);
            }

        }


        public XbosSubscription() {
            SetDefaults();
            SetDefaultRegions();
            SetDefaultCultures();
        }

        public void SetDefaults() {
            TitleId = 0xfffe07d1;
            TierId = 6;
            OfferId = 0xfffe07d18000001B; //get these cleared by Mei-Mei
            BitFilter = -1;
            OfferType = (int)OfferingTypeEnum.Subscription;
            FriendlyName = "Xbos Subscription Test";
            Cancelable = false;//??
            BillingComponentID = "";//?  dropped?
            PolicyFlags = (int)OfferPolicies.PerMachineRights;
            GlobalOfferDetails = 0;

            Cultures = new ArrayList();

            Regions = new ArrayList();
        }

        public void SetDefaultRegions() {
            int [] tierList = {0,3,6};  //tiers involved.
            foreach (int Country in Countries) {
                foreach (int tier in tierList ) {
                    SubscriptionOfferRegion Region = new SubscriptionOfferRegion();
                    Region.TierRequired = tier;
                    Region.PriceWhole = tier;  //just to provide some nice test data.
                    Region.PriceFractional = tier; //same here.  $0.00, $3.03, $6.06.
                    Regions.Add(Region);
                }
            }
        }

        public void SetDefaultCultures() {
            foreach(int CultureId in CultureIds) {
                OfferCultureDetail NewCulture = new OfferCultureDetail(CultureId);
                Cultures.Add(NewCulture);
            }
        }

        //Add this XbosSubscription to the DB
        public void InsertLiveSubscription() {
            ContentOfferLoader.AddLiveSubscriptionOffer(TitleId, TierId, OfferId,
                                                         BitFilter, OfferType,
                                                         FriendlyName, Cancelable,
                                                         BillingComponentID, PolicyFlags,
                                                        GlobalOfferDetails, 2);  //2==Xenon subs
            //add cultures
            foreach (OfferCultureDetail Culture in Cultures) {
                Culture.AddToDB(OfferId);
            }
            //add regions
            foreach (SubscriptionOfferRegion Region in Regions) {
                Region.AddToDB(OfferId);
            }
        }

        //Remove this XbosSubscription from the DB.  NOTE--this calls a cleaning sproc that does not
        //remove existing subscriptions from the t_subscriptions table.
        public void CleanLiveSubscription() {
            ContentOfferLoader.CleanOffers(OfferId);
        }

    }

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\Billing\DRM\XRLXeWmdrmCreateCertificate.cs ===
using System.IO;

using ServerTestFramework.LiveService;
using xonline.common.config;
using xonline.common.service;

namespace ServerTestFramework.LiveService.Billing.DRM
{
    public class XRLXeWmdrmCreateCertificateRequest : XRLPayload
    {
        public XRLXeWmdrmCreateCertificateRequest ()
        {
            ServiceId = XOService.DRM;
        }


        public const int DEVICE_PUBLIC_KEY_LEN = 40;

        [XRLPayloadFld(Serialize=false)]
        public uint keyLength;


        //[WireInfo(Min=0, Max=0)]
        public uint flags;


        //[WireInfo(ArraySize=DEVICE_PUBLIC_KEY_LEN)]
        [WireInfo(SizeParam="keyLength")]
        public byte[] devicePublicKey;


        [XRLPayloadFld(Serialize=false)]
        public XRLXeWmdrmCreateCertificateReply reply = null;


        protected override void ReadResponse (MemoryStream responseStream)
        {
            reply = new XRLXeWmdrmCreateCertificateReply();
            reply.ReadStream(responseStream);
        }


        private string serviceName = "/xbos/XeWmdrmCreateCertificate.ashx";
        public string ServiceName
        {
            get { return serviceName; }
            set { serviceName = value; }
        }
        protected override string GetServiceName ()
        {
            return serviceName;
        }


        public override bool Execute ()
        {
            return base.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xbos_billing_offering));
        }
    }

    public class XRLXeWmdrmCreateCertificateReply : XRLPayload
    {
        public const int DEVICE_CERTIFICATE_BLOCK_MAX_COUNT = 2;


        //[WireInfo(Min=1, Max=DEVICE_CERTIFICATE_BLOCK_MAX_COUNT)]
        public ushort certBlockCount;


        [WireInfo(SizeParam="certBlockCount")]
        public XRLXeWmdrmCertificateBlock[] certBlocks;
    }

    public class XRLXeWmdrmCertificateBlock : XRLPayload
    {
        public const int DEVICE_CERTIFICATE_BLOCK_MAX_LEN = 3000;


        //[WireInfo(Min=1, Max=DEVICE_CERTIFICATE_BLOCK_MAX_LEN)]
        public ushort certBlockLength;


        [WireInfo(SizeParam="certBlockLength")]
        public byte[] certBlock;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\Billing\xbox1\XRLAutoupdReferral.cs ===
using System;
using System.IO;
using System.Net;
using System.Text;
using xonline.common.config;

namespace ServerTestFramework.LiveService.Billing
{
	/// <summary>
	/// Summary description for XRLOfferingDetails.
	/// </summary>
	public class XRLAutoUpdateReferral : XRLPayload
	{
		[XRLPayloadFld(IsMPuid=true)]
		public ulong      MachineId            =0;    
		[XRLPayloadFld(IsTitleId=true)]
		public uint       TitleId              =0;    
        [XRLPayloadFld(IsTitleVersion=true)]
		public uint		dwBaseVersion		= 0;// Base version (Dash only)
			
		[XRLPayloadFld(Serialize=false)]
		public XRLAutoUpdateReferralHead Head;
		[XRLPayloadFld(Serialize=false)]
		public XRLAutoUpdateReferralLocation []Locs;

		protected override string GetServiceName()
		{
			return "/xbos/AutoupdReferral.ashx";
		}

		protected override void ReadResponse(MemoryStream respBuff)
		{
			Head = new XRLAutoUpdateReferralHead();
			Head.ReadStream( respBuff );

			Locs = new XRLAutoUpdateReferralLocation[Head.Locations];
			for (int i = 0; i < Head.Locations; i++)
			{
				Locs[i]=new XRLAutoUpdateReferralLocation();
				Locs[i].ReadStream( respBuff );
			}
		}

		public override bool Execute()
		{
            return Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xbos_autoupdate));
		}
	}


	public class XRLAutoUpdateReferralLocation : XRLPayload
	{
		public ushort Rank;             // Rank
		public ushort XrlLen;			// Length of XRL
		public string Xrl;            // XRL to update package
	}

	public class XRLAutoUpdateReferralHead : XRLPayload
	{
		public ushort Flags;			// Flags
		public ushort Locations;		// Number of XRLs 
		public uint   PackageSize;		// Wire size of package
		public uint   InstallSize;		// Accurate install size
		public uint   TitleVersion;		// Update version
		[WireInfo(ArraySize=16)]          
		public byte[] SymKey;           // Symmetric key
		[WireInfo(ArraySize=284)]          
		public byte[] PubKey;           // Public key

		// Followed by cLocations of packed XoAutoupdReferralLocation records
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\Billing\xbox1\XRLContentAvailable.cs ===
using System;
using System.IO;
using System.Net;
using System.Text;
using xonline.common.config;

namespace ServerTestFramework.LiveService.Billing
{
	/// <summary>
	/// Summary description for XRLContentAvailable.
	/// </summary>
	public class XRLContentAvailable:XRLPayload
	{
		[XRLPayloadFld(IsTitleId=true)]
		public uint		TitleId =0;
		public int		EsrbRating =0;
		public uint		BitFilter =0;
		public DateTime LastChangeDate = DateTime.Now.AddYears(-1);
		public byte		CountryId = 0;

		protected override string GetServiceName()
		{
			return "/xbos/ContentAvailable.ashx";
		}

		public override bool Execute()
		{
            return Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xbos_autoupdate));
		}

	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\Billing\xbox1\XRLGetProductFeatures.cs ===
using System;
using System.IO;
using System.Net;
using ServerTestFramework.Utilities;
using ServerTestFramework.LiveService.FakeSG;
using ServerTestFramework.Database;


/* Wire protocol:
	public class GetProductFeaturesRequest : XRLObject2
    {
        public int productId;
        public int LCID;
        public string Xrl
        {
            get 
            { 
                return "/xbos/GetProductFeatures.ashx"; 
            }
        }
    }
	
    public class GetProductFeaturesResponse : XRLObject2
    {
        public ushort playersOffline;
        public ushort playersSystemLink;
        public ushort playersLive;
        public int HDTVModeRank;
        public ushort HDTVModeLength;
        [WireInfo(SizeParam="HDTVModeLength")]
        public string HDTVMode;
        public ushort HDTVModeResourceNameLength;
        [WireInfo(SizeParam="HDTVModeResourceNameLength")]
        public string HDTVModeResourceName;
        public bool camera;
        public bool hardDriveEnhanced;
        public bool dolby51;
        public bool liveAware;
        public bool customSoundtrack;
        public bool liveContentDownload;
        public bool userCreatableContent;
        public bool liveMultiplayer;
        public bool multiplayerVersus;
        public bool liveCoOp;
        public bool coOp;
        public bool liveClan;
        public bool memoryUnit;
        public bool liveTournaments;
        public bool peripherals;
        public bool liveScoreboard;
        public bool premiumOffers;
        public bool liveStats;
        public bool systemLink;
        public bool liveVoice;
        public bool XboxSupport;
        public bool Xbox2Support;
        public bool liveMessaging;
        public bool liveVoiceMessaging;
        public bool liveServiceProxy;
    }
 */

namespace ServerTestFramework.LiveService.Billing
{
	public class XRLGetProductFeatures 
	{
		public class XRLGetProductFeaturesRequest : XRLPayload
		{
			public int ProductId = 0;
			public int LCID = 0;

			protected override string GetServiceName()
			{
				return "/xbos/GetProductFeatures.ashx";
			}

			public override bool Execute(IPEndPoint endPoint)
			{
				int class_size = this.Size();
				MemoryStream memory_stream = new MemoryStream(class_size);
				WriteStream(memory_stream);
 
				bool return_value = false;
				return_value = InternalExecute(endPoint, memory_stream);

				if (return_value == true)
				{
					if ((xAct.httpStatus == HttpStatusCode.OK) && (HResult.Succeeded(xAct.XErr)))
					{
						// read the response here
						//m_response = new XRLXeContentDetailsResponse();
						//if (xAct.ResponseContents.Length > 0)
						//	m_response.ReadStream(new MemoryStream(xAct.ResponseContents));
						return_value = true;
					}
				}

				return return_value;
			}
		}


		public class XRLGetProductFeaturesResponse : XRLPayload
		{

		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\Billing\XbosUser.cs ===
using System;
using System.Collections;
using System.Data;
using ServerTestFramework.Database;
using ServerTestFramework.Utilities;
using ServerTestFramework.LiveService.UserAccount;

namespace ServerTestFramework.LiveService.Billing
{
    /// <summary>
    /// Argo user for music and video purchase
    /// </summary>
    public class ArgoUser : XeUser
    {
        public ArgoUser()
            : base()
        {
            ArgoCreate(true, 0);
        }

        public ArgoUser(bool withPaymentInstrument)
            : base()
        {
            ArgoCreate(withPaymentInstrument, 0);
        }

        public ArgoUser(string gamerTag, Country countryId, ulong machinePuid, bool withPaymentInstrument) 
            : base(true, gamerTag, countryId)
        {
            ArgoCreate(withPaymentInstrument, machinePuid);
        }

        protected void ArgoCreate(bool withPaymentInstrument, ulong machinePuid)
        {
            if (machinePuid > 0)
                this.MachinePuid = machinePuid;
            if (withPaymentInstrument)
            {
                this.OfferId = Offers.GetBaseOfferId(Offers.BaseOffers.GoldCC1Year);
                this.PaymentInstrumentType = PaymentInstrumentInfoEx.PaymentInstrumentTypeEnum.CreditCard;
                this.CreditCardInfo = CreditCardRandomizer.GenerateVisaCard();
            }
            if (this.Create() == 0) throw new UnexpectedTestResultException("XeUser.Create() failed: " + this.GetDumpString());
            UodbWS.WaitForQueueRemoval(this.UserPuid, false);
        }
    }

    /// <summary>
    /// Xenon user used by Xbos
    /// </summary>
    public class XbosUser
    {
        public const ulong DefaultMachinePuid = 0xfa00000012341234;
        public delegate void CustomizeXeUserDelegate(XeUser user);

        // user account types
        public const byte Xbox1Account = 0;
        public const byte XboxComAccount = 1;
        public const byte XenonAccount = 2;
        public const byte ZuneAccount = 3;
        public const byte PanoramaAccount = 4;

        // Xbox1 user, default to not waiting callback
        public static Owner Xbox1User()
        {
            return Xbox1User(false);
        }

        // Xbox1 user
        public static Owner Xbox1User(bool waitForCallbackCompletion)
        {
            UacsCommon UACS = new UacsCommon();
            Owner owner = UACS.GenerateOwner();
            if (owner.Create() == 0)
                throw new UnexpectedTestResultException("Owner.Create() failed: " + owner.GetDumpString());

            UodbWS.WaitForQueueRemoval(owner.UserPuid, waitForCallbackCompletion);

            return owner;
        }

        public static ulong Xbox1MigratedUser()
        {
            // create an xbox1 user
            Owner owner = Xbox1User();

            // migrate the xbox1 user
            XRLXeMigrateXbox1User request = new XRLXeMigrateXbox1User();
            XRLXeMigrateXbox1UserResponse response = new XRLXeMigrateXbox1UserResponse();

            request.SignedUserPassportPuid = PassportUtilities.GenerateSessionToken(request.Slot.Key);
            request.SignedParentPassportPuid = request.SignedUserPassportPuid;
            request.UserPassportMemberName = "xbltest-" + Guid.NewGuid().ToString() + Global.PassportMemberDomain;
            request.OfflineXuid = 0;

            // link the xbox1 account to the web
            ulong passportPuid = PassportUtilities.GetPuidFromSessionToken(request.SignedUserPassportPuid);
            owner.LinkToPassport(passportPuid);

            if (!request.Execute(out response))
                throw new UnexpectedTestResultException("XRLXeMigrateXbox1User failed: " + request.GetDumpString());
            if (request.XErr != HResult.S_OK)
                throw new UnexpectedTestResultException(String.Format("XRLXeMigrateXbox1User returned XErr=0x{0:x}", request.XErr));

            return owner.UserPuid;
        }

        public static XeUser MinorUser()
        {
            XeUser parent = new XeUser(true);
            ulong userPuid = parent.Create();
            if (userPuid == 0) throw new UnexpectedTestResultException("Parent XeUser.Create failed: " + parent.GetDumpString());
            XeUser user = new XeUser(true);
            userPuid = user.CreateMinor(parent, true);  // minor
            if (userPuid == 0) throw new UnexpectedTestResultException("Minor XeUser.Create failed: " + user.GetDumpString());
            Global.RO.Info("A minor user is created");
            
            return user;
        }

        public static XeUser JuvenileUser()
        {
            XeUser parent = new XeUser(true);
            ulong userPuid = parent.Create();
            if (userPuid == 0) throw new UnexpectedTestResultException("Parent XeUser.Create failed: " + parent.GetDumpString());
            XeUser user = new XeUser(true);
            userPuid = user.CreateMinor(parent, false); // Juvenile
            if (userPuid == 0) throw new UnexpectedTestResultException("Juvenile XeUser.Create failed: " + user.GetDumpString());
            Global.RO.Info("A juvenile user is created");

            return user;
        }

        // Xenon silver user, default to not waiting callback
        public static XeUser XenonSilverUser()
        {
            return XenonSilverUser(0, false);
        }

        public static XeUser XenonSilverUser(ulong machinePuid)
        {
            return XenonSilverUser(machinePuid, false);
        }

        // Xenon silver user
        public static XeUser XenonSilverUser(ulong machinePuid, bool waitForCallbackCompletion)
        {
            return XenonSilverUser(machinePuid, waitForCallbackCompletion, "", XeUser.Country.US, XeUser.Language.en);
        }

        public static XeUser XenonSilverUser(ulong machinePuid, bool waitForCallbackCompletion, string gamerTag, XeUser.Country country, XeUser.Language language)
        {
            return XenonSilverUser(machinePuid, waitForCallbackCompletion, gamerTag, country, language, null);
        }

        public static XeUser XenonSilverUser(ulong machinePuid, bool waitForCallbackCompletion, string gamerTag, XeUser.Country country, XeUser.Language language, CustomizeXeUserDelegate customize)
        {
            XeUser user;
            if (string.IsNullOrEmpty(gamerTag))
                user = new XeUser(true, country);
            else
                user = new XeUser(true, gamerTag, country);
            user.LanguageId = (ushort)language;
            if (machinePuid > 0)
                user.MachinePuid = machinePuid;

            // execute customization delegate (if one was provided)
            if (customize != null)
            {
                customize(user);
            }

            if (user.Create() == 0) throw new UnexpectedTestResultException("XeUser.Create() failed: " + user.GetDumpString());
            UodbWS.WaitForQueueRemoval(user.UserPuid, waitForCallbackCompletion);

            return user;
        }

        // Xenon gold user, default to PP 1 year and not waiting callback
        public static XeUser XenonGoldUser()
        {
            return XenonGoldPPUser();
        }

        public static XeUser XenonGoldUser(XeUser.Country country, bool waitForCallbackCompletion)
        {
            XeUser user = new XeUser(true, country);
            user.CreateAsGold = true;

            if (user.Create() == 0) throw new UnexpectedTestResultException("XeUser.Create() failed: " + user.GetDumpString());
            UodbWS.WaitForQueueRemoval(user.UserPuid, waitForCallbackCompletion);

            return user;
        }

        public static XeUser XenonGoldUser(ulong machinePuid)
        {
            return XenonGoldPPUser(machinePuid);
        }

        // Xenon gold PP user, default to PP 1 year and not waiting callback
        public static XeUser XenonGoldPPUser()
        {
            return XenonGoldPPUser(0);
        }

        public static XeUser XenonGoldPPUser(ulong machinePuid)
        {
            return XenonGoldPPUser(Offers.BaseOffers.GoldPP1Year, machinePuid, false);
        }

        // Xenon gold CC user, default to CC 1 year and not waiting callback
        public static XeUser XenonGoldCCUser()
        {
            return XenonGoldCCUser(Offers.BaseOffers.GoldCC1Year, 0, false);
        }

        // Xenon gold PP user
        public static XeUser XenonGoldPPUser(Offers.BaseOffers ppOffer, ulong machinePuid, bool waitForCallbackCompletion)
        {
            XeUser user = new XeUser(true);
            if (machinePuid > 0)
                user.MachinePuid = machinePuid;
            user.OfferId = Offers.GetBaseOfferId(ppOffer);
            user.BillingToken = Offers.GetBaseOfferPrepaidVoucherCode(ppOffer);

            if (user.Create() == 0) throw new UnexpectedTestResultException("XeUser.Create() failed: " + user.GetDumpString());
            UodbWS.WaitForQueueRemoval(user.UserPuid, waitForCallbackCompletion);

            return user;
        }

        // Xenon gold CC user
        public static XeUser XenonGoldCCUser(Offers.BaseOffers ccOffer, ulong machinePuid, bool waitForCallbackCompletion)
        {
            XeUser user = new XeUser(true);
            if (machinePuid > 0)
                user.MachinePuid = machinePuid;
            user.OfferId = Offers.GetBaseOfferId(ccOffer);
            user.PaymentInstrumentType = PaymentInstrumentInfoEx.PaymentInstrumentTypeEnum.CreditCard;
            user.CreditCardInfo = CreditCardRandomizer.GenerateVisaCard();

            if (user.Create() == 0) throw new UnexpectedTestResultException("XeUser.Create() failed: " + user.GetDumpString());
            UodbWS.WaitForQueueRemoval(user.UserPuid, waitForCallbackCompletion);

            return user;
        }

        // common function
        public static void DisableSub(ulong userPuid, SubscriptionStatus status, bool violation, int numOfSub, int statusId)
        {
            DisableSub(userPuid, status, violation, numOfSub, statusId, null);
        }

        // common function
        public static void DisableSub(ulong userPuid, SubscriptionStatus status, bool violation, int numOfSub, int statusId, string serviceInstanceId)
        {
            // keep track of the last change time, so we can wait on SCG long enough
            SubscriptionInfo[] si = UodbWS.GetUserServiceIDs(userPuid);
            DateTime lastChange = DateTime.UtcNow.AddYears(-100);
            for (int i = 0; i < si.Length; i++)
            {
                if (lastChange < si[i].changeTime)
                    lastChange = si[i].changeTime;
            }

            XRLDisableSubscription request = new XRLDisableSubscription();

            request.UserPuid = userPuid;
            if (serviceInstanceId == null)
                request.ServiceInstanceId = UodbWS.GetUsersSubscriptionInstanceId(userPuid);
            else
                request.ServiceInstanceId = serviceInstanceId;
            request.SubscriptionStatusId = (int)status;
            request.AddViolation = violation;

            // need the machine puid match, otherwise AddPaymentInstrument will fail
            request.ManualPopulateSlot();
            request.Slot.machinePuid = 0xfa00000012341234;

            if (!request.Execute())
                throw new UnexpectedTestResultException("DisableSubscription failed: " + request.GetDumpString());
            if (request.XErr != HResult.S_OK)
                throw new UnexpectedTestResultException(String.Format("DisableSubscription returned XErr=0x{0:x}", request.XErr));

            // give SCG enough time to process, max wait 240 seconds
            DateTime newLastChange = DateTime.UtcNow.AddYears(-100);
            for (int num = 0; num < 80; num++)
            {
                Global.RO.Info("Attemp #" + num);
                System.Threading.Thread.Sleep(3000);
                // get the new last change time
                si = UodbWS.GetUserServiceIDs(userPuid);
                newLastChange = DateTime.UtcNow.AddYears(-100);
                for (int i = 0; i < si.GetLength(0); i++)
                {
                    if (newLastChange < si[i].changeTime)
                        newLastChange = si[i].changeTime;
                }
                if (newLastChange > lastChange)
                    break;
            }

            Global.RO.Info("Number of subscriptions: {0:}", si.GetLength(0));
            for (int i = 0; i < si.GetLength(0); i++)
            {
                Global.RO.Info("{0} subscription status: {1}", i, si[i].statusId);
            }

            // get user type from t_users table
            byte userType = Convert.ToByte(UodbWS.GetUserProperty(userPuid, "ti_account_type"));
            Global.RO.Info("Status: " + status.ToString() + ", violation: " + violation + ", Account type in t_users table: " + userType);
            if (userType == XenonAccount)
            {
                byte downGraded = Convert.ToByte(UodbWS.GetUserProperty(userPuid, "f_downgraded"));
                Global.RO.Info("f_downgraded flag in t_users table: " + downGraded);
                if (statusId >= 3 && statusId <= 4 && !violation)
                {
                    // Flag the user as having been downgraded to silver (only if no billing violations) and not suspended
                    if (downGraded != 1)
                        throw new UnexpectedTestResultException("Downgraded flag should be 1");
                }
            }

            // suspened, canceled, expired
            if (statusId >= 2 && statusId <= 4)
            {
                // account requires management
                UserInfo ui = UodbWS.GetUserInfo(userPuid);
                Global.RO.Info("BillingAccountStatus in t_users table: " + ui.billingAccountStatus.ToString("X"));
                if (ui.billingAccountStatus != 0x80151200) // XONLINE_E_LOGON_USER_ACCOUNT_REQUIRES_MANAGEMENT
                    throw new UnexpectedTestResultException("User status: 0x" + ui.billingAccountStatus.ToString("X"));
            }

            if (si.GetLength(0) != numOfSub)
                throw new UnexpectedTestResultException(string.Format("Expected number of subscription - {0}, returned - {1}", numOfSub, si.GetLength(0)));
            for (int i = 0; i < numOfSub; i++)
            {
                if (si[i].statusId != statusId)
                {
                    // statusId 10 is the old subscription
                    if (si[i].statusId == 10 || si[i].statusId == 0)
                        continue;
                    else
                        throw new UnexpectedTestResultException(string.Format("Expected status id - {0}, returned - {1}", statusId, si[i].statusId));
                }
            }
        }

        public static XRLXeSubscriptionEnumerateResponse XeSubscriptionEnumerate(ulong userPuid, byte countryId, ushort languageId, uint offerType, ushort requestFlags)
        {
            return XeSubscriptionEnumerate(userPuid, countryId, languageId, offerType, requestFlags, XOn.XENON_DASH_TITLE_ID);
        }

        public static XRLXeSubscriptionEnumerateResponse XeSubscriptionEnumerate(ulong userPuid, byte countryId, ushort languageId, uint offerType, ushort requestFlags, uint titleId)
        {
            XRLXeSubscriptionEnumerate enumRequest = new XRLXeSubscriptionEnumerate();
            XRLXeSubscriptionEnumerateResponse enumResponse = new XRLXeSubscriptionEnumerateResponse();

            enumRequest.UserPuid = userPuid;
            enumRequest.UserTier = UodbWS.GetUserTier(userPuid);
            enumRequest.TitleID = titleId;
            enumRequest.CountryID = countryId;
            enumRequest.LanguageID = languageId;
            enumRequest.GameRating = 0xFF;  // all possible game rating
            enumRequest.OfferType = offerType;
            enumRequest.PaymentType = (uint)PaymentTypeEnum.All;
            enumRequest.RequestFlags = requestFlags;

            if (!enumRequest.Execute(out enumResponse))
                throw new UnexpectedTestResultException("XRLXeSubscriptionEnumerate failed: " + enumRequest.GetDumpString());
            if (enumRequest.XErr != HResult.S_OK)
                throw new UnexpectedTestResultException(String.Format("XRLXeSubscriptionEnumerate returned XErr=0x{0:x}", enumRequest.XErr));

            Global.RO.Info(enumResponse.OffersReturned.ToString() + " eligible subscription(s) found.");

            for (int i = 0; i < enumResponse.OffersReturned; i++)
            {
                Global.RO.Info("\t" + i.ToString() + " - offerid:0x" + enumResponse.Subscriptions[i].OfferID.ToString("X") +
                               " name:" + enumResponse.Subscriptions[i].OfferName);
            }
            return enumResponse;
        }

        public enum UserSubType
        {
            Gold,
            Silver,
            FreeTrial,
            FortyEightHoursGamePlay
        };

        /// <summary>
        /// check if the user has the correct privileges
        /// </summary>
        /// <param name="userPuid"></param>
        /// <param name="pType"></param>
        public static void CheckDefaultPrivileges(ulong userPuid, UserSubType pType)
        {
            UserPrivileges privs = new UserPrivileges(XeGetUserWebInfo(userPuid).UserPrivileges);

            Global.RO.Info("CheckDefaultPrivileges for " + pType);

            ArrayList a = new ArrayList();

            if (pType == UserSubType.Gold)
            {
                a.AddRange(UserPrivileges._goldDefaults);
            }
            else if (pType == UserSubType.Silver)
            {
                a.AddRange(UserPrivileges._silverDefaults);
            }
            else if (pType == UserSubType.FortyEightHoursGamePlay)
            {
                a.AddRange(UserPrivileges._silverDefaults);
                a.AddRange(UserPrivileges._48HoursGamePlayAddon);
            }
            else if (pType == UserSubType.FreeTrial)
            {
                a.AddRange(UserPrivileges._silverDefaults);
                a.AddRange(UserPrivileges._freeTrialAddon);
            }

            for (byte i = UserPrivileges.XONLINE_PRIVILEGE_MIN; i <= UserPrivileges.XONLINE_PRIVILEGE_MAX; i++)
            {
                if (!a.Contains(i))
                {
                    ValueCheck.IsTrue(!privs[(int)i], "Should not set Privilege: " + i);
                }
                else
                    ValueCheck.IsTrue(privs[(int)i], "Missing Privilege: " + i);

                if (i == UserPrivileges.XONLINE_PRIVILEGE_MAX) break;
            }

            Global.RO.Success("CheckDefaultPrivileges passed");
        }

        // get user privileges through an API for web
        public static XRLXeGetUserWebInfoResponse XeGetUserWebInfo(ulong userPuid)
        {
            XRLXeGetUserWebInfo requestWeb = new XRLXeGetUserWebInfo();
            XRLXeGetUserWebInfoResponse response = new XRLXeGetUserWebInfoResponse();
            requestWeb.UserPuid = userPuid;
            if (!requestWeb.Execute(out response))
                throw new UnexpectedTestResultException("XRLXeGetUserWebInfo failed: " + requestWeb.GetDumpString());
            if (requestWeb.XErr != HResult.S_OK)
                throw new UnexpectedTestResultException(String.Format("XRLXeGetUserWebInfo returned XErr=0x{0:x}", requestWeb.XErr));
            return response;
        }

        public static void UpdatePrivilege(ulong userPuid, bool grant, int priv)
        {
            UserPrivileges oldPrivs;
            UserPrivileges newPrivs;
            UserPrivileges revokePrivs;
            oldPrivs = new UserPrivileges(XeGetUserWebInfo(userPuid).UserPrivileges);

            XRLXeUpdateParentalControls request = new XRLXeUpdateParentalControls();

            request.UserPuid = userPuid;
            request.Source = "stftest"; // this is the grantor of the priv (for auditing)
            UserPrivileges privs = new UserPrivileges();
            UserPrivileges restrictPrivs = new UserPrivileges();
            privs.SetAllPrivs(true);
            privs.SetPrivilege(priv, grant);
            restrictPrivs.SetAllPrivs(false);
            restrictPrivs.SetPrivilege(priv, !grant);

            request.UserGrantPrivileges = privs.ToArray();
            request.UserRestrictPrivileges = restrictPrivs.ToArray();
            request.ManualPopulateSlot();
            request.Slot.wBuildNumber = 2908; // a build number for 2006 sprind release
            request.Slot.wMajorVersion = 2;
            request.Slot.wMinorVersion = 0;

            if (!request.Execute())
                throw new UnexpectedTestResultException("XeUpdateParentalControlsTests failed: " + request.GetDumpString());
            if (request.XErr != HResult.S_OK)
                throw new UnexpectedTestResultException(String.Format("XeUpdateParentalControlsTests returned XErr=0x{0:x}", request.XErr));

            // get the updated privileges
            privs = new UserPrivileges(XeGetUserWebInfo(userPuid).UserPrivileges);
            UodbWS.GetUserPrivileges(userPuid, out newPrivs, out revokePrivs);

            //if (privs.ToArray()[7] != 0x9bf9a000)    // same as the silver adult account
            //    throw new UnexpectedTestResultException("The privileges are not updated as expected.");
            //if (revokePrivs.ToArray()[7] != 0x04000000)
            //    throw new UnexpectedTestResultException("Revoke privileges don't match for video message.");
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\Billing\xbox1\XRLGetGenres.cs ===
using System;
using System.IO;
using System.Net;
using ServerTestFramework.Utilities;
using ServerTestFramework.LiveService.FakeSG;
using ServerTestFramework.Database;


/* Wire protocol:
	public class GetGenresRequest : XRLObject2
    {
        public int productType;
        public string Xrl
        {
            get 
            { 
                return "/xbos/GetGenres.ashx"; 
            }
        }
    } 
	
	public class GetGenresResponse : XRLObject2
    {
        public ushort genresReturned = 0;
        [WireInfo(SizeParam="genresReturned")]
        public GenreInfo [] genres;
    }

    public class GenreInfo : XRLObject2
    {
        public int genreId = 0;
        public ushort genreNameLength = 0;
        [WireInfo(SizeParam="genreNameLength")]
        public string genreName = "";
        public ushort genreResourceLength = 0;
        [WireInfo(SizeParam="genreResourceLength")]
        public string resourceName = "";
    }
*/

namespace ServerTestFramework.LiveService.Billing
{
	public class XRLGetGenres 
	{
		public class XRLGetGenresRequest : XRLPayload
		{
			public int ProductType = 0;

			protected override string GetServiceName()
			{
				return "/xbos/GetGenres.ashx";
			}

			public override bool Execute(IPEndPoint endPoint)
			{
				int class_size = this.Size();
				MemoryStream memory_stream = new MemoryStream(class_size);
				WriteStream(memory_stream);
 
				bool return_value = false;
				return_value = InternalExecute(endPoint, memory_stream);

				if (return_value == true)
				{
					if ((xAct.httpStatus == HttpStatusCode.OK) && (HResult.Succeeded(xAct.XErr)))
					{
						// read the response here
						//m_response = new XRLXeContentDetailsResponse();
						//if (xAct.ResponseContents.Length > 0)
						//	m_response.ReadStream(new MemoryStream(xAct.ResponseContents));
						return_value = true;
					}
				}

				return return_value;
			}
		}


		public class XRLGetGenresResponse : XRLPayload
		{

		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\Billing\xbox1\XRLContentReferral.cs ===
using System;
using System.IO;
using System.Net;
using System.Text;
using xonline.common.config;
using xonline.common.service;

namespace ServerTestFramework.LiveService.Billing
{
	/// <summary>
	/// Summary description for XRLOfferingDetails.
	/// </summary>
	public class XRLContentReferral : XRLPayload
	{
		[XRLPayloadFld(IsMPuid=true)]
		public ulong		MachineId				=0;
		[XRLPayloadFld(IsUPuid=true)]
		public ulong		UserPuid0				=0;
		public ulong		UserPuid1				=0;
		public ulong		UserPuid2				=0;
		public ulong		UserPuid3				=0;
		[XRLPayloadFld(IsTitleId=true)]
		public uint			TitleId					=0;
		public ulong		OfferingId				=0;
		public uint			Rating					=0;

		[XRLPayloadFld(Serialize=false)]
		public XRLContentReferralHead Head;

		[XRLPayloadFld(Serialize=false)]
		public XRLContentReferralLocation []Locs;

		public XRLContentReferral()
		{
			this.ServiceId = XOService.Billing_Offering;
		}

		protected override string GetServiceName()
		{
			return "/xbos/ContentReferral.ashx";
		}

		protected override void ReadResponse(MemoryStream respBuff)
		{
			Head = new XRLContentReferralHead();
			Head.ReadStream( respBuff );

			Locs = new XRLContentReferralLocation[Head.Locations];

			for (int i=0; i < Head.Locations; i++)
			{
				Locs[i] = new XRLContentReferralLocation();
				Locs[i].ReadStream( respBuff );
			}
		}

		public override bool Execute()
		{
			return Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xbos_billing_offering));
		}

	}


	public class XRLContentReferralLocation : XRLPayload
	{
		public ushort Rank;             // Rank
		public ushort XrlLen;			// Length of XRL
		public string Xrl;            // XRL to update package
	}

	public class XRLContentReferralHead : XRLPayload
	{
		public ushort Flags;			// Flags
		public ushort Locations;		// Number of XRLs
		public uint   PackageSize;		// Wire size of package
		public uint   InstallSize;		// Accurate install size
		public uint   BitFlags;			// Update version
		[WireInfo(ArraySize=16)]
		public byte[] SymKey;           // Symmetric key
		[WireInfo(ArraySize=284)]
		public byte[] PubKey;           // Public key

		// Followed by cLocations of packed XoAutoupdReferralLocation records
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\Billing\xbox1\XRLGetRatings.cs ===
using System;
using System.IO;
using System.Net;
using ServerTestFramework.Utilities;
using ServerTestFramework.LiveService.FakeSG;
using ServerTestFramework.Database;


/* Wire protocol:
	public class GetRatingsRequest : XRLObject2
    {
        public int LCID;
        public string Xrl
        {
            get 
            { 
                return "/xbos/GetRatings.ashx"; 
            }
        }
    }

    public class GetRatingsResponse : XRLObject2
    {
        public ushort ratingsReturned = 0;
        [WireInfo(SizeParam="ratingsReturned")]
        public RatingInfo [] ratings;
    }

    public class RatingInfo : XRLObject2
    {
        public int ratingId;
        public int ratingOrder;
        public ushort ratingNameLength;
        [WireInfo(SizeParam="ratingNameLength")]
        public string ratingName;
        public ushort ratingResourceLength;
        [WireInfo(SizeParam="ratingResourceLength")]
        public string resourceName;
    }
 */

namespace ServerTestFramework.LiveService.Billing
{
	public class XRLGetRatings 
	{
		public class XRLGetRatingsRequest : XRLPayload
		{
			public int LCID = 0;

			protected override string GetServiceName()
			{
				return "/xbos/GetRatings.ashx";
			}

			public override bool Execute(IPEndPoint endPoint)
			{
				int class_size = this.Size();
				MemoryStream memory_stream = new MemoryStream(class_size);
				WriteStream(memory_stream);
 
				bool return_value = false;
				return_value = InternalExecute(endPoint, memory_stream);

				if (return_value == true)
				{
					if ((xAct.httpStatus == HttpStatusCode.OK) && (HResult.Succeeded(xAct.XErr)))
					{
						// read the response here
						//m_response = new XRLXeContentDetailsResponse();
						//if (xAct.ResponseContents.Length > 0)
						//	m_response.ReadStream(new MemoryStream(xAct.ResponseContents));
						return_value = true;
					}
				}

				return return_value;
			}
		}


		public class XRLGetRatingsResponse : XRLPayload
		{

		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\Billing\xbox1\XRLGetProductAssets.cs ===
using System;
using System.IO;
using System.Net;
using ServerTestFramework.Utilities;
using ServerTestFramework.LiveService.FakeSG;
using ServerTestFramework.Database;


/* Wire protocol:
	public class GetProductAssetsRequest : XRLObject2
    {
        public int productId;
        public int LCID;
        public int assetTypeId;
        public string Xrl
        {
            get 
            { 
                return "/xbos/GetProductAssets.ashx"; 
            }
        }
    }

    public class GetProductAssetsResponse : XRLObject2
    {
        public int assetsReturned = 0;
        [WireInfo(SizeParam="assetsReturned")]
        public AssetInfo [] assets;
    }    

    public class AssetInfo : XRLObject2
    {
        public ushort nameLength;
        [WireInfo(SizeParam="nameLength")]
        public string name;
        public ushort CMSGuidLength;
        [WireInfo(SizeParam="CMSGuidLength")]
        public string CMSGuid;
        public ushort ThumbnailCMSGuidLength;
        [WireInfo(SizeParam="ThumbnailCMSGuidLength")]
        public string ThumbnailCMSGuid;
    }
 */

namespace ServerTestFramework.LiveService.Billing
{
	public class XRLGetProductAssets 
	{
		public class XRLGetProductAssetsRequest : XRLPayload
		{
			public int ProductId = 0;
			public int LCID = 0;
			public int AssetTypeId = 0;

			protected override string GetServiceName()
			{
				return "/xbos/GetProductAssets.ashx";
			}

			public override bool Execute(IPEndPoint endPoint)
			{
				int class_size = this.Size();
				MemoryStream memory_stream = new MemoryStream(class_size);
				WriteStream(memory_stream);
 
				bool return_value = false;
				return_value = InternalExecute(endPoint, memory_stream);

				if (return_value == true)
				{
					if ((xAct.httpStatus == HttpStatusCode.OK) && (HResult.Succeeded(xAct.XErr)))
					{
						// read the response here
						//m_response = new XRLXeContentDetailsResponse();
						//if (xAct.ResponseContents.Length > 0)
						//	m_response.ReadStream(new MemoryStream(xAct.ResponseContents));
						return_value = true;
					}
				}

				return return_value;
			}
		}


		public class XRLGetProductAssetsResponse : XRLPayload
		{

		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\Billing\xbox1\XRLGetProductInfo.cs ===
using System;
using System.IO;
using System.Net;
using ServerTestFramework.Utilities;
using ServerTestFramework.LiveService.FakeSG;
using ServerTestFramework.Database;


/* Wire protocol:
	public class GetProductInfoRequest : XRLObject2
    {
        public int productId;
        public int LCID;
        public string Xrl
        {
            get 
            { 
                return "/xbos/GetProductInfo.ashx"; 
            }
        }
    }

    public class GetProductInfoResponse : XRLObject2
    {
        public ushort imageCMSGuidLength;
        [WireInfo(SizeParam="imageCMSGuidLength")]
        public string imageCMSGuid;
        public ushort titleLength;
        [WireInfo(SizeParam="titleLength")]
        public string title;
        public uint descriptionLength;
        [WireInfo(SizeParam="descriptionLength")]
        public string description;        
        public ushort developerLength;
        [WireInfo(SizeParam="developerLength")]
        public string developer;        
        public ushort developerUrlLength;
        [WireInfo(SizeParam="developerUrlLength")]
        public string developerUrl;
        public ushort publisherLength;
        [WireInfo(SizeParam="publisherLength")]
        public string publisher;        
        public ushort publisherUrlLength;
        [WireInfo(SizeParam="publisherUrlLength")]
        public string publisherUrl;        
        public ushort manufacturerLength;
        [WireInfo(SizeParam="manufacturerLength")]
        public string manufacturer;        
        public ushort manufacturerUrlLength;
        [WireInfo(SizeParam="manufacturerUrlLength")]
        public string manufacturerUrl;
        public bool platinumHit;
        public bool XboxExclusive;
        public double price;
        public int genre;
        public ushort genreNameLength;
        [WireInfo(SizeParam="genreNameLength")]
        public string genreName;
        public ushort genreResourceNameLength;
        [WireInfo(SizeParam="genreResourceNameLength")]
        public string genreResourceName;            
        public ushort genreTextLength;
        [WireInfo(SizeParam="genreTextLength")]
        public string genreText;        
        public int rating;
        public ushort ratingNameLength;
        [WireInfo(SizeParam="ratingNameLength")]
        public string ratingName;    
        public ushort ratingResourceNameLength;
        [WireInfo(SizeParam="ratingResourceNameLength")]
        public string ratingResourceName;        
        public ushort ratingDescriptionLength;
        [WireInfo(SizeParam="ratingDescriptionLength")]
        public string ratingDescription;
        public bool XboxSupport;
        public bool Xbox2Support;
        public DateTime releaseDate;
        public ushort releaseDateStringLength;
        [WireInfo(SizeParam="releaseDateStringLength")]
        public string releaseDateString;        
    }
 */

namespace ServerTestFramework.LiveService.Billing
{
	public class XRLGetProductInfo 
	{
		public int ProductId = 0;
		public int LCID = 0;

		public class XRLGetProductInfoRequest : XRLPayload
		{
			protected override string GetServiceName()
			{
				return "/xbos/GetProductInfo.ashx";
			}

			public override bool Execute(IPEndPoint endPoint)
			{
				int class_size = this.Size();
				MemoryStream memory_stream = new MemoryStream(class_size);
				WriteStream(memory_stream);
 
				bool return_value = false;
				return_value = InternalExecute(endPoint, memory_stream);

				if (return_value == true)
				{
					if ((xAct.httpStatus == HttpStatusCode.OK) && (HResult.Succeeded(xAct.XErr)))
					{
						// read the response here
						//m_response = new XRLXeContentDetailsResponse();
						//if (xAct.ResponseContents.Length > 0)
						//	m_response.ReadStream(new MemoryStream(xAct.ResponseContents));
						return_value = true;
					}
				}

				return return_value;
			}
		}

		public class XRLGetProductInfoResponse : XRLPayload
		{

		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\Billing\xbox1\XRLOfferingDetailsNoUser.cs ===
using System;
using System.IO;
using System.Net;
using System.Text;
using xonline.common.config;

namespace ServerTestFramework.LiveService.Billing
{
	/// <summary>
	/// Summary description for XRLOfferingDetails.
	/// </summary>
	public class XRLOfferingDetailsNoUser:XRLPayload
	{
		public byte			CountryId			 =0;
		[XRLPayloadFld(IsMPuid=true)]
		public ulong		MachineId            =0;
		[XRLPayloadFld(IsTitleId=true)]
		public uint			TitleId              =0;
		public ulong		OfferId              =0;
		public int			DescriptionIndex     =0;
		public short		LanguageId           =3;

		[XRLPayloadFld(Serialize=false)]
		public XRLOfferingDetailsResp Resp;

		protected override string GetServiceName()
		{
			return "/xbos/OfferingDetailsNoUser.ashx";
		}

		protected override void ReadResponse(MemoryStream respBuff)
		{
			Resp = new XRLOfferingDetailsResp();
			Resp.ReadStream( respBuff );
		}

		public override bool Execute()
		{
			return Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xbos_autoupdate));
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\Billing\xbox1\XRLGetUpcomingProducts.cs ===
using System;
using System.IO;
using System.Net;
using ServerTestFramework.Utilities;
using ServerTestFramework.LiveService.FakeSG;
using ServerTestFramework.Database;


/* Wire protocol:
	public class GetUpcomingProductsRequest : XRLObject2
    {
        public int LCID;
        public int productTypeId;
        public DateTime currentDate;
        public uint daysBefore;
        public uint daysAfter;
        public string Xrl
        {
            get 
            { 
                return "/xbos/GetUpcomingProducts.ashx"; 
            }
        }
    }

    public class GetUpcomingProductsResponse : XRLObject2
    {
        public int productsReturned = 0;
        [WireInfo(SizeParam="productsReturned")]
        public GetUpcomingProductsInfo [] products;
    }    

    public class GetUpcomingProductsInfo : XRLObject2
    {
        public int productId;
        public ushort titleLength;
        [WireInfo(SizeParam="titleLength")]
        public string title;
        public ushort shortTitleLength;
        [WireInfo(SizeParam="shortTitleLength")]
        public string shortTitle;
        public uint descriptionLength;
        [WireInfo(SizeParam="descriptionLength")]
        public string description;        
        public ushort developerLength;
        [WireInfo(SizeParam="developerLength")]
        public string developer;        
        public ushort developerUrlLength;
        [WireInfo(SizeParam="developerUrlLength")]
        public string developerUrl;
        public ushort publisherLength;
        [WireInfo(SizeParam="publisherLength")]
        public string publisher;        
        public ushort publisherUrlLength;
        [WireInfo(SizeParam="publisherUrlLength")]
        public string publisherUrl;        
        public ushort manufacturerLength;
        [WireInfo(SizeParam="manufacturerLength")]
        public string manufacturer;        
        public ushort manufacturerUrlLength;
        [WireInfo(SizeParam="manufacturerUrlLength")]
        public string manufacturerUrl;
        public ushort productUrlLength;
        [WireInfo(SizeParam="productUrlLength")]
        public string productUrl;
        public int genre;
        public ushort genreNameLength;
        [WireInfo(SizeParam="genreNameLength")]
        public string genreName;    
        public ushort genreResourceNameLength;
        [WireInfo(SizeParam="genreResourceNameLength")]
        public string genreResourceName;                
        public ushort genreTextLength;
        [WireInfo(SizeParam="genreTextLength")]
        public string genreText;        
        public int rating;
        public ushort ratingNameLength;
        [WireInfo(SizeParam="ratingNameLength")]
        public string ratingName;    
        public ushort ratingResourceNameLength;
        [WireInfo(SizeParam="ratingResourceNameLength")]
        public string ratingResourceName;    
        public ushort ratingDescriptionLength;
        [WireInfo(SizeParam="ratingDescriptionLength")]
        public string ratingDescription;
        public bool XboxSupport;
        public bool Xbox2Support;
        public DateTime releaseDate;
        public ushort releaseDateStringLength;
        [WireInfo(SizeParam="releaseDateStringLength")]
        public string releaseDateString;
    }
 */

namespace ServerTestFramework.LiveService.Billing
{
	public class XRLGetUpcomingProducts 
	{
		public class XRLGetUpcomingProductsRequest : XRLPayload
		{
			public int LCID = 0;
			public int ProductTypeId = 0;
			public DateTime CurrentDate = DateTime.UtcNow;
			public uint DaysBefore = 0;
			public uint DaysAfter = 0;

			protected override string GetServiceName()
			{
				return "/xbos/GetUpcomingProducts.ashx";
			}

			public override bool Execute(IPEndPoint endPoint)
			{
				int class_size = this.Size();
				MemoryStream memory_stream = new MemoryStream(class_size);
				WriteStream(memory_stream);
 
				bool return_value = false;
				return_value = InternalExecute(endPoint, memory_stream);

				if (return_value == true)
				{
					if ((xAct.httpStatus == HttpStatusCode.OK) && (HResult.Succeeded(xAct.XErr)))
					{
						// read the response here
						//m_response = new XRLXeContentDetailsResponse();
						//if (xAct.ResponseContents.Length > 0)
						//	m_response.ReadStream(new MemoryStream(xAct.ResponseContents));
						return_value = true;
					}
				}

				return return_value;
			}
		}


		public class XRLGetUpcomingProductsResponse : XRLPayload
		{

		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\Billing\xbox1\XRLOfferingPurchase.cs ===
using System;
using System.IO;
using System.Net;
using System.Text;
using xonline.common.config;

namespace ServerTestFramework.LiveService.Billing
{
	/// <summary>
	/// using System;
	/// </summary>
	public class XRLOfferingPurchase : XRLPayload
	{
		[XRLPayloadFld(IsUPuid=true )]
		public ulong userPuid;

		[XRLPayloadFld(IsMPuid=true )]
		public ulong machinePuid;

		[XRLPayloadFld(IsTitleId=true)]
		public uint titleId=0xfffe0000;

		public ulong offeringId;

		protected override string GetServiceName()
		{
			return "/xbos/OfferingPurchase.ashx";
		}

		public override bool Execute()
		{
			return Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xbos_billing_offering));
		}

		public override string GetDumpString()
		{
			return "UserPuid: " + userPuid.ToString("X") + ", MachinePuid "  + machinePuid.ToString("X") +
				", TitleID: " + titleId.ToString("X") + ", OfferingID: " + offeringId.ToString("X") + "\nBASE: " + base.GetDumpString();
		}

	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\Billing\xbox1\XRLOfferingDetails.cs ===
using System;
using System.IO;
using System.Net;
using System.Text;
using xonline.common.config;

namespace ServerTestFramework.LiveService.Billing
{
	/// <summary>
	/// Summary description for XRLOfferingDetails.
	/// </summary>
	public class XRLOfferingDetails:XRLPayload
	{
		[XRLPayloadFld(IsUPuid=true)]
		public ulong      UserPuid             =0;
		[XRLPayloadFld(IsMPuid=true)]
		public ulong      MachineId            =0;
		[XRLPayloadFld(IsTitleId=true)]
		public uint       TitleId              =0;
		public ulong      OfferId              =0;
		public int        DescriptionIndex     =0;
		public short      LanguageId            =3;

		[XRLPayloadFld(Serialize=false)]
		public XRLOfferingDetailsResp Resp;

		public XRLOfferingDetails()
		{
			//
			// TODO: Add constructor logic here
			//
		}

		protected override string GetServiceName()
		{
			return "/xbos/OfferingDetails.ashx";
		}

		protected override void ReadResponse(MemoryStream respBuff)
		{
			Resp = new XRLOfferingDetailsResp();
			Resp.ReadStream( respBuff );
		}

		public override bool Execute()
		{
			return Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xbos_billing_offering));
		}

	}

	public class XRLOfferingDetailsResp : XRLPayload
	{
		public uint   Instances                 =0;
		public uint   WholePart;
		public byte   FractionalPart;
		public byte   CurrencyFormat;
		[WireInfo(ArraySize=3)]
		public string ISOCode;
		public uint   OfferingDetails;
		public uint   BlobLen= 0;
		public byte[] Blob;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\Billing\xbox1\XRLOfferingCancel.cs ===
using System;
using System.IO;
using System.Net;
using System.Text;
using xonline.common.config;

namespace ServerTestFramework.LiveService.Billing
{
	/// <summary>
	/// using System;
	/// </summary>
	public class XRLOfferingCancel : XRLPayload
	{
		[XRLPayloadFld(IsUPuid=true )]
		public ulong userPuid;

		public ulong offeringId;

		protected override string GetServiceName()
		{
			return "/xbos/OfferingCancel.ashx";
		}

		public override bool Execute()
		{
			return Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xbos_billing_offering));
		}

		public XRLOfferingCancel()
		{}

		public XRLOfferingCancel(XRLOfferingPurchase other)
		{
			GetFrom(other);
		}

		public void GetFrom(XRLOfferingPurchase other)
		{
			this.userPuid=other.userPuid;
			this.offeringId=other.offeringId;
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\Billing\xbox1\XRLVerifyNickname.cs ===
using System;
using System.IO;
using System.Net;
using ServerTestFramework.Utilities;
using xonline.common.config;

namespace ServerTestFramework.LiveService.Billing
{
	/// <summary>
	/// Summary description for XRLVerifyNickname.
	/// </summary>
	public class XRLVerifyNickname: XRLPayload
	{
		public short NameLen                =0;
		public string Name                  ="";

		protected override string GetServiceName()
		{
			return "/xbos/VerifyNickname.ashx";
		}

		public override string GetDumpString()
		{
			string outputString = "Nickname: '"+Name+"' " + base.GetDumpString();
			return outputString;
		}

		public override bool Execute()
		{
            return Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xbos_base_subscription));
		}

		public bool Execute(byte[] nickname )
		{
            return Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xbos_base_subscription), nickname);
		}

		public bool Execute(LiveServer server, byte[] nickname)
		{
			return Execute(server.EPDefault, nickname);
		}

		public bool Execute(IPEndPoint endPoint, byte[] nickname )
		{
			MemoryStream reqStream = new MemoryStream( 512 );
			BinaryWriter writer= new BinaryWriter(reqStream);

			writer.Write((short)nickname.Length);
			writer.Write(nickname, 0, nickname.Length);

			bool uRet = false;
			bool bRet=InternalExecute(endPoint, reqStream);

			if( bRet )
			{
				if( (xAct.httpStatus == HttpStatusCode.OK) && (xAct.XErr == 0) )
				{
					uRet=true;
				}
			}

			return uRet;
		}

		public XRLVerifyNickname()
		{
			//
			// TODO: Add constructor logic here
			//
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\Billing\Xenon\XRLFindMediaInstanceUrls.cs ===
using System;
using System.IO;
using System.Net;
using ServerTestFramework.Utilities;
using ServerTestFramework.LiveService.FakeSG;
using ServerTestFramework.Database;
using xonline.common.config;


namespace ServerTestFramework.LiveService.Billing
{
    public class XRLFindMediaInstanceUrls: XRLPayload
    {
        public uint mediaInstanceIdCount;

        [WireInfo(SizeParam="mediaInstanceIdCount")]
        public Guid[] mediaInstanceIds;

        public XRLFindMediaInstanceUrls()
        {
            // setup some default values
        }

        protected override string GetServiceName()
        {
            return "/xbos/FindMediaInstanceUrls.ashx";
        }

        public bool Execute(out XRLFindMediaInstanceUrlsResponse Response)
        {
            return Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xbos_billing_offering), out Response);
        }

        public bool Execute(LiveServer sServer, out XRLFindMediaInstanceUrlsResponse Response)
        {
            return Execute(sServer.EPDefault, out Response);
        }

        public bool Execute(IPEndPoint endPoint, out XRLFindMediaInstanceUrlsResponse Response)
        {
            MemoryStream reqStream = new MemoryStream( 512 );
            WriteStream( reqStream );

            bool uRet = false;
            bool bRet=InternalExecute(endPoint,reqStream);

            Response = null;
 
            if(bRet)
            {
                if( (xAct.httpStatus == HttpStatusCode.OK) && (xAct.XErr == 0) )
                {
                    Response = new XRLFindMediaInstanceUrlsResponse();
                    MemoryStream respBuff = new MemoryStream(xAct.ResponseContents);
                    Response.ReadStream(respBuff);

                    uRet = true;
                }
            }

            return uRet;
        }

        public string Xrl
        {
            get
            {
                return "/xbos/FindMediaInstanceUrls.ashx";
            }
        }
    }

    public enum MediaUrlType : int
    {
        Video               = 1,
        VideoChapter        = 2,    // unsupported by XBOX client
        SAMI                = 3,
        Image               = 4,
        Music               = 5,
        GameContent         = 6
    }

    public class TypedMediaUrl : WireData
    {
        // We can't serialize enumerations, but we can just add an accessor to convert 
        // it automatically for us
        public int type;

        public MediaUrlType Type
        {
            get { return (MediaUrlType)type; }
        }

        public uint length;
        
        [WireInfo(SizeParam="length")]
        public string url;
    }

    public class MediaInstanceUrl : WireData
    {
        [WireInfo(MinSchemaVersion = "4.1")]
        public Guid mediaId;

        public Guid mediaInstanceId;
        
        public uint fileCount;

        [WireInfo(SizeParam="fileCount")]
        public TypedMediaUrl[] urls;
    }

    public class XRLFindMediaInstanceUrlsResponse : XRLPayload
    {
        public uint mediaInstanceIdCount;

        [WireInfo(SizeParam="mediaInstanceIdCount")]
        public MediaInstanceUrl[] mediaInstanceUrls;
    }

    
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\Billing\xbox1\XRLOfferingEnumerate.cs ===
using System;
using System.IO;
using System.Net;
using System.Runtime.InteropServices;
using xonline.common.config;

namespace ServerTestFramework.LiveService.Billing
{

	public class XRLOfferingEnumerateResp : XRLPayload
	{
		public short	RecordSize;
		public short	RecordIndex;
		public ulong	OfferingId;
		public int		OfferingType;
		public int		BitFlags;
		public int		PackageSize;
		public int		InstallSize;
		public DateTime ActivationDate;
		public int		Rating;
		public short	OfferingFlags;           
		public int		TitleSpecificDataLen;
		public int		pbTitleSpecificDataOffset;
		public byte[]	TitleSpecificData;

		public bool		Equals(XRLOfferingEnumerateResp other)
		{
			if (RecordSize!=other.RecordSize)
				return false;
			if (RecordIndex!=other.RecordIndex)
				return false;
			if (OfferingId!=other.OfferingId)
				return false;
			if (OfferingType!=other.OfferingType)
				return false;
			if (BitFlags!=other.BitFlags)
				return false;
			if (PackageSize!=other.PackageSize)
				return false;
			if (InstallSize!=other.InstallSize)
				return false;
			if (ActivationDate!=other.ActivationDate)
				return false;
			if (Rating!=other.Rating)
				return false;
			if (OfferingFlags!=other.OfferingFlags)
				return false;
			if (TitleSpecificDataLen!=other.TitleSpecificDataLen)
				return false;
			if (pbTitleSpecificDataOffset!=other.pbTitleSpecificDataOffset)
				return false;
			return true;
		}
	}

	public class XRLOfferingEnumerateRespHead : XRLPayload
	{
		public short    Records;
		public short    Flags;
		public DateTime LastChangedDate;
	}
	

	/// <summary>
	/// 
	/// </summary>
	public class XRLOfferingEnumerate : XRLPayload
	{
		[XRLPayloadFld(IsUPuid=true)]
		public ulong       UserPUID             =0;
		[XRLPayloadFld(IsTitleId=true)]
		public uint			TitleId              =0;
		public uint        ClientBuffer         =0;
		public int         Rating               =0;
		public DateTime    LastChangedDate      =DateTime.Now;
		public uint        OfferingType         =0;
		public uint        BitFilter            =0;
		public int         DescriptionIndex     =0;
		public ushort      StartingIndex         =0;
		public ushort      MaxResults            =0;                     
			
		// Results
		[XRLPayloadFld(Serialize=false)]
		public short		NumRecords			=0;
		[XRLPayloadFld(Serialize=false)]
		public XRLOfferingEnumerateRespHead Head;
		[XRLPayloadFld(Serialize=false)]
		public XRLOfferingEnumerateResp []Resp;

		protected override string GetServiceName()
		{
			return "/xbos/OfferingEnumerate.ashx";
		}
		
		protected override void ReadResponse(MemoryStream respBuff)
		{
			// read the header off the stream
			Head = new XRLOfferingEnumerateRespHead();
			Head.ReadStream( respBuff );
			
			// read all of the offereing enumerated records
			Resp = new XRLOfferingEnumerateResp[Head.Records];
			for (int i=0; i<Head.Records; i++)
			{
				Resp[i] = new XRLOfferingEnumerateResp();
				Resp[i].ReadStream( respBuff );
			}

			// set a helper variable
			NumRecords = Head.Records;
		}

        public override bool Execute()
        {
            return base.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xbos_billing_offering));
        }
		
		public XRLOfferingEnumerate()
		{
		}
	}
}

/*

        private const short MORE_RESULTS    = 0x1;
        private const short NO_MORE_RESULTS = 0x0;


        class XOEnumRecord : XRLObject
        {
            public short  cbRecordSize;
            public short  iRecordIndex;
            public ulong  offeringId;
            public int    dwOfferingType;
            public int    dwBitFlags;
            public int    cbPackageSize;
            public int    cbInstallSize;
            public DateTime ftActivationDate;
            public int    dwRating;
            public short  fOfferingFlags;           
            public int    cbTitleSpecificData       = 1;
            public int    pbTitleSpecificDataOffset = RECORD_LEN;
            public byte[] rgbEnumBlob;
            

            public int SizeInBytes()
            {
                return (RECORD_LEN + rgbEnumBlob.Length);
            }
        }
        const int RECORD_LEN            = 50;

        class XOEnumHeader : XRLObject
        {
            public short    cRecords;
            public short    fFlags;
            public DateTime ftLastChangedDate;
        }
        const int HEADER_LEN            = 12;

*/
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\Billing\Xenon\XRLInGameContentAvailable.cs ===
using System;
using System.IO;
using System.Net;
using ServerTestFramework.Utilities;
using ServerTestFramework.LiveService.FakeSG;
using ServerTestFramework.Database;
using xonline.common.config;


namespace ServerTestFramework.LiveService.Billing
{
    public class XRLInGameContentAvailable : XRLPayload
    {
        [XRLPayloadFld(IsUPuid=true)]
        public ulong UserPuid;
        public byte CountryID;
        public ushort LiveLanguageID;
        public byte TierRequired;
        [XRLPayloadFld(IsTitleId=true)]
        public uint TitleID;
        public DateTime lastViewed;
        [WireInfo(HexString = true, MinSchemaVersion = "5.5")]
        public uint avatarBodyTypes;  // Avatar Body Types 

        public XRLInGameContentAvailable()
        {
            SetDefaults();

            this.Slot.SetClientType(ServerTestFramework.LiveService.FakeSG.CSGInfo.ClientType.Xenon);
        }

        public XRLInGameContentAvailable(ServerTestFramework.LiveService.FakeSG.CSGInfo.ClientType clientType)
        {
            SetDefaults();

            this.Slot.SetClientType(clientType);
        }

        private void SetDefaults()
        {
            // setup some default values
            this.CountryID = 103;
            this.LiveLanguageID = 1;
            this.TierRequired = 3;
            this.lastViewed = DateTime.UtcNow;
            this.SchemaVersion = WireData.MakeSchemaVersion(5, 1);
        }


        protected override string GetServiceName()
        {
            return "/xbos/InGameContentAvailable.ashx";
        }

        public bool Execute(out XRLInGameContentAvailableResponse Response)
        {
            return Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xbos_billing_offering), out Response);
        }

        public bool Execute(LiveServer sServer, out XRLInGameContentAvailableResponse Response)
        {
            return Execute(sServer.EPDefault, out Response);
        }

        public bool Execute(IPEndPoint endPoint, out XRLInGameContentAvailableResponse Response)
        {
            MemoryStream reqStream = new MemoryStream( 512 );
            WriteStream( reqStream );

            // to support schema version
            if (!this.CustomHeader.Contains("X-Schema-Ver:"))
                this.CustomHeader += "X-Schema-Ver:" + WireInfoAttribute.VersionToString(this.SchemaVersion) + "\r\n";

            bool uRet = false;
            bool bRet=InternalExecute(endPoint,reqStream);

            Response=null;
            if(bRet)
            {
                if( (xAct.httpStatus == HttpStatusCode.OK) && (xAct.XErr == 0) )
                {
                    Response = new XRLInGameContentAvailableResponse();
                    Response.SchemaVersion = this.SchemaVersion;
                    MemoryStream respBuff = new MemoryStream(xAct.ResponseContents);
                    Response.ReadStream(respBuff);

                    uRet = true;
                }
            }

            return uRet;
        }
    }

    public class XRLInGameContentAvailableResponse : XRLPayload
    {
        public byte NewOffersLength = 32;
        [WireInfo(SizeParam="NewOffersLength")]
        public uint [] NewOffers;
        public byte TotalOffersLength = 32;
        [WireInfo(SizeParam="TotalOffersLength")]
        public uint [] TotalOffers;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\Billing\Xenon\XRLInGameContentEnumerate.cs ===
using System;
using System.IO;
using System.Net;
using ServerTestFramework.Utilities;
using ServerTestFramework.LiveService.FakeSG;
using ServerTestFramework.Database;
using xonline.common.config;
using xonline.common.service;

namespace ServerTestFramework.LiveService.Billing
{
    public class XRLInGameContentEnumerate : XRLPayload
    {
        public static byte HideUnratedContentFilter    = 0x01;    

        [XRLPayloadFld(IsUPuid=true)]
        public ulong UserPuid;
        [XRLPayloadFld(IsMPuid=true)]
        public ulong MachinePuid;
        public byte CountryID;
        public ushort LiveLanguageID;
        public ushort EmsGameRating;
        public uint OfferType; // content, points bundle, gamertag, etc
        public byte TierRequired;
        // [XRLPayloadFld(IsTitleId=true)]
        public uint TitleID;
        public uint TitleCategories;
        public byte RequestFlags; // userPlayedGameFilter, userHasPurchasedFilter
        [WireInfo(MinSchemaVersion = "5.1")]
        public ushort offerIdsLength;
        [WireInfo(SizeParam = "offerIdsLength", MinSchemaVersion = "5.1")]
        public ulong[] offerIDs;

        [WireInfo(HexString = true, MinSchemaVersion = "5.5")]
        public uint avatarBodyTypes;  // Avatar Body Types 
        
        public int StartingIndex;
        public int MaxResults;

        // set all default values
        public XRLInGameContentEnumerate()
        {
            SetDefaults();
        }

        public XRLInGameContentEnumerate(uint schemaVersion, bool useHttpAuth)
        {
            SetDefaults();
            this.SchemaVersion = schemaVersion;
            this.UseHttpAuth = useHttpAuth;
        }

        public XRLInGameContentEnumerate(uint schemaVersion, bool useHttpAuth, ServerTestFramework.LiveService.FakeSG.CSGInfo.ClientType clientType)
        {
            SetDefaults();
            this.SchemaVersion = schemaVersion;
            this.UseHttpAuth = useHttpAuth;

            // override with different ClientType machine puid
            RandomEx rand = new RandomEx();
            this.MachinePuid = rand.GenerateRandomMachineId(clientType);
        }

        private void SetDefaults()
        {
            this.UserPuid = 0;          // a valid user puid should be passed in
            this.CountryID = 103;       // US
            this.LiveLanguageID = 1;        // English
            this.StartingIndex = 0;     // zero based
            this.MaxResults = 30;       // client uses this value
            this.EmsGameRating = 0x00ff;   // US, Allow all games
            this.TierRequired = 3;      // silver
            this.OfferType = 0xffffffff;        // all offer types
            this.RequestFlags = 0;              // no flag is set
            this.TitleID = 0;                   // all titles
            this.TitleCategories = 0xffffffff;  // not used
            this.offerIDs = new ulong[0];
            this.offerIdsLength = 0;

            // default to a valid Xenon machine puid
            RandomEx rand = new RandomEx();
            this.MachinePuid = rand.GenerateRandomMachineId(ServerTestFramework.LiveService.FakeSG.CSGInfo.ClientType.Xenon);
        }

        public void CopyMembers(XRLInGameContentEnumerate old)
        {
            this.UserPuid = old.UserPuid;
            this.MachinePuid = old.MachinePuid;
            this.CountryID = old.CountryID;
            this.LiveLanguageID = old.LiveLanguageID;
            this.EmsGameRating = old.EmsGameRating;
            this.OfferType = old.OfferType;
            this.TierRequired = old.TierRequired;
            this.TitleID = old.TitleID;
            this.TitleCategories = old.TitleCategories;
            this.RequestFlags = old.RequestFlags;
            this.StartingIndex = old.StartingIndex;
            this.MaxResults = old.MaxResults;
            if (old.offerIDs != null)
                this.offerIDs = (ulong[])old.offerIDs.Clone();
            else
                this.offerIDs = null;
            this.offerIdsLength = old.offerIdsLength;

            this.SchemaVersion = old.SchemaVersion;
            this.UseHttpAuth = old.UseHttpAuth;
        }

        public bool hideUnratedContentFilter
        {
            get
            {
                return IsFlagSet(HideUnratedContentFilter, RequestFlags);
            }
            set
            {
                SetFlag(HideUnratedContentFilter, value, ref RequestFlags);
            }
        }

        protected override string GetServiceName()
        {
            return "/xbos/InGameContentEnumerate.ashx";
        }

        public bool Execute(out XRLInGameContentEnumerateResponse Response)
        {
            return Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xbos_billing_offering), out Response);
        }

        public bool Execute(LiveServer sServer, out XRLInGameContentEnumerateResponse Response)
        {
            return Execute(sServer.EPDefault, out Response);
        }

        public bool Execute(IPEndPoint endPoint, out XRLInGameContentEnumerateResponse Response)
        {
            MemoryStream reqStream = new MemoryStream( 512 );
            WriteStream( reqStream );

            // to support schema version
            if (!this.CustomHeader.Contains("X-Schema-Ver:"))
                this.CustomHeader += "X-Schema-Ver:" + WireInfoAttribute.VersionToString(this.SchemaVersion) + "\r\n";
            
            bool uRet = false;
            bool bRet=InternalExecute(endPoint,reqStream);

            Response=null;
            if(bRet)
            {
                if( (xAct.httpStatus == HttpStatusCode.OK) && (xAct.XErr == 0) )
                {
                    Response = new XRLInGameContentEnumerateResponse();
                    Response.SchemaVersion = this.SchemaVersion;
                    MemoryStream respBuff = new MemoryStream(xAct.ResponseContents);
                    Response.ReadStream(respBuff);

                    uRet = true;
                }
            }

            return uRet;
        }
    }

    public class XRLInGameContentEnumerateResponse : XRLPayload
    {
        public ushort OffersReturned;
        [WireInfo(SizeParam="OffersReturned")]
        public InGameContentInfo[] Offers;
        public uint OffersTotal;
    }
    
    public class InGameContentInfo : XRLPayload
    {
        static ushort UserHasPurchased          = 0x0001;
        static ushort IsAcquirable              = 0x0002;
        static ushort IsUnrestricted            = 0x0004;
        static ushort IsUnrated                 = 0x0008;

        public InGameContentInfo()
        {
            ResponseFlags = 0;
        }

        public ulong OfferID;

        public ushort OfferNameLength;
        [WireInfo(SizeParam="OfferNameLength", NullTerminated=true)]
        public string OfferName;
        public uint OfferType;
        [WireInfo(ArraySize=(int)XOn.XONLINE_CONTENT_ID_LEN)]
        public byte[] ContentId;
        
        public uint LicenseMask;

        public uint TitleID;
        public uint TitleCategory;
        public ushort TitleNameLength;
        [WireInfo(SizeParam="TitleNameLength", NullTerminated=true)]
        public string TitleName;
        public byte TierRequired;
        public ushort EmsGameRating;
        public ushort ResponseFlags; // userHasPurchased, userHasViewed
        public uint PackageSize;
        public uint InstallSize;
        public int SellTextLength;
        [WireInfo(SizeParam="SellTextLength", NullTerminated=true)]
        public string SellText;

        public uint AssetID;
        public uint PurchaseQuantity;

        public byte PricesLength;
        [WireInfo(SizeParam="PricesLength")]
        public InGameOfferPrice[] Prices;
        
        public bool userHasPurchased
        {
            get
            {
                return IsFlagSet(UserHasPurchased, ResponseFlags);
            }
            set
            {
                SetFlag(UserHasPurchased, value, ref ResponseFlags);
            }
        }

        public bool isAcquirable
        {
            get
            {
                return IsFlagSet(IsAcquirable, ResponseFlags);
            }
            set
            {
                SetFlag(IsAcquirable, value, ref ResponseFlags);
            }
        }

        public bool isUnrestricted
        {
            get
            {
                return IsFlagSet(IsUnrestricted, ResponseFlags);
            }
            set
            {
                SetFlag(IsUnrestricted, value, ref ResponseFlags);
            }
        }

        public bool isUnrated
        {
            get
            {
                return IsFlagSet(IsUnrated, ResponseFlags);
            }
            set
            {
                SetFlag(IsUnrated, value, ref ResponseFlags);
            }
        }
    }


    public class InGameOfferPrice : XRLPayload
    {
        public uint PaymentType;
        public int Price;
        public ushort PriceTextLength;
        [WireInfo(SizeParam="PriceTextLength")]
        public string PriceText;
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\Billing\Xenon\XRLTransferMachineLicense.cs ===
using System;
using System.IO;
using System.Net;
using ServerTestFramework.Utilities;
using ServerTestFramework.LiveService.FakeSG;
using ServerTestFramework.Database;
using xonline.common.config;


namespace ServerTestFramework.LiveService.Billing
{
    public class XRLTransferMachineLicense : XRLPayload
    {
        [XRLPayloadFld(IsUPuid=true)]
        public ulong UserPuid;
        [XRLPayloadFld(IsMPuid=true)]
        public ulong MachinePuidOld;

        public ulong MachinePuidNew;

        public XRLTransferMachineLicense()
        {
            // setup some default values
            this.MachinePuidOld = XbosUser.DefaultMachinePuid;
        }

        protected override string GetServiceName()
        {
            return "/xbos/TransferMachineLicenses.ashx";
        }

        public override bool Execute()
        {
            return Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xbos_billing_offering));
        }

        public override bool Execute(LiveServer sServer)
        {
            return Execute(sServer.EPDefault);
        }

        public override bool Execute(IPEndPoint endPoint)
        {
            MemoryStream reqStream = new MemoryStream( 512 );
            WriteStream( reqStream );

            bool uRet = false;
            bool bRet=InternalExecute(endPoint,reqStream);

            if(bRet)
            {
                if( (xAct.httpStatus == HttpStatusCode.OK) && (xAct.XErr == 0) )
                {
                    uRet = true;
                }
            }

            return uRet;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\Billing\Xenon\XRLPurchaseMediaOffers.cs ===
using System;
using System.IO;
using System.Net;
using ServerTestFramework.Utilities;
using ServerTestFramework.LiveService.FakeSG;
using ServerTestFramework.Database;
using xonline.common.config;

namespace ServerTestFramework.LiveService.Billing
{

    public class OfferMediaTypeExpectedPrice : XRLPayload
    {
        public Guid OfferId;
        public int MediaTypeId;
        public uint ExpectedPriceWhole;
        public uint ExpectedPriceFractional;
    }
    public class SubscriptionPurchaseInfo : XRLPayload
    {
        public uint subscriptionTimeExtendedInMonths = 0;
    }
    public class XRLPurchaseMediaOffers : XRLPayload
    {
        [XRLPayloadFld(IsUPuid=true)]
        public ulong UserPuid;

        [XRLPayloadFld(IsMPuid=true)]
        public ulong MachinePuid;

        public uint OffersLength;

        [WireInfo(SizeParam = "OffersLength")]
        public OfferMediaTypeExpectedPrice[] Offers;

        public uint PaymentType;
        public ushort PaymentInstrumentIDLength;
        [WireInfo(SizeParam="PaymentInstrumentIDLength")]
        public string PaymentInstrumentID;
        public ushort BillingTokenLength;
        [WireInfo(SizeParam="BillingTokenLength")]
        public string BillingToken;

        [WireInfo(MinSchemaVersion = "3.3")]
        public uint StoreId = 1;

        [WireInfo(MinSchemaVersion = "6.4")]
        public SubscriptionPurchaseInfo SubscriptionPurchaseInfo = null;

        [WireInfo(MinSchemaVersion = "6.9")]
        public Guid TrackingGuid = Guid.Empty;

        public XRLPurchaseMediaOffers()
        {
            SetDefaults();
        }

        public XRLPurchaseMediaOffers(uint schemaVersion, bool useHttpAuth)
        {
            SetDefaults();
            this.SchemaVersion = schemaVersion;
            this.UseHttpAuth = useHttpAuth;
        }

        public void SetDefaults()
        {
            // default values:
            this.MachinePuid = XbosUser.DefaultMachinePuid;
            this.PaymentType = (uint)PaymentTypeEnum.Points;
            this.PaymentInstrumentID = "";
            this.BillingToken = "";
            this.SubscriptionPurchaseInfo = new SubscriptionPurchaseInfo();
        }

        public void CopyMembers(XRLPurchaseMediaOffers old)
        {
            this.UserPuid = old.UserPuid;
            this.MachinePuid = old.MachinePuid;
            this.PaymentType = old.PaymentType;
            this.PaymentInstrumentIDLength = old.PaymentInstrumentIDLength;
            this.PaymentInstrumentID = old.PaymentInstrumentID;
            this.BillingTokenLength = old.BillingTokenLength;
            this.BillingToken = old.BillingToken;
            this.SubscriptionPurchaseInfo = old.SubscriptionPurchaseInfo;

            this.OffersLength = old.OffersLength;
            if (old.Offers != null)
                this.Offers = (OfferMediaTypeExpectedPrice[])old.Offers.Clone();
            else
                this.Offers = null;

            this.SchemaVersion = old.SchemaVersion;
            this.UseHttpAuth = old.UseHttpAuth;
        }

        protected override string GetServiceName()
        {
            return "/xbos/PurchaseMediaOffers.ashx";
        }

        public override bool Execute()
        {
            return Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xbos_billing_offering));
        }

        public override bool Execute(LiveServer sServer)
        {
            return Execute(sServer.EPDefault);
        }

        public override bool Execute(IPEndPoint endPoint)
        {
            // to support schema version
            if (!this.CustomHeader.Contains("X-Schema-Ver:"))
                this.CustomHeader += "X-Schema-Ver:" + WireInfoAttribute.VersionToString(this.SchemaVersion) + "\r\n";

            MemoryStream reqStream = new MemoryStream( 512 );
            WriteStream( reqStream );

            bool uRet = false;
            bool bRet=InternalExecute(endPoint,reqStream);

            if(bRet)
            {
                if( (xAct.httpStatus == HttpStatusCode.OK) && (xAct.XErr == 0) )
                {
                    uRet = true;
                }
            }

            return uRet;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\Billing\Xenon\XRLPurchaseOffers.cs ===
using System;
using System.IO;
using System.Net;
using ServerTestFramework.Utilities;
using ServerTestFramework.LiveService.FakeSG;
using ServerTestFramework.Database;
using xonline.common.config;

namespace ServerTestFramework.LiveService.Billing
{
    public class OfferExpectedPrice : XRLPayload
    {
        public Guid offerId;

        public uint expectedPrice;
    }


    public class XRLPurchaseOffers : XRLPayload
    {
        [XRLPayloadFld(IsUPuid=true)]
        public ulong UserPuid;

        [XRLPayloadFld(IsMPuid=true)]
        public ulong MachinePuid;

        public uint OffersLength;

        [WireInfo(SizeParam = "OffersLength")]
        public OfferExpectedPrice [] Offers;

        public uint PaymentType;
        public ushort PaymentInstrumentIDLength;
        [WireInfo(SizeParam="PaymentInstrumentIDLength")]
        public string PaymentInstrumentID;
        public ushort BillingTokenLength;
        [WireInfo(SizeParam="BillingTokenLength")]
        public string BillingToken;
	 public uint StoreId = 1;
	 
        public XRLPurchaseOffers()
        {
            SetDefaults();
        }

        public XRLPurchaseOffers(uint schemaVersion, bool useHttpAuth)
        {
            SetDefaults();
            this.SchemaVersion = schemaVersion;
            this.UseHttpAuth = useHttpAuth;
        }

        public void SetDefaults()
        {
            // default values:
            this.MachinePuid = XbosUser.DefaultMachinePuid;
            this.PaymentType = (uint)PaymentTypeEnum.Points;
            this.PaymentInstrumentID = "";
            this.BillingToken = "";
        }

        public void CopyMembers(XRLPurchaseOffers old)
        {
            this.UserPuid = old.UserPuid;
            this.MachinePuid = old.MachinePuid;
            this.PaymentType = old.PaymentType;
            this.PaymentInstrumentIDLength = old.PaymentInstrumentIDLength;
            this.PaymentInstrumentID = old.PaymentInstrumentID;
            this.BillingTokenLength = old.BillingTokenLength;
            this.BillingToken = old.BillingToken;

            this.OffersLength = old.OffersLength;
            if (old.Offers != null)
                this.Offers = (OfferExpectedPrice[])old.Offers.Clone();
            else
                this.Offers = null;

            this.SchemaVersion = old.SchemaVersion;
            this.UseHttpAuth = old.UseHttpAuth;
        }

        protected override string GetServiceName()
        {
            return "/xbos/PurchaseOffers.ashx";
        }

        public override bool Execute()
        {
            return Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xbos_billing_offering));
        }

        public override bool Execute(LiveServer sServer)
        {
            return Execute(sServer.EPDefault);
        }

        public override bool Execute(IPEndPoint endPoint)
        {
            // to support schema version
            if (!this.CustomHeader.Contains("X-Schema-Ver:"))
                this.CustomHeader += "X-Schema-Ver:" + WireInfoAttribute.VersionToString(this.SchemaVersion) + "\r\n";

            MemoryStream reqStream = new MemoryStream( 512 );
            WriteStream( reqStream );

            bool uRet = false;
            bool bRet=InternalExecute(endPoint,reqStream);

            if(bRet)
            {
                if( (xAct.httpStatus == HttpStatusCode.OK) && (xAct.XErr == 0) )
                {
                    uRet = true;
                }
            }

            return uRet;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\Billing\Xenon\XRLXeAcknowledgeLicenseDelivery.cs ===
using System;
using System.IO;
using System.Net;
using ServerTestFramework.Utilities;
using ServerTestFramework.LiveService.FakeSG;
using ServerTestFramework.Database;
using xonline.common.config;

namespace ServerTestFramework.LiveService.Billing
{
    public class XRLXeAcknowledgeLicenseDeliveryRequest : XRLPayload
    {
        [XRLPayloadFld(IsUPuid = true)]
        public ulong userPuid;
        [XRLPayloadFld(IsMPuid = true)]
        public ulong machinePuid;
        public XRLWMID wmid;

        public XRLXeAcknowledgeLicenseDeliveryRequest()
        {
        }

        protected override string GetServiceName()
        {
            return "/xbos/XeAcknowledgeLicenseDelivery.ashx";
        }

        public bool Execute(out XRLXeAcknowledgeLicenseDeliveryResponse response)
        {
            return Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xbos_billing_offering),out response);
        }

        public bool Execute(IPEndPoint endPoint, out XRLXeAcknowledgeLicenseDeliveryResponse response)
        {
            MemoryStream reqStream = new MemoryStream(512);
            WriteStream(reqStream);

            response = null;

            if(InternalExecute(endPoint,reqStream))
            {
                if(xAct.httpStatus == HttpStatusCode.OK && xAct.XErr == 0)
                {
                    response = new XRLXeAcknowledgeLicenseDeliveryResponse();
                    MemoryStream respBuff = new MemoryStream(xAct.ResponseContents);
                    response.ReadStream(respBuff);
                    return true;
                }
            }
            return false;
        }
    }

    public class XRLXeAcknowledgeLicenseDeliveryResponse : XRLPayload
    {
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\Billing\Xenon\XRLXeAcquireVideoContentURL.cs ===
using System;
using System.IO;
using System.Net;
using ServerTestFramework.Utilities;
using ServerTestFramework.LiveService.FakeSG;
using ServerTestFramework.Database;
using xonline.common.config;

namespace ServerTestFramework.LiveService.Billing
{
    public class XRLXeAcquireVideoContentURLRequest : XRLPayload
    {
        [XRLPayloadFld(IsUPuid = true)]
        public ulong userPuid;
        public byte countryID;
        public ushort languageID;
        public byte tier;
        [XRLPayloadFld(IsMPuid = true)]
        public ulong machinePuid;
        public XRLWMID wmid;

        public XRLXeAcquireVideoContentURLRequest()
        {
        }

        protected override string GetServiceName()
        {
            return "/xbos/XeAcquireVideoContentURL.ashx";
        }

        public bool Execute(out XRLXeAcquireVideoContentURLResponse response)
        {
            return Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xbos_billing_offering),out response);
        }

        public bool Execute(IPEndPoint endPoint, out XRLXeAcquireVideoContentURLResponse response)
        {
            MemoryStream reqStream = new MemoryStream(512);
            WriteStream(reqStream);

            response = null;

            if(InternalExecute(endPoint,reqStream))
            {
                if(xAct.httpStatus == HttpStatusCode.OK && xAct.XErr == 0)
                {
                    response = new XRLXeAcquireVideoContentURLResponse();
                    MemoryStream respBuff = new MemoryStream(xAct.ResponseContents);
                    response.ReadStream(respBuff);
                    return true;
                }
            }
            return false;
        }

    }

    public class XRLXeAcquireVideoContentURLResponse : XRLPayload
    {
        public ushort contentURLLength;
        [WireInfo(SizeParam="contentURLLength")]
        public string contentURL;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\Billing\Xenon\XRLPreviewProductPurchase.cs ===
using System;
using System.IO;
using System.Net;
using ServerTestFramework.Utilities;
using ServerTestFramework.LiveService.FakeSG;
using ServerTestFramework.Database;
using xonline.common.config;

namespace ServerTestFramework.LiveService.Billing
{
    public class OfferProductInfo : XRLPayload
    {
        public Guid offerId;

        public int productTypeId;
    }
   
    public class XRLPreviewProductPurchase : XRLPayload
    {
        [XRLPayloadFld(IsUPuid = true)]
        public ulong userPuid;

        [XRLPayloadFld(IsMPuid = true)]
        public ulong machinePuid;

        public uint offersLength;

        [WireInfo(SizeParam = "offersLength")]
        public OfferProductInfo[] offers;

        [WireInfo(HexString = true)]
        public uint paymentType;

        public ushort paymentInstrumentIDLength;

        [WireInfo(SizeParam = "paymentInstrumentIDLength")]
        public string paymentInstrumentID;

        public uint storeId = 1;

        public ushort billingTokenLength = 0;

        [WireInfo(SizeParam = "billingTokenLength")]
        public string billingToken = string.Empty;

        public XRLPreviewProductPurchase()
        {
            SetDefaults();
        }

        public XRLPreviewProductPurchase(uint schemaVersion, bool useHttpAuth)
        {
            SetDefaults();
            this.SchemaVersion = schemaVersion;
            this.UseHttpAuth = useHttpAuth;
        }

        public void SetDefaults()
        {
            // default values:
            this.machinePuid = XbosUser.DefaultMachinePuid;
            this.paymentType = (uint)PaymentTypeEnum.Points;
            this.paymentInstrumentID = "";
            this.billingToken = "";
        }

        protected override string GetServiceName()
        {
            return "/xbos/PreviewProductPurchase.ashx";
        }

        public bool Execute(out XRLXePreviewProductPurchaseResponse Response)
        {
            return Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xbos_billing_offering), out Response);
        }

        public bool Execute(LiveServer sServer, out XRLXePreviewProductPurchaseResponse Response)
        {
            return Execute(sServer.EPDefault, out Response);
        }

        public bool Execute(IPEndPoint endPoint, out XRLXePreviewProductPurchaseResponse Response)
        {
            // to support schema version
            if (!this.CustomHeader.Contains("X-Schema-Ver:"))
                this.CustomHeader += "X-Schema-Ver:" + WireInfoAttribute.VersionToString(this.SchemaVersion) + "\r\n";

            MemoryStream reqStream = new MemoryStream(512);
            WriteStream(reqStream);

            bool uRet = false;
            bool bRet = InternalExecute(endPoint, reqStream);

            Response = null;
            if (bRet)
            {
                if ((xAct.httpStatus == HttpStatusCode.OK) && (xAct.XErr == 0))
                {
                    Response = new XRLXePreviewProductPurchaseResponse();
                    MemoryStream respBuff = new MemoryStream(xAct.ResponseContents);
                    Response.ReadStream(respBuff);

                    uRet = true;
                }
            }

            return uRet;
        }
    }

    public class XRLXePreviewProductPurchaseResponse : XRLPayload
    {
        public Guid offerId;

        public double offerPrice;

        public PreviewSubscriptionProductInfo previewSubscriptionInfo;

        public int taxTypeId;
    }

    public class PreviewSubscriptionProductInfo : XRLPayload
    {
        public Guid subscriptionId;

        public bool autoRenewal;

        public double nextChargeAmount;

        public DateTime nextChargeDate;

        public double netPrice;

        public double discount;

        public int timeExtendedinMonths;

        public Guid defaultRenewalOfferId = Guid.Empty;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\Billing\Xenon\XRLXeContentAvailable.cs ===
using System;
using System.IO;
using System.Net;
using ServerTestFramework.Utilities;
using ServerTestFramework.LiveService.FakeSG;
using ServerTestFramework.Database;
using xonline.common.config;


namespace ServerTestFramework.LiveService.Billing
{
    public class XRLXeContentAvailable : XRLPayload
    {
        [XRLPayloadFld(IsUPuid=true)]
        public ulong UserPuid;
        public byte CountryID;
        public byte TierRequired;
        [XRLPayloadFld(IsTitleId=true)]
        public uint TitleID;

        public XRLXeContentAvailable()
        {
            // setup some default values
            this.CountryID = 103;
            this.TierRequired = 3;
        }

        protected override string GetServiceName()
        {
            return "/xbos/XeContentAvailable.ashx";
        }

        public bool Execute(out XRLXeContentAvailableResponse Response)
        {
            return Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xbos_billing_offering), out Response);
        }

        public bool Execute(LiveServer sServer, out XRLXeContentAvailableResponse Response)
        {
            return Execute(sServer.EPDefault, out Response);
        }

        public bool Execute(IPEndPoint endPoint, out XRLXeContentAvailableResponse Response)
        {
            MemoryStream reqStream = new MemoryStream( 512 );
            WriteStream( reqStream );

            // to support schema version
            if (!this.CustomHeader.Contains("X-Schema-Ver:"))
                this.CustomHeader += "X-Schema-Ver:" + WireInfoAttribute.VersionToString(this.SchemaVersion) + "\r\n";

            bool uRet = false;
            bool bRet=InternalExecute(endPoint,reqStream);

            Response=null;
            if(bRet)
            {
                if( (xAct.httpStatus == HttpStatusCode.OK) && (xAct.XErr == 0) )
                {
                    Response = new XRLXeContentAvailableResponse();
                    Response.SchemaVersion = this.SchemaVersion;
                    MemoryStream respBuff = new MemoryStream(xAct.ResponseContents);
                    Response.ReadStream(respBuff);

                    uRet = true;
                }
            }

            return uRet;
        }
    }

    public class XRLXeContentAvailableResponse : XRLPayload
    {
        public byte NewOffersLength = 32;
        [WireInfo(SizeParam="NewOffersLength")]
        public uint [] NewOffers;
        public byte TotalOffersLength = 32;
        [WireInfo(SizeParam="TotalOffersLength")]
        public uint [] TotalOffers;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\Billing\Xenon\XRLXeBannerGetList.cs ===
using System;
using System.IO;
using System.Net;
using ServerTestFramework.Utilities;
using ServerTestFramework.LiveService.FakeSG;
using ServerTestFramework.Database;
using xonline.common.config;

namespace ServerTestFramework.LiveService.Billing
{
    public class XRLXeBannerGetList : XRLPayload
    {
        public enum BannerListLevel : byte
        {
            BannerOnly = 1,
            HotList = 2
        }

        public enum BannerType : byte
        {
            Min = 0,
            Live_Blade_Billboard = 0,
            Live_Blade_Marketplace = 1,
            Marketplace_Storefront = 2,
            V1_Marketplace_Demos_and_Game_Videos = 3,
            V1_Marketplace_Games = 4,
            V1_Marketplace_Themes_and_Gamer_Pictures = 5,
            Games_Blade_Arcade_Banner = 6,
            V1_Marketplace_Arcade = 7,
            V1_Marketplace_Game_Demos = 8,
            V1_Marketplace_Trailers_and_Game_Videos = 9,
            V1_Marketplace_Gamer_Pictures = 10,
            V1_Marketplace_Media_and_Entertainment = 11,
            MediaMarketplace_Video_Main_Large = 12,
            MediaMarketplace_Video_Main_Small = 13,
            MediaMarketplace_Video_Movies_Main = 14,
            MediaMarketplace_Video_TV_Main = 15,
            MediaMarketplace_Video_Music_Videos_Main = 16,
            MediaMarketplace_Video_Viral_Main_Top = 17,
            MediaMarketplace_Video_Viral_Main_Middle = 18,
            MediaMarketpalce_Video_Viral_Main_Bottom = 19,
            V2_Marketplace_Demos_and_Game_Videos = 20,
            V2_Marketplace_Games = 21,
            V2_Marketplace_Themes_and_Gamer_Pictures = 22,
            V2_Marketplace_Arcade = 23,
            V2_Marketplace_Game_Demos = 24,
            V2_Marketplace_Trailers_and_Game_Videos = 25,
            V2_Marketplace_Gamer_Pictures = 26,
            V2_Marketplace_Media_and_Entertainment = 27,
            V2_Marketplace_Game_Trailers = 28,
            V2_Marketplace_Gaming_Community = 29,
            V2_Marketplace_Game_Tips_and_Support_Videos = 30,
            // Added in Spring 2007
            V2_Games_Blade_Title_Promo = 31,
            V2_Marketplace_Games_Small = 32,
            V2_Marketplace_Game_Arcade_Small = 33,
            V2_Marketplace_GameDemos_Small = 34,
            V2_Marketplace_ThemesGamerPic_Small = 35,
            V2_Marketplace_Video_GameVideo_US_Small = 36,
            V2_Marketplace_Video_GameVideo_US_Large = 37,
            V2_Marketplace_Video_NonUS_Small = 38,
            V2_Marketplace_Video_GameVideo_NonUS_Small = 39,
            // Begin Future Slots
            V2_Marketplace_Future_Banner_A = 40,
            V2_Marketplace_Future_Banner_B = 41,
            V2_Marketplace_Future_Banner_C = 42,
            V2_Marketplace_Future_Banner_D = 43,
            V2_Marketplace_Future_Banner_E = 44,
            V2_Marketplace_Future_Banner_F = 45,
            V2_Marketplace_Future_Banner_G = 46,
            V2_Marketplace_Future_Banner_H = 47,
            // End Future Slots
            Max,
        }

        [XRLPayloadFld(IsUPuid=true)]
        public ulong UserPuid;
        public uint LangId;
        public byte Level;
        public int  StartingIndex;
        public int  MaxResults;

        public XRLXeBannerGetList()
        {
            SetDefaults();
        }

        public XRLXeBannerGetList(uint schemaVersion)
        {
            SetDefaults();
            this.SchemaVersion = schemaVersion;
        }

        private void SetDefaults()
        {
            // init some dummy values
            this.LangId = 1;
            this.Level = (byte)BannerListLevel.BannerOnly;
            this.StartingIndex = 0;
            this.MaxResults = 10;
        }
        
        protected override string GetServiceName()
        {
            return "/xbos/XeBannerGetList.ashx";
        }

        // *************************************************
        // BASE LIST REQUESTS
        // *************************************************
        public bool Execute(out XRLXeBannerGetListResponse_BaseList Response)
        {
            return Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xbos_billing_offering), out Response);
        }

        public bool Execute(LiveServer sServer, out XRLXeBannerGetListResponse_BaseList Response)
        {
            return Execute(sServer.EPDefault, out Response);
        }

        public bool Execute(IPEndPoint endPoint, out XRLXeBannerGetListResponse_BaseList Response)
        {
            MemoryStream reqStream = new MemoryStream( 512 );
            WriteStream( reqStream );

            // to support schema version
            if (!this.CustomHeader.Contains("X-Schema-Ver:"))
                this.CustomHeader += "X-Schema-Ver:" + WireInfoAttribute.VersionToString(this.SchemaVersion) + "\r\n";
            
            bool uRet = false;
            bool bRet=InternalExecute(endPoint,reqStream);

            Response=null;
            if(bRet)
            {
                if( (xAct.httpStatus == HttpStatusCode.OK) && (xAct.XErr == 0) )
                {
                    Response = new XRLXeBannerGetListResponse_BaseList();
                    Response.SchemaVersion = this.SchemaVersion;
                    MemoryStream respBuff = new MemoryStream(xAct.ResponseContents);
                    Response.ReadStream(respBuff);

                    uRet = true;
                }
            }

            return uRet;
        }

        // *************************************************
        // HOT LIST REQUESTS
        // *************************************************
        public bool Execute(out XRLXeBannerGetListResponse_HotList Response)
        {
            return Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xbos_billing_offering), out Response);
        }

        public bool Execute(LiveServer sServer, out XRLXeBannerGetListResponse_HotList Response)
        {
            return Execute(sServer.EPDefault, out Response);
        }

        public bool Execute(IPEndPoint endPoint, out XRLXeBannerGetListResponse_HotList Response)
        {
            MemoryStream reqStream = new MemoryStream( 512 );
            WriteStream( reqStream );

            // to support schema version
            if (!this.CustomHeader.Contains("X-Schema-Ver:"))
                this.CustomHeader += "X-Schema-Ver:" + WireInfoAttribute.VersionToString(this.SchemaVersion) + "\r\n";
            
            bool uRet = false;
            bool bRet=InternalExecute(endPoint,reqStream);

            Response=null;
            if(bRet)
            {
                if( (xAct.httpStatus == HttpStatusCode.OK) && (xAct.XErr == 0) )
                {
                    Response = new XRLXeBannerGetListResponse_HotList();
                    Response.SchemaVersion = this.SchemaVersion;
                    MemoryStream respBuff = new MemoryStream(xAct.ResponseContents);
                    Response.ReadStream(respBuff);

                    uRet = true;
                }
            }

            return uRet;
        }

    }


    // *************************************************
    // RESPONSE OBJECTS
    // *************************************************
    public class XRLXeBannerGetListResponse_BaseList : XRLPayload
    {
        public DateTime Expires;   // how long can the list be cached by client
        public int CultureId;
        public ushort BannerCountTotal = 0;
        public ushort BannerCount = 0;
        [WireInfo(SizeParam="BannerCount")]
        public BannerBaseListEntry[] BannerList = null;  // can be BannerHotListEntry[]
    }

    public class XRLXeBannerGetListResponse_HotList : XRLPayload
    {
        public DateTime Expires;   // how long can the list be cached by client
        public int CultureId;
        public ushort BannerCountTotal = 0;
        public ushort BannerCount = 0;
        [WireInfo(SizeParam="BannerCount")]
        public BannerHotListEntry[] HotList = null;
    }


    public class BannerBaseListEntry : XRLPayload
    {
        public byte BannerType;
        public bool IsMyGame;  // whether banner shows on personalized pages
        public ushort Width;
        public ushort Height;
        public ushort PathLength;
        [WireInfo(SizeParam="PathLength")]
        public string Path;
    }

    public class BannerHotListEntry : XRLPayload
    {
        public byte BannerType;
        public bool IsMyGame;  // whether banner shows on personalized pages
        public ushort Width;
        public ushort Height;
        public ushort PathLength;
        [WireInfo(SizeParam="PathLength")]
        public string Path;
        public uint TitleId;
        public ushort TitleNameLength;
        [WireInfo(SizeParam="TitleNameLength")]
        public string TitleName;
        public ulong OfferId;
        public ushort OfferNameLength;
        [WireInfo(SizeParam="OfferNameLength")]
        public string OfferNameName;
        public OfferPrice Price;
        public DateTime DateApproved;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\Billing\Xenon\XRLXeAcquireVideoLicense.cs ===
using System;
using System.IO;
using System.Net;
using ServerTestFramework.Utilities;
using ServerTestFramework.LiveService.FakeSG;
using ServerTestFramework.Database;
using xonline.common.config;

namespace ServerTestFramework.LiveService.Billing
{
    public class XRLXeWmdrmChallengeBlock : XRLPayload
    {
        public ushort challengeBlockLength;
        [WireInfo(SizeParam="challengeBlockLength")]
        public byte[] challengeBlock;
    }

    public class XRLXeAcquireVideoLicenseRequest : XRLPayload
    {
        [XRLPayloadFld(IsUPuid = true)]
        public ulong userPuid;
        public byte countryID;
        public ushort languageID;
        public byte tier;
        [XRLPayloadFld(IsMPuid = true)]
        public ulong machinePuid;
        public XRLWMID wmid;
        public ushort challengeBlockCount;
        [WireInfo(SizeParam="challengeBlockCount")]
        public XRLXeWmdrmChallengeBlock[] challengeBlocks;

        public XRLXeAcquireVideoLicenseRequest()
        {
        }

        protected override string GetServiceName()
        {
            return "/xbos/XeAcquireVideoLicense.ashx";
        }

        public bool Execute(out XRLXeAcquireVideoLicenseResponse response)
        {
            return Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xbos_billing_offering),out response);
        }

        public bool Execute(IPEndPoint endPoint, out XRLXeAcquireVideoLicenseResponse response)
        {
            MemoryStream reqStream = new MemoryStream(512);
            WriteStream(reqStream);

            response = null;

            if(InternalExecute(endPoint,reqStream))
            {
                if(xAct.httpStatus == HttpStatusCode.OK && xAct.XErr == 0)
                {
                    response = new XRLXeAcquireVideoLicenseResponse();
                    MemoryStream respBuff = new MemoryStream(xAct.ResponseContents);
                    response.ReadStream(respBuff);
                    return true;
                }
            }
            return false;
        }
    }

    public class XRLXeWmdrmLicenseBlock : XRLPayload
    {
        public ushort licenseBlockLength;
        [WireInfo(SizeParam="licenseBlockLength")]
        public byte[] licenseBlock;
    }

    public class XRLXeAcquireVideoLicenseResponse : XRLPayload
    {
        public ushort licenseBlockCount;
        [WireInfo(SizeParam="licenseBlockCount")]
        public XRLXeWmdrmLicenseBlock[] licenseBlocks;
        public ushort contentURLLength;
        [WireInfo(SizeParam="contentURLLength")]
        public string contentURL;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\Billing\Xenon\XRLXeContentEnumerate2.cs ===
using System;
using System.IO;
using System.Net;
using ServerTestFramework.Utilities;
using ServerTestFramework.LiveService.FakeSG;
using ServerTestFramework.Database;
using xonline.common.config;

namespace ServerTestFramework.LiveService.Billing
{
    public class XRLXeContentEnumerate2 : XRLPayload
    {
        public static byte NoRating                    = 0xff;
        
        public static byte UserPlayedGameFilter        = 0x01;    // not used
        public static byte UserHasPurchasedFilter      = 0x02;    //       -- This path is only used by Spring06 (and earlier) versions of the Console Flash, and so has been removed.
                                                                                        //      -- Purchase history has been split out into its own API XeContentHistoryEnumerate
        public static byte NewContentOnlyFilter        = 0x04;
        public static byte MatchRequiredTierFilter     = 0x08;

        [XRLPayloadFld(IsUPuid=true)]
        public ulong UserPuid;
        public byte CountryID;
        public ushort LanguageID;
        public ushort GameRating;
        public uint OfferType; // content, points bundle, gamertag, etc
        public uint PaymentType; // credit card, token, points, etc
        public byte TierRequired;
        // [XRLPayloadFld(IsTitleId=true)]
        public uint TitleID;
        public uint TitleCategories;
        public byte RequestFlags; // userPlayedGameFilter, userHasPurchasedFilter
        public int StartingIndex;
        public int MaxResults;
        public int GenreID;

        // set all default values
        public XRLXeContentEnumerate2()
        {
            SetDefaults();
        }

        public XRLXeContentEnumerate2(uint schemaVersion, bool useHttpAuth)
        {
            SetDefaults();
            this.SchemaVersion = schemaVersion;
            this.UseHttpAuth = useHttpAuth;
        }

        private void SetDefaults()
        {
            this.UserPuid = 0;          // a valid user puid should be passed in
            this.CountryID = 103;       // US
            this.LanguageID = 1;        // English
            this.StartingIndex = 0;     // zero based
            this.MaxResults = 30;       // client uses this value
            this.GameRating = 0x00ff;   // US, Allow all games
            this.TierRequired = 3;      // silver
            this.GenreID = 0;           // root genres, across all product type ids (product type id = 0)
            this.OfferType = 0xffffffff;        // all offer types
            this.RequestFlags = 0;              // no flag is set
            this.PaymentType = 0xffffffff;      // all payment types
            this.TitleID = 0;                   // all titles
            this.TitleCategories = 0xffffffff;  // not used
        }

        public void CopyMembers(XRLXeContentEnumerate2 old)
        {
            this.UserPuid = old.UserPuid;
            this.CountryID = old.CountryID;
            this.LanguageID = old.LanguageID;
            this.GameRating = old.GameRating;
            this.OfferType = old.OfferType;
            this.PaymentType = old.PaymentType;
            this.TierRequired = old.TierRequired;
            this.TitleID = old.TitleID;
            this.TitleCategories = old.TitleCategories;
            this.RequestFlags = old.RequestFlags;
            this.StartingIndex = old.StartingIndex;
            this.MaxResults = old.MaxResults;
            this.GenreID = old.GenreID;

            this.SchemaVersion = old.SchemaVersion;
            this.UseHttpAuth = old.UseHttpAuth;
        }

        public bool userPlayedGameFilter
        {
            get
            {
                return IsFlagSet(UserPlayedGameFilter, RequestFlags);
            }
            set
            {
                SetFlag(UserPlayedGameFilter, value, ref RequestFlags);
            }
        }

        public bool userHasPurchasedFilter
        {
            get
            {
                return IsFlagSet(UserHasPurchasedFilter, RequestFlags);
            }
            set
            {
                SetFlag(UserHasPurchasedFilter, value, ref RequestFlags);
            }
        }

        public bool newContentOnlyFilter
        {
            get
            {
                return IsFlagSet(NewContentOnlyFilter, RequestFlags);
            }
            set
            {
                SetFlag(NewContentOnlyFilter, value, ref RequestFlags);
            }
        }

        public bool matchRequiredTierFilter
        {
            get
            {
                return IsFlagSet(MatchRequiredTierFilter, RequestFlags);
            }
            set
            {
                SetFlag(MatchRequiredTierFilter, value, ref RequestFlags);
            }
        }

        protected override string GetServiceName()
        {
            return "/xbos/XeContentEnumerate2.ashx";
        }

        public bool Execute(out XRLXeContentEnumerateResponse2 Response)
        {
            return Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xbos_billing_offering), out Response);
        }

        public bool Execute(LiveServer sServer, out XRLXeContentEnumerateResponse2 Response)
        {
            return Execute(sServer.EPDefault, out Response);
        }

        public bool Execute(IPEndPoint endPoint, out XRLXeContentEnumerateResponse2 Response)
        {
            MemoryStream reqStream = new MemoryStream( 512 );
            WriteStream( reqStream );

            // to support schema version
            if (!this.CustomHeader.Contains("X-Schema-Ver:"))
                this.CustomHeader += "X-Schema-Ver:" + WireInfoAttribute.VersionToString(this.SchemaVersion) + "\r\n";
            
            bool uRet = false;
            bool bRet=InternalExecute(endPoint,reqStream);

            Response=null;
            if(bRet)
            {
                if( (xAct.httpStatus == HttpStatusCode.OK) && (xAct.XErr == 0) )
                {
                    Response = new XRLXeContentEnumerateResponse2();
                    Response.SchemaVersion = this.SchemaVersion;
                    MemoryStream respBuff = new MemoryStream(xAct.ResponseContents);
                    Response.ReadStream(respBuff);

                    uRet = true;
                }
            }

            return uRet;
        }
    }

    public class XRLXeContentEnumerateResponse2 : XRLPayload
    {
        public ushort OffersReturned;
        [WireInfo(SizeParam="OffersReturned")]
        public BasicContentInfo[] Offers;
        public uint OffersTotal;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\Billing\Xenon\XRLXeAssetConsume.cs ===
using System;
using System.IO;
using System.Net;
using ServerTestFramework.Utilities;
using ServerTestFramework.LiveService.FakeSG;
using ServerTestFramework.Database;
using xonline.common.config;
using xonline.common.service;


namespace ServerTestFramework.LiveService.Billing
{
    public class XRLXeAssetConsume : XRLPayload
    {
        [XRLPayloadFld(IsUPuid=true)]
        public ulong UserPuid;
        public ulong MachinePuid;
        [XRLPayloadFld(IsTitleId=true)]
        public uint TitleId;

        [WireInfo(MinSchemaVersion = "6.9")]
        public Guid trackingGuid;

        public uint cAssets;
        [WireInfo(SizeParam="cAssets")]
        public Asset[] Assets;

        public XRLXeAssetConsume()
        {
            // setup some default values
            this.MachinePuid = XbosUser.DefaultMachinePuid;
            this.TitleId = XOn.DASH_TITLE_ID;
        }

        public XRLXeAssetConsume(uint titleId, ulong userPuid, Asset[] assets) : this()
        {
            this.TitleId = titleId;
            this.UserPuid = userPuid;
            this.Assets = assets;
        }

        public XRLXeAssetConsume(uint titleId, ulong userPuid, Asset[] assets, Guid trackingGuid)
            : this()
        {
            this.TitleId = titleId;
            this.UserPuid = userPuid;
            this.Assets = assets;
            this.trackingGuid = trackingGuid;
            this.SchemaVersion = WireData.MakeSchemaVersion(6, 9);
        }

        public void CopyMembers(XRLXeAssetConsume old)
        {
            this.UserPuid = old.UserPuid;
            this.MachinePuid = old.MachinePuid;
            this.TitleId = old.TitleId;
            this.cAssets = old.cAssets;
            this.trackingGuid = old.trackingGuid;

            if (old.Assets != null)
                this.Assets = (Asset[])old.Assets.Clone();
            else
                this.Assets = old.Assets;

            // custom schema data
            this.SchemaVersion = old.SchemaVersion;
            this.CustomHeader = old.CustomHeader;
        }

        protected override string GetServiceName()
        {
            return "/xbos/AssetConsume.ashx";
        }

        public override bool Execute()
        {
            return Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xbos_billing_offering));
        }

        public override bool Execute(LiveServer sServer)
        {
            return Execute(sServer.EPDefault);
        }

        public override bool Execute(IPEndPoint endPoint)
        {
            // allows custom schema to be sent
            if (!this.CustomHeader.Contains("X-Schema-Ver:"))
                this.CustomHeader += "X-Schema-Ver:" + WireInfoAttribute.VersionToString(this.SchemaVersion) + "\r\n";

            MemoryStream reqStream = new MemoryStream( 512 );
            WriteStream( reqStream );

            bool uRet = false;
            bool bRet=InternalExecute(endPoint,reqStream);

            if(bRet)
            {
                if( (xAct.httpStatus == HttpStatusCode.OK) && (xAct.XErr == 0) )
                {
                    uRet = true;
                }
            }

            return uRet;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\Billing\Xenon\XRLXeContentDetails.cs ===
using System;
using System.IO;
using System.Net;
using ServerTestFramework.Utilities;
using ServerTestFramework.LiveService.FakeSG;
using ServerTestFramework.Database;
using xonline.common.config;


namespace ServerTestFramework.LiveService.Billing
{
    public class XRLXeContentDetails : XRLPayload
    {
        [XRLPayloadFld(IsUPuid=true)]
        public ulong UserPuid;
        public byte CountryId;
        public ushort LanguageId;

        [WireInfo(MinSchemaVersion = "2.0")]
        public ushort Offers;        // count of offers

        [WireInfo(SizeParam = "Offers", MinSchemaVersion = "2.0")]
        public ulong[] OfferIDs;

        [WireInfo(MaxSchemaVersion = "1.0")]
        public ulong OfferId;

        public uint PaymentType; // credit card, token, points, etc
        public byte TierRequired;
        public byte RatingSystem;

        public XRLXeContentDetails()
        {
            SetDefaults();
        }

        public XRLXeContentDetails(uint schemaVersion, bool useHttpAuth)
        {
            SetDefaults();
            this.SchemaVersion = schemaVersion;
            this.UseHttpAuth = useHttpAuth;
        }

        private void SetDefaults()
        {
            // setup some default values
            this.CountryId = 103;
            this.LanguageId = 1;
            this.PaymentType = (uint)PaymentTypeEnum.Points;
            this.TierRequired = 3;
            this.RatingSystem = 0;  // ESRB
       }

        public void CopyMembers(XRLXeContentDetails old)
        {
            this.UserPuid = old.UserPuid;
            this.CountryId = old.CountryId;
            this.LanguageId = old.LanguageId;
            this.OfferId = old.OfferId;
            this.PaymentType = old.PaymentType;
            this.TierRequired = old.TierRequired;
            this.RatingSystem = old.RatingSystem;

            this.Offers = old.Offers;
            if (old.OfferIDs != null)
                this.OfferIDs = (ulong[])old.OfferIDs.Clone();
            else
                this.OfferIDs = null;

            this.SchemaVersion = old.SchemaVersion;
            this.UseHttpAuth = old.UseHttpAuth;
        }

        protected override string GetServiceName()
        {
            return "/xbos/XeContentDetails.ashx";
        }

        public bool Execute(out XRLXeContentDetailsResponse Response)
        {
            return Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xbos_billing_offering), out Response);
        }

        public bool Execute(LiveServer sServer, out XRLXeContentDetailsResponse Response)
        {
            return Execute(sServer.EPDefault, out Response);
        }

        public bool Execute(IPEndPoint endPoint, out XRLXeContentDetailsResponse Response)
        {
            MemoryStream reqStream = new MemoryStream( 512 );
            WriteStream( reqStream );

            // to support schema version
            if (!this.CustomHeader.Contains("X-Schema-Ver:"))
                this.CustomHeader += "X-Schema-Ver:" + WireInfoAttribute.VersionToString(this.SchemaVersion) + "\r\n";

            bool uRet = false;
            bool bRet=InternalExecute(endPoint,reqStream);

            Response=null;
            if(bRet)
            {
                if( (xAct.httpStatus == HttpStatusCode.OK) && (xAct.XErr == 0) )
                {
                    Response = new XRLXeContentDetailsResponse();
                    Response.SchemaVersion = this.SchemaVersion;
                    MemoryStream respBuff = new MemoryStream(xAct.ResponseContents);
                    Response.ReadStream(respBuff);

                    uRet = true;
                }
            }

            return uRet;
        }
    }

    public class XRLXeContentDetailsResponse : XRLPayload
    {
        [WireInfo(MinSchemaVersion = "2.0")]
        public ushort OffersReturned;

        [WireInfo(SizeParam = "OffersReturned", MinSchemaVersion = "2.0")]
        public BasicContentInfo[] Infos;

        [WireInfo(MaxSchemaVersion = "1.0")]
        public BasicContentInfo BasicInfo;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\Billing\Xenon\XRLXeContentHistoryEnumerate.cs ===
using System;
using System.IO;
using System.Net;
using ServerTestFramework.Utilities;
using ServerTestFramework.LiveService.FakeSG;
using ServerTestFramework.Database;
using xonline.common.config;

namespace ServerTestFramework.LiveService.Billing
{
    public class XRLXeContentHistoryEnumerate : XRLPayload
    {
        public static byte QueryForIsAcquirable      = 0x01;

        [XRLPayloadFld(IsUPuid=true)]
        public ulong UserPuid;

        [WireInfo(MinSchemaVersion = "3.0")]
        public ulong MachinePuid;
        public byte CountryID;
        public ushort LanguageID;
        public uint OfferType; // content, points bundle, gamertag, etc
        public byte RequestFlags; // userPlayedGameFilter, userHasPurchasedFilter
        public int StartingIndex;
        public int MaxResults;

        // set all default values
        public XRLXeContentHistoryEnumerate()
        {
            SetDefaults();
        }

        public XRLXeContentHistoryEnumerate(bool useHttpAuth)
        {
            this.UseHttpAuth = useHttpAuth;
            SetDefaults();
        }

        public XRLXeContentHistoryEnumerate(uint schemaVersion, bool useHttpAuth)
        {
            SetDefaults();
            this.SchemaVersion = schemaVersion;
            this.UseHttpAuth = useHttpAuth;
        }

        private void SetDefaults()
        {
            this.UserPuid = 0;          // a valid user puid should be passed in
            this.CountryID = 103;       // US
            this.LanguageID = 1;        // English
            this.StartingIndex = 0;     // zero based
            this.MaxResults = 30;       // client uses this value
            this.OfferType = 0xffffffff;        // all offer types
            this.RequestFlags = 0;              // no flag is set
            this.MachinePuid = 0xfa00000012341234; // xenon machine puid
        }

        public void CopyMembers(XRLXeContentHistoryEnumerate old)
        {
            this.UserPuid = old.UserPuid;
            this.CountryID = old.CountryID;
            this.LanguageID = old.LanguageID;
            this.OfferType = old.OfferType;
            this.RequestFlags = old.RequestFlags;
            this.StartingIndex = old.StartingIndex;
            this.MaxResults = old.MaxResults;
            this.MachinePuid = old.MachinePuid;
            
            this.SchemaVersion = old.SchemaVersion;
            this.UseHttpAuth = old.UseHttpAuth;
        }

        public bool isAcquirableOnlyFilter
        {
            get
            {
                return IsFlagSet(QueryForIsAcquirable, RequestFlags);
            }
            set
            {
                SetFlag(QueryForIsAcquirable, value, ref RequestFlags);
            }
        }

        protected override string GetServiceName()
        {
            return "/xbos/XeContentHistoryEnumerate.ashx";
        }

        public bool Execute(out XRLXeContentHistoryEnumerateResponse Response)
        {
            return Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xbos_billing_offering), out Response);
        }

        public bool Execute(LiveServer sServer, out XRLXeContentHistoryEnumerateResponse Response)
        {
            return Execute(sServer.EPDefault, out Response);
        }

        public bool Execute(IPEndPoint endPoint, out XRLXeContentHistoryEnumerateResponse Response)
        {
            MemoryStream reqStream = new MemoryStream( 512 );
            WriteStream( reqStream );

            // to support schema version
            if (!this.CustomHeader.Contains("X-Schema-Ver:"))
                this.CustomHeader += "X-Schema-Ver:" + WireInfoAttribute.VersionToString(this.SchemaVersion) + "\r\n";
            
            bool uRet = false;
            bool bRet=InternalExecute(endPoint,reqStream);

            Response=null;
            if(bRet)
            {
                if( (xAct.httpStatus == HttpStatusCode.OK) && (xAct.XErr == 0) )
                {
                    Response = new XRLXeContentHistoryEnumerateResponse();
                    Response.SchemaVersion = this.SchemaVersion;
                    MemoryStream respBuff = new MemoryStream(xAct.ResponseContents);
                    Response.ReadStream(respBuff);

                    uRet = true;
                }
            }

            return uRet;
        }
    }

    public class XRLXeContentHistoryEnumerateResponse : XRLPayload
    {
        public ushort OffersReturned;
        [WireInfo(SizeParam="OffersReturned")]
        public XRLBasicContentHistoryInfo[] Offers;
        public uint OffersTotal;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\Billing\Xenon\XRLXeAssetEnumerate.cs ===
using System;
using System.IO;
using System.Net;
using ServerTestFramework.Utilities;
using ServerTestFramework.LiveService.FakeSG;
using ServerTestFramework.Database;
using xonline.common.config;
using xonline.common.service;


namespace ServerTestFramework.LiveService.Billing
{
    public class XRLXeAssetEnumerate : XRLPayload
    {
        [XRLPayloadFld(IsUPuid = true)]
        public ulong UserPuid;
        public ulong MachinePuid;
        [XRLPayloadFld(IsTitleId = true)]
        public uint TitleId;
        [WireInfo(MinSchemaVersion = "6.9")]
        public bool signAssets;

        public uint Flags;      // unused
        public ushort StartingIndex;
        public ushort MaxResults;        

        public XRLXeAssetEnumerate()
        {
            // setup some default values
            this.MachinePuid = XbosUser.DefaultMachinePuid;
            this.TitleId = XOn.DASH_TITLE_ID;
            this.Flags = 0;
            this.StartingIndex = 0;
            this.MaxResults = 30;
            this.signAssets = true;
        }

        public void CopyMembers(XRLXeAssetEnumerate old)
        {
            this.UserPuid = old.UserPuid;
            this.MachinePuid = old.MachinePuid;
            this.TitleId = old.TitleId;
            this.Flags = old.Flags;
            this.StartingIndex = old.StartingIndex;
            this.MaxResults = old.MaxResults;
            this.signAssets = old.signAssets;

            // custom schema data
            this.SchemaVersion = old.SchemaVersion;
            this.CustomHeader = old.CustomHeader;
        }

        protected override string GetServiceName()
        {
            return "/xbos/AssetEnumerate.ashx";
        }

        public bool Execute(out XRLXeAssetEnumerateResponse Response)
        {
            return Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xbos_billing_offering), out Response);
        }

        public bool Execute(LiveServer sServer, out XRLXeAssetEnumerateResponse Response)
        {
            return Execute(sServer.EPDefault, out Response);
        }

        public bool Execute(IPEndPoint endPoint, out XRLXeAssetEnumerateResponse Response)
        {
            // allows custom schema to be sent
            if (!this.CustomHeader.Contains("X-Schema-Ver:"))
                this.CustomHeader += "X-Schema-Ver:" + WireInfoAttribute.VersionToString(this.SchemaVersion) + "\r\n";

            MemoryStream reqStream = new MemoryStream( 512 );
            WriteStream( reqStream );

            bool uRet = false;
            bool bRet=InternalExecute(endPoint,reqStream);

            Response=null;
            if(bRet)
            {
                if( (xAct.httpStatus == HttpStatusCode.OK) && (xAct.XErr == 0) )
                {
                    Response = new XRLXeAssetEnumerateResponse();
                    MemoryStream respBuff = new MemoryStream(xAct.ResponseContents);
                    Response.ReadStream(respBuff);

                    uRet = true;
                }
            }

            return uRet;
        }
    }

    // Signable asset structure. 
    public class AssetPackage : WireData
    {
        public DateTime dtAssets;

        public uint cAssets;
        public uint cTotalAssets;

        [WireInfo(SizeParam = "cAssets")]
        public Asset[] Assets;
    }

    public class XRLXeAssetEnumerateResponse : XRLPayload
    {
        public const int ASSET_SIGNATURE_SIZE = 256;

        [WireInfo(ArraySize = ASSET_SIGNATURE_SIZE)]
        public byte[] Signature;

        public AssetPackage Package;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\Billing\Xenon\XRLXeContentReferral.cs ===
using System;
using System.Net;
using System.IO;
using xonline.common.config;
using xonline.common.service;


namespace ServerTestFramework.LiveService.Billing
{
    public class XRLXeContentReferral : XRLPayload
    {

        [XRLPayloadFld(IsUPuid=true)]
        public ulong UserId;
        [WireInfo(ArraySize=(int)XOn.XONLINE_CONTENT_ID_LEN)]
        public byte[] ContentId;

        protected override string GetServiceName()
        {
            return "/xbos/XeContentReferral.ashx";
        }

        public bool Execute(out XRLXeContentReferralResponse Response)
        {
            return Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xbos_billing_offering), out Response);
        }

        public bool Execute(LiveServer sServer, out XRLXeContentReferralResponse Response)
        {
            return Execute(sServer.EPDefault, out Response);
        }

        public bool Execute(IPEndPoint endPoint, out XRLXeContentReferralResponse Response)
        {
            MemoryStream reqStream = new MemoryStream( 512 );
            WriteStream( reqStream );

            // to support schema version
            if (!this.CustomHeader.Contains("X-Schema-Ver:"))
                this.CustomHeader += "X-Schema-Ver:" + WireInfoAttribute.VersionToString(this.SchemaVersion) + "\r\n";

            bool uRet = false;
            bool bRet=InternalExecute(endPoint,reqStream);

            Response=null;
            if(bRet)
            {
                if( (xAct.httpStatus == HttpStatusCode.OK) && (xAct.XErr == 0) )
                {
                    Response = new XRLXeContentReferralResponse();
                    MemoryStream respBuff = new MemoryStream(xAct.ResponseContents);
                    Response.ReadStream(respBuff);

                    uRet = true;
                }
            }

            return uRet;
        }
    }

    public class XRLXeContentReferralResponse : XRLPayload
    {
        public uint PackageSize;
        public uint InstallSize;
        [WireInfo(ArraySize=(int)XOn.XONLINE_CONTENT_SYMMETRIC_KEY_LEN)]
        public byte[] SymKey;
        [WireInfo(ArraySize=(int)XOn.XONLINE_CONTENT_PUBLIC_KEY_LEN)]
        public byte[] PubKey;
        public ushort LocationsCount;
        [WireInfo(SizeParam="LocationsCount")]
        public XeContentReferralLocation[] Locations;
    }

    public class XeContentReferralLocation : XRLPayload
    {
        public ushort Rank;
        public ushort XrlLength;
        [WireInfo(SizeParam="XrlLength")]
        public string Xrl;
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\Billing\Xenon\XRLXeEnumerateGenres.cs ===
using System;
using System.IO;
using System.Net;
using ServerTestFramework.Utilities;
using ServerTestFramework.LiveService.FakeSG;
using ServerTestFramework.Database;
using xonline.common.config;

namespace ServerTestFramework.LiveService.Billing
{
    public class XRLXeEnumerateGenres : XRLPayload
    {
        public byte CountryId;
        public ushort LanguageId;
        public uint StartIndex;
        public uint MaxCount;
        public ushort GameRating;
        public byte TierRequired;
        public uint OfferType = 0;
        public int ParentGenreId = 0;

        // set all default values
        public XRLXeEnumerateGenres()
        {
            this.CountryId = 103;       // US
            this.LanguageId = 1;        // English
            this.StartIndex = 0;        // zero based
            this.MaxCount = 36;         // client uses this value
            this.GameRating = 0x00ff;   // US, Allow all games
            this.TierRequired = 3;      // silver
            this.OfferType = 0xffffffff;// all offer types
            this.ParentGenreId = 0;     // root genres, across all product type ids (product type id = 0)
        }

        protected override string GetServiceName()
        {
            return "/xbos/XeEnumerateGenres.ashx";
        }

        public bool Execute(out XRLXeEnumerateGenresResponse Response)
        {
            return Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xbos_billing_offering), out Response);
        }

        public bool Execute(LiveServer sServer, out XRLXeEnumerateGenresResponse Response)
        {
            return Execute(sServer.EPDefault, out Response);
        }

        public bool Execute(IPEndPoint endPoint, out XRLXeEnumerateGenresResponse Response)
        {
            MemoryStream reqStream = new MemoryStream( 512 );
            WriteStream( reqStream );

            // to support schema version
            if (!this.CustomHeader.Contains("X-Schema-Ver:"))
                this.CustomHeader += "X-Schema-Ver:" + WireInfoAttribute.VersionToString(this.SchemaVersion) + "\r\n";
            
            bool uRet = false;
            bool bRet=InternalExecute(endPoint,reqStream);

            Response=null;
            if(bRet)
            {
                if( (xAct.httpStatus == HttpStatusCode.OK) && (xAct.XErr == 0) )
                {
                    Response = new XRLXeEnumerateGenresResponse();
                    Response.SchemaVersion = this.SchemaVersion;
                    MemoryStream respBuff = new MemoryStream(xAct.ResponseContents);
                    Response.ReadStream(respBuff);

                    uRet = true;
                }
            }

            return uRet;
        }
    }

    public class XRLXeEnumerateGenresResponse : XRLPayload
    {
        public ushort GenresReturned = 0;
        [WireInfo(SizeParam="GenresReturned")]
        public EnumeratedGenreInfo [] Genres;
        public uint TotalGenreCount = 0;
    }

    public class EnumeratedGenreInfo : XRLPayload
    {
        public int GenreId = 0;
        public ushort LocalizedGenreLength = 0;
        [WireInfo(SizeParam="LocalizedGenreLength")]
        public string LocalizedGenreName = "";
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\Billing\Xenon\XRLXeContentUpdateAccessTimes.cs ===
using System;
using System.IO;
using System.Net;
using ServerTestFramework.Utilities;
using ServerTestFramework.LiveService.FakeSG;
using ServerTestFramework.Database;
using xonline.common.config;
using xonline.common.service;

namespace ServerTestFramework.LiveService.Billing
{
    public class XRLXeContentUpdateAccessTimes : XRLPayload
    {
        [XRLPayloadFld(IsUPuid=true)]
        public ulong UserPuid;
        [XRLPayloadFld(IsTitleId=true)]
        public uint TitleID;
        public uint TitleCategories;

        public XRLXeContentUpdateAccessTimes()
        {
            TitleID = XOn.XENON_DASH_TITLE_ID;
            TitleCategories = 0xffffffff;   // all title categories
        }

        protected override string GetServiceName()
        {
            return "/xbos/XeContentUpdateAccessTimes.ashx";
        }

        public override bool Execute()
        {
            return Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xbos_billing_offering));
        }

        public override bool Execute(LiveServer sServer)
        {
            return Execute(sServer.EPDefault);
        }

        public override bool Execute(IPEndPoint endPoint)
        {
            MemoryStream reqStream = new MemoryStream( 512 );
            WriteStream( reqStream );

            bool uRet = false;
            bool bRet=InternalExecute(endPoint,reqStream);

            if(bRet)
            {
                if( (xAct.httpStatus == HttpStatusCode.OK) && (xAct.XErr == 0) )
                {
                    uRet = true;
                }
            }

            return uRet;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\Billing\Xenon\XRLXeContentRefreshLicense.cs ===
using System;
using System.Net;
using System.IO;
using xonline.common.config;
using xonline.common.service;

namespace ServerTestFramework.LiveService.Billing.License
{
    public class ContentLicense : WireData
    {
        public const int LiveSignatureLen = 256;
        public const int ReservedLen = 296;
        public const int LicenseesLen = 16;
        public const UInt64 UnrestrictedLicensee = 0xFFFFFFFFFFFFFFFF;
        public const UInt32 LicenseFlagRequireOnline = 0x1;
        public const UInt32 LicenseTypeLive = 0x4c495645;

        public ContentLicenseSignature signature;
        public ContentLicenseBody body;

        public ContentLicensee this[UInt64 licenseeId]
        {
            get
            {
                foreach(var licensee in this.body.licensees)
                {
                    if(licensee.licenseeId == licenseeId)
                    {
                        return licensee;
                    }
                }

                return null;
            }
        }

        public static UInt32 RevertByteOrder(UInt32 x)
        {
            return
                 (((x) & 0x000000FF) << 24) |
                 (((x) & 0x0000FF00) << 8) |
                 (((x) & 0x00FF0000) >> 8) |
                 (((x) & 0xFF000000) >> 24);
        }

        public static UInt64 RevertByteOrder(UInt64 x)
        {
            return
                ((UInt64)RevertByteOrder((UInt32)(x >> 32))) |
                (((UInt64)RevertByteOrder((UInt32)(x & 0xFFFFFFFF))) << 32);
        }

        public ContentLicense()
        {
            this.signature = new ContentLicenseSignature(false);
            this.body = new ContentLicenseBody();
        }

        public ContentLicense(bool validSig)
        {
            this.signature = new ContentLicenseSignature(validSig);
            this.body = new ContentLicenseBody();
        }

        public void RevertLicenseesByteOrder()
        {
            this.body.RevertLicenseesByteOrder();
        }

        public void VerifyLicensee(UInt64 licenseeId, Int32? licenseBits, Int32? licenseFlags)
        {
            ContentLicensee licensee = this[licenseeId];
            if (licensee == null)
            {
                throw new UnexpectedTestResultException(
                    String.Format("Unable to find expected Licensee 0x{0:X16}", licenseeId));
            }

            if (licenseBits.HasValue)
            {
                ServerTestFramework.Utilities.ValueCheck.Test("LicenseBits", licenseBits, licensee.licenseBits);
            }

            if (licenseFlags.HasValue)
            {
                ServerTestFramework.Utilities.ValueCheck.Test("LicenseFlags", licenseFlags, licensee.licenseFlags);
            }
        }

        public byte[] ToArray()
        {
            MemoryStream ms = new MemoryStream((int)XOn.XONLINE_CONTENT_LICENSE_MAX_LEN);
            this.WriteStream(ms);
            return ms.ToArray();
        }

        public override string ToString()
        {
            return this.body.ToString();
        }
    }

    public class ContentLicenseSignature : WireData
    {
        public UInt32 signatureType;

        [WireInfo(ArraySize = ContentLicense.LiveSignatureLen)]
        public byte[] signature;

        [WireInfo(ArraySize = ContentLicense.ReservedLen)]
        public byte[] reserved;

        public ContentLicenseSignature()
        {
            this.signatureType = 0; // invalid signature, for now only LicenseTypeLive is supported
            this.signature = new byte[ContentLicense.LiveSignatureLen];
            this.reserved = new byte[ContentLicense.ReservedLen];
        }

        public ContentLicenseSignature(bool validSig)
        {
            if (validSig)
                this.signatureType = ContentLicense.RevertByteOrder(ContentLicense.LicenseTypeLive);
            else
                this.signatureType = 0; // invalid signature, for now only LicenseTypeLive is supported
            this.signature = new byte[ContentLicense.LiveSignatureLen];
            this.reserved = new byte[ContentLicense.ReservedLen];
        }
    }

    public class ContentLicenseBody : WireData
    {
        [WireInfo(ArraySize = ContentLicense.LicenseesLen)]
        public ContentLicensee[] licensees;

        [WireInfo(ArraySize = (int)XOn.XONLINE_CONTENT_ID_LEN)]
        public byte[] ContentId;

        public UInt32 SizeOfHeaders;

        public ContentLicenseBody()
        {
            this.licensees = new ContentLicensee[ContentLicense.LicenseesLen];
            for (int i = 0; i < this.licensees.Length; i++)
                this.licensees[i] = new ContentLicensee();

            this.ContentId = new byte[20];
            this.SizeOfHeaders = 123; // any value
        }

        public byte[] ToArray()
        {
            MemoryStream ms = new MemoryStream((int)XOn.XONLINE_CONTENT_LICENSE_MAX_LEN);
            this.WriteStream(ms);
            return ms.ToArray();
        }

        public int GetUsedLicenseeCount()
        {
            for (int i = 0; i < this.licensees.Length; i++)
            {
                if (this.licensees[i].licenseeId == 0)
                    return i;
            }
            return this.licensees.Length;
        }

        public void RevertLicenseesByteOrder()
        {
            for (int i = 0; i < licensees.Length; i++)
            {
                licensees[i].licenseeId = ContentLicense.RevertByteOrder(licensees[i].licenseeId);
                licensees[i].licenseBits = ContentLicense.RevertByteOrder(licensees[i].licenseBits);
                licensees[i].licenseFlags = ContentLicense.RevertByteOrder(licensees[i].licenseFlags);
            }
        }

        public override string ToString()
        {
            return String.Format("ContentId: {0}, Licensees: {1}", ServerTestFramework.Utilities.Hexer.tohex(this.ContentId), GetUsedLicenseeCount());
        }
    }

    public class ContentLicensee : WireData
    {
        public UInt64 licenseeId;   // user id, machine id or unrestricted
        public UInt32 licenseBits;  // should be ORed, could mean different offers for the same content package
        public UInt32 licenseFlags; // used by user id only, it is always LicenseFlagRequireOnline. Machine id and Unrestricted are always 0.

        public bool Compare(ContentLicensee other)
        {
            if (this.licenseeId == other.licenseeId && this.licenseFlags == other.licenseFlags && this.licenseBits == other.licenseBits)
                return true;
            else
                return false;
        }

        public override string ToString()
        {
            return String.Format("0x{0:X16} - Bits: 0x{1:X8}, Flags: 0x{2:X8}", licenseeId, licenseBits, licenseFlags);
        }
    }
}

namespace ServerTestFramework.LiveService.Billing
{
    public class XRLXeContentRefreshLicense : XRLPayload
    {
        [XRLPayloadFld(IsUPuid=true)]
        public UInt64 UserId;
        [XRLPayloadFld(IsMPuid=true)]
        public UInt64 MachineId;
        public UInt16 LicenseLength;
        [WireInfo(SizeParam="LicenseLength")]
        public byte[] License;

        public XRLXeContentRefreshLicense()
        {
            this.MachineId = XbosUser.DefaultMachinePuid;
        }

        protected override string GetServiceName()
        {
            return "/xbos/XeContentRefreshLicense.ashx";
        }

        public bool Execute(out XRLXeContentRefreshLicenseResponse Response)
        {
            return Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xbos_billing_offering), out Response);
        }

        public bool Execute(LiveServer sServer, out XRLXeContentRefreshLicenseResponse Response)
        {
            return Execute(sServer.EPDefault, out Response);
        }

        public bool Execute(IPEndPoint endPoint, out XRLXeContentRefreshLicenseResponse Response)
        {
            MemoryStream reqStream = new MemoryStream( 512 );
            WriteStream( reqStream );

            bool uRet = false;
            bool bRet=InternalExecute(endPoint,reqStream);

            Response=null;
            if(bRet)
            {
                if( (xAct.httpStatus == HttpStatusCode.OK) && (xAct.XErr == 0) )
                {
                    Response = new XRLXeContentRefreshLicenseResponse();
                    MemoryStream respBuff = new MemoryStream(xAct.ResponseContents);
                    Response.ReadStream(respBuff);

                    uRet = true;
                }
            }

            return uRet;
        }
    }

    public class XRLXeContentRefreshLicenseResponse : XRLPayload
    {
        public UInt16 LicenseLength;
        [WireInfo(SizeParam="LicenseLength")]
        public byte[] License;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\Billing\Xenon\XRLXeGetPointsPurchaseStatus.cs ===
using System;
using System.IO;
using System.Net;
using ServerTestFramework.Utilities;
using ServerTestFramework.LiveService.FakeSG;
using ServerTestFramework.Database;
using xonline.common.config;


namespace ServerTestFramework.LiveService.Billing
{
    public enum DMPPurchaseType
    {
        XboxLiveOffers          = 1,    // defines a purchase transaction consisting only of Xbox Live offers
        MusicNetMTVContent      = 2,    // defines a purchase transaction consisting only of MusicNet tracks/albums
        SyncCastWMISContent     = 3     // defines a purchase transaction consisting only of SyncCast videos
    }

    public enum DMPOrderIDType
    {
        DMPTrackingGuid         = 1,    // represents the guid that is created for all dmp transactions
        MTVExternalOrderID      = 2     // represents the ID that MTV generates when making a call into wcmusic.OrderItems
    }

    public class PointsPurchaseQuery : XRLPayload
    {
        public ushort PurchaseType; // DMPPurchaseType
        public ushort OrderIDType; // DMPOrderIDType
       
        public ushort OrderIDLength;
        [WireInfo(SizeParam="OrderIDLength")]
        public string OrderID;

        public PointsPurchaseQuery()
        {
            // by default it is used by MTV
            PurchaseType = (ushort)DMPPurchaseType.MusicNetMTVContent;
            OrderIDType = (ushort)DMPOrderIDType.MTVExternalOrderID;
            OrderID = "";
        }
    }

    public class XRLXeGetPointsPurchaseStatusRequest : XRLPayload
    {
        [XRLPayloadFld(IsUPuid=true)]
        public ulong UserPuid;

        public ushort QueryCount;
        [WireInfo(SizeParam="QueryCount")]
        public PointsPurchaseQuery [] Queries;

        public XRLXeGetPointsPurchaseStatusRequest()
        {
        }

        protected override string GetServiceName()
        {
            return "/xbos/XeGetPointsPurchaseStatus.ashx";
        }

        public bool Execute(out XRLXeGetPointsPurchaseStatusResponse Response)
        {
            return Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xbos_billing_offering), out Response);
        }

        public bool Execute(LiveServer sServer, out XRLXeGetPointsPurchaseStatusResponse Response)
        {
            return Execute(sServer.EPDefault, out Response);
        }

        public bool Execute(IPEndPoint endPoint, out XRLXeGetPointsPurchaseStatusResponse Response)
        {
            // to support schema version
            if (!this.CustomHeader.Contains("X-Schema-Ver:"))
                this.CustomHeader += "X-Schema-Ver:" + WireInfoAttribute.VersionToString(this.SchemaVersion) + "\r\n";

            MemoryStream reqStream = new MemoryStream(512);
            WriteStream(reqStream);

            bool uRet = false;
            bool bRet = InternalExecute(endPoint, reqStream);

            Response = null;
            if (bRet)
            {
                if ((xAct.httpStatus == HttpStatusCode.OK) && (xAct.XErr == 0))
                {
                    Response = new XRLXeGetPointsPurchaseStatusResponse();
                    Response.SchemaVersion = this.SchemaVersion;
                    MemoryStream respBuff = new MemoryStream(xAct.ResponseContents);
                    Response.ReadStream(respBuff);

                    uRet = true;
                }
            }

            return uRet;
        }
    }

    public class PointsPurchaseStatus : XRLPayload
    {
        public ushort OrderIDLength;
        [WireInfo(SizeParam="OrderIDLength")]
        public string OrderID;

        public int Status; // DMPTransacionStatus
    }

    public class XRLXeGetPointsPurchaseStatusResponse : XRLPayload
    {
        public ushort StatusCount;
        [WireInfo(SizeParam="StatusCount")]
        public PointsPurchaseStatus [] Statuses;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\Billing\Xenon\XRLXeEnumerateTitlesByFilter.cs ===
using System;
using System.IO;
using System.Net;
using ServerTestFramework.Utilities;
using ServerTestFramework.LiveService.FakeSG;
using ServerTestFramework.Database;
using xonline.common.config;

namespace ServerTestFramework.LiveService.Billing
{
    public class XRLXeEnumerateTitlesByFilter : XRLPayload
    {
        static ushort QueryForNew = 0x0001;
        static ushort QueryForPlayed = 0x0002;

        [XRLPayloadFld(IsUPuid=true)]
        public ulong UserPuid;
        public byte CountryId;
        public ushort LanguageId;
        public uint StartIndex;
        public uint MaxCount;
        public ushort GameRating;
        public byte TierRequired;
        public int GenreId = 0;
        public uint OfferType = 0;
        public ushort RequestFlags; // new content filter, games played filter

        // set all default values
        public XRLXeEnumerateTitlesByFilter()
        {
            this.UserPuid = 0;          // a valid user puid should be passed in
            this.CountryId = 103;       // US
            this.LanguageId = 1;        // English
            this.StartIndex = 0;        // zero based
            this.MaxCount = 30;         // client uses this value
            this.GameRating = 0x3fff;   // no parental control
            this.TierRequired = 3;      // silver
            this.GenreId = 0;           // root genres, across all product type ids (product type id = 0)
            this.OfferType = 0xffffffff;// all offer types
            this.RequestFlags = 0;      // no flag is set
        }

        public void CopyMembers(XRLXeEnumerateTitlesByFilter old)
        {
            this.UserPuid = old.UserPuid;
            this.CountryId = old.CountryId;
            this.LanguageId = old.LanguageId;
            this.GameRating = old.GameRating;
            this.OfferType = old.OfferType;
            this.TierRequired = old.TierRequired;
            this.RequestFlags = old.RequestFlags;
            this.StartIndex = old.StartIndex;
            this.MaxCount = old.MaxCount;
            this.GenreId = old.GenreId;

            this.SchemaVersion = old.SchemaVersion;
            this.UseHttpAuth = old.UseHttpAuth;
        }

        public bool GamesWithNewContentFilter
        {
            get
            {
                return IsFlagSet(QueryForNew, RequestFlags);
            }
            set
            {
                SetFlag(QueryForNew, value, ref RequestFlags);
            }
        }

        public bool GamesPlayedFilter
        {
            get
            {
                return IsFlagSet(QueryForPlayed, RequestFlags);
            }
            set
            {
                SetFlag(QueryForPlayed, value, ref RequestFlags);
            }
        }


        protected override string GetServiceName()
        {
            return "/xbos/XeEnumerateTitlesByFilter.ashx";
        }

        public bool Execute(out XRLXeEnumerateTitlesByFilterResponse Response)
        {
            return Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xbos_billing_offering), out Response);
        }

        public bool Execute(LiveServer sServer, out XRLXeEnumerateTitlesByFilterResponse Response)
        {
            return Execute(sServer.EPDefault, out Response);
        }

        public bool Execute(IPEndPoint endPoint, out XRLXeEnumerateTitlesByFilterResponse Response)
        {
            MemoryStream reqStream = new MemoryStream( 512 );
            WriteStream( reqStream );

            // to support schema version
            if (!this.CustomHeader.Contains("X-Schema-Ver:"))
                this.CustomHeader += "X-Schema-Ver:" + WireInfoAttribute.VersionToString(this.SchemaVersion) + "\r\n";
            
            bool uRet = false;
            bool bRet=InternalExecute(endPoint,reqStream);

            Response=null;
            if(bRet)
            {
                if( (xAct.httpStatus == HttpStatusCode.OK) && (xAct.XErr == 0) )
                {
                    Response = new XRLXeEnumerateTitlesByFilterResponse();
                    Response.SchemaVersion = this.SchemaVersion;
                    MemoryStream respBuff = new MemoryStream(xAct.ResponseContents);
                    Response.ReadStream(respBuff);

                    uRet = true;
                }
            }

            return uRet;
        }
    }

    public class XRLXeEnumerateTitlesByFilterResponse : XRLPayload
    {
        public uint TitlesReturned = 0;
        [WireInfo(SizeParam="TitlesReturned")]
        public EnumeratedTitleInfo [] Titles;
        public uint TotalTitleCount = 0;
    }

    public class EnumeratedTitleInfo : XRLPayload
    {
        public ushort TitleNameLength;
        [WireInfo(SizeParam="TitleNameLength")]
        public string TitleName;
        public uint TitleId;
        public bool Played;     // not used
        public uint PurchasedContentCount;  // not used. It was remove from the 2006 spring release.
        public uint TotalContentCount;
        public bool NewContentExists;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\Billing\Xenon\XRLXeGetRevocationList.cs ===
using System;
using System.Net;
using System.IO;
using xonline.common.config;
using ServerTestFramework.LiveService.FakeSG;

// Use consts from the real XOn class
using XOnDev = xonline.common.service.XOn;
using xonline.common.service;

namespace ServerTestFramework.LiveService.Billing
{
	public class XeGetRevocationListRequest : XRLPayload
	{
		[XRLPayloadFld(Serialize = false)]
		public uint titleId=XOn.DASH_TITLE_ID;
		[XRLPayloadFld(Serialize = false)]
		public ulong machinePuid=defaultMPuid;
		[XRLPayloadFld(Serialize = false)]
		public IPEndPoint AlternateSigDestination = null;
		[XRLPayloadFld(Serialize=false)]
		public XeGetRevocationListReply Response=null;

		[WireInfo(ArraySize = (int)XOnDev.REVOCATION_LIST_CLIENT_NONCE_SIZE)]
		public byte[] clientNonce;

		protected override void SetServices()
		{
			//base.SetServices();
			Slot.ClearServices();
			Slot.AddService(XOService.DRM);
		}

		protected override string GetServiceName()
		{
			return @"/xbos/GetRevocationList.ashx";
		}

		public override void PopulateSlot(ref CSGInfo slot)
		{
			//base.PopulateSlot(ref slot);
			SetServices();
			slot.UserExists = 1;
			slot.titleId = titleId;
			slot.machinePuid = machinePuid;
			ManualSlotSetup = true;
		}

		public override bool Execute()
		{
			bool retval = Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xbos_drm));
			return retval;
		}

		protected override void ReadResponse(System.IO.MemoryStream responseStream)
		{
			Response = new XeGetRevocationListReply();
			Response.ReadStream(responseStream);
		}
	}

	public class XeGetRevocationListReply : WireData
	{
		[WireInfo(ArraySize = (int)XOnDev.REVOCATION_LIST_SIGNATURE_SIZE)]
		public byte[] signature;

		[WireInfo(ArraySize = (int)XOnDev.REVOCATION_LIST_SERVER_NONCE_SIZE)]
		public byte[] serverNonce;

		public uint _numListEntries = 0;
		public uint numListEntries
		{
			get
			{
				return(_numListEntries);
			}

			set
			{
				if (value > XOnDev.REVOCATION_LIST_MAX_ENTRIES)
				{
					throw new Exception("Broken");
				}
				_numListEntries = value;
			}
		}

		[WireInfo(SizeParam="_numListEntries")]
		public RevocationListEntry[] entries;

		public override WireData ReadStream(BinaryReader binaryReader)
		{
			signature = binaryReader.ReadBytes((int)XOnDev.REVOCATION_LIST_SIGNATURE_SIZE);
			serverNonce = binaryReader.ReadBytes((int)XOnDev.REVOCATION_LIST_SERVER_NONCE_SIZE);
			numListEntries = binaryReader.ReadUInt32();
			entries = new RevocationListEntry[numListEntries];
			for (int i = 0; i < numListEntries; i++)
			{
				entries[i] = new RevocationListEntry();
				entries[i].ReadStream(binaryReader);
			}
			return(this);
		}
	}

	public class RevocationListEntry : WireData
	{
		[WireInfo(ArraySize = (int)XOnDev.REVOCATION_LIST_ENTRY_DIGEST_SIZE)]
		public byte[] digest;

		public override WireData ReadStream(BinaryReader binaryReader)
		{
			digest = binaryReader.ReadBytes((int)XOnDev.REVOCATION_LIST_ENTRY_DIGEST_SIZE);
			return(this);
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\Billing\Xenon\XRLXeGetTitleDetails.cs ===
using System;
using System.IO;
using System.Net;
using ServerTestFramework.Utilities;
using ServerTestFramework.LiveService.FakeSG;
using ServerTestFramework.Database;
using xonline.common.config;


namespace ServerTestFramework.LiveService.Billing
{
    public class XRLXeGetTitleDetails : XRLPayload
    {
        [XRLPayloadFld(IsUPuid=true)]
        public ulong UserPuid;
        [XRLPayloadFld(IsTitleId=true)]
        public uint TitleId;
        public byte CountryId;
        public ushort LanguageId;
        public byte TierRequired;

        public XRLXeGetTitleDetails()
        {
            this.CountryId = 103;   // US
            this.LanguageId = 1;    // en
            this.TierRequired = 3;  // silver
        }

        protected override string GetServiceName()
        {
            return "/xbos/XeGetTitleDetails.ashx";
        }

        public bool Execute(out XRLXeGetTitleDetailsResponse Response)
        {
            return Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xbos_billing_offering), out Response);
        }

        public bool Execute(LiveServer sServer, out XRLXeGetTitleDetailsResponse Response)
        {
            return Execute(sServer.EPDefault, out Response);
        }

        public bool Execute(IPEndPoint endPoint, out XRLXeGetTitleDetailsResponse Response)
        {
            MemoryStream reqStream = new MemoryStream( 512 );
            WriteStream( reqStream );

            // to support schema version
            if (!this.CustomHeader.Contains("X-Schema-Ver:"))
                this.CustomHeader += "X-Schema-Ver:" + WireInfoAttribute.VersionToString(this.SchemaVersion) + "\r\n";
            
            bool uRet = false;
            bool bRet=InternalExecute(endPoint,reqStream);

            Response=null;
            if(bRet)
            {
                if( (xAct.httpStatus == HttpStatusCode.OK) && (xAct.XErr == 0) )
                {
                    Response = new XRLXeGetTitleDetailsResponse();
                    Response.SchemaVersion = this.SchemaVersion;
                    MemoryStream respBuff = new MemoryStream(xAct.ResponseContents);
                    Response.ReadStream(respBuff);

                    uRet = true;
                }
            }

            return uRet;
        }
    }

    public class XRLXeGetTitleDetailsResponse : XRLPayload
    {
        public ushort GameRating;
        public ushort TitleLength;
        [WireInfo(SizeParam="TitleLength")]
        public string Title;
        public ushort SellTextLength;
        [WireInfo(SizeParam="SellTextLength")]
        public string SellText;
        public ushort DeveloperLength;
        [WireInfo(SizeParam="DeveloperLength")]
        public string Developer;
        public ushort PublisherLength;
        [WireInfo(SizeParam="PublisherLength")]
        public string Publisher;
        public ushort GenreLength;
        [WireInfo(SizeParam="GenreLength")]
        public string Genre;
        public bool SubscriptionContent;
        public bool ThemeContent;
        public bool DemoContent;
        public bool TrailerContent;
        public bool Played;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\Billing\Xenon\XRLXeOfferPurchaseMusic.cs ===
using System;
using System.IO;
using System.Net;
using ServerTestFramework.Utilities;
using ServerTestFramework.LiveService.FakeSG;
using ServerTestFramework.Database;
using xonline.common.config;

namespace ServerTestFramework.LiveService.Billing
{
    public class MusicItem : XRLPayload
    {
        public ushort MnetIDLength;
        [WireInfo(SizeParam = "MnetIDLength")]
        public string MnetID;

        public uint ComponentType;

        public ushort ArtistNameLength;
        [WireInfo(SizeParam = "ArtistNameLength")]
        public string ArtistName;

        public ushort TitleFieldLength;
        [WireInfo(SizeParam = "TitleFieldLength")]
        public string TitleField;

        public int RetailPriceInPoints;
        public decimal RetailPriceInCurrency;
        public decimal WholesalePriceInCurrency;
    }

    public class XRLXeOfferPurchaseMusicRequest : XRLPayload
    {
        [XRLPayloadFld(IsUPuid = true)]
        public ulong UserPuid;

        public ushort IpAddressLength;
        [WireInfo(SizeParam = "IpAddressLength")]
        public string IpAddress;

        public ushort ExternalOrderIDLength;
        [WireInfo(SizeParam = "ExternalOrderIDLength")]
        public string ExternalOrderID;

        public ushort ItemCount;
        [WireInfo(SizeParam = "ItemCount")]
        public MusicItem[] Items;

        public uint PaymentType;

        public ushort PaymentInstrumentIDLength;
        [WireInfo(SizeParam = "PaymentInstrumentIDLength")]
        public string PaymentInstrumentID;

        public ushort BillingTokenLength;
        [WireInfo(SizeParam = "BillingTokenLength")]
        public string BillingToken;

        public XRLXeOfferPurchaseMusicRequest()
        {
            // default values:
            this.IpAddress = "10.20.2.81";
            this.PaymentType = (uint)PaymentTypeEnum.Points;
            this.PaymentInstrumentID = "";
            this.BillingToken = "";
        }

        protected override string GetServiceName()
        {
            return "/xbos/XeOfferPurchaseMusic.ashx";
        }

        public override bool Execute()
        {
            return Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xbos_billing_offering));
        }

        public override bool Execute(LiveServer sServer)
        {
            return Execute(sServer.EPDefault);
        }

        public override bool Execute(IPEndPoint endPoint)
        {
            MemoryStream reqStream = new MemoryStream(512);
            WriteStream(reqStream);

            // to support schema version
            if (!this.CustomHeader.Contains("X-Schema-Ver:"))
                this.CustomHeader += "X-Schema-Ver:" + WireInfoAttribute.VersionToString(this.SchemaVersion) + "\r\n";

            bool uRet = false;
            bool bRet = InternalExecute(endPoint, reqStream);

            if (bRet)
            {
                if ((xAct.httpStatus == HttpStatusCode.OK) && (xAct.XErr == 0))
                {
                    uRet = true;
                }
            }

            return uRet;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\Billing\Xenon\XRLXeOfferPurchaseGamertag.cs ===
using System;
using System.Net;
using System.IO;
using xonline.common.config;

namespace ServerTestFramework.LiveService.Billing
{
    public class XRLXeOfferPurchaseGamertag : XRLPayload
    {
        [XRLPayloadFld(IsUPuid=true)]
        public ulong UserPuid;
        [XRLPayloadFld(IsCountryId=true)]
        public byte CountryID;
        public ushort LanguageID;
		[XRLPayloadFld(IsTier=true)]
        public byte Tier;
        [XRLPayloadFld(IsMPuid=true)]
        public ulong MachinePuid;
        public ulong OfferID;
        public uint PaymentType;
        public ushort BillingTokenLength;
        [WireInfo(SizeParam="BillingTokenLength")]
        public string BillingToken;
        public ushort GamertagLength;
        [WireInfo(SizeParam="GamertagLength")]
        public string Gamertag;

        public XRLXeOfferPurchaseGamertag()
        {
            this.CountryID = 103;   // US
            this.LanguageID = 1;    // en
            this.Tier = 3;          // silver
            this.MachinePuid = XbosUser.DefaultMachinePuid;
            this.OfferID = Offers.GetBaseOfferId(Offers.BaseOffers.GamertagChange);
            this.PaymentType = (uint)PaymentTypeEnum.Points;
            this.BillingToken = "";
            this.Gamertag = "";
        }

        public void CopyMembers(XRLXeOfferPurchaseGamertag old)
        {
            this.UserPuid = old.UserPuid;
            this.CountryID = old.CountryID;
            this.LanguageID = old.LanguageID;
            this.Tier = old.Tier;
            this.MachinePuid = old.MachinePuid;
            this.OfferID = old.OfferID;
            this.PaymentType = old.PaymentType;
            this.BillingToken = old.BillingToken;
            this.Gamertag = old.Gamertag;
        }

        protected override string GetServiceName()
        {
            return "/xbos/XeOfferPurchaseGamertag.ashx";
        }

        public override bool Execute()
        {
            XRLXeOfferPurchaseGamertagResponse reply;
            return Execute(out reply);
        }

        public bool Execute(out XRLXeOfferPurchaseGamertagResponse Response)
        {
            return Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xbos_billing_offering), out Response);
        }

        public bool Execute(LiveServer sServer, out XRLXeOfferPurchaseGamertagResponse Response)
        {
            return Execute(sServer.EPDefault, out Response);
        }

        public bool Execute(IPEndPoint endPoint, out XRLXeOfferPurchaseGamertagResponse Response)
        {
            MemoryStream reqStream = new MemoryStream( 512 );
            WriteStream( reqStream );

            bool uRet = false;
            bool bRet=InternalExecute(endPoint,reqStream);

            Response=null;
            if(bRet)
            {
                if( (xAct.httpStatus == HttpStatusCode.OK) && (xAct.XErr == 0) )
                {
                    Response = new XRLXeOfferPurchaseGamertagResponse();
                    MemoryStream respBuff = new MemoryStream(xAct.ResponseContents);
                    Response.ReadStream(respBuff);

                    uRet = true;
                }
            }

            return uRet;
        }

        protected override void ReadResponse(MemoryStream responseStream)
        {
        }
    }

    public class XRLXeOfferPurchaseGamertagResponse : XRLPayload
    {
        public byte NewKeyLength;
        [WireInfo(SizeParam="NewKeyLength")]
        public byte [] NewKey;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\Billing\Xenon\XRLXeOfferingVerifyToken.cs ===
using System;
using System.IO;
using System.Net;
using ServerTestFramework.Utilities;
using ServerTestFramework.LiveService.FakeSG;
using ServerTestFramework.Database;
using xonline.common.config;


namespace ServerTestFramework.LiveService.Billing
{
    public class XRLXeOfferingVerifyToken : XRLPayload
    {
		public byte CountryId;
		public ushort VoucherLength;
		[WireInfo(SizeParam="VoucherLength")]
		public string Voucher;
        [XRLPayloadFld(MinSchemaVersion="4.2", IsUPuid=true)]
        public ulong userPuid = 0;

        public XRLXeOfferingVerifyToken()
        {
            this.CountryId = 103; // US
        }


        protected override string GetServiceName()
        {
            return "/xbos/XeOfferingVerifyToken.ashx";
        }

        public bool Execute(out XRLXeOfferingVerifyTokenResponse Response)
        {
            return Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xbos_billing_offering), out Response);
        }

        public bool Execute(LiveServer sServer, out XRLXeOfferingVerifyTokenResponse Response)
        {
            return Execute(sServer.EPDefault, out Response);
        }

        public bool Execute(IPEndPoint endPoint, out XRLXeOfferingVerifyTokenResponse Response)
        {
            // to support schema version
            if (!this.CustomHeader.Contains("X-Schema-Ver:"))
                this.CustomHeader += "X-Schema-Ver:" + WireInfoAttribute.VersionToString(this.SchemaVersion) + "\r\n";

            MemoryStream reqStream = new MemoryStream( 512 );
            WriteStream( reqStream );

            bool uRet = false;
            bool bRet=InternalExecute(endPoint,reqStream);

            Response=null;
            if(bRet)
            {
                if( (xAct.httpStatus == HttpStatusCode.OK) && (xAct.XErr == 0) )
                {
                    Response = new XRLXeOfferingVerifyTokenResponse();
                    MemoryStream respBuff = new MemoryStream(xAct.ResponseContents);
                    Response.ReadStream(respBuff);

                    uRet = true;
                }
            }

            return uRet;
        }
    }

    public class XRLXeOfferingVerifyTokenResponse : XRLPayload
    {
		public ulong OfferId;
		public uint OfferTypeId;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\Billing\Xenon\XRLXeOfferPurchaseVideo.cs ===
using System;
using System.IO;
using System.Net;
using ServerTestFramework.Utilities;
using ServerTestFramework.LiveService.FakeSG;
using ServerTestFramework.Database;
using xonline.common.config;

namespace ServerTestFramework.LiveService.Billing
{
    public class XRLWMID : XRLPayload
    {
        public ushort wmidLength;
        
        [WireInfo(SizeParam="wmidLength")]
        public string wmid;
        
        public uint videoType;
    }

    public class XRLXeOfferPurchaseVideoResponse : XRLPayload
    {
        public ushort wmidCount;

        [WireInfo(SizeParam="wmidCount")]
        public XRLWMID [] wmids;
    }

    public class XRLXeOfferPurchaseVideoRequest : XRLPayload
    {
        [XRLPayloadFld(IsUPuid=true)]
        public ulong userPuid;

        [XRLPayloadFld(IsMPuid=true)]
        public ulong machinePuid;

        public XRLWMID wmid;
        
        public uint expectedPrice;

        public uint paymentType;

        public ushort paymentInstrumentIDLength;

        [WireInfo(SizeParam="paymentInstrumentIDLength")]
        public string paymentInstrumentID;

        public ushort billingTokenLength;

        [WireInfo(SizeParam="billingTokenLength")]
        public string billingToken;

        public XRLXeOfferPurchaseVideoRequest()
        {
            this.paymentType = (uint)PaymentTypeEnum.Points;
            this.paymentInstrumentID = "";
            this.billingToken = "";
        }

        protected override string GetServiceName()
        {
            return "/xbos/XeOfferPurchaseVideo.ashx";
        }

        public bool Execute(out XRLXeOfferPurchaseVideoResponse Response)
        {
            return Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xbos_billing_offering), out Response);
        }

        public bool Execute(LiveServer sServer, out XRLXeOfferPurchaseVideoResponse Response)
        {
            return Execute(sServer.EPDefault, out Response);
        }

        public bool Execute(IPEndPoint endPoint, out XRLXeOfferPurchaseVideoResponse Response)
        {
            MemoryStream reqStream = new MemoryStream(512);
            WriteStream(reqStream);

            bool uRet = false;
            bool bRet = InternalExecute(endPoint, reqStream);

            Response=null;
            if (bRet)
            {
                if ((xAct.httpStatus == HttpStatusCode.OK) && (xAct.XErr == 0))
                {
                    Response = new XRLXeOfferPurchaseVideoResponse();
                    MemoryStream respBuff = new MemoryStream(xAct.ResponseContents);
                    Response.ReadStream(respBuff);
                    
                    uRet = true;
                }
            }

            return uRet;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\Billing\Xenon\XRLXeSubscriptionDetails.cs ===
using System;
using System.IO;
using System.Net;
using ServerTestFramework.Utilities;
using ServerTestFramework.LiveService.FakeSG;
using ServerTestFramework.Database;
using xonline.common.config;


namespace ServerTestFramework.LiveService.Billing
{
    public class XRLXeSubscriptionDetails : XRLPayload
    {
        [XRLPayloadFld(IsUPuid=true)]
        public ulong UserPuid;
        [XRLPayloadFld(IsMPuid=true)]
        public ulong MachinePuid;
        public byte CountryID;
        public ushort LanguageID;
        public ulong OfferID;
        public uint PaymentType; // credit card, token, points, etc
        public byte TierRequired;
        public byte RatingSystem;

		
		public XRLXeSubscriptionDetails()
		{
            // this.UserPuid, is required
			this.MachinePuid = XbosUser.DefaultMachinePuid;
			this.CountryID = 103;
			this.LanguageID = 1;
            this.OfferID = Offers.GetBaseOfferId(Offers.BaseOffers.GoldPP1Year);    // gold PP 1 year
            this.PaymentType = (uint)PaymentTypeEnum.Token;
            this.TierRequired = 6;
            this.RatingSystem = 0;  // ESRB
		}

        protected override string GetServiceName()
        {
            return "/xbos/XeSubscriptionDetails.ashx";
        }

        public bool Execute(out XRLXeSubscriptionDetailsResponse Response)
        {
            return Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xbos_billing_offering), out Response);
        }

        public bool Execute(LiveServer sServer, out XRLXeSubscriptionDetailsResponse Response)
        {
            return Execute(sServer.EPDefault, out Response);
        }

        public bool Execute(IPEndPoint endPoint, out XRLXeSubscriptionDetailsResponse Response)
        {
            MemoryStream reqStream = new MemoryStream( 512 );
            WriteStream( reqStream );

            bool uRet = false;
            bool bRet=InternalExecute(endPoint,reqStream);

            Response=null;
            if(bRet)
            {
                if( (xAct.httpStatus == HttpStatusCode.OK) && (xAct.XErr == 0) )
                {
                    Response = new XRLXeSubscriptionDetailsResponse();
                    MemoryStream respBuff = new MemoryStream(xAct.ResponseContents);
                    Response.ReadStream(respBuff);

                    uRet = true;
                }
            }

            return uRet;
        }
    }

    public class XRLXeSubscriptionDetailsResponse : XRLPayload
    {
        public BasicSubscriptionInfo BasicInfo;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\Billing\Xenon\XRLXeOfferPurchase.cs ===
using System;
using System.IO;
using System.Net;
using ServerTestFramework.Utilities;
using ServerTestFramework.LiveService.FakeSG;
using ServerTestFramework.Database;
using xonline.common.config;

namespace ServerTestFramework.LiveService.Billing
{
    public class XRLXeOfferPurchase : XRLPayload
    {
        [XRLPayloadFld(IsUPuid=true)]
        public ulong UserPuid;
        [XRLPayloadFld(IsCountryId = true)]
        public byte CountryID;
        public ushort LanguageID;
        [XRLPayloadFld(IsTier=true)]
        public byte Tier;
        [XRLPayloadFld(IsMPuid=true)]
        public ulong MachinePuid;

        [WireInfo(MinSchemaVersion = "2.0")]
        public uint OfferIDLength;

        [WireInfo(SizeParam = "OfferIDLength", MinSchemaVersion = "2.0")]
        public ulong[] OfferIDs;

        [WireInfo(MaxSchemaVersion = "1.0")]        
        public ulong OfferID;

        public uint PaymentType;
        public ushort PaymentInstrumentIDLength;
        [WireInfo(SizeParam="PaymentInstrumentIDLength")]
        public string PaymentInstrumentID;

        public ushort BillingTokenLength;
        [WireInfo(SizeParam="BillingTokenLength")]
        public string BillingToken;

        [WireInfo(MinSchemaVersion = "4.0")]
        public ushort EncryptedPasswordLength;
        [WireInfo(SizeParam = "EncryptedPasswordLength", MinSchemaVersion = "4.0")]
        public string EncryptedPassword;

        public XRLXeOfferPurchase()
        {
            SetDefaults();
        }

        public XRLXeOfferPurchase(uint schemaVersion, bool useHttpAuth)
        {
            SetDefaults();
            this.SchemaVersion = schemaVersion;
            this.UseHttpAuth = useHttpAuth;
        }

        public void SetDefaults()
        {
            // default values:
            this.CountryID = 103;
            this.LanguageID = 1;
            this.Tier = 3;
            this.MachinePuid = MachineEditor.CreateNew().Id;;
            this.PaymentType = (uint)PaymentTypeEnum.Points;
            this.PaymentInstrumentID = "";
            this.BillingToken = "";
        }

        public void CopyMembers(XRLXeOfferPurchase old)
        {
            this.UserPuid = old.UserPuid;
            this.CountryID = old.CountryID;
            this.LanguageID = old.LanguageID;
            this.Tier = old.Tier;
            this.MachinePuid = old.MachinePuid;
            this.OfferID = old.OfferID;
            this.PaymentType = old.PaymentType;
            this.PaymentInstrumentIDLength = old.PaymentInstrumentIDLength;
            this.PaymentInstrumentID = old.PaymentInstrumentID;
            this.BillingTokenLength = old.BillingTokenLength;
            this.BillingToken = old.BillingToken;

            this.OfferIDLength = old.OfferIDLength;
            if (old.OfferIDs != null)
                this.OfferIDs = (ulong[])old.OfferIDs.Clone();
            else
                this.OfferIDs = null;

            this.SchemaVersion = old.SchemaVersion;
            this.UseHttpAuth = old.UseHttpAuth;
            this.CustomHeader = old.CustomHeader;
        }

        protected override string GetServiceName()
        {
            return "/xbos/XeOfferPurchase.ashx";
        }

        public override bool Execute()
        {
            return Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xbos_billing_offering));
        }

        public override bool Execute(LiveServer sServer)
        {
            return Execute(sServer.EPDefault);
        }

        public override bool Execute(IPEndPoint endPoint)
        {
            // hack to make existing version 1 tests work with version 2
            if (SchemaVersion > WireData.MakeSchemaVersion(1, 0) && (OfferIDs == null || OfferIDs.GetLength(0) == 0) && OfferID > 0)
            {
                OfferIDs = new ulong[] { OfferID };
                OfferIDLength = 1;
                OfferID = 0;
            }

            // to support schema version
            if (!this.CustomHeader.Contains("X-Schema-Ver:"))
                this.CustomHeader += "X-Schema-Ver:" + WireInfoAttribute.VersionToString(this.SchemaVersion) + "\r\n";

            MemoryStream reqStream = new MemoryStream( 512 );
            WriteStream( reqStream );

            bool uRet = false;
            bool bRet=InternalExecute(endPoint,reqStream);

            if(bRet)
            {
                if( (xAct.httpStatus == HttpStatusCode.OK) && (xAct.XErr == 0) )
                {
                    uRet = true;
                }
            }

            return uRet;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\Billing\Xenon\XRLXeVerifyToken.cs ===
using System;
using System.IO;
using System.Net;
using ServerTestFramework.Utilities;
using ServerTestFramework.LiveService.FakeSG;
using ServerTestFramework.Database;
using xonline.common.config;


namespace ServerTestFramework.LiveService.Billing
{
    public class XRLXeVerifyToken : XRLPayload
    {
        [XRLPayloadFld(IsUPuid=true)]
        public ulong UserPuid;

        [XRLPayloadFld(IsMPuid=true)]
        public ulong MachinePuid;

        public ushort BillingTokenLength;
        [WireInfo(SizeParam="BillingTokenLength")]

        public string BillingToken;

        public uint StoreId = 1;

        protected override string GetServiceName()
        {
            return "/xbos/XeVerifyToken.ashx";
        }

        public bool Execute(out XRLXeVerifyTokenResponse Response)
        {
            return Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xbos_billing_offering), out Response);
        }

        public bool Execute(LiveServer sServer, out XRLXeVerifyTokenResponse Response)
        {
            return Execute(sServer.EPDefault, out Response);
        }

        public bool Execute(IPEndPoint endPoint, out XRLXeVerifyTokenResponse Response)
        {
            // to support schema version
            if (!this.CustomHeader.Contains("X-Schema-Ver:"))
                this.CustomHeader += "X-Schema-Ver:" + WireInfoAttribute.VersionToString(this.SchemaVersion) + "\r\n";

            MemoryStream reqStream = new MemoryStream( 512 );
            WriteStream( reqStream );

            bool uRet = false;
            bool bRet=InternalExecute(endPoint,reqStream);

            Response=null;
            if(bRet)
            {
                if( (xAct.httpStatus == HttpStatusCode.OK) && (xAct.XErr == 0) )
                {
                    Response = new XRLXeVerifyTokenResponse();
                    MemoryStream respBuff = new MemoryStream(xAct.ResponseContents);
                    Response.ReadStream(respBuff);

                    uRet = true;
                }
            }

            return uRet;
        }
    }

    public class XeXboxOfferInfo : XRLPayload
    {
        public ulong OfferId;
        public uint OfferTypeId;
    }

    public class XeEmsOfferInfo : XRLPayload
    {
        public Guid OfferId;
        public Guid MediaId;
        public uint MediaTypeId;
    }

    public enum OfferCatalogTypeEnum
    {
        Unknown     = 0,
        Xbox        = 1,
        Ems         = 2
    }

    public class XRLXeVerifyTokenResponse : XRLPayload
    {
        public ushort OfferCatalogType;
        public XeXboxOfferInfo XboxOfferInfo;
        public XeEmsOfferInfo EmsOfferInfo;
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\Billing\Xenon\XRLXeSubscriptionEnumerate.cs ===
using System;
using System.IO;
using System.Net;
using ServerTestFramework.Utilities;
using ServerTestFramework.LiveService.FakeSG;
using ServerTestFramework.Database;
using xonline.common.config;
using xonline.common.service;


namespace ServerTestFramework.LiveService.Billing
{
    public class XRLXeSubscriptionEnumerate : XRLPayload
    {
        [XRLPayloadFld(IsUPuid=true)]
        public ulong UserPuid;       
        [XRLPayloadFld(IsMPuid=true)]
        public ulong MachinePuid;
        public byte UserTier;
        public byte CountryID;
        public ushort LanguageID;
        public ushort GameRating;
        public uint OfferType; // live, game, 24-hour, add-on
        public uint PaymentType; // credit card, token, points, etc
        public uint TitleID;
        public uint TitleCategories;
        public ushort RequestFlags; // queryfornew, queryforequivalent etc...
        public int StartingIndex;
        public int MaxResults;

        public bool QueryForNew
        {
            get
            {
                return IsFlagSet((ushort)QueryFlagsEnum.QueryForNew, RequestFlags);
            }
            set
            {
                SetFlag((ushort)QueryFlagsEnum.QueryForNew, value, ref RequestFlags);
            }
        }

        public bool QueryForRenewals
        {
            get
            {
                return IsFlagSet((ushort)QueryFlagsEnum.QueryForRenewals, RequestFlags);
            }
            set
            {
                SetFlag((ushort)QueryFlagsEnum.QueryForRenewals, value, ref RequestFlags);
            }
        }

        public bool QueryForCurrent
        {
            get
            {
                return IsFlagSet((ushort)QueryFlagsEnum.QueryForCurrent, RequestFlags);
            }
            set
            {
                SetFlag((ushort)QueryFlagsEnum.QueryForCurrent, value, ref RequestFlags);
            }
        }

        public bool QueryForExpired
        {
            get
            {
                return IsFlagSet((ushort)QueryFlagsEnum.QueryForExpired, RequestFlags);
            }
            set
            {
                SetFlag((ushort)QueryFlagsEnum.QueryForExpired, value, ref RequestFlags);
            }
        }

        public bool QueryForSuspended
        {
            get
            {
                return IsFlagSet((ushort)QueryFlagsEnum.QueryForSuspended, RequestFlags);
            }
            set
            {
                SetFlag((ushort)QueryFlagsEnum.QueryForSuspended, value, ref RequestFlags);
            }
        }

        public XRLXeSubscriptionEnumerate()
        {
            // some default data to help out the users
            this.MachinePuid = XbosUser.DefaultMachinePuid;
            this.UserTier = 3;    // Silver
            this.CountryID = 103; // US
            this.LanguageID = 1;  // English
            this.GameRating = 1;  // ESRB Early Childhood
            this.OfferType = (uint)OfferingTypeEnum.Subscription; 
            this.PaymentType = (uint)PaymentTypeEnum.Token;
            this.TitleCategories = 0xffffffff;
            this.TitleID = XOn.XENON_DASH_TITLE_ID;
            this.RequestFlags = (ushort)QueryFlagsEnum.QueryForCurrent;
            this.StartingIndex = 0;
            this.MaxResults = 30;
        }


        protected override string GetServiceName()
        {
            return "/xbos/XeSubscriptionEnumerate.ashx";
        }

        public bool Execute(out XRLXeSubscriptionEnumerateResponse Response)
        {
            return Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.xbos_base_subscription), out Response);
        }

        public bool Execute(LiveServer sServer, out XRLXeSubscriptionEnumerateResponse Response)
        {
            return Execute(sServer.EPDefault, out Response);
        }

        public bool Execute(IPEndPoint endPoint, out XRLXeSubscriptionEnumerateResponse Response)
        {
            MemoryStream reqStream = new MemoryStream( 512 );
            WriteStream( reqStream );

            bool uRet = false;
            bool bRet=InternalExecute(endPoint,reqStream);

            Response=null;
            if(bRet)
            {
                if( (xAct.httpStatus == HttpStatusCode.OK) && (xAct.XErr == 0) )
                {
                    Response = new XRLXeSubscriptionEnumerateResponse();
                    MemoryStream respBuff = new MemoryStream(xAct.ResponseContents);
                    Response.ReadStream(respBuff);

                    uRet = true;
                }
            }

            return uRet;
        }
    }

    public class XRLXeSubscriptionEnumerateResponse : XRLPayload
    {
        public ushort OffersReturned;
        [WireInfo(SizeParam="OffersReturned")]
        public BasicSubscriptionInfo [] Subscriptions;
        public int OffersTotal;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\callback\SvcProviderWrapper.cs ===
using System;
using System.Net;
using System.Net.Security;
using System.Security.Cryptography.X509Certificates;
using System.Text.RegularExpressions;
using ServerTestFramework;
using ServerTestFramework.Database;
using xonline.common.config;

namespace ServerTestFramework.LiveService.Callback
{
    /// <summary>
    /// Summary description for SvcProviderWrapper.
    /// </summary>
    public class SvcProviderWrapper : ISvcProvider
    {
        public string AlternateMusicNetUrl = null;
        public string AlternateBillingUrl = null;
        public string InjectedScsError = null;
        public string AlternateDmpUrl = null;

        public static int ConcurrentCalls=0;
        public int errorCode=-1;
        public int responseClass=-1;
        public int expectedTransaction=-1;
        public int expectedStatus=-1;
        
        /// <summary>
        /// This is the default ServiceComponentId, which will be used in the event that we cannot look up the service component id using the provided offer or instance id.
        /// It is the ServiceComponentId for Gold PP 12 Months and can be looked up by running the following SQL query against UODB:
        /// SELECT vc_billing_svc_component_id FROM t_offers WHERE bi_offer_id=0XFFFE07D18000001A -- 0XFFFE07D18000001A is the offer id for Gold PP 12 Months
        ///
        /// TODO - The reason why we need a default ServiceComponentId here is because there are several negative Xcbk test cases that
        /// test with an invalid Offer Id or Instance Id. Naturally, we won't be able to look up the ServiceComponentId for those invalid Offer Ids from the DB,
        /// which means when those tests call ProvisionService, DisableService, etc. an error will occur. The short-term fix is to just default to
        /// a valid service component id; however, the long-term solution is to decouple the logic of looking up the ServiceComponentId from the 
        /// ProvisionService, DisableService etc. methods, and provide an overload that takes in a service component id. 
        /// Unfortunately, there are still a lot of open questions regarding the expected behavior of those negative test cases,
        /// so I am checking this fix in as a temporary stop-gap solution, and will follow up with a more long-term fix for the test cases.
        /// </summary>
        private const string ServiceComponentId = "b4ddce9d-dd08-4273-8919-705e5be296fe";

        static protected Regex RegexXCBKReturn1=new Regex(@"<ResponseInfo><ErrorCode/><ResponseClass>(?<responseClass>(.)+)</ResponseClass><ResponseMessage/></ResponseInfo>");
        static protected Regex RegexXCBKReturn2=new Regex(@"<ResponseInfo><ErrorCode>(?<errorCode>(.)+)</ErrorCode><ResponseClass>(?<responseClass>(.)+)</ResponseClass><ResponseMessage/></ResponseInfo>");

        static public void Initialize()
        {
            ServicePointManager.ServerCertificateValidationCallback += delegate(
                object sender, X509Certificate certificate, X509Chain chain, SslPolicyErrors sslPolicyErrors
                )
            {
                if (sslPolicyErrors != SslPolicyErrors.None)
                {
                    Console.WriteLine("Security Support Provider Interface (SSPI) Status Code = " + sslPolicyErrors.ToString());
                }
                return true;
            };
        }

        public bool CheckProvisioningStatus(string serviceId)
        {
            string s1= CheckProvisioningStatus(0,0,serviceId);
            ParseReturn(s1);
            return (errorCode==0) && (responseClass==0);
        }

        public bool ValidateProvisioningData(string serviceId,string details)
        {
            string response;
            string s1= ValidateProvisioningData(0,0,serviceId,details,out response);
            // For some reason VPD returns data through response instead of s1
            ParseReturn(response);
            return (errorCode==0) && (responseClass==0);
        }

        public void ParseReturn(string str)
        {
            Match match;
            match=RegexXCBKReturn1.Match(str);
            if (match.Length!=0)
            {
                errorCode=0;
                responseClass=Int32.Parse(match.Groups["responseClass"].Value);
            }
            match=RegexXCBKReturn2.Match(str);
            if (match.Length!=0)
            {
                errorCode=Int32.Parse(match.Groups["errorCode"].Value);
                responseClass=Int32.Parse(match.Groups["responseClass"].Value);
            }
        }

        public bool VerifyFlags(SubscriptionInfo newSi)
        {
            if (newSi.transactionFlag!=expectedTransaction ||
                newSi.statusId!=expectedStatus)
            {
                Global.RO.Warn("Flags don't match! TF:"+expectedTransaction+":"+newSi.transactionFlag+
                    "   Status:"+expectedStatus+":"+newSi.statusId);
                return false;
            }
            if (((TimeSpan)(newSi.changeTime-DateTime.Now)).TotalHours>9)
            {
                Global.RO.Warn("Date "+newSi.changeTime+", expected "+DateTime.Now);
                return false;
            }
            return true;
        }

        public bool ProvisionService(ref SubscriptionInfo sInfo)
        {
            return ProvisionService(ref sInfo,"Friendly","","<AlreadyProvisioned>1</AlreadyProvisioned>");
        }


        public bool ProvisionService(ref SubscriptionInfo sInfo,string friendlyName,string baseServiceInstanceId,string details)
        {
            System.Threading.Interlocked.Increment(ref ConcurrentCalls);
            int puidlo=(int) (sInfo.userPuid & 0xFFFFFFFF);
            int puidhi=(int) (sInfo.userPuid >> 32);
            string s1;
            string serviceComponentId;
            XbosWS.GetServiceComponentId(sInfo.offerId, out serviceComponentId, ServiceComponentId);
            s1 = ProvisionService(puidhi, puidlo, serviceComponentId, sInfo.serviceInstanceId, friendlyName, baseServiceInstanceId, details);
            ParseReturn(s1);
            expectedTransaction=sInfo.transactionFlag & ~1;
            expectedStatus=sInfo.statusId;
            System.Threading.Interlocked.Decrement(ref ConcurrentCalls);
            return (errorCode==0) && (responseClass==0);
        }

        public bool ProvisionService(ulong puid, string instanceId)
        {
            System.Threading.Interlocked.Increment(ref ConcurrentCalls);
            int puidlo=(int) (puid & 0xFFFFFFFF);
            int puidhi=(int) (puid >> 32);
            string serviceComponentId;
            XbosWS.GetServiceComponentId(instanceId, out serviceComponentId, ServiceComponentId);
            string s1 = ProvisionService(puidhi, puidlo, serviceComponentId, instanceId, "Friendly!", "baseid", "details");
            ParseReturn(s1);
            System.Threading.Interlocked.Decrement(ref ConcurrentCalls);
            return (errorCode==0) && (responseClass==0);
        }


        public bool DeprovisionService(ref SubscriptionInfo sInfo)
        {
            System.Threading.Interlocked.Increment(ref ConcurrentCalls);
            int puidlo=(int) (sInfo.userPuid & 0xFFFFFFFF);
            int puidhi=(int) (sInfo.userPuid >> 32);
            string serviceComponentId;
            XbosWS.GetServiceComponentId(sInfo.offerId, out serviceComponentId, ServiceComponentId);
            string s1 = DeprovisionService(puidhi, puidlo, serviceComponentId, sInfo.serviceInstanceId, false);
            ParseReturn(s1);
            expectedTransaction=sInfo.transactionFlag;
            expectedStatus=4;
            System.Threading.Interlocked.Decrement(ref ConcurrentCalls);
            return (errorCode==0) && (responseClass==0);
        }


        public bool EnableService(ref SubscriptionInfo sInfo)
        {
            int puidlo=(int) (sInfo.userPuid & 0xFFFFFFFF);
            int puidhi=(int) (sInfo.userPuid >> 32);
            string serviceComponentId;
            XbosWS.GetServiceComponentId(sInfo.offerId, out serviceComponentId, ServiceComponentId);
            string s1 = EnableService(puidhi, puidlo, serviceComponentId, sInfo.serviceInstanceId);
            ParseReturn(s1);
            expectedTransaction=sInfo.transactionFlag;
            expectedStatus=1;
            return (errorCode==0) && (responseClass==0);
        }


        public bool DisableService(ulong puid, string instanceId)
        {
            int puidlo=(int) (puid & 0xFFFFFFFF);
            int puidhi=(int) (puid >> 32);
            string serviceComponentId;
            XbosWS.GetServiceComponentId(instanceId, out serviceComponentId, ServiceComponentId);
            string s1 = DisableService(puidhi, puidlo, serviceComponentId, instanceId, "");
            expectedStatus=2;
            ParseReturn(s1);
            return (errorCode==0) && (responseClass==0);
        }

        public bool DisableService(ref SubscriptionInfo sInfo, string details)
        {
            int puidlo=(int) (sInfo.userPuid & 0xFFFFFFFF);
            int puidhi=(int) (sInfo.userPuid >> 32);
            string serviceComponentId;
            XbosWS.GetServiceComponentId(sInfo.offerId, out serviceComponentId, ServiceComponentId);
            string s1 = DisableService(puidhi, puidlo, serviceComponentId, sInfo.serviceInstanceId, details);
            expectedTransaction=sInfo.transactionFlag & ~2;
            expectedStatus=2;
            ParseReturn(s1);
            return (errorCode==0) && (responseClass==0);
        }

        public bool DeprovisionService(int puidhi, int puidlo, string instanceId, bool removeService, out string errorString)
        {
            string serviceComponentId;
            XbosWS.GetServiceComponentId(instanceId, out serviceComponentId, ServiceComponentId);
            string s1 = DeprovisionService(puidhi, puidlo, serviceComponentId, instanceId, removeService);
            ParseReturn(s1);
            errorString = s1;
            return (errorCode==0) && (responseClass==0);
        }

        public bool DeprovisionService(ulong puid, string instanceId, bool removeService, out string errorString)
        {
            int puidlo=(int) (puid & 0xFFFFFFFF);
            int puidhi=(int) (puid >> 32);
            string serviceComponentId;
            XbosWS.GetServiceComponentId(instanceId, out serviceComponentId, ServiceComponentId);
            string s1 = DeprovisionService(puidhi, puidlo, serviceComponentId, instanceId, removeService);
            ParseReturn(s1);
            errorString = s1;
            return (errorCode==0) && (responseClass==0);
        }


        public bool DeprovisionService(ulong puid, string instanceId, string serviceComponentId, bool removeService, out string errorString)
        {
            int puidlo = (int)(puid & 0xFFFFFFFF);
            int puidhi = (int)(puid >> 32);
            string s1 = DeprovisionService(puidhi, puidlo, serviceComponentId, instanceId, removeService);
            ParseReturn(s1);
            errorString = s1;
            return (errorCode == 0) && (responseClass == 0);
        }

        override protected WebRequest GetWebRequest(Uri url)
        {
            WebRequest wr = base.GetWebRequest(new Uri(Url));

            if (AlternateMusicNetUrl != null)
                wr.Headers.Add("AlternateMusicNetUrl", AlternateMusicNetUrl);
            if (AlternateBillingUrl != null)
                wr.Headers.Add("AlternateBillingUrl", AlternateBillingUrl);
            if (InjectedScsError != null)
                wr.Headers.Add("InjectedScsError", InjectedScsError);
            if (AlternateDmpUrl != null)
                wr.Headers.Add("AlternateDmpUrl", AlternateDmpUrl);

            return wr;
        }

        public SvcProviderWrapper():this(Global.XEnv.GetVirtualInterface(VirtualInterface.xcbk).ToString())
        {
        }

        public SvcProviderWrapper(string Server)
        {
            ServicePointManager.DefaultConnectionLimit=22;

            Url="https://"+Server+"/xcbk/sprov.asmx";

//            ServicePoint sp=ServicePointManager.FindServicePoint(Prov.Url, null);
//            Console.WriteLine("CurrentConnections = " + sp.CurrentConnections);
            Credentials=new NetworkCredential("spsp_xbox_sp","XuAb6KleM4vzilAmtCsvFCtZLMw");
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\Cron\XrlAddJob.cs ===
using System;
using xonline.common.config;

namespace ServerTestFramework.LiveService.Cron
{
	/// <summary>
	/// Summary description for XrlAddJob.
	/// </summary>
	public class XrlAddJobRequest:XRLPayload
	{
		public uint nameLen;
		public string name="NoName";
		public uint titleId=0x673;
		public uint assemblyLen;
		public string assembly="";
		public uint classNameLen;
		public string className="";
		public uint argsXmlLen;
		public string argsXml="";
		public long nextExec=DateTime.Now.ToFileTime();
		public uint intervalSecs=10;
		public uint execCount=1;
		public uint timeoutSecs=60;
		public XrlAddJobResponse Response;

		protected override string GetServiceName()
		{
			return "/cron/addjob.ashx";
		}

		public override bool Execute()
		{
			return base.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.cron_int));
		}

		protected override void ReadResponse(System.IO.MemoryStream responseStream)
		{
			Response=new XrlAddJobResponse();
			Response.ReadStream(responseStream);
		}
	}

	public class XrlAddJobResponse:WireData
	{
		public uint jobId;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\Catalog\CatalogRequest.cs ===
﻿using System;

namespace ServerTestFramework.LiveService.Catalog
{
    public class CatalogRequest : FilterWebRequest
    {
        public static class CatalogOperation
        {
            public static readonly String TestConnection = "TestConnection";
            public static readonly String Query = "Query";
            public static readonly String Execute = "Execute";
        }

        public static readonly String CATALOG_BASE_URL = "Catalog/catalog.asmx";

        /// <summary>
        /// Creates a catalog request of the given operation using values from a 
        /// provided filter.  This uses the filter name as the method name.
        /// </summary>
        /// <param name="operation">The operation to perform</param>
        /// <param name="filter">The filter to use in the request</param>
        public CatalogRequest(String operation, FilterBase filter)
            : base(CATALOG_BASE_URL, operation, filter)
        {
        }

        /// <summary>
        /// Sends this web request to the Catalog web interface
        /// </summary>
        /// <returns>True if the request was successfull, false otherwise</returns>
        public override bool SendRequest()
        {
            return SendRequest(Global.XEnv.GetVirtualInterface(xonline.common.config.Interface.catalog));
        }
    }

    public class CatalogResponse : WebResponseBase
    {
        public CatalogResponse()
        {
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\Cron\XrlGetJob.cs ===
using System;
using xonline.common.config;

namespace ServerTestFramework.LiveService.Cron
{
	/// <summary>
	/// Summary description for XrlGetJob.
	/// </summary>
	public class XrlGetJobRequest:XRLPayload
	{
		public uint jobId;
		public XrlGetJobResponse Response;

		protected override string GetServiceName()
		{
			return "/cron/getjob.ashx";
		}
		
		public override bool Execute()
		{
			return base.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.cron_int));
		}
		protected override void ReadResponse(System.IO.MemoryStream responseStream)
		{
			Response=new XrlGetJobResponse();
			Response.ReadStream(responseStream);
		}
	}

	public class XrlGetJobResponse:WireData
	{
		public XrlCronJobData job;
	}

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\callback\Reference.cs ===
﻿//------------------------------------------------------------------------------
// <autogenerated>
//     This code was generated by a tool.
//     Runtime Version: 1.0.3705.209
//
//     Changes to this file may cause incorrect behavior and will be lost if 
//     the code is regenerated.
// </autogenerated>
//------------------------------------------------------------------------------

// 
// This source code was auto-generated by Microsoft.VSDesigner, Version 1.0.3705.209.
// 
namespace ServerTestFramework.LiveService.Callback {
    using System.Diagnostics;
    using System.Xml.Serialization;
    using System;
    using System.Web.Services.Protocols;
    using System.ComponentModel;
    using System.Web.Services;
    
    
    /// <remarks/>
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Web.Services.WebServiceBindingAttribute(Name="ISvcProviderSoap", Namespace="urn:schemas-xbox-com:billing-data")]
    public class ISvcProvider : System.Web.Services.Protocols.SoapHttpClientProtocol {
        
        /// <remarks/>
        public ISvcProvider() {
            //this.Url = "https://192.168.86.200/xcbk/sprov.asmx";
			this.Url = "https://10.20.1.1:13000/xcbk/sprov.asmx";
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("urn:schemas-xbox-com:billing-data/ProvisionService", RequestNamespace="urn:schemas-xbox-com:billing-data", ResponseNamespace="urn:schemas-xbox-com:billing-data", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        [return: System.Xml.Serialization.XmlElementAttribute("pbstrResponseXML")]
        public string ProvisionService(int lPUIDHigh, int lPUIDLow, string bstrServiceComponentId, string bstrServiceInstanceId, string bstrServiceInstanceFriendlyName, string bstrBaseServiceInstanceId, string bstrDetails) {
            object[] results = this.Invoke("ProvisionService", new object[] {
                        lPUIDHigh,
                        lPUIDLow,
                        bstrServiceComponentId,
                        bstrServiceInstanceId,
                        bstrServiceInstanceFriendlyName,
                        bstrBaseServiceInstanceId,
                        bstrDetails});
            return ((string)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginProvisionService(int lPUIDHigh, int lPUIDLow, string bstrServiceComponentId, string bstrServiceInstanceId, string bstrServiceInstanceFriendlyName, string bstrBaseServiceInstanceId, string bstrDetails, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("ProvisionService", new object[] {
                        lPUIDHigh,
                        lPUIDLow,
                        bstrServiceComponentId,
                        bstrServiceInstanceId,
                        bstrServiceInstanceFriendlyName,
                        bstrBaseServiceInstanceId,
                        bstrDetails}, callback, asyncState);
        }
        
        /// <remarks/>
        public string EndProvisionService(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((string)(results[0]));
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("urn:schemas-xbox-com:billing-data/DeprovisionService", RequestNamespace="urn:schemas-xbox-com:billing-data", ResponseNamespace="urn:schemas-xbox-com:billing-data", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        [return: System.Xml.Serialization.XmlElementAttribute("pbstrResponseXML")]
        public string DeprovisionService(int lPUIDHigh, int lPUIDLow, string bstrServiceComponentId, string bstrServiceInstanceId, bool removeService) {
            object[] results = this.Invoke("DeprovisionService", new object[] {
                        lPUIDHigh,
                        lPUIDLow,
                        bstrServiceComponentId,
                        bstrServiceInstanceId,
						removeService});
            return ((string)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginDeprovisionService(int lPUIDHigh, int lPUIDLow, string bstrServiceComponentId, string bstrServiceInstanceId, bool removeService, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("DeprovisionService", new object[] {
                        lPUIDHigh,
                        lPUIDLow,
                        bstrServiceComponentId,
                        bstrServiceInstanceId,
						removeService}, callback, asyncState);
        }
        
        /// <remarks/>
        public string EndDeprovisionService(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((string)(results[0]));
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("urn:schemas-xbox-com:billing-data/EnableService", RequestNamespace="urn:schemas-xbox-com:billing-data", ResponseNamespace="urn:schemas-xbox-com:billing-data", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        [return: System.Xml.Serialization.XmlElementAttribute("pbstrResponseXML")]
        public string EnableService(int lPUIDHigh, int lPUIDLow, string bstrServiceComponentId, string bstrServiceInstanceId) {
            object[] results = this.Invoke("EnableService", new object[] {
                        lPUIDHigh,
                        lPUIDLow,
                        bstrServiceComponentId,
                        bstrServiceInstanceId});
            return ((string)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginEnableService(int lPUIDHigh, int lPUIDLow, string bstrServiceComponentId, string bstrServiceInstanceId, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("EnableService", new object[] {
                        lPUIDHigh,
                        lPUIDLow,
                        bstrServiceComponentId,
                        bstrServiceInstanceId}, callback, asyncState);
        }
        
        /// <remarks/>
        public string EndEnableService(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((string)(results[0]));
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("urn:schemas-xbox-com:billing-data/DisableService", RequestNamespace="urn:schemas-xbox-com:billing-data", ResponseNamespace="urn:schemas-xbox-com:billing-data", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        [return: System.Xml.Serialization.XmlElementAttribute("pbstrResponseXML")]
        public string DisableService(int lPUIDHigh, int lPUIDLow, string bstrServiceComponentId, string bstrServiceInstanceId, string bstrDetails) {
            object[] results = this.Invoke("DisableService", new object[] {
                        lPUIDHigh,
                        lPUIDLow,
                        bstrServiceComponentId,
                        bstrServiceInstanceId,
                        bstrDetails});
            return ((string)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginDisableService(int lPUIDHigh, int lPUIDLow, string bstrServiceComponentId, string bstrServiceInstanceId, string bstrDetails, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("DisableService", new object[] {
                        lPUIDHigh,
                        lPUIDLow,
                        bstrServiceComponentId,
                        bstrServiceInstanceId,
                        bstrDetails}, callback, asyncState);
        }
        
        /// <remarks/>
        public string EndDisableService(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((string)(results[0]));
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("urn:schemas-xbox-com:billing-data/ValidateProvisioningData", RequestNamespace="urn:schemas-xbox-com:billing-data", ResponseNamespace="urn:schemas-xbox-com:billing-data", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        [return: System.Xml.Serialization.XmlElementAttribute("pbstrDetailsResponse")]
        public string ValidateProvisioningData(int lPUIDHigh, int lPUIDLow, string bstrServiceComponentId, string bstrDetails, out string pbstrResponseXML) {
            object[] results = this.Invoke("ValidateProvisioningData", new object[] {
                        lPUIDHigh,
                        lPUIDLow,
                        bstrServiceComponentId,
                        bstrDetails});
            pbstrResponseXML = ((string)(results[1]));
            return ((string)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginValidateProvisioningData(int lPUIDHigh, int lPUIDLow, string bstrServiceComponentId, string bstrDetails, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("ValidateProvisioningData", new object[] {
                        lPUIDHigh,
                        lPUIDLow,
                        bstrServiceComponentId,
                        bstrDetails}, callback, asyncState);
        }
        
        /// <remarks/>
        public string EndValidateProvisioningData(System.IAsyncResult asyncResult, out string pbstrResponseXML) {
            object[] results = this.EndInvoke(asyncResult);
            pbstrResponseXML = ((string)(results[1]));
            return ((string)(results[0]));
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("urn:schemas-xbox-com:billing-data/CheckProvisioningStatus", RequestNamespace="urn:schemas-xbox-com:billing-data", ResponseNamespace="urn:schemas-xbox-com:billing-data", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        [return: System.Xml.Serialization.XmlElementAttribute("pbstrResponseXML")]
        public string CheckProvisioningStatus(int lPUIDHigh, int lPUIDLow, string bstrServiceComponentId) {
            object[] results = this.Invoke("CheckProvisioningStatus", new object[] {
                        lPUIDHigh,
                        lPUIDLow,
                        bstrServiceComponentId});
            return ((string)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginCheckProvisioningStatus(int lPUIDHigh, int lPUIDLow, string bstrServiceComponentId, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("CheckProvisioningStatus", new object[] {
                        lPUIDHigh,
                        lPUIDLow,
                        bstrServiceComponentId}, callback, asyncState);
        }
        
        /// <remarks/>
        public string EndCheckProvisioningStatus(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((string)(results[0]));
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\Catalog\QueryRequest.cs ===
﻿using System;
using System.Collections.Generic;
using System.Text;
using ServerTestFramework.LiveService.Billing.WebBilling;
using System.Net;
using xonline.common.config;
using System.IO;

namespace ServerTestFramework.LiveService.Catalog
{
    /// <summary>
    /// A basic query request class that can accept a filter
    /// </summary>
    public class QueryRequest : CatalogRequest
    {
        public static class QueryMethod
        {
            public const string FindCategories = "FindCategories";
            public const string FindCategoriesZune = "FindCategoriesZune";
            public const string FindContributors = "FindContributors";
            public const string FindFeaturedPodcasts = "FindFeaturedPodcasts";
            public const string FindGameOffers = "FindGameOffers";
            public const string FindGames = "FindGames";
            public const string FindGamesFTS = "FindGamesFTS";
            public const string FindImages = "FindImages";
            public const string FindMedia = "FindMedia";
            public const string FindMediaFTS = "FindMediaFTS";
            public const string FindMediaOffers = "FindMediaOffers";
            public const string FindPodcasts = "FindPodcasts";
            public const string FindPodcastsFTS = "FindPodcastsFTS";
            public const string FindRelatedMedia = "FindRelatedMedia";
            public const string FindVideoOffers = "FindVideoOffers";
            public const string FindVideos = "FindVideos";
            public const string FindVideosFTS = "FindVideosFTS";
            public const string ReportConcern = "ReportConcern";
            public const string SubmitPodcast = "SubmitPodcast";
        }

        /// <summary>
        /// Creates a query request with the given filter, and uses the filter name
        /// as the method name
        /// </summary>
        /// <param name="filter">The filter to create the request with</param>
        public QueryRequest(FilterBase filter)
            : base(CatalogOperation.Query, filter)
        { }
    }

    /// <summary>
    /// A generic query request type that uses a filter of the given type
    /// </summary>
    /// <typeparam name="FilterType">The type of filter to use for the request</typeparam>
    public class QueryRequest<FilterType> : QueryRequest
        where FilterType : FilterBase, new()
    {
        /// <summary>
        /// Provides access to a strongly typed version of the filter for this request
        /// </summary>
        public FilterType Filter
        {
            get { return BaseFilter as FilterType; }
        }

        /// <summary>
        /// Creates a query request with a filter of the type provided 
        /// and uses the FilterName as the methodName parameter
        /// </summary>
        public QueryRequest()
            : base(new FilterType())
        { }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\Cron\XrlFindJobs.cs ===
using System;
using xonline.common.config;

namespace ServerTestFramework.LiveService.Cron
{
	/// <summary>
	/// Summary description for XrlFindJobs.
	/// </summary>
	public class XrlFindJobsRequest:XRLPayload
	{
		public uint searchLen;
		public string search;
		public XrlFindJobsResponse Response;

		protected override string GetServiceName()
		{
			return "/cron/findjobs.ashx";
		}

		public override bool Execute()
		{
			return base.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.cron_int));
		}

		protected override void ReadResponse(System.IO.MemoryStream responseStream)
		{
			Response=new XrlFindJobsResponse();
			Response.ReadStream(responseStream);
		}
	}

	public class XrlFindJobsResponse:WireData
	{
		public uint jobsLen;
		public XrlCronJobData []jobs;
	}

	public class XrlCronJobData:WireData
	{
		public uint jobId;

		public uint nameLen;
		public string name;

		public uint titleId;

		public uint assemblyLen;
		public string assembly;

		public uint classNameLen;
		public string className;

		public uint argsXmlLen;
		public string argsXml;

		public ulong nextExec;
		public uint intervalSecs;
		public uint execCount;
		public uint timeoutSecs;

		public uint frontDoorLen;
		public string frontDoor;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\Catalog\CatalogFilters.cs ===
﻿using System;
using System.Collections.Generic;
using System.Text;
using StringPair = System.Collections.Generic.KeyValuePair<string, string>;

namespace ServerTestFramework.LiveService.Catalog
{
    public enum Store : int
    {
        Xbox360 = 1,
        PC = 2,
        Zune = 3
    }

    public enum DetailView : int
    {
        IdOnly = 1,
        Minimum = 2,
        Full = 3
    }

    public enum OfferFilterLevel : int
    {
        All = 1,
        WithOffers = 2
    }

    public enum OrderDirection : int
    {
        Ascending = 1,
        Descending = 2
    }

    public enum OrderMediaBy : int
    {
        Name = 1,               // Name of media
        ReleaseDate = 2,        // Date media was released
        AvailabilityDate = 3,   // Date media was made available in the catalog
        DownloadCount = 4,      // Order by number of downloads when applicable
        PurchaseCount = 5,      // Order by number of purchases when applicable
        PlayCount = 6,          // Order by number of times the item was played when applicable (not user specific count)
        IndustryRating = 7,     // Order by a provider/metadata rating when applicable
        UserRating = 8,         // Order by user specified rating when applicable
        UserRatingCount = 9     // Order by number of user ratings
    }

    public enum OrderMediaOffersBy : int
    {
        Name = 1,               // Name of media
        StartDate = 2,          // Offer Start Date
        ReleaseDate = 3,        // Date media was visible
        AvailabilityDate = 4,   // Date media was made available in the catalog
        DownloadCount = 5,      // Order by number of downloads when applicable
        PurchaseCount = 6       // Order by number of purchases when applicable
    }

    /// <summary>
    /// Used to specify the media relationship type.
    /// </summary>
    public enum MediaRelationshipType : int
    {
        EquivalentWorldwideGameTitle = 1,   // Used to link worldwide games that have different titleIDs in different regions
        MediaToAssociatedDownload = 2,      // Downloads which should show up under a media
        GameTrialToFullGame = 3,            // Trial Game to a Full Game
        VideoTrailerToGameTitle = 4,        // Video Trailers for a Game Title
        GameContentPreviewToFullGameContent = 5,    // Preview Offers
        SeriesToSeason = 6,                 // TV Episodic Seasons under TV Episodic Series.
        SeriesToEpisode = 7,                // TV Episodes to a Series where there is no season, e.g. Daily Show, Academy Awards etc.
        SeasonToEpisode = 8,                // TV Episodes under TV Seasons.
        VideoToPoster = 11,                 // Relationship between a Video and Image of a poster
        SeriesToBackgroundImage = 12,       // Relates a series to a background image
        SeasonToPoster = 13,                // Relationship between a Season and Image of a poster
        MediaToRole = 14,                   // Represents the relationship between media and a contributor
        MediaToImage = 15                   // Represents the relationship between media and image
    }
    
    /// <summary>
    /// TestConnection Filter
    /// </summary>
    public class TestConnectionFilter : FilterBase
    {
        [WebRequestParam("inputMessage", WebRequestParamType.StandAlone)]
        public string Message;

        public TestConnectionFilter(string message)
        {
            Message = message;
        }
    }

    //
    // QUERY
    //
    public class FindCategoriesFilter : FilterBase
    {
        /// <summary>
        /// Required.
        /// </summary>
        [WebRequestParam("methodName", WebRequestParamType.StandAlone, Requirement.Required)]
        public String methodName = "FindCategories";

        /// <summary>
        /// Required.
        /// </summary>
        [WebRequestParam("Locale", WebRequestParamType.NameValuePair, Requirement.Required)]
        public String Locale;

        /// <summary>
        /// Required.
        /// </summary>
        [WebRequestParam("LegalLocale", WebRequestParamType.NameValuePair, Requirement.Required)]
        public String LegalLocale;

        /// <summary>
        /// Required.
        /// </summary>
        [WebRequestParam("Store", WebRequestParamType.NameValuePair, Requirement.Required)]
        public Int32 Store;

        /// <summary>
        /// Required.
        /// </summary>
        [WebRequestParam("PageSize", WebRequestParamType.NameValuePair, Requirement.Required)]
        public Int32 PageSize;

        /// <summary>
        /// Required.
        /// </summary>
        [WebRequestParam("PageNum", WebRequestParamType.NameValuePair, Requirement.Required)]
        public Int32 PageNum;

        /// <summary>
        /// Required.
        /// </summary>
        [WebRequestParam("DetailView", WebRequestParamType.NameValuePair, Requirement.Required)]
        public Int32 DetailView;

        /// <summary>
        /// Required.
        /// </summary>
        [WebRequestParam("OfferFilterLevel", WebRequestParamType.NameValuePair, Requirement.Required)]
        public Int32 OfferFilterLevel;

        /// <summary>
        /// Required.
        /// </summary>
        [WebRequestParam("CategorySystemId", WebRequestParamType.NameValuePair, Requirement.Required)]
        public Int32 CategorySystemId;

        /// <summary>
        /// Optional.
        /// Up to 64 CategoryIds can be specified.
        /// </summary>
        [WebRequestParam("CategoryIds", WebRequestParamType.NameValuePair, Requirement.Optional, null)]
        public List<Int32> CategoryIds;

        /// <summary>
        /// Optional.
        /// </summary>
        [WebRequestParam("OrderBy", WebRequestParamType.NameValuePair, Requirement.Optional, "-1")]
        public Int32 OrderBy = -1;

        /// <summary>
        /// Optional.
        /// </summary>
        [WebRequestParam("OrderDirection", WebRequestParamType.NameValuePair, Requirement.Optional, "-1")]
        public Int32 OrderDirection = -1;
    }

    public class FindCategoriesZuneFilter : FilterBase
    {
        /// <summary>
        /// Required.
        /// </summary>
        [WebRequestParam("methodName", WebRequestParamType.StandAlone, Requirement.Required)]
        public String methodName = "FindCategoriesZune";

        /// <summary>
        /// Required.
        /// </summary>
        [WebRequestParam("Locale", WebRequestParamType.NameValuePair, Requirement.Required)]
        public String Locale;

        /// <summary>
        /// Required.
        /// </summary>
        [WebRequestParam("LegalLocale", WebRequestParamType.NameValuePair, Requirement.Required)]
        public String LegalLocale;

        /// <summary>
        /// Required.
        /// </summary>
        [WebRequestParam("Store", WebRequestParamType.NameValuePair, Requirement.Required)]
        public Int32 Store;

        /// <summary>
        /// Required.
        /// </summary>
        [WebRequestParam("PageSize", WebRequestParamType.NameValuePair, Requirement.Required)]
        public Int32 PageSize;

        /// <summary>
        /// Required.
        /// </summary>
        [WebRequestParam("PageNum", WebRequestParamType.NameValuePair, Requirement.Required)]
        public Int32 PageNum;

        /// <summary>
        /// Required.
        /// </summary>
        [WebRequestParam("DetailView", WebRequestParamType.NameValuePair, Requirement.Required)]
        public Int32 DetailView;

        /// <summary>
        /// Required.
        /// </summary>
        [WebRequestParam("OfferFilterLevel", WebRequestParamType.NameValuePair, Requirement.Required)]
        public Int32 OfferFilterLevel;

        /// <summary>
        /// Required.
        /// </summary>
        [WebRequestParam("CategorySystemId", WebRequestParamType.NameValuePair, Requirement.Required)]
        public Int32 CategorySystemId;

        /// <summary>
        /// Optional.
        /// Up to 64 CategoryIds can be specified.
        /// </summary>
        [WebRequestParam("CategoryIds", WebRequestParamType.NameValuePair, Requirement.Optional, null)]
        public List<Int32> CategoryIds;

        /// <summary>
        /// Optional.
        /// </summary>
        [WebRequestParam("OrderBy", WebRequestParamType.NameValuePair, Requirement.Optional, "-1")]
        public Int32 OrderBy = -1;

        /// <summary>
        /// Optional.
        /// </summary>
        [WebRequestParam("OrderDirection", WebRequestParamType.NameValuePair, Requirement.Optional, "-1")]
        public Int32 OrderDirection = -1;
    }

    public class FindContributorsFilter : FilterBase
    {
        /// <summary>
        /// Required.
        /// </summary>
        [WebRequestParam("methodName", WebRequestParamType.StandAlone, Requirement.Required)]
        public String methodName = "FindContributors";

        /// <summary>
        /// Required.
        /// </summary>
        [WebRequestParam("Locale", WebRequestParamType.NameValuePair, Requirement.Required)]
        public String Locale;

        /// <summary>
        /// Required.
        /// </summary>
        [WebRequestParam("LegalLocale", WebRequestParamType.NameValuePair, Requirement.Required)]
        public String LegalLocale;

        /// <summary>
        /// Required.
        /// </summary>
        [WebRequestParam("Store", WebRequestParamType.NameValuePair, Requirement.Required)]
        public Int32 Store;

        /// <summary>
        /// Required.
        /// </summary>
        [WebRequestParam("PageSize", WebRequestParamType.NameValuePair, Requirement.Required)]
        public Int32 PageSize;

        /// <summary>
        /// Required.
        /// </summary>
        [WebRequestParam("PageNum", WebRequestParamType.NameValuePair, Requirement.Required)]
        public Int32 PageNum;

        /// <summary>
        /// Required.
        /// </summary>
        [WebRequestParam("DetailView", WebRequestParamType.NameValuePair, Requirement.Required)]
        public Int32 DetailView;

        /// <summary>
        /// Required.
        /// Up to 256 MediaIds can be specified.
        /// </summary>
        [WebRequestParam("MediaIds", WebRequestParamType.NameValuePair, Requirement.Required)]
        public List<Guid> MediaIds;

        /// <summary>
        /// Required.
        /// </summary>
        [WebRequestParam("ContributorLimit", WebRequestParamType.NameValuePair, Requirement.Required)]
        public Int32 ContributorLimit;

        /// <summary>
        /// Optional.
        /// </summary>
        [WebRequestParam("OrderBy", WebRequestParamType.NameValuePair, Requirement.Optional, "-1")]
        public Int32 OrderBy = -1;

        /// <summary>
        /// Optional.
        /// </summary>
        [WebRequestParam("OrderDirection", WebRequestParamType.NameValuePair, Requirement.Optional, "-1")]
        public Int32 OrderDirection = -1;
    }

    public class FindFeaturedPodcastsFilter : FilterBase
    {
        /// <summary>
        /// Required.
        /// </summary>
        [WebRequestParam("methodName", WebRequestParamType.StandAlone, Requirement.Required)]
        public String methodName = "FindFeaturedPodcasts";

        /// <summary>
        /// Required.
        /// </summary>
        [WebRequestParam("Locale", WebRequestParamType.NameValuePair, Requirement.Required)]
        public String Locale;

        /// <summary>
        /// Required.
        /// </summary>
        [WebRequestParam("LegalLocale", WebRequestParamType.NameValuePair, Requirement.Required)]
        public String LegalLocale;

        /// <summary>
        /// Required.
        /// </summary>
        [WebRequestParam("PageSize", WebRequestParamType.NameValuePair, Requirement.Required)]
        public Int32 PageSize;

        /// <summary>
        /// Required.
        /// </summary>
        [WebRequestParam("PageNum", WebRequestParamType.NameValuePair, Requirement.Required)]
        public Int32 PageNum;

        /// <summary>
        /// Required.
        /// </summary>
        [WebRequestParam("DetailView", WebRequestParamType.NameValuePair, Requirement.Required)]
        public Int32 DetailView;


        /// <summary>
        /// Required.
        /// </summary>
        [WebRequestParam("CollectionId", WebRequestParamType.NameValuePair, Requirement.Required)]
        public String CollectionId;

    }

    public class FindGameOffersFilter : FilterBase
    {
        /// <summary>
        /// Required.
        /// </summary>
        [WebRequestParam("methodName", WebRequestParamType.StandAlone, Requirement.Required)]
        public String methodName = "FindGameOffers";

        /// <summary>
        /// Required.
        /// </summary>
        [WebRequestParam("Locale", WebRequestParamType.NameValuePair, Requirement.Required)]
        public String Locale;

        /// <summary>
        /// Required.
        /// </summary>
        [WebRequestParam("LegalLocale", WebRequestParamType.NameValuePair, Requirement.Required)]
        public String LegalLocale;

        /// <summary>
        /// Required.
        /// </summary>
        [WebRequestParam("Store", WebRequestParamType.NameValuePair, Requirement.Required)]
        public Int32 Store;

        /// <summary>
        /// Required.
        /// </summary>
        [WebRequestParam("PageSize", WebRequestParamType.NameValuePair, Requirement.Required)]
        public Int32 PageSize;

        /// <summary>
        /// Required.
        /// </summary>
        [WebRequestParam("PageNum", WebRequestParamType.NameValuePair, Requirement.Required)]
        public Int32 PageNum;

        /// <summary>
        /// Required.
        /// </summary>
        [WebRequestParam("DetailView", WebRequestParamType.NameValuePair, Requirement.Required)]
        public Int32 DetailView;

        /// <summary>
        /// Optional.
        /// Up to 256 OfferIds may be specified.
        /// </summary>
        [WebRequestParam("OfferIds", WebRequestParamType.NameValuePair, Requirement.Optional, null)]
        public List<Guid> OfferIds;

        /// <summary>
        /// Optional.
        /// Up to 256 MediaIds may be specified.
        /// </summary>
        [WebRequestParam("MediaIds", WebRequestParamType.NameValuePair, Requirement.Optional, null)]
        public List<Guid> MediaIds;

        /// <summary>
        /// Optional.
        /// Up to 64 RatingIds may be specified.
        /// </summary>
        [WebRequestParam("RatingIds", WebRequestParamType.NameValuePair, Requirement.Optional, null)]
        public List<Int32> RatingIds;

        /// <summary>
        /// Optional.
        /// Up to 64 UserTypes may be specified.
        /// </summary>
        [WebRequestParam("UserTypes", WebRequestParamType.NameValuePair, Requirement.Optional, null)]
        public List<Int32> UserTypes;

        /// <summary>
        /// Required.
        /// Up to 64 MediaTypes may be specified.
        /// </summary>
        [WebRequestParam("MediaTypes", WebRequestParamType.NameValuePair, Requirement.Required)]
        public List<Int32> MediaTypes;

        /// <summary>
        /// Optional.
        /// Up to 64 CategoryIds may be specified.
        /// </summary>
        [WebRequestParam("CategoryIds", WebRequestParamType.NameValuePair, Requirement.Optional, null)]
        public List<Int32> CategoryIds;


        /// <summary>
        /// Optional.
        /// Up to 64 TitleFilters may be specified.
        /// </summary>
        [WebRequestParam("TitleFilters", WebRequestParamType.NameValuePair, Requirement.Optional, null)]
        public List<String> TitleFilters;


        /// <summary>
        /// Optional.
        /// Up to 64 ImageTypeIds may be specified.
        /// </summary>
        [WebRequestParam("ImageTypeIds", WebRequestParamType.NameValuePair, Requirement.Optional, null)]
        public List<Int32> ImageTypeIds;

        /// <summary>
        /// Optional.
        /// Up to 64 ImageFormats may be specified.
        /// </summary>
        [WebRequestParam("ImageFormats", WebRequestParamType.NameValuePair, Requirement.Optional, null)]
        public List<Int32> ImageFormats;

        /// <summary>
        /// Optional.
        /// Up to 64 ImageSizes may be specified.
        /// </summary>
        [WebRequestParam("ImageSizes", WebRequestParamType.NameValuePair, Requirement.Optional, null)]
        public List<Int32> ImageSizes;


        /// <summary>
        /// Optional.
        /// Up to 64 Relations may be specified.
        /// </summary>
        [WebRequestParam("Relations", WebRequestParamType.NameValuePair, Requirement.Optional, null)]
        public List<Int32> Relations;

        /// <summary>
        /// Optional.
        /// </summary>
        [WebRequestParam("OrderBy", WebRequestParamType.NameValuePair, Requirement.Optional, "-1")]
        public Int32 OrderBy = -1;

        /// <summary>
        /// Optional.
        /// </summary>
        [WebRequestParam("OrderDirection", WebRequestParamType.NameValuePair, Requirement.Optional, "-1")]
        public Int32 OrderDirection = -1;

    }

    public class FindGamesFilter : FilterBase
    {
        /// <summary>
        /// Required.
        /// </summary>
        [WebRequestParam("methodName", WebRequestParamType.StandAlone, Requirement.Required)]
        public String methodName = "FindGames";

        /// <summary>
        /// Required.
        /// </summary>
        [WebRequestParam("Locale", WebRequestParamType.NameValuePair, Requirement.Required)]
        public String Locale;

        /// <summary>
        /// Required.
        /// </summary>
        [WebRequestParam("LegalLocale", WebRequestParamType.NameValuePair, Requirement.Required)]
        public String LegalLocale;

        /// <summary>
        /// Required.
        /// </summary>
        [WebRequestParam("Store", WebRequestParamType.NameValuePair, Requirement.Required)]
        public Int32 Store;

        /// <summary>
        /// Required.
        /// </summary>
        [WebRequestParam("PageSize", WebRequestParamType.NameValuePair, Requirement.Required)]
        public Int32 PageSize;

        /// <summary>
        /// Required.
        /// </summary>
        [WebRequestParam("PageNum", WebRequestParamType.NameValuePair, Requirement.Required)]
        public Int32 PageNum;

        /// <summary>
        /// Required.
        /// </summary>
        [WebRequestParam("DetailView", WebRequestParamType.NameValuePair, Requirement.Required)]
        public Int32 DetailView;

        /// <summary>
        /// Required.
        /// </summary>
        [WebRequestParam("OfferFilterLevel", WebRequestParamType.NameValuePair, Requirement.Required)]
        public Int32 OfferFilterLevel;

        /// <summary>
        /// Optional.
        /// Up to 256 MediaIds may be specified.
        /// </summary>
        [WebRequestParam("MediaIds", WebRequestParamType.NameValuePair, Requirement.Optional, null)]
        public List<Guid> MediaIds;

        /// <summary>
        /// Optional.
        /// </summary>
        //[WebRequestParam("ExternalId", WebRequestParamType.NameValuePair, Requirement.Optional, null)]
        //public String ExternalId;

        /// <summary>
        /// Optional.
        /// Up to 64 RatingIds may be specified.
        /// </summary>
        [WebRequestParam("RatingIds", WebRequestParamType.NameValuePair, Requirement.Optional, null)]
        public List<Int32> RatingIds;

        /// <summary>
        /// Optional.
        /// Up to 64 UserTypes may be specified.
        /// </summary>
        [WebRequestParam("UserTypes", WebRequestParamType.NameValuePair, Requirement.Optional, null)]
        public List<Int32> UserTypes;

        /// <summary>
        /// Required.
        /// Up to 64 MediaTypes may be specified.
        /// </summary>
        [WebRequestParam("MediaTypes", WebRequestParamType.NameValuePair, Requirement.Required)]
        public List<Int32> MediaTypes;

        /// <summary>
        /// Optional.
        /// Up to 64 CategoryIds may be specified.
        /// </summary>
        [WebRequestParam("CategoryIds", WebRequestParamType.NameValuePair, Requirement.Optional, null)]
        public List<Int32> CategoryIds;

        /// <summary>
        /// Optional.
        /// Up to 64 TitleFilters may be specified.
        /// </summary>
        [WebRequestParam("TitleFilters", WebRequestParamType.NameValuePair, Requirement.Optional, null)]
        public List<String> TitleFilters;

        /// <summary>
        /// Required.
        /// Up to 64 MediaTypes may be specified.
        /// </summary>
        [WebRequestParam("OfferTargetMediaTypes", WebRequestParamType.NameValuePair, Requirement.Optional, null)]
        public List<Int32> OfferTargetMediaTypes;


        /// <summary>
        /// Optional.
        /// Up to 64 ImageTypeIds may be specified.
        /// </summary>
        [WebRequestParam("ImageTypeIds", WebRequestParamType.NameValuePair, Requirement.Optional, null)]
        public List<Int32> ImageTypeIds;

        /// <summary>
        /// Optional.
        /// Up to 64 ImageFormats may be specified.
        /// </summary>
        [WebRequestParam("ImageFormats", WebRequestParamType.NameValuePair, Requirement.Optional, null)]
        public List<Int32> ImageFormats;

        /// <summary>
        /// Optional.
        /// Up to 64 ImageSizes may be specified.
        /// </summary>
        [WebRequestParam("ImageSizes", WebRequestParamType.NameValuePair, Requirement.Optional, null)]
        public List<Int32> ImageSizes;


        /// <summary>
        /// Optional.
        /// Up to 64 Relations may be specified.
        /// </summary>
        [WebRequestParam("Relations", WebRequestParamType.NameValuePair, Requirement.Optional, null)]
        public List<Int32> Relations;

        /// <summary>
        /// Optional.
        /// </summary>
        [WebRequestParam("OrderBy", WebRequestParamType.NameValuePair, Requirement.Optional, "-1")]
        public Int32 OrderBy = -1;

        /// <summary>
        /// Optional.
        /// </summary>
        [WebRequestParam("OrderDirection", WebRequestParamType.NameValuePair, Requirement.Optional, "-1")]
        public Int32 OrderDirection = -1;

    }

    public class FindGamesFTSFilter : FilterBase
    {
        /// <summary>
        /// Required.
        /// </summary>
        [WebRequestParam("methodName", WebRequestParamType.StandAlone, Requirement.Required)]
        public String methodName = "FindGamesFTS";

        /// <summary>
        /// Required.
        /// </summary>
        [WebRequestParam("Query", WebRequestParamType.NameValuePair, Requirement.Required)]
        public String Query;

        /// <summary>
        /// Required.
        /// </summary>
        [WebRequestParam("RankingType", WebRequestParamType.NameValuePair, Requirement.Required)]
        public Int32 RankingType;

        /// <summary>
        /// Required.
        /// </summary>
        [WebRequestParam("Locale", WebRequestParamType.NameValuePair, Requirement.Required)]
        public String Locale;

        /// <summary>
        /// Required.
        /// </summary>
        [WebRequestParam("LegalLocale", WebRequestParamType.NameValuePair, Requirement.Required)]
        public String LegalLocale;

        /// <summary>
        /// Required.
        /// </summary>
        [WebRequestParam("Store", WebRequestParamType.NameValuePair, Requirement.Required)]
        public Int32 Store;

        /// <summary>
        /// Required.
        /// </summary>
        [WebRequestParam("PageSize", WebRequestParamType.NameValuePair, Requirement.Required)]
        public Int32 PageSize;

        /// <summary>
        /// Required.
        /// </summary>
        [WebRequestParam("PageNum", WebRequestParamType.NameValuePair, Requirement.Required)]
        public Int32 PageNum;

        /// <summary>
        /// Required.
        /// </summary>
        [WebRequestParam("DetailView", WebRequestParamType.NameValuePair, Requirement.Required)]
        public Int32 DetailView;

        /// <summary>
        /// Required.
        /// </summary>
        [WebRequestParam("OfferFilterLevel", WebRequestParamType.NameValuePair, Requirement.Required)]
        public Int32 OfferFilterLevel;

        /// <summary>
        /// Optional.
        /// </summary>
        [WebRequestParam("ExternalId", WebRequestParamType.NameValuePair, Requirement.Optional, null)]
        public String ExternalId;

        /// <summary>
        /// Optional.
        /// Up to 64 RatingIds may be specified.
        /// </summary>
        [WebRequestParam("RatingIds", WebRequestParamType.NameValuePair, Requirement.Optional, null)]
        public List<Int32> RatingIds;

        /// <summary>
        /// Optional.
        /// Up to 64 UserTypes may be specified.
        /// </summary>
        [WebRequestParam("UserTypes", WebRequestParamType.NameValuePair, Requirement.Optional, null)]
        public List<Int32> UserTypes;

        /// <summary>
        /// Required.
        /// Up to 64 MediaTypes may be specified.
        /// </summary>
        [WebRequestParam("MediaTypes", WebRequestParamType.NameValuePair, Requirement.Required)]
        public List<Int32> MediaTypes;

        /// <summary>
        /// Optional.
        /// Up to 64 CategoryIds may be specified.
        /// </summary>
        [WebRequestParam("CategoryIds", WebRequestParamType.NameValuePair, Requirement.Optional, null)]
        public List<Int32> CategoryIds;

        /// <summary>
        /// Optional.
        /// </summary>
        [WebRequestParam("OrderBy", WebRequestParamType.NameValuePair, Requirement.Optional, "-1")]
        public Int32 OrderBy = -1;

        /// <summary>
        /// Optional.
        /// </summary>
        [WebRequestParam("OrderDirection", WebRequestParamType.NameValuePair, Requirement.Optional, "-1")]
        public Int32 OrderDirection = -1;

    }

    public class FindImagesFilter : FilterBase
    {
        /// <summary>
        /// Required.
        /// </summary>
        [WebRequestParam("methodName", WebRequestParamType.StandAlone, Requirement.Required)]
        public String methodName = "FindImages";

        /// <summary>
        /// Required.
        /// </summary>
        [WebRequestParam("Locale", WebRequestParamType.NameValuePair, Requirement.Required)]
        public String Locale;

        /// <summary>
        /// Required.
        /// </summary>
        [WebRequestParam("LegalLocale", WebRequestParamType.NameValuePair, Requirement.Required)]
        public String LegalLocale;

        /// <summary>
        /// Required.
        /// </summary>
        [WebRequestParam("Store", WebRequestParamType.NameValuePair, Requirement.Required)]
        public Int32 Store;

        /// <summary>
        /// Required.
        /// </summary>
        [WebRequestParam("PageSize", WebRequestParamType.NameValuePair, Requirement.Required)]
        public Int32 PageSize;

        /// <summary>
        /// Required.
        /// </summary>
        [WebRequestParam("PageNum", WebRequestParamType.NameValuePair, Requirement.Required)]
        public Int32 PageNum;

        /// <summary>
        /// Required.
        /// </summary>
        [WebRequestParam("DetailView", WebRequestParamType.NameValuePair, Requirement.Required)]
        public Int32 DetailView;

        /// <summary>
        /// Required.
        /// </summary>
        [WebRequestParam("OfferFilterLevel", WebRequestParamType.NameValuePair, Requirement.Required)]
        public Int32 OfferFilterLevel;

        /// <summary>
        /// Optional.
        /// Up to 256 MediaIds may be specified.
        /// </summary>
        [WebRequestParam("MediaIds", WebRequestParamType.NameValuePair, Requirement.Optional, null)]
        public List<Guid> MediaIds;

        /// <summary>
        /// Required.
        /// Up to 64 MediaTypes may be specified.
        /// </summary>
        [WebRequestParam("MediaTypes", WebRequestParamType.NameValuePair, Requirement.Required)]
        public List<Int32> MediaTypes;

        /// <summary>
        /// Optional.
        /// Up to 64 ImageFormats may be specified.
        /// </summary>
        [WebRequestParam("ImageFormats", WebRequestParamType.NameValuePair, Requirement.Optional, null)]
        public List<Int32> ImageFormats;

        /// <summary>
        /// Optional.
        /// Up to 64 ImageSizes may be specified.
        /// </summary>
        [WebRequestParam("ImageSizes", WebRequestParamType.NameValuePair, Requirement.Optional, null)]
        public List<Int32> ImageSizes;

        /// <summary>
        /// Required.
        /// </summary>
        [WebRequestParam("OrderBy", WebRequestParamType.NameValuePair, Requirement.Required)]
        public Int32 OrderBy = -1;

        /// <summary>
        /// Required.
        /// </summary>
        [WebRequestParam("OrderDirection", WebRequestParamType.NameValuePair, Requirement.Required)]
        public Int32 OrderDirection = -1;
    }

    public class FindMediaFilter : FilterBase
    {
        /// <summary>
        /// Required.
        /// </summary>
        [WebRequestParam("methodName", WebRequestParamType.StandAlone, Requirement.Required)]
        public String methodName = "FindMedia";

        /// <summary>
        /// Required.
        /// </summary>
        [WebRequestParam("Locale", WebRequestParamType.NameValuePair, Requirement.Required)]
        public String Locale;

        /// <summary>
        /// Required.
        /// </summary>
        [WebRequestParam("LegalLocale", WebRequestParamType.NameValuePair, Requirement.Required)]
        public String LegalLocale;

        /// <summary>
        /// Required.
        /// </summary>
        [WebRequestParam("Store", WebRequestParamType.NameValuePair, Requirement.Required)]
        public Int32 Store;

        /// <summary>
        /// Required.
        /// </summary>
        [WebRequestParam("PageSize", WebRequestParamType.NameValuePair, Requirement.Required)]
        public Int32 PageSize;

        /// <summary>
        /// Required.
        /// </summary>
        [WebRequestParam("PageNum", WebRequestParamType.NameValuePair, Requirement.Required)]
        public Int32 PageNum;

        /// <summary>
        /// Required.
        /// </summary>
        [WebRequestParam("DetailView", WebRequestParamType.NameValuePair, Requirement.Required)]
        public Int32 DetailView;

        /// <summary>
        /// Required.
        /// </summary>
        [WebRequestParam("OfferFilterLevel", WebRequestParamType.NameValuePair, Requirement.Required)]
        public Int32 OfferFilterLevel;

        /// <summary>
        /// Optional.
        /// Up to 256 MediaIds may be specified.
        /// </summary>
        [WebRequestParam("MediaIds", WebRequestParamType.NameValuePair, Requirement.Optional, null)]
        public List<Guid> MediaIds;

        /// <summary>
        /// Optional.
        /// Up to 64 RatingIds may be specified.
        /// </summary>
        [WebRequestParam("RatingIds", WebRequestParamType.NameValuePair, Requirement.Optional, null)]
        public List<Int32> RatingIds;

        /// <summary>
        /// Optional.
        /// Up to 64 UserTypes may be specified.
        /// </summary>
        [WebRequestParam("UserTypes", WebRequestParamType.NameValuePair, Requirement.Optional, null)]
        public List<Int32> UserTypes;

        /// <summary>
        /// Required.
        /// Up to 64 MediaTypes may be specified.
        /// </summary>
        [WebRequestParam("MediaTypes", WebRequestParamType.NameValuePair, Requirement.Required)]
        public List<Int32> MediaTypes;

        /// <summary>
        /// Optional.
        /// Up to 64 CategoryIds may be specified.
        /// </summary>
        [WebRequestParam("CategoryIds", WebRequestParamType.NameValuePair, Requirement.Optional, null)]
        public List<Int32> CategoryIds;

        /// <summary>
        /// Optional.
        /// </summary>
        [WebRequestParam("OrderBy", WebRequestParamType.NameValuePair, Requirement.Optional, "-1")]
        public Int32 OrderBy = -1;

        /// <summary>
        /// Optional.
        /// </summary>
        [WebRequestParam("OrderDirection", WebRequestParamType.NameValuePair, Requirement.Optional, "-1")]
        public Int32 OrderDirection = -1;

    }

    public class FindMediaFTSFilter : FilterBase
    {
        /// <summary>
        /// Required.
        /// </summary>
        [WebRequestParam("methodName", WebRequestParamType.StandAlone, Requirement.Required)]
        public String methodName = "FindMediaFTS";

        /// <summary>
        /// Required.
        /// </summary>
        [WebRequestParam("Query", WebRequestParamType.NameValuePair, Requirement.Required)]
        public String Query;

        /// <summary>
        /// Required.
        /// </summary>
        [WebRequestParam("RankingType", WebRequestParamType.NameValuePair, Requirement.Required)]
        public Int32 RankingType;

        /// <summary>
        /// Required.
        /// </summary>
        [WebRequestParam("Locale", WebRequestParamType.NameValuePair, Requirement.Required)]
        public String Locale;

        /// <summary>
        /// Required.
        /// </summary>
        [WebRequestParam("LegalLocale", WebRequestParamType.NameValuePair, Requirement.Required)]
        public String LegalLocale;

        /// <summary>
        /// Required.
        /// </summary>
        [WebRequestParam("Store", WebRequestParamType.NameValuePair, Requirement.Required)]
        public Int32 Store;

        /// <summary>
        /// Required.
        /// </summary>
        [WebRequestParam("PageSize", WebRequestParamType.NameValuePair, Requirement.Required)]
        public Int32 PageSize;

        /// <summary>
        /// Required.
        /// </summary>
        [WebRequestParam("PageNum", WebRequestParamType.NameValuePair, Requirement.Required)]
        public Int32 PageNum;

        /// <summary>
        /// Required.
        /// </summary>
        [WebRequestParam("DetailView", WebRequestParamType.NameValuePair, Requirement.Required)]
        public Int32 DetailView;

        /// <summary>
        /// Required.
        /// </summary>
        [WebRequestParam("OfferFilterLevel", WebRequestParamType.NameValuePair, Requirement.Required)]
        public Int32 OfferFilterLevel;

        /// <summary>
        /// Optional.
        /// Up to 64 RatingIds may be specified.
        /// </summary>
        [WebRequestParam("RatingIds", WebRequestParamType.NameValuePair, Requirement.Optional, null)]
        public List<Int32> RatingIds;

        /// <summary>
        /// Optional.
        /// Up to 64 UserTypes may be specified.
        /// </summary>
        [WebRequestParam("UserTypes", WebRequestParamType.NameValuePair, Requirement.Optional, null)]
        public List<Int32> UserTypes;

        /// <summary>
        /// Required.
        /// Up to 64 MediaTypes may be specified.
        /// </summary>
        [WebRequestParam("MediaTypes", WebRequestParamType.NameValuePair, Requirement.Required)]
        public List<Int32> MediaTypes;

        /// <summary>
        /// Optional.
        /// Up to 64 CategoryIds may be specified.
        /// </summary>
        [WebRequestParam("CategoryIds", WebRequestParamType.NameValuePair, Requirement.Optional, null)]
        public List<Int32> CategoryIds;

        /// <summary>
        /// Optional.
        /// </summary>
        [WebRequestParam("OrderBy", WebRequestParamType.NameValuePair, Requirement.Optional, "-1")]
        public Int32 OrderBy = -1;

        /// <summary>
        /// Optional.
        /// </summary>
        [WebRequestParam("OrderDirection", WebRequestParamType.NameValuePair, Requirement.Optional, "-1")]
        public Int32 OrderDirection = -1;

    }

    public class FindMediaOffersFilter : FilterBase
    {
        /// <summary>
        /// Required.
        /// </summary>
        [WebRequestParam("methodName", WebRequestParamType.StandAlone, Requirement.Required)]
        public String methodName = "FindMediaOffers";

        /// <summary>
        /// Required.
        /// </summary>
        [WebRequestParam("Locale", WebRequestParamType.NameValuePair, Requirement.Required)]
        public String Locale;

        /// <summary>
        /// Required.
        /// </summary>
        [WebRequestParam("LegalLocale", WebRequestParamType.NameValuePair, Requirement.Required)]
        public String LegalLocale;

        /// <summary>
        /// Required.
        /// </summary>
        [WebRequestParam("Store", WebRequestParamType.NameValuePair, Requirement.Required)]
        public Int32 Store;

        /// <summary>
        /// Required.
        /// </summary>
        [WebRequestParam("PageSize", WebRequestParamType.NameValuePair, Requirement.Required)]
        public Int32 PageSize;

        /// <summary>
        /// Required.
        /// </summary>
        [WebRequestParam("PageNum", WebRequestParamType.NameValuePair, Requirement.Required)]
        public Int32 PageNum;

        /// <summary>
        /// Required.
        /// </summary>
        [WebRequestParam("DetailView", WebRequestParamType.NameValuePair, Requirement.Required)]
        public Int32 DetailView;

        /// <summary>
        /// Optional.
        /// Up to 256 OfferIds may be specified.
        /// </summary>
        [WebRequestParam("OfferIds", WebRequestParamType.NameValuePair, Requirement.Optional, null)]
        public List<Guid> OfferIds;

        /// <summary>
        /// Optional.
        /// Up to 256 MediaIds may be specified.
        /// </summary>
        [WebRequestParam("MediaIds", WebRequestParamType.NameValuePair, Requirement.Optional, null)]
        public List<Guid> MediaIds;

        /// <summary>
        /// Optional.
        /// Up to 64 RatingIds may be specified.
        /// </summary>
        [WebRequestParam("RatingIds", WebRequestParamType.NameValuePair, Requirement.Optional, null)]
        public List<Int32> RatingIds;

        /// <summary>
        /// Optional.
        /// Up to 64 UserTypes may be specified.
        /// </summary>
        [WebRequestParam("UserTypes", WebRequestParamType.NameValuePair, Requirement.Optional, null)]
        public List<Int32> UserTypes;

        /// <summary>
        /// Required.
        /// Up to 64 MediaTypes may be specified.
        /// </summary>
        [WebRequestParam("MediaTypes", WebRequestParamType.NameValuePair, Requirement.Required)]
        public List<Int32> MediaTypes;

        /// <summary>
        /// Optional.
        /// Up to 64 CategoryIds may be specified.
        /// </summary>
        [WebRequestParam("CategoryIds", WebRequestParamType.NameValuePair, Requirement.Optional, null)]
        public List<Int32> CategoryIds;

        /// <summary>
        /// Optional.
        /// </summary>
        [WebRequestParam("OrderBy", WebRequestParamType.NameValuePair, Requirement.Optional, "-1")]
        public Int32 OrderBy = -1;

        /// <summary>
        /// Optional.
        /// </summary>
        [WebRequestParam("OrderDirection", WebRequestParamType.NameValuePair, Requirement.Optional, "-1")]
        public Int32 OrderDirection = -1;


        /// <summary>
        /// Optional.
        /// </summary>
        [WebRequestParam("OtherIds", WebRequestParamType.NameValuePair, Requirement.Optional, null)]
        public String OtherIds;
    }

    public class FindPodcastsFilter : FilterBase
    {
        /// <summary>
        /// Required.
        /// </summary>
        [WebRequestParam("methodName", WebRequestParamType.StandAlone, Requirement.Required)]
        public String methodName = "FindPodcasts";

        /// <summary>
        /// Required.
        /// </summary>
        [WebRequestParam("Locale", WebRequestParamType.NameValuePair, Requirement.Required)]
        public String Locale;

        /// <summary>
        /// Required.
        /// </summary>
        [WebRequestParam("LegalLocale", WebRequestParamType.NameValuePair, Requirement.Required)]
        public String LegalLocale;


        /// <summary>
        /// Required.
        /// </summary>
        [WebRequestParam("PageSize", WebRequestParamType.NameValuePair, Requirement.Required)]
        public Int32 PageSize;

        /// <summary>
        /// Required.
        /// </summary>
        [WebRequestParam("PageNum", WebRequestParamType.NameValuePair, Requirement.Required)]
        public Int32 PageNum;

        /// <summary>
        /// Required.
        /// </summary>
        [WebRequestParam("DetailView", WebRequestParamType.NameValuePair, Requirement.Required)]
        public Int32 DetailView;

        /// <summary>
        /// Optional.
        /// Up to 256 MediaIds may be specified.
        /// </summary>
        [WebRequestParam("MediaIds", WebRequestParamType.NameValuePair, Requirement.Optional, null)]
        public List<Guid> MediaIds;

        /// <summary>
        /// Optional.
        /// Up to 256 MediaUrls may be specified.
        /// </summary>
        [WebRequestParam("MediaUrls", WebRequestParamType.NameValuePair, Requirement.Optional, null)]
        public List<String> MediaUrls;


        /// <summary>
        /// Optional.
        /// Up to 64 CategoryIds may be specified.
        /// </summary>
        [WebRequestParam("CategoryIds", WebRequestParamType.NameValuePair, Requirement.Optional, null)]
        public List<Int32> CategoryIds;

        /// <summary>
        /// Optional.
        /// Up to 256 MediaUrls may be specified.
        /// </summary>
        [WebRequestParam("TitleFilters", WebRequestParamType.NameValuePair, Requirement.Optional, null)]
        public List<String> TitleFilters;

        /// <summary>
        /// Optional.
        /// </summary>
        [WebRequestParam("PodcastType", WebRequestParamType.NameValuePair, Requirement.Optional, null)]
        public int PodcastType;

        /// <summary>
        /// Required.
        /// </summary>
        [WebRequestParam("OrderBy", WebRequestParamType.NameValuePair, Requirement.Required)]
        public Int32 OrderBy = -1;

        /// <summary>
        /// Required.
        /// </summary>
        [WebRequestParam("OrderDirection", WebRequestParamType.NameValuePair, Requirement.Required)]
        public Int32 OrderDirection = -1;
    }

    public class FindPodcastsFTSFilter : FilterBase
    {
        /// <summary>
        /// Required.
        /// </summary>
        [WebRequestParam("methodName", WebRequestParamType.StandAlone, Requirement.Required)]
        public String methodName = "FindPodcastsFTS";

        /// <summary>
        /// Required.
        /// </summary>
        [WebRequestParam("Query", WebRequestParamType.NameValuePair, Requirement.Required)]
        public String Query;

        /// <summary>
        /// Required.
        /// </summary>
        [WebRequestParam("RankingType", WebRequestParamType.NameValuePair, Requirement.Required)]
        public Int32 RankingType;

        /// <summary>
        /// Required.
        /// </summary>
        [WebRequestParam("Locale", WebRequestParamType.NameValuePair, Requirement.Required)]
        public String Locale;

        /// <summary>
        /// Required.
        /// </summary>
        [WebRequestParam("LegalLocale", WebRequestParamType.NameValuePair, Requirement.Required)]
        public String LegalLocale;

        /// <summary>
        /// Required.
        /// </summary>
        [WebRequestParam("Store", WebRequestParamType.NameValuePair, Requirement.Required)]
        public Int32 Store;

        /// <summary>
        /// Required.
        /// </summary>
        [WebRequestParam("PageSize", WebRequestParamType.NameValuePair, Requirement.Required)]
        public Int32 PageSize;

        /// <summary>
        /// Required.
        /// </summary>
        [WebRequestParam("PageNum", WebRequestParamType.NameValuePair, Requirement.Required)]
        public Int32 PageNum;

        /// <summary>
        /// Required.
        /// </summary>
        [WebRequestParam("DetailView", WebRequestParamType.NameValuePair, Requirement.Required)]
        public Int32 DetailView;

        /// <summary>
        /// Optional.
        /// Up to 256 MediaUrls may be specified.
        /// </summary>
        [WebRequestParam("MediaUrls", WebRequestParamType.NameValuePair, Requirement.Optional, null)]
        public List<String> MediaUrls;

        /// <summary>
        /// Optional.
        /// Up to 64 RatingIds may be specified.
        /// </summary>
        [WebRequestParam("RatingIds", WebRequestParamType.NameValuePair, Requirement.Optional, null)]
        public List<Int32> RatingIds;

        /// <summary>
        /// Required.
        /// Up to 64 MediaTypes may be specified.
        /// </summary>
        [WebRequestParam("MediaTypes", WebRequestParamType.NameValuePair, Requirement.Required)]
        public List<Int32> MediaTypes;

        /// <summary>
        /// Optional.
        /// Up to 64 CategoryIds may be specified.
        /// </summary>
        [WebRequestParam("CategoryIds", WebRequestParamType.NameValuePair, Requirement.Optional, null)]
        public List<Int32> CategoryIds;

        /// <summary>
        /// Required.
        /// </summary>
        [WebRequestParam("OrderBy", WebRequestParamType.NameValuePair, Requirement.Required)]
        public Int32 OrderBy = -1;

        /// <summary>
        /// Required.
        /// </summary>
        [WebRequestParam("OrderDirection", WebRequestParamType.NameValuePair, Requirement.Required)]
        public Int32 OrderDirection = -1;

    }

    public class FindRelatedMediaFilter : FilterBase
    {
        /// <summary>
        /// Required.
        /// </summary>
        [WebRequestParam("methodName", WebRequestParamType.StandAlone, Requirement.Required)]
        public String methodName = "FindRelatedMedia";

        /// <summary>
        /// Required.
        /// </summary>
        [WebRequestParam("Locale", WebRequestParamType.NameValuePair, Requirement.Required)]
        public String Locale;

        /// <summary>
        /// Required.
        /// </summary>
        [WebRequestParam("LegalLocale", WebRequestParamType.NameValuePair, Requirement.Required)]
        public String LegalLocale;

        /// <summary>
        /// Required.
        /// </summary>
        [WebRequestParam("Store", WebRequestParamType.NameValuePair, Requirement.Required)]
        public Int32 Store;

        /// <summary>
        /// Required.
        /// </summary>
        [WebRequestParam("PageSize", WebRequestParamType.NameValuePair, Requirement.Required)]
        public Int32 PageSize;

        /// <summary>
        /// Required.
        /// </summary>
        [WebRequestParam("PageNum", WebRequestParamType.NameValuePair, Requirement.Required)]
        public Int32 PageNum;

        /// <summary>
        /// Required.
        /// </summary>
        [WebRequestParam("DetailView", WebRequestParamType.NameValuePair, Requirement.Required)]
        public Int32 DetailView;

        /// <summary>
        /// Required.
        /// </summary>
        [WebRequestParam("OfferFilterLevel", WebRequestParamType.NameValuePair, Requirement.Required)]
        public Int32 OfferFilterLevel;

        /// <summary>
        /// Required.
        /// Up to 256 MediaIds may be specified.
        /// </summary>
        [WebRequestParam("MediaIds", WebRequestParamType.NameValuePair, Requirement.Required)]
        public List<Guid> MediaIds;

        /// <summary>
        /// Required.
        /// Up to 64 MediaRelationshipTypes may be specified.
        /// </summary>
        [WebRequestParam("MediaRelationshipTypes", WebRequestParamType.NameValuePair, Requirement.Required)]
        public List<Int32> MediaRelationshipTypes;

        /// <summary>
        /// Required.
        /// Up to 64 MediaTypes may be specified.
        /// </summary>
        [WebRequestParam("MediaTypes", WebRequestParamType.NameValuePair, Requirement.Required)]
        public List<Int32> MediaTypes;

        /// <summary>
        /// Required.
        /// </summary>
        [WebRequestParam("OrderBy", WebRequestParamType.NameValuePair, Requirement.Required)]
        public Int32 OrderBy = -1;

        /// <summary>
        /// Required.
        /// </summary>
        [WebRequestParam("OrderDirection", WebRequestParamType.NameValuePair, Requirement.Required)]
        public Int32 OrderDirection = -1;
    }

    public class FindVideoOffersFilter : FilterBase
    {
        /// <summary>
        /// Required.
        /// </summary>
        [WebRequestParam("methodName", WebRequestParamType.StandAlone, Requirement.Required)]
        public String methodName = "FindVideoOffers";

        /// <summary>
        /// Required.
        /// </summary>
        [WebRequestParam("Locale", WebRequestParamType.NameValuePair, Requirement.Required)]
        public String Locale;

        /// <summary>
        /// Required.
        /// </summary>
        [WebRequestParam("LegalLocale", WebRequestParamType.NameValuePair, Requirement.Required)]
        public String LegalLocale;

        /// <summary>
        /// Required.
        /// </summary>
        [WebRequestParam("Store", WebRequestParamType.NameValuePair, Requirement.Required)]
        public Int32 Store;

        /// <summary>
        /// Required.
        /// </summary>
        [WebRequestParam("PageSize", WebRequestParamType.NameValuePair, Requirement.Required)]
        public Int32 PageSize;

        /// <summary>
        /// Required.
        /// </summary>
        [WebRequestParam("PageNum", WebRequestParamType.NameValuePair, Requirement.Required)]
        public Int32 PageNum;

        /// <summary>
        /// Required.
        /// </summary>
        [WebRequestParam("DetailView", WebRequestParamType.NameValuePair, Requirement.Required)]
        public Int32 DetailView;

        /// <summary>
        /// Optional.
        /// Up to 256 OfferIds may be specified.
        /// </summary>
        [WebRequestParam("OfferIds", WebRequestParamType.NameValuePair, Requirement.Optional, null)]
        public List<Guid> OfferIds;

        /// <summary>
        /// Optional.
        /// Up to 256 MediaIds may be specified.
        /// </summary>
        [WebRequestParam("MediaIds", WebRequestParamType.NameValuePair, Requirement.Optional, null)]
        public List<Guid> MediaIds;

        /// <summary>
        /// Optional.
        /// Up to 64 RatingIds may be specified.
        /// </summary>
        [WebRequestParam("RatingIds", WebRequestParamType.NameValuePair, Requirement.Optional, null)]
        public List<Int32> RatingIds;

        /// <summary>
        /// Optional.
        /// Up to 64 UserTypes may be specified.
        /// </summary>
        [WebRequestParam("UserTypes", WebRequestParamType.NameValuePair, Requirement.Optional, null)]
        public List<Int32> UserTypes;

        /// <summary>
        /// Required.
        /// Up to 64 MediaTypes may be specified.
        /// </summary>
        [WebRequestParam("MediaTypes", WebRequestParamType.NameValuePair, Requirement.Required)]
        public List<Int32> MediaTypes;

        /// <summary>
        /// Optional.
        /// Up to 64 CategoryIds may be specified.
        /// </summary>
        [WebRequestParam("CategoryIds", WebRequestParamType.NameValuePair, Requirement.Optional, null)]
        public List<Int32> CategoryIds;

        /// <summary>
        /// Optional.
        /// Up to 64 ImageTypeIds may be specified.
        /// </summary>
        [WebRequestParam("ImageTypeIds", WebRequestParamType.NameValuePair, Requirement.Optional, null)]
        public List<Int32> ImageTypeIds;

        /// <summary>
        /// Optional.
        /// Up to 64 ImageFormats may be specified.
        /// </summary>
        [WebRequestParam("ImageFormats", WebRequestParamType.NameValuePair, Requirement.Optional, null)]
        public List<Int32> ImageFormats;

        /// <summary>
        /// Optional.
        /// Up to 64 ImageSizes may be specified.
        /// </summary>
        [WebRequestParam("ImageSizes", WebRequestParamType.NameValuePair, Requirement.Optional, null)]
        public List<Int32> ImageSizes;

        /// <summary>
        /// Optional.
        /// Up to 64 TitleFilters may be specified.
        /// </summary>
        [WebRequestParam("TitleFilters", WebRequestParamType.NameValuePair, Requirement.Optional, null)]
        public List<String> TitleFilters;

        /// <summary>
        /// Optional.
        /// Up to 64 Relations may be specified.
        /// </summary>
        [WebRequestParam("Relations", WebRequestParamType.NameValuePair, Requirement.Optional, null)]
        public List<Int32> Relations;

        /// <summary>
        /// Optional.
        /// </summary>
        [WebRequestParam("OrderBy", WebRequestParamType.NameValuePair, Requirement.Optional, "-1")]
        public Int32 OrderBy = -1;

        /// <summary>
        /// Optional.
        /// </summary>
        [WebRequestParam("OrderDirection", WebRequestParamType.NameValuePair, Requirement.Optional, "-1")]
        public Int32 OrderDirection = -1;

    }

    public class FindVideosFilter : FilterBase
    {
        /// <summary>
        /// Required.
        /// </summary>
        [WebRequestParam("methodName", WebRequestParamType.StandAlone, Requirement.Required)]
        public String methodName = "FindVideos";

        /// <summary>
        /// Required.
        /// </summary>
        [WebRequestParam("Locale", WebRequestParamType.NameValuePair, Requirement.Required)]
        public String Locale;

        /// <summary>
        /// Required.
        /// </summary>
        [WebRequestParam("LegalLocale", WebRequestParamType.NameValuePair, Requirement.Required)]
        public String LegalLocale;

        /// <summary>
        /// Required.
        /// </summary>
        [WebRequestParam("Store", WebRequestParamType.NameValuePair, Requirement.Required)]
        public Int32 Store;

        /// <summary>
        /// Required.
        /// </summary>
        [WebRequestParam("PageSize", WebRequestParamType.NameValuePair, Requirement.Required)]
        public Int32 PageSize;

        /// <summary>
        /// Required.
        /// </summary>
        [WebRequestParam("PageNum", WebRequestParamType.NameValuePair, Requirement.Required)]
        public Int32 PageNum;

        /// <summary>
        /// Required.
        /// </summary>
        [WebRequestParam("DetailView", WebRequestParamType.NameValuePair, Requirement.Required)]
        public Int32 DetailView;

        /// <summary>
        /// Required.
        /// </summary>
        [WebRequestParam("OfferFilterLevel", WebRequestParamType.NameValuePair, Requirement.Required)]
        public Int32 OfferFilterLevel;

        /// <summary>
        /// Optional.
        /// Up to 256 MediaIds may be specified.
        /// </summary>
        [WebRequestParam("MediaIds", WebRequestParamType.NameValuePair, Requirement.Optional, null)]
        public List<Guid> MediaIds;

        /// <summary>
        /// Optional.
        /// Up to 64 RatingIds may be specified.
        /// </summary>
        [WebRequestParam("RatingIds", WebRequestParamType.NameValuePair, Requirement.Optional, null)]
        public List<Int32> RatingIds;

        /// <summary>
        /// Optional.
        /// Up to 64 UserTypes may be specified.
        /// </summary>
        [WebRequestParam("UserTypes", WebRequestParamType.NameValuePair, Requirement.Optional, null)]
        public List<Int32> UserTypes;

        /// <summary>
        /// Required.
        /// Up to 64 MediaTypes may be specified.
        /// </summary>
        [WebRequestParam("MediaTypes", WebRequestParamType.NameValuePair, Requirement.Required)]
        public List<Int32> MediaTypes;

        /// <summary>
        /// Optional.
        /// Up to 64 CategoryIds may be specified.
        /// </summary>
        [WebRequestParam("CategoryIds", WebRequestParamType.NameValuePair, Requirement.Optional, null)]
        public List<Int32> CategoryIds;


        /// <summary>
        /// Optional.
        /// Up to 64 ImageTypeIds may be specified.
        /// </summary>
        [WebRequestParam("ImageTypeIds", WebRequestParamType.NameValuePair, Requirement.Optional, null)]
        public List<Int32> ImageTypeIds;

        /// <summary>
        /// Optional.
        /// Up to 64 ImageFormats may be specified.
        /// </summary>
        [WebRequestParam("ImageFormats", WebRequestParamType.NameValuePair, Requirement.Optional, null)]
        public List<Int32> ImageFormats;

        /// <summary>
        /// Optional.
        /// Up to 64 ImageSizes may be specified.
        /// </summary>
        [WebRequestParam("ImageSizes", WebRequestParamType.NameValuePair, Requirement.Optional, null)]
        public List<Int32> ImageSizes;

        /// <summary>
        /// Optional.
        /// Up to 64 TitleFilters may be specified.
        /// </summary>
        [WebRequestParam("TitleFilters", WebRequestParamType.NameValuePair, Requirement.Optional, null)]
        public List<String> TitleFilters;

        /// <summary>
        /// Optional.
        /// Up to 64 Relations may be specified.
        /// </summary>
        [WebRequestParam("Relations", WebRequestParamType.NameValuePair, Requirement.Optional, null)]
        public List<Int32> Relations;

        /// <summary>
        /// Optional.
        /// </summary>
        [WebRequestParam("VideoFilter", WebRequestParamType.NameValuePair, Requirement.Optional, "-1")]
        public Int32 VideoFilter;

        /// <summary>
        /// Optional.
        /// </summary>
        [WebRequestParam("OrderBy", WebRequestParamType.NameValuePair, Requirement.Optional, "-1")]
        public Int32 OrderBy = -1;

        /// <summary>
        /// Optional.
        /// </summary>
        [WebRequestParam("OrderDirection", WebRequestParamType.NameValuePair, Requirement.Optional, "-1")]
        public Int32 OrderDirection = -1;

    }

    public class FindVideosFTSFilter : FilterBase
    {
        /// <summary>
        /// Required.
        /// </summary>
        [WebRequestParam("methodName", WebRequestParamType.StandAlone, Requirement.Required)]
        public String methodName = "FindVideosFTS";

        /// <summary>
        /// Required.
        /// </summary>
        [WebRequestParam("Query", WebRequestParamType.NameValuePair, Requirement.Required)]
        public String Query;

        /// <summary>
        /// Required.
        /// </summary>
        [WebRequestParam("RankingType", WebRequestParamType.NameValuePair, Requirement.Required)]
        public Int32 RankingType;

        /// <summary>
        /// Required.
        /// </summary>
        [WebRequestParam("Locale", WebRequestParamType.NameValuePair, Requirement.Required)]
        public String Locale;

        /// <summary>
        /// Required.
        /// </summary>
        [WebRequestParam("LegalLocale", WebRequestParamType.NameValuePair, Requirement.Required)]
        public String LegalLocale;

        /// <summary>
        /// Required.
        /// </summary>
        [WebRequestParam("Store", WebRequestParamType.NameValuePair, Requirement.Required)]
        public Int32 Store;

        /// <summary>
        /// Required.
        /// </summary>
        [WebRequestParam("PageSize", WebRequestParamType.NameValuePair, Requirement.Required)]
        public Int32 PageSize;

        /// <summary>
        /// Required.
        /// </summary>
        [WebRequestParam("PageNum", WebRequestParamType.NameValuePair, Requirement.Required)]
        public Int32 PageNum;

        /// <summary>
        /// Required.
        /// </summary>
        [WebRequestParam("DetailView", WebRequestParamType.NameValuePair, Requirement.Required)]
        public Int32 DetailView;

        /// <summary>
        /// Required.
        /// </summary>
        [WebRequestParam("OfferFilterLevel", WebRequestParamType.NameValuePair, Requirement.Required)]
        public Int32 OfferFilterLevel;

        /// <summary>
        /// Optional.
        /// Up to 64 RatingIds may be specified.
        /// </summary>
        [WebRequestParam("RatingIds", WebRequestParamType.NameValuePair, Requirement.Optional, null)]
        public List<Int32> RatingIds;

        /// <summary>
        /// Optional.
        /// Up to 64 UserTypes may be specified.
        /// </summary>
        [WebRequestParam("UserTypes", WebRequestParamType.NameValuePair, Requirement.Optional, null)]
        public List<Int32> UserTypes;

        /// <summary>
        /// Required.
        /// Up to 64 MediaTypes may be specified.
        /// </summary>
        [WebRequestParam("MediaTypes", WebRequestParamType.NameValuePair, Requirement.Required)]
        public List<Int32> MediaTypes;

        /// <summary>
        /// Optional.
        /// Up to 64 CategoryIds may be specified.
        /// </summary>
        [WebRequestParam("CategoryIds", WebRequestParamType.NameValuePair, Requirement.Optional, null)]
        public List<Int32> CategoryIds;

        /// <summary>
        /// Optional.
        /// </summary>
        [WebRequestParam("OrderBy", WebRequestParamType.NameValuePair, Requirement.Optional, "-1")]
        public Int32 OrderBy = -1;

        /// <summary>
        /// Optional.
        /// </summary>
        [WebRequestParam("OrderDirection", WebRequestParamType.NameValuePair, Requirement.Optional, "-1")]
        public Int32 OrderDirection = -1;

    }

    public class ReportConcernFilter : FilterBase
    {
        /// <summary>
        /// Required.
        /// </summary>
        [WebRequestParam("methodName", WebRequestParamType.StandAlone, Requirement.Required)]
        public String methodName = "ReportConcern";

        /// <summary>
        /// Required.
        /// </summary>
        [WebRequestParam("MediaId", WebRequestParamType.NameValuePair, Requirement.Required)]
        public Guid MediaId;

        /// <summary>
        /// Required.
        /// </summary>
        [WebRequestParam("ConcernId", WebRequestParamType.NameValuePair, Requirement.Required)]
        public Int32 ConcernId;

        /// <summary>
        /// Required.
        /// </summary>
        [WebRequestParam("ConcernText", WebRequestParamType.NameValuePair, Requirement.Required)]
        public String ConcernText;
    }

    public class SubmitPodcastFilter : FilterBase
    {
        /// <summary>
        /// Required.
        /// </summary>
        [WebRequestParam("methodName", WebRequestParamType.StandAlone, Requirement.Required)]
        public String methodName = "SubmitPodcast";

        /// <summary>
        /// Required.
        /// </summary>
        [WebRequestParam("PodcastUrl", WebRequestParamType.NameValuePair, Requirement.Required)]
        public String PodcastUrl;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\Cron\XrlRemoveJob.cs ===
using System;
using xonline.common.config;

namespace ServerTestFramework.LiveService.Cron
{
	/// <summary>
	/// Summary description for XrlRemoveJob.
	/// </summary>
	public class XrlRemoveJobRequest:XRLPayload
	{
		public uint jobId;
		public uint titleId;

		protected override string GetServiceName()
		{
			return "/cron/removejob.ashx";
		}

		public override bool Execute()
		{
			return base.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.cron_int));
		}

	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\Cron\XrlTimeWarp.cs ===
using System;
using xonline.common.config;

namespace ServerTestFramework.LiveService.Cron
{
	/// <summary>
	/// Summary description for XrlTimeWarp.
	/// </summary>
	public class XrlTimeWarp:XRLPayload
	{
		public long offsetSeconds=0;

		protected override string GetServiceName()
		{
			return "/cron/timewarp.ashx";
		}

		public override bool Execute()
		{
			return base.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.cron_int));
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\Database\BulkUserSet.cs ===
using System;
using System.Text;

namespace ServerTestFramework.Database
{
	
    ///
    /// Class to represent a set of bulk users. These users a represented as a base
    ///	ID and are gauranteed to have a few useful properties:
    /// 
    /// 1: PUIDs in the range Base + [0,n) offset where Base is the base offset of the set
    ///		and n is the count of users in the set.
    /// 2: Web Puids in the range 0x0001ffffffffffff + BaseLow + [0,n] where BaseLow is the lo 32 bit
    /// 	value of the PUID. This is done to gaurantee unique web IDs that are distiguishable from
    ///		normal user PUIDs.
    /// 3: Gamertags where the first 2 bytes are the passed in prefix, and the last 13 bytes are a base
    ///		32 encoding of the PUID. This is done to allow username/puid calculation from the PUID/gamertag 
	///		without database reads. Use the built-in methods this class for help in doing this.
    ///	
    public class BulkUserSet: BulkUserSetBase
    {
        public BulkUserSet(BulkUserSetBase b): base(b)
        {
        }

        public BulkUserSet(string prefix): base(prefix)
        {
        }

        public BulkUserSet(string prefix, ulong basepuid, uint usercount): base(prefix, basepuid, usercount)
        {
        }

        public ulong IndexToWebId(uint index)
        {
            return IndexToPuid(index);
        }

        public ulong IndexToMachinePuid(uint index)
        {
            ulong userPuid = IndexToPuid(index);
            userPuid |= 0x7000000000000000; // alter the MSB
            return userPuid;
        }

        private byte[] IndexToKey(uint index)
        {
            ulong puid = IndexToPuid(index);
            byte[] puidbytes = BitConverter.GetBytes(puid);
            byte[] rawkey = new byte[16];
            Array.Copy(puidbytes, 0, rawkey, 0, puidbytes.Length);
            return rawkey;
        }

        public byte[] IndexToXenonKey(uint index)
        {
            byte[] rawkey = IndexToKey(index);

            // rawkey[15] = 0 for Xenon key
            rawkey[15] = 0;
            return rawkey;
        }

        public byte[] IndexToXboxKey(uint index)
        {
            byte[] rawkey = IndexToKey(index);

            // rawkey[15] = 1 for Xbox key
            rawkey[15] = 1;
            return rawkey;
        }

        public byte[] IndexToXenonKey2(uint index)
        {
            return ServerTestFramework.LiveService.Auth.AuthContext.CalculateKeyFromGamertag(IndexToGamertag(index), true);
        }

        public byte[] IndexToXboxKey2(uint index)
        {
            return ServerTestFramework.LiveService.Auth.AuthContext.CalculateKeyFromGamertag(IndexToGamertag(index), false);
        }

        public ulong PuidToMachinePuid(ulong puid)
        {
            _CheckPuid(puid);
            puid |= 0x7000000000000000; // add MSB marker
            return puid;
        }

        public ulong PuidToWebId(ulong puid)
        {
            _CheckPuid(puid);
            return puid;
        }

        // Accessors to be used with machine PUIDS
        public ulong MachinePuidToPuid(ulong machinePuid)
        {
            machinePuid &= 0x0fffffffffffffff; // remove MSB marker
            _CheckPuid(machinePuid);
            return machinePuid;
        }

        // Accessors used with web IDs
        public uint WebIdToIndex(ulong webId)
        {
            return PuidToIndex(webId);
        }

        public ulong WebIdToPuid(ulong webId)
        {
            return webId;
        }

        public byte[] WebIdToBytes(ulong webId)
        {
            byte[] bytes = _ConvertPuidToBytes(webId);
            return bytes;
        }

        public ulong GamertagToWebId(string gamertag)
        { 
            return GamertagToPuid(gamertag);
        }

        public CPUIDList GetPuidList()
        {
            CPUIDList pList = new CPUIDList((int)Count);
            for (uint iUser = 0; iUser < Count; iUser++)
            {
                pList.Add(IndexToPuid(iUser), IndexToGamertag(iUser));
            }
            return pList;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\Database\Catalog.cs ===
/* Catalog wrapper class */

using System;

using xonline.common.config;
using xonline.common.sql.sqlclient;
using System.Data.SqlClient;

namespace ServerTestFramework.Database
{
    public class Catalog
    {
        public static void OfferIdToOfferInstanceId(ulong offerId, int emsUserTypeId, string countryCode, int emsPaymentTypeId, out Guid? catalogOfferId, out Guid? catalogOfferInstanceId)
        {
            catalogOfferId = null;
            catalogOfferInstanceId = null;

            using (SqlClient c = new SqlClient(Interface.fecatalogdbxbox, true))
            {
                c.StoredProc = "dbo.GetOfferInstanceIdFromLegacyOffer";
                c.AddParameter("@liveOfferId", offerId);
                c.AddParameter("@paymentTypeId", emsPaymentTypeId);
                c.AddParameter("@countryCode", countryCode);
                c.AddParameter("@userTypeId", emsUserTypeId);

                using (SqlDataReader r = c.Execute())
                {
                    if (r.Read())
                    {
                        if (!r.IsDBNull(r.GetOrdinal("offerInstanceId")))
                        {
                            catalogOfferInstanceId = r.GetGuid(r.GetOrdinal("offerInstanceId"));
                        }
                        if (!r.IsDBNull(r.GetOrdinal("offerId")))
                        {
                            catalogOfferId = r.GetGuid(r.GetOrdinal("offerId"));
                        }
                    }
                    else
                    {
                        throw new UnexpectedTestResultException(
                            String.Format("Error retrieving catalog offerInstanceId for legacyofferid {0},paymenttype {1},countrycode {2}",
                            offerId.ToString("x"), emsPaymentTypeId.ToString(), countryCode));
                    }
                }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\Database\Events.cs ===
/* Events database wrapper class */

using System;
using System.Collections;
using System.Data;
using System.Data.Common;
using System.Data.SqlClient;
using System.Data.SqlTypes;

using ServerTestFramework.Utilities;

using xonline.common.config;

namespace ServerTestFramework.Database
{
    public class EventRecord : Object
    {
        public int      Index;
        public DateTime Time;
        public string   Service;
        public char     Type;
        public int      EventId;
        public string   Server;
        public string   Description;
        public uint     TitleId;
        public uint     Count;

        public override int GetHashCode() 
        {
            return base.GetHashCode();
        }

        public override bool Equals(object er2) 
        {
            object er1 = this;

            if ((null == er1) && (null == er2)) 
            {
                return true;
            }

            if ((null == er1) || (null == er2)) 
            {
                return false;
            }

            if ((er1.GetType() != er2.GetType())) 
            {
                return false;
            }

            EventRecord  record1 = (EventRecord)er1;
            EventRecord  record2 = (EventRecord)er2;

            if (record1.Index != record2.Index) 
            {
                return false;
            }

            if (record1.Time != record2.Time) 
            {
                return false;
            }

            if (record1.Service != record2.Service) 
            {
                return false;
            }

            if (record1.Type != record2.Type) 
            {
                return false;
            }

            if (record1.EventId != record2.EventId) 
            {
                return false;
            }

            if (record1.Server != record2.Server) 
            {
                return false;
            }

            if (record1.Description != record2.Description) 
            {
                return false;
            }

            if (record1.TitleId != record2.TitleId) 
            {
                return false;
            }

            if (record1.Count != record2.Count) 
            {
                return false;
            }

            return true;
        }
    } 

    public class EventCheck 
    {
        public  char    Type;
        public  int     EventId;
        public  string  Description;
        public  bool    Optional;

        public EventCheck(
            char    _Type,
            int     _EventId,
            string  _Description,
            bool    _Optional) 
        {
            Type = _Type;
            EventId = _EventId;
            Description = _Description;
            Optional = _Optional;
        }

        public EventCheck(
            char    _Type,
            int     _EventId,
            string  _Description)
        {
            Type = _Type;
            EventId = _EventId;
            Description = _Description;
            Optional = false;
        }
    }

    /// <summary>
    /// This is a wrapper class for talking to the events database.
    /// </summary>
    public class Events
    {
        SqlConnection _conn;
        string        _serverName;
        object        _readerLock;
        Hashtable     _serviceStartTable;
        Hashtable     _serviceEndTable;

        public Events()
        {
            _readerLock = new object();
            _serviceStartTable = new Hashtable();
            _serviceEndTable = new Hashtable();

            string[] serverNames = Config.GetServerListByInterface(Interface.eventsdb);
            _serverName = serverNames[0];
        }

        public void Close() 
        {
            lock(_readerLock)
            {
                if (IsConnected()) _conn.Close();
            }
        }

        private bool IsConnected()
        {
            return (null != _conn) && (ConnectionState.Closed != _conn.State);
        }

        private void ConnectToServer()
        {
            if (IsConnected()) return;

            try 
            {
                _conn = new SqlConnection("server=" + _serverName + ";database=eventsdb;Integrated Security=SSPI"); 
                _conn.Open();
            } 
            catch(SqlException sqlex)
            {
                throw new DatabaseException(_conn, sqlex);
            }
        }

        public void GetEventsServiceStart(string service)
        {
            string[] services = { service };

            GetEventsServiceStart(services);
        }

        public void GetEventsServiceStart(string[] services)
        {
            // get the latest entry
            ArrayList  recordSet = GetResultSet("select top 1 i_index, dt_time, vc_app, c_type, i_event_id, vc_server, vc_description, i_title_id, i_Count_lastmin from t_events order by i_index desc");

            // map the service and entry
            foreach (string service in services) 
            {
                _serviceStartTable[service] = ((EventRecord) recordSet[0]).Index;
            }
        }

        public void GetEventsServiceEnd(string service)
        {
            string[] services = { service };

            GetEventsServiceEnd(services);
        }

        public void GetEventsServiceEnd(string[] services)
        {
            // get the latest entry
            ArrayList  recordSet = GetResultSet("select top 1 i_index, dt_time, vc_app, c_type, i_event_id, vc_server, vc_description, i_title_id, i_Count_lastmin from t_events order by i_index desc");

            // map the service and entry
            foreach (string service in services) 
            {
                _serviceEndTable[service] = ((EventRecord) recordSet[0]).Index;
            }
        }

        public bool GetEventsServiceCheck(string service, ref ArrayList eventsCheck, ref ArrayList eventsUnexpected) 
        {
            return GetEventsServerCheck(service, "", ref eventsCheck, ref eventsUnexpected);
        }

        public bool GetEventsServerCheck(string service, string server, ref ArrayList eventsCheck, ref ArrayList eventsUnexpected) 
        {
            // eventsUnexpected is the list of unexpected events
            eventsUnexpected = new ArrayList();

            // get all matching events
            ArrayList  eventRecords = GetLatestEventsMatching(0, service, server, (int)_serviceStartTable[service], (int)_serviceEndTable[service]);

            // iterate all entries looking for expected and unexpected events
            foreach (EventRecord eventRecord in eventRecords) 
            {
                // iterate all counts of this entry
                for (int countIndex = 0; countIndex <= eventRecord.Count; countIndex++) 
                {
                    EventCheck  eventFound = null;

                    // look for an expected event
                    foreach (EventCheck eventCheck in eventsCheck) 
                    {
                        if (eventCheck.Type != eventRecord.Type) 
                        {
                            continue;
                        }

                        if (eventCheck.EventId != eventRecord.EventId) 
                        {
                            continue;
                        }

                        if (-1 == eventRecord.Description.IndexOf(eventCheck.Description)) 
                        {
                            continue;
                        }

                        eventFound = eventCheck;
                        break;
                    }

                    if (null == eventFound) 
                    {
                        eventsUnexpected.Add(eventRecord);
                    }
                    else 
                    {
                        eventsCheck.Remove(eventFound);
                    }
                }
            }

            // reset count of any unexpected events
            foreach (EventRecord eventRecord in eventsUnexpected) 
            {
                eventRecord.Count = 0;
            }

            return (0 == eventsCheck.Count) && (0 == eventsUnexpected.Count);
        }

        public ArrayList GetLatestEvents(uint count)
        {
            return GetResultSet("select top " + count + " i_index, dt_time, vc_app, c_type, i_event_id, vc_server, vc_description, i_title_id, i_Count_lastmin from t_events order by i_index desc");
        }

        private ArrayList GetLatestEventsMatching(uint count, string service, string server, int start, int end)
        {
            string query = "";
            string pred = "";

            if (0 < count) 
            {
                query = "select top " + count + " * from t_events";
            }
            else 
            {
                query = "select * from t_events";
            }

            if ("" != service.ToUpper())
            {
                pred = " where vc_app = '" + service + "'";
            }

            if ("" != server.ToUpper())
            {
                if (0 < pred.Length)
                {
                    pred += " and";
                }
                else
                {
                    pred += " where";
                }
                pred += " vc_server = '" + server + "'";
            }

            if (0 < pred.Length) 
            {
                pred += " and";
            }
            else 
            {
                pred += " where";
            }
            pred += " i_index >= '" + start + "'";
            if (0 < end) 
            {
                pred += " and i_index <= '" + end + "'";
            }

            pred += " order by i_index desc";

            return GetResultSet(query + pred);
        }

        public ArrayList GetLatestEventsMatching(uint count, string service, string server, DateTime start, DateTime end)
        {
            string query = "";
            string pred = "";
            SqlDateTime sqlStart = SqlDateTime.MinValue;
            SqlDateTime sqlEnd = SqlDateTime.MaxValue;

            try 
            {
                sqlStart = new SqlDateTime(start);
            }
            catch (SqlTypeException)
            {
                sqlStart = SqlDateTime.MinValue;
            }

            try 
            {
                sqlEnd = new SqlDateTime(end);
            }
            catch (SqlTypeException)
            {
                sqlEnd = SqlDateTime.MaxValue;
            }

            if (0 < count) 
            {
                query = "select top " + count + " * from t_events";
            }
            else 
            {
                query = "select * from t_events";
            }

            if ("" != service.ToUpper())
            {
                pred = " where vc_app = '" + service + "'";
            }

            if ("" != server.ToUpper())
            {
                if (0 < pred.Length)
                {
                    pred += " and";
                }
                else
                {
                    pred += " where";
                }
                pred += " vc_server = '" + server + "'";
            }

            if (0 < pred.Length) 
            {
                pred += " and";
            }
            else 
            {
                pred += " where";
            }
            pred += " dt_time >= '" + sqlStart.ToString() + "'";
            if (SqlDateTime.MinValue < sqlEnd) 
            {
                pred += " and dt_time <= '" + sqlEnd.ToString() + "'";
            }

            pred += " order by i_index desc";

            return GetResultSet(query + pred);
        }

        private ArrayList GetResultSet(string query)
        {
            SqlDataReader reader = null;
            ArrayList results = new ArrayList(128);

            lock(_readerLock)
            {
                try
                {
                    ReadData(query, out reader);

                    while(reader.Read())
                    {
                        EventRecord record = new EventRecord();

                        record.Index       = (int)reader["i_index"];
                        record.Time        = (DateTime)reader["dt_time"];
                        record.Service     = (string)reader["vc_app"];
                        record.Type        = ((string) reader["c_type"])[0];
                        record.EventId     = (DBNull.Value == reader["i_Count_lastmin"]) ? 0 : (int)reader["i_event_id"];
                        record.Server      = (string)reader["vc_server"];
                        record.Description = (string)reader["vc_description"];
                        record.TitleId     = (DBNull.Value == reader["i_title_id"]) ? 0 : (uint)((int)reader["i_title_id"]);
                        record.Count       = (DBNull.Value == reader["i_Count_lastmin"]) ? 0 : (uint)((int)reader["i_Count_lastmin"]);

                        results.Add(record);
                    }
                }
                catch(Exception ex)
                {
                    Global.RO.Warn("Exception occured reading event data: " + ex.ToString());
                }

                if (null != reader) reader.Close();
            }

            return results;
        }

        private void ReadData(string sql, out SqlDataReader reader)
        {
            lock(_readerLock)
            {
                ConnectToServer();

                try
                {
                    SqlCommand command = new SqlCommand(sql, _conn);
                    reader = command.ExecuteReader();

                    if (null == reader)
                    {
                        throw new DatabaseException(_conn, "Execute reader failed");
                    }
                }
                catch(SqlException sqlex)
                {
                    throw new DatabaseException(_conn, sqlex);
                }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\Database\Hasher.cs ===
using System;
using System.Data;
using System.Diagnostics;

namespace ServerTestFramework.Database
{
    public enum SQLDataType {SDT_TINYINT, SDT_SMALLINT, SDT_INT, SDT_BIGINT, SDT_SMALLDATETIME, SDT_DATETIME, SDT_NVARCHAR, SDT_VARCHAR, SDT_BINARY, SDT_VARBINARY};

    public class Hasher
    {
        private int numPartitions = 0;

        // TODO: either remove me or fix me once webstore libraries are integrated
        private int numVirtualPartitions = 0;

        public class Result
        {
            public uint Bucket = 0;
            public int Partition = 0;

            public Result(uint bucket, int partition)
            {
                this.Bucket = bucket;
                this.Partition = partition;
            }
        }

        public Hasher(int numPartitions) 
            : this(numPartitions, 0)
        {
        }

        public Hasher(int numPartitions, int numVirtualPartitions)
        {
            this.numPartitions = numPartitions;
            this.numVirtualPartitions = numVirtualPartitions;
        }

        public Result Hash(SQLDataType type, object data)
        {
            uint bucket = GetBucket(type, data);
            int partition = (int)bucket / (420 / (numPartitions + numVirtualPartitions));
            if (numVirtualPartitions > 0)
            {
                // @@@ HACKHACK FIXME
                // TODO: Use webstore to do this instead of this aweful hack.
                // There are 5 UODB partitions 1-5.  Partition 3 has 100/420 of the buckets
                // 80    - SQLW01  returns 0
                // 80    - SQLW02  returns 1
                // 100   - SQLW03  returns 2
                // 80    - SQLW04  returns 3
                // 80    - SQLW05  returns 4
                //
                // A slightly better hack would be to allow the caller to specify the 
                // mapping of partitions. Oh well.
                
                if(bucket < 80)
                    partition = 0;
                if (bucket < 160 && bucket > 79)
                    partition = 1;
                if (bucket < 260 && bucket > 159)
                    partition = 2;
                if (bucket < 340 && bucket > 259)
                    partition = 3;
                if (bucket < 420 && bucket > 339)
                    partition = 4;
            }
			
            return new Result(bucket, partition);
        }

        /// <summary>
        /// Attempt to determine the SQL data type based on the .Net data type. I think 
        /// the only things we partition on are BIGINT and VARCHAR, so this should catch 
        /// all of those. It may not work quite right in cases beyond that, so use it at 
        /// your own risk.
        /// </summary>
        public Result Hash(object data)
        {
            SQLDataType type = DetermineDataType(data);
            return Hash(type, data);
        }

        static private uint GetBucket(SQLDataType type, object data)
        {
            switch(type)
            {
                case SQLDataType.SDT_TINYINT:
                case SQLDataType.SDT_SMALLINT:
                case SQLDataType.SDT_INT:
                case SQLDataType.SDT_BIGINT: return HashBucket(Convert.ToUInt64(data));
                case SQLDataType.SDT_SMALLDATETIME:
                case SQLDataType.SDT_DATETIME:
                case SQLDataType.SDT_BINARY: return HashBucket((byte[])data);
                case SQLDataType.SDT_NVARCHAR:
                case SQLDataType.SDT_VARCHAR: return HashBucket(Convert.ToString(data));
                default: Debug.Assert(false); return 0;
            }
        }

        static private SQLDataType DetermineDataType(object data)
        {
            Type t = data.GetType();
            if (t == typeof(Int16) ||
                t == typeof(UInt16) ||
                t == typeof(Int32) ||
                t == typeof(UInt32) ||
                t == typeof(Int64) ||
                t == typeof(UInt64))
            {
                return SQLDataType.SDT_BIGINT;
            }
            if ((t == typeof(Byte) || t == typeof(SByte)) &&
                t.IsArray)
            {
                return SQLDataType.SDT_BINARY;
            }
            // Default to string
            return SQLDataType.SDT_VARCHAR;
        }

        private const uint PRIME_A = 31415;
        private const uint PRIME_B = 27183;
        private const uint PRIME_K = 16381;

        static private uint HashBucket(string s)
        {
            uint h = 0;
            uint a = 31415;
            const uint b = 27183;
            const uint prime = 16381;

            int i = 0;
            while (i < s.Length)
            {
                h = (a*h + s[i]) % prime;

                a = a*b % (prime-1);
                i++;
            }

            return h % 420;
        }

        static private uint HashBucket(ulong v)
        {
            uint h = 0;
            uint a = PRIME_A;
            const uint b = PRIME_B;
            const uint k = PRIME_K; 
            uint vLow = (uint)(v >> 32);
            uint vHigh = (uint)v;

            for(int i = 0; i < 4; i++)
            {
                h = (a * h + (byte)vLow) % k;
                a = a * b % (k-1);
                vLow = vLow >> 8;
            }

            for(int i = 0; i < 4; i++)
            {
                h = (a * h + (byte)vHigh) % k;
                a = a * b % (k-1);
                vHigh = vHigh >> 8;
            }

            return h % 420;
        }

        static private uint HashBucket(byte[] v)
        {
            uint h = 0;
            uint a = PRIME_A;
            const uint b = PRIME_B;
            const uint k = PRIME_K;

            for(int i = 0; i < v.Length; i++)
            {
                h = (a * h + (byte)v[i]) % k;
                a = a * b % (k-1);
            }

            return h % 420;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\Database\Filter.cs ===
//
//  Filter DB Common Code
//

using System;
using System.Collections;
using System.Collections.Generic;
using System.Data;
using System.Data.SqlTypes;
using System.Data.SqlClient;
using System.Runtime.InteropServices;
using ServerTestFramework.STFLive.Reporting;
using ServerTestFramework.STFLive.Reporting.Tables;


namespace ServerTestFramework.STFLive.Database
{       
      // Database Class
    [ComVisible(false)]
    public class FilterDB : ReportingDatabase
    {
        /// <summary>
	    /// Summary description for FilterDBTables.
        /// TODO: Add in attributes to specify whether or not fields are strict/loose
        /// TODO: Add all tables into STFLive.Reporting.Tables
        /// TODO: Add comments
	    /// </summary>

        protected string m_ServerName;
        public string Server
        {
            get
            {
                return m_ServerName;
            }
        }

        public FilterDB()
        {
            JobQueue = new List<ReportingJob>(10);
            JobThreads = new Hashtable(10);
        }

        ~FilterDB()
        {
            Close();
        }

        public void ConnectToServer(string serverName)
        {
            this.ConnectToServer(serverName, m_DatabaseName);
        }

        // BUGBUG: Probably should be an enum rather than a string (to reduce the chance that we'll have a bug
        // trying to connect to a non-existant DB when we switch environments)
        public void ConnectToServer(string serverName, string database)
        {
            m_ServerName = serverName;
            m_DatabaseName = database;
            m_SqlConnection = new SqlConnection("server=" + serverName + ";database=" + database + ";Integrated Security=SSPI");
            m_SqlConnection.Open();
        }

        private void Close()
        {
            // m_SqlConnection could be null
            if (m_SqlConnection != null && m_SqlConnection.State != ConnectionState.Closed)
            {
                try
                {
                    m_SqlConnection.Close();
                }
                catch
                {
                    // do nothing here
                }
                finally
                {
                    m_SqlConnection = null;
                }
            }

            CloseJobQueueThreads();
        }

        private SqlConnection Connection
        {
            get { return m_SqlConnection; }
        }

        public System.Data.ConnectionState ConnectionState
        {
            get { return m_SqlConnection.State; }
        }

        /// <summary>
        /// What type server you are dealing with
        /// </summary>
        public override ReportingMachines ComponentType
        {
            get
            {
                return ReportingMachines.Filter;
            }
        }

        /// <summary>
        /// The name of the server you are dealing with
        /// </summary>
        public override string ComponentName
        {
            get
            {
                return m_ServerName;
            }
        }

        /// <summary>
        /// API to inject an event
        /// </summary>
        /// <param name="type"></param>
        /// <param name="reportingRefObject"></param>
        /// <returns></returns>
        public override string InjectEvent(ReportingEventType type, out ReportingReferenceObject reportingRefObject)
        {
            reportingRefObject = null;
            return ""; 
        }

        /// <summary>
        /// API that injects the next event in a series of events
        /// </summary>
        /// <param name="type"></param>
        /// <param name="reportingRefObject"></param>
        /// <returns></returns>
        public override string InjectNextEvent(ReportingEventType type, ref ReportingReferenceObject reportingRefObject)
        {
            return "";
        }

        /// <summary>
        /// Gets a performance counter that is an integer
        /// </summary>
        /// <param name="Counter"></param>
        /// <returns></returns>
        public override int GetIntPerformanceCounter(string Counter)
        {
            return -1;
        }

        /// <summary>
        /// Gets a performance counter that is a floating point number
        /// </summary>
        /// <param name="Counter"></param>
        /// <returns></returns>
        public override float GetFloatPerformanceCounter(string Counter)
        {
            return -0.0f;
        }


        private string m_DatabaseName = "FilterDB";
        /// <summary>
        /// The SQL name of the database (note: NOT THE MACHINE NAME)
        /// </summary>
        public override string DatabaseName
        {
            get
            {
                return m_DatabaseName;
            }
            set
            {
                m_DatabaseName = value;
            }
        }

        /// <summary>
        /// Runs a query against the database (all tables).  Returns data for small tables (less than 20 rows), returns counts for all other tables
        /// </summary>
        /// <returns>Query Results</returns>
        public override string RunDebugQuery()
        {
            // TODO: Implement me
            return "";
        }


        /// <summary>
        /// Queues a job to be run using the default parameters for that job (specific to that job)
        /// Validates that this job can be run on this server
        /// </summary>
        /// <param name="jobType">Type of job to be run</param>
        /// <returns>Could job be queued</returns>
        public override ReportingJob QueueJob(ReportingJobType jobType)
        {
            ReportingJobParameters defaultJobParams = null;
            switch (jobType)
            {
                case ReportingJobType.FilterDB_Purge:   // FilterDB Purge Job
                    defaultJobParams = new FilterDB_PurgeFactTables.FilterDB_PurgeFactTables_Params();
                    break;                
                default:
                    // Invalid Job Type for this database
                    throw new Exception("Invalid Job Type. This specified job does not exist on this database");                    
            }

            return QueueJob(jobType, defaultJobParams);
        }

        /// <summary>
        /// Queues a job to be run using the specified parameters for that job (specific to that job)
        /// Validates that this job can be run on this server
        /// </summary>
        /// <param name="jobType">Type of job to be run</param>
        /// <returns>Could job be queued</returns>
        public override ReportingJob QueueJob(ReportingJobType jobType, ReportingJobParameters jobParameters)
        {
            ReportingJob retVal = null; 
            bool jobExists = false;

            // Get job factory instance
            ReportingJobFactory jobFactory = ReportingJobFactory.Instance;

            // Create job through factory
            switch (jobType)
            {
                case ReportingJobType.FilterDB_Purge:   // FilterDB Purge Job
                    retVal = jobFactory.CreateReportingJob(jobType,jobParameters);
                    break;
                default:
                    // Invalid Job Type for this database
                    throw new Exception("Invalid Job Type. This specified job does not exist on this database");
            }

            // Enforce synchronized access
            lock (JobQueue)
            {
                // Verify that job type is not already in queue
                for (int i = 0; i < JobQueue.Count; i++)
                {
                    if ((retVal.JobName == JobQueue[i].JobName) && (JobQueue[i].Parameters.Equals(jobParameters)))
                    {
                        retVal = null;          // Use existing job in queue
                        retVal = JobQueue[i];
                        jobExists = true;
                    }
                }
                if (!jobExists)
                {
                    JobQueue.Add(retVal);   // Add new job to database queue
                }
            }

            return retVal;
        }

     
        /// <summary>
        /// Inserts a certain data set and returns a reference object to that data set
        /// </summary>
        /// <param name="row"></param>
        /// <param name="reportingRefObject"></param>
        /// <returns></returns>
        public override string InjectSingleData(ReportingDataLoader data, out ReportingReferenceObject reportingRefObject)
        {
            //TODO: Define loader
            reportingRefObject = null;
            
            // Command object
            SqlCommand cmd = new SqlCommand();
            cmd.Connection = m_SqlConnection;

            // Get SQL query to inject data rom Loader
            cmd.CommandText = data.InjectSingleData();

            // Check if the data injection was successful by looking at affected rows
            int affectedRows = 0;
            if ((affectedRows = cmd.ExecuteNonQuery()) > 0)
            {
                // Success - Return executed query and affected rows
                reportingRefObject = new RealtimeDBStressData();
                Hashtable loadedData = new Hashtable(1);
                loadedData.Add(cmd.CommandText, affectedRows);
                ((RealtimeDBStressData)reportingRefObject).Queries = loadedData;
                
            }
            else
            {
                throw new Exception("ERROR: Data could not be inserted into the database " + m_DatabaseName);
            }


            
            return "";
        }
        /// <summary>
        /// Inserts a certain data set and returns a reference object to that data set
        /// </summary>
        /// <param name="table"></param>
        /// <param name="reportingRefObjectContainer"></param>
        /// <returns></returns>
        public override string InjectData(ReportingDataLoader data, out ReportingReferenceObjectContainer reportingRefObjectContainer)
        {
            //TODO: Again, define loader
            reportingRefObjectContainer = null;
            return "";
        }
        /// <summary>
        /// Inserts a randomly generated reporting data type into that particular database, returns a reference object to that item.
        /// </summary>
        /// <param name="dataType"></param>
        /// <param name="refObjectContainer"></param>
        /// <returns>SQL results of inserting the data</returns>
        public override string InjectSingleRandomData(ReportingDataType dataType, out ReportingReferenceObject reportingRefObject)
        {
            //TODO: Add data object factory
            //TODO: Run SQL to insert the data
            reportingRefObject = null;
            return "";
        }
        /// <summary>
        /// Insters a set of randomly generated data into the database
        /// </summary>
        /// <param name="dataType">Type of data to insert</param>
        /// <param name="count">How many objects to insert</param>
        /// <param name="container">A reference object to this data</param>
        /// <returns>SQL results of inserting that data</returns>
        public override string InjectRandomData(ReportingDataType dataType, long count, out ReportingReferenceObjectContainer reportingRefObjectContainer)
        {
            //TODO: Add data object factory
            //TODO: Run SQL to insert the data
            reportingRefObjectContainer = null;
            return "";
        }
        /// <summary>
        /// Collects information about the current replication status
        /// </summary>
        /// <returns>A string describing any streams present as well as their status</returns>
        public override string ListReplicationStreamsAndStatus()
        {

            return "";
        }

        /// <summary>
        /// Verifies that data represented within the reference object is present in this database
        /// Throws an exception if verification fails
        /// </summary>
        /// <param name="refObject">Object whose data needs verifying</param>
        /// <returns>Description of what was verified</returns>
        public override string Verify(ReportingReferenceObject refObject)
        {
            return "";
        }
        /// <summary>
        /// Verifies that ALL data represented within the reference object container is present in this database
        /// Throws an exception if verification fails
        /// </summary>
        /// <param name="refObjectContainer">Object whose data needs verifying</param>
        /// <returns>Description fo what was verified</returns>
        public override string Verify(ReportingReferenceObjectContainer refObjectContainer)
        {
            return "";
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\Database\NameList.cs ===
using System;

namespace ServerTestFramework.Database
{
	/// <summary>
	/// Maintains a cache of valid names
	/// </summary>
	public class NameList
	{
		object					LockObject=new object();
		const int				maxItems=5000;
		int						bufferSize=0;
		int						nextItem=0;
		string					[]List=new string[maxItems];
		public string			Get()
		{
			if (bufferSize==0)
			{
				Console.WriteLine("----- No stored puids ------");
				return "NoName";
			}
			string ret;
			lock (LockObject)
			{
				ret=List[nextItem++];
				if (nextItem>=bufferSize)
					nextItem=0;
			}
			return ret;
		}
		public void				Add(string s)
		{
			if (bufferSize==maxItems)
				throw new Exception("This list can only hold "+maxItems+" items!");
			lock (LockObject)
			{
				List[bufferSize++]=s;
			}
		}		

		public void				Randomize()
		{
			Array.Sort(List,0,bufferSize);
			int i;
			for (i=0; i<bufferSize; i++)
			{
				if (List[i]==null)
					Console.WriteLine("WHOOPS!");
			}
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\Database\Npdb.cs ===
/* Npdb wrapper class */

using System;
using System.Data;
using System.Data.SqlTypes;
using System.Data.SqlClient;
using System.Data.Common;
using System.Collections;
using System.Collections.Generic;
using System.Text;
using System.Runtime.InteropServices;
using ServerTestFramework.LiveService;
using ServerTestFramework.Utilities;

using xonline.common.config;

namespace ServerTestFramework.Database
{
    public enum REVOCATION_DELIVERY_TYPE
    {
        GETREVOCATIONLIST = 1,
        CHECKREVOCATION = 2
    };

    /// <summary>
    /// Data structure returned from GetGameConfig()
    /// </summary>
    public class GameConfigRow
    {
        public Int32    TitleId;
        public DateTime Changed;
        public String   XmlConfig;
        public String   XdkVersion;
    }

    /// <summary>
    /// Data structure returned from GetLiveTitleConfig()
    /// </summary>
    public class LiveTitleConfigRow
    {
        public UInt32   TitleId;
        public DateTime Changed;
        public String   XmlTitleConfig;
    }

    /// <summary>
    /// Data structure describing an entry in the t_stringsvr_strings table
    /// </summary>
    public class StringServerString
    {
        public UInt32   TitleId;
        public Int32    StringId;
        public String   Locale;
        public DateTime Changed;
        public DateTime Expires;
        public String   Value;

        public override bool Equals(object obj)
        {
            if (obj is StringServerString)
            {
                return
                    (
                    (obj as StringServerString).TitleId == TitleId &&
                    (obj as StringServerString).StringId == StringId &&
                    (obj as StringServerString).Locale == Locale &&
                    (obj as StringServerString).Value == Value
                    );
            }
            else
            {
                return false;
            }
        }

        public override int GetHashCode()
        {
            return base.GetHashCode();
        }

        public override string ToString()
        {
            return String.Format("TitleId[0x{0:x}] StringId[{1}] Locale[{2}] Changed[{3}] Expires[{4}] Value[{5}]",
                TitleId, StringId, Locale, Changed, Expires, Value);
        }
    }


    /// <summary>
    /// Collection of StringServerString objects
    /// </summary>
    public class StringServerStrings : CollectionBase
    {
        public StringServerStrings() {}

        public StringServerString this[int index]
        {
            get { return List[index] as StringServerString; }
            set { List[index] = value; }
        }

        public int Add(StringServerString val)
        {
            return List.Add(val);
        }

        public bool Contains(StringServerString val)
        {
            return List.Contains(val);
        }

        public void Remove(StringServerString val)
        {
            List.Remove(val);
        }
    }

    /// <summary>
    /// Class defining a leaderboard entry in the t_stats_leaderboards table
    /// and a competition template entry in the t_stats_competition_templates table.
    /// The IsCompetitionTemplate member will be set to true if the object defines an
    /// Xbox1 Competition Template, otherwise it will be false;
    /// </summary>
    public class Leaderboard
    {
        public UInt32   TitleId;
        public Int32    LeaderboardId;
        public Int32    ResetType;
        public bool     Top100;
        public bool     IsTeamLb;
        public bool     RequiresArbitration;
        public Int32    DecayDays;
        public string   EloBase;
        public Int32    EloK;
        public Int32    EloNew;
        public string   EloCTable;
        public Int32    AttachCount;
        public Int32    MaxAttachSize;
        public DateTime LastReset;
        public bool     IsCompetitionTemplate;

        public override bool Equals(object obj)
        {
            if (obj is Leaderboard)
            {
                return
                    (
                    (obj as Leaderboard).TitleId == TitleId &&
                    (obj as Leaderboard).LeaderboardId == LeaderboardId &&
                    (obj as Leaderboard).ResetType == ResetType &&
                    (obj as Leaderboard).Top100 == Top100 &&
                    (obj as Leaderboard).IsTeamLb == IsTeamLb &&
                    (obj as Leaderboard).RequiresArbitration == RequiresArbitration &&
                    (obj as Leaderboard).DecayDays == DecayDays &&
                    (obj as Leaderboard).EloBase == EloBase &&
                    (obj as Leaderboard).EloK == EloK &&
                    (obj as Leaderboard).EloNew == EloNew &&
                    (obj as Leaderboard).EloCTable == EloCTable &&
                    (obj as Leaderboard).AttachCount == AttachCount &&
                    (obj as Leaderboard).MaxAttachSize == MaxAttachSize &&
                    (obj as Leaderboard).IsCompetitionTemplate == IsCompetitionTemplate
                    );
            }

            return false;
        }

        public override int GetHashCode()
        {
            return base.GetHashCode();
        }

        public override string ToString()
        {
            string ret;

            if (IsCompetitionTemplate)
            {
                ret = String.Format("TitleId[0x{0:x}] TemplateId[{1}] ResetType[{2}] Top100[{3}] IsTeamLb[{4}] " +
                    "RequiresArbitration[{5}] DecayDays[{6}] EloBase[{7}] EloK[{8}] EloNew[{9}] EloCTable[{10}] " +
                    "AttachCount[{11}] MaxAttachSize[{12}]",
                    TitleId, LeaderboardId, ResetType, Top100, IsTeamLb, RequiresArbitration, DecayDays, EloBase,
                    EloK, EloNew, EloCTable, AttachCount, MaxAttachSize);
            }
            else
            {
                ret = String.Format("TitleId[0x{0:x}] LeaderboardId[{1}] ResetType[{2}] Top100[{3}] IsTeamLb[{4}] " +
                    "RequiresArbitration[{5}] DecayDays[{6}] EloBase[{7}] EloK[{8}] EloNew[{9}] EloCTable[{10}] " +
                    "AttachCount[{11}] MaxAttachSize[{12}] LastReset[{13}]",
                    TitleId, LeaderboardId, ResetType, Top100, IsTeamLb, RequiresArbitration, DecayDays, EloBase,
                    EloK, EloNew, EloCTable, AttachCount, MaxAttachSize, LastReset);
            }

            return ret;
        }
    }

    public class LeaderboardCollection : CollectionBase
    {
        public Leaderboard this[int index]
        {
            get { return List[index] as Leaderboard; }
            set { List[index] = value; }
        }

        public int Add(Leaderboard val)
        {
            return List.Add(val);
        }

        public bool Contains(Leaderboard val)
        {
            return List.Contains(val);
        }

        public void Remove(Leaderboard val)
        {
            List.Remove(val);
        }
    }

    public class Digest
    {
        public byte[] bin_digests;
        public short ti_is_blacklisted;
        public DateTime dt_Change_datetime;
        public REVOCATION_DELIVERY_TYPE ti_revocation_delivery_type;
        public String vc_revocation_reason;
    }

    public class MatchTitle
    {
        public int TitleId;
        public int SessionExpiration;
        public int? ForceXenonBehavior;
        public string DbList;
        public int DeleteDelaySeconds;
        public byte? RevokeCrossPlatform;

        public MatchTitle()
        {
        }

        public MatchTitle(MatchTitle source)
        {
            TitleId = source.TitleId;
            SessionExpiration = source.SessionExpiration;
            ForceXenonBehavior = source.ForceXenonBehavior;
            DbList = source.DbList;
            DeleteDelaySeconds = source.DeleteDelaySeconds;
            RevokeCrossPlatform = source.RevokeCrossPlatform;
        }
    }

    /// <summary> This is a wrapper class for talking to the NPDB for service-specific data. </summary>
    [ComVisible(false)]
    public class NpdbUtility: Npdb
    {
        public SqlDataReader GetAllUserSettings()
        {
            lock(_conn)
            {
                SqlDataReader reader = null;

                string sql = "select i_setting_id, vc_name, vc_location, i_permission_flags from t_stats_user_setting_ids";
                ReadData(sql, out reader);
                return reader;
            }
        }

        public void ScheduleDowntime(DateTime start, DateTime end)
        {
            lock(_conn)
            {
                SqlDateTime sqlStart = new SqlDateTime(start);
                SqlDateTime sqlEnd = new SqlDateTime(end);

                string sql = "insert into t_svc_downtime (dt_downtime_start, dt_downtime_end) values ('"+sqlStart.ToString()+"', '"+sqlEnd.ToString()+"')";
                IssueCommand(sql);
            }
        }

        public void ClearDowntime()
        {
            lock(_conn)
            {
                string sql = "delete from t_svc_downtime";
                IssueCommand(sql);
            }
        }

        public void ClearSpecificDowntime(DateTime start, DateTime end)
        {
            lock(_conn)
            {
                SqlDateTime sqlStart = new SqlDateTime(start);
                SqlDateTime sqlEnd = new SqlDateTime(end);

                string sql = "delete from t_svc_downtime where dt_downtime_start = '" + sqlStart.ToString() + "' AND dt_downtime_end = '" + sqlEnd.ToString() + "'";
                IssueCommand(sql);
            }
        }

        public SqlDataReader GetSpecificDowntime(DateTime start, DateTime end)
        {
            lock(_conn)
            {
                SqlDataReader reader = null;

                SqlDateTime sqlStart = new SqlDateTime(start);
                SqlDateTime sqlEnd = new SqlDateTime(end);

                string sql = "select dt_downtime_start, dt_downtime_end from t_svc_downtime where dt_downtime_start = '" + sqlStart.ToString() + "' AND dt_downtime_end = '" + sqlEnd.ToString() + "'";
                ReadData(sql, out reader);

                return reader;
            }
        }

        public SqlDataReader GetAllDowntime()
        {
            lock(_conn)
            {
                SqlDataReader reader = null;

                string sql = "select dt_downtime_start, dt_downtime_end from t_svc_downtime order by dt_downtime_start, dt_downtime_end asc";
                ReadData(sql, out reader);

                return reader;
            }
        }

        public uint GetCronJobBEnabled(ulong jobId)
        {
            lock(_conn)
            {
                SqlDataReader reader = null;
                uint returnValue = 0;

                try
                {
                    string sql = "select b_enabled from t_cron_jobs where (i_job_id = " + jobId + ")";

                    ReadData(sql, out reader);
                    returnValue = (uint)reader.GetValue(0);
                }
                finally
                {
                    if(null != reader && !reader.IsClosed)
                    {
                        reader.Close();
                    }
                }

                return returnValue;
            }


        }

        /// <summary>
        /// Xenon M1 work: t_blacklisted_machines table is moved from uodb to npdb
        /// </summary>
        /// <param name="puid"></param>
        /// <param name="isBlacklisted"></param>
        public void BlacklistMachine(ulong puid, bool isBlacklisted)
        {
            lock(_conn)
            {
                new SqlCommand("DELETE FROM t_blacklisted_machines WHERE bi_machine_puid = " + puid.ToString(), _conn).ExecuteNonQuery();

                new SqlCommand("INSERT INTO dbo.t_blacklisted_machines " + 
                    "(bi_machine_puid, ti_is_blacklisted) VALUES " + 
                    "(" + puid.ToString() + ", " + (isBlacklisted ? "1" : "0") + ")", 
                    _conn).ExecuteNonQuery();
            }
        }

        /// <summary>
        /// Xenon M1 work: t_blacklisted_titles table is moved from uodb to npdb
        /// </summary>
        /// <param name="puid"></param>
        /// <param name="isBlacklisted"></param>
        public void BlacklistTitle(uint title, uint version, bool isBlacklisted)
        {
            lock(_conn)
            {
                new SqlCommand("DELETE FROM t_blacklisted_titles WHERE i_title_id = " + title.ToString() + " and i_title_version = " + version.ToString(), _conn).ExecuteNonQuery();

                new SqlCommand("INSERT INTO dbo.t_blacklisted_titles " + 
                    "(i_title_id, i_title_version, ti_is_blacklisted) VALUES " + 
                    "(" + title.ToString() + ", " + version.ToString() + ", " + (isBlacklisted ? "1" : "0") + ")", 
                    _conn).ExecuteNonQuery();
            }
        }

        /// <summary>
        /// Xenon M1 work: t_blacklisted_users table is moved from uodb to npdb
        /// </summary>
        /// <param name="puid"></param>
        /// <param name="isBlacklisted"></param>
        public void BlacklistUser(ulong puid, bool isBlacklisted)
        {
            lock(_conn)
            {
                new SqlCommand("DELETE FROM t_blacklisted_users WHERE bi_user_puid = " + puid.ToString(), _conn).ExecuteNonQuery();

                new SqlCommand("INSERT INTO dbo.t_blacklisted_users " + 
                    "(bi_user_puid, ti_is_blacklisted) VALUES " + 
                    "(" + puid.ToString() + ", " + (isBlacklisted ? "1" : "0") + ")", 
                    _conn).ExecuteNonQuery();
            }
        }

        /// <summary>
        /// t_blacklisted_digests now contains data for both DietOrange and content
        /// revocation. It is partitioned based on a new row named ti_revocation_delivery_type.
        /// delivery_type == 1 (Revocation List Only)
        /// delivery_type == 2 (CheckRevocaton Only)
        /// </summary>
        /// <param name="digest"></param>
        /// <param name="isBlacklisted"></param>
        public void BlacklistDigest(byte[] digest, bool isBlacklisted)
        {
            BlacklistDigest(digest, isBlacklisted, REVOCATION_DELIVERY_TYPE.CHECKREVOCATION, "No Reason Given");
        }
        public void BlacklistDigest(byte[] digest, bool isBlacklisted, REVOCATION_DELIVERY_TYPE type, string reason)
        {
            try
            {
                lock (_conn)
                {
                    SqlCommand cmd = new SqlCommand("p_xcbt_blacklist_digest", _conn);
                    cmd.CommandType = CommandType.StoredProcedure;
                    cmd.Parameters.Add("@bin_digest", SqlDbType.Binary, 20).Value = digest;
                    cmd.Parameters.Add("@ti_is_blacklisted", SqlDbType.TinyInt).Value = isBlacklisted ? 1 : 0;
                    cmd.Parameters.Add("@ti_revocation_delivery_type", SqlDbType.TinyInt).Value = type;
                    cmd.Parameters.Add("@vc_revocation_reason", SqlDbType.NVarChar, 80).Value = reason;
                    cmd.ExecuteNonQuery();
                }
            }
            // Bug 135242:  there is duplicate data in the table from prodbase and the sproc cannot update it
            catch (System.Data.SqlClient.SqlException ex)
            {
                if (ex.Message.Contains(@"Violation of PRIMARY KEY constraint 'pk_blacklisted_digests'. Cannot insert duplicate key in object 'dbo.t_blacklisted_digests'"))
                {
                    Global.RO.Warn("Bug 135242: Duplicate data found in t_blacklisted_digests, ignoring sql exception until sproc fixed.");
                }
                else
                {
                    throw;
                }
            }
        }

        
        /// <summary>
        /// Xenon M1 work: t_blacklisted_digests table is moved from uodb to npdb
        /// Determines if digest is blacklisted.
        /// </summary>
        /// <param name="digest"></param>
        /// <returns></returns>
        public bool IsBlacklistedDigest(byte [] digest, bool remove)
        {
            lock(_conn)
            {
                bool bRet = false;

                SqlDataReader myDataReader = null;
                SqlCommand mySqlCommand = new SqlCommand("select count(*) from t_blacklisted_digests where bin_digest = 0x"+Hexer.tohex(digest)+" and ti_is_blacklisted <> 0", _conn);

                try
                {
                    myDataReader = mySqlCommand.ExecuteReader();

                    // Always call Read before accessing data.
                    if (myDataReader.Read())
                    {
                        bRet=(myDataReader.GetInt32(0) == 1);
                    }

                    if (remove)
                    {
                        myDataReader.Close();
                        SqlCommand cmd = new SqlCommand("update t_blacklisted_digests set ti_is_blacklisted = 0 where bin_digest = 0x"+Hexer.tohex(digest)+" and ti_is_blacklisted <> 0", _conn);
                        cmd.ExecuteNonQuery();
                    }
                }
                finally
                {
                    // Always call Close when done reading.
                    if (myDataReader != null && !myDataReader.IsClosed)
                        myDataReader.Close();
                }
                return bRet;
            }
        }

        public void DeleteDigest(byte[] digest)
        {
            lock(_conn)
            {
                new SqlCommand("DELETE FROM t_blacklisted_digests WHERE bin_digest = 0x" + Hexer.tohex(digest), _conn).ExecuteNonQuery();
            }
        }

        public Digest[] GetDigests()
        {
            const string SQL = @"use npdb select * from t_blacklisted_digests";

            System.Collections.ArrayList tempDigests = new ArrayList();
            SqlDataReader reader;
            lock(_conn)
            {
                ReadData(SQL, out reader);
                while (reader.Read())
                {
                    Digest digest = new Digest();
                    digest.bin_digests = (byte[])reader.GetValue(reader.GetOrdinal("bin_digest"));
                    digest.ti_is_blacklisted = (short)reader.GetByte(reader.GetOrdinal("ti_is_blacklisted"));
                    digest.dt_Change_datetime = reader.GetDateTime(reader.GetOrdinal("dt_Change_datetime"));
                    digest.ti_revocation_delivery_type = (REVOCATION_DELIVERY_TYPE)reader.GetByte(reader.GetOrdinal("ti_revocation_delivery_type"));
                    digest.vc_revocation_reason = reader.GetString(reader.GetOrdinal("vc_revocation_reason"));
                    tempDigests.Add(digest);
                }
                reader.Close();
            }

            Digest[] digests = new Digest[tempDigests.Count];
            tempDigests.CopyTo(0, digests, 0, digests.Length);
            return(digests);
        }

        public void SaveGameConfig(uint titleId, string xmlConfig)
        {
            SaveGameConfig(titleId, xmlConfig);
        }

        public void SaveGameConfig(uint titleId, string xmlConfig, string xdkVersion)
        {
            lock(_conn)
            {
                SpGameSaveConfig sp = new SpGameSaveConfig();
                sp.titleId = titleId;
                sp.xmlConfig = xmlConfig;
                sp.xdkVersion = xdkVersion;

                if(IssueCommand(sp.GenerateExecString()) == 0)
                {
                    throw new DatabaseException(_conn, "Failed to insert game config");
                }
            }
        }

        public uint GetGameConfig(uint titleId, out GameConfigRow gameConfig)
        {
            lock(_conn)
            {
                SqlDataReader reader = null;
                uint hr = HResult.S_FALSE;
                gameConfig = null;

                SqlCommand cmd = null;
                SqlParameter param = null;

                try
                {

                    cmd = new SqlCommand("p_game_get_config", _conn);
                    cmd.CommandType = CommandType.StoredProcedure;

                    param = new SqlParameter();
                    param.ParameterName = "RETURN_CODE";
                    param.Direction = ParameterDirection.ReturnValue;
                    param.DbType =     DbType.Int32;
                    cmd.Parameters.Add(param);

                    param = new SqlParameter();
                    param.ParameterName = "@i_title_id";
                    param.Direction = ParameterDirection.Input;
                    param.DbType = DbType.Int32;
                    param.Value = (int)titleId;
                    cmd.Parameters.Add(param);
                    
                    reader = cmd.ExecuteReader();

                    if(reader.HasRows)
                    {
                        int titleIdOrdinal = reader.GetOrdinal("i_title_id");
                        int changedOrdinal = reader.GetOrdinal("dt_changed");
                        int xmlConfigOrdinal = reader.GetOrdinal("xml_config");
                        int xdkVersionOrdinal = reader.GetOrdinal("vc_xdk_version");

                        SqlParameter retParam = cmd.Parameters["RETURN_CODE"];
                        if(null != retParam && null != retParam.Value)
                        {
                            hr = (UInt32)retParam.Value;
                        }
                        else
                        {
                            // TODO-jacobr: this operation has been failing but we have data.. just mark
                            // the request as S_OK for now.
                            hr = HResult.S_OK;
                        }

                        if(HResult.S_OK == hr && reader.Read())
                        {
                            gameConfig = new GameConfigRow();

                            // i_title_id, dt_changed, xml_config, vc_xdk_version 
                            gameConfig.TitleId       = reader.GetInt32(titleIdOrdinal);
                            gameConfig.Changed       = reader.GetDateTime(changedOrdinal);
                            gameConfig.XmlConfig     = reader.GetString(xmlConfigOrdinal);
                            gameConfig.XdkVersion    = reader.GetString(xdkVersionOrdinal);
                        }
                    }
                }
                finally
                {
                    if(null != reader && !reader.IsClosed)
                    {
                        reader.Close();
                    }
                }

                return hr;
            }
        }

        public uint[] GetAllGameTitles()
        {
            return this.GetAllGameTitles(false);
        }
        public uint[] GetAllGameTitles(bool filter)
        {
            System.Collections.ArrayList titleList = new ArrayList();
            lock(_conn)
            {
                SqlDataReader myDataReader = null;
                SqlCommand mySqlCommand = new SqlCommand("SELECT i_title_id from dbo.t_game_config", _conn);
                try
                {
                    myDataReader = mySqlCommand.ExecuteReader();
                    // Always call Read before accessing data.
                    while (myDataReader.Read())
                    {
                        uint titleId = (uint)myDataReader.GetInt32(0);
                        if (!filter || (titleId & 0xFFFF0000) > 0)
                        {
                            titleList.Add(titleId);
                        }
                    }
                }
                finally
                {
                    // Always call Close when done reading.
                    if (myDataReader != null)
                        myDataReader.Close();
                }
                if (titleList.Count > 0)
                {
                    return (uint[])titleList.ToArray(System.Type.GetType("System.UInt32"));
                }
                else
                {
                    return null;
                }
            }
        }

        /// <summary>
        /// Gets the Live Title Config (LTC) data for the specified title.
        /// </summary>
        /// <param name="titleId">Title ID</param>
        /// <returns>A LiveTitleConfigRow object that will contain the Live Title Config data</returns>
        public LiveTitleConfigRow GetLiveTitleConfig(uint titleId)
        {
            LiveTitleConfigRow liveTitleConfig = null;
            lock (_conn)
            {
                SqlDataReader reader = null;
                SqlCommand command = null;
                SqlParameter param = null;

                try
                {
                    command = _conn.CreateCommand();
                    command.CommandType = CommandType.StoredProcedure;
                    command.CommandText = "p_live_title_config_get";
                    
                    param = new SqlParameter();
                    param.ParameterName = "@i_title_id";
                    param.Direction = ParameterDirection.Input;
                    param.DbType = DbType.Int32;
                    param.Value = (int)titleId;
                    command.Parameters.Add(param);

                    reader = command.ExecuteReader();
                    if (reader.HasRows)
                    {
                        // The p_live_title_config_Get SP doesn't return the Title ID in the result set
                        int changedOrdinal = reader.GetOrdinal("dt_changed");
                        int xmlTitleCOnfigOrdinal = reader.GetOrdinal("xml_title_config");

                        if (reader.Read())
                        {
                            liveTitleConfig = new LiveTitleConfigRow();
                            liveTitleConfig.TitleId = titleId;
                            liveTitleConfig.Changed = reader.GetDateTime(changedOrdinal);
                            liveTitleConfig.XmlTitleConfig = reader.GetString(xmlTitleCOnfigOrdinal);
                        }
                    }
                }
                finally
                {
                    if (null != reader && !reader.IsClosed)
                    {
                        reader.Close();
                    }
                }
            }

            return liveTitleConfig;
        }

        /// <summary>
        /// Sets the delete delay in seconds for a particular Match title ID.
        /// Note: this method does NOT call xmgmt cmd to reload title IDs on Match servers.
        /// </summary>
        /// <param name="titleId"></param>
        /// <param name="seconds"></param>
        public void SetMatchTitleDeleteDelay(uint titleId, int seconds)
        {
            lock (_conn)
            {
                SqlCommand command = _conn.CreateCommand();
                command.CommandText = "UPDATE t_match_titles SET i_delete_delay_seconds = " + seconds.ToString() +
                    " WHERE i_title_id = 0x" + titleId.ToString("X");
                int rowsAffected = command.ExecuteNonQuery();
                if (rowsAffected != 1)
                {
                    throw new UnexpectedTestResultException("Failed to update delete delay secs for title id " + 
                        titleId.ToString("X"));
                }
            }
        }

        /// <summary>
        /// Sets the delete delay in seconds for a particular Match title ID.
        /// Note: this method does NOT call xmgmt cmd to reload title IDs on Match servers.
        /// </summary>
        /// <param name="titleId"></param>
        /// <param name="seconds"></param>
        public void SetMatchTitleRevokeCrossPlatform(uint titleId, int? setting)
        {
            lock (_conn)
            {
                SqlCommand command = _conn.CreateCommand();
                string value = GetStringValueOrNULL(setting);
                command.CommandText = "UPDATE t_match_titles SET ti_revoke_cross_platform = " + value +
                    " WHERE i_title_id = 0x" + titleId.ToString("X");
                int rowsAffected = command.ExecuteNonQuery();
                if (rowsAffected != 1)
                {
                    throw new UnexpectedTestResultException("Failed to update revoke cross platform for title id " +
                        titleId.ToString("X"));
                }
            }
        }

        private MatchTitle ReadMatchTitle(SqlDataReader reader)
        {
            MatchTitle matchTitle = new MatchTitle();
            matchTitle.TitleId = reader.GetInt32(reader.GetOrdinal("i_title_id"));
            matchTitle.SessionExpiration = reader.GetInt32(reader.GetOrdinal("i_session_expiration"));
            if (!reader.IsDBNull(reader.GetOrdinal("i_force_xenon_behavior")))
            {
                matchTitle.ForceXenonBehavior = reader.GetInt32(reader.GetOrdinal("i_force_xenon_behavior"));
            }
            else
            {
                matchTitle.ForceXenonBehavior = null;
            }
            matchTitle.DbList = reader.GetString(reader.GetOrdinal("vc_db_list"));
            matchTitle.DeleteDelaySeconds = reader.GetInt32(reader.GetOrdinal("i_delete_delay_seconds"));
            if (!reader.IsDBNull(reader.GetOrdinal("ti_revoke_cross_platform")))
            {
                matchTitle.RevokeCrossPlatform = reader.GetByte(reader.GetOrdinal("ti_revoke_cross_platform"));
            }
            else
            {
                matchTitle.RevokeCrossPlatform = null;
            }
            return matchTitle;
        }

        public MatchTitle GetMatchTitle(uint titleId)
        {
            MatchTitle matchTitle = null;
            lock (_conn)
            {
                SqlDataReader reader = null;
                try
                {
                    SqlCommand command = _conn.CreateCommand();
                    command.CommandText = "SELECT * FROM t_match_titles WHERE i_title_id = 0x" + 
                        titleId.ToString("X");
                    reader = command.ExecuteReader();
                    while (reader.Read())
                    {
                        matchTitle = ReadMatchTitle(reader);
                    }
                }
                finally
                {
                    if (reader != null && !reader.IsClosed)
                    {
                        reader.Close();
                    }
                }
            }
            return matchTitle;
        }

        public List<MatchTitle> GetMatchTitles()
        {
            List<MatchTitle> matchTitles = new List<MatchTitle>();
            lock (_conn)
            {
                SqlDataReader reader = null;
                try
                {
                    SqlCommand command = _conn.CreateCommand();
                    command.CommandText = "SELECT * FROM t_match_titles";

                    reader = command.ExecuteReader();
                    while (reader.Read())
                    {
                        matchTitles.Add(ReadMatchTitle(reader));
                    }
                }
                finally
                {
                    if (reader != null && !reader.IsClosed)
                    {
                        reader.Close();
                    }
                }
            }
            return matchTitles;
        }

        private string GetStringValueOrNULL(object x)
        {
            if (x == null)
            {
                return "NULL";
            }
            return x.ToString();
        }

        public void UpdateMatchTitle(MatchTitle matchTitle)
        {
            const string UPDATE_TEMPLATE = @"UPDATE t_match_titles
SET i_session_expiration = __SessionExpiration__,
i_force_xenon_behavior = __ForceXenonBehavior__,
vc_db_list = '__DbList__',
i_delete_delay_seconds = __DeleteDelaySeconds__,
ti_revoke_cross_platform = __RevokeCrossPlatform__
WHERE i_title_id = 0x__TitleId__";

            StringBuilder updateCmdSb = new StringBuilder(UPDATE_TEMPLATE);
            updateCmdSb.Replace("__SessionExpiration__", matchTitle.SessionExpiration.ToString());
            updateCmdSb.Replace("__ForceXenonBehavior__", GetStringValueOrNULL(matchTitle.ForceXenonBehavior));
            updateCmdSb.Replace("__DbList__", matchTitle.DbList);
            updateCmdSb.Replace("__DeleteDelaySeconds__", GetStringValueOrNULL(matchTitle.DeleteDelaySeconds));
            updateCmdSb.Replace("__RevokeCrossPlatform__", GetStringValueOrNULL(matchTitle.RevokeCrossPlatform));
            updateCmdSb.Replace("__TitleId__", matchTitle.TitleId.ToString("X"));

            lock (_conn)
            {
                SqlCommand command = _conn.CreateCommand();
                command.CommandText = updateCmdSb.ToString();
                int rowsAffected = command.ExecuteNonQuery();
                if (rowsAffected != 1)
                {
                    throw new Exception("UpdateMatchTitle: rowsAffected != 1; rowsAffected == " + rowsAffected);
                }
            }
        }

        /// <summary>
        /// Returns all title strings from the t_stringsvr_strings table for the specified title.
        /// </summary>
        /// <param name="titleId">Title ID</param>
        /// <returns>
        /// A collection of StringServerString objects representing each title string.
        /// </returns>
        public StringServerStrings GetTitleStrings(uint titleId)
        {
            StringServerStrings titleStrings = new StringServerStrings();

            lock (_conn)
            {
                SqlDataReader reader = null;
                SqlCommand command = null;
                
                try
                {
                    command = _conn.CreateCommand();
                    command.CommandText = "SELECT * FROM t_stringsvr_strings WHERE i_title_id=0x" +
                        titleId.ToString("x") + " AND i_string_id=0";

                    reader = command.ExecuteReader();
                    while (reader.Read())
                    {
                        StringServerString titleString = new StringServerString();
                        titleString.TitleId = (uint)reader.GetInt32(reader.GetOrdinal("i_title_id"));
                        titleString.StringId = reader.GetInt32(reader.GetOrdinal("i_string_id"));
                        titleString.Locale = reader.GetString(reader.GetOrdinal("vc_locale"));
                        titleString.Changed = reader.GetDateTime(reader.GetOrdinal("dt_modified"));
                        titleString.Expires = reader.GetDateTime(reader.GetOrdinal("dt_expire"));
                        titleString.Value = reader.GetString(reader.GetOrdinal("nvc_text"));
                        titleStrings.Add(titleString);
                    }
                }
                finally
                {
                    if (reader != null && !reader.IsClosed)
                    {
                        reader.Close();
                    }
                }
            }

            return titleStrings;
        }

        /// <summary>
        /// Returns all strings in the t_stringsvr_strings table for a specified StringID
        /// </summary>
        /// <param name="stringID">ID of the strings to be returned</param>
        /// <returns>A collection of StringServerString objects representing each title string.</returns>
        /// <remarks>This method returns all strings for a specified StringID that are in t_stringsvr_strings
        /// without regard to the titleID assigned to the string
        /// </remarks>
        public StringServerStrings GetStringsByID(uint stringID)
        {
            StringServerStrings titleStrings = new StringServerStrings();

            lock (_conn)
            {
                SqlDataReader reader = null;
                SqlCommand command = null;
                
                try
                {
                    command = _conn.CreateCommand();
                    command.CommandText = String.Format("SELECT * FROM t_stringsvr_strings WHERE i_string_id={0}", stringID);

                    reader = command.ExecuteReader();
                    while (reader.Read())
                    {
                        StringServerString titleString = new StringServerString();
                        titleString.TitleId = (uint)reader.GetInt32(reader.GetOrdinal("i_title_id"));
                        titleString.StringId = reader.GetInt32(reader.GetOrdinal("i_string_id"));
                        titleString.Locale = reader.GetString(reader.GetOrdinal("vc_locale"));
                        titleString.Changed = reader.GetDateTime(reader.GetOrdinal("dt_modified"));
                        titleString.Expires = reader.GetDateTime(reader.GetOrdinal("dt_expire"));
                        titleString.Value = reader.GetString(reader.GetOrdinal("nvc_text"));
                        titleStrings.Add(titleString);
                    }
                }
                finally
                {
                    if (reader != null && !reader.IsClosed)
                    {
                        reader.Close();
                    }
                }
            }

            return titleStrings;
        }

        /// <summary>
        /// Retrieves the leaderboard definitions for a specified Title ID
        /// </summary>
        /// <param name="titleId">Title Id</param>
        /// <returns>A collection of Leaderboard objects.</returns>
        public LeaderboardCollection GetLeaderboards(uint titleId)
        {
            return GetLeaderboardsOrTemplates(titleId, false);
        }

        /// <summary>
        /// Retrieves the Competition Template definitions for the specified Title Id
        /// </summary>
        /// <param name="titleId">Xbox1 Title Id</param>
        /// <returns>
        /// A collection of Leaderboard objects with the IsCompetitionTemplate member set to true.
        /// </returns>
        public LeaderboardCollection GetCompetitionTemplates(uint titleId)
        {
            return GetLeaderboardsOrTemplates(titleId, true);
        }

        /// <summary>
        /// Retrieves either leaderboard definitions or competition template definitions for
        /// the given title id.
        /// </summary>
        /// <param name="titleId">Title Id</param>
        /// <param name="isTemplate">Flag indicating whether to retrieve leaderboards or competition templates</param>
        /// <returns>A collection of Leaderboard objects</returns>
        private LeaderboardCollection GetLeaderboardsOrTemplates(uint titleId, bool isTemplate)
        {
            LeaderboardCollection lbs = new LeaderboardCollection();

            lock(_conn)
            {
                SqlDataReader reader = null;
                SqlCommand command = null;
                string idColName;

                command = _conn.CreateCommand();
                command.CommandType = CommandType.Text;
                if (isTemplate)
                {
                    command.CommandText = "SELECT * FROM t_stats_competition_templates WHERE i_title_id=0x" + titleId.ToString("x8");
                    idColName = "i_comp_templ_id";
                }
                else
                {
                    command.CommandText = "SELECT * FROM t_stats_leaderboards WHERE i_title_id=0x" + titleId.ToString("x8");
                    idColName = "i_lb_id";
                }

                reader = command.ExecuteReader();
                try
                {
                    while (reader.Read())
                    {
                        Leaderboard lb = new Leaderboard();
                        lb.TitleId = (uint)reader.GetInt32(reader.GetOrdinal("i_title_id"));
                        lb.LeaderboardId = reader.GetInt32(reader.GetOrdinal(idColName));
                        lb.ResetType = reader.GetInt32(reader.GetOrdinal("i_reset_type"));
                        lb.Top100 = Convert.ToBoolean(reader.GetByte(reader.GetOrdinal("ti_top_100")));
                        lb.IsTeamLb = Convert.ToBoolean(reader.GetByte(reader.GetOrdinal("ti_is_team_lb")));
                        lb.RequiresArbitration = Convert.ToBoolean(reader.GetByte(reader.GetOrdinal("ti_req_arb")));
                        lb.DecayDays = reader.GetInt32(reader.GetOrdinal("i_decay_days"));
                        lb.EloBase = reader.GetString(reader.GetOrdinal("c_Elo_E"));
                        lb.EloK = reader.GetInt32(reader.GetOrdinal("i_Elo_K"));
                        lb.EloNew = reader.GetInt32(reader.GetOrdinal("i_Elo_New"));
                        lb.EloCTable = reader.GetString(reader.GetOrdinal("vc_Elo_C_table"));
                        lb.AttachCount = reader.GetInt32(reader.GetOrdinal("i_attach_count"));
                        lb.MaxAttachSize = reader.GetInt32(reader.GetOrdinal("i_max_attach_size"));
                        lb.LastReset = isTemplate ? DateTime.MinValue : reader.GetDateTime(reader.GetOrdinal("dt_last_reset"));
                        lb.IsCompetitionTemplate = isTemplate;
                        lbs.Add(lb);
                    }
                }
                finally
                {
                    if (reader != null)
                    {
                        reader.Close();
                    }
                }
            }

            return lbs;
        }

        public void PropSgScript(string scriptName, string script, byte[] binaryBlob)
        {
            PropSgScript(scriptName, true, script, binaryBlob, true, true);
        }
        public void PropSgScript(string scriptName, string script, byte[] binaryBlob, bool kick, bool timeout)
        {
            PropSgScript(scriptName, true, script, binaryBlob, kick, timeout);
        }
        public void PropSgScript(string scriptName, bool enabled, string script, byte[] binaryBlob, bool kick, bool timeout)
        {
            if (scriptName == null || scriptName == "")
                throw new Exception("scriptName must not be null");

            // Delete it first just to be safe
            RemoveSgScript(scriptName);

            SqlCommand cmd = new SqlCommand();
            cmd.Connection = _conn;
            cmd.CommandType = CommandType.Text;
            cmd.CommandText = 
                "INSERT INTO dbo.t_sg_scripts (vc_script_name, ti_enabled, txt_script, im_blob, ti_chal_kick_enabled, ti_chal_timeout_enabled) \n" +
                "VALUES (@vc_script_name, " + (enabled ? 1 : 0) + ", @txt_script, @im_blob, " + (kick ? 1 : 0) + ", " + (timeout ? 1 : 0) + ")";
            cmd.Parameters.Add("@vc_script_name", SqlDbType.NVarChar).Value = scriptName;
            cmd.Parameters.Add("@txt_script", SqlDbType.Text).Value = script == null ? (object)DBNull.Value : (object)script;
            cmd.Parameters.Add("@im_blob", SqlDbType.Image).Value = binaryBlob == null ? (object)DBNull.Value : (object)binaryBlob;

            int rows = cmd.ExecuteNonQuery();
        }

        public bool RemoveSgScript(string scriptName)
        {
            if (scriptName == null || scriptName == "")
                throw new Exception("scriptName must not be null");

            SqlCommand cmd = new SqlCommand();
            cmd.Connection = _conn;
            cmd.CommandType = CommandType.Text;
            cmd.CommandText = 
                "DELETE dbo.t_sg_scripts \n" +
                "WHERE vc_script_name = @vc_script_name";
            cmd.Parameters.Add("@vc_script_name", SqlDbType.NVarChar).Value = scriptName;

            int rows = cmd.ExecuteNonQuery();

            return rows > 0;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\Database\ProfileWS.cs ===
using System;
using System.Collections;
using System.Data;
using System.Data.SqlTypes;
using System.Globalization;
using System.Threading;

using Microsoft.Webstore.WstClient;
using xonline.common.sql.webstore;
using xonline.common.config;
using xonline.common.service;
using xonline.common.protocol;
using Microsoft.Xbox.Privacy.Client;
using ServerTestFramework.LiveService;

namespace ServerTestFramework.Database
{
    /// <summary>
    /// Summary description for ProfileWS.
    /// </summary>
    public class ProfileWS
    {
        private const string ProfileWebstoreApp = "profiledb";

        #region Settings

        static public void ResetUserSetttings(ulong puid)
        {
            // Query for all settings for the puid and remove them from the cache
            CacheRemoveUserSettings(puid);

            string query = "delete from t_user_settings where bi_user_puid='" + puid.ToString() + "'";

            WebstoreDB.ExecuteSQLNonQuery(ProfileWebstoreApp, query, puid);

            try
            {
                PrivacyClientInternal client = new PrivacyClientInternal(new XConfig().GetVirtualInterface("privacy_int"));
                client.SetProfilePrivacy(puid, 0);
            }
            catch (Exception)
            {
                // This can throw a valid exception when we're using made-up users
            }

            System.Threading.Thread.Sleep(100);
        }

        public static bool SetUserProfileItemDirect(uint titleId, ulong userId, DateTime changeTime, uint settingId, byte[] value)
        {
            int rowsModified = 0;

            using (WSClient wsClient = new WSClient(ProfileWebstoreApp, CmdType.WRITEONLY_COMMANDTYPE))
            {
                wsClient.ClearParameters();
                wsClient.Partition = wsClient.CalcPartition(userId);

                wsClient.StoredProc = "p_user_settings_write";

                wsClient.AddParameter("@bi_user_puid", userId);
                wsClient.AddParameter("@si_hash_bucket", wsClient.Partition);

                using (DataTable dtUserSettings = new DataTable())
                {
                    dtUserSettings.Locale = CultureInfo.InvariantCulture;

                    dtUserSettings.Columns.Add("bi_user_piud", typeof(long));
                    dtUserSettings.Columns.Add("i_title_id", typeof(int));
                    dtUserSettings.Columns.Add("i_setting_id", typeof(int));
                    dtUserSettings.Columns.Add("vb_value", typeof(byte[]));
                    dtUserSettings.Columns.Add("dt_change_datetime", typeof(DateTime));

                    if (changeTime < (DateTime)SqlDateTime.MinValue)
                    {
                        changeTime = (DateTime)SqlDateTime.MinValue;
                    }

                    dtUserSettings.Rows.Add(
                        (long)userId,
                        (int)titleId,
                        (int)settingId,
                        value,
                        changeTime);

                    wsClient.Parameters.AddWithValue("@user_settings", dtUserSettings);

                    using (WstDataReader reader = wsClient.Execute())
                    {
                        if (reader.Read())
                        {
                            rowsModified = (int)reader["i_total_count"];
                        }
                    }
                }

                return (rowsModified == 1);
            }
        }

        public static byte[] StatsGetUserSettings(uint titleId, ulong userId, uint settingId)
        {
            WstDataReader reader;

            using (WSClient wsClient = new WSClient(ProfileWebstoreApp, CmdType.WRITETHENREAD_COMMANDTYPE))
            {
                using (DataTable dtUserSettings = new DataTable())
                {
                    dtUserSettings.Locale = CultureInfo.InvariantCulture;

                    dtUserSettings.Columns.Add("bi_user_puid", typeof(long));
                    dtUserSettings.Columns.Add("i_title_id", typeof(int));
                    dtUserSettings.Columns.Add("i_setting_id", typeof(int));
                    dtUserSettings.Columns.Add("vb_value", typeof(byte[]));
                    dtUserSettings.Columns.Add("dt_change_datetime", typeof(DateTime));

                    dtUserSettings.Rows.Add(
                        (long)userId,
                        (int)titleId,
                        (int)settingId,
                        null,
                        null);

                    wsClient.ClearParameters();
                    wsClient.StoredProc = "p_user_settings_read";
                    wsClient.Partition = wsClient.CalcPartition(userId);

                    wsClient.Parameters.AddWithValue("@user_settings", dtUserSettings);

                    reader = wsClient.Execute();

                    byte[] data = null;
                    // populate the values back into the settings items
                    try
                    {
                        int valueOrd = reader.GetOrdinal("vb_value");

                        data = (byte[])reader.GetSqlBinary(valueOrd);
                    }
                    finally
                    {
                        reader.Close();
                        dtUserSettings.Rows.Clear();
                    }

                    return data;
                }
            }
        }

        #endregion // Settings

        #region ConsoleAuditList

        // For Console Audit List API tests, need to clear out the users
        static public void ResetUserConsoleAuditList(ulong puid)
        {
            // Clear out all the console audit list rows for the user specified
            string query = "delete from t_user_console_audit_list where bi_user_puid='" + puid.ToString() + "'";
            WebstoreDB.ExecuteSQLNonQuery(ProfileWebstoreApp, query, puid);

            Thread.Sleep(50);
        }

        // For Console Audit List API tests, validation of row count for upload's
        static public int UserConsoleAuditListCount(ulong puid)
        {
            int count = 0;
            // Clear out all the console audit list rows for the user specified
            string query = "select count(*) from t_user_console_audit_list where bi_user_puid='" + puid.ToString() + "'";
            count = (int)WebstoreDB.ExecuteSQLScalar(ProfileWebstoreApp, query, puid);
            Thread.Sleep(50);
            return count;
        }

        // For Console Audit List API tests, validation of the i_first_seen_ordinal column for uploads
        static public int UserConsoleAuditListFirstSeenOrdinalValue(ulong puid, ulong uploadingconsoleId, ulong signingconsoleId, ulong machineconsoleId)
        {
            int retFirstSeenOrdinal = 0;
            // Clear out all the console audit list rows for the user specified
            string query = "select i_first_seen_ordinal from t_user_console_audit_list where bi_user_puid='" + puid.ToString() + "'";
            query += " and bi_uploading_machine_console_id=" + uploadingconsoleId + " and bi_signing_machine_console_id=" + signingconsoleId + " and bi_machine_console_id=" + machineconsoleId;

            using (WSClient ws = new WSClient(ProfileWebstoreApp, CmdType.WRITETHENREAD_COMMANDTYPE))
            {
                for (int p = 0; p < ws.PhysicalPartitions; p++)
                {
                    ws.ClearParameters();
                    ws.PhysicalPartition = p;
                    ws.CommandSql = query;

                    using (WstDataReader myDataReader = ws.Execute())
                    {
                        if (myDataReader.Read())
                        {
                            // I only care about this field for the validation
                            retFirstSeenOrdinal = Convert.ToInt32(myDataReader.GetValue(myDataReader.GetOrdinal("i_first_seen_ordinal")));
                        }

                        myDataReader.Close();
                    }
                }
            }

            return retFirstSeenOrdinal;
        }

        #endregion // ConsoleAuditList


        // With Acceleration, we need to remove each key individually (and this is just more correct anyway)
        // So this function will select all the settings for a user and then remove them all from the cache
        // Call this function BEFORE clearing the database obviously.
        static public void CacheRemoveUserSettings(ulong puid)
        {
            ArrayList settings = new ArrayList();
            byte[][] keys;
            string readquery = "select i_setting_id, i_title_id from t_user_settings where bi_user_puid='" + puid.ToString() + "'";

            Acceleration accCache = new Acceleration(Interface.ProfileCache);

            using (WSClient ws = new WSClient(ProfileWebstoreApp, CmdType.WRITETHENREAD_COMMANDTYPE))
            {
                for (int p = 0; p < ws.PhysicalPartitions; p++)
                {
                    ws.ClearParameters();
                    ws.PhysicalPartition = p;
                    ws.CommandSql = readquery;

                    using (WstDataReader myDataReader = ws.Execute())
                    {
                        while (myDataReader.Read())
                        {
                            uint title = (uint)Convert.ToInt32(myDataReader.GetValue(myDataReader.GetOrdinal("i_title_id")));
                            uint settingId = (uint)Convert.ToInt32(myDataReader.GetValue(myDataReader.GetOrdinal("i_setting_id")));
                            settings.Add(ProfileDefs.BuildCacheKey(settingId, title, puid));
                        }

                        // Now that we have all the settings, remove them
                        if (settings.Count != 0)
                        {
                            keys = (byte[][])settings.ToArray(typeof(byte[]));
                            accCache.Remove(keys);
                        }

                        myDataReader.Close();
                    }
                }
            }

            return;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\Database\LiveRegistry.cs ===
using ServerTestFramework.Utilities;

using System.Data.SqlClient;

namespace ServerTestFramework.Database
{
    public class LiveRegistrySetting
    {
        public string ClientConfig;
        public ushort Build;
        public ushort Qfe;
        public System.Guid Group;
        public string Setting;
        public string Value;

        public override bool Equals(object otherObject)
        {
            if (!(otherObject is LiveRegistrySetting))
            {
                return false;
            }

            LiveRegistrySetting other=(LiveRegistrySetting)otherObject;

            return ClientConfig==other.ClientConfig &&
                Build==other.Build &&
                Qfe==other.Qfe &&
                Group==other.Group &&
                Setting==other.Setting &&
                Value==other.Value;
        }

        public override int GetHashCode()
        {
            return Build+Qfe;
        }

        public override string ToString()
        {
            return "LiveRegistrySetting("
                +"ClientConfig="+ClientConfig
                +" Build="+Build
                +" Qfe="+Qfe
                +" Group="+Group
                +" Setting="+Setting
                +" Value="+Value
                +")";
        }
    }

    /// <summary> Utilities for manipulating livehive. </summary>
    public class LiveRegistry
    {
        public static void AddSettings(System.Collections.Generic.IEnumerable<LiveRegistrySetting> settings)
        {
            foreach (LiveRegistrySetting s in settings)
            {
                AddSetting(s.ClientConfig, s.Build, s.Qfe, s.Group, s.Setting, s.Value);
            }
        }

        public static void AddSetting(string clientConfig, ushort build, ushort qfe, System.Guid group, string setting, string value)
        {
            string query=QueryGenerator.GenerateUpdateOrInsert(
                "t_live_registry_settings",
                new string[]{"vc_environment",     "vc_client_config", "si_build", "si_qfe", "guid_beta_group_id", "vc_setting", "vc_value"},
                new object[]{Global.XEnv.GetEnv(), clientConfig,       build,      qfe,      group,                setting,      value},
                new string[]{"vc_environment",     "vc_client_config", "si_build", "si_qfe", "guid_beta_group_id", "vc_setting"});

            StaticNpdb.ExecuteNonQuery(query);
        }

        public static LiveRegistrySetting[] GetSettingsForClientConfig(string clientConfig)
        {
            using (Npdb npdb=new Npdb())
            {
                npdb.ConnectToServer();

                SqlDataReader reader;
                npdb.ReadData("select si_build, si_qfe, guid_beta_group_id, vc_setting, vc_value from t_live_registry_settings where vc_environment="+QueryGenerator.EvaluateObject(Global.XEnv.GetEnv())+" and vc_client_config="+QueryGenerator.EvaluateObject(clientConfig), out reader);

                System.Collections.Generic.List<LiveRegistrySetting> list=new System.Collections.Generic.List<LiveRegistrySetting>();

                while (reader.Read())
                {
                    LiveRegistrySetting s=new LiveRegistrySetting();
                    s.ClientConfig=clientConfig;
                    s.Build=(ushort)(short)reader[0];
                    s.Qfe=(ushort)(short)reader[1];
                    s.Group=(System.Guid)reader[2];
                    s.Setting=(string)reader[3];
                    s.Value=(string)reader[4];

                    list.Add(s);
                }

                return list.ToArray();
            }
        }

        public static LiveRegistrySetting[] GetAllSettings()
        {
            using (Npdb npdb=new Npdb())
            {
                npdb.ConnectToServer();

                SqlDataReader reader;
                npdb.ReadData("select vc_client_config, si_build, si_qfe, guid_beta_group_id, vc_setting, vc_value from t_live_registry_settings where vc_environment="+QueryGenerator.EvaluateObject(Global.XEnv.GetEnv()), out reader);

                System.Collections.Generic.List<LiveRegistrySetting> list=new System.Collections.Generic.List<LiveRegistrySetting>();

                while (reader.Read())
                {
                    LiveRegistrySetting s=new LiveRegistrySetting();
                    s.ClientConfig=(string)reader[0];
                    s.Build=(ushort)(short)reader[1];
                    s.Qfe=(ushort)(short)reader[2];
                    s.Group=(System.Guid)reader[3];
                    s.Setting=(string)reader[4];
                    s.Value=(string)reader[5];

                    list.Add(s);
                }

                return list.ToArray();
            }
        }

        public static void RemoveSettingsForClientConfig(string clientConfig)
        {
            StaticNpdb.ExecuteNonQuery("delete from t_live_registry_settings where vc_environment="+QueryGenerator.EvaluateObject(Global.XEnv.GetEnv())+" and vc_client_config="+QueryGenerator.EvaluateObject(clientConfig));
        }
    };
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\Database\ProgressWS.cs ===
using System;
using System.Collections;
using System.Data;
using System.Threading;

using Microsoft.Webstore.WstClient;
using xonline.common.sql.webstore;
using xonline.common.config;
using xonline.common.service;
using xonline.common.protocol;
using Microsoft.Xbox.Privacy.Client;
using ServerTestFramework.LiveService;

namespace ServerTestFramework.Database
{
    /// <summary>
    /// Summary description for ProgressWS.
    /// </summary>
    public class ProgressWS
    {
        private const string ProgressWebstoreApp = "progressdb";
        private const string ProfileWebstoreApp = "profiledb";

        #region Titles

        static public void AddLegacyTitleRow(ulong user, int title, DateTime logontime, int sequence)
        {
            using (WSClient ws = new WSClient(ProgressWebstoreApp, CmdType.WRITEONLY_COMMANDTYPE))
            {
                ws.PartitionType = WstPartitionType.Logical;
                ws.SetHashVal(user);

                string query = "INSERT INTO [t_user_titles]([bi_user_puid], [i_title_id], [i_flags], [dt_last_logon], [i_sequence], [i_gamerscore], [i_achievement_count], [si_hash_bucket], [dt_Change_datetime])";
                query = query + " VALUES(" + user + "," + title + ", 65536,'" + logontime.ToString() + "'," + sequence + ", 0, 0," + ws.Partition + ", getutcDate())";
                ws.CommandSql = query;

                ws.ExecuteNonQuery();
            }

            Thread.Sleep(50);
        }

        static public void AddTitleToMsgTitle(ulong puid, int title, DateTime lastplayed)
        {
            using (WSClient ws = new WSClient(ProgressWebstoreApp, CmdType.WRITEONLY_COMMANDTYPE))
            {
                ws.PartitionType = WstPartitionType.Logical;
                ws.SetHashVal(puid);

                string query = "insert into t_user_titles(bi_user_puid, i_title_id, i_flags, dt_last_logon, i_sequence, i_gamerscore, i_achievement_count, si_hash_bucket, dt_change_datetime)";
                query += "values (" + puid + ", " + title + ", 0x00000000, '" + lastplayed.ToString() + "', 0, 0, 0, " + ws.Partition + ", getutcdate())";
                ws.CommandSql = query;

                ws.ExecuteNonQuery();
            }

            Thread.Sleep(50);
        }

        static public void ResetUsertitles(ulong puid)
        {
            // Query for all settings for the puid and remove them from the cache
            CacheRemoveUserSettings(puid);

            string query = "delete from t_user_titles where bi_user_puid='" + puid.ToString() + "'";
            WebstoreDB.ExecuteSQLNonQuery(ProgressWebstoreApp, query, puid);

            Thread.Sleep(50);
        }

        public static void SetLastTitleToDemoTitle(ulong user, int titleid)
        {
            string query = " update t_user_titles set i_flags = 0 where bi_user_puid = " + user + " and i_title_id =" + titleid;
            WebstoreDB.ExecuteSQLNonQuery(ProgressWebstoreApp, query, user);
        }
        
        #endregion // Titles

        #region Achievement

        static public void AddLegacyAchievementRow(ulong puid, int title, int achievement_id, int sequence, DateTime achieved)
        {
            using (WSClient ws = new WSClient(ProgressWebstoreApp, CmdType.WRITEONLY_COMMANDTYPE))
            {
                ws.PartitionType = WstPartitionType.Logical;
                ws.SetHashVal(puid);

                string query = "INSERT INTO [t_achievements]([i_title_id], [bi_puid], [i_achievement_id], [dt_achieved], [i_sequence], [i_flags], [si_hash_bucket], [dt_Change_datetime], [dt_max_time], [dt_last_sync_time])";
                query += "VALUES(" + title + ", " + puid + ", " + achievement_id + ",'" + achieved + "', " + sequence + ", 196608, " + ws.Partition + ", getutcdate(), null, null)";
                ws.CommandSql = query;

                ws.ExecuteNonQuery();
            }

            Thread.Sleep(50);
        }

        static public void MarkAchievementNotAchievable(ulong puid, uint titleid, uint achId)
        {
            // Mark the achievement for the user as Not Achievable (Cheater)
            string query = "update t_achievements set i_flags=((i_flags & 0xFFF7FFFF) | 0x00040000) where bi_puid=" + puid.ToString();
            query += " and i_title_id=" + titleid.ToString() + " and i_achievement_id=" + achId.ToString();
            WebstoreDB.ExecuteSQLNonQuery(ProgressWebstoreApp, query, puid);

            Thread.Sleep(50);
        }

        static public bool RecalcUsersTitleGamerscore(uint titleId, ulong userId, int gamerscore, int achievements, DateTime syncTimeUtc)
        {
            using (WSClient wsClient = new WSClient(ProgressWebstoreApp, CmdType.WRITEONLY_COMMANDTYPE))
            {
                wsClient.ClearParameters();

                wsClient.StoredProc = "p_usertitles_update_gamerscore";
                wsClient.Partition = wsClient.CalcPartition(userId);

                wsClient.AddParameter("@bi_user_puid", userId);
                wsClient.AddParameter("@i_title_id", titleId);
                wsClient.AddParameter("@i_achievement_count", achievements);
                wsClient.AddParameter("@i_gamerscore", gamerscore);
                wsClient.AddParameter("@dt_last_sync_time", syncTimeUtc);

                int rowsAffected = wsClient.ExecuteNonQuery();

                return rowsAffected >= 1 ? true : false;
            }

            ////using (WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITEONLY_COMMANDTYPE))
            ////{
            ////    ws.PartitionType = WstPartitionType.Logical;
            ////    ws.StoredProc = "dbo.p_stats_gamerscore_update";
            ////    ws.SetHashVal(userPuid);

            ////    ws.AddParameter(ParamType.RETVAL, "@ret", 0);
            ////    ws.AddParameter("@bi_user_puid", userPuid);
            ////    ws.AddParameter("@i_title_id", titleId);
            ////    ws.AddParameter("@i_gamerscore", gamerscore);
            ////    ws.AddParameter("@i_achievements", achievements);
            ////    ws.AddParameter("@si_hash_bucket", ws.Partition);

            ////    int rowsAffected = ws.ExecuteNonQuery();
            ////    if (rowsAffected >= 1)
            ////        return true;
            ////    else
            ////        return false;
            ////}
        }

        static public void ResetUserAchievements(ulong puid)
        {
            // Query for all settings for the puid and remove them from the cache
            CacheRemoveUserSettings(puid);

            string query = "delete from t_achievements where bi_puid='" + puid.ToString() + "'";
            WebstoreDB.ExecuteSQLNonQuery(ProgressWebstoreApp, query, puid);
        }
        
        #endregion // Achievement

        #region Avatar

        static public void InsertPurchasedAvatarAsset(ulong puid, Guid avuid)
        {
            using (WSClient ws = new WSClient(ConfigUtil.GetUserCommerceWebstoreApp(), CmdType.WRITEONLY_COMMANDTYPE))
            {
                ws.PartitionType = WstPartitionType.Logical;
                ws.Partition = ws.CalcPartition(puid);
                ws.CommandSql = @"INSERT [t_user_purchased_avatar_items]
                                (bi_user_puid, uid_avatar_item_id, si_hash_bucket, dt_Change_datetime)
                                VALUES(@bi_user_puid, @uid_avatar_item_id, @si_hash_bucket, getutcdate())";
                ws.AddParameter("@bi_user_puid", puid);
                ws.AddParameter("@uid_avatar_item_id", avuid);
                ws.AddParameter("@si_hash_bucket", ws.Partition);

                ws.ExecuteNonQuery();
            }

            Thread.Sleep(50);
        }

        static public void MarkAvatarAssetNotAchievable(ulong puid, uint titleid, uint avatarOrdinal)
        {
            // Mark the avatar award for the user as Not Achievable (Cheater)
            string query = "update t_awarded_avatar_items set i_status=((i_status & 0xFFF7FFFF) | 0x00040000) where bi_user_puid=" + puid.ToString();
            query += " and i_title_id=" + titleid.ToString() + " and i_asset_ordinal=" + avatarOrdinal.ToString();
            WebstoreDB.ExecuteSQLNonQuery(ProgressWebstoreApp, query, puid);

            Thread.Sleep(50);
        }

        static public void ResetUserAvatarAssets(ulong puid)
        {
            // Clear out all the award avatar items for the user specified
            string query = "delete from t_awarded_avatar_items where bi_user_puid='" + puid.ToString() + "'";
            WebstoreDB.ExecuteSQLNonQuery(ProgressWebstoreApp, query, puid);

            Thread.Sleep(50);
        }

        static public void ResetUserAvatarPurchasedAssets(ulong puid)
        {
            // Clear out all the award avatar items for the user specified
            string query = "delete from t_user_purchased_avatar_items where bi_user_puid='" + puid.ToString() + "'";
            UserCommercedbWS.ExecuteSQLNonQuery(query, puid);

            Thread.Sleep(50);
        }

        #endregion // Avatar


        // With Acceleration, we need to remove each key individually (and this is just more correct anyway)
        // So this function will select all the settings for a user and then remove them all from the cache
        // Call this function BEFORE clearing the database obviously.
        static public void CacheRemoveUserSettings(ulong puid)
        {
            ArrayList settings = new ArrayList();
            byte[][] keys;
            string readquery = "select i_setting_id, i_title_id from t_user_settings where bi_user_puid='" + puid.ToString() + "'";

            Acceleration accCache = new Acceleration(Interface.ProfileCache);

            using (WSClient ws = new WSClient(ProfileWebstoreApp, CmdType.WRITETHENREAD_COMMANDTYPE))
            {
                for (int p = 0; p < ws.PhysicalPartitions; p++)
                {
                    ws.ClearParameters();
                    ws.PhysicalPartition = p;
                    ws.CommandSql = readquery;

                    using (WstDataReader myDataReader = ws.Execute())
                    {
                        while (myDataReader.Read())
                        {
                            uint title = (uint)Convert.ToInt32(myDataReader.GetValue(myDataReader.GetOrdinal("i_title_id")));
                            uint settingId = (uint)Convert.ToInt32(myDataReader.GetValue(myDataReader.GetOrdinal("i_setting_id")));
                            settings.Add(ProfileDefs.BuildCacheKey(settingId, title, puid));
                        }

                        // Now that we have all the settings, remove them
                        if (settings.Count != 0)
                        {
                            keys = (byte[][])settings.ToArray(typeof(byte[]));
                            accCache.Remove(keys);
                        }

                        myDataReader.Close();
                    }
                }
            }

            return;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\Database\Ppa.cs ===
using System;
using System.Security.Cryptography;
using System.Text;
using System.IO;

namespace ServerTestFramework.Database
{
    public class Ppa
    {
        public const int XONLINE_GAMERTAG_SIZE = 16;
        public static SHA1 sha = new SHA1Managed();

        private static byte[] MakeHashableName(string s)
        {
            byte[] tempbytes = new ASCIIEncoding().GetBytes(s.ToUpper());

            byte[] data = new byte[16];
            tempbytes.CopyTo(data, 0);

            return data;
        }

        public static byte[] CalculateNameSha(string s)
        {
            return sha.ComputeHash(MakeHashableName(s));
        }

        public static byte[] CalculateVoucherSha(string s)
        {
            // Format:  nnnnn-nnnnn-nnnnn-nnnnn-nnnnn\0
            // Must be unicode, not ascii
            // Don't forget the null terminator
            // Must be uppercase
            // Must have "-" every 5 characters
            byte[] data = new UnicodeEncoding().GetBytes(s.ToUpper() + "\0");
            return sha.ComputeHash(data);
        }

        public static byte[] GenSppa1(string name, byte[] key)
        {
            byte[] hashablename = MakeHashableName(name);

            // Compute SPPA1
            HMACSHA1 hmac = new HMACSHA1(key);
            CryptoStream cs = new CryptoStream(Stream.Null, hmac, CryptoStreamMode.Write);
            cs.Write(hashablename, 0, hashablename.Length);
            cs.Close();

            SHA1 sha = new SHA1Managed();
            byte[] shahmac = sha.ComputeHash(hmac.Hash);
            hmac.Clear();
            sha.Clear();
            return shahmac;
        }

        public static byte[] GenPpa2(string name, byte[] key)
        {
            byte[] hashablename = MakeHashableName(name);
            byte[] doublename = new byte[32];
            hashablename.CopyTo(doublename, 0);
            hashablename.CopyTo(doublename, 16);

            HMACSHA1 hmac = new HMACSHA1(key);
            byte[] longppa2 = hmac.ComputeHash(doublename);
            hmac.Clear();

            byte[] ppa2 = new byte[8];
            for (int i = 0; i < 8; i++)
                ppa2[i] = longppa2[i];

            return ppa2;
        }

        private static byte[] TruncateBytes(byte[] b, int length)
        {
            byte[] t = new byte[length];
            for (int i = 0; i < t.Length; i++)
            {
                t[i] = b[i];
            }
            return t;
        }

        public static byte[] DecryptKeyWithKek(byte[] iv, byte[] encData)
        {

            byte[] kek = ServerTestFramework.LiveService.Auth.ServiceKeys.GetServiceKey(ServerTestFramework.LiveService.Auth.ServiceKeys.Key_KEK);
            RijndaelManaged aes = new RijndaelManaged();
            aes.BlockSize = 128;
            aes.KeySize = 256;
            aes.Padding = PaddingMode.None;

            // create a buffer for the raw data
            byte[] rawKey = new byte[encData.Length];

            MemoryStream ms = new MemoryStream(rawKey);
            ICryptoTransform cryptTrans = aes.CreateDecryptor(kek, iv);
            CryptoStream cs = new CryptoStream(ms, cryptTrans, CryptoStreamMode.Write);
            cs.Write(encData, 0, encData.Length);
            cs.Close();
            return rawKey;
        }

        public static byte[] DecryptKey(byte[] kek, byte[] iv, byte[] encData)
        {

            RijndaelManaged aes = new RijndaelManaged();
            aes.BlockSize = 128;
            aes.KeySize = 256;
            aes.Padding = PaddingMode.None;
            // create a buffer for the raw data
            byte[] rawKey = new byte[encData.Length];

            MemoryStream ms = new MemoryStream(rawKey);
            ICryptoTransform cryptTrans = aes.CreateDecryptor(kek, iv);
            CryptoStream cs = new CryptoStream(ms, cryptTrans, CryptoStreamMode.Write);
            cs.Write(encData, 0, encData.Length);
            cs.Close();
            return rawKey;
        }

        public static void GenerateKey(byte[] kek, byte[] rawkey, out byte[] iv, out byte[] enckey)
        {
            RijndaelManaged aes = new RijndaelManaged();
            aes.BlockSize = 128;
            aes.KeySize = 256;
            aes.Padding = PaddingMode.None;
            aes.GenerateIV();
            iv = aes.IV;
            //iv = unhex("00000000000000000000000000000000");

            enckey = new byte[16];
            MemoryStream keystream = new MemoryStream(enckey);
            CryptoStream cs = new CryptoStream(keystream, aes.CreateEncryptor(kek, iv), CryptoStreamMode.Write);
            cs.Write(rawkey, 0, 16);
            cs.Close();
        }

        private static byte[] unhex(string s)
        {
            byte[] hex = new byte[s.Length / 2];
            for (int i = 0; i < s.Length / 2; i++)
            {
                hex[i] = (byte)((unhex(s[i*2]) << 4) + unhex(s[i*2+1]));
            }
            return hex;
        }

        private static byte unhex(char c)
        {
            if (c >= '0' && c <= '9')
                return (byte)(c - '0');
            else if (c >= 'a' && c <= 'z')
                return (byte)(c - 'a' + 10);
            else if (c >= 'A' && c <= 'Z')
                return (byte)(c - 'A' + 10);
            return 0;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\Database\OLAP.cs ===
//
//  OLAP DB Common Code
//

using System;
using System.Text;
using System.Collections;
using System.Collections.Generic;
using System.Data;
using System.Data.OleDb;
using System.Data.SqlTypes;
using System.Data.SqlClient;
using System.Runtime.InteropServices;
using Microsoft.AnalysisServices;
using Microsoft.AnalysisServices.AdomdClient;   // ADOMD SSAS client

using ServerTestFramework.STFLive.Reporting;


namespace ServerTestFramework.STFLive.Database
{
    [ComVisible(false)]
    public class OLAPDB : ReportingDatabase
    {


        // OLAP related databases have 2 connections, 1 for SSAS and 1 for SQL
        protected OleDbConnection m_OleConnection;      // Ole connection for SSAS
        protected Microsoft.AnalysisServices.Server m_SSASServer;   // Analysis Services Server object
        protected string m_ServerName;

        // ADOMD SSAS Connection
        protected AdomdConnection m_AdoSSASConn;


        public OLAPDB()
        {
            JobQueue = new List<ReportingJob>(10);
            JobThreads = new Hashtable(10);
        }

        ~OLAPDB()
        {
            Close();
        }

        public void ConnectToServer(string serverName)
        {
            // BUGBUG: Is olaprdbtest the appropriate default olap to use?
            this.ConnectToServer(serverName, m_DatabaseName);
        }

        // BUGBUG: Probably should be an enum rather than a string (to reduce the chance that we'll have a bug
        // trying to connect to a non-existant DB when we switch environments)
        public void ConnectToServer(string serverName, string database)
        {
            m_ServerName = serverName;
            m_DatabaseName = database;
            // Open SQL connection to msdb directly since we need this for jobs and there are no SQL databases in Olap Server
            m_SqlConnection = new SqlConnection("server=" + serverName + ";database=msdb;Integrated Security=SSPI");
            m_SqlConnection.Open();
            // Open OLE connection for Olap
            m_OleConnection = new OleDbConnection("Provider=msolap;Data Source=" + serverName + ";Initial Catalog=" + database + ";Integrated Security=SSPI");            
            m_OleConnection.Open();
            // Open SSAS object connection
            m_SSASServer = new Microsoft.AnalysisServices.Server();
            m_SSASServer.Connect(serverName);

            // Open ADOMD SSAS Connection
            m_AdoSSASConn = new AdomdConnection("data source=" + serverName + "; initial catalog=" + database + " ;Integrated Security=SSPI");
            m_AdoSSASConn.Open();

        }

        public void Close()
        {            
            // m_SqlConnection could be null
            if (m_SqlConnection != null && m_SqlConnection.State != ConnectionState.Closed)
            {
                try
                {
                    m_SqlConnection.Close();
                }
                catch
                {
                    // do nothing here
                }
                finally
                {
                    m_SqlConnection = null;
                }
            }
            // m_OleConnection could be null
            if (m_OleConnection != null && m_OleConnection.State != ConnectionState.Closed)
            {
                try
                {
                    m_OleConnection.Close();
                }
                catch
                {
                    // do nothing here
                }
                finally
                {
                    m_OleConnection = null;
                }
            }
            // m_SSASServer could be null
            if (m_SSASServer != null && m_SSASServer.GetConnectionState(false) != ConnectionState.Closed)
            {
                try
                {
                    m_SSASServer.Disconnect();
                }
                catch
                {
                    // nothing
                }
                finally
                {
                    m_SSASServer = null;
                }
            }

            // m_ADoMDSSAS could be null
            if (m_AdoSSASConn != null && m_AdoSSASConn.State != ConnectionState.Closed)
            {
                try
                {
                    m_AdoSSASConn.Close(true);
                }
                catch
                {   // nothing
                }
                finally
                {
                    m_AdoSSASConn = null;
                }
            }


            CloseJobQueueThreads();
        }

        protected SqlConnection SQLConnection
        {
            get { return m_SqlConnection; }
        }

        public System.Data.ConnectionState SQLConnectionState
        {
            get { return m_SqlConnection.State; }
        }

        protected OleDbConnection OlapConnection
        {
            get { return m_OleConnection; }
        }

        public System.Data.ConnectionState OlapConnectionState
        {
            get { return m_OleConnection.State; }
        }

        // ****
        // BUGBUG: This should be changed back to protected once there is an Event created
        // to process an Olap database fully
        // ****
        public Microsoft.AnalysisServices.Server SSASServer
        {
            get { return m_SSASServer; }
        }

        /// <summary>
        /// What type server you are dealing with
        /// </summary>
        public override ReportingMachines ComponentType
        {
            get
            {
                return ReportingMachines.OLAP;
            }
        }

        /// <summary>
        /// The name of the server you are dealing with
        /// </summary>
        public override string ComponentName
        {
            get
            {
                return m_ServerName;
            }
        }

        /// <summary>
        /// API to inject an event
        /// </summary>
        /// <param name="type"></param>
        /// <param name="reportingRefObject"></param>
        /// <returns></returns>
        public override string InjectEvent(ReportingEventType type, out ReportingReferenceObject reportingRefObject)
        {
            reportingRefObject = null;
            return "";
        }

        /// <summary>
        /// API that injects the next event in a series of events
        /// </summary>
        /// <param name="type"></param>
        /// <param name="reportingRefObject"></param>
        /// <returns></returns>
        public override string InjectNextEvent(ReportingEventType type, ref ReportingReferenceObject reportingRefObject)
        {
            reportingRefObject = null;
            return "";
        }

        /// <summary>
        /// Gets a performance counter that is an integer
        /// </summary>
        /// <param name="Counter"></param>
        /// <returns></returns>
        public override int GetIntPerformanceCounter(string Counter)
        {
            return -1;
        }

        /// <summary>
        /// Gets a performance counter that is a floating point number
        /// </summary>
        /// <param name="Counter"></param>
        /// <returns></returns>
        public override float GetFloatPerformanceCounter(string Counter)
        {
            return -0.0f;
        }


        private string m_DatabaseName = "olaprdb";
        /// <summary>
        /// The SQL name of the database (note: NOT THE MACHINE NAME)
        /// </summary>
        public override string DatabaseName
        {
            get
            {
                return m_DatabaseName;
            }
            set
            {
                m_DatabaseName = value;
            }
        }

        /// <summary>
        /// Runs a query against the database (all tables).  Returns data for small tables (less than 20 rows), returns counts for all other tables
        /// </summary>
        /// <returns>Query Results</returns>
        public override string RunDebugQuery()
        {
            // TODO: Implement me
            return "";
        }

        /// <summary>
        /// Runs a query against the database (all tables).  Returns data for small tables (less than 20 rows), returns counts for all other tables
        /// </summary>
        /// <returns>Query Results</returns>
        public override string RunDebugQuery(ReportingReferenceObject reportingRefObject)
        {
            // TODO: Implement me *IF NEEDED*
            return base.RunDebugQuery(reportingRefObject);
        }

        /// <summary>
        /// Runs a query against the OLAP database using ADOMD and returns the query result in resultDataObject
        /// </summary>
        /// <param name="reportingRefObject">RefObject containing the OLAP query to execute</param>
        /// <param name="resultDataObject">Dat object with query results</param>
        /// <returns>Query results in a string</returns>
        public virtual string RunDebugQuery(ReportingReferenceObject reportingRefObject, out ReportingData resultDataObject)
        {
            // Initialize object
            ReportingReferenceObjectFactory factory = ReportingReferenceObjectFactory.Instance;
            resultDataObject = (ReportingData)factory.CreateDataObject(ReportingDataType.OlapGenericData);
           
            // Declare command object to execute SSAS query
            AdomdCommand cmd = new AdomdCommand(reportingRefObject.RunDebugQuery(), m_AdoSSASConn);


            // Execute Command
            object queryResult = cmd.Execute();
            if (queryResult != null)
            {
                // Check the kind of result returned
                if (queryResult is AdomdDataReader)
                {
                    // ADO reader returned
                    AdomdDataReader reader = (AdomdDataReader)queryResult;

                    reader.Close();
                    reader = null;
                }
                else
                {
                    // CellSet returned
                    CellSet reader = (CellSet)queryResult;

                    // Extract first value into 'out' parameter
                    resultDataObject.DataType = ReportingData.InternalDataType.RawData;
                    resultDataObject.RawData = reader.Cells[0].Value;
                }
            }// if restul != null

            cmd = null;

            return "";
        }


        /// <summary>
        /// Runs an Olap query against this database using the data available in the reference objects
        /// </summary>
        /// <param name="reportingRefObject"></param>
        /// <returns></returns>
        public string RunDebugOlapQuery(ReportingReferenceObject reportingRefObject)
        {
            Hashtable queries; 
            string[] query; string returnQuery="";
            Hashtable dataList; DataSet theData;
            //OleDbDataReader reader = null;
            //object[] rawData;
            OleDbDataAdapter adapter = null;
            
            if (m_OleConnection == null)
            {
                // No valid Connection
                throw new Exception("Error: Invalid connection to OLAPDB");
            }        

            // Create a new command
            OleDbCommand cmd = new OleDbCommand();

            // Assign the connection to the command
            cmd.Connection = m_OleConnection;

            try
            {                                
                // Set Timeout
                cmd.CommandTimeout = 300000; // 5 MINUTES WAIT LIMIT

                // Check connection state
                if (m_OleConnection.State != ConnectionState.Open)
                {
                    // Open connection
                    m_OleConnection.Open();
                }
                                

                // Get queries from object
                queries = ((OlapReportData)reportingRefObject).Queries;

                // Initialize result raw data list
                dataList = new Hashtable(queries.Count);

                // Initialize adapter
                adapter = new OleDbDataAdapter();

                for (int i = 0; i < queries.Count; i++)
                {                                      
                    
                    // Assign a query to the commandtext
                    query = (string[])queries[i];
                    
                    cmd.CommandText = query[2];
                    
                    //******
                    // USING DATASETS
                    //******
                    theData = new DataSet(query[0] + query[1]);
                    adapter.SelectCommand = cmd;
                    adapter.Fill(theData);
                    dataList.Add(query[0] + query[1], theData);


                    //******
                    // USING DATA READERS
                    //******
                    //// Execute query
                    //reader = cmd.ExecuteReader();                    
                    //// Read data and populate Raw Data object
                    //while (reader.Read())
                    //{
                    //    rawData = new object[reader.FieldCount];
                    //    reader.GetValues(rawData);
                    //    dataList.Add(query[0] + query[1] + "|" + reader.FieldCount, rawData);
                    //}
                    //reader.Close();
                }
                // Store the Raw Data
                ((OlapReportData)reportingRefObject).RawData = dataList;

            }
            catch (Exception e)
            {
                //OLAP returns "Object reference not set" for invalid parameters.
                //In this case return null for query string 
                string msg = e.ToString();
                if (msg.Contains("Object reference not set"))
                {
                    throw new Exception("*ERROR* Check parameters in OLAP query; " + e.Message);
                }               
                else
                {
                    throw new Exception(e.Message);
                }
            }          
            return returnQuery;
        }

        /// <summary>
        /// Queues a job to be run using the default parameters for that job (specific to that job)
        /// Validates that this job can be run on this server
        /// </summary>
        /// <param name="jobType">Type of job to be run</param>
        /// <returns>Could job be queued</returns>
        public override ReportingJob QueueJob(ReportingJobType jobType)
        {            
            ReportingJobParameters defaultJobParams = null;
            switch (jobType)
            {
                case ReportingJobType.OlapDB_SSASAchievementsDaily: // Daily Achievement SSAS processing job
                    defaultJobParams = new DailySSAS_AchievementsProcessing.DailySSAS_AchievementProcessing_Params();
                    break;
                case ReportingJobType.OlapDB_SSASGameUsageDaily:    // Daily Game Usage SSAS processing job
                    defaultJobParams = new DailySSAS_GameUsageProcessing.DailySSAS_GameUsageProcessing_Params();
                    break;
                case ReportingJobType.OlapDB_SSASCruxUsageDaily:     // Daily Crux Usage SSAS processing job
                    defaultJobParams = new DailySSAS_CruxUsageProcessing.DailySSAS_CruxUsageProcessing_Params();
                    break;
                case ReportingJobType.OlapDB_SSASCDBCruxUsageDaily:     // Daily CDB Crux Usage SSAS processing job
                    defaultJobParams = new DailySSAS_CDBCruxUsageProcessing.DailySSAS_CDBCruxUsageProcessing_Params();
                    break;
                case ReportingJobType.OlapDB_SSASVideoCubeDaily:        // DAILY OLAP VIDEO CUBE processing job
                    defaultJobParams = new DailySSAS_VideoCubeProcessing.DailySSAS_VideoCubeProcessing_Params();
                    break;
                case ReportingJobType.OlapCubeGeneration:            // OlapCubeGeneration - Cube Partition creation job
                    defaultJobParams = new OlapCubeGeneration.OlapCubeGeneration_Params();
                    break;
                default:
                    // Invalid Job Type for this database
                    throw new Exception("Invalid Job Type. This specified job does not exist on this database");
            }

            return QueueJob(jobType, defaultJobParams);
        }

        /// <summary>
        /// Queues a job to be run using the specified parameters for that job (specific to that job)
        /// Validates that this job can be run on this server
        /// </summary>
        /// <param name="jobType">Type of job to be run</param>
        /// <returns>Could job be queued</returns>
        public override ReportingJob QueueJob(ReportingJobType jobType, ReportingJobParameters jobParameters)
        {
            ReportingJob retVal = null; bool jobExists = false;
            
            // Get job factory instance
            ReportingJobFactory jobFactory = ReportingJobFactory.Instance;
            
            // Validate job type for this server            
            switch (jobType)
            {
                // Create job through factory
                case ReportingJobType.OlapDB_SSASAchievementsDaily: // Daily Achievement SSAS processing job
                    retVal = jobFactory.CreateReportingJob(jobType, jobParameters);
                    break;
                case ReportingJobType.OlapDB_SSASGameUsageDaily:    // Daily Game Usage SSAS processing job
                    retVal = jobFactory.CreateReportingJob(jobType, jobParameters);
                    break;
                case ReportingJobType.OlapDB_SSASCruxUsageDaily:     // Daily Crux Usage SSAS processing job
                    retVal = jobFactory.CreateReportingJob(jobType, jobParameters);
                    break;
                case ReportingJobType.OlapDB_SSASCDBCruxUsageDaily:     // Daily CDB Crux Usage SSAS processing job
                    retVal = jobFactory.CreateReportingJob(jobType, jobParameters);
                    break;
                case ReportingJobType.OlapDB_SSASVideoCubeDaily:        // DAILY OLAP VIDEO CUBE USAGE CUBE PROCESSING
                    retVal = jobFactory.CreateReportingJob(jobType, jobParameters);
                    break;
                case ReportingJobType.OlapCubeGeneration:            // OlapCubeGeneration - Cube Partition creation job
                    retVal = jobFactory.CreateReportingJob(jobType, jobParameters);
                    break;
                default:
                    // Invalid Job Type for this database
                    throw new Exception("Invalid Job Type. This specified job does not exist on this database");
            }

            // Enforce synchronized access
            lock (JobQueue)
            {
                // Verify that job type is not already in queue
                for (int i = 0; i < JobQueue.Count; i++)
                {
                    if ((retVal.JobName == JobQueue[i].JobName) && (JobQueue[i].Parameters.Equals(jobParameters)))
                    {
                        retVal = null;          // Use existing job in queue
                        retVal = JobQueue[i];
                        jobExists = true;
                    }
                }
                if (!jobExists)
                {
                    JobQueue.Add(retVal);   // Add new job to database queue
                }
            }
                   
            return retVal;
        }

     
        /// <summary>
        /// Inserts a certain data set and returns a reference object to that data set
        /// </summary>
        /// <param name="row"></param>
        /// <param name="reportingRefObject"></param>
        /// <returns></returns>
        public override string InjectSingleData(ReportingDataLoader data, out ReportingReferenceObject reportingRefObject)
        {
            // TODO: Define loader
            reportingRefObject = null;
            return "";
        }
        /// <summary>
        /// Inserts a certain data set and returns a reference object to that data set
        /// </summary>
        /// <param name="table"></param>
        /// <param name="reportingRefObjectContainer"></param>
        /// <returns></returns>
        public override string InjectData(ReportingDataLoader data, out ReportingReferenceObjectContainer reportingRefObjectContainer)
        {
            //TODO: Again, define loader
            reportingRefObjectContainer = null;
            return "";
        }
        /// <summary>
        /// Inserts a randomly generated reporting data type into that particular database, returns a reference object to that item.
        /// </summary>
        /// <param name="dataType"></param>
        /// <param name="refObjectContainer"></param>
        /// <returns>SQL results of inserting the data</returns>
        public override string InjectSingleRandomData(ReportingDataType dataType, out ReportingReferenceObject reportingRefObject)
        {
            //TODO: Add data object factory
            //TODO: Run SQL to insert the data
            reportingRefObject = null;
            return "";
        }
        /// <summary>
        /// Insters a set of randomly generated data into the database
        /// </summary>
        /// <param name="dataType">Type of data to insert</param>
        /// <param name="count">How many objects to insert</param>
        /// <param name="container">A reference object to this data</param>
        /// <returns>SQL results of inserting that data</returns>
        public override string InjectRandomData(ReportingDataType dataType, long count, out ReportingReferenceObjectContainer reportingRefObjectContainer)
        {
            //TODO: Add data object factory
            //TODO: Run SQL to insert the data
            reportingRefObjectContainer = null;
            return "";
        }
        /// <summary>
        /// Collects information about the current replication status
        /// </summary>
        /// <returns>A string describing any streams present as well as their status</returns>
        public override string ListReplicationStreamsAndStatus()
        {

            return "";
        }

        /// <summary>
        /// Verifies that data represented within the reference object is present in this database
        /// Throws an exception if verification fails
        /// </summary>
        /// <param name="refObject">Object whose data needs verifying</param>
        /// <returns>Description of what was verified</returns>
        public override string Verify(ReportingReferenceObject refObject)
        {
            StringBuilder retVal = new StringBuilder("");
            List<string> warnErrors;

            // Check verification type
            if (refObject is Verify_OlapMeasureDimension)
            {
                // Store current Olap database connected to
                string tempDB = m_DatabaseName;
                if(m_DatabaseName != ((Verify_OlapMeasureDimension)refObject).OlapDatabase)
                {
                    m_DatabaseName = ((Verify_OlapMeasureDimension)refObject).OlapDatabase;

                    // Change connection to verification object
                    m_AdoSSASConn.Close();
                    try
                    {
                        m_AdoSSASConn.ConnectionString = "data source=" + ComponentName + "; initial catalog=" + m_DatabaseName + " ;Integrated Security=SSPI";
                        m_AdoSSASConn.Open();
                    }
                    catch (Exception exce)
                    {
                        m_DatabaseName = tempDB;
                        m_AdoSSASConn.ConnectionString = "data source=" + ComponentName + "; initial catalog=" + m_DatabaseName + " ;Integrated Security=SSPI";
                        m_AdoSSASConn.Open();
                        ((ReportingVerification)refObject).HResult = -1;
                        return exce.Message;
                    }
                }//If databaseName = OlapDatabase

                // If verification fails, then mark refObject as failed and return errors/warnings
                if (!VerifyMeasureVSDimension(((Verify_OlapMeasureDimension)refObject).OlapDatabase,
                    ((Verify_OlapMeasureDimension)refObject).Cube,
                    ((Verify_OlapMeasureDimension)refObject).Measure,
                    ((Verify_OlapMeasureDimension)refObject).Dimension,
                    ((Verify_OlapMeasureDimension)refObject).TestOLAPValue,
                    ((Verify_OlapMeasureDimension)refObject).TestSQLValue,
                    ((Verify_OlapMeasureDimension)refObject).TestDate,
                    out warnErrors))
                {
                    ((ReportingVerification)refObject).HResult = -1;
                }
                else
                {
                    // Success
                    ((ReportingVerification)refObject).HResult = 1;
                }
                // Compile all errors/warnings into a string
                foreach (string s in warnErrors)
                {
                    retVal.AppendLine(s);
                }
                ((ReportingVerification)refObject).Completed = true;

                // Revert to previous connection
                if (m_DatabaseName != tempDB)
                {
                    // Change connection to verification object
                    m_AdoSSASConn.Close();
                    try
                    {
                        m_DatabaseName = tempDB;
                        m_AdoSSASConn.ConnectionString = "data source=" + ComponentName + "; initial catalog=" + m_DatabaseName + " ;Integrated Security=SSPI";
                        m_AdoSSASConn.Open();
                    }
                    catch (Exception exce)
                    {
                        ((ReportingVerification)refObject).HResult = -1;
                        return "Error restoring original Olap connection: \n" + exce.Message;
                    }
                }
            }//MeasureDimension verification
            else
            {
                // Insert code for other Verification types here...
                // ...


            }
            return retVal.ToString();
        }
        /// <summary>
        /// Verifies that ALL data represented within the reference object container is present in this database
        /// Throws an exception if verification fails
        /// </summary>
        /// <param name="refObjectContainer">Object whose data needs verifying</param>
        /// <returns>Description fo what was verified</returns>
        public override string Verify(ReportingReferenceObjectContainer refObjectContainer)
        {
            return "";
        }



        protected virtual bool VerifyMeasureVSDimension(string DatabaseName, string CubeName, string MeasureName, string DimensionName, string TestOLAPValue,
            string TestSQLValue, DateRange TestDate, out List<string> WarnErrors)
        {
            bool retVal = true;
           
            // Init error/warning list
            WarnErrors = new List<string>();
            
            DateTime m_TestDate = DateTime.Now.AddDays(-1f); // By default, test for yesterday's date

            Microsoft.AnalysisServices.Database olapDB; // Database
            Microsoft.AnalysisServices.Cube olapCube;   // Cube

            // Query lists
            List<string> OlapQueries, SQLQueries;
            string tempOlapResult = "", tempSQLResult = "";

            // Create SSAS Server object and open connection
            Microsoft.AnalysisServices.Server olapServer = new Microsoft.AnalysisServices.Server();
            try
            {
                olapServer.Connect(ComponentName);
            }
            catch (Microsoft.AnalysisServices.ConnectionException exce)
            {
                WarnErrors.Add("Unable to open Analysis Services connection to :" + ComponentName + "\n" + exce.Message);
                olapServer.Disconnect(true);
                olapServer = null;
                return false;
            }

            // Find database by name
            olapDB = olapServer.Databases.FindByName(DatabaseName);
            olapCube = olapDB.Cubes.GetByName(CubeName);

            // Browse through all measuregroups in the Cube
            for (int measuregroup = 0; measuregroup < olapCube.MeasureGroups.Count; measuregroup++)
            {
              
                // Create Olap & SQL queries
                ConstructQueries(olapCube.MeasureGroups[measuregroup], MeasureName, DimensionName, TestOLAPValue, TestSQLValue, TestDate, out SQLQueries, out OlapQueries);

                // Loop through and execute queries
                for (int testCase = 0; (testCase < OlapQueries.Count) && (testCase < SQLQueries.Count); testCase++)
                {

                    // First check if any of the queries have a 'NO_VALUE_FOUND' string
                    if ((OlapQueries[testCase].Contains("NO_VALUE_FOUND")) || (SQLQueries[testCase].Contains("NO_VALUE_FOUND")))
                    {
                        // One of the queries doesn't have a test value
                        WarnErrors.Add("WARNING: Could not complete test for Measuregroup: " + olapCube.MeasureGroups[measuregroup].Name + ".\n\t" +
                            "Olap query: " + OlapQueries[testCase] + "\n\tSQL query: " + SQLQueries[testCase]);
                        retVal = false;
                    }
                    else
                    {
                        //Execute queries
                        if (!ExecuteQueries(OlapQueries[testCase], SQLQueries[testCase], out tempOlapResult, out tempSQLResult))
                        {
                            retVal = false;
                            WarnErrors.Add(tempOlapResult); WarnErrors.Add(tempSQLResult);
                        }
                        else
                        {

                            // Compare query results
                            if (!CompareResults(tempOlapResult, tempSQLResult))
                            {
                                //// Mark it as failed
                                WarnErrors.Add("ERROR: Olap test failed for Measuregroup: " + olapCube.MeasureGroups[measuregroup].Name + ".\n\t\t\t" +
                                    "Olap query: " + OlapQueries[testCase] + "\tResult: " + tempOlapResult + "\n\t\t\tSQL query: " + SQLQueries[testCase] +
                                    "\tResult: " + tempSQLResult);

                                retVal = false;
                            }
                            else
                            {
                                //// Success!
                                WarnErrors.Add("Olap test successful for Measuregroup: " + olapCube.MeasureGroups[measuregroup].Name + ".\n\t\t\t" +
                                    "Olap query: " + OlapQueries[testCase] + "\tResult: " + tempOlapResult + "\n\t\t\tSQL query: " + SQLQueries[testCase] +
                                    "\tResult: " + tempSQLResult);

                            }//if CompareResults == true
                        }//if ExecuteQueries
                    }//if NO_VALUE_FOUND
                }// for each query

            }// For All measure groups

            // Close connections
            if (olapServer != null)
            {
                olapServer.Disconnect(true);
            }
            olapServer = null;
            olapDB = null;
            olapCube = null;

            return retVal;
        }// VerifyMeasureVSDimension()



        /// <summary>
        /// This function will construct the Olap queries based on an input test date and Measure/Dimension collections.
        /// </summary>
        /// <param name="InputMeasureGroup">Measure group collection</param>
        /// <param name="QueryBindDate">Input Test date</param>
        /// <returns>A list of Olap MDX queries, one for each applicable Measure/Dimension combination.</returns>
        protected virtual void ConstructQueries(Microsoft.AnalysisServices.MeasureGroup InputMeasureGroup, string TargetMeasure, string TargetDimension, string TestOLAPValue,
            string TestSQLValue, DateRange QueryBindDate, out List<string> SQLQueries, out List<string> OlapQueries)
        {
            OlapQueries = SQLQueries = null;
            string tempOLAPQuery, baseOLAPQuery, tempSQLQuery, baseSQLQuery, dimensionColumnKey, measureColumnKey;
            string workString = "";
            measureColumnKey = "NO_VALUE_FOUND";

            // Extract measures/dimensions from MeasureGroup
            Microsoft.AnalysisServices.MeasureGroupDimensionCollection relatedDimensions;// Associated dimensions of input measure group
            Microsoft.AnalysisServices.MeasureCollection currentMeasures;

            currentMeasures = InputMeasureGroup.Measures;
            relatedDimensions = InputMeasureGroup.Dimensions;

            // Construct base query
            baseOLAPQuery = string.Format("select [Measures].[XX] on columns from (select [YY].&[DD] on columns from [{0}])", InputMeasureGroup.ParentDatabase.Cubes[0].Name);
            baseSQLQuery = string.Format("select tab1.XX from YY as tab1 inner join ZZ as tab2 on tab1.AA = tab2.BB where tab2.CC = DD AND tab1.OfferId <> -1");

            // Base query parts
            string OlapQ_CubeName,  //
                OlapQ_Measure,      // XX
                OlapQ_Dim,          // YY
                OlapQ_DimValue,     // DD
                SqlQ_RetVal,        // XX
                SqlQ_Tab1,          // YY
                SqlQ_Tab2,          // ZZ
                SqlQ_Tab1Join,      // AA
                SqlQ_Tab2Join,      // BB 
                SqlQ_Tab2TestCol,   // CC
                SqlQ_Tab2DimValue;  // DD

            // Initialize lists
            if (OlapQueries == null)
            {
                OlapQueries = new List<string>(400);
            }
            if (SQLQueries == null)
            {
                SQLQueries = new List<string>(400);
            }

            // Browse through all measures
            for (int measure = 0; measure < currentMeasures.Count; measure++)
            {
 
                // Check for matching measure names
                if (currentMeasures[measure].Name.ToUpper() == TargetMeasure.ToUpper())
                {

                    // For each associated dimension
                    for (int dimensions = 0; dimensions < relatedDimensions.Count; dimensions++)
                    {
 
                        //**************
                        // Loop through all dimension Hierarchies if present
                        //**************
                        for (int i = 0; i < relatedDimensions[dimensions].CubeDimension.Dimension.Hierarchies.Count; i++)
                        {

                            // Loop through all Levels in a Hierarchy
                            for (int j = 0; j < relatedDimensions[dimensions].CubeDimension.Dimension.Hierarchies[i].Levels.Count; j++)
                            {

                                // Check for matching dimension names
                                if (relatedDimensions[dimensions].CubeDimension.Dimension.Hierarchies[i].Levels[j].Name.ToUpper() == TargetDimension)
                                {

                                    // **********************
                                    // Initialize Queries
                                    // **********************
                                    OlapQ_Measure = OlapQ_Dim = OlapQ_DimValue = SqlQ_RetVal = SqlQ_Tab1 = SqlQ_Tab2 = SqlQ_Tab1Join = SqlQ_Tab2Join = SqlQ_Tab2TestCol = SqlQ_Tab2DimValue = "";

                                    tempOLAPQuery = baseOLAPQuery;
                                    tempSQLQuery = baseSQLQuery;

                                    OlapQ_CubeName = InputMeasureGroup.ParentDatabase.Cubes[0].Name;
                                    OlapQ_Measure = currentMeasures[measure].Name;


                                    // Update SQL Query return parameter
                                    workString = currentMeasures[measure].Source.ToString();
                                    if (workString.Contains("."))
                                    {
                                        workString = workString.Substring(workString.IndexOf(".") + 1);
                                    }
                                    SqlQ_RetVal = workString;

                                    // Check the type of Binding to source table
                                    if (currentMeasures[measure].Source.Source is Microsoft.AnalysisServices.RowBinding)
                                    {
                                        // Get Measure Information
                                        workString = ((Microsoft.AnalysisServices.RowBinding)(currentMeasures[measure].Source.Source)).TableID;
                                    }
                                    else // Column binding
                                    {
                                        workString = currentMeasures[measure].Source.ToString();
                                        workString = workString.Substring(0, workString.IndexOf("."));
                                    }
                                    SqlQ_Tab1 = workString;
                                    // **********************
                                    // **********************

                                    // Update SQL Query dimension column
                                    workString = relatedDimensions[dimensions].CubeDimension.Dimension.KeyAttribute.KeyColumns[0].Source.ToString();
                                    dimensionColumnKey = workString.Substring(workString.IndexOf(".") + 1);
                                    SqlQ_Tab2Join = dimensionColumnKey;

                                    // Add Olap dimension
                                    OlapQ_Dim = relatedDimensions[dimensions].CubeDimension.Dimension.Name + "].[" + relatedDimensions[dimensions].CubeDimension.Dimension.Hierarchies[i].Levels[j].Name;
                                    OlapQ_DimValue = TestOLAPValue;

                                    // Find dimension keys - SQL mapping
                                    if (relatedDimensions[dimensions].CubeDimension.Dimension.Hierarchies[i].Levels[j].SourceAttribute != null)
                                    {
                                        //for (int keys = 0; keys < relatedDimensions[dimensions].CubeDimension.Dimension.Hierarchies[i].Levels[j].SourceAttribute.KeyColumns.Count; keys++)
                                        if (relatedDimensions[dimensions].CubeDimension.Dimension.Hierarchies[i].Levels[j].SourceAttribute.KeyColumns.Count > 0)
                                        {
  
                                            // Get column name
                                            workString = relatedDimensions[dimensions].CubeDimension.Dimension.Hierarchies[i].Levels[j].SourceAttribute.KeyColumns[0].Source.ToString();
                                            workString = workString.Substring(workString.IndexOf(".") + 1);
                                            SqlQ_Tab2TestCol = workString;

                                            // Get dimension table name
                                            workString = relatedDimensions[dimensions].CubeDimension.Dimension.Hierarchies[i].Levels[j].SourceAttribute.KeyColumns[0].Source.ToString();
                                            workString = workString.Substring(0, workString.IndexOf("."));
                                            SqlQ_Tab2 = workString;

                                            SqlQ_Tab2DimValue = TestSQLValue;

                                            // Get Measure source column
                                            // We have to loop through here since we don't know which attribute contains the column definition.
                                            // ** NOTE: THIS LOGIC DOESN'T CATCH REFERENCED DIMENSIONS SINCE ALL THE SOURCE DATA IS INHERITED **
                                            for (int inh = 0; inh < ((Microsoft.AnalysisServices.RegularMeasureGroupDimension)relatedDimensions[dimensions]).Attributes.Count; inh++)
                                            {
                                                if ((((Microsoft.AnalysisServices.DataItem)(((Microsoft.AnalysisServices.RegularMeasureGroupDimension)relatedDimensions[dimensions]).Attributes[inh].KeyColumns[0].Source.Parent)).Source) is Microsoft.AnalysisServices.ColumnBinding)
                                                {
                                                    workString = ((Microsoft.AnalysisServices.ColumnBinding)(((Microsoft.AnalysisServices.DataItem)(((Microsoft.AnalysisServices.RegularMeasureGroupDimension)relatedDimensions[dimensions]).Attributes[inh].KeyColumns[0].Source.Parent)).Source)).ColumnID;
                                                    measureColumnKey = workString;
                                                    break;
                                                }
                                            }
                                            SqlQ_Tab1Join = measureColumnKey;

                                            // Since the OLAP query is from aggregated data, we need to verify if the query we are doing consists of
                                            // row counts, or if we have to add a SUM() aggregation, or if it is a 'distinct count'
                                            if (currentMeasures[measure].AggregateFunction == Microsoft.AnalysisServices.AggregationFunction.DistinctCount)
                                            {
                                                SqlQ_RetVal = "COUNT(DISTINCT tab1." + SqlQ_RetVal + ")";
                                            }
                                            else if (currentMeasures[measure].AggregateFunction == Microsoft.AnalysisServices.AggregationFunction.Sum)
                                            {
                                                SqlQ_RetVal = "SUM( tab1." + SqlQ_RetVal + ")";
                                            }
                                            else
                                            {
                                                SqlQ_RetVal = "COUNT(*)";
                                            }

                                            FormatQueryText(OlapQ_CubeName, OlapQ_Measure, OlapQ_Dim, OlapQ_DimValue, SqlQ_RetVal, SqlQ_Tab1, SqlQ_Tab2, SqlQ_Tab1Join, SqlQ_Tab2Join, SqlQ_Tab2TestCol, SqlQ_Tab2DimValue, out tempSQLQuery, out tempOLAPQuery);
                                            // Add query to group
                                            SQLQueries.Add(tempSQLQuery);
                                            OlapQueries.Add(tempOLAPQuery);

                                        }// For sourceAttribute.KeyColumns

                                    }// If sourceAttribute != null

                                }//For each Hierarchy Level

                            }//if(Levels[j].Name.ToUpper() == TargetDimension)

                        }//For each dimension Hierarchy ***

                        // Reset column keys
                        measureColumnKey = "NO_VALUE_FOUND";


                        //**************
                        // Loop through dimension attributes
                        //**************
                        for (int attr = 0; attr < relatedDimensions[dimensions].CubeDimension.Dimension.Attributes.Count; attr++)
                        {
                            // Skip any 'HIDDEN' attributes
                            if (relatedDimensions[dimensions].CubeDimension.Dimension.Attributes[attr].AttributeHierarchyVisible == false)
                            {
                                continue;
                            }

                            // Check for matching dimensions
                            if (relatedDimensions[dimensions].CubeDimension.Dimension.Attributes[attr].Name.ToUpper() == TargetDimension.ToUpper())
                            {

                                // **********************
                                // Initialize Queries
                                // **********************
                                OlapQ_Measure = OlapQ_Dim = OlapQ_DimValue = SqlQ_RetVal = SqlQ_Tab1 = SqlQ_Tab2 = SqlQ_Tab1Join = SqlQ_Tab2Join = SqlQ_Tab2TestCol = SqlQ_Tab2DimValue = "";

                                tempOLAPQuery = baseOLAPQuery;
                                tempSQLQuery = baseSQLQuery;

                                OlapQ_CubeName = InputMeasureGroup.ParentDatabase.Cubes[0].Name;
                                OlapQ_Measure = currentMeasures[measure].Name;

                                // Update SQL Query return parameter
                                workString = currentMeasures[measure].Source.ToString();
                                if (workString.Contains("."))
                                {
                                    workString = workString.Substring(workString.IndexOf(".") + 1);
                                }
                                SqlQ_RetVal = workString;

                                // Check the type of Binding to source table to set the source fact table
                                if (currentMeasures[measure].Source.Source is Microsoft.AnalysisServices.RowBinding)
                                {
                                    workString = currentMeasures[measure].Source.ToString();
                                    workString = ((Microsoft.AnalysisServices.RowBinding)(currentMeasures[measure].Source.Source)).TableID;

                                }
                                else
                                {
                                    workString = currentMeasures[measure].Source.ToString();
                                    workString = workString.Substring(0, workString.IndexOf("."));
                                }
                                SqlQ_Tab1 = workString;
                                // **********************
                                // **********************

                                // Add Olap dimension
                                OlapQ_Dim = relatedDimensions[dimensions].CubeDimension.Dimension.Name + "].[" + relatedDimensions[dimensions].CubeDimension.Dimension.Attributes[attr].Name;

                                // Set Dimension values:
                                OlapQ_DimValue = TestOLAPValue;

                                // Find dimension keys - SQL mapping
                                //for (int keys = 0; keys < relatedDimensions[dimensions].CubeDimension.Dimension.Attributes[attr].KeyColumns.Count; keys++)
                                if (relatedDimensions[dimensions].CubeDimension.Dimension.Attributes[attr].KeyColumns.Count > 0)
                                {
 
                                    // Get Column name
                                    workString = relatedDimensions[dimensions].CubeDimension.Dimension.Attributes[attr].NameColumn.ToString();
                                    workString = workString.Substring(workString.IndexOf(".") + 1);
                                    SqlQ_Tab2TestCol = workString;

                                    // Get Dimension Table name
                                    workString = relatedDimensions[dimensions].CubeDimension.Dimension.Attributes[attr].KeyColumns[0].Source.ToString();
                                    workString = workString.Substring(0, workString.IndexOf("."));
                                    SqlQ_Tab2 = workString;

                                    // Get Measure Source column
                                    workString = relatedDimensions[dimensions].CubeDimension.Dimension.KeyAttribute.KeyColumns[0].Source.ToString();
                                    dimensionColumnKey = workString.Substring(workString.IndexOf(".") + 1);
                                    SqlQ_Tab2Join = dimensionColumnKey;

                                    // Set Dimension values:
                                    //      Get dimension values from test
                                    SqlQ_Tab2DimValue = TestSQLValue;

                                    // Get Measure source column
                                    // We have to loop through here since we don't know which attribute contains the column definition.
                                    // ** NOTE: THIS LOGIC DOESN'T CATCH REFERENCED DIMENSIONS SINCE ALL THE SOURCE DATA IS INHERITED **
                                    for (int inh = 0; inh < ((Microsoft.AnalysisServices.RegularMeasureGroupDimension)relatedDimensions[dimensions]).Attributes.Count; inh++)
                                    {
                                        if ((((Microsoft.AnalysisServices.DataItem)(((Microsoft.AnalysisServices.RegularMeasureGroupDimension)relatedDimensions[dimensions]).Attributes[inh].KeyColumns[0].Source.Parent)).Source) is Microsoft.AnalysisServices.ColumnBinding)
                                        {
                                            workString = ((Microsoft.AnalysisServices.ColumnBinding)(((Microsoft.AnalysisServices.DataItem)(((Microsoft.AnalysisServices.RegularMeasureGroupDimension)relatedDimensions[dimensions]).Attributes[inh].KeyColumns[0].Source.Parent)).Source)).ColumnID;
                                            measureColumnKey = workString;
                                            break;
                                        }
                                    }
                                    SqlQ_Tab1Join = measureColumnKey;

                                    // Since the OLAP query is from aggregated data, we need to verify if the query we are doing consists of
                                    // row counts, or if we have to add a SUM() aggregation, or if it is a 'distinct count'
                                    if (currentMeasures[measure].AggregateFunction == Microsoft.AnalysisServices.AggregationFunction.DistinctCount)
                                    {
                                        SqlQ_RetVal = "COUNT(DISTINCT tab1." + SqlQ_RetVal + ")";
                                    }
                                    else if (currentMeasures[measure].AggregateFunction == Microsoft.AnalysisServices.AggregationFunction.Sum)
                                    {
                                        SqlQ_RetVal = "SUM( tab1." + SqlQ_RetVal + ")";
                                    }
                                    else
                                    {
                                        // BUG BUG
                                        SqlQ_RetVal = "COUNT(*)";
                                    }

                                    FormatQueryText(OlapQ_CubeName, OlapQ_Measure, OlapQ_Dim, OlapQ_DimValue, SqlQ_RetVal, SqlQ_Tab1, SqlQ_Tab2, SqlQ_Tab1Join, SqlQ_Tab2Join, SqlQ_Tab2TestCol, SqlQ_Tab2DimValue, out tempSQLQuery, out tempOLAPQuery);

                                    // Add queries to group
                                    SQLQueries.Add(tempSQLQuery);
                                    OlapQueries.Add(tempOLAPQuery);

                                }// For each attribute key

                            }// If(Dimension Attribute == TestDimension)

                        }//For each dimension attribute

                    }// for all dimensions


                }// If(currentMeasures[measure] == TargetMeasure) // Check for matching measure

            }// for all measures

            // Reset list sizes
            SQLQueries.TrimExcess();
            OlapQueries.TrimExcess();

        }// ConstructQueries()


        /// <summary>
        /// This function will format the SQL and Olap queries based on the individual components passed as parameters. The resulting queries will be returned as 'out'
        /// parameters SqlQuery and Olapquery. If there is an error while constructing the query, the return value will be 'NO_VALUE_FOUND'.
        /// </summary>
        /// <param name="OlapQ_CubeName">Target Olap Cube Name</param>
        /// <param name="OlapQ_Measure">Source Measure for Olap query</param>
        /// <param name="OlapQ_Dim">Dimension for Olap query</param>
        /// <param name="OlapQ_DimValue">Specific Dimension value for Olap Query</param>
        /// <param name="SqlQ_RetVal">SQL query return, normally it is a COUNT(x) or SUM(x)</param>
        /// <param name="SqlQ_Tab1">First table - usually the 'FACT' table to use in query</param>
        /// <param name="SqlQ_Tab2">Second table - usually the 'Dimension' table to use in query</param>
        /// <param name="SqlQ_Tab1Join">Fact table field to use in 'JOIN'</param>
        /// <param name="SqlQ_Tab2Join">Dimension table field to use in 'JOIN'</param>
        /// <param name="SqlQ_Tab2TestCol">Dimension field to compare against test value</param>
        /// <param name="SqlQ_Tab2DimValue">Test value for Dimension table</param>
        /// <param name="SqlQuery">OUT - Output Sql query</param>
        /// <param name="OlapQuery">OUT - Output Olap query</param>
        protected virtual void FormatQueryText(string OlapQ_CubeName, string OlapQ_Measure, string OlapQ_Dim, string OlapQ_DimValue,
            string SqlQ_RetVal, string SqlQ_Tab1, string SqlQ_Tab2, string SqlQ_Tab1Join, string SqlQ_Tab2Join, string SqlQ_Tab2TestCol, string SqlQ_Tab2DimValue, out string SqlQuery, out string OlapQuery)
        {
            OlapQuery = SqlQuery = "NO_VALUE_FOUND";

            // Base queries
            StringBuilder baseOLAPQuery = new StringBuilder(string.Format("select [Measures].[{0}] on columns from (select [{1}].&[{2}] on columns from [{3}])",
                OlapQ_Measure,
                OlapQ_Dim,
                OlapQ_DimValue,
                OlapQ_CubeName));
            StringBuilder baseSQLQuery = new StringBuilder(string.Format("select {0} from {1} as tab1 inner join {2} as tab2 on tab1.{3} = tab2.{4} where tab2.{5} = {6} AND tab1.OfferId <> -1",
                SqlQ_RetVal,
                SqlQ_Tab1,
                SqlQ_Tab2,
                SqlQ_Tab1Join,
                SqlQ_Tab2Join,
                SqlQ_Tab2TestCol,
                SqlQ_Tab2DimValue));

            // Custom Formatting..

            // Replace %0 with *
            baseSQLQuery = baseSQLQuery.Replace("%0", "*");
            // Replace dbo_
            baseSQLQuery = baseSQLQuery.Replace("dbo_", "dbo.");

            OlapQuery = baseOLAPQuery.ToString();
            SqlQuery = baseSQLQuery.ToString();
        }//FormatQueryText


        /// <summary>
        /// Execute the input SQL and Olap queries and return the result as 'out' parameters respectively
        /// </summary>
        /// <param name="OlapQuery">Olap MDX query</param>
        /// <param name="SQLQuery">Related SQL query to the 'OlapQuery' parameter</param>
        /// <param name="OlapResult">Result of Olap query - only the first result returned, so queries are assummed to return a single value.</param>
        /// <param name="SQLResult">Result of SQL query - only the first result returned, so queries are assummed to return a single value.</param>
        /// <returns>True if successful execution, false if error, or if queries were missing parameters</returns> 
        protected virtual bool ExecuteQueries(string OlapQuery, string SQLQuery, out string OlapResult, out string SQLResult)
        {
            OlapResult = ""; SQLResult = "";
            bool retVal = true;

            // Get Database pointers
            ReportingCommon reportingCommon = ReportingCommon.Instance;
            ReportingDB reportingdb = (ReportingDB)reportingCommon.ReportingDB;

            // Ref object to execute queries against
            ServerTestFramework.STFLive.Reporting.TestRefObject trefo = new TestRefObject();

            // Execute Olap Query
            trefo.DebugQuery = OlapQuery;
            ReportingData olapData;
            try
            {
                // Execute Olap query
                OlapResult = RunDebugQuery(trefo, out olapData);

                // Check if result is in data object
                if (OlapResult == "")
                {
                    if (olapData.RawData != null)
                    {
                        OlapResult = olapData.RawData.ToString();
                    }
                }
            }
            catch (Exception exce)
            {
                // Display error and clear result
                OlapResult = "Error executing OLAP query: " + exce.Message + "\n" + exce.StackTrace;
                retVal = false;
            }

            // Execute SQL Query
            trefo.DebugQuery = SQLQuery;
            try
            {
                SQLResult = reportingdb.RunDebugQuery(trefo);
            }
            catch (Exception exce)
            {
                // Display error and clear result
                SQLResult = "Error executing SQL query: " + exce.Message + "\n" + exce.StackTrace;
                retVal = false;
            }
            return retVal;
        }//ExecuteQueries()


        /// <summary>
        /// Compare the results of the SQL and Olap queries
        /// </summary>
        /// <param name="OlapResult">Olap query results</param>
        /// <param name="SQLResult">SQL query results</param>
        /// <returns>True if values are similar, false otherwise</returns>
        protected virtual bool CompareResults(string OlapResult, string SQLResult)
        {
            bool testPass = false;
            double num1, num2;

            // Check for valid parameters
            if (OlapResult == string.Empty || OlapResult == "" ||
                SQLResult == string.Empty || SQLResult == "")
            {
                // Return False: no data to compare
            }

            // Try numeric comparison
            try
            {
                // Try to parse into a double
                num1 = Convert.ToDouble(OlapResult);
                num2 = Convert.ToDouble(SQLResult);

                // Round to same number of decimal places
                num1 = Math.Round(num1, 4);
                num2 = Math.Round(num2, 4);

                // Compare values
                if ((num1 == num2) && (num1 != 0) && (num2 != 0))
                {
                    testPass = true;
                }
            }
            catch (FormatException) // Format Exceptions are thrown by Convert.ToDouble() when trying to parse a string as a number
            {
                // Do string comparison
                if (OlapResult.ToUpper() == SQLResult.ToUpper())
                {
                    testPass = true;
                }
            }//catch


            return testPass;
        }//CompareResults()

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\Database\CatalogDb.cs ===
﻿using System;
using System.Data.SqlClient;
using System.Linq;
using System.Reflection;
using System.Text;
using xonline.common.config;
using System.Collections.Generic;

namespace ServerTestFramework.Database
{
    public class CatalogDb : IDisposable
    {
        private SqlConnection connection;
        private Object connectionLock = new Object();

        private Dictionary<Type, List<String>> ignoredColumnsByType = new Dictionary<Type,List<string>>();

        /// <summary>
        /// Connect to the default CatalogDB, the Xbox Catalog
        /// </summary>
        public CatalogDb() : this(ConfigUtil.FECatalogDBXboxConnectionString) { }

        /// <summary>
        /// Connect to the specified CatalogDB.  This should be either 
        /// FECatalogDBXbox or FECatalogDBZune
        /// </summary>
        /// <param name="connectionString">
        /// The connection string for the database.  Should refer to 
        /// ConfigUtil.FECatalogDBXboxConnectionString or 
        /// ConfigUtil.FECatalogDBZuneConnectionString
        /// </param>
        public CatalogDb(String connectionString)
        {
            connection = new SqlConnection(connectionString);
            connection.Open();
        }

        public void Close()
        {
            if (connection != null)
            {
                lock (connectionLock)
                {
                    if (connection != null)
                    {
                        connection.Dispose();
                        connection = null;
                    }
                }
            }
        }

        public SqlCommand CreateCommand()
        {
            return connection.CreateCommand();
        }

        public Object ExecuteScalar(String sql)
        {
            SqlCommand cmd = connection.CreateCommand();
            cmd.CommandText = sql;
            return cmd.ExecuteScalar();
        }

        public Int32 ExecuteCount(String sql)
        {
            Object result = ExecuteScalar(sql);
            return (Int32)(result ?? 0);
        }

        public SqlDataReader ExecuteReader(String sql)
        {
            SqlCommand cmd = connection.CreateCommand();
            cmd.CommandText = sql;
            return cmd.ExecuteReader();
        }

        public Int32 ExecuteNonQuery(String sql)
        {
            SqlCommand cmd = connection.CreateCommand();
            cmd.CommandText = sql;
            return cmd.ExecuteNonQuery();
        }

        /// <summary>
        /// Insert an arbitrary object into the catalog database.
        /// This is used with the various CatalogDB structures such
        /// as MediaInstance or Offer which represent a single 
        /// row in the database.
        /// </summary>
        /// <remarks>
        /// When performing an insert, a SQL statement is generated 
        /// that inserts a row into the database table with the same
        /// name as the type of the provided object and includes each 
        /// value in the structure.  The default value is used for 
        /// any fields that don't have an explicitly defined value.  
        /// This default to null for value types.
        /// </remarks>
        /// <typeparam name="TObjectType">The type of object to insert</typeparam>
        /// <param name="catalogObject">The object to insert</param>
        /// <returns>The number of rows added</returns>
        public Int32 Insert<TObjectType>(TObjectType catalogObject)
        {
            Int32 result = -1;
            Boolean retry;
            Type objectType = typeof(TObjectType);

            do
            {
                retry = false;
                try
                {
                    result = this.ExecuteNonQuery(String.Format("if not exists (select * from {0} where {1}) {2}",
                                                          objectType.Name,
                                                          GetWhereString(catalogObject),
                                                          GetInsertString(catalogObject)));
                }
                catch (SqlException se)
                {
                    if (se.Message.Contains("Invalid column name"))
                    {
                        String columnName = se.Message.Split('\'')[1];
                        List<String> ignoredColumns = GetIgnoredColumns(objectType);
                        if (ignoredColumns == null)
                        {
                            ignoredColumns = new List<string>();
                            ignoredColumnsByType[objectType] = ignoredColumns;
                        }

                        ignoredColumns.Add(columnName);
                        retry = true;
                    }
                    else
                    {
                        throw se;
                    }
                }

            }
            while(retry);

            return result;
        }

        /// <summary>
        /// Attempts to insert an arbitrary object into the catalog 
        /// database. This is used with the various CatalogDB structures 
        /// such as MediaInstance or Offer which represent a single 
        /// row in the database.  This just does an insert and swallows
        /// any exceptions to allow test to easily add testdata without
        /// having to check for existance each time
        /// </summary>
        /// <remarks>
        /// When performing an insert, a SQL statement is generated 
        /// that inserts a row into the database table with the same
        /// name as the type of the provided object and includes each 
        /// value in the structure.  The default value is used for 
        /// any fields that don't have an explicitly defined value.  
        /// This default to null for value types.
        /// </remarks>
        /// <typeparam name="TObjectType">The type of object to insert</typeparam>
        /// <param name="catalogObject">The object to insert</param>
        /// <param name="result">The result of the insert </param>
        /// <returns>The number of rows added</returns>
        public Boolean TryInsert<TObjectType>(TObjectType catalogObject, out Int32 result)
        {
            result = -1;
            try
            {
                result = Insert(catalogObject);
                return true;
            }
            catch (SqlException)
            {
                return false;
            }
        }

        /// <summary>
        /// Remove arbitrary row(s) from the CatalogDB based on the 
        /// values in the provided object. 
        /// </summary>
        /// <remarks>
        /// When performing a delete, a SQL statement is generated
        /// that deletes all rows in the database table with the same
        /// name as the type of the object provided where the rows
        /// match the non default values provided in the object.
        /// </remarks>
        /// <typeparam name="TObjectType">The type of object to remove</typeparam>
        /// <param name="catalogObject">The defines what fields to remove</param>
        /// <returns>The number of rows removed</returns>
        public Int32 Remove<TObjectType>(TObjectType catalogObject)
        {
            return ExecuteNonQuery(String.Format("delete from {0} where {1}",
                                                 typeof(TObjectType).Name, 
                                                 GetWhereString(catalogObject)));
        }

        /// <summary>
        /// Attempts to remove an arbitrary object from the catalog 
        /// database. This is used with the various CatalogDB structures 
        /// such as MediaInstance or Offer which represent a single 
        /// row in the database.  This just does an remove and swallows
        /// any exceptions to allow test to easily remove testdata without
        /// having to check for existance each time
        /// </summary>
        /// <typeparam name="TObjectType">The type of object to insert</typeparam>
        /// <param name="catalogObject">The object to insert</param>
        /// <param name="result">The result of the insert </param>
        /// <returns>The number of rows removed</returns>
        public Boolean TryRemove<TObjectType>(TObjectType catalogObject, out Int32 result)
        {
            result = -1;
            try
            {
                result = Remove(catalogObject);
                return true;
            }
            catch (SqlException)
            {
                return false;
            }
        }

        /// <summary>
        /// Helper function to get the value of an object as a 
        /// string for use in a SQL function.  This started out
        /// really basic and has expanded a bit.  Might be better
        /// to find a SQL class that handles marshaling the types
        /// but I couldn't find one.
        /// </summary>
        /// <param name="fieldValue">The object to get a string for</param>
        /// <returns>The SQL friendly string value</returns>
        private String GetValueString(Object fieldValue)
        {
            if (fieldValue == null)
            {
                return "''";
            }

            Type valueType = fieldValue.GetType();

            if (valueType == typeof(DateTime))
            {
                if ((DateTime)fieldValue == new DateTime())
                {
                    fieldValue = DateTime.UtcNow;
                }
            }

            // Guids DateTimes and Strings are all quoted
            // Enums?
            if (valueType == typeof(Guid) ||
               valueType == typeof(DateTime) ||
               valueType == typeof(String))
            {
                return "'" + fieldValue + "'";
            }
            else
            {
                return fieldValue.ToString();
            }
        }


        private String GetValuesString<TObjectType>(TObjectType catalogObject, Func<String, String, String> columnValueToString, String connectorString, Boolean removeDefaults)
        {
            Type objectType = typeof(TObjectType);
            FieldInfo[] fields = objectType.GetFields();
            List<String> ignoredColumns = GetIgnoredColumns(objectType);

            return (from fi in fields
                    where !ignoredColumns.Contains(fi.Name)
                    let value = fi.GetValue(catalogObject)
                    select new
                    {
                        Name = fi.Name,
                        Value = GetValueString(value),
                        IsDefault = value == null || (fi.FieldType.IsValueType && value.Equals(Activator.CreateInstance(fi.FieldType))),
                    }).Where(i => !removeDefaults || !i.IsDefault)
                    .Select(i => columnValueToString(i.Name, i.Value))
                    .Aggregate((a, b) => a + connectorString + b);
        }

        private String GetInsertString<TObjectType>(TObjectType catalogObject)
        {
            return String.Format("insert into {0} ({1}) values ({2})",
                typeof(TObjectType).Name,
                GetValuesString(catalogObject, (n, v) => n, ", ", false),
                GetValuesString(catalogObject, (n, v) => v, ", ", false));
        }

        private String GetWhereString<TObjectType>(TObjectType catalogObject)
        {
            return GetValuesString(catalogObject, (n, v) => n + "=" + v, " and ", true);
        }

        private List<String> GetIgnoredColumns(Type objectType)
        {
            List<String> ignoredColumns = null;
            if (!ignoredColumnsByType.TryGetValue(objectType, out ignoredColumns))
            {
                ignoredColumns = new List<string>();
                ignoredColumnsByType[objectType] = ignoredColumns;
            }
            return ignoredColumns;
        }

        #region IDisposable Members

        public void Dispose()
        {
            Close();
        }

        #endregion

        #region CatalogDB Structures
        // The following structures are proxies for the Catalog DB 
        // tables and their entries.  This makes it easy to insert
        // rows into the given tables without having to manipulate
        // any raw SQL strings.

        public struct Media
        {
            public Guid mediaId;
            public Int32 mediaTypeId;
            public Int32 metadataProviderId;
            /// <summary>
            /// This is the same column as metadataProviderId but is named
            /// differently in the FECatalogDBZune schema
            /// </summary>
            public Int32 providerId;
            public DateTime? originalReleaseDate;
            public String displayOriginalReleaseDate;
            public DateTime visibilityDate;
            public Int32 visibilityStatusId;
            public Byte geoCheckPolicy;
            public DateTime modifiedDate;
        }

        public struct MediaInstance
        {
            public Guid mediaInstanceId;
            public Guid mediaId;
            public Byte isAcquirable;
            public Byte isAdSupported;
            public Byte isPreview;
            public DateTime modifiedDate;
        }

        public struct Offer
        {
            public Guid offerId;
            public Guid mediaId;
            public String name;
            public DateTime modifiedDate;
            public Int32 offerTypeId;
        }

        public struct OfferInstance
        {
            public Guid offerInstanceId;
            public Guid offerId;
            public String sku;
            public Int32 pricingRuleId;
            public Decimal price;
            public Decimal reportingRetailValue;
            public String reportingRetailValueCurrencyCode;
            public DateTime startDateTime;
            public DateTime endDateTime;
            public String countryCode;
            public Int32 visibilityLevelId;
            public DateTime modifiedDate;
            public Int32 paymentTypeId;
            public String priceCurrencyCode;
            public String externalOfferInstanceId;
            public Decimal suggestedRetailPrice;
            public Decimal wholesalePrice;
        }

        public struct OfferInstanceMediaInstance
        {
            public Guid offerInstanceId;
            public Guid mediaInstanceId;
            public Int32 visibilityStatusId;
            public Int32 providerId;
            public Int32 licenseTypeId;
            public DateTime modifiedDate;
        }
        
        public struct OfferInstanceGameContentInstance
        {
            public Guid offerInstanceId;
            public Guid gameContentInstanceId;
            public Int32 licenseExtensionBits;
            public DateTime modifiedDate;
        }

        public struct OfferInstanceProviderTerm
        {
            public Guid offerInstanceId;
            public Guid providerTermId;
            public Int32 visibilityStatusId;
            public DateTime modifiedDate;
        }

        public struct ProviderTerm
        {
            public Guid providerTermId;
            public Guid mediaId;
            public Decimal wholesalePrice;
            public String wholesalePriceCurrencyCode;
            public DateTime startDatetime;
            public DateTime endDatetime;
            public String countryCode;
            public Int32 providerId;
            public String externalProviderContentId;
            public Int32 drmLicenseIssuerId;
            public String externalDRMLicenseIssuerContentId;
            public Byte automaticallyGenerateOffer;
            public String modifiedBy;
            public DateTime modifiedDate;
        }

        public struct ProviderTermMediaInstance
        {
            public Guid providerTermId;
            public Guid mediaInstanceId;
            public Int32 licenseTypeId;
            public DateTime? expirationDate;
            public DateTime modifiedDate;
        }

        public struct ProviderTermGameContentInstance
        {
            public Guid providerTermId;
            public Guid mediaInstanceId;
            public Int32 licenseExtensionBits;
            public DateTime modifiedDate;
        }

        public struct ProviderTermMediaInstanceClientType
        {
            public Guid providerTermId;
            public Guid mediaInstanceId;
            public Int32 clientTypeId;
            public DateTime modifiedDate;
        }

        public struct SyncCastKeyInfo
        {
            public String SCOID;
            public String syncCastKey;
            public String encryptedSeed;
            public DateTime modifiedDate;
        }

        public struct SyncCastMediaInstanceMap
        {
            public String SCOID;
            public Guid mediaInstanceId;
            public DateTime modifiedDate;
        }
        #endregion
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\Database\PuidList.cs ===
using System;
using System.Collections;
using System.Threading;
using System.IO;
using ServerTestFramework.WebWidget;
using ServerTestFramework.Utilities;

namespace ServerTestFramework.Database
{
	public class PuidName
	{
		public ulong  Puid;
		public string GamerTag;
		public byte[] WebId = {};
		public PuidName(ulong puid, string gamerTag) : this( puid, gamerTag, null) {}
		public PuidName(ulong puid, string gamerTag, byte[] webId )
		{
			Puid=puid;
			GamerTag=gamerTag;
			if( WebId == null )
			{
				WebId = new byte[0];
			}
			else
			{
				WebId=webId;
			}
		}
		public override string ToString()
		{
			return "("+GamerTag+", "+Puid+")";
		}
	}

	public class PuidNameComparer : IComparer
	{
		int IComparer.Compare( object x, object y )
		{
			if( ((PuidName)x).Puid < ((PuidName)y).Puid )
			{
				return -1;
			}
			else if( ((PuidName)x).Puid > ((PuidName)y).Puid )
			{
				return 1;
			}
			else
			{
				return 0;
			}
		}
	}

	/// <summary>
	/// Maintains a cache of valid puids
	/// </summary>
	public class CPUIDList
	{
		static object			LockObject=new object();
		int						maxPuids;
		int						bufferSize=0;
		int						nextItem=0;
		PuidName				[]puidList;
		
		public PuidName this[ int index ]
		{
			get
			{
				if( (index >= puidList.Length) || (index < 0) )
				{
					throw new ArgumentOutOfRangeException( "index", index, "No such PuidName" );
				}
				return( puidList[ index ] );
			}
		}

		public PuidName	GetPuidName()
		{
			if (bufferSize==0)
			{
				throw new Exception("----- No stored puids ------");
			}
			
			PuidName ret;
			lock (LockObject)
			{
				ret=puidList[nextItem++];
				if (nextItem>=bufferSize)
					nextItem=0;
				if (ret.Puid==0)
					ConsoleX.WriteLine(CC.BLUE,"A very unexpected error has occurred in CPUIDList. I've been trying to track this one down. Email me: reljam");
			}
			return ret;
		}

		public ulong GetPuid()
		{
			return GetPuidName().Puid;
		}

		public string GetGamerTag()
		{
			return GetPuidName().GamerTag;
		}

		public int GetSize()
		{
			lock (LockObject)
			{
				return bufferSize;
			}
		}

		public bool IsLast()
		{
			return (nextItem==bufferSize-1);
		}			

		public void Reset()
		{
			nextItem=0;
		}

		public void	Add(ulong puid, string gamerTag)
		{
			Add( puid, gamerTag, null );
		}
		public void	Add(ulong puid, string gamerTag, byte[] webId )
		{
			lock (LockObject)
			{
				if (bufferSize==maxPuids)
				{
					int insertItem=nextItem-1;
					if (insertItem<0)
						insertItem=bufferSize-1;
					puidList[insertItem].Puid=puid;
					puidList[insertItem].GamerTag=gamerTag;
					puidList[insertItem].WebId=webId;
					return;
				}
				puidList[bufferSize++]=new PuidName(puid,gamerTag,webId);
			}
		}		

		public void Randomize()
		{
//			Array.Sort(puidList,0,bufferSize);
		}

		public void SortByPuid()
		{
			PuidNameComparer sorter = new PuidNameComparer();
			lock (LockObject)
			{
				Array.Sort( puidList, sorter );
			}
		}

		public void SetDefaultWebIds()
		{
			for( int i = 0; i < bufferSize; ++i )
			{
				puidList[i].WebId = WCUserAccount.PuidToWebID( puidList[i].Puid );
			}
		}
		
		public CPUIDList(int MaxPuids)
		{
			// 
			// TODO: Add constructor logic here
			//
			maxPuids=MaxPuids;
			puidList=new PuidName[maxPuids];
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\Database\QueryDB.cs ===
/* Wrapper for QueryDB database */

using System;
using System.Data;
using System.Data.SqlTypes;
using System.Data.SqlClient;
using System.Data.Common;
using System.Collections;
using System.Text;
using System.Runtime.InteropServices;
using ServerTestFramework.LiveService;
using ServerTestFramework.Utilities;
using System.Xml;

namespace ServerTestFramework.Database
{
    /// <summary>
    /// Wrapper for talking to QueryDB.
    /// </summary>
    public class QueryDB
    {
        private SqlConnection _conn;
        private string _serverName;

        public QueryDB()
        {
        }
  
        /// <summary>
        /// Connects to QueryDB server taking an array
        /// Only connects to the first server in the array
        /// </summary>
        /// <param name="serverNames">Array of QueryDB server names</param>
        public void ConnectToServer(string []serverNames)
        {
            ConnectToServer(serverNames[0]);
        }

        /// <summary>
        /// Connects to the QueryDB Database
        /// </summary>
        /// <param name="serverName">Name of QueryDB server</param>
        public void ConnectToServer(string serverName)
        {
            try 
            {
                _serverName=serverName;
                _conn = new SqlConnection("server="+_serverName+";database=QueryDB;Integrated Security=SSPI"); 
                _conn.Open();
            } 
            catch(SqlException sqlex)
            {
                throw new DatabaseException(_conn, sqlex);
            }
        }

        /// <summary>
        /// Closes the connection to QueryDB
        /// </summary>
        public void Close()
        {
            lock(_conn)
            {
                // m_SqlConnection could be null
                if (_conn!=null && _conn.State!=ConnectionState.Closed)
                {
                    try
                    {
                        _conn.Close();
                    }
                    catch
                    {
                        // do nothing
                    }
                    _conn=null;
                }
            }
        }

        /// <summary>
        /// Executes a SQL Query and returns the single scalar value
        /// </summary>
        /// <param name="sql">SQL Query</param>
        /// <returns>Value of Query</returns>
        public object ExecuteScalar(string sql)
        {
            object value = null;

            try 
            {
                SqlCommand command = new SqlCommand(sql, _conn);
                value = command.ExecuteScalar();
            }
            catch(SqlException sqlex)
            {
                throw new DatabaseException(_conn, sqlex);
            }

            return value;
        }

        /// <summary>
        /// Allows you to run a command against QueryDB
        /// </summary>
        /// <param name="sql">SQL command to execute</param>
        /// <returns>Number of rows affected.</returns>
        public int IssueCommand(string sql)
        {
            int affected = 0;

            try 
            {
                SqlCommand command = new SqlCommand(sql, _conn);
                affected = command.ExecuteNonQuery();
            }
            catch(SqlException sqlex)
            {
                throw new DatabaseException(_conn, sqlex);
            }

            return affected;
        }

        /// <summary>
        /// Allows you to pass a query to QueryDB and get a data reader back.
        /// </summary>
        /// <param name="sql">SQL Query</param>
        /// <param name="reader">Data returned from query</param>
        public void ReadData(string sql, out SqlDataReader reader)
        {
            try
            {
                SqlCommand command = new SqlCommand(sql, _conn);
                reader = command.ExecuteReader();

                if (reader == null)
                {
                    throw new DatabaseException(_conn, "Execute reader failed");
                }
            }
            catch(SqlException sqlex)
            {
                throw new DatabaseException(_conn, sqlex);
            }
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\Database\Reporting.cs ===
//
//  Reporting DB Common Code
//

using System;
using System.Collections;
using System.Collections.Generic;
using System.Data;
using System.Data.SqlTypes;
using System.Data.SqlClient;
using System.Runtime.InteropServices;

using System.Threading;
using ServerTestFramework.STFLive.Reporting;

namespace ServerTestFramework.STFLive.Database
{
    [ComVisible(false)]
    public class ReportingDB : ReportingDatabase
    {
        public static Report Log = new Report("ReportingDB");

        protected string m_ServerName;
        static private string[]  m_StagingTables = {"t_new_account_fact",
                                                                            "t_migrate_account_fact",
                                                                            "t_provision_fact",
                                                                            "t_presence_fact",
                                                                            "t_session_fact",
                                                                            "t_msg_snd_fact",
                                                                            "t_guest_fact",
                                                                            "t_purchase_fact",
                                                                            "t_content_fact"
                                                                            };

        static private string[]  m_FinalFactTables = {"t_rdb_new_account_fact",
                                                                            "t_rdb_migrate_account_fact",
                                                                            "t_rdb_provision_fact",
                                                                            "t_rdb_presence_fact",
                                                                            "t_rdb_session_fact",
                                                                            "t_rdb_msg_snd_fact",
                                                                            "t_rdb_guest_fact",
                                                                            "t_rdb_purchase_fact",
                                                                            "t_rdb_content_fact",
                                                                            "t_rdb_content_xbox360_fact",
                                                                            "t_rdb_user_status_fact"
                                                                            };

        public ReportingDB()
        {
            // Initialize Database objects
            JobQueue = new List<ReportingJob>(10);
            JobThreads = new Hashtable(10);
            
        }

        ~ReportingDB()
        {
            Close();
        }

        public void ConnectToServer(string serverName)
        {
            this.ConnectToServer(serverName, m_DatabaseName);
        }

        // BUGBUG: Probably should be an enum rather than a string (to reduce the chance that we'll have a bug
        // trying to connect to a non-existant DB when we switch environments)
        public void ConnectToServer(string serverName, string database)
        {
            m_ServerName = serverName;
            m_DatabaseName = database;
            m_SqlConnection = new SqlConnection("server=" + serverName + ";database=" + database + ";Integrated Security=SSPI");
            m_SqlConnection.Open();
        }

        public void Close()
        {
            // m_SqlConnection could be null
            if (m_SqlConnection != null && m_SqlConnection.State != ConnectionState.Closed)
            {
                try
                {
                    m_SqlConnection.Close();
                }
                catch
                {
                    // do nothing here
                }
                finally
                {
                    m_SqlConnection = null;
                }
            }

            CloseJobQueueThreads();
        }

        public SqlConnection Connection
        {
            get { return m_SqlConnection; }
        }

        public System.Data.ConnectionState ConnectionState
        {
            get { return m_SqlConnection.State; }
        }

        /// <summary>
        /// What type server you are dealing with
        /// </summary>
        public override ReportingMachines ComponentType
        {
            get
            {
                return ReportingMachines.Reporting;
            }
        }

        /// <summary>
        /// The name of the server you are dealing with
        /// </summary>
        public override string ComponentName
        {
            get
            {
                return m_ServerName;
            }
        }

        /// <summary>
        /// API to inject an event
        /// </summary>
        /// <param name="type"></param>
        /// <param name="reportingRefObject"></param>
        /// <returns></returns>
        public override string InjectEvent(ReportingEventType type, out ReportingReferenceObject reportingRefObject)
        {
            reportingRefObject = null;
            return "";
        }

        /// <summary>
        /// API that injects the next event in a series of events
        /// </summary>
        /// <param name="type"></param>
        /// <param name="reportingRefObject"></param>
        /// <returns></returns>
        public override string InjectNextEvent(ReportingEventType type, ref ReportingReferenceObject reportingRefObject)
        {
            return "";
        }

        /// <summary>
        /// Gets a performance counter that is an integer
        /// </summary>
        /// <param name="Counter"></param>
        /// <returns></returns>
        public override int GetIntPerformanceCounter(string Counter)
        {
            return -1;
        }

        /// <summary>
        /// Gets a performance counter that is a floating point number
        /// </summary>
        /// <param name="Counter"></param>
        /// <returns></returns>
        public override float GetFloatPerformanceCounter(string Counter)
        {
            return -0.0f;
        }


        private string m_DatabaseName = "ReportingDB";
        /// <summary>
        /// The SQL name of the database (note: NOT THE MACHINE NAME)
        /// </summary>
        public override string DatabaseName
        {
            get
            {
                return m_DatabaseName;
            }
            set
            {
                m_DatabaseName = value;
            }
        }

        /// <summary>
        /// Runs a query against the database (all tables).  Returns data for small tables (less than 20 rows), returns counts for all other tables
        /// </summary>
        /// <returns>Query Results</returns>
        public override string RunDebugQuery()
        {
            // TODO: Implement me
            return "";
        }

        /// <summary>
        /// Queues a job to be run using the default parameters for that job (specific to that job)
        /// Validates that this job can be run on this server
        /// </summary>
        /// <param name="jobType">Type of job to be run</param>
        /// <returns>Could job be queued</returns>
        public override ReportingJob QueueJob(ReportingJobType jobType)
        {
            ReportingJobParameters jobParameters = null;
            // Validate job type for this server            
            switch (jobType)
            {
                // Declare new default parameters for the job
                case ReportingJobType.ReportingDB_GameUsageDaily: // Daily Processing - Game Usage
                    jobParameters = new DailyProcessing_GameUsage.DailyProcessing_GameUsage_Params();
                    break;
                case ReportingJobType.ReportingDB_ArgoUsageDaily:    // Daily Processing - Crux
                    jobParameters = new DailyProcessing_Crux.DailyProcessing_Crux_Params();
                    break;
                case ReportingJobType.ReportingDB_PurgeFact:     // Purge Fact Tables
                    jobParameters = new ReportingDB_PurgeFactTables.ReportingDB_PurgeFactTables_Params();
                    break;
                case ReportingJobType.ReportingDB_DropArchivedFact:     // Drop Archived Fact Tables
                    jobParameters = new ReportingDB_DropArchivedFacts.ReportingDB_DropArchivedFacts_Params();
                    break;
                case ReportingJobType.CIQ_Datafeed:             // CIQ Datafeed
                    jobParameters = new CIQDatafeed.CIQDatafeed_Params();
                    break;
                case ReportingJobType.SCGExport_SSIS:           // SCG Export SSIS Job
                    jobParameters = new SCGExport_SSIS.SCGExport_SSIS_Params();
                    break;
                default:
                    // Invalid Job Type for this database
                    throw new Exception("Invalid Job Type. This specified job does not exist on this database");
            }
            return QueueJob(jobType, jobParameters);    // Queue Job with parameters
        }

        /// <summary>
        /// Queues a job to be run using the specified parameters for that job (specific to that job)
        /// Validates that this job can be run on this server
        /// </summary>
        /// <param name="jobType">Type of job to be run</param>
        /// <returns>Could job be queued</returns>
        public override ReportingJob QueueJob(ReportingJobType jobType, ReportingJobParameters jobParameters)
        {
            ReportingJob retVal = null;
            bool jobExists = false;

            // Get job factory instance
            ReportingJobFactory jobFactory = ReportingJobFactory.Instance;            
          
            // Validate job type for this server            
            switch (jobType)
            {
                // Create job through factory
                case ReportingJobType.ReportingDB_GameUsageDaily: // Daily Processing - Game Usage
                    retVal = jobFactory.CreateReportingJob(jobType, jobParameters);
                    break;
                case ReportingJobType.ReportingDB_ArgoUsageDaily:    // Daily Processing - Crux
                    retVal = jobFactory.CreateReportingJob(jobType, jobParameters);
                    break;
                case ReportingJobType.ReportingDB_PurgeFact:     // Purge Fact Tables
                    retVal = jobFactory.CreateReportingJob(jobType, jobParameters);
                    break;
                case ReportingJobType.ReportingDB_DropArchivedFact:     // Drop Archived Fact Tables
                    retVal = jobFactory.CreateReportingJob(jobType, jobParameters);
                    break;
                case ReportingJobType.CIQ_Datafeed:             // CIQ Datafeed
                    retVal = jobFactory.CreateReportingJob(jobType, jobParameters);
                    break;
                case ReportingJobType.SCGExport_SSIS:           // SCG Export SSIS Job
                    retVal = jobFactory.CreateReportingJob(jobType, jobParameters);
                    break;
                default:
                    // Invalid Job Type for this database
                    throw new Exception("Invalid Job Type. This specified job does not exist on this database");
            }

            // Force synchronized access to job list
            lock (JobQueue)
            {
                // Verify that job type is not already in queue
                for (int i = 0; i < JobQueue.Count; i++)
                {
                    if ((retVal.JobName == JobQueue[i].JobName) && (JobQueue[i].Parameters.Equals(jobParameters)))
                    {
                        retVal = null;          // Use existing job in queue
                        retVal = JobQueue[i];
                        jobExists = true;
                    }
                }
                if (!jobExists)
                {
                    JobQueue.Add(retVal);   // Add new job to database queue
                }
            }
            return retVal;
        }


        /// <summary>
        /// Inserts a certain data set and returns a reference object to that data set
        /// </summary>
        /// <param name="row"></param>
        /// <param name="reportingRefObject"></param>
        /// <returns></returns>
        public override string InjectSingleData(ReportingDataLoader data, out ReportingReferenceObject reportingRefObject)
        {
            //TODO: Define loader
            reportingRefObject = null;
            return "";
        }
        /// <summary>
        /// Inserts a certain data set and returns a reference object to that data set
        /// </summary>
        /// <param name="table"></param>
        /// <param name="reportingRefObjectContainer"></param>
        /// <returns></returns>
        public override string InjectData(ReportingDataLoader data, out ReportingReferenceObjectContainer reportingRefObjectContainer)
        {
            //TODO: Again, define loader
            reportingRefObjectContainer = null;
            return "";
        }
        /// <summary>
        /// Inserts a randomly generated reporting data type into that particular database, returns a reference object to that item.
        /// </summary>
        /// <param name="dataType"></param>
        /// <param name="refObjectContainer"></param>
        /// <returns>SQL results of inserting the data</returns>
        public override string InjectSingleRandomData(ReportingDataType dataType, out ReportingReferenceObject reportingRefObject)
        {
            //TODO: Add data object factory
            //TODO: Run SQL to insert the data
            reportingRefObject = null;
            return "";
        }
        /// <summary>
        /// Insters a set of randomly generated data into the database
        /// </summary>
        /// <param name="dataType">Type of data to insert</param>
        /// <param name="count">How many objects to insert</param>
        /// <param name="container">A reference object to this data</param>
        /// <returns>SQL results of inserting that data</returns>
        public override string InjectRandomData(ReportingDataType dataType, long count, out ReportingReferenceObjectContainer reportingRefObjectContainer)
        {
            //TODO: Add data object factory
            //TODO: Run SQL to insert the data
            reportingRefObjectContainer = null;
            return "";
        }
        /// <summary>
        /// Collects information about the current replication status
        /// </summary>
        /// <returns>A string describing any streams present as well as their status</returns>
        public override string ListReplicationStreamsAndStatus()
        {

            return "";
        }

        /// <summary>
        /// Verifies that data represented within the reference object is present in this database
        /// Throws an exception if verification fails
        /// </summary>
        /// <param name="refObject">Object whose data needs verifying</param>
        /// <returns>Description of what was verified</returns>
        public override string Verify(ReportingReferenceObject refObject)
        {
            return "";
        }
        /// <summary>
        /// Verifies that ALL data represented within the reference object container is present in this database
        /// Throws an exception if verification fails
        /// </summary>
        /// <param name="refObjectContainer">Object whose data needs verifying</param>
        /// <returns>Description fo what was verified</returns>
        public override string Verify(ReportingReferenceObjectContainer refObjectContainer)
        {
            return "";
        }

        /// <summary>
        /// Confirm all staging tables exist
        /// </summary>
        /// <param name="szReplicationProvider">Replication Provider Name</param>
        /// <returns>void</returns>
        public bool ConfirmStagingTables(string  szReplicationProvider)
        {
            bool bReturn = true;
            
            SqlCommand Cmd = new SqlCommand();
            Cmd.Connection = Connection;
            Cmd.CommandType = CommandType.Text;

            foreach (string szTableName in m_StagingTables)
            {
                string szFullTableName = string.Format("{0}_{1}", szTableName, szReplicationProvider);

                Cmd.CommandText   = string.Format("select count(*) from dbo.sysobjects where id = object_id(N'[dbo].[{0}]') and OBJECTPROPERTY(id, N'IsUserTable') = 1", szFullTableName);
                int iNum = (int) Cmd.ExecuteScalar();

                if(iNum ==0 )
                {
                    bReturn = false;
                    Log.Warn("{0} doesn't exisit", szFullTableName);
                }
                else
                {
                    Log.Info("{0} does exisit", szFullTableName);
                }
            }

            return bReturn;
        }

        /// <summary>
        /// Delete all staging tables if data is newer than dtWhen
        /// </summary>
        /// <param name="szReplicationProvider">Replication Provider Name</param>
        /// <returns>void</returns>
        public void DeleteStagingTables(string  szReplicationProvider, DateTime dtWhen)
        {
            SqlCommand Cmd = new SqlCommand();
            Cmd.Connection = Connection;
            Cmd.CommandType = CommandType.Text;

            foreach (string szTableName in m_StagingTables)
            {
                string szFullTableName = string.Format("{0}_{1}", szTableName, szReplicationProvider);

                switch(szTableName)
                {
                    case "t_presence_fact":
                    case "t_session_fact":
                        Cmd.CommandText   = string.Format("delete from {0} where dt_start >= '{1}'", szFullTableName, dtWhen);
                        break;

                    default:
                        Cmd.CommandText   = string.Format("delete from {0} where dt_when >= '{1}'", szFullTableName, dtWhen);
                        break;
                    
                }
                Cmd.ExecuteNonQuery();
            }
        }

        /// <summary>
        /// Delete all final fact tables if data is newer than iDate
        /// </summary>
        /// <returns>void</returns>
        public void DeleteFinalFactTables(int iDate)
        {
            SqlCommand Cmd = new SqlCommand();
            Cmd.Connection = Connection;
            Cmd.CommandType = CommandType.Text;

            foreach (string szTableName in m_FinalFactTables)
            {
                Cmd.CommandText   = string.Format("delete from {0} where i_date >= {1}", szTableName, iDate);
                Cmd.ExecuteNonQuery();
            }
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\Database\ReportingIIS.cs ===
using System;
using System.Collections.Generic;
using System.Collections.Specialized;
using System.Text;

using ServerTestFramework.STFLive.Reporting;
using ServerTestFramework.STFLive.Reporting.Service;

namespace ServerTestFramework.STFLive.Database
{
    /// <summary>
    /// Reporting Common Code object to extend the ReportingService Proxy class
    /// </summary>
    public class ReportingIIS : ServerTestFramework.STFLive.Reporting.ReportingDatabase 
    {
        private ServerTestFramework.STFLive.Reporting.Service.ReportingService _reportingService;   // Reporting Service

        private string m_DatabaseName = "ReportingIIS";
        /// <summary>
        /// The SQL name of the database (note: NOT THE MACHINE NAME)
        /// </summary>
        public override string DatabaseName
        {
            get
            {
                return m_DatabaseName;
            }
            set
            {
                m_DatabaseName = value;
            }
        }

        // Get Server Name (URL)
        private string m_ComponentName = "Uninitialized";
        public override string ComponentName
        {
            get {return m_ComponentName;}            
        }
        

        public ReportingIIS()
        {
            _reportingService = new ReportingService(null);
        }

        public ReportingIIS(string ReportingURL)
        {
            if (ReportingURL == null)
            {
                // By default use STRESSNET Report Server URL
                ReportingURL = "https://reports.test.xboxlive.com/ReportServer/ReportService.asmx";
                
            }
            // Initialize Proxy class
            _reportingService = new ReportingService(ReportingURL);
            m_ComponentName = ReportingURL;            
        }

        /// <summary>
        /// Submit a report request to the Reporting Web Service. 
        /// </summary>
        /// <param name="ReportPath">Full path of the report in the web server. Example: XBOX Live New Portal\Title Usage Report\Title Usage Summary</param>
        /// <param name="SavePath">Path of report export file</param>
        /// <param name="FileName">Name of report export file</param>
        /// <param name="ReportParameters">Name/Value Collection of report input parameters to submit to the server. 
        /// These input parameters can be found in the report RDL</param>
        /// <param name="ReportFormat">Report export format. Default format is XML</param>
        /// <returns>True if execution was successful</returns>
        public bool GetXMLReportingServerData(string ReportPath, string SavePath, string FileName, NameValueCollection ReportParameters, string ReportFormat)
        {
            string Savepathfilename = SavePath + FileName;            
            
            // Render arguments
            byte[] result = null;
            //string reportPath = "/XBOX Live New Portal/Administrative Reports/Daily Component Process";
            string reportPath = ReportPath;
            int totalParams = 0;
            string format;

            // Check for valid parameters. ReportParameters is not checked because a report may not require inputs
            if (ReportPath == null || SavePath == null || FileName == null)
            {
                return false;
            }
            if (ReportFormat == null)
            {
                // load the binary into an XML document //OTHER FORMATS format = "CSV" or format = "MHTML";
                format = "XML";
            }
            else
            {
                format = ReportFormat;
            }
            if (ReportParameters != null)
            {
                totalParams = ReportParameters.Count;
            }                                   

            // Comment the line above and uncomment the lines below if using a Report Service proxy class from WSDL                
            _reportingService.Credentials = System.Net.CredentialCache.DefaultCredentials;

            System.Xml.XmlDocument doc = new System.Xml.XmlDocument();

            // ***
            // REPORT PARAMETERS
            // ***
            ParameterValue[] parameters = new ParameterValue[totalParams];

            for (int i = 0; i < totalParams; i++)
            {
                parameters[i] = new ParameterValue();
                parameters[i].Name = ReportParameters.AllKeys[i];
                parameters[i].Value = ReportParameters.Get(i);

                // Search for Multi-value parameters and set the parameter names to be the same
                for (int j = 0; j < totalParams; j++)
                {
                    if (ReportParameters.AllKeys[i].Substring(0, ReportParameters.AllKeys[i].Length - 3) ==
                        ReportParameters.GetKey(j))
                    {
                        parameters[i].Name = ReportParameters.GetKey(j);
                        break;
                    }
                }
            }

            // Report request parameters
            DataSourceCredentials[] credentials = null;
            string historyID = null;
            string showHideToggle = null;

            // OUT parameters
            string mimeType;
            string encoding;
            Warning[] warnings = null;
            string[] streamIDs = null;
            ParameterValue[] reportHistoryParameters = null;

            // XML Format options
            string devInfo = @"<DeviceInfo><Indented>True</Indented><FileExtension>xml</FileExtension></DeviceInfo>";

            SessionHeader sh = new SessionHeader();
            _reportingService.SessionHeaderValue = sh;

            // Set Timeout limit
            _reportingService.Timeout = 450000;// 300000; // 5 MINUTES WAIT LIMIT                        

            // Submit repor request
            result = _reportingService.Render(reportPath, format, historyID, devInfo, parameters, credentials,
                showHideToggle, out encoding, out mimeType, out reportHistoryParameters, out warnings, out streamIDs);

            // Save report as an xml file
            doc.Load(new System.IO.MemoryStream(result));
            doc.Save(Savepathfilename);
                        
            return true;
        } // GetXMLReportData()


        /// <summary>
        /// Get report parameters from Service.
        /// </summary>
        /// <param name="ReportPath">Path to report</param>
        /// <returns>String of parameter names</returns>
        public List<string> GetReportParameters(string ReportPath)
        {
            DataSourceCredentials[] credentials = null;
            string historyID = null; List<string> retVal = null;
            ParameterValue[] reportHistoryParameters = null;
            ReportParameter[] rparms = null;

            // Check parameters
            if (ReportPath == null || ReportPath == "")
            {
                throw new Exception("Reporting Service Error: Invalid ReportPath - GetReportParameters()");
            }

            // Set credentials for connection
            _reportingService.Credentials = System.Net.CredentialCache.DefaultCredentials;

            SessionHeader sh = new SessionHeader();
            _reportingService.SessionHeaderValue = sh;

            // Set Timeout limit
            _reportingService.Timeout = 450000;

            // Get report parameters
            rparms = _reportingService.GetReportParameters(ReportPath, historyID, false, reportHistoryParameters, credentials);

            // Get Parameter Names
            retVal = new List<string>(rparms.Length);
            foreach (ReportParameter rparm in rparms)
            {
                retVal.Add(rparm.Name);
            }

            return retVal;
        }




        /// <summary>
        /// Runs a query against the database (all tables).  Returns data for small tables (less than 20 rows), returns counts for all other tables
        /// </summary>
        /// <returns>Query Results</returns>
        public override string RunDebugQuery() 
        {
            throw new Exception("This functionality is not currently available");
        }
        /// <summary>
        /// Runs a query against the tables for this database using the data available in the reference objects
        /// </summary>
        /// <param name="reportingRefObject"></param>
        /// <returns></returns>
        public override string RunDebugQuery(ReportingReferenceObject reportingRefObject) 
        {
            throw new Exception("This functionality is not currently available");
        }
        /// <summary>
        /// Queues a job to be run using the default parameters for that job (specific to that job)
        /// Validates that this job can be run on this server
        /// </summary>
        /// <param name="jobType">Type of job to be run</param>
        /// <returns>Could job be queued</returns>
        public override ReportingJob QueueJob(ReportingJobType jobType)
        {
            throw new Exception("This functionality is not currently available");
        }
        /// <summary>
        /// Queues a job to be run using the specified parameters for that job (specific to that job)
        /// Validates that this job can be run on this server
        /// </summary>
        /// <param name="jobType">Type of job to be run</param>
        /// <returns>Could job be queued</returns>
        public override ReportingJob QueueJob(ReportingJobType jobType, ReportingJobParameters jobParameters)
        {
            throw new Exception("This functionality is not currently available");
        }
        /// <summary>
        /// Runs the queued jobs
        /// </summary>
        /// <returns>An array list with the return values with the associated ReportingJob Objects which contain the results of each job</returns>
        public override List<ReportingJob> RunJobs()
        {
            throw new Exception("This functionality is not currently available");
        }
    
        /// <summary>
        /// Updates the status of the queued jobs. *Note that only jobs that have already been started will be updated*
        /// </summary>
        /// <returns>An array list of the currently queued jobs with their updated status</returns>>        
        public override List<ReportingJob> GetCurrentJobStatus()
        {
            throw new Exception("This functionality is not currently available");
        }
        /// <summary>
        /// Inserts a certain data set and returns a reference object to that data set
        /// </summary>
        /// <param name="row"></param>
        /// <param name="reportingRefObject"></param>
        /// <returns></returns>
        public override string InjectSingleData(ReportingDataLoader data, out ReportingReferenceObject reportingRefObject)
        {
            throw new Exception("This functionality is not currently available");
        }
        /// <summary>
        /// Inserts a certain data set and returns a reference object to that data set
        /// </summary>
        /// <param name="table"></param>
        /// <param name="reportingRefObjectContainer"></param>
        /// <returns></returns>
        public override string InjectData(ReportingDataLoader data, out ReportingReferenceObjectContainer reportingRefObjectContainer)
        {
            throw new Exception("This functionality is not currently available");
        }
        /// <summary>
        /// Inserts a randomly generated reporting data type into that particular database, returns a reference object to that item.
        /// </summary>
        /// <param name="dataType"></param>
        /// <param name="refObjectContainer"></param>
        /// <returns>SQL results of inserting the data</returns>
        public override string InjectSingleRandomData(ReportingDataType dataType, out ReportingReferenceObject reportingRefObject)
        {
            throw new Exception("This functionality is not currently available");
        }
        /// <summary>
        /// Insters a set of randomly generated data into the database
        /// </summary>
        /// <param name="dataType">Type of data to insert</param>
        /// <param name="count">How many objects to insert</param>
        /// <param name="container">A reference object to this data</param>
        /// <returns>SQL results of inserting that data</returns>
        public override string InjectRandomData(ReportingDataType dataType, long count, out ReportingReferenceObjectContainer container)
        {
            throw new Exception("This functionality is not currently available");
        }
        /// <summary>
        /// Collects information about the current replication status
        /// </summary>
        /// <returns>A string describing any streams present as well as their status</returns>
        public override string ListReplicationStreamsAndStatus()
        {
            throw new Exception("This functionality is not currently available");
        }
        /// <summary>
        /// Verifies that data represented within the reference object is present in this database
        /// Throws an exception if verification fails
        /// </summary>
        /// <param name="refObject">Object whose data needs verifying</param>
        /// <returns>Description of what was verified</returns>
        public override string Verify(ReportingReferenceObject refObject)
        {
            throw new Exception("This functionality is not currently available");
        }
        /// <summary>
        /// Verifies that ALL data represented within the reference object container is present in this database
        /// Throws an exception if verification fails
        /// </summary>
        /// <param name="refObjectContainer">Object whose data needs verifying</param>
        /// <returns>Description fo what was verified</returns>
        public override string Verify(ReportingReferenceObjectContainer refObjectContainer)
        {
            throw new Exception("This functionality is not currently available");
        }



    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\Database\ReportingArchive.cs ===
using System;
using System.Data;
using System.Collections;
using System.Collections.Generic;
using System.Data.SqlClient;
using ServerTestFramework.STFLive.Reporting;

namespace ServerTestFramework.STFLive.Database
{
    public class ReportingArchiveDatabase : ReportingDatabase
    {
        public ReportingArchiveDatabase()
        {
            JobQueue = new List<ReportingJob>(10);
            JobThreads = new Hashtable(10);
        }

        ~ReportingArchiveDatabase()
        {
            Close();
        }

        // Close
        public void Close()
        {
            // m_SqlConnection could be null
            if (m_SqlConnection != null && m_SqlConnection.State != ConnectionState.Closed)
            {
                try
                {
                    m_SqlConnection.Close();
                }
                catch
                {
                    // do nothing here
                }
                finally
                {
                    m_SqlConnection = null;
                }
            }

            CloseJobQueueThreads();
        }



        /// <summary>
        /// What type server you are dealing with
        /// </summary>
        public override ReportingMachines ComponentType
        {
            get
            {
                return ReportingMachines.Archive;
            }
        }

        // Connection
        private SqlConnection Connection
        {
            get { return m_SqlConnection; }
        }

        // Open connection to server
        public void ConnectToServer(string serverName)
        {
            this.ConnectToServer(serverName, m_DatabaseName);
        }

        // BUGBUG: Probably should be an enum rather than a string (to reduce the chance that we'll have a bug
        // trying to connect to a non-existant DB when we switch environments)
        public void ConnectToServer(string serverName, string database)
        {
            m_ServerName = serverName;
            m_DatabaseName = database;
            m_SqlConnection = new SqlConnection("server=" + serverName + ";database=" + database + ";Integrated Security=SSPI");
            m_SqlConnection.Open();
        }



        private string m_ServerName = "";
        /// <summary>
        /// The name of the server you are dealing with
        /// </summary>
        public override string ComponentName
        {
            get
            {
                return m_ServerName;
            }
        }

        /// <summary>
        /// API to inject an event
        /// </summary>
        /// <param name="type"></param>
        /// <param name="reportingRefObject"></param>
        /// <returns></returns>
        public override string InjectEvent(ReportingEventType type, out ReportingReferenceObject reportingRefObject)
        {
            reportingRefObject = null;
            return "";
        }

        /// <summary>
        /// API that injects the next event in a series of events
        /// </summary>
        /// <param name="type"></param>
        /// <param name="reportingRefObject"></param>
        /// <returns></returns>
        public override string InjectNextEvent(ReportingEventType type, ref ReportingReferenceObject reportingRefObject)
        {
            return "";
        }

        /// <summary>
        /// Gets a performance counter that is an integer
        /// </summary>
        /// <param name="Counter"></param>
        /// <returns></returns>
        public override int GetIntPerformanceCounter(string Counter)
        {
            return -1;
        }

        /// <summary>
        /// Gets a performance counter that is a floating point number
        /// </summary>
        /// <param name="Counter"></param>
        /// <returns></returns>
        public override float GetFloatPerformanceCounter(string Counter)
        {
            return -0.0f;
        }


        private string m_DatabaseName = "ReportArchiveDB";
        /// <summary>
        /// The SQL name of the database (note: NOT THE MACHINE NAME)
        /// </summary>
        public override string DatabaseName
        {
            get
            {
                return m_DatabaseName;
            }
            set
            {
                m_DatabaseName = value;
            }
        }

        /// <summary>
        /// Runs a query against the database (all tables).  Returns data for small tables (less than 20 rows), returns counts for all other tables
        /// </summary>
        /// <returns>Query Results</returns>
        public override string RunDebugQuery()
        {
            // TODO: Implement me
            return "";
        }

        /// <summary>
        /// Queues a job to be run using the default parameters for that job (specific to that job)
        /// Validates that this job can be run on this server
        /// </summary>
        /// <param name="jobType">Type of job to be run</param>
        /// <returns>Could job be queued</returns>
        public override ReportingJob QueueJob(ReportingJobType jobType)
        {
            ReportingJobParameters defaultJobParams = null;

            switch (jobType)
            {
                case ReportingJobType.ReportArchiveDB_TransferFactData:
                    defaultJobParams = new ReportArchiveDB_TransferFactData.ReportArchiveDB_TransferFactData_Params();
                    break;
                case ReportingJobType.ReportArchiveDB_UpdateFilegroups:
                    defaultJobParams = new ReportArchiveDB_UpdateFilegroups.ReportArchiveDB_UpdateFilegroups_Params();
                    break;
                default:
                    // Invalid Job Type for this database
                    throw new Exception("Invalid Job Type. This specified job does not exist on this database");
            }

            return QueueJob(jobType, defaultJobParams);
        }

        /// <summary>
        /// Queues a job to be run using the specified parameters for that job (specific to that job)
        /// Validates that this job can be run on this server
        /// </summary>
        /// <param name="jobType">Type of job to be run</param>
        /// <returns>Could job be queued</returns>
        public override ReportingJob QueueJob(ReportingJobType jobType, ReportingJobParameters jobParameters)
        {
            ReportingJob retVal = null;
            bool jobExists = false;
            
            // Get job factory instance
            ReportingJobFactory jobFactory = ReportingJobFactory.Instance;
            
            // Create job through factory
            switch (jobType)
            {
                case ReportingJobType.ReportArchiveDB_TransferFactData: // ArchiveDB: Transfer Fact Data
                    retVal = jobFactory.CreateReportingJob(jobType, jobParameters);
                    break;
                case ReportingJobType.ReportArchiveDB_UpdateFilegroups: // ArchiveDB: Update File Groups
                    retVal = jobFactory.CreateReportingJob(jobType, jobParameters);
                    break;
                default:
                    // Invalid Job Type for this database
                    throw new Exception("Invalid Job Type. This specified job does not exist on this database");                   
            }

            // Enforce synchronized access
            lock (JobQueue)
            {
                // Verify that job type is not already in queue
                for (int i = 0; i < JobQueue.Count; i++)
                {
                    if ((retVal.JobName == JobQueue[i].JobName) && (JobQueue[i].Parameters.Equals(jobParameters)))
                    {
                        retVal = null;          // Use existing job in queue
                        retVal = JobQueue[i];
                        jobExists = true;
                    }
                }
                if (!jobExists)
                {
                    JobQueue.Add(retVal);   // Add new job to database queue
                }
            }

            return retVal;            
        }
      

        /// <summary>
        /// Inserts a certain data set and returns a reference object to that data set
        /// </summary>
        /// <param name="row"></param>
        /// <param name="reportingRefObject"></param>
        /// <returns></returns>
        public override string InjectSingleData(ReportingDataLoader data, out ReportingReferenceObject reportingRefObject)
        {
            //TODO: Define loader
            reportingRefObject = null;
            return "";
        }
        /// <summary>
        /// Inserts a certain data set and returns a reference object to that data set
        /// </summary>
        /// <param name="table"></param>
        /// <param name="reportingRefObjectContainer"></param>
        /// <returns></returns>
        public override string InjectData(ReportingDataLoader data, out ReportingReferenceObjectContainer reportingRefObjectContainer)
        {
            //TODO: Again, define loader
            reportingRefObjectContainer = null;
            return "";
        }
        /// <summary>
        /// Inserts a randomly generated reporting data type into that particular database, returns a reference object to that item.
        /// </summary>
        /// <param name="dataType"></param>
        /// <param name="refObjectContainer"></param>
        /// <returns>SQL results of inserting the data</returns>
        public override string InjectSingleRandomData(ReportingDataType dataType, out ReportingReferenceObject reportingRefObject)
        {
            //TODO: Add data object factory
            //TODO: Run SQL to insert the data
            reportingRefObject = null;
            return "";
        }
        /// <summary>
        /// Insters a set of randomly generated data into the database
        /// </summary>
        /// <param name="dataType">Type of data to insert</param>
        /// <param name="count">How many objects to insert</param>
        /// <param name="container">A reference object to this data</param>
        /// <returns>SQL results of inserting that data</returns>
        public override string InjectRandomData(ReportingDataType dataType, long count, out ReportingReferenceObjectContainer reportingRefObjectContainer)
        {
            //TODO: Add data object factory
            //TODO: Run SQL to insert the data
            reportingRefObjectContainer = null;
            return "";
        }
        /// <summary>
        /// Collects information about the current replication status
        /// </summary>
        /// <returns>A string describing any streams present as well as their status</returns>
        public override string ListReplicationStreamsAndStatus()
        {

            return "";
        }

        /// <summary>
        /// Verifies that data represented within the reference object is present in this database
        /// Throws an exception if verification fails
        /// </summary>
        /// <param name="refObject">Object whose data needs verifying</param>
        /// <returns>Description of what was verified</returns>
        public override string Verify(ReportingReferenceObject refObject)
        {
            return "";
        }
        /// <summary>
        /// Verifies that ALL data represented within the reference object container is present in this database
        /// Throws an exception if verification fails
        /// </summary>
        /// <param name="refObjectContainer">Object whose data needs verifying</param>
        /// <returns>Description fo what was verified</returns>
        public override string Verify(ReportingReferenceObjectContainer refObjectContainer)
        {
            return "";
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\Database\ReportingSSIS.cs ===
using System;
using System.Collections;
using System.Collections.Generic;
using System.Data;
using System.Data.SqlClient;
using ServerTestFramework.STFLive.Reporting;

namespace ServerTestFramework.STFLive.Database
{
    public class ReportingSSIS : ReportingDatabase
    {
        
        public ReportingSSIS()
        {
            JobQueue = new List<ReportingJob>(10);
            JobThreads = new Hashtable(10);
        }

        ~ReportingSSIS()
        {
            Close();
        }
        
        
        /// <summary>
        /// What type server you are dealing with
        /// </summary>
        public override ReportingMachines ComponentType
        {
            get
            {
                return ReportingMachines.SSIS;
            }
        }

        private string m_ServerName = "";
        /// <summary>
        /// The name of the server you are dealing with
        /// </summary>
        public override string ComponentName
        {
            get
            {
                return m_ServerName;
            }
        }

        public SqlConnection Connection
        {
            get { return m_SqlConnection; }
        }

        public void ConnectToServer(string serverName)
        {
            this.ConnectToServer(serverName, m_DatabaseName);
        }

        // BUGBUG: Probably should be an enum rather than a string (to reduce the chance that we'll have a bug
        // trying to connect to a non-existant DB when we switch environments)
        public void ConnectToServer(string serverName, string database)
        {
            m_ServerName = serverName;
            m_DatabaseName = database;
            m_SqlConnection = new SqlConnection("server=" + serverName + ";database=" + database + ";Integrated Security=SSPI");
            m_SqlConnection.Open();
        }

        public void Close()
        {
            // m_SqlConnection could be null
            if (m_SqlConnection != null && m_SqlConnection.State != ConnectionState.Closed)
            {
                try
                {
                    m_SqlConnection.Close();
                }
                catch
                {
                    // do nothing here
                }
                finally
                {
                    m_SqlConnection = null;
                }
            }

            CloseJobQueueThreads();
        }



        /// <summary>
        /// API to inject an event
        /// </summary>
        /// <param name="type"></param>
        /// <param name="reportingRefObject"></param>
        /// <returns></returns>
        public override string InjectEvent(ReportingEventType type, out ReportingReferenceObject reportingRefObject)
        {
            reportingRefObject = null;
            return "";
        }

        /// <summary>
        /// API that injects the next event in a series of events
        /// </summary>
        /// <param name="type"></param>
        /// <param name="reportingRefObject"></param>
        /// <returns></returns>
        public override string InjectNextEvent(ReportingEventType type, ref ReportingReferenceObject reportingRefObject)
        {
            return "";
        }

        /// <summary>
        /// Gets a performance counter that is an integer
        /// </summary>
        /// <param name="Counter"></param>
        /// <returns></returns>
        public override int GetIntPerformanceCounter(string Counter)
        {
            return -1;
        }

        /// <summary>
        /// Gets a performance counter that is a floating point number
        /// </summary>
        /// <param name="Counter"></param>
        /// <returns></returns>
        public override float GetFloatPerformanceCounter(string Counter)
        {
            return -0.0f;
        }


        private string m_DatabaseName = "ReportSSISDB";
        /// <summary>
        /// The SQL name of the database (note: NOT THE MACHINE NAME)
        /// </summary>
        public override string DatabaseName
        {
            get
            {
                return m_DatabaseName;
            }
            set
            {
                m_DatabaseName = value;
            }
        }

        /// <summary>
        /// Runs a query against the database (all tables).  Returns data for small tables (less than 20 rows), returns counts for all other tables
        /// </summary>
        /// <returns>Query Results</returns>
        public override string RunDebugQuery()
        {
            // TODO: Implement me
            return "";
        }

        /// <summary>
        /// Queues a job to be run using the default parameters for that job (specific to that job)
        /// Validates that this job can be run on this server
        /// </summary>
        /// <param name="jobType">Type of job to be run</param>
        /// <returns>Could job be queued</returns>
        public override ReportingJob QueueJob(ReportingJobType jobType)
        {
            ReportingJobParameters defaultJobParams = null;
            switch (jobType)
            {
                case ReportingJobType.SSIS_Daily:   // Daily UODB SSIS
                    defaultJobParams = new UODB_Primary_SSIS.UODB_Primary_SSIS_Params();
                    break;
                case ReportingJobType.SSIS_Secondary:  // Weekly UODB SSIS
                    defaultJobParams = new UODB_Secondary_SSIS.UODB_Secondary_SSIS_Params();
                    break;
                case ReportingJobType.SSIS_Realtime:// Realtime SSIS
                    defaultJobParams = new UODB_Realtime_SSIS.UODB_Realtime_SSIS_Params();
                    break;
                case ReportingJobType.SSIS_Music:   // UODB Music SSIS
                    defaultJobParams = new UODB_Music_SSIS.UODB_Music_SSIS_Params();
                    break;
                case ReportingJobType.SSIS_Video:   // UODB Video SSIS
                    defaultJobParams = new UODB_Video_SSIS.UODB_Video_SSIS_Params();
                    break;
                case ReportingJobType.WMIS_Download:// WMIS Download
                    defaultJobParams = new WMIS_Download.WMIS_Download_Params();
                    break;
                case ReportingJobType.SSIS_Accounts:// UODB Accounts SSIS
                    defaultJobParams = new UODB_Accounts_SSIS.UODB_Accounts_SSIS_Params();
                    break;
                case ReportingJobType.SSIS_Offers:  // UODB Offers SSIS
                    defaultJobParams = new UODB_Offers_SSIS.UODB_Offers_SSIS_Params();
                    break;
                case ReportingJobType.SSIS_Purchase:// UODB PURCHASE SSIS
                    defaultJobParams = new UODB_Purchase_SSIS.UODB_Purchase_SSIS_Params();
                    break;
                case ReportingJobType.SCGImportFeed_SSIS:// SCG Import Feed
                    defaultJobParams = new SCGImportFeed_SSIS.SCGImportFeed_SSIS_Params();
                    break;
                case ReportingJobType.SSIS_CdbVideoProcessing:// SSIS Cdb Video Processing
                    defaultJobParams = new CdbVideoProcessing_SSIS.CdbVideoProcessing_SSIS_Params();
                    break;
                default:
                    // Invalid Job Type for this database
                    throw new Exception("Invalid Job Type. This specified job does not exist on this database"); 
            }

            return QueueJob(jobType, defaultJobParams);            
        }

        /// <summary>
        /// Queues a job to be run using the specified parameters for that job (specific to that job)
        /// Validates that this job can be run on this server
        /// </summary>
        /// <param name="jobType">Type of job to be run</param>
        /// <returns>Could job be queued</returns>
        public override ReportingJob QueueJob(ReportingJobType jobType, ReportingJobParameters jobParameters)
        {
            ReportingJob retVal = null;
            bool jobExists = false;

            // Get job factory instance
            ReportingJobFactory jobFactory = ReportingJobFactory.Instance;

            // Validate job type for this server            
            switch (jobType)
            {
                // Create job through factory
                case ReportingJobType.SSIS_Daily:   // Daily UODB SSIS                
                    retVal = jobFactory.CreateReportingJob(jobType, jobParameters);
                    break;
                case ReportingJobType.SSIS_Secondary:  // Secondary UODB SSIS
                    retVal = jobFactory.CreateReportingJob(jobType, jobParameters);
                    break;
                case ReportingJobType.SSIS_Realtime:// Realtime SSIS
                    retVal = jobFactory.CreateReportingJob(jobType, jobParameters);
                    break;
                case ReportingJobType.SSIS_Music:   // UODB Music SSIS
                    retVal = jobFactory.CreateReportingJob(jobType, jobParameters);
                    break;
                case ReportingJobType.SSIS_Video:   // UODB Video SSIS
                    retVal = jobFactory.CreateReportingJob(jobType, jobParameters);
                    break;
                case ReportingJobType.WMIS_Download:// WMIS Download
                    retVal = jobFactory.CreateReportingJob(jobType, jobParameters);
                    break;
                case ReportingJobType.SCGImportFeed_SSIS:// SCG Import Feed
                    retVal = jobFactory.CreateReportingJob(jobType, jobParameters);
                    break;
                case ReportingJobType.SSIS_Accounts:// UODB ACCOUNTS SSIS
                    retVal = jobFactory.CreateReportingJob(jobType, jobParameters);
                    break;
                case ReportingJobType.SSIS_Offers:  // UODB OFFERS SSIS
                    retVal = jobFactory.CreateReportingJob(jobType, jobParameters);
                    break;
                case ReportingJobType.SSIS_Purchase:// UODB PURCHASE SSIS
                    retVal = jobFactory.CreateReportingJob(jobType, jobParameters);
                    break;
                case ReportingJobType.SSIS_CdbVideoProcessing:// SSIS Cdb Video Processing
                    retVal = jobFactory.CreateReportingJob(jobType, jobParameters);
                    break;
                default:
                    // Invalid Job Type for this database
                    throw new Exception("Invalid Job Type. This specified job does not exist on this database");                    
            }

            // Enforce synchronized access
            lock (JobQueue)
            {
                // Verify that job type is not already in queue
                for (int i = 0; i < JobQueue.Count; i++)
                {
                    if ((retVal.JobName == JobQueue[i].JobName) && (JobQueue[i].Parameters.Equals(jobParameters)))
                    {
                        retVal = null;          // Use existing job in queue
                        retVal = JobQueue[i];
                        jobExists = true;
                    }
                }
                if (!jobExists)
                {
                    JobQueue.Add(retVal);   // Add new job to database queue
                }
            }

            return retVal;
        }
    

        /// <summary>
        /// Inserts a certain data set and returns a reference object to that data set
        /// </summary>
        /// <param name="row"></param>
        /// <param name="reportingRefObject"></param>
        /// <returns></returns>
        public override string InjectSingleData(ReportingDataLoader data, out ReportingReferenceObject reportingRefObject)
        {
            //TODO: Define loader
            reportingRefObject = null; 
            return "";
        }
        /// <summary>
        /// Inserts a certain data set and returns a reference object to that data set
        /// </summary>
        /// <param name="table"></param>
        /// <param name="reportingRefObjectContainer"></param>
        /// <returns></returns>
        public override string InjectData(ReportingDataLoader data, out ReportingReferenceObjectContainer reportingRefObjectContainer)
        {
            //TODO: Again, define loader
            reportingRefObjectContainer = null;
            return "";
        }
        /// <summary>
        /// Inserts a randomly generated reporting data type into that particular database, returns a reference object to that item.
        /// </summary>
        /// <param name="dataType"></param>
        /// <param name="refObjectContainer"></param>
        /// <returns>SQL results of inserting the data</returns>
        public override string InjectSingleRandomData(ReportingDataType dataType, out ReportingReferenceObject reportingRefObject)
        {
            //TODO: Add data object factory
            //TODO: Run SQL to insert the data
            reportingRefObject = null;
            return "";
        }
        /// <summary>
        /// Insters a set of randomly generated data into the database
        /// </summary>
        /// <param name="dataType">Type of data to insert</param>
        /// <param name="count">How many objects to insert</param>
        /// <param name="container">A reference object to this data</param>
        /// <returns>SQL results of inserting that data</returns>
        public override string InjectRandomData(ReportingDataType dataType, long count, out ReportingReferenceObjectContainer reportingRefObjectContainer)
        {
            //TODO: Add data object factory
            //TODO: Run SQL to insert the data
            reportingRefObjectContainer = null;
            return "";
        }
        /// <summary>
        /// Collects information about the current replication status
        /// </summary>
        /// <returns>A string describing any streams present as well as their status</returns>
        public override string ListReplicationStreamsAndStatus()
        {

            return "";
        }

        /// <summary>
        /// Verifies that data represented within the reference object is present in this database
        /// Throws an exception if verification fails
        /// </summary>
        /// <param name="refObject">Object whose data needs verifying</param>
        /// <returns>Description of what was verified</returns>
        public override string Verify(ReportingReferenceObject refObject)
        {            
            return "";
        }
        /// <summary>
        /// Verifies that ALL data represented within the reference object container is present in this database
        /// Throws an exception if verification fails
        /// </summary>
        /// <param name="refObjectContainer">Object whose data needs verifying</param>
        /// <returns>Description fo what was verified</returns>
        public override string Verify(ReportingReferenceObjectContainer refObjectContainer)
        {
            return "";
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\Database\ReportRealtimeDB.cs ===
using System;
using System.Collections;
using System.Collections.Generic;
using System.Collections.Specialized;
using System.Text;
using System.Data;
using System.Data.SqlClient;

using ServerTestFramework.STFLive.Reporting;

namespace ServerTestFramework.STFLive.Database
{
    /// <summary>
    /// Reporting Realtime Database Object
    /// </summary>
    public class ReportRealtimeDB : ServerTestFramework.STFLive.Reporting.ReportingDatabase 
    {
        protected string m_ServerName;

        private string m_DatabaseName = "ReportRealtimeDB";
        /// <summary>
        /// The SQL name of the database (note: NOT THE MACHINE NAME)
        /// </summary>
        public override string DatabaseName
        {
            get
            {
                return m_DatabaseName;
            }
            set
            {
                m_DatabaseName = value;
            }
        }

        public ReportRealtimeDB()
        {
            JobQueue = new List<ReportingJob>(10);
            JobThreads = new Hashtable(10);
        }

        ~ReportRealtimeDB()
        {
            Close();
        }

        public void ConnectToServer(string serverName)
        {
            this.ConnectToServer(serverName, m_DatabaseName);
        }

        // BUGBUG: Probably should be an enum rather than a string (to reduce the chance that we'll have a bug
        // trying to connect to a non-existant DB when we switch environments)
        public void ConnectToServer(string serverName, string database)
        {
            m_ServerName = serverName;
            m_DatabaseName = database;
            m_SqlConnection = new SqlConnection("server=" + serverName + ";database=" + database + ";Integrated Security=SSPI");
            m_SqlConnection.Open();
        }

        public void Close()
        {
            // m_SqlConnection could be null
            if (m_SqlConnection != null && m_SqlConnection.State != ConnectionState.Closed)
            {
                try
                {
                    m_SqlConnection.Close();
                }
                catch
                {
                    // do nothing here
                }
                finally
                {
                    m_SqlConnection = null;
                }
            }

            CloseJobQueueThreads();
        }

        public SqlConnection Connection
        {
            get { return m_SqlConnection; }
        }

        public System.Data.ConnectionState ConnectionState
        {
            get { return m_SqlConnection.State; }
        }

        /// <summary>
        /// What type server you are dealing with
        /// </summary>
        public override ReportingMachines ComponentType
        {
            get
            {
                return ReportingMachines.Realtime;
            }
        }

        /// <summary>
        /// The name of the server you are dealing with
        /// </summary>
        public override string ComponentName
        {
            get
            {
                return m_ServerName;
            }
        }




        /// <summary>
        /// Runs a query against the database (all tables).  Returns data for small tables (less than 20 rows), returns counts for all other tables
        /// </summary>
        /// <returns>Query Results</returns>
        public override string RunDebugQuery() 
        {
            throw new Exception("This functionality is not currently available");
        }
      
        /// <summary>
        /// Queues a job to be run using the default parameters for that job (specific to that job)
        /// Validates that this job can be run on this server
        /// </summary>
        /// <param name="jobType">Type of job to be run</param>
        /// <returns>Could job be queued</returns>
        public override ReportingJob QueueJob(ReportingJobType jobType)
        {
            ReportingJobParameters defaultJobParams = null;
            switch (jobType)
            {
                case ReportingJobType.RealtimeDB_RealtimeProcessing:   // Realtime Processing
                    defaultJobParams = new RealtimeDB_RealtimeProcessing.RealtimeDB_PurgeFactTables_Params();
                    break;
                case ReportingJobType.RealtimeDB_PurgeFact:             // Realtime Purge Fact Tables
                    defaultJobParams = new RealtimeDB_PurgeFactTables.RealtimeDB_PurgeFactTables_Params();
                    break;
                
                default:
                    // Invalid Job Type for this database
                    throw new Exception("Invalid Job Type. This specified job does not exist on this database");
            }

            return QueueJob(jobType, defaultJobParams);       
        }
        /// <summary>
        /// Queues a job to be run using the specified parameters for that job (specific to that job)
        /// Validates that this job can be run on this server
        /// </summary>
        /// <param name="jobType">Type of job to be run</param>
        /// <returns>Could job be queued</returns>
        public override ReportingJob QueueJob(ReportingJobType jobType, ReportingJobParameters jobParameters)
        {
            ReportingJob retVal = null;
            bool jobExists = false;

            // Get job factory instance
            ReportingJobFactory jobFactory = ReportingJobFactory.Instance;

            // Validate job type for this server            
            switch (jobType)
            {
                // Create job through factory
                case ReportingJobType.RealtimeDB_RealtimeProcessing:   // Realtime Processing
                    retVal = jobFactory.CreateReportingJob(jobType, jobParameters);
                    break;
                case ReportingJobType.RealtimeDB_PurgeFact:             // Realtime Purge Fact Tables
                    retVal = jobFactory.CreateReportingJob(jobType, jobParameters);
                    break;

                default:
                    // Invalid Job Type for this database
                    throw new Exception("Invalid Job Type. This specified job does not exist on this database");
            }
             // Enforce synchronized access
            lock (JobQueue)
            {
                // Verify that job type is not already in queue
                for (int i = 0; i < JobQueue.Count; i++)
                {
                    if ((retVal.JobName == JobQueue[i].JobName) && (JobQueue[i].Parameters.Equals(jobParameters)))
                    {
                        retVal = null;          // Use existing job in queue
                        retVal = JobQueue[i];
                        jobExists = true;
                    }
                }
                if (!jobExists)
                {
                    JobQueue.Add(retVal);   // Add new job to database queue
                }
            }

            return retVal;
        }

        
        /// <summary>
        /// Inserts a certain data set and returns a reference object to that data set
        /// </summary>
        /// <param name="row"></param>
        /// <param name="reportingRefObject"></param>
        /// <returns></returns>
        public override string InjectSingleData(ReportingDataLoader data, out ReportingReferenceObject reportingRefObject)
        {
            throw new Exception("This functionality is not currently available");
        }
        /// <summary>
        /// Inserts a certain data set and returns a reference object to that data set
        /// </summary>
        /// <param name="table"></param>
        /// <param name="reportingRefObjectContainer"></param>
        /// <returns></returns>
        public override string InjectData(ReportingDataLoader data, out ReportingReferenceObjectContainer reportingRefObjectContainer)
        {
            throw new Exception("This functionality is not currently available");
        }
        /// <summary>
        /// Inserts a randomly generated reporting data type into that particular database, returns a reference object to that item.
        /// </summary>
        /// <param name="dataType"></param>
        /// <param name="refObjectContainer"></param>
        /// <returns>SQL results of inserting the data</returns>
        public override string InjectSingleRandomData(ReportingDataType dataType, out ReportingReferenceObject reportingRefObject)
        {
            throw new Exception("This functionality is not currently available");
        }
        /// <summary>
        /// Insters a set of randomly generated data into the database
        /// </summary>
        /// <param name="dataType">Type of data to insert</param>
        /// <param name="count">How many objects to insert</param>
        /// <param name="container">A reference object to this data</param>
        /// <returns>SQL results of inserting that data</returns>
        public override string InjectRandomData(ReportingDataType dataType, long count, out ReportingReferenceObjectContainer container)
        {
            throw new Exception("This functionality is not currently available");
        }
        /// <summary>
        /// Collects information about the current replication status
        /// </summary>
        /// <returns>A string describing any streams present as well as their status</returns>
        public override string ListReplicationStreamsAndStatus()
        {
            throw new Exception("This functionality is not currently available");
        }
        /// <summary>
        /// Verifies that data represented within the reference object is present in this database
        /// Throws an exception if verification fails
        /// </summary>
        /// <param name="refObject">Object whose data needs verifying</param>
        /// <returns>Description of what was verified</returns>
        public override string Verify(ReportingReferenceObject refObject)
        {
            throw new Exception("This functionality is not currently available");
        }
        /// <summary>
        /// Verifies that ALL data represented within the reference object container is present in this database
        /// Throws an exception if verification fails
        /// </summary>
        /// <param name="refObjectContainer">Object whose data needs verifying</param>
        /// <returns>Description fo what was verified</returns>
        public override string Verify(ReportingReferenceObjectContainer refObjectContainer)
        {
            throw new Exception("This functionality is not currently available");
        }



    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\Database\StatsWS.cs ===
using System;
using System.Collections;
using System.Data;
using System.Threading;

using Microsoft.Webstore.WstClient;
using xonline.common.sql.webstore;
using xonline.common.config;
using xonline.common.service;
using xonline.common.protocol;
using Microsoft.Xbox.Privacy.Client;
using ServerTestFramework.LiveService;

namespace ServerTestFramework.Database
{
    /// <summary>
    /// Summary description for StatsWS.
    /// </summary>
    public class StatsWS
    {
        // partitioned by user puid
        static public object GetUserStats(long puid, int title, int lbid)
        {
            object Statsvalue = null;
            string query = "SELECT [vb_data] FROM [t_stats_leaderboard_data] where [i_title_id]= " + title + " and  [i_lb_id]=" + lbid + " and [bi_puid]=" + puid;

            Statsvalue = UodbWS.ExecuteSQLScalar(query, puid);
            return Statsvalue;
        }


        static public int GetGUIDOccurrences(Guid guid, ulong puid)
        {
            int retval = 0;
            string query = "SELECT i_occurrences FROM [t_sync_guids] where bi_user_id =" + puid + " and bin_guid=0x" + ByteConvert.ToString(guid.ToByteArray());

            using (WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITETHENREAD_COMMANDTYPE))
            {
                for (int p = 0; p < ws.PhysicalPartitions; p++)
                {
                    ws.ClearParameters();
                    ws.PhysicalPartition = p;
                    ws.CommandSql = query;

                    object val = ws.ExecuteScalar();
                    if (val != null)
                    {
                        retval = (int)val;
                        System.Console.WriteLine(ws.Command.Database.Name);
                    }
                }

                return retval;
            }
        }

        static public ulong GetTeamid(string teamName, uint titleid)
        {
            ulong teamid = 0;

            string query = "SELECT [bi_team_puid] FROM [t_xprof_team_names]";
            query += " where i_title_id=" + titleid.ToString() + " and vc_full_name='" + teamName + "'";

            using (WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITETHENREAD_COMMANDTYPE))
            {
                for (int p = 0; p < ws.PhysicalPartitions; p++)
                {
                    ws.ClearParameters();
                    ws.PhysicalPartition = p;
                    ws.CommandSql = query;
                    object retval = ws.ExecuteScalar();
                    if (retval != null)
                        teamid = (ulong)((long)ws.ExecuteScalar());
                    if (teamid != 0)
                        break;
                }

                return teamid;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\Database\SecUserHistoryWS.cs ===
using System;
using System.Collections;
using System.Text;
using System.Transactions;
using Microsoft.Webstore.WstClient;

using xonline.common.sql.webstore;
using xonline.common.config;
using xonline.common.protocol;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.Billing;
using System.Collections.Generic;

namespace ServerTestFramework.Database
{
    /// <summary>
    /// Interfaces with the SecUserHistory WebStore - taking into account partitioned tables
    /// </summary>
    public class SecUserHistoryWS
    {
        public static String WebstoreApp
        {
            get { return ConfigUtil.SecUserHistoryWebstoreApp; }
        }

        /// <summary>
        /// Execute a SQL Scalar statment that returns a single value using Webstore
        /// </summary>
        /// <param name="sql">The scalar SQL statement to execute</param>
        /// <param name="hash">The object to use as the Webstore hash value, or null to set AnyPartition</param>
        /// <returns>The result of the select statement</returns>
        public static object ExecuteSQLScalar(string sql, object hash)
        {
            return WebstoreDB.ExecuteSQLScalar(WebstoreApp, sql, hash);
        }

        /// <summary>
        /// Execute a SQL WRITEONLY command using Webstore
        /// </summary>
        /// <param name="sql">The scalar SQL statement to execute</param>
        /// <param name="hash">The object to use as the Webstore hash value, or null to set AllPhysicalPartitions</param>
        /// <returns>The number of affected rows</returns>
        public static int ExecuteSQLNonQuery(string sql, object hash)
        {
            return WebstoreDB.ExecuteSQLNonQuery(WebstoreApp, sql, hash);
        }

        /// <summary>
        /// Execute a SQL select count command using Webstore.
        /// </summary>
        /// <param name="sql">The SQL count statement to execute</param>
        /// <returns>The number sum of the counts across each partition</returns>
        public static uint ExecuteSQLSelectCount(string sql)
        {
            return WebstoreDB.ExecuteSQLSelectCount(WebstoreApp, sql);
        }

        /// <summary>
        /// Get the total number of physical partitions
        /// </summary>
        /// <returns>The total number of physical partitions</returns>
        public static int WstPhysicalPartitionCount()
        {
            return WebstoreDB.WstPhysicalPartitionCount(WebstoreApp);
        }

        /// <summary>
        /// Get the logical partition from a given hash object(si_hash_bucket)
        /// </summary>
        /// <param name="hash">The object to get the Webstore Hash Bucket for.</param>
        /// <returns>The webstore hash bucket for the given object</returns>
        public static int GetHashBucket(object hash)
        {
            return WebstoreDB.GetHashBucket(WebstoreApp, hash);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\Database\SecMachineHistoryWS.cs ===
using System;
using System.Collections;
using System.Text;
using System.Transactions;
using Microsoft.Webstore.WstClient;

using xonline.common.sql.webstore;
using xonline.common.config;
using xonline.common.protocol;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.Billing;
using System.Collections.Generic;

namespace ServerTestFramework.Database
{
    /// <summary>
    /// Interfaces with the SecUserHistory WebStore - taking into account partitioned tables
    /// </summary>
    public class SecMachineHistoryWS
    {
        public static String WebstoreApp
        {
            get { return ConfigUtil.SecMachineHistoryWebstoreApp; }
        }

        /// <summary>
        /// Execute a SQL Scalar statment that returns a single value using Webstore
        /// </summary>
        /// <param name="sql">The scalar SQL statement to execute</param>
        /// <param name="hash">The object to use as the Webstore hash value, or null to set AnyPartition</param>
        /// <returns>The result of the select statement</returns>
        public static object ExecuteSQLScalar(string sql, object hash)
        {
            return WebstoreDB.ExecuteSQLScalar(WebstoreApp, sql, hash);
        }

        /// <summary>
        /// Execute a SQL WRITEONLY command using Webstore
        /// </summary>
        /// <param name="sql">The scalar SQL statement to execute</param>
        /// <param name="hash">The object to use as the Webstore hash value, or null to set AllPhysicalPartitions</param>
        /// <returns>The number of affected rows</returns>
        public static int ExecuteSQLNonQuery(string sql, object hash)
        {
            return WebstoreDB.ExecuteSQLNonQuery(WebstoreApp, sql, hash);
        }

        /// <summary>
        /// Execute a SQL select count command using Webstore.
        /// </summary>
        /// <param name="sql">The SQL count statement to execute</param>
        /// <returns>The number sum of the counts across each partition</returns>
        public static uint ExecuteSQLSelectCount(string sql)
        {
            return WebstoreDB.ExecuteSQLSelectCount(WebstoreApp, sql);
        }

        /// <summary>
        /// Get the total number of physical partitions
        /// </summary>
        /// <returns>The total number of physical partitions</returns>
        public static int WstPhysicalPartitionCount()
        {
            return WebstoreDB.WstPhysicalPartitionCount(WebstoreApp);
        }

        /// <summary>
        /// Get the logical partition from a given hash object(si_hash_bucket)
        /// </summary>
        /// <param name="hash">The object to get the Webstore Hash Bucket for.</param>
        /// <returns>The webstore hash bucket for the given object</returns>
        public static int GetHashBucket(object hash)
        {
            return WebstoreDB.GetHashBucket(WebstoreApp, hash);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\Database\TokendbWS.cs ===
using System;
using System.Text;
using System.Data;
using System.Data.SqlClient;
using System.Data.Common;
using System.Collections;
using System.Collections.Generic;
using System.IO;
using System.Threading;
using System.Diagnostics;
using System.Xml;
using System.Runtime.InteropServices;
using System.Security.Cryptography;

using ServerTestFramework.Utilities;

using Microsoft.Webstore.WstClient;
using xonline.common.sql.webstore;
using xonline.common.config;
using xonline.common.billing;

namespace ServerTestFramework.Database
{

    /// <summary>
    /// Interfaces with the TokenDB WebStore - taking into account partitioned tables
    /// </summary>
    public class TokendbWS
    {
        //static constructor
        static TokendbWS()
        {
            //We can catch the first time TokendbWS is referenced here and force the environment to be reset.
            //This doesn't catch cases where the environment is changed after starting, but it's an improvement over never catching it.
            Global.ResetEnvironment();
        }

        // Using Webstore. select statement only, can set to AnyPartition by making hash to null
        public static object ExecuteSQLScalar(string sql, object hash)
        {
            return WebstoreDB.ExecuteSQLScalar(ConfigUtil.TokendbWebstoreApp, sql, hash);
        }

        // Using Webstore. WRITEONLY command type, can set to All Physical Partitions by makeing hash to null
        public static int ExecuteSQLNonQuery(string sql, object hash)
        {
            return WebstoreDB.ExecuteSQLNonQuery(ConfigUtil.TokendbWebstoreApp, sql, hash);
        }

        // Using Webstore. "select count" statement only.  Sums together the scalar returned for each partition and returns that.
        public static uint ExecuteSQLSelectCount(string sql)
        {
            return WebstoreDB.ExecuteSQLSelectCount(ConfigUtil.TokendbWebstoreApp, sql);
        }

        // get the total number of physical partitions
        public static int WstPhysicalPartitionCount()
        {
            return WebstoreDB.WstPhysicalPartitionCount(ConfigUtil.TokendbWebstoreApp);
        }

        // get the logical partition from hash (si_hash_bucket)
        public static int GetHashBucket(object hash)
        {
            return WebstoreDB.GetHashBucket(ConfigUtil.TokendbWebstoreApp, hash);
        }


        //
        // voucher related methods
        //

        public static string GetVoucherHash(string voucherCode)
        {
            byte[] hash = GetVoucherHashBytes(voucherCode);

            string s = "";
            foreach (byte b in hash) s += b.ToString("X2");
            return s;
        }

        public static byte[] GetVoucherHashBytes(string voucherCode)
        {
            return VoucherUtil.GetVoucherHash(voucherCode);
        }

        public static ulong HashVoucherBytes(byte[] voucherHash)
        {
            byte[] bytes = (byte[])voucherHash.Clone();
            System.Array.Resize(ref bytes, 8); //we only use the first 8 bytes to hash
            return BitConverter.ToUInt64(bytes, 0);
        }

        /// <summary>
        /// Returns whether a specific voucher exists.
        /// </summary>
        public static bool DoesVoucherExist(byte[] hash, ulong offer)
        {
            bool exist = false;
            string sql = "SELECT bi_offer_id FROM dbo.t_vouchers WHERE bin_voucher_hash=0x" + Hexer.tohex(hash) + " and bi_offer_id= 0x" + offer.ToString("x");

            using (WSClient ws = new WSClient(ConfigUtil.TokendbWebstoreApp, CmdType.WRITETHENREAD_COMMANDTYPE))
            {
                ws.PartitionType = WstPartitionType.Logical;
                ws.SetHashVal(BitConverter.ToInt64(hash, 0));
                ws.CommandSql = sql;

                if (ws.ExecuteScalar() != null)
                {
                    exist = true;
                }

                return exist;
            }
        }

        // offer id: 0xFFFE000080000001 or -562947805937663
        public static void AddVoucher(string hash, int useCount, byte inScg, byte consoleVersion)
        {
            AddVoucherForOffer(hash, 0xFFFE000080000001, useCount, inScg, consoleVersion);
        }

        public static void AddVoucherForOffer(string hash, ulong offerId, int useCount, byte inScg, byte consoleVersion)
        {
            DeleteVoucher(hash);

            using (WSClient ws = new WSClient(ConfigUtil.TokendbWebstoreApp, CmdType.WRITEONLY_COMMANDTYPE))
            {
                ws.PartitionType = WstPartitionType.Logical;
                byte[] hashBytes = Hexer.unhex(hash);
                ws.SetHashVal(BitConverter.ToInt64(hashBytes, 0));

                string sql = "INSERT INTO [dbo].[t_vouchers] (bin_voucher_hash,bi_offer_id,i_use_count,f_in_scg,f_console_version,si_hash_bucket) VALUES (0x" + hash
                    + ", 0x" + offerId.ToString("X")
                    + ", " + useCount + ", " + inScg + ", " + consoleVersion + ", " + ws.Partition + ")";
                ws.CommandSql = sql;

                ws.ExecuteNonQuery();
            }
        }

        public static void UnuseVoucher(string hash)
        {
            string Query = "DELETE FROM [dbo].[t_vouchers_used] WHERE bin_voucher_hash=0x" + hash;
            byte[] hashBytes = Hexer.unhex(hash);
            ExecuteSQLNonQuery(Query, BitConverter.ToInt64(hashBytes, 0));
        }

        public static void DeleteVoucher(string hash)
        {
            UnuseVoucher(hash);
            string Query = "DELETE FROM [dbo].[t_vouchers] WHERE bin_voucher_hash=0x" + hash;
            byte[] hashBytes = Hexer.unhex(hash);
            ExecuteSQLNonQuery(Query, BitConverter.ToInt64(hashBytes, 0));
        }

        public static int ClearUserVouchers(ulong upuid)
        {
            int FieldsAffected = 0;
            string sql = "DELETE t_vouchers_used WHERE (bi_user_puid = " + upuid + ")";

            using (WSClient ws = new WSClient(ConfigUtil.TokendbWebstoreApp, CmdType.WRITEONLY_COMMANDTYPE))
            {
                for (int p = 0; p < ws.PhysicalPartitions; p++)
                {
                    ws.ClearParameters();
                    ws.PhysicalPartition = p;
                    ws.CommandSql = sql;
                    FieldsAffected += ws.ExecuteNonQuery();
                }
                return FieldsAffected;
            }
        }

        public static void ClearUserVouchers(ulong puid, string token)
        {
            string Query = "DELETE FROM [dbo].[t_vouchers_used] WHERE bi_user_puid = " + puid;
            byte[] hashBytes = Hexer.unhex(GetVoucherHash(token));
            ExecuteSQLNonQuery(Query, BitConverter.ToInt64(hashBytes, 0));
        }

        public static void UnuseToken(string hash)
        {
            string Query = "DELETE FROM [dbo].[t_tokens_used] WHERE bin_token_hash=0x" + hash;
            byte[] hashBytes = Hexer.unhex(hash);
            ExecuteSQLNonQuery(Query, BitConverter.ToInt64(hashBytes, 0));
        }

        public static void DeleteToken(string hash)
        {
            UnuseToken(hash);
            string Query = "DELETE FROM [dbo].[t_tokens] WHERE bin_token_hash=0x" + hash;
            byte[] hashBytes = Hexer.unhex(hash);
            ExecuteSQLNonQuery(Query, BitConverter.ToInt64(hashBytes, 0));
        }

        public static void DeleteToken2(string hash)
        {
            UnuseToken(hash);
            string Query = "DELETE FROM [dbo].[t_tokens_v2] WHERE bin_token_hash=0x" + hash;
            byte[] hashBytes = Hexer.unhex(hash);
            ExecuteSQLNonQuery(Query, BitConverter.ToInt64(hashBytes, 0));
        }

        public static void ClearUserTokens(ulong puid, string token)
        {
            string Query = "DELETE FROM [dbo].[t_tokens_used] WHERE bi_user_puid = " + puid;
            byte[] hashBytes = Hexer.unhex(GetVoucherHash(token));
            ExecuteSQLNonQuery(Query, BitConverter.ToInt64(hashBytes, 0));
        }

        // hashed by offer id
        public static void DeleteUnactivatedBillingTokens(string offerId)
        {
            string Query = "DELETE FROM [dbo].[t_unactivated_billing_tokens] WHERE bi_offer_id = " + offerId;
            ExecuteSQLNonQuery(Query, offerId);
        }

        /// <summary>
        /// Verifies that no tokens are found on any TokenDB partition outside of the specified sequence range
        /// </summary>
        public static bool VerifyExclusiveSequenceRange(string offerId, ulong minSeq, ulong maxSeq)
        {
            bool success = true;
            string Query = "select count(*) from t_unactivated_billing_tokens where bi_offer_id =" + offerId +
                " and vc_sequence_number < " + minSeq.ToString() + " OR vc_sequence_number > " + maxSeq.ToString();
            int rowsCounted = Int32.Parse(ExecuteSQLScalar(Query, offerId).ToString());
            success = success && (rowsCounted == 0);
            return (success);
        }

        /// <summary>
        /// Verifies that one or more tokens are found on every TokenDB partition within the specified sequence range
        /// </summary>
        public static bool VerifySequenceRange(string offerId, ulong minSeq, ulong maxSeq)
        {
            bool success = true;
            string Query = "select count(*) from t_unactivated_billing_tokens where bi_offer_id =" + offerId +
                " and vc_sequence_number >= " + minSeq.ToString() + " AND vc_sequence_number <= " + maxSeq.ToString();
            int rowsCounted = Int32.Parse(ExecuteSQLScalar(Query, offerId).ToString());
            success = success && (rowsCounted != 0);
            return (success);
        }

        // simulate consume a ESP voucher
        public static uint RegisterVoucherUse(byte[] voucherHash, ulong userPuid)
        {
            using (WSClient ws = new WSClient(ConfigUtil.TokendbWebstoreApp, CmdType.WRITEONLY_COMMANDTYPE))
            {
                ws.StoredProc = "dbo.p_xuacs_use_voucher";
                ws.SetHashVal(BitConverter.ToInt64(voucherHash, 0));

                ws.AddParameter(ParamType.RETVAL, "@RETVAL", (uint)0);
                ws.AddParameter("@bin_voucher_hash", voucherHash);
                ws.AddParameter("@bi_user_puid", userPuid);
                ws.AddParameter("@si_hash_bucket", ws.Partition);

                ws.ExecuteNonQuery();

                return (uint)ws.GetIntParameter("@RETVAL");
            }
        }

        // simulate consume a EMS token
        public static uint RegisterEmsTokenUse(byte[] tokenHash, ulong userPuid)
        {
            using (WSClient ws = new WSClient(ConfigUtil.TokendbWebstoreApp, CmdType.WRITEONLY_COMMANDTYPE))
            {
                ws.StoredProc = "dbo.p_xuacs_use_token";
                ws.SetHashVal(BitConverter.ToInt64(tokenHash, 0));

                ws.AddParameter(ParamType.RETVAL, "@hr", (uint)0);
                ws.AddParameter("@bin_token_hash", tokenHash);
                ws.AddParameter("@bi_user_puid", userPuid);
                ws.AddParameter("@si_hash_bucket", ws.Partition);

                ws.ExecuteNonQuery();

                return (uint)ws.GetIntParameter("@hr");
            }
        }

        //---------------NEW TOKEN SUPPORT FOR CATALOG------------------------------------------------------//
        //Re-Adding voucher ADD, UNUSE, DELETE for the new catalog offer -token mapping
        public static void AddTokenForOffer(string hash, Guid offerId, int mediaType, int useCount, byte inScg, byte consoleVersion)
        {
            DeleteToken(hash);

            using (WSClient ws = new WSClient(ConfigUtil.TokendbWebstoreApp, CmdType.WRITEONLY_COMMANDTYPE))
            {
                ws.PartitionType = WstPartitionType.Logical;
                byte[] hashBytes = Hexer.unhex(hash);
                ws.SetHashVal(BitConverter.ToInt64(hashBytes, 0));
                string sql = string.Format("INSERT INTO [dbo].[t_tokens] (bin_token_hash,uid_offer_id,i_media_type_id, i_use_count, f_in_scg,f_console_version,si_hash_bucket)  VALUES (0x{0}, '{1}', {2}, {3}, {4}, {5}, {6} )  ",
                                                            hash, offerId.ToString(), mediaType, useCount, inScg, consoleVersion, ws.Partition);
                ws.CommandSql = sql;

                ws.ExecuteNonQuery();
            }
        }

        public static void AddTokenForOffer(string hash, int useCount, int status, byte consoleVersion, int sequence, Guid tokenCategoryId, Guid jobId, bool isTest)
        {
            DeleteToken2(hash);

            using (WSClient ws = new WSClient(ConfigUtil.TokendbWebstoreApp, CmdType.WRITEONLY_COMMANDTYPE))
            {
                ws.PartitionType = WstPartitionType.Logical;
                byte[] hashBytes = Hexer.unhex(hash);
                ws.SetHashVal(BitConverter.ToInt64(hashBytes, 0));
                string sql = string.Format("INSERT INTO [dbo].[t_tokens_v2] (bin_token_hash,i_use_count,i_token_status_id,f_console_version,si_hash_bucket,dt_change_datetime,i_sequence_number,uid_token_category_id, uid_job_id, f_is_test)  VALUES (0x{0}, {1}, {2}, {3}, {4}, '{5}', {6}, '{7}', '{8}', {9} )  ",
                                                            hash, useCount, status, consoleVersion, ws.Partition, DateTime.UtcNow, sequence, tokenCategoryId.ToString(), jobId.ToString(),
                                                            (isTest ? 1 : 0));
                ws.CommandSql = sql;

                ws.ExecuteNonQuery();
            }
        }

        public static void AddTokenForOfferWithoutDelete(string hash, Guid offerId, int mediaType, int useCount, byte inScg, byte consoleVersion)
        {

            using (WSClient ws = new WSClient(ConfigUtil.TokendbWebstoreApp, CmdType.WRITEONLY_COMMANDTYPE))
            {
                ws.PartitionType = WstPartitionType.Logical;
                byte[] hashBytes = Hexer.unhex(hash);
                ws.SetHashVal(BitConverter.ToInt64(hashBytes, 0));
                string sql = string.Format("INSERT INTO [dbo].[t_tokens] (bin_token_hash,uid_offer_id,i_media_type_id, i_use_count, f_in_scg,f_console_version,si_hash_bucket)  VALUES (0x{0}, '{1}', {2}, {3}, {4}, {5}, {6} )  ",
                                                            hash, offerId.ToString(), mediaType, useCount, inScg, consoleVersion, ws.Partition);
                ws.CommandSql = sql;

                ws.ExecuteNonQuery();
            }
        }
        public static void AddTokenForOfferWithoutDelete(string hash, int useCount, int status, byte consoleVersion, int sequence, Guid tokenCategoryId, Guid jobId, bool isTest)
        {

            using (WSClient ws = new WSClient(ConfigUtil.TokendbWebstoreApp, CmdType.WRITEONLY_COMMANDTYPE))
            {
                ws.PartitionType = WstPartitionType.Logical;
                byte[] hashBytes = Hexer.unhex(hash);
                ws.SetHashVal(BitConverter.ToInt64(hashBytes, 0));
                string sql = string.Format("INSERT INTO [dbo].[t_tokens_v2] (bin_token_hash,i_use_count,i_token_status_id,f_console_version,si_hash_bucket,dt_change_datetime,i_sequence_number,uid_token_category_id, uid_job_id)  VALUES (0x{0}, {1}, {2}, {3}, {4}, '{5}', {6}, '{7}', '{8}')  ",
                                                            hash, useCount, status, consoleVersion, ws.Partition, DateTime.UtcNow, sequence, tokenCategoryId.ToString(), jobId.ToString(),
                                                            (isTest ? 1 : 0));
                ws.CommandSql = sql;

                ws.ExecuteNonQuery();
            }
        }
        public static void DisableToken(string hash)
        {
            string Query = "update [dbo].[t_tokens] set i_token_status_id = 1 WHERE bin_token_hash=0x" + hash;
            byte[] hashBytes = Hexer.unhex(hash);
            ExecuteSQLNonQuery(Query, BitConverter.ToInt64(hashBytes, 0));
        }

        //---------------NEW TOKEN SUPPORT FOR CATALOG------------------------------------------------------//

        //---------------TOKEN SUPPORT FOR NEW TOKEN MANAGEMENT SYSTEM--------------------------------------//

        //Add Token Category
        public static void AddTokenCategory(Guid tokenCategoryId, string tokenCategoryName, int mediaType, Guid OfferId, Guid PromotionId, byte inScg, byte isRsm, string pkpn, byte channelTypeId, byte isRevenueBearing, DateTime expirationDate, DateTime changeTime, byte isRedeemable, byte isRoyalty)
        {
            DeleteTokenCategory(tokenCategoryId);

            string sql = string.Format("INSERT INTO [dbo].[t_token_category](uid_token_category_id,vc_token_category_name,i_media_type_id,uid_offer_id,uid_promotion_id,f_in_scg,f_is_rsm,vc_pkpn,ti_channel_type_id,f_is_revenue_bearing,dt_expiration_date,dt_Change_datetime,f_is_redeemable,f_is_royalty_bearing)"
            + "VALUES ('{0}', '{1}', {2}, '{3}', '{4}', {5}, {6}, '{7}', {8}, {9}, '{10}', '{11}', {12}, {13})  ",
            tokenCategoryId.ToString(), 
            tokenCategoryName, 
            mediaType, 
            OfferId.ToString(), 
            PromotionId.ToString(), 
            inScg, 
            isRsm, 
            pkpn, 
            channelTypeId, 
            isRevenueBearing, 
            expirationDate.ToString(), 
            changeTime.ToString(), 
            isRedeemable,
            isRoyalty);
               
            ExecuteSQLNonQuery(sql, null);
        }       

        //Add token in t_tokens_v2 table
        public static void AddTokenForOffer(string hash, int useCount, byte consoleVersion, int tokenStatus, Guid tokenCategoryId, int sequenceNumber, Guid JobId, DateTime changeTime, byte isTest)
        {
            DeleteToken2(hash);

            using (WSClient ws = new WSClient(ConfigUtil.TokendbWebstoreApp, CmdType.WRITEONLY_COMMANDTYPE))
            {
                ws.PartitionType = WstPartitionType.Logical;
                byte[] hashBytes = Hexer.unhex(hash);
                ws.SetHashVal(BitConverter.ToInt64(hashBytes, 0));
                string sql = string.Format("INSERT INTO [dbo].[t_tokens_v2] (bin_token_hash,i_use_count,i_token_status_id,f_console_version,si_hash_bucket,dt_Change_datetime,uid_token_category_id,i_sequence_number,uid_job_id, f_is_test)"
                + "VALUES (0x{0}, {1}, {2}, {3}, {4}, '{5}', '{6}', {7}, '{8}', {9} )  ",
                hash, 
                useCount, 
                tokenStatus, 
                consoleVersion, 
                ws.Partition, 
                changeTime, 
                tokenCategoryId, 
                sequenceNumber, 
                JobId, 
                isTest);

                ws.CommandSql = sql;
                ws.ExecuteNonQuery();
            }
        }

        public static int GetNumTokensByTokenJobId(Guid jobId)
        {
            int numTokens = 0;
            string sql = "SELECT COUNT(*) FROM [dbo].[t_tokens_v2] WHERE (uid_job_id = '" + jobId.ToString() + "')";

            using (WSClient ws = new WSClient(ConfigUtil.TokendbWebstoreApp, CmdType.WRITETHENREAD_COMMANDTYPE))
            {
                for (int p = 0; p < ws.PhysicalPartitions; p++)
                {
                    ws.ClearParameters();
                    ws.PhysicalPartition = p;
                    ws.CommandSql = sql;
                    numTokens += (int)ws.ExecuteScalar();
                }
                return numTokens;
            }
        }

        public static void DeleteTokenCategory(Guid id)
        {            
            string Query = "DELETE FROM [dbo].[t_token_category] WHERE uid_offer_id='" + id.ToString() + "'";

            ExecuteSQLNonQuery(Query, null);
        }

        //---------------TOKEN SUPPORT FOR NEW TOKEN MANAGEMENT SYSTEM--------------------------------------//

        //Expire Token Category
         public static void ExipreTokenCategory(Guid id)
         {
             //Expire token category
             DateTime updatedExpDate = DateTime.UtcNow.AddDays(-2);
             string expireTCQuery = String.Format("UPDATE t_token_category SET dt_expiration_date = '{0}' WHERE uid_token_category_id = '{1}'", updatedExpDate, id);

             ExecuteSQLNonQuery(expireTCQuery, null);
         }


         //Un-Expire Token Category
         public static void UnExipreTokenCategory(Guid id)
         {
             //Expire token category
             DateTime updatedExpDate = DateTime.UtcNow.AddYears(20);
             string unExpireTCQuery = String.Format("UPDATE t_token_category SET dt_expiration_date = '{0}' WHERE uid_token_category_id = '{1}'", updatedExpDate, id);

             ExecuteSQLNonQuery(unExpireTCQuery, null);
         }

        //Disable Token
         public static void DisableTokenV2(string tokenHash)
         {
             string Query = String.Format("UPDATE t_tokens_v2 SET i_token_status_id = 1 WHERE bin_token_hash = 0x{0}", tokenHash);
             byte[] hashBytes = Hexer.unhex(tokenHash);

             ExecuteSQLNonQuery(Query, BitConverter.ToInt64(hashBytes, 0));
         }

         //Enable Token
         public static void EnableTokenV2(string tokenHash)
         {
             string Query = String.Format("UPDATE t_tokens_v2 SET i_token_status_id = 0 WHERE bin_token_hash = 0x{0}", tokenHash);
             byte[] hashBytes = Hexer.unhex(tokenHash);

             ExecuteSQLNonQuery(Query, BitConverter.ToInt64(hashBytes, 0));
         }

        //NonReedemable TokenCategory
         public static void NonReedemableTC(Guid tokenCategoryId)
         {
             string Query = String.Format("UPDATE t_token_category SET f_is_redeemable = 0 WHERE uid_token_category_id = '{0}'", tokenCategoryId);
             ExecuteSQLNonQuery(Query, null);
         }

         //Reedemable TokenCategory
         public static void ReedemableTC(Guid tokenCategoryId)
         {
             string Query = String.Format("UPDATE t_token_category SET f_is_redeemable = 1 WHERE uid_token_category_id = '{0}'", tokenCategoryId);
             ExecuteSQLNonQuery(Query, null);
         }

        //---------------TOKEN SUPPORT FOR NEW TOKEN MANAGEMENT SYSTEM--------------------------------------//

        //creates a random 5x5 panorama voucher from the same offer as the test voucher (all P's) and adds it to t_vouchers
        public static string CreatePanoramaVoucher(int useCount)
        {
            return CreatePanoramaVoucher(useCount, 0x585207D10FF00001);
        }

        public static string CreatePanoramaVoucher(int useCount, ulong offerId)
        {
            //make the voucher string
            string voucher = "PTEST";
            for (int i = 1; i < 5; ++i)
            {
                if (i != 0) voucher += "-";
                voucher += ServerTestFramework.Core.Utilities.RandomEx.GlobalRandGen.GenerateRandomUpperAlphaNumericString(5);
            }

            //add it to db
            string voucherHash = HashPanoramaVoucher(voucher);

            using (WSClient ws = new WSClient(ConfigUtil.TokendbWebstoreApp, CmdType.WRITEONLY_COMMANDTYPE))
            {
                ws.PartitionType = WstPartitionType.Logical;
                WebstoreDB.SetHashValue(ws, BitConverter.ToUInt64(Hexer.unhex(voucherHash), 0));
                int bucket = ws.Partition;
                ws.CommandSql = "INSERT INTO t_vouchers ([bin_voucher_hash], [bi_offer_id],         [i_use_count], [i_voucher_status_id], [f_in_scg], [f_console_version],  [si_hash_bucket], [dt_Change_datetime]) " +
                                               "VALUES(0x" + voucherHash + ", 0x" + offerId.ToString("X") + ", " + useCount + ",    0,                     0,          2,                   " + bucket + ",        getutcdate())";
                int rows = ws.ExecuteNonQuery();
                if (rows != 1) throw new Exception("" + rows + " rows were affected by query.  Expected 1.");
            }

            //
            return voucher;
        }

        //hashes a 5x5 panorama voucher string to the hash string used in t_vouchers
        public static string HashPanoramaVoucher(string voucher)
        {
            return Hexer.tohex(GetHashForPanoramaVoucher(voucher));
        }

        //hashes a 5x5 panorama voucher string to hash bytes
        public static byte[] GetHashForPanoramaVoucher(string voucher)
        {
            if (voucher.Length != 29)
            {
                Global.RO.Warn("PanoramaVoucher should be of the form: XXXXX-XXXXX-XXXXX-XXXXX-XXXXX");
            }

            voucher = voucher.ToUpper() + "\0";
            System.Security.Cryptography.SHA1CryptoServiceProvider sha = new System.Security.Cryptography.SHA1CryptoServiceProvider();
            byte[] hashBytes = sha.ComputeHash(Encoding.Unicode.GetBytes(voucher));
            return hashBytes;
        }

        public static bool IsInVouchersUsedTable(string hash, ulong userPuid)
        {

            string query = "select COUNT(*) FROM dbo.t_vouchers_used WHERE bin_voucher_hash = 0x" + hash + " AND bi_user_puid = 0x" + userPuid.ToString("x");

            Global.RO.Info(query);

            bool exist = false;

            byte[] hashBytes = Hexer.unhex(hash);
            object result = (int)(TokendbWS.ExecuteSQLScalar(query, BitConverter.ToInt64(hashBytes, 0)));

            if (result == null)
                exist = false;
            else if ((int)result > 0)
                exist = true;
            return exist;

        }

        public static bool IsInTokensUsedTable(string hash, ulong userPuid)
        {

            string query = "select COUNT(*) FROM dbo.t_tokens_used WHERE dbo.bin_token_hash = 0x" + hash + " AND bi_user_puid = 0x" + userPuid.ToString("x");

            Global.RO.Info(query);

            bool exist = false;

            byte[] hashBytes = Hexer.unhex(hash);
            object result = (int)(TokendbWS.ExecuteSQLScalar(query, BitConverter.ToInt64(hashBytes, 0)));

            if (result == null)
                exist = false;
            else if ((int)result > 0)
                exist = true;
            return exist;

        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\Database\UtilityClasses.cs ===
using System;
using System.Collections;
using System.Text;

using ServerTestFramework.LiveService.UserAccount;

namespace ServerTestFramework.Database
{
    public class ReservationInfo
    {
        public DateTime reservationExpires = DateTime.MinValue;
        public ulong puid = 0;
        public double expiresIn
        {
            get
            {
                TimeSpan t = reservationExpires - DateTime.Now;
                return t.TotalSeconds;
            }
        }
    };

    public class SubscriptionInfo
    {
        public SubscriptionInfo()
        { }
        public SubscriptionInfo(SubscriptionInfo other)
        {
            userPuid = other.userPuid;
            offerId = other.offerId;
            serviceInstanceId = other.serviceInstanceId;
            isMPuid = other.isMPuid;
            statusId = other.statusId;
            transactionFlag = other.transactionFlag;
            changeTime = other.changeTime;
            server = other.server;
        }
        public ulong userPuid = 0;
        public long offerId = 0;
        public string serviceInstanceId = "";
        public DateTime startDate = DateTime.Now.AddDays(-1);
        public DateTime endDate = DateTime.Now.AddYears(+2);
        public int isMPuid = 0;
        public int statusId = 0;
        public int transactionFlag = 0;
        public DateTime changeTime = DateTime.Now;
        public string server = null;

        public override string ToString()
        {
            return String.Format("\nuserPuid=0x{0:x}\nofferId={1:x}\nserviceInstanceId={2}\n" +
                                 "startDate={3}\nendDate={4}\nisMPuid={5}\nstatusId={6}({9})\n" +
                                 "transactionFilag={7}\nchangeTime={8}",
                                 userPuid, offerId, serviceInstanceId,
                                 startDate, endDate, isMPuid, statusId, transactionFlag,
                                 changeTime, Enum.Format(typeof(SubscriptionStatus), (uint)statusId, "g"));

        }
    }

    public class SubscriptionHistoryInfo
    {
        public SubscriptionHistoryInfo()         { }
        
        public SubscriptionHistoryInfo(SubscriptionHistoryInfo other)
        {
            userPuid = other.userPuid;
            offerId = other.offerId;
            startDate = other.startDate;
            endDate = other.endDate;
            statusId = other.statusId;
            changeTime = other.changeTime;
            server = other.server;
        }
        
        public ulong userPuid = 0;
        public long offerId = 0;
        public DateTime startDate = DateTime.Now.AddDays(-1);
        public DateTime endDate = DateTime.Now.AddYears(+2);
        public int statusId = 0;
        public DateTime changeTime = DateTime.Now;
        public string server = null;
        public Guid catalogOfferId;
        public Guid catalogOfferInstanceId;

        public override string ToString()
        {
            return String.Format("\nuserPuid=0x{0:x}\nofferId={1:x}\n" +
                                 "startDate={2}\nendDate={3}\nstatusId={4}\n" +
                                 "changeTime={5}\nOfferId={6}\nOfferInstanceId={7}\n",
                                 userPuid, offerId, startDate, endDate, statusId, changeTime, catalogOfferId, catalogOfferInstanceId);
        }


        public bool IsMatched(SubscriptionHistoryInfo other)
        {
            bool bReturn = true;

            Global.RO.Info("expected : " + this.ToString());
            Global.RO.Info("returned : " + other.ToString());


            if (userPuid != other.userPuid)
            {
                bReturn = false;
                Global.RO.Warn("userPuid is different");
            }

            if (offerId != other.offerId)
            {
                bReturn = false;
                Global.RO.Warn("offerId is different");
            }

            if (((TimeSpan)(startDate - other.startDate)).TotalHours > 1)
            {
                bReturn = false;
                Global.RO.Warn("startDate is different");
            }

            if (((TimeSpan)(endDate - other.endDate)).TotalHours > 1)
            {
                bReturn = false;
                Global.RO.Warn("endDate is different");
            }

            if (statusId != other.statusId)
            {
                bReturn = false;
                Global.RO.Warn("statusId is different");
            }

            if (((TimeSpan)(changeTime - other.changeTime)).TotalHours > 1)
            {
                bReturn = false;
                Global.RO.Warn("changeTime is different");
            }
          
            return bReturn;
        }

        public bool IsCatalogOfferCheckMatched(SubscriptionHistoryInfo other)
        {
            bool bReturn = true;

            Global.RO.Info("expected : "+this.ToString());
            Global.RO.Info("returned : "+other.ToString());

            
            if(userPuid != other.userPuid)
            {
                bReturn = false;
                Global.RO.Warn("userPuid is different");
            }
                
            if(offerId != other.offerId)
            {
                bReturn = false;
                Global.RO.Warn("offerId is different");
            }

            if (Math.Abs(((TimeSpan)(startDate - other.startDate)).TotalHours) > 1)
            {
                bReturn = false;
                Global.RO.Warn("startDate is different");
            }
            
            if (Math.Abs(((TimeSpan)(endDate-other.endDate)).TotalHours)>1)
            {
                bReturn = false;
                Global.RO.Warn("endDate is different");
            }
            
            if(statusId != other.statusId)
            {
                bReturn = false;
                Global.RO.Warn("statusId is different");
            }

            if (((TimeSpan)(changeTime-other.changeTime)).TotalHours>1)
            {
                bReturn = false;
                Global.RO.Warn("changeTime is different");
            }

            if (catalogOfferId != other.catalogOfferId)
            {
                bReturn = false;
                Global.RO.Warn("Catalog Offer Id is different");
            }


            if (catalogOfferInstanceId != other.catalogOfferInstanceId)
            {
                bReturn = false;
                Global.RO.Warn("Catalog OfferInstance Id is different");
            }



            return bReturn;
        }
    }
    
    public class UserSubInfo
    {
        public ulong offerId;
        public int instances;
        public string serviceInstanceId;
        public DateTime startDate;
        public DateTime endDate;
        public int subStatus;
        public bool provisionPending;
        public bool disablePending;
        public bool purchaseIncomplete;
        public string friendlyName;

        public static void DumpHeader()
        {
            Global.RO.Debug("OfferId            FriendlyName                   'SrvcInstanceId'   Status");
        }
        public void Dump()
        {
            int len = friendlyName.Length;
            Global.RO.Debug("0x{0,-16} {1,-30} {2,-18} {3}",
                offerId.ToString("X"),
                len > 30 ? friendlyName.Substring(1, 30) : friendlyName,
                "'" + serviceInstanceId + "'",
                subStatus);
        }
    };

    public class UserInfo
    {
        public ulong puid = 0;
        public ulong ownerPuid = 0;
        public ulong machinePuid = 0;
        public string nickname = "";
        public int accountStatus = 0;
        public byte nameChangeRequired = 0;
        public int newTermsOfService = 0;
        public DateTime suspendedUntil = DateTime.MinValue;
        public int totalDaysSuspended = 0;
        public DateTime voiceBannedUntil = DateTime.MinValue;
        public int totalDaysVoiceBanned = 0;
        public uint billingAccountStatus = 0;
        public DateTime acceptedTOS = DateTime.MinValue;
        public byte msSpam = 0;
        public byte partnerSpam = 0;
        public DateTime created = DateTime.MinValue;
        public ushort ticketFlags = 0;
        public ushort userFlags = 0;
        public DateTime changed = DateTime.MinValue;
        public int country = 0;
        public int language = 0;
        public int culture = 0;
        public string paymentInstrumentId;
        public string billingAccountId = "";
        public int createdAccountType;
        public ulong offlineXuid = 0;
        public byte isGeofenceExempt = 0;
        public byte isFreeGamertagEligible = 0;

        public bool queued
        {
            get
            {
                return billingAccountId.StartsWith("$XBOX");
            }
        }

        public string server = "";

        public void Dump()
        {
            Global.RO.Debug("      Username: " + nickname);
            Global.RO.Debug("          Puid: " + puid);
            if (ownerPuid != puid)
                Global.RO.Debug("    Owner puid: " + ownerPuid);
            Global.RO.Debug("        Queued: " + queued);
            Global.RO.Debug("        Server: " + server);

        }
        public bool Matches(XRLSetUserAccountStatus Request)
        {
            if (nameChangeRequired != Request.nameChangeRequired)
            {
                Global.RO.Error("Field nameChangeRequired mismatch (" + nameChangeRequired + ")!");
                return false;
            }
            if (Math.Abs((suspendedUntil - Request.suspendedUntil).TotalDays) > 1)
            {
                Global.RO.Error("Field suspendedUntil mismatch!");
                return false;
            }
            if (totalDaysSuspended != Request.totalDaysSuspended)
            {
                Global.RO.Error("Field totalDaysSuspended mismatch!");
                return false;
            }
            if (Math.Abs((voiceBannedUntil - Request.voiceBannedUntil).TotalDays) > 1)
            {
                Global.RO.Error("Field voiceBannedUntil mismatch!");
                return false;
            }
            if (totalDaysVoiceBanned != Request.totalDaysVoiceBanned)
            {
                Global.RO.Error("Field totalDaysVoiceBanned mismatch!");
                return false;
            }
            return true;
        }
        public bool Matches(XRLTroubleshootAccountResponse Request)
        {
            if (nameChangeRequired != Request.nameChangeRequired)
            {
                Global.RO.Error("Field nameChangeRequired mismatch (" + nameChangeRequired + ")!");
                return false;
            }
            if (Math.Abs((suspendedUntil - Request.suspendedUntil).TotalDays) > 1)
            {
                Global.RO.Error("Field suspendedUntil mismatch!");
                return false;
            }
            if (totalDaysSuspended != Request.totalDaysSuspended)
            {
                Global.RO.Error("Field totalDaysSuspended mismatch!");
                return false;
            }
            if (Math.Abs((voiceBannedUntil - Request.voiceBannedUntil).TotalDays) > 1)
            {
                Global.RO.Error("Field voiceBannedUntil mismatch!");
                return false;
            }
            if (totalDaysVoiceBanned != Request.totalDaysVoiceBanned)
            {
                Global.RO.Error("Field totalDaysVoiceBanned mismatch!");
                return false;
            }
            return true;
        }
    };

    public class QueuedUserInfo
    {
        public ulong puid = 0;
        public ulong ownerPuid = 0;
        public ulong baseOfferId = 0;
        public string billingOfferId = String.Empty;
        public string guid = String.Empty;
        public string purchaseGuid = String.Empty;
        public int status = 0;
        public DateTime changeDateTime = DateTime.MaxValue;
        public string server = null;
        public string accountInfo;

        public override string ToString()
        {
            StringBuilder str = new StringBuilder(256);

            str.Append("PUID: "); str.Append(puid.ToString("X"));
            str.Append(", OwnerPUID: "); str.Append(ownerPuid.ToString("X"));
            str.Append(", BaseOID: "); str.Append(baseOfferId.ToString("X"));

            str.Append(", BOID: "); str.Append(billingOfferId);
            str.Append(", GUID: "); str.Append(guid);
            str.Append(", PGUID: "); str.Append(purchaseGuid);

            str.Append(", Status: "); str.Append(status.ToString("X"));
            str.Append(", Change: "); str.Append(changeDateTime);
            str.Append(", Server: "); str.Append(server);

            return str.ToString();
        }
    };

    public class MachineAccount
    {
        public UInt64 MachinePuid;
        public string SerialNumber;
        public DateTime BlockedDate;
        public DateTime ResetDate;
        public Byte BetaUser;
        public Int32 BetaTitleId;
        public DateTime Changed;

        public override bool Equals(object obj)
        {
            if (obj is MachineAccount)
            {
                return
                    (
                    (obj as MachineAccount).MachinePuid == MachinePuid &&
                    (string.Compare((obj as MachineAccount).SerialNumber, SerialNumber, true) == 0) &&
                    (obj as MachineAccount).BlockedDate == BlockedDate &&
                    (obj as MachineAccount).ResetDate == ResetDate &&
                    (obj as MachineAccount).BetaUser == BetaUser &&
                    (obj as MachineAccount).BetaTitleId == BetaTitleId
                    );
            }
            else
            {
                return false;
            }
        }

        public override string ToString()
        {
            return String.Format("MachinePuid[{0}] SerialNumber[{1}] BlockedDate[{2}] ResetDate[{3}] BetaUser[{4}] BetaTitleId[{5}] Changed[{6}]",
                MachinePuid, SerialNumber, BlockedDate, ResetDate, BetaUser, BetaTitleId, Changed);
        }

        public override int GetHashCode()
        {
            return base.GetHashCode();
        }
    }

    public class UserLicense
    {
        public ulong UserId;
        public ulong OfferId;
        public ulong MachineId;
        public short HashBucket;
        public DateTime Changed;

        public override bool Equals(object obj)
        {
            if (obj is UserLicense)
            {
                return
                    (
                    (obj as UserLicense).UserId == UserId &&
                    (obj as UserLicense).OfferId == OfferId &&
                    (obj as UserLicense).MachineId == MachineId &&
                    (obj as UserLicense).HashBucket == HashBucket
                    );
            }
            else
            {
                return false;
            }
        }

        public override string ToString()
        {
            return String.Format("UserId[{0}] OfferId[{1}] MachineId[{2}] HashBucket[{3}] ChangedDate[{4}]",
                UserId, OfferId, MachineId, HashBucket, Changed);
        }

        public override int GetHashCode()
        {
            return base.GetHashCode();
        }
    }

    public class TitleVersion
    {
        public UInt32 TitleId;
        public UInt32 BaseVersion;
        public UInt32 UpdateVersion;
        public UInt32 BetaVersion;
        public DateTime Changed;
        public Byte ConsoleTypeId;

        public override bool Equals(object obj)
        {
            if (obj is TitleVersion)
            {
                return
                    (
                    (obj as TitleVersion).TitleId == TitleId &&
                    (obj as TitleVersion).BaseVersion == BaseVersion &&
                    (obj as TitleVersion).UpdateVersion == UpdateVersion &&
                    (obj as TitleVersion).BetaVersion == BetaVersion &&
                    (obj as TitleVersion).ConsoleTypeId == ConsoleTypeId
                    );
            }
            else
            {
                return false;
            }
        }

        public override string ToString()
        {
            return String.Format("TitleID[0x{0:x}] BaseVersion[{1}] UpdateVersion[{2}] BetaVersion[{3}] Changed[{4}] Console Type ID[{5}]",
                TitleId, BaseVersion, UpdateVersion, BetaVersion, Changed, ConsoleTypeId);
        }

        public override int GetHashCode()
        {
            return base.GetHashCode();
        }
    }

    public class TitleVersions : CollectionBase
    {
        public TitleVersions() { }

        public TitleVersion this[int index]
        {
            get { return List[index] as TitleVersion; }
            set { List[index] = value; }
        }

        public int Add(TitleVersion val)
        {
            return List.Add(val);
        }

        public bool Contains(TitleVersion val)
        {
            return List.Contains(val);
        }

        public void Remove(TitleVersion val)
        {
            List.Remove(val);
        }

        //Compare the two TitleVersions, but disregard changed date.
        public bool Equals(TitleVersions toCompare)
        {
            if (this.Count != toCompare.Count)
            {
                return false;
            }
            for (int i = 0; i < this.Count; i++)
            {
                if (!(this[i].Equals(toCompare[i])))
                {
                    return false;
                }
            }
            return true;
        }

        public override string ToString()
        {
            String printout = "";
            foreach (TitleVersion row in this)
            {
                printout += row + "\n";
            }
            return printout;
        }
    }

    public class TitleRating
    {
        public UInt32 TitleId;
        public Int32 RatingSystemId;
        public Int32 RatingId;
        public DateTime Changed;

        public override bool Equals(object obj)
        {
            if (obj is TitleRating)
            {
                return
                    (
                    (obj as TitleRating).TitleId == TitleId &&
                    (obj as TitleRating).RatingSystemId == RatingSystemId &&
                    (obj as TitleRating).RatingId == RatingId
                    );
            }
            else
            {
                return false;
            }
        }

        public override string ToString()
        {
            return String.Format("TitleId[0x{0:x}] RatingSystemId[{1}] RaitingId[{2}] Changed[{3}]",
                TitleId, RatingSystemId, RatingId, Changed);
        }

        public override int GetHashCode()
        {
            return base.GetHashCode();
        }
    }

    public class TitleRatings : CollectionBase
    {
        public TitleRatings() { }

        public TitleRating this[int index]
        {
            get { return List[index] as TitleRating; }
            set { List[index] = value; }
        }

        public int Add(TitleRating val)
        {
            return List.Add(val);
        }

        public bool Contains(TitleRating val)
        {
            return List.Contains(val);
        }

        public void Remove(TitleRating val)
        {
            List.Remove(val);
        }
    }

    public class TitleGenre
    {
        public UInt32 TitleId;
        public Int32 GenreId;
        public DateTime Changed;

        public override bool Equals(object obj)
        {
            if (obj is TitleGenre)
            {
                return
                    (
                    (obj as TitleGenre).TitleId == TitleId &&
                    (obj as TitleGenre).GenreId == GenreId
                    );
            }
            else
            {
                return false;
            }
        }

        public override string ToString()
        {
            return String.Format("TitleId[0x{0:x}] GenreId[{1}] Changed[{2}]",
                TitleId, GenreId, Changed);
        }

        public override int GetHashCode()
        {
            return base.GetHashCode();
        }
    }

    public class TitleGenres : CollectionBase
    {
        public TitleGenres() { }

        public TitleGenre this[int index]
        {
            get { return List[index] as TitleGenre; }
            set { List[index] = value; }
        }

        public int Add(TitleGenre val)
        {
            return List.Add(val);
        }

        public bool Contains(TitleGenre val)
        {
            return List.Contains(val);
        }

        public void Remove(TitleGenre val)
        {
            List.Remove(val);
        }
    }

    public class TitleCultureDetail
    {
        public UInt32 TitleId;
        public Int32 CultureId;
        public string Name;
        public string SellText;
        public string Publisher;
        public string Developer;
        public string Genre;
        public string Locale;     // This field is from the t_cultures table
        public DateTime Changed;

        public override bool Equals(object obj)
        {
            if (obj is TitleCultureDetail)
            {
                return
                    (
                    (obj as TitleCultureDetail).TitleId == TitleId &&
                    (obj as TitleCultureDetail).CultureId == CultureId &&
                    (obj as TitleCultureDetail).Name == Name &&
                    (obj as TitleCultureDetail).SellText == SellText &&
                    (obj as TitleCultureDetail).Publisher == Publisher &&
                    (obj as TitleCultureDetail).Developer == Developer &&
                    (obj as TitleCultureDetail).Genre == Genre
                    );
            }
            else
            {
                return false;
            }
        }

        public override string ToString()
        {
            return String.Format("TitleId[0x{0:x}] CultureId[{1}] Name[{2}] SellText[{3}] Publisher[{4}] Developer[{5}] Genre[{6}] Changed[{7}]",
                TitleId, CultureId, Name, SellText, Publisher, Developer, Genre, Changed);
        }

        public override int GetHashCode()
        {
            return base.GetHashCode();
        }
    }

    public class TitleCultureDetails : CollectionBase
    {
        public TitleCultureDetails() { }

        public TitleCultureDetail this[int index]
        {
            get { return List[index] as TitleCultureDetail; }
            set { List[index] = value; }
        }

        public int Add(TitleCultureDetail val)
        {
            return List.Add(val);
        }

        public bool Contains(TitleCultureDetail val)
        {
            return List.Contains(val);
        }

        public void Remove(TitleCultureDetail val)
        {
            List.Remove(val);
        }
    }

    public class AlternateTitleId
    {
        public UInt32 TitleId;
        public Int32 TitleRegion;
        public Int32 MediaId;
        public Int32 LiveTitleId;
        public Int32 AlternateId1;
        public Int32 AlternateId2;
        public Int32 AlternateId3;
        public Int32 AlternateId4;
        public Int32 Service1;
        public Int32 Service1AltId;
        public Int32 Service2;
        public Int32 Service2AltId;
        public Int32 Service3;
        public Int32 Service3AltId;
        public Int32 Service4;
        public Int32 Service4AltId;
        public DateTime Changed;

        public override bool Equals(object obj)
        {
            if (obj is AlternateTitleId)
            {
                return
                    (
                    (obj as AlternateTitleId).TitleId == TitleId &&
                    (obj as AlternateTitleId).TitleRegion == TitleRegion &&
                    (obj as AlternateTitleId).MediaId == MediaId &&
                    (obj as AlternateTitleId).LiveTitleId == LiveTitleId &&
                    (obj as AlternateTitleId).AlternateId1 == AlternateId1 &&
                    (obj as AlternateTitleId).AlternateId2 == AlternateId2 &&
                    (obj as AlternateTitleId).AlternateId3 == AlternateId3 &&
                    (obj as AlternateTitleId).AlternateId4 == AlternateId4 &&
                    (obj as AlternateTitleId).Service1 == Service1 &&
                    (obj as AlternateTitleId).Service1AltId == Service1AltId &&
                    (obj as AlternateTitleId).Service2 == Service2 &&
                    (obj as AlternateTitleId).Service2AltId == Service2AltId &&
                    (obj as AlternateTitleId).Service3 == Service3 &&
                    (obj as AlternateTitleId).Service3AltId == Service3AltId &&
                    (obj as AlternateTitleId).Service4 == Service4 &&
                    (obj as AlternateTitleId).Service4AltId == Service4AltId
                    );
            }
            else
            {
                return false;
            }
        }

        public override string ToString()
        {
            return String.Format("TitleId[0x{0:x}] TitleRegion[{1}] MediaId[{2}] LiveTitleId[{3}] AlternateId1[{4}] " +
                "AlternateId2[{5}] AlternateId3[{6}] AlternateId4[{7}] Service1[{8}] Service1AltId[{9}] Service2[{10}] " +
                "Service2AltId[{11}] Service3[{12}] Service3AltId[{13}] Service4[{14}] Service4AltId[{15}] Changed[{16}]",
                TitleId, TitleRegion, MediaId, LiveTitleId, AlternateId1, AlternateId2, AlternateId3, AlternateId4,
                Service1, Service1AltId, Service2, Service2AltId, Service3, Service3AltId, Service4, Service4AltId, Changed);
        }

        public override int GetHashCode()
        {
            return base.GetHashCode();
        }
    }

    public class AlternateTitleIds : CollectionBase
    {
        public AlternateTitleIds() { }

        public AlternateTitleId this[int index]
        {
            get { return List[index] as AlternateTitleId; }
            set { List[index] = value; }
        }

        public int Add(AlternateTitleId val)
        {
            return List.Add(val);
        }

        public bool Contains(AlternateTitleId val)
        {
            return List.Contains(val);
        }

        public void Remove(AlternateTitleId val)
        {
            List.Remove(val);
        }
    }

    public class TitleInformation
    {
        private string _sourceDb;

        // t_titles
        public UInt32 TitleId;
        public byte ConsoleTypeId;
        public DateTime LastModified;
        // t_title_feature_data
        public string Name;
        public bool Camera;
        public bool CoOp;
        public bool CustomSoundtrack;
        public bool Dolby51;
        public bool HardDriveEnhanced;
        public bool HardDriveRequired;
        public bool LiveAware;
        public bool LiveClans;
        public bool LiveCoOp;
        public bool LiveDownloads;
        public bool LiveFriends;
        public bool LiveMessaging;
        public bool LiveMultiplayer;
        public bool LiveScoreboard;
        public bool LiveServiceProxy;
        public bool LiveStats;
        public bool LiveTournaments;
        public bool LiveVoice;
        public bool LiveVoiceMessaging;
        public bool MemoryUnit;
        public bool MultiplayerVersus;
        public bool Peripherals;
        public Int32 PlayersOffline;
        public Int32 PlayersSystemLink;
        public Int32 PlayersLive;
        public bool PremiumOffers;
        public bool SystemLink;
        public bool UserCreatableContent;
        public bool XboxSupport;
        public bool Xbox2Support;
        public bool BountyExempt;   // This is from t_xprof_bounty_exempt_titles
        // t_title_trust_constants
        public TitleTrustConstants TrustConstants;
        // t_title_versions
        public TitleVersions TitleVersions;
        // t_title_ratings
        public TitleRatings TitleRatings;
        // t_title_genres
        public TitleGenres TitleGenres;
        // t_title_culture_details
        public TitleCultureDetails TitleCultureDetails;
        // t_alternate_titleids
        public AlternateTitleId AlternateTitleId;
        // Cross-Platform privilege
        public bool CrossPlatform;


        // Constructors
        //
        // The second constructor is meant to be used by the Uodb and Pcdb classes
        // to differentiate from where this title information is taken.
        public TitleInformation() { }
        public TitleInformation(string sourceDb)
        {
            _sourceDb = sourceDb;
        }

        public string SourceDb
        {
            get { return _sourceDb; }
        }
    }

    public class TitleTrustConstants
    {
        public uint titleId = 0;
        public double w2 = 0.0;
        public double w3 = 0.0;
        public double w4 = 0.0;
        public double w5 = 0.0;
        public double w6 = 0.0;
        public double w7 = 0.0;
        public double w8 = 0.0;
        public double w9 = 0.0;
        public double baseUserTrust = 0.0;
        public double minorityQuorum = 0.0;
        public double userCompetitionAmp = 0.0;
        public double publisherCompetitionAmp = 0.0;
        public uint lambda = 0;
        public uint baseSessionTime = 0;
        public double s1 = 0.0;
        public double s2 = 0.0;
        public double s3 = 0.0;
        public double s4 = 0.0;
        public double s5 = 0.0;
        public double s6 = 0.0;
        public double s7 = 0.0;
        public double s8 = 0.0;
        public double s9 = 0.0;
        public ulong totalSessions = 0L;
        public ulong totalSessionDisconnects = 0L;
        public ulong totalCompetitions = 0L;
        public ulong totalCompetitionNoShows = 0L;
        public ulong sessionBase = 0L;
        public ulong sessionXboxCount = 0L;
        public ulong sessionSeconds = 0L;
        public ulong sessionFreeForAll = 0L;
        public uint totalUsers = 0;
        public double r2 = 0.0;
        public double r3 = 0.0;
        public double r4 = 0.0;
        public double r5 = 0.0;
        public double r6 = 0.0;
        public double r7 = 0.0;
        public double r8 = 0.0;
        public double r9 = 0.0;
        public double k = 0.0;
        public byte lowerBottom = 0;
        public byte lowerMid = 0;
        public byte lowerTop = 0;
        public byte midBottom = 0;
        public byte midTop = 0;
        public byte upperBottom = 0;
        public byte upperMid = 0;
        public byte upperTop = 0;
        public DateTime changeDatetime = DateTime.MinValue;

        public TitleTrustConstants() { }

        public TitleTrustConstants(uint titleId, double w2, double w3, double w4, double w5, double w6, double w7, double w8, double w9,
            double baseUserTrust, double minorityQuorum, double userCompetitionAmp, double publisherCompetitionAmp,
            uint lambda, uint baseSessionTime, double s1, double s2, double s3, double s4, double s5, double s6, double s7, double s8, double s9,
            ulong totalSessions, ulong totalSessionDisconnects, ulong totalCompetitions, ulong totalCompetitionNoShows,
            ulong sessionBase, ulong sessionXboxCount, ulong sessionSeconds, ulong sessionFreeForAll, uint totalUsers,
            double r2, double r3, double r4, double r5, double r6, double r7, double r8, double r9, double k,
            byte lowerBottom, byte lowerMid, byte lowerTop, byte midBottom, byte midTop, byte upperBottom, byte upperMid, byte upperTop, DateTime changeDatetime)
        {
            this.titleId = titleId;
            this.w2 = w2;
            this.w3 = w3;
            this.w4 = w4;
            this.w5 = w5;
            this.w6 = w6;
            this.w7 = w7;
            this.w8 = w8;
            this.w9 = w9;
            this.baseUserTrust = baseUserTrust;
            this.minorityQuorum = minorityQuorum;
            this.userCompetitionAmp = userCompetitionAmp;
            this.publisherCompetitionAmp = publisherCompetitionAmp;
            this.lambda = lambda;
            this.baseSessionTime = baseSessionTime;
            this.s1 = s1;
            this.s2 = s2;
            this.s3 = s3;
            this.s4 = s4;
            this.s5 = s5;
            this.s6 = s6;
            this.s7 = s7;
            this.s8 = s8;
            this.s9 = s9;
            this.totalSessions = totalSessions;
            this.totalSessionDisconnects = totalSessionDisconnects;
            this.totalCompetitions = totalCompetitions;
            this.totalCompetitionNoShows = totalCompetitionNoShows;
            this.sessionBase = sessionBase;
            this.sessionXboxCount = sessionXboxCount;
            this.sessionSeconds = sessionSeconds;
            this.sessionFreeForAll = sessionFreeForAll;
            this.totalUsers = totalUsers;
            this.r2 = r2;
            this.r3 = r3;
            this.r4 = r4;
            this.r5 = r5;
            this.r6 = r6;
            this.r7 = r7;
            this.r8 = r8;
            this.r9 = r9;
            this.k = k;
            this.lowerBottom = lowerBottom;
            this.lowerMid = lowerMid;
            this.lowerTop = lowerTop;
            this.midBottom = midBottom;
            this.midTop = midTop;
            this.upperBottom = upperBottom;
            this.upperMid = upperMid;
            this.upperTop = upperTop;
            this.changeDatetime = changeDatetime;
        }

        public new TitleTrustConstants MemberwiseClone()
        {
            return (TitleTrustConstants)base.MemberwiseClone();
        }

    };

    public class UserTrustRatings
    {
        public ulong puid = 0L;
        public uint titleId = 0;
        public double c1_SuccessfulSessionCount = 0.0;
        public double c2_MinoritySessionCount = 0.0;
        public double c3_FailedSessionCount = 0.0;
        public double c4_ProblematicSessionCount = 0.0;
        public double c5_UDPReportCount = 0.0;
        public double c6_DisconnectCount = 0.0;
        public double c7_Type1SuspiciousCount = 0.0;
        public double c8_Type2SuspiciousCount = 0.0;
        public double c9_Type3SuspiciousCount = 0.0;
        public uint totalSessions = 0;
        public uint totalSessionDisconnects = 0;
        public uint totalCompetitions = 0;
        public uint totalCompetitionNoShows = 0;
        public uint sessionBase = 0;
        public uint sessionXboxCount = 0;
        public uint sessionSeconds = 0;
        public uint sessionFreeForAll = 0;
        public DateTime changeDatetime = DateTime.MinValue;

        public UserTrustRatings() { }

        public UserTrustRatings(ulong puid, uint titleId, double c1_SuccessfulSessionCount, double c2_MinoritySessionCount,
            double c3_FailedSessionCount, double c4_ProblematicSessionCount, double c5_UDPReportCount,
            double c6_DisconnectCount, double c7_Type1SuspiciousCount, double c8_Type2SuspiciousCount,
            double c9_Type3SuspiciousCount, uint totalSessions, uint totalSessionDisconnects,
            uint totalCompetitions, uint totalCompetitionNoShows, uint sessionBase, uint sessionXboxCount,
            uint sessionSeconds, uint sessionFreeForAll, DateTime changeDatetime)
        {
            this.puid = puid;
            this.titleId = titleId;
            this.c1_SuccessfulSessionCount = c1_SuccessfulSessionCount;
            this.c2_MinoritySessionCount = c2_MinoritySessionCount;
            this.c3_FailedSessionCount = c3_FailedSessionCount;
            this.c4_ProblematicSessionCount = c4_ProblematicSessionCount;
            this.c5_UDPReportCount = c5_UDPReportCount;
            this.c6_DisconnectCount = c6_DisconnectCount;
            this.c7_Type1SuspiciousCount = c7_Type1SuspiciousCount;
            this.c8_Type2SuspiciousCount = c8_Type2SuspiciousCount;
            this.c9_Type3SuspiciousCount = c9_Type3SuspiciousCount;
            this.totalSessions = totalSessions;
            this.totalSessionDisconnects = totalSessionDisconnects;
            this.totalCompetitions = totalCompetitions;
            this.totalCompetitionNoShows = totalCompetitionNoShows;
            this.sessionBase = sessionBase;
            this.sessionXboxCount = sessionXboxCount;
            this.sessionSeconds = sessionSeconds;
            this.sessionFreeForAll = sessionFreeForAll;
            this.changeDatetime = changeDatetime;
        }

        public new UserTrustRatings MemberwiseClone()
        {
            return (UserTrustRatings)base.MemberwiseClone();
        }
    };

    public enum SubscriptionStatus : uint
    {
        Queued = 0xFFFFFFFF, // not used
        Pending = 0,
        Enabled = 1,
        Suspended = 2,
        Expired = 3,
        Deprovisioned = 4,    // Canceled
        OldSubscription = 10,   // in UODB
        Expired_No_Violations = 128 // only for Xbox1, never in UODB
    };

    public enum AccountResetState : uint
    {
        ForcedNameChange = 1,
        ReacceptTermOfUse = 2,
        VoiceBan = 3,
        AccountBan = 4,
        Max = 5
    };


    // Essential info from t_service_instances
    public class ServiceInfoInstance
    {
        public int TitleID;
        public int TitleVersion;
        public int TitleRegion;
        public int SiteID;
        public int Port;
        public int ServiceAvailable;
    }

    // Essential info from t_services
    public class ServiceInfo
    {
        public int ServiceID;
        public string Description;
        public int MachineOnly;
        public ServiceInfoInstance[] Instances;
    }

    public class LockoutInfo
    {
        public ulong UserPuid;
        public ulong LockoutPuid;
        public DateTime Added;
        public int HashBucket;
        public DateTime Changed;
    }

    public class TitleUpdateLocationInfo
    {
        public uint baseVer;
        public uint updateVer;
        public uint rank;
        public string XRL;
    }

    public class TitleUpdatePackagesInfo
    {
        public uint baseVer;
        public uint updateVer;
        public string updateSymKey;
        public string publicKey;
        public uint installSize;
        public uint packageSize;
        public string contentID;
    }

    public class FriendRecord
    {
        public ulong BuddyId;
        public uint Status;
    }

    public class GamerTagChange
    {
        public string OldGamerTag;
        public string NewGamerTag;
        public DateTime Timestamp;
        public bool WasPurchased;
        public string IpAddress;

        public GamerTagChange(string oldGamerTag, string newGamerTag, DateTime timestamp, bool wasPurchased, string ipAddress)
        {
            this.OldGamerTag = oldGamerTag;
            this.NewGamerTag = newGamerTag;
            this.Timestamp = timestamp;
            this.WasPurchased = wasPurchased;
            this.IpAddress = ipAddress;
        }

        public override bool Equals(object other)
        {
            return (other is GamerTagChange && this == (GamerTagChange)other);
        }

        public override int GetHashCode()
        {
            return OldGamerTag.GetHashCode() ^ NewGamerTag.GetHashCode()
                ^ Timestamp.GetHashCode() ^ WasPurchased.GetHashCode()
                ^ IpAddress.GetHashCode();
        }


        public static bool operator ==(GamerTagChange rhs, GamerTagChange lhs)
        {
            return (lhs.OldGamerTag == rhs.OldGamerTag
                    && lhs.NewGamerTag == rhs.NewGamerTag
                    && lhs.Timestamp == rhs.Timestamp
                    && lhs.WasPurchased == rhs.WasPurchased
                    && lhs.IpAddress == rhs.IpAddress);
        }

        public static bool operator !=(GamerTagChange rhs, GamerTagChange lhs)
        {
            return !(rhs == lhs);
        }
    }

    public class PassportChange
    {
        public ulong OldPassportPuid;
        public ulong NewPassportPuid;
        public DateTime Timestamp;
        public byte Reason;
        public string IpAddress;

        public PassportChange(ulong oldPassportPuid, ulong newPassportPuid, DateTime timestamp, byte reason, string ipAddress)
        {
            this.OldPassportPuid = oldPassportPuid;
            this.NewPassportPuid = newPassportPuid;
            this.Timestamp = timestamp;
            this.Reason = reason;
            this.IpAddress = ipAddress;
        }

        public override bool Equals(object other)
        {
            return (other is PassportChange && this == (PassportChange)other);
        }

        public override int GetHashCode()
        {
            return OldPassportPuid.GetHashCode() ^ NewPassportPuid.GetHashCode()
                ^ Timestamp.GetHashCode() ^ Reason.GetHashCode()
                ^ IpAddress.GetHashCode();
        }


        public static bool operator ==(PassportChange rhs, PassportChange lhs)
        {
            return (lhs.OldPassportPuid == rhs.OldPassportPuid
                    && lhs.NewPassportPuid == rhs.NewPassportPuid
                    && lhs.Timestamp == rhs.Timestamp
                    && lhs.Reason == rhs.Reason
                    && lhs.IpAddress == rhs.IpAddress);
        }

        public static bool operator !=(PassportChange rhs, PassportChange lhs)
        {
            return !(rhs == lhs);
        }
    }

    /// <summary>
    ///     Offer type enumeration. See CreateBulkUsers()
    /// </summary>
    public enum OfferType
    {
        StarterKit12Month,
        PrepaidCode12Month,
        GameTrial,
        ConsoleTrial,
        Trial3Month,
        MonthlyRenewal,
        YearlyRenewal
    }

    public class UserWebMapping
    {
        public ulong      Puid=0;
        public int        CredentialType=0;
        public byte[]     GamerWebId=new byte[8];
        public byte[]     OwnerWebId=new byte[8];
        public ulong      GamerWebPuid=0;
        public ulong      OwnerWebPuid=0;
        public DateTime   Change=DateTime.Now;

        static public bool CompareArrays(byte []a, byte []b)
        {
            if (a.Length!=b.Length)
                return false;
            int i;
            for (i=0; i<a.Length; i++)
            {
                if (a[i]!=b[i])
                    return false;
            }
            return true;
        }

        public bool CompareGamer(byte []other)
        {
            return CompareArrays(GamerWebId, other);
        }

        public bool CompareOwner(byte []other)
        {
            return CompareArrays(OwnerWebId, other);
        }
    }


    /// <summary>
    /// Summary description for WebMapping.
    /// </summary>
    public class UserWebMappingList
    {
        ArrayList data=new ArrayList(4);

        public int Length
        {
            get
            {
                return data.Count;
            }
        }

        public UserWebMapping[] GetArray()
        {
            return (UserWebMapping[]) data.ToArray(typeof(UserWebMapping));
        }

        public void Add(UserWebMapping uwm)
        {
            data.Add(uwm);
        }

        public UserWebMapping this[int Index]
        {
            get
            {
                return data[Index] as UserWebMapping;
            }
            set
            {
                data[Index]=value;
            }
        }

        public UserWebMappingList()
        {
            //
            // TODO: Add constructor logic here
            //
        }
    }

    public class QueryGenerator
    {
        /// <summary> Generates an SQL query for the logic of: "if count=0 then insert, else update" </summary>
        public static string GenerateUpdateOrInsert(string table, string []columnNames, object []values, string []keyColumnNames)
        {
            if (keyColumnNames.Length==0)
            {
                throw new System.Exception("You must specify at least one key column");
            }

            if (values.Length!=columnNames.Length)
            {
                throw new System.Exception("Length of the values and columns array must match.");
            }

            //find the column values that line up with the keys
            int []keyValueIndices=new int[keyColumnNames.Length];
            for (int keyInd=0; keyInd<keyColumnNames.Length; ++keyInd)
            {
                keyValueIndices[keyInd]=-1;
                for (int colInd=0; colInd<columnNames.Length; ++colInd)
                {
                    if (columnNames[colInd]==keyColumnNames[keyInd])
                    {
                        keyValueIndices[keyInd]=colInd;
                        break;
                    }
                }

                if (keyValueIndices[keyInd]==-1)
                {
                    throw new System.Exception("Key column "+keyColumnNames[keyInd]+" not found in the column names.");
                }
            }

            //build the count subquery
            string countQuery="select count(*) from "+table+" where ";

            for (int i=0; i<keyColumnNames.Length; ++i)
            {
                if (i>0)
                {
                    countQuery+=" and ";
                }

                countQuery+=keyColumnNames[i]+"="+EvaluateObject(values[keyValueIndices[i]]);
            }

            //build the insert subquery
            string insertQuery="insert into "+table+" (";

            for (int i=0; i<columnNames.Length; ++i)
            {
                if (i>0)
                {
                    insertQuery+=", ";
                }

                insertQuery+=columnNames[i];
            }

            insertQuery+=") values (";

            for (int i=0; i<values.Length; ++i)
            {
                if (i>0)
                {
                    insertQuery+=", ";
                }

                insertQuery+=EvaluateObject(values[i]);
            }

            insertQuery+=")";

            //build the update subquery
            string updateQuery="update "+table+" set ";

            for (int i=0; i<columnNames.Length; ++i)
            {
                if (i>0)
                {
                    updateQuery+=", ";
                }

                updateQuery+=columnNames[i]+"="+EvaluateObject(values[i]);
            }

            updateQuery+=" where ";

            for (int i=0; i<keyColumnNames.Length; ++i)
            {
                if (i>0)
                {
                    updateQuery+=" and ";
                }

                updateQuery+=keyColumnNames[i]+"="+EvaluateObject(values[keyValueIndices[i]]);
            }

            //put it all together
            string query="if (0=("+countQuery+"))\nbegin "+insertQuery+" end else begin "+updateQuery+" end";
            return query;
        }

        public static string EvaluateObject(object o)
        {
            if (o==null)
            {
                return "null";
            }
            else if (o is byte[])
            {
                return "0x"+ServerTestFramework.Utilities.Hexer.tohex((byte[])o);
            }
            else if (o is long || o is int || o is short || o is sbyte || o is byte)
            {
                return o.ToString();
            }
            else if (o is ulong)
            {
                return ((long)(ulong)o).ToString();
            }
            else if (o is uint)
            {
                return ((int)(uint)o).ToString();
            }
            else if (o is ushort)
            {
                return ((short)(ushort)o).ToString();
            }
            else if (o is DateTime) //the default ToString will truncate precision less than a second, this preserves it
            {
                System.DateTime dt=(System.DateTime)o;
                System.DateTime maxDate=new System.DateTime(9999, 12, 31, 23, 59, 59, 990);

                if (dt<maxDate) //999 ms is too large for sql, but 990ms is not apparently
                {
                    return "'"+dt.ToString("yyyy'-'MM'-'dd HH':'mm':'ss'.'fff")+"'";
                }
                else
                {
                    return "'"+maxDate.ToString("yyyy'-'MM'-'dd HH':'mm':'ss'.'fff")+"'";
                }
            }
            else
            {
                return "'"+EscapeString(o.ToString())+"'";
            }
        }

        public static string EscapeString(string str)
        {
            return str.Replace("'","''");
        }
    };
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\Database\UodbTable.cs ===
using System;
using System.Collections.Generic;
using System.Text;
using ServerTestFramework.Utilities;    

namespace ServerTestFramework.Database
{

    /// <summary>
    /// Represents an easy way to retrieve values from and modify tables in the UODB. 
    /// Intended to represent a single row.
    /// </summary>
    public class UodbTable
    {
        private string _tableName;
        private string _partitionedColumnName;
        private Dictionary<string, object> _properties;
        private Dictionary<string, object> _constraints;

        /// <summary>
        /// The name of the table
        /// </summary>
        public string TableName
        {
            get { return _tableName; }
        }

        /// <summary>
        /// Is this a partitioned or a non-partitioned (mirrored) table?
        /// </summary>
        public bool IsPartitioned
        {
            get { return _partitionedColumnName != null; }
        }

        /// <summary>
        /// Retrieves the value for the partitioned column from the constraints
        /// or properties. This is the value that needs to be hashed on.
        /// </summary>
        public object PartitioningValue
        {
            get
            {
                if (!IsPartitioned) 
                    throw new System.InvalidOperationException("UodbTable " + _tableName + " is not partitioned");
                // Check constraints first, then properties. I think that makes sense.
                if (_constraints.ContainsKey(_partitionedColumnName))
                    return _constraints[_partitionedColumnName];
                if (_properties.ContainsKey(_partitionedColumnName))
                    return _properties[_partitionedColumnName];
                throw new System.ArgumentNullException("Cannot find a value for " + _partitionedColumnName + " in either properties or constraints in UodbTable " + _tableName);
            }
        }

        /// <summary>
        /// Constructor for a non-partitioned (mirrored) database table
        /// </summary>
        /// <param name="tableName">Name of the table, i.e. t_users</param>
        public UodbTable(string tableName)
        {
            _tableName = tableName;
            _partitionedColumnName = null;
            _properties = new Dictionary<string, object>();
            _constraints = new Dictionary<string, object>();
        }
        
        /// <summary>
        /// Constructor for a partitioned database table
        /// </summary>
        /// <param name="tableName">Name of the table, i.e. t_users</param>
        /// <param name="partitionedColumnName">Name of the column this table is partitioned on, i.e. bi_user_puid</param>
        public UodbTable(string tableName, string partitionedColumnName)
        {
            _tableName = tableName;
            _partitionedColumnName = partitionedColumnName;
            _properties = new Dictionary<string, object>();
            _constraints = new Dictionary<string, object>();
        }

        /// <summary>
        /// Add or change a property and its value. A property is a column in the table.
        /// </summary>
        /// <param name="columnName">Name of property (column) to update</param>
        /// <param name="value">New value</param>
        public void SetProperty(string columnName, object value)
        {
            _properties[columnName] = value;
        }

        /// <summary>
        /// Add or change a constraint and its value. A constraint is a column in the
        /// table and is used in the "... WHERE constraints" part of the SQL clause.
        /// </summary>
        /// <param name="columnName">Name of constraint (column) to update</param>
        /// <param name="value">New value</param>
        public void SetConstraint(string columnName, object value)
        {
            _constraints[columnName] = value;
        }

        /// <summary>
        /// Retrieve a value for the column.
        /// </summary>
        /// <param name="columnName">Name of table's column</param>
        /// <returns>Data cell for row/column</returns>
        public object GetProperty(string columnName)
        {
            return _properties[columnName];
        }

        /// <summary>
        /// The SQL UPDATE statement for this dbtable
        /// </summary>
        public string GetSqlUpdateStatement()
        {
            string props = GetProperties();
            string constraints = GetConstraints();

            // Need properties to update, and need constraints so we don't 
            // update the whole table.
            if (props == null || constraints == null)
                throw new System.ArgumentNullException("No constraints or properties set, one or more of each are required for the UPDATE statement in UodbTable " + _tableName);

            return "UPDATE " + _tableName + " SET " + props + " WHERE " + constraints;
        }

        /// <summary>
        /// The SQL SELECT statement for this dbtable
        /// </summary>
        public string GetSqlSelectStatement()
        {
            string constraints = GetConstraints();

            if (constraints == null)
                throw new ArgumentNullException("No constraints set, one or more are required for the SELECT statement in UodbTable " + _tableName);

            return "SELECT * FROM " + _tableName + " WHERE " + constraints;
        }

        /// <summary>
        /// The SQL DELETE statement for this dbtable
        /// </summary>
        public string GetSqlDeleteStatement()
        {
            string constraints = GetConstraints();

            if (constraints == null)
                throw new ArgumentNullException("No constraints set, one or more are required for the DELETE statement in UodbTable " + _tableName);

            return "DELETE FROM " + _tableName + " WHERE " + constraints;
        }

        private string GetProperties()
        {
            return GetKeyValuePairs(_properties, ", ");
        }

        private string GetConstraints()
        {
            return GetKeyValuePairs(_constraints, " AND ");
        }

        private string GetKeyValuePairs(Dictionary<string, object> dictionary, string separator)
        {
            StringBuilder sb = new StringBuilder(200);
            if (dictionary.Count == 0)
            {
                return null;
            }
            int count = 0;
            foreach (KeyValuePair<string, object> kvp in dictionary)
            {
                string value;
                Type t = kvp.Value.GetType();
                if (t == typeof(Byte) ||
                    t == typeof(SByte) ||
                    t == typeof(Int16) ||
                    t == typeof(UInt16) ||
                    t == typeof(Int32) ||
                    t == typeof(UInt32) ||
                    t == typeof(Int64) ||
                    t == typeof(UInt64))
                {
                    value = String.Format("0x{0:X}", kvp.Value);
                }
                else if (t == typeof(string)
                      || t == typeof(DateTime)
                      || t == typeof(TimeSpan))
                {
                    value = "'" + kvp.Value.ToString() + "'";
                }
                else if (t == typeof(Byte[]) ||
                         t == typeof(SByte[]))
                {
                    value = "0x" + Hexer.tohex((byte[])kvp.Value);
                }
                else
                {
                    value = kvp.Value.ToString();
                }

                sb.AppendFormat("{0}={1}{2}",
                    kvp.Key,
                    value,
                    count < dictionary.Count - 1 ? separator : "");
                count++;
            }
            return sb.ToString();
        }

        public override string ToString()
        {
            string props = GetKeyValuePairs(_properties, ", ");
            string constraints = GetKeyValuePairs(_constraints, ", ");
            return String.Join("\n", new string[] {
                IsPartitioned ? 
                    String.Format("[{0}, partitioned on {1}={2}]", _tableName, _partitionedColumnName, PartitioningValue) :
                    String.Format("[{0}, non-partitioned]", _tableName),
                "Properties: " + props,
                "Constraints: " + constraints });
        }

        #region Test method
        public static string Test()
        {
            StringBuilder sb = new StringBuilder(1000);
            UodbTable t;

            sb.AppendLine("\nTesting non-partitioned (+)");
            t = new UodbTable("t_machines");
            t.SetConstraint("bi_machine_puid", 0xFA00000000000001);
            t.SetConstraint("dt_blocked_date", "2006-01-01 00:00:00.000");
            t.SetProperty("dt_blocked_date", "2006-01-01 00:00:00.000");
            t.SetProperty("dt_reset_date", "2006-01-01 00:00:00.000");
            sb.AppendLine(t.ToString());
            sb.AppendLine(t.GetSqlSelectStatement());
            sb.AppendLine(t.GetSqlUpdateStatement());

            sb.AppendLine("\nTesting partitioned (+)");
            t = new UodbTable("t_machines", "bi_machine_puid");
            t.SetConstraint("bi_machine_puid", 0xFA00000000000001);
            t.SetConstraint("dt_blocked_date", "2006-01-01 00:00:00.000");
            t.SetProperty("dt_blocked_date", "2006-01-01 00:00:00.000");
            t.SetProperty("dt_reset_date", "2006-01-01 00:00:00.000");
            sb.AppendLine(t.ToString());
            sb.AppendLine(t.GetSqlSelectStatement());
            sb.AppendLine(t.GetSqlUpdateStatement());

            try
            {
                sb.AppendLine("\nTesting non-partitioned (-)");
                t = new UodbTable("t_machines");
                t.SetProperty("dt_blocked_date", "2006-01-01 00:00:00.000");
                sb.AppendLine(t.ToString());
                sb.AppendLine(t.GetSqlSelectStatement());
                sb.AppendLine(t.GetSqlUpdateStatement());
            }
            catch (Exception e) { sb.AppendLine(e.Message); }

            try
            {
                sb.AppendLine("\nTesting non-partitioned (-)");
                t = new UodbTable("t_machines");
                t.SetConstraint("dt_blocked_date", "2006-01-01 00:00:00.000");
                sb.AppendLine(t.ToString());
                sb.AppendLine(t.GetSqlSelectStatement());
                sb.AppendLine(t.GetSqlUpdateStatement());
            }
            catch (Exception e) { sb.AppendLine(e.Message); }

            try
            {
                sb.AppendLine("\nTesting partitioned (-)");
                t = new UodbTable("t_machines", "bi_machine_puid");
                //t.SetConstraint("bi_machine_puid", 0xFA00000000000001);
                t.SetConstraint("dt_blocked_date", "2006-01-01 00:00:00.000");
                t.SetProperty("dt_blocked_date", "2006-01-01 00:00:00.000");
                t.SetProperty("dt_reset_date", "2006-01-01 00:00:00.000");
                sb.AppendLine(t.ToString());
                sb.AppendLine(t.GetSqlSelectStatement());
                sb.AppendLine(t.GetSqlUpdateStatement());
            }
            catch (Exception e) { sb.AppendLine(e.Message); }

            return sb.ToString();
        }
        #endregion

    }


}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\Database\UodbWS.cs ===
using System;
using System.Text;
using System.Data;
using System.Data.SqlClient;
using System.Data.Common;
using System.Collections;
using System.Collections.Generic;
using System.IO;
using System.Threading;
using System.Diagnostics;
using System.Xml;
using System.Runtime.InteropServices;
using System.Security.Cryptography;

using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.Billing;
using ServerTestFramework.LiveService.UserAccount;
using ServerTestFramework.WebWidget;
using ServerTestFramework.Utilities;

using Microsoft.Webstore.WstClient;
using xonline.common.sql.webstore;
using xonline.common.config;
using xonline.common.crypto;
using xonline.common.protocol;
using Microsoft.Xbox.Privacy.Client;
using Microsoft.Xbox.Privacy.Interfaces;
using ServerTestFramework.LiveService.UserSettings;

using LiveUserSetting = ServerTestFramework.LiveService.UserSettings.UserSetting;
using TestSyncSettingsRequest = ServerTestFramework.LiveService.UserSettings.SyncSettingsRequest;
using TestSyncSettingsResponse = ServerTestFramework.LiveService.UserSettings.SyncSettingsResponse;

namespace ServerTestFramework.Database
{
    /// <summary>
    /// Interfaces with the UODB WebStore - taking into account partitioned tables
    /// </summary>
    public class UodbWS
    {
        //static constructor
        static UodbWS()
        {
            //We can catch the first time UodbWS is referenced here and force the environment to be reset.
            //This doesn't catch cases where the environment is changed after starting, but it's an improvement over never catching it.
            Global.ResetEnvironment();
        }

        //One ring to rule them all.  Is this used anywhere? Nothing in this file seems to...
        static public ArrayList m_Kingdoms;

        /// <summary>
        /// Delegate for a handler that is called when a webstore query has completed.
        /// </summary>
        /// <param name="reader"></param>
        public delegate void HandleWebstoreReader( WstDataReader reader );

        // don't use and will be removed. Use ExecuteSQLScalar(string sql, object hash)
        /// <summary>
        /// Run the sql, expecting a certain value.  Returns true if all returned
        /// scalars match the expected result.  The query *must* expect an integer
        /// response, and is best used with a SELECT COUNT(*)... type of query.
        /// </summary>
        /// <param name="sql">The SQL query used</param>
        /// <param name="result">The expected value the query should return.</param>
        /// <returns></returns>
        static public bool ExecuteScalarExpectingResult(string sql, int expected)
        {
            Global.RO.Warn("Method UodbWS.ExecuteScalarExpectingResult() shouldn't be used.");
            return (expected == (int)ExecuteSQLScalar(sql, null));
        }

        // don't use this one. Use ExecuteSQLNonQuery(string sql, object hash) instead.
        static public int ExecuteNonQuery(string sql)
        {
            Global.RO.Warn("Method UodbWS.ExecuteNonQuery() shouldn't be used.");
            return ExecuteSQLNonQuery(sql, null);
        }

        // Using Webstore. select statement only, can set to AnyPartition by making hash to null
        public static object ExecuteSQLScalar(string sql, object hash)
        {
            return WebstoreDB.ExecuteSQLScalar(ConfigUtil.UodbWebstoreApp, sql, hash);
        }

        // Using Webstore. WRITEONLY command type, can set to All Physical Partitions by makeing hash to null
        public static int ExecuteSQLNonQuery(string sql, object hash)
        {
            return WebstoreDB.ExecuteSQLNonQuery(ConfigUtil.UodbWebstoreApp, sql, hash);
        }

        // Using Webstore. WRITEONLY command type, can set to All Physical Partitions by makeing hash to null
        public static int ExecuteSQLNonQuery(string sql, object hash, int timeoutInS)
        {
            return WebstoreDB.ExecuteSQLNonQuery(ConfigUtil.UodbWebstoreApp, sql, hash, timeoutInS);
        }

        public static void ExecuteSQLSelect(string sql, HandleWebstoreReader handler)
        {
            using (WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITETHENREAD_COMMANDTYPE))
            {
                ws.CommandSql = sql;

                using (WstDataReader r = ws.Execute())
                {
                    handler( r );
                }
            }
        }

        /// <summary>
        /// Executes a SQL SELECT statement using the provided UodbTable object. Results
        /// are stored in the dbtable.
        /// </summary>
        /// <param name="dbtable">UodbTable object to use. Must have 1 or more constraints
        /// set. Expected to only return 1 row.</param>
        public static int ExecuteSQLSelect(UodbTable dbtable)
        {
            return ExecuteSQLSelect(dbtable, null);
        }

       // for speical tables like t_dmp_purchase_transaction_music_details and t_dmp_purchase_transaction_music_items,
        // the hash column is userPuid, but it is not a column in the table, instead it is borrowed from another table, for this
        // case, t_dmp_purchase_transactions table. So we add the hashCol as the second input parameter here
        public static int ExecuteSQLSelect(UodbTable dbtable, object hashCol)
        {
            return WebstoreDB.ExecuteSQLSelect(ConfigUtil.UodbWebstoreApp, dbtable, hashCol);
        }

        /// <summary>
        /// Executes a SQL UPDATE statement using the provided UodbTable object.
        /// </summary>
        /// <param name="dbtable">UodbTable object to use. Must have 1 or more constraints
        /// set and 1 or more properties to update.</param>
        public static int ExecuteSQLUpdate(UodbTable dbtable)
        {
            string sql = dbtable.GetSqlUpdateStatement();
            Global.RO.Debug("Executing UodbTable UPDATE: {0}", sql);
            return ExecuteSQLWriteOnly(dbtable, sql);
        }

        /// <summary>
        /// Executes a SQL DELETE statement using the provided UodbTable object.
        /// </summary>
        /// <param name="dbtable">UodbTable object to use. Must have 1 or more constraints
        /// set.</param>
        public static int ExecuteSQLDelete(UodbTable dbtable)
        {
            string sql = dbtable.GetSqlDeleteStatement();
            Global.RO.Debug("Executing UodbTable DELETE: {0}", sql);
            return ExecuteSQLWriteOnly(dbtable, sql);
        }

        public static int ExecuteSQLWriteOnly(UodbTable dbtable, string sql)
        {
            object hash = WebstoreDB.GetHashFromUodbTable(dbtable);
            // The new trigger will update the change datetime as well, thus returning 2
            // updated rows. Divide by 2 to "fix" this.
            return ExecuteSQLNonQuery(sql, hash) / 2;
        }

        // execute the Sproc on all UODB physical partitions
        public static void ExecSProc(StoredProc sproc)
        {
            ExecuteSQLNonQuery(sproc.GenerateExecString(), null);
        }

        // Using Webstore. "select count" statement only.  Sums together the scalar returned for each partition and returns that.
        public static uint ExecuteSQLSelectCount(string sql)
        {
            return WebstoreDB.ExecuteSQLSelectCount(ConfigUtil.UodbWebstoreApp, sql);
        }

        // get the total number of physical partitions
        public static int WstPhysicalPartitionCount()
        {
            return WebstoreDB.WstPhysicalPartitionCount(ConfigUtil.UodbWebstoreApp);
        }

        // get the logical partition from hash (si_hash_bucket)
        public static int GetHashBucket(object hash)
        {
            return WebstoreDB.GetHashBucket(ConfigUtil.UodbWebstoreApp, hash);
        }

        private static void SetHashValue(WSClient ws, object hash)
        {
            Type t = hash.GetType();
            if (t == typeof(ulong))
                ws.SetHashVal((ulong)hash);
            else if (t == typeof(long))
                ws.SetHashVal((long)hash);
            else if (t == typeof(string))
                ws.SetHashVal((string)hash);
            else if (t == typeof(System.Guid))
                ws.SetHashVal((System.Guid)hash);
            else
                throw new UnexpectedTestResultException("Only ulong, long, string, and guid types are supported for hash values.");
        }

        //------------------------------------------------------------
        // user related

        public static string WhatServerIsTheUserOn(ulong puid)
        {
            string server = null;
            DoesUserExist(puid, out server);

            return server;
        }

        public static ulong DoesUserExist(string gamertag, out string server)
        {
            server = null;

            using (WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITETHENREAD_COMMANDTYPE))
            {
                // Data is partitioned by gamertag
                ws.PartitionType = WstPartitionType.Logical;
                ws.StoredProc = "dbo.p_xuacs_get_user_acct_by_name";
                ws.SetHashVal(gamertag);

                ws.AddParameter(ParamType.RETVAL, "@ret", 0);
                ws.AddParameter("@vc_gamertag", gamertag);
                ws.AddParameter(ParamType.OUTPUT, "@bi_user_puid", (ulong)0);

                ws.ExecuteNonQuery();

                // user not found
                uint hr = (uint)ws.GetIntParameter("@ret");
                if (HResult.Failed(hr))
                {
                    return 0;
                }

                // user found
                server = ws.Command.Database.Server.Name;
                return (ulong)ws.GetLongParameter("@bi_user_puid");
            }
        }

        /// <summary>
        /// Searches for a given user
        /// </summary>
        /// <param name="Puid">PUID of user</param>
        /// <returns>PUID of user</returns>
        /// <remarks>
        /// Searches for a given user
        ///returns the puid of the user if it finds a match, otherwise 0
        ///
        ///The reason why it returns a puid instead of a bool is to make this function return code
        ///compatible with DoesUserExist(string)
        ///</remarks>
        public static ulong DoesUserExist(ulong Puid, out string server)
        {
            server = null;
            ulong bRet = 0;
            string sql = "SELECT bi_user_puid, vc_gamertag FROM dbo.t_users WHERE bi_user_puid = " + Puid;

            using (WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITETHENREAD_COMMANDTYPE))
            {
                ws.PartitionType = WstPartitionType.Logical;
                ws.SetHashVal(Puid);
                ws.CommandSql = sql;

                using (WstDataReader r = ws.Execute())
                {
                    if (r.Read())
                    {
                        bRet = (ulong)r.GetInt64(0);
                    }

                    r.Close();

                    // user found
                    if (bRet != 0)
                        server = ws.Command.Database.Server.Name;

                    return bRet;
                }
            }
        }

        /*
         * Searches all UODB servers for a given user
         * returns the puid of the user if it finds a match, otherwise 0
         */
        public static ulong DoesUserExist(string gamertag)
        {
            string server = null;
            return DoesUserExist(gamertag, out server);
        }

        /*
         * Searches all UODB servers for a given user
         * returns the puid of the user if it finds a match, otherwise 0
         *
         * The reason why it returns a puid instead of a bool is to make this function return code
         * compatible with DoesUserExist(string)
         */
        public static ulong DoesUserExist(ulong Puid)
        {
            string server = null;
            return DoesUserExist(Puid, out server);
        }

        /// <summary>
        /// Searches for a given owner and dependent pair from t_family_membership
        /// </summary>
        public static bool DoesOwnerDependentExist(ulong OwnerPassportPuid, ulong UserPuid)
        {
            int count = 0;
            string sql = "SELECT count(*) FROM dbo.t_family_membership WHERE bi_user_puid = @bi_user_puid and bi_owner_passport_puid = @bi_owner_passport_puid";

            using (WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITETHENREAD_COMMANDTYPE))
            {
                ws.PartitionType = WstPartitionType.Logical;
                ws.SetHashVal(OwnerPassportPuid);
                ws.CommandSql = sql;
                ws.AddParameter("@bi_user_puid", UserPuid);
                ws.AddParameter("@bi_owner_passport_puid", OwnerPassportPuid);

                object ret = ws.ExecuteScalar();
                if (ret != null)
                {
                    count = (int)ret;
                }

                return (count == 1);
            }
        }

        /// <summary>
        /// Searches for a subscription for a user
        /// </summary>
        public static bool DoesUserCurrentOwnSubscription(ulong userPuid, Guid offerId, Guid offerInstance)
        {
            int count = 0;
           
            string sql = "select count(*) from t_subscriptions where bi_primary_puid = 0x" + userPuid.ToString("X") +
                " and dt_start_date <= getutcdate() and dt_end_date > getutcdate() and i_subscription_status_id = 1" +
                " and uid_catalog_offerid = '" + offerId + "' and uid_catalog_offerinstance_id = '" + offerInstance + "'";
            Global.RO.Info("Executing sql: " + sql);

            using (WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITETHENREAD_COMMANDTYPE))
            {
                ws.PartitionType = WstPartitionType.Logical;
                ws.SetHashVal(userPuid);
                ws.CommandSql = sql;

                object ret = ws.ExecuteScalar();
                if (ret != null)
                {
                    count = (int)ret;
                }

                return (count == 1);
            }
        }


        /// <summary>
        /// Get max user puid
        /// </summary>
        /// <returns>ulong</returns>
        public static ulong GetMaxXuid()
        {
            ulong maxPuid = 0;
            string sql = "SELECT max(bi_user_puid) FROM dbo.t_users";

            using (WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITETHENREAD_COMMANDTYPE))
            {
                for (int p = 0; p < ws.PhysicalPartitions; p++)
                {
                    ws.ClearParameters();
                    ws.PhysicalPartition = p;
                    ws.CommandSql = sql;

                    using (WstDataReader r = ws.Execute())
                    {
                        if (r.Read())
                        {
                            ulong temp = (ulong)r.GetInt64(0);
                            if (temp > maxPuid)
                            {
                                maxPuid = temp;
                            }
                        }

                        r.Close();
                    }
                }
            }

            return maxPuid;
        }

        /// <summary>
        /// Do a direct gamertag to puid look up.
        /// This method used to hit t_users on all partitions. It should be hitting
        /// t_user_names on the gamertag partition, since that's the point of the
        /// table. You must hash gamerTag in lowercase form!
        /// </summary>
        /// <param name="_gamertag">gamertag</param>
        /// <returns>puid of gamertag</returns>
        public static ulong GetUserIDFromGamerTag(string _gamertag)
        {
            return DoesUserExist(_gamertag);
        }

        /// <summary>
        /// Lookup the gamertag of a user puid
        /// </summary>
        /// <param name="userPuid">user's puid</param>
        /// <returns>Gamertag</returns>
        public static string GetGamertag(ulong puid)
        {
            string strRet = "";
            string sql = "SELECT vc_gamertag from dbo.t_users WHERE bi_user_puid = " + puid;

            using (WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITETHENREAD_COMMANDTYPE))
            {
                ws.PartitionType = WstPartitionType.Logical;
                ws.SetHashVal(puid);
                ws.CommandSql = sql;

                using (WstDataReader r = ws.Execute())
                {
                    if (r.Read())
                    {
                        strRet = (string)r.GetString(0);
                    }

                    r.Close();
                    return strRet;
                }
            }
        }

        public static bool IsUserQueued(ulong puid)
        {
            ulong bRet = 0;
            string sql = "SELECT bi_user_puid FROM dbo.t_user_billing_queue WHERE bi_user_puid = " + puid;

            using (WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITETHENREAD_COMMANDTYPE))
            {
                ws.PartitionType = WstPartitionType.Logical;
                ws.SetHashVal(puid);
                ws.CommandSql = sql;

                using (WstDataReader r = ws.Execute())
                {
                    if (r.Read())
                    {
                        bRet = (ulong)r.GetInt64(0);
                    }

                    r.Close();
                    return (bRet == puid);
                }
            }
        }

        public static short GetSetNoAgeOutQueueStatus(ulong puid, ulong passportPuid)
        {
            short siQueueStatus = 0;
            string sql = "SELECT si_queue_status FROM dbo.t_set_no_age_out_queue WHERE bi_user_puid = " + puid +
                                " And bi_passport_puid = " + passportPuid;

            using (WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITETHENREAD_COMMANDTYPE))
            {
                ws.PartitionType = WstPartitionType.Logical;
                ws.SetHashVal(puid);
                ws.CommandSql = sql;

                using (WstDataReader r = ws.Execute())
                {
                    if (r.Read())
                    {
                        siQueueStatus = (short)r.GetInt16(0);
                    }

                    r.Close();
                    return (siQueueStatus);
                }
            }
        }

        public static int EmptyAlternatePassportUrl(ulong userPuid, ulong passportPuid)
        {
            string sql = "update t_set_no_age_out_queue " +
                " set vc_alternate_passport_url = '' " +
                " where bi_user_puid= " + userPuid  +
                " and bi_passport_puid=" + passportPuid;

            return ExecuteSQLNonQuery(sql, userPuid); ;
        }

        /*
         * Searches all UODB servers for a given TEAM
         * returns the puid of the team if it finds a match, otherwise 0
         * throws an exception if the team is found on multiple partitions
         */
        public static ulong DoesTeamExist(string _TeamName)
        {
            ulong bRet = 0;
            string sql = "SELECT bi_team_puid FROM dbo.t_xprof_teams WHERE vc_name LIKE '" + _TeamName + "'";

            using (WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITETHENREAD_COMMANDTYPE))
            {
                for (int p = 0; p < ws.PhysicalPartitions; p++)
                {
                    ws.ClearParameters();
                    ws.PhysicalPartition = p;
                    ws.CommandSql = sql;

                    using (WstDataReader r = ws.Execute())
                    {
                        if (r.Read())
                        {
                            ulong TeamPuid = (ulong)r.GetInt64(0);
                            if (TeamPuid != 0)
                            {
                                if (bRet == 0)
                                    bRet = TeamPuid;
                                else
                                    throw new Exception("Team " + _TeamName + " found on multiple UODB servers, second server " + ws.Command.Database.Server);
                            }
                        }

                        r.Close();
                    }
                }

                return bRet;
            }
        }

        /// <summary>
        /// Looks up a country entry in uodb.t_countries, returns vc_name
        /// </summary>
        public static string GetCountryName(int CountryID)
        {
            string ret = null;
            string sql = "SELECT vc_name FROM dbo.t_countries WHERE ti_country_id = " + CountryID;

            using (WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITETHENREAD_COMMANDTYPE))
            {
                ws.PartitionType = WstPartitionType.Logical;
                ws.Partition = WstCommand.AnyPartition;
                ws.CommandSql = sql;

                using (WstDataReader myDataReader = ws.Execute())
                {
                    if (myDataReader.Read())
                    {
                        ret = myDataReader.GetString(0);
                        myDataReader.NextResult();
                        if (myDataReader.Read())
                            throw new Exception("Countries table has a non-unique country  - ID: " + CountryID);
                    }

                    myDataReader.Close();
                    return ret;
                }
            }
        }

        /// <summary>
        /// Lookup a country ID using it's friendly name.
        /// </summary>
        /// <param name="countryName">2 letter country code</param>
        /// <returns>Country ID</returns>faskfj;
        public static int GetCountryID(string countryCode)
        {
            int ret = 0;
            string sql = "SELECT ti_country_id from dbo.t_countries where vc_name = '" + countryCode + "'";

            using (WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITETHENREAD_COMMANDTYPE))
            {
                ws.PartitionType = WstPartitionType.Logical;
                ws.Partition = WstCommand.AnyPartition;
                ws.CommandSql = sql;

                using (WstDataReader myDataReader = ws.Execute())
                {
                    if (myDataReader.Read())
                    {
                        ret = (int)myDataReader.GetByte(0);
                        myDataReader.NextResult();
                        if (myDataReader.Read())
                            throw new Exception("Countries table has a non-unique country  - code: " + countryCode);
                    }

                    myDataReader.Close();
                    return ret;
                }
            }
        }

        /// <summary>
        /// Get all of the billing notifications for a user based on their PUID
        /// </summary>
        /// <param name="userPUID">the users online PUID</param>
        /// <returns></returns>
        public static bool GetBillingNotifications(ulong userPUID, Guid trackingGuid, out int eventID, out byte creditCardDeclinedReason )
        {
            eventID = 0;
            creditCardDeclinedReason = (byte)0;

            string sql =
                "SELECT i_event_id, ISNULL(ti_credit_card_decline_reason_id,0) AS ti_credit_card_decline_reason_id "
                + "FROM dbo.t_user_billing_notifications "
                + "WHERE bi_user_puid = @bi_user_puid AND uid_tracking_guid = @uid_tracking_guid";

            using (WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITETHENREAD_COMMANDTYPE))
            {
                ws.PartitionType = WstPartitionType.Logical;
                ws.SetHashVal(userPUID);
                ws.AddParameter("@bi_user_puid", userPUID);
                ws.AddParameter("@uid_tracking_guid", trackingGuid);
                ws.CommandSql = sql;

                using (WstDataReader myDataReader = ws.Execute())
                {
                    if (myDataReader.Read())
                    {
                        eventID = (int)myDataReader.GetInt32(0);
                        creditCardDeclinedReason = myDataReader.GetByte(1);
                        return true;
                    }
                }
            }

            return false;
        }

        /// <summary>
        /// Get the transient subscription notification for the given user and tracking guid
        /// </summary>
        /// <param name="userPuid">the userPuid (aka xuid) of the user</param>
        /// <param name="trackingGuid">the tracking guid of the specific notification</param>
        /// <returns></returns>
        public static bool GetSubscriptionNotification(ulong userPuid, Guid trackingGuid, out uint titleId, out Guid offerId, out bool isTrial, out DateTime endDate, out bool enabled)
        {
            titleId = 0;
            offerId = Guid.Empty;
            isTrial = false;
            endDate = DateTime.MinValue;
            enabled = false;

            string sql =
                "SELECT i_title_id, uid_offer_id, ti_is_trial, dt_end_date, ti_enabled "
                + "FROM dbo.t_user_subscription_notifications "
                + "WHERE bi_user_puid = @bi_user_puid AND uid_tracking_guid = @uid_tracking_guid";

            using (WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITETHENREAD_COMMANDTYPE))
            {
                ws.PartitionType = WstPartitionType.Logical;
                ws.SetHashVal(userPuid);
                ws.AddParameter("@bi_user_puid", userPuid);
                ws.AddParameter("@uid_tracking_guid", trackingGuid);
                ws.CommandSql = sql;

                using (WstDataReader rdr = ws.Execute())
                {
                    if (rdr.Read())
                    {
                        titleId = (uint)rdr.GetInt32(0);
                        offerId = rdr.GetGuid(1);
                        isTrial = (rdr.GetByte(2) != 0);
                        endDate = rdr.GetDateTime(3);
                        enabled = (rdr.GetByte(4) != 0);
                        return true;
                    }
                }
            }

            return false;
        }

        /// <summary>
        /// Fetches the Enabled value for a notification associated with given userPuid and instanceId
        /// </summary>
        /// <param name="userPuid">the userPuid (aka xuid) of the user</param>
        /// <param name="instanceId">subscription instance Id</param>
        /// <returns></returns>
        public static bool GetEnabledValueForNotification(ulong userPuid, string instanceId, out bool enabled)
        {
            enabled = false;

            string sql = String.Format(
                "SELECT tu.ti_enabled "
                + "FROM dbo.t_user_subscription_notifications tu INNER JOIN t_subscriptions ts "
                + "ON tu.bi_user_puid = ts.bi_primary_puid "
                + "WHERE bi_user_puid = {0} "
                + "AND vc_svc_instance_id = '{1}' "
                + "AND tu.dt_end_date > GETUTCDATE()", userPuid, instanceId);


            using (WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITETHENREAD_COMMANDTYPE))
            {
                ws.PartitionType = WstPartitionType.Logical;
                ws.SetHashVal(userPuid);
                ws.CommandSql = sql;

                using (WstDataReader rdr = ws.Execute())
                {
                    if (rdr.Read())
                    {
                        enabled = (rdr.GetByte(0) != 0);
                        return true;
                    }
                }
            }

            return false;
        }

        /// <summary>
        /// Lookup the language ID used by the given locale
        /// </summary>
        /// <param name="localeCode">Locale string. IE: "en-US"</param>
        /// <returns>The Language ID used by this Live locale</returns>
        public static int GetLanguageId(string localeCode)
        {
            int langId = 1; // default to US English
            string sql = "SELECT i_language_id FROM t_cultures WHERE vc_code = '" + localeCode + "'";

            using (WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITETHENREAD_COMMANDTYPE))
            {
                ws.PartitionType = WstPartitionType.Logical;
                ws.Partition = WstCommand.AnyPartition;
                ws.CommandSql = sql;

                using (WstDataReader myDataReader = ws.Execute())
                {
                    if (myDataReader.Read())
                    {
                        langId = myDataReader.GetInt32(0);
                    }

                    myDataReader.Close();
                    return langId;
                }
            }
        }


        /// <summary>
        /// Looks up a Language entry in uodb.t_languages, returns vc_name
        /// </summary>
        /// <param name="LanguageID">Language Id. e.g. 1</param>
        /// <returns>The name for this Language Id</returns>
        public static string GetLanguageName(int LanguageID)
        {
            string ret = null;
            string sql = "SELECT vc_name FROM t_languages WHERE i_language_id = " + LanguageID;

            using (WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITETHENREAD_COMMANDTYPE))
            {
                ws.PartitionType = WstPartitionType.Logical;
                ws.Partition = WstCommand.AnyPartition;
                ws.CommandSql = sql;

                using (WstDataReader myDataReader = ws.Execute())
                {
                    if (myDataReader.Read())
                    {
                        ret = myDataReader.GetString(0);
                        myDataReader.NextResult();
                        if (myDataReader.Read())
                            throw new Exception("Languages table has a non-unique language  - ID: " + LanguageID);
                    }

                    myDataReader.Close();
                    return ret;
                }
            }
        }

        /// <summary>
        /// Lookup a live billing offer ID from the SPS billing offer ID string.
        /// </summary>
        /// <param name="billingOfferID">SPS billing offer ID string</param>
        /// <returns>Live billing offer ID</returns>
        public static ulong GetOfferID(string billingOfferID)
        {
            ulong ret = 0;
            string sql = "SELECT bi_offer_id from dbo.t_offer_regions where vc_billing_offer_id = '" + billingOfferID + "'";

            using (WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITETHENREAD_COMMANDTYPE))
            {
                ws.PartitionType = WstPartitionType.Logical;
                ws.Partition = WstCommand.AnyPartition;
                ws.CommandSql = sql;

                using (WstDataReader myDataReader = ws.Execute())
                {
                    if (myDataReader.Read())
                    {
                        ret = (ulong)myDataReader.GetInt64(0);
                        myDataReader.NextResult();
                        if (myDataReader.Read())
                            throw new Exception("t_offer_regions table has a non-unique billing offer ID: " + billingOfferID);
                    }

                    myDataReader.Close();
                    return ret;
                }
            }
        }


        /// <summary>
        /// Get the supported regions for an offer.
        /// </summary>
        /// <param name="offerId">legacy offer Id</param>
        /// <returns>List of countryId where  the offer is available</returns>
        public static List<byte> GetOfferSupportRegions(ulong offerId)
        {
            byte ret = 0;
            string sql = "SELECT ti_country_id from dbo.t_offer_regions where dt_end_date >= getdate() and bi_offer_id  = 0x" + offerId.ToString("X");
            List<byte> countryIds = null;

            using (WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITETHENREAD_COMMANDTYPE))
            {
                ws.PartitionType = WstPartitionType.Logical;
                ws.Partition = WstCommand.AnyPartition;
                ws.CommandSql = sql;

                using (WstDataReader myDataReader = ws.Execute())
                {
                    while (myDataReader.Read())
                    {                   
                        ret = myDataReader.GetByte(0);
                        if (countryIds == null) 
                        {
                            countryIds = new List<byte>();
                        }

                        countryIds.Add(ret);
                  }
                    myDataReader.Close();
                    return countryIds;
                }
            }
        }

        public static bool GetUserKeys(string name, out int encKeyVersion, out int keyVersion)
        {
            return GetUserKeys(name, out encKeyVersion, out keyVersion, false);
        }

        public static bool GetUserKeys(string userName, out int encKeyVersion, out int keyVersion, bool isXenon)
        {
            bool bRet = false;
            encKeyVersion = -1;
            keyVersion = -1;
            string table = "t_user_keys";
            if (isXenon)
                table = "t_xenon_user_keys";

            string sql = "SELECT * FROM dbo." + table + " WHERE vc_gamertag = '" + userName + "'";

            using (WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITETHENREAD_COMMANDTYPE))
            {
                ws.PartitionType = WstPartitionType.Logical;
                ws.SetHashVal(userName);
                ws.CommandSql = sql;

                using (WstDataReader myDataReader = ws.Execute())
                {
                    if (myDataReader.Read())
                    {
                        encKeyVersion = (int)myDataReader.GetInt32(1);
                        keyVersion = (int)myDataReader.GetInt32(2);
                        bRet = true;
                    }

                    myDataReader.Close();
                    return bRet;
                }
            }
        }

        /// <summary>
        /// Returns user information
        /// </summary>
        /// <param name="userPuid">user's puid</param>
        /// <param name="user">[out] information about the user</param>
        /// <returns></returns>
        public static bool GetUserInfo(ulong _puid, out UserInfo user)
        {
            bool bRet = false;
            user = new UserInfo();
            string sql = "SELECT vc_gamertag,bi_machine_puid,ti_name_change_required," +
                    "dt_acct_resume_date,i_suspension_length,dt_voice_resume_date,i_voice_ban_length," +
                    "dt_accepted_tos, bi_owner_puid, dt_created," +
                    "si_ticket_flags, dt_change_datetime, ti_country_id, i_language_id, i_culture_id, " +
                    "i_billing_account_status, vc_billing_account_id, " +
                    "vc_billing_payinfo_id, f_ms_opt_in, f_partner_opt_in, ti_created_account_type, bi_offline_xuid, f_geofence_exempt " +
                    ", f_free_gamertag_eligible " +
                    " FROM dbo.t_users WHERE bi_user_puid = " + _puid;

            using (WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITETHENREAD_COMMANDTYPE))
            {
                ws.PartitionType = WstPartitionType.Logical;
                ws.SetHashVal(_puid);
                ws.CommandSql = sql;

                using (WstDataReader myDataReader = ws.Execute())
                {
                    if (myDataReader.Read())
                    {
                        user.nickname = (string)myDataReader.GetString(0);
                        user.machinePuid = (ulong)myDataReader.GetInt64(1);
                        user.nameChangeRequired = (byte)myDataReader.GetByte(2);
                        user.suspendedUntil = (DateTime)myDataReader.GetDateTime(3);
                        user.totalDaysSuspended = (int)myDataReader.GetInt32(4);
                        user.voiceBannedUntil = (DateTime)myDataReader.GetDateTime(5);
                        user.totalDaysVoiceBanned = (int)myDataReader.GetInt32(6);
                        user.acceptedTOS = ((DateTime)myDataReader.GetDateTime(7));
                        user.ownerPuid = (ulong)myDataReader.GetInt64(8);
                        user.created = ((DateTime)myDataReader.GetDateTime(9));
                        user.ticketFlags = (ushort)myDataReader.GetInt16(10);
                        user.changed = ((DateTime)myDataReader.GetDateTime(11));
                        user.country = (int)myDataReader.GetByte(12);
                        user.language = (int)myDataReader.GetInt32(13);
                        user.culture = (int)myDataReader.GetInt32(14);
                        user.billingAccountStatus = (uint)myDataReader.GetInt32(15);
                        user.billingAccountId = (string)myDataReader.GetString(16);
                        user.paymentInstrumentId = (string)myDataReader.GetString(17);
                        user.msSpam = (byte)myDataReader.GetSqlByte(18);
                        user.partnerSpam = (byte)myDataReader.GetSqlByte(19);
                        user.createdAccountType = myDataReader.GetByte(20);
                        user.offlineXuid = (ulong)myDataReader.GetInt64(21);
                        user.isGeofenceExempt = (byte)myDataReader.GetSqlByte(22);
                        user.isFreeGamertagEligible = (byte)myDataReader.GetSqlByte(23);
                        user.puid = _puid;
                        user.server = ws.Command.Database.Server.Name;

                        bRet = true;
                    }

                    myDataReader.Close();
                    return bRet;
                }
            }
        }

        /// <summary>
        /// Returns user information. Throws an exception on error
        /// </summary>
        /// <param name="userPuid">user's puid</param>
        /// <returns>information about the user</returns>
        public static UserInfo GetUserInfo(ulong userPuid)
        {
            UserInfo user;
            if (userPuid == 0 || !GetUserInfo(userPuid, out user))
                throw new ApplicationException("Can't find " + userPuid);
            return user;
        }

        /// <summary>
        /// Returns user-web linking
        /// </summary>
        /// <param name="userPuid">user's puid</param>
        /// <returns></returns>
        public static UserWebMappingList GetUserWebMapping(ulong puid)
        {
            UserWebMappingList uwml = new UserWebMappingList();
            string sql = "SELECT " +
                    "t_users.bi_user_puid, " +
                    "t_users.bi_user_passport_puid, " +
                    "t_users.bi_owner_passport_puid, " +
                    "t_users.dt_Change_datetime " +
                    "FROM t_users JOIN t_user_passport_puids " +
                    "ON t_users.bi_user_puid = t_user_passport_puids.bi_user_puid " +
                    "WHERE t_users.bi_user_puid = " + puid;

            using (WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITETHENREAD_COMMANDTYPE))
            {
                ws.PartitionType = WstPartitionType.Logical;
                ws.SetHashVal(puid);
                ws.CommandSql = sql;

                using (WstDataReader myDataReader = ws.Execute())
                {
                    while (myDataReader.Read())
                    {
                        object o;
                        UserWebMapping uwm = new UserWebMapping();

                        uwm.Puid = (ulong)myDataReader.GetInt64(0);
                        uwm.CredentialType = 1; // Passport

                        o = myDataReader.GetValue(1);
                        if (o is System.DBNull)
                            uwm.GamerWebPuid = 0;
                        else
                            uwm.GamerWebPuid = (ulong)Convert.ToInt64(o);

                        o = myDataReader.GetValue(2);
                        if (o is System.DBNull)
                            uwm.OwnerWebPuid = 0;
                        else
                            uwm.OwnerWebPuid = (ulong)Convert.ToInt64(o);

                        uwm.GamerWebId = BitConverter.GetBytes(uwm.GamerWebPuid);
                        uwm.OwnerWebId = BitConverter.GetBytes(uwm.OwnerWebPuid);

                        uwm.Change = ((DateTime)myDataReader.GetDateTime(3));
                        uwml.Add(uwm);
                    }

                    myDataReader.Close();
                    return uwml;
                }
            }
        }

        public static void AddToWebMappings(string userName, ulong puid)
        {
            byte[] wedId = WCUserAccount.PuidToWebID(puid);
            string sqlWebId = "0x" + Hexer.tohex(wedId);

            string sql = "insert into t_users VALUES (" + puid + "," + puid + ",0x9500000000000, 0x00000000,'" + userName + "','1963-03-25 00:00:00.000', 103, 0x01010101, 0, 'wbcatest', 'wbcatest', 0, 0, '1979-12-30 00:00:00.000', 0, '1979-12-30 00:00:00.000', 0, 0, getutcdate(), getutcdate(), 0, 0, 0, 0, getutcdate(), null)";
            ExecuteSQLNonQuery(sql, puid);

            sql = "insert into t_user_web_mapping VALUES(" + puid + ",1," + sqlWebId + "," + sqlWebId + "," + puid + "," + puid + ",100,'2003-07-10')";
            ExecuteSQLNonQuery(sql, puid);
        }


        /// <summary>
        /// Retrieves a list of licenses for a user, a machine, or both.
        /// </summary>
        /// <param name="userPuid">PUID of the user. May be 0 to get all licenses for a machine.</param>
        /// <param name="machinePuid">PUID of the machine. May be 0 to get all licenses for a user.</param>
        /// <returns>A List of UserLicense objects.</returns>
        public static List<UserLicense> GetUserLicenses(ulong userPuid, ulong machinePuid)
        {
            // Both input values may not be zero
            if (userPuid == 0 && machinePuid == 0)
                throw new ArgumentException("A non-zero user or machine PUID must be specified.");

            List<UserLicense> licenses = new List<UserLicense>();
            StringBuilder sql = new StringBuilder();

            sql.Append("SELECT bi_user_id,bi_offer_id,bi_machine_id,si_hash_bucket,dt_change_datetime FROM t_user_licenses WHERE ");
            if (userPuid > 0)
            {
                sql.AppendFormat("bi_user_puid = 0x{0:X8}", userPuid);
            }
            if (machinePuid > 0)
            {
                sql.AppendFormat("{0}bi_machine_id = 0x{1:X8}", userPuid > 0 ? " AND " : "", machinePuid);
            }

            using (WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.READONLY_COMMANDTYPE))
            {
                ws.PartitionType = WstPartitionType.Logical;
                ws.CommandSql = sql.ToString();

                WstDataReader reader = null;
                reader = ws.Execute();
                try
                {
                    while (reader.Read())
                    {
                        UserLicense license = new UserLicense();
                        license.UserId = (ulong)reader.GetInt64(0);
                        license.OfferId = (ulong)reader.GetInt64(1);
                        license.MachineId = (ulong)reader.GetInt64(2);
                        license.HashBucket = reader.GetInt16(3);
                        license.Changed = reader.GetDateTime(4);
                        licenses.Add(license);
                    }
                }
                finally
                {
                    if (reader != null)
                    {
                        reader.Close();
                    }
                }
            }

            return licenses;
        }


        /// <summary>
        /// Returns the passport puid associated with this user
        /// </summary>
        /// <param name="userPuid">user's puid</param>
        /// <returns>The user's passport puid</returns>
        public static ulong GetUserPassportUserPuid(ulong userPuid)
        {
            return unchecked((ulong)long.Parse(GetUserProperty(userPuid, "bi_user_passport_puid")));
        }


        /// <summary>
        /// Returns the passport puid associated with this user
        /// </summary>
        /// <param name="userPuid">user's puid</param>
        /// <returns>The user's passport puid</returns>
        public static ulong GetUserPassportOwnerPuid(ulong userPuid)
        {
            return unchecked((ulong)long.Parse(GetUserProperty(userPuid, "bi_owner_passport_puid")));
        }


        /// <summary>
        /// Get a single property as a string from the proper partition of UODB
        /// </summary>
        /// <param name="userPuid">user's puid</param>
        /// <param name="_property">property name</param>
        /// <returns>property value</returns>
        public static string GetUserProperty(ulong _puid, string _property)
        {
            if (_puid == 0)
                throw new ApplicationException("Can't find user " + _puid);

            string strValue = "";
            string sql = "SELECT cast(" + _property + " as varchar(255)) FROM dbo.t_users WHERE bi_user_puid = " + _puid;

            using (WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITETHENREAD_COMMANDTYPE))
            {
                ws.PartitionType = WstPartitionType.Logical;
                ws.SetHashVal(_puid);
                ws.CommandSql = sql;

                using (WstDataReader r = ws.Execute())
                {
                    if (r.Read())
                    {
                        strValue = (string)r.GetString(0);
                    }

                    r.Close();
                    if (string.IsNullOrEmpty(strValue))
                        throw new ApplicationException("Can't find user " + _puid);
                    return strValue;
                }
            }
        }

        /// <summary>
        /// Get a single property as a string from the proper partition of UODB
        /// </summary>
        /// <param name="userPuid">user's puid</param>
        /// <param name="_property">property name</param>
        /// <returns>property value</returns>
        public static string GetLatestUserSubscriptionProperty(ulong _puid, ulong _offerId, string _property)
        {
            if (_puid == 0)
                throw new ApplicationException("Can't find user " + _puid);

            string strValue = "";
            string sql = "SELECT TOP 1 cast(" + _property + 
                         " as varchar(255)) FROM dbo.t_subscriptions WHERE bi_primary_puid = " + _puid +
                         " and bi_offer_id = 0X" + _offerId.ToString("X") +
                         " order by dt_Change_datetime DESC";
            Global.RO.Info("Executing sql: " + sql);

            using (WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITETHENREAD_COMMANDTYPE))
            {
                ws.PartitionType = WstPartitionType.Logical;
                ws.SetHashVal(_puid);
                ws.CommandSql = sql;

                using (WstDataReader r = ws.Execute())
                {
                    if (r.Read())
                    {
                        if (r.IsDBNull(0)) return null;
                        strValue = (string)r.GetString(0);
                    }
                    else
                        throw new ApplicationException("Can't find records for user " + _puid);

                    r.Close();
                    return strValue;
                }
            }
        }


        /// <summary>
        /// Set a single property on a user in the property partition of UODB
        /// </summary>
        /// <param name="userPuid">user's puid</param>
        /// <param name="_property">property name</param>
        /// <param name="_newvalue">new property value</param>
        /// <returns>true if set was successful</returns>
        public static bool SetUserProperty(ulong _puid, string _property, string _newvalue)
        {
            if (_puid == 0)
                throw new ApplicationException("Can't find user " + _puid);

            int FieldsAffected = 0;
            string sql = "UPDATE t_users " +
                    "SET " + _property + "= '" + _newvalue + "'" +
                    " WHERE (bi_user_puid = " + _puid + ")";

            using (WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITEONLY_COMMANDTYPE))
            {
                ws.PartitionType = WstPartitionType.Logical;
                ws.SetHashVal(_puid);
                ws.CommandSql = sql;

                FieldsAffected = ws.ExecuteNonQuery();
                if (FieldsAffected != 2)
                    throw new ApplicationException("Can't find user " + _puid);

                return (FieldsAffected == 2); // since a new trigger will update the changedtime, two rows returned instead of one
            }
        }

        /// <summary>
        /// Set account management information in the proper partition of UODB
        /// </summary>
        /// <param name="_puid">user's puid</param>
        /// <param name="type">account management type</param>
        /// <param name="nDurationInDays">how long the account is being banned</param>
        /// <returns></returns>
        public static void SetUserAccountState(ulong _puid, AccountResetState type, uint nDurationInDays)
        {
            DateTime resumeDate = DateTime.Today;
            resumeDate = resumeDate.AddDays((double)nDurationInDays);
            string sqlExecutionString = string.Empty;

            if (type == AccountResetState.ForcedNameChange)
            {
                sqlExecutionString = "UPDATE t_users SET ti_name_change_required = 1 WHERE bi_user_puid = " + _puid.ToString();
            }
            else if (type == AccountResetState.ReacceptTermOfUse)
            {
                sqlExecutionString = "UPDATE t_users SET dt_accepted_tos = '2000-01-01 00:00:00.000' WHERE bi_user_puid = " + _puid.ToString();
            }
            else if (type == AccountResetState.VoiceBan)
            {
                sqlExecutionString = "UPDATE t_users SET i_voice_ban_length = "
                    + nDurationInDays.ToString()
                    + ", dt_voice_resume_date = '"
                    + resumeDate.ToString("yyyy-MM-dd HH:mm:ss.fff")
                    + "' WHERE bi_user_puid = "
                    + _puid.ToString();
            }
            else if (type == AccountResetState.AccountBan)
            {
                sqlExecutionString = "UPDATE t_users SET i_suspension_length = "
                    + nDurationInDays.ToString()
                    + ", dt_acct_resume_date = '"
                    + resumeDate.ToString("yyyy-MM-dd HH:mm:ss.fff")
                    + "' WHERE bi_user_puid = "
                    + _puid.ToString();
            }
            else
            {
                throw new NotImplementedException("Requested account service is not implemented");
            }

            using (WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITEONLY_COMMANDTYPE))
            {
                ws.PartitionType = WstPartitionType.Logical;
                ws.SetHashVal(_puid);
                ws.CommandSql = sqlExecutionString;

                ws.ExecuteNonQuery();
            }
        }

        /// <summary>
        /// Expires account management information in the proper partition of UODB
        /// </summary>
        /// <param name="_puid">user's puid</param>
        /// <param name="type">account management type to expire</param>
        /// <returns></returns>
        public static void ExpireUserAccountState(ulong _puid, AccountResetState type)
        {
            DateTime expireDate = DateTime.Today.AddDays(-1);
            string sqlExecutionString = string.Empty;

            switch (type)
            {
                case AccountResetState.ForcedNameChange:
                    sqlExecutionString = "UPDATE t_users SET ti_name_change_required = 0 WHERE bi_user_puid = " + _puid.ToString();
                    break;
                case AccountResetState.VoiceBan:
                    sqlExecutionString = "UPDATE t_users SET dt_voice_resume_date = '"
                        + expireDate.ToString("yyyy-MM-dd HH:mm:ss.fff")
                        + "' WHERE bi_user_puid = "
                        + _puid.ToString();
                    break;
                case AccountResetState.AccountBan:
                    sqlExecutionString = "UPDATE t_users SET dt_acct_resume_date = '"
                        + expireDate.ToString("yyyy-MM-dd HH:mm:ss.fff")
                        + "' WHERE bi_user_puid = "
                        + _puid.ToString();
                    break;
                default:
                    throw new NotImplementedException("Requested account expiration is not implemented");
            }

            using (WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITEONLY_COMMANDTYPE))
            {
                ws.PartitionType = WstPartitionType.Logical;
                ws.SetHashVal(_puid);
                ws.CommandSql = sqlExecutionString;

                ws.ExecuteNonQuery();
            }
        }

        /// <summary>
        /// Only get the grant privileges
        /// </summary>
        /// <param name="userPuid"></param>
        /// <param name="privileges"></param>
        /// <returns></returns>
        public static bool GetUserPrivileges(ulong userPuid, out UserPrivileges privileges)
        {
            // TODOD: Get ti_privilege_id from t_user_privilege_revoked too.
            privileges = new UserPrivileges();
            string sql = "select ti_privilege_id from t_user_privilege_grants where bi_user_puid = " + userPuid.ToString();

            using (WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITETHENREAD_COMMANDTYPE))
            {
                ws.PartitionType = WstPartitionType.Logical;
                ws.SetHashVal(userPuid);
                ws.CommandSql = sql;

                using (WstDataReader r = ws.Execute())
                {
                    while (r.Read())
                    {
                        privileges[r.GetByte(0)] = true;
                    }

                    r.Close();
                    return true;
                }
            }
        }

        /// <summary>
        /// Get both grant privileges and restricted privileges
        /// </summary>
        /// <param name="userPuid"></param>
        /// <param name="grantPrivileges"></param>
        /// <param name="restrictPrivileges"></param>
        /// <returns></returns>
        public static bool GetUserPrivileges(ulong userPuid, out UserPrivileges grantPrivileges, out UserPrivileges restrictPrivileges)
        {
            grantPrivileges = new UserPrivileges();
            restrictPrivileges = new UserPrivileges();

            using (WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITETHENREAD_COMMANDTYPE))
            {
                // grant table
                string sql = "select ti_privilege_id from t_user_privilege_grants where bi_user_puid = 0x" + userPuid.ToString("X");
                ws.PartitionType = WstPartitionType.Logical;
                ws.SetHashVal(userPuid);
                ws.CommandSql = sql;

                using (WstDataReader r = ws.Execute())
                {
                    while (r.Read())
                    {
                        grantPrivileges[r.GetByte(0)] = true;
                    }
                    r.Close();
                }

                // revoke table
                sql = "select ti_privilege_id from t_user_privilege_restrictions where bi_user_puid = 0x" + userPuid.ToString("X");
                ws.PartitionType = WstPartitionType.Logical;
                ws.SetHashVal(userPuid);
                ws.CommandSql = sql;

                using (WstDataReader r = ws.Execute())
                {
                    while (r.Read())
                    {
                        restrictPrivileges[r.GetByte(0)] = true;
                    }
                    r.Close();
                }

                return true;
            }
        }

        public static int[] GetAllValidPrivileges()
        {
            int[] results = null;
            string sql = "select ti_privilege_id, rcount = (select count(*) from t_privileges) from t_privileges";

            using (WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITETHENREAD_COMMANDTYPE))
            {
                ws.PartitionType = WstPartitionType.Logical;
                ws.Partition = WstCommand.AnyPartition;
                ws.CommandSql = sql;

                using (WstDataReader r = ws.Execute())
                {
                    int i = 0;
                    while (r.Read())
                    {
                        if (results == null)    // array hasn't been set yet
                        {
                            results = new int[r.GetInt32(1)];
                        }
                        results[i++] = r.GetByte(0);
                    }

                    r.Close();

                    return results;
                }
            }
        }


        /// <summary>
        /// Sets the billing account Id of a user 
        /// </summary>
        /// <param name="userPuid">user's puid</param>
        /// <param name="vc_billing_account_id">new billing account Id</param>     
        public static void  UpdateUserBillingAccountId(ulong puid, string vc_billing_account_id)
        {
                           
              string sql = string.Format("UPDATE t_users SET vc_billing_account_id = '{1}' WHERE bi_user_puid = {0} and vc_billing_account_id !='{1}'",
                           puid,  vc_billing_account_id);
              ExecuteSQLNonQuery(sql, puid);
            
        }

        /// <summary>
        /// Update start date in t_subscription_history corresponding to input user's active subscription's offerid
        /// </summary>
        /// <param name="puid">User Puid</param>
        /// <param name="startDate">Start Date</param>
        /// <param name="offerId">Offer Id</param>
        public static void UpdateStartDateInSubscriptionHistory(ulong puid, DateTime startDate, ulong offerId)
        {
            string sql = String.Format("UPDATE t_subscription_history SET dt_start_date = '{0}' "
                                        + " WHERE bi_user_puid = {1} AND bi_offer_id = 0x{2} AND i_subscription_status_id = 1", startDate, puid, offerId.ToString("X"));

            Global.RO.Info("Executing sql: " + sql);
            ExecuteSQLNonQuery(sql, puid);
        }

        /// <summary>
        /// Update end date in t_subscription_history corresponding to input user's inactive subscription's offerid
        /// </summary>
        /// <param name="puid">User Puid</param>
        /// <param name="endDate">End Date</param>
        /// <param name="offerId">Offer Id</param>
        public static void UpdateEndDateInSubscriptionHistory(ulong puid, DateTime endDate, ulong offerId)
        {
            string sql = String.Format("UPDATE t_subscription_history SET dt_end_date = '{0}'" 
                                        + " FROM t_subscription_history tsh INNER JOIN t_subscriptions ts"
                                        + " ON (tsh.bi_user_puid = ts.bi_primary_puid) AND (tsh.bi_offer_id = ts.bi_offer_id)"
                                        + " WHERE ts.bi_primary_puid = {1} AND ts.bi_offer_id = 0x{2} AND ts.i_subscription_status_id > 1", endDate, puid, offerId.ToString("X"));

            Global.RO.Info("Executing sql: " + sql);
            ExecuteSQLNonQuery(sql, puid);
        }

        /// <summary>
        /// Sets the Message flag for expiring billing notification of a user 
        /// </summary>
        /// <param name="userPuid">user's puid</param>
        /// <param name="uid_tracking_guid">tracking guid</param>   
        /// <param name="messageFlag">Message flag</param> 
        public static void UpdateMessageFlagForNotification(ulong puid, Guid uid_tracking_guid, int messageFlag)
        {

            string sql = string.Format("UPDATE t_user_billing_notifications SET ti_message_flags = '{2}' WHERE bi_user_puid = {0} and uid_tracking_guid ='{1}'",
                         puid, uid_tracking_guid, messageFlag);
            ExecuteSQLNonQuery(sql, puid);

        }

        /// <summary>
        /// Sets a user in the UODB as being enabled, suspended (expired), or canceled (deprovisioned) without the SPS hit.
        /// </summary>
        /// <param name="userPuid">user's puid</param>
        /// <param name="_newStatus">new status</param>
        /// <returns>true if set was successful</returns>
        public static bool SetUserSubscriptionStatus(ulong _puid, SubscriptionStatus _newstatus)
        {
            if (_puid == 0)
                throw new ApplicationException("Can't find user " + _puid);

            int FieldsAffected = 0;
            string sql = null;

            if (_newstatus != SubscriptionStatus.Queued)
            {
                sql = "UPDATE t_users SET i_billing_account_status=" + (_newstatus == SubscriptionStatus.Enabled ? "0" : "0x8151200") + " WHERE (bi_user_puid = " + _puid + ")";
                FieldsAffected = ExecuteSQLNonQuery(sql, _puid);
                if (FieldsAffected < 1)
                    return false;

                sql = "UPDATE t_subscriptions SET i_subscription_status_id=" + ((uint)_newstatus).ToString() + " WHERE (bi_primary_puid = " + _puid + ")";
                FieldsAffected = ExecuteSQLNonQuery(sql, _puid);
                return (FieldsAffected > 0);
            }

            // Special work to "queue" a user
            string s = _puid.ToString("X16");
            s = s.Substring(8, 8);

            sql = "UPDATE t_users SET vc_billing_account_id='$XBOX!U" + s + "', vc_billing_payinfo_id='$XBOX!U" + s + "' WHERE (bi_user_puid = " + _puid + ")";
            FieldsAffected = ExecuteSQLNonQuery(sql, _puid);
            if (FieldsAffected != 1)
                return false;

            sql = "UPDATE t_subscriptions SET vc_svc_instance_id='' WHERE (bi_primary_puid = " + _puid + ")";
            FieldsAffected = ExecuteSQLNonQuery(sql, _puid);
            return (FieldsAffected > 0);
        }



        /// <summary>
        /// Sets a user in the UODB as being enabled, suspended (expired), or canceled (deprovisioned) without the SPS hit.
        /// </summary>
        /// <param name="userPuid">user's puid</param>
        /// <param name="_offerId">offer Guid</param>
        /// <param name="_newStatus">new status</param>
        /// <returns>true if set was successful</returns>
        public static bool SetUserSubscriptionStatus(ulong _puid, ulong _offerId, SubscriptionStatus _newstatus)
        {
            if (_puid == 0)
                throw new ApplicationException("Can't find user " + _puid);

            int FieldsAffected = 0;
            string sql = null;

            if (_newstatus != SubscriptionStatus.Queued)
            {
                sql = "UPDATE t_users SET i_billing_account_status=" + (_newstatus == SubscriptionStatus.Enabled ? "0" : "0x8151200") + " WHERE (bi_user_puid = " + _puid +")";
                FieldsAffected = ExecuteSQLNonQuery(sql, _puid);
                if (FieldsAffected < 1)
                    return false;

                sql = "UPDATE t_subscriptions SET i_subscription_status_id=" + ((uint)_newstatus).ToString() + " WHERE (bi_primary_puid = " + _puid +
                        " and bi_offer_id = " + (long)_offerId + ")";
                FieldsAffected = ExecuteSQLNonQuery(sql, _puid);
                return (FieldsAffected > 0);
            }

            // Special work to "queue" a user
            string s = _puid.ToString("X16");
            s = s.Substring(8, 8);

            sql = "UPDATE t_users SET vc_billing_account_id='$XBOX!U" + s + "', vc_billing_payinfo_id='$XBOX!U" + s + "' WHERE (bi_user_puid = " + _puid + ")";
            FieldsAffected = ExecuteSQLNonQuery(sql, _puid);
            if (FieldsAffected != 1)
                return false;

            sql = "UPDATE t_subscriptions SET vc_svc_instance_id='' WHERE (bi_primary_puid = " + _puid + ")";
            FieldsAffected = ExecuteSQLNonQuery(sql, _puid);
            return (FieldsAffected > 0);
        }



        /// <summary>
        /// Returns information about a queued user
        /// </summary>
        /// <param name="_puid">User puid</param>
        /// <param name="user">[out] QueuedUserInfo object containing the user data</param>
        /// <returns></returns>
        public static bool GetQueuedUserInfo(ulong _puid, out QueuedUserInfo user)
        {
            bool bRet = false;
            user = new QueuedUserInfo();
            string sql = "SELECT bi_owner_puid, bi_base_offer_id, vc_billing_offer_id, vc_guid, vc_purchase_guid, si_queue_status, dt_change_datetime, vc_account_info" +
                    " FROM dbo.t_user_billing_queue WHERE bi_user_puid = " + _puid;

            using (WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITETHENREAD_COMMANDTYPE))
            {
                ws.PartitionType = WstPartitionType.Logical;
                ws.SetHashVal(_puid);
                ws.CommandSql = sql;

                using (WstDataReader myDataReader = ws.Execute())
                {
                    if (myDataReader.Read())
                    {
                        user.puid = _puid;
                        user.ownerPuid = (ulong)myDataReader.GetInt64(0);
                        user.baseOfferId = (ulong)myDataReader.GetInt64(1);
                        user.billingOfferId = (string)myDataReader.GetString(2);
                        user.guid = (string)myDataReader.GetString(3);
                        user.purchaseGuid = (string)myDataReader.GetString(4);
                        user.status = (int)(myDataReader.GetInt16(5));
                        user.changeDateTime = ((DateTime)myDataReader.GetDateTime(6));
                        user.accountInfo = myDataReader.GetString(7);
                        user.server = ws.Command.Database.Server.Name;

                        bRet = true;
                    }

                    myDataReader.Close();
                    return bRet;
                }
            }
        }

        /// <summary>
        /// Returns ReservationInfo (machine puid, expiration date) for a user
        /// </summary>
        /// <param name="gamerTag">The gamerTag that was reserved</param>
        /// <param name="RI">ReservationInfo object that gets filled</param>
        /// <returns>True if it find this user</returns>
        public static bool GetReservationInfo(string gamerTag, out ReservationInfo RI)
        {
            RI = null;
            bool ret = false;
            string sql = "SELECT bi_user_puid, dt_expires FROM dbo.t_user_names WHERE vc_gamertag = '" + gamerTag + "'";

            using (WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITETHENREAD_COMMANDTYPE))
            {
                ws.PartitionType = WstPartitionType.Logical;
                ws.SetHashVal(gamerTag);
                ws.CommandSql = sql;

                using (WstDataReader myDataReader = ws.Execute())
                {
                    if (myDataReader.Read())
                    {
                        RI = new ReservationInfo();
                        RI.puid = (ulong)myDataReader.GetInt64(0);
                        RI.reservationExpires = myDataReader.GetDateTime(1);
                        ret = true;
                        myDataReader.NextResult();
                    }
                    myDataReader.Close();

                    return ret;
                }
            }
        }

        /// <summary>
        /// Sets ReservationInfo (machine puid, expiration date) for a user
        /// </summary>
        /// <param name="gamerTag">The gamerTag that was reserved</param>
        /// <param name="RI">ReservationInfo object that gets entered into the UODB</param>
        /// <returns>True if it succeeds</returns>
        public static bool SetReservationInfo(string gamerTag, ReservationInfo RI)
        {
            string sql = "UPDATE t_user_names " +
                    "SET dt_expires = '" + RI.reservationExpires + "', " +
                    "bi_user_puid = " + RI.puid + " " +
                    "WHERE vc_gamertag = '" + gamerTag + "'";

            using (WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITEONLY_COMMANDTYPE))
            {
                ws.PartitionType = WstPartitionType.Logical;
                ws.SetHashVal(gamerTag);
                ws.CommandSql = sql;

                return (ws.ExecuteNonQuery() == 1);
            }
        }


        // this function populates OUID list from the t_user_names table instead of t_users table.
        /// <summary>
        /// Populates a puid cache with puids from t_user_names table.
        /// </summary>
        /// <param name="prefix"> Gamer tag prefix</param>
        /// <param name="pList"> Puid list</param>
        /// <returns></returns>
        public static void PopulatePuidListFromNames(string prefix, ref CPUIDList pList)
        {
            string sql = "SELECT bi_user_puid, vc_gamertag FROM dbo.t_user_names WHERE vc_gamertag LIKE '" + prefix + "%'";

            using (WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITETHENREAD_COMMANDTYPE))
            {
                for (int p = 0; p < ws.PhysicalPartitions; p++)
                {
                    ws.ClearParameters();
                    ws.PhysicalPartition = p;
                    ws.CommandSql = sql;

                    using (WstDataReader myDataReader = ws.Execute())
                    {
                        if (myDataReader.Read())
                        {
                            ulong puid;
                            System.Data.SqlTypes.SqlInt64 sqlPuid = myDataReader.GetSqlInt64(0);
                            string gamerTag = myDataReader.GetString(1);
                            puid = (ulong)sqlPuid.Value;
                            pList.Add(puid, gamerTag);
                        }

                        myDataReader.Close();
                    }
                }
            }
        }

        /// <summary>
        /// Populates a puid cache with puids from the database
        /// </summary>
        public static void PopulatePuidList(string prefix, ref CPUIDList pList)
        {
            string sql = "SELECT bi_user_puid, vc_gamertag FROM dbo.t_users WHERE vc_gamertag LIKE '" + prefix + "%'";

            using (WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITETHENREAD_COMMANDTYPE))
            {
                for (int p = 0; p < ws.PhysicalPartitions; p++)
                {
                    ws.ClearParameters();
                    ws.PhysicalPartition = p;
                    ws.CommandSql = sql;

                    using (WstDataReader myDataReader = ws.Execute())
                    {
                        if (myDataReader.Read())
                        {
                            ulong puid;
                            System.Data.SqlTypes.SqlInt64 sqlPuid = myDataReader.GetSqlInt64(0);
                            string gamerTag = myDataReader.GetString(1);
                            puid = (ulong)sqlPuid.Value;
                            pList.Add(puid, gamerTag);
                        }

                        myDataReader.Close();
                    }
                }
            }
        }


        public static SubscriptionInfo GetUserServiceID(ulong puid, string serviceInstanceId)
        {
            SubscriptionInfo[] si = GetUserServiceIDs(puid);
            foreach (SubscriptionInfo sInfo in si)
            {
                if (sInfo.serviceInstanceId == serviceInstanceId)
                    return sInfo;
            }
            return null;
        }

        public static SubscriptionInfo[] GetUserServiceIDs(ulong upuid)
        {
            SubscriptionInfo[] subList = null;
            ArrayList subInfo = new ArrayList();
            string sql = "SELECT bi_primary_puid, bi_offer_id, " +
                    "vc_svc_instance_id, i_puid_is_machine, " +
                    "i_subscription_status_id, i_transaction_flags, " +
                    "dt_Change_datetime FROM t_subscriptions " +
                    "WHERE bi_primary_puid = " + upuid;

            using (WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITETHENREAD_COMMANDTYPE))
            {
                ws.PartitionType = WstPartitionType.Logical;
                ws.SetHashVal(upuid);
                ws.CommandSql = sql;

                using (WstDataReader myDataReader = ws.Execute())
                {
                    while (myDataReader.Read())
                    {
                        SubscriptionInfo sInfo = new SubscriptionInfo();
                        sInfo.userPuid = (ulong)myDataReader.GetSqlInt64(0).Value;
                        sInfo.offerId = (long)myDataReader.GetSqlInt64(1);
                        sInfo.serviceInstanceId = (string)myDataReader.GetSqlString(2);
                        sInfo.isMPuid = (int)myDataReader.GetSqlInt32(3);
                        sInfo.statusId = (int)myDataReader.GetSqlInt32(4);
                        sInfo.transactionFlag = (int)myDataReader.GetSqlInt32(5);
                        sInfo.changeTime = (DateTime)myDataReader.GetSqlDateTime(6);
                        sInfo.server = ws.Command.Database.Server.Name;
                        subInfo.Add(sInfo);
                    }

                    myDataReader.Close();

                    subList = (SubscriptionInfo[])subInfo.ToArray(typeof(SubscriptionInfo));
                    return subList;
                }
            }
        }

        public static SubscriptionInfo[] GetUserServiceIDs(ulong xuid, long offerId)
        {
            SubscriptionInfo[] subList = null;
            ArrayList subInfo = new ArrayList();
            string sql = "SELECT bi_primary_puid, bi_offer_id, " +
                    "vc_svc_instance_id, i_puid_is_machine, " +
                    "i_subscription_status_id, i_transaction_flags, " +
                    "dt_Change_datetime, dt_start_date, dt_end_date FROM t_subscriptions " +
                    "WHERE bi_primary_puid = " + xuid + " AND bi_offer_id = " + offerId + " order by dt_start_date";

            using (WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITETHENREAD_COMMANDTYPE))
            {
                ws.PartitionType = WstPartitionType.Logical;
                ws.SetHashVal(xuid);
                ws.CommandSql = sql;

                using (WstDataReader myDataReader = ws.Execute())
                {
                    while (myDataReader.Read())
                    {
                        SubscriptionInfo sInfo = new SubscriptionInfo();
                        sInfo.userPuid = (ulong)myDataReader.GetSqlInt64(0).Value;
                        sInfo.offerId = (long)myDataReader.GetSqlInt64(1);
                        sInfo.serviceInstanceId = (string)myDataReader.GetSqlString(2);
                        sInfo.isMPuid = (int)myDataReader.GetSqlInt32(3);
                        sInfo.statusId = (int)myDataReader.GetSqlInt32(4);
                        sInfo.transactionFlag = (int)myDataReader.GetSqlInt32(5);
                        sInfo.changeTime = (DateTime)myDataReader.GetSqlDateTime(6);
                        sInfo.startDate = (DateTime)myDataReader.GetSqlDateTime(7);
                        sInfo.endDate = (DateTime)myDataReader.GetSqlDateTime(8);
                        sInfo.server = ws.Command.Database.Server.Name;
                        subInfo.Add(sInfo);
                    }

                    myDataReader.Close();

                    subList = (SubscriptionInfo[])subInfo.ToArray(typeof(SubscriptionInfo));
                    return subList;
                }
            }
        }


        public static SubscriptionHistoryInfo[] GetSubscriptionHistory(ulong upuid)
        {
            SubscriptionHistoryInfo[] subList = null;
            ArrayList subInfo = new ArrayList();
            string sql = "SELECT bi_user_puid, bi_offer_id, " +
                    "dt_start_date, dt_end_date, i_subscription_status_id, " +
                    "dt_Change_datetime, uid_catalog_offerinstance_id,  uid_catalog_offer_id FROM t_subscription_history " +
                    "WHERE bi_user_puid = " + upuid + " order by  dt_start_date" ;

            using (WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITETHENREAD_COMMANDTYPE))
            {
                ws.PartitionType = WstPartitionType.Logical;
                ws.SetHashVal(upuid);
                ws.CommandSql = sql;

                using (WstDataReader myDataReader = ws.Execute())
                {
                    while (myDataReader.Read())
                    {
                        SubscriptionHistoryInfo sInfo = new SubscriptionHistoryInfo();
                        sInfo.userPuid = (ulong)myDataReader.GetSqlInt64(0).Value;
                        sInfo.offerId = (long)myDataReader.GetSqlInt64(1);
                        sInfo.startDate = (DateTime)myDataReader.GetSqlDateTime(2);
                        sInfo.endDate = (DateTime)myDataReader.GetSqlDateTime(3);
                        sInfo.statusId = (int)myDataReader.GetSqlInt32(4);
                        sInfo.changeTime = (DateTime)myDataReader.GetSqlDateTime(5);
                        sInfo.catalogOfferInstanceId = (Guid)myDataReader.GetGuid(6);
                        sInfo.catalogOfferId = (Guid)myDataReader.GetGuid(7);
                        sInfo.server = ws.Command.Database.Server.Name;
                        subInfo.Add(sInfo);
                    }

                    myDataReader.Close();

                    subList = (SubscriptionHistoryInfo[])subInfo.ToArray(typeof(SubscriptionHistoryInfo));
                    return subList;
                }
            }
        }

        /// <summary>
        /// Get the active subscription service instance id, but in this case get only the
        /// one whose offerId matches the one given.
        /// Get the subscription id for the given user and the given offerid.  This particular
        /// call, unlike the others, does not care if the subscription is active, expired,
        /// cancelled, etc.
        /// </summary>
        /// <param name="userPuid">User puid</param>
        /// <param name="offerId">Offer Id</param>
        /// <returns>Subscription service instance id</returns>
        public static string GetUsersAndOffersSubscriptionInstanceId(ulong userPuid, ulong offerId)
        {
            string retval = "";
            string sql = "select vc_svc_instance_id from t_subscriptions where bi_primary_puid = 0x" + userPuid.ToString("X") +
                " and dt_start_date <= getutcdate() and dt_end_date > getutcdate() and bi_offer_id = 0x" + offerId.ToString("X") +
                " and i_subscription_status_id = 1";
            Global.RO.Info("Executing sql: " + sql);

            using (WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITETHENREAD_COMMANDTYPE))
            {
                ws.PartitionType = WstPartitionType.Logical;
                ws.SetHashVal(userPuid);
                ws.CommandSql = sql;

                object ret = ws.ExecuteScalar();
                if (ret != null)
                {
                    retval = (string)ret;
                }

                return retval;
            }
        }

        /// <summary>
        /// Get the active subscription service instance id.
        /// </summary>
        /// <param name="userPuid">User puid</param>
        /// <returns>Subscription service instance id</returns>
        public static string GetUsersSubscriptionInstanceId(ulong userPuid)
        {
            string retval = "";
            string sql = "select vc_svc_instance_id from t_subscriptions where bi_primary_puid = 0x" + userPuid.ToString("X") +
                " and dt_start_date <= getutcdate() and dt_end_date > getutcdate() and i_subscription_status_id = 1";
            Global.RO.Info("Executing sql: " + sql);

            using (WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITETHENREAD_COMMANDTYPE))
            {
                ws.PartitionType = WstPartitionType.Logical;
                ws.SetHashVal(userPuid);
                ws.CommandSql = sql;

                object ret = ws.ExecuteScalar();
                if (ret != null)
                {
                    retval = (string)ret;
                }

                return retval;
            }
        }

        /// <summary>
        /// Get the active subscription service instance id.
        /// </summary>
        /// <param name="userPuid">User puid</param>
        /// <param name="offerId">Offer Id</param>
        /// <returns>Subscription service instance id</returns>
        public static string GetUsersSubscriptionInstanceId(ulong userPuid, ulong offerId)
        {
            string retval = "";
            string sql = "select vc_svc_instance_id from t_subscriptions where bi_primary_puid = @bi_user_puid and bi_offer_id = @bi_offer_id" +
                " and dt_start_date <= getutcdate() and dt_end_date > getutcdate() and i_subscription_status_id = 1";
            Global.RO.Info("Executing sql: " + sql);

            using (WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITETHENREAD_COMMANDTYPE))
            {
                ws.PartitionType = WstPartitionType.Logical;
                ws.SetHashVal(userPuid);
                ws.CommandSql = sql;

                ws.AddParameter("@bi_user_puid", userPuid);
                ws.AddParameter("@bi_offer_id", offerId);

                object ret = ws.ExecuteScalar();
                if (ret != null)
                {
                    retval = (string)ret;
                }

                return retval;
            }
        }


        /// <summary>
        /// Get the active subscription offer id.
        /// </summary>
        /// <param name="userPuid">User puid</param>
        /// <returns>Subscription offer id</returns>
        public static ulong GetUsersSubscriptionOfferId(ulong userPuid)
        {
            ulong retval = 0;
            string sql = "select bi_offer_id from t_subscriptions where bi_primary_puid = 0x" + userPuid.ToString("X") +
                " and dt_start_date <= getutcdate() and dt_end_date > getutcdate() and i_subscription_status_id = 1";
            Global.RO.Info("Executing sql: " + sql);

            using (WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITETHENREAD_COMMANDTYPE))
            {
                ws.PartitionType = WstPartitionType.Logical;
                ws.SetHashVal(userPuid);
                ws.CommandSql = sql;

                object ret = ws.ExecuteScalar();
                if (ret != null)
                {
                    retval = (ulong)((long)ret);
                }

                return retval;
            }
        }

        public static int AddSubscription(SubscriptionInfo sInfo)
        {
            string sql = "INSERT t_subscriptions " +
                "(bi_primary_puid, bi_offer_id, vc_svc_instance_id, i_puid_is_machine, dt_start_date, dt_end_date, i_subscription_status_id, i_transaction_flags, dt_Change_datetime) " +
                "VALUES (" + sInfo.userPuid +
                ", " + sInfo.offerId +
                ", '" + sInfo.serviceInstanceId +
                "', " + sInfo.isMPuid +
                ", '" + sInfo.startDate.ToString("yyyy-MM-dd") +
                "', '" + sInfo.endDate.ToString("yyyy-MM-dd") +
                "', " + sInfo.statusId +
                ", " + sInfo.transactionFlag +
                ", '" + sInfo.changeTime + "')";

            return ExecuteSQLNonQuery(sql, sInfo.userPuid); ;
        }

        public static int UpdateSubscriptionStatusAndTransaction(SubscriptionInfo sInfo)
        {
            string sql = "update t_subscriptions " +
                " set i_subscription_status_id=" + sInfo.statusId +
                ", i_transaction_flags=" + sInfo.transactionFlag +
                ", vc_svc_instance_id='" + sInfo.serviceInstanceId + "'" +
                " where bi_primary_puid=0x" + sInfo.userPuid.ToString("x") +
                " and bi_offer_id=0x" + sInfo.offerId.ToString("x");

            return ExecuteSQLNonQuery(sql, sInfo.userPuid); ;
        }

        public static void FindMinors(out ArrayList puids)
        {
            puids = new ArrayList();
            string sql = "SELECT bi_owner_puid FROM dbo.t_users " +
                "WHERE bi_user_puid != bi_owner_puid";

            using (WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITETHENREAD_COMMANDTYPE))
            {
                for (int p = 0; p < ws.PhysicalPartitions; p++)
                {
                    ws.ClearParameters();
                    ws.PhysicalPartition = p;
                    ws.CommandSql = sql;

                    using (WstDataReader myDataReader = ws.Execute())
                    {
                        if (myDataReader.Read())
                        {
                            puids.Add((ulong)myDataReader.GetInt64(0));
                            myDataReader.NextResult();
                        }

                        myDataReader.Close();
                    }
                }
            }
        }

        public static bool GetUserSubs(ulong puid, out UserSubInfo[] subs)
        {
            UserSubInfo currentBaseSub = null;
            return GetUserSubs(puid, out subs, out currentBaseSub);
        }

        public static bool GetUserSubs(ulong _puid, out UserSubInfo[] subInfoList, out UserSubInfo currentSub)
        {
            subInfoList = null;
            currentSub = null;
            ArrayList subList = new ArrayList();
            bool bRet = false;
            string sql = "select subs.bi_offer_id, i_instances, subs.dt_start_date, i_subscription_status_id, i_transaction_flags, vc_friendly_name, vc_svc_instance_id, subs.dt_end_date " +
                    "from t_subscriptions as subs inner join t_offers as offs " +
                    "on subs.bi_offer_id=offs.bi_offer_id " +
                    "where bi_primary_puid = " + _puid + " order by subs.dt_change_datetime asc";

            using (WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITETHENREAD_COMMANDTYPE))
            {
                ws.PartitionType = WstPartitionType.Logical;
                ws.SetHashVal(_puid);
                ws.CommandSql = sql;

                using (WstDataReader myDataReader = ws.Execute())
                {
                    while (myDataReader.Read())
                    {
                        UserSubInfo subInfo = new UserSubInfo();

                        subInfo.offerId = (ulong)myDataReader.GetInt64(0);
                        subInfo.instances = (int)myDataReader.GetInt32(1);
                        subInfo.startDate = (DateTime)myDataReader.GetDateTime(2);
                        subInfo.subStatus = (int)myDataReader.GetInt32(3);
                        int flags = (int)myDataReader.GetInt32(4);
                        subInfo.disablePending = (bool)((flags & 0x2) != 0);
                        subInfo.purchaseIncomplete = (bool)((flags & 0x4) != 0);
                        subInfo.provisionPending = (bool)((flags & 0x1) != 0);
                        subInfo.friendlyName = (string)myDataReader.GetString(5);
                        subInfo.serviceInstanceId = (string)myDataReader.GetString(6);
                        subInfo.endDate = (DateTime)myDataReader.GetDateTime(7);

                        subList.Add(subInfo);
                        bRet = true;
                    }

                    myDataReader.Close();

                    if (bRet)
                    {
                        subInfoList = (UserSubInfo[])subList.ToArray(typeof(UserSubInfo));

                        foreach (UserSubInfo subInfo in subInfoList)
                        {
                            if (subInfo.serviceInstanceId != null &&
                                subInfo.serviceInstanceId != "")
                            {
                                currentSub = subInfo;
                                break;
                            }
                        }
                    }

                    return bRet;
                }
            }
        }

        /// <summary>
        /// Return a list of all BOIDs that match the specified criteria
        /// Since BOIDs should be uniform across servers, we only verify the first server
        /// </summary>
        public static string[] GrabBOIDs(int country, uint policy, int offerType)
        {
            // Note that we do not take into account the fact that there might be less transactions
            // than what we asked for. The reason for this is that we typically only request 5 or 10
            // transactions, and by then there should be way more users anyway
            string sql = "SELECT vc_billing_offer_id from t_offer_regions as regs INNER JOIN t_offers AS o ON regs.bi_offer_id = o.bi_offer_id WHERE " +
                    "i_policy_flags=" + policy + " AND ti_country_id=" + country + " AND i_offer_type_id=" + offerType;
            ArrayList outAr = new ArrayList();

            using (WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITETHENREAD_COMMANDTYPE))
            {
                ws.PartitionType = WstPartitionType.Logical;
                ws.Partition = WstCommand.AnyPartition;
                ws.CommandSql = sql;

                using (WstDataReader r = ws.Execute())
                {
                    if (r.Read())
                    {
                        outAr.Add((string)r.GetString(0));
                        r.NextResult();
                    }

                    r.Close();

                    return (string[])outAr.ToArray(typeof(System.String));
                }
            }
        }

        /// <summary>
        /// Retrieves title information from several tables in UODB for the specified title.
        /// </summary>
        /// <param name="titleId">Title ID</param>
        /// <returns>
        /// A TitleInformation class that contains information about the title.
        /// If there is no title information for this title, null is returned.
        /// </returns>
        /// <remarks>
        /// This method pulls data directly from the t_titles and t_title_feature_data tables.
        /// It then calls the following methods to finish populating the fields:
        ///     GetAllTitleVersions
        ///     GetTitleRatings
        ///     GetTitleGenres
        ///     GetTitleCultureDetails
        ///     GetAlternateTitleIds
        ///     GetTitleTrustConstants
        /// </remarks>
        public static TitleInformation GetTitleInformation(uint titleId)
        {
            TitleInformation ti = null;
            string sql = "SELECT tt.*, tfd.* FROM t_titles as tt INNER JOIN t_title_feature_data as tfd ON tt.i_title_id=tfd.i_titleid WHERE tt.i_title_id=0x" + titleId.ToString("x8");

            using (WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITETHENREAD_COMMANDTYPE))
            {
                ws.PartitionType = WstPartitionType.Logical;
                ws.Partition = WstCommand.AnyPartition;
                ws.CommandSql = sql;

                using (WstDataReader reader = ws.Execute())
                {
                    while (reader.Read())
                    {
                        int index = 0;

                        ti = new TitleInformation("UODB");
                        ti.TitleId = (uint)reader.GetInt32(index++);
                        ti.ConsoleTypeId = reader.GetByte(index++);
                        ti.LastModified = reader.GetDateTime(index++);
                        index = reader.GetOrdinal("vc_Name");
                        ti.Name = reader.GetString(index++);
                        ti.Camera = reader.GetBoolean(index++);
                        ti.CoOp = reader.GetBoolean(index++);
                        ti.CustomSoundtrack = reader.GetBoolean(index++);
                        ti.Dolby51 = reader.GetBoolean(index++);
                        ti.HardDriveEnhanced = reader.GetBoolean(index++);
                        ti.HardDriveRequired = reader.GetBoolean(index++);
                        ti.LiveAware = reader.GetBoolean(index++);
                        ti.LiveClans = reader.GetBoolean(index++);
                        ti.LiveCoOp = reader.GetBoolean(index++);
                        ti.LiveDownloads = reader.GetBoolean(index++);
                        ti.LiveFriends = reader.GetBoolean(index++);
                        ti.LiveMessaging = reader.GetBoolean(index++);
                        ti.LiveMultiplayer = reader.GetBoolean(index++);
                        ti.LiveScoreboard = reader.GetBoolean(index++);
                        ti.LiveServiceProxy = reader.GetBoolean(index++);
                        ti.LiveStats = reader.GetBoolean(index++);
                        ti.LiveTournaments = reader.GetBoolean(index++);
                        ti.LiveVoice = reader.GetBoolean(index++);
                        ti.LiveVoiceMessaging = reader.GetBoolean(index++);
                        ti.MemoryUnit = reader.GetBoolean(index++);
                        ti.MultiplayerVersus = reader.GetBoolean(index++);
                        ti.Peripherals = reader.GetBoolean(index++);
                        ti.PlayersOffline = reader.GetInt32(index++);
                        ti.PlayersSystemLink = reader.GetInt32(index++);
                        ti.PlayersLive = reader.GetInt32(index++);
                        ti.PremiumOffers = reader.GetBoolean(index++);
                        ti.SystemLink = reader.GetBoolean(index++);
                        ti.UserCreatableContent = reader.GetBoolean(index++);
                        ti.XboxSupport = reader.GetBoolean(index++);
                        ti.Xbox2Support = reader.GetBoolean(index++);
                    }
                    reader.Close();
                }

                // Query the t_xprof_bounty_exempt_titles table to determine if this title is bounty exempt
                sql = "SELECT i_title_id FROM t_xprof_bounty_exempt_titles WHERE i_title_id=0x" + titleId.ToString("x8");
                ws.PartitionType = WstPartitionType.Logical;
                ws.Partition = WstCommand.AnyPartition;
                ws.CommandSql = sql;

                ti.BountyExempt = false;
                if (ws.ExecuteScalar() != null)
                    ti.BountyExempt = true;

                // Query the t_title_privileges table to determine if the cross-platform privilege is set
                sql = "SELECT ti_privilege_id FROM t_title_privileges WHERE i_title_id=0x" + titleId.ToString("X8") + " AND ti_privilege_id=241";
                ws.PartitionType = WstPartitionType.Logical;
                ws.Partition = WstCommand.AnyPartition;
                ws.CommandSql = sql;

                ti.CrossPlatform = (ws.ExecuteScalar() != null);
            }

            // Don't bother continuing if there is no title information
            if (ti != null)
            {
                ti.TitleVersions = (TitleVersions)(GetAllTitleVersions(titleId)[0]);
                ti.TitleRatings = GetTitleRatings(titleId);
                ti.TitleGenres = GetTitleGenres(titleId);
                ti.TitleCultureDetails = GetTitleCultureDetails(titleId);
                ti.AlternateTitleId = GetAlternateTitleIds(titleId);
                GetTitleTrustConstants(titleId, out ti.TrustConstants);
            }

            return ti;
        }

        /// <summary>
        /// Check if title/privilege/tier exists in t_title_privileges.
        /// </summary>
        /// <param name="titleId">Title ID</param>
        /// <param name="privilegeId">Privilege ID</param>
        /// <param name="tierId">Tier ID</param>
        /// <returns>
        /// True if a specific privilge exists.
        /// </returns>
        public static bool DoesTitlePrivilegeExist(uint titleId, int privilegeId, int tierId)
        {
            using (WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITETHENREAD_COMMANDTYPE))
            {
                // Query the t_title_privileges table to determine if specific privilege is set
                string sql = String.Format("SELECT ti_privilege_id FROM t_title_privileges WHERE i_title_id={0} AND ti_privilege_id={1} AND i_tier_id={2}", (int)titleId, privilegeId, tierId );
                ws.PartitionType = WstPartitionType.Logical;
                ws.Partition = WstCommand.AnyPartition;
                ws.CommandSql = sql;

                return (ws.ExecuteScalar() != null);
            }
        }


        /// <summary>
        /// Retrieves title version information for the specified title.
        /// </summary>
        /// <param name="titleId">Title ID</param>
        /// <returns>
        /// A collection of TitleVersion objects that represent the version chains for this title.
        /// </returns>
        public static ArrayList GetAllTitleVersions(uint titleId)
        {
            ArrayList version_lists = new ArrayList();
            string sql = "SELECT * FROM t_title_versions WHERE i_title_id=0x" + titleId.ToString("x8");

            using (WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITETHENREAD_COMMANDTYPE))
            {
                for (int p = 0; p < ws.PhysicalPartitions; p++)
                {
                    ws.ClearParameters();
                    ws.PhysicalPartition = p;
                    ws.CommandSql = sql;

                    using (WstDataReader reader = ws.Execute())
                    {
                        if (reader.HasRows)
                        {
                            int titleidOrdinal = reader.GetOrdinal("i_title_id");
                            int baseVersionOrdinal = reader.GetOrdinal("i_base_version");
                            int updateVersionOrdinal = reader.GetOrdinal("i_update_version");
                            int betaVersionOrdinal = reader.GetOrdinal("i_beta_version");
                            int changedOrdinal = reader.GetOrdinal("dt_Change_datetime");
                            int consoleTypeOrdinal = reader.GetOrdinal("ti_console_type_id");

                            TitleVersions versions = new TitleVersions();
                            while (reader.Read())
                            {
                                TitleVersion version = new TitleVersion();
                                version.TitleId = (uint)reader.GetInt32(titleidOrdinal);
                                version.BaseVersion = (uint)reader.GetInt32(baseVersionOrdinal);
                                version.UpdateVersion = (uint)reader.GetInt32(updateVersionOrdinal);
                                version.BetaVersion = (uint)reader.GetInt32(betaVersionOrdinal);
                                version.Changed = reader.GetDateTime(changedOrdinal);
                                version.ConsoleTypeId = reader.GetByte(consoleTypeOrdinal);
                                versions.Add(version);
                            }
                            version_lists.Add(versions);
                        }
                        reader.Close();
                    }
                }

                return version_lists;
            }
        }

        /// <summary>
        /// Retrieves title ratings for the specified title.
        /// </summary>
        /// <param name="titleId">Title ID</param>
        /// <returns>
        /// A collection of TitleRating objects that represent the ratings for this title.
        /// </returns>
        public static TitleRatings GetTitleRatings(uint titleId)
        {
            TitleRatings ratings = new TitleRatings();
            string sql = "SELECT * FROM t_title_ratings WHERE i_title_id=0x" + titleId.ToString("x8");

            using (WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITETHENREAD_COMMANDTYPE))
            {
                ws.PartitionType = WstPartitionType.Logical;
                ws.Partition = WstCommand.AnyPartition;
                ws.CommandSql = sql;

                using (WstDataReader reader = ws.Execute())
                {
                    if (reader.HasRows)
                    {
                        int titleidOrdinal = reader.GetOrdinal("i_title_id");
                        int ratingSystemOrdinal = reader.GetOrdinal("i_rating_system_id");
                        int ratingOrdinal = reader.GetOrdinal("i_rating_id");
                        int changedOrdinal = reader.GetOrdinal("dt_change_datetime");

                        while (reader.Read())
                        {
                            TitleRating rating = new TitleRating();
                            rating.TitleId = (uint)reader.GetInt32(titleidOrdinal);
                            rating.RatingSystemId = reader.GetInt32(ratingSystemOrdinal);
                            rating.RatingId = reader.GetInt32(ratingOrdinal);
                            rating.Changed = reader.GetDateTime(changedOrdinal);
                            ratings.Add(rating);
                        }
                    }

                    reader.Close();

                    return ratings;
                }
            }
        }

        /// <summary>
        /// Retrieves genre information for the specified title.
        /// </summary>
        /// <param name="titleId">Title ID</param>
        /// <returns>
        /// A collection of TitleGenre objects that represent the genres for this title.
        /// </returns>
        public static TitleGenres GetTitleGenres(uint titleId)
        {
            TitleGenres genres = new TitleGenres();
            string sql = "SELECT * FROM t_title_genres WHERE i_title_id=0x" + titleId.ToString("x8");

            using (WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITETHENREAD_COMMANDTYPE))
            {
                ws.PartitionType = WstPartitionType.Logical;
                ws.Partition = WstCommand.AnyPartition;
                ws.CommandSql = sql;

                using (WstDataReader reader = ws.Execute())
                {
                    if (reader.HasRows)
                    {
                        int titleidOrdinal = reader.GetOrdinal("i_title_id");
                        int genreOrdinal = reader.GetOrdinal("i_genre_id");
                        int changedOrdinal = reader.GetOrdinal("dt_change_datetime");

                        while (reader.Read())
                        {
                            TitleGenre genre = new TitleGenre();
                            genre.TitleId = (uint)reader.GetInt32(titleidOrdinal);
                            genre.GenreId = reader.GetInt32(genreOrdinal);
                            genre.Changed = reader.GetDateTime(changedOrdinal);
                            genres.Add(genre);
                        }
                    }
                    reader.Close();

                    return genres;
                }
            }
        }


        /// <summary>
        /// Retrieves the alternate title id data for the specified title.
        /// </summary>
        /// <param name="titleId">Title ID</param>
        /// <returns>
        /// An AlternateTitleId object that specified the alternate title id data for this title
        /// </returns>
        public static AlternateTitleId GetAlternateTitleIds(uint titleId)
        {
            AlternateTitleId altTitleId = null;
            string sql = "SELECT * FROM t_alternate_titleids WHERE i_title_id=0x" + titleId.ToString("x8");

            using (WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITETHENREAD_COMMANDTYPE))
            {
                ws.PartitionType = WstPartitionType.Logical;
                ws.Partition = WstCommand.AnyPartition;
                ws.CommandSql = sql;

                using (WstDataReader reader = ws.Execute())
                {
                    if (reader.Read())
                    {
                        int titleidOrdinal = reader.GetOrdinal("i_title_id");
                        int regionOrdinal = reader.GetOrdinal("i_title_region");
                        int mediaIdOrdinal = reader.GetOrdinal("i_media_id");
                        int liveTitleIdOrdinal = reader.GetOrdinal("i_live_title_id");
                        int altTitleIdOrdinal = reader.GetOrdinal("i_alternate_id1");
                        int serviceOrdinal = reader.GetOrdinal("i_service1");
                        int changedOrdinal = reader.GetOrdinal("dt_change_datetime");

                        altTitleId = new AlternateTitleId();
                        altTitleId.TitleId = (uint)reader.GetInt32(titleidOrdinal);
                        altTitleId.TitleRegion = reader.GetInt32(regionOrdinal);
                        altTitleId.MediaId = reader.GetInt32(mediaIdOrdinal);
                        altTitleId.LiveTitleId = reader.GetInt32(liveTitleIdOrdinal);
                        altTitleId.AlternateId1 = reader.GetInt32(altTitleIdOrdinal);
                        altTitleId.AlternateId2 = reader.GetInt32(altTitleIdOrdinal + 1);
                        altTitleId.AlternateId3 = reader.GetInt32(altTitleIdOrdinal + 2);
                        altTitleId.AlternateId4 = reader.GetInt32(altTitleIdOrdinal + 3);
                        altTitleId.Service1 = reader.GetInt32(serviceOrdinal);
                        altTitleId.Service1AltId = reader.GetInt32(serviceOrdinal + 1);
                        altTitleId.Service2 = reader.GetInt32(serviceOrdinal + 2);
                        altTitleId.Service2AltId = reader.GetInt32(serviceOrdinal + 3);
                        altTitleId.Service3 = reader.GetInt32(serviceOrdinal + 4);
                        altTitleId.Service3AltId = reader.GetInt32(serviceOrdinal + 5);
                        altTitleId.Service4 = reader.GetInt32(serviceOrdinal + 6);
                        altTitleId.Service4AltId = reader.GetInt32(serviceOrdinal + 7);
                        altTitleId.Changed = reader.GetDateTime(changedOrdinal);
                    }
                    reader.Close();

                    return altTitleId;
                }
            }
        }

        /// <summary>
        /// Deletes all title update information on a given titleid.
        /// Tables affected are t_title_versions, t_update_packages,
        /// and t_update_locations.
        /// Deletes all records of updates to a title.
        /// </summary>
        /// <param name="titleId">titleId to affect.</param>
        /// <param name="basever">base version to reset to.</param>
        public static void DeleteAllTitleUpdateInfo(uint titleId, uint baseVer)
        {
            string sql = "";

            using (WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITEONLY_COMMANDTYPE))
            {
                for (int p = 0; p < ws.PhysicalPartitions; p++)
                {
                    ws.ClearParameters();
                    //toast t_title_versions for this titleId
                    sql = "delete from t_title_versions WHERE i_title_id = 0x" + titleId.ToString("X8");
                    ws.PhysicalPartition = p;
                    ws.CommandSql = sql;
                    ws.ExecuteNonQuery();

                    //toast t_title_update_packages
                    sql = "delete from t_title_update_locations WHERE i_title_id = 0x" + titleId.ToString("X8");
                    ws.PhysicalPartition = p;
                    ws.CommandSql = sql;
                    ws.ExecuteNonQuery();

                    //toast t_title_update_packages
                    sql = "delete from t_title_update_packages WHERE i_title_id = 0x" + titleId.ToString("X8");
                    ws.PhysicalPartition = p;
                    ws.CommandSql = sql;
                    ws.ExecuteNonQuery();
                }
            }

            // Add the new base version (assume Xenon platform)
            AddTitleVersion(titleId, baseVer, true, ConsoleTypeEnum.Xenon);
        }

        /// <summary>
        /// Adds a version chain for a specified title.
        /// </summary>
        /// <param name="titleId">Title ID</param>
        /// <param name="version">The version to add</param>
        /// <param name="fullUpdate">Flag indicating whether this is a full update or a beta update.</param>
        /// <param name="consoleType">A ConsoleType value specifying which console this version targets.</param>
        public static void AddTitleVersion(uint titleId, uint version, bool fullUpdate, ConsoleTypeEnum consoleType)
        {
            using (WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITEONLY_COMMANDTYPE))
            {
                for (int p = 0; p < ws.PhysicalPartitions; p++)
                {
                    ws.ClearParameters();
                    ws.PhysicalPartition = p;
                    ws.StoredProc = "dbo.p_svc_insert_title_versions";

                    ws.AddParameter("@i_title_id", titleId);
                    ws.AddParameter("@i_base_version", version);
                    ws.AddParameter("@i_new_version", version);
                    ws.AddParameter("@i_version_flag", Convert.ToInt32(fullUpdate));
                    ws.AddParameter("@ti_console_type_id", (byte)consoleType);

                    ws.ExecuteNonQuery();
                }
            }
        }

        /// <summary>
        /// Retrieves the culture details for the specified title.
        /// </summary>
        /// <param name="titleId">Title ID</param>
        /// <returns>
        /// A collection of TitleCultureDetail objects that represent the culture details for this title.
        /// </returns>
        public static TitleCultureDetails GetTitleCultureDetails(uint titleId)
        {
            TitleCultureDetails cultureDetails = new TitleCultureDetails();
            string sql = "SELECT tcd.*,tc.vc_code FROM t_title_culture_details as tcd INNER JOIN t_cultures as tc ON tcd.i_culture_id = tc.i_culture_id WHERE tcd.i_title_id=0x" + titleId.ToString("x8");

            using (WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITETHENREAD_COMMANDTYPE))
            {
                ws.PartitionType = WstPartitionType.Logical;
                ws.Partition = WstCommand.AnyPartition;
                ws.CommandSql = sql;

                using (WstDataReader reader = ws.Execute())
                {
                    if (reader.HasRows)
                    {
                        int titleidOrdinal = reader.GetOrdinal("i_title_id");
                        int cultureIdOrdinal = reader.GetOrdinal("i_culture_id");
                        int nameOrdinal = reader.GetOrdinal("vc_name");
                        int sellTextOrdinal = reader.GetOrdinal("vc_sell_text");
                        int publisherOrdinal = reader.GetOrdinal("vc_publisher");
                        int developerOrdinal = reader.GetOrdinal("vc_developer");
                        int genreOrdinal = reader.GetOrdinal("vc_genre");
                        int localeOrdinal = reader.GetOrdinal("vc_code");
                        int changedOrdinal = reader.GetOrdinal("dt_change_datetime");

                        while (reader.Read())
                        {
                            TitleCultureDetail cultureDetail = new TitleCultureDetail();
                            cultureDetail.TitleId = (uint)reader.GetInt32(titleidOrdinal);
                            cultureDetail.CultureId = reader.GetInt32(cultureIdOrdinal);
                            cultureDetail.Name = reader.GetString(nameOrdinal);
                            cultureDetail.SellText = reader.GetString(sellTextOrdinal);
                            cultureDetail.Developer = reader.GetString(developerOrdinal);
                            cultureDetail.Publisher = reader.GetString(publisherOrdinal);
                            cultureDetail.Genre = reader.GetString(genreOrdinal);
                            cultureDetail.Changed = reader.GetDateTime(changedOrdinal);
                            cultureDetail.Locale = reader.GetString(localeOrdinal);
                            cultureDetails.Add(cultureDetail);
                        }
                    }
                    reader.Close();

                    return cultureDetails;
                }
            }
        }

        public static bool DoesTitleExist(uint titleId)
        {
            bool exist = false;
            string sql = "SELECT i_title_id FROM dbo.t_titles WHERE i_title_id = 0x" + titleId.ToString("x");

            using (WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITETHENREAD_COMMANDTYPE))
            {
                ws.PartitionType = WstPartitionType.Logical;
                ws.Partition = WstCommand.AnyPartition;
                ws.CommandSql = sql;

                if (ws.ExecuteScalar() != null)
                {
                    exist = true;
                }

                return exist;
            }
        }

        public static bool DoTitleTrustConstantsExist(uint titleId)
        {
            bool exist = false;
            string sql = "SELECT i_title_id FROM dbo.t_title_trust_constants WHERE i_title_id = 0x" + titleId.ToString("x");

            using (WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITETHENREAD_COMMANDTYPE))
            {
                ws.PartitionType = WstPartitionType.Logical;
                ws.Partition = WstCommand.AnyPartition;
                ws.CommandSql = sql;

                if (ws.ExecuteScalar() != null)
                {
                    exist = true;
                }

                return exist;
            }
        }

        /// <summary>
        /// Gets the title trust constants for a title ID
        /// </summary>
        /// <param name="titleId"></param>
        /// <param name="TTC"></param>
        /// <returns>true if the retrieval was sucessful, false if the title id does not exist in the table</returns>
        public static bool GetTitleTrustConstants(uint titleId, out TitleTrustConstants TTC)
        {
            bool ret = false;
            TTC = null;
            int index = 0;
            string sql = "SELECT i_title_id,f_R2,f_R3,f_R4,f_R5,f_R6,f_R7,f_R8,f_R9,f_BaseUserTrust,f_MinorityQuorum,f_UserCompetitionAmp,f_PublisherCompetitionAmp,i_Lambda,i_BaseSessionTime,i_TotalUsers,f_S1,f_S2,f_S3,f_S4,f_S5,f_S6,f_S7,f_S8,f_S9,f_W2,f_W3,f_W4,f_W5,f_W6,f_W7,f_W8,f_W9,f_K,bi_TotalSessions,bi_TotalSessionDisconnects,bi_TotalCompetitions,bi_TotalCompetitionNoShows,bi_SessionBase,bi_SessionXboxCount,bi_SessionSeconds,bi_SessionFreeForAll,ti_lower_bottom,ti_lower_mid,ti_lower_top,ti_mid_bottom,ti_mid_top,ti_upper_bottom,ti_upper_mid,ti_upper_top,dt_Change_datetime FROM dbo.t_title_trust_constants " + "WHERE i_title_id = 0x" + titleId.ToString("X8");

            using (WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITETHENREAD_COMMANDTYPE))
            {
                ws.PartitionType = WstPartitionType.Logical;
                ws.Partition = WstCommand.AnyPartition;
                ws.CommandSql = sql;

                using (WstDataReader myDataReader = ws.Execute())
                {
                    if (myDataReader.Read())
                    {
                        TTC = new TitleTrustConstants();
                        TTC.titleId = (uint)myDataReader.GetInt32(index++);
                        TTC.r2 = myDataReader.GetDouble(index++);
                        TTC.r3 = myDataReader.GetDouble(index++);
                        TTC.r4 = myDataReader.GetDouble(index++);
                        TTC.r5 = myDataReader.GetDouble(index++);
                        TTC.r6 = myDataReader.GetDouble(index++);
                        TTC.r7 = myDataReader.GetDouble(index++);
                        TTC.r8 = myDataReader.GetDouble(index++);
                        TTC.r9 = myDataReader.GetDouble(index++);
                        TTC.baseUserTrust = myDataReader.GetDouble(index++);
                        TTC.minorityQuorum = myDataReader.GetDouble(index++);
                        TTC.userCompetitionAmp = myDataReader.GetDouble(index++);
                        TTC.publisherCompetitionAmp = myDataReader.GetDouble(index++);
                        TTC.lambda = (uint)myDataReader.GetInt32(index++);
                        TTC.baseSessionTime = (uint)myDataReader.GetInt32(index++);
                        TTC.totalUsers = (uint)myDataReader.GetInt32(index++);
                        TTC.s1 = myDataReader.GetDouble(index++);
                        TTC.s2 = myDataReader.GetDouble(index++);
                        TTC.s3 = myDataReader.GetDouble(index++);
                        TTC.s4 = myDataReader.GetDouble(index++);
                        TTC.s5 = myDataReader.GetDouble(index++);
                        TTC.s6 = myDataReader.GetDouble(index++);
                        TTC.s7 = myDataReader.GetDouble(index++);
                        TTC.s8 = myDataReader.GetDouble(index++);
                        TTC.s9 = myDataReader.GetDouble(index++);
                        TTC.w2 = myDataReader.GetDouble(index++);
                        TTC.w3 = myDataReader.GetDouble(index++);
                        TTC.w4 = myDataReader.GetDouble(index++);
                        TTC.w5 = myDataReader.GetDouble(index++);
                        TTC.w6 = myDataReader.GetDouble(index++);
                        TTC.w7 = myDataReader.GetDouble(index++);
                        TTC.w8 = myDataReader.GetDouble(index++);
                        TTC.w9 = myDataReader.GetDouble(index++);
                        TTC.k = myDataReader.GetDouble(index++);
                        TTC.totalSessions = (ulong)myDataReader.GetInt64(index++);
                        TTC.totalSessionDisconnects = (ulong)myDataReader.GetInt64(index++);
                        TTC.totalCompetitions = (ulong)myDataReader.GetInt64(index++);
                        TTC.totalCompetitionNoShows = (ulong)myDataReader.GetInt64(index++);
                        TTC.sessionBase = (ulong)myDataReader.GetInt64(index++);
                        TTC.sessionXboxCount = (ulong)myDataReader.GetInt64(index++);
                        TTC.sessionSeconds = (ulong)myDataReader.GetInt64(index++);
                        TTC.sessionFreeForAll = (ulong)myDataReader.GetInt64(index++);
                        TTC.lowerBottom = myDataReader.GetByte(index++);
                        TTC.lowerMid = myDataReader.GetByte(index++);
                        TTC.lowerTop = myDataReader.GetByte(index++);
                        TTC.midBottom = myDataReader.GetByte(index++);
                        TTC.midTop = myDataReader.GetByte(index++);
                        TTC.upperBottom = myDataReader.GetByte(index++);
                        TTC.upperMid = myDataReader.GetByte(index++);
                        TTC.upperTop = myDataReader.GetByte(index++);
                        TTC.changeDatetime = myDataReader.GetDateTime(index++);
                        ret = true;
                    }

                    myDataReader.Close();
                    return ret;
                }
            }
        }

        /// <summary>
        /// Sets the title trust constants for a title ID.
        /// If the title exists it updates the values, otherwise, it creates it and populatest the values.
        /// </summary>
        /// <param name="TTC"></param>
        /// <returns>true if the operation was successful, false if the create or update failed</returns>
        public static bool SetTitleTrustConstants(TitleTrustConstants TTC)
        {
            string sql = "";
            int FieldsAffected = 0;
            bool ret = true;
            bool titleExist = DoesTitleExist(TTC.titleId);
            bool titleTrustExist = DoTitleTrustConstantsExist(TTC.titleId);

            using (WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITEONLY_COMMANDTYPE))
            {
                for (int p = 0; p < ws.PhysicalPartitions; p++)
                {
                    ws.ClearParameters();
                    //Does the title exist in t_titles?
                    if (!titleExist)
                    {
                        //No, then add this title ID to the UODB if not present
                        sql = "INSERT t_titles (i_title_id,dt_last_modified,dt_Change_datetime) " +
                            "VALUES (" +
                            "0x" + TTC.titleId.ToString("X8") + "," +
                            "'" + TTC.changeDatetime + "'," +
                            "'" + TTC.changeDatetime + "')";

                        ws.PhysicalPartition = p;
                        ws.CommandSql = sql;
                        FieldsAffected = ws.ExecuteNonQuery();
                        if (FieldsAffected != 1)
                            ret = false;
                        ws.ClearParameters();
                        //If this fails we will still try to update the other table
                    }

                    //Does the title exist in t_title_trust_constants?
                    if (!titleTrustExist)
                    {
                        //No, Insert it
                        sql = "INSERT t_title_trust_constants (i_title_id,f_R2,f_R3,f_R4,f_R5,f_R6,f_R7,f_R8,f_R9,f_BaseUserTrust,f_MinorityQuorum,f_UserCompetitionAmp,f_PublisherCompetitionAmp,i_Lambda,i_BaseSessionTime,i_TotalUsers,f_S1,f_S2,f_S3,f_S4,f_S5,f_S6,f_S7,f_S8,f_S9,f_W2,f_W3,f_W4,f_W5,f_W6,f_W7,f_W8,f_W9,f_K,bi_TotalSessions,bi_TotalSessionDisconnects,bi_TotalCompetitions,bi_TotalCompetitionNoShows,bi_SessionBase,bi_SessionXboxCount,bi_SessionSeconds,bi_SessionFreeForAll,ti_lower_bottom,ti_lower_mid,ti_lower_top,ti_mid_bottom,ti_mid_top,ti_upper_bottom,ti_upper_mid,ti_upper_top,dt_Change_datetime) " +
                            "VALUES (" +
                            "0x" + TTC.titleId.ToString("X8") + "," +
                            TTC.r2 + "," +
                            TTC.r3 + "," +
                            TTC.r4 + "," +
                            TTC.r5 + "," +
                            TTC.r6 + "," +
                            TTC.r7 + "," +
                            TTC.r8 + "," +
                            TTC.r9 + "," +
                            TTC.baseUserTrust + "," +
                            TTC.minorityQuorum + "," +
                            TTC.userCompetitionAmp + "," +
                            TTC.publisherCompetitionAmp + "," +
                            TTC.lambda + "," +
                            TTC.baseSessionTime + "," +
                            TTC.totalUsers + "," +
                            TTC.s1 + "," +
                            TTC.s2 + "," +
                            TTC.s3 + "," +
                            TTC.s4 + "," +
                            TTC.s5 + "," +
                            TTC.s6 + "," +
                            TTC.s7 + "," +
                            TTC.s8 + "," +
                            TTC.s9 + "," +
                            TTC.w2 + "," +
                            TTC.w3 + "," +
                            TTC.w4 + "," +
                            TTC.w5 + "," +
                            TTC.w6 + "," +
                            TTC.w7 + "," +
                            TTC.w8 + "," +
                            TTC.w9 + "," +
                            TTC.k + "," +
                            TTC.totalSessions + "," +
                            TTC.totalSessionDisconnects + "," +
                            TTC.totalCompetitions + "," +
                            TTC.totalCompetitionNoShows + "," +
                            TTC.sessionBase + "," +
                            TTC.sessionXboxCount + "," +
                            TTC.sessionSeconds + "," +
                            TTC.sessionFreeForAll + "," +
                            TTC.lowerBottom + "," +
                            TTC.lowerMid + "," +
                            TTC.lowerTop + "," +
                            TTC.midBottom + "," +
                            TTC.midTop + "," +
                            TTC.upperBottom + "," +
                            TTC.upperMid + "," +
                            TTC.upperTop + "," +
                            "'" + TTC.changeDatetime + "')";
                    }
                    else
                    {
                        //Yes, update it
                        sql = "UPDATE t_title_trust_constants " +
                            "SET f_R2=" + TTC.r2 + "," +
                            "f_R3=" + TTC.r3 + "," +
                            "f_R4=" + TTC.r4 + "," +
                            "f_R5=" + TTC.r5 + "," +
                            "f_R6=" + TTC.r6 + "," +
                            "f_R7=" + TTC.r7 + "," +
                            "f_R8=" + TTC.r8 + "," +
                            "f_R9=" + TTC.r9 + "," +
                            "f_BaseUserTrust=" + TTC.baseUserTrust + "," +
                            "f_MinorityQuorum=" + TTC.minorityQuorum + "," +
                            "f_UserCompetitionAmp=" + TTC.userCompetitionAmp + "," +
                            "f_PublisherCompetitionAmp=" + TTC.publisherCompetitionAmp + "," +
                            "i_Lambda=" + TTC.lambda + "," +
                            "i_BaseSessionTime=" + TTC.baseSessionTime + "," +
                            "i_TotalUsers=" + TTC.totalUsers + "," +
                            "f_S1=" + TTC.s1 + "," +
                            "f_S2=" + TTC.s2 + "," +
                            "f_S3=" + TTC.s3 + "," +
                            "f_S4=" + TTC.s4 + "," +
                            "f_S5=" + TTC.s5 + "," +
                            "f_S6=" + TTC.s6 + "," +
                            "f_S7=" + TTC.s7 + "," +
                            "f_S8=" + TTC.s8 + "," +
                            "f_S9=" + TTC.s9 + "," +
                            "f_W2=" + TTC.w2 + "," +
                            "f_W3=" + TTC.w3 + "," +
                            "f_W4=" + TTC.w4 + "," +
                            "f_W5=" + TTC.w5 + "," +
                            "f_W6=" + TTC.w6 + "," +
                            "f_W7=" + TTC.w7 + "," +
                            "f_W8=" + TTC.w8 + "," +
                            "f_W9=" + TTC.w9 + "," +
                            "f_K=" + TTC.k + "," +
                            "bi_TotalSessions=" + TTC.totalSessions + "," +
                            "bi_TotalSessionDisconnects=" + TTC.totalSessionDisconnects + "," +
                            "bi_TotalCompetitions=" + TTC.totalCompetitions + "," +
                            "bi_TotalCompetitionNoShows=" + TTC.totalCompetitionNoShows + "," +
                            "bi_SessionBase=" + TTC.sessionBase + "," +
                            "bi_SessionXboxCount=" + TTC.sessionXboxCount + "," +
                            "bi_SessionSeconds=" + TTC.sessionSeconds + "," +
                            "bi_SessionFreeForAll=" + TTC.sessionFreeForAll + "," +
                            "ti_lower_bottom=" + TTC.lowerBottom + "," +
                            "ti_lower_mid=" + TTC.lowerMid + "," +
                            "ti_lower_top=" + TTC.lowerTop + "," +
                            "ti_mid_bottom=" + TTC.midBottom + "," +
                            "ti_mid_top=" + TTC.midTop + "," +
                            "ti_upper_bottom=" + TTC.upperBottom + "," +
                            "ti_upper_mid=" + TTC.upperMid + "," +
                            "ti_upper_top=" + TTC.upperTop + "," +
                            "dt_Change_datetime='" + TTC.changeDatetime + "' " +
                            "WHERE i_title_id = 0x" + TTC.titleId.ToString("X8");
                    }
                    ws.PhysicalPartition = p;
                    ws.CommandSql = sql;
                    FieldsAffected = ws.ExecuteNonQuery();
                    if (FieldsAffected != 1)
                        ret = false;
                }

                return ret;
            }
        }

        /// <summary>
        /// Gets the user trust ratings for a title ID and Puid pair.
        /// </summary>
        /// <param name="puid"></param>
        /// <param name="titleId"></param>
        /// <param name="UTR"></param>
        /// <returns>true if retrieval was sucessful, false if record could not be found</returns>
        public static bool GetUserTrustRatings(ulong puid, uint titleId, out UserTrustRatings UTR)
        {
            bool ret = false;
            UTR = null;
            int index = 0;
            string sql = "SELECT  bi_user_puid,i_title_id,f_C1_SuccessfulSessionCount,f_C2_MinoritySessionCount,f_C3_FailedSessionCount,f_C4_ProblematicSessionCount,f_C5_UDPReportSessionCount,f_C6_DisconnectCount,f_C7_Type1SuspiciousCount,f_C8_Type2SuspiciousCount,f_C9_Type3SuspiciousCount,i_TotalSessions,i_TotalSessionDisconnects,i_TotalCompetitions,i_TotalCompetitionNoShows,i_SessionBase,i_SessionXboxCount,i_SessionSeconds,i_SessionFreeForAll,dt_Change_datetime FROM dbo.t_user_trust_ratings " + "WHERE i_title_id = 0x" + titleId.ToString("X8") + " AND bi_user_puid = 0x" + puid.ToString("X16");

            using (WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITETHENREAD_COMMANDTYPE))
            {
                ws.PartitionType = WstPartitionType.Logical;
                ws.SetHashVal(puid);
                ws.CommandSql = sql;

                using (WstDataReader myDataReader = ws.Execute())
                {
                    if (myDataReader.Read())
                    {
                        UTR = new UserTrustRatings();
                        UTR.puid = (ulong)myDataReader.GetInt64(index++);
                        UTR.titleId = (uint)myDataReader.GetInt32(index++);
                        UTR.c1_SuccessfulSessionCount = myDataReader.GetFloat(index++);
                        UTR.c2_MinoritySessionCount = myDataReader.GetFloat(index++);
                        UTR.c3_FailedSessionCount = myDataReader.GetFloat(index++);
                        UTR.c4_ProblematicSessionCount = myDataReader.GetFloat(index++);
                        UTR.c5_UDPReportCount = myDataReader.GetFloat(index++);
                        UTR.c6_DisconnectCount = myDataReader.GetFloat(index++);
                        UTR.c7_Type1SuspiciousCount = myDataReader.GetFloat(index++);
                        UTR.c8_Type2SuspiciousCount = myDataReader.GetFloat(index++);
                        UTR.c9_Type3SuspiciousCount = myDataReader.GetFloat(index++);
                        UTR.totalSessions = (uint)myDataReader.GetInt32(index++);
                        UTR.totalSessionDisconnects = (uint)myDataReader.GetInt32(index++);
                        UTR.totalCompetitions = (uint)myDataReader.GetInt32(index++);
                        UTR.totalCompetitionNoShows = (uint)myDataReader.GetInt32(index++);
                        UTR.sessionBase = (uint)myDataReader.GetInt32(index++);
                        UTR.sessionXboxCount = (uint)myDataReader.GetInt32(index++);
                        UTR.sessionSeconds = (uint)myDataReader.GetInt32(index++);
                        UTR.sessionFreeForAll = (uint)myDataReader.GetInt32(index++);
                        UTR.changeDatetime = myDataReader.GetDateTime(index++);
                        ret = true;
                    }
                    myDataReader.Close();

                    return ret;
                }
            }
        }

        /// <summary>
        /// Sets the user trust rating for a title ID and Puid pair.
        /// </summary>
        /// <param name="puid"></param>
        /// <param name="titleId"></param>
        /// <param name="UTR"></param>
        /// <returns></returns>
        public static bool SetUserTrustRatings(UserTrustRatings UTR)
        {
            int FieldsAffected = 0;
            string sql = "SELECT * FROM dbo.t_user_trust_ratings " + "WHERE i_title_id = 0x" + UTR.titleId.ToString("X8") + " AND bi_user_puid = 0x" + UTR.puid.ToString("X16");

            using (WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITEONLY_COMMANDTYPE))
            {
                ws.PartitionType = WstPartitionType.Logical;
                ws.SetHashVal(UTR.puid);
                ws.CommandSql = sql;

                object ret = ws.ExecuteScalar();
                //Does the user exist?
                if (ret == null)
                {
                    //No, Insert it
                    sql = "INSERT INTO t_user_trust_ratings (bi_user_puid,i_title_id,f_C1_SuccessfulSessionCount,f_C2_MinoritySessionCount,f_C3_FailedSessionCount,f_C4_ProblematicSessionCount,f_C5_UDPReportSessionCount,f_C6_DisconnectCount,f_C7_Type1SuspiciousCount,f_C8_Type2SuspiciousCount,f_C9_Type3SuspiciousCount,i_TotalSessions,i_TotalSessionDisconnects,i_TotalCompetitions,i_TotalCompetitionNoShows,i_SessionBase,i_SessionXboxCount,i_SessionSeconds,i_SessionFreeForAll,dt_Change_datetime) " +
                        "VALUES (" +
                        "0x" + UTR.puid.ToString("X16") + "," +
                        "0x" + UTR.titleId.ToString("X8") + "," +
                        (float)UTR.c1_SuccessfulSessionCount + "," +
                        (float)UTR.c2_MinoritySessionCount + "," +
                        (float)UTR.c3_FailedSessionCount + "," +
                        (float)UTR.c4_ProblematicSessionCount + "," +
                        (float)UTR.c5_UDPReportCount + "," +
                        (float)UTR.c6_DisconnectCount + "," +
                        (float)UTR.c7_Type1SuspiciousCount + "," +
                        (float)UTR.c8_Type2SuspiciousCount + "," +
                        (float)UTR.c9_Type3SuspiciousCount + "," +
                        (int)UTR.totalSessions + "," +
                        (int)UTR.totalSessionDisconnects + "," +
                        (int)UTR.totalCompetitions + "," +
                        (int)UTR.totalCompetitionNoShows + "," +
                        (int)UTR.sessionBase + "," +
                        (int)UTR.sessionXboxCount + "," +
                        (int)UTR.sessionSeconds + "," +
                        (int)UTR.sessionFreeForAll + "," +
                        "'" + UTR.changeDatetime + "')";
                }
                else
                {
                    //Yes, update it
                    sql = "UPDATE t_user_trust_ratings " +
                        "SET f_C1_SuccessfulSessionCount=" + (float)UTR.c1_SuccessfulSessionCount + "," +
                        "f_C2_MinoritySessionCount=" + (float)UTR.c2_MinoritySessionCount + "," +
                        "f_C3_FailedSessionCount=" + (float)UTR.c3_FailedSessionCount + "," +
                        "f_C4_ProblematicSessionCount=" + (float)UTR.c4_ProblematicSessionCount + "," +
                        "f_C5_UDPReportSessionCount=" + (float)UTR.c5_UDPReportCount + "," +
                        "f_C6_DisconnectCount=" + (float)UTR.c6_DisconnectCount + "," +
                        "f_C7_Type1SuspiciousCount=" + (float)UTR.c7_Type1SuspiciousCount + "," +
                        "f_C8_Type2SuspiciousCount=" + (float)UTR.c8_Type2SuspiciousCount + "," +
                        "f_C9_Type3SuspiciousCount=" + (float)UTR.c9_Type3SuspiciousCount + "," +
                        "i_TotalSessions=" + (int)UTR.totalSessions + "," +
                        "i_TotalSessionDisconnects=" + (int)UTR.totalSessionDisconnects + "," +
                        "i_TotalCompetitions=" + (int)UTR.totalCompetitions + "," +
                        "i_TotalCompetitionNoShows=" + (int)UTR.totalCompetitionNoShows + "," +
                        "i_SessionBase=" + (int)UTR.sessionBase + "," +
                        "i_SessionXboxCount=" + (int)UTR.sessionXboxCount + "," +
                        "i_SessionSeconds=" + (int)UTR.sessionSeconds + "," +
                        "i_SessionFreeForAll=" + (int)UTR.sessionFreeForAll + "," +
                        "dt_Change_datetime='" + UTR.changeDatetime + "' " +
                        "WHERE i_title_id = 0x" + UTR.titleId.ToString("X8") + " AND bi_user_puid = 0x" + UTR.puid.ToString("X16");
                }

                ws.ClearParameters();
                ws.PartitionType = WstPartitionType.Logical;
                ws.SetHashVal(UTR.puid);
                ws.CommandSql = sql;

                FieldsAffected = ws.ExecuteNonQuery();
                return (FieldsAffected == 1);
            }
        }

        /// <summary>
        /// Removes all user trust ratings for a given title from the database
        /// </summary>
        /// <param name="titleId"></param>
        public static void ClearUserTrustRatings(uint titleId)
        {
            ExecuteSQLNonQuery("DELETE " +
                        "FROM dbo.t_user_trust_ratings " +
                        "WHERE i_title_id = 0x" + titleId.ToString("X8"), null);
        }

        /// <summary>
        /// Get the SQL server UTC Date
        /// </summary>
        /// <returns></returns>
        public static DateTime GetUTCDate()
        {
            DateTime ret = DateTime.MinValue;
            string sql = "SELECT GETUTCDATE()";

            using (WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITETHENREAD_COMMANDTYPE))
            {
                ws.PartitionType = WstPartitionType.Logical;
                ws.Partition = WstCommand.AnyPartition;
                ws.CommandSql = sql;

                using (WstDataReader r = ws.Execute())
                {
                    if (r.Read())
                    {
                        ret = r.GetDateTime(0);
                    }
                    r.Close();

                    return ret;
                }
            }
        }

        /// <summary>
        /// Returns whether a specific offer exists.
        /// </summary>
        public static bool DoesOfferExist(ulong offerId)
        {
            bool exist = false;
            string sql = "SELECT bi_offer_id FROM dbo.t_offers WHERE bi_offer_id = 0x" + offerId.ToString("x");

            using (WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITETHENREAD_COMMANDTYPE))
            {
                ws.PartitionType = WstPartitionType.Logical;
                ws.Partition = WstCommand.AnyPartition;
                ws.CommandSql = sql;

                if (ws.ExecuteScalar() != null)
                {
                    exist = true;
                }

                return exist;
            }
        }

        /// <summary>
        /// Returns whether a specific privilege exists.
        /// </summary>
        public static bool DoesPrivilegeExist(byte privilegeId)
        {
            bool exist = false;
            string sql = "SELECT ti_privilege_id FROM dbo.t_privileges WHERE ti_privilege_id = 0x" + privilegeId.ToString("x");

            using (WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITETHENREAD_COMMANDTYPE))
            {
                ws.PartitionType = WstPartitionType.Logical;
                ws.Partition = WstCommand.AnyPartition;
                ws.CommandSql = sql;

                if (ws.ExecuteScalar() != null)
                {
                    exist = true;
                }

                return exist;
            }
        }

        /// <summary>
        /// Returns whether a specific privilege set exists.
        /// </summary>
        public static bool DoesPrivilegeSetExist(ushort privilegeSetId)
        {
            bool exist = false;
            string sql = "SELECT si_privilege_set_id FROM dbo.t_privilege_set WHERE si_privilege_set_id = 0x" + privilegeSetId.ToString("x");

            using (WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITETHENREAD_COMMANDTYPE))
            {
                ws.PartitionType = WstPartitionType.Logical;
                ws.Partition = WstCommand.AnyPartition;
                ws.CommandSql = sql;

                if (ws.ExecuteScalar() != null)
                {
                    exist = true;
                }

                return exist;
            }
        }

        /// <summary>
        /// Returns whether a specific service-privilege set exists.
        /// </summary>
        public static bool DoesServicePrivilegeSetExist(ushort servicePrivilegeSetId)
        {
            bool exist = false;
            string sql = "SELECT si_service_privilege_set_id FROM dbo.t_service_privilege_set WHERE si_service_privilege_set_id = 0x" + servicePrivilegeSetId.ToString("x");

            using (WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITETHENREAD_COMMANDTYPE))
            {
                ws.PartitionType = WstPartitionType.Logical;
                ws.Partition = WstCommand.AnyPartition;
                ws.CommandSql = sql;

                if (ws.ExecuteScalar() != null)
                {
                    exist = true;
                }

                return exist;
            }
        }

        /// <summary>
        /// Returns whether a specific service exists.
        /// </summary>
        public static bool DoesServiceExist(uint serviceId)
        {
            bool exist = false;
            string sql = "SELECT i_service_id FROM dbo.t_services WHERE i_service_id = 0x" + serviceId.ToString("x");

            using (WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITETHENREAD_COMMANDTYPE))
            {
                ws.PartitionType = WstPartitionType.Logical;
                ws.Partition = WstCommand.AnyPartition;
                ws.CommandSql = sql;

                if (ws.ExecuteScalar() != null)
                {
                    exist = true;
                }

                return exist;
            }
        }

        /// <summary>
        /// Returns whether a specific service set exists.
        /// </summary>
        public static bool DoesServiceSetExist(ushort serviceSetId)
        {
            bool exist = false;
            string sql = "SELECT si_service_set_id FROM dbo.t_service_set WHERE si_service_set_id = 0x" + serviceSetId.ToString("x");

            using (WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITETHENREAD_COMMANDTYPE))
            {
                ws.PartitionType = WstPartitionType.Logical;
                ws.Partition = WstCommand.AnyPartition;
                ws.CommandSql = sql;

                if (ws.ExecuteScalar() != null)
                {
                    exist = true;
                }

                return exist;
            }
        }

        /// <summary>
        /// Returns whether a specific service exists.
        /// </summary>
        public static bool DoesSiteExist(uint siteId)
        {
            bool exist = false;
            string sql = "SELECT i_site_id FROM dbo.t_sites WHERE i_site_id = 0x" + siteId.ToString("x");

            using (WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITETHENREAD_COMMANDTYPE))
            {
                ws.PartitionType = WstPartitionType.Logical;
                ws.Partition = WstCommand.AnyPartition;
                ws.CommandSql = sql;

                if (ws.ExecuteScalar() != null)
                {
                    exist = true;
                }

                return exist;
            }
        }

        /// <summary>
        /// Returns whether a machine exists.
        /// </summary>
        public static bool DoesMachineExist(ulong machineId)
        {
            bool exist = false;
            string sql = "SELECT bi_machine_puid FROM dbo.t_machines WHERE bi_machine_puid = 0x" + machineId.ToString("x");

            using (WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITETHENREAD_COMMANDTYPE))
            {
                ws.PartitionType = WstPartitionType.Logical;
                ws.SetHashVal(machineId);
                ws.CommandSql = sql;

                if (ws.ExecuteScalar() != null)
                {
                    exist = true;
                }

                return exist;
            }
        }


        /// <summary>
        /// Returns whether a machine exists, based on console id (XE.12341234etc or such).
        /// </summary>
        public static bool DoesMachineExist(string consoleId, byte[] certHash)
        {
            if (consoleId.ToLower().StartsWith("xe.")) //xbox360 looks in a different place now
            {
                if (certHash==null)
                {
                    object ret = ExecuteSQLScalar("select vc_console_id from t_machine_xenon_keys where vc_console_id='" + consoleId.Replace("'", "''") + "'", consoleId);
                    return ret != null;
                }
                else
                {
                    object ret = ExecuteSQLScalar("select vc_console_id from t_machine_xenon_keys where vc_console_id='" + consoleId.Replace("'", "''") + "' and bin_cert_hash=0x"+Hexer.tohex(certHash), consoleId);
                    return ret != null;
                }
            }
            else
            {
                object ret = ExecuteSQLScalar("select vc_gamertag from t_user_names where vc_gamertag='" + consoleId.Replace("'", "''") + "'", consoleId);
                return ret != null;
            }
        }

        /// <summary>
        /// Returns whether a pc machine account exists.
        /// </summary>
        public static bool DoesPCMachineExist(byte []voucherHash, ulong pcId)
        {
            string sql = "select bi_machine_puid from dbo.t_pc_accounts where bin_voucher_hash=0x"+Hexer.tohex(voucherHash)+" and b_pc_id=0x"+string.Format("{0:X}",pcId);

            using (WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITETHENREAD_COMMANDTYPE))
            {
                ws.PartitionType = WstPartitionType.Logical;
                ws.SetHashVal(TokendbWS.HashVoucherBytes(voucherHash));
                ws.CommandSql = sql;

                return (ws.ExecuteScalar() != null);
            }
        }

        public static bool DoesWMMachineExist(String deviceId, ulong machineId)
        {
            String sql = String.Format(
                "select bi_machine_puid from dbo.t_wm_machines where bi_machine_puid=0x{0:X}",
                machineId);

            using(WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITETHENREAD_COMMANDTYPE))
            {
                ws.PartitionType = WstPartitionType.Logical;
                ws.SetHashVal(deviceId);
                ws.CommandSql = sql;

                return (ws.ExecuteScalar() != null);
            }
        }

        /// <summary>
        /// Returns whether a specific curfew exists.
        /// </summary>
        public static bool DoesCurfewExist(byte countryId)
        {
            bool exist = false;
            string sql = "SELECT ti_country_id FROM dbo.t_curfew_privilege_set_restrictions WHERE ti_country_id = 0x" + countryId.ToString("x");

            using (WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITETHENREAD_COMMANDTYPE))
            {
                ws.PartitionType = WstPartitionType.Logical;
                ws.Partition = WstCommand.AnyPartition;
                ws.CommandSql = sql;

                if (ws.ExecuteScalar() != null)
                {
                    exist = true;
                }

                return exist;
            }
        }

        /// <summary>
        /// Returns whether a specific country exists.
        /// </summary>
        public static bool DoesCountryExist(byte countryId)
        {
            bool exist = false;
            string sql = "SELECT ti_country_id FROM dbo.t_countries WHERE ti_country_id = 0x" + countryId.ToString("x");

            using (WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITETHENREAD_COMMANDTYPE))
            {
                ws.PartitionType = WstPartitionType.Logical;
                ws.Partition = WstCommand.AnyPartition;
                ws.CommandSql = sql;

                if (ws.ExecuteScalar() != null)
                {
                    exist = true;
                }

                return exist;
            }
        }

        /// <summary>
        /// Returns whether a specific country set exists.
        /// </summary>
        public static bool DoesCountrySetExist(ushort countrySetId)
        {
            bool exist = false;
            string sql = "SELECT si_country_set_id FROM dbo.t_country_set WHERE si_country_set_id = 0x" + countrySetId.ToString("x");

            using (WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITETHENREAD_COMMANDTYPE))
            {
                ws.PartitionType = WstPartitionType.Logical;
                ws.Partition = WstCommand.AnyPartition;
                ws.CommandSql = sql;

                if (ws.ExecuteScalar() != null)
                {
                    exist = true;
                }

                return exist;
            }
        }

        /// <summary>
        /// Returns whether a specific culture exists.
        /// </summary>
        public static bool DoesCultureExist(int cultureId)
        {
            bool exist = false;
            string sql = "SELECT i_culture_id FROM dbo.t_cultures WHERE i_culture_id = 0x" + cultureId.ToString("x");

            using (WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITETHENREAD_COMMANDTYPE))
            {
                ws.PartitionType = WstPartitionType.Logical;
                ws.Partition = WstCommand.AnyPartition;
                ws.CommandSql = sql;

                if (ws.ExecuteScalar() != null)
                {
                    exist = true;
                }

                return exist;
            }
        }

        /// <summary>
        /// Returns whether a specific beta group exists.
        /// </summary>
        public static bool DoesBetaGroupExist(System.Guid guid)
        {
            bool exist = false;
            string sql = "SELECT uid_group_id FROM dbo.t_beta_group WHERE uid_group_id = '"+guid+"'";

            using (WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITETHENREAD_COMMANDTYPE))
            {
                ws.PartitionType = WstPartitionType.Logical;
                ws.SetHashVal(guid);
                ws.CommandSql = sql;

                if (ws.ExecuteScalar() != null)
                {
                    exist = true;
                }

                return exist;
            }
        }

        /// <summary>
        /// Returns whether a specific subscription family exists.
        /// </summary>
        public static bool DoesSubscriptionFamilyExist(System.Guid guid)
        {
            bool exist = false;
            string sql = "SELECT guid_subscription_family FROM dbo.t_subscription_family WHERE guid_subscription_family = '"+guid+"'";

            using (WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITETHENREAD_COMMANDTYPE))
            {
                ws.PartitionType = WstPartitionType.Logical;
                ws.Partition = WstCommand.AnyPartition;
                ws.CommandSql = sql;

                if (ws.ExecuteScalar() != null)
                {
                    exist = true;
                }

                return exist;
            }
        }

        /// <summary>
        /// Returns whether a specific service type mapping exists.
        /// </summary>
        public static bool DoesServiceTypeMappingExist(ushort stmId)
        {
            bool exist = false;
            string sql = "SELECT si_service_type_mapping_id FROM dbo.t_service_type_mapping WHERE si_service_type_mapping_id = 0x" + stmId.ToString("x");

            using (WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITETHENREAD_COMMANDTYPE))
            {
                ws.PartitionType = WstPartitionType.Logical;
                ws.Partition = WstCommand.AnyPartition;
                ws.CommandSql = sql;

                if (ws.ExecuteScalar() != null)
                {
                    exist = true;
                }

                return exist;
            }
        }

        /// <summary>
        /// Builds list of services and info about them from t_service and t_service_instances tables
        /// </summary>
        /// <returns>True if data found</returns>
        public static ServiceInfo[] GetServices()
        {
            ServiceInfo[] serviceInfoArray = null;
            int prevServiceID = 0;
            int curIndex = 0;
            ArrayList serviceInfo = new ArrayList(32);  // array of ServiceInfo objects
            ArrayList serviceInstances = new ArrayList(32);
            string sql = "SELECT tsi.*, ts.* FROM t_service_instances tsi INNER JOIN t_services ts ON tsi.i_service_id = ts.i_service_id";

            using (WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITETHENREAD_COMMANDTYPE))
            {
                ws.PartitionType = WstPartitionType.Logical;
                ws.Partition = WstCommand.AnyPartition;
                ws.CommandSql = sql;

                using (WstDataReader dr = ws.Execute())
                {
                    while (dr.Read())
                    {
                        int serviceID = (int)dr.GetInt32(dr.GetOrdinal("i_service_id"));

                        // If new service, add to ServiceInfo
                        if (serviceID != prevServiceID)
                        {
                            // Make array, add to previous object
                            if (serviceInstances.Count > 0)
                            {
                                ServiceInfo infoObj = (ServiceInfo)serviceInfo[curIndex];
                                infoObj.Instances = (ServiceInfoInstance[])serviceInstances.ToArray(typeof(ServiceInfoInstance));
                                serviceInstances.Clear();
                            }
                            ServiceInfo info = new ServiceInfo();
                            info.ServiceID = serviceID;
                            info.Description = (string)dr.GetString(dr.GetOrdinal("vc_description"));
                            info.MachineOnly = (int)dr.GetInt32(dr.GetOrdinal("i_machine_only"));
                            serviceInfo.Add(info);

                            prevServiceID = serviceID;
                            curIndex = serviceInfo.Count - 1;
                        }

                        // Add instance
                        ServiceInfoInstance si = new ServiceInfoInstance();
                        si.TitleID = (int)dr.GetInt32(dr.GetOrdinal("i_title_id"));
                        si.TitleVersion = (int)dr.GetInt32(dr.GetOrdinal("i_title_version"));
                        si.TitleRegion = (int)dr.GetInt32(dr.GetOrdinal("i_title_region"));
                        si.SiteID = (int)dr.GetInt32(dr.GetOrdinal("i_site_id"));
                        si.Port = (int)dr.GetInt32(dr.GetOrdinal("i_port"));
                        si.ServiceAvailable = (int)dr.GetInt32(dr.GetOrdinal("i_service_available"));
                        serviceInstances.Add(si);
                    }

                    dr.Close();

                    // Make array, add to previous object
                    if (serviceInstances.Count > 0)
                    {
                        ServiceInfo infoObj = (ServiceInfo)serviceInfo[curIndex];
                        infoObj.Instances = (ServiceInfoInstance[])serviceInstances.ToArray(typeof(ServiceInfoInstance));
                        serviceInstances.Clear();
                    }

                    if (serviceInfo.Count > 0)
                    {
                        serviceInfoArray = (ServiceInfo[])serviceInfo.ToArray(typeof(ServiceInfo));
                    }

                    return serviceInfoArray;
                }
            }
        }

        public static void SetContentAccessTimes(uint titleId, ulong userPuid, DateTime accessTime)
        {
            DateTime[] dt = new DateTime[32];
            for (int i = 0; i < 32; i++) dt[i] = accessTime;

            SetContentAccessTimes(titleId, userPuid, dt);
        }

        public static void SetContentAccessTimes(uint titleId, ulong userPuid, DateTime[] accessTimes)
        {
            // validate quickly
            if (accessTimes == null)
            {
                accessTimes = new DateTime[32];
                for (int i = 0; i < 32; i++) accessTimes[i] = DateTime.MinValue;
            }
            if (accessTimes.Length != 32)
                throw new ApplicationException("accessTimes must contain only 32 DateTime entries.");

            using (WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITEONLY_COMMANDTYPE))
            {
                // remove the old row
                string sql = "delete from t_user_title_enumeration_times where bi_user_puid = " + userPuid.ToString() +
                    " and i_title_id = " + titleId.ToString();

                ws.PartitionType = WstPartitionType.Logical;
                ws.SetHashVal(userPuid);
                ws.CommandSql = sql;

                ws.ExecuteNonQuery();

                // add a new row
                sql = "insert into t_user_title_enumeration_times (bi_user_puid, i_title_id, ";
                for (int i = 0; i < 31; i++) sql += "dt_last_access" + (i + 1).ToString() + ", ";
                sql += "dt_last_access32) values (" + userPuid.ToString() + ", " + titleId.ToString() + ", ";
                for (int i = 0; i < 31; i++) sql += "'" + accessTimes[i].ToString() + "', ";
                sql += "'" + accessTimes[31].ToString() + "')";

                ws.ClearParameters();
                ws.PartitionType = WstPartitionType.Logical;
                ws.SetHashVal(userPuid);
                ws.CommandSql = sql;

                int rows = ws.ExecuteNonQuery();
                if (rows != 1)
                    throw new ApplicationException("Unexpected # rows affected (" + rows.ToString() + ") in SetContentAccessTimes()");
            }
        }

        public static DateTime[] GetContentAccessTimes(uint titleId, ulong userPuid)
        {
            DateTime[] dt = null;
            string sql = "select * from t_user_title_enumeration_times where bi_user_puid = " + userPuid.ToString() +
                        " and i_title_id = " + titleId.ToString();

            using (WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITETHENREAD_COMMANDTYPE))
            {
                ws.PartitionType = WstPartitionType.Logical;
                ws.SetHashVal(userPuid);
                ws.CommandSql = sql;

                using (WstDataReader r = ws.Execute())
                {
                    while (r.Read())
                    {
                        dt = new DateTime[32];
                        for (int i = 0; i < 32; i++)
                            dt[i] = r.GetDateTime(r.GetOrdinal("dt_last_access" + (i + 1).ToString()));
                    }
                    r.Close();

                    return dt;
                }
            }
        }

        public static LockoutInfo[] GetLockoutList(ulong userPuid)
        {
            ArrayList results = new ArrayList();
            string sql = "select bi_user_puid, bi_lockout_puid, dt_added, si_hash_bucket, dt_change_datetime from t_xprof_lockout_lists where bi_user_puid = " + userPuid.ToString();

            using (WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITETHENREAD_COMMANDTYPE))
            {
                ws.PartitionType = WstPartitionType.Logical;
                ws.SetHashVal(userPuid);
                ws.CommandSql = sql;

                using (WstDataReader reader = ws.Execute())
                {
                    while (reader.Read())
                    {
                        LockoutInfo info = new LockoutInfo();

                        info.UserPuid = (ulong)reader.GetInt64(0);
                        info.LockoutPuid = (ulong)reader.GetInt64(1);
                        info.Added = reader.GetDateTime(2);
                        info.HashBucket = reader.GetInt16(3);
                        info.Changed = reader.GetDateTime(4);

                        results.Add(info);
                    }
                    reader.Close();

                    return (LockoutInfo[])results.ToArray(typeof(LockoutInfo));
                }
            }
        }

        /// <summary>
        /// This function will return the tier to which the user currently has a subscription.
        /// </summary>
        /// <param name="userPuid">The user puid</param>
        /// <returns>The tier of the base subscription to which this user is subscribed</returns>
        public static byte GetUserTier(ulong userPuid)
        {
            int tier = 0;
            // Copied from p_xkdc_get_user_authorization_and_privileges.sql:
            //        SELECT TOP 1
            //            @i_tier_id = b.i_tier_id
            //        FROM
            //            dbo.t_subscriptions s
            //        INNER JOIN
            //            dbo.t_base_offers b
            //        ON
            //            (b.bi_offer_id = s.bi_offer_id)
            //        WHERE
            //            s.bi_primary_puid = @bi_user_puid
            //            AND s.i_subscription_status_id in (1,2,3,4)
            //            AND s.dt_start_date <= @dt_now
            //            AND s.dt_end_date > @dt_now
            //        ORDER BY
            //            s.i_subscription_status_id ASC,
            //            b.i_tier_id DESC
            //
            // We will do something like this.

            // Sort in descending order
            string sql = "select i_tier_id from t_base_offers inner join t_subscriptions on t_subscriptions.bi_offer_id = t_base_offers.bi_offer_id " +
                    " where t_subscriptions.bi_primary_puid = " + ((long)userPuid).ToString() + " and i_subscription_status_id = 1 order by t_base_offers.i_tier_id desc";

            using (WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITETHENREAD_COMMANDTYPE))
            {
                ws.PartitionType = WstPartitionType.Logical;
                ws.SetHashVal(userPuid);
                ws.CommandSql = sql;

                object ret = ws.ExecuteScalar();
                if (ret != null)
                {
                    tier = (int)ret;
                }

                return (byte)tier;
            }
        }

        /// <summary>
        /// This function will subscribe a user to a base subscription which matches the requested tier.
        /// </summary>
        /// <param name="userPuid">The user puid</param>
        /// <param name="tier">The requested tier.</param>
        public static void SetUserTier(ulong userPuid, byte tier)
        {
            ulong offerId = 0;
            switch (tier)
            {
                // xbox silver
                case 3: offerId = Offers.GetBaseOfferId(Offers.BaseOffers.SilverFreeTrial);
                    break;

                // xbox gold 12 month prepaid offer
                case 6: offerId = Offers.GetBaseOfferId(Offers.BaseOffers.GoldPP1Year);
                    break;

                // this is an error condition
                default:
                    throw new ApplicationException("Invalid tier: " + tier.ToString());
            }

            using (WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITEONLY_COMMANDTYPE))
            {
                // delete any previous base offer subscriptions that this user had
                string sql = "delete from t_subscriptions where bi_primary_puid = " + ((long)userPuid).ToString() +
                    " and i_subscription_status_id = 1 and dt_start_date <= getutcdate() and dt_end_date > getutcdate()";

                ws.PartitionType = WstPartitionType.Logical;
                ws.SetHashVal(userPuid);
                ws.CommandSql = sql;

                ws.ExecuteNonQuery();

                // add a row to the subscription table for this user/offer combination
                sql = "insert into t_subscriptions (bi_primary_puid, bi_offer_id, i_instances, vc_svc_instance_id, i_puid_is_machine, dt_start_date, " +
                " dt_end_date, i_subscription_status_id, i_transaction_flags) " +
                " values ( " + ((long)userPuid).ToString() + ", " + ((long)offerId).ToString() + ", 1, '', 0, '" + DateTime.Now.AddYears(-1).ToString() + "', '" + DateTime.Now.AddYears(1).ToString() +
                "', 1, 0)";

                ws.ClearParameters();
                ws.PartitionType = WstPartitionType.Logical;
                ws.SetHashVal(userPuid);
                ws.CommandSql = sql;

                ws.ExecuteNonQuery();
            }
        }


        /// <summary>
        /// Checks to see if the user/offer combination has an entry in the dbo.t_user_licenses table
        /// </summary>
        /// <param name="userPuid"></param>
        /// <param name="offerId"></param>
        /// <returns></returns>
        public static bool UserHasLicense(ulong userPuid, ulong offerId)
        {
            int count = 0;
            string sql = "select count(*) from dbo.t_user_licenses where bi_user_id = @bi_user_puid and bi_offer_id = @bi_offer_id";

            using (WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITETHENREAD_COMMANDTYPE))
            {
                ws.PartitionType = WstPartitionType.Logical;
                ws.SetHashVal(userPuid);
                ws.CommandSql = sql;
                ws.AddParameter("@bi_user_puid", userPuid);
                ws.AddParameter("@bi_offer_id", offerId);

                object ret = ws.ExecuteScalar();
                if (ret != null)
                {
                    count = (int)ret;
                }

                return (count > 0);
            }
        }

        public static int GetMachineTrialCount(ulong machinePuid)
        {
            using (WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITETHENREAD_COMMANDTYPE))
            {
                ws.PartitionType = WstPartitionType.Logical;
                ws.StoredProc = "dbo.p_xuacs_get_trial_count";
                ws.SetHashVal(machinePuid);

                ws.AddParameter("@bi_machine_id", (long)machinePuid);
                ws.AddParameter(ParamType.OUTPUT, "@@i_trial_count", (int)0);
                ws.ExecuteNonQuery();

                int trialCount = ws.GetIntParameter("@@i_trial_count");
                return trialCount;
            }
        }

        public static int GetMigrationStatus(ulong userPuid)
        {
            int retval = 0;
            string sql = "select i_migration_status from t_xenon_migration_queue where bi_user_puid = 0x" + userPuid.ToString("X");

            using (WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITETHENREAD_COMMANDTYPE))
            {
                ws.PartitionType = WstPartitionType.Logical;
                ws.SetHashVal(userPuid);
                ws.CommandSql = sql;

                object ret = ws.ExecuteScalar();
                if (ret != null)
                {
                    retval = (int)ret;
                }
                else
                    throw new Exception("Migration row could not be found in t_xenon_migration_queue for user 0x" + userPuid.ToString("X"));

                return retval;
            }
        }

        /// <summary>
        ///  Load all of the friend records for a given user. This is used to
        ///  bulk load friend by private\server\presence\test\setupstress. And
        ///  anyone else who might need to manually validate friend data in the
        ///  database
        /// </summary>
        public static FriendRecord[] LoadFriends(ulong puid)
        {
            FriendRecord[] records = null;

            using (WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITETHENREAD_COMMANDTYPE))
            {
                ws.PartitionType = WstPartitionType.Logical;
                ws.SetHashVal(puid);
                ws.StoredProc = "dbo.p_pres_load_offline";

                ws.AddParameter(ParamType.RETVAL, "@ret", 0);
                ws.AddParameter("@bi_user_puid", puid);

                using (WstDataReader r = ws.Execute())
                {
                    // get count first
                    int friendCount = 0;
                    if (r.Read())
                    {
                        friendCount = r.GetInt32(0);
                    }
                    records = new FriendRecord[friendCount];

                    int i = 0;
                    while (r.Read())
                    {
                        records[i].BuddyId = (ulong)r.GetInt64(0);
                        records[i].Status = (uint)r.GetInt32(1);
                        i++;
                    }

                    r.Close();

                    uint hr = (uint)ws.GetIntParameter("@ret");
                    if (HResult.Failed(hr))
                    {
                        throw new UnexpectedTestResultException(ws.GetCallSignature() + " failed with hr = 0x" + hr.ToString("x"));
                    }

                    return records;
                }
            }
        }

        public static GamerTagChange[] GetGamerTagChanges(ulong puid)
        {
            ArrayList results = new ArrayList();
            string sql = "select vc_old_gamertag, vc_new_gamertag, ti_reason, dt_timestamp, vc_ip_address " +
                         "from t_user_gamertag_history where bi_user_puid = 0x" + puid.ToString("x") + " order by dt_timestamp DESC";

            using (WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITETHENREAD_COMMANDTYPE))
            {
                ws.PartitionType = WstPartitionType.Logical;
                ws.SetHashVal(puid);
                ws.CommandSql = sql;

                using (WstDataReader r = ws.Execute())
                {
                    while (r.Read())
                    {
                        GamerTagChange change = new GamerTagChange(
                            r.IsDBNull(0) ? string.Empty : r.GetString(0),
                            r.IsDBNull(1) ? string.Empty : r.GetString(1),
                            (DateTime)r.GetDateTime(3),
                            (byte) r.GetByte(2) == 2, // HistoryReason.Purchased
                            r.IsDBNull(4) ? string.Empty : r.GetString(4)
                        );

                        results.Add(change);
                    }

                    r.Close();

                    return (GamerTagChange[])results.ToArray(typeof(GamerTagChange));
                }
            }
        }

        public static PassportChange[] GetPassportChanges(ulong puid)
        {
            ArrayList results = new ArrayList();
            string sql = "select bi_old_passport_puid, bi_new_passport_puid, ti_reason, dt_timestamp, vc_ip_address " +
                         "from t_user_passport_history where bi_user_puid = 0x" + puid.ToString("x") + " order by dt_timestamp DESC";

            using (WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITETHENREAD_COMMANDTYPE))
            {
                ws.PartitionType = WstPartitionType.Logical;
                ws.SetHashVal(puid);
                ws.CommandSql = sql;

                using (WstDataReader r = ws.Execute())
                {
                    while (r.Read())
                    {
                        PassportChange change = new PassportChange(
                            r.IsDBNull(0) ? 0 : (ulong)r.GetInt64(0),
                            r.IsDBNull(1) ? 0 : (ulong)r.GetInt64(1),
                            (DateTime)r.GetDateTime(3),
                            (byte)r.GetByte(2),
                            r.IsDBNull(4) ? string.Empty : r.GetString(4)
                        );

                        results.Add(change);
                    }

                    r.Close();

                    return (PassportChange[])results.ToArray(typeof(PassportChange));
                }
            }
        }

        public static bool DoesMusicNetAccountExist(ulong puid)
        {
            int count = 0;
            string sql = "select count(*) from t_user_musicnet_accounts where bi_user_puid = 0x" + puid.ToString("x");

            using (WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITETHENREAD_COMMANDTYPE))
            {
                ws.PartitionType = WstPartitionType.Logical;
                ws.SetHashVal(puid);
                ws.CommandSql = sql;

                object ret = ws.ExecuteScalar();
                if (ret != null)
                {
                    count = (int)ret;
                }

                return count == 1;
            }
        }

        /// <summary>
        /// Returns true if Xbox1 offer is visible on the console
        /// </summary>
        /// <param name="expectedOfferId">OfferID we are looking for</param>
        /// <param name="countryId">Country ID of offer</param>
        /// <param name="titleId">TitleId for Offer</param>
        /// <returns></returns>
        public static bool IsOfferVisible(ulong expectedOfferId, uint countryId, uint titleId)
        {
            bool bRet = false;

            using (WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITETHENREAD_COMMANDTYPE))
            {
                ws.PartitionType = WstPartitionType.Logical;
                ws.Partition = WstCommand.AnyPartition;
                ws.StoredProc = "dbo.p_xbos_enumerate";

                ws.AddParameter("@countryid", countryId);
                ws.AddParameter("@titleid", titleId);
                ws.AddParameter("@offeringtype", -1);
                ws.AddParameter("@descriptionindex", 0);
                ws.AddParameter("@bitfilter", -1);
                ws.AddParameter("@esrbrating", 0);

                using (WstDataReader r = ws.Execute())
                {
                    while (r.Read())
                    {
                        ulong retrievedOfferId = (ulong)r.GetInt64(0);
                        if (retrievedOfferId == expectedOfferId)
                        {
                            bRet = true;  //our offer's in the DB, as is expected.
                            break;
                        }
                    }

                    r.Close();
                    return bRet;
                }
            }
        }

        //looks up a ConsoleID (t_machines' "gamertag") for a machine puid
        static public string LookupConsoleIDFromMachineID(ulong id)
        {
            //lookup console id
            WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITETHENREAD_COMMANDTYPE);
            ws.PartitionType = Microsoft.Webstore.WstClient.WstPartitionType.Logical;
            ws.SetHashVal(id);

            long signedID = (long)id; //ms sql has a bug, apparently it can't handle "big int" as unsigned for large values
            ws.CommandSql = "SELECT vc_serial_num FROM t_machines WHERE bi_machine_puid=" + signedID;
            object qres = ws.ExecuteScalar();

            string cid = "";
            if (qres == null)
            {
                Global.RO.Debug("Could not find consoleID for machineID " + id + " in uodb t_machines.");
            }
            else
            {
                cid = (string)qres;
                Global.RO.Debug("Found consoleID for machineID " + id + ": cid=" + cid);
            }

            return cid;
        }

        //looks up a MachineID (t_user_names) given a machine's "gamertag" (SN.blah or XE.blah etc)
        //if more than one console with the same ID is found, this will throw.
        static public ulong LookupMachineIDFromConsoleID(string consoleId)
        {
            return LookupMachineIDFromConsoleID(consoleId, (byte[])null);
        }

        //looks up a machine puid from a console id.  If certHash is null and more than one are found, this will throw.
        static public ulong LookupMachineIDFromConsoleID(string consoleId, byte []certHash)
        {
            ulong puid=0;

            if (consoleId.ToLower().StartsWith("xe.")) //normally xbox360 looks in a different place now
            {
                if (certHash!=null)
                {
                    object ret=ExecuteSQLScalar("select bi_machine_puid from t_machine_xenon_keys where vc_console_id='"+consoleId.Replace("'","''")+"' and bin_cert_hash=0x"+ServerTestFramework.Utilities.Hexer.tohex(certHash), consoleId);
                    if (ret==null)
                    {
                        throw new RowDoesNotExistException("Could not find machineID for \""+consoleId+"\" in uodb t_machine_xenon_keys");
                    }

                    puid=(ulong)(long)ret;
                }
                else
                {
                    int count=(int)ExecuteSQLScalar("select count(*) from t_machine_xenon_keys where vc_console_id='"+consoleId.Replace("'","''")+"'", consoleId);
                    if (count==0)
                    {
                        //allow it to fall through to the legacy case
                    }
                    else if (count>1)
                    {
                        throw new System.Exception("More than one consoles with the same consoleID("+consoleId+") were found.  You must provide certHash to differentiate between them.");
                    }
                    else
                    {
                        object ret=ExecuteSQLScalar("select bi_machine_puid from t_machine_xenon_keys where vc_console_id='"+consoleId.Replace("'","''")+"'", consoleId);
                        puid=(ulong)(long)ret;
                    }
                }
            }

            if (puid==0) //non-xbox360 or legacy xbox360
            {
                object ret=ExecuteSQLScalar("SELECT bi_user_puid FROM t_user_names WHERE vc_gamertag='"+consoleId.Replace("'","''")+"'", consoleId);
                if (ret==null)
                {
                    throw new RowDoesNotExistException("Could not find machineID for \""+consoleId+"\" in uodb t_user_names");
                }

                return (ulong)(long)ret;
            }

            return puid;
        }

        //looks up a machine puid from a console id.  If scode is null and more than one are found, this will throw.
        static public ulong LookupMachineIDFromConsoleID(string consoleId, string scode)
        {
            ulong puid=0;

            if (consoleId.ToLower().StartsWith("xe.")) //normally xbox360 looks in a different place now
            {
                if (!(scode==null || scode==""))
                {
                    //convert scode to cert hash bytes (note that the scode is a subset of the cert hash)
                    string rawSCode=scode.Replace("-", "").Trim();
                    byte []certHashPartial=Hexer.unhex(rawSCode);
                    System.Array.Resize(ref certHashPartial, 7); //8th byte is a checksum, truncate it.  ideally we should verify it here; maybe someday.

                    //
                    object ret=ExecuteSQLScalar("select bi_machine_puid from t_machine_xenon_keys where vc_console_id='"+consoleId.Replace("'","''")+"' and substring(bin_cert_hash, 0, 8)=0x"+ServerTestFramework.Utilities.Hexer.tohex(certHashPartial), consoleId);
                    if (ret==null)
                    {
                        throw new RowDoesNotExistException("Could not find machineID for \""+consoleId+"\" in uodb t_machine_xenon_keys");
                    }

                    puid=(ulong)(long)ret;
                }
                else
                {
                    int count=(int)ExecuteSQLScalar("select count(*) from t_machine_xenon_keys where vc_console_id='"+consoleId.Replace("'","''")+"'", consoleId);
                    if (count==0)
                    {
                        //allow it to fall through to the legacy case
                    }
                    else if (count>1)
                    {
                        throw new System.Exception("More than one consoles with the same consoleID("+consoleId+") were found.  You must provide scode to differentiate between them.");
                    }
                    else
                    {
                        object ret=ExecuteSQLScalar("select bi_machine_puid from t_machine_xenon_keys where vc_console_id='"+consoleId.Replace("'","''")+"'", consoleId);
                        puid=(ulong)(long)ret;
                    }
                }
            }

            if (puid==0) //non-xbox360 or legacy xbox360
            {
                object ret=ExecuteSQLScalar("SELECT bi_user_puid FROM t_user_names WHERE vc_gamertag='"+consoleId.Replace("'","''")+"'", consoleId);
                if (ret==null)
                {
                    throw new RowDoesNotExistException("Could not find machineID for \""+consoleId+"\" in uodb t_user_names");
                }

                return (ulong)(long)ret;
            }

            return puid;
        }

        static public ulong LookupMachineIDFromWMDeviceID(string wmDeviceID)
        {
	    ulong puid = 0;
            using (WSClient ws = new WSClient( ConfigUtil.UodbWebstoreApp, CmdType.WRITETHENREAD_COMMANDTYPE))
            {
               ws.StoredProc = "dbo.p_wm_get_machines";
               ws.SetHashVal(wmDeviceID);
               ws.AddParameter("@vc_wmdevice_id", wmDeviceID);
              
               using (WstDataReader r = ws.Execute())
               {
                   if (r.Read())
                   {
                      puid = (ulong)r.GetInt64(0);
                   }
                   r.Close();
               }
            }
            if (puid==0)
            {
               throw new RowDoesNotExistException("Could not find machineID for \""+wmDeviceID+"\" in uodb t_wm_machines");
            }

            return puid;
        }

        //
        static public void DeleteFromXbox1UserKey(string cid)
        {
            //we'll be trying all partitions of each table to be on the safe side
            uint rowsHit = 0;

            WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITETHENREAD_COMMANDTYPE);
            ws.PartitionType = Microsoft.Webstore.WstClient.WstPartitionType.Physical;

            if (cid.Length > 0)
            {
                ws.CommandSql = "DELETE FROM t_user_keys WHERE vc_gamertag='" + cid + "'";
                for (uint p = 0; p < ws.PhysicalPartitions; ++p)
                {
                    ws.PhysicalPartition = (int)p;
                    rowsHit += (uint)ws.ExecuteNonQuery();
                }

                System.Threading.Thread.Sleep(500); //data could be on diff partitions, meaning the referance constraint may need a moment to update
            }
        }

        //
        static public void DeleteFromXenonUserKey(string cid)
        {
            //we'll be trying all partitions of each table to be on the safe side
            uint rowsHit = 0;

            WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITETHENREAD_COMMANDTYPE);
            ws.PartitionType = Microsoft.Webstore.WstClient.WstPartitionType.Physical;

            if (cid.Length > 0)
            {
                ws.CommandSql = "DELETE FROM t_xenon_user_keys WHERE vc_gamertag='" + cid + "'";
                for (uint p = 0; p < ws.PhysicalPartitions; ++p)
                {
                    ws.PhysicalPartition = (int)p;
                    rowsHit += (uint)ws.ExecuteNonQuery();
                }

                System.Threading.Thread.Sleep(500); //data could be on diff partitions, meaning the referance constraint may need a moment to update
            }
        }

        //
        static public void ZeroFromXbox1UserKey(string cid)
        {
            //we'll be trying all partitions of each table to be on the safe side
            uint rowsHit = 0;

            WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITETHENREAD_COMMANDTYPE);
            ws.PartitionType = Microsoft.Webstore.WstClient.WstPartitionType.Physical;

            if (cid.Length > 0)
            {
                ws.CommandSql = "update  t_user_keys set bin_key = 0x0 WHERE vc_gamertag='" + cid + "'";
                for (uint p = 0; p < ws.PhysicalPartitions; ++p)
                {
                    ws.PhysicalPartition = (int)p;
                    rowsHit += (uint)ws.ExecuteNonQuery();
                }

                System.Threading.Thread.Sleep(500); //data could be on diff partitions, meaning the referance constraint may need a moment to update
            }
        }

        static public void ReleaseUserNames( string nameToFree, ulong machinePuid )
        {
            using ( WSClient ws = new WSClient( ConfigUtil.UodbWebstoreApp, CmdType.WRITEONLY_COMMANDTYPE ) )
            {
                ws.StoredProc = "dbo.p_xuacs_release_name";
                ws.SetHashVal( nameToFree );

                ws.AddParameter( "@vc_gamertag", nameToFree );
                ws.AddParameter( "@bi_puid", (Int64)machinePuid );

                ws.ExecuteNonQuery();
            }
        }

        //
        static public void ZeroFromXenonUserKey(string cid)
        {
            //we'll be trying all partitions of each table to be on the safe side
            uint rowsHit = 0;

            WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITETHENREAD_COMMANDTYPE);
            ws.PartitionType = Microsoft.Webstore.WstClient.WstPartitionType.Physical;

            if (cid.Length > 0)
            {
                ws.CommandSql = "update  t_xenon_user_keys set bin_key = 0x0 WHERE vc_gamertag='" + cid + "'";
                for (uint p = 0; p < ws.PhysicalPartitions; ++p)
                {
                    ws.PhysicalPartition = (int)p;
                    rowsHit += (uint)ws.ExecuteNonQuery();
                }

                System.Threading.Thread.Sleep(500); //data could be on diff partitions, meaning the referance constraint may need a moment to update
            }
        }

        //Makes uodb forget a machine exists (by machine id, console id will be looked up)
        static public void DeleteMachineAccount(ulong id)
        {
            MachineEditor me=MachineEditor.FromId(id);
            if (me.Exists)
            {
                me.CompletelyRemoveMachine();
            }
        }

        //grab the subscriptionInfo that has the matching offerid.
        private static SubscriptionInfo SelectFromSubscriptionInfos(SubscriptionInfo[] si, ulong offerid) {
            foreach (SubscriptionInfo subInfo in si) {
                if (((ulong) subInfo.offerId) == offerid) {
                    return subInfo;
                }
            }
            return null;
        }

        public static void UpdateAcceptedTOS(ulong userPuid, uint serviceType, DateTime newDate)
        {
            string sql =
                "update t_user_per_service_type_data " +
                "set dt_accepted_tos = '" + newDate.ToString() +
                "' where ti_service_type = " + serviceType + " and bi_user_puid = 0x" +
                userPuid.ToString("X");

            UodbWS.ExecuteSQLNonQuery(sql, userPuid);
        }

        public static string GetAcceptedTOS(ulong userPuid)
        {
            string tosDate = "";
            using (WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITEONLY_COMMANDTYPE))
            {
                ws.PartitionType = WstPartitionType.Logical;
                ws.SetHashVal(userPuid);
                ws.CommandSql = "select convert(varchar(10),dt_accepted_tos,112) "
                                + "from t_user_per_service_type_data "
                                + "where bi_user_puid = "
                                + ((long)userPuid).ToString();
                WstDataReader reader = null;
                reader = ws.Execute();
                try
                {
                    while (reader.Read())
                    {
                        tosDate = reader[0].ToString();
                    }
                }
                finally
                {
                    if (reader != null)
                    {
                        reader.Close();
                    }
                }
            }
            return tosDate;
        }

        public static void UpdatePerServiceTypeSuspended(ulong userPuid, uint serviceType, DateTime newDate)
        {
            string sql =
                "update t_user_per_service_type_data " +
                "set dt_suspended_until = '" + newDate.ToString() +
                "' where ti_service_type = " + serviceType + " and bi_user_puid = 0x" +
                userPuid.ToString("X");

            UodbWS.ExecuteSQLNonQuery(sql, userPuid);
        }

        public static void DeleteMusicNetAccountRecord(ulong puid)
        {
            using (WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITEONLY_COMMANDTYPE))
            {
                ws.PartitionType = WstPartitionType.Logical;
                ws.SetHashVal(puid);
                ws.CommandSql = "delete from t_user_musicnet_accounts where bi_user_puid = @user_puid";
                ws.AddParameter("@user_puid", puid);

                ws.ExecuteNonQuery();
            }
        }

        public static int GetSwitchUserCountryStatus(ulong userPuid, out uint hr)
        {
            int status = 0;
            hr = HResult.S_OK;
            string sql = "select ti_status_id, i_hresult from dbo.t_switch_user_country_queue WITH (NOLOCK) where bi_user_puid = @bi_user_puid order by dt_change_datetime DESC";
            
            using (WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITETHENREAD_COMMANDTYPE))
            {
                ws.PartitionType = WstPartitionType.Logical;
                ws.SetHashVal(userPuid);
                ws.CommandSql = sql;
                ws.AddParameter("@bi_user_puid", userPuid);

                using (WstDataReader r = ws.Execute())
                {
                    if (r.Read())
                    {
                        status = (int)r.GetByte(0);
                        if (!r.IsDBNull(1))
                            hr = (uint)r.GetInt32(1);
                    }
                    r.Close();
                }
            }

            return status;
        }

        /// <summary>
        /// Update new BIF field for switch user country queue
        /// </summary>
        /// <param name="userPuid"></param>
        /// <param name="newUrl">new alternate url</param>
        public static void UpdateSwtichUserCountryQueueBIF(ulong userPuid, string newBIF)
        {
            string sql = "update dbo.t_switch_user_country_queue set vc_behavior_injection = @bif where bi_user_puid = @bi_user_puid";

            using (WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITEONLY_COMMANDTYPE))
            {
                ws.PartitionType = WstPartitionType.Logical;
                ws.SetHashVal(userPuid);
                ws.CommandSql = sql;
                ws.AddParameter("@bi_user_puid", userPuid);
                ws.AddParameter("@bif", newBIF);

                if (ws.ExecuteNonQuery() <= 0)
                    throw new UnexpectedTestResultException("UpdateSwtichUserCountryQueueBIF failed: no row has been changed.");
            }
        }

        /// <summary>
        /// Update the initiated time, to work around a block in p_xuacs_switch_user_country_record_intent
        /// </summary>
        /// <param name="userPuid"></param>
        /// <param name="newInitiated">new initiated time</param>
        public static void UpdateSwtichUserCountryInitiatedTime(ulong userPuid, DateTime newInitiated)
        {
            string sql = "update dbo.t_switch_user_country_queue set dt_initiated = @newTime where bi_user_puid = @bi_user_puid and (dt_initiated > @newTime)";

            using (WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITEONLY_COMMANDTYPE))
            {
                ws.PartitionType = WstPartitionType.Logical;
                ws.SetHashVal(userPuid);
                ws.CommandSql = sql;
                ws.AddParameter("@bi_user_puid", userPuid);
                ws.AddParameter("@newTime", newInitiated);

                if (ws.ExecuteNonQuery() <= 0)
                    throw new UnexpectedTestResultException("UpdateSwtichUserCountryInitiatedTime failed: no row has been changed. UserPuid = 0x" + userPuid.ToString("X"));
            }
        }

        //////////////////////////////////////////////////////////////////////////////////////////////////////////////
        // Call back


        //Wait for XCBK to receive a callback.  When callbacks occur, the transaction flag for the
        //appropriate row in t_subscriptions is set to 0, and any other information is also updated appropriately.
        public static void WaitForCallback(ulong userPuid, ulong offerid, int maxRetries) {
            Global.RO.Info("Waiting for callback for user 0x{0:X}", userPuid);
            int retryCount = 0;
            SubscriptionInfo[] si = UodbWS.GetUserServiceIDs(userPuid);
            if ((SelectFromSubscriptionInfos(si, offerid)) == null) {
                throw new UnexpectedTestResultException("User does not have a subscription row with offerid " + offerid.ToString("X"));
            }
            while (SelectFromSubscriptionInfos(si, offerid).transactionFlag != 0 && retryCount < maxRetries)
            {
                retryCount++;
                si = UodbWS.GetUserServiceIDs(userPuid);

                //check only the one for your offerid.
                Global.RO.Info("Waiting for callback to set the transactionFlag to 0. Currently at {0}",
                               SelectFromSubscriptionInfos(si, offerid).transactionFlag);
                System.Threading.Thread.Sleep(1000);
            }

            if (SelectFromSubscriptionInfos(si, offerid).transactionFlag != 0)
                throw new UnexpectedTestResultException("Provision callback was not received.");
        }

        //use a default max retries.
        public static void WaitForCallback(ulong userPuid, ulong offerid) {
            WaitForCallback(userPuid, offerid, 60); //one retry/second--this waits a minute.
        }

        /// <summary>
        /// Wait 10 sec for billing queue removal and optionally wait 60 sec for callback.  NOTE:This expects
        /// only one subscription row, and will be unable to reliably wait if there are more than one.
        /// </summary>
        /// <param name="userPuid">the user puid</param>
        /// <param name="waitForCallbackCompletion">if wait callback</param>
        public static void WaitForQueueRemoval(ulong userPuid, bool waitForCallbackCompletion)
        {
            Global.RO.Info("Waiting for queue removal of user 0x{0:X}", userPuid);
            int c = 0;
            while (UodbWS.IsUserQueued(userPuid) && c < 100)
            {
                c++;
                System.Threading.Thread.Sleep(100);
            }
            if (UodbWS.IsUserQueued(userPuid))
                throw new UnexpectedTestResultException("User never left queued state.");

            if (waitForCallbackCompletion)
            {
                SubscriptionInfo[] si = UodbWS.GetUserServiceIDs(userPuid);
                if (si.Length != 1) {
                    Global.RO.Warn("Warning:Calling UodbWS.WaitForQueueRemoval when more than one subscription exists.(number of subscription rows: " + si.Length + ")");
                    Global.RO.Warn("Cannot decide which subscription to wait on.  Sleeping five seconds instead.");
                    System.Threading.Thread.Sleep(5000);
                } else {
                    //wait for the flag to clear on the only subscription in the table.
                    WaitForCallback(userPuid, (ulong) si[0].offerId);
                }
            }
        }

        public static void WaitForQueueRemoval( ulong userPuid, bool waitForCallbackCompletion, ulong offerId )
        {
            Global.RO.Info( "Waiting for queue removal of user 0x{0:X}", userPuid );
            int c = 0;
            while ( UodbWS.IsUserQueued( userPuid ) && c < 100 )
            {
                c++;
                System.Threading.Thread.Sleep( 100 );
            }
            if ( UodbWS.IsUserQueued( userPuid ) )
                throw new UnexpectedTestResultException( "User never left queued state." );

            if ( waitForCallbackCompletion )
            {
                SubscriptionInfo[] si = UodbWS.GetUserServiceIDs( userPuid, (long)offerId );
                if ( si.Length != 1 )
                {
                    Global.RO.Warn( "Warning:Calling UodbWS.WaitForQueueRemoval when more than one subscription exists.(number of subscription rows: " + si.Length + ")" );
                    Global.RO.Warn( "Cannot decide which subscription to wait on.  Sleeping five seconds instead." );
                    System.Threading.Thread.Sleep( 5000 );
                }
                else
                {
                    //wait for the flag to clear on the only subscription in the table.
                    WaitForCallback( userPuid, (ulong)si[0].offerId );
                }
            }
        }

        //Wait only to get out of the queue.
        public static void WaitForQueueRemoval(ulong userPuid)
        {
            WaitForQueueRemoval(userPuid, false);
        }

        //---------------------------------------------------------------
        // Create bulk users for stress testing

        // Be optimisitic ;)
        private static bool _ReserveNameCanCrypto = true;
        private static bool _ReserveNameShowStatus = true;

        // If we can't crypto, then we should attempt to create valid users with our own crypto
        // stuff. The problem is we need a decrypted (with the Master key) Key Encryption Key (kek)
        // for the environment we are using. To do this dynamically would require all the crypto
        // routines & steps. Thus, we will allow tests to set the decrypted KEK. If so done,
        // the users will have valid keys & PPA *with known rawkeys*. We can sign them in!
        public static byte[] ReserveName_KEK = null;
        public static int ReserveName_KEKVersion = 1;

        //calcKeyFromGamertagInsteadOfPuid paramter is temporary until we know for sure that uacs tests won't break using the gamertag method.  it should be removed then.
        public static void ReserveName(string gamerTag, ulong userPuid, ulong machinePuid, bool calcKeyFromGamertagInsteadOfPuid)
        {
            ReserveName(gamerTag, userPuid, machinePuid, ReserveName_KEK, ReserveName_KEKVersion, calcKeyFromGamertagInsteadOfPuid);
        }

        public static void ReserveName(string gamerTag, ulong userPuid, ulong machinePuid)
        {
            ReserveName(gamerTag, userPuid, machinePuid, ReserveName_KEK, ReserveName_KEKVersion);
        }

        public static void ReserveName(string gamerTag, ulong userPuid, ulong machinePuid, byte []kek, int kekVersion)
        {
            ReserveName(gamerTag, userPuid, machinePuid, kek, kekVersion, false);
        }

        //calcKeyFromGamertagInsteadOfPuid paramter is temporary until we know for sure that uacs tests won't break using the gamertag method.  it should be removed then.
        public static void ReserveName(string gamerTag, ulong userPuid, ulong machinePuid, byte []kek, int kekVersion, bool calcKeyFromGamertagInsteadOfPuid)
        {
            byte[] empty = new byte[] { 0, 0, 0, 0 };
            byte[] one = new byte[] { 1 };
            DateTime now = DateTime.Now;

            // xbox1 per-user stored encryption data
            byte[] xboxIV = null;
            byte[] encryptedXboxKey = null;
            byte[] rawXboxKey = null;
            byte[] xboxSPPA = null;
            byte[] xboxPPA = null;


            // xenon per-user stored encryption data
            byte[] xenonIV = null;
            byte[] encryptedXenonKey = null;
            byte[] rawXenonKey = null;
            byte[] xenonSPPA = null;
            byte[] xenonPPA = null;

            // Make the raw keys, which have a specific format that needs to match how
            // BulkUserSet does things.

            rawXboxKey = new byte[16];
            rawXenonKey = new byte[16];

            if (!calcKeyFromGamertagInsteadOfPuid) //puid way
            {
                // Keys are 16 bytes long.  Use PUID (8 bytes), pad with zeroes.
                byte[] puidbytes = BitConverter.GetBytes(userPuid);
                Array.Copy(puidbytes, 0, rawXboxKey, 0, puidbytes.Length);
                Array.Copy(puidbytes, 0, rawXenonKey, 0, puidbytes.Length);

                // Xbox key is the following, where N is the PUID:
                // [NN,NN,NN,NN,NN,NN,NN,NN,00,00,00,00,00,00,00,01]
                // Notice the 0x01 in the last byte.
                rawXboxKey[15] = 1;

                // Xenon key is the following, where N is the PUID:
                // [NN,NN,NN,NN,NN,NN,NN,NN,00,00,00,00,00,00,00,00]
                // Notice the 0x00 in the last byte.
                rawXenonKey[15] = 0;  // redundant for clarity
            }
            else //gamertag way
            {
                // Keys are 16 bytes long: GG GG GG GG GG GG GG GG GG GG GG GG GG GG GG XX
                // GG are characters from the lowercase gamertag (padded with 0's on the right side if needed)
                // XX = 1 for xbox key and 2 for xenon key
                rawXboxKey=ServerTestFramework.LiveService.Auth.AuthContext.CalculateKeyFromGamertag(gamerTag, false);
                rawXenonKey=ServerTestFramework.LiveService.Auth.AuthContext.CalculateKeyFromGamertag(gamerTag, true);
            }

            // Option 1
            // If KEK set, use it instead of decoding one properly from the UODB.
            // This is useful if you don't have the full crypto stuff set up. It's
            // a very special case used (probably) only by the XKDC tests.
            //
            if (kek != null)
            {
                // Generate keys and IV
                Ppa.GenerateKey(kek, rawXboxKey, out xboxIV, out encryptedXboxKey);
                Ppa.GenerateKey(kek, rawXenonKey, out xenonIV, out encryptedXenonKey);

                // Generate SPPA data
                xboxSPPA = Ppa.GenSppa1(gamerTag, rawXboxKey);
                xenonSPPA = Ppa.GenSppa1(gamerTag, rawXenonKey);

                // Generate PPA2 data
                xboxPPA = Ppa.GenPpa2(gamerTag, rawXboxKey);
                xenonPPA = Ppa.GenPpa2(gamerTag, rawXenonKey);

                if (_ReserveNameShowStatus)
                {
                    Global.RO.Info("ReserveName: using provided KEK (probably valid users!)");
                    _ReserveNameShowStatus = false;
                }

            }
            // Option 2
            // If KEK not set, let's attempt the crypto libraries. We can still generate
            // known keys, which is useful. This may fail, but that's OK.
            //
            else if (_ReserveNameCanCrypto)
            {
                try
                {
                    // This was moved from XConfig.Initialize, since it requires talking to the
                    // NPDB.  Initialize is called before the GUI window has popped, so the user
                    // experience when the connect call times out was bad.
                    // This call adds your computer to t_servers, which is needed for the crypto
                    // calls below.
                    Global.XEnv.InitializeTestServer();

                    kekVersion = KEKCryptoMgr.GetKeyVersion();

                    // rawXboxKey has already been created
                    KEKCryptoMgr.EncryptWithKEK(
                        kekVersion,
                        rawXboxKey,
                        out xboxIV,
                        out encryptedXboxKey);

                    KEKCryptoMgr.GenPPAforDBWrp(
                        gamerTag,
                        //(byte[]) rawXboxKey.Clone(),
                        rawXboxKey,
                        out xboxSPPA,
                        out xboxPPA);

                    // rawXenonKey has already been created
                    KEKCryptoMgr.EncryptWithKEK(
                        kekVersion,
                        rawXenonKey,
                        out xenonIV,
                        out encryptedXenonKey);

                    KEKCryptoMgr.GenPPAforDBWrp(
                        gamerTag,
                        //(byte[]) rawXenonKey.Clone(),
                        rawXenonKey,
                        out xenonSPPA,
                        out xenonPPA);

                    if (_ReserveNameShowStatus)
                    {
                        Global.RO.Info("ReserveName: using crypto libraries (valid users!)");
                        _ReserveNameShowStatus = false;
                    }

                }
                catch (Exception ex)
                {
                    //Global.RO.Debug("Cryto creation failed you have probably failed to setup crypto correctly please perform the following: \n" +
                    //    "1.) Install WSTClient from %drop%\\webstore40\\wsclientlib\\setup.exe\n" +
                    //    "2.) Register the crypto wrapper COM interface: REGSVR32 <STFPATH>\\CryptoWrapper.dll\n" +
                    //    "3.) Register the master private key for the environment: XKEYMGR removemk 1; XKEYMGR storemk MasterKeyV1.PRV\n" +
                    //    "4.) Restart current ServerTestFramework AppDomain (STFRunner, BulkUsers, etc.)\n");
                    // Global.RO.Debug("Crypto exception was: " + ex.ToString());
                    _ReserveNameCanCrypto = false;

                    if (_ReserveNameShowStatus)
                    {
                        Global.RO.Warn("ReserveName: failed to use crypto libraries, exception message: {0}", ex.Message);
                        Global.RO.Debug("Exception is: " + ex.ToString());
                        _ReserveNameShowStatus = false;
                    }
                }
            }

            // Option 3
            // If KEK not set and attempt at crypto failed, then we'll just create
            // dummy values. Too bad for you.
            if (null == xboxIV)
            {
                xboxIV = empty;
                encryptedXboxKey = one;
                rawXboxKey = empty;
                xboxSPPA = empty;
                xboxPPA = empty;
                kekVersion = 0;

                if (_ReserveNameShowStatus)
                {
                    Global.RO.Info("ReserveName: using fake key data (invalid users!)");
                    _ReserveNameShowStatus = false;
                }
            }

            if (null == xenonIV)
            {
                xenonIV = empty;
                encryptedXenonKey = one;
                rawXenonKey = empty;
                xenonSPPA = empty;
                xenonPPA = empty;
                kekVersion = 0;

                if (_ReserveNameShowStatus)
                {
                    Global.RO.Info("ReserveName: using fake key data (invalid users!)");
                    _ReserveNameShowStatus = false;
                }
            }

            // we set a non empty bin_key to make sure that nobody takes our name
            using (WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITEONLY_COMMANDTYPE))
            {
                ws.PartitionType = WstPartitionType.Logical;
                ws.StoredProc = "dbo.p_xuacs_reserve_gamertag";
                ws.SetHashVal(gamerTag);

                ws.AddParameter(ParamType.RETVAL, "@ret", 0);
                ws.AddParameter("@vc_gamertag", gamerTag);
                ws.AddParameter("@bi_puid", userPuid);
                ws.AddParameter("@i_kek_version", kekVersion);
                ws.AddParameter("@bin_xbox_key", encryptedXboxKey);
                ws.AddParameter("@bin_xbox_iv", xboxIV);
                ws.AddParameter("@bin_xbox_sppa", xboxSPPA);
                ws.AddParameter("@bin_xbox_ppa", xboxPPA);
                ws.AddParameter("@bin_xenon_key", encryptedXenonKey);
                ws.AddParameter("@bin_xenon_iv", xenonIV);
                ws.AddParameter("@bin_xenon_sppa", xenonSPPA);
                ws.AddParameter("@bin_xenon_ppa", xenonPPA);
                ws.AddParameter("@dt_expires", now.AddMinutes(10));
                ws.AddParameter("@bi_machine_puid", (Int64)machinePuid);
                ws.AddParameter("@si_hash_bucket", ws.Partition);

                ws.Command.CommandTimeout = 30;
                ws.ExecuteNonQuery();

                uint hr = (uint)ws.GetIntParameter("@ret");
                if (HResult.Failed(hr))
                {
                    throw new UnexpectedTestResultException(ws.GetCallSignature() + " failed with hr = 0x" + hr.ToString("x"));
                }
            }
        }

        public static void CreateUserDirect(string gamerTag, ulong userPuid, ulong machinePuid, ulong offerId, byte countryCode)
        {
            CreateUserDirectExt(gamerTag, userPuid, machinePuid, offerId, countryCode, 0);
        }

        public static void CreateSubscriptionForNewUser(ulong userId, ulong offerId, string serviceInstanceId)
        {
            using (WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITEONLY_COMMANDTYPE))
            {
                ws.SetHashVal((long)userId);
                ws.StoredProc = "dbo.p_xbos_create_subscription_for_new_user";

                // intput and output params
                ws.AddParameter(ParamType.RETVAL, "@RETVAL", 0);
                ws.AddParameter(ParamType.INPUT, "@bi_user_puid", userId);
                ws.AddParameter(ParamType.INPUT, "@bi_offer_id", offerId);
                ws.AddParameter(ParamType.INPUT, "@vc_service_instance_id", serviceInstanceId, serviceInstanceId.Length);
                ws.AddParameter(ParamType.INPUT, "@si_hash_bucket", ws.Partition);

                // call the procedure
                ws.ExecuteNonQuery();

                uint hr = (uint)ws.GetIntParameter("@RETVAL");
                if (HResult.Failed(hr))
                {
                    throw new UnexpectedTestResultException(ws.GetCallSignature() + " failed with hr = 0x" + hr.ToString("x"));
                }
            }
        }

        public static void CreateSubscriptionForNewUser(ulong userId, ulong offerId, string serviceInstanceId, System.Guid offerInstance, System.Guid offerGuid)
        {
            using (WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITEONLY_COMMANDTYPE))
            {
                ws.SetHashVal((long)userId);
                ws.StoredProc = "dbo.p_xbos_create_subscription_for_new_user";

                // intput and output params
                ws.AddParameter(ParamType.RETVAL, "@RETVAL", 0);
                ws.AddParameter(ParamType.INPUT, "@bi_user_puid", userId);
                ws.AddParameter(ParamType.INPUT, "@bi_offer_id", offerId);
                ws.AddParameter(ParamType.INPUT, "@vc_service_instance_id", serviceInstanceId, serviceInstanceId.Length);
                ws.AddParameter(ParamType.INPUT, "@si_hash_bucket", ws.Partition);
                ws.AddParameter(ParamType.INPUT, "@uid_catalogOfferId", offerGuid);
                ws.AddParameter(ParamType.INPUT, "@uid_catalogOfferInstanceId", offerInstance);

                // call the procedure
                ws.ExecuteNonQuery();

                uint hr = (uint)ws.GetIntParameter("@RETVAL");
                if (HResult.Failed(hr))
                {
                    throw new UnexpectedTestResultException(ws.GetCallSignature() + " failed with hr = 0x" + hr.ToString("x"));
                }
            }
        }

        public static void CreateUserDirectExt(string gamerTag, ulong userPuid, ulong machinePuid, ulong offerId, byte countryCode, int fPartnerOptIn)
        {
            CreateUserDirectExt(gamerTag, userPuid, machinePuid, offerId, countryCode, fPartnerOptIn, null, null);
        }

        public static void CreateUserDirectExt(string gamerTag, ulong userPuid, ulong machinePuid, ulong offerId, byte countryCode, int fPartnerOptIn, System.Nullable<System.Guid> offerInstance, System.Nullable<System.Guid> offerGuid)
        {
            string accountId = "BULKACCTID";
            string payinfoId = "BULKPYMTID";
            DateTime now = DateTime.UtcNow - new System.TimeSpan(0, 5, 0); //use 5 minutes in the past to avoid time sync problems between client and server (for example the xkdc may see a newly created account as suspended if the client time is ahead of server time and the new user is immediately used).

            // save to uodb
            using (WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITEONLY_COMMANDTYPE))
            {
                ws.PartitionType = WstPartitionType.Logical;
                ws.StoredProc = "dbo.p_xuacs_add_user_v2";
                ws.SetHashVal(userPuid);

                ws.AddParameter(ParamType.RETVAL, "@ret", 0);
                ws.AddParameter("@bi_user_puid", userPuid);
                ws.AddParameter("@bi_owner_puid", userPuid);
                ws.AddParameter("@bi_machine_puid", machinePuid);
                ws.AddParameter("@ti_country_id", countryCode);
                ws.AddParameter("@i_language_id", 1);
                ws.AddParameter("@vc_billing_account_id", accountId);
                ws.AddParameter("@vc_billing_payinfo_id", payinfoId);
                ws.AddParameter("@vc_gamertag", gamerTag);
                ws.AddParameter("@dt_birthdate", now.AddYears(-19));
                ws.AddParameter("@si_ticket_flags", 0);
                ws.AddParameter("@dt_acct_resume_date", now);
                ws.AddParameter("@i_suspension_length", 0);
                ws.AddParameter("@dt_voice_resume_date", now);
                ws.AddParameter("@i_voice_ban_length", 0);
                ws.AddParameter("@ti_name_change_required", 0);
                ws.AddParameter("@dt_accepted_tos", now);
                ws.AddParameter("@dt_reset_date", now);
                ws.AddParameter("@i_billing_account_status", 0);
                ws.AddParameter("@bin_acct_pin", new byte[] { 1, 1, 1, 1 });
                ws.AddParameter("@f_ms_opt_in", 0); // OBSOLETE: _acceptMsSpam
                ws.AddParameter("@f_partner_opt_in", fPartnerOptIn); // OBSOLETE: _acceptPartnerSpam
                ws.AddParameter("@si_hash_bucket", ws.Partition);

                ws.Command.CommandTimeout = 30;
                ws.ExecuteNonQuery();

                uint hr = (uint)ws.GetIntParameter("@ret");
                if (HResult.Failed(hr))
                {
                    throw new UnexpectedTestResultException(ws.GetCallSignature() + " failed with hr = 0x" + hr.ToString("x"));
                }
            }

            if (offerInstance==null && offerGuid==null)
            {
                CreateSubscriptionForNewUser(userPuid, offerId, "");
            }
            else
            {
                CreateSubscriptionForNewUser(userPuid, offerId, "", (System.Guid)offerInstance, (System.Guid)offerGuid);
            }

            // save to profiledb
            using (WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITEONLY_COMMANDTYPE))
            {
                ws.PartitionType = WstPartitionType.Logical;
                ws.StoredProc = "dbo.p_xuacs_insert_user";
                ws.SetHashVal(userPuid);

                ws.AddParameter(ParamType.RETVAL, "@ret", 0);
                ws.AddParameter("@bi_user_puid", userPuid);
                ws.AddParameter("@vc_gamertag", gamerTag);
                ws.AddParameter("@f_ms_opt_in", 0);
                ws.AddParameter("@f_partner_opt_in", 0);
                ws.AddParameter("@si_hash_bucket", ws.Partition);

                ws.Command.CommandTimeout = 30;
                ws.ExecuteNonQuery();

                uint hr = (uint)ws.GetIntParameter("@ret");
                if (HResult.Failed(hr))
                {
                    throw new UnexpectedTestResultException(ws.GetCallSignature() + " failed with hr = 0x" + hr.ToString("x"));
                }
            }
        }

        public static void CreateXeUserDirect(ulong userPuid, ulong passportPuid, ulong machinePuid, byte countryCode, string gamerTag, ulong offerId)
        {
            CreateXeUserDirectExt(userPuid, passportPuid, machinePuid, countryCode, gamerTag, offerId, 0);
        }

        public static void CreateXeUserDirectExt(ulong userPuid, ulong passportPuid, ulong machinePuid, byte countryCode, string gamerTag, ulong offerId, int partnerOptIn)
        {
            Global.RO.Warn("CreateXeUserDirect: This version of the call will no longer result in valid subscriptions after catalog kdc subscription changes.  Please call the version that accepts an offerInstanceGuid instead.");
            CreateXeUserDirectExt(userPuid, passportPuid, machinePuid, countryCode, gamerTag, offerId, partnerOptIn, null, null);
        }

        public static void CreateXeUserDirectExt(ulong userPuid, ulong passportPuid, ulong machinePuid, byte countryCode, string gamerTag, ulong offerId, int partnerOptIn, System.Nullable<System.Guid> offerInstance, System.Nullable<System.Guid> offerGuid)
        {
            string accountId = "BULKACCTID";
            DateTime now = DateTime.UtcNow - new System.TimeSpan(0, 5, 0); //use 5 minutes in the past to avoid time sync problems between client and server (for example the xkdc may see a newly created account as suspended if the client time is ahead of server time and the new user is immediately used).

            using (WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITEONLY_COMMANDTYPE))
            {
                ws.PartitionType = WstPartitionType.Logical;
                ws.StoredProc = "dbo.p_xuacs_create_live_account_v3";
                ws.SetHashVal(userPuid);

                ws.AddParameter(ParamType.RETVAL, "@ret", 0);
                ws.AddParameter("@bi_user_puid", userPuid);
                ws.AddParameter("@bi_owner_puid", userPuid);
                ws.AddParameter("@bi_offline_xuid", userPuid);
                ws.AddParameter("@bi_user_passport_puid", passportPuid);
                ws.AddParameter("@bi_owner_passport_puid", passportPuid);
                ws.AddParameter("@bi_machine_puid", machinePuid);
                ws.AddParameter("@ti_country_id", countryCode);
                ws.AddParameter("@i_language_id", 1);
                ws.AddParameter("@vc_billing_account_id", accountId);
                ws.AddParameter("@vc_gamertag", gamerTag);
                ws.AddParameter("@f_allow_xbox1_logon", 1);
                ws.AddParameter("@dt_birthdate", now.AddYears(-25));
                ws.AddParameter("@si_ticket_flags", 0);
                ws.AddParameter("@dt_acct_resume_date", now);
                ws.AddParameter("@i_suspension_length", 0);
                ws.AddParameter("@dt_voice_resume_date", now);
                ws.AddParameter("@i_voice_ban_length", 0);
                ws.AddParameter("@ti_name_change_required", 0);
                ws.AddParameter("@dt_accepted_tos", now);
                ws.AddParameter("@dt_reset_date", now);
                ws.AddParameter("@i_billing_account_status", 0);
                ws.AddParameter("@bin_acct_pin", new byte[] { 1, 1, 1, 1 });
                ws.AddParameter("@i_parental_control_group_id", 0);
                ws.AddParameter("@f_ms_opt_in", 0);
                ws.AddParameter("@f_partner_opt_in", partnerOptIn);
                ws.AddParameter("@ti_created_account_type", 2);
                ws.AddParameter("@si_hash_bucket", ws.Partition);
                ws.AddParameter(ParamType.OUTPUT, "@i_culture_id", (int)0);

                ws.Command.CommandTimeout = 30;
                ws.ExecuteNonQuery();

                uint hr = (uint)ws.GetIntParameter("@ret");
                if (HResult.Failed(hr))
                {
                    throw new UnexpectedTestResultException(ws.GetCallSignature() + " failed with hr = 0x" + hr.ToString("x"));
                }
            }

            if (offerInstance==null && offerGuid==null)
            {
                CreateSubscriptionForNewUser(userPuid, offerId, "");
            }
            else
            {
                CreateSubscriptionForNewUser(userPuid, offerId, "", (System.Guid)offerInstance, (System.Guid)offerGuid);
            }
        }

        public static void AddUserByPassport(ulong uUserPuid, ulong uWebID)
        {
            using (WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITEONLY_COMMANDTYPE))
            {
                ws.ClearParameters();
                ws.StoredProc = "dbo.p_xuacs_add_user_by_passport";
                ws.SetHashVal(uWebID);

                ws.AddParameter("@bi_user_passport_puid", uWebID);
                ws.AddParameter("@bi_user_puid", uUserPuid);
                ws.AddParameter("@si_hash_bucket", ws.Partition);

                ws.Command.CommandTimeout = 30;
                ws.ExecuteNonQuery();
            }
        }

        public static void GetUserByPassport(ulong uWebID, out ulong uUserPuid )
        {
            uUserPuid = 0;
            using (WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITEONLY_COMMANDTYPE))
            {
                ws.ClearParameters();
                ws.StoredProc = "dbo.p_xuacs_get_user_by_passport";
                ws.SetHashVal(uWebID);

                ws.AddParameter(ParamType.RETVAL, "@RETVAL", 0);
                ws.AddParameter(ParamType.INPUT, "@bi_user_passport_puid", uWebID);
                ws.AddParameter(ParamType.OUTPUT, "@bi_user_puid", uUserPuid);

                ws.Command.CommandTimeout = 30;

                using (WstDataReader r = ws.Execute())
                {
                    uint hr = (uint)ws.GetIntParameter("@RETVAL");

                    if (HResult.Succeeded(hr))
                        uUserPuid = (ulong)ws.GetLongParameter("@bi_user_puid");
                }
            }
        }

        static public void CreateBulkUsers(string prefix, uint count, out BulkUserSet userSet)
        {
            CreateBulkUsers(prefix, count, OfferType.StarterKit12Month, (byte) 103, false, out userSet);
        }

        static public void CreateBulkUsers(string prefix, uint count, byte countryCode, out BulkUserSet userSet)
        {
            CreateBulkUsers(prefix, count, OfferType.StarterKit12Month, countryCode, false, out userSet);
        }

        static public void CreateBulkUsers(string prefix, uint count, OfferType offerType, bool partnerOptIn, out BulkUserSet userSet)
        {
            CreateBulkUsers(prefix, count, offerType, (byte) 103, partnerOptIn, out userSet);
        }

        static public void CreateBulkUsers(string prefix, uint count, OfferType offerType, byte countryCode, bool partnerOptIn, out BulkUserSet userSet)
        {
            ulong offerId = 0;
            switch (offerType)
            {
                case OfferType.StarterKit12Month:
                    offerId = 0xFFFE000080000008;
                    break;
                case OfferType.PrepaidCode12Month:
                    offerId = 0xFFFE00008000000D;
                    break;
                case OfferType.GameTrial:
                    offerId = 0xFFFE000080000009;
                    break;
                case OfferType.ConsoleTrial:
                    offerId = 0xFFFE00008000000A;
                    break;
                case OfferType.Trial3Month:
                    offerId = 0xFFFE00008000000E;
                    break;
                case OfferType.MonthlyRenewal:
                    offerId = 0xFFFE00008000000B;
                    break;
                case OfferType.YearlyRenewal:
                    offerId = 0xFFFE00008000000C;
                    break;
            }

            CreateBulkUsers(prefix, count, offerId, countryCode, partnerOptIn, out userSet);
        }

        static public void CreateBulkUsers(string prefix, uint count, ulong offerId, bool partnerOptIn, out BulkUserSet userSet)
        {
            CreateBulkUsers(prefix, count, offerId, 103, partnerOptIn, out userSet);
        }

        static public void CreateBulkUsers(string prefix, uint count, ulong offerId, byte countryCode, bool partnerOptIn, out BulkUserSet userSet)
        {
            CreateBulkUsers(prefix, count, offerId, countryCode, false, partnerOptIn, out userSet);
        }

        static public void CreateBulkUsers(string prefix, uint count, ulong offerId, byte countryCode, bool xenon, bool partnerOptIn, out BulkUserSet userSet)
        {
            CreateBulkUsersExt(prefix, count, offerId, countryCode, xenon, out userSet, false, partnerOptIn);
        }

        static public void CreateBulkUsers(string prefix, uint count, ulong offerId, byte countryCode, bool xenon, out BulkUserSet userSet, bool calcRawKeyFromGamertag)
        {
            CreateBulkUsersExt(prefix, count, offerId, countryCode, xenon, out userSet, calcRawKeyFromGamertag, false);
        }

        static public void CreateBulkUsersExt(string prefix, uint count, ulong offerId, byte countryCode, bool xenon, out BulkUserSet userSet, bool calcRawKeyFromGamertag, bool partnerOptIn)
        {
            Global.RO.Warn("CreateBulkUsers: This version of the call will no longer result in valid subscriptions after catalog kdc subscription changes.  Please call the version that accepts an offerInstanceGuid instead.");
            CreateBulkUsersExt(prefix, count, offerId, countryCode, xenon, out userSet, calcRawKeyFromGamertag, partnerOptIn, System.Guid.Empty, System.Guid.Empty);
        }

        static public void CreateBulkUsersExt(string prefix, uint count, ulong offerId, byte countryCode, bool xenon, out BulkUserSet userSet, bool calcRawKeyFromGamertag, bool partnerOptIn, System.Guid offerInstanceGuid, System.Guid offerGuid)
        {
            if (0 == count)
            {
                throw new Exception("CreateBulkUsers: cannot create 0 bulk users.");
            }

            if (prefix.Length != 2)
            {
                throw new Exception("CreateBulkUsers: Prefix strings are limited to 2 characters.");
            }


            // Setup the user set parameters
            userSet = new BulkUserSet(prefix);
            userSet.OfferId = offerId;
            userSet.OfferInstanceIdGuid = offerInstanceGuid;
            userSet.OfferIdGuid = offerGuid;
            userSet.Count = count;
            userSet.Country = countryCode;

            // Get the NPDB connection for puid generation
            // Pre-Xenon this would talk to UODB
            {
                Npdb npdb = new Npdb();
                if (Global.CurrentEnvironment == null)
                    throw new Exception("No Environment setting specified");
                npdb.ConnectToServer();
                npdb.AllocatePuids(0, count, userSet);
                npdb.Close();

                // This was moved from XConfig.Initialize, since it requires talking to the
                // NPDB.  Initialize is called before the GUI window has popped, so the user
                // experience when the connect call times out was bad.
                // This call adds your computer to t_servers, which is needed for the crypto
                // calls below.
                // It was then moved from ReserveName because it was taking a long time
                // in certain scenarios, causing the 1st thread to slow down. We don't need
                // to do this if the user override the Key Encryption Key, though.
                if (ReserveName_KEK == null)
                {
                    Global.RO.Debug("Initializing the test server...");
                    Global.XEnv.InitializeTestServer();
                }
            }

            // Once the PUIDs have been reserved we can go ahead and run a bunch of threads.
            // 4 threads per UODB partition seems to give the best bang for the buck.
            uint threadsPerPartition = 4;
            int UodbCount = WstPhysicalPartitionCount();
            uint numThreads = (uint)(UodbCount * threadsPerPartition);

            // Only use 1 thread if the number of users being created is small, the overhead
            // isn't worth it. Plus doing fewer than threadsPerPartition will create problems
            // with the start & stop range.
            if (count < numThreads * 4)
            {
                numThreads = 1;
            }

            ManualResetEvent stopEvent = new ManualResetEvent(false);
            SafeCounter counter = new SafeCounter();
            BulkUserPartitionThread[] threads = new BulkUserPartitionThread[numThreads];

            Global.RO.Debug("Creating {0} users with {1} threads hitting {2} UODB partitions",
                count, numThreads, UodbCount);

            try
            {
                for (int i = 0; i < numThreads; ++i)
                {
                    // The threads use the current user index (counter) as input for which user
                    // to create.  The thread-safe Interlocked.Increment is used to increment the counter
                    // and return the value -- this value is used as the index of the user that the
                    // thread should create. Thus we'll never have too big of a gap in users, although
                    // it is possible for 1 thread to hang while the others go on creating users.
                    threads[i] = new BulkUserPartitionThread(i, stopEvent, userSet, counter, xenon, partnerOptIn);
                    threads[i].CalcRawKeyFromGamertag=calcRawKeyFromGamertag;
                    threads[i].Go();
                }

                // Do some basic measurements, this only really matters for creations that take
                // longer than REPORT_INTERVAL
                const uint REPORT_INTERVAL = 5;
                uint lastCreated = 0;
                uint created = 0;
                DateTime started = DateTime.Now;
                DateTime lastReport = DateTime.Now;
                DateTime reportAt = DateTime.Now.AddSeconds(REPORT_INTERVAL);
                TimeSpan elapsed;
                TimeSpan totalElapsed;

                while (!stopEvent.WaitOne(0, false) && (uint)counter.Value < count + numThreads)
                {
                    if (DateTime.Now > reportAt)
                    {
                        created = (uint)counter.Value - lastCreated;
                        lastCreated = (uint)counter.Value;
                        reportAt = DateTime.Now.AddSeconds(REPORT_INTERVAL);
                        elapsed = DateTime.Now - lastReport;
                        totalElapsed = DateTime.Now - started;
                        lastReport = DateTime.Now;

                        Global.RO.Debug("CreateBulkUsers: created: {0}, rate {1}/s, elapsed: {2}",
                            counter.Value,
                            (float)created / ((float)elapsed.TotalSeconds + 0.0001f),
                            totalElapsed.ToString());
                    }
                    Thread.Sleep(500);
                }

                // Count users actually created
                uint totalUsersCreated = 0;
                for (int i = 0; i < threads.Length; ++i)
                {
                    totalUsersCreated += threads[i].UsersCreated;
                }

                totalElapsed = DateTime.Now - started;
                Global.RO.Debug("Finished generating users, base puid: {0}, created: {1} out of {2}, avg.rate: {3}/s, elapsed: {4}",
                    userSet.Base,
                    totalUsersCreated,
                    userSet.Count,
                    (float)counter.Value / (totalElapsed.Seconds + 0.0001f),
                    totalElapsed.ToString());

                // Check for exceptions, log error and rethrow
                for (int i = 0; i < threads.Length; ++i)
                {
                    if (null != threads[i].LastEx)
                    {
                        Global.RO.Error("Error creating accounts in partition thread [index {0}]: {1}",
                            i, threads[i].LastEx.ToString());
                        throw threads[i].LastEx;
                    }
                }
            }
            catch (System.Threading.ThreadAbortException) //if we're being aborted, abort our threads too
            {
                for (int i=0; i<threads.Length; ++i)
                {
                    if (threads[i]!=null && threads[i].TaskThread!=null)
                        threads[i].TaskThread.Abort();
                }
            }
        }

        /// <summary>
        /// Dequeue BillingQueue.
        /// Tables affected are t_user_billing_queue.
        /// </summary>
        public static void DequeueBillingQueue()
        {
            string sql = "";

            using (WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITEONLY_COMMANDTYPE))
            {
                for (int p = 0; p < ws.PhysicalPartitions; p++)
                {
                    // set si_queue_status = 2
                    ws.ClearParameters();
                    sql = "update t_user_billing_queue set si_queue_status = 2 where si_queue_status in (0, 1)";
                    ws.PhysicalPartition = p;
                    ws.CommandSql = sql;
                    ws.ExecuteNonQuery();
/*
                    // run p_xuacs_get_queued_billing_info_users
                    ws.ClearParameters();
                    ws.StoredProc = "dbo.p_xuacs_get_queued_billing_info_users";
                    ws.Command.CommandTimeout = 30;
                    ws.Execute();
*/
                }
            }
        }

        /// <summary>
        /// Executes the supplied sql against all partions.
        /// </summary>
        /// <param name="_sql"></param>
        /// <returns></returns>
        public static IEnumerable<T> ExecuteOnAllPartitions<T>(string _sql, Func<WstDataReader, T> func)
        {
            using (WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITETHENREAD_COMMANDTYPE))
            {
                for (int p = 0; p < ws.PhysicalPartitions; p++)
                {
                    ws.ClearParameters();
                    ws.PhysicalPartition = p;
                    ws.CommandSql = _sql;

                    using (WstDataReader r = ws.Execute())
                    {
                        while(r.Read())
                        {
                            yield return func(r);
                        }
                    }
                }
            }
        }

        class BulkUserPartitionThread : ThreadBase
        {
            public int ThreadIdx;
            public BulkUserSet UserSet;
            public SafeCounter Counter;
            public ManualResetEvent StopEvent;
            public Exception LastEx;
            public uint UsersCreated;
            public bool IsXenon;
            public bool CalcRawKeyFromGamertag=false;
            public bool IsPartnerOptIn = false;

            public BulkUserPartitionThread(int threadIdx, ManualResetEvent stopEvent, BulkUserSet userSet, SafeCounter counter, bool xenonUser, bool partnerOptIn)
            {
                this.Initialize(threadIdx, stopEvent, userSet, counter, xenonUser, partnerOptIn);
            }

            protected void Initialize(int threadIdx, ManualResetEvent stopEvent, BulkUserSet userSet, SafeCounter counter, bool xenonUser, bool partnerOptIn)
            {
                ThreadIdx = threadIdx;
                StopEvent = stopEvent;
                UserSet = userSet;
                Counter = counter;
                UsersCreated = 0;
                IsXenon = xenonUser;
                IsPartnerOptIn = partnerOptIn;
            }

            protected override void ThreadBody()
            {
                try
                {
                    RandomEx randGen = new RandomEx();

                    // Loop until we try to create a user outside the range
                    while (true)
                    {
                        // Get user index that we're going to create.
                        // Remember Counter is thread safe and atomic.
                        uint i = (uint)Counter.Increment() - 1;
                        if (i >= UserSet.Count)
                            break;

                        // Get puid and UODB partition (hash)
                        ulong puid = UserSet.IndexToPuid(i);

                        // BulkUserSet will generate a unique set of these based on the
                        // puid that will be unique to the system
                        string gamertag = UserSet.IndexToGamertag(i);
                        ulong machinePuid = UserSet.IndexToMachinePuid(i);
                        ulong webId = UserSet.IndexToWebId(i);
                        byte[] webIdBytes = UserSet.WebIdToBytes(webId);

                        // do the name reservation and key generation
                        // Since we're optimistic, if we get a SQL exception, just try again
                        // a few times.  If we still fail after that, give up on this user
                        int nNumTries = 0;
                        const int kMaxTries = 3;
                        bool bFailed = false;
                        do
                        {
                            try
                            {
                                // The asserts here are to catch the weird reverse-byte puid/gamertag problem
                                // we've been seeing.
                                System.Diagnostics.Debug.Assert(String.Compare(gamertag, UserSet.IndexToGamertag(i)) == 0, "Gamertags don't match");

                                bFailed = false;
                                // user hash!
                                System.Diagnostics.Debug.Assert((puid & 0xFFFF000000000000) == 0x0009000000000000, "ReserveName: puid & 0x0009");
                                ReserveName(gamertag, puid, machinePuid, CalcRawKeyFromGamertag);

                                int partnerOptIn = 0;
                                if (IsPartnerOptIn) partnerOptIn = 1;

                                if (IsXenon)
                                {
                                    // xenon
                                    System.Diagnostics.Debug.Assert((puid & 0xFFFF000000000000) == 0x0009000000000000, "CreateXeUserDirect: puid & 0x0009");
                                    CreateXeUserDirectExt(puid, webId, randGen.NextPuid(), UserSet.Country, gamertag, UserSet.OfferId, partnerOptIn, UserSet.OfferInstanceIdGuid, UserSet.OfferIdGuid);
                                }
                                else
                                {
                                    // xbox1
                                    System.Diagnostics.Debug.Assert((puid & 0xFFFF000000000000) == 0x0009000000000000, "CreateUserDirect: puid & 0x0009");
                                    CreateUserDirectExt(gamertag, puid, randGen.NextPuid(), UserSet.OfferId, UserSet.Country, partnerOptIn, UserSet.OfferInstanceIdGuid, UserSet.OfferIdGuid);
                                }
                                System.Diagnostics.Debug.Assert((puid & 0xFFFF000000000000) == 0x0009000000000000, "AddUserByPassport: puid & 0x0009");
                                AddUserByPassport(puid, webId);
                            }
                            catch (SqlException sqlX)
                            {
                                // SqlConnections do not stay open if the class of error
                                // is above 19. Errors below 17 are user generated and
                                // will not be corrected by a retry.
                                //
                                // Retrying if ReserveName suceeded will result in an automatic failure
                                if (sqlX.Class > 16 && sqlX.Class < 20)
                                {
                                    Global.RO.Error(sqlX.Message);
                                    nNumTries++;
                                    bFailed = true;
                                }
                                else
                                {
                                    // re-throw the exception
                                    //throw;
                                    // don't throw, instead just log an error message
                                    Global.RO.Error("SqlException: " + sqlX.Message);
                                }
                            }
                            catch (Exception ex)
                            {
                                Global.RO.Error("Exception: " + ex.Message);
                                Global.RO.Error("Stack:  " + ex.StackTrace);
                            }
                        } while (bFailed && nNumTries < kMaxTries);

                        // Don't update the number of created users if we actually didn't
                        if (!bFailed)
                            UsersCreated++;
                    }
                }
                catch (Exception ex)
                {
                    LastEx = ex;
                    StopEvent.Set();
                }
            }
        }
        public static void InsertUserMachineHistoryDetails(ulong userPuid, ulong machinePuid)
        {
            using (WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITEONLY_COMMANDTYPE))
            {
                ws.ClearParameters();
                ws.PartitionType = WstPartitionType.Logical;
                int hashbucket=ws.SetHashVal(userPuid);
                string sql = "insert into t_user_machine_history values(" + "0x"+userPuid.ToString("X") + "," + "0x"+machinePuid.ToString("X") + ",GETUTCDATE(),GETUTCDATE(),1,GETUTCDATE()," + hashbucket.ToString() + ",NULL)";
                ws.CommandSql = sql;

                ws.ExecuteNonQuery();
            }
        }
        public static uint CheckOfflineXuid(ulong xuid)
        {
            uint hr = (uint)HResult.S_OK;

            if (xuid == 0)
            {
                // don't bother checking, it's always ok
                return hr;
            }

            using (WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITEONLY_COMMANDTYPE))
            {
                ws.StoredProc = "p_xuacs_check_offline_xuid";
                ws.SetHashVal(xuid);

                ws.AddParameter("@bi_offline_xuid", xuid);
                ws.AddParameter(ParamType.RETVAL, "@RETVAL", 0);

                ws.ExecuteNonQuery();

                hr = (uint)ws.GetIntParameter("@RETVAL");
            }

            return hr;
        }

    public static uint MoveSubscription
    (
      ulong userId
    , ulong baseOfferId
    , string instanceId
    , ulong newOfferId
    , string newInstanceId
    , Guid? catalogOfferId
    , Guid? catalogOfferInstanceId
    , DateTime moveDate
    )
        {

            WSClient ws = null;
            uint hr = 0;

            try
            {
                ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITEONLY_COMMANDTYPE);
                ws.SetHashVal((long)userId);
                ws.StoredProc = "dbo.p_xbos_move_subscription";

                // intput and output params
                ws.AddParameter(ParamType.RETVAL, "@RETVAL", 0);
                ws.AddParameter(ParamType.INPUT, "@bi_user_puid", userId);
                ws.AddParameter(ParamType.INPUT, "@bi_old_offer_id", baseOfferId);
                ws.AddParameter(ParamType.INPUT, "@vc_old_instance_id", instanceId, instanceId.Length);
                ws.AddParameter(ParamType.INPUT, "@bi_new_offer_id", newOfferId);
                ws.AddParameter(ParamType.INPUT, "@vc_new_instance_id", newInstanceId, newInstanceId.Length);
                ws.AddParameter(ParamType.INPUT, "@dt_movedate", moveDate);


                if (catalogOfferId.HasValue)
                {
                    ws.AddParameter(ParamType.INPUT, "@uid_catalogoffer_id", catalogOfferId.Value);
                }
                if (catalogOfferInstanceId.HasValue)
                {
                    ws.AddParameter(ParamType.INPUT, "@uid_catalog_offerinstance_id", catalogOfferInstanceId.Value);
                }


                // call the procedure
                ws.ExecuteNonQuery();

                hr = (uint)ws.GetIntParameter("@RETVAL");
            }
            finally
            {
                if (ws != null)
                {
                    ws.Close();
                    ws = null;
                }
            }

            return hr;
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\Database\StoredProcs.cs ===
using System;
using System.Text;
using System.Reflection;

namespace ServerTestFramework.Database
{

    public class       SpGetBillingNotifications : StoredProc
    {
        public ulong bi_user_puid = 0;
        public byte[] ti_message_all = new byte[1];
        public System.DateTime dt_notification_datetime;

        public override string GenerateExecString()
        {
            StringBuilder   SB = new StringBuilder("exec p_xuacs_user_billing_notifications_get");
            SPExecBuilder SP = BuildSP();
            SP.Add(bi_user_puid);
            SP.Add(ti_message_all);
            SP.Add(dt_notification_datetime);
            SB.Append(SP.ToString());
            return SB.ToString();
        }
    }
    
    public class		SpTitleVersions : StoredProc
	{
		public uint		titleId=0;
		public int		titleBaseVersion=0;
		public int		titleUpdateVersion=0;
		public int		versionFlag=0;

		public override	 string GenerateExecString()
		{
			StringBuilder	SB=new StringBuilder("exec p_svc_insert_title_versions ");
			SPExecBuilder	SP=BuildSP();
			SB.Append(SP.ToString());
			return SB.ToString();
		}
	}

	public class		SpTitleUpdatePackages : StoredProc
	{
		public uint		titleId=0;
		public int		titleBaseVersion=0;
		public int		titleUpdateVersion=0;
		public int		packageSize=0;
		public int		installSize=0;
		public byte[]	updateKey=new byte[16]; 
		public byte[]	publicKey=new byte[284];
		
		public override	 string GenerateExecString()
		{
			StringBuilder	SB=new StringBuilder("exec p_svc_insert_title_update_packages ");
			SPExecBuilder	SP=BuildSP();
			SB.Append(SP.ToString());
			return SB.ToString();
		}
	}

	public class		SpOfferLocation : StoredProc
	{
		public ulong	offerId=0;
		public int		locationRank=0;
		public string	XRL;

		public override	 string GenerateExecString()
		{
			StringBuilder	SB=new StringBuilder("exec p_svc_insert_offer_locations ");
			SPExecBuilder	SP=BuildSP();
			SB.Append(SP.ToString());
			return SB.ToString();
		}
	}

	public class		SpTitleUpdateLocations : StoredProc
	{
		public uint		titleId=0;
		public int		titleBaseVersion=0;
		public int		titleUpdateVersion=0;
		public int		locationRank=0;
		public string	XRL;
		
		public override	 string GenerateExecString()
		{
			StringBuilder	SB=new StringBuilder("exec p_svc_insert_title_update_locations ");
			SPExecBuilder	SP=BuildSP();
			SB.Append(SP.ToString());
			return SB.ToString();
		}
	}

	public class		SpOfferRegion : StoredProc
	{
		public ulong	offerId=0;
		public byte		countryId=103;
		public string	billingOfferId="JACARIZRAZITISAMPION";			// 36
		public int		priceWhole=1;
		public int		priceFractional=0;
		public short	specificOfferDetails=0;
		
		public override	 string GenerateExecString()
		{
			StringBuilder	SB=new StringBuilder("exec p_svc_insert_offer_regions ");
			SPExecBuilder	SP=new SPExecBuilder();
			SP.Add(offerId);
			SP.Add(countryId);
			SP.Add(billingOfferId);
			SP.Add(priceWhole);
			SP.Add(priceFractional);
			SP.Add(specificOfferDetails);
			SB.Append(SP.ToString());
			return SB.ToString();
		}
	}

	public class		SpOfferDescription : StoredProc
	{
		public ulong		offerId=0;
		public byte			[]blob=new byte[128];
		public int			descriptionIndex=0;

		public override	 string GenerateExecString()
		{
			StringBuilder	SB=new StringBuilder("exec p_svc_insert_offer_descriptions ");
			SPExecBuilder	SP=new SPExecBuilder();
			SP.Add(offerId);
			SP.Add(blob);
			SP.Add(descriptionIndex);
			SB.Append(SP.ToString());
			return SB.ToString();
		}
	}

    public class SpXbox1OfferEnum : StoredProc
    {
        public byte countryid = 103;
        public uint titleID = 0;
        public int offeringtype = -1;
        public int descriptionindex = 0;
        public int bitfilter = -1;
        public int esrbrating = 0;
        
        public override string GenerateExecString()
        {
            StringBuilder SB = new StringBuilder("exec p_xbos_enumerate ");
            SPExecBuilder SP = new SPExecBuilder();
            SP.Add(countryid);
            SP.Add(titleID);
            SP.Add(offeringtype);
            SP.Add(descriptionindex);
            SP.Add(bitfilter);
            SP.Add(esrbrating);
            SB.Append(SP.ToString());
            return SB.ToString();
        }
    }


	public class		SpOfferDescriptionDetails : StoredProc
	{
		public ulong	offerId=0;
		public byte[]	detailsBlob=new byte[16]; 
		public int		descriptionIndex=0;
		public int		order=0;
		
		public override	 string GenerateExecString()
		{
			StringBuilder	SB=new StringBuilder("exec p_svc_insert_offer_description_details ");
			SPExecBuilder	SP=BuildSP();
			SB.Append(SP.ToString());
			return SB.ToString();
		}
	}

	public class		SpTitle : StoredProc
	{
		public uint		titleId=0x524D0000;
		public int		initialVersion=0;

		public override	 string GenerateExecString()
		{
			StringBuilder	SB=new StringBuilder("exec p_svc_insert_titles ");
			SPExecBuilder	SP=new SPExecBuilder();
			SP.Add(titleId);
			SP.Add(initialVersion);
			SB.Append(SP.ToString());
			return SB.ToString();
		}
	}

	public class		SpOffer : StoredProc
	{
		public const uint PER_USER_RIGHTS     =    0x001;
		public const uint PER_MACHINE_RIGHTS  =    0x002;
		public const uint ONLY_PURCHASE_ONCE  =    0x100;        

		public uint		titleId=0;
		public ulong	offerId=0; //                   bigint,
		public int		ESRBid=0; //                     int,
		public bool		cancelable=false; //                  bit,
		public int		packageSize=128; //                int,
		public int		installSize=256; //                int,
		public byte[]	symKey=new byte[16]; //                    varbinary(16),
		public int		bitFilter=1; //                   int,
		public string	billingSvcComponentId=String.Empty; //    nvarchar(36),
		public int		offerTypeId=1;
		public int		offerFrequencyId=0;
		public DateTime startDate=DateTime.Now.AddYears(-1);
		public DateTime endDate=DateTime.Now.AddYears(1);
		public string	friendlyName="FakeOffer"; //150
		public byte[]	publicKey=new byte[284]; // 284
		public uint		policyFlags=PER_USER_RIGHTS;

		public override string GenerateExecString()
		{
			StringBuilder	SB=new StringBuilder("exec p_svc_insert_offers ");
			SPExecBuilder	SP=new SPExecBuilder();
			SP.Add(titleId);
			SP.Add(offerId);
			SP.Add(ESRBid);
			SP.Add(cancelable);
			SP.Add(packageSize);
			SP.Add(installSize);
			SP.Add(symKey);
			SP.Add(bitFilter);
			SP.Add(billingSvcComponentId);
			SP.Add(offerTypeId);
			SP.Add(offerFrequencyId);
			SP.Add(startDate);
			SP.Add(endDate);
			SP.Add(friendlyName);
			SP.Add(publicKey);
			SP.Add(policyFlags);
			SB.Append(SP.ToString());
			return SB.ToString();
		}
	}

	public class SpGameSaveConfig : StoredProc
	{
		public uint		titleId;
		public string   xmlConfig;
		public string   xdkVersion;

		public override	 string GenerateExecString()
		{
			StringBuilder	SB=new StringBuilder("exec p_game_save_config ");
			SPExecBuilder	SP=new SPExecBuilder();
			SP.Add(titleId);
			SP.Add(xmlConfig);
			SP.Add(xdkVersion);
			SB.Append(SP.ToString());
			return SB.ToString();
		}
	}

	public class SpGameGetConfig : StoredProc
	{
		public uint titleId;

		public override string GenerateExecString()
		{
			StringBuilder SB = new StringBuilder("exec p_game_get_config ");
			SPExecBuilder SP = new SPExecBuilder();
			SP.Add(titleId);
			SB.Append(SP.ToString());
			return SB.ToString();
		}
	}

    public class SPUpdateUserLicenses : StoredProc
    {
        public ulong OldConsoleId;
        public ulong NewConsoleId;

        public override string GenerateExecString()
        {
            StringBuilder sb = new StringBuilder("exec p_svc_update_user_licenses ");
            SPExecBuilder sp = new SPExecBuilder();
            sp.Add(OldConsoleId);
            sp.Add(NewConsoleId);
            sb.Append(sp.ToString());
            return sb.ToString();
        }
    }
	
	public abstract class StoredProc
	{
		internal protected SPExecBuilder	BuildSP()
		{
			SPExecBuilder	SP=new SPExecBuilder();
			FieldInfo[] fields = GetType().GetFields(BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly);
			for (int i = 0; i < fields.Length; i++)
			{
				FieldInfo field = fields[i];
				SP.Add(field.GetValue(this));
			}
			return SP;
		}
		public abstract string	GenerateExecString();
	}
		
	public class SPExecBuilder
	{
		StringBuilder SB=new StringBuilder(256);
		public override string ToString()
		{
			string ret=SB.ToString();
			int lastComma=ret.LastIndexOf(",");
			if (lastComma>0)
				return ret.Substring(0,lastComma);
			return ret;
		}
		public void Add(object o)
		{
			if (o is System.Int32)
			{
				Add((int) o);
				return;
			}
			if (o is System.UInt32)
			{
				Add((uint) o);
				return;
			}
			if (o is System.Int64)
			{
				Add((long) o);
				return;
			}
			if (o is System.UInt64)
			{
				Add((ulong) o);
				return;
			}
			if (o is System.Boolean)
			{
				Add((bool) o);
				return;
			}
			if (o is System.String)
			{
				Add((string) o);
				return;
			}
			if (o.GetType().IsArray)
			{
				Add((byte[]) o);
				return;
			}
			throw new Exception("SPExecBuilder can't process type "+o.GetType().ToString());
		}

		public void Add(int i)
		{
			SB.Append(i.ToString()+", ");
		}
		public void Add(uint i)
		{
			SB.Append(i.ToString()+", ");
		}
		public void Add(bool i)
		{
			SB.Append((i?1:0).ToString()+", ");
		}
		public void Add(long i)
		{
			SB.Append(i.ToString()+", ");
		}
		public void Add(ulong i)
		{
			SB.Append(i.ToString()+", ");
		}
		public void Add(string s)
		{
			SB.Append("'"+s+"', ");
		}
		public void Add(DateTime t)
		{
			string s=t.ToString();
			if (s.Length<2)
			{
				// get rid of the terminating ,
				s=s.Substring(0,s.Length-2);
			}
			Add(s);
		}
		public void Add(byte []b)
		{
			SB.Append("0x");
			foreach (byte bt in b)
				SB.Append(bt.ToString("X02"));
			SB.Append(", ");
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\Database\WebstoreDB.cs ===
using System;
using System.Collections;

using Microsoft.Webstore.WstClient;

using xonline.common.sql.webstore;
using xonline.common.config;

namespace ServerTestFramework.Database
{
    /// <summary>
    /// Base class for WebStore databases - taking into account partitioned tables
    /// </summary>
    public static class WebstoreDB
    {
        // Using Webstore. select statement only, can set to AnyPartition by making hash to null
        public static object ExecuteSQLScalar(string dbWebstoreApp, string sql, object hash)
        {
            using (WSClient ws = new WSClient(dbWebstoreApp, CmdType.WRITETHENREAD_COMMANDTYPE))
            {
                ws.PartitionType = WstPartitionType.Logical;
                if (hash == null)
                    ws.Partition = WstCommand.AnyPartition;
                else
                {
                    SetHashValue(ws, hash);
                }
                ws.CommandSql = sql;

                return ws.ExecuteScalar();
            }
        }

        // Using Webstore. WRITEONLY command type, can set to All Physical Partitions by makeing hash to null
        public static int ExecuteSQLNonQuery(string dbWebstoreApp, string sql, object hash)
        {
            return ExecuteSQLNonQuery(dbWebstoreApp, sql, hash, 0);
        }

        // Using Webstore. WRITEONLY command type, can set to All Physical Partitions by makeing hash to null
        public static int ExecuteSQLNonQuery(string dbWebstoreApp, string sql, object hash, int timeoutInS)
        {
            int RowsAffected = 0;

            using (WSClient ws = new WSClient(dbWebstoreApp, CmdType.WRITEONLY_COMMANDTYPE))
            {
                if (timeoutInS!=0)
                {
                    ws.Command.CommandTimeout=timeoutInS;
                }

                if (hash != null)
                {
                    ws.PartitionType = WstPartitionType.Logical;
                    SetHashValue(ws, hash);
                    ws.CommandSql = sql;

                    RowsAffected = ws.ExecuteNonQuery();
                    return RowsAffected;
                }

                for (int p = 0; p < ws.PhysicalPartitions; p++)
                {
                    ws.ClearParameters();
                    ws.PhysicalPartition = p;
                    ws.CommandSql = sql;

                    RowsAffected += ws.ExecuteNonQuery();
                }
                return RowsAffected;    // the total number from all physical partitions
            }
        }

        // Using Webstore. "select count" statement only.  Sums together the scalar returned 
        // from each physical partition and returns that.
        public static uint ExecuteSQLSelectCount(string dbWebstoreApp, string sql)
        {
            uint count=0;

            using (WSClient ws = new WSClient(dbWebstoreApp, CmdType.WRITETHENREAD_COMMANDTYPE))
            {
                ws.CommandSql = sql;

                for (int p = 0; p < ws.PhysicalPartitions; p++)
                {
                    ws.PhysicalPartition = p;

                    object res=ws.ExecuteScalar();
                    count+=(uint)((int)res);
                }
            }

            return count;
        }

        // get the total number of physical partitions
        public static int WstPhysicalPartitionCount(string dbWebstoreApp)
        {
            using (WSClient ws = new WSClient(dbWebstoreApp, CmdType.WRITETHENREAD_COMMANDTYPE))
            {
                return ws.PhysicalPartitions;
            }
        }

        // get the logical partition from hash (si_hash_bucket)
        public static int GetHashBucket(string dbWebstoreApp, object hash)
        {
            using (WSClient ws = new WSClient(dbWebstoreApp, CmdType.WRITETHENREAD_COMMANDTYPE))
            {
                ws.PartitionType = WstPartitionType.Logical;
                SetHashValue(ws, hash);

                return ws.Partition;
            }
        }

        public static void SetHashValue(WSClient ws, object hash)
        {
            Type t = hash.GetType();
            if (t == typeof(ulong))
                ws.SetHashVal((ulong)hash);
            else if (t == typeof(long))
                ws.SetHashVal((long)hash);
            else if (t == typeof(string))
                ws.SetHashVal((string)hash);
            else if (t == typeof(System.Guid))
                ws.SetHashVal((System.Guid)hash);
            else
                throw new UnexpectedTestResultException("Only ulong, long, string, and guid types are supported for hash values.");
        }

        // for speical tables like t_dmp_purchase_transaction_music_details and t_dmp_purchase_transaction_music_items,
        // the hash column is userPuid, but it is not a column in the table, instead it is borrowed from another table, for this
        // case, t_dmp_purchase_transactions table. So we add the hashCol as the second input parameter here
        public static int ExecuteSQLSelect(string dbWebstoreApp, UodbTable dbtable, object hashCol)
        {
            object hash;
            if (hashCol != null)
                hash = hashCol;
            else
                hash = GetHashFromUodbTable(dbtable);
            Global.RO.Debug("Executing UodbTable SELECT: {0}", dbtable.GetSqlSelectStatement());
            string sql = dbtable.GetSqlSelectStatement();

            using (WSClient ws = new WSClient(dbWebstoreApp, CmdType.WRITETHENREAD_COMMANDTYPE))
            {
                ws.PartitionType = WstPartitionType.Logical;
                if (hash == null)
                    ws.Partition = WstCommand.AnyPartition;
                else
                {
                    SetHashValue(ws, hash);
                }
                ws.CommandSql = sql;

                using (WstDataReader myDataReader = ws.Execute())
                {
                    // Read only the first row for now
                    int rowcount = 0;
                    if (myDataReader.Read())
                    {
                        rowcount++;
                        for (int i = 0; i < myDataReader.FieldCount; i++)
                        {
                            string fieldname = myDataReader.GetName(i);
                            object fieldvalue = myDataReader.GetValue(i);
                            dbtable.SetProperty(fieldname, fieldvalue);
                        }
                    }

                    // See if more than 1 row was returned
                    if (rowcount == 1)
                    {
                        while (myDataReader.Read())
                            rowcount++;
                    }

                    myDataReader.Close();
                    return rowcount;
                }
            }
        }

        public static object GetHashFromUodbTable(UodbTable dbtable)
        {
            object hash = null;
            if (dbtable.IsPartitioned)
            {
                // So t_vouchers hashes based on the token hash, which is a byte array.
                // But it doesn't work like the Hasher class expects -- it just uses the
                // first 8 bytes of the byte array as-is.  I don't want to change the
                // behavior of Hasher for binary data in case it would break other things,
                // so we're going to have to special-case the vouchers here. See
                // DbpScriptEngine.cs in dbposter for additional details.
                if (dbtable.TableName == "t_vouchers" || dbtable.TableName == "t_pc_accounts" || dbtable.TableName == "t_vouchers_used")
                {
                    byte[] voucher = (byte[])dbtable.PartitioningValue;
                    hash = BitConverter.ToInt64(voucher, 0);
                }
                else
                {
                    hash = dbtable.PartitioningValue;
                }
            }

            return hash;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\Database\webdb.cs ===
/* Npdb wrapper class */

using System;
using System.Data;
using System.Data.SqlTypes;
using System.Data.SqlClient;
using System.Data.Common;
using System.Collections;
using System.Text;
using System.Runtime.InteropServices;
using ServerTestFramework.LiveService;
using ServerTestFramework.Utilities;

namespace ServerTestFramework.Database
{

    public class WebdbTitleInformation
    {
        public UInt32   TitleId;
        public byte     ESRBRating;
        public Int32    ClusterId;
        public string   DefaultLocale;
        public DateTime Changed;
        public WebdbTitleNameCollection TitleNames;

        public override bool Equals(object obj)
        {
            if (obj is WebdbTitleInformation)
            {
                return
                    (
                    (obj as WebdbTitleInformation).TitleId == TitleId &&
                    (obj as WebdbTitleInformation).ESRBRating == ESRBRating &&
                    (obj as WebdbTitleInformation).ClusterId == ClusterId &&
                    (obj as WebdbTitleInformation).DefaultLocale == DefaultLocale
                    );
            }

            return false;
        }

        public override int GetHashCode()
        {
            return base.GetHashCode();
        }

        public override string ToString()
        {
            return String.Format("TitleId[0x{0:x}] ESRBRating[{1}] ClusterId[{2}] DefaultLocale[{3}] Changed[{4}]",
                TitleId, ESRBRating, ClusterId, DefaultLocale, Changed);
        }
    }

    public class WebdbTitleName
    {
        public UInt32   TitleId;
        public string   Locale;
        public string   DisplayName;

        public override bool Equals(object obj)
        {
            if (obj is WebdbTitleName)
            {
                return
                    (
                    (obj as WebdbTitleName).TitleId == TitleId &&
                    (obj as WebdbTitleName).Locale == Locale &&
                    (obj as WebdbTitleName).DisplayName == DisplayName
                    );
            }

            return false;
        }

        public override int GetHashCode()
        {
            return base.GetHashCode();
        }

        public override string ToString()
        {
            return String.Format("TitleId[0x{0:x}] Locale[{1}] DisplayName[{2}]",
                TitleId, Locale, DisplayName);
        }
    }

    public class WebdbTitleNameCollection : CollectionBase
    {
        public WebdbTitleName this[int index]
        {
            get { return List[index] as WebdbTitleName; }
            set { List[index] = value; }
        }

        public int Add(WebdbTitleName val)
        {
            return List.Add(val);
        }

        public bool Contains(WebdbTitleName val)
        {
            return List.Contains(val);
        }

        public void Remove(WebdbTitleName val)
        {
            List.Remove(val);
        }
    }

    public class WebdbLeaderboardName
    {
        public UInt32   TitleId;
        public Int32    LeaderboardId;
        public string   Locale;
        public string   DisplayName;
        public DateTime Changed;

        public override bool Equals(object obj)
        {
            if (obj is WebdbLeaderboardName)
            {
                return
                    (
                    (obj as WebdbLeaderboardName).TitleId == TitleId &&
                    (obj as WebdbLeaderboardName).LeaderboardId == LeaderboardId &&
                    (obj as WebdbLeaderboardName).Locale == Locale &&
                    (obj as WebdbLeaderboardName).DisplayName == DisplayName
                    );
            }

            return false;
        }

        public override int GetHashCode()
        {
            return base.GetHashCode();
        }

        public override string ToString()
        {
            return String.Format("TitleId[0x{0:x}] LeaderboardId[{1}] Locale[{2}] DisplayName[{3}] Changed[{4}]",
                TitleId, LeaderboardId, Locale, DisplayName, Changed);
        }
    }

    public class WebdbLeaderboardNameCollection : CollectionBase
    {
        public WebdbLeaderboardName this[int index]
        {
            get { return List[index] as WebdbLeaderboardName; }
            set { List[index] = value; }
        }

        public int Add(WebdbLeaderboardName val)
        {
            return List.Add(val);
        }

        public bool Contains(WebdbLeaderboardName val)
        {
            return List.Contains(val);
        }

        public void Remove(WebdbLeaderboardName val)
        {
            List.Remove(val);
        }
    }

    public class WebdbRawAttribute
    {
        public UInt32   TitleId;
        public Int32    LeaderboardId;
        public Int32    RawAttributeId;
        public bool     IsPuidAttribute;
        public DateTime Changed;

        public override bool Equals(object obj)
        {
            if (obj is WebdbRawAttribute)
            {
                return
                    (
                    (obj as WebdbRawAttribute).TitleId == TitleId &&
                    (obj as WebdbRawAttribute).LeaderboardId == LeaderboardId &&
                    (obj as WebdbRawAttribute).RawAttributeId == RawAttributeId &&
                    (obj as WebdbRawAttribute).IsPuidAttribute == IsPuidAttribute
                    );
            }

            return false;
        }

        public override int GetHashCode()
        {
            return base.GetHashCode();
        }

        public override string ToString()
        {
            return String.Format("TItleId[0x{0:x}] LeaderboardId[{1}] RawAttributeId[{2}] IsPuidAttribute[{3}] Changed[{4}]",
                TitleId, LeaderboardId, RawAttributeId, IsPuidAttribute, Changed);
        }
    }

    public class WebdbRawAttributeCollection : CollectionBase
    {
        public WebdbRawAttribute this[int index]
        {
            get { return List[index] as WebdbRawAttribute; }
            set { List[index] = value; }
        }

        public int Add(WebdbRawAttribute val)
        {
            return List.Add(val);
        }

        public bool Contains(WebdbRawAttribute val)
        {
            return List.Contains(val);
        }

        public void Remove(WebdbRawAttribute val)
        {
            List.Remove(val);
        }
    }

    public class WebdbFormattedAttribute
    {
        public UInt32   TitleId;
        public Int32    LeaderboardId;
        public string   FriendlyName;
        public Int32    Type;
        public string   Formula;
        public WebdbFormattedAttributeNameCollection Names;
        public DateTime Changed;

        public override bool Equals(object obj)
        {
            if (obj is WebdbFormattedAttribute)
            {
                return
                    (
                    (obj as WebdbFormattedAttribute).TitleId == TitleId &&
                    (obj as WebdbFormattedAttribute).LeaderboardId == LeaderboardId &&
                    (obj as WebdbFormattedAttribute).FriendlyName == FriendlyName &&
                    (obj as WebdbFormattedAttribute).Type == Type &&
                    (obj as WebdbFormattedAttribute).Formula == Formula
                    );
            }

            return false;
        }

        public override int GetHashCode()
        {
            return base.GetHashCode();
        }

        public override string ToString()
        {
            return String.Format("TitleId[0x{0:x}] LeaderboardId[{1}] FriendlyName[{2}] Type[{3}] Formula[{4}] Changed[{5}]",
                TitleId, LeaderboardId, FriendlyName, Type, Formula, Changed);
        }
    }

    public class WebdbFormattedAttributeCollection : CollectionBase
    {
        public WebdbFormattedAttribute this[int index]
        {
            get { return List[index] as WebdbFormattedAttribute; }
            set { List[index] = value; }
        }

        public int Add(WebdbFormattedAttribute val)
        {
            return List.Add(val);
        }

        public bool Contains(WebdbFormattedAttribute val)
        {
            return List.Contains(val);
        }

        public void Remove(WebdbFormattedAttribute val)
        {
            List.Remove(val);
        }
    }

    public class WebdbFormattedAttributeName
    {
        public UInt32   TitleId;
        public Int32    LeaderboardId;
        public string   FriendlyName;
        public string   Locale;
        public string   DisplayName;
        public DateTime Changed;

        public override bool Equals(object obj)
        {
            if (obj is WebdbFormattedAttributeName)
            {
                return
                    (
                    (obj as WebdbFormattedAttributeName).TitleId == TitleId &&
                    (obj as WebdbFormattedAttributeName).LeaderboardId == LeaderboardId &&
                    (obj as WebdbFormattedAttributeName).FriendlyName == FriendlyName &&
                    (obj as WebdbFormattedAttributeName).Locale == Locale &&
                    (obj as WebdbFormattedAttributeName).DisplayName == DisplayName
                    );
            }

            return false;
        }

        public override int GetHashCode()
        {
            return base.GetHashCode();
        }

        public override string ToString()
        {
            return String.Format("TitleId[0x{0:x}] LeaderboardId[{1}] FriendlyName[{2}] Locale[{3}] DisplayName[{4}] Changed[{5}]",
                TitleId, LeaderboardId, FriendlyName, Locale, DisplayName, Changed);
        }
    }

    public class WebdbFormattedAttributeNameCollection : CollectionBase
    {
        public WebdbFormattedAttributeName this[int index]
        {
            get { return List[index] as WebdbFormattedAttributeName; }
            set { List[index] = value; }
        }

        public int Add(WebdbFormattedAttributeName val)
        {
            return List.Add(val);
        }

        public bool Contains(WebdbFormattedAttributeName val)
        {
            return List.Contains(val);
        }

        public void Remove(WebdbFormattedAttributeName val)
        {
            List.Remove(val);
        }
    }

    public class WebdbLeaderboard
    {
        public UInt32   TitleId;
        public Int32    LeaderboardId;
        public byte     ResetType;
        public Int32    EntriesPerCacheLine;
        public Int32    ExpirationSeconds;
        public Int32    LeaderboardType;
        public bool     DontList;
        public DateTime Changed;
        public WebdbLeaderboardNameCollection Names;
        public WebdbRawAttributeCollection RawAttributes;
        public WebdbFormattedAttributeCollection FormattedAttributes;
    }

    public class WebdbLeaderboardCollection : CollectionBase
    {
        public WebdbLeaderboard this[int index]
        {
            get { return List[index] as WebdbLeaderboard; }
            set { List[index] = value; }
        }

        public int Add(WebdbLeaderboard val)
        {
            return List.Add(val);
        }

        public bool Contains(WebdbLeaderboard val)
        {
            return List.Contains(val);
        }

        public void Remove(WebdbLeaderboard val)
        {
            List.Remove(val);
        }
    }

    /// <summary>
    /// This is a wrapper class for talking to the WebDB.
    /// </summary>
    [ComVisible(false)]
    public class Webdb: IDisposable
    {
        SqlConnection _conn;
        string _serverName;

        public Webdb()
        {
        }

        public void ConnectToServer(string []serverNames)
        {
            ConnectToServer(serverNames[0]);
        }

        public void ConnectToServer(string serverName)
        {
            try 
            {
                _serverName=serverName;
                _conn = new SqlConnection("server="+_serverName+";database=webdb;Integrated Security=SSPI"); 
                _conn.Open();
            }
            catch(SqlException sqlex)
            {
                throw new DatabaseException(_conn, sqlex);
            }
        }

        public void ConnectToServer()
        {
            ConnectToServer(xonline.common.config.Config.GetServerListByInterface(xonline.common.config.Interface.webdb)[0]);
        }

        public void Close()
        {
            lock(_conn)
            {
                // m_SqlConnection could be null
                if (_conn!=null && _conn.State!=ConnectionState.Closed)
                {
                    _conn.Close();
                    _conn=null;
                }
            }
        }

        public void Dispose()
        {
            Close();
        }

        public SqlDataReader GetTitles()
        {
            lock(_conn)
            {
                SqlDataReader reader = null;

                string sql = @"select ti.i_title_id, tni.vc_display_name 
from t_title_info as ti 
    inner join t_title_name_info as tni on tni.i_title_id=ti.i_title_id and tni.vc_locale_id=ti.vc_default_locale
order by tni.vc_display_name";

                ReadData(sql, out reader);
                return reader;
            }
        }

        /// <summary>
        /// Retrieves the title information from the WebDB, including localized title names.
        /// </summary>
        /// <param name="titleId">Title ID</param>
        /// <returns>A WebdbTitleInformation object describing the title in WebDB.</returns>
        public WebdbTitleInformation GetTitleInformation(uint titleId)
        {
            WebdbTitleInformation ti = null;

            lock(_conn)
            {
                SqlDataReader reader = null;
                SqlCommand command = null;
                SqlParameter param = null;

                command = _conn.CreateCommand();
                command.CommandType = CommandType.StoredProcedure;
                command.CommandText = "p_webdb_tmr_get_title_info";

                param = new SqlParameter();
                param.ParameterName = "@i_title_id";
                param.DbType = DbType.Int32;
                param.Direction = ParameterDirection.Input;
                param.Value = (int)titleId;
                command.Parameters.Add(param);

                reader = command.ExecuteReader();
                try
                {
                    if (reader.Read())
                    {
                        ti = new WebdbTitleInformation();
                        ti.TitleId = (uint)reader.GetInt32(reader.GetOrdinal("i_title_id"));
                        ti.ESRBRating = reader.GetByte(reader.GetOrdinal("ti_esrb_rating"));
                        ti.ClusterId = reader.GetInt32(reader.GetOrdinal("i_cluster_id"));
                        ti.DefaultLocale = reader.GetString(reader.GetOrdinal("vc_default_locale"));
                        ti.Changed = reader.GetDateTime(reader.GetOrdinal("dt_Change_datetime"));
                    }
                }
                finally
                {
                    if (reader != null)
                    {
                        reader.Close();
                    }
                }
            }

            // Get all the localized title strings for this title
            if (ti != null)
            {
                ti.TitleNames = GetTitleNames(titleId);
            }

            return ti;
        }

        /// <summary>
        /// Retrieves all the localized title names for the specified title.
        /// </summary>
        /// <param name="titleId">Title ID</param>
        /// <returns>A collection of WebdbTitleName objects. Null if none exist.</returns>
        public WebdbTitleNameCollection GetTitleNames(uint titleId)
        {
            WebdbTitleNameCollection names = new WebdbTitleNameCollection();

            lock(_conn)
            {
                SqlCommand command = null;
                SqlDataReader reader = null;
                SqlParameter param = null;

                command = _conn.CreateCommand();
                command.CommandType = CommandType.StoredProcedure;
                command.CommandText = "p_webdb_tmr_get_title_name_info";

                param = new SqlParameter();
                param.ParameterName = "@i_title_id";
                param.DbType = DbType.Int32;
                param.Direction = ParameterDirection.Input;
                param.Value = (int)titleId;
                command.Parameters.Add(param);

                reader = command.ExecuteReader();
                try
                {
                    while (reader.Read())
                    {
                        WebdbTitleName name = new WebdbTitleName();
                        name.TitleId = (uint)reader.GetInt32(reader.GetOrdinal("i_title_id"));
                        name.Locale = reader.GetString(reader.GetOrdinal("vc_locale_id"));
                        name.DisplayName = reader.GetString(reader.GetOrdinal("vc_display_name"));
                        names.Add(name);
                    }
                }
                finally
                {
                    if (reader != null)
                    {
                        reader.Close();
                    }
                }
            }

            return names;
        }

        /// <summary>
        /// Retrieves the leaderboard data for the specified title, including all localized names, raw attributes
        /// and formatted attributes.
        /// </summary>
        /// <param name="titleId">Title ID</param>
        /// <returns>A collection of WebdbLeaderboard objects. Null is none exist.</returns>
        public WebdbLeaderboardCollection GetLeaderboards(uint titleId)
        {
            WebdbLeaderboardCollection lbs = new WebdbLeaderboardCollection();

            lock(_conn)
            {
                SqlCommand command = null;
                SqlDataReader reader = null;

                command = _conn.CreateCommand();
                command.CommandType = CommandType.Text;
                command.CommandText = "SELECT * FROM t_leaderboard_info WHERE i_title_id = 0x" + titleId.ToString("x8");

                reader = command.ExecuteReader();
                try
                {
                    while (reader.Read())
                    {
                        WebdbLeaderboard lb = new WebdbLeaderboard();
                        lb.TitleId = (uint)reader.GetInt32(reader.GetOrdinal("i_title_id"));
                        lb.LeaderboardId = reader.GetInt32(reader.GetOrdinal("i_lb_id"));
                        lb.ResetType = reader.GetByte(reader.GetOrdinal("ti_reset_type"));
                        lb.EntriesPerCacheLine = reader.GetInt32(reader.GetOrdinal("i_entries_per_cache_line"));
                        lb.ExpirationSeconds = reader.GetInt32(reader.GetOrdinal("i_expiration_seconds"));
                        lb.LeaderboardType = reader.GetInt32(reader.GetOrdinal("i_lb_type"));
                        lb.DontList = Convert.ToBoolean(reader.GetByte(reader.GetOrdinal("ti_dont_list")));
                        lb.Changed = reader.GetDateTime(reader.GetOrdinal("dt_Change_datetime"));
                        lbs.Add(lb);
                    }
                }
                finally
                {
                    if (reader != null)
                    {
                        reader.Close();
                    }
                }
            }

            // We need to do this down here because each of these methods uses the lock() mechanism.
            if (lbs != null)
            {
                foreach (WebdbLeaderboard lb in lbs)
                {
                    lb.Names = GetLeaderboardNames(lb.TitleId, lb.LeaderboardId);
                    lb.RawAttributes = GetLeaderboardRawAttributes(lb.TitleId, lb.LeaderboardId);
                    lb.FormattedAttributes = GetLeaderboardFormattedAttributes(lb.TitleId, lb.LeaderboardId);
                }
            }

            return lbs;
        }

        /// <summary>
        /// Retrieves the localized names for the specified title and leaderboard.
        /// </summary>
        /// <param name="titleId">Title ID</param>
        /// <param name="leaderboardId">Leaderboard ID</param>
        /// <returns>A collection of WebdbLeaderboardName objects. Null if none exist.</returns>
        public WebdbLeaderboardNameCollection GetLeaderboardNames(uint titleId, int leaderboardId)
        {
            WebdbLeaderboardNameCollection names = new WebdbLeaderboardNameCollection();

            lock(_conn)
            {
                SqlCommand command = null;
                SqlDataReader reader = null;
                SqlParameter param = null;

                command = _conn.CreateCommand();
                command.CommandType = CommandType.StoredProcedure;
                command.CommandText = "p_webdb_tmr_get_lb_name_info";

                param = new SqlParameter();
                param.ParameterName = "@i_title_id";
                param.DbType = DbType.Int32;
                param.Direction = ParameterDirection.Input;
                param.Value = (int)titleId;
                command.Parameters.Add(param);

                param = new SqlParameter();
                param.ParameterName = "@i_lb_id";
                param.DbType = DbType.Int32;
                param.Direction = ParameterDirection.Input;
                param.Value = leaderboardId;
                command.Parameters.Add(param);

                reader = command.ExecuteReader();
                try
                {
                    while (reader.Read())
                    {
                        WebdbLeaderboardName name = new WebdbLeaderboardName();
                        name.TitleId = (uint)reader.GetInt32(reader.GetOrdinal("i_title_id"));
                        name.LeaderboardId = reader.GetInt32(reader.GetOrdinal("i_lb_id"));
                        name.Locale = reader.GetString(reader.GetOrdinal("vc_locale_id"));
                        name.DisplayName = reader.GetString(reader.GetOrdinal("vc_display_name"));
                        name.Changed = reader.GetDateTime(reader.GetOrdinal("dt_Change_datetime"));
                        names.Add(name);
                    }
                }
                finally
                {
                    if (reader != null)
                    {
                        reader.Close();
                    }
                }
            }

            return names;
        }

        /// <summary>
        /// Retrieves the raw attributes for the specified leaderboard
        /// </summary>
        /// <param name="titleId">Title ID</param>
        /// <param name="leaderboardId">Leaderboard ID</param>
        /// <returns>A collection of WebdbRawAttributes object. Null if none exist.</returns>
        public WebdbRawAttributeCollection GetLeaderboardRawAttributes(uint titleId, int leaderboardId)
        {
            WebdbRawAttributeCollection attrs = new WebdbRawAttributeCollection();

            lock(_conn)
            {
                SqlCommand command = null;
                SqlDataReader reader = null;
                SqlParameter param = null;

                command = _conn.CreateCommand();
                command.CommandType = CommandType.StoredProcedure;
                command.CommandText = "p_webdb_tmr_get_raw_attribute_info";

                param = new SqlParameter();
                param.ParameterName = "@i_title_id";
                param.DbType = DbType.Int32;
                param.Direction = ParameterDirection.Input;
                param.Value = (int)titleId;
                command.Parameters.Add(param);

                param = new SqlParameter();
                param.ParameterName = "@i_lb_id";
                param.DbType = DbType.Int32;
                param.Direction = ParameterDirection.Input;
                param.Value = leaderboardId;
                command.Parameters.Add(param);

                reader = command.ExecuteReader();
                try
                {
                    while (reader.Read())
                    {
                        WebdbRawAttribute attr = new WebdbRawAttribute();
                        attr.TitleId = (uint)reader.GetInt32(reader.GetOrdinal("i_title_id"));
                        attr.LeaderboardId = reader.GetInt32(reader.GetOrdinal("i_lb_id"));
                        attr.RawAttributeId = reader.GetInt32(reader.GetOrdinal("i_raw_attribute_id"));
                        attr.IsPuidAttribute = Convert.ToBoolean(reader.GetByte(reader.GetOrdinal("ti_puid_attribute")));
                        attr.Changed = reader.GetDateTime(reader.GetOrdinal("dt_Change_datetime"));
                        attrs.Add(attr);
                    }
                }
                finally
                {
                    if (reader != null)
                    {
                        reader.Close();
                    }
                }
            }

            return attrs;
        }

        /// <summary>
        /// Retrieves the formatted attributes for the specified leaderboard, including the localized
        /// formatted attribute names.
        /// </summary>
        /// <param name="titleId">Title ID</param>
        /// <param name="leaderboardId">Leaderboard ID</param>
        /// <returns>A collection of WebdbFormattedAttribute objects. Null if none exist.</returns>
        public WebdbFormattedAttributeCollection GetLeaderboardFormattedAttributes(uint titleId, int leaderboardId)
        {
            WebdbFormattedAttributeCollection attrs = new WebdbFormattedAttributeCollection();

            lock(_conn)
            {
                SqlCommand command = null;
                SqlDataReader reader = null;

                command = _conn.CreateCommand();
                command.CommandType = CommandType.Text;
                command.CommandText = "SELECT * FROM t_leaderboard_formatted_attribute_info WHERE i_title_id = 0x" + titleId.ToString("x8") +
                    " AND i_lb_id = " + leaderboardId.ToString();

                reader = command.ExecuteReader();
                try
                {
                    if (reader.HasRows)
                    {
                        attrs = new WebdbFormattedAttributeCollection();
                        while (reader.Read())
                        {
                            WebdbFormattedAttribute attr = new WebdbFormattedAttribute();
                            attr.TitleId = (uint)reader.GetInt32(reader.GetOrdinal("i_title_id"));
                            attr.LeaderboardId = reader.GetInt32(reader.GetOrdinal("i_lb_id"));
                            attr.FriendlyName = reader.GetString(reader.GetOrdinal("vc_name"));
                            attr.Type = reader.GetInt32(reader.GetOrdinal("i_type"));
                            attr.Formula = reader.GetString(reader.GetOrdinal("vc_formula"));
                            attr.Changed = reader.GetDateTime(reader.GetOrdinal("dt_Change_datetime"));
                            attrs.Add(attr);
                        }
                    }
                }
                finally
                {
                    if (reader != null)
                    {
                        reader.Close();
                    }
                }
            }

            foreach (WebdbFormattedAttribute attr in attrs)
            {
                attr.Names = GetLeaderboardFormattedAttributeNames(attr.TitleId, attr.LeaderboardId, attr.FriendlyName);
            }

            return attrs;
        }

        /// <summary>
        /// Retrieves the localized names for a formatted attribute on the specified leaderboard.
        /// </summary>
        /// <param name="titleId">Title ID</param>
        /// <param name="leaderboardId">Leaderboard ID</param>
        /// <param name="friendlyName">Friendly name of the formatted attribute</param>
        /// <returns>A collection of WebdbFormattedAttributeName objects. Null if none exist.</returns>
        public WebdbFormattedAttributeNameCollection GetLeaderboardFormattedAttributeNames(uint titleId, int leaderboardId, string friendlyName)
        {
            WebdbFormattedAttributeNameCollection names = new WebdbFormattedAttributeNameCollection();

            lock(_conn)
            {
                SqlCommand command = null;
                SqlDataReader reader = null;
                SqlParameter param = null;

                command = _conn.CreateCommand();
                command.CommandType = CommandType.StoredProcedure;
                command.CommandText = "p_webdb_tmr_get_attribute_name_info";

                param = new SqlParameter();
                param.ParameterName = "@i_title_id";
                param.DbType = DbType.Int32;
                param.Direction = ParameterDirection.Input;
                param.Value = (int)titleId;
                command.Parameters.Add(param);

                param = new SqlParameter();
                param.ParameterName = "@i_lb_id";
                param.DbType = DbType.Int32;
                param.Direction = ParameterDirection.Input;
                param.Value = leaderboardId;
                command.Parameters.Add(param);

                param = new SqlParameter();
                param.ParameterName = "@vc_name";
                param.DbType = DbType.StringFixedLength;
                param.Size = 8;
                param.Direction = ParameterDirection.Input;
                param.Value = friendlyName;
                command.Parameters.Add(param);

                reader = command.ExecuteReader();
                try
                {
                    while (reader.Read())
                    {
                        WebdbFormattedAttributeName name = new WebdbFormattedAttributeName();
                        name.TitleId = (uint)reader.GetInt32(reader.GetOrdinal("i_title_id"));
                        name.LeaderboardId = reader.GetInt32(reader.GetOrdinal("i_lb_id"));
                        name.FriendlyName = reader.GetString(reader.GetOrdinal("vc_name"));
                        name.Locale = reader.GetString(reader.GetOrdinal("vc_locale_id"));
                        name.DisplayName = reader.GetString(reader.GetOrdinal("vc_display_name"));
                        name.Changed = reader.GetDateTime(reader.GetOrdinal("dt_Change_datetime"));
                        names.Add(name);
                    }
                }
                finally
                {
                    if (reader != null)
                    {
                        reader.Close();
                    }
                }
            }

            return names;
        }

        public object ExecuteScalar(string sql)
        {
            object value = null;

            try 
            {
                SqlCommand command = new SqlCommand(sql, _conn);
                value = ExecuteScalar(command);
            }
            catch(SqlException sqlex)
            {
                throw new DatabaseException(_conn, sqlex);
            }

            return value;
        }

        public object ExecuteScalar(SqlCommand cmd)
        {
            return cmd.ExecuteScalar();
        }

        public int IssueCommand(string sql)
        {
            int affected = 0;

            try 
            {
                SqlCommand command = new SqlCommand(sql, _conn);
                affected = command.ExecuteNonQuery();
            }
            catch(SqlException sqlex)
            {
                throw new DatabaseException(_conn, sqlex);
            }

            return affected;
        }

        public void ReadData(string sql, out SqlDataReader reader)
        {
            try
            {
                SqlCommand command = new SqlCommand(sql, _conn);
                reader = command.ExecuteReader();

                if (reader == null)
                {
                    throw new DatabaseException(_conn, "Execute reader failed");
                }
            }
            catch(SqlException sqlex)
            {
                throw new DatabaseException(_conn, sqlex);
            }
        }
    }

    /// <summary> This is a wrapper for the WebDB class, with static methods that can be directly called to get results. </summary>
    public class StaticWebDB
    {
        public static int ExecuteNonQuery(string query)
        {
            using (Webdb db=new Webdb())
            {
                db.ConnectToServer();
                return db.IssueCommand(query);
            }
        }

        public static object ExecuteScalar(string query)
        {
            using (Webdb db=new Webdb())
            {
                db.ConnectToServer();
                return db.ExecuteScalar(query);
            }
        }

        public static object ExecuteScalar(SqlCommand cmd)
        {
            using (Webdb db = new Webdb())
            {
                db.ConnectToServer();
                return db.ExecuteScalar(cmd);
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\Database\XbosWS.cs ===
using System;
using System.Data;
using System.Threading;
using System.Text;
using System.Collections;
using System.Collections.Generic;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.Billing;
using ServerTestFramework.LiveService.UserAccount;
using ServerTestFramework.Utilities;
using System.Globalization;  //for XeFormatPrice

using Microsoft.Webstore.WstClient;
using xonline.common.sql.webstore;
using xonline.common.config;
using xonline.common.utilities;

namespace ServerTestFramework.Database
{
    public class CountryCulture
    {
        public int CultureId;
        public ushort LanguageId;
        public byte CountryId;
        public string FriendlyName;
        public string CultureCode;
    }

    /// <summary>
    /// Derived from UodbWS, so all functions from UodbWS are also available here.
    /// </summary>
    public class XbosWS : UodbWS
    {
        /////////////////////////////////////////////////////////////////////////////////////
        // Game rating

        // #define XC_PC_GAME_RATING_SYS_NONE  0x3f
        public const byte RATING_SYS_NONE = 0x3f;
        // return 0xff if no rating id found
        public const byte RATING_ID_NONE = 0xff;


        /////////////////////////////////////////
        // Generic Webstore calls
        //
        // Note that these are private.  XbosWS's design is to provide an API for database access.
        // We should not allow arbitray SQL to be created, as it will make it difficult to update
        // code when the DB schema changes.  In addition this will reduce duplication of SQL statements.

        //Return a WSClient that is prepared for a read.  This lacks the selection of a partition.
        private static WSClient CreateGenericUODBRead(string sql) {
            WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITETHENREAD_COMMANDTYPE);
            ws.PartitionType = WstPartitionType.Logical;
            ws.CommandSql = sql;
            return ws;
        }

        //Returns an object that encapsulates the result of a scalar select statement.  Grabs data from one
        //of the UODBs, determined by the hash value.  Use this for data that is partitioned across UODBs.
        private static object ExecuteUODBReadOne(string sql, ulong hashVal) {
            WSClient ws = CreateGenericUODBRead(sql);
            ws.SetHashVal(hashVal);
            return ws.ExecuteScalar();
        }

        //Returns an object that encapsulates the result of a scalar select statement.  Grabs data from any
        //of the UODBs.  Use this for data that is synchronized across all UODBs.
        private static object ExecuteUODBReadAny(string sql) {
            WSClient ws = CreateGenericUODBRead(sql);
            ws.Partition = WstCommand.AnyPartition;
            return ws.ExecuteScalar();
        }

        //returns a WSClient that is prepared for a write statement.  As with reads, the partition
        //selection information is left for later.
        private static WSClient CreateGenericUODBWrite(string sql) {
            WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITEONLY_COMMANDTYPE);
            ws.PartitionType = WstPartitionType.Logical;
            ws.CommandSql = sql;
            return ws;
        }

        //Excute a write(update or delete) on a single partition, determined by the hashVal.
        private static void ExecuteUODBWriteOne(string sql, ulong hashVal) {
            WSClient ws = CreateGenericUODBWrite(sql);
            ws.SetHashVal(hashVal);
            ws.ExecuteNonQuery();
        }

        //Execute a write(update or delete) on all partitions.
        private static void ExecuteUODBWriteAll(string sql) {
            WSClient ws = CreateGenericUODBWrite(sql);
                for (int p = 0; p < ws.PhysicalPartitions; p++)
                {
                    ws.PhysicalPartition = p;
                    ws.CommandSql = sql;

                    ws.ExecuteNonQuery();
                }
        }

        /////////////////////////////////////////
        // Rating and Culture queries

        public static byte GetRatingSystemIdFromCountry(byte countryId)
        {
            byte ratingSystemId = RATING_SYS_NONE;
            string sql = "select i_rating_system_id from dbo.t_region_rating_systems where ti_country_id = " + countryId.ToString();

            using (WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITETHENREAD_COMMANDTYPE))
            {
                ws.PartitionType = WstPartitionType.Logical;
                ws.Partition = WstCommand.AnyPartition;
                ws.CommandSql = sql;

                object ret = ws.ExecuteScalar();
                if (ret != null)
                {
                    ratingSystemId = (byte)(int)ret;
                }

                return ratingSystemId;
            }
        }

        public static byte GetRatingId(byte ratingSystemId, byte ratingRank)
        {
            byte ratingId = RATING_ID_NONE;
            string sql = "select i_rating_id from  dbo.t_rating_system_ratings where i_rating_system_id =" + ratingSystemId.ToString() + " and i_rank = " + ratingRank.ToString();

            using (WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITETHENREAD_COMMANDTYPE))
            {
                ws.PartitionType = WstPartitionType.Logical;
                ws.Partition = WstCommand.AnyPartition;
                ws.CommandSql = sql;

                object ret = ws.ExecuteScalar();
                if (ret != null)
                {
                    ratingId = (byte)(int)ret;
                }

                return ratingId;
            }
        }


        ///////////////////////////////////////////////////////////////////////////////
        // country, language and culture

        public static readonly int TotalLiveCountryCount = CountryLanguage.GetAllCountryIds().Length;
        public static readonly int TotalLiveCultureCount = CountryLanguage.GetAllCultureIds().Length;

        public static int GetCultureIndex(int[] cultureIds, byte countryId, int languageId)
        {
            int index = -1;
            int cultureId = CountryLanguage.GetCultureId(countryId, (ushort)languageId);
            for (int i = 0; i < cultureIds.GetLength(0) && cultureIds[i] != 0; i++)
            {
                if (cultureIds[i] == cultureId)
                {
                    index = i;
                    break;
                }
            }
            return index;
        }

        public static byte GetLiveCountryIdFromCulture(int cultureId)
        {
            byte countryId = 0;
            string sql = "select ti_country_id from dbo.t_cultures where ti_xbox_live_supported = 1 and i_culture_id =" + cultureId.ToString();

            using (WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITETHENREAD_COMMANDTYPE))
            {
                ws.PartitionType = WstPartitionType.Logical;
                ws.Partition = WstCommand.AnyPartition;
                ws.CommandSql = sql;

                object ret = ws.ExecuteScalar();
                if (ret != null)
                {
                    countryId = (byte)ret;
                }

                return countryId;
            }
        }

        //////////////////////////////////////////////////////////////////
        // console id
        // add console id to UODB. It is for license. If you make console id = "", the default console "XE.024195370001" will be used. Otherwise, you should create
        // your own unique console id.
        public static string AddConsoleId(ulong machineId)
        {
            return AddConsoleId(machineId, "");
        }

        public static string AddConsoleId(ulong machineId, string console)
        {
            if (console == null || console == "")
            {
                console = "XE.024195370001";
            }

            if (machineId == 0)
            {
                machineId = MachineEditor.AllocateMachinePuid(MachineType.Xbox360);
            }

            MachineEditor.CreateOrUseExistingName(console, null, machineId);
            return console;
        }

        public static string AddConsoleId(ulong machineId, string console, string partNumber)
        {
            console=AddConsoleId(machineId, console);

            MachineEditor mach=MachineEditor.FromName(console);
            mach.ConsoleCertificatePartNumber=Hexer.unhex(partNumber);

            return console;
        }

        //////////////////////////////////////////////////////////////////
        // Reward id for a subscription offer

        public static void AddRewardId(ulong offerId, int tier, int rewardId)
        {
            using (WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITEONLY_COMMANDTYPE))
            {
                for (int p = 0; p < ws.PhysicalPartitions; p++)
                {
                    ws.ClearParameters();
                    ws.PhysicalPartition = p;
                    ws.StoredProc = "dbo.p_svc_insert_offer_subscription_reward";

                    ws.AddParameter(ParamType.RETVAL, "@ret", 0);
                    ws.AddParameter("@bi_offer_id", offerId);
                    ws.AddParameter("@ti_country_id", 103);
                    ws.AddParameter("@i_subscription_tier_id", tier);
                    ws.AddParameter("@dt_start_date", DateTime.UtcNow.AddMonths(-10));
                    ws.AddParameter("@dt_end_date", DateTime.UtcNow.AddMonths(10));
                    ws.AddParameter("@i_reward_id", rewardId);

                    ws.ExecuteNonQuery();

                    uint hr = (uint)ws.GetIntParameter("@ret");
                    if (HResult.Failed(hr))
                    {
                        throw new UnexpectedTestResultException(ws.GetCallSignature() + " failed with hr = 0x" + hr.ToString("x"));
                    }
                }
            }
        }

        public static void RemoveRewardId(ulong offerId, int rewardId)
        {
            string sql = "delete from dbo.t_offer_subscription_rewards where bi_offer_id=0x" + offerId.ToString("x") + " and i_reward_id=" + rewardId;

            using (WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITEONLY_COMMANDTYPE))
            {
                for (int p = 0; p < ws.PhysicalPartitions; p++)
                {
                    ws.ClearParameters();
                    ws.PhysicalPartition = p;
                    ws.CommandSql = sql;

                    ws.ExecuteNonQuery();
                }
            }
        }

        //---------------------------------------------------------------------
        // Title and Offer

        // content enumerate
        public static int GetContentEnumerateCount(uint offerType, uint paymentType)
        {
            string sql = "select count(distinct o.bi_offer_id) from t_offers o " +
            "inner join t_offer_regions ore on o.bi_offer_id = ore.bi_offer_id " +
            "inner join t_title_offers t on o.bi_offer_id = t.bi_offer_id " +
            "where (o.i_offer_type_id & 0x" + offerType.ToString("x") + ") <> 0 " +
            "and (ore.i_payment_type_id & 0x" + paymentType.ToString("x") + ") <> 0 " +
            "and ore.ti_country_id = 103 " +
            "and ore.i_tier_required = 3 " +
            "and t.i_title_id = 0xFFFE07D1 " + // xenon dashboard
            "and o.i_policy_flags <> 1024";   // do not enumerate

            return (int)ExecuteSQLScalar(sql, null);
        }


        public static uint GetTitleId(ulong offerId)
        {
            string sql = string.Format("select i_title_id  from t_title_offers where bi_offer_id = 0x{0}", offerId.ToString("X"));


            return (uint)((int)ExecuteSQLScalar(sql, null));
        }

        // get some content title ids for ContentEnumerate stress testing
        public static uint[] GetTitleIds()
        {
            string sql = "select distinct t.i_title_id from dbo.t_offers o inner join dbo.t_title_offers t on o.bi_offer_id = t.bi_offer_id where o.ti_console_type_id = 2 and i_offer_type_id = 2";

            using (WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITETHENREAD_COMMANDTYPE))
            {
                ws.PartitionType = WstPartitionType.Logical;
                ws.Partition = WstCommand.AnyPartition;

                ws.CommandSql = sql;

                ws.AddParameter(ParamType.RETVAL, "@RETVAL", 0);

                using (WstDataReader r = ws.Execute())
                {
                    List<uint> titleIds = new List<uint>();
                    while (r.Read())
                    {
                        titleIds.Add((uint)r.GetInt32(0));
                    }

                    r.Close();

                    uint hr = (uint)ws.GetIntParameter("@RETVAL");
                    if (HResult.Failed(hr))
                    {
                        throw new UnexpectedTestResultException(ws.GetCallSignature() + " failed with hr = 0x" + hr.ToString("x"));
                    }

                    return titleIds.ToArray();
                }
            }
        }

        public static string GetOfferCategoryName(int categoryId, int cultureId)
        {
            string name = "";
            string sql = "select vc_category_name from dbo.t_offer_category_culture_details where i_category_id = " + categoryId + " and i_culture_id =" + cultureId;

            using (WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITETHENREAD_COMMANDTYPE))
            {
                ws.PartitionType = WstPartitionType.Logical;
                ws.Partition = WstCommand.AnyPartition;
                ws.CommandSql = sql;

                object ret = ws.ExecuteScalar();
                if (ret != null)
                {
                    name = (string)ret;
                }

                return name;
            }
        }

        public static string GetOfferSKU(ulong offerId)
        {
            string offerSku = "";
            string sql = "select vc_sku from dbo.t_dmp_offer_details do inner join dbo.t_offer_skus osku on do.i_revenue_sku_id = osku.i_sku_id where do.bi_offer_id = 0x" + offerId.ToString("x");

            using (WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITETHENREAD_COMMANDTYPE))
            {
                ws.PartitionType = WstPartitionType.Logical;
                ws.Partition = WstCommand.AnyPartition;
                ws.CommandSql = sql;

                object ret = ws.ExecuteScalar();
                if (ret != null)
                {
                    offerSku = (string)ret;
                }

                return offerSku;
            }
        }

       
        public class UserSubscription
        {
            public ulong bi_primary_puid;
            public ulong bi_offer_id;
            public int i_instances;
            public int i_puid_is_machine;
            public DateTime dt_start_date;
            public DateTime dt_end_date;
            public int i_subscription_status_id;
            public int i_transaction_flags;
            public short si_hash_bucket;
            public DateTime dt_change_datetime;
        }

        public static void UpdateSubscriptionofferDetails(Guid offerId, Guid offerInstanceId,ulong userPuid,ulong uodbofferId)
        {
            string sql = string.Format("Update t_subscriptions set uid_catalog_offerid='{0}',uid_catalog_offerinstance_id='{1}' where bi_primary_puid={2} and bi_offer_id={3}", offerId.ToString(), offerInstanceId.ToString(), userPuid, "0x"+uodbofferId.ToString("X"));
            ExecuteUODBWriteOne(sql,userPuid);
        }

        public static void UpdateSubscriptionofferDetails(Guid offerId, Guid offerInstanceId, ulong userPuid, Guid origOfferId, ulong newlegacyOfferId)
        {
            string sql = string.Format("Update t_subscriptions set uid_catalog_offerid='{0}',uid_catalog_offerinstance_id='{1}', bi_offer_id = 0x{2} where bi_primary_puid={3} and uid_catalog_offerid='{4}'", offerId.ToString(), offerInstanceId.ToString(), newlegacyOfferId.ToString("X"), userPuid, origOfferId.ToString());
            ExecuteUODBWriteOne(sql, userPuid);
        }

        public static void UpdateSubscriptionofferAndOwnerPuid(Guid offerId, Guid offerInstanceId, ulong userPuid, ulong uodbofferId,ulong subscriptionOwnerPuid)
        {
            string sql = string.Format("Update t_subscriptions set uid_catalog_offerid='{0}',uid_catalog_offerinstance_id='{1}',bi_subscription_owner_puid={4} where bi_primary_puid={2} and bi_offer_id={3}", offerId.ToString(), offerInstanceId.ToString(), userPuid, "0x" + uodbofferId.ToString("X"), "0x" + subscriptionOwnerPuid);
            ExecuteUODBWriteOne(sql, userPuid);
        }


        public static void UpdateSubscriptionofferDetailsServiceInstance(ulong userPuid, Guid offerId, string serviceInstanceId)
        {
            string sql = string.Format("Update t_subscriptions set vc_svc_instance_id ='{0}' where bi_primary_puid={1} and  uid_catalog_offerid='{2}'", serviceInstanceId.ToString(), userPuid, offerId.ToString());
            ExecuteUODBWriteOne(sql, userPuid);
        }


        public static void UpdateSubscriptionofferDetails(Guid offerId, Guid offerInstanceId, ulong userPuid, Guid origOfferId)
        {
            string sql = string.Format("Update t_subscriptions set uid_catalog_offerid='{0}',uid_catalog_offerinstance_id='{1}' where bi_primary_puid={2} and uid_catalog_offerid='{3}'", offerId.ToString(), offerInstanceId.ToString(), userPuid, origOfferId.ToString());
            ExecuteUODBWriteOne(sql, userPuid);
        }

        // for OfferingPurchase stress
        public static void SaveUserSubscription(ulong userPuid, ArrayList subscriptions)
        {
            // save the user's subscriptions
            string sql = "select bi_primary_puid, bi_offer_id, i_instances, i_puid_is_machine, dt_start_date, ";
            sql += "dt_end_date, i_subscription_status_id, i_transaction_flags, si_hash_bucket, dt_change_datetime ";
            sql += "from t_subscriptions where bi_primary_puid = 0x" + userPuid.ToString("X");

            using (WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITETHENREAD_COMMANDTYPE))
            {
                ws.PartitionType = WstPartitionType.Logical;
                ws.SetHashVal(userPuid);
                ws.CommandSql = sql;

                using (WstDataReader dr = ws.Execute())
                {
                    while (dr.Read())
                    {
                        UserSubscription sub = new UserSubscription();
                        sub.bi_primary_puid = (ulong)dr.GetInt64(0);
                        sub.bi_offer_id = (ulong)dr.GetInt64(1);
                        sub.i_instances = dr.GetInt32(2);
                        sub.i_puid_is_machine = dr.GetInt32(3);
                        sub.dt_start_date = dr.GetDateTime(4);
                        sub.dt_end_date = dr.GetDateTime(5);
                        sub.i_subscription_status_id = dr.GetInt32(6);
                        sub.i_transaction_flags = dr.GetInt32(7);
                        sub.si_hash_bucket = dr.GetInt16(8);
                        sub.dt_change_datetime = dr.GetDateTime(9);

                        subscriptions.Add(sub);
                    }

                    dr.Close();
                }
            }
        }

        public static void UpdateSubscriptionOfferId(ulong userPuid, ulong offerId)
        {
            // now dummy update the user's subscription to a silver subscription
            string sql = "update t_subscriptions set bi_offer_id = 0x" + offerId.ToString("X") +
                " where bi_primary_puid = 0x" + userPuid.ToString("X");

            using (WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITEONLY_COMMANDTYPE))
            {
                ws.PartitionType = WstPartitionType.Logical;
                ws.SetHashVal(userPuid);
                ws.CommandSql = sql;

                int rowsAffected = ws.ExecuteNonQuery();
                if (rowsAffected != 2 )  // a new trigger is added to update changedtime, so two rows returned.
                    throw new UnexpectedTestResultException("Expected one row to be updated in t_subscriptions. Actual = " + rowsAffected.ToString());
            }
        }

        public static void UpdateSubscriptionOfferId(ulong userPuid, ulong offerId, int numRowaffected)
        {
            // now dummy update the user's subscription to a silver subscription
            string sql = "update t_subscriptions set bi_offer_id = 0x" + offerId.ToString("X") +
                " where bi_primary_puid = 0x" + userPuid.ToString("X");

            using (WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITEONLY_COMMANDTYPE))
            {
                ws.PartitionType = WstPartitionType.Logical;
                ws.SetHashVal(userPuid);
                ws.CommandSql = sql;

                int rowsAffected = ws.ExecuteNonQuery();
                if (rowsAffected < numRowaffected)  // a new trigger is added to update changedtime, so at least such many of  rows should returned returned.
                    throw new UnexpectedTestResultException("Expected one row to be updated in t_subscriptions. Actual = " + rowsAffected.ToString());
            }
        }



        public static void UpdateSubscriptionOfferId(ulong userPuid, ulong curOfferId, ulong offerId)
        {
            // now dummy update the user's subscription to a silver subscription
            string sql = "update t_subscriptions set bi_offer_id = 0x" + offerId.ToString("X") +
                " where bi_primary_puid = 0x" + userPuid.ToString("X") + " and bi_offer_id = 0x" + curOfferId.ToString("X");

            using (WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITEONLY_COMMANDTYPE))
            {
                ws.PartitionType = WstPartitionType.Logical;
                ws.SetHashVal(userPuid);
                ws.CommandSql = sql;

                int rowsAffected = ws.ExecuteNonQuery();
                if (rowsAffected < 1)  // a new trigger is added to update changedtime, so at least such many of  rows should returned returned.
                    throw new UnexpectedTestResultException("Expected one row to be updated in t_subscriptions. Actual = " + rowsAffected.ToString());
            }
        }
        /////////////////////////////////////
        // Banner related calls

        //Return whether this offer should be visible for a given region and tier.
        public static bool IsOfferVisibleForRegionAndTier(ulong offerId, int countryId, int tier) {
            string sql = "select count(*) from t_offer_regions where bi_offer_id = 0x" +
                String.Format("{0:x}", offerId) + " and i_tier_required = " +
                tier + " and ti_country_id = " + countryId;
            object ans = ExecuteUODBReadAny(sql);
            if (ans == null) {
                throw new UnexpectedTestResultException("Error!  No result returned from select statement:" + sql);
            }
            //the offer should be visible for this tier if there's at least one row present.
            bool shouldBeVisible = ((int) ans != 0);
            return shouldBeVisible;
        }


        /////////////////////////////////////
        // Subscription related queries

        //Return the tier value that p_xbos_subscription_details would use.  This obeys the
        //following rules:
        //If there is a row in t_offer_regions with the exact tier match, then use that.
        //Otherwise if there's one of a higher tier, then use that.
        //Otherwise use one of a lower tier.
        //The rationale for that is for upsell--attempt to show the user a subscription they cannot
        //have at their current tier.
        public static uint GetSubscriptionDetailsTierValue(ulong bi_offer_id, int i_country_id,
                                                    uint i_payment_type_id, uint i_tier_required,
                                                    bool printDebugInfo) {
            string sql = "SELECT TOP 1 " +  //straight-up grab this info from the xbos sproc
                " ore.i_tier_required FROM " +
                " dbo.t_offers o INNER JOIN " +
                " dbo.t_offer_regions ore ON ore.bi_offer_id = o.bi_offer_id INNER JOIN " +
                " dbo.t_title_offers tof ON tof.bi_offer_id = o.bi_offer_id WHERE " +
                " o.bi_offer_id = 0x" + bi_offer_id.ToString("X") + " AND " +
                " (o.ti_console_type_id = 2 or o.ti_console_type_id = 3) AND " +
                " ore.ti_country_id = " + i_country_id + " AND " +
                " (ore.i_payment_type_id & 0x" + i_payment_type_id.ToString("X") + ") <> 0 " +
                " ORDER BY " +
                " CASE " +
                " WHEN ore.i_tier_required = " + i_tier_required + " THEN 1 " +
                " WHEN ore.i_tier_required > " + i_tier_required + " THEN 2 " +
                " WHEN ore.i_tier_required < " + i_tier_required + " THEN 3 " +
                " END ASC ";

            if (printDebugInfo) {
                Global.RO.Info("Selecting proper i_tier_required value:");
                Global.RO.Info(sql);
            }
            object ans = ExecuteUODBReadAny(sql);
            if (ans == null) {
                throw new UnexpectedTestResultException("Cannot obtain correct tier_required value!  " +
                                                        "Row missing in t_offer_regions!");
            } else {
                return (uint) ((int) ans);
            }
        }

        ////////////////////////////////////////
        /// Subscription-related UODB queries.
        //
        //Currently the following strucutres and queries retrieve a subset of info related to an
        //offer.  If more columns are needed from a table, expand the structure and retrieve the
        //query from the row as well.  The only information required to perform each of the queries
        //should be primary keys.


        public class OfferInfo {
            public ulong offerId;
            public int offerType;
            public uint titleCategory;
            public byte duration;  //this is split from si_global_details because the column is
            public byte frequency; //essentially overloaded
        }

        //Retrieve info related to subscriptions from the t_offers table.
        public static void QuerySubInfoForOffer(ulong bi_offer_id, bool printDebugInfo,
                                    out OfferInfo result) {
            string sql = "SELECT i_offer_type_id, i_bitfilter, si_global_offer_details from t_offers " +
                "where bi_offer_id = 0x" + bi_offer_id.ToString("X");
            if (printDebugInfo) {
                Global.RO.Info(sql);
            }
            WSClient ws = CreateGenericUODBRead(sql);
            ws.Partition = WstCommand.AnyPartition;

            using (WstDataReader myDataReader = ws.Execute()) {
                if (myDataReader.Read()) {
                    result = new OfferInfo();
                    result.offerId = bi_offer_id;
                    result.offerType = myDataReader.GetInt32(0);
                    result.titleCategory = (uint) myDataReader.GetInt32(1);
                    int si_global_offer_details = myDataReader.GetInt16(2);
                    result.duration = (byte) ((si_global_offer_details >> 4) & 0xf);
                    result.frequency = (byte) ((si_global_offer_details >> 1) & 0x7);
                    myDataReader.Close();
                } else {
                    myDataReader.Close();
                    throw new UnexpectedTestResultException("SQL Error reading from t_offers.  Possibly no rows returned.");
                }
            }

        }

        public class OfferCultureDetailsInfo {
            public ulong offerId;
            public int culture;
            public string offerName;
            public string sellText;
            public DateTime dateChanged;
        }

        //Return the row, given an offerid and culture.
        public static void QueryOfferCultureDetails(ulong bi_offer_id, int culture, bool printDebugInfo,
                                             out OfferCultureDetailsInfo result) {
            string sql = "SELECT vc_name, vc_sell_text, dt_change_datetime from t_offer_culture_details " +
                "where bi_offer_id = 0x" + bi_offer_id.ToString("X") + " AND i_culture_id = " + culture;
            if (printDebugInfo) {
                Global.RO.Info(sql);
            }
            WSClient ws = CreateGenericUODBRead(sql);
            ws.Partition = WstCommand.AnyPartition;

            using (WstDataReader myDataReader = ws.Execute()) {
                if (myDataReader.Read()) {
                    result = new OfferCultureDetailsInfo();
                    result.offerId = bi_offer_id;
                    result.culture = culture;
                    result.offerName = myDataReader.GetString(0);
                    result.sellText = myDataReader.GetString(1);
                    result.dateChanged = myDataReader.GetDateTime(2);
                    myDataReader.Close();
                } else {
                    myDataReader.Close();
                    throw new UnexpectedTestResultException("SQL Error reading from t_offer_culture_details.  Possibly no rows returned.");
                }
            }
        }

        public class SubscriptionsInfo {
            public ulong offerId;
            public ulong userPuid;
            public string instanceID;
            public int subscriptionStatus;
            public DateTime startDate;
            public DateTime endDate;
        }

        public static void QuerySubscriptions(ulong bi_offer_id, ulong bi_user_puid, bool printDebugInfo,
                                       out SubscriptionsInfo result) {
            string sql = "SELECT vc_svc_instance_id, i_subscription_status_id, dt_start_date, dt_end_date " +
                "from t_subscriptions where bi_offer_id = 0x" + bi_offer_id.ToString("X") +
                " and bi_primary_puid = 0x" + bi_user_puid.ToString("X");
            if (printDebugInfo) {
                Global.RO.Info(sql);
            }
            WSClient ws = CreateGenericUODBRead(sql);
            ws.SetHashVal(bi_user_puid);

            using (WstDataReader myDataReader = ws.Execute()) {
                if (myDataReader.Read()) {
                    result = new SubscriptionsInfo();
                    result.offerId = bi_offer_id;
                    result.userPuid = bi_user_puid;
                    result.instanceID = myDataReader.GetString(0);
                    result.subscriptionStatus = myDataReader.GetInt32(1);
                    result.startDate = myDataReader.GetDateTime(2);
                    result.endDate = myDataReader.GetDateTime(3);
                    myDataReader.Close();
                } else {
                    myDataReader.Close();
                    //we may be allowed to use a value of no returned rows.  In this case return
                    //null and have the caller deal with it as they see fit.
                    result = null;
//                    throw new UnexpectedTestResultException("SQL Error reading from t_subscriptions.  Possibly no rows returned.");
                }
            }
        }

        public class TitleOfferInfo {
            public ulong offerId;
            public uint titleId;
        }

        public static void QueryTitleOffers(ulong bi_offer_id, bool printDebugInfo,
                                     out TitleOfferInfo result) {
            string sql = "SELECT i_title_id from t_title_offers where bi_offer_id = 0x" + bi_offer_id.ToString("X");
            if (printDebugInfo) {
                Global.RO.Info(sql);
            }

            WSClient ws = CreateGenericUODBRead(sql);
            ws.Partition = WstCommand.AnyPartition;
            using (WstDataReader myDataReader = ws.Execute()) {
                if (myDataReader.Read()) {
                    result = new TitleOfferInfo();
                    result.offerId = bi_offer_id;
                    result.titleId = (uint) myDataReader.GetInt32(0);
                } else {
                    throw new UnexpectedTestResultException("SQL Error reading from t_title_offers!");
                }

            }
        }

        public class TitleCultureDetailsInfo {
            public uint titleId;
            public int culture;
            public string titleName;
        }

        public static void QueryTitleCultureDetails(uint i_title_id, int culture, bool printDebugInfo,
                                             out TitleCultureDetailsInfo result) {
            string sql = "SELECT vc_name from t_title_culture_details where i_title_id = 0x" +
                i_title_id.ToString("X") + " and i_culture_id = " + culture;
            if (printDebugInfo) {
                Global.RO.Info(sql);
            }

            WSClient ws = CreateGenericUODBRead(sql);
            ws.Partition = WstCommand.AnyPartition;

            using (WstDataReader myDataReader = ws.Execute()) {
                if (myDataReader.Read()) {
                    result = new TitleCultureDetailsInfo();
                    result.titleId = i_title_id;
                    result.culture = culture;
                    result.titleName = myDataReader.GetString(0);
                } else {
                    throw new UnexpectedTestResultException("SQL Error reading from t_title_culture_details!");
                }
            }
        }

        public class BaseOffersInfo {
            public ulong offerId;
            public byte tierProvided;
        }

        public static void QueryBaseOffers(ulong bi_offer_id, bool printDebugInfo,
                                    out BaseOffersInfo result) {
            string sql = "SELECT i_tier_id from t_base_offers where bi_offer_id = 0x" +
                bi_offer_id.ToString("X");
            if (printDebugInfo) {
                Global.RO.Info(sql);
            }

            WSClient ws = CreateGenericUODBRead(sql);
            ws.Partition = WstCommand.AnyPartition;

            using (WstDataReader myDataReader = ws.Execute()) {
                if (myDataReader.Read()) {
                    result = new BaseOffersInfo();
                    result.offerId = bi_offer_id;
                    result.tierProvided = (byte) myDataReader.GetInt32(0);
                } else {
                    result = null;
//                    throw new UnexpectedTestResultException("SQL Error reading from t_base_offers!");
                }
            }
        }

//right thing to do is take all the matching ones and return them.  Then have the caller filter out
//by relation type id.

        public class OfferRelationsInfo {
            public ulong offerId;
            public ulong relatedOfferId;
            public int relationType;
        }

        public static void QueryOfferRelations(ulong bi_offer_id, bool printDebugInfo,
                                        out OfferRelationsInfo [] result) {
            string sql = "SELECT bi_related_offer_id, i_relation_type_id from t_offer_relations where bi_offer_id = 0x" +
                bi_offer_id.ToString("X");
            if (printDebugInfo) {
                Global.RO.Info(sql);
            }
            WSClient ws = CreateGenericUODBRead(sql);
            ws.Partition = WstCommand.AnyPartition;

            ArrayList relatedOffers = new ArrayList();

            using (WstDataReader myDataReader = ws.Execute()) {
                while (myDataReader.Read())
                {
                    OfferRelationsInfo row = new OfferRelationsInfo();
                    row.offerId = bi_offer_id;
                    row.relatedOfferId = (ulong) myDataReader.GetInt64(0);
                    row.relationType = (int) myDataReader.GetInt32(1);
                    relatedOffers.Add(row);
                }
            }
            result = (OfferRelationsInfo []) relatedOffers.ToArray(typeof(OfferRelationsInfo));
        }


        //Return an array of all the prices listed in t_offer_regions that match the offer, tier,
        //payment type, etc.  If there is no match, returns an empty array.
        public static void RetrievePrices(ulong bi_offer_id, uint i_payment_type_id, uint i_tier_required,
                                      int cultureId, int country, bool printDebugInfo,
                                      out OfferPrice [] result) {
            string sql = "select i_payment_type_id, i_price_whole, i_price_Fractional, si_specific_offer_details "+
                "from t_offer_regions where bi_offer_id = 0x" + bi_offer_id.ToString("X") +
                " AND ((i_payment_type_id & 0x" + i_payment_type_id.ToString("X") + ") <> 0)" +
                " AND i_tier_required = " + i_tier_required +
                " AND ti_country_id = " + country;
            if (printDebugInfo) {
                Global.RO.Info(sql);
            }

            WSClient ws = CreateGenericUODBRead(sql);
            ws.Partition = WstCommand.AnyPartition;

            ArrayList priceList = new ArrayList();

            using (WstDataReader myDataReader = ws.Execute()) {
                while (myDataReader.Read())
                {
                    OfferPrice price = new OfferPrice();
                    price.PaymentType = (uint)myDataReader.GetInt32(0);
                    price.WholePrice = (int)myDataReader.GetInt32(1);
                    price.FractionalPrice = (int) myDataReader.GetInt32(2);
                    int specificDetails = (int) myDataReader.GetInt16(3);

                    price.TaxType = (byte) (specificDetails & 0x7);
                    Global.RO.Info(i_payment_type_id + "   " + price.WholePrice + "  " +
                                   price.FractionalPrice + "  " + cultureId);
                    price.PriceText = XeFormatPrice(price.PaymentType, price.WholePrice,
                                                    price.FractionalPrice, cultureId);
                    price.PriceTextLength = (ushort)price.PriceText.Length;
                    priceList.Add(price);
                }
                myDataReader.Close();
            }
            result = (OfferPrice []) priceList.ToArray(typeof(OfferPrice));
        }

//This taken from private\common\billing\Price.cs and modified.
        private static string XeFormatPrice(uint paymentType, int wholePrice, int fractionalPrice, int cultureID)
        {
            double priceValue = (double)(wholePrice) + ((double)(fractionalPrice) / 100);

            string formattedPrice = "";

            // if the lcid is fake, we need to fix it
            cultureID %= 100000;
            CultureInfo ci;
            try
            {
                ci = new CultureInfo(cultureID);
            }
            catch
            {
                throw new Exception("Locale.GetValidLCID: provided LCID does not map to a real LCID");
            }

            NumberFormatInfo nfi = ci.NumberFormat;

            // based on payment type, determine the if we need to do special cases
            switch ((PaymentTypeEnum)paymentType)
            {
                case PaymentTypeEnum.CreditCard:
                    switch (cultureID)
                    {
                        case 1033: // US
                            nfi.CurrencySymbol = "\u0024";
                            break;

                        case 2057: // UK
                            nfi.CurrencySymbol = "\u00A3";
                            break;

                        case 1041: // Japan
                            nfi.CurrencySymbol = "\u00A5";
                            break;

                        case 1042: // S. Korea
                            nfi.CurrencySymbol = "\u20A9";
                            break;
                    }
                    formattedPrice = priceValue.ToString("c", nfi);
                    break;

                case PaymentTypeEnum.Points:

                    // points do not have fractions
                    nfi.NumberDecimalDigits = 0;
                    nfi.CurrencyDecimalDigits = 0;
                    nfi.CurrencySymbol = "\u00A4";
                    nfi.CurrencyPositivePattern = 1;
                    nfi.CurrencyNegativePattern = 5;
                    formattedPrice = Convert.ToInt32(priceValue).ToString("c", nfi);
                    break;

                case PaymentTypeEnum.Token:
                default:
                    formattedPrice = "";
                    return formattedPrice;
            }

            return formattedPrice;
        }


        public static bool GetServiceComponentId(long offerId, out string serviceComponentId)
        {
            return GetServiceComponentId(offerId, out serviceComponentId, null);
        }

        public static bool GetServiceComponentId(long offerId, out string serviceComponentId, string serviceComponentIdDefaultValue)
        {
            serviceComponentId = serviceComponentIdDefaultValue;
            string sql = "select vc_billing_svc_component_id from t_offers where bi_offer_id = " + offerId;

            using (WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITETHENREAD_COMMANDTYPE))
            {
                ws.PartitionType = WstPartitionType.Logical;
                ws.Partition = WstCommand.AnyPartition;
                ws.CommandSql = sql;

                using (WstDataReader r = ws.Execute())
                {
                    if (r.Read())
                    {
                        serviceComponentId = r.GetString(0);
                    }

                    r.Close();
                    return true;
                }
            }
        }

        public static bool GetServiceComponentId(string instanceId, out string serviceComponentId)
        {
            return GetServiceComponentId(instanceId, out serviceComponentId, null);
        }

        public static bool GetServiceComponentId(string instanceId, out string serviceComponentId, string serviceComponentIdDefaultValue)
        {
            serviceComponentId = serviceComponentIdDefaultValue;
            string sql = "select tof.vc_billing_svc_component_id from t_offers tof inner join t_subscriptions ts on tof.bi_offer_id = ts.bi_offer_id where ts.vc_svc_instance_id = '" + instanceId + "'";

            using (WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITETHENREAD_COMMANDTYPE))
            {
                ws.PartitionType = WstPartitionType.Logical;
                ws.Partition = WstCommand.AnyPartition;
                ws.CommandSql = sql;

                using (WstDataReader r = ws.Execute())
                {
                    if (r.Read())
                    {
                        serviceComponentId = r.GetString(0);
                    }

                    r.Close();
                    return true;
                }
            }
        }

        //////////////////////////////////////////////////////////////////
        // Billing audit UODB table

        public static List<AuditInfo> GetAuditInfo(ulong userPuid)
        {
            string sql = "select * from dbo.t_user_audit_info where bi_user_puid = 0x" + userPuid.ToString("x") + " order by dt_change_datetime";

            using (WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITETHENREAD_COMMANDTYPE))
            {
                ws.PartitionType = WstPartitionType.Logical;
                ws.SetHashVal(userPuid);
                ws.CommandSql = sql;

                ws.AddParameter(ParamType.RETVAL, "@RETVAL", 0);

                using (WstDataReader r = ws.Execute())
                {
                    List<AuditInfo> auditList = new List<AuditInfo>();
                    while (r.Read())
                    {
                        //r.GetSqlXml(6).Value;
                        AuditInfo info = new AuditInfo((ulong)r.GetInt64(0), r.GetGuid(1),
                            r.GetString(3), r.GetString(4), r.GetString(5),
                            r.GetString(6), DateTime.UtcNow, false);
                        auditList.Add(info);
                    }

                    r.Close();

                    uint hr = (uint)ws.GetIntParameter("@RETVAL");
                    if (HResult.Failed(hr))
                    {
                        throw new UnexpectedTestResultException(ws.GetCallSignature() + " failed with hr = 0x" + hr.ToString("x"));
                    }

                    return auditList;
                }
            }
        }

        public class EMSOfferInfo
        {
            public enum CatalogUserTypeEnum : uint
            {
                XboxLiveGoldUser = 2,
                XboxLiveSilverUser = 3,
                XboxLiveFamilyGoldUser = 4
            };

            public Guid OfferGuid;
            public Guid OfferInstanceId;
            public int OfferMediaType;

            public override bool Equals(Object other)
            {
                if (other == null || GetType() != other.GetType())
                    return false;

                EMSOfferInfo info = (EMSOfferInfo)other;
                return (this.OfferGuid == info.OfferGuid) && (this.OfferInstanceId == info.OfferInstanceId) && (this.OfferMediaType == info.OfferMediaType);
            }

            public override int GetHashCode()
            {
                return base.GetHashCode();
            }

            public override string ToString()
            {
                string toString = "OfferGuid: " + OfferGuid.ToString() + ", OfferInstanceId: " + OfferInstanceId.ToString() + ", OfferMediaType: " + OfferMediaType;
                return toString;
            }

            // offer id converted to EMS offer guid
            public static Guid OfferIdToOfferingGuid(ulong offerId)
            {
                uint hi32 = (uint)(offerId >> 32);
                uint lo32 = (uint)(offerId & 0x00000000FFFFFFFF);

                string s = String.Format("{0:x8}-0000-4000-8000-0000{1:x8}", lo32, hi32);

                return new System.Guid(s);
            }

            // offer id converted to EMS offer instance id
            public static Guid OfferIdToOfferInstanceId(ulong offerId, int emsUserTypeId, byte countryId, uint uodbPaymentType)
            {
                uint hi32 = (uint)(offerId >> 32);
                uint lo32 = (uint)(offerId & 0x00000000FFFFFFFF);
                uint emsPaymentType = 1;

                if (uodbPaymentType == 4) emsPaymentType = 1;
                else
                    if (uodbPaymentType == 2) emsPaymentType = 2;
                    else {
                        throw new Exception("OfferIdToOfferInstanceId: uodb payment type {0} is not supported by ems catalog" + uodbPaymentType);
                    }


                string s = String.Format("{0:x8}-{1:d1}0{2:x2}-40{3:d2}-8000-0000{4:x8}", lo32, emsUserTypeId, countryId, emsPaymentType, hi32);

                return new System.Guid(s);
            }

            public static int GetMediaTypeFromOfferType(OfferingTypeEnum offerType)
            {
                int mediaType = 0;

                switch (offerType)
                {
                    case OfferingTypeEnum.ArcadeTrial:
                        mediaType = 5; // 360ArcadeDemo
                        break;
                    case OfferingTypeEnum.Content:
                        mediaType = 18; // 360InGameContent
                        break;
                    case OfferingTypeEnum.GameDemo:
                        mediaType = 19; // 360GameDemo
                        break;
                    case OfferingTypeEnum.Theme:
                        mediaType = 20; // 360Theme
                        break;
                    case OfferingTypeEnum.Xbox1Game:
                        mediaType = 21; // Xbox1Game
                        break;
                    case OfferingTypeEnum.Tile:
                        mediaType = 22; // GamerTile
                        break;
                    case OfferingTypeEnum.Arcade:
                        mediaType = 23; // 360ArcadeGame
                        break;
                    case OfferingTypeEnum.GameConsumable:
                        mediaType = 24; // 360ConsumableContent
                        break;
                    case OfferingTypeEnum.Video:
                        mediaType = 30; // GameVideo
                        break;
                    case OfferingTypeEnum.GameTrailer:
                        mediaType = 34; // GameTrailer
                        break;
                    default:
                        mediaType = 0;
                        break;
                }

                return mediaType;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\Database\UserCommercedbWS.cs ===
using System;
using System.Collections;
using System.Text;
using System.Transactions;
using Microsoft.Webstore.WstClient;

using xonline.common.sql.webstore;
using xonline.common.config;
using xonline.common.protocol;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.Billing;
using System.Collections.Generic;

namespace ServerTestFramework.Database
{
    /// <summary>
    /// A class contains purchase transaction related data
    /// </summary>
    public class PurchaseTranasction
    {
        private int status;
        public int Status
        {
            get { return status; }
            set { status = value; }
        }

        private byte origin;
        public byte Origin
        {
            get { return origin; }
            set { origin = value; }
        }

        private uint titleId;
        public uint TitleId
        {
            get { return titleId; }
            set { titleId = value; }
        }

        private uint hresult;
        public uint HResult
        {
            get { return hresult; }
            set { hresult = value; }
        }
    }


    /// <summary>
    /// class contains CTP  transaction related data
    /// </summary>
    public class CTPPurchaseTranasction
    {
        private DMPTransactionStatus status;
        public DMPTransactionStatus Status
        {
            get { return status; }
            set { status = value; }
        }
       
        private uint hresult;
        public uint HResult
        {
            get { return hresult; }
            set { hresult = value; }
        }

        private uint cTPErrorCode;
        public uint CTPErrorCode
        {
            get { return cTPErrorCode; }
            set { cTPErrorCode = value; }
        }

        private QueueState state;
        public QueueState State
        {
            get { return state; }
            set { state = value; }
        }

    }
    /// <summary>
    /// Interfaces with the UserCommcerceDB WebStore - taking into account partitioned tables
    /// </summary>
    public class UserCommercedbWS
    {
        //static constructor
        static UserCommercedbWS()
        {
            //We can catch the first time UserCommercedbWS is referenced here and force the environment to be reset.
            //This doesn't catch cases where the environment is changed after starting, but it's an improvement over never catching it.
            Global.ResetEnvironment();
        }

        // Using Webstore. select statement only, can set to AnyPartition by making hash to null
        public static object ExecuteSQLScalar(string sql, object hash)
        {
            return WebstoreDB.ExecuteSQLScalar(ConfigUtil.GetUserCommerceWebstoreApp(), sql, hash);
        }

        // Using Webstore. WRITEONLY command type, can set to All Physical Partitions by makeing hash to null
        public static int ExecuteSQLNonQuery(string sql, object hash)
        {
            return WebstoreDB.ExecuteSQLNonQuery(ConfigUtil.GetUserCommerceWebstoreApp(), sql, hash);
        }

        // Using Webstore. "select count" statement only.  Sums together the scalar returned 
        // from each physical partition and returns that.
        public static uint ExecuteSQLSelectCount(string sql)
        {
            return WebstoreDB.ExecuteSQLSelectCount(ConfigUtil.GetUserCommerceWebstoreApp(), sql);
        }

        // get the total number of physical partitions
        public static int WstPhysicalPartitionCount()
        {
            return WebstoreDB.WstPhysicalPartitionCount(ConfigUtil.GetUserCommerceWebstoreApp());
        }

        // get the logical partition from hash (si_hash_bucket)
        public static int GetHashBucket(object hash)
        {
            return WebstoreDB.GetHashBucket(ConfigUtil.GetUserCommerceWebstoreApp(), hash);
        }

        /// <summary>
        /// Executes a SQL SELECT statement using the provided UodbTable object. Results
        /// are stored in the dbtable.
        /// </summary>
        /// <param name="dbtable">UodbTable object to use. Must have 1 or more constraints
        /// set. Expected to only return 1 row.</param>
        public static int ExecuteSQLSelect(UodbTable dbtable)
        {
            return ExecuteSQLSelect(dbtable, null);
        }

        // for speical tables like t_dmp_purchase_transaction_music_details and t_dmp_purchase_transaction_music_items,
        // the hash column is userPuid, but it is not a column in the table, instead it is borrowed from another table, for this
        // case, t_dmp_purchase_transactions table. So we add the hashCol as the second input parameter here
        public static int ExecuteSQLSelect(UodbTable dbtable, object hashCol)
        {
            return WebstoreDB.ExecuteSQLSelect(ConfigUtil.GetUserCommerceWebstoreApp(), dbtable, hashCol);
        }

        /// <summary>
        /// Executes a SQL UPDATE statement using the provided UodbTable object.
        /// </summary>
        /// <param name="dbtable">UodbTable object to use. Must have 1 or more constraints
        /// set and 1 or more properties to update.</param>
        public static int ExecuteSQLUpdate(UodbTable dbtable)
        {
            string sql = dbtable.GetSqlUpdateStatement();
            Global.RO.Debug("Executing UodbTable UPDATE: {0}", sql);
            return ExecuteSQLWriteOnly(dbtable, sql);
        }

        public static int ExecuteSQLWriteOnly(UodbTable dbtable, string sql)
        {
            object hash = WebstoreDB.GetHashFromUodbTable(dbtable);
            // The new trigger will update the change datetime as well, thus returning 2
            // updated rows. Divide by 2 to "fix" this.
            return ExecuteSQLNonQuery(sql, hash) / 2;
        }


        //////////////////////////////////////////////////////////////////////////
        // Purchase transaction tables

        /// <summary>
        /// Get purchase transaction
        /// </summary>
        /// <param name="userPuid"></param>
        /// <returns>PurchaseTransaction</returns>
        private static PurchaseTranasction GetPurchaseTransaction(string tableName, ulong userPuid, string newSql)
        {
            PurchaseTranasction transaction = null;
            if (tableName == null)
                tableName = "";
            string sql = "select i_status_id, i_hresult from " + tableName + 
                " WITH (NOLOCK) where bi_user_puid = @bi_user_puid order by dt_change_datetime DESC";
            if (!string.IsNullOrEmpty(newSql))
                sql = newSql;

            using (WSClient ws = new WSClient(ConfigUtil.GetUserCommerceWebstoreApp(), CmdType.WRITETHENREAD_COMMANDTYPE))
            {
                ws.PartitionType = WstPartitionType.Logical;
                ws.SetHashVal(userPuid);
                ws.CommandSql = sql;
                ws.AddParameter("@bi_user_puid", userPuid);

                using (WstDataReader r = ws.Execute())
                {
                    if (r.Read())
                    {

                        transaction = new PurchaseTranasction();
                        transaction.Status = (int)r.GetInt32(0);

                        object obj = r.GetValue(1);
                        if (obj is System.DBNull)
                            transaction.HResult = 0;
                        else
                            transaction.HResult = (uint)Convert.ToInt32(obj);
                        
                        if (r.FieldCount > 2)
                        {
                            transaction.Origin = (byte)r.GetByte(2);
                            transaction.TitleId = (uint)r.GetInt32(3);
                        }

                    }

                    r.Close();
                }
            }

            return transaction;
        }

        public static PurchaseTranasction GetDmpPurchaseTransaction(ulong userPuid)
        {
            string sql = "select i_status_id, i_hresult, ti_purchase_origin, i_purchasing_title_id from " + 
                "dbo.t_dmp_purchase_transactions WITH (NOLOCK) where bi_user_puid = @bi_user_puid order by dt_change_datetime DESC";
            return GetPurchaseTransaction(null, userPuid, sql);
        }

        public static PurchaseTranasction GetDmpRewardTransaction(ulong userPuid)
        {
            return GetPurchaseTransaction("dbo.t_dmp_reward_transactions", userPuid, null);
        }

        public static PurchaseTranasction GetScsPurchaseItemTransaction(ulong userPuid)
        {
            return GetPurchaseTransaction("dbo.t_scs_purchaseitem_transactions", userPuid, null);
        }

        public static PurchaseTranasction GetScsSubmitOrderTransaction(ulong userPuid)
        {
            string sql = "select i_status_id, i_bdk_hresult, ti_purchase_origin, i_purchasing_title_id from " +
                "dbo.t_scs_SubmitOrder_transactions WITH (NOLOCK) where bi_user_puid = @bi_user_puid order by dt_change_datetime DESC";
            return GetPurchaseTransaction(null, userPuid, sql);
        }

        public static PurchaseTranasction GetFinBusTransaction(ulong userPuid)
        {
            return GetPurchaseTransaction("dbo.t_finbus_transactions_v2", userPuid, null);
        }

        public static PurchaseTranasction GetDmpMusicPurchaseTransaction(ulong userPuid)
        {
            string sql = "select t.i_status_id, t.i_hresult, t.ti_purchase_origin, t.i_purchasing_title_id from dbo.t_dmp_purchase_transactions t with (nolock) " +
                "inner join dbo.t_dmp_purchase_transaction_music_details d on t.uid_tracking_guid = d.uid_tracking_guid " +
                "where t.bi_user_puid = @bi_user_puid order by t.dt_change_datetime desc";

            return GetPurchaseTransaction(null, userPuid, sql);
        }

        /// <summary>
        /// Update the finbus transaction start date. This is needed due to a change in p_finbus_record_item_preintent_v2 to
        /// block a second transaction for the same user in 120 seconds
        /// </summary>
        /// <param name="userPuid"></param>
        /// <param name="newStart"></param>
        public static void UpdateFinBusTransactionStartDate(ulong userPuid, DateTime newStart)
        {
            string sql = "update dbo.t_finbus_transactions_v2 set dt_change_datetime = @newStart where bi_user_puid = @bi_user_puid";

            using (WSClient ws = new WSClient(ConfigUtil.GetUserCommerceWebstoreApp(), CmdType.WRITEONLY_COMMANDTYPE))
            {
                ws.PartitionType = WstPartitionType.Logical;
                ws.SetHashVal(userPuid);
                ws.CommandSql = sql;
                ws.AddParameter("@bi_user_puid", userPuid);
                ws.AddParameter("@newStart", newStart);

                if (ws.ExecuteNonQuery() <= 0)
                    throw new UnexpectedTestResultException("UpdateFinBusTransactionStartDate failed: no row has been changed.");
            }
        }

        /// <summary>
        /// Update new alternate url for dmp PurchaseItem transaction
        /// </summary>
        /// <param name="userPuid"></param>
        /// <param name="newUrl">new alternate url</param>
        public static void UpdateDmpPurchaseItemAlternateUrl(ulong userPuid, string newUrl)
        {
            string sql = "update dbo.t_dmp_purchase_transactions set vc_alternate_url = @url where bi_user_puid = @bi_user_puid";

            using (WSClient ws = new WSClient(ConfigUtil.GetUserCommerceWebstoreApp(), CmdType.WRITEONLY_COMMANDTYPE))
            {
                ws.PartitionType = WstPartitionType.Logical;
                ws.SetHashVal(userPuid);
                ws.CommandSql = sql;
                ws.AddParameter("@bi_user_puid", userPuid);
                ws.AddParameter("@url", newUrl);

                if (ws.ExecuteNonQuery() <= 0)
                    throw new UnexpectedTestResultException("UpdateDmpPurchaseItemAlternateUrl failed: no row has been changed.");
            }
        }

        /// <summary>
        /// Update new alternate url for dmp AddPromotionPoints transaction
        /// </summary>
        /// <param name="userPuid"></param>
        /// <param name="newUrl">new alternate url</param>
        public static void UpdateDmpRewardAlternateUrl(ulong userPuid, string newUrl)
        {
            string sql = "update dbo.t_dmp_reward_transactions set vc_alternate_url = @url where bi_user_puid = @bi_user_puid";

            using (WSClient ws = new WSClient(ConfigUtil.GetUserCommerceWebstoreApp(), CmdType.WRITEONLY_COMMANDTYPE))
            {
                ws.PartitionType = WstPartitionType.Logical;
                ws.SetHashVal(userPuid);
                ws.CommandSql = sql;
                ws.AddParameter("@bi_user_puid", userPuid);
                ws.AddParameter("@url", newUrl);

                if (ws.ExecuteNonQuery() <= 0)
                    throw new UnexpectedTestResultException("UpdateDmpRewardAlternateUrl failed: no row has been changed.");
            }
        }

        /// <summary>
        /// Update new alternate url for scs PurchaseItem transaction
        /// </summary>
        /// <param name="userPuid"></param>
        /// <param name="newUrl">new alternate url</param>
        public static void UpdateScsPurchaseItemAlternateUrl(ulong userPuid, string newUrl)
        {
            string sql = "update dbo.t_scs_purchaseitem_transactions set vc_alternate_url = @url where bi_user_puid = @bi_user_puid";

            using (WSClient ws = new WSClient(ConfigUtil.GetUserCommerceWebstoreApp(), CmdType.WRITEONLY_COMMANDTYPE))
            {
                ws.PartitionType = WstPartitionType.Logical;
                ws.SetHashVal(userPuid);
                ws.CommandSql = sql;
                ws.AddParameter("@bi_user_puid", userPuid);
                ws.AddParameter("@url", newUrl);

                if (ws.ExecuteNonQuery() <= 0)
                    throw new UnexpectedTestResultException("UpdateScsPurchaseItemAlternateUrl failed: no row has been changed.");
            }
        }

        /// <summary>
        /// Update vc_alternate_scs_url for SCS SubmitOrder transaction
        /// </summary>
        /// <param name="userPuid"></param>
        /// <param name="newUrl">new alternate url</param>
        public static void UpdateScsSubmitOrderAlternateScsUrl(ulong userPuid, string newUrl)
        {
            string sql = "update dbo.t_scs_SubmitOrder_transactions set vc_alternate_scs_url = @url where bi_user_puid = @bi_user_puid";

            using (WSClient ws = new WSClient(ConfigUtil.GetUserCommerceWebstoreApp(), CmdType.WRITEONLY_COMMANDTYPE))
            {
                ws.PartitionType = WstPartitionType.Logical;
                ws.SetHashVal(userPuid);
                ws.CommandSql = sql;
                ws.AddParameter("@bi_user_puid", userPuid);
                ws.AddParameter("@url", newUrl);

                if (ws.ExecuteNonQuery() <= 0)
                    throw new UnexpectedTestResultException("UpdateScsSubmitOrderAlternateScsUrl failed: no row has been changed.");
            }
        }


        /// <summary>
        /// Update vc_alternate_ctp_url for CTP transaction
        /// </summary>
        /// <param name="userPuid"></param>
        /// <param name="newUrl">new alternate url</param>
        public static void UpdateCTPQueueAlternateUrl(ulong userPuid, string newUrl)
        {
            string sql = "update dbo.t_ctp_purchase_transactions set vc_alternate_ctp_url = @url where bi_user_puid = @bi_user_puid";

            using (WSClient ws = new WSClient(ConfigUtil.GetUserCommerceWebstoreApp(), CmdType.WRITEONLY_COMMANDTYPE))
            {
                ws.PartitionType = WstPartitionType.Logical;
                ws.SetHashVal(userPuid);
                ws.CommandSql = sql;
                ws.AddParameter("@bi_user_puid", userPuid);
                ws.AddParameter("@url", newUrl);

                if (ws.ExecuteNonQuery() <= 0)
                    throw new UnexpectedTestResultException("UpdateCTPQueueAlternateUrl failed: no row has been changed.");
            }
        }

        /// <summary>
        /// Update vc_behavior_injection for FinBus transaction. Also update the dt_consider_pending field,
        /// so the thread won't wait 2 minutes
        /// </summary>
        /// <param name="userPuid"></param>
        /// <param name="newBif">new BIF field</param>
        public static void UpdateFinBusTransactionBif(ulong userPuid, string newBif)
        {
            DateTime newTime = DateTime.UtcNow;
            string sql = "update dbo.t_finbus_transactions_v2 set vc_behavior_injection = @bif, dt_consider_pending = @newTime where bi_user_puid = @bi_user_puid";

            using (WSClient ws = new WSClient(ConfigUtil.GetUserCommerceWebstoreApp(), CmdType.WRITEONLY_COMMANDTYPE))
            {
                ws.PartitionType = WstPartitionType.Logical;
                ws.SetHashVal(userPuid);
                ws.CommandSql = sql;
                ws.AddParameter("@bi_user_puid", userPuid);
                ws.AddParameter("@bif", newBif);
                ws.AddParameter("@newTime", newTime);

                if (ws.ExecuteNonQuery() <= 0)
                    throw new UnexpectedTestResultException("UpdateFinBusTransactionBif failed: no row has been changed.");
            }
        }

        // User puid alone is not primary key, use this function carefully
        public static void UpdateMusicNetAlternateUrl(ulong userPuid, string newUrl)
        {
            string sql = "update dbo.t_dmp_purchase_transaction_music_details set vc_alternate_url = '" + newUrl + "' " +
                "where uid_tracking_guid in (select uid_tracking_guid from dbo.t_dmp_purchase_transactions where bi_user_puid = 0x" + userPuid.ToString("x") + ")";

            using (WSClient ws = new WSClient(ConfigUtil.GetUserCommerceWebstoreApp(), CmdType.WRITEONLY_COMMANDTYPE))
            {
                ws.PartitionType = WstPartitionType.Logical;
                ws.SetHashVal(userPuid);
                ws.CommandSql = sql;

                if (ws.ExecuteNonQuery() <= 0)
                    throw new UnexpectedTestResultException("UpdateMusicNetAlternateUrl failed: no row has been changed.");
            }
        }

        public static void UpdateMusicPurchaseStatus(ulong userPuid, string externalId, int newStatus)
        {
            string sql = "update dbo.t_dmp_purchase_transactions set i_status_id = " + newStatus + " " +
                "where bi_user_puid = 0x" + userPuid.ToString("x") +
                " and uid_tracking_guid in (select uid_tracking_guid from dbo.t_dmp_purchase_transaction_music_details where vc_external_id ='" + externalId + "')";

            using (WSClient ws = new WSClient(ConfigUtil.GetUserCommerceWebstoreApp(), CmdType.WRITEONLY_COMMANDTYPE))
            {
                ws.PartitionType = WstPartitionType.Logical;
                ws.SetHashVal(userPuid);
                ws.CommandSql = sql;

                if (ws.ExecuteNonQuery() <= 0)
                    throw new UnexpectedTestResultException("UpdateMusicPurchaseStatus failed: no row has been changed.");
            }
        }

        //////////////////////////////////////////////////////////////////////////
        // t_scs_SubmitOrder_transaction_media

        public static void GetScsSubmitOrderTransactionMediaPriceInfo(ulong userPuid, Guid offerId, out decimal displayPrice, out decimal taxAmount, out decimal priceNetOfTax)
        {
            displayPrice = taxAmount = priceNetOfTax = -1;

            string sql =
                "SELECT dec_display_price, dec_tax_amount, dec_price_net_of_tax FROM " +
                "dbo.t_scs_SubmitOrder_transaction_media som WITH (NOLOCK) " +
                "WHERE som.bi_user_puid = @bi_user_puid AND som.uid_offer_id = @uid_offer_id";

            using (WSClient ws = new WSClient(ConfigUtil.GetUserCommerceWebstoreApp(), CmdType.WRITETHENREAD_COMMANDTYPE))
            {
                ws.PartitionType = WstPartitionType.Logical;
                ws.SetHashVal(userPuid);
                ws.CommandSql = sql;
                ws.AddParameter("@bi_user_puid", userPuid);
                ws.AddParameter("@uid_offer_id", offerId.ToString());

                using (WstDataReader r = ws.Execute())
                {
                    if (r.Read())
                    {
                        int colNum = 0;

                        displayPrice = r.GetDecimal(colNum++);
                        taxAmount = r.GetDecimal(colNum++);
                        priceNetOfTax = r.GetDecimal(colNum++);
                    }
                }
            }
        }

        public static void GetScsSubmitOrderTransactionAmountInfo(ulong userPuid, Guid offerId, out decimal totalAmount, out decimal totalTaxAmount)
        {
            totalAmount = totalTaxAmount = -1;

            string sql =
                "SELECT dec_total_amount, dec_total_tax_amount FROM " +
                "dbo.t_scs_SubmitOrder_transactions sot WITH (NOLOCK) " +
                "INNER JOIN " +
                "dbo.t_scs_SubmitOrder_transaction_media som WITH (NOLOCK) " +
                "ON (sot.bi_user_puid = som.bi_user_puid AND sot.uid_tracking_guid = som.uid_tracking_guid) " +
                "WHERE som.bi_user_puid = @bi_user_puid AND som.uid_offer_id = @uid_offer_id";

            using (WSClient ws = new WSClient(ConfigUtil.GetUserCommerceWebstoreApp(), CmdType.WRITETHENREAD_COMMANDTYPE))
            {
                ws.PartitionType = WstPartitionType.Logical;
                ws.SetHashVal(userPuid);
                ws.CommandSql = sql;
                ws.AddParameter("@bi_user_puid", userPuid);
                ws.AddParameter("@uid_offer_id", offerId.ToString());

                using (WstDataReader r = ws.Execute())
                {
                    if (r.Read())
                    {
                        int colNum = 0;

                        totalAmount = r.GetDecimal(colNum++);
                        totalTaxAmount = r.GetDecimal(colNum++);
                    }
                }
            }
        }

        //////////////////////////////////////////////////////////////////////////
        // t_user_offer_instance_purchases

        public static int DoesUserHaveOffers(ulong userPuid)
        {
            string sql = "SELECT count(*) FROM dbo.t_user_offer_instance_purchases WITH (NOLOCK) WHERE bi_user_puid = @bi_user_puid";

            int retVal = 0;

            using (WSClient ws = new WSClient(ConfigUtil.GetUserCommerceWebstoreApp(), CmdType.WRITETHENREAD_COMMANDTYPE))
            {
                ws.PartitionType = WstPartitionType.Logical;
                ws.SetHashVal(userPuid);
                ws.CommandSql = sql;
                ws.AddParameter("@bi_user_puid", userPuid);

                using (WstDataReader r = ws.Execute())
                {
                    if (r.Read())
                    {
                        retVal = r.GetInt32(0);
                    }

                    r.Close();
                }
            }
            return retVal;
        }

        // get CTP purchase Transaction from t_ctp_purchase_transactions
        public static CTPPurchaseTranasction GetCTPTransaction(ulong userPuid)
        {
            Hashtable hashTable = new Hashtable();
            CTPPurchaseTranasction transaction = null;

            string sql = "SELECT i_status_id, i_state_id, i_xonline_hresult, i_ctp_error_code FROM dbo.t_ctp_purchase_transactions WHERE bi_user_puid = 0x" + userPuid.ToString("x") + " ORDER BY dt_change_datetime DESC";

            using (WSClient ws = new WSClient(ConfigUtil.GetUserCommerceWebstoreApp(), CmdType.WRITETHENREAD_COMMANDTYPE))
            {
                ws.PartitionType = WstPartitionType.Logical;
                ws.SetHashVal(userPuid);
                ws.CommandSql = sql;

                using (WstDataReader r = ws.Execute())
                {
                    while (r.Read())
                    {             
                        if(transaction == null)
                            transaction = new CTPPurchaseTranasction();
                        transaction.Status  = (DMPTransactionStatus) r.GetInt32(0);
                        transaction.State = (QueueState)r.GetInt32(1);
                        transaction.HResult = (uint)r.GetInt32(2);
                        transaction.CTPErrorCode = (uint)r.GetInt32(3);
                        break;
                    }

                    r.Close();
                }
            }
            return transaction;
        }




        // get all EMS offers back from the new license table
        public static Hashtable GetEMSOfferPurchased(ulong userPuid)
        {
            Hashtable hashTable = new Hashtable();

            string sql = "SELECT uid_offer_id, uid_offer_instance_id, i_offer_media_type_id FROM dbo.t_user_offer_instance_purchases WHERE i_store_id =1 and bi_user_puid = 0x" + userPuid.ToString("x");

            using (WSClient ws = new WSClient(ConfigUtil.GetUserCommerceWebstoreApp(), CmdType.WRITETHENREAD_COMMANDTYPE))
            {
                ws.PartitionType = WstPartitionType.Logical;
                ws.SetHashVal(userPuid);
                ws.CommandSql = sql;

                using (WstDataReader r = ws.Execute())
                {
                    while (r.Read())
                    {
                        XbosWS.EMSOfferInfo info = new XbosWS.EMSOfferInfo();
                        info.OfferGuid = r.GetGuid(0);
                        info.OfferInstanceId = r.GetGuid(1);
                        info.OfferMediaType = r.GetInt32(2);

                        hashTable.Add(info.OfferGuid, info);
                    }

                    r.Close();
                }
            }
            return hashTable;
        }


        public static ulong GetMachinePuidForOfferPurchased(ulong userPuid, Guid offerId)
        {
            ulong machinePuid = 0;
            string sql = "select bi_machine_puid from t_user_offer_instance_purchases where bi_user_puid=0x" +
                userPuid.ToString("x") + " and uid_offer_id='" + offerId.ToString() + "'";

            using (WSClient ws = new WSClient(ConfigUtil.GetUserCommerceWebstoreApp(), CmdType.WRITETHENREAD_COMMANDTYPE))
            {
                ws.PartitionType = WstPartitionType.Logical;
                ws.SetHashVal(userPuid);
                ws.CommandSql = sql;
                using (WstDataReader r = ws.Execute())
                {
                    if (r.Read())
                    {
                        machinePuid = (ulong)r.GetInt64(0);
                    }

                    r.Close();

                    return machinePuid;
                }

            }
        }

        public static void SimulatePurchaseOffers(ulong userPuid, ulong machinePuid, Guid offerInstanceId, Guid offerId, int mediaTypeId, int storeId)
        {
            SimulatePurchaseOffers(userPuid, machinePuid, offerInstanceId, offerId, mediaTypeId, storeId, null);
        }

        public static void SimulatePurchaseOffers(ulong userPuid, ulong machinePuid, Guid offerInstanceId, Guid offerId, int mediaTypeId, int storeId, DateTime date)
        {
            SimulatePurchaseOffers(userPuid, machinePuid, offerInstanceId, offerId, mediaTypeId, storeId, date.ToString("G"));
        }

        public static void SimulatePurchaseOffers(ulong userPuid, ulong machinePuid, Guid offerInstanceId, Guid offerId, int mediaTypeId, int storeId, string date)
        {
            date = (date == null) ? "getutcdate()" : "'" + date + "'";

            using (WSClient ws = new WSClient(ConfigUtil.GetUserCommerceWebstoreApp(), CmdType.WRITEONLY_COMMANDTYPE))
            {
                String sql = String.Format(@"if not exists(select null from t_user_offer_instance_purchases where bi_user_puid = 0x{0:X16} and uid_offer_instance_id = '{2}')
                                             insert into t_user_offer_instance_purchases (bi_user_puid, bi_machine_puid, uid_offer_instance_id, 
                                              uid_offer_id, i_offer_media_type_id, dt_purchased, si_hash_bucket, dt_change_datetime, i_store_id) 
                                             values (0x{0:X16},0x{1:X16}, '{2}', '{3}', {4}, {5}, {6}, getutcdate(), {7})",
                                             userPuid, machinePuid, offerInstanceId, offerId, mediaTypeId, date, GetHashBucket(userPuid), storeId);

                ws.PartitionType = WstPartitionType.Logical;
                ws.SetHashVal(userPuid);
                ws.CommandSql = sql;

                ws.ExecuteNonQuery();
            }
        }

        public static void SimulatePurchaseMultipleOffers(ulong userPuid, string puchases, bool cleanBeforeInsert)
        {
            using (WSClient ws = new WSClient(ConfigUtil.GetUserCommerceWebstoreApp(), CmdType.WRITEONLY_COMMANDTYPE))
            {
                string sql = "";
                if (cleanBeforeInsert)
                    sql = "delete from t_user_offer_instance_purchases where bi_user_puid = " + userPuid;

                sql += string.Format("\r\n insert into t_user_offer_instance_purchases values " + puchases);

                ws.PartitionType = WstPartitionType.Logical;
                ws.SetHashVal(userPuid);
                ws.CommandSql = sql;

                ws.ExecuteNonQuery();
            }
        }

        public static void DeleteUserOfferPurchaseInstances(ulong userPuid)
        {
            DeleteUserOfferPurchaseInstances(userPuid, Guid.Empty);
        }

        public static void DeleteUserOfferPurchaseInstances(ulong userPuid, Guid offerId)
        {
            StringBuilder sql = new StringBuilder();
            sql.AppendFormat("delete from t_user_offer_instance_purchases where bi_user_puid = 0x{0:X}", userPuid);
            if (offerId != Guid.Empty)
            {
                sql.AppendFormat(" and uid_offer_id = '{0}'", offerId);
            }

            ExecuteSQLNonQuery(sql.ToString(), userPuid);
        }

        /// <summary>
        /// Update the PPV purchased date. This is needed due to a change in p_xbos_check_catalog_offer_licenses to
        /// block a second PPV purchase for the same user in 24 hours
        /// </summary>
        /// <param name="userPuid"></param>
        /// <param name="newDate"></param>
        public static void UpdatePPVPurchasedDate(ulong userPuid, DateTime newDate)
        {
            string sql = "update dbo.t_user_offer_instance_purchases set dt_purchased = @newDate where bi_user_puid = @bi_user_puid";

            using (WSClient ws = new WSClient(ConfigUtil.GetUserCommerceWebstoreApp(), CmdType.WRITEONLY_COMMANDTYPE))
            {
                ws.PartitionType = WstPartitionType.Logical;
                ws.SetHashVal(userPuid);
                ws.CommandSql = sql;
                ws.AddParameter("@bi_user_puid", userPuid);
                ws.AddParameter("@newDate", newDate);

                if (ws.ExecuteNonQuery() <= 0)
                    throw new UnexpectedTestResultException("UpdatePPVPurchasedDate failed: no row has been changed.");
            }
        }

        public static void UpdatePurchasedDate(ulong userPuid, Guid offerInstanceId, DateTime newDate)
        {
            string sql = "update dbo.t_user_offer_instance_purchases set dt_purchased = @newDate where bi_user_puid = @bi_user_puid and uid_offer_instance_id = @uid_offer_instance_id";

            using (WSClient ws = new WSClient(ConfigUtil.GetUserCommerceWebstoreApp(), CmdType.WRITEONLY_COMMANDTYPE))
            {
                ws.PartitionType = WstPartitionType.Logical;
                ws.SetHashVal(userPuid);
                ws.CommandSql = sql;
                ws.AddParameter("@bi_user_puid", userPuid);
                ws.AddParameter("@uid_offer_instance_id", offerInstanceId);
                ws.AddParameter("@newDate", newDate);

                if(ws.ExecuteNonQuery() <= 0)
                {
                    throw new UnexpectedTestResultException("UpdatePurchasedDate failed: now rows updated");
                }
            }
        }

        public static void SimulateAssetPurchased(ulong userPuid, ulong machinePuid, int titleId, ServerTestFramework.LiveService.Billing.Asset[] Assets)
        {
             String offerXml = "";
             StringBuilder assetXml = new StringBuilder();


             for (int i = 0; i < Assets.Length; i++)
             { 
           
                   assetXml.Append(string.Format(
                                "<item assetId=\"{0}\" quantity=\"{1}\" titleID=\"{2}\"/>",
                                Assets[i].AssetID, Assets[i].Quantity, titleId));                            
            }

            TransactionOptions txnOpts = new TransactionOptions();
            txnOpts.IsolationLevel = System.Transactions.IsolationLevel.RepeatableRead;

            using (TransactionScope ts = new TransactionScope(TransactionScopeOption.RequiresNew, txnOpts))
            {
                using (WSClient ws = new WSClient(ConfigUtil.GetUserCommerceWebstoreApp(), CmdType.WRITEONLY_COMMANDTYPE))
                {
                    Guid trackingGuid = new Guid();
                    DateTime transactionEnd = DateTime.UtcNow.AddDays(-30);
                    ws.PartitionType = WstPartitionType.Logical;
                    ws.StoredProc = "dbo.p_xbos_record_media_purchases_and_assets";
                    ws.SetHashVal(userPuid);

                    ws.AddParameter(ParamType.RETVAL, "@hr", 0);
                    ws.AddParameter("@uid_tracking_guid", trackingGuid.ToString());
                    ws.AddParameter("@bi_user_puid", userPuid);
                    ws.AddParameter("@bi_machine_puid", machinePuid);
                    ws.AddParameter("@dt_posting_date", transactionEnd.ToShortDateString());
                    ws.AddParameter("@xml_offers", offerXml);
                    ws.AddParameter("@xml_assets", assetXml.ToString());
                    ws.AddParameter("@si_hash_bucket", ws.Partition);
                    ws.ExecuteNonQuery();
                }

                ts.Complete();
            }
        }

        public static Guid[] GetPurchaseTrackingGuid(ulong userPuid, Guid offerId)
        {
            string sql = "select uid_tracking_guid from t_user_purchase_transactions where bi_user_puid=@bi_user_puid and uid_offer_id=@uid_offer_id";

            List<Guid> transationIds = new List<Guid>();

            using (WSClient ws = new WSClient(ConfigUtil.GetUserCommerceWebstoreApp(), CmdType.WRITETHENREAD_COMMANDTYPE))
            {
                ws.PartitionType = WstPartitionType.Logical;
                ws.SetHashVal(userPuid);
                ws.CommandSql = sql;
                ws.AddParameter("@bi_user_puid", userPuid);
                ws.AddParameter("@uid_offer_id", offerId);

                using (WstDataReader r = ws.Execute())
                {
                    if (r.Read())
                    {
                        transationIds.Add(r.GetGuid(0));
                    }

                    r.Close();
                }
            }
            return transationIds.ToArray();

        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\Database\Editor\BetaGroupEditor.cs ===
using System;
using xonline.common.sql.webstore;
using xonline.common.config;
using Microsoft.Webstore.WstClient;

using System.Collections.Generic;

using ServerTestFramework.Utilities;

namespace ServerTestFramework.Database
{
    /// <summary>
    /// Utility for altering or creating beta groups.
    /// </summary>
    public class BetaGroupEditor: EditorCommon
    {
        /// <summary> Beta Group ID.  This is the only non-cached information we store about the beta group. </summary>
        public System.Guid Id
        {
            get { return id; }
        }

        private System.Guid id;

        /// <summary>
        ///     Nuke the group from orbit. This includes all references to it. You better be sure.
        /// </summary>
        public static void NukeGroup(Guid id)
        {
            BetaGroupEditor bge = FromId(id);
            if (bge.Exists)
            {
                UodbWS.ExecuteSQLNonQuery(String.Format("delete from t_title_versions where uid_beta_group_id = '{0}'", bge.Id), null);
                UodbWS.ExecuteSQLNonQuery(String.Format("delete from t_machine_beta_groups where uid_group_id = '{0}'", bge.Id), null);
                UodbWS.ExecuteSQLNonQuery(String.Format("delete from t_beta_group where uid_group_id = '{0}'", bge.Id), null);
                bge.RemoveReleaseInfo();
            }
        }

        #region Create an instance of BetaGroupEditor

        /// <summary>
        ///     Get all beta groups, accross all partitions.
        /// </summary>
        public static IEnumerable<BetaGroupEditor> GetAllBetaGroups()
        {
            return UodbWS.ExecuteOnAllPartitions("SELECT uid_group_id FROM t_beta_group", delegate(WstDataReader reader) { return FromId((Guid)reader["uid_group_id"]); });
        }

        /// <summary> Construct from an existing beta group id (does not guarentee that the group exists). </summary>
        public static BetaGroupEditor FromId(System.Guid existingId)
        {
            BetaGroupEditor bge=new BetaGroupEditor();
            bge.id=existingId;
            return bge;
        }

        /// <summary> Constructs from a beta group id, creating the beta group in the db if it does not already exist. </summary>
        public static BetaGroupEditor CreateOrUseExistingId(System.Guid existingId)
        {
            BetaGroupEditor bge=new BetaGroupEditor();
            bge.id=existingId;

            //only add the entry if needed
            if (!UodbWS.DoesBetaGroupExist(existingId))
            {
                string queryString = String.Format("exec p_beta_group_create '{0}', 'Unnamed test group {0}', '{1}', {2}",
                        bge.id, System.Security.Principal.WindowsIdentity.GetCurrent().Name, UodbWS.GetHashBucket(bge.id));

                UodbWS.ExecuteSQLNonQuery(queryString, bge.id);
            }

            return bge;
        }

        /// <summary> Creates a new beta group. </summary>
        public static BetaGroupEditor CreateNew()
        {
            return CreateOrUseExistingId(System.Guid.NewGuid());
        }

        //constructor is not for public consumption.
        private BetaGroupEditor()
        {
        }

        #endregion

        // --

        #region Lookup or alter properties of the beta group

        /// <summary> Whether the beta group actually exists in the db. </summary>
        public override bool Exists
        {
            get
            {
                if (HasCachedEntry("exists"))
                {
                    return (bool)cache["exists"];
                }

                bool exists=UodbWS.DoesBetaGroupExist(id);
                SetCacheEntry("exists", exists);
                return exists;
            }
        }

        /// <summary> Name of the group. </summary>
        public string Name
        {
            get
            {
                return GetGenericUserProperty<string>("vc_group_name", "groupname");
            }

            set
            {
                SetGenericUserProperty("vc_group_name", "groupname", value);
            }
        }

        /// <summary> Who created the group. </summary>
        public string Creator
        {
            get
            {
                return GetGenericUserProperty<string>("vc_created_by", "creator");
            }

            set
            {
                SetGenericUserProperty("vc_created_by", "creator", value);
            }
        }

        /// <summary> When the group was created. </summary>
        public System.DateTime Created
        {
            get
            {
                return GetGenericUserProperty<System.DateTime>("dt_created", "createDate");
            }

            set
            {
                SetGenericUserProperty("dt_created", "createDate", value);
            }
        }

        /// <summary> Webstore SQL hash bucket. </summary>
        public short HashBucket
        {
            get
            {
                return GetGenericUserProperty<short>("si_hash_bucket", "hash");
            }

            set
            {
                SetGenericUserProperty("si_hash_bucket", "hash", value);
            }
        }

        /// <summary> Generic implementation of returning a property from a table hashed on guid (or cache if able). </summary>
        private TypeOfProperty GetGenericUserProperty<TypeOfProperty>(string columnName, string cacheName)
        {
            if (HasCachedEntry(cacheName))
            {
                return (TypeOfProperty)cache[cacheName];
            }

            object ret=UodbWS.ExecuteSQLScalar("select "+columnName+" from t_beta_group where uid_group_id='"+id+"'", id);
            if (ret!=null)
            {
                TypeOfProperty val=(TypeOfProperty)System.Convert.ChangeType(ret, typeof(TypeOfProperty));
                SetCacheEntry(cacheName, val);
                return val;
            }

            throw new RowDoesNotExistException("t_beta_group", columnName, id.ToString());
        }

        /// <summary> Generic implementation of setting a property in a table hashed on guid.  The value must be convertible to a string in a way that SQL understands. </summary>
        private void SetGenericUserProperty<TypeOfProperty>(string columnName, string cacheName, TypeOfProperty value)
        {
            UodbWS.ExecuteSQLNonQuery("update t_beta_group set "+columnName+"='"+EscapeString(value.ToString())+"' where uid_group_id='"+id+"'", id);
            SetCacheEntry(cacheName, value);
        }

        #endregion

        //Short descriptive useful string that doesn't require db hits
        public override string ToString()
        {
            return "Beta Group"+id;
        }

        //Long string containing every field of the beta group.  This call can be expensive, as it may make db hits.
        public string FullDescription
        {
            get
            {
                if (!Exists)
                {
                    return "Nonexistant "+ToString();
                }
                else
                {
                    return ToString()+
                        "(Name="+Name+
                        ", Creator="+Creator+
                        ", Created="+Created+")";
                }
            }
        }

        #region Add or remove "assets" for the beta group

        /// <summary> Returns all machines in the group. </summary>
        public ulong[] GetAllMachines()
        {
            List<ulong> machs=new List<ulong>();

            using (WSClient ws=new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITETHENREAD_COMMANDTYPE))
            {
                for (int p=0; p<ws.PhysicalPartitions; ++p)
                {
                    ws.PhysicalPartition=p;
                    ws.CommandSql="select bi_machine_puid from t_machine_beta_groups where uid_group_id='"+id+"'";

                    using (WstDataReader reader=ws.Execute())
                    {
                        while (reader.Read())
                        {
                            machs.Add((ulong)(long)reader[0]);
                        }
                    }
                }
            }

            return machs.ToArray();
        }

        /// <summary> Returns all console IDs in the group. </summary>
        public string[] GetAllConsoles()
        {
            List<string> machs=new List<string>();

            using (WSClient ws=new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITETHENREAD_COMMANDTYPE))
            {
                for (int p=0; p<ws.PhysicalPartitions; ++p)
                {
                    ws.PhysicalPartition=p;
                    ws.CommandSql="select vc_serial_num from t_machine_beta_groups as tmbg inner join t_machines as tm on tm.bi_machine_puid=tmbg.bi_machine_puid  where uid_group_id='"+id+"'";

                    using (WstDataReader reader=ws.Execute())
                    {
                        while (reader.Read())
                        {
                            machs.Add((string)reader[0]);
                        }
                    }
                }
            }

            return machs.ToArray();
        }

        /// <summary> Removes all machine from the group. </summary>
        public void RemoveAllMachines()
        {
            UodbWS.ExecuteSQLNonQuery("delete from t_machine_beta_groups where uid_group_id='"+id+"'", null);
        }

        /// <summary> Add a machine to the group, if it does not already contain it. </summary>
        public void AddMachine(ulong machine)
        {
            UodbWS.ExecuteSQLNonQuery("exec p_beta_group_machine_add "+(long)machine+", '"+id+"'" + "," + UodbWS.GetHashBucket(machine), machine);
        }

        public class BetaReleaseInfo
        {
            public string SOMRevision;
            public string SMRevision;
            public int FlashVersion;
        }

        public BetaReleaseInfo GetReleaseInfo()
        {
            using (WSClient ws=new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITETHENREAD_COMMANDTYPE))
            {
                ws.PartitionType=WstPartitionType.Logical;
                WebstoreDB.SetHashValue(ws, Id);
                ws.CommandSql="select vc_som_revision, vc_sm_revision, i_flash_version from t_beta_group_releases where uid_group_id='"+Id+"'";

                using (WstDataReader reader=ws.Execute())
                {
                    if (reader.Read())
                    {
                        BetaReleaseInfo info=new BetaReleaseInfo();
                        info.SOMRevision=(string)reader[0];
                        info.SMRevision=(string)reader[1];
                        info.FlashVersion=(int)reader[2];

                        return info;
                    }
                    else
                    {
                        return null;
                    }
                }
            }
        }

        public void SetReleaseInfo(BetaReleaseInfo info)
        {
            int bucket=UodbWS.GetHashBucket(Id);
            string query=QueryGenerator.GenerateUpdateOrInsert("t_beta_group_releases",
                                                  new string[]{"uid_group_id", "vc_som_revision", "vc_sm_revision", "i_flash_version",            "si_hash_bucket"},
                                                  new string[]{Id.ToString(),  info.SOMRevision,  info.SMRevision,  info.FlashVersion.ToString(), bucket.ToString()},
                                                  new string[]{"uid_group_id"});
            UodbWS.ExecuteSQLNonQuery(query, Id);
        }

        public void RemoveReleaseInfo()
        {
            UodbWS.ExecuteSQLNonQuery("delete from t_beta_group_releases where uid_group_id='"+Id+"'", Id);
        }

        #endregion
    };
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\Database\Editor\ConsoleBanEditor.cs ===
using xonline.common.sql.webstore;
using xonline.common.config;
using Microsoft.Webstore.WstClient;

using ServerTestFramework.Utilities;

namespace ServerTestFramework.Database
{
    /// <summary>
    /// Utility for manipulating console bans directly in the database.
    /// </summary>
    public class ConsoleBanEditor
    {
        /// <summary>
        /// Console ID.  This is the only non-cached information we store about the console (or set of consoles).
        /// </summary>
        public string ConsoleId
        {
            get { return id; }
        }

        private string id;

        // --
        #region Create an instance of ConsoleBanEditor

        /// <summary>
        /// Construct from a console id (does not guarentee that the console exists).
        /// </summary>
        public static ConsoleBanEditor FromConsoleId(string consoleId)
        {
            ConsoleBanEditor cbe=new ConsoleBanEditor();
            cbe.id=consoleId;
            return cbe;
        }

        //constructor is not for public consumption.
        private ConsoleBanEditor()
        {
        }

        #endregion

        #region Adjust "assets" of the console ban

        public struct ConsoleBanStatus: System.IEquatable<ConsoleBanStatus>
        {
            public string ConsoleId;
            public int ReasonCode; //reason for the ban
            public System.DateTime StartDate; //Start date of the ban.  There is no end date.
            public short HashBucket;

            public ConsoleBanStatus(string id, int reason, System.DateTime start)
            {
                ConsoleId=id;
                ReasonCode=reason;
                StartDate=start;
                HashBucket=(short)UodbWS.GetHashBucket(id);
            }

            public override bool Equals(object other)
            {
                if(!(other is ConsoleBanStatus))
                {
                    return false;
                }

                return Equals((ConsoleBanStatus)other);
            }

            public bool Equals(ConsoleBanStatus other)
            {
                return ConsoleId==other.ConsoleId &&
                    ReasonCode==other.ReasonCode &&
                    System.Math.Abs((StartDate-other.StartDate).TotalMilliseconds)<10 &&
                    HashBucket==other.HashBucket;
            }

            public override int GetHashCode()
            {
                return unchecked((ConsoleId!=null?ConsoleId.GetHashCode():0)^ReasonCode);
            }

            public override string ToString()
            {
                return "ConsoleBanStatus(ConsoleId="+ConsoleId+" ReasonCode="+string.Format("0x{0:X}", ReasonCode)+" StartDate="+StartDate+" HashBucket="+HashBucket+")";
            }
        };

        /// <summary> Removes all console bans from this console.  This does not remove machine bans. </summary>
        public void RemoveAllConsoleBans()
        {
            UodbWS.ExecuteSQLNonQuery("delete from t_machine_banned_console_id where vc_console_id='"+ConsoleId+"'", ConsoleId);
        }

        /// <summary> Adds or updates a console ban for this console using the default reason forever.  This does not add a machine ban. </summary>
        public void BanConsole()
        {
            ConsoleBanStatus bs=new ConsoleBanStatus(ConsoleId, unchecked((int)0x8015190D), System.DateTime.UtcNow-new System.TimeSpan(0, 5, 0));
            BanConsole(bs);
        }

        /// <summary> Adds or updates a console ban for this console.  A console may be banned for multiple reasons.  This does not add a machine ban. </summary>
        public void BanConsole(int ReasonCode, System.DateTime start)
        {
            ConsoleBanStatus bs=new ConsoleBanStatus(ConsoleId, ReasonCode, start);
            BanConsole(bs);
        }

        /// <summary> Adds or updates a console ban for this console.  A console may be banned for multiple reasons.  This does not add a machine ban. </summary>
        public static void BanConsole(ConsoleBanStatus ban)
        {
            string query=QueryGenerator.GenerateUpdateOrInsert("t_machine_banned_console_id",
                                                  new string[]{"vc_console_id", "i_reason_code", "dt_since",     "si_hash_bucket"},
                                                  new object[]{ban.ConsoleId,    ban.ReasonCode,  ban.StartDate, ban.HashBucket},
                                                  new string[]{"vc_console_id", "i_reason_code"});
            UodbWS.ExecuteSQLNonQuery(query, ban.ConsoleId);
        }

        /// <summary> Retrieves all console bans for this console, sorted by reason code ascending.  This does not retrieve machine bans. </summary>
        public ConsoleBanStatus[] GetAllConsoleBans()
        {
            System.Collections.Generic.List<ConsoleBanStatus> bans=new System.Collections.Generic.List<ConsoleBanStatus>();

            using (WSClient ws=new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITETHENREAD_COMMANDTYPE))
            {
                ws.PartitionType=WstPartitionType.Logical;
                WebstoreDB.SetHashValue(ws, ConsoleId);
                ws.CommandSql="select i_reason_code, dt_since, si_hash_bucket from t_machine_banned_console_id where vc_console_id='"+ConsoleId.Replace("'","''")+"' order by i_reason_code";

                using (WstDataReader reader=ws.Execute())
                {
                    while (reader.Read())
                    {
                        ConsoleBanStatus bs=new ConsoleBanStatus();
                        bs.ConsoleId=ConsoleId;
                        bs.ReasonCode=(int)reader[0];
                        bs.StartDate=(System.DateTime)reader[1];
                        bs.HashBucket=(short)reader[2];

                        bans.Add(bs);
                    }
                }
            }

            return bans.ToArray();
        }

        public struct ConsoleBanHistory
        {
            public string ConsoleId;
            public System.DateTime ChangeTime;
            public int ReasonCode;
            public System.DateTime StartDate;
            public System.DateTime EndDate;
            public short HashBucket;

            public ConsoleBanHistory(string id, System.DateTime changeTime, int reason, System.DateTime start, System.DateTime end)
            {
                ConsoleId=id;
                ChangeTime=changeTime;
                ReasonCode=reason;
                StartDate=start;
                EndDate=end;
                HashBucket=(short)UodbWS.GetHashBucket(id);
            }

            public override string ToString()
            {
                return "ConsoleBanHistory(ConsoleId="+ConsoleId+" ChangeTime="+ChangeTime+" ReasonCode="+string.Format("0x{0:X}", ReasonCode)+" StartDate="+StartDate+" EndDate="+EndDate+" HashBucket="+HashBucket+")";
            }
        };

        /// <summary> Retrieves all console ban history for this console.  This does not retrieve machine ban history. </summary>
        public ConsoleBanHistory[] GetAllConsoleBanHistories()
        {
            System.Collections.Generic.List<ConsoleBanHistory> bans=new System.Collections.Generic.List<ConsoleBanHistory>();

            using (WSClient ws=new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITETHENREAD_COMMANDTYPE))
            {
                ws.PartitionType=WstPartitionType.Logical;
                WebstoreDB.SetHashValue(ws, ConsoleId);
                ws.CommandSql="select dt_timestamp, i_reason_code, dt_start, dt_end, si_hash_bucket from t_machine_banned_console_id_history where vc_console_id='"+ConsoleId.Replace("'","''")+"'";

                using (WstDataReader reader=ws.Execute())
                {
                    while (reader.Read())
                    {
                        ConsoleBanHistory bs=new ConsoleBanHistory();
                        bs.ConsoleId=ConsoleId;
                        bs.ChangeTime=(System.DateTime)reader[0];
                        bs.ReasonCode=(int)reader[1];
                        bs.StartDate=(System.DateTime)reader[2];
                        bs.EndDate=(System.DateTime)reader[3];
                        bs.HashBucket=(short)reader[4];

                        bans.Add(bs);
                    }
                }
            }

            return bans.ToArray();
        }

        #endregion
    };
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\Database\Editor\ComponentEditor.cs ===
using System;

using xonline.common.config;
using xonline.common.sql.webstore;

namespace ServerTestFramework.Database
{
    /// <summary>
    /// Utility for altering or creating components directly in the database.
    /// NOTE: Be careful using this, modifying an existing component is not to be done lightly.
    /// </summary>
    public class ComponentEditor : EditorCommon
    {
        /// <summary>The component's name.</summary>
        /// <remarks>This is the only non-cached information we store.</remarks>
        public string Name
        {
            get;
            private set;
        }

        #region Create or remove an instance of ComponentEditor

        /// <summary>Construct from an existing component name (does not guarantee that the component exists).</summary>
        public static ComponentEditor FromName (string name)
        {
            return new ComponentEditor() { Name = name };
        }

        /// <summary>
        /// Constructs from a component definition, creating the component in the database
        /// if it does not already exist or overwriting all values if it does.  KNOW WHAT YOU ARE DOING IF YOU USE THIS!
        /// </summary>
        public static ComponentEditor CreateOrOverwrite (string name, string installUnit, string executable,
            string installer, string userRole, string info1, string info2)
        {
            // check for invalid data
            if (string.IsNullOrEmpty(name))
            {
                throw new ArgumentNullException("name");
            }

            if (string.IsNullOrEmpty(installUnit))
            {
                throw new ArgumentNullException("installUnit");
            }

            // create sproc call string
            string sproc = @"
Exec p_config_add_component
    @component = {0},
    @installUnit = {1},
    @executable = {2},
    @installer = {3},
    @userRole = {4},
    @info1 = {5},
    @info2 = {6},
    @overwriteExistingValue = 1
";
            sproc = string.Format(sproc,
                FormatString(name),
                FormatString(installUnit),
                FormatString(executable),
                FormatString(installer),
                FormatString(userRole),
                FormatString(info1),
                FormatString(info2));

            StaticNpdb.ExecuteNonQuery(sproc);

            return FromName(name);
        }

        /// <summary>Completely removes the virtual interface from the database.</summary>
        public void Delete ()
        {
            StaticNpdb.ExecuteNonQuery("Delete from t_components where vc_component = '" +
                    EscapedName + "'");
        }

        // constructor is not for public consumption.
        private ComponentEditor ()
        {
        }

        #endregion

        #region Lookup or alter properties of the component

        /// <summary>Whether the component actually exists in the database.</summary>
        public override bool Exists
        {
            get
            {
                if (HasCachedEntry("exists"))
                {
                    return (bool)cache["exists"];
                }

                bool exists = !string.IsNullOrEmpty(Name) &&
                    ((int)StaticNpdb.ExecuteScalar("Select count(0) from t_components where vc_component = '" +
                    EscapedName + "'") != 0);
                SetCacheEntry("exists", exists);
                return exists;
            }
        }

        /// <summary>Install unit of the component.</summary>
        public string InstallUnit
        {
            get
            {
                return GetGenericProperty<string>("vc_install_unit");
            }

            set
            {
                SetGenericProperty("vc_install_unit", value);
            }
        }

        /// <summary>Executable of the component.</summary>
        public string Executable
        {
            get
            {
                return GetGenericProperty<string>("vc_executable");
            }

            set
            {
                SetGenericProperty("vc_executable", value);
            }
        }

        /// <summary>Installer of the component.</summary>
        public string Installer
        {
            get
            {
                return GetGenericProperty<string>("vc_installer");
            }

            set
            {
                SetGenericProperty("vc_installer", value);
            }
        }

        /// <summary>User role of the component.</summary>
        public string UserRole
        {
            get
            {
                return GetGenericProperty<string>("vc_user_role");
            }

            set
            {
                SetGenericProperty("vc_user_role", value);
            }
        }

        /// <summary>Info1 of the component.</summary>
        public string Info1
        {
            get
            {
                return GetGenericProperty<string>("vc_info1");
            }

            set
            {
                SetGenericProperty("vc_info1", value);
            }
        }

        /// <summary>Info2 of the component.</summary>
        public string Info2
        {
            get
            {
                return GetGenericProperty<string>("vc_info2");
            }

            set
            {
                SetGenericProperty("vc_info2", value);
            }
        }

        /// <summary>Generic implementation of returning a property from a component (or cache if able).</summary>
        private TypeOfProperty GetGenericProperty<TypeOfProperty> (string columnName)
        {
            return GetGenericProperty<TypeOfProperty>(columnName, columnName);
        }

        /// <summary>Generic implementation of returning a property from a component (or cache if able).</summary>
        private TypeOfProperty GetGenericProperty<TypeOfProperty> (string columnName, string cacheName)
        {
            if (HasCachedEntry(cacheName))
            {
                return (TypeOfProperty)cache[cacheName];
            }

            object ret = StaticNpdb.ExecuteScalar("Select " + columnName + " from t_components where vc_component = '" +
                    EscapedName + "'");
            if (ret != null)
            {
                TypeOfProperty val = (TypeOfProperty)System.Convert.ChangeType(ret, typeof(TypeOfProperty));
                SetCacheEntry(cacheName, val);
                return val;
            }

            throw new RowDoesNotExistException("t_components", columnName, Name);
        }

        /// <summary>Generic implementation of setting a property of a component.  The value must be convertible to a string in a way that SQL understands.</summary>
        private void SetGenericProperty<TypeOfProperty> (string columnName, TypeOfProperty value)
        {
            SetGenericProperty<TypeOfProperty>(columnName, columnName, value);
        }

        /// <summary>Generic implementation of setting a property of a component.  The value must be convertible to a string in a way that SQL understands.</summary>
        private void SetGenericProperty<TypeOfProperty> (string columnName, string cacheName, TypeOfProperty value)
        {
            StaticNpdb.ExecuteNonQuery("Update t_components set " + columnName + " = '" + EscapeString(value.ToString()) +
                "' where vc_component = '" + EscapedName + "'");
            SetCacheEntry(cacheName, value);
        }

        #endregion

        #region Add or remove "assets" for the component

        #endregion

        // Short descriptive useful string that doesn't require db hits
        public override string ToString ()
        {
            return "Component: " + (Name ?? "<null>");
        }

        // string containing every field.  This call is expensive, as it makes many db hits.
        public string FullDescription
        {
            get
            {
                throw new NotImplementedException();
            }
        }

        #region Helpers

        /// <summary>The Name, escaped.</summary>
        private string EscapedName
        {
            get
            {
                return EscapeString(Name);
            }
        }

        /// <summary>Formats a nullable type for a SQL statement.</summary>
        private static string FormatNullable<T> (Nullable<T> n) where T : struct
        {
            return (n.HasValue ? n.Value.ToString() : "null");
        }

        /// <summary>Formats a string for a SQL statement.</summary>
        private static string FormatString (string s)
        {
            return (s == null ? "null" : "'" + EscapeString(s) + "'");
        }

        #endregion
    };
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\Database\XMatch.cs ===
/* Wrapper for XMatch database */

using System;
using System.Data;
using System.Data.SqlTypes;
using System.Data.SqlClient;
using System.Data.Common;
using System.Collections;
using System.Text;
using System.Runtime.InteropServices;
using ServerTestFramework.LiveService;
using ServerTestFramework.Utilities;
using System.Xml;

namespace ServerTestFramework.Database
{
	/// <summary>
	/// Wrapper for talking to XMatch.
	/// </summary>
	public class XMatch
	{
		private SqlConnection _conn;
		private string _serverName;

		public XMatch()
		{
		}
  
        /// <summary>
        /// Connects to XMatch server taking an array
        /// Only connects to the first server in the array
        /// </summary>
        /// <param name="serverNames">Array of XMatch server names</param>
        public void ConnectToServer(string []serverNames)
        {
            ConnectToServer(serverNames[0]);
        }

        /// <summary>
        /// Connects to the Xmatch Database
        /// </summary>
        /// <param name="serverName">Name of XMatch server</param>
        public void ConnectToServer(string serverName)
        {
            try 
            {
                _serverName=serverName;
                _conn = new SqlConnection("server="+_serverName+";database=xmatch;Integrated Security=SSPI"); 
                _conn.Open();
            } 
            catch(SqlException sqlex)
            {
                throw new DatabaseException(_conn, sqlex);
            }
        }

        /// <summary>
        /// Closes the connection to XMatch
        /// </summary>
        public void Close()
        {
            lock(_conn)
            {
                // m_SqlConnection could be null
                if (_conn!=null && _conn.State!=ConnectionState.Closed)
                {
                    try
                    {
                        _conn.Close();
                    }
                    catch
                    {
                        // do nothing
                    }
                    _conn=null;
                }
            }
        }

        /// <summary>
        /// Removes the match tables and procs for specified TitleID
        /// Reverses the changes that LiveMatch does to make it 'clean' for running LiveMatch again.
        /// There is a stored proc in NPDB that does the same thing p_match_title_delete
        /// Works for both Xbox and Xenon
        /// </summary>
        /// <param name="titleId">TitleID to remove match tables</param>
        public void ClearMatchConfiguration(uint titleID)
        {
            NpdbUtility npdb = new NpdbUtility();
            npdb.ConnectToServer();

            // Check the LTC to see if this is an xbox or xenon title...
            XmlDocument xmlDoc = new XmlDocument();

            LiveTitleConfigRow titleConfigRow = npdb.GetLiveTitleConfig(titleID);
            if (titleConfigRow == null)
            {
                throw new Exception("Live title config not found for title ID 0x" + titleID.ToString("X08"));
            }

            xmlDoc.LoadXml(titleConfigRow.XmlTitleConfig);
            XmlNamespaceManager nsmgr = new XmlNamespaceManager(xmlDoc.NameTable);
            nsmgr.AddNamespace("xl", "http://www.xboxlive.com/livetitleconfig");

            string generation = xmlDoc.SelectSingleNode("//xl:TitleGeneration",nsmgr).InnerText;
            
            // Check for tables and if there are any drop them...
            string tableNames;
            if (generation == "Xbox")
            {
                tableNames = GetXboxMatchTables(titleID).Trim();
            }
            else
            {
                tableNames= GetMatchTables(titleID).Trim();
            }
            if (tableNames != "")
            {
                // Drop Tables...
                string[] tables = GetMatchTables(titleID).Split(',');
                foreach( string table in tables )
                {
                    IssueCommand(String.Format("DROP TABLE {0:x}", table));
                }
            }

            string procs;
            // Drop Procs...
            if (generation == "Xbox")
            {
                procs = GetXboxStoredProcs(titleID).Trim();
            }
            else
            {
                procs = GetStoredProcs(titleID).Trim();
            }
            if (procs != "")
            {
                IssueCommand(String.Format("DROP PROCEDURE {0}", procs));
            }

            // Delete title from t_match_titles
            npdb.IssueCommand("DELETE FROM t_match_titles WHERE i_title_id = " + ((int)titleID).ToString());
            npdb.Close();
            npdb = null;
        }



        /// <summary>
        /// Gets a list of match tables from the XMatch Db
        /// </summary>
        /// <param name="titleID">Title ID to retrieve matches</param>
        /// <returns>Comma separated list of names</returns>
        public string GetMatchTables(uint titleID)
        {
            lock(_conn)
            {
                SqlDataReader reader = null;
                StringBuilder tables = new StringBuilder();

                try
                {
                    string sql = String.Format("Select name from sysobjects where name like 't_match_sessions_0x{0:x}%' and type='U'", titleID);
                    ReadData(sql, out reader);
            
                    while (reader.Read())
                    {
                        if (tables.Length != 0)
                        {
                            tables.Append(",");
                        }
                        tables.Append(reader.GetString(0));
                
                    }
                }
                finally
                {
                    if(null != reader && !reader.IsClosed)
                    {
                        reader.Close();
                    }
                    reader = null;
                }
                return tables.ToString();
            }
        }

        /// <summary>
        /// Gets a list of match tables from the XMatch Db
        /// </summary>
        /// <param name="titleID">Title ID to retrieve matches</param>
        /// <returns>Comma separated list of names</returns>
        public string GetXboxMatchTables(uint titleID)
        {
            lock(_conn)
            {
                SqlDataReader reader = null;
                StringBuilder tables = new StringBuilder();

                try
                {
                    string sql;
                    sql = String.Format("Select name from sysobjects where name='t_match_sessions_{0}' and type='U'", (int)titleID);
                    ReadData(sql, out reader);
            
                    while (reader.Read())
                    {
                        if (tables.Length != 0)
                        {
                            tables.Append(",");
                        }
                        tables.Append(reader.GetString(0));
                
                    }
                }
                finally
                {
                    if(null != reader && !reader.IsClosed)
                    {
                        reader.Close();
                    }
                    reader = null;
                }
                return tables.ToString();
            }
        }

        /// <summary>
        /// Return a single stored procedure's text.  This can be used to re-create the stored
        /// procedure.
        /// </summary>
        /// <param name="sprocName">Name of the stored procedure whose text is to be returned.</param>
        /// <returns>Text of the stored procedure.  This begins with a CREATE, and can be used to
        /// re-create the procedure.  Replacing CREATE with ALTER allows modifications in-place.</returns>
        public string GetStoredProc(string sprocName)
        {
            lock(_conn)
            {
                SqlDataReader reader = null;
                string sprocResult = "";

                try
                {
                    string sql = "SELECT OBJECT_DEFINITION(object_id) FROM sys.procedures WHERE OBJECT_NAME(object_id) = '" +
                        sprocName + "'";
                    ReadData(sql, out reader);
            
                    if (reader.Read())
                    {
                        sprocResult = reader.GetString(0);
                    }
                }
                finally
                {
                    if(null != reader && !reader.IsClosed)
                    {
                        reader.Close();
                    }
                    reader = null;
                }
                return sprocResult;
            }
        }

        /// <summary>
        /// Get a list of stored procedures in XMatch DB for Matches.
        /// </summary>
        /// <param name="titleID">Title of the matches to be returned</param>
        /// <returns>Comma separated string of match stored procs</returns>
        public string GetStoredProcs(uint titleID)
        {
            lock(_conn)
            {
                SqlDataReader reader = null;
                StringBuilder procs = new StringBuilder();

                try
                {
                    string sql = String.Format(@"Select name from sysobjects where name like 'p_match_session_v2_0x{0:x}%' 
                                                OR name='p_match_session_0x{0:x}_deadxbox' and type='P'", titleID);
                    ReadData(sql, out reader);
            
                    while (reader.Read())
                    {
                        if (procs.Length != 0)
                        {
                            procs.Append(",");
                        }
                        procs.Append(reader.GetString(0));
                    }

                }
                finally
                {
                    if(null != reader && !reader.IsClosed)
                    {
                        reader.Close();
                    }
                    reader = null;
                }
                return procs.ToString();
            }
        }

        /// <summary>
        /// Get a list of stored procedures in XMatch DB for Matches.
        /// </summary>
        /// <param name="titleID">Title of the matches to be returned</param>
        /// <returns>Comma separated string of match stored procs</returns>
        public string GetXboxStoredProcs(uint titleID)
        {
            lock(_conn)
            {
                SqlDataReader reader = null;
                StringBuilder procs = new StringBuilder();

                try
                {
                    // Get searches...
                    string sql = String.Format(@"Select name from sysobjects where name like
                        'p_match_search_{0}%' OR name='p_match_session_delete_{0}' OR name='p_match_session_insert_{0}'
                        OR name='p_match_session_update_{0}' and type='P'", (int)titleID);
                    ReadData(sql, out reader);
            
                    while (reader.Read())
                    {
                        if (procs.Length != 0)
                        {
                            procs.Append(",");
                        }
                        procs.Append(reader.GetString(0));
                
                    }
                }
                finally
                {
                    if(null != reader && !reader.IsClosed)
                    {
                        reader.Close();
                    }
                    reader = null;
                }
                return procs.ToString();
            }
        }

        /// <summary>
        /// Get a list of column names from a specified table
        /// </summary>
        /// <param name="TableName">Table name to retrieve</param>
        /// <returns>Comma separated list of column names</returns>
        public string GetTableColumns(string tableName)
        {
            lock(_conn)
            {
                SqlDataReader reader = null;
                StringBuilder fields = new StringBuilder();

                try
                {
                    string sql = String.Format("Select * from {0} where bi_session_id=null", tableName);
                    ReadData(sql, out reader);
                    
                    for (int i=0;i < reader.FieldCount; i++)
                    {
                        if (fields.Length != 0)
                        {
                            fields.Append(",");
                        }
                        fields.Append(reader.GetName(i));
                    }
                }
                finally
                {
                    if(null != reader && !reader.IsClosed)
                    {
                        reader.Close();
                    }
                    reader = null;
                }
                return fields.ToString();
            }
        }

        /// <summary>
        /// Executes a SQL Query and returns the single scalar value
        /// </summary>
        /// <param name="sql">SQL Query</param>
        /// <returns>Value of Query</returns>
        public object ExecuteScalar(string sql)
        {
            object value = null;

            try 
            {
                SqlCommand command = new SqlCommand(sql, _conn);
                value = command.ExecuteScalar();
            }
            catch(SqlException sqlex)
            {
                throw new DatabaseException(_conn, sqlex);
            }

            return value;
        }

        /// <summary>
        /// Allows you to run a command against XMatch
        /// </summary>
        /// <param name="sql">SQL command to execute</param>
        /// <returns>Number of rows affected.</returns>
        public int IssueCommand(string sql)
        {
            int affected = 0;

            try 
            {
                SqlCommand command = new SqlCommand(sql, _conn);
                affected = command.ExecuteNonQuery();
            }
            catch(SqlException sqlex)
            {
                throw new DatabaseException(_conn, sqlex);
            }

            return affected;
        }

        /// <summary>
        /// Allows you to pass a query to XMatch and get a data reader back.
        /// </summary>
        /// <param name="sql">SQL Query</param>
        /// <param name="reader">Data returned from query</param>
        public void ReadData(string sql, out SqlDataReader reader)
        {
            try
            {
                SqlCommand command = new SqlCommand(sql, _conn);
                reader = command.ExecuteReader();

                if (reader == null)
                {
                    throw new DatabaseException(_conn, "Execute reader failed");
                }
            }
            catch(SqlException sqlex)
            {
                throw new DatabaseException(_conn, sqlex);
            }
        }

	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\Database\Editor\CountryEditor.cs ===
using xonline.common.sql.webstore;
using xonline.common.config;
using Microsoft.Webstore.WstClient;

using System.Collections.Generic;

using ServerTestFramework.Utilities;

namespace ServerTestFramework.Database
{
    /// <summary>
    /// Utility for altering or creating an individual country.
    /// </summary>
    public class CountryEditor: EditorCommon
    {
        /// <summary>
        /// Country ID.  This is the only non-cached information we store about the country.
        /// </summary>
        public byte Id
        {
            get { return id; }
        }

        private byte id=0;

        #region Create an instance of CountryEditor

        /// <summary>
        /// Construct from an existing country id (does not guarentee that the country exists).
        /// </summary>
        public static CountryEditor FromId(byte countryId)
        {
            CountryEditor priv=new CountryEditor();
            priv.id=countryId;
            return priv;
        }

        /// <summary>
        /// Constructs from a country id, creating the country in the db if it does not already exist.
        /// </summary>
        public static CountryEditor CreateOrUseExistingId(byte countryId)
        {
            CountryEditor priv=new CountryEditor();
            priv.id=countryId;

            //insert the t_countries entry if needed
            if (!UodbWS.DoesCountryExist(countryId))
            {
                UodbWS.ExecuteSQLNonQuery("insert into t_countries (ti_country_id,vc_name,vc_friendly_name,ti_min_user_age,ti_min_billing_age,f_allow_direct_debit,f_require_cc_for_age) values ("+(int)countryId+", 'TC"+countryId+"', 'Test Country "+countryId+"', 10, 10, 1, 0)", null);
            }

            return priv;
        }

        //constructor is not for public consumption.
        private CountryEditor()
        {
        }

        #endregion

        // --
        #region Lookup or alter properties of the country

        /// <summary>
        /// Whether the country actually exists in the db.
        /// </summary>
        public override bool Exists
        {
            get
            {
                if (HasCachedEntry("exists"))
                {
                    return (bool)cache["exists"];
                }

                bool exists=id!=0 && UodbWS.DoesCountryExist(id);
                SetCacheEntry("exists", exists);
                return exists;
            }
        }

        /// <summary>
        /// Abbreviation of the country.
        /// </summary>
        public string Name
        {
            get
            {
                if (HasCachedEntry("name"))
                {
                    return (string)cache["name"];
                }

                object ret=UodbWS.ExecuteSQLScalar("select vc_name from t_countries where ti_country_id="+(int)id, null);
                if (ret==null)
                {
                    throw new RowDoesNotExistException("t_countries", "ti_country_id", id.ToString());
                }
                string name=(string)ret;
                SetCacheEntry("name", name);
                return name;
            }

            set
            {
                UodbWS.ExecuteSQLNonQuery("update t_countries set vc_name='"+EscapeString(value)+"' where ti_country_id="+id, null);
                SetCacheEntry("name", value);
            }
        }

        /// <summary>
        /// Actual name of the country.
        /// </summary>
        public string FriendlyName
        {
            get
            {
                if (HasCachedEntry("friendlyname"))
                {
                    return (string)cache["friendlyname"];
                }

                object ret=UodbWS.ExecuteSQLScalar("select vc_friendly_name from t_countries where ti_country_id="+(int)id, null);
                if (ret==null)
                {
                    throw new RowDoesNotExistException("t_countries", "ti_country_id", id.ToString());
                }
                string name=(string)ret;
                SetCacheEntry("friendlyname", name);
                return name;
            }

            set
            {
                UodbWS.ExecuteSQLNonQuery("update t_countries set vc_friendly_name='"+EscapeString(value)+"' where ti_country_id="+id, null);
                SetCacheEntry("friendlyname", value);
            }
        }

        //TODO: the other fields...

        #endregion

        //Short descriptive useful string that doesn't require db hits
        public override string ToString()
        {
            if (id==0)
            {
                return "Nonexistant Country (id=0)";
            }
            else
            {
                return string.Format("Country 0x{0:X}", id);
            }
        }

        //Long string containing every field of the country.  This call can be expensive, as it may make db hits.
        public string FullDescription
        {
            get
            {
                if (!Exists)
                {
                    return string.Format("Nonexistant Country 0x{0:X}", id);
                }
                else
                {
                    return ToString()+
                        "\nName="+Name+
                        "\nFriendlyName="+FriendlyName;
                }
            }
        }
    };

    // --

    /// <summary>
    /// Utility for altering or creating a country set.
    /// </summary>
    public class CountrySetEditor: EditorCommon
    {
        /// <summary>
        /// Privelege set ID.  This is the only non-cached information we store about the country set.
        /// </summary>
        public ushort Id
        {
            get { return id; }
        }

        private ushort id=0;

        #region Create an instance of CountrySetEditor

        /// <summary>
        /// Construct from an existing country set id (does not guarentee that the country set exists).
        /// </summary>
        public static CountrySetEditor FromId(ushort countrySetId)
        {
            CountrySetEditor conset=new CountrySetEditor();
            conset.id=countrySetId;
            return conset;
        }

        /// <summary>
        /// Constructs from a country set id, creating the country set in the db if it does not already exist.
        /// </summary>
        public static CountrySetEditor CreateOrUseExistingId(ushort countrySetId)
        {
            CountrySetEditor conset=new CountrySetEditor();
            conset.id=countrySetId;

            //insert the t_countries entry if needed
            if (!UodbWS.DoesCountrySetExist(countrySetId))
            {
                UodbWS.ExecuteSQLNonQuery("insert into t_country_set (si_country_set_id,vc_friendly_name) values ("+(short)countrySetId+", 'Test Country Set "+countrySetId+"')", null);
            }

            return conset;
        }

        //constructor is not for public consumption.
        private CountrySetEditor()
        {
        }

        #endregion

        // --
        #region Lookup or alter properties of the country set

        /// <summary>
        /// Whether the country set actually exists in the db.
        /// </summary>
        public override bool Exists
        {
            get
            {
                if (HasCachedEntry("exists"))
                {
                    return (bool)cache["exists"];
                }

                bool exists=id!=0 && UodbWS.DoesCountrySetExist(id);
                SetCacheEntry("exists", exists);
                return exists;
            }
        }

        /// <summary>
        /// Name of the country set.
        /// </summary>
        public string Name
        {
            get
            {
                if (HasCachedEntry("name"))
                {
                    return (string)cache["name"];
                }

                object ret=UodbWS.ExecuteSQLScalar("select vc_friendly_name from t_country_set where si_country_set_id="+(short)id, null);
                if (ret==null)
                {
                    throw new RowDoesNotExistException("t_country_set", "si_country_set_id", id.ToString());
                }
                string name=(string)ret;
                SetCacheEntry("name", name);
                return name;
            }

            set
            {
                UodbWS.ExecuteSQLNonQuery("update t_country_set set vc_friendly_name="+EscapeString(value)+" where si_country_set_id="+(short)id, null);
                SetCacheEntry("name", value);
            }
        }

        #endregion

        //Short descriptive useful string that doesn't require db hits
        public override string ToString()
        {
            if (id==0)
            {
                return "Nonexistant Country Set (id=0)";
            }
            else
            {
                return string.Format("Country Set 0x{0:X}", id);
            }
        }

        //Long string containing every field of the country set.  This call can be expensive, as it may make db hits.
        public string FullDescription
        {
            get
            {
                if (!Exists)
                {
                    return string.Format("Nonexistant Country Set 0x{0:X}", id);
                }
                else
                {
                    string ret=ToString();
                    ret+="\nName="+Name;
                    ret+="\nCountries: "+StringUtils.MakeCommaSeparatedList(GetAllCountries());
                    return ret;
                }
            }
        }

        #region Add or remove "assets" for the country set

        /// <summary>
        /// Returns all granted countries from the set.
        /// </summary>
        public byte[] GetAllCountries()
        {
            List<byte> cons=new List<byte>();

            using (WSClient ws=new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITETHENREAD_COMMANDTYPE))
            {
                ws.PartitionType=WstPartitionType.Logical;
                ws.Partition=WstCommand.AnyPartition;
                ws.CommandSql="select ti_country_id from t_country_set_country where si_country_set_id="+(short)id+" and ti_is_grant=1";

                using (WstDataReader myDataReader=ws.Execute())
                {
                    while (myDataReader.Read())
                    {
                        cons.Add((byte)myDataReader[0]);
                    }
                }
            }

            return cons.ToArray();
        }

        /// <summary>
        /// Removes all countries from the set.
        /// </summary>
        public void RemoveAllCountries()
        {
            UodbWS.ExecuteSQLNonQuery("delete from t_country_set_country where si_country_set_id="+(short)id, null);
        }

        /// <summary>
        /// Add a country to a set, if it does not already contain it.
        /// </summary>
        public void AddCountry(byte countryId)
        {
            string query="if (0=(select count(ti_country_id) from t_country_set_country where si_country_set_id="+(short)id+" and ti_country_id="+(int)countryId+")) ";
            query+="begin insert into t_country_set_country (si_country_set_id, ti_country_id) values ("+(short)id+", "+(int)countryId+") end";
            UodbWS.ExecuteSQLNonQuery(query, null);
        }

        #endregion
    };
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\Database\Editor\CultureEditor.cs ===
using xonline.common.sql.webstore;
using xonline.common.config;
using Microsoft.Webstore.WstClient;

using System.Collections.Generic;

using ServerTestFramework.Utilities;

namespace ServerTestFramework.Database
{
    /// <summary>
    /// Utility for altering or creating an individual culture.
    /// </summary>
    public class CultureEditor: EditorCommon
    {
        /// <summary>
        /// Culture ID.  This is the only non-cached information we store about the culture.
        /// </summary>
        public int Id
        {
            get { return id; }
        }

        private int id=0;

        #region Create an instance of CultureEditor

        /// <summary>
        /// Construct from an existing culture id (does not guarentee that the culture exists).
        /// </summary>
        public static CultureEditor FromId(int culture)
        {
            CultureEditor ce=new CultureEditor();
            ce.id=culture;
            return ce;
        }

        /// <summary>
        /// Constructs from a culture id, creating the culture in the db if it does not already exist.
        /// </summary>
        public static CultureEditor CreateOrUseExistingId(int culture)
        {
            CultureEditor ce=new CultureEditor();
            ce.id=culture;

            //insert the t_cultures entry if needed
            if (!UodbWS.DoesCultureExist(culture))
            {
                UodbWS.ExecuteSQLNonQuery("exec p_svc_insert_culture "+(int)culture+", 1, 103, 'Test Culture "+(int)culture+"', 'TEST', 'SQL_Latin1_General_CP1_CI_AS', 1, 1, 1, "+(int)culture, null);
            }

            return ce;
        }

        //constructor is not for public consumption.
        private CultureEditor()
        {
        }

        #endregion

        // --
        #region Lookup or alter properties of the culture

        /// <summary>
        /// Whether the culture actually exists in the db.
        /// </summary>
        public override bool Exists
        {
            get
            {
                if (HasCachedEntry("exists"))
                {
                    return (bool)cache["exists"];
                }

                bool exists=id!=0 && UodbWS.DoesCultureExist(id);
                SetCacheEntry("exists", exists);
                return exists;
            }
        }

        /// <summary> Language ID of the culture. </summary>
        public int LanguageId
        {
            get
            {
                return GetGenericCultureProperty<int>("i_language_id", "langid");
            }

            set
            {
                SetGenericCultureProperty("i_language_id", "langid", value);
            }
        }

        /// <summary> Country ID of the culture. </summary>
        public byte CountryId
        {
            get
            {
                return GetGenericCultureProperty<byte>("ti_country_id", "countryid");
            }

            set
            {
                SetGenericCultureProperty("ti_country_id", "countryid", value);
            }
        }

        /// <summary> Name of the culture. </summary>
        public string Name
        {
            get
            {
                return GetGenericCultureProperty<string>("vc_name", "name");
            }

            set
            {
                SetGenericCultureProperty("vc_name", "name", value);
            }
        }

        /// <summary> Country code of the culture. </summary>
        public string CountryCode
        {
            get
            {
                return GetGenericCultureProperty<string>("vc_code", "countrycode");
            }

            set
            {
                SetGenericCultureProperty("vc_code", "countrycode", value);
            }
        }

        /// <summary> SQL collation thing. </summary>
        public string Collation
        {
            get
            {
                return GetGenericCultureProperty<string>("vc_collation", "collation");
            }

            set
            {
                SetGenericCultureProperty("vc_collation", "collation", value);
            }
        }

        /// <summary> Whether the culture is live-supported or not. </summary>
        public byte IsLiveSupported
        {
            get
            {
                return GetGenericCultureProperty<byte>("ti_xbox_live_supported", "livesupported");
            }

            set
            {
                SetGenericCultureProperty("ti_xbox_live_supported", "livesupported", value);
            }
        }

        /// <summary> Whether the culture is xbox.com supported or not. </summary>
        public byte IsXboxComSupported
        {
            get
            {
                return GetGenericCultureProperty<byte>("ti_xbox_com_supported", "xboxcomsupported");
            }

            set
            {
                SetGenericCultureProperty("ti_xbox_com_supported", "xboxcomsupported", value);
            }
        }

        /// <summary> The Live Language ID of the culture. </summary>
        public int LiveLanguageId
        {
            get
            {
                return GetGenericCultureProperty<int>("i_live_language_id", "livelangid");
            }

            set
            {
                SetGenericCultureProperty("i_live_language_id", "livelangid", value);
            }
        }

        /// <summary> The Live Culture ID of the culture. </summary>
        public int LiveCultureId
        {
            get
            {
                return GetGenericCultureProperty<int>("i_lcid", "liveculture");
            }

            set
            {
                SetGenericCultureProperty("i_lcid", "liveculture", value);
            }
        }

        /// <summary>
        /// Generic implementation of returning a property from a culture (or cache if able).
        /// </summary>
        private TypeOfProperty GetGenericCultureProperty<TypeOfProperty>(string columnName, string cacheName)
        {
            if (HasCachedEntry(cacheName))
            {
                return (TypeOfProperty)cache[cacheName];
            }

            object ret=UodbWS.ExecuteSQLScalar("select "+columnName+" from t_cultures where i_culture_id="+(int)id, null);
            if (ret!=null)
            {
                TypeOfProperty val=(TypeOfProperty)System.Convert.ChangeType(ret, typeof(TypeOfProperty));
                SetCacheEntry(cacheName, val);
                return val;
            }

            throw new RowDoesNotExistException("t_cultures", columnName, id.ToString());
        }

        /// <summary>
        /// Generic implementation of setting a property in a culture.  The value must be convertible to a string in a way that SQL understands.
        /// </summary>
        private void SetGenericCultureProperty<TypeOfProperty>(string columnName, string cacheName, TypeOfProperty value)
        {
            UodbWS.ExecuteSQLNonQuery("update t_cultures set "+columnName+"='"+EscapeString(value.ToString())+"' where i_culture_id="+(int)id, null);
            SetCacheEntry(cacheName, value);
        }

        #endregion

        //Short descriptive useful string that doesn't require db hits
        public override string ToString()
        {
            if (id==0)
            {
                return "Nonexistant Culture (id=0)";
            }
            else
            {
                return string.Format("Culture 0x{0:X}", id);
            }
        }

        //Long string containing every field of the culture.  This call can be expensive, as it may make db hits.
        public string FullDescription
        {
            get
            {
                if (!Exists)
                {
                    return string.Format("Nonexistant Culture 0x{0:X}", id);
                }
                else
                {
                    string ret=ToString();
                    ret+="\nName="+Name;
                    ret+="\nLanguageId="+LanguageId;
                    ret+="\nCountryId="+CountryId;
                    ret+="\nCountryCode="+CountryCode;
                    ret+="\nCollation="+Collation;
                    ret+="\nIsLiveSupported="+IsLiveSupported;
                    ret+="\nIsXboxComSupported="+IsXboxComSupported;
                    ret+="\nLiveLanguageId="+LiveLanguageId;
                    ret+="\nLiveCultureId="+LiveCultureId;
                    return ret;
                }
            }
        }
    };
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\Database\Editor\EditorCommon.cs ===
namespace ServerTestFramework.Database
{
    /// <summary>
    /// Thrown when trying to access a property for something that doesn't exist.
    /// </summary>
    public class RowDoesNotExistException: ServerTestFramework.UnexpectedTestResultException
    {
        public RowDoesNotExistException(string message): base(message)
        {
        }

        public RowDoesNotExistException(string table, string keys, string keyValues): base("Row does not exist.  Table="+table+(keys==null?"":" using columns "+keys)+(keyValues==null?"":" with values "+keyValues))
        {
        }
    }

    /// <summary>
    /// Common code for all the db *Editor classes.
    /// </summary>
    abstract public class EditorCommon
    {
        /// <summary>
        /// Whether or not the object exists in the db.
        /// If this property is cached, it must use the name "exists".
        /// </summary>
        public abstract bool Exists
        {
            get;
        }

        /// <summary>
        /// If true, then lookups will store their result in a cache, so that subsequent lookups do not hit the DB.
        /// If false, every lookup will hit the DB every time.
        /// </summary>
        public bool UseCaching;

        /// <summary>
        /// This can be enabled for a short time during bulk data editing to turn caching on by default for new instances.  Please leave it off normally unless you have a really good reason.
        /// </summary>
        public static bool EnableCachingByDefaultForNewInstances=false;

        /// <summary>
        /// Clears all locally cached data.
        /// </summary>
        public void ClearCache()
        {
            if (cache!=null)
            {
                cache.Clear();
            }
        }

        //stores the locally cached data
        protected System.Collections.Specialized.HybridDictionary cache=null;

        //adds a piece of data to the local cached store for the object
        protected void SetCacheEntry(string name, object value)
        {
            if (UseCaching && (name=="exists" || Exists))
            {
                if (cache==null)
                {
                    cache=new System.Collections.Specialized.HybridDictionary();
                }

                if (!cache.Contains(name))
                {
                    cache.Add(name, value);
                }
                else
                {
                    cache[name]=value;
                }
            }
        }

        //returns whether we already have a specific piece of cached data
        protected bool HasCachedEntry(string name)
        {
            if (!UseCaching)
            {
                return false;
            }

            if (cache==null)
            {
                return false;
            }

            return cache.Contains(name);
        }

        //utils
        protected static string EscapeString(string str)
        {
            return str.Replace("'","''");
        }

        public EditorCommon()
        {
            UseCaching=EnableCachingByDefaultForNewInstances;
        }
    };
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\Database\Editor\MachineEditor.cs ===
using System;
using System.Collections.Generic;
using System.Security.Cryptography;

using xonline.common.config;
using xonline.common.sql.webstore;

using Microsoft.Webstore.WstClient;

using ServerTestFramework.Utilities;
using ServerTestFramework.LiveService.Auth;

namespace ServerTestFramework.Database
{
    public enum MachineType
    {
        Invalid,
        Xbox1,
        Xbox360,
        PC,
        Phone,
        XboxCom //These aren't real machines and can't be created.  The real xbox.com uses random numbers, we will allocate puids from a pool in the correct range for this for testing purposes.
    }

    /// <summary>
    /// Utility for altering or creating machines directly in the database.
    /// </summary>
    public class MachineEditor: EditorCommon
    {
        public static MachineType GetMachineType(string consoleId)
        {
            if (String.IsNullOrEmpty(consoleId))
            {
                throw new ArgumentNullException("consoleId");
            }

            string prefix = consoleId.Substring(0, 3).ToUpper();

            switch (prefix)
            {
                case "SN.":
                    return MachineType.Xbox1;
                case "XE.":
                    return MachineType.Xbox360;
                case "PC.":
                    return MachineType.PC;
                case "WM.":
                    return MachineType.Phone;
                default:
                    throw new FormatException("consoleId must start with a two letter machine type prefix");
            }
        }

        public static MachineType GetMachineType(ulong id)
        {
            if ((id&0xFFFF000000000000)==0x0009000000000000)
            {
                return MachineType.Xbox1;
            }
            else if ((id&0xFFFF000000000000)==0xFA00000000000000)
            {
                return MachineType.Xbox360;
            }
            else if ((id&0xFFFF000000000000)==0xFB00000000000000)
            {
                return MachineType.PC;
            }
            else if ((id&0xFFFF000000000000)==0xFC00000000000000)
            {
                return MachineType.Phone;
            }
            else if ((id&0xFFFF000000000000)==0xFFED000000000000)
            {
                return MachineType.XboxCom;
            }
            else
            {
                throw new System.Exception("Unrecognized machine puid platform: "+string.Format("0x{0:X16}", id));
            }
        }

        public static string GetConsoleIdPrefix(MachineType machineType)
        {
            switch (machineType)
            {
                case MachineType.Xbox1:
                    return "SN.";
                case MachineType.Xbox360:
                    return "XE.";
                case MachineType.PC:
                    return "PC.";
                case MachineType.Phone:
                    return "WM.";
                default:
                    throw new ArgumentException("Invalid MachineType specified", "machineType");
            }
        }

        /// <summary>
        /// Machine ID.  This is the only non-cached information we store about the machine.
        /// </summary>
        public ulong Id
        {
            get { return id; }
        }

        private ulong id=0;

        /// <summary> Default fixed value used when a console certificate hash is not provided. </summary>
        public static readonly byte []DefaultCertHash=Hexer.unhex("0x7E57000000000000000000000000000000007E57");

        // --
        #region Create an instance of MachineEditor

        /// <summary>
        /// Construct from an existing machine id (does not guarentee that the machine exists).
        /// </summary>
        public static MachineEditor FromId(ulong machineId)
        {
            MachineEditor machine=new MachineEditor();
            machine.id=machineId;
            return machine;
        }

        /// <summary>
        /// Construct from a WM device id (does not guarentee that the machine exists).
        /// </summary>
        public static MachineEditor FromWMDId(string wmDeviceId)
        {
            return MachineEditor.FromId(UodbWS.LookupMachineIDFromWMDeviceID(wmDeviceId));
        }

        /// <summary>
        /// Construct from an existing console Id.  This does a lookup, and will throw if it does not exist.
        /// ConsoleID is of the form: XE.blahnumbers or SN.blahnumbers or such.
        /// This will throw if there are more than one machines that share the same console ID.
        /// </summary>
        public static MachineEditor FromName(string consoleId)
        {
            return MachineEditor.FromId(UodbWS.LookupMachineIDFromConsoleID(consoleId));
        }

        /// <summary>
        /// Construct from an existing console Id and console certificate sha1 hash.  This does a lookup, and will throw if it does not exist.
        /// consoleID is of the form: XE.blahnumbers or SN.blahnumbers or such.
        /// certHash is a 20 byte sha1 hash of the console certificate, used by xbox360 only.  If null, a default fixed value will be used.
        /// </summary>
        public static MachineEditor FromName(string consoleId, byte []certHash)
        {
            return MachineEditor.FromId(UodbWS.LookupMachineIDFromConsoleID(consoleId, certHash));
        }

        /// <summary>
        /// Construct from an existing console Id and scode (a transformed subset of the console certificate sha1 hash).  This does a lookup, and will throw if it does not exist.
        /// consoleID is of the form: XE.blahnumbers or PC.blahnumbers or such.
        /// scode is of the form XXXX-XXXX-XXXX-XXXX, and is used by xbox360 only.  If this is null then there must be only one machine with the specified console id.
        /// </summary>
        public static MachineEditor FromName(string consoleId, string scode)
        {
            return MachineEditor.FromId(UodbWS.LookupMachineIDFromConsoleID(consoleId, scode));
        }

        /// <summary>
        /// Adds an entry to t_machines for the specified console ID and machine ID
        /// </summary>
        /// <param name="consoleId"></param>
        /// <param name="machineId"></param>
        /// <returns>True if the entry was successfully added, false if a machine with the same ID exists already</returns>
        private static bool AddTMachinesEntry(string consoleId, ulong machineId)
        {
            if (!UodbWS.DoesMachineExist(machineId))
            {
                if (consoleId.StartsWith("SN.")) //for xbox 1, t_machines doesn't prefix the serial number with SN.
                {
                    consoleId = consoleId.Substring(3);
                }

                using (WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITEONLY_COMMANDTYPE))
                {
                    ws.PartitionType = WstPartitionType.Logical;
                    ws.SetHashVal(machineId);
                    int bucket = ws.Partition;
                    ws.CommandSql = "exec p_xmacs_insertmachine '" + EscapeString(consoleId) + "', " + (long)machineId + ", " + (int)bucket;
                    ws.ExecuteNonQuery();
                }

                return true;
            }

            return false;
        }

        /// <summary>
        /// Adds an entry to t_user_names for the specified console ID, and machine ID
        /// </summary>
        /// <param name="consoleId"></param>
        /// <param name="machineId"></param>
        /// <returns>True if the entry was successfully added, false if a machine with the same ID exists already</returns>
        private static bool AddTUserNamesEntry(string consoleId, ulong machineId)
        {
            if (0==(int)UodbWS.ExecuteSQLScalar("select count(*) from t_user_names where vc_gamertag='"+consoleId+"'", consoleId))
            {
                //calculate some crypto magic stuff
                bool isXeKey=!((machineId&0xffff000000000000)==0x0009000000000000);
                byte []rawkey=ServerTestFramework.LiveService.Auth.AuthContext.CalculateKeyFromGamertag(consoleId, isXeKey);
                byte []iv;
                byte []enckey;
                byte []kek=ServerTestFramework.LiveService.Auth.ServiceKeys.GetServiceKey(ServerTestFramework.LiveService.Auth.ServiceKeys.Key_KEK);
                GenerateKey(kek, rawkey, out iv, out enckey);

                byte []sppa1=GenSppa1(consoleId, rawkey);
                byte []ppa2=GenPpa2(consoleId, rawkey);

                //add the name for the machine
                using (WSClient ws=new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITEONLY_COMMANDTYPE))
                {
                    ws.PartitionType=WstPartitionType.Logical;
                    ws.SetHashVal(consoleId);
                    int bucket=ws.Partition;
                    ws.CommandSql="exec p_xmacs_insertmachinename '"+EscapeString(consoleId)+"', "+(long)machineId+", 1, 1, 0x"+Hexer.tohex(iv)+", 0x"+Hexer.tohex(enckey)+", 0x"+Hexer.tohex(ppa2)+", 0x"+Hexer.tohex(sppa1)+", "+(int)bucket;
                    ws.ExecuteNonQuery();
                }

                return true;
            }

            return false;
        }

        private static bool AddTMachineXenonKeysEntry(string consoleId, byte []certHash, ulong machineId)
        {
            if (!UodbWS.DoesMachineExist(consoleId, certHash))
            {
                //calculate some crypto magic stuff
                bool isXeKey=!((machineId&0xffff000000000000)==0x0009000000000000);
                byte []rawkey=ServerTestFramework.LiveService.Auth.AuthContext.CalculateKeyFromGamertag(consoleId, isXeKey);
                byte []iv;
                byte []enckey;
                byte []kek=ServerTestFramework.LiveService.Auth.ServiceKeys.GetServiceKey(ServerTestFramework.LiveService.Auth.ServiceKeys.Key_KEK);
                GenerateKey(kek, rawkey, out iv, out enckey);

                //add the name for the machine
                using (WSClient ws=new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITEONLY_COMMANDTYPE))
                {
                    ws.PartitionType=WstPartitionType.Logical;
                    ws.SetHashVal(consoleId);
                    int bucket=ws.Partition;
                    ws.CommandSql="exec p_xmacs_insert_machine_xenon_keys '"+EscapeString(consoleId)+"', 0x"+Hexer.tohex(certHash)+", "+(long)machineId+", 1, 1, 0x"+Hexer.tohex(iv)+", 0x"+Hexer.tohex(enckey)+", "+(int)bucket;
                    ws.ExecuteNonQuery();
                }

                return true;
            }

            return false;
        }

        /// <summary>
        /// Constructs from a console id (SN.XXXXXXXXXXXX or XE.XXXXXXXXXXXX or PC.XXXXXXXXXXXX) and machine id.
        /// If used for a PC machine, the default voucher, a random id, and a new/cached passport will be used.
        /// certHash is a 20 byte sha1 hash of the console certificate, used by xbox360 only.  If null, a default fixed value will be used.
        /// </summary>
        public static MachineEditor CreateOrUseExistingName(string consoleId, byte []certHash, ulong machineId)
        {
            if (certHash==null)
            {
                certHash=DefaultCertHash;
            }

            MachineType consoleType = GetMachineType(consoleId);

            //add t_machines and t_user_names entries
            if (consoleType == MachineType.Xbox360)
            {
                AddTMachineXenonKeysEntry(consoleId, certHash, machineId);
                AddTMachinesEntry(consoleId, machineId);
            }
            else
            {
                Boolean didCreate = AddTUserNamesEntry(consoleId, machineId);
                didCreate = AddTMachinesEntry(consoleId, machineId) || didCreate;

                if(didCreate)
                {
                    if (consoleType == MachineType.PC)
                    {
                        return CreateOrUseExistingPCName(consoleId, machineId, null, null, null);
                    }
                    else if (consoleType == MachineType.Phone)
                    {
                        return CreateOrUseExistingWMName(consoleId, machineId);
                    }
                }
            }

            return FromId(machineId);
        }

        /// <summary> Creates a new xbox360 machine with a random cert hash, so that the second machine using the console id will be assigned a different machine puid. </summary>
        public static MachineEditor CreateDuplicateXbox360(string consoleId)
        {
            ulong machineId=AllocateMachinePuid(MachineType.Xbox360);
            byte []randomHash=new byte[20];
            ServerTestFramework.Core.Utilities.RandomEx.GlobalRandGen.NextBytes(randomHash);
            return CreateOrUseExistingName(consoleId, randomHash, machineId);
        }

        /// <summary> Creates a new xbox360 machine, setting up the tables to match how an xbox360 would look before the transition to the xenon machine key table. </summary>
        public static MachineEditor CreateLegacyXbox360()
        {
            string consoleId=GenerateRandomConsoleID(MachineType.Xbox360);
            return CreateLegacyXbox360(consoleId);
        }

        /// <summary> Creates a new xbox360 machine, setting up the tables to match how an xbox360 would look before the transition to the xenon machine key table. </summary>
        public static MachineEditor CreateLegacyXbox360(string consoleId)
        {
            ulong machineId=AllocateMachinePuid(MachineType.Xbox360);

            AddTUserNamesEntry(consoleId, machineId);
            AddTMachinesEntry(consoleId, machineId);

            return FromId(machineId);
        }

        /// <summary>
        /// Constructs from a console id (PC.XXXXXXXXXXXX) and machine id.  Only valid for PC machines.
        /// If voucher is null, the PC test voucher will be used.  If pcId is null a random value will be used.  If passportId is null, a random passport will be created and cached/used.
        /// </summary>
        public static MachineEditor CreateOrUseExistingPCName(string consoleId, System.Nullable<ulong> machineId, string voucher, System.Nullable<ulong> pcId, System.Nullable<ulong> passportId)
        {
            //fix up the voucher, pcid, and passport id
            if (voucher==null)
            {
                voucher="PPPPP-PPPPP-PPPPP-PPPPP-PPPPP";
            }
            byte[] voucherHash = TokendbWS.GetHashForPanoramaVoucher(voucher);

            if (pcId==null)
            {
                pcId=ServerTestFramework.Core.Utilities.RandomEx.GlobalRandGen.NextUlong();
            }
            byte []pcIdBytes=System.BitConverter.GetBytes((ulong)pcId);

            //look up the machine id... if we have one, we don't need to do anything
            object ret = UodbWS.ExecuteSQLScalar("select bi_machine_puid from t_pc_accounts where bin_voucher_hash=0x" + Hexer.tohex(voucherHash) + " and b_pc_id=0x" + string.Format("{0:X}", pcId), TokendbWS.HashVoucherBytes(voucherHash));
            if (ret!=null)
            {
                return FromId((ulong)(long)ret);
            }

            if (passportId==null)
            {
                passportId=GetCachedPassportId();
            }

            if (machineId==null)
            {
                machineId=AllocateMachinePuid(MachineType.PC);
            }

            if (consoleId==null)
            {
                consoleId=string.Format("PC.{0:X12}", machineId&0x0000ffffffffffff);
            }

            //add t_machines and t_user_names entries
            AddTUserNamesEntry(consoleId, (ulong)machineId);
            AddTMachinesEntry(consoleId, (ulong)machineId);

            //add t_pc_accounts entries
            if (!UodbWS.DoesPCMachineExist(voucherHash, (ulong)pcId))
            {
                using (WSClient ws=new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITEONLY_COMMANDTYPE))
                {
                    ws.PartitionType=WstPartitionType.Logical;
                    ws.SetHashVal(TokendbWS.HashVoucherBytes(voucherHash));
                    int bucket=ws.Partition;
                    ws.CommandSql="exec p_xmacs_pc_account_create 0x"+Hexer.tohex(voucherHash)+", 0x"+string.Format("{0:X}",(ulong)pcId)+", "+(long)(ulong)machineId+", "+(short)bucket+", "+(long)(ulong)passportId;
                    ws.ExecuteNonQuery();
                }
            }

            return FromId((ulong)machineId);
        }

        /// <summary>
        /// Constructs from voucher, pcid, and passport id.  Only valid for PC machines.  Voucher should be of the form XXXXX-XXXXX-XXXXX-XXXXX-XXXXX.
        /// </summary>
        public static MachineEditor CreateOrUseExistingPCName(string voucher, ulong pcId, System.Nullable<ulong> passportId)
        {
            byte[] voucherHash = TokendbWS.GetHashForPanoramaVoucher(voucher);

            //look up the machine id... if we have one, we don't need to do anything
            object ret = UodbWS.ExecuteSQLScalar("select bi_machine_puid from t_pc_accounts where bin_voucher_hash=0x" + Hexer.tohex(voucherHash) + " and b_pc_id=0x" + string.Format("{0:X}", pcId), TokendbWS.HashVoucherBytes(voucherHash));
            if (ret!=null)
            {
                return FromId((ulong)(long)ret);
            }

            //generate a console id and puid, then make it
            return CreateOrUseExistingPCName(null, null, voucher, pcId, passportId);
        }

        public static MachineEditor CreateOrUseExistingWMName(string deviceId, ulong machineId)
        {
            if (!UodbWS.DoesWMMachineExist(deviceId, machineId))
            {
                using(WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITETHENREAD_COMMANDTYPE))
                {
                    ws.PartitionType = WstPartitionType.Logical;
                    ws.SetHashVal(deviceId);
                    ws.StoredProc = "p_wm_insert_machine";
                    ws.AddParameter("vc_wmdevice_id", deviceId);
                    ws.AddParameter("bi_machine_puid", machineId);
                    ws.AddParameter("si_hash_bucket", ws.Partition);

                    ws.ExecuteNonQuery();
                }
            }

            return FromId(machineId);
        }

        /// <summary>
        /// Constructs from a console id (SN.XXXXXXXXXXXX or XE.XXXXXXXXXXXX or such).  If it doesn't exist, uses a random machine id.
        /// In the case of xbox360, a default certificate hash will be used.
        /// </summary>
        public static MachineEditor CreateOrUseExistingName(string consoleId)
        {
            return CreateOrUseExistingName(consoleId, null);
        }

        /// <summary>
        /// Constructs from a console id (SN.XXXXXXXXXXXX or XE.XXXXXXXXXXXX or such) and console certificate hash.  If it doesn't exist, uses a random machine id.
        /// certHash is a 20 byte sha1 hash of the console certificate, used by xbox360 only.  If null, a default fixed value will be used.
        /// </summary>
        public static MachineEditor CreateOrUseExistingName(string consoleId, byte []certHash)
        {
            if (certHash==null)
            {
                certHash=DefaultCertHash;
            }

            //see if it already exists (name)
            if (UodbWS.DoesMachineExist(consoleId, certHash))
            {
                return FromId(UodbWS.LookupMachineIDFromConsoleID(consoleId, certHash));
            }

            MachineType machineType=GetMachineType(consoleId);

            //get the puid to use
            ulong puid=0;

            if (machineType==MachineType.PC) //for pc, the puid here matches the console ID, so we don't need to allocate anything
            {
                puid=0xfb00000000000000|Hexer.fromhex(consoleId.Substring(3));
            }
            else if (machineType==MachineType.Phone)
            {
                puid=0xfc00000000000000|Hexer.fromhex(consoleId.Substring(3));
            }

            if (puid==0)
            {
                puid=AllocateMachinePuid(machineType);
            }

            return CreateOrUseExistingName(consoleId, certHash, puid);
        }

        /// <summary> Reserves a new machine puid in npdb for use by a specific machine type. </summary>
        public static ulong AllocateMachinePuid(MachineType type)
        {
            return AllocateMachinePuid(type, 1);
        }

        /// <summary> Reserves a range of new machine puids in npdb for use by a specific machine type. </summary>
        public static ulong AllocateMachinePuid(MachineType type, uint count)
        {
            //we can't allocate xbox.com puids since they aren't real, so just randomly generate one
            if (type==MachineType.XboxCom)
            {
                return 0xffed000000000000 | (RandomEx.GlobalRandGen.NextUlong()&0x0000ffffffffffff);
            }

            //get puid base
            ulong baseid=0xffff000000000000;
            switch (type)
            {
                case MachineType.Xbox1:
                    baseid=0x0009000000000000;
                    break;
                case MachineType.Xbox360:
                    baseid=0xfa00000000000000;
                    break;
                case MachineType.PC:
                    baseid=0xfb00000000000000;
                    break;
                case MachineType.Phone:
                    baseid=0xfc00000000000000;
                    break;
                default:
                    throw new System.ArgumentException("Invalid machine type: "+type);
            }

            using (Npdb npdb=new Npdb())
            {
                npdb.ConnectToServer();
                return npdb.AllocatePuids(0, count, null, baseid);
            }
        }

        /// <summary> Constructs from an machine id, creating the machine in the db if it does not already exist. </summary>
        public static MachineEditor CreateOrUseExistingId(ulong machineId)
        {
            MachineEditor mach=MachineEditor.FromId(machineId);
            if (mach.Exists)
            {
                return mach;
            }

            MachineType mtype=GetMachineType(machineId);
            string cid=GenerateRandomConsoleID(mtype);

            return CreateOrUseExistingName(cid, null, machineId);
        }

        /// <summary>
        /// Creates a new MachineEditor with the Xbox360 machine 
        /// type and a random machine id and console id.
        /// </summary>
        public static MachineEditor CreateNew()
        {
            return CreateNew(MachineType.Xbox360);
        }

        /// <summary>
        /// Creates a new machine editor of the given type with a 
        /// random machine id and random console id.
        /// </summary>
        public static MachineEditor CreateNew(MachineType type)
        {
            byte[] certHash = RandomEx.GlobalRandGen.GenerateRandomBlob(20);
            string consoleId = GenerateRandomConsoleID(type);
            return CreateOrUseExistingName(consoleId, certHash);
        }

        /// <summary> Generates a random valid console ID for a specific machine type for a machine that does not currently exist. </summary>
        public static string GenerateRandomConsoleID(MachineType type)
        {
            String consoleId;
            String prefix = GetConsoleIdPrefix(type);

            do
            {
                if (type == MachineType.PC || type == MachineType.Phone)
                {
                    // For the PC and Phone, the ConsoleId is just the zero 
                    // padded machine id in hex with the appropriate prefix
                    consoleId = string.Format("{0}{1:X12}", prefix, AllocateMachinePuid(type) & 0x0000ffffffffffff);
                }
                else //xbox1 or xbox360
                {
                    //the id itself
                    ulong cidValue = 1 + RandomEx.GlobalRandGen.NextUlong() % 0xffffffffe; //36 bits max
                    string cidString = cidValue.ToString("D11");

                    //the checksum digit
                    int sum = 0;
                    for (int i = 0; i < 11; ++i)
                    {
                        int digit = (int)(cidString[i] - '0');
                        sum += digit;
                    }

                    // ConsoleId = XX.###########C
                    consoleId = prefix + cidString + (sum % 10);
                }
            } while (UodbWS.DoesMachineExist(consoleId, null));

            return consoleId;
        }

        /// <summary> Gets the passport id used to create PC machine accounts in cases where the passport ID is not provided by the caller. </summary>
        public static ulong GetCachedPassportId()
        {
            if (cachedPassportId!=0 || (System.DateTime.UtcNow-cachedPassportDate).TotalMinutes<=60)
            {
                return cachedPassportId;
            }

            lock (cachedPassportLock)
            {
                if (cachedPassportId!=0 || (System.DateTime.UtcNow-cachedPassportDate).TotalMinutes<=60)
                {
                    return cachedPassportId;
                }

                //make the passport user
                ServerTestFramework.LiveService.UserAccount.UacsCommon.PassportUser passportUser=null;
                if (cachedPassportName==null)
                {
                    Global.RO.Debug("Creating a cached passport user...");

                    ServerTestFramework.LiveService.UserAccount.UacsCommon uc = new ServerTestFramework.LiveService.UserAccount.UacsCommon();
                    for (int i=0; i<10; ++i)
                    {
                        try
                        {
                            passportUser = uc.CreatePassportUser();
                            break;
                        }
                        catch (System.Exception e)
                        {
                            if (i==9) throw;
                            Global.RO.Debug("CreatePassportUser failed(will retry):"+e.Message);
                            System.Threading.Thread.Sleep(i*100);
                        }
                    }

                    cachedPassportPassword=passportUser.Password;
                    cachedPassportName=passportUser.MemberName;
                    Global.RO.Debug("Cached passport: "+passportUser.MemberName+" "+passportUser.Password);
                }

                //get their ticket, which will give us their passport id
                byte []ticket;
                byte []key;
                ServerTestFramework.LiveService.Auth.AuthClientBase.GetPassportTicket(cachedPassportName, cachedPassportPassword, out ticket, out key, "MBI_KEY_OLD", ServerTestFramework.LiveService.Auth.AuthClientBase.PassportSite.KdcPanorama); //TODO: Change this policy when we write a new panorama xmacs preauth that encrypts the ticket
                cachedPassportSessionKey=key;
                cachedPassportTicket=ticket;

                if (passportUser!=null)
                {
                    //cachedPassportId=(ulong)System.BitConverter.ToInt64(key, 0); //first 8 bytes has the puid
                    cachedPassportId=passportUser.PassportPuid;
                }
                cachedPassportDate=System.DateTime.UtcNow;
            }

            return cachedPassportId;
        }

        private static ulong cachedPassportId=0;
        private static string cachedPassportName=null;
        private static string cachedPassportPassword=null;
        private static byte []cachedPassportTicket=null;
        private static byte []cachedPassportSessionKey=null;
        private static System.DateTime cachedPassportDate=System.DateTime.MinValue;
        private static object cachedPassportLock=new object();

        /// <summary> Gets the passport login/password used to create PC machine accounts in cases where the passport ID is not provided by the caller. </summary>
        public static void GetCachedPassportLoginInfo(out string userName, out string userPassword)
        {
            GetCachedPassportId();
            userName=cachedPassportName;
            userPassword=cachedPassportPassword;
        }

        /// <summary> Gets the passport login/password used to create PC machine accounts in cases where the passport ID is not provided by the caller. </summary>
        public static void GetCachedPassportTicket(out byte []ticket, out byte []sessionKey)
        {
            GetCachedPassportId();
            ticket=cachedPassportTicket;
            sessionKey=cachedPassportSessionKey;
        }

        /// <summary>
        /// MachineEditors are not created directy.  Use the static
        /// factory methods like CreateNew instead.
        /// </summary>
        private MachineEditor()
        {
        }

        #endregion

        // --
        #region Lookup or alter properties of the machine

        /// <summary>
        /// Whether the machine actually exists in the db.
        /// </summary>
        public override bool Exists
        {
            get
            {
                if (HasCachedEntry("exists"))
                {
                    return (bool)cache["exists"];
                }

                bool exists=id!=0 && UodbWS.DoesMachineExist(id);
                SetCacheEntry("exists", exists);
                return exists;
            }
        }

        /// <summary>
        /// ConsoleId of the machine t_machines.
        /// </summary>
        public string ConsoleId
        {
            get
            {
                return GetGenericMachineProperty<string>("vc_serial_num", "consoleid");
            }

            set
            {
                SetGenericMachineProperty("vc_serial_num", "consoleid", value);
            }
        }

        /// <summary> 20 byte sha1 hash of the Xenon Console Certificate.  This only exists for xbox360 and will be null or ignored for anything else. </summary>
        public byte []CertHash
        {
            get
            {
                string cid=ConsoleId;
                if (cid.ToLower().StartsWith("xe."))
                {
                    object ret=UodbWS.ExecuteSQLScalar("select bin_cert_hash from t_machine_xenon_keys where vc_console_id='"+EscapeString(cid)+"' and bi_machine_puid="+(long)Id, cid);
                    if (ret==null)
                    {
                        return null;
                    }

                    return (byte[])ret;
                }
                else
                {
                    return null;
                }
            }

            set
            {
                string cid=ConsoleId;
                if (cid.ToLower().StartsWith("xe."))
                {
                    UodbWS.ExecuteSQLNonQuery("update t_machine_xenon_keys set bin_cert_hash=0x"+Hexer.tohex(value)+" where vc_console_id='"+EscapeString(cid)+"' and bi_machine_puid="+(long)Id, cid);
                }
            }
        }

        /*/// <summary>
        /// Date the machine is blocked from.
        /// THIS IS DEPRECATED and will no longer be used by the service after the 2011 March XSR.  It will be deleted from t_machines shortly after that.
        /// </summary>
        public System.DateTime BlockedDate
        {
            get
            {
                Global.RO.Warn("BlockedDate is deprecated and no longer respected by the service.");
                return GetGenericMachineProperty<System.DateTime>("dt_blocked_date", "blockeddate");
            }

            set
            {
                Global.RO.Warn("BlockedDate is deprecated and no longer respected by the service.");
                SetGenericMachineProperty("dt_blocked_date", "blockeddate", value);
            }
        }*/

        /// <summary>
        /// Date the machine was last reset.
        /// </summary>
        public System.DateTime ResetDate
        {
            get
            {
                return GetGenericMachineProperty<System.DateTime>("dt_reset_date", "resetdate");
            }

            set
            {
                SetGenericMachineProperty("dt_reset_date", "resetdate", value);
            }
        }

        /// <summary>
        /// Whether the machine is a beta user.
        /// TODO: This is deprecated and should NOT be used.  It will be removed after the column is actually deleted from production.
        /// </summary>
        public byte BetaUser
        {
            get
            {
                return GetGenericMachineProperty<byte>("ti_beta_user", "betauser");
            }

            set
            {
                SetGenericMachineProperty("ti_beta_user", "betauser", value);
            }
        }

        /// <summary>
        /// Beta title for the machine.
        /// TODO: This is deprecated and should NOT be used.  It will be removed after the column is actually deleted from production.
        /// </summary>
        public System.Nullable<int> BetaTitle
        {
            get
            {
                return GetGenericNullableMachineProperty<int>("i_beta_title_id", "betatitle");
            }

            set
            {
                SetGenericNullableMachineProperty("i_beta_title_id", "betatitle", value);
            }
        }

        /// <summary>
        /// Console's certificate type.
        /// </summary>
        public int ConsoleCertificateType
        {
            get
            {
                return GetGenericMachineProperty<int>("i_cert_console_type", "certconstype");
            }

            set
            {
                SetGenericMachineProperty("i_cert_console_type", "certconstype", value);
            }
        }

        /// <summary>
        /// Console's certificate part number.
        /// </summary>
        public byte[] ConsoleCertificatePartNumber
        {
            get
            {
                return GetGenericMachineProperty<byte[]>("bin_cert_part_number", "binpartnum");
            }

            set
            {
                SetGenericMachineProperty("bin_cert_part_number", "binpartnum", "0x"+Hexer.tohex(value));
            }
        }

        /// <summary>
        /// Machine's creation date
        /// </summary>
        public System.Nullable<System.DateTime> CreationDate
        {
            get
            {
                return GetGenericNullableMachineProperty<System.DateTime>("dt_creation_date", "creationdate");
            }

            set
            {
                SetGenericNullableMachineProperty("dt_creation_date", "creationdate", value);
            }
        }

        /// <summary>
        /// Hash bucket for the machine (for t_machines).
        /// </summary>
        public short HashBucket
        {
            get
            {
                return GetGenericMachineProperty<short>("si_hash_bucket", "hashbucket");
            }
        }

        /// <summary>
        /// Machine's most recently seen client version, as updated by the xkdc.
        /// </summary>
        public string ClientFlashVersion
        {
            get
            {
                return GetGenericMachineProperty<string>("vc_flash_version", "clientflashversion");
            }

            set
            {
                SetGenericMachineProperty("vc_flash_version", "clientflashversion", value);
            }
        }

        /// <summary>
        /// The date that the client's flash version column was last updated.
        /// </summary>
        public System.Nullable<System.DateTime> ClientFlashVersionChangedDate
        {
            get
            {
                return GetGenericNullableMachineProperty<System.DateTime>("dt_flash_version_change_datetime", "flash_version_change_datetime");
            }

            set
            {
                SetGenericNullableMachineProperty("dt_flash_version_change_datetime", "flash_version_change_datetime", value);
            }
        }

        /// <summary>
        /// Machine's most recently seen region, as updated by the xkdc.
        /// </summary>
        public int ConsoleRegion
        {
            get
            {
                return GetGenericMachineProperty<int>("i_console_region", "consoleRegion");
            }

            set
            {
                SetGenericMachineProperty("i_console_region", "consoleRegion", value);
            }
        }

        /// <summary>
        /// Machine's most recently requested flash update version, as updated by xbos.
        /// </summary>
        public string ClientFlashUpdateVersion
        {
            get
            {
                return GetGenericMachineProperty<string>("vc_update_version", "clientupdateversion");
            }

            set
            {
                SetGenericMachineProperty("vc_update_version", "clientupdateversion", value);
            }
        }

        /// <summary>
        /// The date that the client's flash update version column was last updated.
        /// </summary>
        public System.Nullable<System.DateTime> ClientFlashUpdateVersionChangedDate
        {
            get
            {
                return GetGenericNullableMachineProperty<System.DateTime>("dt_update_version_change_datetime", "update_version_change_datetime");
            }

            set
            {
                SetGenericNullableMachineProperty("dt_update_version_change_datetime", "update_version_change_datetime", value);
            }
        }

        /// <summary>
        /// Generic implementation of returning a property from a machine (or cache if able).
        /// </summary>
        private TypeOfProperty GetGenericMachineProperty<TypeOfProperty>(string columnName, string cacheName)
        {
            if (HasCachedEntry(cacheName))
            {
                return (TypeOfProperty)cache[cacheName];
            }

            object ret=UodbWS.ExecuteSQLScalar("select "+columnName+" from t_machines where bi_machine_puid="+(long)id, id);
            if (ret!=null)
            {
                if (ret==System.DBNull.Value)
                {
                    return default(TypeOfProperty);
                }

                TypeOfProperty val=(TypeOfProperty)System.Convert.ChangeType(ret, typeof(TypeOfProperty));
                SetCacheEntry(cacheName, val);
                return val;
            }

            throw new RowDoesNotExistException("t_machines", columnName, id.ToString());
        }

        /// <summary>
        /// Generic implementation of returning a property from a machine (or cache if able), for columns that may be null.
        /// </summary>
        private System.Nullable<TypeOfProperty> GetGenericNullableMachineProperty<TypeOfProperty>(string columnName, string cacheName)
            where TypeOfProperty:struct
        {
            if (HasCachedEntry(cacheName))
            {
                return (TypeOfProperty)cache[cacheName];
            }

            object ret=UodbWS.ExecuteSQLScalar("select "+columnName+" from t_machines where bi_machine_puid="+(long)id, id);
            if (ret!=null)
            {
                if (ret==System.DBNull.Value)
                {
                    return null;
                }

                TypeOfProperty val=(TypeOfProperty)System.Convert.ChangeType(ret, typeof(TypeOfProperty));
                SetCacheEntry(cacheName, val);
                return val;
            }

            throw new RowDoesNotExistException("t_machines", columnName, id.ToString());
        }

        /// <summary>
        /// Generic implementation of setting a property in a machine.  The value must be convertible to a string in a way that SQL understands.
        /// </summary>
        private void SetGenericMachineProperty<TypeOfProperty>(string columnName, string cacheName, TypeOfProperty value)
        {
            if (value==null)
            {
                UodbWS.ExecuteSQLNonQuery("update t_machines set "+columnName+"=null where bi_machine_puid="+(long)id, id);
            }
            else
            {
                UodbWS.ExecuteSQLNonQuery("update t_machines set "+columnName+"='"+EscapeString(value.ToString())+"' where bi_machine_puid="+(long)id, id);
            }
        }

        /// <summary>
        /// Generic implementation of setting a property in a machine for columns that may be null.  The value must be convertible to a string in a way that SQL understands, or null.
        /// </summary>
        private void SetGenericNullableMachineProperty<TypeOfProperty>(string columnName, string cacheName, System.Nullable<TypeOfProperty> value)
            where TypeOfProperty:struct
        {
            if (value==null)
            {
                UodbWS.ExecuteSQLNonQuery("update t_machines set "+columnName+"=null where bi_machine_puid="+(long)id, id);
            }
            else
            {
                UodbWS.ExecuteSQLNonQuery("update t_machines set "+columnName+"='"+EscapeString(value.ToString())+"' where bi_machine_puid="+(long)id, id);
            }

            SetCacheEntry(cacheName, value);
        }

        #endregion

        //Short descriptive useful string that doesn't require db hits
        public override string ToString()
        {
            if (id==0)
            {
                return "Nonexistant Machine (id=0)";
            }
            else
            {
                return string.Format("Machine 0x{0:X}", id);
            }
        }

        //Long string containing every field of the machine.  This call is expensive, as it makes many db hits.
        public string FullDescription
        {
            get
            {
                if (!Exists)
                {
                    return string.Format("Nonexistant Machine 0x{0:X}", id);
                }
                else
                {
                    string ret=ToString();
                    ret+="\nConsoleId="+ConsoleId;
                    ret+="\nResetDate="+ResetDate;
                    ret+="\nConsoleCertificateType="+ConsoleCertificateType;
                    ret+="\nConsoleCertificatePartNumber=0x"+Hexer.tohex(ConsoleCertificatePartNumber);
                    ret+="\nCreationDate="+CreationDate;
                    ret+="\nClientFlashVersion="+ClientFlashVersion;
                    ret+="\nConsoleRegion="+ConsoleRegion;
                    return ret;
                }
            }
        }

        #region Helpers and Crypto Magic
        //mostly taken from our old dbposter

        private static void GenerateKey(byte[] kek, byte[] rawkey, out byte[] iv, out byte[] enckey)
        {
            RijndaelManaged aes = new RijndaelManaged();
            aes.BlockSize = 128;
            aes.KeySize = 256;
            aes.Padding = PaddingMode.None;
            aes.GenerateIV();
            iv = aes.IV;

            enckey = new byte[16];
            System.IO.MemoryStream keystream = new System.IO.MemoryStream(enckey);
            CryptoStream cs = new CryptoStream(keystream, aes.CreateEncryptor(kek, iv), CryptoStreamMode.Write);
            cs.Write(rawkey, 0, 16);
            cs.Close();
        }

        public static byte[] DecryptKey(byte[] iv, byte[] enckey)
        {
            byte []kek=ServiceKeys.GetServiceKey(ServiceKeys.Key_KEK);
            return DecryptKey(kek, iv, enckey);
        }

        public static byte[] DecryptKey(byte[] kek, byte[] iv, byte[] enckey)
        {
            RijndaelManaged aes = new RijndaelManaged();
            aes.BlockSize = 128;
            aes.KeySize = 256;
            aes.Padding = PaddingMode.None;
            aes.GenerateIV();
            aes.IV=iv;

            byte []rawkey=new byte[16];
            System.IO.MemoryStream keystream = new System.IO.MemoryStream(rawkey);
            CryptoStream cs = new CryptoStream(keystream, aes.CreateDecryptor(kek, iv), CryptoStreamMode.Write);
            cs.Write(enckey, 0, 16);
            cs.Close();

            return rawkey;
        }

        private static byte[] GenSppa1(string name, byte[] key)
        {
            byte[] hashablename = MakeHashableName(name);

            // Compute SPPA1
            HMACSHA1 hmac = new HMACSHA1(key);
            CryptoStream cs = new CryptoStream(System.IO.Stream.Null, hmac, CryptoStreamMode.Write);
            cs.Write(hashablename, 0, hashablename.Length);
            cs.Close();

            SHA1 sha = new SHA1Managed();
            byte[] shahmac = sha.ComputeHash(hmac.Hash);
            hmac.Clear();
            sha.Clear();
            return shahmac;
        }

        private static byte[] GenPpa2(string name, byte[] key)
        {
            byte[] hashablename = MakeHashableName(name);
            byte[] doublename = new byte[32];
            hashablename.CopyTo(doublename, 0);
            hashablename.CopyTo(doublename, 16);

            HMACSHA1 hmac = new HMACSHA1(key);
            byte[] longppa2 = hmac.ComputeHash(doublename);
            hmac.Clear();

            byte[] ppa2 = new byte[8];
            for (int i = 0; i < 8; i++)
                ppa2[i] = longppa2[i];

            return ppa2;
        }

        private static byte[] MakeHashableName(string s)
        {
            byte[] tempbytes = new System.Text.ASCIIEncoding().GetBytes(s.ToUpper());

            byte[] data = new byte[16];
            tempbytes.CopyTo(data, 0);

            return data;
        }

        /// <summary>
        /// Completely removes a machine from existance.
        /// </summary>
        public void CompletelyRemoveMachine()
        {
            string query="delete from t_subscriptions where bi_primary_puid="+(long)id+"\n";
            query+="delete from t_user_licenses where bi_machine_id="+(long)id+"\n";
            UodbWS.ExecuteSQLNonQuery(query, null);

            query = "delete from t_dmp_purchase_transactions where bi_machine_puid=" + (long)id + "\n";
            query+= "delete from t_user_license_pending_dmp_reporting where bi_machine_puid=" + (long)id + "\n";
            query+="delete from t_user_offer_instance_purchases where bi_machine_puid="+(long)id+"\n";
            UserCommercedbWS.ExecuteSQLNonQuery(query, null);

            query="delete from t_machine_security_information where bi_machine_id="+(long)id+"\n";
            query+="delete from t_machine_title_activations where bi_machine_puid="+(long)id+"\n";
            query+="delete from t_machine_trial_count where bi_machine_id="+(long)id+"\n";
            query+="delete from t_pc_accounts where bi_machine_puid="+(long)id+"\n";
            query+="delete from t_machine_beta_groups where bi_machine_puid="+(long)id+"\n";
            UodbWS.ExecuteSQLNonQuery(query, null);

            string cid=null;
            if (Exists)
            {
                cid=ConsoleId;
                string cidWithPrefix=cid; //if it does not start with **., it's xbox1 and needs the prefix added
                if (cidWithPrefix.Length>=3 && cidWithPrefix[2]!='.') cidWithPrefix="SN."+cidWithPrefix;

                query="delete from t_user_keys where vc_gamertag='"+cidWithPrefix+"'\n";
                query+="delete from t_xenon_user_keys where vc_gamertag='"+cidWithPrefix+"'\n";
                query+="delete from t_machine_xenon_keys where vc_console_id='"+cidWithPrefix+"' and bi_machine_puid="+(long)id+"\n";
                query+="delete from t_user_names where vc_gamertag='"+cidWithPrefix+"'\n";
                UodbWS.ExecuteSQLNonQuery(query, null);
            }
            else
            {
                query="delete from t_user_keys where vc_gamertag in (select vc_gamertag from t_user_names where bi_user_puid="+(long)id+")\n";
                query+="delete from t_xenon_user_keys where vc_gamertag in (select vc_gamertag from t_user_names where bi_user_puid="+(long)id+")\n";
                query+="delete from t_user_names where vc_gamertag in (select vc_gamertag from t_user_names where bi_user_puid="+(long)id+")\n";
                UodbWS.ExecuteSQLNonQuery(query, null);
            }

            UodbWS.ExecuteSQLNonQuery("delete from t_machines where bi_machine_puid="+(long)id, null);

            UodbWS.ExecuteSQLNonQuery("delete from t_user_names where bi_user_puid="+(long)id, null);
        }

        /// <summary>
        /// Set's the machines key's input vector, which is 16 bytes long.
        /// </summary>
        public void SetIV(byte []iv)
        {
            UodbWS.ExecuteSQLNonQuery("update t_user_keys set bin_iv=0x"+Hexer.tohex(iv)+" where vc_gamertag='"+EscapeString(ConsoleId)+"'", ConsoleId); //for legacy machine rows
            UodbWS.ExecuteSQLNonQuery("update t_machine_xenon_keys set bin_iv=0x"+Hexer.tohex(iv)+" where vc_console_id='"+EscapeString(ConsoleId)+"' and bi_machine_puid="+(long)id, ConsoleId);
        }

        /// <summary>
        /// Set's the machines encrypted key, which is 16 bytes long.
        /// </summary>
        public void SetKey(byte []password)
        {
            UodbWS.ExecuteSQLNonQuery("update t_user_keys set bin_key=0x"+Hexer.tohex(password)+" where vc_gamertag='"+EscapeString(ConsoleId)+"'", ConsoleId); //for legacy machine rows
            UodbWS.ExecuteSQLNonQuery("update t_machine_xenon_keys set bin_key=0x"+Hexer.tohex(password)+" where vc_console_id='"+EscapeString(ConsoleId)+"' and bi_machine_puid="+(long)id, ConsoleId);
        }

        /// <summary>
        /// Get's the machines raw key, which for tests we just calculate from their console ID.
        /// </summary>
        public byte[] CalculateKey()
        {
            //!TODO: Should factor in cert hash somehow so we don't have identical keys for the same console ID
            bool isXeKey=!((Id&0xffff000000000000)==0x0009000000000000);
            return ServerTestFramework.LiveService.Auth.AuthContext.CalculateKeyFromGamertag(GetDecoratedConsoleId(), isXeKey);
        }

        /// <summary> Retrieves the encrypted session key for the machine. </summary>
        public byte[] GetEncryptedKey()
        {
            byte []key=null;

            if ((Id&0xfa00000000000000) == 0xfa00000000000000) //xbox360 uses a different table normally
            {
                key=(byte[])UodbWS.ExecuteSQLScalar("select bin_key from t_machine_xenon_keys where vc_console_id='"+EscapeString(ConsoleId)+"' and bi_machine_puid="+(long)id, ConsoleId);
            }

            if (key==null) //other platforms, or old xbox360 machine that haven't yet migrated
            {
                key=(byte[])UodbWS.ExecuteSQLScalar("select bin_key from t_user_keys where vc_gamertag='"+EscapeString(ConsoleId)+"'", ConsoleId);
            }

            return key;
        }

        /// <summary>
        /// Set's the machine's ppa2 entry, which is 8 bytes long.
        /// </summary>
        public void SetPPA2(byte []ppa2)
        {
            UodbWS.ExecuteSQLNonQuery("update t_user_keys set bin_ppa2=0x"+Hexer.tohex(ppa2)+" where vc_gamertag='"+EscapeString(ConsoleId)+"'", ConsoleId);
        }

        /// <summary>
        /// Set's the machines's sppa1 entry, which is 20 bytes long.
        /// </summary>
        public void SetSPPA1(byte []sppa1)
        {
            UodbWS.ExecuteSQLNonQuery("update t_user_keys set bin_sppa1=0x"+Hexer.tohex(sppa1)+" where vc_gamertag='"+EscapeString(ConsoleId)+"'", ConsoleId);
        }

        /// <summary> Creates or replaces the genealogy entry for the machine. </summary>
        public void SetGenealogyEntry(bool isActive, int sequenceNumber, string onlineKey, byte []key)
        {
            string cid=ConsoleId;
            string sppa1String="0x"+Hexer.tohex(GenSppa1(cid, key));

            StaticNpdb.ExecuteNonQuery("use genealogy; delete from OnlineGaming where SerialNumber='"+cid+"' and SPPA1="+sppa1String+"; insert into OnlineGaming (SerialNumber, PartNumber, OnlineKey, OnlineKeyVer, MACAddr, GameRegionCode, TVRegionCode, IsActive, PPA2, SPPA1, FirstAppeared, LastUpdated, SequenceNumber, SequenceChangeDate) values ('"+cid+"', 'F23-00061', '"+onlineKey+"', '0001', '000000000000', '00000001', '00000000', '"+(isActive?"1":"0")+"', 0x"+Hexer.tohex(GenPpa2(cid, key))+", "+sppa1String+", getutcdate(), getutcdate(), "+sequenceNumber+", getutcdate())");
        }

        /// <summary> Returns the ConsoleID with any decorations attached. </summary>
        public string GetDecoratedConsoleId()
        {
            string cid=ConsoleId;
            if (cid[2]!='.') //xbox1 is not decorated in t_machines
            {
                cid="SN."+cid;
            }
            return cid;
        }

        /// <summary> Returns the SCode that is computed from the CertHash.  Only applicable to Xbox360. </summary>
        public byte[] ComputeSCodeBytes()
        {
            byte []certHash=CertHash;
            if (certHash==null || certHash.Length==0)
            {
                return null;
            }

            //scode is the first 7 bytes of the certificate hash then a 1 byte checksum of the nibbles
            byte[] scode=new byte[8];
            for (int digit=0; digit<7; ++digit)
            {
                scode[digit]=certHash[digit];
            }

            uint checksumLow=0;
            uint checksumHigh=0;
            for (int digit=0; digit<7; ++digit)
            {
                unchecked
                {
                    checksumLow+=(uint)(scode[digit]&0x0f);
                    checksumHigh+=(uint)((scode[digit]&0xf0)>>4);
                }
            }

            scode[7]=(byte)((checksumLow&0x0f)|((checksumHigh&0x0f)<<4));
            return scode;
        }

        /// <summary> Returns the SCode that is computed from the CertHash.  Only applicable to Xbox360. </summary>
        public string ComputeSCode()
        {
            byte []scodeBytes=ComputeSCodeBytes();
            if (scodeBytes==null || scodeBytes.Length!=8)
            {
                return null;
            }

            string scode="";
            for (int segments=0; segments<4; ++segments)
            {
                if (scode.Length>0)
                {
                    scode+="-";
                }

                scode+=string.Format("{0:X2}", scodeBytes[segments*2+0]);
                scode+=string.Format("{0:X2}", scodeBytes[segments*2+1]);
            }
            return scode;
        }

        #endregion

        #region Adjust "assets" of the machine

        public struct MachineBanStatus: System.IEquatable<MachineBanStatus>
        {
            public ulong MachineId;
            public int ReasonCode; //reason for the ban
            public System.DateTime StartDate; //date the ban starts
            public System.DateTime EndDate; //date the ban ends
            public short HashBucket;

            public MachineBanStatus(ulong id, int reason, System.DateTime start, System.DateTime end)
            {
                MachineId=id;
                ReasonCode=reason;
                StartDate=start;
                EndDate=end;
                HashBucket=(short)UodbWS.GetHashBucket(id);
            }

            public override bool Equals(object other)
            {
                if(!(other is MachineBanStatus))
                {
                    return false;
                }

                return Equals((MachineBanStatus)other);
            }

            public bool Equals(MachineBanStatus other)
            {
                return MachineId==other.MachineId &&
                    ReasonCode==other.ReasonCode &&
                    System.Math.Abs((StartDate-other.StartDate).TotalMilliseconds)<10 &&
                    System.Math.Abs((EndDate-other.EndDate).TotalMilliseconds)<10 &&
                    HashBucket==other.HashBucket;
            }

            public override int GetHashCode()
            {
                return unchecked((int)MachineId^ReasonCode);
            }

            public override string ToString()
            {
                return "MachineBanStatus(MachineId="+string.Format("0x{0:X}", MachineId)+" ReasonCode="+string.Format("0x{0:X}", ReasonCode)+" StartDate="+StartDate+" EndDate="+EndDate+" HashBucket="+HashBucket+")";
            }
        };

        /// <summary> Removes all machine bans from this machine.  This does not remove console bans. </summary>
        public void RemoveAllMachineBans()
        {
            UodbWS.ExecuteSQLNonQuery("delete from t_machine_banned where bi_machine_puid="+(long)Id, Id);
        }

        /// <summary> Adds or updates a machine ban for this machine using the default reason forever.  This does not add a console ban. </summary>
        public void BanMachine()
        {
            MachineBanStatus bs=new MachineBanStatus(Id, unchecked((int)0x8015190D), System.DateTime.UtcNow-new System.TimeSpan(0, 5, 0), System.DateTime.MaxValue);
            BanMachine(bs);
        }

        /// <summary> Adds or updates a machine ban for this machine.  A machine may be banned for multiple reasons.  This does not add a console ban. </summary>
        public void BanMachine(int ReasonCode, System.DateTime start, System.DateTime end)
        {
            MachineBanStatus bs=new MachineBanStatus(Id, ReasonCode, start, end);
            BanMachine(bs);
        }

        /// <summary> Adds or updates a machine ban for this machine.  A machine may be banned for multiple reasons.  This does not add a console ban. </summary>
        public static void BanMachine(MachineBanStatus ban)
        {
            string query=QueryGenerator.GenerateUpdateOrInsert("t_machine_banned",
                                                  new string[]{"bi_machine_puid", "i_reason_code", "dt_start",    "dt_end",    "si_hash_bucket"},
                                                  new object[]{ban.MachineId,     ban.ReasonCode,  ban.StartDate, ban.EndDate, ban.HashBucket},
                                                  new string[]{"bi_machine_puid", "i_reason_code"});
            UodbWS.ExecuteSQLNonQuery(query, ban.MachineId);
        }

        /// <summary> Retrieves all machine bans for this machine, sorted by ban reason ascending.  This does not retrieve console bans. </summary>
        public MachineBanStatus[] GetAllMachineBans()
        {
            System.Collections.Generic.List<MachineBanStatus> bans=new System.Collections.Generic.List<MachineBanStatus>();

            using (WSClient ws=new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITETHENREAD_COMMANDTYPE))
            {
                ws.PartitionType=WstPartitionType.Logical;
                WebstoreDB.SetHashValue(ws, Id);
                ws.CommandSql="select i_reason_code, dt_start, dt_end, si_hash_bucket from t_machine_banned where bi_machine_puid="+(long)id+" order by i_reason_code";

                using (WstDataReader reader=ws.Execute())
                {
                    while (reader.Read())
                    {
                        MachineBanStatus bs=new MachineBanStatus();
                        bs.MachineId=Id;
                        bs.ReasonCode=(int)reader[0];
                        bs.StartDate=(System.DateTime)reader[1];
                        bs.EndDate=(System.DateTime)reader[2];
                        bs.HashBucket=(short)reader[3];

                        bans.Add(bs);
                    }
                }
            }

            return bans.ToArray();
        }

        public struct MachineBanHistory
        {
            public ulong MachineId;
            public System.DateTime ChangeTime;
            public int ReasonCode;
            public System.DateTime StartDate;
            public System.DateTime EndDate;
            public short HashBucket;

            public MachineBanHistory(ulong id, System.DateTime changeTime, int reason, System.DateTime start, System.DateTime end)
            {
                MachineId=id;
                ChangeTime=changeTime;
                ReasonCode=reason;
                StartDate=start;
                EndDate=end;
                HashBucket=(short)UodbWS.GetHashBucket(id);
            }

            public override string ToString()
            {
                return "MachineBanHistory(MachineId="+string.Format("0x{0:X}", MachineId)+" ChangeTime="+ChangeTime+" ReasonCode="+string.Format("0x{0:X}", ReasonCode)+" StartDate="+StartDate+" EndDate="+EndDate+" HashBucket="+HashBucket+")";
            }
        }

        /// <summary> Retrieves all machine ban history for this machine.  This does not retrieve console ban history. </summary>
        public MachineBanHistory[] GetAllMachineBanHistories()
        {
            System.Collections.Generic.List<MachineBanHistory> bans=new System.Collections.Generic.List<MachineBanHistory>();

            using (WSClient ws=new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITETHENREAD_COMMANDTYPE))
            {
                ws.PartitionType=WstPartitionType.Logical;
                WebstoreDB.SetHashValue(ws, Id);
                ws.CommandSql="select dt_timestamp, i_reason_code, dt_start, dt_end, si_hash_bucket from t_machine_banned_history where bi_machine_puid="+(long)id;

                using (WstDataReader reader=ws.Execute())
                {
                    while (reader.Read())
                    {
                        MachineBanHistory bs=new MachineBanHistory();
                        bs.MachineId=Id;
                        bs.ChangeTime=(System.DateTime)reader[0];
                        bs.ReasonCode=(int)reader[1];
                        bs.StartDate=(System.DateTime)reader[2];
                        bs.EndDate=(System.DateTime)reader[3];
                        bs.HashBucket=(short)reader[4];

                        bans.Add(bs);
                    }
                }
            }

            return bans.ToArray();
        }

        #endregion

        /// <summary> Converts an AuthContext client type to a MachineType. </summary>
        public static MachineType AuthClientTypeToMachineType(ServerTestFramework.LiveService.Auth.AuthContext.ClientTypes clientType)
        {
            if (clientType==ServerTestFramework.LiveService.Auth.AuthContext.ClientTypes.Xbox) return MachineType.Xbox1;
            else if (clientType==ServerTestFramework.LiveService.Auth.AuthContext.ClientTypes.Xenon) return MachineType.Xbox360;
            else if (clientType==ServerTestFramework.LiveService.Auth.AuthContext.ClientTypes.XenonBackCompat) return MachineType.Xbox360;
            else if (clientType==ServerTestFramework.LiveService.Auth.AuthContext.ClientTypes.Panorama) return MachineType.PC;
            else
            {
                throw new System.Exception("Unhandled client type: "+clientType);
            }
        }
    };
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\Database\Editor\InstanceEditor.cs ===
using System;

using xonline.common.sql.webstore;
using xonline.common.config;

namespace ServerTestFramework.Database
{
    /// <summary>
    /// Utility for altering or creating instances directly in the database.
    /// </summary>
    public class InstanceEditor : EditorCommon
    {
        /// <summary>Instance name. This is the only non-cached information we store about the site.</summary>
        public string Name
        {
            get;
            private set;
        }

        // --
        #region Create an instance of InstanceEditor

        /// <summary>Construct from an existing instance (does not guarentee that the instance exists).</summary>
        public static InstanceEditor FromName (string name)
        {
            InstanceEditor editor = new InstanceEditor();
            editor.Name = name;
            return editor;
        }

        /// <summary>Constructs from a name, creating the instance in the database if it does not already exist.</summary>
        public static InstanceEditor CreateOrUseExisting (string name)
        {
            if (string.IsNullOrEmpty(name))
            {
                throw new ArgumentException("Name must have a value.", "name");
            }

            // use existing if it already exists
            InstanceEditor editor = InstanceEditor.FromName(name);

            if (!editor.Exists)
            {
                // create it
                string query = @"
Insert into t_instances (vc_instance, vc_environment, vc_hostname) values ('{0}', '{1}', '')
";
                query = string.Format(query, EscapeString(name), EscapeString(Config.Environment));

                StaticNpdb.ExecuteNonQuery(query);
            }

            return editor;
        }

        // constructor is not for public consumption.
        private InstanceEditor ()
        {
        }

        #endregion

        // --
        #region Lookup or alter properties of the instance

        /// <summary>Whether the instance actually exists in the database.</summary>
        public override bool Exists
        {
            get
            {
                if (HasCachedEntry("exists"))
                {
                    return (bool)cache["exists"];
                }

                bool exists = (int)StaticNpdb.ExecuteScalar("select count(0) from t_instances where vc_instance = '" +
                    EscapeString(Name) + "' and vc_environment = '" + EscapeString(Config.Environment) + "'") != 0;
                SetCacheEntry("exists", exists);
                return exists;
            }
        }

        /// <summary>The hostname of the instance.</summary>
        public string Hostname
        {
            get
            {
                return GetGenericSiteProperty<string>("vc_hostname");
            }

            set
            {
                SetGenericSiteProperty("vc_hostname", value);
            }
        }

        /// <summary>Generic implementation of returning a property from an instance (or cache if able).</summary>
        private TypeOfProperty GetGenericSiteProperty<TypeOfProperty> (string columnName)
        {
            return GetGenericSiteProperty<TypeOfProperty>(columnName, columnName);
        }

        /// <summary>Generic implementation of returning a property from an instance (or cache if able).</summary>
        private TypeOfProperty GetGenericSiteProperty<TypeOfProperty>(string columnName, string cacheName)
        {
            if (HasCachedEntry(cacheName))
            {
                return (TypeOfProperty)cache[cacheName];
            }

            object ret = StaticNpdb.ExecuteScalar("select " + columnName + " from t_instances where vc_instance = '" +
                EscapeString(Name) + "' and vc_environment = '" + EscapeString(Config.Environment) + "'");
            if (ret != null)
            {
                TypeOfProperty val = (TypeOfProperty)System.Convert.ChangeType(ret, typeof(TypeOfProperty));
                SetCacheEntry(cacheName, val);
                return val;
            }

            throw new RowDoesNotExistException("t_instances", columnName, Name);
        }

        /// <summary>Generic implementation of setting a property of an instance. The value must be convertible to a string in a way that SQL understands.</summary>
        private void SetGenericSiteProperty<TypeOfProperty> (string columnName, TypeOfProperty value)
        {
            SetGenericSiteProperty<TypeOfProperty>(columnName, columnName, value);
        }

        /// <summary>Generic implementation of setting a property of an instance. The value must be convertible to a string in a way that SQL understands.</summary>
        private void SetGenericSiteProperty<TypeOfProperty>(string columnName, string cacheName, TypeOfProperty value)
        {
            StaticNpdb.ExecuteNonQuery("update t_instances set " + columnName + " = '" + EscapeString(value.ToString()) +
                "' where vc_instance = '" + EscapeString(Name) + "' and vc_environment = '" + EscapeString(Config.Environment) + "'");
            SetCacheEntry(cacheName, value);
        }

        #endregion

        // Short descriptive useful string that doesn't require db hits
        public override string ToString()
        {
            if (string.IsNullOrEmpty(Name))
            {
                return "Nonexistant Instance";
            }
            else
            {
                return "Instance " + Name;
            }
        }

        // string containing every field.  This call is expensive, as it makes many db hits.
        public string FullDescription
        {
            get
            {
                throw new NotImplementedException();
            }
        }

        #region Add or remove "assets" for the instance

        /// <summary>Completely removes the instance from the database. </summary>
        public void Delete ()
        {
            StaticNpdb.ExecuteNonQuery("delete from t_instances where vc_instance = '" +
                EscapeString(Name) + "' and vc_environment = '" + EscapeString(Config.Environment) + "'");
        }

        #endregion
    };
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\Database\Editor\InterfaceEditor.cs ===
using System;
using System.Collections.Generic;
using System.Linq;

using xonline.common.config;
using xonline.common.sql.webstore;

namespace ServerTestFramework.Database
{
    /// <summary>
    /// Utility for altering or creating virtual interfaces directly in the database.
    /// NOTE: Be careful using this, modifying an existing interface is not to be done lightly.
    /// </summary>
    public class InterfaceEditor : EditorCommon
    {
        /// <summary>The interface's name.</summary>
        /// <remarks>This is the only non-cached information we store.</remarks>
        public string Name
        {
            get;
            private set;
        }

        #region Create or remove an instance of InterfaceEditor

        /// <summary>Construct from an existing interface name (does not guarantee that the interface exists).</summary>
        public static InterfaceEditor FromName (string name)
        {
            return new InterfaceEditor() { Name = name };
        }

        /// <summary>
        /// Constructs from an interface definition, creating the interface in the database
        /// if it does not already exist or overwriting all values if it does.  KNOW WHAT YOU ARE DOING IF YOU USE THIS!
        /// </summary>
        public static InterfaceEditor CreateOrOverwrite (string name, string componentName, string nicRole, string protocol, int? port,
            int? portEnd, string vSite, int? vSiteId, string vDir, string dbName, string shareName, int? timeout, int? serviceId,
            string serviceName, bool needSgInfo, string xboxStateChangeNotificationUrl, string titleChangeNotificationUrl,
            string deadXboxNotificationUrl, string userRole, string info1, string info2)
        {
            // check for invalid data
            if (string.IsNullOrEmpty(name))
            {
                throw new ArgumentNullException("name");
            }

            if (string.IsNullOrEmpty(componentName))
            {
                throw new ArgumentNullException("componentName");
            }

            if (string.IsNullOrEmpty(nicRole))
            {
                throw new ArgumentNullException("nicRole");
            }

            if (string.IsNullOrEmpty(protocol))
            {
                throw new ArgumentNullException("protocol");
            }

            // create sproc call string
            string sproc = @"
Exec p_config_add_interface
    @interface = {0},
    @component = {1},
    @nicRole = {2},
    @protocol = {3},
    @port = {4},
    @portEnd = {5},
    @vSite = {6},
    @vSiteId = {7},
    @vDir = {8},
    @dbName = {9},
    @shareName = {10},
    @timeout = {11},
    @serviceId = {12},
    @serviceName = {13},
    @needSgInfo = {14},
    @xboxStateChangeNotificationUrl = {15},
    @titleChangeNotificationUrl = {16},
    @deadXboxNotificationUrl = {17},
    @userRole = {18},
    @info1 = {19},
    @info2 = {20},
    @overwriteExistingValue = 1
";
            sproc = string.Format(sproc,
                FormatString(name),
                FormatString(componentName),
                FormatString(nicRole),
                FormatString(protocol),
                FormatNullable(port),
                FormatNullable(portEnd),
                FormatString(vSite),
                FormatNullable(vSiteId),
                FormatString(vDir),
                FormatString(dbName),
                FormatString(shareName),
                FormatNullable(timeout),
                FormatNullable(serviceId),
                FormatString(serviceName),
                FormatBool(needSgInfo),
                FormatString(xboxStateChangeNotificationUrl),
                FormatString(titleChangeNotificationUrl),
                FormatString(deadXboxNotificationUrl),
                FormatString(userRole),
                FormatString(info1),
                FormatString(info2));

            StaticNpdb.ExecuteNonQuery(sproc);

            return FromName(name);
        }

        /// <summary>Completely removes the interface from the database.</summary>
        public void Delete ()
        {
            StaticNpdb.ExecuteNonQuery("Delete from t_interface_notifications where vc_interface = '" + EscapedName + "'");
            StaticNpdb.ExecuteNonQuery("Delete from t_interfaces where vc_interface = '" + EscapedName + "'");
        }

        // constructor is not for public consumption.
        private InterfaceEditor ()
        {
        }

        #endregion

        #region Lookup or alter properties of the interface

        /// <summary>Whether the interface actually exists in the database.</summary>
        public override bool Exists
        {
            get
            {
                if (HasCachedEntry("exists"))
                {
                    return (bool)cache["exists"];
                }

                bool exists = !string.IsNullOrEmpty(Name) && 
                    ((int)StaticNpdb.ExecuteScalar("Select count(0) from t_interfaces where vc_interface = '" +
                    EscapedName + "'") != 0);
                SetCacheEntry("exists", exists);
                return exists;
            }
        }

        /// <summary>Component that the interface represents.</summary>
        public string Component
        {
            get
            {
                return GetGenericProperty<string>("vc_component");
            }

            set
            {
                SetGenericProperty("vc_component", value);
            }
        }

        /// <summary>Nic role of the interface.</summary>
        public string NicRole
        {
            get
            {
                return GetGenericProperty<string>("vc_nic_role");
            }

            set
            {
                SetGenericProperty("vc_nic_role", value);
            }
        }

        /// <summary>Protocol of the interface.</summary>
        public string Protocol
        {
            get
            {
                return GetGenericProperty<string>("vc_protocol");
            }

            set
            {
                SetGenericProperty("vc_protocol", value);
            }
        }

        /// <summary>Port of the interface.</summary>
        public int Port
        {
            get
            {
                return GetGenericProperty<int>("i_port");
            }

            set
            {
                SetGenericProperty("i_port", value);
            }
        }

        /// <summary>End port of the interface.</summary>
        public int PortEnd
        {
            get
            {
                return GetGenericProperty<int>("i_port_end");
            }

            set
            {
                SetGenericProperty("i_port_end", value);
            }
        }

        /// <summary>VSite of the interface.</summary>
        public string VSite
        {
            get
            {
                return GetGenericProperty<string>("vc_vsite");
            }

            set
            {
                SetGenericProperty("vc_vsite", value);
            }
        }

        /// <summary>VSite Id of the interface.</summary>
        public int VSiteId
        {
            get
            {
                return GetGenericProperty<int>("i_vsite_id");
            }

            set
            {
                SetGenericProperty("i_vsite_id", value);
            }
        }

        /// <summary>VDir of the interface.</summary>
        public string VDir
        {
            get
            {
                return GetGenericProperty<string>("vc_vdir");
            }

            set
            {
                SetGenericProperty("vc_vdir", value);
            }
        }

        /// <summary>Database name of the interface.</summary>
        public string DBName
        {
            get
            {
                return GetGenericProperty<string>("vc_dbname");
            }

            set
            {
                SetGenericProperty("vc_dbname", value);
            }
        }

        /// <summary>Share name of the interface.</summary>
        public string ShareName
        {
            get
            {
                return GetGenericProperty<string>("vc_sharename");
            }

            set
            {
                SetGenericProperty("vc_sharename", value);
            }
        }

        /// <summary>Timeout of the interface.</summary>
        public int Timeout
        {
            get
            {
                return GetGenericProperty<int>("i_timeout");
            }

            set
            {
                SetGenericProperty("i_timeout", value);
            }
        }

        /// <summary>Service id of the interface.</summary>
        public int ServiceId
        {
            get
            {
                return GetGenericProperty<int>("i_service_id");
            }

            set
            {
                SetGenericProperty("i_service_id", value);
            }
        }

        /// <summary>Service name of the interface.</summary>
        public string ServiceName
        {
            get
            {
                return GetGenericProperty<string>("vc_service_name");
            }

            set
            {
                SetGenericProperty("vc_service_name", value);
            }
        }

        /// <summary>Whether the interface needs SG info.</summary>
        public bool NeedSGInfo
        {
            get
            {
                return GetGenericProperty<bool>("b_need_sg_info");
            }

            set
            {
                SetGenericProperty("b_need_sg_info", value);
            }
        }

        /// <summary>Xbox state change notification url of the interface.</summary>
        public string XboxStateChangeNotificationUrl
        {
            get
            {
                return GetGenericProperty<string>("vc_xbox_state_change_notification_url");
            }

            set
            {
                SetGenericProperty("vc_xbox_state_change_notification_url", value);
            }
        }

        /// <summary>Title change notification url of the interface.</summary>
        public string TitleChangeNotificationUrl
        {
            get
            {
                return GetGenericProperty<string>("vc_title_change_notification_url");
            }

            set
            {
                SetGenericProperty("vc_title_change_notification_url", value);
            }
        }

        /// <summary>Dead xbox notification url of the interface.</summary>
        public string DeadXboxNotificationUrl
        {
            get
            {
                return GetGenericProperty<string>("vc_dead_xbox_notification_url");
            }

            set
            {
                SetGenericProperty("vc_dead_xbox_notification_url", value);
            }
        }

        /// <summary>User role of the interface.</summary>
        public string UserRole
        {
            get
            {
                return GetGenericProperty<string>("vc_user_role");
            }

            set
            {
                SetGenericProperty("vc_user_role", value);
            }
        }

        /// <summary>Info1 of the interface.</summary>
        public string Info1
        {
            get
            {
                return GetGenericProperty<string>("vc_info1");
            }

            set
            {
                SetGenericProperty("vc_info1", value);
            }
        }

        /// <summary>Info2 of the interface.</summary>
        public string Info2
        {
            get
            {
                return GetGenericProperty<string>("vc_info2");
            }

            set
            {
                SetGenericProperty("vc_info2", value);
            }
        }

        /// <summary>Generic implementation of returning a property from an interface (or cache if able).</summary>
        private TypeOfProperty GetGenericProperty<TypeOfProperty> (string columnName)
        {
            return GetGenericProperty<TypeOfProperty>(columnName, columnName);
        }

        /// <summary>Generic implementation of returning a property from an interface (or cache if able).</summary>
        private TypeOfProperty GetGenericProperty<TypeOfProperty> (string columnName, string cacheName)
        {
            if (HasCachedEntry(cacheName))
            {
                return (TypeOfProperty)cache[cacheName];
            }

            object ret = StaticNpdb.ExecuteScalar("Select " + columnName + " from t_interfaces where vc_interface = '" +
                    EscapedName + "'");
            if (ret != null)
            {
                TypeOfProperty val = (TypeOfProperty)System.Convert.ChangeType(ret, typeof(TypeOfProperty));
                SetCacheEntry(cacheName, val);
                return val;
            }

            throw new RowDoesNotExistException("t_interfaces", columnName, Name);
        }

        /// <summary>Generic implementation of setting a property of an interface.  The value must be convertible to a string in a way that SQL understands.</summary>
        private void SetGenericProperty<TypeOfProperty> (string columnName, TypeOfProperty value)
        {
            SetGenericProperty<TypeOfProperty>(columnName, columnName, value);
        }

        /// <summary>Generic implementation of setting a property of an interface.  The value must be convertible to a string in a way that SQL understands.</summary>
        private void SetGenericProperty<TypeOfProperty> (string columnName, string cacheName, TypeOfProperty value)
        {
            StaticNpdb.ExecuteNonQuery("Update t_interfaces set " + columnName + " = '" + EscapeString(value.ToString()) + 
                "' where vc_interface = '" + EscapedName + "'");
            SetCacheEntry(cacheName, value);
        }

        #endregion

        #region Add or remove "assets" for the interface

        /// <summary>The different notification types.</summary>
        public enum NotificationType
        {
            XboxStateChange,
            TitleChange,
            DeadXbox,
            UserChange,
            SpiUpdate
        }

        /// <summary>Gets the string for the given notification type.</summary>
        public string ConvertNotificationTypeToName (NotificationType notification)
        {
            switch (notification)
            {
                case NotificationType.XboxStateChange: return "xbox_state_change_notification_url";
                case NotificationType.TitleChange: return "title_change_notification_url";
                case NotificationType.DeadXbox: return "dead_xbox_notification_url";
                case NotificationType.UserChange: return "user_change_notification_url";
                case NotificationType.SpiUpdate: return "spi_update_notification_url";
            }

            return null;
        }

        /// <summary>
        /// Sets the url for a given notification type.
        /// </summary>
        /// <param name="notification">The notification type to set.</param>
        /// <param name="url">The url; when null, removes the entry.</param>
        public void SetNotificationUrl (NotificationType notification, string url)
        {
            SetNotificationUrl(ConvertNotificationTypeToName(notification), url);
        }

        /// <summary>
        /// Sets the url for a given notification type.
        /// </summary>
        /// <param name="notification">The notification type to set.</param>
        /// <param name="url">The url; when null, removes the entry.</param>
        public void SetNotificationUrl (string notification, string url)
        {
            if (string.IsNullOrEmpty(notification))
            {
                throw new ArgumentNullException("notification");
            }

            if (url == null)
            {
                StaticNpdb.ExecuteNonQuery("Delete from t_interface_notifications where vc_interface = '" + EscapedName +
                    "' and vc_notification = '" + EscapeString(notification) + "'");
            }
            else
            {
                string sproc = @"
p_config_add_interface_notification
    @interface = {0},
    @notification = {1},
    @url = {2},
    @overwriteExistingValue = 1
";
                sproc = string.Format(sproc,
                    FormatString(Name),
                    FormatString(notification),
                    FormatString(url)
                    );

                StaticNpdb.ExecuteNonQuery(sproc);
            }
        }

        /// <summary>
        /// Gets the servers for the interface.
        /// </summary>
        public List<string> GetServerList ()
        {
            string sproc = @"
Exec p_config_get_server_list_by_interface
    @vc_environment = {0},
    @vc_interface = {1}
";
            sproc = string.Format(sproc,
                FormatString(Config.Environment),
                FormatString(Name)
                );

            return StaticNpdb.ExecuteQueryGetMultiple(sproc).Select(a => a[0]).ToList();
        }

        #endregion

        // Short descriptive useful string that doesn't require db hits
        public override string ToString ()
        {
            return "Interface: " + (Name ?? "<null>");
        }

        // string containing every field.  This call is expensive, as it makes many db hits.
        public string FullDescription
        {
            get
            {
                throw new NotImplementedException();
            }
        }

        #region Helpers

        /// <summary>The Name, escaped.</summary>
        private string EscapedName
        {
            get
            {
                return EscapeString(Name);
            }
        }

        /// <summary>Formats a nullable type for a SQL statement.</summary>
        private static string FormatNullable<T> (Nullable<T> n) where T : struct
        {
            return (n.HasValue ? n.Value.ToString() : "null");
        }

        /// <summary>Formats a string for a SQL statement.</summary>
        private static string FormatString (string s)
        {
            return (s == null ? "null" : "'" + EscapeString(s) + "'");
        }

        /// <summary>Formats a bool for a SQL statement.</summary>
        private static string FormatBool (bool b)
        {
            return (b ? "1" : "0");
        }

        #endregion
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\Database\Editor\CurfewEditor.cs ===
using xonline.common.sql.webstore;
using xonline.common.config;
using Microsoft.Webstore.WstClient;

using System.Collections.Generic;

using ServerTestFramework.Utilities;

namespace ServerTestFramework.Database
{
    /// <summary>
    /// Utility for altering or creating a curfew.
    /// </summary>
    public class CurfewEditor: EditorCommon
    {
        /// <summary> Country ID.  This is the only non-cached information we store about the curfew. </summary>
        public byte CountryId
        {
            get { return id; }
        }

        private byte id=0;

        #region Create an instance of CountryEditor

        /// <summary> Construct from an existing country id (does not guarentee that the country or curfew exists). </summary>
        public static CurfewEditor FromId(byte countryId)
        {
            CurfewEditor ce=new CurfewEditor();
            ce.id=countryId;
            return ce;
        }

        /// <summary> Constructs from a country id, creating the curfew row if neccesary in the db if it does not already exist. </summary>
        public static CurfewEditor CreateOrUseExistingId(byte countryId)
        {
            CurfewEditor ce=new CurfewEditor();
            ce.id=countryId;

            //insert the t_countries entry if needed
            if (!UodbWS.DoesCurfewExist(countryId))
            {
                UodbWS.ExecuteSQLNonQuery("insert into t_curfew_privilege_set_restrictions (ti_country_id, si_age_limit, t_start_time_utc, si_duration_minutes, dt_change_datetime, si_privilege_set_id) values ("+(int)countryId+", 16, '14:55', 365, getutcdate(), 2000)", null);
            }

            return ce;
        }

        //constructor is not for public consumption.
        private CurfewEditor()
        {
        }

        #endregion

        // --
        #region Lookup or alter properties of the country

        /// <summary> Whether the curfew actually exists in the db. </summary>
        public override bool Exists
        {
            get
            {
                if (HasCachedEntry("exists"))
                {
                    return (bool)cache["exists"];
                }

                bool exists=id!=0 && UodbWS.DoesCurfewExist(id);
                SetCacheEntry("exists", exists);
                return exists;
            }
        }

        /// <summary> The age under which the curfew applies. </summary>
        public short AgeLimit
        {
            get
            {
                return GetGenericCurfewProperty<short>("si_age_limit");
            }

            set
            {
                SetGenericCurfewProperty("si_age_limit", value);
            }
        }

        /// <summary> The time of day (in utc) that the curfew starts. </summary>
        public System.TimeSpan StartTime
        {
            get
            {
                return GetGenericCurfewProperty<System.TimeSpan>("t_start_time_utc");
            }

            set
            {
                SetGenericCurfewProperty("t_start_time_utc", value);
            }
        }

        /// <summary> The duration of the curfew in minutes. </summary>
        public short DurationInMinutes
        {
            get
            {
                return GetGenericCurfewProperty<short>("si_duration_minutes");
            }

            set
            {
                SetGenericCurfewProperty("si_duration_minutes", value);
            }
        }

        /// <summary> Privilege set for which privileges are revoked during the curfew. </summary>
        public short PrivilegeSetId
        {
            get
            {
                return GetGenericCurfewProperty<short>("si_privilege_set_id");
            }

            set
            {
                SetGenericCurfewProperty("si_privilege_set_id", value);
            }
        }

        #endregion

        //Short descriptive useful string that doesn't require db hits
        public override string ToString()
        {
            return string.Format("Curfew 0x{0:X}", id);
        }

        //Long string containing every field of the curfew.  This call can be expensive, as it may make db hits.
        public string FullDescription
        {
            get
            {
                if (!Exists)
                {
                    return string.Format("Nonexistant Curfew 0x{0:X}", id);
                }
                else
                {
                    return ToString()+
                        "\nAgeLimit="+AgeLimit+
                        "\nStartTime="+StartTime+
                        "\nDurationInMinutes="+DurationInMinutes+
                        "\nPrivilegeSetId="+PrivilegeSetId;
                }
            }
        }

        /// <summary> Deletes the curfew. </summary>
        public void Remove()
        {
            UodbWS.ExecuteSQLNonQuery("delete from t_curfew_privilege_set_restrictions where ti_country_id="+(int)id, null);
        }

        /// <summary> Generic implementation of returning a property from an Curfew (or cache if able). </summary>
        private TypeOfProperty GetGenericCurfewProperty<TypeOfProperty>(string columnName)
        {
            if (HasCachedEntry(columnName))
            {
                return (TypeOfProperty)cache[columnName];
            }

            object ret=UodbWS.ExecuteSQLScalar("select "+columnName+" from t_curfew_privilege_set_restrictions where ti_country_id="+(int)id, null);
            if (ret!=null)
            {
                TypeOfProperty val=(TypeOfProperty)System.Convert.ChangeType(ret, typeof(TypeOfProperty));
                SetCacheEntry(columnName, val);
                return val;
            }

            throw new RowDoesNotExistException("t_curfew_privilege_set_restrictions", columnName, "ti_country_id="+(int)id);
        }

        /// <summary> Generic implementation of setting a property in an Voucher.  The value must be convertible to a string in a way that SQL understands. </summary>
        private void SetGenericCurfewProperty<TypeOfProperty>(string columnName, TypeOfProperty value)
        {
            UodbWS.ExecuteSQLNonQuery("update t_curfew_privilege_set_restrictions set "+columnName+"='"+EscapeString(value.ToString())+"' where ti_country_id="+(int)id, null);
            SetCacheEntry(columnName, value);
        }
    };
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\Database\Editor\MachineGamertagHistoryEditor.cs ===
using xonline.common.sql.webstore;
using xonline.common.config;

using Microsoft.Webstore.WstClient;

namespace ServerTestFramework.Database
{
    public class MachineGamertagHistoryEditor
    {
        /// <summary> Machine Puid.  This is the only non-cached information we store about the machine's gamertag history. </summary>
        public ulong MachinePuid
        {
            get { return machinePuid; }
        }
        private ulong machinePuid;

        //TODO: Once the UODB version is deprecated and completely removed, we can remove this.  This controls whether operations hit Uodb or SecMachineHistoryDB.
        public bool HitSecMHDB
        {
            get { return hitSecMHDB; }
        }
        private bool hitSecMHDB;

        // --

        #region Create an instance of MachineGamertagHistoryEditor

        //constructor is not for public use
        private MachineGamertagHistoryEditor() {}

        //TODO: Once the UODB version is deprecated and completely removed, we can remove hitSecMHDBInsteadOfUodb
        public static MachineGamertagHistoryEditor FromMachinePuid(ulong mpuid, bool hitSecMHDBInsteadOfUodb)
        {
            MachineGamertagHistoryEditor mghe=new MachineGamertagHistoryEditor();
            mghe.machinePuid=mpuid;
            mghe.hitSecMHDB=hitSecMHDBInsteadOfUodb;
            return mghe;
        }

        #endregion

        #region Access the "assets" of the machine's gamertag history

        public class MachineGamertagHistoryEntry: System.IEquatable<MachineGamertagHistoryEntry>
        {
            public ulong UserPuid;
            public ulong MachinePuid;
            public string IpAddress;
            public System.DateTime TimeStamp;
            public uint Hr;
            public string OldGamertag;
            public string NewGamertag;
            public byte Reason;
            public short HashBucket;

            public MachineGamertagHistoryEntry()
            {
            }

            //TODO: Once the UODB version is deprecated and completely removed, we can remove isSecMHDBInsteadOfUodbHashing
            public MachineGamertagHistoryEntry(ulong userPuid, ulong machinePuid, string ipAddress, System.DateTime timeStamp, uint hr, string oldGamertag, string newGamertag, byte reason, bool isSecMHDBInsteadOfUodbHashing)
            {
                UserPuid=userPuid;
                MachinePuid=machinePuid;
                IpAddress=ipAddress;
                TimeStamp=timeStamp;
                Hr=hr;
                OldGamertag=oldGamertag;
                NewGamertag=newGamertag;
                Reason=reason;

                if (isSecMHDBInsteadOfUodbHashing)
                {
                    HashBucket=(short)WebstoreDB.GetHashBucket(ConfigUtil.SecMachineHistoryWebstoreApp, machinePuid);
                }
                else
                {
                    HashBucket=(short)UodbWS.GetHashBucket(machinePuid);
                }
            }

            public override bool Equals(object other)
            {
                if(!(other is MachineGamertagHistoryEntry))
                {
                    return false;
                }

                return Equals((MachineGamertagHistoryEntry)other);
            }

            public bool Equals(MachineGamertagHistoryEntry other)
            {
                return UserPuid==other.UserPuid &&
                    MachinePuid==other.MachinePuid &&
                    IpAddress==other.IpAddress &&
                    System.Math.Abs((TimeStamp-other.TimeStamp).TotalMilliseconds)<10 &&
                    Hr==other.Hr &&
                    OldGamertag==other.OldGamertag &&
                    NewGamertag==other.NewGamertag &&
                    Reason==other.Reason &&
                    HashBucket==other.HashBucket;
            }

            public override int GetHashCode()
            {
                return MachinePuid.GetHashCode()^UserPuid.GetHashCode()^TimeStamp.GetHashCode();
            }

            public override string ToString()
            {
                return "MachineGamertagHistoryEntry(UserPuid="+string.Format("0x{0:X}", UserPuid)+" MachinePuid="+string.Format("0x{0:X}", MachinePuid)+" IpAddress="+IpAddress+" TimeStamp="+TimeStamp+" Hr="+string.Format("0x{0:X}", Hr)+" OldGamertag="+OldGamertag+" NewGamertag="+NewGamertag+" Reason="+Reason+" HashBucket="+HashBucket+")";
            }
        };

        /// <summary> Removes all gamertag history for this machine. </summary>
        public void RemoveAllHistory()
        {
            if (HitSecMHDB)
            {
                WebstoreDB.ExecuteSQLNonQuery(ConfigUtil.SecMachineHistoryWebstoreApp, "delete from t_machine_gamertag_history where bi_machine_puid="+(long)MachinePuid, MachinePuid);
            }
            else
            {
                UodbWS.ExecuteSQLNonQuery("delete from t_machine_gamertag_history where bi_machine_puid="+(long)MachinePuid, MachinePuid);
            }
        }

        /// <summary> Adds or updates a history entry for this machine. </summary>
        public void SetHistory(MachineGamertagHistoryEntry ent)
        {
            if (ent.MachinePuid!=MachinePuid)
            {
                throw new System.Exception("Cannot set row for the wrong machine puid.");
            }

            string query=QueryGenerator.GenerateUpdateOrInsert("t_machine_gamertag_history",
                                                  new string[]{"bi_user_puid", "bi_machine_puid", "vc_ip_address", "dt_timestamp", "i_hr", "vc_old_gamertag", "vc_new_gamertag", "ti_reason", "si_hash_bucket"},
                                                  new object[]{ent.UserPuid,   ent.MachinePuid,   ent.IpAddress,   ent.TimeStamp,  ent.Hr, ent.OldGamertag,   ent.NewGamertag,   ent.Reason,  ent.HashBucket},
                                                  new string[]{"bi_machine_puid", "dt_timestamp"});

            if (HitSecMHDB)
            {
                WebstoreDB.ExecuteSQLNonQuery(ConfigUtil.SecMachineHistoryWebstoreApp, query, MachinePuid);
            }
            else
            {
                UodbWS.ExecuteSQLNonQuery(query, MachinePuid);
            }
        }

        /// <summary> Retrieves all history for this machine. </summary>
        public MachineGamertagHistoryEntry[] GetAllHistory()
        {
            System.Collections.Generic.List<MachineGamertagHistoryEntry> entries=new System.Collections.Generic.List<MachineGamertagHistoryEntry>();

            string webstoreDb;
            if (HitSecMHDB)
            {
                webstoreDb=ConfigUtil.SecMachineHistoryWebstoreApp;
            }
            else
            {
                webstoreDb=ConfigUtil.UodbWebstoreApp;
            }

            using (WSClient ws=new WSClient(webstoreDb, CmdType.WRITETHENREAD_COMMANDTYPE))
            {
                ws.PartitionType=WstPartitionType.Logical;
                WebstoreDB.SetHashValue(ws, MachinePuid);
                ws.CommandSql="select bi_user_puid, vc_ip_address, dt_timestamp, i_hr, vc_old_gamertag, vc_new_gamertag, ti_reason, si_hash_bucket from t_machine_gamertag_history where bi_machine_puid="+(long)MachinePuid;

                using (WstDataReader reader=ws.Execute())
                {
                    while (reader.Read())
                    {
                        MachineGamertagHistoryEntry entry=new MachineGamertagHistoryEntry();
                        entry.UserPuid=(ulong)(long)reader[0];
                        entry.MachinePuid=MachinePuid;
                        entry.IpAddress=(reader[1]==System.DBNull.Value?null:(string)reader[1]);
                        entry.TimeStamp=(System.DateTime)reader[2];
                        entry.Hr=(uint)(int)reader[3];
                        entry.OldGamertag=(reader[4]==System.DBNull.Value?null:(string)reader[4]);
                        entry.NewGamertag=(reader[5]==System.DBNull.Value?null:(string)reader[5]);
                        entry.Reason=(byte)reader[6];
                        entry.HashBucket=(short)reader[7];

                        entries.Add(entry);
                    }
                }
            }

            return entries.ToArray();
        }

        #endregion
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\Database\Editor\MachinePassportHistoryEditor.cs ===
using xonline.common.sql.webstore;
using xonline.common.config;

using Microsoft.Webstore.WstClient;

namespace ServerTestFramework.Database
{
    public class MachinePassportHistoryEditor
    {
        /// <summary> Machine Puid.  This is the only non-cached information we store about the machine's Passport history. </summary>
        public ulong MachinePuid
        {
            get { return machinePuid; }
        }
        private ulong machinePuid;

        //TODO: Once the UODB version is deprecated and completely removed, we can remove this.  This controls whether operations hit Uodb or SecMachineHistoryDB.
        public bool HitSecMHDB
        {
            get { return hitSecMHDB; }
        }
        private bool hitSecMHDB;

        // --

        #region Create an instance of MachinePassportHistoryEditor

        //constructor is not for public use
        private MachinePassportHistoryEditor() {}

        //TODO: Once the UODB version is deprecated and completely removed, we can remove hitSecMHDBInsteadOfUodb
        public static MachinePassportHistoryEditor FromMachinePuid(ulong mpuid, bool hitSecMHDBInsteadOfUodb)
        {
            MachinePassportHistoryEditor mghe=new MachinePassportHistoryEditor();
            mghe.machinePuid=mpuid;
            mghe.hitSecMHDB=hitSecMHDBInsteadOfUodb;
            return mghe;
        }

        #endregion

        #region Access the "assets" of the machine's Passport history

        public class MachinePassportHistoryEntry: System.IEquatable<MachinePassportHistoryEntry>
        {
            public ulong UserPuid;
            public ulong MachinePuid;
            public string IpAddress;
            public System.DateTime TimeStamp;
            public uint Hr;
            public ulong ?OldPassport;
            public ulong ?NewPassport;
            public byte Reason;
            public short HashBucket;

            public MachinePassportHistoryEntry()
            {
            }

            //TODO: Once the UODB version is deprecated and completely removed, we can remove isSecMHDBInsteadOfUodbHashing
            public MachinePassportHistoryEntry(ulong userPuid, ulong machinePuid, string ipAddress, System.DateTime timeStamp, uint hr, ulong ?oldPassport, ulong ?newPassport, byte reason, bool isSecMHDBInsteadOfUodbHashing)
            {
                UserPuid=userPuid;
                MachinePuid=machinePuid;
                IpAddress=ipAddress;
                TimeStamp=timeStamp;
                Hr=hr;
                OldPassport=oldPassport;
                NewPassport=newPassport;
                Reason=reason;

                if (isSecMHDBInsteadOfUodbHashing)
                {
                    HashBucket=(short)WebstoreDB.GetHashBucket(ConfigUtil.SecMachineHistoryWebstoreApp, machinePuid);
                }
                else
                {
                    HashBucket=(short)UodbWS.GetHashBucket(machinePuid);
                }
            }

            public override bool Equals(object other)
            {
                if(!(other is MachinePassportHistoryEntry))
                {
                    return false;
                }

                return Equals((MachinePassportHistoryEntry)other);
            }

            public bool Equals(MachinePassportHistoryEntry other)
            {
                return UserPuid==other.UserPuid &&
                    MachinePuid==other.MachinePuid &&
                    IpAddress==other.IpAddress &&
                    System.Math.Abs((TimeStamp-other.TimeStamp).TotalMilliseconds)<10 &&
                    Hr==other.Hr &&
                    OldPassport==other.OldPassport &&
                    NewPassport==other.NewPassport &&
                    Reason==other.Reason &&
                    HashBucket==other.HashBucket;
            }

            public override int GetHashCode()
            {
                return MachinePuid.GetHashCode()^UserPuid.GetHashCode()^TimeStamp.GetHashCode();
            }

            public override string ToString()
            {
                return "MachinePassportHistoryEntry(UserPuid="+string.Format("0x{0:X}", UserPuid)+" MachinePuid="+string.Format("0x{0:X}", MachinePuid)+" IpAddress="+IpAddress+" TimeStamp="+TimeStamp+" Hr="+string.Format("0x{0:X}", Hr)+" OldPassport="+(OldPassport!=null?string.Format("0x{0:X}", OldPassport):"")+" NewPassport="+(NewPassport!=null?string.Format("0x{0:X}", NewPassport):"")+" Reason="+Reason+" HashBucket="+HashBucket+")";
            }
        };

        /// <summary> Removes all Passport history for this machine. </summary>
        public void RemoveAllHistory()
        {
            if (HitSecMHDB)
            {
                WebstoreDB.ExecuteSQLNonQuery(ConfigUtil.SecMachineHistoryWebstoreApp, "delete from t_machine_passport_history where bi_machine_puid="+(long)MachinePuid, MachinePuid);
            }
            else
            {
                UodbWS.ExecuteSQLNonQuery("delete from t_machine_passport_history where bi_machine_puid="+(long)MachinePuid, MachinePuid);
            }
        }

        /// <summary> Adds or updates a history entry for this machine. </summary>
        public void SetHistory(MachinePassportHistoryEntry ent)
        {
            if (ent.MachinePuid!=MachinePuid)
            {
                throw new System.Exception("Cannot set row for the wrong machine puid.");
            }

            string query=QueryGenerator.GenerateUpdateOrInsert("t_machine_passport_history",
                                                  new string[]{"bi_user_puid", "bi_machine_puid", "vc_ip_address", "dt_timestamp", "i_hr", "bi_old_passport_puid", "bi_new_passport_puid", "ti_reason", "si_hash_bucket"},
                                                  new object[]{ent.UserPuid,   ent.MachinePuid,   ent.IpAddress,   ent.TimeStamp,  ent.Hr, ent.OldPassport,        ent.NewPassport,        ent.Reason,  ent.HashBucket},
                                                  new string[]{"bi_machine_puid", "dt_timestamp"});

            if (HitSecMHDB)
            {
                WebstoreDB.ExecuteSQLNonQuery(ConfigUtil.SecMachineHistoryWebstoreApp, query, MachinePuid);
            }
            else
            {
                UodbWS.ExecuteSQLNonQuery(query, MachinePuid);
            }
        }

        /// <summary> Retrieves all history for this machine. </summary>
        public MachinePassportHistoryEntry[] GetAllHistory()
        {
            System.Collections.Generic.List<MachinePassportHistoryEntry> entries=new System.Collections.Generic.List<MachinePassportHistoryEntry>();

            string webstoreDb;
            if (HitSecMHDB)
            {
                webstoreDb=ConfigUtil.SecMachineHistoryWebstoreApp;
            }
            else
            {
                webstoreDb=ConfigUtil.UodbWebstoreApp;
            }

            using (WSClient ws=new WSClient(webstoreDb, CmdType.WRITETHENREAD_COMMANDTYPE))
            {
                ws.PartitionType=WstPartitionType.Logical;
                WebstoreDB.SetHashValue(ws, MachinePuid);
                ws.CommandSql="select bi_user_puid, vc_ip_address, dt_timestamp, i_hr, bi_old_passport_puid, bi_new_passport_puid, ti_reason, si_hash_bucket from t_machine_passport_history where bi_machine_puid="+(long)MachinePuid;

                using (WstDataReader reader=ws.Execute())
                {
                    while (reader.Read())
                    {
                        MachinePassportHistoryEntry entry=new MachinePassportHistoryEntry();
                        entry.UserPuid=(ulong)(long)reader[0];
                        entry.MachinePuid=MachinePuid;
                        entry.IpAddress=(reader[1]==System.DBNull.Value?null:(string)reader[1]);
                        entry.TimeStamp=(System.DateTime)reader[2];
                        entry.Hr=(uint)(int)reader[3];
                        entry.OldPassport=(reader[4]==System.DBNull.Value?null:(ulong?)(ulong)(long)reader[4]);
                        entry.NewPassport=(reader[5]==System.DBNull.Value?null:(ulong?)(ulong)(long)reader[5]);
                        entry.Reason=(byte)reader[6];
                        entry.HashBucket=(short)reader[7];

                        entries.Add(entry);
                    }
                }
            }

            return entries.ToArray();
        }

        #endregion
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\Database\Editor\PrivilegeEditor.cs ===
using xonline.common.sql.webstore;
using xonline.common.config;
using Microsoft.Webstore.WstClient;

using System.Collections.Generic;

using ServerTestFramework.Utilities;

namespace ServerTestFramework.Database
{
    /// <summary>
    /// Utility for altering or creating an individual privilege.
    /// </summary>
    public class PrivilegeEditor: EditorCommon
    {
        /// <summary>
        /// Privilege ID.  This is the only non-cached information we store about the privilege.
        /// </summary>
        public byte Id
        {
            get { return id; }
        }

        private byte id=0;

        #region Create an instance of PrivilegeEditor

        /// <summary>
        /// Construct from an existing privilege id (does not guarentee that the privilege exists).
        /// </summary>
        public static PrivilegeEditor FromId(byte privilegeId)
        {
            PrivilegeEditor priv=new PrivilegeEditor();
            priv.id=privilegeId;
            return priv;
        }

        /// <summary>
        /// Constructs from a privilege id, creating the privilege in the db if it does not already exist.
        /// </summary>
        public static PrivilegeEditor CreateOrUseExistingId(byte privilegeId)
        {
            PrivilegeEditor priv=new PrivilegeEditor();
            priv.id=privilegeId;

            //insert the t_privileges entry if needed
            if (!UodbWS.DoesPrivilegeExist(privilegeId))
            {
                UodbWS.ExecuteSQLNonQuery("insert into t_privileges (ti_privilege_id,vc_name) values ("+(int)privilegeId+", 'Test Privilege "+privilegeId+"')", null);
            }

            return priv;
        }

        //constructor is not for public consumption.
        private PrivilegeEditor()
        {
        }

        #endregion

        // --
        #region Lookup or alter properties of the privilege

        /// <summary>
        /// Whether the privilege actually exists in the db.
        /// </summary>
        public override bool Exists
        {
            get
            {
                if (HasCachedEntry("exists"))
                {
                    return (bool)cache["exists"];
                }

                bool exists=id!=0 && UodbWS.DoesPrivilegeExist(id);
                SetCacheEntry("exists", exists);
                return exists;
            }
        }

        /// <summary>
        /// Name of the privilege.
        /// </summary>
        public string Name
        {
            get
            {
                if (HasCachedEntry("name"))
                {
                    return (string)cache["name"];
                }

                object ret=UodbWS.ExecuteSQLScalar("select vc_name from t_privileges where ti_privilege_id="+(int)id, null);
                if (ret==null)
                {
                    throw new RowDoesNotExistException("t_privileges", "ti_privilege_id", id.ToString());
                }
                string name=(string)ret;
                SetCacheEntry("name", name);
                return name;
            }

            set
            {
                UodbWS.ExecuteSQLNonQuery("update t_privileges set vc_name='"+EscapeString(value)+"' where ti_privilege_id="+id, null);
                SetCacheEntry("name", value);
            }
        }

        #endregion

        //Short descriptive useful string that doesn't require db hits
        public override string ToString()
        {
            if (id==0)
            {
                return "Nonexistant Privilege (id=0)";
            }
            else
            {
                return string.Format("Privilege 0x{0:X}", id);
            }
        }

        //Long string containing every field of the privilege.  This call can be expensive, as it may make db hits.
        public string FullDescription
        {
            get
            {
                if (!Exists)
                {
                    return string.Format("Nonexistant Privilege 0x{0:X}", id);
                }
                else
                {
                    return ToString()+
                        "\nName="+Name;
                }
            }
        }
    };

    // --

    /// <summary>
    /// Utility for altering or creating a privilege set.
    /// </summary>
    public class PrivilegeSetEditor: EditorCommon
    {
        /// <summary>
        /// Privelege set ID.  This is the only non-cached information we store about the privilege set.
        /// </summary>
        public ushort Id
        {
            get { return id; }
        }

        private ushort id=0;

        #region Create an instance of PrivilegeSetEditor

        /// <summary>
        /// Construct from an existing privilege set id (does not guarentee that the privilege set exists).
        /// </summary>
        public static PrivilegeSetEditor FromId(ushort privilegeSetId)
        {
            PrivilegeSetEditor privset=new PrivilegeSetEditor();
            privset.id=privilegeSetId;
            return privset;
        }

        /// <summary>
        /// Constructs from a privilege set id, creating the privilege set in the db if it does not already exist.
        /// </summary>
        public static PrivilegeSetEditor CreateOrUseExistingId(ushort privilegeSetId)
        {
            PrivilegeSetEditor privset=new PrivilegeSetEditor();
            privset.id=privilegeSetId;

            //insert the t_privileges entry if needed
            if (!UodbWS.DoesPrivilegeSetExist(privilegeSetId))
            {
                UodbWS.ExecuteSQLNonQuery("insert into t_privilege_set (si_privilege_set_id,vc_friendly_name) values ("+(short)privilegeSetId+", 'Test Privilege Set "+privilegeSetId+"')", null);
            }

            return privset;
        }

        //constructor is not for public consumption.
        private PrivilegeSetEditor()
        {
        }

        #endregion

        // --
        #region Lookup or alter properties of the privilege set

        /// <summary>
        /// Whether the privilege set actually exists in the db.
        /// </summary>
        public override bool Exists
        {
            get
            {
                if (HasCachedEntry("exists"))
                {
                    return (bool)cache["exists"];
                }

                bool exists=id!=0 && UodbWS.DoesPrivilegeSetExist(id);
                SetCacheEntry("exists", exists);
                return exists;
            }
        }

        /// <summary>
        /// Name of the privilege set.
        /// </summary>
        public string Name
        {
            get
            {
                if (HasCachedEntry("name"))
                {
                    return (string)cache["name"];
                }

                object ret=UodbWS.ExecuteSQLScalar("select vc_friendly_name from t_privilege_set where si_privilege_set_id="+(short)id, null);
                if (ret==null)
                {
                    throw new RowDoesNotExistException("t_privilege_set", "si_privilege_set_id", id.ToString());
                }
                string name=(string)ret;
                SetCacheEntry("name", name);
                return name;
            }

            set
            {
                UodbWS.ExecuteSQLNonQuery("update t_privilege_set set vc_friendly_name='"+EscapeString(value)+"' where si_privilege_set_id="+(short)id, null);
                SetCacheEntry("name", value);
            }
        }

        #endregion

        //Short descriptive useful string that doesn't require db hits
        public override string ToString()
        {
            if (id==0)
            {
                return "Nonexistant Privilege Set (id=0)";
            }
            else
            {
                return string.Format("Privilege Set 0x{0:X}", id);
            }
        }

        //Long string containing every field of the privilege set.  This call can be expensive, as it may make db hits.
        public string FullDescription
        {
            get
            {
                if (!Exists)
                {
                    return string.Format("Nonexistant Privilege Set 0x{0:X}", id);
                }
                else
                {
                    string ret=ToString();
                    ret+="\nName="+Name;
                    ret+="\nPrivileges: "+StringUtils.MakeCommaSeparatedList(GetAllPrivileges());
                    return ret;
                }
            }
        }

        #region Add or remove "assets" for the privilege set

        /// <summary>
        /// Returns all granted privileges from the set.
        /// </summary>
        public byte[] GetAllPrivileges()
        {
            List<byte> privs=new List<byte>();

            using (WSClient ws=new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITETHENREAD_COMMANDTYPE))
            {
                ws.PartitionType=WstPartitionType.Logical;
                ws.Partition=WstCommand.AnyPartition;
                ws.CommandSql="select ti_privilege_id from t_privilege_set_privilege where si_privilege_set_id="+(short)id+" and ti_is_grant=1";

                using (WstDataReader myDataReader=ws.Execute())
                {
                    while (myDataReader.Read())
                    {
                        privs.Add((byte)myDataReader[0]);
                    }
                }
            }

            return privs.ToArray();
        }

        /// <summary>
        /// Removes all privileges from the set.
        /// </summary>
        public void RemoveAllPrivileges()
        {
            UodbWS.ExecuteSQLNonQuery("delete from t_privilege_set_privilege where si_privilege_set_id="+(short)id, null);
        }

        /// <summary>
        /// Add a privilege to a set, if it does not already contain it.
        /// </summary>
        public void AddPrivilege(byte privilegeId)
        {
            string query="if (0=(select count(ti_privilege_id) from t_privilege_set_privilege where si_privilege_set_id="+(short)id+" and ti_privilege_id="+(int)privilegeId+")) ";
            query+="begin insert into t_privilege_set_privilege (si_privilege_set_id, ti_privilege_id, ti_is_grant) values ("+(short)id+", "+(int)privilegeId+", 1) end";
            UodbWS.ExecuteSQLNonQuery(query, null);
        }

        #endregion
    };
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\Database\Editor\MachineRecoveryHistoryEditor.cs ===
using xonline.common.sql.webstore;
using xonline.common.config;

using Microsoft.Webstore.WstClient;

namespace ServerTestFramework.Database
{
    public class MachineRecoveryHistoryEditor
    {
        /// <summary> Machine Puid.  This is the only non-cached information we store about the machine's recovery history. </summary>
        public ulong MachinePuid
        {
            get { return machinePuid; }
        }
        private ulong machinePuid;

        //TODO: Once the UODB version is deprecated and completely removed, we can remove this.  This controls whether operations hit Uodb or SecMachineHistoryDB.
        public bool HitSecMHDB
        {
            get { return hitSecMHDB; }
        }
        private bool hitSecMHDB;

        // --

        #region Create an instance of MachineRecoveryHistoryEditor

        //constructor is not for public use
        private MachineRecoveryHistoryEditor() {}

        //TODO: Once the UODB version is deprecated and completely removed, we can remove hitSecMHDBInsteadOfUodb
        public static MachineRecoveryHistoryEditor FromMachinePuid(ulong mpuid, bool hitSecMHDBInsteadOfUodb)
        {
            MachineRecoveryHistoryEditor mghe=new MachineRecoveryHistoryEditor();
            mghe.machinePuid=mpuid;
            mghe.hitSecMHDB=hitSecMHDBInsteadOfUodb;
            return mghe;
        }

        #endregion

        #region Access the "assets" of the machine's Recovery history

        public class MachineRecoveryHistoryEntry: System.IEquatable<MachineRecoveryHistoryEntry>
        {
            public ulong UserPuid;
            public ulong MachinePuid;
            public string IpAddress;
            public System.DateTime TimeStamp;
            public uint Hr;
            public ulong PassportPuid;
            public byte Reason;
            public short HashBucket;

            public MachineRecoveryHistoryEntry()
            {
            }

            //TODO: Once the UODB version is deprecated and completely removed, we can remove isSecMHDBInsteadOfUodbHashing
            public MachineRecoveryHistoryEntry(ulong userPuid, ulong machinePuid, string ipAddress, System.DateTime timeStamp, uint hr, ulong passportPuid, byte reason, bool isSecMHDBInsteadOfUodbHashing)
            {
                UserPuid=userPuid;
                MachinePuid=machinePuid;
                IpAddress=ipAddress;
                TimeStamp=timeStamp;
                Hr=hr;
                PassportPuid=passportPuid;
                Reason=reason;

                if (isSecMHDBInsteadOfUodbHashing)
                {
                    HashBucket=(short)WebstoreDB.GetHashBucket(ConfigUtil.SecMachineHistoryWebstoreApp, machinePuid);
                }
                else
                {
                    HashBucket=(short)UodbWS.GetHashBucket(machinePuid);
                }
            }

            public override bool Equals(object other)
            {
                if(!(other is MachineRecoveryHistoryEntry))
                {
                    return false;
                }

                return Equals((MachineRecoveryHistoryEntry)other);
            }

            public bool Equals(MachineRecoveryHistoryEntry other)
            {
                return UserPuid==other.UserPuid &&
                    MachinePuid==other.MachinePuid &&
                    IpAddress==other.IpAddress &&
                    System.Math.Abs((TimeStamp-other.TimeStamp).TotalMilliseconds)<10 &&
                    Hr==other.Hr &&
                    PassportPuid==other.PassportPuid &&
                    Reason==other.Reason &&
                    HashBucket==other.HashBucket;
            }

            public override int GetHashCode()
            {
                return MachinePuid.GetHashCode()^UserPuid.GetHashCode()^TimeStamp.GetHashCode();
            }

            public override string ToString()
            {
                return "MachineRecoveryHistoryEntry(UserPuid="+string.Format("0x{0:X}", UserPuid)+" MachinePuid="+string.Format("0x{0:X}", MachinePuid)+" IpAddress="+IpAddress+" TimeStamp="+TimeStamp+" Hr="+string.Format("0x{0:X}", Hr)+" PassportPuid="+string.Format("0x{0:X}", PassportPuid)+" Reason="+Reason+" HashBucket="+HashBucket+")";
            }
        };

        /// <summary> Removes all Recovery history for this machine. </summary>
        public void RemoveAllHistory()
        {
            if (HitSecMHDB)
            {
                WebstoreDB.ExecuteSQLNonQuery(ConfigUtil.SecMachineHistoryWebstoreApp, "delete from t_machine_recovery_history where bi_machine_puid="+(long)MachinePuid, MachinePuid);
            }
            else
            {
                UodbWS.ExecuteSQLNonQuery("delete from t_machine_recovery_history where bi_machine_puid="+(long)MachinePuid, MachinePuid);
            }
        }

        /// <summary> Adds or updates a history entry for this machine. </summary>
        public void SetHistory(MachineRecoveryHistoryEntry ent)
        {
            if (ent.MachinePuid!=MachinePuid)
            {
                throw new System.Exception("Cannot set row for the wrong machine puid.");
            }

            string query=QueryGenerator.GenerateUpdateOrInsert("t_machine_recovery_history",
                                                  new string[]{"bi_user_puid", "bi_machine_puid", "vc_ip_address", "dt_timestamp", "i_hr", "bi_user_passport_puid", "ti_reason", "si_hash_bucket"},
                                                  new object[]{ent.UserPuid,   ent.MachinePuid,   ent.IpAddress,   ent.TimeStamp,  ent.Hr, ent.PassportPuid,        ent.Reason,  ent.HashBucket},
                                                  new string[]{"bi_machine_puid", "dt_timestamp"});

            if (HitSecMHDB)
            {
                WebstoreDB.ExecuteSQLNonQuery(ConfigUtil.SecMachineHistoryWebstoreApp, query, MachinePuid);
            }
            else
            {
                UodbWS.ExecuteSQLNonQuery(query, MachinePuid);
            }
        }

        /// <summary> Retrieves all history for this machine. </summary>
        public MachineRecoveryHistoryEntry[] GetAllHistory()
        {
            System.Collections.Generic.List<MachineRecoveryHistoryEntry> entries=new System.Collections.Generic.List<MachineRecoveryHistoryEntry>();

            string webstoreDb;
            if (HitSecMHDB)
            {
                webstoreDb=ConfigUtil.SecMachineHistoryWebstoreApp;
            }
            else
            {
                webstoreDb=ConfigUtil.UodbWebstoreApp;
            }

            using (WSClient ws=new WSClient(webstoreDb, CmdType.WRITETHENREAD_COMMANDTYPE))
            {
                ws.PartitionType=WstPartitionType.Logical;
                WebstoreDB.SetHashValue(ws, MachinePuid);
                ws.CommandSql="select bi_user_puid, vc_ip_address, dt_timestamp, i_hr, bi_user_passport_puid, ti_reason, si_hash_bucket from t_machine_recovery_history where bi_machine_puid="+(long)MachinePuid;

                using (WstDataReader reader=ws.Execute())
                {
                    while (reader.Read())
                    {
                        MachineRecoveryHistoryEntry entry=new MachineRecoveryHistoryEntry();
                        entry.UserPuid=(ulong)(long)reader[0];
                        entry.MachinePuid=MachinePuid;
                        entry.IpAddress=(reader[1]==System.DBNull.Value?null:(string)reader[1]);
                        entry.TimeStamp=(System.DateTime)reader[2];
                        entry.Hr=(uint)(int)reader[3];
                        entry.PassportPuid=(ulong)(long)reader[4];
                        entry.Reason=(byte)reader[5];
                        entry.HashBucket=(short)reader[6];

                        entries.Add(entry);
                    }
                }
            }

            return entries.ToArray();
        }

        #endregion
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\Database\Editor\ReleaseEditor.cs ===
﻿using System;
using System.Collections.Generic;

using xonline.common.sql.webstore;
using xonline.common.config;
using Microsoft.Webstore.WstClient;

using ServerTestFramework.Utilities;

namespace ServerTestFramework.Database
{
    public class ReleaseEditor : EditorCommon
    {
        private static Random r = new Random();


        public string SMRevision;
        public string SOMRevision;
        public int FlashVersion;
        public List<ReleaseEditor.ReleaseApp> Apps = new List<ReleaseApp>();

        private static string RandomString(int size)
        {
            return ServerTestFramework.Core.Utilities.RandomEx.GlobalRandGen.GenerateRandomUpperAlphaNumericString(size);
        }
        public static ReleaseEditor CreateNew()
        {
            return CreateNew(1);
        }

        public static ReleaseEditor CreateNew(int numApps)
        {
            ReleaseEditor re = new ReleaseEditor();

            re.FlashVersion = r.Next(10000, 14000);
            re.SMRevision = RandomString(20);
            re.SOMRevision = RandomString(20);

            for (int i = 0; i < numApps; i++)
            {
                ReleaseApp ra = ReleaseApp.Random(re);
                re.Apps.Add(ra);

                ra.Insert();
            }

            return re;
        }

        public override bool Exists
        {
            // Determines whether a release 'exists' or not.  A release 'exists' if there is at least one application associated with the manifest revision
            // is in the table.  For a release to be in USE, there needs to be a beta group assigned to it.
            get
            {
                if (SMRevision == null || SOMRevision == null || FlashVersion == 0) return false;

                uint rows = UodbWS.ExecuteSQLSelectCount(String.Format("select NULL from t_release_apps " +
                                                   "where ((vc_manifest_revision='{0}' and b_online=0 OR " +
                                                          "vc_manifest_revision='{1}' and b_online=1)",
                                                          SMRevision,
                                                          SOMRevision));
                return (rows != 0);
            }
        }

        public void Assign(Guid groupGuid)
        {
            int bucket = UodbWS.GetHashBucket(groupGuid);
            string query = QueryGenerator.GenerateUpdateOrInsert("t_beta_group_releases",
                                                  new string[] { "uid_group_id", "vc_som_revision", "vc_sm_revision", "i_flash_version", "si_hash_bucket" },
                                                  new string[] { groupGuid.ToString(), SOMRevision, SMRevision, FlashVersion.ToString(), bucket.ToString() },
                                                  new string[] { "uid_group_id" });
            UodbWS.ExecuteSQLNonQuery(query, groupGuid);
        }

        public class ReleaseApp
        {
            public string AppName { get; set; }
            public string FriendlyName { get; set; }
            public bool Online = false;
            public string Version;
            public string ManifestRevision;
            public DateTime ChangeDateTime;

            public static ReleaseApp Random(ReleaseEditor re)
            {
                ReleaseApp ra = new ReleaseApp();
                ra.AppName = RandomString(15);
                ra.FriendlyName = RandomString(15);
                ra.Online = (r.Next(1) == 0);
                ra.Version = String.Format("{0}.{1}.{2}.{3}",
                                            2,
                                            0,
                                            r.Next(5000),
                                            0);
                ra.ManifestRevision = ra.Online ? re.SOMRevision : re.SMRevision;
                ra.ChangeDateTime = DateTime.Now;
                return ra;
            }

            internal void Insert()
            {
                string query = String.Format("insert into t_release_apps values ('{0}','{1}',{2},'{3}','{4}','{5}')",
                                             AppName,
                                             FriendlyName, 
                                             Online ? 1 : 0,
                                             Version,
                                             ManifestRevision,
                                             ChangeDateTime);
                UodbWS.ExecuteSQLNonQuery(query, null);
            }
        }
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\Database\Editor\OfferEditor.cs ===
using xonline.common.sql.webstore;
using xonline.common.config;
using Microsoft.Webstore.WstClient;

using System.Collections.Generic;

using ServerTestFramework.Utilities;

namespace ServerTestFramework.Database
{
    /// <summary>
    /// Utility for altering or creating offers directly in the database.
    /// </summary>
    public class OfferEditor: EditorCommon
    {
        /// <summary>
        /// Offer ID.  This is the only non-cached information we store about the offer.
        /// </summary>
        public ulong Id
        {
            get { return id; }
        }

        private ulong id=0;

        // --
        #region Create an instance of OfferEditor

        /// <summary>
        /// Construct from an existing offer id (does not guarentee that the offer exists).
        /// </summary>
        public static OfferEditor FromId(ulong offerId)
        {
            OfferEditor offer=new OfferEditor();
            offer.id=offerId;
            return offer;
        }

        /// <summary>
        /// Constructs from an offer id, creating the offer in the db if it does not already exist.
        /// </summary>
        public static OfferEditor CreateOrUseExistingId(ulong offerId)
        {
            string offerHex=string.Format("0x{0:X8}",offerId);

            OfferEditor offer=new OfferEditor();
            offer.id=offerId;

            if (!UodbWS.DoesOfferExist(offerId))
            {
                UodbWS.ExecuteSQLNonQuery("insert into t_offers (bi_offer_id,ti_console_type_id,dt_start_date,dt_end_date,i_offer_type_id,i_offer_frequency_id,b_cancelable,i_ESRB_id,"+
                    "i_bitfilter,i_install_size,i_package_size,vb_sym_key,i_policy_flags,vc_billing_svc_component_id,vc_friendly_name,si_global_offer_details,vb_public_key,dt_Change_datetime) "+
                    "values ("+(long)offerId+", 2, '1982-06-26', '4999-01-01', 512, 0, 0, 4,"+
                    "1, 0, 0, 0x0, 4, '', 'STF Test "+offerHex+"', 0, 0x0, getutcdate())", null);
            }

            return offer;
        }

        /// <summary>
        /// Creates a new offer id with a random id.
        /// </summary>
        public static OfferEditor CreateNew()
        {
            ulong offerId;
            do
            {
                offerId=ServerTestFramework.Core.Utilities.RandomEx.GlobalRandGen.NextUlong();
            } while (UodbWS.DoesOfferExist(offerId));

            return CreateOrUseExistingId(offerId);
        }

        //constructor is not for public consumption.
        private OfferEditor()
        {
        }

        #endregion

        // --
        #region Lookup or alter properties of the offer

        /// <summary>
        /// Whether the offer actually exists in the db.
        /// </summary>
        public override bool Exists
        {
            get
            {
                if (HasCachedEntry("exists"))
                {
                    return (bool)cache["exists"];
                }

                bool exists=id!=0 && UodbWS.DoesOfferExist(id);
                SetCacheEntry("exists", exists);
                return exists;
            }
        }

        /// <summary>
        /// Console Type for the offer.
        /// </summary>
        public byte ConsoleType
        {
            get
            {
                return GetGenericOfferProperty<byte>("ti_console_type_id", "consoletype");
            }

            set
            {
                SetGenericOfferProperty("ti_console_type_id", "consoletype", value);
            }
        }

        /// <summary>
        /// Start Date.
        /// </summary>
        public System.DateTime StartDate
        {
            get
            {
                return GetGenericOfferProperty<System.DateTime>("dt_start_date", "startdate");
            }

            set
            {
                SetGenericOfferProperty("dt_start_date", "startdate", value);
            }
        }

        /// <summary>
        /// End Date.
        /// </summary>
        public System.DateTime EndDate
        {
            get
            {
                return GetGenericOfferProperty<System.DateTime>("dt_end_date", "enddate");
            }

            set
            {
                SetGenericOfferProperty("dt_end_date", "enddate", value);
            }
        }

        /// <summary>
        /// Type of offer.
        /// </summary>
        public int OfferType
        {
            get
            {
                return GetGenericOfferProperty<int>("i_offer_type_id", "offertype");
            }

            set
            {
                SetGenericOfferProperty("i_offer_type_id", "offertype", value);
            }
        }

        /// <summary>
        /// Frequency id of the offer.
        /// </summary>
        public int FrequencyId
        {
            get
            {
                return GetGenericOfferProperty<int>("i_offer_frequency_id", "freqid");
            }

            set
            {
                SetGenericOfferProperty("i_offer_frequency_id", "freqid", value);
            }
        }

        /// <summary>
        /// Whether the offer can be canceled.
        /// </summary>
        public byte Cancelable
        {
            get
            {
                return GetGenericOfferProperty<byte>("b_cancelable", "cancelable");
            }

            set
            {
                SetGenericOfferProperty("b_cancelable", "cancelable", value);
            }
        }

        /// <summary>
        /// ESRB rating for the offer.
        /// </summary>
        public int ESRBRating
        {
            get
            {
                return GetGenericOfferProperty<int>("i_ESRB_id", "esrb");
            }

            set
            {
                SetGenericOfferProperty("i_ESRB_id", "esrb", value);
            }
        }

        /// <summary>
        /// ???
        /// </summary>
        public int BitFilter
        {
            get
            {
                return GetGenericOfferProperty<int>("i_bitfilter", "bitfilter");
            }

            set
            {
                SetGenericOfferProperty("i_bitfilter", "bitfilter", value);
            }
        }

        /// <summary>
        /// Policies for the offer.
        /// </summary>
        public int PolicyFlags
        {
            get
            {
                return GetGenericOfferProperty<int>("i_policy_flags", "policyflags");
            }

            set
            {
                SetGenericOfferProperty("i_policy_flags", "policyflags", value);
            }
        }

        /// <summary>
        /// Friendly name of the offer.
        /// </summary>
        public string Name
        {
            get
            {
                return GetGenericOfferProperty<string>("vc_friendly_name", "friendlyname");
            }

            set
            {
                SetGenericOfferProperty("vc_friendly_name", "friendlyname", value);
            }
        }

        /// <summary>
        /// Offer details...?
        /// </summary>
        public ushort GlobalOfferDetails
        {
            get
            {
                return GetGenericOfferProperty<ushort>("si_global_offer_details", "globalofferdetails");
            }

            set
            {
                SetGenericOfferProperty("si_global_offer_details", "globalofferdetails", value);
            }
        }

        /// <summary>
        /// Generic implementation of returning a property from an offer (or cache if able).
        /// </summary>
        private TypeOfProperty GetGenericOfferProperty<TypeOfProperty>(string columnName, string cacheName)
        {
            if (HasCachedEntry(cacheName))
            {
                return (TypeOfProperty)cache[cacheName];
            }

            object ret=UodbWS.ExecuteSQLScalar("select "+columnName+" from t_offers where bi_offer_id="+(long)id, null);
            if (ret!=null)
            {
                TypeOfProperty val=(TypeOfProperty)System.Convert.ChangeType(ret, typeof(TypeOfProperty));
                SetCacheEntry(cacheName, val);
                return val;
            }

            throw new RowDoesNotExistException("t_offers", columnName, id.ToString());
        }

        /// <summary>
        /// Generic implementation of setting a property in an offer.  The value must be convertible to a string in a way that SQL understands.
        /// </summary>
        private void SetGenericOfferProperty<TypeOfProperty>(string columnName, string cacheName, TypeOfProperty value)
        {
            UodbWS.ExecuteSQLNonQuery("update t_offers set "+columnName+"='"+EscapeString(value.ToString())+"' where bi_offer_id="+(long)id, null);
            SetCacheEntry(cacheName, value);
        }

        #endregion

        //Short descriptive useful string that doesn't require db hits
        public override string ToString()
        {
            if (id==0)
            {
                return "Nonexistant Offer (id=0)";
            }
            else
            {
                return string.Format("Offer 0x{0:X}", id);
            }
        }

        //Long string containing every field of the offer.  This call is expensive, as it makes many db hits.
        public string FullDescription
        {
            get
            {
                if (!Exists)
                {
                    return string.Format("Nonexistant Offer 0x{0:X}", id);
                }
                else
                {
                    string ret=ToString();
                    ret+="\nName="+Name;
                    ret+="\nConsoleType="+ConsoleType;
                    ret+="\nStartDate="+StartDate;
                    ret+="\nEndDate="+EndDate;
                    ret+="\nOfferType="+OfferType;
                    ret+="\nFrequencyId="+FrequencyId;
                    ret+="\nCancelable="+Cancelable;
                    ret+="\nESRBRating="+ESRBRating;
                    ret+="\nBitFilter="+BitFilter;
                    ret+="\nPolicyFlags="+PolicyFlags;
                    ret+="\nServices: "+StringUtils.MakeCommaSeparatedList(GetAllServices());
                    ret+="\nGranted Privileges: "+StringUtils.MakeCommaSeparatedList(GetAllPrivileges());
                    ret+="\nRestricted Privileges: "+StringUtils.MakeCommaSeparatedList(GetAllPrivilegeRestrictions());
                    return ret;
                }
            }
        }

        // --
        #region Add or remove "assets" for the offer
        //note that services and such are only granted if the offer has a subscrption created for it

        /// <summary>
        /// Completely removes an offer and all references to it from UODB.
        /// </summary>
        public void CompletelyRemoveOffer()
        {
            RemoveSubscriptions();
            const int timeoutInS=120; //2 minutes since some of these make take an abnormal amount of time to execute
            UodbWS.ExecuteSQLNonQuery("delete from t_subscriptions where bi_offer_id="+(long)id, null, timeoutInS);
            UodbWS.ExecuteSQLNonQuery("delete from t_user_licenses where bi_offer_id="+(long)id, null, timeoutInS);
            UodbWS.ExecuteSQLNonQuery("delete from t_offer_consumables where bi_offer_id="+(long)id, null, timeoutInS);
            UodbWS.ExecuteSQLNonQuery("delete from t_offer_content_details where bi_offer_id="+(long)id, null, timeoutInS);
            UodbWS.ExecuteSQLNonQuery("delete from t_offer_culture_details where bi_offer_id="+(long)id, null, timeoutInS);
            UodbWS.ExecuteSQLNonQuery("delete from t_offer_description_details where bi_offer_id="+(long)id, null, timeoutInS);
            UodbWS.ExecuteSQLNonQuery("delete from t_offer_descriptions where bi_offer_id="+(long)id, null, timeoutInS);
            UodbWS.ExecuteSQLNonQuery("delete from t_offer_durations where bi_offer_id="+(long)id, null, timeoutInS);
            UodbWS.ExecuteSQLNonQuery("delete from t_offer_locations where bi_offer_id="+(long)id, null, timeoutInS);
            UodbWS.ExecuteSQLNonQuery("delete from t_offer_privilege_restrictions where bi_offer_id="+(long)id, null, timeoutInS);
            UodbWS.ExecuteSQLNonQuery("delete from t_offer_privileges where bi_offer_id="+(long)id, null, timeoutInS);
            UodbWS.ExecuteSQLNonQuery("delete from t_offer_regions where bi_offer_id="+(long)id, null, timeoutInS);
            UodbWS.ExecuteSQLNonQuery("delete from t_offer_relations where bi_offer_id="+(long)id, null, timeoutInS);
            UodbWS.ExecuteSQLNonQuery("delete from t_offer_reward_details where bi_offer_id="+(long)id, null, timeoutInS);
            UodbWS.ExecuteSQLNonQuery("delete from t_offer_scs_item_details where bi_offer_id="+(long)id, null, timeoutInS);
            UodbWS.ExecuteSQLNonQuery("delete from t_offer_services where bi_offer_id="+(long)id, null, timeoutInS);
            UodbWS.ExecuteSQLNonQuery("delete from t_offer_subscription_rewards where bi_offer_id="+(long)id, null, timeoutInS);
            UodbWS.ExecuteSQLNonQuery("delete from t_offers where bi_offer_id="+(long)id, null, timeoutInS);
        }

        /// <summary>
        /// Removes all subscription entries for the offer.
        /// </summary>
        public void RemoveSubscriptions()
        {
            UodbWS.ExecuteSQLNonQuery("delete from t_subscription_info where bi_offer_id="+(long)id, null);
        }

        /// <summary>
        /// Creates an entry for the offer as a subscription.
        /// </summary>
        public void AddSubscription(ushort subscriptionType, uint tierID, byte isBase)
        {
            string query="if (0=(select count(bi_offer_id) from t_subscription_info where bi_offer_id="+(long)id+" and si_subscription_type="+(short)subscriptionType+" and i_tier_id="+(int)tierID+")) ";
            query+="begin insert into t_subscription_info (bi_offer_id, si_subscription_type, i_tier_id, ti_is_base) values ("+(long)id+", "+(short)subscriptionType+", "+(int)tierID+", "+(int)isBase+") end";
            UodbWS.ExecuteSQLNonQuery(query, null);
        }

        /// <summary>
        /// Creates a nice default entry for the offer as an xbox live subscription not related to tier.
        /// </summary>
        public void AddSubscription()
        {
            AddSubscription(1, 0, 0);
        }

        /// <summary>
        /// Returns a list of all services that the offer grants.
        /// </summary>
        public uint[] GetAllServices()
        {
            List<uint> servs=new List<uint>();

            using (WSClient ws=new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITETHENREAD_COMMANDTYPE))
            {
                ws.PartitionType=WstPartitionType.Logical;
                ws.Partition=WstCommand.AnyPartition;
                ws.CommandSql="select i_service_id from t_offer_services where bi_offer_id="+(long)id;

                using (WstDataReader myDataReader=ws.Execute())
                {
                    while (myDataReader.Read())
                    {
                        servs.Add((uint)(int)myDataReader[0]);
                    }
                }
            }

            return servs.ToArray();
        }

        /// <summary>
        /// Removes all services from an offer.
        /// </summary>
        public void RemoveAllServices()
        {
            UodbWS.ExecuteSQLNonQuery("delete from t_offer_services where bi_offer_id="+(long)id, null);
        }

        /// <summary>
        /// Adds a service to the offer, if it does not already exist.
        /// </summary>
        public void AddService(uint serviceId)
        {
            string query="if (0=(select count(i_service_id) from t_offer_services where bi_offer_id="+(long)id+" and i_service_id="+(int)serviceId+")) ";
            query+="begin insert into t_offer_services (bi_offer_id, i_service_id) values ("+(long)id+", "+(int)serviceId+") end";
            UodbWS.ExecuteSQLNonQuery(query, null);
        }

        /// <summary>
        /// Returns a list of all privileges that the offer grants.
        /// </summary>
        public byte[] GetAllPrivileges()
        {
            List<byte> privs=new List<byte>();

            using (WSClient ws=new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITETHENREAD_COMMANDTYPE))
            {
                ws.PartitionType=WstPartitionType.Logical;
                ws.Partition=WstCommand.AnyPartition;
                ws.CommandSql="select ti_privilege_id from t_offer_privileges where bi_offer_id="+(long)id;

                using (WstDataReader myDataReader=ws.Execute())
                {
                    while (myDataReader.Read())
                    {
                        privs.Add((byte)myDataReader[0]);
                    }
                }
            }

            return privs.ToArray();
        }

        /// <summary>
        /// Removes all granted privileges from an offer.
        /// </summary>
        public void RemoveAllPrivileges()
        {
            UodbWS.ExecuteSQLNonQuery("delete from t_offer_privileges where bi_offer_id="+(long)id, null);
        }

        /// <summary>
        /// Adds a granted privilege to the offer, if it does not already exist.
        /// </summary>
        public void AddPrivilege(byte privilegeId)
        {
            string query="if (0=(select count(ti_privilege_id) from t_offer_privileges where bi_offer_id="+(long)id+" and ti_privilege_id="+(int)privilegeId+")) ";
            query+="begin insert into t_offer_privileges (bi_offer_id, ti_privilege_id) values ("+(long)id+", "+(int)privilegeId+") end";
            UodbWS.ExecuteSQLNonQuery(query, null);
        }

        /// <summary>
        /// Returns a list of all privileges that the offer restricts.
        /// </summary>
        public byte[] GetAllPrivilegeRestrictions()
        {
            List<byte> privs=new List<byte>();

            using (WSClient ws=new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITETHENREAD_COMMANDTYPE))
            {
                ws.PartitionType=WstPartitionType.Logical;
                ws.Partition=WstCommand.AnyPartition;
                ws.CommandSql="select ti_privilege_id from t_offer_privilege_restrictions where bi_offer_id="+(long)id;

                using (WstDataReader myDataReader=ws.Execute())
                {
                    while (myDataReader.Read())
                    {
                        privs.Add((byte)myDataReader[0]);
                    }
                }
            }

            return privs.ToArray();
        }

        /// <summary>
        /// Removes all restricted privileges from an offer.
        /// </summary>
        public void RemoveAllPrivilegeRestrictions()
        {
            UodbWS.ExecuteSQLNonQuery("delete from t_offer_privilege_restrictions where bi_offer_id="+(long)id, null);
        }

        /// <summary>
        /// Adds a restricted privilege to the offer, if it does not already exist.
        /// </summary>
        public void AddPrivilegeRestriction(byte privilegeId)
        {
            string query="if (0=(select count(ti_privilege_id) from t_offer_privilege_restrictions where bi_offer_id="+(long)id+" and ti_privilege_id="+(int)privilegeId+")) ";
            query+="begin insert into t_offer_privilege_restrictions (bi_offer_id, ti_privilege_id) values ("+(long)id+", "+(int)privilegeId+") end";
            UodbWS.ExecuteSQLNonQuery(query, null);
        }

        #endregion
    };
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\Database\Editor\ServicePrivilegeEditor.cs ===
using xonline.common.sql.webstore;
using xonline.common.config;
using Microsoft.Webstore.WstClient;

using System.Collections.Generic;

using ServerTestFramework.Utilities;

namespace ServerTestFramework.Database
{
    /// <summary> Utility for altering or creating a service-privilege set. </summary>
    public class ServicePrivilegeSetEditor: EditorCommon
    {
        /// <summary> Service-Privilege set ID.  This is the only non-cached information we store about the privilege set. </summary>
        public ushort Id
        {
            get { return id; }
        }

        private ushort id=0;

        #region Create an instance of ServicePrivilegeSetEditor

        /// <summary> Construct from an existing service-privilege set id (does not guarentee that the service-privilege set exists). </summary>
        public static ServicePrivilegeSetEditor FromId(ushort servicePrivilegeSetId)
        {
            ServicePrivilegeSetEditor servprivset=new ServicePrivilegeSetEditor();
            servprivset.id=servicePrivilegeSetId;
            return servprivset;
        }

        /// <summary> Constructs from a service-privilege set id, creating the set in the db if it does not already exist.  The created set does not reference any service or privilege sets. </summary>
        public static ServicePrivilegeSetEditor CreateOrUseExistingId(ushort servicePrivilegeSetId)
        {
            ServicePrivilegeSetEditor servprivset=new ServicePrivilegeSetEditor();
            servprivset.id=servicePrivilegeSetId;

            //insert the t_privileges entry if needed
            if (!UodbWS.DoesServicePrivilegeSetExist(servicePrivilegeSetId))
            {
                UodbWS.ExecuteSQLNonQuery("insert into t_service_privilege_set (si_service_privilege_set_id, vc_friendly_name, si_service_set_id, si_privilege_set_id) values ("+(short)servicePrivilegeSetId+", 'Test ServicePrivilege Set "+servicePrivilegeSetId+"', null, null)", null);
            }

            return servprivset;
        }

        //constructor is not for public consumption.
        private ServicePrivilegeSetEditor()
        {
        }

        #endregion

        // --
        #region Lookup or alter properties of the service-privilege set

        /// <summary> Whether the service-privilege set actually exists in the db. </summary>
        public override bool Exists
        {
            get
            {
                if (HasCachedEntry("exists"))
                {
                    return (bool)cache["exists"];
                }

                bool exists=id!=0 && UodbWS.DoesServicePrivilegeSetExist(id);
                SetCacheEntry("exists", exists);
                return exists;
            }
        }

        /// <summary> Name of the service-privilege set. </summary>
        public string Name
        {
            get
            {
                return GetGenericProperty<string>("vc_friendly_name");
            }

            set
            {
                SetGenericProperty("vc_friendly_name", value);
            }
        }

        /// <summary> Service set represented by this group. </summary>
        public System.Nullable<short> ServiceSet
        {
            get
            {
                return GetGenericProperty<short>("si_service_set_id");
            }

            set
            {
                SetGenericProperty("si_service_set_id", value);
            }
        }

        /// <summary> Privilege set represented by this group. </summary>
        public System.Nullable<short> PrivilegeSet
        {
            get
            {
                return GetGenericProperty<System.Nullable<short>>("si_privilege_set_id");
            }

            set
            {
                SetGenericProperty("si_privilege_set_id", value);
            }
        }

        /// <summary> Generic implementation of returning a property from a table based on id (or cache if able). </summary>
        private TypeOfProperty GetGenericProperty<TypeOfProperty>(string columnName)
        {
            if (HasCachedEntry(columnName))
            {
                return (TypeOfProperty)cache[columnName];
            }

            object ret=UodbWS.ExecuteSQLScalar("select "+columnName+" from t_service_privilege_set where si_service_privilege_set_id="+QueryGenerator.EvaluateObject(id), null);
            if (ret!=null)
            {
                if (ret==System.DBNull.Value)
                {
                    return default(TypeOfProperty);
                }

                TypeOfProperty val=(TypeOfProperty)System.Convert.ChangeType(ret, typeof(TypeOfProperty));
                SetCacheEntry(columnName, val);
                return val;
            }

            throw new RowDoesNotExistException("t_service_privilege_set", columnName, id.ToString());
        }

        /// <summary> Generic implementation of setting a property in a table based on id.  The value must be convertible to a string in a way that SQL understands. </summary>
        private void SetGenericProperty<TypeOfProperty>(string columnName, TypeOfProperty value)
        {
            UodbWS.ExecuteSQLNonQuery("update t_service_privilege_set set "+columnName+"="+QueryGenerator.EvaluateObject(value)+" where si_service_privilege_set_id="+QueryGenerator.EvaluateObject(id), null);
            SetCacheEntry(columnName, value);
        }

        #endregion

        //Short descriptive useful string that doesn't require db hits
        public override string ToString()
        {
            return string.Format("ServicePrivilege Set 0x{0:X}", id);
        }

        //Long string containing every field of the privilege set.  This call can be expensive, as it may make db hits.
        public string FullDescription
        {
            get
            {
                if (!Exists)
                {
                    return string.Format("Nonexistant Privilege Set 0x{0:X}", id);
                }
                else
                {
                    string ret=ToString();
                    ret+="\nName: "+Name;
                    ret+="\nServiceSet: "+ServiceSet;
                    ret+="\nPrivilegeSet: "+PrivilegeSet;
                    return ret;
                }
            }
        }
    };
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\Database\Editor\ServerEditor.cs ===
using System;
using System.Collections.Generic;

using xonline.common.config;
using xonline.common.sql.webstore;

namespace ServerTestFramework.Database
{
    /// <summary>
    /// Utility for altering or creating servers directly in the database.
    /// </summary>
    public class ServerEditor : EditorCommon
    {
        /// <summary>The server's name.</summary>
        /// <remarks>This is the only non-cached information we store.</remarks>
        public string Name
        {
            get;
            private set;
        }

        #region Create or remove an instance of ServerEditor

        /// <summary>Construct from an existing server name (does not guarantee that the server exists).</summary>
        public static ServerEditor FromName (string name)
        {
            return new ServerEditor() { Name = name };
        }

        // constructor is not for public consumption.
        private ServerEditor ()
        {
        }

        #endregion

        #region Lookup or alter properties of the server

        /// <summary>Whether the server actually exists in the database.</summary>
        public override bool Exists
        {
            get
            {
                if (HasCachedEntry("exists"))
                {
                    return (bool)cache["exists"];
                }

                bool exists = !string.IsNullOrEmpty(Name) &&
                    ((int)StaticNpdb.ExecuteScalar("Select count(0) from t_servers where vc_environment = '" + 
                    EscapeString(Config.Environment) + "' and vc_server = '" + EscapedName + "'") != 0);
                SetCacheEntry("exists", exists);
                return exists;
            }
        }

        /// <summary>Site of the server.</summary>
        public int Site
        {
            get
            {
                return GetGenericProperty<int>("i_site_id");
            }

            set
            {
                SetGenericProperty("i_site_id", value);
            }
        }

        /// <summary>State of the server.</summary>
        public string State
        {
            get
            {
                return GetGenericProperty<string>("vc_server_state");
            }

            set
            {
                SetGenericProperty("vc_server_state", value);
            }
        }

        /// <summary>True if the server is online.</summary>
        public bool IsOnline
        {
            get { return State == "online"; }
        }

        /// <summary>Generic implementation of returning a property from a server (or cache if able).</summary>
        private TypeOfProperty GetGenericProperty<TypeOfProperty> (string columnName)
        {
            return GetGenericProperty<TypeOfProperty>(columnName, columnName);
        }

        /// <summary>Generic implementation of returning a property from a server (or cache if able).</summary>
        private TypeOfProperty GetGenericProperty<TypeOfProperty> (string columnName, string cacheName)
        {
            if (HasCachedEntry(cacheName))
            {
                return (TypeOfProperty)cache[cacheName];
            }

            object ret = StaticNpdb.ExecuteScalar("Select " + columnName + " from t_servers where vc_environment = '" +
                    EscapeString(Config.Environment) + "' and vc_server = '" + EscapedName + "'");
            if (ret != null)
            {
                TypeOfProperty val = (TypeOfProperty)System.Convert.ChangeType(ret, typeof(TypeOfProperty));
                SetCacheEntry(cacheName, val);
                return val;
            }

            throw new RowDoesNotExistException("t_servers", columnName, Name);
        }

        /// <summary>Generic implementation of setting a property of a server.  The value must be convertible to a string in a way that SQL understands.</summary>
        private void SetGenericProperty<TypeOfProperty> (string columnName, TypeOfProperty value)
        {
            SetGenericProperty<TypeOfProperty>(columnName, columnName, value);
        }

        /// <summary>Generic implementation of setting a property of a server.  The value must be convertible to a string in a way that SQL understands.</summary>
        private void SetGenericProperty<TypeOfProperty> (string columnName, string cacheName, TypeOfProperty value)
        {
            StaticNpdb.ExecuteNonQuery("Update t_components set " + columnName + " = '" + EscapeString(value.ToString()) +
                "' where vc_environment = '" + EscapeString(Config.Environment) + "' and vc_server = '" + EscapedName + "'");
            SetCacheEntry(cacheName, value);
        }

        #endregion

        #region Add or remove "assets" for the server

        /// <summary>
        /// Gets the IP address of a given nic role for the server.
        /// </summary>
        public System.Net.IPAddress GetServiceNicIp (string nicRole)
        {
            string sproc = @"
Exec p_config_get_server_nic
    @vc_environment = {0},
    @vc_server = {1},
    @vc_nic_role = {2}
";
            sproc = string.Format(sproc,
                FormatString(Config.Environment),
                FormatString(Name),
                FormatString(nicRole)
                );

            List<string[]> results = StaticNpdb.ExecuteQueryGetMultiple(sproc);
            if (results.Count == 0)
            {
                return null;
            }

            return System.Net.IPAddress.Parse(results[0][0]);
        }

        #endregion

        // Short descriptive useful string that doesn't require db hits
        public override string ToString ()
        {
            return "Server: " + (Name ?? "<null>");
        }

        // string containing every field.  This call is expensive, as it makes many db hits.
        public string FullDescription
        {
            get
            {
                throw new NotImplementedException();
            }
        }

        #region Helpers

        /// <summary>The Name, escaped.</summary>
        private string EscapedName
        {
            get
            {
                return EscapeString(Name);
            }
        }

        /// <summary>Formats a nullable type for a SQL statement.</summary>
        private static string FormatNullable<T> (Nullable<T> n) where T : struct
        {
            return (n.HasValue ? n.Value.ToString() : "null");
        }

        /// <summary>Formats a string for a SQL statement.</summary>
        private static string FormatString (string s)
        {
            return (s == null ? "null" : "'" + EscapeString(s) + "'");
        }

        #endregion
    };
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\Database\Editor\ServiceEditor.cs ===
using xonline.common.sql.webstore;
using xonline.common.config;
using Microsoft.Webstore.WstClient;

using System.Collections.Generic;

using ServerTestFramework.Utilities;

namespace ServerTestFramework.Database
{
    /// <summary>
    /// Utility for altering or creating an individual service.
    /// </summary>
    public class ServiceEditor: EditorCommon
    {
        /// <summary>
        /// Service ID.  This is the only non-cached information we store about the service.
        /// </summary>
        public uint Id
        {
            get { return id; }
        }

        private uint id=0;

        #region Create an instance of ServiceEditor

        /// <summary>
        /// Construct from an existing service id (does not guarentee that the service exists).
        /// </summary>
        public static ServiceEditor FromId(uint serviceId)
        {
            ServiceEditor priv=new ServiceEditor();
            priv.id=serviceId;
            return priv;
        }

        /// <summary>
        /// Constructs from a service id, creating the service in the db if it does not already exist.
        /// </summary>
        public static ServiceEditor CreateOrUseExistingId(uint serviceId)
        {
            ServiceEditor priv=new ServiceEditor();
            priv.id=serviceId;

            //insert the t_services entry if needed
            if (!UodbWS.DoesServiceExist(serviceId))
            {
                UodbWS.ExecuteSQLNonQuery("exec p_svc_service_create "+(int)serviceId+", 'test', 'Test"+(int)serviceId+"', 'STF Test Service "+(int)serviceId+"', 0", null);
            }

            return priv;
        }

        //constructor is not for public consumption.
        private ServiceEditor()
        {
        }

        #endregion

        // --
        #region Lookup or alter properties of the service

        /// <summary>
        /// Whether the service actually exists in the db.
        /// </summary>
        public override bool Exists
        {
            get
            {
                if (HasCachedEntry("exists"))
                {
                    return (bool)cache["exists"];
                }

                bool exists=id!=0 && UodbWS.DoesServiceExist(id);
                SetCacheEntry("exists", exists);
                return exists;
            }
        }

        /// <summary>
        /// Description of the service.
        /// </summary>
        public string Name
        {
            get
            {
                return GetGenericServiceProperty<string>("vc_description", "description");
            }

            set
            {
                SetGenericServiceProperty("vc_description", "description", value);
            }
        }

        /// <summary>
        /// Kerberos service name.
        /// </summary>
        public string KerberosServiceName
        {
            get
            {
                return GetGenericServiceProperty<string>("vc_kerb_service_name", "kerbname");
            }

            set
            {
                SetGenericServiceProperty("vc_kerb_service_name", "kerbname", value);
            }
        }

        /// <summary>
        /// Kerberos domain name.
        /// </summary>
        public string KerberosDomainName
        {
            get
            {
                return GetGenericServiceProperty<string>("vc_kerb_domain_name", "kerbdomain");
            }

            set
            {
                SetGenericServiceProperty("vc_kerb_domain_name", "kerbdomain", value);
            }
        }

        /// <summary>
        /// Whether the service is granted on a machine-only login.
        /// </summary>
        public int MachineOnly
        {
            get
            {
                return GetGenericServiceProperty<int>("i_machine_only", "machineonly");
            }

            set
            {
                SetGenericServiceProperty("i_machine_only", "machineonly", value);
            }
        }

        /// <summary>
        /// Generic implementation of returning a property from a service (or cache if able).
        /// </summary>
        private TypeOfProperty GetGenericServiceProperty<TypeOfProperty>(string columnName, string cacheName)
        {
            if (HasCachedEntry(cacheName))
            {
                return (TypeOfProperty)cache[cacheName];
            }

            object ret=UodbWS.ExecuteSQLScalar("select "+columnName+" from t_services where i_service_id="+(int)id, null);
            if (ret!=null)
            {
                TypeOfProperty val=(TypeOfProperty)System.Convert.ChangeType(ret, typeof(TypeOfProperty));
                SetCacheEntry(cacheName, val);
                return val;
            }

            throw new RowDoesNotExistException("t_services", columnName, id.ToString());
        }

        /// <summary>
        /// Generic implementation of setting a property in a service.  The value must be convertible to a string in a way that SQL understands.
        /// </summary>
        private void SetGenericServiceProperty<TypeOfProperty>(string columnName, string cacheName, TypeOfProperty value)
        {
            UodbWS.ExecuteSQLNonQuery("update t_services set "+columnName+"='"+EscapeString(value.ToString())+"' where i_service_id="+(int)id, null);
            SetCacheEntry(cacheName, value);
        }

        #endregion

        //Short descriptive useful string that doesn't require db hits
        public override string ToString()
        {
            if (id==0)
            {
                return "Nonexistant Service (id=0)";
            }
            else
            {
                return string.Format("Service 0x{0:X}", id);
            }
        }

        //Long string containing every field of the service.  This call can be expensive, as it may make db hits.
        public string FullDescription
        {
            get
            {
                if (!Exists)
                {
                    return string.Format("Nonexistant Service 0x{0:X}", id);
                }
                else
                {
                    string ret=ToString();
                    ret+="\nName(Description)="+Name;
                    ret+="\nKerberosServiceName="+KerberosServiceName;
                    ret+="\nKerberosDomainName="+KerberosDomainName;
                    ret+="\nMachineOnly="+MachineOnly;
                    ret+="\nInstances: "+StringUtils.MakeCommaSeparatedList(GetAllInstances());
                    return ret;
                }
            }
        }

        #region Add or remove "assets" for the service

        /// <summary>
        /// Completely removes the service and all references to it from UODB.
        /// </summary>
        public void CompletelyRemoveService()
        {
            const int timeoutInS=120; //2 minutes since some of these make take an abnormal amount of time to execute
            UodbWS.ExecuteSQLNonQuery("delete from t_service_set_service where i_service_id="+(int)id, null, timeoutInS);
            UodbWS.ExecuteSQLNonQuery("delete from t_offer_services where i_service_id="+(int)id, null, timeoutInS);
            UodbWS.ExecuteSQLNonQuery("delete from t_title_services where i_service_id="+(int)id, null, timeoutInS);
            UodbWS.ExecuteSQLNonQuery("delete from t_service_instances where i_service_id="+(int)id, null, timeoutInS);
            UodbWS.ExecuteSQLNonQuery("delete from t_services where i_service_id="+(int)id, null, timeoutInS);
        }

        /// <summary>
        /// Represents an instance of a service
        /// </summary>
        public class ServiceInstance
        {
            public uint ServiceId;
            public uint TitleId;
            public uint TitleVersion;
            public uint TitleRegion;
            public uint SiteId;
            public uint Port;
            public uint Available;

            public override string ToString()
            {
                return "ServiceId="+ServiceId+" TitleId="+TitleId+" TitleVersion="+TitleVersion+" TitleRegion="+TitleRegion+" SiteId="+SiteId+" Port="+Port+" Available="+Available;
            }
        };

        /// <summary>
        /// Retrieves all instance of the service.
        /// </summary>
        public ServiceInstance[] GetAllInstances()
        {
            List<ServiceInstance> instances=new List<ServiceInstance>();

            using (WSClient ws=new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITETHENREAD_COMMANDTYPE))
            {
                ws.PartitionType=WstPartitionType.Logical;
                ws.Partition=WstCommand.AnyPartition;
                ws.CommandSql="select i_title_id, i_title_version, i_title_region, i_site_id, i_port, i_service_available from t_service_instances where i_service_id="+(int)id;

                using (WstDataReader myDataReader=ws.Execute())
                {
                    while (myDataReader.Read())
                    {
                        ServiceInstance si=new ServiceInstance();
                        si.ServiceId=id;
                        si.TitleId=(uint)(int)myDataReader[0];
                        si.TitleVersion=(uint)(int)myDataReader[1];
                        si.TitleRegion=(uint)(int)myDataReader[2];
                        si.SiteId=(uint)(int)myDataReader[3];
                        si.Port=(uint)(int)myDataReader[4];
                        si.Available=(uint)(int)myDataReader[5];

                        instances.Add(si);
                    }
                }
            }

            return instances.ToArray();
        }

        /// <summary>
        /// Deletes all instances of the service
        /// </summary>
        public void RemoveAllInstances()
        {
            UodbWS.ExecuteSQLNonQuery("delete from t_service_instances where i_service_id="+(int)id, null);
        }

        /// <summary>
        /// Adds or updates an existance instance of a service.  Any of the title fields may be 0 to indicate "all".
        /// </summary>
        public void AddInstance(uint titleId, uint titleVersion, uint titleRegion, uint siteId, uint port, uint available)
        {
            UodbWS.ExecuteSQLNonQuery("exec p_svc_service_create_instance "+(int)id+", "+(int)siteId+", "+(int)titleId+", "+(int)titleVersion+", "+(int)titleRegion+", "+(int)port+", "+(int)available, null);
        }

        #endregion
    };

    // --

    /// <summary>
    /// Utility for altering or creating a service set.
    /// </summary>
    public class ServiceSetEditor: EditorCommon
    {
        /// <summary>
        /// Service set ID.  This is the only non-cached information we store about the service set.
        /// </summary>
        public ushort Id
        {
            get { return id; }
        }

        private ushort id=0;

        #region Create an instance of ServiceSetEditor

        /// <summary>
        /// Construct from an existing service set id (does not guarentee that the service set exists).
        /// </summary>
        public static ServiceSetEditor FromId(ushort serviceSetId)
        {
            ServiceSetEditor servset=new ServiceSetEditor();
            servset.id=serviceSetId;
            return servset;
        }

        /// <summary>
        /// Constructs from a service set id, creating the service set in the db if it does not already exist.
        /// </summary>
        public static ServiceSetEditor CreateOrUseExistingId(ushort serviceSetId)
        {
            ServiceSetEditor servset=new ServiceSetEditor();
            servset.id=serviceSetId;

            //insert the t_services entry if needed
            if (!UodbWS.DoesServiceSetExist(serviceSetId))
            {
                UodbWS.ExecuteSQLNonQuery("insert into t_service_set (si_service_set_id,vc_friendly_name) values ("+(short)serviceSetId+", 'Test Service Set "+serviceSetId+"')", null);
            }

            return servset;
        }

        //constructor is not for public consumption.
        private ServiceSetEditor()
        {
        }

        #endregion

        // --

        #region Lookup or alter properties of the service set

        /// <summary>
        /// Whether the service set actually exists in the db.
        /// </summary>
        public override bool Exists
        {
            get
            {
                if (HasCachedEntry("exists"))
                {
                    return (bool)cache["exists"];
                }

                bool exists=id!=0 && UodbWS.DoesServiceSetExist(id);
                SetCacheEntry("exists", exists);
                return exists;
            }
        }

        /// <summary>
        /// Name of the service set.
        /// </summary>
        public string Name
        {
            get
            {
                if (HasCachedEntry("name"))
                {
                    return (string)cache["name"];
                }

                object ret=UodbWS.ExecuteSQLScalar("select vc_friendly_name from t_service_set where si_service_set_id="+(short)id, null);
                if (ret==null)
                {
                    throw new RowDoesNotExistException("t_service_set", "si_service_set_id", id.ToString());
                }
                string name=(string)ret;
                SetCacheEntry("name", name);
                return name;
            }

            set
            {
                UodbWS.ExecuteSQLNonQuery("update t_service_set set vc_friendly_name='"+EscapeString(value)+"' where si_service_set_id="+(short)id, null);
                SetCacheEntry("name", value);
            }
        }

        #endregion

        //Short descriptive useful string that doesn't require db hits
        public override string ToString()
        {
            if (id==0)
            {
                return "Nonexistant Service Set (id=0)";
            }
            else
            {
                return string.Format("Service Set 0x{0:X}", id);
            }
        }

        //Long string containing every field of the service set.  This call can be expensive, as it may make db hits.
        public string FullDescription
        {
            get
            {
                if (!Exists)
                {
                    return string.Format("Nonexistant Service Set 0x{0:X}", id);
                }
                else
                {
                    string ret=ToString();
                    ret+="\nName="+Name;
                    ret+="\nServices: "+StringUtils.MakeCommaSeparatedList(GetAllServices());
                    return ret;
                }
            }
        }

        #region Add or remove "assets" for the service set

        /// <summary>
        /// Returns all granted services from the set.
        /// </summary>
        public uint[] GetAllServices()
        {
            List<uint> servs=new List<uint>();

            using (WSClient ws=new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITETHENREAD_COMMANDTYPE))
            {
                ws.PartitionType=WstPartitionType.Logical;
                ws.Partition=WstCommand.AnyPartition;
                ws.CommandSql="select i_service_id from t_service_set_service where si_service_set_id="+(short)id;

                using (WstDataReader myDataReader=ws.Execute())
                {
                    while (myDataReader.Read())
                    {
                        servs.Add((uint)(int)myDataReader[0]);
                    }
                }
            }

            return servs.ToArray();
        }

        /// <summary>
        /// Removes all services from the set.
        /// </summary>
        public void RemoveAllServices()
        {
            UodbWS.ExecuteSQLNonQuery("delete from t_service_set_service where si_service_set_id="+(short)id, null);
        }

        /// <summary>
        /// Add a service to a set, if it does not already contain it.
        /// </summary>
        public void AddService(uint serviceId)
        {
            string query="if (0=(select count(i_service_id) from t_service_set_service where si_service_set_id="+(short)id+" and i_service_id="+(int)serviceId+")) ";
            query+="begin insert into t_service_set_service (si_service_set_id, i_service_id) values ("+(short)id+", "+(int)serviceId+") end";
            UodbWS.ExecuteSQLNonQuery(query, null);
        }

        #endregion
    };
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\Database\Editor\SiteEditor.cs ===
using xonline.common.sql.webstore;
using xonline.common.config;

namespace ServerTestFramework.Database
{
    /// <summary>
    /// Utility for altering or creating sites directly in the database.
    /// Note that creating a site also creates the associated service keys.  TODO: make a separate service key editor.
    /// </summary>
    public class SiteEditor: EditorCommon
    {
        /// <summary> Site ID.  This is the only non-cached information we store about the site. </summary>
        public uint Id
        {
            get { return id; }
        }

        private uint id=0;

        // --
        #region Create an instance of SiteEditor

        /// <summary> Construct from an existing site id (does not guarentee that the site exists). </summary>
        public static SiteEditor FromId(uint siteId)
        {
            SiteEditor site=new SiteEditor();
            site.id=siteId;
            return site;
        }

        /// <summary> Constructs from an site id, creating the site in the db if it does not already exist. </summary>
        public static SiteEditor CreateOrUseExistingId(uint siteId)
        {
            //use existing if it already exists
            SiteEditor site=SiteEditor.FromId(siteId);
            if (site.Exists)
            {
                return site;
            }

            //create it
            string keyblob="0x132EF9B4DE63CFDB7CC2D79DD0D2C6E63E86682E6CE07B1649C70A804816E448F8C8707630D2C2B3F69A34A2DA1DD616552E9C0ED2C91B4CE7F96FF0CBBDD9D2F8EC82FF469D2C3B2E79E67D8702FBD2591CB8C74099F4BD639DDAEE1E54416271111A5F361F000ED68FF0BE3E7A02278A2F446301FC1E310565B4A12A80A1E0004ED3E1791CD4D22ABFE9883CD8FC5C3D4DDB43A49F788D647EEBD2CD7D964B36CD7C8F0970BCDDBDA5245E3B930EC910E189C1BE2C29F1269A2C29CDD00E2EDFC39BA5DD9AE00041FE47AE4568B1220892349914F482EA373CAA2996E1CDE03AAF43479CC0CEB21051B8EF29A321D133ED3D4D6E937004F2BB7DC0A7174615";
            string query="exec p_svc_site_create "+(int)siteId+", 'TestSite"+siteId+"', 'SiteTest"+siteId+"', 1800, '0.0.0.0', 1, "+keyblob+", null, 3, '"+Global.XEnv.GetEnv()+"'";
            StaticNpdb.ExecuteNonQuery(query);

            return site;
        }

        //constructor is not for public consumption.
        private SiteEditor()
        {
        }

        #endregion

        // --
        #region Lookup or alter properties of the site

        /// <summary> Whether the site actually exists in the db. </summary>
        public override bool Exists
        {
            get
            {
                if (HasCachedEntry("exists"))
                {
                    return (bool)cache["exists"];
                }

                bool exists=id!=0 && (int)StaticNpdb.ExecuteScalar("select count(0) from t_sites where i_site_id="+(int)id)!=0;
                SetCacheEntry("exists", exists);
                return exists;
            }
        }

        /// <summary> AuthData version used within the site. </summary>
        public int AuthDataVersion
        {
            get
            {
                return GetGenericSiteProperty<int>("i_authdata_version", "authversion");
            }

            set
            {
                SetGenericSiteProperty("i_authdata_version", "authversion", value);
            }
        }

        /// <summary> Environment the site is in. </summary>
        public string Environment
        {
            get
            {
                return GetGenericSiteProperty<string>("vc_environment", "environment");
            }

            set
            {
                SetGenericSiteProperty("vc_environment", "environment", value);
            }
        }

        /// <summary> Domain of the site? </summary>
        public string Domain
        {
            get
            {
                return GetGenericSiteProperty<string>("vc_domain", "domain");
            }

            set
            {
                SetGenericSiteProperty("vc_domain", "domain", value);
            }
        }

        /// <summary> Generic implementation of returning a property from an site (or cache if able). </summary>
        private TypeOfProperty GetGenericSiteProperty<TypeOfProperty>(string columnName, string cacheName)
        {
            if (HasCachedEntry(cacheName))
            {
                return (TypeOfProperty)cache[cacheName];
            }

            object ret=StaticNpdb.ExecuteScalar("select "+columnName+" from t_sites where i_site_id="+(int)id);
            if (ret!=null)
            {
                TypeOfProperty val=(TypeOfProperty)System.Convert.ChangeType(ret, typeof(TypeOfProperty));
                SetCacheEntry(cacheName, val);
                return val;
            }

            throw new RowDoesNotExistException("t_sites", columnName, id.ToString());
        }

        /// <summary> Generic implementation of setting a property in an site.  The value must be convertible to a string in a way that SQL understands. </summary>
        private void SetGenericSiteProperty<TypeOfProperty>(string columnName, string cacheName, TypeOfProperty value)
        {
            StaticNpdb.ExecuteNonQuery("update t_sites set "+columnName+"='"+EscapeString(value.ToString())+"' where i_site_id="+(int)id);
            SetCacheEntry(cacheName, value);
        }

        #endregion

        //Short descriptive useful string that doesn't require db hits
        public override string ToString()
        {
            if (id==0)
            {
                return "Nonexistant Site (id=0)";
            }
            else
            {
                return string.Format("Site 0x{0:X}", id);
            }
        }

        // string containing every field of the site.  This call is expensive, as it makes many db hits.
        public string FullDescription
        {
            get
            {
                if (!Exists)
                {
                    return string.Format("Nonexistant Site 0x{0:X}", id);
                }
                else
                {
                    string ret=ToString();
                    //TODO: all fields
                    return ret;
                }
            }
        }

        #region Add or remove "assets" for the site

        //TODO: functions to remove ips and get a list of ips from t_site_virtual_interface_ips

        /// <summary> Updates or creates a new row in t_site_virtual_interface_ips.  The KDC service names are special cases: sg=sgsvc ts=sgsvc_xlsp </summary>
        public void SetVirtualInterfaceIp(string interfaceName, string ip)
        {
            string env=Environment;
            string query="if ((select count(0) from t_site_virtual_interface_ips where i_site_id="+(int)id+" and vc_virtual_interface='"+interfaceName+"' and vc_environment='"+env+"')=0)\n"+
                         "begin insert into t_site_virtual_interface_ips (vc_environment, i_site_id, vc_virtual_interface, vc_ip) values ('"+env+"', "+(int)id+", '"+interfaceName+"', '"+ip+"') end\n"+
                         "else update t_site_virtual_interface_ips set vc_ip='"+ip+"' where i_site_id="+(int)id+" and vc_virtual_interface='"+interfaceName+"' and vc_environment='"+env+"'";
            StaticNpdb.ExecuteNonQuery(query);
        }

        /// <summary> Completely removes the site and its associated service keys from NPDB. </summary>
        public void CompletelyRemoveSite()
        {
            StaticNpdb.ExecuteNonQuery("delete from t_service_keys where i_site_id="+(int)id);
            StaticNpdb.ExecuteNonQuery("delete from t_site_virtual_interface_ips where i_site_id="+(int)id);
            StaticNpdb.ExecuteNonQuery("delete from t_site_virtual_interface_overrides where i_site_id="+(int)id);
            StaticNpdb.ExecuteNonQuery("delete from t_site_regions where i_site_id="+(int)id);
            StaticNpdb.ExecuteNonQuery("delete from t_sites where i_site_id="+(int)id);
        }

        #endregion
    };
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\Database\Editor\TitleEditor.cs ===
using System;
using System.Collections.Generic;

using xonline.common.sql.webstore;
using xonline.common.config;
using Microsoft.Webstore.WstClient;

using ServerTestFramework.Utilities;

namespace ServerTestFramework.Database
{
    /// <summary>
    /// Utility for altering or creating titles directly in the database.
    /// At the moment this does not do any actual content/packages/etc for the title, there's currently just enough here for the XKDC to be happy.
    /// </summary>
    public class TitleEditor: EditorCommon
    {
        /// <summary>
        /// Title ID.  This is the only non-cached information we store about the title.
        /// </summary>
        public uint Id
        {
            get { return id; }
        }

        private uint id=0;

        // --
        #region Create an instance of TitleEditor

        /// <summary>
        /// Construct from an existing title id (does not guarentee that the title exists).
        /// </summary>
        public static TitleEditor FromId(uint titleId)
        {
            TitleEditor title=new TitleEditor();
            title.id=titleId;
            return title;
        }

        /// <summary>
        /// Constructs from a title id, creating the title in the db if it does not already exist.
        /// Titles created this way initally have a version 0 created for them. (you can remove this version and add different ones if desired)
        /// </summary>
        public static TitleEditor CreateOrUseExistingId(uint titleId)
        {
            TitleEditor title=new TitleEditor();
            title.id=titleId;
            byte consoleType=2; //xenon default

            //insert the t_titles entry if needed
            if (!UodbWS.DoesTitleExist(titleId))
            {
                UodbWS.ExecuteSQLNonQuery("insert into t_titles (i_title_id,ti_console_type_id,dt_last_modified) values ("+(int)titleId+","+(int)consoleType+", getutcdate())", null);

                //add a version and trust constants for it, so it is usable
                title.AddVersion(0, 0, 0, consoleType);
                title.SetDefaultTitleTrustConstants();
            }

            return title;
        }

        //constructor is not for public consumption.
        private TitleEditor()
        {
        }

        #endregion

        // --
        #region Lookup or alter properties of the title

        /// <summary>
        /// Whether the title actually exists in the db.
        /// </summary>
        public override bool Exists
        {
            get
            {
                if (HasCachedEntry("exists"))
                {
                    return (bool)cache["exists"];
                }

                bool exists=id!=0 && UodbWS.DoesTitleExist(id);
                SetCacheEntry("exists", exists);
                return exists;
            }
        }

        /// <summary>
        /// Console type for this title.
        /// Note that this is ignored by most things, and the type specified in the title version is the real "console type", which allows for multiple platforms on the same title.
        /// </summary>
        public byte ConsoleType
        {
            get
            {
                if (HasCachedEntry("consoletype"))
                {
                    return (byte)cache["consoletype"];
                }

                object ret=UodbWS.ExecuteSQLScalar("select ti_console_type_id from t_titles where i_title_id="+(int)id, null);
                if (ret==null)
                {
                    throw new RowDoesNotExistException("t_titles", "i_title_id", id.ToString());
                }
                byte consoleType=(byte)ret;
                SetCacheEntry("consoletype", consoleType);
                return consoleType;
            }

            set
            {
                UodbWS.ExecuteSQLNonQuery("update t_titles set ti_console_type_id="+(int)value+" where i_title_id="+id, null);
                SetCacheEntry("consoletype", value);
            }
        }

        #endregion

        //Short descriptive useful string that doesn't require db hits
        public override string ToString()
        {
            if (id==0)
            {
                return "Nonexistant Title (id=0)";
            }
            else
            {
                return string.Format("Title 0x{0:X}", id);
            }
        }

        //Long string containing every field of the title.  This call can be expensive, as it may make db hits.
        public string FullDescription
        {
            get
            {
                if (!Exists)
                {
                    return string.Format("Nonexistant Title 0x{0:X}", id);
                }
                else
                {
                    string ret=ToString();
                    ret+="\nVersions: "+StringUtils.MakeCommaSeparatedList(GetAllVersions());
                    ret+="\nPrivileges: "+StringUtils.MakeCommaSeparatedList(GetAllPrivileges());
                    ret+="\nServices: "+StringUtils.MakeCommaSeparatedList(GetAllServices());
                    ret+="\nOffers: "+StringUtils.MakeCommaSeparatedList(GetAllOffers());
                    return ret;
                }
            }
        }

        // --
        #region Add or remove "assets" for the title

        /// <summary>
        /// Represents a specific version path.
        /// </summary>
        public class TitleVersion
        {
            public byte ConsoleType;
            public uint BaseVersion;
            public uint UpgradeVersion;
            public uint BetaVersion;

            public override string ToString()
            {
                string ret="";
                ret+="ConsoleType="+ConsoleType;
                ret+=" BaseVersion="+BaseVersion;
                ret+=" UpgradeVersion="+UpgradeVersion;
                ret+=" BetaVersion="+BetaVersion;
                return ret;
            }
        }

        /// <summary>
        /// Returns all versions of a title.
        /// </summary>
        public TitleVersion[] GetAllVersions()
        {
            List<TitleVersion> vers=new List<TitleVersion>();

            using (WSClient ws=new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITETHENREAD_COMMANDTYPE))
            {
                ws.PartitionType=WstPartitionType.Logical;
                ws.Partition=WstCommand.AnyPartition;
                ws.CommandSql="select ti_console_type_id,i_base_version,i_update_version,i_beta_version from t_title_versions where i_title_id="+(int)id;

                using (WstDataReader myDataReader=ws.Execute())
                {
                    while (myDataReader.Read())
                    {
                        TitleVersion v=new TitleVersion();
                        v.ConsoleType=(byte)myDataReader[0];
                        v.BaseVersion=(uint)(int)myDataReader[1];
                        v.UpgradeVersion=(uint)(int)myDataReader[2];
                        v.BetaVersion=(uint)(int)myDataReader[3];
                        vers.Add(v);
                    }
                }
            }

            return vers.ToArray();
        }

        /// <summary>
        /// Returns all versions of a title filtered by beta group.
        /// </summary>
        /// <param name="BetaGroup">Beta Group to filter</param>
        /// <returns></returns>
        public TitleVersion[] GetAllVersions(Guid BetaGroup)
        {
            List<TitleVersion> vers = new List<TitleVersion>();

            using (WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITETHENREAD_COMMANDTYPE))
            {
                ws.PartitionType = WstPartitionType.Logical;
                ws.Partition = WstCommand.AnyPartition;
                ws.CommandSql = "select ti_console_type_id,i_base_version,i_update_version,i_beta_version from t_title_versions where i_title_id=" + (int)id + "and uid_beta_group_id='" + BetaGroup.ToString() + "'";

                using (WstDataReader myDataReader = ws.Execute())
                {
                    while (myDataReader.Read())
                    {
                        TitleVersion v = new TitleVersion();
                        v.ConsoleType = (byte)myDataReader[0];
                        v.BaseVersion = (uint)(int)myDataReader[1];
                        v.UpgradeVersion = (uint)(int)myDataReader[2];
                        v.BetaVersion = (uint)(int)myDataReader[3];
                        vers.Add(v);
                    }
                }
            }

            return vers.ToArray();
        }

        /// <summary>
        /// Removes all versions for a title.
        /// </summary>
        public void RemoveAllVersions()
        {
            UodbWS.ExecuteSQLNonQuery("delete from t_title_versions where i_title_id="+(int)id, null);
        }

        /// <summary> Removes a specific base version of a title. </summary>
        public void RemoveBaseVersion(uint baseVersion)
        {
            UodbWS.ExecuteSQLNonQuery("delete from t_title_versions where i_title_id="+(int)id+" and i_base_version="+(int)baseVersion, null);
        }

        /// <summary>
        /// Adds a version to a title.
        /// If the fully entry already exists, the call is ignored.
        /// If the base version and console type exist but the update/beta version is different, you will get an exception.
        /// </summary>
        public void AddVersion(uint baseVersion, uint updateVersion, uint betaVersion, byte consoleType)
        {
            string query="if (0=(select count(*) from t_title_versions where i_title_id="+(int)id+" and i_base_version="+(int)baseVersion+" and i_update_version="+(int)updateVersion+" and i_beta_version="+(int)betaVersion+" and ti_console_type_id="+(int)consoleType+")) \n"+
                "begin insert into t_title_versions (i_title_id, i_base_version, i_update_version, i_beta_version, ti_console_type_id) values ("+(int)id+", "+(int)baseVersion+", "+(int)updateVersion+", "+(int)betaVersion+", "+(int)consoleType+") end";
            UodbWS.ExecuteSQLNonQuery(query, null);
        }

        /// <summary>
        /// Adds a version to a title.
        /// If the fully entry already exists, the call is ignored.
        /// If the base version and console type exist but the update/beta version is different, you will get an exception.
        /// </summary>
        public void AddVersion(uint baseVersion, uint updateVersion, byte consoleType, System.Guid betaGroup)
        {
            string query="if (0=(select count(*) from t_title_versions where i_title_id="+(int)id+" and i_base_version="+(int)baseVersion+" and i_update_version="+(int)updateVersion+" and ti_console_type_id="+(int)consoleType+" and uid_beta_group_id='"+betaGroup+"')) \n"+
                "begin insert into t_title_versions (i_title_id, i_base_version, i_update_version, i_beta_version, ti_console_type_id, uid_beta_group_id) values ("+(int)id+", "+(int)baseVersion+", "+(int)updateVersion+", "+(int)updateVersion+", "+(int)consoleType+", '"+betaGroup+"') end";
            UodbWS.ExecuteSQLNonQuery(query, null);
        }

        /// <summary>
        /// Adds a version to a title.
        /// If the fully entry already exists, the call is ignored.
        /// If the base version and console type exist but the update/beta version is different, you will get an exception.
        /// </summary>
        public void AddVersion(uint baseVersion, uint updateVersion, byte consoleType, System.Guid betaGroup, System.DateTime startDate, System.DateTime endDate)
        {
            string query="if (0=(select count(*) from t_title_versions where i_title_id="+(int)id+" and i_base_version="+(int)baseVersion+" and i_update_version="+(int)updateVersion+" and ti_console_type_id="+(int)consoleType+" and uid_beta_group_id='"+betaGroup+"')) \n"+
                "begin insert into t_title_versions (i_title_id, i_base_version, i_update_version, i_beta_version, ti_console_type_id, uid_beta_group_id, dt_start_time, dt_end_time) values ("+(int)id+", "+(int)baseVersion+", "+(int)updateVersion+", "+(int)updateVersion+", "+(int)consoleType+", '"+betaGroup+"', '"+startDate+"', '"+endDate+"') end";
            UodbWS.ExecuteSQLNonQuery(query, null);
        }

        /// <summary> Represents an update package. </summary>
        public class TitleUpdatePackageData
        {
            public byte ConsoleType;
            public uint BaseVersion;
            public uint UpgradeVersion;

            public byte []UpdateSymmetricKey;
            public byte []PublicKey;
            public int    InstallSize;
            public int    PackageSize;
            public byte []ContentId;
        };

        /// <summary> Removes all update packages for this title. </summary>
        public void RemoveAllUpdatePackages()
        {
            UodbWS.ExecuteSQLNonQuery("delete from t_title_update_packages where i_title_id="+(int)id, null);
        }

        /// <summary> Adds an update package entry with dummy data. </summary>
        public void AddUpdatePackage(uint baseVersion, uint updateVersion, byte consoleType)
        {
            AddUpdatePackage(baseVersion, updateVersion, consoleType, new byte[16], new byte[284], 1234, 1234, new byte[20]);
        }

        /// <summary> Adds an update package entry. </summary>
        public void AddUpdatePackage(uint baseVersion, uint updateVersion, byte consoleType, byte []updateKey, byte []publicKey, uint installSize, uint packageSize, byte []contentId)
        {
            string query=QueryGenerator.GenerateUpdateOrInsert("t_title_update_packages",
                                                               new string[]{"i_title_id", "i_title_base_version", "i_title_update_version", "vb_update_sym_key", "vb_public_key", "i_install_size", "i_package_size", "b_content_id", "ti_console_type_id"},
                                                               new object[]{id, baseVersion, updateVersion, updateKey, publicKey, installSize, packageSize, contentId, consoleType},
                                                               new string[]{"i_title_id", "i_title_base_version", "i_title_update_version", "ti_console_type_id"}
                                                               );
            UodbWS.ExecuteSQLNonQuery(query, null);
        }

        /// <summary> Adds an update package entry. </summary>
        public void AddUpdatePackage(TitleUpdatePackageData tupd)
        {
            AddUpdatePackage(tupd.BaseVersion, tupd.UpgradeVersion, tupd.ConsoleType, tupd.UpdateSymmetricKey, tupd.PublicKey, (uint)tupd.InstallSize, (uint)tupd.PackageSize, tupd.ContentId);
        }

        /// <summary> Gets a list of title update packages. </summary>
        public TitleUpdatePackageData[] GetUpdatePackages(uint baseVersion, uint updateVersion, byte consoleType)
        {
            List<TitleUpdatePackageData> tups=new List<TitleUpdatePackageData>();

            using (WSClient ws=new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITETHENREAD_COMMANDTYPE))
            {
                ws.PartitionType=WstPartitionType.Logical;
                ws.Partition=WstCommand.AnyPartition;
                ws.CommandSql="select vb_update_sym_key, vb_public_key, i_install_size, i_package_size, b_content_id from t_title_update_packages where i_title_id="+(int)id+" and i_title_base_version="+(int)baseVersion+" and i_title_update_version="+(int)updateVersion+" and ti_console_type_id="+consoleType;

                using (WstDataReader reader=ws.Execute())
                {
                    while (reader.Read())
                    {
                        TitleUpdatePackageData t=new TitleUpdatePackageData();
                        t.ConsoleType=consoleType;
                        t.BaseVersion=baseVersion;
                        t.UpgradeVersion=updateVersion;
                        t.UpdateSymmetricKey=(byte[])reader[0];
                        t.PublicKey=(byte[])reader[1];
                        t.InstallSize=(int)reader[2];
                        t.PackageSize=(int)reader[3];
                        t.ContentId = (byte[])((reader[4] == DBNull.Value) ? null : reader[4]);
                        tups.Add(t);
                    }
                }
            }

            return tups.ToArray();
        }

        /// <summary> Gets a list of all title update packages. </summary>
        public TitleUpdatePackageData[] GetUpdatePackages()
        {
            List<TitleUpdatePackageData> tups=new List<TitleUpdatePackageData>();

            using (WSClient ws=new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITETHENREAD_COMMANDTYPE))
            {
                ws.PartitionType=WstPartitionType.Logical;
                ws.Partition=WstCommand.AnyPartition;
                ws.CommandSql="select vb_update_sym_key, vb_public_key, i_install_size, i_package_size, b_content_id, i_title_base_version, i_title_update_version, ti_console_type_id from t_title_update_packages where i_title_id="+(int)id;

                using (WstDataReader reader=ws.Execute())
                {
                    while (reader.Read())
                    {
                        TitleUpdatePackageData t=new TitleUpdatePackageData();
                        t.UpdateSymmetricKey=(byte[])reader[0];
                        t.PublicKey=(byte[])reader[1];
                        t.InstallSize=(int)reader[2];
                        t.PackageSize=(int)reader[3];
                        t.ContentId = (byte[])((reader[4] == DBNull.Value) ? null : reader[4]);
                        t.BaseVersion=(uint)(int)reader[5];
                        t.UpgradeVersion=(uint)(int)reader[6];
                        t.ConsoleType=(byte)reader[7];
                        tups.Add(t);
                    }
                }
            }

            return tups.ToArray();
        }

        /// <summary> Represents a title update packace location </summary>
        public class TitleUpdateLocationData
        {
            public byte ConsoleType;
            public uint BaseVersion;
            public uint UpgradeVersion;

            public int    Rank;
            public string Xrl;
        };

        /// <summary> Removes all update locations for this title. </summary>
        public void RemoveAllUpdateLocations()
        {
            UodbWS.ExecuteSQLNonQuery("delete from t_title_update_locations where i_title_id="+(int)id, null);
        }

        /// <summary> Adds an update location entry. </summary>
        public void AddUpdateLocation(uint baseVersion, uint updateVersion, byte consoleType, uint rank, string xrl)
        {
            string query=QueryGenerator.GenerateUpdateOrInsert("t_title_update_locations",
                                                  new string[]{"i_title_id", "i_title_base_version", "i_title_update_version", "i_location_rank", "vc_XRL", "ti_console_type_id"},
                                                  new object[]{id, baseVersion, updateVersion, rank, xrl, consoleType},
                                                  new string[]{"i_title_id", "i_title_base_version", "i_title_update_version", "i_location_rank", "ti_console_type_id"}
                                                  );
            UodbWS.ExecuteSQLNonQuery(query, null);
        }

        /// <summary> Adds an update location entry. </summary>
        public void AddUpdateLocation(TitleUpdateLocationData loc)
        {
            AddUpdateLocation(loc.BaseVersion, loc.UpgradeVersion, loc.ConsoleType, (uint)loc.Rank, loc.Xrl);
        }

        /// <summary> Gets a list of title update locations. </summary>
        public TitleUpdateLocationData[] GetUpdateLocations(uint baseVersion, uint updateVersion, byte consoleType)
        {
            List<TitleUpdateLocationData> locs=new List<TitleUpdateLocationData>();

            using (WSClient ws=new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITETHENREAD_COMMANDTYPE))
            {
                ws.PartitionType=WstPartitionType.Logical;
                ws.Partition=WstCommand.AnyPartition;
                ws.CommandSql="select i_location_rank, vc_XRL from t_title_update_locations where i_title_id="+(int)id+" and i_title_base_version="+(int)baseVersion+" and i_title_update_version="+(int)updateVersion+" and ti_console_type_id="+consoleType;

                using (WstDataReader reader=ws.Execute())
                {
                    while (reader.Read())
                    {
                        TitleUpdateLocationData l=new TitleUpdateLocationData();
                        l.ConsoleType=consoleType;
                        l.BaseVersion=baseVersion;
                        l.UpgradeVersion=updateVersion;
                        l.Rank=(int)reader[0];
                        l.Xrl=(string)reader[1];
                        locs.Add(l);
                    }
                }
            }

            return locs.ToArray();
        }

        /// <summary> Gets a list of all title update locations. </summary>
        public TitleUpdateLocationData[] GetUpdateLocations()
        {
            List<TitleUpdateLocationData> locs=new List<TitleUpdateLocationData>();

            using (WSClient ws=new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITETHENREAD_COMMANDTYPE))
            {
                ws.PartitionType=WstPartitionType.Logical;
                ws.Partition=WstCommand.AnyPartition;
                ws.CommandSql="select i_location_rank, vc_XRL, i_title_base_version, i_title_update_version, ti_console_type_id from t_title_update_locations where i_title_id="+(int)id;

                using (WstDataReader reader=ws.Execute())
                {
                    while (reader.Read())
                    {
                        TitleUpdateLocationData l=new TitleUpdateLocationData();
                        l.Rank=(int)reader[0];
                        l.Xrl=(string)reader[1];
                        l.BaseVersion=(uint)(int)reader[2];
                        l.UpgradeVersion=(uint)(int)reader[3];
                        l.ConsoleType=(byte)reader[4];
                        locs.Add(l);
                    }
                }
            }

            return locs.ToArray();
        }

        /// <summary>
        /// Adds or updates a title's trust constants to a sane value.
        /// </summary>
        public void SetDefaultTitleTrustConstants()
        {
            SetTitleTrustConstants(1, 1, 1, 1, 1, 0, 0, 0, 1, 0.25f, 2, 4, 2592000, 120, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 8, 16, 32, 64, 0, 0, 0, 1, 8, 4, 2, 1, 1, 2, 4, 8);
        }

        /// <summary>
        /// Adds or updates a title's trust constants to a specific value.
        /// </summary>
        public void SetTitleTrustConstants(float w2, float w3, float w4, float w5, float w6, float w7, float w8, float w9,
                                           float baseUserTrust, float minorityQuorum, float userCompAmp, float publisherCompAmp, int lambda, int sessionTime,
                                           float s1, float s2, float s3, float s4, float s5, float s6, float s7, float s8, float s9,
                                           long totalSessions, long sessionsDisconnect, long totalComp, long compNoShow,
                                           long sessionBase, long sessionXboxCount, long sessionSeconds, long sessionFFA, int totalUsers,
                                           float r2, float r3, float r4, float r5, float r6, float r7, float r8, float r9,
                                           float k, byte lowerBottom, byte lowerMiddle, byte lowerTop, byte middleBottom, byte middleTop, byte upperBottom, byte upperMiddle, byte upperTop)
        {
            string query="delete from t_title_trust_constants where i_title_id="+(int)id+" \n"+
                              "insert into t_title_trust_constants ([i_title_id], "+
                              "[f_W2], [f_W3], [f_W4], [f_W5], [f_W6], [f_W7], [f_W8], [f_W9], "+
                              "[f_BaseUserTrust], [f_MinorityQuorum], [f_UserCompetitionAmp], [f_PublisherCompetitionAmp], [i_Lambda], [i_BaseSessionTime], "+
                              "[f_S1], [f_S2], [f_S3], [f_S4], [f_S5], [f_S6], [f_S7], [f_S8], [f_S9], "+
                              "[bi_TotalSessions], [bi_TotalSessionDisconnects], [bi_TotalCompetitions], [bi_TotalCompetitionNoShows], "+
                              "[bi_SessionBase], [bi_SessionXboxCount], [bi_SessionSeconds], [bi_SessionFreeForAll], [i_TotalUsers], "+
                              "[f_R2], [f_R3], [f_R4], [f_R5], [f_R6], [f_R7], [f_R8], [f_R9], "+
                              "[f_K], [ti_lower_bottom], [ti_lower_mid], [ti_lower_top], [ti_mid_bottom], [ti_mid_top], [ti_upper_bottom], [ti_upper_mid], [ti_upper_top]) "+
                              "values ("+(int)id+", "+
                              w2+", "+w3+", "+w4+", "+w5+", "+w6+", "+w7+", "+w8+", "+w9+", "+
                              baseUserTrust+", "+minorityQuorum+", "+userCompAmp+", "+publisherCompAmp+", "+lambda+", "+sessionTime+", "+
                              s1+", "+s2+", "+s3+", "+s4+", "+s5+", "+s6+", "+s7+", "+s8+", "+s9+", "+
                              totalSessions+", "+sessionsDisconnect+", "+totalComp+", "+compNoShow+", "+
                              sessionBase+", "+sessionXboxCount+", "+sessionSeconds+", "+sessionFFA+", "+totalUsers+", "+
                              r2+", "+r3+", "+r4+", "+r5+", "+r6+", "+r7+", "+r8+", "+r9+", "+
                              k+", "+lowerBottom+", "+lowerMiddle+", "+lowerTop+", "+middleBottom+", "+middleTop+", "+upperBottom+", "+upperMiddle+", "+upperTop+")";

            UodbWS.ExecuteSQLNonQuery(query, null);
        }

        /// <summary>
        /// Removes all alt title IDs from a title.
        /// </summary>
        public void RemoveAllAlternateIDs()
        {
            UodbWS.ExecuteSQLNonQuery("delete from t_alternate_titleids where i_title_id="+(int)id, null);
        }
        /// <summary>
        /// Adds an alternate id to a title (or updates the existing title/region/media entry).  Each region and media can have its own set of alt IDs.  Or 0 means all.
        /// </summary>
        /// <param name="xbox1AltTitleId">Used only for xbox1, up to 4 alt IDs can be given.</param>
        /// <param name="xenonAltService">Used only for xenon and newer.  This is the service that will be remapped to the corresponding entry in xenonAltTitle.  Up to 4 can be given.</param>
        /// <param name="xenonAltTitle">Used only for xenon and newer.  This is the title mapped to a service in the corresponding entry in xenonAltService.  Up to 4 can be given.</param>
        /// <param name="liveTitleId">Who knows?  Just set it to 0 for the mainline case, since every entry in prod right now is 0.</param>
        public void AddAlternateID(uint regionID, uint mediaID, uint liveTitleId, uint []xbox1AltTitleId, uint []xenonAltService, uint []xenonAltTitle)
        {
            //make arrays exist, and verify sanity
            if (xbox1AltTitleId==null) xbox1AltTitleId=new uint[0];
            if (xenonAltService==null) xenonAltService=new uint[0];
            if (xenonAltTitle==null) xenonAltTitle=new uint[0];

            if (xbox1AltTitleId.Length>4) throw new System.Exception("xbox1AltTitleId may only have up to 4 entries.");
            if (xenonAltService.Length>4) throw new System.Exception("xenonAltService may only have up to 4 entries.");
            if (xenonAltTitle.Length>4) throw new System.Exception("xenonAltTitle may only have up to 4 entries.");
            if (xenonAltService.Length!=xenonAltTitle.Length) throw new System.Exception("xenonAltService.Length must match xenonAltTitle.Length");

            //insert
            string query="exec p_svc_set_alternate_titleids "+(int)id+", "+(int)regionID+", "+(int)mediaID+", "+liveTitleId;
            query+=", "+(xbox1AltTitleId.Length>=1?xbox1AltTitleId[0]:0);
            query+=", "+(xbox1AltTitleId.Length>=2?xbox1AltTitleId[1]:0);
            query+=", "+(xbox1AltTitleId.Length>=3?xbox1AltTitleId[2]:0);
            query+=", "+(xbox1AltTitleId.Length>=4?xbox1AltTitleId[3]:0);
            query+=", "+(xenonAltService.Length>=1?xenonAltService[0]:0);
            query+=", "+(xenonAltTitle.Length>=1?xenonAltTitle[0]:0);
            query+=", "+(xenonAltService.Length>=2?xenonAltService[1]:0);
            query+=", "+(xenonAltTitle.Length>=2?xenonAltTitle[1]:0);
            query+=", "+(xenonAltService.Length>=3?xenonAltService[2]:0);
            query+=", "+(xenonAltTitle.Length>=3?xenonAltTitle[2]:0);
            query+=", "+(xenonAltService.Length>=4?xenonAltService[3]:0);
            query+=", "+(xenonAltTitle.Length>=4?xenonAltTitle[3]:0);

            UodbWS.ExecuteSQLNonQuery(query, null);
        }

        /// <summary>
        /// Returns all privileges that the title grants.
        /// </summary>
        public byte[] GetAllPrivileges()
        {
            List<byte> privs=new List<byte>();

            using (WSClient ws=new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITETHENREAD_COMMANDTYPE))
            {
                ws.PartitionType=WstPartitionType.Logical;
                ws.Partition=WstCommand.AnyPartition;
                ws.CommandSql="select ti_privilege_id from t_title_privileges where i_title_id="+(int)id;

                using (WstDataReader myDataReader=ws.Execute())
                {
                    while (myDataReader.Read())
                    {
                        privs.Add((byte)myDataReader[0]);
                    }
                }
            }

            return privs.ToArray();
        }

        /// <summary>
        /// Removes all granted privileges from the title.
        /// </summary>
        public void RemoveAllPrivileges()
        {
            UodbWS.ExecuteSQLNonQuery("delete from t_title_privileges where i_title_id="+(int)id, null);
        }

        /// <summary>
        /// Adds a privilege granted by the title, if it does not already grant it.
        /// </summary>
        public void AddPrivilege (byte privilegeId)
        {
            AddPrivilege(privilegeId, 0);
        }

        /// <summary>
        /// Adds a privilege granted by the title for the specific tier, if it does not already grant it.
        /// </summary>
        public void AddPrivilege (byte privilegeId, int tier)
        {
            string query = @"
If not exists( Select null from t_title_privileges where i_title_id={0} and ti_privilege_id={1} and i_tier_id={2} ) Begin
  Insert into t_title_privileges (i_title_id, ti_privilege_id, i_tier_id) values ({0}, {1}, {2})
End
";
            query = String.Format(query, (int)id, (int)privilegeId, tier);

            UodbWS.ExecuteSQLNonQuery(query, null);
        }

        /// <summary>
        /// Returns all services that the title grants.
        /// </summary>
        public uint[] GetAllServices()
        {
            List<uint> servs=new List<uint>();

            using (WSClient ws=new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITETHENREAD_COMMANDTYPE))
            {
                ws.PartitionType=WstPartitionType.Logical;
                ws.Partition=WstCommand.AnyPartition;
                ws.CommandSql="select i_service_id from t_title_services where i_title_id="+(int)id;

                using (WstDataReader myDataReader=ws.Execute())
                {
                    while (myDataReader.Read())
                    {
                        servs.Add((uint)(int)myDataReader[0]);
                    }
                }
            }

            return servs.ToArray();
        }

        /// <summary>
        /// Removes all granted services from the title.
        /// </summary>
        public void RemoveAllServices()
        {
            UodbWS.ExecuteSQLNonQuery("delete from t_title_services where i_title_id="+(int)id, null);
        }

        /// <summary>
        /// Adds a service granted by the title, if it does not already grant it.
        /// </summary>
        public void AddService(uint serviceId)
        {
            string query="if (0=(select count(i_service_id) from t_title_services where i_title_id="+(int)id+" and i_service_id="+(int)serviceId+")) ";
            query+="begin insert into t_title_services (i_title_id, i_service_id) values ("+(int)id+", "+(int)serviceId+") end";
            UodbWS.ExecuteSQLNonQuery(query, null);
        }

        /// <summary>
        /// Returns all offers that the title provides.
        /// </summary>
        public ulong[] GetAllOffers()
        {
            List<ulong> offers=new List<ulong>();

            using (WSClient ws=new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITETHENREAD_COMMANDTYPE))
            {
                ws.PartitionType=WstPartitionType.Logical;
                ws.Partition=WstCommand.AnyPartition;
                ws.CommandSql="select bi_offer_id from t_title_offers where i_title_id="+(int)id;

                using (WstDataReader myDataReader=ws.Execute())
                {
                    while (myDataReader.Read())
                    {
                        offers.Add((ulong)(long)myDataReader[0]);
                    }
                }
            }

            return offers.ToArray();
        }

        /// <summary>
        /// Removes all allowed offers from the title.
        /// </summary>
        public void RemoveAllOffers()
        {
            UodbWS.ExecuteSQLNonQuery("delete from t_title_offers where i_title_id="+(int)id, null);
        }

        /// <summary>
        /// Adds an offer allowed by the title, if it does not already allowed for it.
        /// For xbox360 and PC, if the offer is not in this list for a title, any services and privileges and such will not be applied.
        /// For xbox1, this is not used.
        /// </summary>
        public void AddOffer(ulong offerId)
        {
            string query="if (0=(select count(bi_offer_id) from t_title_offers where i_title_id="+(int)id+" and bi_offer_id="+(long)offerId+")) ";
            query+="begin insert into t_title_offers (i_title_id, bi_offer_id) values ("+(int)id+", "+(long)offerId+") end";
            UodbWS.ExecuteSQLNonQuery(query, null);
        }

        /// <summary>
        /// Modifies the t_title_info table
        /// </summary>
        public void SetTitleInfo(byte consoleTypeId, bool fRequiresActivation)
        {
            string strRequiresActivation = fRequiresActivation ? "1" : "0";

            string query="if not exists (select null from t_title_info where i_title_id="+(int)id+" and ti_console_type_id="+(int)consoleTypeId+") ";
            query+="begin insert into t_title_info (i_title_id, ti_console_type_id, f_requires_activation) values ("+(int)id+", "+(int)consoleTypeId+", "+strRequiresActivation+") end ";
            query+="else begin update t_title_info set f_requires_activation="+strRequiresActivation+" where i_title_id="+(int)id+" and ti_console_type_id="+(int)consoleTypeId+" end ";
            UodbWS.ExecuteSQLNonQuery(query, null);
        }

        /// <summary>
        /// Contains the information from t_title_culture_details.
        /// </summary>
        public class CultureDetails
        {
            public int TitleId;
            public int CultureId;
            public string Name;
            public string SellText;
            public string Publisher;
            public string Developer;
            public string Genre;
            public DateTime ChangeTime;

            public string InsertColumns
            {
                get
                {
                    return "i_title_id, i_culture_id, vc_name, vc_sell_text, vc_publisher, vc_developer, vc_genre";
                }
            }

            public string InsertValues
            {
                get
                {
                    return string.Format("{0}, {1}, '{2}', '{3}', '{4}', '{5}', '{6}'", TitleId, CultureId,
                        ReplaceSQs(Name), ReplaceSQs(SellText), ReplaceSQs(Publisher), ReplaceSQs(Developer), ReplaceSQs(Genre));
                }
            }

            public string UpdateSet
            {
                get
                {
                    return string.Format("vc_name='{0}', vc_sell_text='{1}', vc_publisher='{2}', vc_developer='{3}', vc_genre='{4}'",
                        ReplaceSQs(Name), ReplaceSQs(SellText), ReplaceSQs(Publisher), ReplaceSQs(Developer), ReplaceSQs(Genre));
                }
            }

            private string ReplaceSQs (string s) { return (s == null ? "" : s.Replace("'", "''")); }
        }

        /// <summary>
        /// Gets the culture details for the specified culture.
        /// </summary>
        public CultureDetails GetTitleCultureDetails (uint cultureId)
        {
            string query = "Select * from t_title_culture_details where i_title_id = " + (int)id + " and i_culture_id = " + (int)cultureId;

            using (WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITETHENREAD_COMMANDTYPE))
            {
                ws.PartitionType = WstPartitionType.Logical;
                ws.Partition = WstCommand.AnyPartition;
                ws.CommandSql = query;

                using (WstDataReader myDataReader = ws.Execute())
                {
                    if (myDataReader.Read())
                    {
                        CultureDetails ans = new CultureDetails();

                        ans.TitleId = myDataReader.GetInt32(myDataReader.GetOrdinal("i_title_id"));
                        ans.CultureId = myDataReader.GetInt32(myDataReader.GetOrdinal("i_culture_id"));
                        ans.Name = myDataReader.GetString(myDataReader.GetOrdinal("vc_name"));
                        ans.SellText = myDataReader.GetString(myDataReader.GetOrdinal("vc_sell_text"));
                        ans.Publisher = myDataReader.GetString(myDataReader.GetOrdinal("vc_publisher"));
                        ans.Developer = myDataReader.GetString(myDataReader.GetOrdinal("vc_developer"));
                        ans.Genre = myDataReader.GetString(myDataReader.GetOrdinal("vc_genre"));
                        ans.ChangeTime = myDataReader.GetDateTime(myDataReader.GetOrdinal("dt_change_datetime"));

                        return ans;
                    }
                    else
                    {
                        return null;
                    }
                }
            }
        }

        /// <summary>
        /// Sets the culture details for the specified culture.
        /// </summary>
        public void SetTitleCultureDetails (CultureDetails details)
        {
            if (details.TitleId != (int)id)
            {
                throw new ArgumentException("CultureDetails.TitleId does not match the Id of this TitleEditor.", "details");
            }

            string query = @"
If not exists (select null from t_title_culture_details where i_title_id = {0} and i_culture_id = {1}) begin
  Insert into t_title_culture_details ({2}) values ({3})
end else begin
  Update t_title_culture_details set {4} where i_title_id = {0} and i_culture_id = {1}
end
";
            query = string.Format(query, (int)id, details.CultureId, 
                details.InsertColumns, details.InsertValues, details.UpdateSet);

            UodbWS.ExecuteSQLNonQuery(query, null);
        }

        #endregion
    };
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\Database\Editor\SubscriptionFamilyEditor.cs ===
using System;
using System.Collections.Generic;

using xonline.common.sql.webstore;
using xonline.common.config;
using Microsoft.Webstore.WstClient;

using ServerTestFramework.Utilities;

namespace ServerTestFramework.Database
{
    /// <summary> Utility for altering or creating subscription families. </summary>
    public class SubscriptionFamilyEditor: EditorCommon
    {
        /// <summary> Subscription Family ID.  This is the only non-cached information we store about the subscription family. </summary>
        public System.Guid Id
        {
            get { return id; }
        }

        private System.Guid id;

        #region Create an instance of SubscriptionFamilyEditor

        /// <summary> Get all families. </summary>
        public static IEnumerable<SubscriptionFamilyEditor> GetAllFamilies()
        {
            return UodbWS.ExecuteOnAllPartitions("SELECT guid_subscription_family FROM t_subscription_family", delegate(WstDataReader reader) { return FromId((Guid)reader["guid_subscription_family"]); });
        }

        /// <summary> Construct from a guid (does not guarentee that the family exists). </summary>
        public static SubscriptionFamilyEditor FromId(System.Guid existingId)
        {
            SubscriptionFamilyEditor sfe=new SubscriptionFamilyEditor();
            sfe.id=existingId;
            return sfe;
        }

        /// <summary> Constructs from a guid, creating the subscription family in the db if it does not already exist.  The default is to create a game subscription family and nothing special configured for it. </summary>
        public static SubscriptionFamilyEditor CreateOrUseExistingId(System.Guid existingId)
        {
            SubscriptionFamilyEditor sfe=new SubscriptionFamilyEditor();
            sfe.id=existingId;

            //only add the entry if needed
            if (!UodbWS.DoesSubscriptionFamilyExist(existingId))
            {
                //unfortunately we need a real service-privilege set to use
                ServicePrivilegeSetEditor dummySPSE=ServicePrivilegeSetEditor.FromId(0xfeff);
                if (!dummySPSE.Exists)
                {
                    dummySPSE=ServicePrivilegeSetEditor.CreateOrUseExistingId(0xfeff);
                    dummySPSE.Name="Test Empty set";
                }

                //
                System.Data.DataTable dataTable=new System.Data.DataTable("titleIds");
                dataTable.Columns.Add(new System.Data.DataColumn("i_title_id", typeof(int)));

                using (WSClient ws=new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITEONLY_COMMANDTYPE))
                {
                    for (int p=0; p<ws.PhysicalPartitions; ++p)
                    {
                        ws.ClearParameters();
                        ws.PartitionType=WstPartitionType.Physical;
                        ws.PhysicalPartition=p;
                        ws.StoredProc="dbo.p_subscription_family_configure";

                        ws.AddParameter(ParamType.RETVAL, "@ret", 0);
                        ws.AddParameter("@guid_subscription_family", existingId);
                        ws.AddParameter("@vc_friendly_name", "TestFamily "+existingId);
                        ws.AddParameter("@ti_service_type", 1); //Xbox Live
                        ws.AddParameter("@si_subscription_type", 3); //game
                        ws.AddParameter("@i_tier_id", 0);
                        ws.Parameters.AddWithValue("@title_id_list", dataTable); //empty table
                        ws.AddParameter("@si_service_privilege_set_id", dummySPSE.Id);

                        ws.Command.CommandTimeout=30;
                        ws.ExecuteNonQuery();

                        uint hr=(uint)ws.GetIntParameter("@ret");
                        if (hr!=0)
                        {
                            throw new System.Exception(ws.GetCallSignature()+" failed with hr=0x"+hr.ToString("X")+" on partition "+p);
                        }
                    }
                }
            }

            return sfe;
        }

        /// <summary> Creates a new subscription family. </summary>
        public static SubscriptionFamilyEditor CreateNew()
        {
            return CreateOrUseExistingId(System.Guid.NewGuid());
        }

        //constructor is not for public consumption.
        private SubscriptionFamilyEditor()
        {
        }

        #endregion

        // --

        #region Lookup or alter properties of the subscription family

        /// <summary> Whether the beta group actually exists in the db. </summary>
        public override bool Exists
        {
            get
            {
                if (HasCachedEntry("exists"))
                {
                    return (bool)cache["exists"];
                }

                bool exists=UodbWS.DoesSubscriptionFamilyExist(id);
                SetCacheEntry("exists", exists);
                return exists;
            }
        }

        /// <summary> Name of the subscription family. </summary>
        public string Name
        {
            get
            {
                return GetGenericProperty<string>("vc_friendly_name");
            }

            set
            {
                SetGenericProperty("vc_friendly_name", value);
            }
        }

        /// <summary> Service type the subscription family is for. </summary>
        public byte ServiceType
        {
            get
            {
                return GetGenericProperty<byte>("ti_service_type");
            }

            set
            {
                SetGenericProperty("ti_service_type", value);
            }
        }

        /// <summary> Subscription type the subscription family is for. </summary>
        public short SubscriptionType
        {
            get
            {
                return GetGenericProperty<short>("si_subscription_type");
            }

            set
            {
                SetGenericProperty("si_subscription_type", value);
            }
        }

        /// <summary> Tier ID the subscription family is for.  Only applicable to base subscription types. </summary>
        public int TierId
        {
            get
            {
                return GetGenericProperty<int>("i_tier_id");
            }

            set
            {
                SetGenericProperty("i_tier_id", value);
            }
        }

        /// <summary> Service-Privilege set id (t_service_privilege_set) granted by this subscription family. </summary>
        public short ServicePrivilegeSet
        {
            get
            {
                return GetGenericProperty<short>("si_service_privilege_set_id");
            }

            set
            {
                SetGenericProperty("si_service_privilege_set_id", value);
            }
        }

        /// <summary> Generic implementation of returning a property from a table based on guid (or cache if able). </summary>
        private TypeOfProperty GetGenericProperty<TypeOfProperty>(string columnName)
        {
            if (HasCachedEntry(columnName))
            {
                return (TypeOfProperty)cache[columnName];
            }

            object ret=UodbWS.ExecuteSQLScalar("select "+columnName+" from t_subscription_family where guid_subscription_family='"+id+"'", null);
            if (ret!=null)
            {
                TypeOfProperty val=(TypeOfProperty)System.Convert.ChangeType(ret, typeof(TypeOfProperty));
                SetCacheEntry(columnName, val);
                return val;
            }

            throw new RowDoesNotExistException("t_subscription_family", columnName, id.ToString());
        }

        /// <summary> Generic implementation of setting a property in a table based on guid.  The value must be convertible to a string in a way that SQL understands. </summary>
        private void SetGenericProperty<TypeOfProperty>(string columnName, TypeOfProperty value)
        {
            UodbWS.ExecuteSQLNonQuery("update t_subscription_family set "+columnName+"='"+EscapeString(value.ToString())+"' where guid_subscription_family='"+id+"'", null);
            SetCacheEntry(columnName, value);
        }

        #endregion

        //Short descriptive useful string that doesn't require db hits
        public override string ToString()
        {
            return "Subscription Family "+id;
        }

        #region Add or remove "assets" for the subscription family

        /// <summary> Retrieves a list of titles to which the subscription family applies.  Only applicable to game subscription types. </summary>
        public uint[] GetTitleIds()
        {
            List<uint> titles=new List<uint>();

            using (WSClient ws=new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITETHENREAD_COMMANDTYPE))
            {
                ws.PartitionType=WstPartitionType.Logical;
                ws.Partition=WstCommand.AnyPartition;
                ws.CommandSql="select i_title_id from t_subscription_family_title where guid_subscription_family='"+id+"'";

                using (WstDataReader reader=ws.Execute())
                {
                    while (reader.Read())
                    {
                        titles.Add((uint)(int)reader[0]);
                    }
                }
            }

            return titles.ToArray();
        }

        /// <summary> Removes all titles from the list to which the subscription family applies.  Only applicable to game subscription types. </summary>
        public void RemoveAllTitleIds()
        {
            UodbWS.ExecuteSQLNonQuery("delete from t_subscription_family_title where guid_subscription_family='"+id+"'", null);
        }

        /// <summary> Adds a title to which the subscription family applies if it is not already there.  Only applicable to game subscription types. </summary>
        public void AddTitleId(uint titleId)
        {
            string query="if (0=(select count(i_title_id) from t_subscription_family_title where guid_subscription_family='"+id+"' and i_title_id="+(int)titleId+")) ";
            query+="begin insert into t_subscription_family_title (guid_subscription_family, i_title_id) values ('"+id+"', "+(int)titleId+") end";
            UodbWS.ExecuteSQLNonQuery(query, null);
        }

        #endregion
    };


    // ----


    /// <summary> Utility for associating subscription families with offer instance guids. </summary>
    public class OfferInstanceSubscriptionFamilyMappingEditor
    {
        /// <summary> Offer instance guid.  This is the only non-cached information we store about the offer instance guid. </summary>
        public System.Guid Id
        {
            get { return id; }
        }

        private System.Guid id;

        /// <summary> Construct from a guid (does not guarentee that the offer instance exists). </summary>
        public static OfferInstanceSubscriptionFamilyMappingEditor FromId(System.Guid offerInstanceId)
        {
            OfferInstanceSubscriptionFamilyMappingEditor eisfme=new OfferInstanceSubscriptionFamilyMappingEditor();
            eisfme.id=offerInstanceId;
            return eisfme;
        }

        //constructor is not for public consumption.
        private OfferInstanceSubscriptionFamilyMappingEditor()
        {
        }

        #region Add or remove subscription families for the offer instance

        /// <summary> Retrieves a list of subscription families mapped to this offer instance. </summary>
        public System.Guid[] GetSubscriptionFamilies()
        {
            List<System.Guid> sf=new List<System.Guid>();

            using (WSClient ws=new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITETHENREAD_COMMANDTYPE))
            {
                ws.PartitionType=WstPartitionType.Logical;
                ws.Partition=WstCommand.AnyPartition;
                ws.CommandSql="select guid_subscription_family from t_subscription_family_mapping where guid_offer_instance='"+id+"'";

                using (WstDataReader reader=ws.Execute())
                {
                    while (reader.Read())
                    {
                        sf.Add((System.Guid)reader[0]);
                    }
                }
            }

            return sf.ToArray();
        }

        /// <summary> Removes all subscription familys mapped to this offer instance. </summary>
        public void RemoveAllSubscriptionFamilies()
        {
            UodbWS.ExecuteSQLNonQuery("delete from t_subscription_family_mapping where guid_offer_instance='"+id+"'", null);
        }

        /// <summary> Adds a subscription family mapping for the offer instance if it is not already there. </summary>
        public void AddSubscriptionFamily(System.Guid subscriptionFamilyId)
        {
            string query="if (0=(select count(guid_subscription_family) from t_subscription_family_mapping where guid_offer_instance='"+id+"' and guid_subscription_family='"+subscriptionFamilyId+"')) ";
            query+="begin insert into t_subscription_family_mapping (guid_offer_instance, guid_subscription_family) values ('"+id+"', '"+subscriptionFamilyId+"') end";
            UodbWS.ExecuteSQLNonQuery(query, null);
        }

        #endregion
    };
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\Database\Editor\ServiceTypeMappingEditor.cs ===
using xonline.common.sql.webstore;
using xonline.common.config;
using Microsoft.Webstore.WstClient;

using System.Collections.Generic;

namespace ServerTestFramework.Database
{
    /// <summary>
    /// Utility for altering or creating an individual service type mapping.
    /// </summary>
    public class ServiceTypeMappingEditor: EditorCommon
    {
        /// <summary>
        /// Service Type Mapping ID.  This is the only non-cached information we store about the service type mapping.
        /// </summary>
        public ushort Id
        {
            get { return id; }
        }

        private ushort id=0;

        #region Create an instance of ServiceTypeMappingEditor

        /// <summary>
        /// Construct from an existing service type mapping id (does not guarentee that it exists).
        /// </summary>
        public static ServiceTypeMappingEditor FromId(ushort serviceTypeMappingId)
        {
            ServiceTypeMappingEditor stm=new ServiceTypeMappingEditor();
            stm.id=serviceTypeMappingId;
            return stm;
        }

        /// <summary>
        /// Constructs from a service type mapping id, creating the service type mapping in the db if it does not already exist.
        /// </summary>
        public static ServiceTypeMappingEditor CreateOrUseExistingId(ushort serviceTypeMappingId)
        {
            ServiceTypeMappingEditor stm=new ServiceTypeMappingEditor();
            stm.id=serviceTypeMappingId;

            //insert the entry if needed
            if (!UodbWS.DoesServiceTypeMappingExist(serviceTypeMappingId))
            {
                UodbWS.ExecuteSQLNonQuery("insert into t_service_type_mapping (si_service_type_mapping_id,   vc_friendly_name,                       ti_service_type,ti_client_type,si_country_set_id,si_privilege_set_id,si_service_set_id,si_subscription_type_set_id,dt_start,dt_end) values ("+
                                                                              (short)serviceTypeMappingId+", 'TestMapping "+serviceTypeMappingId+"', 1,              2,             null,             null,               null,             null,                       null,    null)", null);
            }

            return stm;
        }

        //constructor is not for public consumption.
        private ServiceTypeMappingEditor()
        {
        }

        #endregion

        // --
        #region Lookup or alter properties of the serviceTypeMapping

        /// <summary>
        /// Whether the serviceTypeMapping actually exists in the db.
        /// </summary>
        public override bool Exists
        {
            get
            {
                if (HasCachedEntry("exists"))
                {
                    return (bool)cache["exists"];
                }

                bool exists=id!=0 && UodbWS.DoesServiceTypeMappingExist(id);
                SetCacheEntry("exists", exists);
                return exists;
            }
        }

        /// <summary>
        /// Name of the mapping.
        /// </summary>
        public string Name
        {
            get
            {
                return GetGenericMappingProperty<string>("vc_friendly_name", "name");
            }

            set
            {
                SetGenericMappingProperty("vc_friendly_name", "name", value);
            }
        }

        /// <summary>
        /// Type of service this mapping is for (from t_service_types).
        /// </summary>
        public byte ServiceType
        {
            get
            {
                return GetGenericMappingProperty<byte>("ti_service_type", "servicetype");
            }

            set
            {
                SetGenericMappingProperty("ti_service_type", "servicetype", value);
            }
        }

        /// <summary>
        /// Type of client this mapping is for (from t_client_types).
        /// </summary>
        public byte ClientType
        {
            get
            {
                return GetGenericMappingProperty<byte>("ti_client_type", "clienttype");
            }

            set
            {
                SetGenericMappingProperty("ti_client_type", "clienttype", value);
            }
        }

        /// <summary>
        /// Set of countries that this mapping is for, or null for all.
        /// </summary>
        public System.Nullable<short> CountrySet
        {
            get
            {
                return GetGenericNullableMappingProperty<short>("si_country_set_id", "countryset");
            }

            set
            {
                SetGenericNullableMappingProperty("si_country_set_id", "countryset", value);
            }
        }

        /// <summary>
        /// Set of privileges that this mapping gets, or null for none.
        /// </summary>
        public System.Nullable<short> PrivilegeSet
        {
            get
            {
                return GetGenericNullableMappingProperty<short>("si_privilege_set_id", "privilegeset");
            }

            set
            {
                SetGenericNullableMappingProperty("si_privilege_set_id", "privilegeset", value);
            }
        }

        /// <summary>
        /// Set of services that this mapping gets, or null for none.
        /// </summary>
        public System.Nullable<short> ServiceSet
        {
            get
            {
                return GetGenericNullableMappingProperty<short>("si_service_set_id", "serviceset");
            }

            set
            {
                SetGenericNullableMappingProperty("si_service_set_id", "serviceset", value);
            }
        }

        /// <summary>
        /// Type of subscription that this mapping gets, or null for none.
        /// </summary>
        public System.Nullable<short> SubscriptionType
        {
            get
            {
                return GetGenericNullableMappingProperty<short>("si_subscription_type_set_id", "subscriptionset");
            }

            set
            {
                SetGenericNullableMappingProperty("si_subscription_type_set_id", "subscriptionset", value);
            }
        }

        /// <summary>
        /// Whether this is for a free trial (TODO: what's the difference between 0 or null here?)
        /// //TODO: This column might be removed soon.
        /// </summary>
        public System.Nullable<byte> IsFreeTrial
        {
            get
            {
                return GetGenericNullableMappingProperty<byte>("ti_is_trial", "istrial");
            }

            set
            {
                SetGenericNullableMappingProperty("ti_is_trial", "istrial", value);
            }
        }

        /// <summary>
        /// The time this mapping becomes effective (null means unbounded).
        /// </summary>
        public System.Nullable<System.DateTime> StartDate
        {
            get
            {
                return GetGenericNullableMappingProperty<System.DateTime>("dt_start", "startdate");
            }

            set
            {
                SetGenericNullableMappingProperty("dt_start", "startdate", value);
            }
        }

        /// <summary>
        /// The time this mapping is no longer effective (null means unbounded).
        /// </summary>
        public System.Nullable<System.DateTime> EndDate
        {
            get
            {
                return GetGenericNullableMappingProperty<System.DateTime>("dt_end", "enddate");
            }

            set
            {
                SetGenericNullableMappingProperty("dt_end", "enddate", value);
            }
        }

        /// <summary>
        /// Generic implementation of returning a property of a service type mapping (or cache if able).
        /// </summary>
        private TypeOfProperty GetGenericMappingProperty<TypeOfProperty>(string columnName, string cacheName)
        {
            if (HasCachedEntry(cacheName))
            {
                return (TypeOfProperty)cache[cacheName];
            }

            object ret=UodbWS.ExecuteSQLScalar("select "+columnName+" from t_service_type_mapping where si_service_type_mapping_id="+(short)id, null);
            if (ret!=null)
            {
                TypeOfProperty val=(TypeOfProperty)System.Convert.ChangeType(ret, typeof(TypeOfProperty));
                SetCacheEntry(cacheName, val);
                return val;
            }

            throw new RowDoesNotExistException("t_service_type_mapping", columnName, id.ToString());
        }

        /// <summary>
        /// Generic implementation of returning a property of a service type mapping (or cache if able), for columns that may be null.
        /// </summary>
        private System.Nullable<TypeOfProperty> GetGenericNullableMappingProperty<TypeOfProperty>(string columnName, string cacheName)
            where TypeOfProperty:struct
        {
            if (HasCachedEntry(cacheName))
            {
                return (TypeOfProperty)cache[cacheName];
            }

            object ret=UodbWS.ExecuteSQLScalar("select "+columnName+" from t_service_type_mapping where si_service_type_mapping_id="+(short)id, null);
            if (ret!=null)
            {
                if (ret==System.DBNull.Value)
                {
                    return null;
                }

                TypeOfProperty val=(TypeOfProperty)System.Convert.ChangeType(ret, typeof(TypeOfProperty));
                SetCacheEntry(cacheName, val);
                return val;
            }

            throw new RowDoesNotExistException("t_service_type_mapping", columnName, id.ToString());
        }

        /// <summary>
        /// Generic implementation of setting a property of a service type mapping.  The value must be convertible to a string in a way that SQL understands.
        /// </summary>
        private void SetGenericMappingProperty<TypeOfProperty>(string columnName, string cacheName, TypeOfProperty value)
        {
            UodbWS.ExecuteSQLNonQuery("update t_service_type_mapping set "+columnName+"='"+EscapeString(value.ToString())+"' where si_service_type_mapping_id="+(short)id, null);
            SetCacheEntry(cacheName, value);
        }

        /// <summary>
        /// Generic implementation of setting a property of a service type mapping for columns that may be null.  The value must be convertible to a string in a way that SQL understands, or null.
        /// </summary>
        private void SetGenericNullableMappingProperty<TypeOfProperty>(string columnName, string cacheName, System.Nullable<TypeOfProperty> value)
            where TypeOfProperty:struct
        {
            if (value==null)
            {
                UodbWS.ExecuteSQLNonQuery("update t_service_type_mapping set "+columnName+"=null where si_service_type_mapping_id="+(short)id, null);
            }
            else
            {
                UodbWS.ExecuteSQLNonQuery("update t_service_type_mapping set "+columnName+"='"+EscapeString(value.ToString())+"' where si_service_type_mapping_id="+(short)id, null);
            }

            SetCacheEntry(cacheName, value);
        }

        #endregion

        //Short descriptive useful string that doesn't require db hits
        public override string ToString()
        {
            if (id==0)
            {
                return "Nonexistant ServiceTypeMapping (id=0)";
            }
            else
            {
                return string.Format("ServiceTypeMapping 0x{0:X}", id);
            }
        }

        //Long string containing every field of the serviceTypeMapping.  This call can be expensive, as it may make db hits.
        public string FullDescription
        {
            get
            {
                if (!Exists)
                {
                    return string.Format("Nonexistant ServiceTypeMapping 0x{0:X}", id);
                }
                else
                {
                    return ToString();
                    //TODO:
                }
            }
        }
    };
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLive\Database\Editor\UserEditor.cs ===
using xonline.common.sql.webstore;
using xonline.common.service;
using xonline.common.config;
using xonline.common.utilities;

using Microsoft.Webstore.WstClient;

using System;
using System.Collections.Generic;

using ServerTestFramework.Utilities;

namespace ServerTestFramework.Database
{
    /// <summary>
    /// Type of user to create.
    /// </summary>
    public enum UserCreationType
    {
        Xbox1,
        Xbox360
    }

    /// <summary>
    /// Utility for altering or creating users directly in the database.
    /// By default gold users are created; you can alter their subscriptions afterwards to change that.
    /// </summary>
    public class UserEditor: EditorCommon
    {
        /// <summary>
        /// Passport User ID.  This is the only non-cached information we store about the user.
        /// </summary>
        public ulong Puid
        {
            get { return puid; }
        }

        private ulong puid=0;

        // --
        #region Create an instance of UserEditor

        /// <summary>
        /// Construct from a puid.
        /// </summary>
        public static UserEditor FromPuid(ulong userPuid)
        {
            UserEditor user=new UserEditor();
            user.puid=userPuid;
            return user;
        }

        /// <summary>
        /// Construct from a passport puid.
        /// </summary>
        public static UserEditor FromPassportPuid(long userPassportPuid)
        {
            UserEditor user = new UserEditor();
            ulong xuid;            
            UodbWS.GetUserByPassport((ulong)userPassportPuid, out xuid);
            user.puid = xuid;            
            return user;
        }

        /// <summary>
        /// Construct from a gamertag.
        /// </summary>
        public static UserEditor FromGamerTag(string userGamerTag)
        {
            UserEditor user=new UserEditor();
            user.puid=UodbWS.DoesUserExist(userGamerTag.ToLower());
            return user;
        }

        /// <summary>
        /// Creates a new xbox360 user with a random name.
        /// </summary>
        public static UserEditor CreateNew()
        {
            return CreateNew(UserCreationType.Xbox360);
        }

        /// <summary>
        /// Creates a new user with a random name.
        /// </summary>
        public static UserEditor CreateNew(UserCreationType type)
        {
            return CreateOrUseExistingGamerTag(GenerateRandomGamertag(), type);
        }

        /// <summary>
        /// Creates a new xbox360 user or uses an exsting user with a specific name.
        /// </summary>
        public static UserEditor CreateOrUseExistingGamerTag(string userGamerTag)
        {
            return CreateOrUseExistingGamerTag(userGamerTag, UserCreationType.Xbox360);
        }

        /// <summary>
        /// Creates a new user or uses an existing user with a specific name.
        /// </summary>
        public static UserEditor CreateOrUseExistingGamerTag (string userGamerTag, UserCreationType userTypeIfCreating)
        {
            return CreateOrUseExistingGamerTag(userGamerTag, userTypeIfCreating, 0);
        }

        /// <summary>
        /// Allocate a new user puid.
        /// </summary>
        public static ulong AllocatePuid ()
        {
            Npdb npdb = new Npdb();
            npdb.ConnectToServer();
            ulong newPuid = npdb.AllocatePuids(0, 1, null);
            npdb.Close();

            return newPuid;
        }

        /// <summary>
        /// Creates a new user or uses an existing user with a specific name.
        /// </summary>
        public static UserEditor CreateOrUseExistingGamerTag (string userGamerTag, UserCreationType userTypeIfCreating, ulong passportPuid)
        {
            return CreateOrUseExistingGamerTag(userGamerTag, userTypeIfCreating, passportPuid, 0);
        }

        /// <summary>
        /// Creates a new user or uses an existing user with a specific name.
        /// </summary>
        public static UserEditor CreateOrUseExistingGamerTag(string userGamerTag, UserCreationType userTypeIfCreating, ulong passportPuid, ulong xboxPuid)
        {
            UserEditor user=new UserEditor();
            user.puid=UodbWS.DoesUserExist(userGamerTag.ToLower());

            if (user.puid==0) //need to create it
            {
                //get a puid to use
                ulong newPuid = (xboxPuid == 0 ? AllocatePuid() : xboxPuid);

                user.puid=newPuid;

                if (passportPuid == 0)
                {
                    passportPuid = newPuid;
                }

                //make them (use kek since most people don't have crypto stuff set up correctly)
                byte []testKek=ServerTestFramework.LiveService.Auth.ServiceKeys.GetServiceKey(ServerTestFramework.LiveService.Auth.ServiceKeys.Key_KEK);
                ulong offerID;
                System.Guid offerInstanceGuid;
                System.Guid offerGuid;

                if (userTypeIfCreating==UserCreationType.Xbox360)
                {
                    offerID=0xFFFE07D18000000A; //xbox360 12 month gold
                    offerInstanceGuid=new System.Guid("8000000A-0067-4003-8000-0000FFFE07D1");
                    offerGuid=new System.Guid("8000000A-0000-4000-8000-0000FFFE07D1");

                    UodbWS.ReserveName(userGamerTag, newPuid, 0xfa00000000000000, testKek, 1, true);
                    UodbWS.CreateXeUserDirectExt(newPuid, passportPuid, 0xfa00000000000000, 103, userGamerTag, offerID, 0, offerInstanceGuid, offerGuid);
                }
                else //xbox1
                {
                    offerID=0xFFFE000080000008; //xbox1 12 month online
                    offerInstanceGuid=new System.Guid("80000018-0005-4002-8000-0000FFFE07D1"); //this is NOT a matching offer guid... but it should behave equivilently in the new subscription family system
                    offerGuid=new System.Guid("80000018-0000-4000-8000-0000FFFE07D1");

                    UodbWS.ReserveName(userGamerTag, newPuid, 0x0009000000000000, testKek, 1, true);
                    UodbWS.CreateUserDirectExt(userGamerTag, newPuid, 0x0009000000000000, offerID, 103, 0, offerInstanceGuid, offerGuid);

                    //fixup some properties to be more like "old xbox1"
                    user.CreatedDate=null;
                    //user.RemoveXenonKey();
                }
                user.LinkPassport(passportPuid);

            }

            return user;
        }

        //constructor is not for public consumption.
        private UserEditor()
        {
        }

        /// <summary>
        /// Generates a random gamertag.
        /// </summary>
        public static string GenerateRandomGamertag ()
        {
            //create a random 15 character gamertag starting with STFU
            string gamerTag = "STFU";
            gamerTag += ServerTestFramework.Core.Utilities.RandomEx.GlobalRandGen.GenerateRandomUpperAlphaNumericString(11);
            return gamerTag;
        }

        #endregion

        // --
        #region Lookup or alter properties of the user

        /// <summary>
        /// Whether the user actually exists in the db.
        /// </summary>
        public override bool Exists
        {
            get
            {
                if (HasCachedEntry("exists"))
                {
                    return (bool)cache["exists"];
                }

                bool exists=puid!=0 && (puid==UodbWS.DoesUserExist(puid));
                SetCacheEntry("exists", exists);
                return exists;
            }
        }

        /// <summary>
        /// Hash bucket the user lives in.
        /// </summary>
        public short HashBucket
        {
            get
            {
                return GetGenericUserProperty<short>("t_users", "si_hash_bucket", "hashbucket");
            }
        }

        /// <summary>
        /// Gamertag.
        /// </summary>
        public string Gamertag
        {
            get
            {
                return GetGenericUserProperty<string>("t_users", "vc_gamertag", "gamertag");
            }

            //TODO: Implementing set for gamertag may be non-trivial, as it may involve moving rows between partitions.
            //set {}
        }

        /// <summary>
        /// User's owner's puid.
        /// </summary>
        public long OwnerPuid
        {
            get
            {
                return GetGenericUserProperty<long>("t_users", "bi_owner_puid", "userowner");
            }

            set
            {
                SetGenericUserProperty("t_users", "bi_owner_puid", "userowner", value);
            }
        }

        /// <summary>
        /// Machine puid user was created on.
        /// </summary>
        public long MachinePuid
        {
            get
            {
                return GetGenericUserProperty<long>("t_users", "bi_machine_puid", "machinepuid");
            }

            set
            {
                SetGenericUserProperty("t_users", "bi_machine_puid", "machinepuid", value);
            }
        }

        /// <summary>
        /// User's offline xuid.
        /// </summary>
        public long OfflineXuid
        {
            get
            {
                return GetGenericUserProperty<long>("t_users", "bi_offline_xuid", "offlinexuid");
            }

            set
            {
                SetGenericUserProperty("t_users", "bi_offline_xuid", "offlinexuid", value);
            }
        }

        /// <summary>
        /// Date of birth.
        /// </summary>
        public System.DateTime Birthdate
        {
            get
            {
                return GetGenericUserProperty<System.DateTime>("t_users", "dt_birthdate", "birthdate");
            }

            set
            {
                SetGenericUserProperty("t_users", "dt_birthdate", "birthdate", value);
            }
        }

        /// <summary>
        /// Country Id.
        /// </summary>
        public byte CountryId
        {
            get
            {
                return GetGenericUserProperty<byte>("t_users", "ti_country_id", "countryid");
            }

            set
            {
                SetGenericUserProperty("t_users", "ti_country_id", "countryid", value);
            }
        }

        /// <summary>
        /// Language Id.
        /// </summary>
        public int LanguageId
        {
            get
            {
                return GetGenericUserProperty<int>("t_users", "i_language_id", "languageid");
            }

            set
            {
                SetGenericUserProperty("t_users", "i_language_id", "languageid", value);
            }
        }

        /// <summary>
        /// Culture Id.
        /// </summary>
        public int CultureId
        {
            get
            {
                return GetGenericUserProperty<int>("t_users", "i_culture_id", "cultureid");
            }

            set
            {
                SetGenericUserProperty("t_users", "i_culture_id", "cultureid", value);
            }
        }

        /// <summary>
        /// Extra kdc ticket flags for the user.  Supposedly not currently used.
        /// </summary>
        public short ExtraTicketFlags
        {
            get
            {
                return GetGenericUserProperty<short>("t_users", "si_ticket_flags", "extraticketflags");
            }

            set
            {
                SetGenericUserProperty("t_users", "si_ticket_flags", "extraticketflags", value);
            }
        }

        /// <summary>
        /// If the current date is before this date, the user is considered banned.
        /// </summary>
        public System.DateTime BannedUntilDate
        {
            get
            {
                return GetGenericUserProperty<System.DateTime>("t_users", "dt_acct_resume_date", "banneduntildate"); //TODO: will we switch to using the per_service data?
                //return GetGenericUserProperty<System.DateTime>("t_user_per_service_type_data", "dt_suspended_until", "banneduntildate");
            }

            set
            {
                SetGenericUserProperty("t_users", "dt_acct_resume_date", "banneduntildate", value); //TODO: will we switch to using the per_service data?
                //SetGenericUserProperty("t_user_per_service_type_data", "dt_suspended_until", "banneduntildate", value);
            }
        }

        /// <summary>
        /// If the current date is before this date, the user is considered banned (per service).
        /// </summary>
        /// <remarks>
        /// This won't work properly if the user has multiple per service entries.
        /// Cross that bridge when its needed though.
        /// </remarks>
        public System.DateTime PerServiceBannedUntilDate
        {
            get
            {
                return GetGenericUserProperty<System.DateTime>("t_user_per_service_type_data", "dt_suspended_until", "perservicebanneduntildate");
            }

            set
            {
                SetGenericUserProperty("t_user_per_service_type_data", "dt_suspended_until", "perservicebanneduntildate", value);
            }
        }

        /// <summary>
        /// If the current date is before this date, the user is not allowed to use voice communications.
        /// </summary>
        public System.DateTime VoiceBannedUntilDate
        {
            get
            {
                return GetGenericUserProperty<System.DateTime>("t_users", "dt_voice_resume_date", "voicebanneduntildate");
            }

            set
            {
                SetGenericUserProperty("t_users", "dt_voice_resume_date", "voicebanneduntildate", value);
            }
        }

        /// <summary>
        /// Connects a user to Live using a machine puid.
        /// </summary>
        /// <param name="userPuid"></param>
        /// <param name="machinePuid"></param>
        /// <param name="lastSeen">Last time this console was seen.  </param>
        public void ConnectToLive(ulong machinePuid, DateTime lastSeen)
        {
            using (WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITETHENREAD_COMMANDTYPE))
            {
                int hash = ws.SetHashVal(Puid);
                ws.Command.CommandType = System.Data.CommandType.Text;
                ws.PartitionType = WstPartitionType.Logical;
                
                string query = QueryGenerator.GenerateUpdateOrInsert("t_user_machine_history",
                                                                  new string[]{"bi_user_puid", "bi_machine_puid", "d_first_seen",    "d_last_seen", "i_days_seen", "dt_change_datetime", "si_hash_bucket", /*"ti_console_trust_level", "bi_owner_label_puid", "i_user_pin", "dt_user_pin_expiration", */"vc_ip_address"},
                                                                  new object[]{Puid,           machinePuid,       DateTime.Now.Date, lastSeen     ,  1,             DateTime.Now,         hash,            /*4,                        0,                     0,            DateTime.Now.AddYears(1),*/           null},
                                                                  new string[]{"bi_user_puid", "bi_machine_puid"});

                ws.ExecuteScalar(query);
            }
        }

        /// <summary>
        /// Whether the user is required to change their name on the next login.
        /// </summary>
        public byte NameChangeRequired
        {
            get
            {
                return GetGenericUserProperty<byte>("t_users", "ti_name_change_required", "namechangerequired");
            }

            set
            {
                SetGenericUserProperty("t_users", "ti_name_change_required", "namechangerequired", value);
            }
        }

        /// <summary>
        /// Whether the user's WLID is invalid and user must be prompted to change WLID at logon.
        /// </summary>
        public byte OwnerWLIDInvalid
        {
            get
            {
                return GetGenericUserProperty<byte>("t_users", "ti_invalid_owner_passport", "ownerwlidinvalid");
            }

            set
            {
                SetGenericUserProperty("t_users", "ti_invalid_owner_passport", "ownerwlidinvalid", value);
            }
        }

        /// <summary>
        /// Whether the user's owner WLID is invalid and user must be prompted to change WLID at logon.
        /// </summary>
        public byte UserWLIDInvalid
        {
            get
            {
                return GetGenericUserProperty<byte>("t_users", "ti_invalid_user_passport", "userwlidinvalid");
            }

            set
            {
                SetGenericUserProperty("t_users", "ti_invalid_user_passport", "userwlidinvalid", value);
            }
        }
        
        /// <summary>
        /// Date the user was created.  Users created on an older version of the service may have null in this field.
        /// </summary>
        public System.Nullable<System.DateTime> CreatedDate
        {
            get
            {
                return GetGenericNullableUserProperty<System.DateTime>("t_users", "dt_created", "createddate");
            }

            set
            {
                SetGenericNullableUserProperty("t_users", "dt_created", "createddate", value);
            }
        }

        /// <summary>
        /// Type of account the user was originally created as (0=Xbox1, 1=Xbox.com, 2=Xbox 360)
        /// </summary>
        public byte CreatedAccountType
        {
            get
            {
                return GetGenericUserProperty<byte>("t_users", "ti_created_account_type", "createdaccounttype");
            }

            set
            {
                SetGenericUserProperty("t_users", "ti_created_account_type", "createdaccounttype", value);
            }
        }

        /// <summary>
        /// Current type of the account (0=Xbox1, 1=Xbox.com, 2=Xbox 360)
        /// </summary>
        public byte CurrentAccountType
        {
            get
            {
                return GetGenericUserProperty<byte>("t_users", "ti_account_type", "accounttype");
            }

            set
            {
                SetGenericUserProperty("t_users", "ti_account_type", "accounttype", value);
            }
        }

        /// <summary>
        /// Date the account key was last reset.
        /// </summary>
        public System.DateTime ResetDate
        {
            get
            {
                return GetGenericUserProperty<System.DateTime>("t_users", "dt_reset_date", "resetdate");
            }

            set
            {
                SetGenericUserProperty("t_users", "dt_reset_date", "resetdate", value);
            }
        }

        /// <summary>
        /// The date the user last accepted the terms of service.
        /// </summary>
        public System.DateTime AcceptedTOSDate
        {
            get
            {
                //return GetGenericUserProperty<System.DateTime>("t_users", "dt_accepted_tos", "accepttosdate"); //TODO: the t_users entry is going to be removed some day?
                return GetGenericUserProperty<System.DateTime>("t_user_per_service_type_data", "dt_accepted_tos", "accepttosdate");
            }

            set
            {
                //SetGenericUserProperty("t_users", "dt_accepted_tos", "accepttosdate", value); //TODO: the t_users entry is going to be removed some day?
                SetGenericUserProperty("t_user_per_service_type_data", "dt_accepted_tos", "accepttosdate", value);
            }
        }

        /// <summary>
        /// The date that the user was provisioned.
        /// </summary>
        public System.DateTime ProvisionedDate
        {
            get
            {
                return GetGenericUserProperty<System.DateTime>("t_user_per_service_type_data", "dt_provisioned", "provisioneddate");
            }

            set
            {
                SetGenericUserProperty("t_user_per_service_type_data", "dt_provisioned", "provisioneddate", value);
            }
        }

        /// <summary>
        /// Billing account status.
        /// </summary>
        public int BillingAccountStatus
        {
            get
            {
                return GetGenericUserProperty<int>("t_users", "i_billing_account_status", "billingstatus");
            }

            set
            {
                SetGenericUserProperty("t_users", "i_billing_account_status", "billingstatus", value);
            }
        }

        /// <summary>
        /// Date that the user migrated from xbox1 to xbox360.
        /// </summary>
        public System.Nullable<System.DateTime> XenonMigrationDate
        {
            get
            {
                return GetGenericNullableUserProperty<System.DateTime>("t_users", "dt_xenon_migration", "xenonmigrationdate");
            }

            set
            {
                SetGenericNullableUserProperty("t_users", "dt_xenon_migration", "xenonmigrationdate", value);
            }
        }

        /// <summary>
        /// Part of parental controls.  Whether the user is allowed to play xbox1 games online.
        /// </summary>
        public byte AllowXbox1Login
        {
            get
            {
                return GetGenericUserProperty<byte>("t_users", "f_allow_xbox1_logon", "allowxbox1login");
            }

            set
            {
                SetGenericUserProperty("t_users", "f_allow_xbox1_logon", "allowxbox1login", value);
            }
        }

        /// <summary>
        /// Part of parental controls.  (0=open, 1=medium, 2=restricted)
        /// </summary>
        public int ParentalControlGroup
        {
            get
            {
                return GetGenericUserProperty<int>("t_users", "i_parental_control_group_id", "parentalcontrolgroup");
            }

            set
            {
                SetGenericUserProperty("t_users", "i_parental_control_group_id", "parentalcontrolgroup", value);
            }
        }

        /// <summary>
        /// User's passport puid.
        /// </summary>
        public long UserPassportPuid
        {
            get
            {
                return GetGenericUserProperty<long>("t_users", "bi_user_passport_puid", "userpassport");
            }

            set
            {
                SetGenericUserProperty("t_users", "bi_user_passport_puid", "userpassport", value);
            }
        }

        /// <summary>
        /// Owner's passport puid (compared against the user's to determine if they are an adult).
        /// </summary>
        public long OwnerPassportPuid
        {
            get
            {
                return GetGenericUserProperty<long>("t_users", "bi_owner_passport_puid", "ownerpassport");
            }

            set
            {
                SetGenericUserProperty("t_users", "bi_owner_passport_puid", "ownerpassport", value);
            }
        }

        /// <summary>
        /// Users Key version from t_xenon_user_keys.
        /// </summary>
        public int XenonEncKeyVersion
        {
            get
            {
                return GetGenericGamerTagProperty<int>("t_xenon_user_keys", "i_key_enc_key_version", "xenonenckeyversion");
            }
            set
            {
                SetGenericGamerTagProperty("t_xenon_user_keys", "i_key_enc_key_version", "xenonenckeyversion", value);
            }
        }

        /// <summary>
        /// Users Key version from t_xenon_user_keys.
        /// </summary>
        public int XenonKeyVersion
        {
            get
            {
                return GetGenericGamerTagProperty<int>("t_xenon_user_keys", "i_key_version", "xenonkeyversion");
            }
            set
            {
                SetGenericGamerTagProperty("t_xenon_user_keys", "i_key_version", "xenonkeyversion", value);
            }
        }

        /// <summary>
        /// Users IV from t_xenon_user_keys.
        /// </summary>
        public byte[] XenonIv
        {
            get
            {
                return GetGenericGamerTagProperty<byte[]>("t_xenon_user_keys", "bin_iv", "xenoniv");
            }
            set
            {
                SetByteGamerTagProperty("t_xenon_user_keys", "bin_iv", "xenoniv", value);
            }
        }

        /// <summary>
        /// Users Encrypted Key from t_xenon_user_keys.
        /// </summary>
        public byte[] XenonEncKey
        {
            get
            {
                return GetGenericGamerTagProperty<byte[]>("t_xenon_user_keys", "bin_key", "xenonenckey");
            }
            set
            {
                SetByteGamerTagProperty("t_xenon_user_keys", "bin_key", "xenonenckey", value);
            }
        }

        /// <summary>
        /// Users PPA2 data from t_xenon_user_keys.
        /// </summary>
        public byte[] XenonPpa2
        {
            get
            {
                return GetGenericGamerTagProperty<byte[]>("t_xenon_user_keys", "bin_ppa2", "xenonppa2");

            }
            set
            {
                //UodbWS.ExecuteSQLNonQuery("update t_xenon_user_keys set bin_ppa2=0x" + Hexer.tohex(value) + " where vc_gamertag='" + EscapeString(Gamertag) + "'", Gamertag);
                SetByteGamerTagProperty("t_xenon_user_keys", "bin_ppa2", "xenonppa2", value);
            }

        }

        /// <summary>
        /// Users PPA2 data from t_xenon_user_keys.
        /// </summary>
        public byte[] XenonSppa1
        {
            get
            {
                return GetGenericGamerTagProperty<byte[]>("t_xenon_user_keys", "bin_sppa1", "xenonsppa1");
            }
            set
            {
                SetByteGamerTagProperty("t_xenon_user_keys", "bin_sppa1", "xenonsppa1", value);
            }
        }

        /// <summary>
        /// Users Hash Bucket data from t_xenon_user_keys.
        /// </summary>
        public short XenonHashBucket
        {
            get
            {
                return GetGenericGamerTagProperty<short>("t_xenon_user_keys", "si_hash_bucket", "xenonhashbucked");
            }
        }

        /// <summary>
        /// Users Hash Bucket data from t_xenon_user_keys.
        /// </summary>
        public DateTime XenonLastChanged
        {
            get
            {
                return GetGenericGamerTagProperty<DateTime>("t_xenon_user_keys", "dt_Change_datetime", "xenondatetimechange");
            }
        }

        /// <summary>
        /// User's xenon key, decrypted with the environment's kek.
        /// </summary>
        public byte[] XenonKey
        {
            get
            {
                return Ppa.DecryptKeyWithKek(XenonIv, XenonEncKey);
            }
        }

        /// <summary>
        /// Users Key version from t_user_keys.
        /// </summary>
        public int XboxEncKeyVersion
        {
            get
            {
                return GetGenericGamerTagProperty<int>("t_user_keys", "i_key_enc_key_version", "xboxenckeyversion");
            }
            set
            {
                SetGenericGamerTagProperty("t_user_keys", "i_key_enc_key_version", "xboxenckeyversion", value);
            }
        }

        /// <summary>
        /// Users Key version from t_user_keys.
        /// </summary>
        public int XboxKeyVersion
        {
            get
            {
                return GetGenericGamerTagProperty<int>("t_user_keys", "i_key_version", "xboxkeyversion");
            }
            set
            {
                SetGenericGamerTagProperty("t_user_keys", "i_key_version", "xboxkeyversion", value);
            }
        }

        /// <summary>
        /// Users IV from t_user_keys.
        /// </summary>
        public byte[] XboxIv
        {
            get
            {
                return GetGenericGamerTagProperty<byte[]>("t_user_keys", "bin_iv", "xboxiv");
            }
            set
            {
                SetByteGamerTagProperty("t_user_keys", "bin_iv", "xboxiv", value);
            }
        }

        /// <summary>
        /// Users Encrypted Key from t_user_keys.
        /// </summary>
        public byte[] XboxEncKey
        {
            get
            {
                return GetGenericGamerTagProperty<byte[]>("t_user_keys", "bin_key", "xboxenckey");
            }
            set
            {
                SetByteGamerTagProperty("t_user_keys", "bin_key", "xboxenckey", value);
            }
        }

        /// <summary>
        /// Users PPA2 data from t_user_keys.
        /// </summary>
        public byte[] XboxPpa2
        {
            get
            {
                return GetGenericGamerTagProperty<byte[]>("t_user_keys", "bin_ppa2", "xboxppa2");

            }
            set
            {
                SetByteGamerTagProperty("t_user_keys", "bin_ppa2", "xboxppa2", value);
            }

        }

        /// <summary>
        /// Users PPA2 data from t_user_keys.
        /// </summary>
        public byte[] XboxSppa1
        {
            get
            {
                return GetGenericGamerTagProperty<byte[]>("t_user_keys", "bin_sppa1", "xboxsppa1");
            }
            set
            {
                SetByteGamerTagProperty("t_user_keys", "bin_sppa1", "xboxsppa1", value);
            }
        }

        /// <summary>
        /// Users Hash Bucket data from t_user_keys.
        /// </summary>
        public short XboxHashBucket
        {
            get
            {
                return GetGenericGamerTagProperty<short>("t_user_keys", "si_hash_bucket", "xboxhashbucked");
            }
        }

        /// <summary>
        /// Users Hash Bucket data from t_user_keys.
        /// </summary>
        public DateTime XboxLastChanged
        {
            get
            {
                return GetGenericGamerTagProperty<DateTime>("t_user_keys", "dt_Change_datetime", "xboxdatetimechange");
            }
        }

        /// <summary>
        /// User's xbox1 key, decrypted with the environment's kek.
        /// </summary>
        public byte[] XboxKey
        {
            get
            {
                return Ppa.DecryptKeyWithKek(XboxIv, XboxEncKey);
            }
        }

        /// <summary>
        /// Generic implementation of returning a property from a table hashed on puid (or cache if able).
        /// </summary>
        private TypeOfProperty GetGenericUserProperty<TypeOfProperty>(string tableName, string columnName, string cacheName)
        {
            if (HasCachedEntry(cacheName))
            {
                return (TypeOfProperty)cache[cacheName];
            }

            object ret=UodbWS.ExecuteSQLScalar("select "+columnName+" from "+tableName+" where bi_user_puid="+(long)puid, puid);
            if (ret!=null)
            {
                TypeOfProperty val=(TypeOfProperty)System.Convert.ChangeType(ret, typeof(TypeOfProperty));
                SetCacheEntry(cacheName, val);
                return val;
            }

            throw new RowDoesNotExistException(tableName, "bi_user_puid", puid.ToString());
        }

        /// <summary>
        /// Generic implementation of returning a property from a table hashed on GamerTag (or cache if able).
        /// </summary>
        private TypeOfProperty GetGenericGamerTagProperty<TypeOfProperty>(string tableName, string columnName, string cacheName)
        {
            if (HasCachedEntry(cacheName))
            {
                return (TypeOfProperty)cache[cacheName];
            }

            object ret = UodbWS.ExecuteSQLScalar("select " + columnName + " from " + tableName + " where vc_gamertag='" + EscapeString(Gamertag) + "'", Gamertag);
            if (ret != null)
            {
                TypeOfProperty val = (TypeOfProperty)System.Convert.ChangeType(ret, typeof(TypeOfProperty));
                SetCacheEntry(cacheName, val);
                return val;
            }

            throw new RowDoesNotExistException(tableName, "vc_gamertag", Gamertag);
        }

        /// <summary>
        /// Generic implementation of returning a property from a table hashed on GamerTag (or cache if able), for columns that may be null.
        /// </summary>
        private System.Nullable<TypeOfProperty> GetGenericNullableGamerTagProperty<TypeOfProperty>(string tableName, string columnName, string cacheName)
            where TypeOfProperty : struct
        {
            if (HasCachedEntry(cacheName))
            {
                return (TypeOfProperty)cache[cacheName];
            }
            object ret = UodbWS.ExecuteSQLScalar("select " + columnName + " from " + tableName + " where vc_gamertag='" + EscapeString(Gamertag) + "'", Gamertag);
            if (ret != null)
            {
                if (ret == System.DBNull.Value)
                {
                    return null;
                }

                TypeOfProperty val = (TypeOfProperty)System.Convert.ChangeType(ret, typeof(TypeOfProperty));
                SetCacheEntry(cacheName, val);
                return val;
            }

            throw new RowDoesNotExistException(tableName, columnName, Gamertag);
        }

        /// <summary>
        /// Generic implementation of returning a property from a table hashed on puid (or cache if able), for columns that may be null.
        /// </summary>
        private System.Nullable<TypeOfProperty> GetGenericNullableUserProperty<TypeOfProperty>(string tableName, string columnName, string cacheName)
            where TypeOfProperty:struct
        {
            if (HasCachedEntry(cacheName))
            {
                return (TypeOfProperty)cache[cacheName];
            }

            object ret=UodbWS.ExecuteSQLScalar("select "+columnName+" from "+tableName+" where bi_user_puid="+(long)puid, puid);
            if (ret!=null)
            {
                if (ret==System.DBNull.Value)
                {
                    return null;
                }

                TypeOfProperty val=(TypeOfProperty)System.Convert.ChangeType(ret, typeof(TypeOfProperty));
                SetCacheEntry(cacheName, val);
                return val;
            }

            throw new RowDoesNotExistException(tableName, "bi_user_puid", puid.ToString());
        }

        /// <summary>
        /// Generic implementation of setting a property in a table hashed on GamerTag.  The value must be convertible to a string in a way that SQL understands.
        /// </summary>
        private void SetByteGamerTagProperty(string tableName, string columnName, string cacheName, byte[] value)
        {
            UodbWS.ExecuteSQLNonQuery("update " + tableName + " set " + columnName + "=0x" + Hexer.tohex(value) + " where vc_gamertag='" + EscapeString(Gamertag) + "'", Gamertag);
            SetCacheEntry(cacheName, value);
        }

        /// <summary>
        /// Generic implementation of setting a property in a table hashed on GamerTag for columns that may be null.  The value must be convertible to a string in a way that SQL understands, or null.
        /// </summary>
        private void SetByteNullableGamerTagProperty(string tableName, string columnName, string cacheName, byte[] value)
        {
            if (value == null)
            {
                UodbWS.ExecuteSQLNonQuery("update " + tableName + " set " + columnName + "=null where vc_gamertag='" + EscapeString(Gamertag) + "'", Gamertag);
            }
            else
            {
                UodbWS.ExecuteSQLNonQuery("update " + tableName + " set " + columnName + "=0x" + Hexer.tohex(value) + " where vc_gamertag='" + EscapeString(Gamertag) + "'", Gamertag);
            }

            SetCacheEntry(cacheName, value);
        }

        /// <summary>
        /// Generic implementation of setting a property in a table hashed on GamerTag.  The value must be convertible to a string in a way that SQL understands.
        /// </summary>
        private void SetGenericGamerTagProperty<TypeOfProperty>(string tableName, string columnName, string cacheName, TypeOfProperty value)
        {
            UodbWS.ExecuteSQLNonQuery("update " + tableName + " set " + columnName + "='" + EscapeString(value.ToString()) + "' where vc_gamertag='" + EscapeString(Gamertag) + "'", Gamertag);
            SetCacheEntry(cacheName, value);
        }

        /// <summary>
        /// Generic implementation of setting a property in a table hashed on GamerTag for columns that may be null.  The value must be convertible to a string in a way that SQL understands, or null.
        /// </summary>
        private void SetGenericNullableGamerTagProperty<TypeOfProperty>(string tableName, string columnName, string cacheName, System.Nullable<TypeOfProperty> value)
            where TypeOfProperty : struct
        {
            if (value == null)
            {
                UodbWS.ExecuteSQLNonQuery("update " + tableName + " set " + columnName + "=null where vc_gamertag='" + EscapeString(Gamertag) + "'", Gamertag);
            }
            else
            {
                UodbWS.ExecuteSQLNonQuery("update " + tableName + " set " + columnName + "='" + EscapeString(value.ToString()) + "' where vc_gamertag='" + EscapeString(Gamertag) + "'", Gamertag);
            }

            SetCacheEntry(cacheName, value);
        }

        /// <summary>
        /// Generic implementation of setting a property in a table hashed on puid.  The value must be convertible to a string in a way that SQL understands.
        /// </summary>
        private void SetGenericUserProperty<TypeOfProperty>(string tableName, string columnName, string cacheName, TypeOfProperty value)
        {
            UodbWS.ExecuteSQLNonQuery("update "+tableName+" set "+columnName+"='"+EscapeString(value.ToString())+"' where bi_user_puid="+(long)puid, puid);
            SetCacheEntry(cacheName, value);
        }

        /// <summary>
        /// Generic implementation of setting a property in a table hashed on puid for columns that may be null.  The value must be convertible to a string in a way that SQL understands, or null.
        /// </summary>
        private void SetGenericNullableUserProperty<TypeOfProperty>(string tableName, string columnName, string cacheName, System.Nullable<TypeOfProperty> value)
            where TypeOfProperty:struct
        {
            if (value==null)
            {
                UodbWS.ExecuteSQLNonQuery("update "+tableName+" set "+columnName+"=null where bi_user_puid="+(long)puid, puid);
            }
            else
            {
                UodbWS.ExecuteSQLNonQuery("update "+tableName+" set "+columnName+"='"+EscapeString(value.ToString())+"' where bi_user_puid="+(long)puid, puid);
            }

            SetCacheEntry(cacheName, value);
        }

        #endregion

        private static int ComputeAge(DateTime birthdate)
        {
            DateTime now = DateTime.UtcNow;
            int age = now.Year - birthdate.Year;

            if ((birthdate.Month > now.Month) ||
                (birthdate.Month == now.Month) &&
                (birthdate.Day > now.Day))
            {
                age--;
            }

            return age;
        }

        public int AgeGroupId
        {
            get
            {
                int age = ComputeAge(Birthdate);

                MinAge minAge = CountryDictionary.MinAge(CountryId);

                if (age < minAge.User)
                {
                    return XOn.PARENTAL_CONTROL_GROUP_RESTRICTED;
                }
                else if (age < minAge.Billing)
                {
                    return XOn.PARENTAL_CONTROL_GROUP_MEDIUM;
                }
                else
                {
                    return XOn.PARENTAL_CONTROL_GROUP_OPEN;
                }
            }
        }

        //Short descriptive useful string that doesn't require db hits
        public override string ToString()
        {
            if (puid==0)
            {
                return "Nonexistant User (puid=0)";
            }
            else
            {
                return string.Format("User 0x{0:X}", puid);
            }
        }

        //Long string containing every field of the user.  This call is expensive, as it makes many db hits.
        public string FullDescription
        {
            get
            {
                if (puid==0)
                {
                    return "Nonexistant User (puid=0)";
                }
                else
                {
                    if (!Exists)
                    {
                        return string.Format("Nonexistant User (puid=0x{0:X})", puid);
                    }
                    else
                    {
                        string ret;
                        ret=string.Format("User Puid=0x{0:X}", puid);
                        ret+="\nGamertag="+Gamertag;
                        ret+="\nBirthdate="+Birthdate;
                        ret+="\nCountryId="+CountryId;
                        ret+="\nLanguageId="+LanguageId;
                        ret+="\nCultureId="+CultureId;
                        ret+="\nBannedUntilDate="+BannedUntilDate;
                        ret+="\nExtraTicketFlags="+ExtraTicketFlags;
                        ret+="\nVoiceBannedUntilDate="+VoiceBannedUntilDate;
                        ret+="\nNameChangeRequired="+NameChangeRequired;
                        ret+="\nCreatedDate="+CreatedDate;
                        ret+="\nCreatedAccountType="+CreatedAccountType;
                        ret+="\nCurrentAccountType="+CurrentAccountType;
                        ret+="\nResetDate="+ResetDate;
                        ret+="\nXenonMigrationDate="+XenonMigrationDate;
                        ret+="\nAllowXbox1Login="+AllowXbox1Login;
                        ret+="\nParentalControlGroup="+ParentalControlGroup;
                        ret+="\nPrivilege Grants: "+StringUtils.MakeCommaSeparatedList(GetAllPrivilegeGrants());
                        ret+="\nPrivilige Restrictions: "+StringUtils.MakeCommaSeparatedList(GetAllPrivilegeRestrictions());
                        return ret;
                    }
                }
            }
        }

        // --
        #region Add or remove "assets" for the user

        /// <summary>
        /// Completely removes a user from UODB.
        /// </summary>
        public void CompletelyRemoveUser()
        {
            const int timeoutInS=120; //2 minutes since some of these make take an abnormal amount of time to execute

            string query="delete from t_achievements where bi_puid="+(long)puid+"\n";
            query+="delete from t_user_feedback_v1 where bi_user_puid="+(long)puid+" or bi_target_puid="+(long)puid+"\n";
            query+="delete from t_user_review where bi_user_puid="+(long)puid+" or bi_target_puid="+(long)puid+"\n";
            query+="delete from t_user_review_aggregates where bi_user_puid="+(long)puid+"\n";
            query+="delete from t_user_rating_data where bi_user_puid="+(long)puid+"\n";
            query+="delete from t_user_complaint where bi_user_puid="+(long)puid+" or bi_target_puid="+(long)puid+"\n";
            query+="delete from t_user_privilege_grants where bi_user_puid="+(long)puid+"\n";
            query+="delete from t_user_privilege_restrictions where bi_user_puid="+(long)puid+"\n";
            query+="delete from t_user_settings where bi_user_puid="+(long)puid+"\n";
            query+="delete from t_user_title_enumeration_times where bi_user_puid="+(long)puid+"\n";
            query+="delete from t_user_trust_ratings where bi_user_puid="+(long)puid+"\n";
            query+="delete from t_user_title_activations where bi_user_puid="+(long)puid+"\n";
            UodbWS.ExecuteSQLNonQuery(query, null, timeoutInS);

            query = "delete from t_user_assets where bi_user_puid=" + (long)puid + "\n";
            query +="delete from t_dmp_purchase_transactions where bi_user_puid="+(long)puid+"\n";
            query += "delete from t_user_license_pending_dmp_reporting where bi_xuid=" + (long)puid + "\n";
            query += "delete from t_user_license_transfer where bi_xuid=" + (long)puid + "\n";
            query += "delete from t_user_media_instance_license_state where bi_user_puid=" + (long)puid + "\n";
            query += "delete from t_user_offer_instance_purchases where bi_user_puid=" + (long)puid + "\n";
            UserCommercedbWS.ExecuteSQLNonQuery(query, null);

            query="delete from t_user_audit_info where bi_user_puid="+(long)puid+"\n";
            query+="delete from t_subscription_history where bi_user_puid="+(long)puid+"\n";
            query+="delete from t_subscriptions where bi_primary_puid="+(long)puid+"\n";
            query+="delete from t_user_billing_queue where bi_user_puid="+(long)puid+"\n";
          